# 三、排序和搜索算法

在本章中，我们将介绍用于排序和搜索的算法。这是一种重要的算法，可以单独使用，也可以成为更复杂的算法的基础（在本书的后半章中介绍）。本章首先介绍不同类型的排序算法。它比较了设计排序算法的各种方法的性能。然后，详细介绍了一些搜索算法。最后，本章给出了一个排序和搜索算法的实例。

在本章结束时，您将能够理解用于排序和搜索的各种算法，并理解它们的优缺点。由于搜索和排序算法是大多数更复杂算法的组成部分，因此详细了解它们将有助于您理解现代复杂算法。

以下是本章讨论的主要概念：

*   介绍排序算法
*   介绍搜索算法
*   实例

让我们先看看一些排序算法。

# 介绍排序算法

在大数据时代，在复杂数据结构中高效排序和搜索项目的能力非常重要，因为许多现代算法都需要这种能力。如本章所述，对数据进行排序和搜索的正确策略将取决于数据的大小和类型。虽然最终结果完全相同，但需要正确的排序和搜索算法才能有效地解决实际问题

本章介绍了以下排序算法：

*   气泡排序
*   合并排序
*   插入排序
*   贝壳类
*   选择排序

# 在 Python 中交换变量

在实现排序和搜索算法时，我们需要交换两个变量的值。在 Python 中，有一种交换两个变量的简单方法，如下所示：

```py
var1 = 1 
var2 = 2 
var1,var2 = var2,var1
>>> print (var1,var2)
>>> 2 1
```

让我们看看它是如何工作的：

![](img/943d98a8-6cea-43f1-b3dc-1a96ed14a074.png)

在本章的排序和搜索算法中使用了这种简单的值交换方法。

让我们从下一节中的冒泡排序算法开始。

# 气泡排序

气泡排序是用于排序的最简单、最慢的算法。它的设计方式是，当算法循环迭代时，其列表中的最高值会冒泡到顶部。由于其最坏情况的性能是 O（N<sup>2</sup>，如前所述，它应该用于较小的数据集。

# 理解冒泡排序背后的逻辑

气泡排序基于各种迭代，称为**过程**。对于大小为*N*的列表，冒泡排序将有*N*-1 次通过。让我们关注第一次迭代：通过一次。

passOne 的目标是将最高值推到列表的顶部。我们将看到列表中的最高值随着 pass one 的进行而冒泡到顶部。

气泡排序比较相邻的相邻值。如果较高位置的值高于较低索引的值，我们交换这些值。这个迭代将继续，直到我们到达列表的末尾。如下图所示：

![](img/1f24bd5d-ae99-4c23-b504-bdb9941e21d7.png)

现在让我们看看如何使用 Python 实现冒泡排序：

```py
#Pass 1 of Bubble Sort
lastElementIndex = len(list)-1 
print(0,list) 
for idx in range(lastElementIndex):                 
                    if list[idx]>list[idx+1]:                                                                             list[idx],list[idx+1]=list[idx+1],list[idx]                                         
print(idx+1,list)
```

如果我们在 Python 中实现气泡排序的 pass one，它将如下所示：

![](img/4dd07ced-d8e2-4baa-a32d-73496686b03c.png)

第一次传递完成后，最大值出现在列表的顶部。算法接下来将进入第二次传递。第二次传递的目标是将第二高的值移动到列表中第二高的位置。要做到这一点，算法将再次比较相邻的邻居值，如果它们不符合顺序，则交换它们。第二个过程将排除顶部元素，该元素由过程 1 放置在正确的位置，无需再次触摸。

完成第二步后，算法继续执行第三步，依此类推，直到列表中的所有数据点都按升序排列。该算法需要*N*-1 次传递，才能对大小为*N*的列表进行完全排序。Python 中气泡排序的完整实现如下所示：

![](img/8112422d-7d3a-4910-b2e9-f1240a431250.png)

现在让我们来看看`BubbleSort`算法的性能。

# 气泡排序的性能分析

更容易看出冒泡排序涉及两个级别的循环：

*   **外环**：也称为**通过**。例如，passone 是外循环的第一次迭代。
*   **一个内部循环**：对列表中剩余未排序的元素进行排序，直到将最高值冒泡到右侧。第一个过程将有*N*-1 个比较，第二个过程将有*N*-2 个比较，每个后续过程将减少 1 个比较。

由于两个级别的循环，最坏情况下的运行时复杂性为 O（n<sup>2</sup>。

# 插入排序

插入排序的基本思想是，在每次迭代中，我们从已有的数据结构中删除一个数据点，然后将其插入正确的位置。这就是为什么我们称之为**插入排序算法**。在第一次迭代中，我们选择两个数据点并对它们进行排序。然后，我们展开选择并选择第三个数据点，并根据其值找到其正确位置。算法将继续执行，直到所有数据点都移动到正确的位置。该过程如下图所示：

![](img/8ba25bc4-942a-4704-abbe-558b0a521f69.png)

插入排序算法可以用 Python 编码，如下所示：

```py
def InsertionSort(list):        
    for i in range(1, len(list)):             
        j = i-1             
        element_next = list[i]             

        while (list[j] > element_next) and (j >= 0):                 
            list[j+1] = list[j]                 
            j=j-1                 
        list[j+1] = element_next
    return list
```

注意，在主循环中，我们遍历所有列表。在每次迭代中，两个相邻的元素是`list[j]`（当前元素）和`list[i]`（下一个元素）。

在`list[j] > element_next`和`j >= 0`中，我们将当前元素与下一个元素进行比较。

让我们使用以下代码对数组进行排序：

![](img/f82e873e-fb1a-4e6f-a195-799328961525.png)

让我们看看插入排序算法的性能。

从算法的描述可以明显看出，如果数据结构已经排序，插入排序将执行得非常快。事实上，如果对数据结构进行排序，那么插入排序将具有线性运行时间；即 O（n）。最坏的情况是每个内部循环必须移动列表中的所有元素。如果内部循环由*i*定义，则插入排序算法的最坏情况性能如下所示：

![](img/23bd35a5-d92c-42c8-80d7-c85821d98ffb.png)

*![](img/e136b412-be8f-4725-91d1-ab716386d1b8.png)*

通过的总数如下图所示：

![](img/03f8b384-ace0-401b-986f-d9fdfca57d1f.png)

通常，插入可以用于小型数据结构。对于较大的数据结构，由于二次平均性能，不建议使用插入排序

# 合并排序

到目前为止，我们已经提出了两种排序算法：冒泡排序和插入排序。如果对数据进行部分排序，这两种方法的性能都会更好。本章介绍的第三种算法是**合并排序算法**，由约翰·冯·诺依曼于 1940 年开发。该算法的定义特征是其性能不依赖于输入数据是否排序。与 MapReduce 和其他大数据算法一样，它基于分而治之的策略。在第一个阶段，称为分割，该算法继续递归地将数据分成两部分，直到数据的大小小于定义的阈值。在第二阶段，称为**合并**，该算法继续合并和处理，直到得到最终结果。该算法的逻辑如下图所示：

![](img/bf2a1910-f8d4-4703-95e6-b68fe5a7ab3f.png)

让我们先看看合并排序算法的伪代码：

```py
mergeSort(list, start, end) 
    if(start < end) 
        midPoint = (end - start) / 2 + start           
        mergeSort(list, start, midPoint)             
        mergeSort(list, midPoint + 1, start)         
        merge(list, start, midPoint, end) 
```

我们可以看到，该算法有以下三个步骤：

1.  它将输入列表分成两个相等的部分
2.  它使用递归进行拆分，直到每个列表的长度为 1
3.  然后，它将已排序的部分合并到已排序的列表中并返回该列表

实现`MergeSort`的代码如下：

![](img/90b41c82-5962-42c7-b781-57a59557f994.png)

当前面的 Python 代码运行时，它会生成一个输出，如下所示：

![](img/ff2f2912-318f-418a-800c-331c8ad48f00.png)

请注意，代码结果位于排序列表中

# 贝壳类

气泡排序算法比较近邻，如果近邻出现故障，则进行交换。如果我们有一个部分排序的列表，冒泡排序应该提供合理的性能，因为一旦循环中不再发生元素交换，冒泡排序就会退出

但对于一个大小为*N*的完全未排序的列表，您可以认为冒泡排序必须完全迭代*N*-1 次才能对其进行完全排序。

Donald Shell 提出了 Shell sort（以他的名字命名），它质疑选择近邻进行比较和交换的重要性。

现在，让我们来理解这个概念。

在第一步中，我们使用固定间距的元素，而不是选择近邻，最终对由一对数据点组成的子列表进行排序。下图显示了这一点。在第二步中，它对包含四个数据点的子列表进行排序（参见下图）。在随后的过程中，每个子列表的数据点数量不断增加，子列表的数量不断减少，直到我们达到只有一个子列表包含所有数据点的情况。此时，我们可以假设列表已排序：

![](img/495145de-2a5c-4d41-aceb-2a95e51cc8e6.png)

在 Python 中，实现 Shell 排序算法的代码如下：

```py
def ShellSort(list):     
    distance = len(list) // 2     
    while distance > 0:         
        for i in range(distance, len(list)):             
            temp = input_list[i]             
            j = i 
# Sort the sub list for this distance 
           while j >= distance and list[j - distance] > temp: 
              list[j] = list[j - distance] 
              j = j-distance            
          list[j] = temp 
# Reduce the distance for the next element         
        distance = distance//2
    return list
```

上述代码可用于对列表进行排序，如下所示：

![](img/0749878d-e9b5-4f42-8610-19075022e645.png)

请注意，调用`ShellSort`函数会导致对输入数组进行排序。

# Shell 排序的性能分析

Shell 排序不适用于大数据。它用于中型数据集。粗略地说，它在包含多达 6000 个元素的列表中具有相当好的性能。如果数据部分顺序正确，则性能会更好。在最佳情况下，如果列表已排序，则只需通过一次*N*元素来验证顺序，产生*O（N）*的最佳情况性能

# 选择排序

正如我们在本章前面看到的，冒泡排序是最简单的排序算法之一。选择排序是对冒泡排序的改进，在冒泡排序中，我们尝试最小化算法所需的交换总数。与使用气泡排序算法的*N*-1 个过程相比，它的设计是为每个过程进行一次交换。我们在每个过程中寻找最大值并将其移向顶部，而不是在小步骤中将最大值冒泡到顶部（就像在冒泡排序中所做的那样，导致*N*-1 交换）。因此，在第一次通过后，最大值将位于顶部。第二次通过后，第二个最大值将位于顶部值的旁边。随着算法的进行，后续值将根据其值移动到正确的位置。最后一个值将在（*N*-1）<sup>第</sup>次通过后移动。因此，选择排序需要*N*-1 次通过才能对*N*项进行排序：

![](img/6e5e3334-1189-42eb-bb80-cac42d97f922.png)

Python 中选择排序的实现如下所示：

```py
def SelectionSort(list):     
    for fill_slot in range(len(list) - 1, 0, -1):         
        max_index = 0         
        for location in range(1, fill_slot + 1):             
            if list[location] > list[max_index]:                 
                max_index = location         
        list[fill_slot],list[max_index] = list[max_index],list[fill_slot]
```

执行选择排序算法时，将产生以下输出：

![](img/d9494a36-e503-48a3-ad9f-b52b30611260.png)

请注意，最终输出是排序列表。

# 选择排序算法的性能

选择排序的最坏情况性能为*O（N**<sup>2</sup>**。请注意，它最差的性能类似于冒泡排序，不应用于对较大的数据集进行排序。尽管如此，选择排序是一种比冒泡排序设计得更好的算法，其平均性能优于冒泡排序，因为交换数量减少了*

 *# 选择排序算法

选择正确的排序算法取决于当前输入数据的大小和状态。对于已排序的小输入列表，使用高级算法将给代码带来不必要的复杂性，而性能的改善微乎其微。例如，我们不需要对较小的数据集使用合并排序。气泡排序将更容易理解和实现。如果数据是部分排序的，我们可以通过使用插入排序来利用这一点。对于较大的数据集，合并排序算法是最好的。

# 搜索算法简介

高效地搜索复杂数据结构中的数据是最重要的功能之一。最简单的方法是在每个数据点中搜索所需的数据，但效率不高。但是，随着数据越来越大，我们需要设计更复杂的算法来搜索数据

本节介绍了以下搜索算法：

*   线性搜索
*   二进制搜索
*   插值搜索

让我们更详细地看一下它们。

# 线性搜索

搜索数据的最简单策略之一是简单地循环通过每个元素寻找目标。搜索每个数据点以查找匹配项，当找到匹配项时，返回结果，算法退出循环。否则，算法将继续搜索，直到到达数据的末尾。线性搜索的明显缺点是，由于其固有的穷举搜索，它的速度非常慢。其优点是数据不需要按照本章介绍的其他算法的要求进行排序。

让我们看看线性搜索的代码：

```py
def LinearSearch(list, item):     
    index = 0     
    found = False 
# Match the value with each data element     
    while index < len(list) and found is False:         
        if list[index] == item:             
            found = True         
    else:             
        index = index + 1     
  return found
```

现在让我们看看前面代码的输出：

![](img/8406c7c9-2fee-4e53-be31-6c5efcd71876.png)

请注意，如果能够成功找到数据，则运行`LinearSearch`函数将返回一个`True`值。

# 线性搜索的性能

如前所述，线性搜索是一种执行穷举搜索的简单算法。其最坏情况行为为*O（N）*。

# 二进制搜索

二进制搜索算法的先决条件是对数据进行排序。该算法迭代地将列表分为两部分，并跟踪最低和最高索引，直到找到它要查找的值：

```py
def BinarySearch(list, item): 
   first = 0 
   last = len(list)-1 
   found = False 

while first<=last and not found:         
    midpoint = (first + last)//2         
    if list[midpoint] == item:             
        found = True         
    else:             
        if item < list[midpoint]:                 
            last = midpoint-1             
        else:                 
            first = midpoint+1     
return found
```

结果如下：

![](img/4b23f9aa-ada6-4d28-841b-eea4256a3c7e.png)

请注意，如果在输入列表中找到该值，则调用`BinarySearch`函数将返回`True`。

# 二进制搜索的性能

二进制搜索之所以这样命名，是因为在每次迭代中，算法将数据分为两部分。如果数据有*N*项，则迭代最多需要 O（logN）步。这意味着该算法有一个*O（logN）*运行时。

# 插值搜索

二进制搜索是基于逻辑的，它集中在数据的中间部分。插值搜索更复杂。它使用目标值来估计元素在已排序数组中的位置。让我们试着用一个例子来理解它。假设我们要在英语词典中搜索一个单词，例如单词*river*。我们将使用此信息插入并开始搜索以*r*开头的单词。更通用的插值搜索可编程如下：

```py

def IntPolsearch(list,x ):     
    idx0 = 0     
    idxn = (len(list) - 1)     
    found = False     
    while idx0 <= idxn and x >= list[idx0] and x <= list[idxn]: 
    # Find the mid point         
         mid = idx0 +int(((float(idxn - idx0)/( list[idxn] - list[idx0])) * ( x - list[idx0]))) 
 # Compare the value at mid point with search value 
         if list[mid] == x: 
            found = True             
            return found         
    if list[mid] < x:             
            idx0 = mid + 1     
return found
```

结果如下：

![](img/bc21fe23-43bb-4852-8e42-1458f022db6a.png)

注意，在使用`IntPolsearch`之前，首先需要使用排序算法对数组进行排序。

# 插值搜索的性能

如果数据分布不均匀，插值搜索算法的性能将很差。该算法在最坏情况下的性能是*O（N）*，如果数据相当均匀，则最佳性能是 O（log（logn））

# 实际应用

在给定的数据存储库中高效、准确地搜索数据的能力对于许多实际应用程序至关重要。根据您选择的搜索算法，您可能还需要首先对数据进行排序。选择正确的排序和搜索算法将取决于数据的类型和大小，以及您试图解决的问题的性质

让我们尝试使用本章介绍的算法来解决将某个国家的移民局的新申请人与历史记录匹配的问题。当有人申请签证进入该国时，系统会尝试将申请人与现有历史记录进行匹配。如果至少找到一个匹配项，则系统会进一步计算该个人过去被批准或拒绝的次数。另一方面，如果未找到匹配项，系统会将该申请人归类为新申请人，并向其颁发新的标识符。搜索、定位、，而在历史数据中识别一个人对于系统来说至关重要。这些信息很重要，因为如果有人在过去申请过，并且已知该申请已被拒绝，那么这可能会对该个人当前的申请产生负面影响。类似地，如果已知某人的申请在过去已获得批准，此批准可能会增加该个人获得当前申请批准的机会。通常，历史数据库将有数百万行，我们需要一个设计良好的解决方案来匹配历史数据库中的新申请者。

假设数据库中的历史表如下所示：

| **个人身份证** | **申请 ID** | **名** | **姓** | **DOB** | **决定** | **决定日期** |
| 45583 | 677862 | 约翰 | 雌鹿 | 2000-09-19 | 经核准的 | 2018-08-07 |
| 54543 | 877653 | 金钟国 | Xsir | 1970-03-10 | 拒绝 | 2018-06-07 |
| 34332 | 344565 | 农业的 | 瓦卡 | 1973-02-15 | 拒绝 | 2018-05-05 |
| 45583 | 677864 | 约翰 | 雌鹿 | 2000-09-19 | 经核准的 | 2018-03-02 |
| 22331 | 344553 | 卡尔 | 种类 | 1975-01-02 | 经核准的 | 2018-04-15 |

在该表中，第一列`Personal ID`与历史数据库中的每个唯一申请者相关联。如果历史数据库中有 3000 万个独特的申请人，那么将有 3000 万个独特的个人 ID。每个个人 ID 标识历史数据库系统中的申请人。

第二栏是`Application ID`。每个应用程序 ID 标识系统中唯一的应用程序。一个人过去可能申请过不止一次。因此，这意味着在历史数据库中，我们将拥有比个人 ID 更多的唯一应用程序 ID。John Doe 只有一个个人 ID，但有两个应用程序 ID，如上表所示。

上表仅显示了历史数据集的示例。假设我们的历史数据集中有近 100 万行，其中包含过去 10 年申请者的记录。新申请者不断以平均每分钟 2 人左右的速度到达。对于每个申请人，我们需要执行以下操作：

*   为申请人颁发新的申请 ID。
*   查看历史数据库中是否与申请者匹配。
*   如果找到匹配项，请使用历史数据库中该申请人的个人 ID。我们还需要确定应用程序在历史数据库中被批准或拒绝的次数。
*   如果没有找到匹配项，那么我们需要为该个人颁发一个新的个人 ID。

假设一个新人到达时具有以下凭据：

*   `First Name`：`John`
*   `Surname`：`Doe`
*   `DOB`：`2000-09-19`

现在，我们如何设计一个能够执行高效且经济高效的搜索的应用程序？

可以设计一种在数据库中搜索新应用程序的策略，如下所示：

*   按`DOB`对历史数据库进行排序。
*   每次新人到达时，向申请人发放一个新的申请 ID。
*   获取与该出生日期匹配的所有记录。这将是主要搜索。
*   从匹配的记录中，使用名字和姓氏执行二次搜索。
*   如果找到匹配项，请使用`Personal ID`向申请人推荐。计算批准和拒绝的数量。
*   如果没有找到匹配项，则向申请人颁发新的个人 ID。

让我们尝试选择正确的算法对历史数据库进行排序。由于数据量巨大，我们可以安全地排除冒泡排序。Shell 排序将执行得更好，但前提是我们对列表进行了部分排序。因此，合并排序可能是对历史数据库进行排序的最佳选择。

当一个新的人到达时，我们需要在历史数据库中定位和搜索那个人。由于数据已经排序，可以使用插值搜索或二进制搜索。由于申请者可能分布均匀，根据`DOB`，我们可以安全地使用二进制搜索。

最初，我们基于`DOB`进行搜索，它返回一组具有相同出生日期的申请人。现在，我们需要在出生日期相同的一小部分人中找到所需的人。由于我们已经成功地将数据减少到一个小的子集，所以可以使用任何搜索算法（包括气泡排序）来搜索申请人。注意，我们在这里简化了二次搜索问题。如果找到多个匹配项，我们还需要通过聚合搜索结果来计算批准和拒绝的总数。

在现实世界中，每个人都需要在二次搜索中使用模糊搜索算法进行识别，因为名字和姓氏的拼写可能略有不同。搜索可能需要使用某种距离算法来实现模糊搜索，其中相似度高于定义阈值的数据点被认为是相同的。

# 总结

在本章中，我们介绍了一套排序和搜索算法。我们还讨论了不同排序和搜索算法的优缺点。我们量化了这些算法的性能，并学习了何时使用每种算法。

在下一章中，我们将研究动态算法。我们还将看一个设计算法的实际例子，以及页面排名算法的细节。最后，我们将研究线性规划算法。*