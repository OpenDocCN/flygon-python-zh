# 五、通过构建贪食蛇游戏学习 Curses

任何开发人员在编写游戏或应用程序时，都可能需要重复使用代码的某些部分。例如，当我们希望玩家在游戏控制台内移动时，他们会多次使用左右箭头键。因此，我们需要能够处理和处理此类事件的代码。多次编写相同的代码来处理相同的操作不支持**不要重复自己**（**DRY**原则，所以我们需要使用可以多次调用的函数来反复执行相同的操作。

为了便于实现这一点，这些函数被捆绑到称为模块的容器中。正如您在上一章中所回忆的，我们在大多数程序中都使用了模块。例如，通过使用`random`模块函数，我们能够获得特定范围内的随机数；另一方面，数学模块允许我们执行不同的数学计算。在本章中，我们将介绍另一个模块，即Curses。它将为我们提供一个可以处理 curses 库的接口，其中包含直接与 Python 终端交互的函数。这意味着我们可以制作一个简单的基于终端的游戏。

本章将介绍以下主题：

*   理解Curses
*   启动 curses 应用程序
*   带Curses的用户输入
*   用Curses做贪食蛇游戏
*   游戏测试

# 技术要求

您需要以下内容才能充分利用本章：

*   **Python****空闲**（**集成开发工具包**）
*   本书的代码资产，可在本书的 GitHub 存储库中找到：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter05](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter05)

请查看以下视频以查看代码的运行情况：

[http://bit.ly/2oG1CVO](http://bit.ly/2oG1CVO)

# 理解Curses

Curses 是一个终端控制器库，允许我们编写基于文本的应用程序。终端这个词独立于任何平台，因此Curses可以在任何操作系统上使用。有了 curses，开发人员将能够直接编写应用程序，而无需与终端交互。curses 库是一种介质，它以控制字符的形式发送命令，同时确定应该在哪个操作系统或终端上执行命令。

在 Python 中，我们有两个名为 windows curses 和 UniCourses 的库。这两个库都提供了可以设置输出终端屏幕所需外观的功能。它们使用控制序列进行更新。简言之，开发人员将设计输出窗口屏幕的外观，并调用函数以使Curses完成其工作。因此，在基于 curses 的应用程序中，我们无法获得预期的用户友好输出，因为我们只能使用 curses 库编写基于文本的应用程序。因此，任何使用Curses编写的游戏都将在终端中运行，即 Windows 的命令提示符或 Linux 的终端。

Python 的*Curses*库将允许我们编写基于文本的用户界面，并通过用户输入控制屏幕。我们在本章中使用的库将帮助我们控制屏幕移动并处理用户事件或输入。由 curses 构建的程序将不会具有类似于现代 GUI 应用程序或 Android 应用程序的功能，后者具有文本视图、标签、滑块、图形和模板等小部件。相反，它将提供简单的小部件和工具，如**命令行界面**（**CLI**），其中大部分都可以在纯文本应用程序中找到。

Python 的 curses 模块是对 C 语言 curses 的一种改编。唯一的区别是使用 Python；任何事情都可以在我们不深入了解低级常规的情况下完成。我们可以调用接口来调用函数，这些函数反过来会调用Curses来处理用户操作。

在处理Curses时，窗口屏幕被视为一个字符矩阵。每个窗口界面由程序员设置，包括高度、宽度和边框。设置这些坐标后，程序员将调用 Python Curses来更新该屏幕。使用诸如文本视图、按钮和标签等小部件也是以相同的方式完成的；也就是说，我们将初始化应该放置在窗口中的坐标，并调用 curses 相应地更新它。要处理来自Curses的用户输入，我们必须导入它。我们可以很容易地导入诸如右、左、上、下等动作，并根据程序的需要处理它们的行为。在大多数游戏中，这些事件将为游戏角色提供移动。我们将在本章末尾介绍的游戏是贪食蛇游戏，蛇本身就是我们的主角。这意味着，左、右、上、下等动作会将蛇移动到新位置。Python 的 Windows 版本没有内置的 curses 模块，因此不能使用相同的名称。然而，有两个兼容的模块可以做同样的事情。这些被称为 UniCourses 和 windows Curses。我们将在本章中使用后者。

让我们通过制作一个简单的应用程序来学习Curses。我们将制作一个简单的`hello`程序，打印在Curses终端上。

# 启动 curses 应用程序

我们将使用一个模块构建应用程序，该模块不是用 Python 预先打包的。因此，我们必须在机器上手动安装该软件包。安装 Python 后，包管理系统应该已经自动安装在您的机器上，称为 pip。此管理工具用于安装和组织使用 Python 编写的库。因此，如果您想在程序上使用任何第三方库或依赖项，则必须使用 pip 工具安装它们。安装任何软件包的方法都很简单。您只需编写`pip install`命令，后跟希望安装的库的名称。库名称区分大小写，因此在编写库名称时不应出错。如果要检查库中编写的代码，只需搜索该库的文档即可。您将获得有关库的信息，以及可在程序中使用的函数。

我们将使用 windows curses 库编写基于文本的程序，因此我们必须使用`pip`命令安装该软件包。如果您的计算机是 Windows，则应在命令提示符中执行 pip 命令；如果您使用 Mac OS X 或 Linux，则应在计算机终端中执行 pip 命令。下面的屏幕截图显示了我们需要如何执行`pip`命令：

![](img/16064870-3492-408d-8aae-cd282362fb42.png)

类似地，要在 Linux 机器中安装 curses，可以打开终端并运行以下命令：

```py
$ sudo apt-get install libncurses5-dev libncursesw5-dev
```

现在，我们将能够使用 curses 模块编写程序。此时，我们安装的 curses 模块将以与其他内置模块（如 math 或 random）相同的方式可用。与内置模块类似，我们可以简单地导入 curses 模块并开始调用其中定义的函数。以下步骤解释了创建任何 curses 应用程序的路线图：

1.  让我们从导入Curses开始，看看它是否安装正确。我们用于导入任何模块的命令是`import`，后跟模块名称。我们的模块名是 curses。因此，命令如下：

```py
 >>> import curses
 >>> #no any error
```

2.  我们可以得出结论，因为 Python 解析器没有抛出错误，所以它被成功导入。现在，我们可以使用这个模块来编写程序。让我们编写一个简单的程序来观察 curses 模块的工作过程：

```py
      #program is written as Scripts
      # curser_starter.py

      import curses
      import time
      window_screen = curses.initscr()
      window_screen.clear()

      time.sleep(10)
```

We cannot run any curses applications directly from Python IDLE. To run it, you have to navigate to the folder where you have stored the Python file and double-click on that file to open it. You will get a blank screen with a cursor at the top, which will remain there for 10 seconds. After 10 seconds, the same blank window screen will pop out from the screen. That screen will yield the text-based application that can be written with curses.

让我们看看前面的代码，并揭示Curses的有趣功能：

*   首先，和往常一样，我们导入了我们想要在程序中使用的模块。我们在这里导入了两个模块：Curses和时间。curses 模块有不同的函数可用于编写基于文本的应用程序，而 time 模块有不同的函数可用于更新输出屏幕行为。在这个程序中，我们调用了`time`模块的`sleep`方法，它将保持屏幕输出在括号内经过的时间量（在我们的例子中为 10 秒）。10 秒后，我们的输出屏幕将消失。
*   在编写带有Curses的代码之前，应该对其进行初始化。`initscr()`函数的调用将初始化Curses。因此，对于任何 curses 应用程序，我们应该在代码的第一行初始化 curses。这个初始化代码将返回一个窗口对象，它表示程序的输出屏幕。这里，这个初始化被名为`window_screen`的窗口对象捕获，它代表我们的输出终端的屏幕。因此，对 curses API 的任何函数调用都应该使用`window_screen`完成。第一次调用是通过`clear()`函数完成的。

我们成功地创建了一个游戏屏幕，并通过方法调用保持它。但是，当前屏幕的可修改性不够。作为程序员，我们可能希望通过明确指定高度和宽度来定制屏幕。幸运的是，Python 的 curses 模块提供了另一种方法来实现这一点，即`newwin`方法。我们将在下一节中了解它。

# 新的屏幕和窗口对象

调用`initscr()`函数返回的窗口对象表示输出窗口的整个屏幕。这个窗口对象还支持不同的方法，可以向窗口显示文本、修改它、从用户获取事件和更新位置，等等。此`initscr()`功能的唯一缺点是我们无法将自定义屏幕高度或宽度传递给它。它仅表示输出终端的默认整个屏幕。

有时，我们可能希望对游戏屏幕进行定制，使其高度为 20，宽度为 60，例如。这里，高度和宽度可以视为列和行，其中每个单元表示该矩阵中的一条线。因为我们已经通过了 60 的宽度，所以将有 60 条水平线。我们 20 岁的身高也是如此；将有 20 条垂直线。也可以将它们表示为像素。要创建一个新的屏幕，这可能是我们在创建一个 curses 应用程序时要做的，因为`initscr()`函数不会为我们这样做，我们必须调用新函数。此函数将根据指定的坐标将较大的窗口屏幕划分为一个新屏幕。这个函数的名称是`newwin()`，字面意思是新窗口，它有四个参数，即**高度**、**宽度**、**Y**和**X。这些参数传入的顺序是**Y**、**X**，这与其他库相比是不寻常的。**Y**值表示列的位置，**X**值表示行的位置。请看下图，**Y**和**X**的值说明如下：**

![](img/1df0dbbc-8aca-4b5e-93bc-0e9e14718431.png)

因此，通过增加**Y**的值，我们向下移动，这与矩阵中的列相同。类似地，通过增加**X**的值，我们朝向屏幕的右侧，这与矩阵中的行相同。正如我们所看到的，curses 以字符矩阵的形式存储窗口屏幕。我们可以使用这些坐标来表示游戏显示的位置以及游戏角色。例如，如果你想让你的玩家移动到（5,0）的位置，如上图所示，你可以调用`move(5,0)`函数来实现。记住参数传递的顺序。**Y**的值后面跟着**X**，如果您有任何其他库的游戏编程背景，这可能会让您感到困惑

例如，我们将创建一个程序，在该程序中，我们将使用`newwin()`函数在大屏幕内创建一个新屏幕。此函数中的四个参数是`height`、`width`、`y`和`x`。记住这个顺序，因为我们必须以类似的方式传递它：

```py
height = 20
width = 60
y = 0
x= 0

screen = curses.newwin(height, width, y, x)
```

现在，是时候编写一个简单的程序，为我们的 curses 应用程序添加一些文本：

```py
# text_app.py
import curses
import time

screen = curses.initscr()
curses.noecho()
curses.cbreak()
screen.keypad(True)
screen.addstr(0,0, "Hello")
screen.refresh()
time.sleep(10)
curses.endwin()
```

让我们逐行观察前面的代码，并了解我们使用的每个方法，如下所示：

*   首先，我们导入了两个重要模块：Curses和时间。之后，我们使用`initscr()`函数初始化窗口对象。`noecho()`功能将关闭我们应用程序中的自动回音过程。这是必要的，因为当用户玩游戏时，我们不希望他们向我们展示他们按下的按钮；相反，我们希望他们根据该事件执行操作。下一个函数调用是`cbreak()`。此模式将帮助我们的程序对用户的输入做出即时反应。例如，在 Python 的`input()`方法中，除非我们在键盘上按下*Enter*，否则该方法不会执行任何操作。但是，在使用`cbreak()`功能的情况下，它将帮助应用程序立即对任何输入键做出反应，而无需按下*Enter*。这一点很重要，因为我们必须制作一个游戏，让用户能够毫不延迟地得到响应。例如，如果用户按下向下键，游戏角色必须立即向下移动。这与缓冲输入功能不同，缓冲输入功能将接收所有输入并将其存储在缓冲区中，只有当用户按下*Enter*时，缓冲区才会做出反应。

*   下一个函数调用是`keypad()`函数。我们通过传递 True 作为参数来启用键盘模式。无论何时按下终端中的任何键，它都会以多字节转义序列的形式返回数据。例如，`Esc`发送`\x1b`。这是 1 字节。`Page Up`发送`\x1b[H`。这是 3 个字节。为了处理终端返回的此类数据，curses 使用一个可以手动导入的特殊值。例如，要处理键盘上按下的向下键，我们可以将其作为`curses.KEY_DOWN`导入。这是通过启用键盘模式完成的。
*   之后，我们调用了`addstr()`函数。此函数将在其调用过程中指定的位置向输出屏幕添加字符串。我们向它提出了三个论点。请记住，前两个参数的顺序是 y，x。传递的最后一个参数是需要添加到（y，x）位置的字符串。我们传递了一个值（0,0），这意味着字符串将被添加到输出窗口的左上角。我们调用的下一个方法是`refresh()`，它将更新窗口对象*屏幕*的字符矩阵。如果您仔细查看代码，就会发现，无论何时添加或刷新屏幕内容，我们都是使用 window curses 对象进行操作，该对象是使用`initscr()`函数初始化的。但是，curses 模块已经改变了终端的行为。例如，为了更改终端的默认回显行为，我们直接从 curses 模块调用了`noecho()`函数，而不是从 window cursor 对象调用。

现在，让我们运行代码来观察结果。确保在终端或命令提示符下使用`filename.py`运行应用程序：

![](img/f76bd343-3e09-41ef-8a3e-956e4c65c004.png)

可以将位置从（0,0）更改为任何其他值，例如，（5,5），以观察窗口和填充格式。

最后，我们制作了第一个带有Curses的程序。现在，是时候探索 curses 的另一个特性了，它基于处理用户输入的能力。

# 带Curses的用户输入

在任何游戏中，用户输入都是需要正确处理的最关键的信息之一。在处理这些类型的行动时，我们不能有任何延误。对于Curses，我们有两种方法从用户那里获取输入。这两种方法如下：

*   如果你有 C 语言或 C++语言的编程背景，这对你来说不应该是新的。`getch()`函数与 C 中的函数一样，用于生成一个侦听器，该侦听器将持续侦听用户密钥。它返回一个 0 到 255 之间的整数，表示按下的键的 ASCII 码。例如，`a`的 ASCII 码是`097`。大于 255 的值是特殊键，例如*页面向上*和导航键，即向上、向下、向左和向右。我们可以将这些键的值与存储在 curses 中的常量进行比较；例如，`curses.UP`、`curses.DOWN`、`curses.LEFT`和`curses.RIGHT`。
*   `getkey()`：`getch`和`getkey`做同样的事情，`getkey`函数将返回的整数转换成字符串。正常键（如 a-z 或 a-z）将以 1 个字符串的形式返回，可与`ord()`函数进行比较。但是，特殊键或功能键将作为包含键并表示操作类型的较长字符串返回，如`KEY_UP`。

让我们编写一个可以处理键盘事件的程序：

```py
#program3.py
import curses as c

screen = c.initscr()
win = c.newwin(20, 60, 0, 0)

c.noecho()
c.cbreak()
screen.keypad(True)
while True:
  char = screen.getch() #takes input
  if char == ord('q'):
      break
  if char == ord('p'):
      win.addstr(5,10, "Hello World")
      win.refresh()
screen.endwin()
```

我们在讨论使用真循环时讨论了这段代码。如果对这些命令中的任何一个感到困惑，请确保修改前面的主题。在这段代码中，您可能会看到一件奇怪的事情，我们导入了Curses，并给它一个别名 c。这是重命名模块的过程。现在，我们不必在每次方法调用时都使用`curses.method_name`，而只需使用`c.method_name()`来调用它，这无疑消除了每次编写相同模块名的开销。在循环内部，我们使用`getch()`函数从用户那里获取输入。之后，在`char`变量中检索字符，并将其与`ord`函数的返回值进行比较。还记得`getch`函数将返回 Unicode 格式的值吗？通过`ord`功能也可以实现这一点。它将参数作为字符，并返回该字符的 Unicode 值。我们用条件句来创造条件。因此，如果用户在键盘上按*q*，我们将结束程序，如果用户在键盘上按*p*，我们将`Hello World`打印到（y，x）位置的输出窗口。让我们运行 Python 文件`C:\User\Desktop> python program3.py`，看看输出：

![](img/935843ba-c5f4-4c19-96c2-0b28b7fe7a6e.png)

按键盘上的*q*终止循环并关闭应用程序。

Note that *q* is not the same as *Q* because the ASCII code for these characters isn't the same.

我们的代码运行得很好，但越来越长，即使应用程序非常简单。我们已经调用了很多方法，比如`noecho()`、`cbreak()`、`keypad()`和`endwin()`。为了消除调用这么多函数的开销，我们可以使用 curses 模块中的包装器函数。所有这些函数，包括 curses 对象的初始化，都是由包装器函数自动完成的。请记住，包装器函数是对包的调用，它将所有这些方法包装在包中。

类似地，我们也可以使用 curses 模块处理鼠标事件。让我们使用包装器函数制作一个程序，并在同一程序中处理鼠标按钮的事件：

```py
#mouse_events.py

import curses as c
def main(screen):
  c.curs_set(0) #hides the cursor
  c.mousemask(1)

  inp = screen.getch()
  if inp == c.KEY_MOUSE:
      screen.addstr(17,40, "Mouse is clicked")
      screen.refresh()
  screen.getch()

c.wrapper(main)
```

让我们详细地看一下前面的代码：

*   我们将从最后一行开始，在那里我们使用一些可调用对象作为参数调用包装器函数。我们已经了解了`wrapper()`的目标；它消除了多个函数调用，如`initscr()`、`noecho()`等。因此，使用包装器函数可以更容易地进行调试。不仅如此，该函数还通过使用 try 和 catch 块在内部处理异常。每当您遇到可能未捕获的未知异常时，您总是可以信任包装器函数来执行此操作。这将识别程序的错误，并在不使应用程序崩溃的情况下向您提供异常消息。包装器函数的参数将是一个可调用对象，在本例中，它是主函数。此主函数有一个*screen*参数，它是 curses 窗口对象。我们没有使用`initscr()`函数初始化程序中任何地方的 curses 对象，因为这是由包装器函数在内部完成的。
*   在 main 函数的范围内，我们调用了两个方法：`curs_set(0)`，它将在输出屏幕中隐藏光标；以及`mousemask(1)`，它将接受鼠标事件。在这里，鼠标事件将是特殊符号或功能字符，与普通字母字符不同。因此，curses 创建了常量来处理这些函数字符。这与向上键盘键相同；我们有`KEY_UP`常数；对于鼠标事件，我们有`KEY_MOUSE`常数。这些应该从 curses 模块调用，例如，`curses.KEY_MOUSE`。在我们得到这样的鼠标事件之后，我们将把`Mouse is clicked`打印到输出终端。`getch()`方法将输入任何与鼠标或键盘按钮相关的事件。让我们运行程序以实现以下输出：

![](img/29bbc122-b640-411f-a973-606a7ff98269.png)

现在，我们已经获得了足够的知识来制作使用Curses的游戏，让我们进入下一节，这将让我们了解如何在引擎盖下制作游戏逻辑。我们将制作一个简单的贪食蛇游戏。

# 用Curses做贪食蛇游戏

我们已经知道，编写游戏的过程并不像看上去那么容易。我们必须遵循许多程序才能使游戏可玩，因为在将游戏暴露于环境的同时，我们可能会被许多不想要的和意外的异常所淹没。因此，遵循正确的执行顺序始终是至关重要的，即使这可能需要比平时更多的时间。在本节中，我们将创建一个使用Curses的清酒游戏。在接下来的章节中，我们将把它修改成一款更具吸引力的游戏。一个好的游戏并不总是意味着一个好的用户界面，因为界面为用户而不是程序员提供了价值。我们必须养成在编写好接口的同时编写适当代码的习惯，这要求我们遵循本节将介绍的每个步骤。我们将使用Curses模块来制作最初的贪食蛇游戏。然后，在下一章中，我们将使用面向对象编程对其进行修改。

在编写代码之前，我们必须收集有关模型和游戏界面的信息。在建模时，我们必须提取关键信息，例如*如何将游戏角色渲染到屏幕*、*如何制作事件监听器*、*如何制作允许游戏角色移动的逻辑*。我们将在下一节介绍所有这些。

# 集思广益和信息收集

正如我们到目前为止所做的那样，第一步是集思广益，收集有关游戏布局和游戏模型的关键信息。在贪食蛇游戏中，我们有两个角色：蛇（玩家）和它的食物。每当蛇吃东西时，它的长度应该增加。不管怎么说，这是最基本的想法。现在，让我们修改可用的资源。显然，Python 提供的资源更加丰富，但我们还没有学会如何制作图形字符并在游戏中使用它们。我们所学的就是用基于文本的终端制作游戏。我们可以使用 A-Z 等字符来指定游戏对象。例如，我们可以制作 snake`XXXXXXX`，它是 Xs 的组合。食物可以用`O`表示。让我们看看这在我们的游戏机中是什么样子：

![](img/a3df7678-7e01-4124-bec7-1a9f24c72335.png)

我们还必须决定游戏的屏幕。`initscr()`方法将整个屏幕创建为Curses对象。我们不希望这样；相反，我们希望制作一个游戏屏幕，可以根据高度、宽度和 y、x 位置进行定制。您可能还记得，我们可以使用`newwin()`方法将屏幕划分为一个新的屏幕。

要记住的最重要的事情是跟踪坐标，因为我们必须为我们的游戏设定一个边界。我们可以制定特定规则，指定游戏角色的边界位置，如果他们触及该边界，我们可以终止游戏。

我们必须为两件事制定逻辑：

*   每当蛇吃了食物，我们就必须在新的位置产生新的食物。
*   每当蛇吃食物时，我们必须提高蛇的速度，使游戏更加困难。我们还应该追踪蛇头和蛇身之间的碰撞。

对于前一点，我们可以使用随机模块，它提供了一个（y，x）的随机坐标位置，我们可以将食物分配给它。对于后一点，我们必须使用一个名为 timeout 的 curses 方法。我们必须将延迟值作为参数传递给该函数。根据 Python 的官方文档，timeout 函数为窗口设置阻塞或非阻塞读取行为。如果*延迟*为负，则使用阻塞读取（将无限期等待输入）。如果*延迟*为零，则使用非阻塞读取，如果没有等待输入，`getch()`将返回-1。如果*延迟*为正，则`getch()`将阻塞*延迟*毫秒，如果在该时间结束时仍然没有输入，则返回-1。因此，当延迟为零或正时，我们可以根据延迟改变游戏的速度。

所以，根据`curses.timeout(delay)`命令，如果延迟为负数，你的蛇将快速移动。然而，我们需要记住，我们在这里有一些限制；蛇的速度应该随着蛇的长度而增加。首先，什么是蛇？我们的游戏是如何制作的？我们在上一章学习了列表。让我们用它来做一条蛇。我们已经看到了蛇的结构，这是一堆 X 字符。但在游戏开始时，我们应该只为蛇提供一个小长度，可能是 3，也就是说，`XXX`。我们将在列表中存储这些 X 中的每一个，该列表表示坐标，例如[[4,10]、[4,9]、[4,8]]。这里，这些列表中的每一个都代表一个 X，也就是说，在[4,10]的位置，我们将有一个 X 和另一个 X 在 4,9。请记住，这些位置应该是 y、x 位置，并且它们应该彼此相邻，因为它们代表蛇的身体。

假设我们的延迟是 100，这是常数。因此，我们表示速度的命令将是`curses.timeout(100)`，这将是蛇在整个游戏中的恒定速度。然而，我们可以通过增加蛇的长度来改变游戏的速度。现在，让我们进入下一节，在那里我们将为游戏设定一个边界。

# 开端

在本节中，我们将开始为游戏编写代码。我们将使用 curses 模块来实现这一点。首先，我们将初始化游戏的屏幕并制作一些游戏角色。请看下面的代码：

```py
#snake_game.py
import curses as c

c.initscr()
win = c.newwin(20,60,0,0)
win.keypad(1)
c.noecho()
c.curs_set(0)
win.border(0)
win.nodelay(1)

snake = [[4,10], [4,9], [4,8]]
food = [10,20]

win.addch(food[0],food[1], 'O')
```

前面的代码中没有什么新内容。您还可以使用`wrapper()`函数消除所有函数调用。我们可以看到，我们有两个列表变量，`snake`和`food`，其中包含代表它们在游戏控制台中位置的坐标。我们还调用了`addch`函数。它将以类似于`addstr`功能的方式工作。我们传递了食物的位置，并在该位置添加了`O`字符。

制作电脑游戏需要两个步骤：第一步是制作自然吸引人的视觉效果，第二步是让玩家与游戏互动。为了使游戏具有交互性，我们必须处理玩家提供的事件。这是我们将在下一节中做的。

# 处理用户密钥事件

我们已经开始构建游戏的基本布局。现在，让我们编写一些代码来处理用户键盘事件。蛇是一个简单的游戏。我们只需操作键盘上的四个键，即上、下、左、右，就可以使它正常工作。我们可以使用`getch()`获取用户输入。但请记住，这些不是字母字符，它们是功能字符。因此，我们必须导入常量，如`KEY_UP`、`KEY_DOWN`、`KEY_LEFT`和`KEY_RIGHT`来获取这些 ASCII 值。让我们开始编写处理用户事件的代码：

```py
from curses import KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT
#CODE FROM PREVIOUS TOPIC

key = KEY_RIGHT #default key

#ASCII value of ESC is 27
while key != 27:
  win.border(0)
  win.timeout(100) #speed for snake
  default_key = key
  event = win.getch()
  key = key if event == -1 else event
  if key not in [KEY_LEFT, KEY_RIGHT, KEY_UP, KEY_DOWN, 27]:
     key = default_key
```

我们编写的代码可能看起来很复杂，但所有这些内容都已经涵盖。让我们来看看我们做了什么：

*   在第一条语句中，我们使用了默认键`KEY_RIGHT`。这一点很重要，因为如果用户没有按键，我们不想让蛇移动。因此，当游戏开始时，我们的蛇角色将自动向右移动。
*   在那之后，我们做了一个游戏循环。由于*Esc*的 ASCII 值为 27，所以在我们按下*Esc*之前，将执行此循环。在循环内部，我们调用了 timeout 方法，它将表示蛇角色的速度。在下一行中，我们使用`getch()`方法获取用户的事件。记住，如果您按下任何键事件，其值将为-1。因此，我们可以比较它并将用户按下的键放入键变量中。但是，键可以是任何东西，例如字母字符或特殊符号，例如[！、@、#、$]，因此我们必须使用适当的键对它们进行过滤，例如，左、右、上和下。如果用户按下的键不在其中，我们将使该键具有默认值`KEY_RIGHT`。

现在，我们可以用键盘或操纵杆等输入设备与程序通信。现在是进入下一节的时候了，在这里我们将创建第一个逻辑，当用户按下左、右、上、下键时，更新蛇形角色的**头部位置**。

# 游戏逻辑-更新蛇的头部位置

在上一节中，我们能够使用 curses 提供的常量处理用户事件。就像移动一样，蛇头也可以改变。我们必须做出全新的逻辑来更新蛇头的位置。我们的 snake 是由存储在列表中的坐标组成的。嵌套列表的第一个元素是蛇头的位置。因此，我们只需要更新列表的第一个元素。让我们看看我们将如何做到这一点：

```py
while key != 27:
  #code from preceding topic
  snake.insert(0, [snake[0][0] + (key == KEY_DOWN and 1) + 
  (key == KEY_UP and -1), snake[0][1] + (key == KEY_LEFT and -1) + 
  (key == KEY_RIGHT and 1)])
```

这似乎有点难以理解，所以让我说清楚。

`snake`变量是一个列表。因此，我们可以使用`insert()`方法来操作该列表元素。`insert()`方法将包含两个参数：一个是索引，另一个是要插入的元素。在前面的代码中，索引为 0，这意味着我们要在列表的第一个元素中插入一个元素，该元素表示蛇的头部。下一个参数是需要添加到索引 0 的元素。我们可以在两个语句之间看到一个逗号（`,`）：`snake[0][0] + (key == KEY_DOWN and 1) + (key == KEY_UP and -1)`和`snake[0][1] + (key == KEY_LEFT and -1) + (key == KEY_RIGHT and 1)`。第一条语句表示蛇头的 y 坐标，第二条语句表示蛇头的 x 坐标。在蛇头的 y 形部分，可以表示为一列，我们可以有两个动作：向下或向上。向下时，我们必须在当前头部位置 y 元素上加 1，向上时，我们必须在当前 y 位置上减少 1。对于蛇头的 x 部分，我们有左右移动。

按左键时，我们将用 1 减小 x 的坐标，按右键时，我们将向 x 添加 1。还困惑吗？看一下下面的图表应该会让您更清楚：

![](img/20279a9a-0c1a-41ba-a180-c0b02331e9f8.png)

请记住，此更新必须按（y，x）的顺序进行。对于每按一次**向上**和**向下**键，在 y 坐标系中减量或增加 1，即头部的 snake[0][0]。对于 x，这是 snake[0][1]，这与我们之前使用的增量和减量相同，但是当用户按下**右**和**左**键时。

现在我们已经做了一些逻辑来更新蛇的位置，我们需要让蛇吃食物。我们要讲的逻辑很简单：当蛇的头部位置与食物的位置相同时，我们可以说蛇吃了食物。让我们现在再看一遍。

# 游戏逻辑——当蛇吃食物时

让我们为我们的游戏做下一点逻辑。在本节中，我们将让蛇吃食物。这很容易实现。每当蛇头碰到食物时，我们就认为蛇已经吃了食物。因此，蛇头坐标和食物坐标是相同的。我们还必须做出一些逻辑，一旦蛇吃掉了当前的食物，就会在下一个位置生成食物。下一块食物的位置应该是随机的。我们可以使用`random`模块创建这样一个任意位置。让我们开始编写代码：

```py
from random import randint
```

这是从模块导入任何函数的新方法。调用此函数时，我们不必编写类似于`random.randint()`的内容。相反，我们可以在程序中直接调用它。`randint()`方法中的参数必须是值的范围。例如，`randint(2,8)`返回一个介于 2 到 8 之间的数字，如下所示：

```py
while key != 27:
#add the following code after updating head position
  if snake[0] == food:
      food = []
      while food == []:
        food = [randint(1,18), randint(1,58)]
        if food in snake: 
            food = []
      win.addch(food[0], food[1], 'O')
  else:
      last = snake.pop()
      win.addch(last[0], last[1], ' ')
  win.addch(snake[0][0], snake[0][1], 'X')

c.endwin()
```

在代码的 if 部分中，我们添加了将食物置于新位置的逻辑。请记住，在游戏开始时，我们将新窗口的高度初始化为 20，宽度初始化为 60。因此，我们只能在这一边界内生产食物。在代码的 else 部分，如果用户不能吃食物，我们将弹出最后一个元素。在倒数第二行中，我们用`'X'`字符添加了蛇头的位置。

让我们运行我们的游戏，看看到目前为止它是什么样子：

![](img/b1eacf8b-662a-45a1-883f-f68146d1edf9.png)

现在，我们的游戏可以玩了。在制作这个游戏的过程中，我们学到了很多东西，比如如何在使用游戏控制台的方法和坐标时制作游戏逻辑。现在，让我们进入下一节，在那里我们将学习如何测试和修改我们的游戏。

# 游戏测试和修改

要发现任何程序的缺陷，运行和测试它总是一个好主意。就像我们以前的游戏一样，我们也可以对 Snake 游戏进行修改。以下几点解释了我们可以对游戏进行的一些修改：

*   当你运行游戏时，你会注意到的第一件事是，我们的游戏没有逻辑来决定蛇是否与自身碰撞。如果它确实与身体的另一部分相撞，我们必须停止比赛。让我们在 while 循环中添加该逻辑：

```py
      if snake[0] in snake[1:]: 
          break
```

*   在前面的代码中，snake[0]表示蛇的头部，而 snake[1:]表示蛇的身体。因此，前面的条件意味着头部坐标位于蛇的身体内部，这意味着发生了碰撞。在本例中，我们使用`break`语句退出循环并终止游戏。

*   假设我们想增加球员的得分。添加分数很简单；蛇吃过的食物数量等于玩家的分数。我们可以将分数的值初始化为 0，以：

```py
      score = 0 
      while key != 27:
        # CODE TO ADD SCORE IN THE SCREEN
        win.border(0)
        win.addstr(0, 2, 'Score : ' + str(score) + ' ') 
        win.addstr(0, 27, ' SNAKE ')

        if snake[0] == food:
            food = []
            #AFTER EATING EVERY FOOD SCORE = FOOD
            score += 1
            while food == []:
              food = [randint(1,18), randint(1,58)]
              if food in snake: food = []
            win.addch(food[0], food[1], 'O')
        else:
            end = snake.pop()
            win.addch(last[0], last[1], '')
        win.addch(snake[0][0], snake[0][1], 'X')

      c.endwin()
```

在前面的代码中，我们添加了一些带有`addstr`方法的语句，这些语句将提供玩家在指定位置的得分。现在，让我们运行我们的游戏：

![](img/9358081e-0e9b-4242-ab0e-0e7a30cc3cd5.png)

运行游戏后，您可以看到我们能够在Curses界面内进行游戏。然而，当你的蛇到达边界线时，你会遇到一个异常，你的游戏将自动终止。在接下来的章节中，我们将详细学习如何处理边界冲突（具体来说，[第 11 章](11.html)、*奥多乌龟-蛇类游戏 UI 和 Pygame*），但是，现在，让我们来学习处理和避免触发异常的最简单方法。首先，观察边界屏幕的尺寸，并记录边界所在的实际高度和宽度。考虑一下这个变量，了解边界屏幕的大小。现在，看 20 的高度，我们可以假设，每当蛇接触到顶部边界时，也就是说，蛇的头部位置为 0，蛇的头部必须通过自己的边界，y 坐标为 19。请记住，在上边界和下边界中，只有 y 坐标发生更改。其代码如下所示：

```py
if snake[0][0] == 0:
    snake[0][0] = 18 #regenerate snake from lower boundary line

if snake[0][0] == 19:
    snake[0][0] = 1 #regenerate snake from upper boundary line
```

类似地，我们必须解决蛇撞击右边界或左边界的情况。由于两种情况下高度保持不变，我们只对宽度（x 位置）感兴趣。由于 win 变量所声明的屏幕宽度为 60，因此我们可以预期蛇在 0（右侧）和 59（左侧）左右撞击边界，从而导致蛇相应地重新生成。必须添加以下代码行来处理左右边界处发生的碰撞：

```py
if snake[0][1] == 0:
    snake[0][1] = 58 #regenerate from left
if snake[0][1] == 59:
    snake[0][1] = 1 #regenerate from right
```

最后，我们完成了蛇的游戏。它的吸引力足以让任何用户玩这个游戏。我们还学习了如何用我们自己的全新逻辑创建程序。这是我们用来制作基于文本的游戏的第一个简单模块。即使它是可玩的，我们还没有添加任何图形，所以它看起来很平淡。我们将学习一种新的 Python 范例，名为面向对象编程，从而使它更加精彩。我们已经成功地对游戏进行了一些修改。现在，是学习 Python 最重要的概念的时候了：面向对象编程。

# 总结

在本章中，我们开始揭示Curses游戏编程的世界。显然，这不是一个完美的游戏，因为它没有令人惊异的动画或精彩的界面。我们很少涉及这些主题，因为 curses 提供了基于文本并在普通终端上运行的应用程序。甚至游戏中的角色，如蛇和蛇的食物都是由字母组成的。尽管我们没有付出额外的努力使游戏更具吸引力，但我们已经学会了如何使游戏具有逻辑性。我们在 Snake 游戏中制定的两个逻辑非常重要：第一个是游戏控制台坐标与玩家位置的交互，第二个是使角色发生碰撞。被Curses支持的坐标系的顺序很奇怪。在大多数库中，例如 pygame 和 pyopengl，我们有一个以（x，y）顺序表示的坐标系，但在 curses 中，它是（y，x）。如果两个字符位于同一坐标点（y，x），则确认它们之间的碰撞。要做到这一点，我们必须检查蛇头和蛇身之间的碰撞。这个逻辑听起来可能很简单，但从长远来看，它会派上用场。例如，在即将推出的游戏中，如 Flappy Bird 或 Angly Birds，我们将使用相同的逻辑检查角色之间的碰撞。

我们为 Snake 游戏编写的代码是细致而彻底的，因为该游戏的编写考虑到了过程编程。在下一章中，我们将学习 Python 最重要的概念，面向对象编程，并相应地修改我们的代码，这将使我们的代码更具可读性和可重用性。