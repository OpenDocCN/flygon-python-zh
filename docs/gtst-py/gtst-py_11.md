# 第十一章：图和其他算法

在本章中，我们将讨论图。 这是来自称为图论的数学分支的概念。

图用于解决许多计算问题。 它们的结构比我们所看到的其他数据结构要少得多，遍历等操作可能更加不寻常，我们将会看到。

在本章结束时，您应该能够做到以下几点：

+   了解图是什么

+   了解图的类型及其组成部分

+   知道如何表示图并遍历它

+   对优先队列有一个基本的概念

+   能够实现优先队列

+   能够确定列表中第 i 个最小元素

# 图

图是一组顶点和边，它们之间形成连接。 在更正式的方法中，图 G 是顶点集 V 和边集 E 的有序对，以`G = (V, E)`的形式给出。

这里给出了一个图的示例：

![](img/314da5e8-4407-450b-b87c-582443b5a40e.png)

现在让我们来看一些图的定义：

+   **节点或顶点**：图中通常由一个点表示。 顶点或节点是 A、B、C、D 和 E。

+   **边**：这是两个顶点之间的连接。 连接 A 和 B 的线就是边的一个例子。

+   **环**：当来自节点的边与自身相交时，该边形成一个环。

+   **顶点的度**：这是与给定顶点相交的顶点数。 顶点 B 的度为`4`。

+   **邻接**：这指的是节点与其邻居之间的连接。 节点 C 与节点 A 相邻，因为它们之间有一条边。

+   **路径**：一系列顶点，其中每对相邻的顶点都由一条边连接。

# 有向和无向图

图可以根据它们是无向的还是有向的进行分类。 无向图简单地将边表示为节点之间的线。 除了它们连接在一起这一事实之外，关于节点之间关系的其他信息都没有：

![](img/a00af33a-cce6-410c-87a6-b3a8127808a5.jpg)

在有向图中，边除了连接节点外还提供方向。 也就是说，边将被绘制为带有箭头的线，箭头指示边连接两个节点的方向：

![](img/fa6d3a7d-d3ba-4c05-bf97-2ff2cc3ee21e.png)

边的箭头确定了方向的流动。 在上图中，只能从**A**到**B**。 而不能从**B**到**A**。

# 加权图

加权图在边上添加了一些额外的信息。 这可以是指示某些内容的数值。 例如，假设以下图表表示从点**A**到点**D**的不同路径。 您可以直接从**A**到**D**，也可以选择通过**B**和**C**。 与每条边相关的是到达下一个节点所需的时间（以分钟为单位）：

![](img/297e002c-8a8f-467a-a1c8-ef7abeaa99c0.jpg)

也许旅程**AD**需要您骑自行车（或步行）。 **B**和**C**可能代表公交车站。 在**B**，您需要换乘另一辆公交车。 最后，**CD**可能是到达**D**的短途步行。

在这个例子中，**AD**和**ABCD**代表两条不同的路径。 **路径**只是两个节点之间*穿过*的边的序列。 沿着这些路径，您会发现总共需要**40**分钟的旅程**AD**，而旅程**ABCD**需要**25**分钟。 如果您唯一关心的是时间，即使需要换乘公交车，您也最好沿着**ABCD**行驶。

边可以是有向的，并且可能包含其他信息，例如所花费的时间或路径上关联的其他值，这表明了一些有趣的事情。在我们之前使用的数据结构中，我们绘制的*线*只是连接器。即使它们有箭头从一个节点指向另一个节点，也可以通过在节点类中使用`next`或`previous`、`parent`或`child`来表示。

对于图来说，将边视为对象与节点一样是有意义的。就像节点一样，边可以包含跟随特定路径所必需的额外信息。

# 图表示

图可以用两种主要形式表示。一种方法是使用邻接矩阵，另一种方法是使用邻接表。

我们将使用以下图来开发图的两种表示形式：

![](img/ae318786-366f-4a2f-858c-bbf6dd4b14e0.png)

# 邻接表

可以使用简单的列表来表示图。列表的索引将表示图中的节点或顶点。在每个索引处，可以存储该顶点的相邻节点：

![](img/e8839a93-3591-4613-8321-298d514d2271.png)

盒子中的数字代表顶点。索引**0**代表顶点**A**，其相邻节点为**B**和**C**。

使用列表进行表示相当受限，因为我们缺乏直接使用顶点标签的能力。因此，使用字典更合适。为了表示图中的图表，我们可以使用以下语句：

```py
    graph = dict() 
    graph['A'] = ['B', 'C'] 
    graph['B'] = ['E','A'] 
    graph['C'] = ['A', 'B', 'E','F'] 
    graph['E'] = ['B', 'C'] 
    graph['F'] = ['C'] 
```

现在我们很容易确定顶点**A**有相邻顶点**B**和**C**。顶点 F 只有顶点**C**作为其邻居。

# 邻接矩阵

图可以使用邻接矩阵来表示的另一种方法。矩阵是一个二维数组。这里的想法是用 1 或 0 来表示两个顶点是否通过一条边连接。

给定邻接表，应该可以创建邻接矩阵。需要一个图的键的排序列表：

```py
    matrix_elements = sorted(graph.keys()) 
    cols = rows = len(matrix_elements) 
```

键的长度用于提供矩阵的维度，这些维度存储在`cols`和`rows`中。这些值在`cols`和`rows`中是相等的：

```py
    adjacency_matrix = [[0 for x in range(rows)] for y in range(cols)] 
    edges_list = [] 
```

然后我们设置了一个`cols`乘以`rows`的数组，并用零填充它。`edges_list`变量将存储构成图中边的元组。例如，节点 A 和 B 之间的边将存储为(A, B)。

使用嵌套的 for 循环填充多维数组：

```py
    for key in matrix_elements: 
        for neighbor in graph[key]: 
            edges_list.append((key,neighbor)) 
```

顶点的邻居是通过`graph[key]`获得的。然后，结合`neighbor`使用`edges_list`中存储的元组。

迭代的输出如下：

```py
>>> [('A', 'B'), ('A', 'C'), ('B', 'E'), ('B', 'A'), ('C', 'A'), 
     ('C', 'B'), ('C', 'E'), ('C', 'F'), ('E', 'B'), ('E', 'C'), 
     ('F', 'C')]
```

现在需要做的是通过使用 1 来填充我们的多维数组，以标记边的存在，使用行`adjacency_matrix[index_of_first_vertex][index_of_second_vertex] = 1`：

```py
    for edge in edges_list: 
        index_of_first_vertex = matrix_elements.index(edge[0]) 
        index_of_second_vertex = matrix_elements.index(edge[1]) 
        adjacecy_matrix[index_of_first_vertex][index_of_second_vertex] = 1 
```

`matrix_elements`数组的`rows`和`cols`从 A 到 E，索引从 0 到 5。`for`循环遍历我们的元组列表，并使用`index`方法获取要存储边的相应索引。

生成的邻接矩阵如下所示：

```py
>>>
[0, 1, 1, 0, 0]
[1, 0, 0, 1, 0]
[1, 1, 0, 1, 1]
[0, 1, 1, 0, 0]
[0, 0, 1, 0, 0]
```

在第 1 列和第 1 行，0 表示 A 和 A 之间没有边。在第 2 列和第 3 行，C 和 B 之间有一条边。

# 图遍历

由于图不一定具有有序结构，遍历图可能更加复杂。遍历通常涉及跟踪已经访问过的节点或顶点以及尚未访问过的节点或顶点。一个常见的策略是沿着一条路径走到死胡同，然后向上走，直到有一个可以选择的路径。我们也可以迭代地从一个节点移动到另一个节点，以遍历整个图或部分图。在下一节中，我们将讨论用于图遍历的广度优先搜索和深度优先搜索算法。

# 广度优先搜索

广度优先搜索算法从一个节点开始，选择该节点或顶点作为其根节点，并访问相邻节点，然后探索图的下一级邻居。

考虑以下图表作为图：

![](img/a504a846-1f62-4eda-a404-e822ab78931b.png)

该图是一个无向图的示例。我们继续使用这种类型的图来帮助解释，而不会太啰嗦。

图的邻接列表如下：

```py
    graph = dict() 
    graph['A'] = ['B', 'G', 'D'] 
    graph['B'] = ['A', 'F', 'E'] 
    graph['C'] = ['F', 'H'] 
    graph['D'] = ['F', 'A'] 
    graph['E'] = ['B', 'G'] 
    graph['F'] = ['B', 'D', 'C'] 
    graph['G'] = ['A', 'E'] 
    graph['H'] = ['C'] 
```

为了以广度优先的方式遍历这个图，我们将使用队列。算法创建一个列表来存储已访问的节点，随着遍历过程的进行。我们将从节点 A 开始遍历。

节点 A 被排队并添加到已访问节点的列表中。之后，我们使用`while`循环来实现对图的遍历。在`while`循环中，节点 A 被出队。它未访问的相邻节点 B、G 和 D 按字母顺序排序并排队。队列现在包含节点 B、D 和 G。这些节点也被添加到已访问节点的列表中。此时，我们开始`while`循环的另一个迭代，因为队列不为空，这也意味着我们并没有真正完成遍历。

节点 B 被出队。在它的相邻节点 A、F 和 E 中，节点 A 已经被访问。因此，我们只按字母顺序排队节点 E 和 F。然后将节点 E 和 F 添加到已访问节点的列表中。

此时，我们的队列中包含以下节点：D、G、E 和 F。已访问节点的列表包含 A、B、D、G、E、F。

节点 D 被出队，但是它的所有相邻节点都已经被访问过，所以我们只是出队它。队列前面的下一个节点是 G。我们出队节点 G，但是我们也发现它的所有相邻节点都已经被访问，因为它们在已访问节点的列表中。节点 G 也被出队。我们也出队节点 E，因为它的所有节点都已经被访问。现在队列中唯一的节点是节点 F。

节点 F 被出队，我们意识到它的相邻节点 B、D 和 C 中，只有节点 C 还没有被访问。然后我们将节点 C 排队并将其添加到已访问节点的列表中。节点 C 被出队。节点 C 有相邻节点 F 和 H，但 F 已经被访问，只剩下节点 H。节点 H 被排队并添加到已访问节点的列表中。

最后，`while`循环的最后一次迭代将导致节点 H 被出队。它唯一的相邻节点 C 已经被访问过。一旦队列完全为空，循环就会中断。

在图中遍历的输出是 A、B、D、G、E、F、C、H。

广度优先搜索的代码如下所示：

```py
    from collections import deque 

    def breadth_first_search(graph, root): 
        visited_vertices = list() 
        graph_queue = deque([root]) 
        visited_vertices.append(root) 
        node = root 

        while len(graph_queue) > 0: 
            node = graph_queue.popleft() 
            adj_nodes = graph[node] 

            remaining_elements = 
                set(adj_nodes).difference(set(visited_vertices)) 
            if len(remaining_elements) > 0: 
                for elem in sorted(remaining_elements): 
                    visited_vertices.append(elem) 
                    graph_queue.append(elem) 

        return visited_vertices 
```

当我们想要找出一组节点是否在已访问节点的列表中时，我们使用语句`remaining_elements = set(adj_nodes).difference(set(visited_vertices))`。这使用了集合对象的差异方法来找出在`adj_nodes`中但不在`visited_vertices`中的节点。

在最坏的情况下，每个顶点或节点和边都将被遍历，因此算法的时间复杂度是`O(|V| + |E|)`，其中`|V|`是顶点或节点的数量，而`|E|`是图中边的数量。

# 深度优先搜索

正如其名称所示，该算法在遍历广度之前遍历图中任何特定路径的深度。因此，首先访问子节点，然后访问兄弟节点。它适用于有限图，并需要使用堆栈来维护算法的状态：

```py
    def depth_first_search(graph, root): 
        visited_vertices = list() 
        graph_stack = list() 

        graph_stack.append(root) 
        node = root 
```

算法首先创建一个列表来存储已访问的节点。`graph_stack`堆栈变量用于辅助遍历过程。为了连贯起见，我们使用普通的 Python 列表作为堆栈。

起始节点称为`root`，并与图的邻接矩阵`graph`一起传递。`root`被推入堆栈。`node = root`保存堆栈中的第一个节点：

```py
        while len(graph_stack) > 0: 

            if node not in visited_vertices: 
                visited_vertices.append(node) 

            adj_nodes = graph[node] 

            if set(adj_nodes).issubset(set(visited_vertices)): 
                graph_stack.pop() 
            if len(graph_stack) > 0: 
                node = graph_stack[-1] 
                continue 
            else: 
                remaining_elements = 
                set(adj_nodes).difference(set(visited_vertices)) 

            first_adj_node = sorted(remaining_elements)[0] 
            graph_stack.append(first_adj_node) 
            node = first_adj_node 
                return visited_vertices 
```

`while`循环的主体将被执行，前提是堆栈不为空。如果`node`不在已访问节点的列表中，我们将其添加进去。`node`的所有相邻节点都被`adj_nodes = graph[node]`收集起来。如果所有相邻节点都已经被访问过，我们就从堆栈中弹出该节点，并将`node`设置为`graph_stack[-1]`。`graph_stack[-1]`是堆栈顶部的节点。`continue`语句跳回到`while`循环的测试条件的开头。

另一方面，如果并非所有相邻节点都已经被访问，那么通过使用语句`remaining_elements = set(adj_nodes).difference(set(visited_vertices))`来找到尚未访问的节点。

在`sorted(remaining_elements)`中的第一个项目被分配给`first_adj_node`，并被推入堆栈。然后我们将堆栈的顶部指向这个节点。

当`while`循环结束时，我们将返回`visited_vertices`。

对算法进行干扰运行将会很有用。考虑以下图表：

![](img/9d0766e9-a5f6-44e9-94e9-430d7e17d19e.png)

这样一个图的邻接列表如下所示：

```py
    graph = dict() 
    graph['A'] = ['B', 'S'] 
    graph['B'] = ['A'] 
    graph['S'] = ['A','G','C'] 
    graph['D'] = ['C'] 
    graph['G'] = ['S','F','H'] 
    graph['H'] = ['G','E'] 
    graph['E'] = ['C','H'] 
    graph['F'] = ['C','G'] 
    graph['C'] = ['D','S','E','F'] 
```

节点 A 被选择为我们的起始节点。节点 A 被推入堆栈，并添加到`visisted_vertices`列表中。这样做时，我们标记它已经被访问。堆栈`graph_stack`是用简单的 Python 列表实现的。我们的堆栈现在只有 A 一个元素。我们检查节点 A 的相邻节点 B 和 S。为了测试节点 A 的所有相邻节点是否都已经被访问，我们使用 if 语句：

```py
    if set(adj_nodes).issubset(set(visited_vertices)): 
        graph_stack.pop() 
        if len(graph_stack) > 0: 
            node = graph_stack[-1] 
        continue 
```

如果所有节点都已经被访问，我们就弹出堆栈的顶部。如果堆栈`graph_stack`不为空，我们就将堆栈顶部的节点赋给`node`，并开始另一个`while`循环主体的执行。语句`set(adj_nodes).issubset(set(visited_vertices))`将在`adj_nodes`中的所有节点都是`visited_vertices`的子集时评估为`True`。如果 if 语句失败，这意味着还有一些节点需要被访问。我们可以通过`remaining_elements = set(adj_nodes).difference(set(visited_vertices))`获得这些节点的列表。

从图表中，节点**B**和**S**将被存储在`remaining_elements`中。我们将按字母顺序访问列表：

```py
    first_adj_node = sorted(remaining_elements)[0] 
    graph_stack.append(first_adj_node) 
    node = first_adj_node 
```

我们对`remaining_elements`进行排序，并将第一个节点返回给`first_adj_node`。这将返回 B。我们通过将其附加到`graph_stack`来将节点 B 推入堆栈。我们通过将其分配给`node`来准备访问节点 B。

在`while`循环的下一次迭代中，我们将节点 B 添加到`visited nodes`列表中。我们发现 B 的唯一相邻节点 A 已经被访问过。因为 B 的所有相邻节点都已经被访问，我们将其从堆栈中弹出，只留下节点 A。我们返回到节点 A，并检查它的所有相邻节点是否都已经被访问。现在节点 A 只有 S 是未访问的节点。我们将 S 推入堆栈，并重新开始整个过程。

遍历的输出是 A-B-S-C-D-E-H-G-F。

深度优先搜索在解决迷宫问题、查找连通分量和查找图的桥梁等方面有应用。

# 其他有用的图方法

您经常关心的是找到两个节点之间的路径。您可能还希望找到节点之间的所有路径。另一个有用的方法是找到节点之间的最短路径。在无权图中，这只是它们之间边的最小数量的路径。在加权图中，正如您所见，这可能涉及计算通过一组边的总权重。

当然，在不同的情况下，您可能希望找到最长或最短的路径。

# 优先队列和堆

优先队列基本上是一种按优先级顺序返回项目的队列类型。这个优先级可以是，例如，最低的项目总是先弹出。虽然它被称为队列，但优先队列通常使用堆来实现，因为对于这个目的来说非常高效。

考虑到，在商店中，顾客排队等候，服务只在队列的前面提供。每个顾客都会花一些时间在队列中等待服务。如果队列中顾客的等待时间分别为 4、30、2 和 1，那么队列中的平均等待时间变为`(4 + 34 + 36 + 37)/4`，即`27.75`。然而，如果我们改变服务顺序，使等待时间最短的顾客先接受服务，那么我们会得到不同的平均等待时间。这样做，我们通过`(1 + 3 + 7 + 37)/4`计算我们的新平均等待时间，现在等于`12`，一个更好的平均等待时间。显然，按照等待时间最少的顾客开始服务是有益的。按照优先级或其他标准选择下一个项目的方法是创建优先队列的基础。

堆是满足堆属性的数据结构。堆属性规定父节点和其子节点之间必须存在一定的关系。这个属性必须适用于整个堆。

在最小堆中，父节点和子节点之间的关系是父节点必须始终小于或等于其子节点。由于这个关系，堆中最小的元素必须是根节点。

另一方面，在最大堆中，父节点大于或等于其子节点。由此可知，最大值组成了根节点。

从我们刚刚提到的内容中可以看出，堆是树，更具体地说，是二叉树。

虽然我们将使用二叉树，但实际上我们将使用一个列表来表示它。这是可能的，因为堆将存储一个完全二叉树。完全二叉树是指在开始填充下一行之前，每一行必须完全填满：

![](img/69b6c928-300f-4b6f-a4f3-5e4d84c63cae.jpg)

为了使索引的数学运算更容易，我们将保留列表中的第一项（索引 0）为空。之后，我们将树节点从上到下、从左到右放入列表中：

![](img/908ee528-61fc-4fe4-8ed4-f9c34a763f6f.jpg)

如果你仔细观察，你会注意到你可以很容易地检索任何节点 n 的子节点。左子节点位于`2n`，右子节点位于`2n + 1`。这总是成立的。

我们将看一个最小堆的实现。反过来得到最大堆的逻辑应该不难。

```py
     class Heap: 
        def __init__(self): 
            self.heap = [0] 
            self.size = 0 
```

我们用零初始化我们的堆列表，以表示虚拟的第一个元素（请记住，我们只是为了简化数学而这样做）。我们还创建一个变量来保存堆的大小。这不是必需的，因为我们可以检查列表的大小，但我们总是要记得减去一个。所以我们选择保持一个单独的变量。

# 插入

插入一个项目本身非常简单。我们将新元素添加到列表的末尾（我们理解为树的底部）。然后我们将堆的大小增加一。

但是在每次插入后，如果需要，我们需要将新元素浮动起来。请记住，最小堆中最小的元素需要是根元素。我们首先创建一个名为`float`的辅助方法来处理这个问题。让我们看看它应该如何行为。想象一下我们有以下堆，并且想要插入值`2`：

![](img/e6a9c152-f5f6-4ca7-a420-cb01171a9ff2.jpg)

新元素占据了第三行或级别中的最后一个插槽。它的索引值是**7**。现在我们将该值与其父元素进行比较。父元素位于索引`7/2 = 3`（整数除法）。该元素持有**6**，所以我们交换**2**：

![](img/1646d43e-9a53-45d8-813b-7deece8019e7.jpg)

我们的新元素已经被交换并移动到索引**3**。我们还没有到达堆的顶部（`3 / 2 > 0`），所以我们继续。我们元素的新父节点在索引`3/2 = 1`。所以我们比较并且如果需要的话再次交换：

![](img/f1653f9b-b5d1-4651-a409-efb01743a112.jpg)

在最后一次交换之后，我们得到了以下堆。请注意它如何符合堆的定义：

![](img/e9ef20a5-3355-455b-a953-453641987aa6.jpg)

接下来是我们刚刚描述的实现：

```py
    def float(self, k): 
```

我们将循环直到达到根节点，以便我们可以将元素浮动到需要到达的最高位置。由于我们使用整数除法，一旦我们低于 2，循环就会中断：

```py
        while k // 2 > 0: 
```

比较父节点和子节点。如果父节点大于子节点，则交换两个值：

```py
        if self.heap[k] < self.heap[k//2]: 
            self.heap[k], self.heap[k//2] = self.heap[k//2], 
            self.heap[k] 
```

最后，不要忘记向上移动树：

```py
        k //= 2 
```

这个方法确保元素被正确排序。现在我们只需要从我们的`insert`方法中调用它：

```py
    def insert(self, item): 
        self.heap.append(item) 
        self.size += 1 
        self.float(self.size) 
```

注意`insert`中的最后一行调用了`float()`方法来根据需要重新组织堆。

# 弹出

就像插入一样，`pop()`本身是一个简单的操作。我们移除根节点并将堆的大小减一。然而，一旦根节点被弹出，我们需要一个新的根节点。

为了尽可能简单，我们只需取列表中的最后一个项目并将其作为新的根。也就是说，我们将它移动到列表的开头。但现在我们可能不会在堆的顶部有最小的元素，所以我们执行与`float`操作相反的操作：让新的根节点根据需要下沉。

与插入一样，让我们看看整个操作在现有堆上是如何工作的。想象一下以下堆。我们弹出`root`元素，暂时使堆没有根：

![](img/1eb8cd9b-d17d-4c76-8854-5bb8ca4edb34.jpg)

由于我们不能有一个没有根的堆，我们需要用某物填充这个位置。如果我们选择将一个子节点移上去，我们将不得不弄清楚如何重新平衡整个树结构。所以，我们做一些非常有趣的事情。我们将列表中的最后一个元素移上去填充`root`元素的位置：

![](img/85ef095d-22b3-450c-87b7-6e51d530ac49.jpg)

现在这个元素显然不是堆中最小的。这就是我们开始将其下沉的地方。首先我们需要确定将其下沉到哪里。我们比较两个子节点，以便较小的元素将作为根节点下沉时浮动上去：

![](img/13caacb4-06e6-4206-823c-720d634f2268.jpg)

右子节点显然更小。它的索引是**3**，代表根索引`* 2 + 1`。我们继续将我们的新根节点与该索引处的值进行比较：

![](img/c99e234d-5ac4-4f47-8083-768d443bb116.jpg)

现在我们的节点跳到了索引**3**。我们需要将其与较小的子节点进行比较。然而，现在我们只有一个子节点，所以我们不需要担心要与哪个子节点进行比较（对于最小堆来说，它总是较小的子节点）：

![](img/601969bf-ac39-4be8-8160-e2ec826e6e9a.jpg)

这里不需要交换。由于没有更多的行，我们完成了。请再次注意，在`sink()`操作完成后，我们的堆符合堆的定义。

现在我们可以开始实现这个。在执行`sink()`方法之前，注意我们需要确定要将父节点与哪个子节点进行比较。好吧，让我们把这个选择放在自己的小方法中，这样代码看起来会简单一些：

```py
    def minindex(self, k): 
```

我们可能会超出列表的末尾，在这种情况下，我们返回左子节点的索引：

```py
        if k * 2 + 1 > self.size: 
            return k * 2 
```

否则，我们只需返回较小的两个子节点的索引：

```py
        elif self.heap[k*2] < self.heap[k*2+1]: 
            return k * 2 
        else: 
            return k * 2 + 1 
```

现在我们可以创建`sink`函数：

```py
    def sink(self, k): 
```

与之前一样，我们将循环以便将我们的元素下沉到所需的位置：

```py
        while k * 2 <= self.size: 
```

接下来，我们需要知道左侧还是右侧的子节点进行比较。这就是我们使用`minindex()`函数的地方：

```py
            mi = self.minindex(k) 
```

就像我们在`float()`方法中所做的那样，我们比较父节点和子节点，看看是否需要交换：

```py
            if self.heap[k] > self.heap[mi]: 
                self.heap[k], self.heap[mi] = self.heap[mi], 
                self.heap[k] 
```

我们需要确保向下移动树，以免陷入循环：

```py
            k = mi 
```

现在唯一剩下的就是实现`pop()`本身。这非常简单，因为`sink()`方法执行了大部分工作：

```py
    def pop(self): 
        item = self.heap[1] 
        self.heap[1] = self.heap[self.size] 
        self.size -= 1 
        self.heap.pop() 
        self.sink(1) 
        return item
```

# 测试堆

现在我们只需要一些代码来测试堆。我们首先创建我们的堆并插入一些数据：

```py
    h = Heap() 
    for i in (4, 8, 7, 2, 9, 10, 5, 1, 3, 6): 
        h.insert(i) 
```

我们可以打印堆列表，只是为了检查元素的排序方式。如果你将其重新绘制为树形结构，你应该注意到它满足堆的所需属性：

```py
    print(h.heap) 
```

现在我们将一个一个地弹出项目。注意项目是如何按照从低到高的顺序出来的。还要注意每次弹出后堆列表是如何改变的。最好拿出纸和笔，在每次弹出后重新绘制这个列表作为一棵树，以充分理解`sink()`方法的工作原理：

```py
    for i in range(10): 
        n = h.pop() 
        print(n) 
        print(h.heap) 
```

在排序算法的章节中，我们将重新组织堆排序算法的代码。

一旦你的最小堆正常工作并且了解它的工作原理，实现最大堆应该是一项简单的任务。你所需要做的就是颠倒逻辑。

# 选择算法

选择算法属于一类算法，旨在解决在列表中找到第 i 小元素的问题。当列表按升序排序时，列表中的第一个元素将是列表中最小的项。列表中的第二个元素将是列表中第二小的元素。列表中的最后一个元素将是列表中最小的元素，但也将符合列表中最大的元素。

在创建堆数据结构时，我们已经了解到调用`pop`方法将返回堆中最小的元素。从最小堆中弹出的第一个元素是列表中第一个最小的元素。同样，从最小堆中弹出的第七个元素将是列表中第七小的元素。因此，要找到列表中第 i 小的元素，我们需要弹出堆*i*次。这是在列表中找到第 i 小的元素的一种非常简单和高效的方法。

但在第十四章中，*选择算法*，我们将学习另一种方法，通过这种方法我们可以在列表中找到第 i 小的元素。

选择算法在过滤嘈杂数据、查找列表中的中位数、最小和最大元素以及甚至可以应用于计算机国际象棋程序中。

# 摘要

本章讨论了图和堆。我们研究了使用列表和字典在 Python 中表示图的方法。为了遍历图，我们研究了广度优先搜索和深度优先搜索。

然后我们将注意力转向堆和优先队列，以了解它们的实现。本章以使用堆的概念来找到列表中第 i 小的元素而结束。

图的主题非常复杂，仅仅一章是不够的。与节点的旅程将在本章结束。下一章将引领我们进入搜索的领域，以及我们可以有效搜索列表中项目的各种方法。
