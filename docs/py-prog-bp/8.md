# 八、订单微服务

在本章中，我们将与 Django 一起扩展我们在[第 7 章](7.html)、*在线视频游戏商店中实现的 web 应用。我不知道你是否注意到了，但在这个项目中有一些重要的东西遗漏了。首先是提交订单的能力。到目前为止，用户可以浏览产品并将物品添加到购物车中；但是，无法发送订单并完成购买。*

缺少的另一项是一个页面，在该页面中，我们应用的用户将能够看到所有已发送的订单，以及他们订单的历史记录。

话虽如此，我们将创建一个名为*订单*的微服务，它将完成与网站上订单相关的所有工作。它将接收订单、更新订单等。

在本章中，您将学习：

*   如何创建微服务的基础知识
*   如何使用 Django REST 框架创建 RESTful API
*   如何使用服务并将其与其他应用集成
*   如何编写测试
*   如何在 AWS 上部署应用
*   如何在 HTTP 代理`nginx`后面使用 Gunicorn 运行我们的 web 应用

那么，让我们开始吧！

# 建立环境

与前面的所有章节一样，我们将从本章开始，设置开发服务所需的环境。让我们从创建工作目录开始：

```py
mkdir microservices && cd microservices
```

然后，我们用`pipenv`创建我们的虚拟环境：

```py
pipenv --python ~/Install/Python3.6/bin/python3.6
```

If you don't know how to use `pipenv`, in the section *Setting up the environment* in [Chapter 4](4.html), *Exchange Rates and the Currency Conversion Tool,* there is a very good introduction about how to get started with `pipenv`.

创建虚拟环境后，我们需要安装项目依赖项。对于这个项目，我们将安装 Django 和 Django REST 框架：

```py
pipenv install django djangorestframework requests python-dateutil
```

我们之所以使用 Django 和 Django REST 框架而不是像 Flask 这样更简单的框架，是因为这个项目的主要思想是提供关注点分离，创建一个微服务来处理我们在上一章中开发的在线游戏商店中的订单。我们不希望只提供 web 应用使用的 API。如果有一个简单的网站，我们就可以列出订单，查看每个订单的详细信息，还可以执行更新，例如更改订单的状态，那就太好了。
正如您在上一章中所看到的，Django 已经有了一个非常强大和灵活的管理 UI，我们可以定制它来为用户提供这种功能，而无需花费太多时间开发 web 应用。

安装依赖项后，您的`Pipfile`应该如下所示：

```py
[[source]]

verify_ssl = true
name = "pypi"
url = "https://pypi.python.org/simple"

[packages]

django = "*"
djangorestframework = "*"

[dev-packages]

[requires]

python_version = "3.6"
```

完美的现在，我们可以开始一个新的 Django 项目。我们将使用`django-admin`工具创建项目。让我们继续创建一个名为`order`的项目：

```py
django-admin startproject order
```

创建项目后，我们将创建一个 Django 应用。对于这个项目，我们将只创建一个名为`main`的应用。首先，我们将目录更改为服务目录：

```py
cd order
```

同样，我们使用`django-admin`工具创建一个应用：

```py
django-admin startapp main
```

创建 Django 应用后，您的项目结构应类似于以下结构：

```py
.
├── main
│   ├── admin.py
│   ├── apps.py
│   ├── __init__.py
│   ├── migrations
│   │   └── __init__.py
│   ├── models.py
│   ├── tests.py
│   └── views.py
├── manage.py
└── order
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py
```

接下来，我们将开始为我们的服务创建模型。

# 创建服务模型

在订单服务的第一部分中，我们将创建一个模型来存储来自在线视频游戏商店的订单数据。让我们继续，打开主应用目录中的`models.py`文件，开始添加模型：

```py
class OrderCustomer(models.Model):
    customer_id = models.IntegerField()
    name = models.CharField(max_length=100)
    email = models.CharField(max_length=100)
```

我们将创建一个名为`OrderCustomer`的类，该类继承自`Model`，并定义三个属性；`customer_id`，对应网游商店中的客户 ID，客户的`name`，最后是`email`。

然后，我们将创建存储订单信息的模型：

```py
class Order(models.Model):

    ORDER_STATUS = (
        (1, 'Received'),
        (2, 'Processing'),
        (3, 'Payment complete'),
        (4, 'Shipping'),
        (5, 'Completed'),
        (6, 'Cancelled'),
    )

    order_customer = models.ForeignKey(
        OrderCustomer, 
        on_delete=models.CASCADE
    )    
    total = models.DecimalField(
        max_digits=9,
        decimal_places=2,
        default=0
    )
    created_at = models.DateTimeField(auto_now_add=True)
    last_updated = models.DateTimeField(auto_now=True)
    status = models.IntegerField(choices=ORDER_STATUS, default='1')   
```

`Order`类继承自`Model`，我们通过添加一个元组来启动该类，该元组包含应用中的订单可以具有的状态。我们还定义了一个外键`order_customer`，它将创建`OrderCustomer`和`Order`之间的关系。然后是时候定义其他字段了，从`total`开始，这是该订单的总购买价值。然后我们有两个 datetime 字段；`created_at`是客户提交订单的日期，`last_update`是我们想知道订单何时有状态更新时要使用的字段。

When adding `auto_now_add` to a `DateTimeField`, Django uses the `django.utils.timezone.now` function, which will return the current `datetime` object with timezone information. DateField uses `datetime.date.today()`, which does not contain timezone information.

我们要创建的最后一个模型是`OrderItems`。这将保存属于订单的项目。我们将这样定义它：

```py
class OrderItems(models.Model):
    class Meta:
        verbose_name_plural = 'Order items'

    product_id = models.IntegerField()
    name = models.CharField(max_length=200)
    quantity = models.IntegerField()
    price_per_unit = models.DecimalField(
        max_digits=9,
        decimal_places=2,
        default=0 
    )
    order = models.ForeignKey(
        Order, on_delete=models.CASCADE, related_name='items')
```

这里，我们还定义了一个`Meta`类，这样我们就可以为模型设置一些元数据。在本例中，我们将`verbose_name_plural`设置为`Order items`，以便它在 Django 管理 UI 中看起来拼写正确。然后，我们定义了`product_id`、`name`、`quantity`和`price_per_unit`，这是指在线游戏商店中的`Game`模型。
最后，我们有项目数量和外键`Order`。

现在，我们需要编辑`microservices/order/order`目录中的`settings.py`文件，并将主应用添加到`INSTALLED_APPS`。应该是这样的：

```py
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'main',
]
```

唯一剩下的就是创建和应用数据库迁移。首先，我们运行命令`makemigrations`：

```py
python manage.py makemigrations
```

以及`migrate`将更改应用于数据库：

```py
python manage.py migrate
```

# 创建模型的管理器

为了使我们的应用更具可读性，并且不让端点因大量业务逻辑而混乱，我们将为我们的模型类创建管理器。如果您遵循上一章，您应该非常熟悉这一点。简而言之，管理器是一个向 Django 模型提供查询操作的接口。

By default, Django adds a manager to every model; it is stored on a property named objects. The default manager that Django adds to the models is sometimes sufficient and there's no need to create a custom manager, but it is a good practice to keep all database-related code within the model. This will make our code more consistent, readable, and easier to test and maintain.

在我们的例子中，我们感兴趣创建的唯一模型是一个名为 Order 的自定义模型管理器，但是在开始实现 Order 管理器之前，我们需要创建几个 helper 类。我们需要创建的第一个类将定义在数据库上执行查询时可能发生的自定义异常。当然，我们可以使用标准库中已经定义的异常，但在应用上下文中创建有意义的异常始终是一种好的做法。
我们要创建的三个例外是`InvalidArgumentError`、`OrderAlreadyCompletedError`和`OrderCancellationError`。

当将无效参数传递给我们将在管理器中定义的函数时，将引发异常`InvalidArgumentError`，因此让我们继续在主应用目录中创建一个名为`exceptions.py`的文件，该文件包含以下内容：

```py
class InvalidArgumentError(Exception):
    def __init__(self, argument_name):
        message = f'The argument {argument_name} is invalid'
        super().__init__(message)
```

在这里，我们定义了一个名为`InvalidArgumentError`的类，它继承自`Exception`，我们在其中所做的唯一一件事就是重写构造函数并接收一个名为`argument_name`的参数。通过这个参数，我们可以指定引发异常的原因。

我们还将自定义异常消息，最后，我们将调用超类上的构造函数。

我们还将创建一个异常，当我们尝试取消状态为“已取消”的订单时，以及当我们尝试在订单已完成时将订单状态设置为“已完成”时，将引发该异常：

```py
class OrderAlreadyCompletedError(Exception):
    def __init__(self, order):
        message = f'The order with ID: {order.id} is already  
        completed.'
        super().__init__(message)

class OrderAlreadyCancelledError(Exception):
    def __init__(self, order):
        message = f'The order with ID: {order.id} is already  
        cancelled.'
        super().__init__(message)
```

然后，我们将再添加两个自定义异常：

```py
class OrderCancellationError(Exception):
    pass

class OrderNotFoundError(Exception):
    pass
```

这两门课做的不多。他们只从`Exception`继承。我们将为每个异常配置和自定义一条消息，并将其传递给超级类初始值设定项。添加自定义异常类的价值在于，它将提高应用的可读性和可维护性。

伟大的在开始与经理交谈之前，我们只需要补充一件事。我们将在模型管理器中创建函数，返回按状态筛选的数据。如您所见，在`Order`模型的定义中，我们定义了如下状态：

```py
ORDER_STATUS = (
    (1, 'Received'),
    (2, 'Processing'),
    (3, 'Payment complete'),
    (4, 'Shipping'),
    (5, 'Completed'),
    (6, 'Cancelled'),
)
```

这意味着，如果我们想要获得状态为`Completed`的所有订单，我们需要写类似于以下行的内容：

```py
  Order.objects.filter(status=5)
```

这个代码只有一个问题，你猜怎么着？如果你猜到了*魔法*数字`5`，你绝对是对的！想象一下，如果我们的同事需要维护这个代码，只看到数字`5`，却不知道 5 到底意味着什么，他们会多么沮丧。因此，我们将创建一个枚举，用于表示不同的状态。让我们在`main`应用目录中创建一个名为`status.py`的文件，并添加以下枚举：

```py
from enum import Enum, auto

class Status(Enum):
    Received = auto()
    Processing = auto()
    Payment_Complete = auto()
    Shipping = auto()
    Completed = auto()
    Cancelled = auto()
```

所以，现在，当我们需要获得所有状态为`Completed`的订单时，我们可以做：

```py
Order.objects.filter(Status.Received.value)
```

好多了！

现在，让我们为它创建模型管理器。在 mail app 目录中创建一个名为`managers.py`的文件，我们可以从添加几个导入开始：

```py
from datetime import datetime
from django.db.models import Manager, Q

from .status import Status

from .exceptions import InvalidArgumentError
from .exceptions import OrderAlreadyCompletedError
from .exceptions import OrderCancellationError

from . import models
```

然后，我们定义了`OrderManager`类和第一个名为`set_status`的方法：

```py
class OrderManager(Manager):

    def set_status(self, order, status):
        if status is None or not isinstance(status, Status):
            raise InvalidArgumentError('status')

        if order is None or not isinstance(order, models.Order):
            raise InvalidArgumentError('order')

        if order.status is Status.Completed.value:
            raise OrderAlreadyCompletedError()

        order.status = status.value
        order.save()
```

此方法采用两个参数：顺序和状态。`order`是`Order`类型的对象，状态是我们之前创建的`Status`枚举的一项。

我们通过验证参数并引发相应的异常来启动此方法。首先，我们验证字段是否有值并且类型是否正确。如果验证失败，则会引发`InvalidArgumentError`。然后，我们检查试图设置状态的订单是否已经完成；在这种情况下，我们无法再更改它，因此我们提出了一个`OrderAlreadyCompletedError`。如果所有参数都有效，我们将设置订单的状态并保存。

在我们的应用中，我们希望能够取消尚未处理的订单；换句话说，只有状态为`Received`时，我们才允许取消订单。以下是`cancel_order`方法的外观：

```py
def cancel_order(self, order):
    if order is None or not isinstance(order, models.Order):
        raise InvalidArgumentError('order')

    if order.status != Status.Received.value:
        raise OrderCancellationError()

    self.set_status(order, Status.Cancelled)
```

此方法只获取`order`参数，首先需要检查 order 对象是否有效，如果无效则引发`InvalidArgumentError`。然后检查订单状态是否为`not Received`。在这种情况下，我们提出一个`OrderCancellationError`异常。否则，我们继续调用`set_status`方法，将`Status.Cancelled`作为参数传递。

我们还需要获得给定客户的所有订单列表：

```py
def get_all_orders_by_customer(self, customer_id):
    try:
        return self.filter(
            order_customer_id=customer_id).order_by(
            'status', '-created_at')
    except ValueError:
        raise InvalidArgumentError('customer_id')
```

`get_all_orders_by_customer`方法获取`customer_id`作为参数，然后使用 filter 函数按`customer_id`过滤订单，也按状态排序；仍在处理中的订单将位于查询集的顶部。

如果`customer_id`无效，例如，如果我们传递的是字符串而不是整数，则会引发`ValueError`异常。我们捕获此异常并引发自定义异常`InvalidArgumentError`。

我们在线游戏商店的财务部门要求为特定用户获取所有完整和不完整订单的列表，因此让我们继续添加一些方法：

```py
def get_customer_incomplete_orders(self, customer_id):
    try:
        return self.filter(
            ~Q(status=Status.Completed.value),
            order_customer_id=customer_id).order_by('status')
    except ValueError:
        raise InvalidArgumentError('customer_id')

def get_customer_completed_orders(self, customer_id):
    try:
        return self.filter(
            status=Status.Completed.value,
            order_customer_id=customer_id)
    except ValueError:
        raise InvalidArgumentError('customer_id')
```

第一个方法`get_customer_incomplete_orders`获取一个名为`customer_id`的参数。与前一种方法相同；如果`customer_id`无效，我们将捕获一个`ValueError`异常，并提出一个`InvalidArgumentError`。这个方法的有趣部分是过滤器。这里，我们使用一个`Q()`对象，它以`Python`对象的形式封装了一个 SQL 表达式。

这里我们有`~Q(status=Status.Completed.value)`，它是`not`操作符，这与说状态不是`Status.Complete`是一样的。我们还过滤`order_customer_id`以检查它是否等于该方法的`customer_id`参数，最后，我们按状态排序 QuerySet。

`get_customer_completed_orders`基本相同，但这次我们过滤状态等于`Status.Completed`的订单。

`Q()`对象允许我们使用`|`（OR）和`&`（and）运算符编写更复杂的查询。

其次，每个负责处理订单生命周期的部门都希望在特定阶段获得订单的简单方法；例如，负责运送游戏的工作人员希望获得状态为`Payment Complete`的所有订单的列表，以便将这些订单运送给客户。因此，我们需要添加一种方法来实现这一点：

```py
def get_orders_by_status(self, status):
    if status is None or not isinstance(status, Status):
        raise InvalidArgumentError('status')

    return self.filter(status=status.value)
```

这是一个非常简单的方法；这里，我们将状态作为参数。我们检查状态是否有效；如果没有，我们将提出一个`InvalidArgumentError`。否则，我们将继续并按状态筛选订单。

我们财务部门的另一项要求是获取给定日期范围内的订单列表：

```py
def get_orders_by_period(self, start_date, end_date):
    if start_date is None or not isinstance(start_date, datetime):
        raise InvalidArgumentError('start_date')

    if end_date is None or not isinstance(end_date, datetime):
        raise InvalidArgumentError('end_date')

    result = self.filter(created_at__range=[start_date, end_date])
    return result
```

这里，我们得到两个参数，`start_date`和`end_date`。与所有其他方法一样，我们首先检查这些参数是否有效；在这种情况下，参数不能是`None`，必须是`Datetime`对象的实例。如果任何字段无效，将引发一个`InvalidArgumentError`。当参数有效时，我们使用`created_at`字段过滤订单，我们还使用这种特殊语法`created_at__range`，这意味着我们将传递一个日期范围，它将用作过滤器。在这里，我们经过`start_date`和`end_date`。

只有一种方法可以实现，它可以为应用的管理员增加价值。这里的想法是添加一个方法，该方法在调用时自动将顺序更改为下一个状态：

```py
def set_next_status(self, order):
    if order is None or not isinstance(order, models.Order):
        raise InvalidArgumentError('order')

    if order.status is Status.Completed.value:
        raise OrderAlreadyCompletedError()

    order.status += 1
    order.save()
```

这个方法只得到一个参数，order。我们检查订单是否有效，如果无效，我们提出`InvalidArgumentError`。我们还希望确保订单一旦进入`Completed`状态，就不能再进行更改。因此，我们检查订单的状态是否为`Completed`，然后我们提出`OrderAlreadyCompleted`异常。最后，我们将`1`添加到当前状态并保存对象。

现在，我们可以修改我们的`Order`模型，以便它利用我们刚刚创建的`OrderManager`。打开主 app 目录中的 model.py 文件，在`Order`类末尾添加以下行：

```py
objects = OrderManager()
```

现在我们可以访问我们在`OrderManager`到`Order.objects`中定义的所有方法。

接下来，我们将向模型管理器方法添加测试。

# 学习测试

到目前为止，在本书中，我们还没有介绍如何创建测试。现在是这样做的好时机，所以我们将为我们在模型管理器中创建的方法创建测试。

为什么我们需要测试？这个问题的简单答案是，测试将让我们知道方法或函数正在做正确的事情。另一个原因（在我看来，也是最重要的原因之一）是测试在执行代码更改时给了我们更多的信心。

Django 提供了用于创建单元和集成测试的现成工具，并与 Selenium 等框架相结合，基本上可以测试我们的所有应用。

话虽如此，让我们创建第一个测试。Django 在创建新的 Django 应用时，会在`app`目录中创建一个名为`test.py`的文件。您可以在其中编写测试，或者如果您希望通过将测试分离为多个文件来保持项目的组织性，您可以删除该文件并创建一个名为`tests`的目录，并将所有测试文件放在其中。因为我们只为订单模型管理器创建测试，所以我们将把所有测试都保存在 Django 为我们创建的`tests.py`文件中。

# 创建测试文件

打开`test.py`文件，让我们从添加几个导入开始：

```py
from dateutil.relativedelta import relativedelta

from django.test import TestCase
from django.utils import timezone

from .models import OrderCustomer, Order
from .status import Status

from .exceptions import OrderAlreadyCompletedError
from .exceptions import OrderCancellationError
from .exceptions import InvalidArgumentError
```

伟大的我们从导入相对增量函数开始，这样我们就可以轻松地执行日期操作，比如为日期添加天数或月份。当测试在一定时间内获取订单的方法时，这将非常有用。

现在，我们导入一些与 Django 相关的东西。首先是`TestCase`类，它是`unittest.TestCase`的一个子类。因为我们要编写与数据库交互的测试，所以最好使用`django.tests.TestCase`而不是`unittest.TestCase`。Django 的`TestCase`实现将确保您的测试在事务中运行，以提供隔离。这样，我们在运行测试时不会因为测试套件中另一个测试创建的数据而产生不可预测的结果。
我们还导入了一些我们将在测试中使用的模型类，`Order`、`OrderCustomer`模型，以及在测试更改订单状态的方法时使用的状态类。

在为您的应用编写测试时，我们不希望只测试*良好*场景，我们还希望在出现问题时进行测试，并将错误参数传递给正在测试的函数和方法。出于这个原因，我们正在导入自定义错误类，因此我们可以确保在正确的情况下引发正确的异常。

现在我们已经准备好了导入，现在是创建类和方法的时候了，该类和方法将为我们的测试设置数据：

```py
class OrderModelTestCase(TestCase):

    @classmethod
    def setUpTestData(cls):
        cls.customer_001 = OrderCustomer.objects.create(
            customer_id=1,
            email='customer_001@test.com'
        )

        Order.objects.create(order_customer=cls.customer_001)

        Order.objects.create(order_customer=cls.customer_001,
                             status=Status.Completed.value)

        cls.customer_002 = OrderCustomer.objects.create(
            customer_id=1,
            email='customer_002@test.com'
        )

        Order.objects.create(order_customer=cls.customer_002)
```

在这里，我们创建一个名为`OrderModelTestCase`的类，继承自`django.test.TestCase`。然后，我们定义了`setUpTestData`方法，该方法将负责设置每个测试使用的数据。

在这里，我们创建两个用户；第一个有两个订单，其中一个订单设置为`Completed`。第二个用户只有一个订单。

# 测试取消订单功能

我们要测试的第一种方法是`cancel_orders`方法。顾名思义，它将取消订单。在这种方法中，我们需要测试以下几点：

*   第一个测试非常简单；我们只想测试是否可以取消订单，将其状态设置为`Cancelled`
*   第二个测试是不可能取消尚未收到的订单；也就是说，只有当前状态设置为`Received`的订单才能取消
*   我们需要测试在向`cancel_order`方法传递无效参数的情况下是否引发了正确的异常

话虽如此，让我们添加我们的测试：

```py
def test_cancel_order(self):
    order = Order.objects.get(pk=1)

    self.assertIsNotNone(order)
    self.assertEqual(Status.Received.value, order.status)

    Order.objects.cancel_order(order)

    self.assertEqual(Status.Cancelled.value, order.status)

def test_cancel_completed_order(self):
    order = Order.objects.get(pk=2)

    self.assertIsNotNone(order)
    self.assertEqual(Status.Completed.value, order.status)

    with self.assertRaises(OrderCancellationError):
        Order.objects.cancel_order(order)

def test_cancel_order_with_invalid_argument(self):
    with self.assertRaises(InvalidArgumentError):
        Order.objects.cancel_order({'id': 1})
```

第一个测试`test_cancel_order`首先获取 ID 为 1 的订单。我们断言返回的值不是使用`assertIsNotNone`函数的`None`，我们还使用`assertEqual`函数来确保订单的状态为“`Received`。

然后，我们从传递订单的订单模型管理器调用`cancel_order`方法，最后，我们再次使用`assertEqual`函数来验证订单的状态实际上已更改为`Cancelled`。

第二个测试`test_cancel_complated_order`首先获取 ID 等于`2`的订单；请记住，我们已将此订单设置为`Completed`状态。然后，我们做与前面测试相同的事情；我们确认订单不等于`None`，并且我们确认状态设置为`Complete`。最后，我们使用`assertRaises`函数测试，如果我们试图取消已经取消的订单，是否会引发正确的异常；在这种情况下，将引发类型为`OrderCancellationError`的异常。

最后，我们有`test_cancel_order_with_invalid_argument`函数，它将测试如果我们将无效参数传递给`cancel_order`函数，是否会引发正确的异常。

# 测试 get all orders 函数

现在，我们将在`get_all_orders_by_customer`方法中添加测试。对于这种方法，我们需要测试：

*   如果在给定客户 ID 时返回了正确数量的订单
*   如果向方法传递无效参数时引发了正确的异常

```py
def test_get_all_orders_by_customer(self):
    orders = Order.objects.get_all_orders_by_customer(customer_id=1)

    self.assertEqual(2, len(orders),
                     msg='It should have returned 2 orders.')

def test_get_all_order_by_customer_with_invalid_id(self):
    with self.assertRaises(InvalidArgumentError):
        Order.objects.get_all_orders_by_customer('o')
```

`get_all_orders_by_customer`方法的测试非常简单。在第一个测试中，我们为 ID 为`1`的客户获取订单，并测试返回的项目数是否等于`2`。

在第二个测试中，我们断言如果使用无效参数调用`get_all_orders_by_customer`，实际上会引发类型为`InvalidArgumentError`的异常。在这种情况下，测试将成功通过。

# 获取客户未完成的订单

`get_customer_incomplete_orders`方法返回与给定客户 ID 的`Completed`状态不同的所有订单。对于此测试，我们需要验证：

*   该方法返回正确数量的项目，并且如果返回的项目的状态不等于`Completed`
*   我们将测试在将无效值作为参数传递到此方法时是否引发异常

```py
def test_get_customer_incomplete_orders(self):
    orders = Order.objects.get_customer_incomplete_orders(customer_id=1)

    self.assertEqual(1, len(orders))
    self.assertEqual(Status.Received.value, orders[0].status)

def test_get_customer_incomplete_orders_with_invalid_id(self):
    with self.assertRaises(InvalidArgumentError):
        Order.objects.get_customer_incomplete_orders('o')
```

测试`test_get_customer_incomplete_orders`首先调用`get_customer_incomplete_orders`函数，并将等于`1`的客户 ID 作为参数传递。然后，我们验证返回项目的数量是否正确；在这种情况下，只有一个未完成的订单，所以应该是`1`。最后，我们检查返回的项目是否具有与`Completed`不同的状态。

另一个测试与前一个测试异常的测试完全相同，只调用该方法并断言已引发正确的异常。

# 获取客户已完成的订单

接下来，我们将测试`get_customer_completed_order`。这个方法，顾名思义，返回给定客户状态为`Completed`的所有订单。在这里，我们将测试与`get_customer_incompleted_orders`相同的场景：

```py
def test_get_customer_completed_orders(self):
    orders = Order.objects.get_customer_completed_orders(customer_id=1)

    self.assertEqual(1, len(orders))
    self.assertEqual(Status.Completed.value, orders[0].status)

def test_get_customer_completed_orders_with_invalid_id(self):
    with self.assertRaises(InvalidArgumentError):
        Order.objects.get_customer_completed_orders('o')
```

首先，我们调用`get_customer_completed_orders`，传递一个等于`1`的客户 ID，然后我们验证返回的项目数是否等于`1`。为了完成它，我们验证返回的项目实际上具有设置为`Completed`的状态。

# 按状态获取订单

`get_order_by_status`函数返回给定状态的订单列表。我们必须在这里测试两个场景：

*   如果该方法返回给定特定状态的正确订单数
*   向方法传递无效参数时引发正确的异常

```py
def test_get_order_by_status(self):
    order = Order.objects.get_orders_by_status(Status.Received)

    self.assertEqual(2, len(order),
                     msg=('There should be only 2 orders '
                          'with status=Received.'))

    self.assertEqual('customer_001@test.com',
                     order[0].order_customer.email)

def test_get_order_by_status_with_invalid_status(self):
    with self.assertRaises(InvalidArgumentError):
        Order.objects.get_orders_by_status(1)
```

很简单。我们调用的第一个测试是`get_orders_by_status`，作为参数`Status.Received`传递。然后，我们验证只返回了两个订单。
对于第二个测试，对于`get_order_by_status`方法，与前面的异常测试一样，运行该方法，传递一个无效参数，然后验证是否引发了类型为`InvalidArgumentError`的异常。

# 按时段获取订单

现在，我们将测试`get_order_by_period`方法，该方法返回给定初始日期和结束日期的订单列表。对于此方法，我们将执行以下测试：

*   调用该方法，作为参数传递，并应返回在该期间内创建的命令
*   调用该方法，作为参数传递我们知道没有创建订单的有效日期，这将返回一个空结果
*   测试调用方法时是否引发异常，传递的开始日期无效
*   测试调用方法时是否引发异常，传递的结束日期无效

```py
def test_get_orders_by_period(self):

    date_from = timezone.now() - relativedelta(days=1)
    date_to = date_from + relativedelta(days=2)

    orders = Order.objects.get_orders_by_period(date_from, date_to)

    self.assertEqual(3, len(orders))

    date_from = timezone.now() + relativedelta(days=3)
    date_to = date_from + relativedelta(months=1)

    orders = Order.objects.get_orders_by_period(date_from, date_to)

    self.assertEqual(0, len(orders))

def test_get_orders_by_period_with_invalid_start_date(self):
    start_date = timezone.now()

    with self.assertRaises(InvalidArgumentError):
        Order.objects.get_orders_by_period(start_date, None)

def test_get_orders_by_period_with_invalid_end_date(self):
    end_date = timezone.now()

    with self.assertRaises(InvalidArgumentError):
        Order.objects.get_orders_by_period(None, end_date)
```

我们通过创建`date_from`开始这个方法，它是当前日期减去一天。这里，我们使用`python-dateutil`包的`relativedelta`方法来执行日期操作。然后，我们定义了`date_to`，即当前日期加上两天。

现在我们有了周期，我们可以将这些值作为参数传递给`get_orders_by_period`方法。在我们的例子中，我们设置了三个订单，所有订单都是以当前日期创建的，所以这个方法调用应该返回三个订单。

然后，我们定义一个不同的时期，我们知道不会有任何订单。`date_from`函数定义为当前日期加三天，因此`date_from`为当前日期加`1`月。

再次调用传递新值`date_from`和`date_to`的方法不应返回任何订单。

`get_orders_by_period`的最后两个测试与我们之前实现的异常测试相同。

# 设置订单的下一个状态

我们将要创建的`Order`模型管理器的下一个方法是`set_next_status`方法。`set_next_status`方法只是为了方便而使用的一种方法，它将设置订单的下一个状态。如果您还记得，我们创建的`Status`枚举意味着枚举中的每个项都设置为`auto()`，这意味着枚举中的项将获得一个数字序列号作为值。

当我们在数据库中保存订单并将其状态设置为，例如，`Status.Processing`，数据库中状态字段的值将为`2`。

该函数只是将`1`添加到当前订单的状态，因此除非状态为`Completed`，否则会转到下一个状态项；这是订单生命周期的最后一个状态。

现在，我们已经刷新了关于此方法如何工作的记忆，现在是为其创建测试的时候了，我们将必须执行以下测试：

*   调用`set_next_status`时，订单获得下一个状态
*   测试调用`set_next_status`并将状态为`Completed`的订单作为参数传递时是否会引发异常
*   测试在将无效顺序作为参数传递时是否引发异常

```py
def test_set_next_status(self):
    order = Order.objects.get(pk=1)

    self.assertTrue(order is not None,
                    msg='The order is None.')

    self.assertEqual(Status.Received.value, order.status,
                     msg='The status should have been 
                     Status.Received.')

    Order.objects.set_next_status(order)

    self.assertEqual(Status.Processing.value, order.status,
                     msg='The status should have been 
                     Status.Processing.')

def test_set_next_status_on_completed_order(self):
    order = Order.objects.get(pk=2)

    with self.assertRaises(OrderAlreadyCompletedError):
        Order.objects.set_next_status(order)

def test_set_next_status_on_invalid_order(self):
    with self.assertRaises(InvalidArgumentError):
        Order.objects.set_next_status({'order': 1})
```

第一个测试`test_set_next_status`首先获取 ID 等于`1`的订单。然后，它断言 order 对象不等于 none，并且我们还断言 order 的 status 的值为`Received`。然后，我们调用`set_next_status`方法，将`order`作为参数传递。紧接着，我们再次断言，以确保状态已更改。如果订单状态为`2`，即`Status`枚举中的`Processing`，则测试通过。

另外两个测试与我们断言异常的订单测试非常相似，但值得一提的是，测试`test_set_next_status_on_completed_order`断言，如果我们尝试在状态等于`Status.Completed`的订单上调用`set_next_status`，则会引发`OrderAlreadyCompletedError`类型的异常。

# 设置订单的状态

最后，我们将实现`Order`模型管理器的最后测试。我们将为`set_status`方法创建测试。`set_status`方法完全按照名称的含义执行；它将设置给定订单的状态。我们需要执行以下测试：

*   设置状态并验证订单的状态确实已更改
*   在已完成的订单中设置状态；它应该引发类型为`OrderAlreadyCompletedError`的异常
*   设置已取消订单的状态；它应该引发类型为`OrderAlreadyCancelledError`的异常
*   使用无效命令调用`set_status`方法；它应该引发类型为`InvalidArgumentError`的异常
*   使用无效状态调用`set_status`方法；它应该引发类型为`InvalidArgumentError`的异常

```py
def test_set_status(self):
    order = Order.objects.get(pk=1)

    Order.objects.set_status(order, Status.Processing)

    self.assertEqual(Status.Processing.value, order.status)

def test_set_status_on_completed_order(self):
    order = Order.objects.get(pk=2)

    with self.assertRaises(OrderAlreadyCompletedError):
        Order.objects.set_status(order, Status.Processing)

def test_set_status_on_cancelled_order(self):
    order = Order.objects.get(pk=1)
    Order.objects.cancel_order(order)

    with self.assertRaises(OrderAlreadyCancelledError):
        Order.objects.set_status(order, Status.Processing)

def test_set_status_with_invalid_order(self):
    with self.assertRaises(InvalidArgumentError):
        Order.objects.set_status(None, Status.Processing)

def test_set_status_with_invalid_status(self):
    order = Order.objects.get(pk=1)

    with self.assertRaises(InvalidArgumentError):
        Order.objects.set_status(order, {'status': 1})
```

我们不会经历所有测试异常的测试，因为它们与我们之前实现的测试类似，但值得经历第一次测试。在测试`test_set_status`中，它将获得 ID 等于`1`的订单，正如我们在`setUpTestData`中定义的，其状态等于`Status.Received`。我们调用`set_status`方法，将订单和新状态作为参数传递，在本例中称为`Status.Processing`。在设置了新的状态后，我们只需调用`assertEquals`，以确保订单的状态实际上已更改为`Status.Processing`。

# 创建订单模型序列化程序

我们现在已经具备了开始创建 API 端点所需的一切。在本节中，我们将为在`Order`管理器中实现的每个方法创建端点。

对于其中一些端点，我们将使用 Django REST 框架。使用 Django REST 框架的优点是该框架包含许多现成的特性。它有不同的认证方法，一个非常健壮的对象序列化，我最喜欢的是它将为您提供一个 web 界面，您可以在其中浏览 API，当您需要创建基于类的视图时，它还包含大量的基类和混合类。

那么，让我们直接投入其中吧！

此时我们需要做的第一件事是为模型的实体创建序列化器类，`Order`、`OrderCustomer`和`OrderItem`。

继续在主目录`app`中创建一个名为`serializers.py`的文件，我们先添加几个导入语句：

```py
import functools

from rest_framework import serializers

from .models import Order, OrderItems, OrderCustomer
```

我们首先从标准库导入`functools`模块；然后，我们从`rest_framework`模块导入序列化程序。我们将使用它来创建我们的模型序列化程序。最后，我们将导入用于创建`serializers`、`Order`、`OrderItems`和`OrderCustomer`的模型。

我们要创建的第一个序列化程序是`OrderCustomerSerializer`：

```py
class OrderCustomerSerializer(serializers.ModelSerializer):
    class Meta:
        model = OrderCustomer
        fields = ('customer_id', 'email', 'name', )
```

`OrderCustomerSerializer`继承自`ModelSerializer`且相当简单；它只是定义了一些类元数据。我们将设置模型，`OrderCustomer,`以及属性字段，这些字段将包含一个元组和字段，我们将序列化这些字段。

然后，我们创建`OrderItemSerializer`：

```py
class OrderItemSerializer(serializers.ModelSerializer):
    class Meta:
        model = OrderItems
        fields = ('name', 'price_per_unit', 'product_id', 'quantity', )
```

`OrderItemSerializer`与`OrderCustomerSerializer`非常相似。该类还继承了`ModelSerializer`并定义了两个元数据属性。第一个是一个模型，我们将其设置为`OrderItems`，然后是包含每个要序列化的模型字段的元组的字段。

我们将要创建的最后一个序列化程序是`OrderSerializer`，因此让我们首先定义一个名为`OrderSerializer`的类：

```py
class OrderSerializer(serializers.ModelSerializer):
    items = OrderItemSerializer(many=True)
    order_customer = OrderCustomerSerializer()
    status = serializers.SerializerMethodField()
```

首先，我们定义两个属性。`items`属性设置为`OrderItemSerializer`，这意味着当我们需要序列化要在添加新订单时发送的 JSON 数据时，它将使用该序列化程序。`items`属性指订单包含的项目（游戏）。在这里，我们只使用一个关键字参数`(many=True)`。这将告诉您序列化程序项将是一个数组。

状态字段有点特殊；如果您还记得`Order`模型中的状态字段，它被定义为`ChoiceField`。当我们在数据库中保存订单时，如果订单的状态为`Received`，该字段将存储值`1`，如果状态为`Processing`，则存储值`2`，以此类推。当 API 的使用者调用端点以获取订单时，他们将感兴趣的是状态的名称，而不是号码。

因此，这个问题的解决方案是将字段定义为`SerializeMethodField`，然后我们将创建一个名为`get_status`的函数，该函数将返回订单状态的显示名称。我们将在短时间内看到`get_status`方法的实现情况。

我们还定义了`order_customer`属性，该属性设置为`OrderCustomerSerializer`，这意味着框架在尝试反序列化我们在尝试添加新订单时发送的 JSON 对象时将使用`OrderCustomerSerializer`类。

然后我们定义了一个`Meta`类，这样我们就可以在 serializer 类中添加一些元数据信息：

```py
    class Meta:
        depth = 1
        model = Order
        fields = ('items', 'total', 'order_customer',
                  'created_at', 'id', 'status', )
```

第一个属性`depth`指定序列化之前应遍历的关系的深度。在这种情况下，它被设置为`1`，因为在获取订单对象时，我们还需要关于客户和项目的信息。与其他序列化程序一样，我们将模型设置为`Order`，fields 属性指定哪些字段将被序列化和反序列化。

然后，我们实现`get_status`方法：

```py
    def get_status(self, obj):
        return obj.get_status_display()
```

这是获取`ChoiceField`状态显示值的方法。这将覆盖默认行为并返回`get_status_display()`函数的结果。

`_created_order_item`方法只是一种辅助方法，我们将使用它在执行批量插入之前创建和准备订单项的对象：

```py
    def _create_order_item(self, item, order):
        item['order'] = order
        return OrderItems(**item)
```

这里，我们将得到两个参数。第一个参数将是一个包含关于`OrderItem`数据的字典和一个包含`Order`类型对象的`order`参数。首先，我们更新在第一个参数中传递的字典，添加`order`对象，然后调用`OrderItem`构造函数，将项作为参数传递到`item`字典中。

我会给你展示一下它的用途。现在我们已经了解了这个序列化程序的核心，我们将实现`create`方法，这将是一个在每次调用序列化程序的`save`方法时自动调用的方法：

```py
def create(self, validated_data):
    validated_customer = validated_data.pop('order_customer')
    validated_items = validated_data.pop('items')

    customer = OrderCustomer.objects.create(**validated_customer)

    validated_data['order_customer'] = customer
    order = Order.objects.create(**validated_data)

    mapped_items = map(
        functools.partial(
        self._create_order_item, order=order), validated_items
    )

    OrderItems.objects.bulk_create(mapped_items)

    return order
```

因此，调用`save`方法时会自动调用 create 方法，并将`validated_data`作为参数。`validated_date`是经过验证的反序列化订单数据。它将类似于以下数据：

```py
{
    "items": [
        {
            "name": "Prod 001",
            "price_per_unit": 10,
            "product_id": 1,
            "quantity": 2
        },
        {
            "name": "Prod 002",
            "price_per_unit": 12,
            "product_id": 2,
            "quantity": 2
        }
    ],
    "order_customer": {
        "customer_id": 14,
        "email": "test@test.com",
        "name": "Test User"
    },
    "order_id": 1,
    "status": 4,
    "total": "190.00"
}
```

如您所见，在这个 JSON 中，我们一次传递所有信息。在这里，我们有`order`、`items`属性，这是一个订单项目列表，`order_customer`属性包含提交订单的客户的信息。

由于我们必须单独创建这些对象，我们首先弹出`order_customer`和`items`，因此我们有三个不同的对象。第一个，`validated_customer`将只包含与下订单的人相关的数据。`validated_items`对象将只包含与订单的每个项目相关的数据，`validated_data`对象将只包含与订单本身相关的数据。

分割数据后，我们现在可以开始添加对象。我们首先创建一个`OrderCustomer`：

```py
customer = OrderCustomer.objects.create(**validated_customer)
```

然后，我们可以创建订单。`Order`有一个名为`order_customer`的外键字段，它是连接到该特定订单的客户。我们需要做的是在`validated_data`字典中创建一个名为`order_customer`的键的新项目，并将其值设置为我们刚刚创建的客户：

```py
validated_data['order_customer'] = customer
order = Order.objects.create(**validated_data)
```

最后，我们将添加`OrderItems`。现在，要添加订单项，我们需要做一些事情。`validated_items`变量是属于基础顺序的项目列表，我们需要首先为这些项目中的每一个设置顺序，并为列表中的每一个项目创建一个`OrderItem`对象。
执行此操作的方式不同。你可以分两部分来做；例如，首先循环项目列表并设置 order 属性，然后再次循环列表并创建`OrderItem`对象。然而，那就不那么优雅了，是吗？

这里更好的方法是利用 Python 是一种多范式编程语言这一事实，我们可以用更实用的方式解决这个问题：

```py
mapped_items = map(
    functools.partial(
        self._create_order_item, order=order), validated_items
)

OrderItems.objects.bulk_create(mapped_items)
```

这里，我们使用一个内置函数映射。`map`函数将把我指定为第一个参数的函数应用于作为第二个参数传递的 iterable，然后返回一个带有结果的 iterable。
我们将作为映射的第一个参数传递的函数是一个名为`partial`的函数，来自`functools`模块。`partial`函数是一个高阶函数，这意味着它将返回另一个函数（第一个参数中的函数），并将参数和关键字参数添加到其签名中。在前面的代码中，它将返回`self._create_order_item`，第一个参数将是 iterable`validated_items`的一项。第二个参数是我们之前创建的顺序。

之后，`mapped_items`的值应该包含一个`OrderItem`对象的列表，剩下要做的就是调用`bulk_create`，它将为我们插入列表上的所有项目。

接下来，我们将创建视图。

# 创建视图

在创建视图之前，我们将创建一些帮助器类和函数，这些类和函数将使视图中的代码更简单和干净。继续，在主应用目录中创建一个名为`view_helper.py`的文件，像往常一样，让我们从包含导入语句开始：

```py
from rest_framework import generics, status
from rest_framework.response import Response

from django.http import HttpResponse

from .exceptions import InvalidArgumentError
from .exceptions import OrderAlreadyCancelledError
from .exceptions import OrderAlreadyCompletedError

from .serializers import OrderSerializer
```

这里，我们从 Django REST 框架导入一些东西，主要的框架是泛型框架，它包含泛型视图类的定义，我们将使用泛型视图类创建我们自己的自定义视图。状态包含所有 HTTP 状态代码，这些代码在将响应发送回客户端时非常有用。然后，我们导入`Response`类，它将允许我们向客户机发送可以以不同内容类型呈现的内容，例如 JSON 和 XML。

然后，我们在 rest 框架中从 Django 导入与`Response`等价的`HttpResponse`。

我们还导入以前实现的所有自定义异常，以便在出现错误时正确处理数据并向客户端发送有用的错误消息。

最后，我们导入`OrderSerializer`，用于序列化、反序列化和验证模型。

我们要创建的第一个类是`OrderListAPIBaseView`类，它将作为所有视图的基类，这些视图将向客户端返回内容列表：

```py
class OrderListAPIBaseView(generics.ListAPIView):
    serializer_class = OrderSerializer
    lookup_field = ''

    def get_queryset(self, lookup_field_id):
        pass

    def list(self, request, *args, **kwargs):
        try:
            result = self.get_queryset(kwargs.get(self.lookup_field, None))
        except Exception as err:
            return Response(err, status=status.HTTP_400_BAD_REQUEST)

        serializer = OrderSerializer(result, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)
```

`OrderListAPIBaseView`继承自泛型。`ListAPIView`为我们提供了 get 和 list 方法，我们可以覆盖这些方法来添加满足我们需求的功能。

该类首先定义两个属性；`serializer_class`，设置为`OrderSerializer`，`lookup_field`，在本例中我们设置为空字符串。我们将在子类中重写此值。然后，我们定义了`get_queryset`方法，它也将在子类中被重写。

最后，我们实现了 list 方法，它将首先运行`get_queryset`方法来获取将返回给用户的数据。如果出现错误，将返回状态为`400`（`BAD REQUEST`的响应，否则将使用`OrderSerializer`对数据进行序列化。`result`参数是`get_queryset`方法返回的`QuerySet`结果，`many`关键字参数告诉序列化程序我们将序列化项目列表。

当数据正确序列化后，我们将发送一个状态为`200`（OK）的响应以及查询结果。

这个基类的思想是，所有的子类只需要实现`get_queryset`方法，这将保持视图类小而整洁。

现在，我们将添加一个函数，该函数将帮助我们执行`POST`请求的方法。让我们继续添加一个名为`set_status_handler`的函数：

```py
def set_status_handler(set_status_delegate):
    try:
        set_status_delegate()
    except (
            InvalidArgumentError,
            OrderAlreadyCancelledError,
            OrderAlreadyCompletedError) as err:
        return HttpResponse(err, status=status.HTTP_400_BAD_REQUEST)

    return HttpResponse(status=status.HTTP_204_NO_CONTENT)
```

这个功能非常简单；它只会得到一个函数作为参数。运行函数；如果其中一个异常发生，则返回`400`（`BAD REQUEST`响应给客户端，否则返回`204`（`NO CONTENT`响应。

# 添加视图

现在，是时候开始添加视图了！打开`app`主目录下的`views.py`文件，我们添加一些导入语句：

```py
from django.http import HttpResponse
from django.shortcuts import get_object_or_404

from rest_framework import generics, status
from rest_framework.response import Response

from .models import Order
from .status import Status
from .view_helper import OrderListAPIBaseView
from .view_helper import set_status_handler
from .serializers import OrderSerializer
```

首先，我们将从`django.http`模块导入`HttpReponse`，从`django.shortcuts`模块导入`get_object_or_404`。后者只是一个获取对象的助手函数，如果找不到对象，它将返回一个状态为`440`（`NOT FOUND`的响应。

然后，我们导入泛型以创建泛型视图和状态，并从`rest_framework`导入`Response`类。

最后，我们导入一些模型、助手方法和函数，以及我们将在视图中使用的序列化程序。

我们应该准备好开始创建视图。让我们创建一个视图，以获取给定客户的所有订单：

```py
class OrdersByCustomerView(OrderListAPIBaseView):
    lookup_field = 'customer_id'

    def get_queryset(self, customer_id):
        return Order.objects.get_all_orders_by_customer(customer_id)
```

美好的因此，我们创建了一个从基类`(OrderListAPIBaseView)`继承的类，该基类是我们在`view_helpers.py`中创建的，因为我们已经实现了 list 方法，所以我们在这里需要实现的唯一方法是`get_queryset`。`get_queryset`方法获取一个`customer_id`作为参数，并简单地调用我们在`Order`模型管理器中创建的`get_all_orders_by_customer`，传递`customer_id`。
我们还定义了`lookup_field`的值，该值将用于获取传递给基类上 list 方法的`kwargs`的关键字参数的值。

让我们再添加两个视图以获取未完成和完整订单：

```py
class IncompleteOrdersByCustomerView(OrderListAPIBaseView):
    lookup_field = 'customer_id'

    def get_queryset(self, customer_id):
        return Order.objects.get_customer_incomplete_orders(
            customer_id
        )

class CompletedOrdersByCustomerView(OrderListAPIBaseView):
    lookup_field = 'customer_id'

    def get_queryset(self, customer_id):
        return Order.objects.get_customer_completed_orders(
            customer_id
        )
```

与我们实现的第一个视图非常相似，我们定义了`lookup_field`并覆盖`get_queryset`以在`Order`模型管理器中调用适当的方法。

现在，我们将添加一个视图，该视图将在给定特定状态时获取订单列表：

```py
class OrderByStatusView(OrderListAPIBaseView):
    lookup_field = 'status_id'

    def get_queryset(self, status_id):
        return Order.objects.get_orders_by_status(
            Status(status_id)
        )
```

如您所见，我们将`lookup_field`定义为`status_id`，并覆盖`get_queryset`调用`get_orders_by_status`，传递状态值。

在这里，我们使用`Status`（`status_id`，所以我们传递`Enum`项，而不仅仅是 ID。

到目前为止，我们实现的所有视图将只接受`GET`请求，并返回订单列表。现在，我们将实现一个支持`POST`请求的视图，以便能够接收新订单：

```py
class CreateOrderView(generics.CreateAPIView):

    def post(self, request, *arg, **args):
        serializer = OrderSerializer(data=request.data)

        if serializer.is_valid():
            order = serializer.save()
            return Response(
                {'order_id': order.id},
                status=status.HTTP_201_CREATED)

        return Response(status=status.HTTP_400_BAD_REQUEST)
```

现在，这个类与我们之前创建的类有点不同，基类是泛型。`CreateAPIView`为我们提供了`post`方法，因此我们重写该方法以添加我们需要的逻辑。首先，我们获取请求的数据并将其作为参数传递给`OrderSerializer`类；它将反序列化数据并将其设置为序列化程序变量。然后，我们调用方法`is_valid()`，该方法将验证接收到的数据。如果请求的数据无效，我们返回一个`400`响应（`BAD REQUEST`，否则，我们继续调用`save()`方法。此方法将在内部调用序列化程序上的`create`方法，并将创建新订单以及新订单的客户和订单的项目。如果一切顺利，我们将返回一个`202`响应（`CREATED`）以及新创建订单的 ID。

现在，我们将创建三个函数来处理订单取消、设置下一个订单的状态以及最后设置特定订单的状态：

```py
def cancel_order(request, order_id):
    order = get_object_or_404(Order, order_id=order_id)

    return set_status_handler(
        lambda: Order.objects.cancel_order(order)
    )

def set_next_status(request, order_id):
    order = get_object_or_404(Order, order_id=order_id)

    return set_status_handler(
        lambda: Order.objects.set_next_status(order)
    )

def set_status(request, order_id, status_id):
    order = get_object_or_404(Order, order_id=order_id)

    try:
        status = Status(status_id)
    except ValueError:
        return HttpResponse(
            'The status value is invalid.',
            status=status.HTTP_400_BAD_REQUEST)

    return set_status_handler(
        lambda: Order.objects.set_status(order, status)
    )
```

如您所见，这里我们不使用 Django REST 框架基于类的视图。我们只是使用常规函数。第一个是`cancel_order`函数，它获取两个参数：请求和`order_id`。我们首先使用快捷功能`get_object_or_404`。如果无法找到与第二个参数中传递的条件匹配的对象，`get_object_or_404`函数将返回`404`响应（`NOT FOUND`。否则，它将返回对象。

然后，我们使用我们在`view_helpers.py`文件中实现的 helper 函数`set_status_handler`。此函数获取另一个函数作为参数。因此，我们正在传递一个`lambda`函数，该函数将在`Order`模型管理器中执行我们想要的方法。在这种情况下，当`lambda`函数被执行时，它将执行我们在`Order`模型管理器中定义的`cancel_order`方法，传递我们想要取消的订单。

`set_next_status`函数非常相似，但是我们将调用`set_next_status`而不是`lambda`函数内部的`cancel_order`，将要设置的顺序传递到下一个状态。

`set_status`函数包含了更多的逻辑，但也非常简单。此函数将获得两个参数，`order_id`和`status_id`。首先，我们获取订单对象，然后使用`status_id`查找状态。如果状态不存在，将引发`ValueError`异常，然后我们返回`400`响应（`BAD REQUEST`。否则，我们调用`set_status_handle`，传递一个`lambda`函数，该函数将执行传递订单和状态对象的`set_status`函数。

# 设置服务 URL

现在我们已经准备好了所有视图，现在是开始设置 URL 的好时机，我们的订单服务的用户可以调用这些 URL 来获取和修改订单。让我们继续打开主目录`app`中的`urls.py`文件；首先，我们需要导入要使用的所有视图类和函数：

```py
from .views import (
    cancel_order,
    set_next_status,
    set_status,
    OrdersByCustomerView,
    IncompleteOrdersByCustomerView,
    CompletedOrdersByCustomerView,
    OrderByStatusView,
    CreateOrderView,
)
```

完美的现在，我们可以开始添加 URL：

```py
urlpatterns = [
    path(
        r'order/add/',
        CreateOrderView.as_view()
    ),
    path(
        r'customer/<int:customer_id>/orders/get/',
        OrdersByCustomerView.as_view()
    ),
    path(
        r'customer/<int:customer_id>/orders/incomplete/get/',
        IncompleteOrdersByCustomerView.as_view()
    ),
    path(
        r'customer/<int:customer_id>/orders/complete/get/',
        CompletedOrdersByCustomerView.as_view()
    ),
    path(
        r'order/<int:order_id>/cancel',
        cancel_order
    ),
    path(
        r'order/status/<int:status_id>/get/',
        OrderByStatusView.as_view()
    ),
    path(
        r'order/<int:order_id>/status/<int:status_id>/set/',
        set_status
    ),
    path(
        r'order/<int:order_id>/status/next/',
        set_next_status
    ),
]
```

要添加新的 URL，我们需要使用`path``function`传递第一个参数`URL`。第二个参数是将请求发送到第一个参数指定的`URL`时将执行的函数。我们创建的每个 URL 都必须添加到`urlspatterns`列表中。请注意，Django 2 简化了向 URL 添加参数的方式。在此之前，您需要使用正则表达式进行一些修改；现在，您可以按照符号`<type:param>`进行操作。

在我们尝试之前，我们必须打开`urls.py`文件，但这次是在 order 目录中，因为我们需要包含我们刚刚创建的 URL。

`urls.py`文件的外观应与此类似：

```py
"""order URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/2.0/topics/http/urls/
Examples:
Function views
    1\. Add an import: from my_app import views
    2\. Add a URL to urlpatterns: path('', views.home, name='home')
Class-based views
    1\. Add an import: from other_app.views import Home
    2\. Add a URL to urlpatterns: path('', Home.as_view(), name='home')
Including another URLconf
    1\. Import the include() function: from django.urls import include, path
    2\. Add a URL to urlpatterns: path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
]
```

现在，我们希望我们在主应用上定义的所有 URL 都位于`/api/`下。要实现这一点，我们唯一需要做的就是创建一个新的路由，并包含来自主应用的 URL。在`urlpatterns`列表中添加以下代码：

```py
path('api/', include('main.urls')),
```

别忘了导入`include`函数：

```py
from django.urls import include
```

当我们将订单服务部署到 AWS 时，它不会公开；但是，作为一种额外的安全措施，我们将为此服务启用令牌认证。

要调用服务的 API，我们必须发送一个认证令牌。让我们继续并启用它。打开`order`目录下的`settings.py`文件，添加以下内容：

```py
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    ),
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework.authentication.TokenAuthentication',
    )
}
```

你可以把这个放在`INSTALLED_APPS`后面。

`DEFAULT_PERMISSION_CLASSES`函数定义全局权限策略。在这里，我们将其设置为`rest_framework.permissions.IsAuthenticated`，这意味着它将拒绝任何未经授权的用户的访问。

`DEFAULT_AUTHENTICATION_CLASSES`函数指定全局认证模式。在本例中，我们将使用令牌认证。

然后，在`INSTALLED_APPS`中，我们需要包含`rest_framework.authtoken`。你的`INSTALLED_APPS`应该是这样的：

```py
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'main',
    'rest_framework',
    'rest_framework.authtoken',
]
```

完美的保存文件，并在终端上运行以下命令：

```py
python manage.py migrate
```

Django REST 框架具有现成的视图，因此用户可以调用并获取令牌。然而，为了简单起见，我们将创建一个可以访问 API 的用户。然后，我们可以手动创建一个认证令牌，用于向订单服务 API 发出请求。

让我们继续创建这个用户。使用以下命令启动服务：

```py
python manage.py runserver
```

并浏览至`https://localhost:8000/admin`。

在“认证和授权”选项卡下，您将看到`Users`模型。单击添加并创建一个用户名为`api_user`的用户。创建用户后，浏览回管理员首页，在认证令牌**下，**单击添加。在下拉菜单中选择`api_user`并点击保存。您将看到如下页面：

![](img/edccbabd-f4f7-4bf9-9e8a-930fe3e07c42.png)

复制密钥，让我们创建一个小脚本来添加订单，这样我们就可以测试 API 了。

创建一个名为`send_order.py`的文件；只要激活了虚拟环境，它就可以放在任何您想要的地方，因为我们将使用包请求将订单发送到订单服务。将以下内容添加到`send_order.py`文件中：

```py
import json
import sys
import argparse
from http import HTTPStatus

import requests

def setUpData(order_id):
    data = {
        "items": [
            {
                "name": "Prod 001",
                "price_per_unit": 10,
                "product_id": 1,
                "quantity": 2
            },
            {
                "name": "Prod 002",
                "price_per_unit": 12,
                "product_id": 2,
                "quantity": 2
            }
        ],
        "order_customer": {
            "customer_id": 14,
            "email": "test@test.com",
            "name": "Test User"
        },
        "order_id": order_id,
        "status": 1,
        "total": "190.00"
    }

    return data

def send_order(data):

    response = requests.put(
        'http://127.0.0.1:8000/api/order/add/',
        data=json.dumps(data))

    if response.status_code == HTTPStatus.NO_CONTENT:
        print('Ops! Something went wrong!')
        sys.exit(1)

    print('Request was successfull')

if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        description='Create a order for test')

    parser.add_argument('--orderid',
                        dest='order_id',
                        required=True,
                        help='Specify the the order id')

    args = parser.parse_args()

    data = setUpData(args.order_id)
    send_order(data)
```

伟大的现在，我们可以启动开发服务器：

```py
python manage.py runserver
```

在另一个窗口中，我们将运行刚刚创建的脚本：

```py
python send_order.py --orderid 10
```

您可以看到如下结果：

![](img/2a95e41c-4f91-4a4e-ab80-64223855e413.png)

什么这里出了点问题，你能猜出是什么吗？请注意，在我运行 Django 开发服务器的终端屏幕截图中打印的日志消息：

```py
[21/Jan/2018 09:30:37] "PUT /api/order/add/ HTTP/1.1" 401 58
```

好的，这里说服务器已经收到了对`/api/order/add/`的 PUT 请求，需要注意的是代码`401`表示`Unauthorized`。这意味着我们在`settings.py`文件中添加的设置工作正常。要调用 API，我们需要进行认证，并且我们正在使用令牌认证。

要为用户创建令牌，我们需要登录 Django 管理 UI。在这里，我们将找到如下所示的认证令牌部分：

![](img/2d36948d-637f-4279-8ae5-2ab99d1abc0a.png)

单击右侧的绿色加号。然后，您可以选择要为其创建令牌的用户，准备好后，单击保存。之后，您将看到已创建的令牌列表：

![](img/20e4a65d-5b1a-4455-9ed6-8aad6945c683.png)

该密钥是您希望在请求的**头**中发送的密钥。

现在我们有了一个令牌，我们可以修改`send_order.py`脚本并将令牌信息添加到请求中，因此在`send_order`函数的顶部添加以下代码：

```py
token = '744cf4f8bd628e62f248444a478ce06681cb8089'

headers = {
    'Authorization': f'Token {token}',
    'Content-type': 'application/json'
}
```

token 变量是我们为用户`api_user`创建的令牌。要获取令牌，只需登录到 Django 管理 UI，在 AUTH-token 下，您将看到已创建的令牌。只需删除我在这里添加的令牌，并将其替换为应用上为`api_user`生成的令牌。

然后，我们需要随请求一起发送头。更改以下代码：

```py
response = requests.put(
    'http://127.0.0.1:8000/api/order/add/',
    data=json.dumps(data))
```

将其替换为以下内容：

```py
response = requests.put(
    'http://127.0.0.1:8000/api/order/add/',
    headers=headers,
    data=json.dumps(data))
```

现在，我们可以转到终端并再次运行代码。您应该会看到与以下屏幕截图中显示的输出类似的输出：

![](img/b834857f-c578-4561-bf20-7c10a898da7a.png)

请注意，现在我们得到以下日志消息：

```py
[21/Jan/2018 09:49:40] "PUT /api/order/add/ HTTP/1.1" 201 0
```

这意味着认证工作正常。继续，花时间探索 Django 管理 UI，并验证现在我们有一个客户和一个订单，并且在数据库中创建了几个项目。

让我们试试其他一些端点，看看它们是否按预期工作。例如，我们可以获得我们刚刚创建的客户的所有订单。

You can perform small tests to the endpoints using any tool you want. There are a few very handy browser plugins that you can install, or, if you are like me and like to do everything on the terminal, you can use cURL. Alternatively if you want to try to build something with Python, there is the `httpie` package that you can install using pip. Use the `pip install httpie --upgrade --user` command to install `httpie` on your local directory under `./local/bin`. So, don't forget to add this directory to your PATH. I like to use `httpie` instead of cURL because `httpie` shows a nice and formatted JSON output so I can get a better view of the response that I'm getting back from the endpoint.

那么，让我们试试我们创建的第一个`GET`端点：

```py
  http http://127.0.0.1:8000/api/customer/1/orders/get/ 'Authorization: Token 744cf4f8bd628e62f248444a478ce06681cb8089'
```

您应该看到以下输出：

```py
HTTP/1.1 200 OK
Allow: GET, HEAD, OPTIONS
Content-Length: 270
Content-Type: application/json
Date: Sun, 21 Jan 2018 10:03:00 GMT
Server: WSGIServer/0.2 CPython/3.6.2
Vary: Accept
X-Frame-Options: SAMEORIGIN

[
 {
 "items": [
 {
 "name": "Prod 001",
 "price_per_unit": 10,
 "product_id": 1,
 "quantity": 2
 },
 {
 "name": "Prod 002",
 "price_per_unit": 12,
 "product_id": 2,
 "quantity": 2
 }
 ],
 "order_customer": {
 "customer_id": 14,
 "email": "test@test.com",
 "name": "Test User"
 },
 "order_id": 10,
 "status": 1,
 "total": "190.00"
 }
]
```

完美的正如所料。继续并尝试其他端点！

接下来，我们将返回在线视频游戏商店并发送订单。

# 与游戏在线商店的集成

现在我们已经启动并运行了服务，我们准备与 Django 一起完成[第 7 章](7.html)、*的在线游戏商店项目。我们不会进行很多更改，但我们将做两项改进：*

*   目前，在线游戏商店无法提交订单。我们网站的用户只能向购物车添加项目、可视化和编辑购物车的项目。我们将完成该实现并创建一个视图，以便提交订单。
*   我们将实现一个查看订单历史的视图。

那么，让我们开始吧！

我们要做的第一个更改是为我们在服务订单中创建的`api_user`添加认证令牌。我们还希望将基本 URL 添加到订单服务中，这样我们就可以更容易地构建执行请求所需的 URL。打开`gamestore`目录中的`settings.py`文件，添加这两个常量变量：

```py
ORDER_SERVICE_AUTHTOKEN = '744cf4f8bd628e62f248444a478ce06681cb8089'
ORDER_SERVICE_BASEURL = 'http://127.0.0.1:8001'
```

把代码放在哪里并不重要，但是把它放在文件的末尾也许是个好主意。

我们要做的下一个改变是添加一个名为`OrderItem`的`namedtuple`，只是为了帮助我们准备订单数据，使其与订单服务所期望的格式兼容。打开`gamestore/main`目录下的`models.py`文件，添加`import`：

```py
from collections import namedtuple
```

模型文件的另一个变化是，我们将在`ShoppingCartManager`类中添加一个名为`empty`的新方法，以便在调用它时，它将删除购物车的所有项目。在`ShoppingCartManager`类中，添加以下方法：

```py
def empty(self, cart):
    cart_items = ShoppingCartItem.objects.filter(
        cart__id=cart.id
    )

    for item in cart_items:
        item.delete()
```

在文件末尾，我们创建`namedtuple`：

```py
OrderItem = namedtuple('OrderItem', 
                         'name price_per_unit product_id quantity')
```

接下来，我们将更改`cart.html`模板。找到`send order`按钮：

```py
<button class='btn btn-primary'>
  <i class="fa fa-check" aria-hidden="true"></i>
  &nbsp;SEND ORDER
</button>
```

将其替换为以下内容：

```py
<form action="/cart/send">
  {% csrf_token %}
  <button class='btn btn-primary'>
    <i class="fa fa-check" aria-hidden="true"></i>
    &nbsp;SEND ORDER
  </button>
</form>
```

美好的我们只是在按钮周围创建了一个表单，并在表单中添加了跨站点请求伪造令牌，这样当我们点击按钮时，它会向`cart/send`发送请求。

让我们添加新的 URL。打开主目录`app`中的`urls.py`文件，我们添加两个新 URL：

```py
path(r'cart/send', views.send_cart),
path(r'my-orders/', views.my_orders),
```

您可以将这两个 URL 定义放在`/cart/`URL 的定义之后。

打开`views.py`文件并添加一些新导入：

```py
import json
import requests
from http import HTTPStatus
from django.core.serializers.json import DjangoJSONEncoder
from gamestore import settings
```

然后，我们添加一个函数，该函数将帮助我们序列化要发送到订单服务的订单数据：

```py
def _prepare_order_data(cart):

    cart_items = ShoppingCartItem.objects.values_list(
        'game__name',
        'price_per_unit',
        'game__id',
        'quantity').filter(cart__id=cart.id)

    order = cart_items.aggregate(
        total_order=Sum(F('price_per_unit') * F('quantity'),
                        output_field=DecimalField(decimal_places=2))
    )

    order_items = [OrderItem(*x)._asdict() for x in cart_items]

    order_customer = {
        'customer_id': cart.user.id,
        'email': cart.user.email,
        'name': f'{cart.user.first_name} {cart.user.last_name}'
    }

    order_dict = {
        'items': order_items,
        'order_customer': order_customer,
        'total': order['total_order']
    }

    return json.dumps(order_dict, cls=DjangoJSONEncoder)
```

现在，我们还要添加两个视图，第一个是`send_order`：

```py
@login_required
def send_cart(request):
    cart = ShoppingCart.objects.get(user_id=request.user.id)

    data = _prepare_order_data(cart)

    headers = {
        'Authorization': f'Token {settings.ORDER_SERVICE_AUTHTOKEN}',
        'Content-type': 'application/json'
    }

    service_url = f'{settings.ORDER_SERVICE_BASEURL}/api/order/add/'

    response = requests.post(
        service_url,
        headers=headers,
        data=data)

    if HTTPStatus(response.status_code) is HTTPStatus.CREATED:
        request_data = json.loads(response.text)
        ShoppingCart.objects.empty(cart)
        messages.add_message(
            request,
            messages.INFO,
            ('We received your order!'
             'ORDER ID: {}').format(request_data['order_id']))
    else:
        messages.add_message(
            request,
            messages.ERROR,
            ('Unfortunately, we could not receive your order.'
             ' Try again later.'))

    return HttpResponseRedirect(reverse_lazy('user-cart'))
```

接下来是`my_orders`视图，它将是返回订单历史记录的新视图：

```py
@login_required
def my_orders(request):
    headers = {
        'Authorization': f'Token {settings.ORDER_SERVICE_AUTHTOKEN}',
        'Content-type': 'application/json'
    }

    get_order_endpoint = f'/api/customer/{request.user.id}/orders/get/'
    service_url = f'{settings.ORDER_SERVICE_BASEURL}{get_order_endpoint}'

    response = requests.get(
        service_url,
        headers=headers
    )

    if HTTPStatus(response.status_code) is HTTPStatus.OK:
        request_data = json.loads(response.text)
        context = {'orders': request_data}
    else:
        messages.add_message(
            request,
            messages.ERROR,
            ('Unfortunately, we could not retrieve your orders.'
             ' Try again later.'))
        context = {'orders': []}

    return render(request, 'main/my-orders.html', context)
```

我们需要创建`my-orders.html`文件，它将是`my_orders`视图呈现的模板。在`main/templates/main/`目录中创建一个名为`my-orders.html`的新文件，包含以下内容：

```py
{% extends 'base.html' %}

{% block 'content' %}

<h3>Order history</h3>

{% for order in orders %}

<div class="order-container">
  <div><strong>Order ID:</strong> {{order.id}}</div>
  <div><strong>Create date:</strong> {{ order.created_at }}</div>
  <div><strong>Status:</strong> <span class="label label-success">{{order.status}}</span></div>
  <div class="table-container">
    <table class="table table-striped">
      <thead>
        <tr>
          <th>Product name</th>
          <th>Quantity</th>
          <th>Price per unit</th>
        </tr>
      </thead>
      <tbody>
        {% for item in order.items %}
        <tr>
          <td>{{item.name}}</td><td>{{item.quantity}}</td>  
          <td>${{item.price_per_unit}}</td>
        </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>
  <div><strong>Total amount:</strong>{{order.total}}</div>
  <hr/>
</div>
{% endfor %}
{% endblock %}
```

这个模板非常基础；它只是在订单中循环，然后循环项目，并用项目信息构建一个 HTML 表。

我们需要在`site.css`中做一些更改，我们有在线视频游戏商店的定制样式。打开`static/styles`文件夹中的`site.css`文件，让我们做一些修改。首先，找到此代码，如下所示：

```py
.nav.navbar-nav .fa-home,
.nav.navbar-nav .fa-shopping-cart {
    font-size: 1.5em;
}
```

将其替换为以下内容：

```py
.nav.navbar-nav .fa-home,
.nav.navbar-nav .fa-shopping-cart,
.nav.navbar-nav .fa-truck {
    font-size: 1.5em;
}
```

在此文件末尾，我们可以添加特定于订单历史页面的样式：

```py
.order-container {
    border: 1px solid #000;
    margin: 20px;
    padding: 10px;
}
```

现在，我们将再添加一个菜单选项，它将链接到新的`my orders`页面。打开应用`root`目录中`templates`目录下的`base.html`文件，找到菜单选项`CART`：

```py
<li>
  <a href="/cart/">
    <i class="fa fa-shopping-cart" aria-hidden="true"></i> CART
  </a>
</li>
```

在结束`</li>`标记后添加以下代码：

```py
<li>
  <a href="/my-orders/">
    <i class="fa fa-truck" aria-hidden="true"></i> ORDERS
  </a>
</li>
```

最后，我们要做的最后一个更改是改进我们在 UI 中显示的错误消息的布局。在`base.html`文件末尾找到此代码：

```py
{% if messages %}
  {% for message in messages %}    
    {{message}}
    </div>
  {% endfor %}
{% endif %}
```

将其替换为以下代码：

```py
{% if messages %}
  {% for message in messages %}
    {% if message.tags == 'error' %}
      <div class="alert alert-danger" role="alert">
    {% else %}
      <div class="alert alert-info" role="alert">
    {% endif %}
    {{message}}
    </div>
  {% endfor %}
{% endif %}
```

# 测试集成

我们把一切都准备好了。现在，我们需要启动网站和服务，这样我们就可以验证是否一切正常。

需要记住的一点是，为了进行测试，我们需要在不同的端口上运行 Django 应用。我们可以使用默认端口`800`运行网站（游戏在线商店），对于订单服务，我们可以使用端口`8001`。

打开两个端子；在一个终端中，我们将启动在线视频游戏商店：

```py
python manage.py runserver
```

在第二个终端，我们将启动订单服务：

```py
python manage.py runserver 127.0.0.1:8001
```

伟大的打开浏览器，前往`http://localhost:8000`并使用我们的凭证登录。登录后，您会注意到有几件事是不同的。现在，在顶部菜单中有一个名为`ORDERS`的新选项。它应该是空的，所以继续向购物车添加一些物品。完成后，转到购物车视图并单击发送订单按钮。

如果一切正常，您应该在页面顶部看到一个通知，如下所示：

![](img/23172db2-3235-40a2-8e5d-7fa0e02142bd.png)

完美的它的效果和预期的一样。请注意，将订单发送到订单服务后，购物车也被清空。

现在，点击顶部菜单上的`ORDERS`选项，您会看到我们刚刚提交的订单：

![](img/9a3ff13e-c15e-4cce-8cfa-7d66c14e0787.png)

# 部署到 AWS

现在，是时候向世界展示我们迄今为止所做的工作了。

我们将把 gamestore Django 应用和订单服务部署到 AmazonWeb 服务中的 EC2 实例。

This section is not about configuring Virtual Private Cloud, Security groups, Routing tables, and EC2 instances. Packt has plenty of excellent books and videos available that talk about this topic.

相反，我们将假设您已经设置了环境，并将重点放在：

*   部署应用
*   安装所有必要的依赖项
*   安装和使用`gunicorn`
*   安装和配置`nginx`

我的 AWS 设置非常简单，但它肯定适用于更复杂的设置。现在，我有一个 VPC，其中有一个子网和两个 EC2 实例（`gamestore`和订单服务）。请参见以下屏幕截图：

![](img/e36b74d3-ac74-4979-851d-878b9b9f5b7b.png)

我们可以从`gamestore`应用开始；通过 ssh 连接到要在其上部署在线游戏应用的 EC2 实例。请记住，在其中一种情况下，您需要有`.pem`文件：

```py
ssh -i gamestore-keys.pem ec2-user@35.176.16.157
```

我们将首先更新我们在该机器上安装的任何软件包；这不是必需的，但这是一种很好的做法，因为某些软件包可能有您可能希望在安装时进行的安全修复和性能改进。Amazon Linux 使用`yum`包管理器，因此我们运行以下命令：

```py
sudo yum update
```

对于任何需要更新的包，只需回答“是”`y`。

默认情况下，这些 EC2 实例没有安装 Python，因此我们也需要安装它：

```py
sudo yum install python36.x86_64 python36-pip.noarch python36- setuptools.noarch
```

我们还需要安装`nginx`：

```py
sudo yum install nginx
```

然后，我们安装项目依赖项：

```py
sudo pip-3.6 install django requests pillow gunicorn
```

完美的现在，我们可以复制应用，退出此实例，然后从本地计算机运行以下命令：

```py
scp -R -i gamestore-keys.pem ./gamestore ec2-user@35.176.16.157:~/gamestore
```

此命令将递归地将所有文件从本地机器上的`gamestore`目录复制到 EC2 实例中的主目录。

# 修改 settings.py 文件

有一件事我们必须改变。在`settings.py`文件中，有一个名为`ALLOWED_HOSTS`的列表，在我们创建 Django 项目时它是空的。我们需要添加部署应用的 EC2 的 IP 地址；就我而言，这将是：

```py
ALLOWED_HOSTS=["35.176.16.157"]
```

我们还需要更改文件末尾定义的`ORDER_SERVICE_BASEURL`。它需要是我们将要部署到订单服务的实例的地址。在我的例子中，IP 是`35.176.194.15`，所以我的变量如下所示：

```py
ORDER_SERVICE_BASEURL = "http://35.176.194.15"
```

我们将创建一个文件夹来保存应用，因为让应用在`ec2-user`文件夹中运行不是一个好主意。因此，我们将在`root`目录中创建一个名为`app`的新文件夹，并将`gamestore`目录复制到新创建的目录中：

```py
sudo mkdir /app && sudo cp -R ./gamestore /app/
```

我们还需要设置该目录的当前权限。安装`nginx`时，它还会创建一个`nginx`用户和一个组。因此，让我们更改整个文件夹的所有权：

```py
cd / && sudo chown -R nginx:nginx ./gamestore
```

最后，我们将设置`nginx`，编辑`/etc/nginx/nginx.conf`文件，并在`service`下添加以下配置：

```py
location / {
  proxy_pass http://127.0.0.1:8000;
  proxy_set_header Host $host;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}

location /static {
  root /app/gamestore;
}
```

我们需要重新启动`nginx`服务，以便该服务反映我们刚才所做的更改：

```py
sudo service nginx restart
```

最后，我们转到`application`文件夹：

```py
cd /app/gamestore
```

使用`gunicorn`启动应用。我们将以`nginx`用户身份启动应用：

```py
sudo gunicorn -u nginx gamestore.wsgi
```

现在，我们可以浏览到该网站。您不需要指定端口`8000`，因为`nginx`会将来自端口`80`的请求路由到`127.0.0.1:8000`。

# 部署订单服务

部署 order 服务与`gamestore`项目基本相同，唯一的区别是我们将安装不同的 Python 依赖项，并将应用部署到不同的目录中。那么，让我们开始吧。

在安装`nginx`步骤之前，您几乎可以重复所有步骤。另外，确保从现在开始使用其他 EC2 实例的弹性 IP 地址。

安装`nginx`后，我们可以安装订单服务依赖项：

```py
sudo pip-3.6 install django djangorestframework requests
```

我们现在可以复制项目文件了。转到服务目录所在的目录，然后运行以下命令：

```py
scp -R -i order-service-keys.pem ./order ec2-user@35.176.194.15:~/gamestore
```

像`gamestore`一样，我们也需要编辑`settings.py`文件，添加我们的 EC2 实例弹性 IP：

```py
ALLOWED_HOSTS=["35.176.194.15"]
```

我们还将在`root`目录中创建一个文件夹，这样项目就不会出现在`ec2-user`主目录中：

```py
sudo mkdir /srv && sudo cp -R ./order /srv/
```

让我们也更改整个目录的所有者：

```py
cd / && sudo chown -R nginx:nginx ./order
```

让我们编辑`/etc/nginx/nginx.conf`文件，并在`service`下添加以下配置：

```py
location / {
  proxy_pass http://127.0.0.1:8000;
  proxy_set_header Host $host;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
}
```

这一次，我们不需要配置静态文件夹，因为 order 服务没有图像、模板、JS 或 CSS 文件。

重新启动`nginx`服务：

```py
sudo service nginx restart
```

转到服务的目录：

```py
cd /srv/order
```

并使用`gunicorn`启动应用。我们将以`nginx`用户身份启动应用：

```py
sudo gunicorn -u nginx order.wsgi
```

最后，我们可以浏览到部署`gamestore`的地址，您应该可以看到该站点已启动并正在运行。

浏览该网站，您将看到第一页。所有产品都已加载，登录和注销部分也正常工作。以下是我的系统截图：

![](img/9660d0a6-ccf9-4d45-981a-f541742d1c64.png)

如果您浏览到使用订单服务的视图，例如“订单”部分，您可以验证一切正常，如果您在网站上下了任何订单，您应该会看到此处列出的订单，如以下屏幕截图所示：

![](img/b57770dd-21a8-4748-81ae-5c8326529984.png)

# 总结

我们在本章中涵盖了很多主题；我们已经构建了订单服务，该服务负责从我们在上一章中开发的 web 应用接收订单。订单服务还提供其他功能，如更新订单状态和使用不同标准提供订单信息的能力。

该微服务是我们在上一章中开发的 web 应用的扩展，在下一章中，我们将进一步扩展它，添加无服务器功能，以便在成功接收订单以及订单状态更改为已发货时通知应用的用户。