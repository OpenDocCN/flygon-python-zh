# 二、使用 Spotify 创建远程控制应用

Spotify 是在瑞典斯德哥尔摩开发的音乐流媒体服务。第一个版本发布于 2008 年，今天它不仅提供音乐，还提供视频和播客。Spotify 从瑞典的一家初创公司迅速成长为世界上最大的音乐服务公司，其应用运行在视频游戏机和手机上，并与许多社交网络进行了整合。
该公司确实改变了我们的音乐消费方式，不仅让知名艺术家，也让小型独立艺术家能够与世界分享他们的音乐。

幸运的是，Spotify 也是一个很好的开发平台，它提供了一个非常好的 RESTAPI，可以通过艺术家、专辑、歌曲名称进行搜索，还可以创建和共享播放列表。

对于本书中的第二个应用，我们将开发一个终端应用，我们可以：

*   搜索艺术家
*   搜索相册
*   搜索轨迹
*   演奏音乐

除了所有这些功能外，我们还将实现一些功能，以便通过终端控制 Spotify 应用。

首先，我们将经历在 Spotify 上创建新应用的过程；然后，是时候开发一个小型框架来包装 Spotify 的 RESTAPI 的一些部分了。我们还将致力于实现 Spotify 支持的不同类型的认证，以使用其 RESTAPI。
当所有这些核心功能就绪后，我们将使用 Python 发布的`curses`包开发终端用户界面。

在本章中，您将学习：

*   如何创建`Spotify`应用
*   如何使用`OAuth`
*   面向对象编程概念
*   使用流行包`Requests`消费 REST API
*   如何使用 curses 设计终端用户界面

我不知道你的情况，但我真的很想写代码和听一些好听的音乐，所以让我们开始吧！

# 建立环境

让我们继续配置我们的开发环境。我们需要做的第一件事是创建一个新的虚拟环境，这样我们就可以在不干扰全局 Python 安装的情况下工作并安装所需的包。

我们的应用将被称为`musicterminal`，因此我们可以创建一个同名的虚拟环境。

要创建新的虚拟环境，请运行以下命令：

```py
$ python3 -m venv musicterminal
```

Make sure that you are using Python 3.6 or later, otherwise the applications in this book may not work properly.

要激活虚拟环境，可以运行以下命令：

```py
$ . musicterminal/bin/activate
```

完美的现在我们已经设置了虚拟环境，可以创建项目的目录结构了。它应具有以下结构：

```py
musicterminal
├── client
├── pytify
│   ├── auth
│   └── core
└── templates
```

与第一章中的应用一样，我们创建了一个项目目录（此处称为`musicterminal`）和一个子目录（也称为`pytify`），其中将包含封装 Spotify REST API 的框架。
在框架目录中，我们将`auth`分为两个模块，其中包含 Spotify 授权代码和客户端凭据支持的两个认证流的实现。最后，`core`模块将包含从 REST API 获取数据的所有方法。

客户机目录将包含与我们将要构建的客户机应用相关的所有脚本。

最后，`templates`目录将包含一些 HTML 文件，这些文件将在我们构建小型 Flask 应用以执行 Spotify 认证时使用。

现在，让我们在`musicterminal`目录中创建一个包含以下内容的`requirements.txt`文件：

```py
requests==2.18.4
PyYAML==3.12
```

要安装依赖项，只需运行以下命令：

```py
$ pip install -r requirements.txt
```

![](img/c51878ae-cdd2-4c1c-aba5-a1fb2df3386e.png)

正如您在输出中看到的，我们的虚拟环境中已经安装了其他软件包。原因是我们的项目需要的包也需要其他包，所以它们也将被安装。

请求由 Kenneth Reitz[创建 https://www.kennethreitz.org/](https://www.kennethreitz.org/) ，它是 Python 生态系统中最常用和最受欢迎的软件包之一。微软、谷歌、Mozilla、Spotify、Twitter 和索尼等大公司都在使用它，只是举几个例子而已，而且它是 Pythonic，而且使用起来非常简单。

Check out other projects from Kenneth, especially the `pipenv` project, which is an awesome Python packaging tool.

Another module that we are going to use is curses. The curses module is simply a wrapper over the curses C functions and it is relatively simpler to use than programming in C. If you worked with the curses C library before, the curses module in Python should be familiar and easy to learn.

One thing to note is that Python includes the curses module on Linux and Mac; however, it is not included by default on Windows. If you are running Windows, the curses documentation at [https://docs.python.org/3/howto/curses.html](https://docs.python.org/3/howto/curses.html) recommends the  UniCurses package developed by Fredrik Lundh.

在我们开始编码之前还有一件事。在尝试导入诅咒时可能会遇到问题；最常见的原因是您的系统中没有安装`libncurses`。在安装 Python 之前，请确保已在系统上安装了`libncurses`和`libncurses-dev`。

如果您使用的是 Linux，您很可能会在我们首选发行版的软件包存储库中找到`libncurses`。在 Debian/Ubuntu 中，您可以使用以下命令安装它：

```py
$ sudo apt-get install libncurses5 libncurses5-dev
```

伟大的现在，我们都准备好开始实现我们的应用了。

# 创建 Spotify 应用

我们需要做的第一件事是创建一个 Spotify 应用；在那之后，我们将获得访问密钥，这样我们就可以验证并使用 RESTAPI。

前往[https://beta.developer.spotify.com/dashboard/](https://beta.developer.spotify.com/dashboard/) 在页面下方，您可以找到登录按钮，如果您没有帐户，您可以创建一个新帐户：

![](img/1557b618-e930-456a-bf79-f539bf015194.png)

At the time of writing, Spotify started changing its developer's site and was currently in beta, so the address to log in and some screenshots may be different.

如果您没有 Spotify 帐户，则必须先创建一个帐户。如果你注册了免费帐户，你应该能够创建应用，但我建议你注册高级帐户，因为这是一项很棒的服务，有很棒的音乐目录。

当您登录 Spotify 开发者网站时，您将看到一个类似于以下内容的页面：

![](img/d051e689-8f73-40a9-b6bf-7e005dc6fd66.png)

目前，我们还没有创建任何应用（除非您已经创建了一个），所以请继续并单击“创建应用”按钮。将显示用于创建应用的对话框屏幕：

![](img/50e3e47c-e7b5-484f-8617-203af23e550a.png)

这里，我们有三个必填字段：应用的名称、描述，以及一些复选框，在这些复选框中，您必须告诉 Spotify 您正在构建什么。名称应该是`pytify`并且在描述中，您可以放置任何您想要的内容，但是让我们添加类似`Application for controlling the Spotify client from the terminal`的内容。我们正在构建的应用类型将是一个网站。

完成后，单击对话框屏幕底部的“下一步”按钮。

应用创建过程的第二步是通知 Spotify 您是否正在创建商业集成。就本书而言，我们将选择**否**；但是，如果您要创建一个可以赚钱的应用，您必须选择**是**。

在下一步中，将显示以下对话框：

![](img/0f932dc3-70ea-4696-91e7-7ddc19dd3cef.png)

如果您同意所有条件，只需选中所有复选框并单击提交按钮。

如果已成功创建应用，您将被重定向到应用页面，如下所示：

![](img/ed9c9c57-1548-4c53-8414-9a973dc370df.png)

单击 ShowClient SECRET 链接并复制客户端 ID 和客户端密码的值。我们需要这些密钥来使用 Spotify 的 RESTAPI。

# 应用的配置

为了使应用更加灵活和易于配置，我们将创建一个配置文件。这样，我们不需要硬编码 URL 和访问密钥；此外，如果我们需要更改这些设置，则不需要更改源代码。
我们将创建一个 YAML 格式的配置文件，以存储应用用于认证、向 Spotify RESP API 端点发出请求等的信息。

# 创建配置文件

让我们继续在`musicterminal`目录中创建一个名为`config.yaml`的文件，其内容如下：

```py
client_id: '<your client ID>'
client_secret: '<your client secret>'
access_token_url: 'https://accounts.spotify.com/api/token'
auth_url: 'http://accounts.spotify.com/authorize'
api_version: 'v1'
api_url: 'https://api.spotify.com'
auth_method: 'AUTHORIZATION_CODE'
```

`client_id`和`client_secret`是我们创建 Spotify 应用时为我们创建的密钥。这些密钥将用于获取访问令牌，每次需要向 Spotify 的 RESTAPI 发送新请求时，我们都必须获取该令牌。只需用您自己的钥匙更换`<your client ID>`和`<your client secret>`。

Keep in mind that these keys have to be kept in a safe place. Don't share the keys with anyone and if you are having your project on sites like GitHub, make sure that you are not committing this configuration file with your secret keys. What I usually do is add the config file to my `.gitignore` file so it won't be source-controlled; otherwise, you can always commit the file as I did by presenting it with placeholders instead of the actual keys. That way, it will be easy to remember where you need to add the keys.

在`client_id`和`client_secret`键之后，我们有`access_token_url`。这是 API 端点的 URL，为了获得访问令牌，我们必须对其执行请求。

`auth_url`是 Spotify 账户服务的端点；我们将在需要获取或刷新授权令牌时使用它。

顾名思义，`api_version`指定了 Spotify 的 RESTAPI 版本。在执行请求时，这会附加到 URL。

最后，我们还有`api_url`，它是 Spotify REST API 端点的基本 URL。

# 实现配置文件读取器

在实现阅读器之前，我们将添加一个枚举来表示 Spotify 为我们提供的两种认证流。让我们继续在`musicterminal/pytify/auth`目录中创建一个名为`auth_method.py`的文件，其内容如下：

```py
from enum import Enum, auto

class AuthMethod(Enum):
    CLIENT_CREDENTIALS = auto()
    AUTHORIZATION_CODE = auto()
```

这将定义具有`CLIENT_CREDENTIALS`和`AUTHORIZATION_CODE`属性的枚举。现在我们可以在配置文件中使用这些值。我们需要做的另一件事是在`musicterminal/pytify/auth`目录中创建一个名为`__init__.py`的文件，并导入我们刚刚创建的枚举：

```py
from .auth_method import AuthMethod
```

现在，我们可以继续并创建将为我们读取配置的函数。在`musicterminal/pytify/core`目录中创建一个名为`config.py`的文件，我们先添加一些导入语句：

```py
import os
import yaml
from collections import namedtuple

from pytify.auth import AuthMethod
```

首先，我们导入`os`模块，以便能够访问有助于构建 YAML 配置文件所在路径的函数。我们还导入了`yaml`包来读取配置文件，最后但并非最不重要的是，我们正在从 collections 模块导入`namedtuple`。稍后，我们将详细介绍`namedtuple`的功能。

我们导入的最后一件事是我们刚刚在`pytify.auth`模块中创建的`AuthMethod`枚举。

现在，我们需要一个表示配置文件的模型，因此我们创建了一个名为`Config`的命名元组，例如：

```py
Config = namedtuple('Config', ['client_id',
                               'client_secret',
                               'access_token_url',
                               'auth_url',
                               'api_version',
                               'api_url',
                               'base_url',
                               'auth_method', ])
```

`namedtuple`在 Python 中并不是一个新特性，从 2.6 版开始就有了。`namedtuple`是具有名称和属性查找可访问字段的类似元组的对象。可以用两种不同的方式创建`namedtuple`；让我们启动 Python REPL 并尝试一下：

```py
>>> from collections import namedtuple
>>> User = namedtuple('User', ['firstname', 'lastname', 'email'])
>>> u = User('Daniel','Furtado', 'myemail@test.com')
User(firstname='Daniel', lastname='Furtado', email='myemail@test.com')
>>>
```

这个构造有两个参数；第一个参数是`namedtuple`的名称，第二个参数是表示`namedtuple`中每个字段的`str`元素数组。也可以通过传递一个字符串来指定`namedtuple`的字段，每个字段名之间用空格分隔，例如：

```py
>>> from collections import namedtuple
>>> User = namedtuple('User', 'firstname lastname email')
>>> u = User('Daniel', 'Furtado', 'myemail@test.com')
>>> print(u)
User(firstname='Daniel', lastname='Furtado', email='myemail@test.com')
```

`namedtuple`构造函数还有两个关键字参数：

`Verbose`，设置为`True`时，显示终端上定义`namedtuple`的类的定义。在幕后，`namedtuple`是类，`verbose`关键字参数让我们可以窥探`namedtuple`类是如何构造的。让我们在 REPL 上看到这一点：

```py
>>> from collections import namedtuple
>>> User = namedtuple('User', 'firstname lastname email', verbose=True)
from builtins import property as _property, tuple as _tuple
from operator import itemgetter as _itemgetter
from collections import OrderedDict

class User(tuple):
    'User(firstname, lastname, email)'

    __slots__ = ()

    _fields = ('firstname', 'lastname', 'email')

    def __new__(_cls, firstname, lastname, email):
        'Create new instance of User(firstname, lastname, email)'
        return _tuple.__new__(_cls, (firstname, lastname, email))

    @classmethod
    def _make(cls, iterable, new=tuple.__new__, len=len):
        'Make a new User object from a sequence or iterable'
        result = new(cls, iterable)
        if len(result) != 3:
            raise TypeError('Expected 3 arguments, got %d' % 
            len(result))
        return result

    def _replace(_self, **kwds):
        'Return a new User object replacing specified fields with  
         new values'
        result = _self._make(map(kwds.pop, ('firstname', 'lastname',  
                             'email'), _self))
        if kwds:
            raise ValueError('Got unexpected field names: %r' %  
                              list(kwds))
        return result

    def __repr__(self):
        'Return a nicely formatted representation string'
        return self.__class__.__name__ + '(firstname=%r,  
                                           lastname=%r, email=%r)' 
        % self

    def _asdict(self):
        'Return a new OrderedDict which maps field names to their  
          values.'
        return OrderedDict(zip(self._fields, self))

    def __getnewargs__(self):
        'Return self as a plain tuple. Used by copy and pickle.'
        return tuple(self)

    firstname = _property(_itemgetter(0), doc='Alias for field  
                          number 0')

    lastname = _property(_itemgetter(1), doc='Alias for field number  
                         1')

    email = _property(_itemgetter(2), doc='Alias for field number  
                      2')
```

另一个关键字参数是`rename`，它将重命名`namedtuple`中名称不正确的所有属性，例如：

```py
>>> from collections import namedtuple
>>> User = namedtuple('User', 'firstname lastname email 23445', rename=True)
>>> User._fields
('firstname', 'lastname', 'email', '_3')
```

如您所见，字段`23445`已自动重命名为`_3`，这是字段位置。

要访问`namedtuple`字段，您可以在访问类中的属性时使用相同的语法，使用`namedtuple`-`User`，如上例所示。如果我们想访问`lastname`属性，我们可以只写`u.lastname`。

现在我们有了表示配置文件的`namedtuple`，现在是时候添加函数来执行加载 YAML 文件并返回`namedtuple`-`Config`的工作了。在同一个文件中，我们实现`read_config`功能如下：

```py
def read_config():
    current_dir = os.path.abspath(os.curdir)
    file_path = os.path.join(current_dir, 'config.yaml')

    try:
        with open(file_path, mode='r', encoding='UTF-8') as file:
            config = yaml.load(file)

            config['base_url'] = 
            f'{config["api_url"]}/{config["api_version"]}'

            auth_method = config['auth_method']
            config['auth_method'] = 
            AuthMethod.__members__.get(auth_method)

            return Config(**config)

    except IOError as e:
        print(""" Error: couldn''t file the configuration file 
        `config.yaml`
        'on your current directory.

        Default format is:',

        client_id: 'your_client_id'
        client_secret: 'you_client_secret'
        access_token_url: 'https://accounts.spotify.com/api/token'
        auth_url: 'http://accounts.spotify.com/authorize'
        api_version: 'v1'
        api_url: 'http//api.spotify.com'
        auth_method: 'authentication method'

        * auth_method can be CLIENT_CREDENTIALS or  
          AUTHORIZATION_CODE""")
        raise

```

`read_config`函数首先使用`os.path.abspath`函数获取当前目录的绝对路径，并将其分配给`current_dir`变量。然后，我们将存储在`current_dir`变量上的路径与文件名（在本例中为 YAML 配置文件）连接起来。

在`try`语句中，我们尝试以只读方式打开文件，并将编码设置为 UTF-8。如果失败，它将向用户打印一条帮助消息，说明无法打开该文件，并显示说明 YAML 配置文件结构的帮助。

如果能够成功读取配置文件，我们调用`yaml`模块中的 load 函数来加载和解析文件，并将结果分配给`config`变量。我们还在配置中包含一个名为`base_url`的额外项，它只是一个辅助值，包含`api_url`和`api_version`的串联值。

`base_url`的值将如下所示：[https://api.spotify.com/v1\.](https://api.spotify.com/v1)

最后，我们创建了一个`Config`实例。注意我们如何在构造函数中传播值；这是可能的，因为`namedtuple`-`Config`与`yaml.load()`返回的对象具有相同的字段。这与执行此操作完全相同：

```py
return Config(
    client_id=config['client_id'],
    client_secret=config['client_secret'],
    access_token_url=config['access_token_url'],
    auth_url=config['auth_url'],
    api_version=config['api_version'],
    api_url=config['api_url'],
    base_url=config['base_url'],
    auth_method=config['auth_method'])
```

这里的最后一点是在`pytify/core`目录中创建一个`__init__.py`文件，并导入我们刚刚创建的`read_config`函数：

```py
from .config import read_config
```

# 使用 Spotify 的 web API 进行认证

现在我们已经有了加载配置文件的代码，我们将开始对框架的认证部分进行编码。Spotify 目前支持三种认证：授权码、客户端凭据和隐式授权。我们将在本章中实现授权代码和客户端凭据，我们将从实现客户端凭据流开始，这是最容易开始的。

与授权代码流相比，客户端凭据流有一些缺点，因为该流不包括授权，并且无法访问用户的私有数据以及控制播放。现在我们将实现并使用这个流程，但是当我们开始实现终端播放器时，我们将更改为授权代码。

首先，我们将在`musicterminal/pytify/auth`目录中创建一个名为`authorization.py`的文件，其内容如下：

```py
from collections import namedtuple

Authorization = namedtuple('Authorization', [
    'access_token',
    'token_type',
    'expires_in',
    'scope',
    'refresh_token',
])
```

这将是认证模型，它将包含我们在请求访问令牌后获得的数据。在以下列表中，您可以看到每个属性的说明：

*   `access_token`：必须与每个请求一起发送到 Web API 的令牌
*   `token_type`：令牌的类型，通常为`Bearer`
*   `expires_in`：`access_token`到期时间，为 3600 秒（1 小时）
*   `scope`：范围基本上是 Spotify 用户授予我们应用的权限
*   `refresh_token`：到期后可以刷新`access_token`的令牌

最后一步是在`musicterminal/pytify/auth`目录中创建一个`__init__.py`文件，并导入`Authorization`，这是一个`namedtuple`：

```py
from .authorization import Authorization
```

# 实现客户端凭据流

客户端凭证流非常简单。让我们分解所有步骤，直到得到`access_token`：

1.  我们的应用将从 Spotify 帐户服务请求访问令牌；请记住，在我们的配置文件中，我们有`api_access_token`。这是我们需要发送请求以获取访问令牌的 URL。我们需要发送三个请求：客户端 id、客户端机密和授权类型，在本例中为`client_credentials`。
2.  Spotify 帐户服务将验证该请求，检查密钥是否与我们注册到开发人员站点的应用的密钥匹配，并返回访问令牌。
3.  现在，我们的应用必须使用这个访问令牌才能使用 RESTAPI 中的数据。
4.  spotifyrestapi 将返回我们请求的数据。

在开始实现进行认证和获取访问令牌的功能之前，我们可以添加一个自定义异常，如果从 Spotify 帐户服务收到错误请求（HTTP【T0）】，我们将抛出该异常。

让我们在`musicterminal/pytify/core`目录中创建一个名为`exceptions.py`的文件，其内容如下：

```py
class BadRequestError(Exception):
    pass
```

这门课做的不多；我们只是从`Exception`继承。我们本可以抛出一个通用异常，但在开发其他开发人员将使用的框架和库时，创建具有良好名称和描述的自定义异常是一个很好的实践。

因此，不要抛出这样的异常：

`raise Exception('some message')`

我们可以更明确地抛出一个`BadRequestError`，如下所示：

`raise BadRequestError('some message')`

现在，使用此代码的开发人员可以在其代码中正确处理此类异常。

打开`musicterminal/pytify/core`目录下的`__init__.py`文件，添加以下导入语句：

```py
from .exceptions import BadRequestError
```

完美的现在，是时候在`musicterminal/pytify/auth`目录中添加一个名为`auth.py`的新文件了，我们首先要添加到这个文件中的是一些导入：

```py
import requests
import base64
import json

from .authorization import Authorization
from pytify.core import BadRequestError
```

I usually put all the imports from standard library modules first and function imports in files from my applications last. It is not a requirement, but it is just something I think makes the code cleaner and more organized. This way, I can easily see which are standard library items and which aren't.

现在，我们可以开始添加将请求发送到`Spotify`帐户服务并返回访问令牌的函数。我们要添加的第一个函数称为`get_auth_key`：

```py
def get_auth_key(client_id, client_secret):
    byte_keys = bytes(f'{client_id}:{client_secret}', 'utf-8')
    encoded_key = base64.b64encode(byte_keys)
    return encoded_key.decode('utf-8')
```

客户端凭证流要求我们发送`client_id`和`client_secret`，这必须是 base 64 编码。首先，我们将`client_id:client_secret`格式的字符串转换为字节。之后，我们使用 base 64 对其进行编码，然后对其进行解码，返回编码数据的字符串表示形式，以便我们可以将其与请求负载一起发送。

我们将在同一文件中实现的另一个函数称为`_client_credentials`：

```py
def _client_credentials(conf):

    auth_key = get_auth_key(conf.client_id, conf.client_secret)

    headers = {'Authorization': f'Basic {auth_key}', }

    options = {
        'grant_type': 'client_credentials',
        'json': True,
        }

    response = requests.post(
        'https://accounts.spotify.com/api/token',
        headers=headers,
        data=options
    )

    content = json.loads(response.content.decode('utf-8'))

    if response.status_code == 400:
        error_description = content.get('error_description','')
        raise BadRequestError(error_description)

    access_token = content.get('access_token', None)
    token_type = content.get('token_type', None)
    expires_in = content.get('expires_in', None)
    scope = content.get('scope', None)    

    return Authorization(access_token, token_type, expires_in, 
    scope, None)
```

此函数获取一个参数作为配置，并使用`get_auth_key`函数传递`client_id`和`client_secret`来构建一个 base 64 编码的`auth_key`。这将被发送到 Spotify 的账户服务，以申请`access_token`。

现在，是准备请求的时候了。首先，我们在请求头中设置了`Authorization`，该值将是`Basic`字符串，后跟`auth_key.`，该请求的有效负载将是`grant_type`，在本例中是`client_credentials`，而`json`将设置为`True`，这告诉 API 我们需要 JSON 格式的响应。

我们使用 requests 包向 Spotify 的帐户服务发出请求，传递我们配置的头和数据。

当我们得到响应时，我们首先解码 JSON 数据并将其加载到变量内容中。

如果 HTTP 状态码为`400 (BAD_REQUEST)`我们会提出一个`BadRequestError`；否则，我们将获得`access_token`、`token_type`、`expires_in`和`scope`的值，并最终创建一个`Authorization`元组并返回它。

Note that we are setting `None` to the last parameter when creating an `Authentication`, `namedtuple`. The reason for this is that Spotify's account service doesn't return a `refresh_token` when the type of authentication is `CLIENT_CREDENTIALS`.

到目前为止，我们创建的所有函数都是私有的，所以我们要添加的最后一个函数是`authenticate`函数。开发人员将调用此函数来启动认证过程：

```py
def authenticate(conf):
    return _client_credentials(conf)
```

这个函数非常简单；函数获取一个参数作为`Config``namedtuple`的实例，该实例将包含从配置文件读取的所有数据。然后，我们将配置传递给`_client_credentials`函数，该函数将使用客户端凭证流获取`access_token`。

我们打开`musicterminal/pytify/auth`目录下的`__init__.py`文件，导入`authenticate`和`get_auth_key`函数：

```py
from .auth import authenticate
from .auth import get_auth_key
```

美好的让我们在 Python REPL 中尝试一下：

```py
Python 3.6.2 (default, Oct 15 2017, 01:15:28)
[GCC 6.3.0 20170516] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from pytify.core import read_config
>>> from pytify.auth import authenticate
>>> config = read_config()
>>> auth = authenticate(config)
>>> auth
Authorization(access_token='BQDM_DC2HcP9kq5iszgDwhgDvq7zm1TzvzXXyJQwFD7trl0Q48DqoZirCMrMHn2uUml2YnKdHOszAviSFGtE6w', token_type='Bearer', expires_in=3600, scope=None, refresh_token=None)
>>>
```

正是我们所期望的！下一步是开始创建使用 Spotify 的 RESTAPI 的函数。

# 实现授权代码流

在本节中，我们将实现授权代码流，我们将在客户端中使用它。我们需要使用这个认证流，因为我们需要从使用我们的应用执行某些操作的用户那里获得特殊的访问权限。例如，我们的应用必须能够向 Spotify 的 Web API 发送请求，以便在用户的活动设备上播放特定曲目。为此，我们需要请求`user-modify-playback-state`。

以下是授权代码流中涉及的步骤：

1.  我们的应用将请求访问数据的授权，将用户重定向到 Spotify 网页上的登录页面。在那里，用户可以看到应用所需的所有访问权限。
2.  如果用户批准，Spotify 帐户服务将向回调 URI 发送请求，并发送代码和状态。
3.  当我们获得代码时，我们发送一个新的请求，通过`client_id`、`client_secret`、`grant_type`和`code`来获取`access_token`。这一次，它将不同于客户端凭据流；我们将得到`scope`和`refresh_token`
4.  现在，我们通常可以向 Web API 发送请求，如果访问令牌已过期，我们可以执行另一个请求来刷新访问令牌并继续执行请求。

话虽如此，打开`musicterminal/pytify/auth`目录中的`auth.py`文件，让我们再添加几个函数。首先，我们要添加一个名为`_refresh_access_token`的函数；您可以在`get_auth_key`功能后添加此功能：

```py
def _refresh_access_token(auth_key, refresh_token):

    headers = {'Authorization': f'Basic {auth_key}', }

    options = {
        'refresh_token': refresh_token,
        'grant_type': 'refresh_token',
        }

    response = requests.post(
        'https://accounts.spotify.com/api/token',
        headers=headers,
        data=options
    )

    content = json.loads(response.content.decode('utf-8'))

    if not response.ok:
        error_description = content.get('error_description', None)
        raise BadRequestError(error_description)

    access_token = content.get('access_token', None)
    token_type = content.get('token_type', None)
    scope = content.get('scope', None)
    expires_in = content.get('expires_in', None)

    return Authorization(access_token, token_type, expires_in, 
    scope, None)
```

它基本上与处理客户端凭证流的函数做相同的事情，但是这次我们发送了`refresh_token`和`grant_type`。我们从响应对象获取数据，并创建一个`Authorization`、`namedtuple`。

我们要实现的下一个函数将使用标准库的`os`模块，所以在开始实现之前，我们需要在`auth.py`文件的顶部添加以下导入语句：

```py
import os
```

现在，我们可以继续添加一个名为`_authorization_code`的函数。您可以在`get_auth_key`函数之后添加此函数，其内容如下：

```py
def _authorization_code(conf):

    current_dir = os.path.abspath(os.curdir)
    file_path = os.path.join(current_dir, '.pytify')

    auth_key = get_auth_key(conf.client_id, conf.client_secret)

    try:
        with open(file_path, mode='r', encoding='UTF-8') as file:
            refresh_token = file.readline()

            if refresh_token:
                return _refresh_access_token(auth_key, 
                 refresh_token)

    except IOError:
        raise IOError(('It seems you have not authorize the 
                       application '
                       'yet. The file .pytify was not found.'))
```

在这里，我们尝试在`musicterminal`目录中打开一个名为`.pytify`的文件。此文件将包含我们每次打开应用时用来刷新`access_token`的`refresh_token`。

从文件中获取`refresh_token`后，我们将其与`auth_key`一起传递给`_refresh_access_token`函数。如果由于某种原因，我们无法打开该文件或该文件在`musicterminal`目录中不存在，将引发异常。

我们现在需要做的最后一个修改是在同一个文件中的`authenticate`函数中。我们将添加对这两种认证方法的支持；应该是这样的：

```py
def authenticate(conf):
    if conf.auth_method == AuthMethod.CLIENT_CREDENTIALS:
        return _client_credentials(conf)

    return _authorization_code(conf)
```

现在，我们将根据配置文件中指定的内容启动不同的认证方法。

由于认证功能引用了`AuthMethod`，我们需要导入：

```py
from .auth_method import AuthMethod
```

在尝试这种类型的认证之前，我们需要创建一个小型 web 应用来为我们的应用授权。我们将在下一节中对此进行研究。

# 使用授权代码流授权我们的应用

为了使我们的 Spotify 终端客户端正常工作，我们需要特殊的访问权限来操纵用户的播放。我们通过使用授权码来实现这一点，我们需要特别请求`user-modify-playback-state`访问权。

如果您打算在此应用中添加更多功能，那么最好从一开始就添加一些访问权限；例如，如果您希望能够操纵用户的私有和公共播放列表，您可能需要添加`playlist-modify-private`和`playlist-modify-public`范围。

您可能还希望显示用户在客户端应用上遵循的艺术家列表，因此您还需要将`user-follow-read`包含到范围中。

对于我们将要在客户端应用中实现的功能，请求`user-modify-playback-state`访问权限就足够了。

其思想是使用授权代码流对我们的应用进行授权。我们将使用框架 Flask 创建一个简单的 web 应用，该框架将定义两条路由。`/`根目录只会呈现一个带有链接的简单页面，该链接会将我们重定向到 Spotify 认证页面。

第二个根将是`/callback`，这是 Spotify 在应用的用户授权我们的应用访问其 Spotify 数据后将调用的端点。

让我们看看这是如何实现的，但首先，我们需要安装 Flask。打开终端并键入以下命令：

```py
pip install flask
```

安装后，您甚至可以将其包含在`requirements.txt`文件中，例如：

```py
$ pip freeze | grep Flask >> requirements.txt
```

命令`pip freeze`将以需求格式打印所有已安装的软件包。输出将返回更多项，因为它还将包含我们已经安装的包的所有依赖项，这就是为什么我们 grep`Flask`并将其附加到`requirements.txt`文件中。

下次要设置虚拟环境来处理此项目时，只需运行：

```py
pip install -r requirements.txt
```

伟大的现在，我们可以开始创建 web 应用了。创建一个名为`spotify_auth.py`的文件。

首先，我们添加了所有必要的导入：

```py
from urllib.parse import urlencode

import requests
import json

from flask import Flask
from flask import render_template
from flask import request

from pytify.core import read_config
from pytify.core import BadRequestError
from pytify.auth import Authorization
from pytify.auth import get_auth_key
```

我们将使用`urllib.parse`模块中的`urlencode`函数对要附加到授权 URL 的参数进行编码。在用户授权我们的应用后，我们还将使用请求发送请求以获取`access_token`，并使用`json`包解析响应。
然后，我们将导入与 Flask 相关的东西，这样我们就可以创建一个 Flask 应用`render_template`，这样我们就可以将呈现的 HTML 模板返回给用户，最后返回请求，这样我们就可以访问 Spotify 授权服务返回给我们的数据。

我们还将导入我们在`pytify`模块的核心和授权子模块中包含的一些功能：`read_config`加载和读取 YAML 配置文件和`_authorization_code_request`。稍后将更详细地解释后者。

我们将创建一个 Flask 应用和根路径：

```py
app = Flask(__name__)

@app.route("/")
def home():
    config = read_config()

    params = {
        'client_id': config.client_id,
        'response_type': 'code',
        'redirect_uri': 'http://localhost:3000/callback',
        'scope': 'user-read-private user-modify-playback-state',
    }

    enc_params = urlencode(params)
    url = f'{config.auth_url}?{enc_params}'

    return render_template('index.html', link=url)
```

伟大的从顶部开始，我们读取配置文件，以便获得我们的`client_id`以及 Spotify 授权服务的 URL。用`client_id`建立参数字典；授权码流的响应类型需要设置为`code`；`redirect_uri`是 Spotify 授权服务将用于向我们发送回授权代码的回调 URI。最后，由于我们将向 RESTAPI 发送指令，以便在用户的活动设备中播放曲目，因此应用需要具有`user-modify-playback-state`权限。

现在，我们对所有参数进行编码并构建 URL。

返回值将是呈现的 HTML。在这里，我们将使用`render_template`函数，传递模板作为第一个参数。默认情况下，Flask 将在名为`templates`的目录中搜索此模板。此函数的第二个参数是模型。我们正在传递一个名为`link`的属性，并设置变量 URL 的值。这样，我们可以在 HTML 模板中呈现链接，如：`{{link}}`。

接下来，我们将添加一个函数，在从 Spotify 的帐户服务中获取授权码后，为我们获取`access_token`和`refresh_token`。创建一个名为`_authorization_code_request`的函数，其内容如下：

```py
def _authorization_code_request(auth_code):
    config = read_config()

    auth_key = get_auth_key(config.client_id, config.client_secret)

    headers = {'Authorization': f'Basic {auth_key}', }

    options = {
        'code': auth_code,
        'redirect_uri': 'http://localhost:3000/callback',
        'grant_type': 'authorization_code',
        'json': True
    }

    response = requests.post(
        config.access_token_url,
        headers=headers,
        data=options
    )

    content = json.loads(response.content.decode('utf-8'))

    if response.status_code == 400:
        error_description = content.get('error_description', '')
        raise BadRequestError(error_description)

    access_token = content.get('access_token', None)
    token_type = content.get('token_type', None)
    expires_in = content.get('expires_in', None)
    scope = content.get('scope', None)
    refresh_token = content.get('refresh_token', None)

    return Authorization(access_token, token_type, expires_in, 
    scope, refresh_token)
```

这个函数与我们之前在`auth.py`文件中实现的`_refresh_access_token`函数几乎相同。这里唯一需要注意的是，在选项中，我们正在传递授权码，`grant_type`被设置为`authorization_code`：

```py
@app.route('/callback')
def callback():
    config = read_config()
    code = request.args.get('code', '')
    response = _authorization_code_request(config, code)

    file = open('.pytify', mode='w', encoding='utf-8')
    file.write(response.refresh_token)
    file.close()

    return 'All set! You can close the browser window and stop the 
    server.'
```

这里，我们定义了 Spotify 授权服务将调用的路由，以发回授权代码。

我们首先读取配置，解析请求数据中的代码，然后调用`_authorization_code_request`，传递刚刚获得的代码。

此函数将使用此代码发送另一个请求，它将获取一个我们可以用来发送请求的访问令牌，以及一个刷新令牌，该令牌将存储在`musicterminal`目录中名为`.pytify`的文件中。

我们为向 Spotify REST API 发出请求而获得的访问令牌有效期为 3600 秒，即 1 小时，这意味着在一小时内，我们可以使用相同的访问令牌发出请求。之后，我们需要刷新访问令牌。我们可以通过使用`.pytify`文件中存储的刷新令牌来实现这一点。

最后，我们向浏览器发送一条带有成功消息的消息。

现在，要完成 Flask 应用，我们需要添加以下代码：

```py
if __name__ == '__main__':
    app.run(host='localhost', port=3000)
```

这告诉 Flask 在本地主机上运行服务器并使用端口`3000`。

作为响应，我们的 Flash 应用的`home`函数将返回一个名为 index.HTML 的模板 HTML 文件。我们还没有创建该文件，所以让我们继续创建一个名为`musicterminal/templates`的文件夹，并在新创建的目录中添加一个名为`index.html`的文件，其内容如下：

```py
<html>
    <head>
    </head>
    <body>
       <a href={{link}}> Click here to authorize </a>
    </body>
</html>
```

这里没有太多的解释，但请注意，我们引用的是传递给 Flask 应用的 home 函数中的`render_template`函数的 link 属性。我们正在将锚元素的`href`属性设置为链接的值。

伟大的只有更多的事情，我们才能尝试这一点，看看是否一切都正常工作。我们需要更改 Spotify 应用的设置；更具体地说，我们需要为应用配置回调函数，以便接收授权代码。

话虽如此，前往[https://beta.developer.spotify.com/dashboard/](https://beta.developer.spotify.com/dashboard/) 网站，并使用您的凭据登录。仪表板将显示我们在本章开头创建的`pytify`应用。单击应用名称，然后单击页面右上角的编辑设置按钮。

向下滚动直到找到重定向 URI，然后在文本字段中输入 http://localhost:3000/callback 然后单击添加按钮。您的配置应如下所示：

![](img/bc6aecdc-cc8d-41c2-b322-0e5104dee0e5.png)

伟大的向下滚动至对话框底部，然后单击“保存”按钮。

现在，我们需要运行刚刚创建的 Flask 应用。在终端上的项目根文件夹中，键入以下命令：

```py
python spotify_auth.py
```

您应该会看到类似以下内容的输出：

```py
* Running on http://localhost:3000/ (Press CTRL+C to quit)
```

打开您选择的浏览器，进入`http://localhost:3000`；您将看到一个简单的页面，其中包含我们创建的链接：

![](img/6bc6cdd8-da51-453f-a117-5ac4fe18ee67.png)

单击该链接，您将被发送到 Spotify 的授权服务页面。

将显示一个对话框，要求将`Pytify`应用连接到我们的帐户。一旦您授权，您将被重定向回`http://localhost:3000/callback`。如果一切顺利的话，你应该看看全套的！您可以关闭浏览器窗口并停止页面上的服务器消息。

现在，只需关闭浏览器，就可以停止 Flask 应用。

请注意，`musicterminal`目录中现在有一个名为`.pytify`的文件。如果您查看内容，您将拥有一个与此类似的加密密钥：

```py
AQB2jJxziOvuj1VW_DOBeJh-uYWUYaR03nWEJncKdRsgZC6ql2vaUsVpo21afco09yM4tjwgt6Kkb_XnVC50CR0SdjWrrbMnr01zdemN0vVVHmrcr_6iMxCQSk-JM5yTjg4
```

现在，我们准备开始对播放器进行编码。

接下来，我们将添加一些函数，这些函数将执行对 Spotify 的 Web API 的请求，以搜索艺术家，获取艺术家的专辑列表和专辑中的曲目列表，并播放所选曲目。

# 查询 Spotify 的 web API

到目前为止，我们只准备了地形，现在事情开始变得更有趣了。在本节中，我们将创建向 Spotify 的 Web API 发送请求的基本函数；更具体地说，我们希望能够搜索艺术家，获取艺术家的专辑列表，获取该专辑中的曲目列表，最后我们希望发送请求，在 Spotify 的客户端中实际播放当前处于活动状态的给定曲目。它可以是浏览器、手机、Spotify 的客户端，甚至是视频游戏机。那么，让我们直接投入其中吧！

首先，我们将在`musicterminal/pytify/core`目录中创建一个名为`request_type.py`的文件，其内容如下：

```py
from enum import Enum, auto

class RequestType(Enum):
    GET = auto()
    PUT = auto()
```

我们以前已经做过枚举，所以我们不需要太多细节。可以说，我们创建了一个具有`GET`和`PUT`属性的枚举。这将用于通知为我们执行请求的函数我们要执行`GET`请求或`PUT`请求。

然后，我们可以在同一个`musicterminal/pytify/core`目录中创建另一个名为`request.py`的文件，我们首先添加几个导入语句并定义一个名为`execute_request`的函数：

```py
import requests
import json

from .exceptions import BadRequestError
from .config import read_config
from .request_type import RequestType

def execute_request(
        url_template,
        auth,
        params,
        request_type=RequestType.GET,
        payload=()):

```

此函数获取几个参数：

*   `url_template`：这是用于构建 URL 以执行请求的模板；它将使用另一个名为`params`的参数来构建 URL
*   `auth`：是`Authorization`对象吗
*   `params`：它是一个`dict`，包含了我们将要执行请求的 URL 中的所有参数
*   `request`：这是请求类型；可以是`GET`或`PUT`
*   `payload`：这是可以与请求一起发送的数据

随着我们继续实现相同的功能，我们可以添加：

```py
conf = read_config()

params['base_url'] = conf.base_url

url = url_template.format(**params)

headers = {
    'Authorization': f'Bearer {auth.access_token}'
}
```

我们读取配置并将基本 URL 添加到参数中，以便在`url_template`字符串中替换它。我们在请求头中添加了`Authorization`和认证访问令牌：

```py
if request_type is RequestType.GET:
    response = requests.get(url, headers=headers)
else:
    response = requests.put(url, headers=headers, data=json.dumps(payload))

    if not response.text:
        return response.text

result = json.loads(response.text)
```

这里，我们检查请求类型是否为`GET`。如果是，则从请求执行`get`函数；否则，执行`put`函数。函数调用非常相似；这里唯一不同的是数据参数。如果返回的响应为空，则只返回空字符串；否则，我们将 JSON 数据解析为`result`变量：

```py
if not response.ok:
    error = result['error']
    raise BadRequestError(
        f'{error["message"]} (HTTP {error["status"]})')

return result
```

解析 JSON 结果后，测试请求的状态是否为`200`（OK）；在这种情况下，我们提出一个`BadRequestError`。如果响应成功，我们将返回结果。

我们还需要一些函数来帮助我们准备要传递给 Web API 端点的参数。让我们继续在`musicterminal/pytify/core`文件夹中创建一个名为`parameter.py`的文件，包含以下内容：

```py
from urllib.parse import urlencode

def validate_params(params, required=None):

    if required is None:
        return

    partial = {x: x in params.keys() for x in required}
    not_supplied = [x for x in partial.keys() if not partial[x]]

    if not_supplied:
        msg = f'The parameter(s) `{", ".join(not_supplied)}` are 
        required'
        raise AttributeError(msg)

def prepare_params(params, required=None):

    if params is None and required is not None:
        msg = f'The parameter(s) `{", ".join(required)}` are 
        required'
        raise ValueErrorAttributeError(msg)
    elif params is None and required is None:
        return ''
    else:
        validate_params(params, required)

    query = urlencode(
        '&'.join([f'{key}={value}' for key, value in 
         params.items()])
    )

    return f'?{query}'
```

这里有两个函数，`prepare_params`和`validate_params`。`validate_params`功能用于识别是否存在某些操作所需的参数，但这些参数尚未提供。`prepare_params`函数首先调用`validate_params`以确保已提供所有参数，并将所有参数连接在一起，以便可以轻松地将它们附加到 URL 查询字符串中。

现在，让我们添加一个枚举，其中包含可以执行的搜索类型。在`musicterminal/pytify/core`目录中创建一个名为`search_type.py`的文件，包含以下内容：

```py
from enum import Enum

class SearchType(Enum):
    ARTIST = 1
    ALBUM = 2
    PLAYLIST = 3
    TRACK = 4
```

这只是一个带有四个搜索选项的简单枚举。

现在，我们准备创建函数来执行搜索。在`musicterminal/pytify/core`目录中创建一个名为`search.py`的文件：

```py
import requests
import json
from urllib.parse import urlencode

from .search_type import SearchType
from pytify.core import read_config

def _search(criteria, auth, search_type):

    conf = read_config()

    if not criteria:
        raise AttributeError('Parameter `criteria` is required.')

    q_type = search_type.name.lower()
    url = urlencode(f'{conf.base_url}/search?q={criteria}&type=
    {q_type}')

    headers = {'Authorization': f'Bearer {auth.access_token}'}
    response = requests.get(url, headers=headers)

    return json.loads(response.text)

def search_artist(criteria, auth):
    return _search(criteria, auth, SearchType.ARTIST)

def search_album(criteria, auth):
    return _search(criteria, auth, SearchType.ALBUM)

def search_playlist(criteria, auth):
    return _search(criteria, auth, SearchType.PLAYLIST)

def search_track(criteria, auth):
    return _search(criteria, auth, SearchType.TRACK)
```

我们首先解释`_search`函数。此函数获取三个条件参数（我们要搜索的内容），`Authorization`对象，最后是搜索类型，这是我们刚刚创建的枚举中的一个值。

功能比较简单；我们首先验证参数，然后构建 URL 进行请求，使用访问令牌设置`Authorization`头，最后执行请求并返回解析后的响应。

其他函数`search_artist`、`search_album`、`search_playlist`和`search_track`只是获取相同的参数、条件和`Authorization`对象，并将其传递给`_search`函数，但传递的搜索类型不同。

现在我们可以搜索艺术家了，我们必须得到一张专辑列表。在`musicterminal/pytify/core`目录中添加一个名为`artist.py`的文件，内容如下：

```py
from .parameter import prepare_params
from .request import execute_request

def get_artist_albums(artist_id, auth, params=None):

    if artist_id is None or artist_id is "":
        raise AttributeError(
            'Parameter `artist_id` cannot be `None` or empty.')

    url_template = '{base_url}/{area}/{artistid}/{postfix}{query}'
    url_params = {
        'query': prepare_params(params),
        'area': 'artists',
        'artistid': artist_id,
        'postfix': 'albums',
        }

    return execute_request(url_template, auth, url_params)
```

因此，给定一个`artist_id`，我们只需定义我们想要发出请求的 URL 模板和参数，并运行`execute_request`函数，该函数将为我们构建 URL、获取和解析结果。

现在，我们想要得到一张给定专辑的曲目列表。在`musicterminal/pytify/core`目录中添加一个名为`album.py`的文件，内容如下：

```py
from .parameters import prepare_params
from .request import execute_request

def get_album_tracks(album_id, auth, params=None):

    if album_id is None or album_id is '':
        raise AttributeError(
            'Parameter `album_id` cannot be `None` or empty.')

    url_template = '{base_url}/{area}/{albumid}/{postfix}{query}'
    url_params = {
        'query': prepare_params(params),
        'area': 'albums',
        'albumid': album_id,
        'postfix': 'tracks',
        }

    return execute_request(url_template, auth, url_params)
```

`get_album_tracks`函数与我们刚刚实现的`get_artist_albums`函数非常相似。

最后，我们希望能够向 Spotify 的 Web API 发送指令，告诉它播放我们选择的曲目。在`musicterminal/pytify/core`目录中添加一个名为`player.py`的文件，并添加以下内容：

```py
from .parameter import prepare_params
from .request import execute_request

from .request_type import RequestType

def play(track_uri, auth, params=None):

    if track_uri is None or track_uri is '':
        raise AttributeError(
            'Parameter `track_uri` cannot be `None` or empty.')

    url_template = '{base_url}/{area}/{postfix}'
    url_params = {
        'query': prepare_params(params),
        'area': 'me',
        'postfix': 'player/play',
        }

    payload = {
        'uris': [track_uri],
        'offset': {'uri': track_uri}
    }

    return execute_request(url_template,
                           auth,
                           url_params,
                           request_type=RequestType.PUT,
                           payload=payload)
```

此函数与前面的函数（`get_artist_albums`和`get_album_tracks`非常相似，只是它定义了有效负载。有效负载是一个包含两项的字典：`uris`，它是应添加到播放队列中的曲目列表；`offset`，它包含另一个字典，其中包含应首先播放的曲目 URI。因为我们只想一次播放一首歌，`uris`和`offset`将包含相同的`track_uri`。

这里的最后一点是导入我们实现的新功能。在`musicterminal/pytify/core`目录下的`__init__.py`文件中，添加以下代码：

```py
from .search_type import SearchType

from .search import search_album
from .search import search_artist
from .search import search_playlist
from .search import search_track

from .artist import get_artist_albums
from .album import get_album_tracks
from .player import play
```

让我们尝试在 python REPL 中搜索美工人员，以检查是否一切正常：

```py
Python 3.6.2 (default, Dec 22 2017, 15:38:46)
[GCC 6.3.0 20170516] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from pytify.core import search_artist
>>> from pytify.core import read_config
>>> from pytify.auth import authenticate
>>> from pprint import pprint as pp
>>>
>>> config = read_config()
>>> auth = authenticate(config)
>>> results = search_artist('hot water music', auth)
>>> pp(results)
{'artists': {'href': 'https://api.spotify.com/v1/search?query=hot+water+music&type=artist&market=SE&offset=0&limit=20',
 'items': [{'external_urls': {'spotify': 'https://open.spotify.com/artist/4dmaYARGTCpChLhHBdr3ff'},
 'followers': {'href': None, 'total': 56497},
 'genres': ['alternative emo',
 'emo',
 'emo punk', 
```

输出的其余部分被省略了，因为它太长了，但是现在我们可以看到一切都按照预期工作。

现在，我们准备开始构建终端播放器。

# 创建播放器

现在，我们已经具备了验证和使用 Spotify Rest API 所需的一切，我们将创建一个小型终端客户端，在该客户端中，我们可以搜索艺术家、浏览他/她的专辑，并选择要在 Spotify 客户端中播放的曲目。请注意，要使用客户端，我们必须从高级帐户发出访问令牌，我们需要在这里使用的认证流是`AUTHENTICATION_CODE`。
我们还需要向应用的用户请求`user-modify-playback-state`范围，这将允许我们控制播放。说到这里，让我们开始吧！

首先，我们需要创建一个新的目录来保存所有客户端的相关文件，所以继续创建一个名为`musicterminal/client`的目录。

我们的客户只有三种观点。在第一个视图中，我们将获取用户输入并搜索艺术家。当艺术家搜索完成后，我们将切换到第二个视图，其中将显示选定艺术家的相册列表。在此视图中，用户将能够使用键盘的*向上*和*向下*箭头键选择列表中的相册，并通过点击*输入*键选择相册。

最后，当一张专辑被选中时，我们将切换到应用的第三个也是最后一个视图，用户将看到所选专辑的曲目列表。与前面的视图一样，用户还可以使用键盘的*向上*和*向下*箭头键选择曲目；点击*输入*将向 Spotify API 发送请求，在用户可用设备上播放所选曲目。

一种方法是使用`curses.panel`。面板是一种窗口，非常灵活，允许我们堆叠、隐藏和显示面板，切换面板，返回面板堆栈顶部，等等，这非常适合我们的目的。

那么，让我们在`musicterminal/client`目录中创建一个名为`panel.py`的文件，其内容如下：

```py
import curses
import curses.panel
from uuid import uuid1

class Panel:

    def __init__(self, title, dimensions):
        height, width, y, x = dimensions

        self._win = curses.newwin(height, width, y, x)
        self._win.box()
        self._panel = curses.panel.new_panel(self._win)
        self.title = title
        self._id = uuid1()

        self._set_title()

        self.hide()
```

我们在这里所做的就是导入我们需要的模块和函数，并创建一个名为`Panel`的类。我们还导入了`uuid`模块，以便为每个新面板创建 GUID。

面板的初始值设定项有两个参数：`title`（窗口标题）和`dimensions`。`dimensions`参数是一个元组，遵循 curses 约定。它由`height`、`width`和`y`和`x`位置组成，在这些位置开始绘制面板。

我们解压`dimensions`元组的值，以便更容易使用，然后使用`newwin`函数创建一个新窗口；它将具有我们在类初始值设定项中传递的相同维度。接下来，我们调用 box 函数在终端的四个边上画线。

现在我们已经创建了窗口，是时候为我们刚刚创建的窗口创建面板了，调用`curses.panel.new_panel`并传递窗口。我们还设置窗口标题并创建 GUID。

最后，我们将面板的状态设置为隐藏。继续处理这个类，让我们添加一个名为`hide`的新方法：

```py
def hide(self):
    self._panel.hide()
```

这种方法很简单；它所做的唯一事情就是在我们的面板中调用`hide`方法。

我们在初始值设定项中调用的另一个方法是`_set_title`；让我们现在创建它：

```py
def _set_title(self):
    formatted_title = f' {self._title} '
    self._win.addstr(0, 2, formatted_title, curses.A_REVERSE)
```

在`_set_title`中，我们通过在标题字符串的两侧添加一些额外的填充来格式化标题，然后调用窗口的`addstr`方法打印第 0 行第 2 列的标题，我们使用常量`A_REVERSE`，它将反转字符串的颜色，如下所示：

![](img/ae53d748-1e23-4730-8538-9be17dde71de.png)

我们有一个隐藏面板的方法；现在，我们需要一个方法来显示面板。让我们添加`show`方法：

```py
def show(self):
    self._win.clear()
    self._win.box()
    self._set_title()
    curses.curs_set(0)
    self._panel.show()
```

`show`方法首先清除窗口，并使用`box`方法在其周围绘制边框。然后，我们再次设置了`title`。`cursers.curs_set(0)`调用将禁用光标；我们在这里这样做是因为我们不希望在选择列表中的项目时光标可见。最后，我们在面板中调用`show`方法。

如果有办法知道当前面板是否可见，那就太好了。那么，让我们添加一个名为`is_visible`的方法：

```py
def is_visible(self):
    return not self._panel.hidden()
```

在这里，我们可以在面板上使用`hidden`方法，如果面板隐藏，则返回`true`，如果面板可见，则返回`false`。

本课程的最后一点是增加比较面板的可能性。我们可以通过覆盖一些特殊方法来实现这一点；在本例中，我们希望重写`__eq__`方法，每次使用`==`操作符时都会调用该方法。还记得我们为每个面板创建了一个`id`吗？我们现在可以使用`id`来测试等式：

```py
def __eq__(self, other):
    return self._id == other._id
```

完美的现在我们有了`Panel`基类，我们准备创建一个面板的特殊实现，它将包含选择项目的菜单。

# 添加相册和曲目选择的菜单

现在，我们将在`musicterminal/client/`目录中创建一个名为`menu_item.py`的文件，我们将首先导入一些我们需要的函数：

```py
from uuid import uuid1
```

我们只需要从`uuid`模块导入`uuid1`函数，因为与面板一样，我们将为列表中的每个菜单项创建一个`id (GUID)`。

让我们从添加类和构造函数开始：

```py
class MenuItem:
    def __init__(self, label, data, selected=False):
        self.id = str(uuid1())
        self.data = data
        self.label = label

        def return_id():
            return self.data['id'], self.data['uri']

        self.action = return_id
        self.selected = selected
```

`MenuItem`初始值设定项获得三个参数，`label`项、`data`项将包含 Spotify REST API 返回的原始数据，以及一个表示该项当前是否被选中的标志。

我们首先为该项创建一个 id，然后使用类初始值设定项中传递的参数值设置数据和标签属性的值。

列表中的每个项都有一个操作，当在列表中选择该项时，将执行该操作，因此我们创建了一个名为`return_id`的函数，该函数返回一个具有项 id（与我们刚才创建的 id 不同）的元组。这是 Spotify 上项目的 id，URI 是 Spotify 上项目的 URI。当我们选择并播放歌曲时，后者将非常有用。

现在，我们将实现一些特殊的方法，这些方法在执行项目比较和打印项目时将非常有用。我们要实施的第一种方法是`__eq__`：

```py
def __eq__(self, other):
    return self.id == other.id
```

这将允许我们使用索引函数在`MenuItem`对象列表中查找特定的`MenuItem`。

我们将要实施的另一种特殊方法是`__len__`方法：

```py
def __len__(self):
    return len(self.label)
```

它返回`MenuItem`标签的长度，并将在测量列表上菜单项标签的长度时使用。稍后，当我们构建菜单时，我们将使用`max`函数获取标签最长的菜单项，并在此基础上，我们将向其他项添加额外的填充，以便列表中的所有项看起来都对齐。

我们要实施的最后一种方法是`__str__`方法：

```py
def __str__(self):
    return self.label
```

这只是为了方便打印菜单项；我们不做`print(menuitem.label)`，只做`print(menuitem)`，它会调用`__str__`，返回`MenuItem`标签的值。

# 实现菜单面板

现在，我们将实现菜单面板，它将是容器类，它将容纳所有菜单项、处理事件并在终端屏幕上执行渲染。

在开始实现菜单面板之前，让我们添加一个枚举来表示不同的项对齐选项，这样我们就可以在菜单中显示菜单项的方式上有更多的灵活性。

在`musicterminal/client`目录中创建一个名为`alignment.py`的文件，包含以下内容：

```py
from enum import Enum, auto

class Alignment(Enum):
    LEFT = auto()
    RIGHT = auto()
```

如果遵循第一章中的代码，您应该是枚举专家。这里没有那么复杂的东西；我们定义了一个继承自 Enum 的类`Alignment`，定义了两个属性`LEFT`和`RIGHT`，它们的值都设置为`auto()`，这意味着这些值将为我们自动设置，分别为`1`和`2`。

现在，我们准备创建菜单。让我们继续在`musicterminal/client`目录中创建最后一个名为`menu.py`的类。

让我们添加一些导入和构造函数：

```py
import curses
import curses.panel

from .alignment import Alignment
from .panel import Panel

class Menu(Panel):

    def __init__(self, title, dimensions, align=Alignment.LEFT, 
                 items=[]):
        super().__init__(title, dimensions)
        self._align = align
        self.items = items
```

`Menu`类继承了我们刚刚创建的`Panel`基类，类初始值设定项获得了几个参数：`title`、`dimensions`（包含`height`、`width`、`y`和`x`值的元组）`alignment`设置（默认为`LEFT`和`items`。items 参数是`MenuItems`对象的列表。这是可选的，如果未指定值，则将设置为空列表。

我们在类初始值设定项中做的第一件事是调用基类中的`__init__`方法。我们可以通过使用`super`函数来实现这一点。如果您还记得，`Panel`类上的`__init__`方法有两个参数，`title`和`dimension`，因此我们将其传递给基类初始值设定项。

接下来，我们为属性`align`和`items`赋值。

我们还需要一个方法返回菜单项列表中当前选定的项：

```py
def get_selected(self):
    items = [x for x in self.items if x.selected]
    return None if not items else items[0]
```

这种方法非常简单；理解返回所选项目列表，如果没有选择项目，则返回`None`；否则，它将返回列表中的第一项。

现在，我们可以实现处理项目选择的方法。让我们添加另一个名为`_select`的方法：

```py
def _select(self, expr):
    current = self.get_selected()
    index = self.items.index(current)
    new_index = expr(index)

    if new_index < 0:
        return

    if new_index > index and new_index >= len(self.items):
        return

    self.items[index].selected = False
    self.items[new_index].selected = True
```

在这里，我们开始选择当前项，然后使用数组中的 index 方法在菜单项列表中获取该项的索引。这是可能的，因为我们在`Panel`类中实现了`__eq__`方法。

然后，我们运行作为参数传递的函数`expr`，传递当前所选项目索引的值。

`expr`将确定下一个当前项目索引。如果新索引小于`0`，则表示我们到达了菜单项列表的顶部，因此我们不采取任何行动。

如果新索引大于当前索引，并且新索引大于或等于列表中菜单项的数量，则我们已到达列表的底部，因此此时无需执行任何操作，我们可以继续选择相同的项。

但是，如果尚未到达列表的顶部或底部，则需要交换所选项目。为此，我们将当前项的 selected 属性设置为`False`，并将下一项的 selected 属性设置为`True`。

`_select`方法是`private`方法，不打算对外调用，所以我们定义了两种方法——`next`和`previous`：

```py
def next(self):
    self._select(lambda index: index + 1)

def previous(self):
    self._select(lambda index: index - 1)
```

下一个方法将调用`_select`方法并传递一个 lambda 表达式，该表达式将接收一个索引并向其添加一个索引，上一个方法将执行相同的操作，但它不会将索引增加`1`，而是将其减去。因此，在`_select`方法中，我们调用：

```py
new_index = expr(index)
```

我们正在呼叫`lambda index: index + 1`或`lambda index: index + 1`。

伟大的现在，我们将添加一个方法，该方法将负责在屏幕上呈现菜单项之前设置菜单项的格式。创建一个名为`_initialize_items`的方法，如下图：

```py
def _initialize_items(self):
    longest_label_item = max(self.items, key=len)

    for item in self.items:
        if item != longest_label_item:
            padding = (len(longest_label_item) - len(item)) * ' '
            item.label = (f'{item}{padding}'
                          if self._align == Alignment.LEFT
                          else f'{padding}{item}')

        if not self.get_selected():
            self.items[0].selected = True
```

首先，我们得到标签最大的菜单项；我们可以通过使用内置函数`max`并传递`items`，以及另一个名为`len`的内置函数作为键来实现。这将起作用，因为我们在菜单项中实现了特殊方法`__len__`。

发现标签最大的菜单项后，我们循环浏览列表项，根据对齐选项在`LEFT`或`RIGHT`上添加填充。最后，如果列表中没有选择标志设置为`True`的菜单项，我们选择第一项作为选中项。

我们还希望提供一个名为`init`的方法，该方法将为我们初始化列表中的项目：

```py
def init(self):
    self._initialize_items()
```

我们还需要处理键盘事件，这样当用户特别按下*向上*和*向下*箭头键以及*回车*时，我们可以执行一些操作。

首先，我们需要在文件顶部定义几个常量。可以在导入和类定义之间添加以下常量：

```py
NEW_LINE = 10
CARRIAGE_RETURN = 13
```

让我们继续并包括一个名为`handle_events`的方法：

```py
    def handle_events(self, key):
        if key == curses.KEY_UP:
            self.previous()
        elif key == curses.KEY_DOWN:
            self.next()
        elif key == curses.KEY_ENTER or key == NEW_LINE or key == 
         CARRIAGE_RETURN:
            selected_item = self.get_selected()
            return selected_item.action
```

这个方法很简单；它得到一个`key`参数，如果 key 等于`curses.KEY_UP`，那么我们调用`previous`方法。如果 key 等于`curses.KEY_DOWN`，则调用`next`方法。现在，如果键是`ENTER`，那么我们获得所选项目并返回其操作。该操作是一个将执行另一个函数的函数；在我们的例子中，我们可能会在列表中选择一个艺术家或歌曲，或者执行一个播放音乐曲目的函数。

除了测试`key`是否为`curses.KEY_ENTER`外，我们还需要检查密钥是新行`\n`还是回车`\r`。这是必要的，因为*输入*键的代码可能会因运行应用的终端配置而异。

我们将实现`__iter__`方法，这将使我们的`Menu`类的行为类似于一个 iterable 对象：

```py
    def __iter__(self):
        return iter(self.items)
```

这个类的最后一个方法是`update`方法。此方法将执行渲染菜单项和刷新窗口屏幕的实际工作：

```py
def update(self):
    pos_x = 2
    pos_y = 2

    for item in self.items:
        self._win.addstr(
                pos_y,
                pos_x,
                item.label,
                curses.A_REVERSE if item.selected else 
                curses.A_NORMAL)
        pos_y += 1

    self._win.refresh()
```

首先，我们将`x`和`y`坐标设置为`2`，因此此窗口上的菜单将从`2`行和`2`列开始。我们循环浏览菜单项并调用`addstr`方法在屏幕上打印该项。

`addstr`方法获取一个`y`位置、`x`位置、将在屏幕上写入的字符串，在我们的例子中是`item.label`，最后一个参数是`style`。如果项目被选中，我们希望将其高亮显示；否则，它将以正常颜色显示。以下屏幕截图说明了渲染列表的外观：

![](img/270dbea3-ceb9-4922-8216-c30ab85c7688.png)

# 创建 DataManager 类

我们已经实现了基本功能来验证和使用来自 Spotify REST API 的数据，但是现在我们需要创建一个类来使用此功能，以便获得需要在客户端中显示的信息。

我们的 Spotify 终端客户端将执行以下操作：

*   按姓名搜索艺术家
*   列出艺术家的专辑
*   列出专辑的曲目
*   请求播放一首曲目

我们要添加的第一件事是可以引发的自定义异常，spotifyrestapi 不会返回任何结果。在`musicterminal/client`目录中创建一个名为`empty_results_error.py`的新文件，包含以下内容：

```py
class EmptyResultsError(Exception):
    pass
```

为了让我们更容易，让我们创建一个`DataManager`类，它将为我们封装所有这些功能。在`musicterminal/client`目录中创建一个名为`data_manager.py`的文件：

```py
from .menu_item import MenuItem

from pytify.core import search_artist
from pytify.core import get_artist_albums
from pytify.core import get_album_tracks
from pytify.core import play

from .empty_results_error import EmptyResultsError

from pytify.auth import authenticate
from pytify.core import read_config

class DataManager():

    def __init__(self):
        self._conf = read_config()
        self._auth = authenticate(self._conf)
```

首先，我们导入`MenuItem,`以便返回包含请求结果的`MenuItem`对象。之后，我们从`pytify`模块导入函数来搜索艺术家、获取专辑、列出专辑曲目和播放曲目。另外，在`pytify`模块中，我们导入`read_config`函数并对其进行认证。

最后，我们导入刚刚创建的自定义异常`EmptyResultsError`。

`DataManager`类的初始值设定项开始读取配置并执行认证。认证信息将存储在`_auth`属性中。

接下来，我们将添加一个搜索艺术家的方法：

```py
def search_artist(self, criteria):
    results = search_artist(criteria, self._auth)
    items = results['artists']['items']

    if not items:
        raise EmptyResultsError(f'Could not find the artist: 
        {criteria}')

    return items[0]
```

`_search_artist`方法将获取`criteria`作为参数，并从`python.core`模块调用`search_artist`函数。如果没有退货，则会引发`EmptyResultsError`；否则，它将返回第一个匹配。

在我们继续创建获取相册和曲目的方法之前，我们需要两个实用方法来格式化`MenuItem`对象的标签。

第一个将格式化艺术家标签：

```py
def _format_artist_label(self, item):
    return f'{item["name"]} ({item["type"]})'
```

在这里，标签将是项目的名称和类型，可以是相册、单曲、EP 等。

第二个设置了曲目名称的格式：

```py
def _format_track_label(self, item):

    time = int(item['duration_ms'])
    minutes = int((time / 60000) % 60)
    seconds = int((time / 1000) % 60)

    track_name = item['name']

    return f'{track_name} - [{minutes}:{seconds}]'
```

在这里，我们以毫秒为单位提取轨迹的持续时间，将其转换为`minutes: seconds`，并在方括号内格式化标签，标签上显示轨迹名称及其持续时间。

之后，让我们创建一个获取艺术家专辑的方法：

```py
def get_artist_albums(self, artist_id, max_items=20):

     albums = get_artist_albums(artist_id, self._auth)['items']

     if not albums:
         raise EmptyResultsError(('Could not find any albums for'
                                  f'the artist_id: {artist_id}'))

     return [MenuItem(self._format_artist_label(album), album)
             for album in albums[:max_items]]
```

`get_artist_albums`方法得到两个参数，`artist_id`和`max_item`，这是该方法将返回的最大相册数。默认设置为`20`。

我们在这里要做的第一件事是使用`pytify.core`模块中的`get_artist_albums`方法，传递`artist_id`和`authentication`对象，然后从结果中获取项目的属性，将其分配给变量 albums。如果`albums`变量为空，则会引发`EmptyResultsError`；否则，它将为每个相册创建一个`MenuItem`对象列表。

我们可以为轨迹添加另一种方法：

```py
def get_album_tracklist(self, album_id):

    results = get_album_tracks(album_id, self._auth)

    if not results:
        raise EmptyResultsError('Could not find the tracks for this 
        album')

    tracks = results['items']

    return [MenuItem(self._format_track_label(track), track)
            for track in tracks]
```

`get_album_tracklist`方法将`album_id`作为参数，我们要做的第一件事是使用`pytify.core`模块中的`get_album_tracks`函数获取该专辑的曲目。如果没有返回结果，我们会提出一个`EmptyResultsError`；否则，我们将建立一个`MenuItem`对象列表。

最后一种方法实际上是向 Spotify REST API 发送命令以播放曲目：

```py
def play(self, track_uri):
    play(track_uri, self._auth)
```

非常简单。在这里，我们只是将`track_uri`作为参数，并将其与`authentication`对象一起传递给`pytify.core`模块中的`play`函数。这将使曲目开始在可用设备上播放；它可以是手机、Spotify 在您计算机上的客户端、Spotify web 播放器，甚至是您的游戏机。

接下来，让我们把我们已经构建的所有东西放在一起，并运行 Spotify 播放器终端。

# 该听音乐了！

现在，我们已经具备了开始构建终端播放器所需的所有部件。我们有`pytify`模块，它提供了 Spotify RESP API 的包装，允许我们搜索艺术家、专辑、曲目，甚至控制运行在手机或计算机上的 Spotify 客户端。

`pytify`模块还提供了两种不同类型的认证客户端凭据和授权代码，在前面的部分中，我们实现了使用 curses 构建应用所需的所有基础设施。所以，让我们把所有的部分粘在一起，听一些好听的音乐。

在`musicterminal`目录下创建一个名为`app.py`的文件；这将是我们应用的入口点。我们首先添加导入语句：

```py
import curses
import curses.panel
from curses import wrapper
from curses.textpad import Textbox
from curses.textpad import rectangle

from client import Menu
from client import DataManager
```

我们当然需要进口`curses`和`curses.panel`，这次我们也在进口`wrapper`。这用于调试目的。在开发 curses 应用时，它们极难调试，当出现问题并引发异常时，终端将无法返回其原始状态。

包装器接受一个`callable`，当`callable`函数返回时，它返回终端原始状态。

包装器将在 try-catch 块中运行 callable，并在出现问题时恢复终端。在开发应用时，这对我们来说是非常好的。让我们使用包装器，以便能够看到可能发生的任何类型的问题。

我们将导入两个新功能，`Textbox`和`rectangle`。我们将使用这些来创建一个搜索框，用户可以在其中搜索他们最喜欢的艺术家。

最后，我们导入前面几节中实现的`Menu`类和`DataManager`。

让我们开始实现一些助手函数；第一个是`show_search_screen`：

```py
def show_search_screen(stdscr):
    curses.curs_set(1)
    stdscr.addstr(1, 2, "Artist name: (Ctrl-G to search)")

    editwin = curses.newwin(1, 40, 3, 3)
    rectangle(stdscr, 2, 2, 4, 44)
    stdscr.refresh()

    box = Textbox(editwin)
    box.edit()

    criteria = box.gather()
    return criteria
```

它获取一个窗口实例作为参数，因此我们可以打印文本并在屏幕上添加文本框。

`curses.curs_set`功能打开和关闭光标；当设置为`1`时，光标将在屏幕上可见。我们希望在搜索屏幕中显示，以便用户知道从何处开始键入搜索条件。然后，我们打印帮助文本，以便用户知道应该输入艺术家的姓名；然后按*Ctrl*+*G*或*输入*即可完成搜索。

为了创建文本框，我们创建了一个新的小窗口，高度等于`1`，宽度等于`40`，它从终端屏幕的`3`行`3`列开始。之后，我们使用`rectangle`函数在新窗口周围绘制一个矩形，并刷新屏幕，使所做的更改生效。

然后，我们创建`Textbox`对象，传递我们刚刚创建的窗口，并调用方法`edit`，将框设置为文本框并进入编辑模式。这将`stop`应用，并允许用户在文本框中输入一些文本；当用户点击*Ctrl*+*G*或*Enter*时退出。

当用户编辑完文本后，我们调用`gather`方法，收集用户输入的数据并分配给`criteria`变量，最后返回`criteria`。

我们还需要一个可以轻松清洁屏幕的功能，让我们创建另一个名为`clean_screen`的功能：

```py
def clear_screen(stdscr):
    stdscr.clear()
    stdscr.refresh()
```

伟大的现在，我们可以从应用的主入口点开始，创建一个名为 main 的函数，其内容如下：

```py
def main(stdscr):

    curses.cbreak()
    curses.noecho()
    stdscr.keypad(True)

    _data_manager = DataManager()

    criteria = show_search_screen(stdscr)

    height, width = stdscr.getmaxyx()

    albums_panel = Menu('List of albums for the selected artist',
                        (height, width, 0, 0))

    tracks_panel = Menu('List of tracks for the selected album',
                        (height, width, 0, 0))

    artist = _data_manager.search_artist(criteria)

    albums = _data_manager.get_artist_albums(artist['id'])

    clear_screen(stdscr)

    albums_panel.items = albums
    albums_panel.init()
    albums_panel.update()
    albums_panel.show()

    current_panel = albums_panel

    is_running = True

    while is_running:
        curses.doupdate()
        curses.panel.update_panels()

        key = stdscr.getch()

        action = current_panel.handle_events(key)

        if action is not None:
            action_result = action()
            if current_panel == albums_panel and action_result is 
            not None:
                _id, uri = action_result
                tracks = _data_manager.get_album_tracklist(_id)
                current_panel.hide()
                current_panel = tracks_panel
                current_panel.items = tracks
                current_panel.init()
                current_panel.show()
            elif current_panel == tracks_panel and action_result is  
            not None:
                _id, uri = action_result
                _data_manager.play(uri)

        if key == curses.KEY_F2:
            current_panel.hide()
            criteria = show_search_screen(stdscr)
            artist = _data_manager.search_artist(criteria)
            albums = _data_manager.get_artist_albums(artist['id'])

            clear_screen(stdscr)
            current_panel = albums_panel
            current_panel.items = albums
            current_panel.init()
            current_panel.show()

        if key == ord('q') or key == ord('Q'):
            is_running = False

        current_panel.update()

try:
    wrapper(main)
except KeyboardInterrupt:
    print('Thanks for using this app, bye!')
```

让我们将其分解为几个组成部分：

```py
curses.cbreak()
curses.noecho()
stdscr.keypad(True)
```

在这里，我们进行一些初始化。通常，诅咒不会立即注册密钥。当它被输入时，这被称为缓冲模式；用户必须键入一些内容，然后点击*回车键。*在我们的应用中，我们不希望出现这种行为；我们希望在用户键入密钥后立即注册该密钥。这就是`cbreak`所做的；它关闭了诅咒缓冲模式。

我们还使用`noecho`功能读取按键，并控制何时在屏幕上显示按键。

我们所做的最后一个 curses 设置是打开键盘，这样 curses 将相应地读取和处理按键，并返回表示已按下按键的常量值。这比尝试自己处理和测试关键代码号更干净、更容易阅读。

我们创建了`DataManager`类的一个实例，这样我们就可以获得需要在菜单上显示的数据并执行认证：

```py
_data_manager = DataManager()
```

现在，我们创建搜索对话框：

```py
criteria = show_search_screen(stdscr)
```

调用`show_search_screen`函数，传递窗口实例；它将在屏幕上呈现搜索字段，并将结果返回给我们。当用户完成输入时，用户输入将存储在`criteria`变量中。

在我们获得标准后，我们调用`get_artist_albums`，它将首先搜索一位艺术家，然后获取该艺术家的专辑列表，并返回`MenuItem`对象列表。

当返回相册列表时，我们可以使用以下菜单创建其他面板：

```py
height, width = stdscr.getmaxyx()

albums_panel = Menu('List of albums for the selected artist',
                    (height, width, 0, 0))

tracks_panel = Menu('List of tracks for the selected album',
                    (height, width, 0, 0))

artist = _data_manager.search_artist(criteria)

albums = _data_manager.get_artist_albums(artist['id'])

clear_screen(stdscr)
```

在这里，我们得到主窗口的高度和宽度，以便我们可以创建具有相同尺寸的面板。`albums_panel`将显示相册，`tracks_panel`将显示曲目；正如我前面提到的，它将具有与主窗口相同的尺寸，并且两个面板将从第`0`行、第`0`列开始。

之后，我们调用`clear_screen`准备窗口，用相册呈现菜单窗口：

```py
albums_panel.items = albums
albums_panel.init()
albums_panel.update()
albums_panel.show()

current_panel = albums_panel

is_running = True
```

我们首先用相册搜索的结果设置项目的属性。我们还在面板上调用`init`，它将在内部运行`_initialize_items`，格式化标签并设置当前所选项目。我们也称之为`update`方法，它将完成在窗口中打印菜单项的实际工作；最后，我们将演示如何将面板设置为可见。

我们还定义了`current_panel`变量，该变量将保存当前显示在终端上的面板实例。

`is_running`标志设置为`True`，将在应用的主循环中使用。当我们想要停止应用的执行时，我们会将其设置为`False`。

现在，我们进入应用的主循环：

```py
while is_running:
    curses.doupdate()
    curses.panel.update_panels()

    key = stdscr.getch()

    action = current_panel.handle_events(key)
```

首先，我们称之为`doupdate`和`update_panels`：

*   `doupdate`：Curses 保留两个数据结构，分别表示物理屏幕（终端屏幕上的一个）和虚拟屏幕（保持下一个更新的一个）。`doupdate`更新物理屏幕，使其与虚拟屏幕匹配。
*   `update_panels`：在面板堆栈中的更改、隐藏、显示面板等更改后更新虚拟屏幕。

更新屏幕后，我们等待使用`getch`功能按下一个键，并将按下的键值分配给`key`变量。然后将`key`变量传递给当前面板的`handle_events`方法。

如果您还记得`Menu`类中`handle_events`的实现，它看起来是这样的：

```py
def handle_events(self, key):
    if key == curses.KEY_UP:
        self.previous()
    elif key == curses.KEY_DOWN:
        self.next()
    elif key == curses.KEY_ENTER or key == NEW_LINE or key ==  
    CARRIAGE_RETURN:
    selected_item = self.get_selected()
    return selected_item.action
```

它处理`KEY_DOWN`、`KEY_UP`和`KEY_ENTER`。如果按键为`KEY_UP`或`KEY_DOWN`，则只需更新菜单中的位置并设置新选择的项目，并在下一次循环交互时在屏幕上更新。如果键为`KEY_ENTER`，则获取所选项目并返回其动作函数。

请记住，对于这两个面板，它都将返回一个函数，该函数在执行时将返回一个包含项 id 和项 URI 的元组。

继续，如果返回操作，我们将处理：

```py
if action is not None:
    action_result = action()
    if current_panel == albums_panel and action_result is not None:
        _id, uri = action_result
        tracks = _data_manager.get_album_tracklist(_id)
        current_panel.hide()
        current_panel = tracks_panel
        current_panel.items = tracks
        current_panel.init()
        current_panel.show()
    elif current_panel == tracks_panel and action_result is not 
    None:
        _id, uri = action_result
        _data_manager.play(uri)
```

如果当前面板的`handle_events`方法返回一个可调用的`action`，我们执行它并得到结果。然后，我们检查活动面板是否是第一个面板（带有相册）。在本例中，我们需要获取所选专辑的曲目列表，因此我们在`DataManager`实例中调用`get_album_tracklist`。
我们隐藏`current_panel,`开关，将当前面板切换到第二个面板（轨道面板），使用轨道列表设置 items 属性，调用 init 方法，使项目正确格式化，并将列表中的第一个项目设置为 selected，最后调用`show`使轨道面板可见。

如果当前面板是`tracks_panel`，我们将获得动作结果并调用`DataManager`上的播放，并传递曲目 URI。它将请求在 Spotify 上激活的设备上播放所选曲目。

现在，我们需要一种返回搜索屏幕的方法。当用户点击*F12*功能`key`*时，我们会这样做*

```py
if key == curses.KEY_F2:
    current_panel.hide()
    criteria = show_search_screen(stdscr)
    artist = _data_manager.search_by_artist_name(criteria)
    albums = _data_manager.get_artist_albums(artist['id'])

    clear_screen(stdscr)
    current_panel = albums_panel
    current_panel.items = albums
    current_panel.init()
    current_panel.show()
```

对于上面的`if`语句，测试用户是否按下*F12*功能`key`；在本例中，我们希望返回搜索屏幕，以便用户可以搜索新的艺术家。当按下*F12*键时，我们隐藏当前面板。然后，我们调用`show_search_screen`函数，以便呈现搜索屏幕，文本框将进入编辑模式，等待用户输入。

当用户完成输入并点击*Ctrl*+*G*或*Enter*时，我们搜索艺术家。然后，我们得到了艺术家的专辑，我们展示了一个专辑列表面板。

我们要处理的最后一个事件是当用户按下`q`或`Q`键时，将`is_running`变量设置为`False`，应用关闭：

```py
if key == ord('q') or key == ord('Q'):
    is_running = False
```

最后，我们在当前面板上调用`update`，因此我们重新绘制项目以反映屏幕上的变化：

```py
current_panel.update()
```

在 main 函数之外，我们有一段代码片段，在这里我们实际执行了`main`函数：

```py
try:
    wrapper(main)
except KeyboardInterrupt:
    print('Thanks for using this app, bye!')
```

我们用一个`try`catch 将其包围，因此如果用户按下*Ctrl*+*C，将引发*异常，我们只是优雅地完成应用，而不会在屏幕上抛出异常。

我们都完了！让我们试试看！

打开终端并键入命令-`python app.py`。

您将看到的第一个屏幕是搜索屏幕：

![](img/526e4ad4-49d1-401d-8c0c-d58064a728fd.png)

让我搜索我最喜欢的艺术家之一：

![](img/fdc3a925-18ee-43ea-b8e1-65fe12d2ae54.png)

按*回车*或*Ctrl*+*G 后，*会看到一张专辑列表：

![](img/131e336d-88eb-4ca7-a629-e2670ede056f.png)

在这里，您可以使用箭头键（*向上*和*向下*导航相册，然后按*回车*选择相册。然后，您将看到屏幕显示所选唱片集的所有曲目：

![](img/71f792f1-dc7c-4300-a96e-3983f7576669.png)

如果此屏幕相同，您可以使用箭头键（*Up*和*Down*选择曲目，*Enter*将发送一个请求，在您启用 Spotify 的设备上播放歌曲。

# 总结

在本章中，我们已经介绍了很多内容；我们首先在 Spotify 上创建了一个应用，并在其开发者的网站上学习我们的方法。然后，我们学习了如何实现 Spotify 支持的两种认证流：客户端凭据流和授权流。

在本章中，我们还使用 Spotify 的 RESTAPI 提供的一些功能实现了一个完整的模块包装器。

然后，我们实现了一个简单的终端客户端，用户可以在其中搜索艺术家，浏览艺术家的专辑和曲目，最后在用户的活动设备（可以是计算机、手机，甚至是视频游戏机）中播放歌曲。

在下一章中，我们将创建一个桌面应用，显示通过 Twitter hashtags 给出的投票数。*