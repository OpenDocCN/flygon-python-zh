# 一、实现天气应用

本书中的第一个应用将是一个 web 抓取应用，它将从[中抓取天气预报信息 https://weather.com](https://weather.com) 并在终端中呈现。我们将添加一些可以作为参数传递给应用的选项，例如：

*   温度单位（摄氏度或华氏度）
*   你可以得到天气预报的地区
*   输出选项，应用的用户可以在当前预测、五天预测、十天预测和周末之间进行选择
*   用额外信息（如风和湿度）补充输出的方法

除了上面提到的参数，这个应用将被设计成可扩展的，这意味着我们可以为不同的网站创建解析器来获取天气预报，这些解析器将作为参数选项提供。

在本章中，您将学习如何：

*   在 Python 应用中使用面向对象编程概念
*   使用`BeautifulSoup`包从网站上刮取数据
*   接收命令行参数
*   利用`inspect`模块
*   动态加载 Python 模块
*   使用 Python 理解
*   使用`Selenium`请求网页并检查其 DOM 元素

在我们开始之前，重要的一点是，在开发 web 抓取应用时，您应该记住，这些类型的应用容易受到更改的影响。如果从中获取数据的站点的开发人员更改了 CSS 类名或 HTML DOM 的结构，则应用将停止工作。此外，如果我们从中获取数据的站点的 URL 发生更改，应用将无法发送请求

# 建立环境

在开始编写第一个示例之前，我们需要设置一个环境来工作，并安装项目可能具有的任何依赖项。幸运的是，Python 有一个非常好的工具系统来处理虚拟环境。

Python 中的虚拟环境是一个广泛的主题，超出了本书的范围。但是，如果您不熟悉虚拟环境，那么只需知道虚拟环境是一个与全局 Python 安装隔离的包含 Python 的环境。这种隔离使开发人员能够轻松地使用不同版本的 Python，在环境中安装软件包，并管理项目依赖关系，而不会干扰 Python 的全局安装。

Python 的安装附带了一个名为`venv`的模块，您可以使用该模块创建虚拟环境；语法相当简单。我们将要创建的应用称为`weatherterm`（气象终端），因此我们可以创建一个同名的虚拟环境，使其变得简单。

要创建新的虚拟环境，请打开终端并运行以下命令：

```py
$ python3 -m venv weatherterm
```

如果一切顺利，您应该会在当前所在的目录中看到一个名为`weatherterm`的目录。现在我们有了虚拟环境，只需使用以下命令激活它：

```py
$ . weatherterm/bin/activate
```

I recommend installing and using `virtualenvwrapper`, which is an extension of the `virtualenv` tool. This makes it very simple to manage, create, and delete virtual environments as well as quickly switch between them. If you wish to investigate this further, visit: [https://virtualenvwrapper.readthedocs.io/en/latest/#](https://virtualenvwrapper.readthedocs.io/en/latest/#).

现在，我们需要创建一个目录，在其中创建应用。不要在创建虚拟环境的同一目录中创建此目录；相反，创建一个 projects 目录，并在其中为应用创建目录。为了简单起见，我建议您将其命名为与虚拟环境相同的名称。

I am setting the environment and running all the examples in a machine with Debian 9.2 installed, and at the time of writing, I am running the latest Python version (3.6.2). If you are a Mac user, it shouldn't be so different; however, if you are on Windows, the steps can be slightly different, but it is not hard to find information on how to set up virtual environments on it. A Python 3 installation works nicely on Windows nowadays.

进入您刚刚创建的项目目录，创建一个名为`requirements.txt`的文件，内容如下：

```py
beautifulsoup4==4.6.0
selenium==3.6.0
```

这些是我们需要用于此项目的所有依赖项：

*   `BeautifulSoup`**这是一个解析 HTML 和 XML 文件的包。我们将使用它来解析我们从天气站点获取的 HTML，并在终端上获取我们需要的天气数据。它的使用非常简单，并且有一个很好的在线文档，网址为：[http://beautiful-soup-4.readthedocs.io/en/latest/](http://beautiful-soup-4.readthedocs.io/en/latest/) 。**
***   `Selenium`**这是一套众所周知的测试工具。有许多应用，但它主要用于 web 应用的自动测试****

 ****要在虚拟环境中安装所需的软件包，可以运行以下命令：

```py
pip install -r requirements.txt
```

It is always a good idea to make use of version-control tools like GIT or Mercurial. It is very helpful to control changes, check history, rollback changes, and more. If you are not familiar with any of these tools, there are plenty of tutorials on the internet. You can get started by checking the documentation for GIT at: [https://git-scm.com/book/en/v1/Getting-Started](https://git-scm.com/book/en/v1/Getting-Started).

我们需要安装的最后一个工具是 PhantomJS；您可以从以下网址下载：[http://phantomjs.org/download.html](http://phantomjs.org/download.html)

下载后，提取`weatherterm`目录内的内容，并将文件夹重命名为`phantomjs.`

随着虚拟环境的建立和 PhantomJS 的安装，我们已经准备好开始编码了！

# 核心功能

让我们首先为您的模块创建一个目录。在项目的根目录中，创建一个名为`weatherterm.`的子目录`weatherterm`是我们模块所在的子目录。模块目录需要两个子目录-`core`和`parsers`。项目的目录结构应如下所示：

```py
weatherterm
├── phantomjs
└── weatherterm
    ├── core
    ├── parsers   
```

# 动态加载解析器

该应用旨在变得灵活，允许开发人员为不同的天气网站创建不同的解析器。我们将创建一个解析器加载器，它将动态发现`parsers`目录中的文件，加载它们，并使它们可供应用使用，而无需更改代码的任何其他部分。以下是我们的加载器在实现新解析器时所需的规则：

*   创建一个包含类的文件，该类实现获取当前天气预报以及五天、十天和周末天气预报的方法
*   文件名必须以`parser`结尾，例如`weather_com_parser.py`
*   文件名不能以双下划线开头

说到这里，让我们继续创建解析器加载器。在`weatherterm/core`目录中创建一个名为`parser_loader.py`的文件，并添加以下内容：

```py
import os
import re
import inspect

def _get_parser_list(dirname):
    files = [f.replace('.py', '')
             for f in os.listdir(dirname)
             if not f.startswith('__')]

    return files

def _import_parsers(parserfiles):

    m = re.compile('.+parser$', re.I)

    _modules = __import__('weatherterm.parsers',
                          globals(),
                          locals(),
                          parserfiles,
                          0)

    _parsers = [(k, v) for k, v in inspect.getmembers(_modules)
                if inspect.ismodule(v) and m.match(k)]

    _classes = dict()

    for k, v in _parsers:
        _classes.update({k: v for k, v in inspect.getmembers(v)
                         if inspect.isclass(v) and m.match(k)})

    return _classes

def load(dirname):
    parserfiles = _get_parser_list(dirname)
    return _import_parsers(parserfiles)
```

首先执行`_get_parser_list`函数，返回`weatherterm/parsers`中所有文件的列表；它将根据前面描述的解析器规则过滤文件。返回文件列表后，是时候导入模块了。这是由`_import_parsers`函数完成的，它首先导入`weatherterm.parsers`模块，并利用标准库中的 inspect 包查找模块中的解析器类。

`inspect.getmembers`函数返回元组列表，其中第一项是表示模块中属性的键，第二项是值，可以是任何类型。在我们的场景中，我们对一个属性感兴趣，该属性的键以`parser`结尾，值为 type class。

假设我们在`weatherterm/parsers`目录中已经有了解析器，`inspect.getmembers(_modules)`返回的值如下所示：

```py
[('WeatherComParser',
  <class 'weatherterm.parsers.weather_com_parser.WeatherComParser'>),
  ...]
```

`inspect.getmembers(_module)` returns many more items, but they have been omitted since it is not relevant to show all of them at this point.

最后，我们循环遍历模块中的项并提取解析器类，返回一个包含类名称和类对象的字典，该类对象将稍后用于创建解析器实例。

# 创建应用的模型

让我们开始创建一个模型，该模型将表示我们的应用将从天气网站获取的所有信息。我们要添加的第一项是一个枚举，表示我们将向应用用户提供的天气预报的每个选项。在目录`weatherterm/core`中创建一个名为`forecast_type.py`的文件，其内容如下：

```py
from enum import Enum, unique

@unique
class ForecastType(Enum):
    TODAY = 'today'
    FIVEDAYS = '5day'
    TENDAYS = '10day'
    WEEKEND = 'weekend'
```

从 3.4 版开始，枚举就在 Python 的标准库中，可以使用创建类的语法创建枚举。只需创建一个继承自`enum.Enum`的类，该类包含一组设置为常量值的唯一属性。这里，我们有应用将提供的四种预测类型的值，并且可以访问其中的值，例如`ForecastType.TODAY`、`ForecastType.WEEKEND`等等。

请注意，我们正在分配与枚举的属性项不同的常量值，原因是稍后这些值将用于构建 URL 以向天气网站发出请求。

应用还需要一个枚举来表示用户可以在命令行中选择的温度单位。此枚举将包含摄氏和华氏项目

首先，让我们包含一个基枚举。在`weatherterm/core`目录中创建一个名为`base_enum.py`的文件，包含以下内容：

```py
from enum import Enum

class BaseEnum(Enum):
    def _generate_next_value_(name, start, count, last_value):
        return name
```

`BaseEnum`是从`Enum `继承的一个非常简单的类。我们在这里要做的唯一一件事就是重写方法`_generate_next_value_`，这样从`BaseEnum`继承并具有设置为`auto() `的属性的每个枚举将自动获得与属性名相同的值。

现在，我们可以为温度单位创建枚举。在`weatherterm/core`目录中创建一个名为`unit.py`的文件，内容如下：

```py
from enum import auto, unique

from .base_enum import BaseEnum

@unique
class Unit(BaseEnum):
    CELSIUS = auto()
    FAHRENHEIT = auto()
```

这个类继承了我们刚刚创建的`BaseEnum`，并且每个属性都设置为`auto()`，这意味着枚举中每个项目的值都会自动为我们设置。由于`Unit`类继承自`BaseEnum`，因此每次调用`auto()`时，都会调用`BaseEnum `上的`_generate_next_value_`方法，并返回属性本身的名称。

在我们尝试之前，让我们在`weatherterm/core`目录中创建一个名为`__init__.py`的文件，并导入我们刚刚创建的枚举，如下所示：

```py
from .unit import Unit
```

如果我们在 Python REPL 中加载此类并检查这些值，将出现以下情况：

```py
Python 3.6.2 (default, Sep 11 2017, 22:31:28) 
[GCC 6.3.0 20170516] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> from weatherterm.core import Unit
>>> [value for key, value in Unit.__members__.items()]
[<Unit.CELSIUS: 'CELSIUS'>, <Unit.FAHRENHEIT: 'FAHRENHEIT'>]
```

我们还想添加到应用核心模块的另一项是一个类，用于表示解析器返回的天气预报数据。让我们继续在`weatherterm/core`目录中创建一个名为`forecast.py`的文件，其内容如下：

```py
from datetime import date

from .forecast_type import ForecastType

class Forecast:
    def __init__(
            self,
            current_temp,
            humidity,
            wind,
            high_temp=None,
            low_temp=None,
            description='',
            forecast_date=None,
            forecast_type=ForecastType.TODAY):
        self._current_temp = current_temp
        self._high_temp = high_temp
        self._low_temp = low_temp
        self._humidity = humidity
        self._wind = wind
        self._description = description
        self._forecast_type = forecast_type

        if forecast_date is None:
            self.forecast_date = date.today()
        else:
            self._forecast_date = forecast_date

    @property
    def forecast_date(self):
        return self._forecast_date

    @forecast_date.setter
    def forecast_date(self, forecast_date):
        self._forecast_date = forecast_date.strftime("%a %b %d")

    @property
    def current_temp(self):
        return self._current_temp

    @property
    def humidity(self):
        return self._humidity

    @property
    def wind(self):
        return self._wind

    @property
    def description(self):
        return self._description

    def __str__(self):
        temperature = None
        offset = ' ' * 4

        if self._forecast_type == ForecastType.TODAY:
            temperature = (f'{offset}{self._current_temp}\xb0\n'
                           f'{offset}High {self._high_temp}\xb0 / '
                           f'Low {self._low_temp}\xb0 ')
        else:
            temperature = (f'{offset}High {self._high_temp}\xb0 / '
                           f'Low {self._low_temp}\xb0 ')

        return(f'>> {self.forecast_date}\n'
               f'{temperature}'
               f'({self._description})\n'
               f'{offset}Wind: '
               f'{self._wind} / Humidity: {self._humidity}\n')
```

在 Forecast 类中，我们将为要分析的所有数据定义属性：

| `current_temp` | 表示当前温度。只有在得到今天的天气预报时才能使用。 |
| `humidity` | 一天的湿度百分比。 |
| `wind` | 有关当前风力等级的信息。 |
| `high_temp` | 一天的最高温度。 |
| `low_temp` | 一天的最低温度。 |
| `description` | 天气状况的描述，例如*部分多云。* |
| `forecast_date` | 预测日期；如果未提供，将设置为当前日期。 |
| `forecast_type` | 枚举`ForecastType`（`TODAY`、`FIVEDAYS`、`TENDAYS`或`WEEKEND`中的任何值）。 |

我们还可以通过 decorator`@property `和`@forecast_date.setter `实现两个名为`forecast_date `的方法。`@property `修饰符会将该方法转换为 Forecast 类`_forecast_date`属性的 getter，`@forecast_date.setter`会将该方法转换为 setter。setter 是在这里定义的，因为每次我们需要在`Forecast`实例中设置日期时，我们都需要确保它会被相应地格式化。在 setter 中，我们调用`strftime`方法，传递格式代码`%a`（平日缩写名称）、`%b`（月缩写名称）和`%d`（月中日期）。

The format codes `%a` and `%b` will use the locale configured in the machine that the code is running on.

最后，我们重写了`__str__`方法，以允许我们按照使用`print`、`format`和`str`函数时所希望的方式格式化输出。

默认情况下，`weather.com`使用的温度单位是`Fahrenheit`，我们希望让应用的用户可以选择使用摄氏度。那么，让我们继续在`weatherterm/core`目录中创建一个名为`unit_converter.py`的文件，内容如下：

```py
from .unit import Unit

class UnitConverter:
    def __init__(self, parser_default_unit, dest_unit=None):
        self._parser_default_unit = parser_default_unit
        self.dest_unit = dest_unit

        self._convert_functions = {
            Unit.CELSIUS: self._to_celsius,
            Unit.FAHRENHEIT: self._to_fahrenheit,
        }

    @property
    def dest_unit(self):
        return self._dest_unit

    @dest_unit.setter
    def dest_unit(self, dest_unit):
        self._dest_unit = dest_unit

    def convert(self, temp):

        try:
            temperature = float(temp)
        except ValueError:
            return 0

        if (self.dest_unit == self._parser_default_unit or
                self.dest_unit is None):
            return self._format_results(temperature)

        func = self._convert_functions[self.dest_unit]
        result = func(temperature)

        return self._format_results(result)

    def _format_results(self, value):
        return int(value) if value.is_integer() else f'{value:.1f}'

    def _to_celsius(self, fahrenheit_temp):
        result = (fahrenheit_temp - 32) * 5/9
        return result

    def _to_fahrenheit(self, celsius_temp):
        result = (celsius_temp * 9/5) + 32
        return result
```

这是一个将温度从摄氏度转换为华氏度的类，反之亦然。此类的初始值设定项获取两个参数；解析器和目标单元使用的默认单元。在初始值设定项中，我们将定义一个字典，其中包含用于温度单位转换的函数。

`convert`方法只得到一个参数，即温度。这里，温度是一个字符串，所以我们需要做的第一件事是尝试将其转换为浮点值；如果失败，它将立即返回一个零值。

您还可以验证目标单元是否与解析器的默认单元相同。在这种情况下，我们不需要继续执行任何转换；我们只需格式化值并返回它。

如果我们需要执行转换，我们可以在`_convert_functions `字典中查找需要运行的`conversion`函数。如果找到要查找的函数，我们将调用它并返回格式化的值。

下面的代码片段显示了`_format_results`方法，这是一种实用方法，可以为我们格式化温度值：

```py
return int(value) if value.is_integer() else f'{value:.1f}'
```

`_format_results`方法检查数字是否为整数；例如，如果数字为 10.0，`value.is_integer()`将返回`True`。如果是`True`，我们将使用`int`函数将值转换为 10；否则，该值将作为精度为 1 的定点数字返回。Python 中的默认精度为 6。最后，有两种实用方法执行温度转换，`_to_celsius`和`_to_fahrenheit`。

现在，我们只需要编辑`weatherterm/core`目录中的`__init__.py`文件，并包含以下导入语句：

```py
from .base_enum import BaseEnum
from .unit_converter import UnitConverter
from .forecast_type import ForecastType
from .forecast import Forecast
```

# 从天气网站获取数据

我们将添加一个名为`Request`的类，负责从天气网站获取数据。我们在`weatherterm/core`目录中添加一个名为`request.py`的文件，内容如下：

```py
import os
from selenium import webdriver

class Request:
    def __init__(self, base_url):
        self._phantomjs_path = os.path.join(os.curdir,
                                          'phantomjs/bin/phantomjs')
        self._base_url = base_url
        self._driver = webdriver.PhantomJS(self._phantomjs_path)

    def fetch_data(self, forecast, area):
        url = self._base_url.format(forecast=forecast, area=area)
        self._driver.get(url)

        if self._driver.title == '404 Not Found':
            error_message = ('Could not find the area that you '
                             'searching for')
            raise Exception(error_message)

        return self._driver.page_source
```

这门课很简单；初始值设定项定义基本 URL 并使用安装 PhantomJS 的路径创建 PhantomJS 驱动程序。`fetch_data`方法格式化 URL，添加预测选项和区域。之后，`webdriver`执行请求并返回页面源。如果返回的标记标题为`404 Not Found`，则会引发异常。不幸的是，`Selenium`没有提供获取 HTTP 状态码的正确方法；这比比较字符串要好得多。

You may notice that I prefix some of the class properties with an underscore sign. I usually do that to show that the underlying property is private and shouldn't be set outside the class. In Python, there is no need to do that because there's no way to set private or public properties; however, I like it because I can clearly show my intent.

现在我们可以导入到`weatherterm/core`目录下的`__init__.py `文件中：

```py
from .request import Request
```

现在我们有了一个解析器加载器来加载我们放入目录`weatherterm/parsers`中的任何解析器，我们有一个表示预测模型的类和一个枚举`ForecastType`，这样我们就可以指定我们正在解析的预测类型。枚举表示温度单位和实用函数，用于将温度从`Fahrenheit`转换为`Celsius`和`Celsius`转换为`Fahrenheit.`，因此现在，我们应该准备好创建应用的入口点，以接收用户传递的所有参数，运行解析器，并在终端上显示数据。

# 使用 ArgumentParser 获取用户的输入

在第一次运行应用之前，我们需要添加应用的入口点。入口点是执行应用时将运行的第一个代码

我们希望为应用的用户提供尽可能好的用户体验，因此我们需要添加的第一个功能是接收和解析命令行参数、执行参数验证、在需要时设置参数，以及最后但并非最不重要的功能，显示一个有组织且信息丰富的帮助系统，以便用户可以看到可以使用哪些参数以及如何使用应用

听起来像是乏味的工作，对吧？

幸运的是，Python 包含了电池，标准库包含了一个很棒的模块，允许我们以非常简单的方式实现它；该模块称为`argparse`。

另一个很好的特性是，我们的应用可以很容易地分发给用户。一种方法是在`weatherterm`模块目录中创建一个`__main__.py`文件，您可以将模块作为常规脚本运行。Python 会自动运行`__main__.py`文件，如下所示：

```py
$ python -m weatherterm
```

另一个选项是压缩整个应用的目录，并执行传递 zip 文件名的 Python。这是一种分发 Python 程序的简单、快速的方法。

有许多其他的方法来分发你的程序，但它们超出了本书的范围；我只是想给大家举一些关于`__main__.py`文件用法的例子。

话虽如此，让我们在`weatherterm`目录中创建一个包含以下内容的`__main__.py`文件：

```py
import sys
from argparse import ArgumentParser

from weatherterm.core import parser_loader
from weatherterm.core import ForecastType
from weatherterm.core import Unit

def _validate_forecast_args(args):
    if args.forecast_option is None:
        err_msg = ('One of these arguments must be used: '
                   '-td/--today, -5d/--fivedays, -10d/--tendays, -
                    w/--weekend')
        print(f'{argparser.prog}: error: {err_msg}', 
        file=sys.stderr)
        sys.exit()

parsers = parser_loader.load('./weatherterm/parsers')

argparser = ArgumentParser(
    prog='weatherterm',
    description='Weather info from weather.com on your terminal')

required = argparser.add_argument_group('required arguments')

required.add_argument('-p', '--parser',
                      choices=parsers.keys(),
                      required=True,
                      dest='parser',
                      help=('Specify which parser is going to be  
                       used to '
                            'scrape weather information.'))

unit_values = [name.title() for name, value in Unit.__members__.items()]

argparser.add_argument('-u', '--unit',
                       choices=unit_values,
                       required=False,
                       dest='unit',
                       help=('Specify the unit that will be used to 
                       display '
                             'the temperatures.'))

required.add_argument('-a', '--areacode',
                      required=True,
                      dest='area_code',
                      help=('The code area to get the weather 
                       broadcast from. '
                            'It can be obtained at 
                              https://weather.com'))

argparser.add_argument('-v', '--version',
                       action='version',
                       version='%(prog)s 1.0')

argparser.add_argument('-td', '--today',
                       dest='forecast_option',
                       action='store_const',
                       const=ForecastType.TODAY,
                       help='Show the weather forecast for the 
                       current day')

args = argparser.parse_args()

_validate_forecast_args(args)

cls = parsers[args.parser]

parser = cls()
results = parser.run(args)

for result in results:
    print(results)
```

我们的应用将不需要接受的天气预报选项（今天、五天、十天和周末预报）；但是，命令行中必须至少提供一个选项，因此我们创建一个名为`_validate_forecast_args`的简单函数来为我们执行此验证。此功能将显示帮助消息并退出应用。

首先，我们在`weatherterm/parsers`目录中获得所有可用的解析器。解析器列表将用作解析器参数的有效值。

正是`ArgumentParser`对象完成了定义参数、解析值和显示帮助的工作，因此我们创建了`ArgumentParser`的一个实例，还为所需参数创建了一个参数组。这将使帮助输出看起来更好、更有条理。

为了使参数和帮助输出更有条理，我们将在`ArgumentParser`对象中创建一个组。此组将包含应用需要的所有必需参数。通过这种方式，我们的应用的用户可以很容易地看到哪些参数是必需的，哪些参数不是必需的。

我们通过以下声明实现这一目标：

```py
required = argparser.add_argument_group('required arguments')
```

在为所需参数创建参数组后，我们将获得枚举`Unit`的所有成员的列表，并使用`title()`函数仅将第一个字母设置为大写字母。

现在，我们可以开始添加应用能够在命令行上接收的参数。大多数参数定义使用同一组关键字参数，因此我将不介绍所有这些参数。

我们将创建的第一个参数是`--parser`或`-p`：

```py
required.add_argument('-p', '--parser',
                      choices=parsers.keys(),
                      required=True,
                      dest='parser',
                      help=('Specify which parser is going to be 
                       used to '
                            'scrape weather information.'))
```

我们来分解创建解析器标志时使用的`add_argument `的每个参数：

*   前两个参数是标志。在这种情况下，用户使用命令行中的`-p`或`--parser`向该参数传递一个值，例如`--parser WeatherComParser`。
*   `choices`参数为我们正在创建的参数指定有效值的列表。这里，我们使用的是`parsers.keys()`，它将返回一个解析器名称列表。这种实现的优点是，如果我们添加一个新的解析器，它将自动添加到此列表中，并且不需要对此文件进行任何更改。
*   正如名字所说，`required`参数指定是否需要该参数。
*   `dest`参数指定要添加到解析器参数的结果对象的属性的名称。`parser_args()`返回的对象将包含一个名为`parser`的属性，该属性的值是我们在命令行中传递给此参数的。
*   最后，`help`参数是参数的帮助文本，在使用`-h`或`--help`标志时显示。

继续讨论`--today`论点：

```py
argparser.add_argument('-td', '--today',
                       dest='forecast_option',
                       action='store_const',
                       const=ForecastType.TODAY,
                       help='Show the weather forecast for the 
                       current day')
```

这里有两个我们以前从未见过的关键字参数，`action`和`const`。

动作可以绑定到我们创建的参数，它们可以执行许多事情。`argparse`模块包含一组很棒的动作，但是如果你需要做一些特定的事情，你可以创建自己的动作来满足你的需要。`argparse`模块中定义的大多数动作都是在解析结果的对象属性中存储值的动作。

在前面的代码片段中，我们使用了`store_const`操作，它将为`parse_args()`返回的对象中的属性存储一个常量值。

我们还使用了关键字参数`const`，它指定了在命令行中使用标志时的常量默认值。

记得我说过可以创建自定义操作吗？参数单元是自定义操作的一个很好的用例。`choices`参数只是一个字符串列表，因此我们使用这种理解来获得`Unit`枚举中每个项的名称列表，如下所示：

```py
unit_values = [name.title() for name, value in Unit.__members__.items()]

required.add_argument('-u', '--unit',
                      choices=unit_values,
                      required=False,
                      dest='unit',
                      help=('Specify the unit that will be used to 
                       display '
                            'the temperatures.'))
```

`parse_args()`返回的对象将包含一个名为 unit 的属性，该属性具有字符串值（`Celsius`或`Fahrenheit`，但这并不是我们想要的。将该值作为枚举项不是很好吗？我们可以通过创建自定义操作来更改此行为。

首先，在`weatherterm/core`目录中添加一个名为`set_unit_action.py`的新文件，其内容如下：

```py
from argparse import Action

from weatherterm.core import Unit

class SetUnitAction(Action):

    def __call__(self, parser, namespace, values,    
     option_string=None):
        unit = Unit[values.upper()]
        setattr(namespace, self.dest, unit)
```

这个动作类很简单；它只是从`argparse.Action`继承并重写`__call__`方法，解析参数值时将调用该方法。这将被设置为 destination 属性。

`parser`参数将是`ArgumentParser`的一个实例。名称空间是`argparser.Namespace`的一个实例，它只是一个简单的类，包含`ArgumentParser`对象中定义的所有属性。如果使用调试器检查此参数，您将看到类似以下内容：

```py
Namespace(area_code=None, fields=None, forecast_option=None, parser=None, unit=None)
```

`values`参数是用户在命令行上传递的值；在我们的例子中，温度可以是摄氏度，也可以是华氏度。最后，`option_string`参数是为参数定义的标志。对于 unit 参数，`option_string`的值将是`-u`。

幸运的是，Python 中的枚举允许我们使用 item access 访问其成员和属性：

```py
Unit[values.upper()]
```

在 Python REPL 中验证这一点，我们有：

```py
>>> from weatherterm.core import Unit
>>> Unit['CELSIUS']
<Unit.CELSIUS: 'CELSIUS'>
>>> Unit['FAHRENHEIT']
<Unit.FAHRENHEIT: 'FAHRENHEIT'>
```

在获得正确的枚举成员后，我们在 namespace 对象中设置由`self.dest`指定的属性的值。这是更干净，我们不需要处理魔术字符串。

定制操作就绪后，我们需要在`weatherterm/core`目录的`__init__.py`文件中添加导入语句：

```py
from .set_unit_action import SetUnitAction
```

只需在文件末尾包含上面的行。然后，我们需要将其导入到`__main__.py`文件中，如下所示：

```py
from weatherterm.core import SetUnitAction
```

我们将在 unit 参数的定义中添加`action`关键字参数，并将其设置为`SetUnitAction`，如下所示：

```py
required.add_argument('-u', '--unit',
                      choices=unit_values,
                      required=False,
                      action=SetUnitAction,
                      dest='unit',
                      help=('Specify the unit that will be used to 
                       display '
                            'the temperatures.'))
```

因此，当我们的应用的用户使用标志`-u`表示摄氏度时，`parse_args() `函数返回的对象中属性单位的值将为：

`<Unit.CELSIUS: 'CELSIUS'>`

代码的其余部分非常简单；我们调用`parse_args`函数来解析参数，并在`args`变量中设置结果。然后，我们使用`args.parser`（所选解析器的名称）的值并访问解析器字典中的该项。请记住，该值是类类型，因此我们创建了一个解析器实例，最后，调用方法 run，这将启动网站抓取。

# 创建解析器

为了第一次运行我们的代码，我们需要创建一个解析器。我们可以快速创建一个解析器来运行代码，并检查值是否被正确解析。

让我们继续在`weatherterm/parsers`目录中创建一个名为`weather_com_parser.py`的文件。为了简单起见，我们将只创建必要的方法，当调用这些方法时，我们要做的唯一一件事就是提出一个`NotImplementedError`：

```py
from weatherterm.core import ForecastType

class WeatherComParser:

    def __init__(self):
        self._forecast = {
            ForecastType.TODAY: self._today_forecast,
            ForecastType.FIVEDAYS: self._five_and_ten_days_forecast,
            ForecastType.TENDAYS: self._five_and_ten_days_forecast,
            ForecastType.WEEKEND: self._weekend_forecast,
            }

    def _today_forecast(self, args):
        raise NotImplementedError()

    def _five_and_ten_days_forecast(self, args):
        raise NotImplementedError()

    def _weekend_forecast(self, args):
        raise NotImplementedError()

    def run(self, args):
        self._forecast_type = args.forecast_option
        forecast_function = self._forecast[args.forecast_option]
        return forecast_function(args)
```

在初始值设定项中，我们创建一个字典，其中键是`ForecasType`枚举的成员，值是绑定到这些选项中任何一个的方法。我们的应用将能够显示今天、五天、十天和周末的预测，因此我们实现了所有四种方法。

`run`方法只做两件事；它使用我们在命令行中作为参数传递的`forecast_option`查找需要执行的函数，并执行返回其值的函数。

现在，如果在命令行中运行该命令，应用终于可以第一次执行了：

```py
$ python -m weatherterm --help
```

您应该看到应用的帮助选项：

```py
usage: weatherterm [-h] -p {WeatherComParser} [-u {Celsius,Fahrenheit}] -a AREA_CODE [-v] [-td] [-5d] [-10d] [-w]

Weather info from weather.com on your terminal

optional arguments:
 -h, --help show this help message and exit
 -u {Celsius,Fahrenheit}, --unit {Celsius,Fahrenheit}
 Specify the unit that will be used to display 
 the temperatures.
 -v, --version show program's version number and exit
 -td, --today Show the weather forecast for the current day

require arguments:
 -p {WeatherComParser}, --parser {WeatherComParser}
 Specify which parser is going to be used to scrape
 weather information.
 -a AREA_CODE, --areacode AREA_CODE
 The code area to get the weather broadcast from. It
 can be obtained at https://weather.com
```

如您所见，`ArgumentParse`模块已经提供了现成的帮助输出。有很多方法可以自定义输出，但是我发现默认布局非常好。

注意，`-p`参数已经给了您选择`WeatherComParser`的选项。无需在任何地方硬编码，因为解析器加载程序为我们完成了所有工作。`-u`（`--unit`）标志还包含枚举`Unit`的项目。如果有一天您想扩展此应用并添加新单位，您只需在此处将新项目添加到枚举中，它将自动拾取并作为`-u`标志的选项包含。

现在，如果再次运行应用，并且这次传递一些参数：

```py
$ python -m weatherterm -u Celsius -a SWXX2372:1:SW -p WeatherComParser -td
```

您将得到类似以下情况的异常：

![](img/c2b594fc-7ad7-4b4f-877a-3476564ec7f6.png)

别担心，这正是我们想要的！如果您遵循堆栈跟踪，您可以看到一切都按预期工作。当我们运行代码时，我们从`__main__.py`文件中调用所选解析器上的`run`方法，然后选择与预测选项关联的方法，在本例中为`_today_forecast`，最后将结果存储在`forecast_function`变量中。

当执行存储在`forecast_function`变量中的函数时，引发`NotImplementedError`异常。到现在为止，一直都还不错；代码运行良好，现在我们可以开始为这些方法中的每一个添加实现。

# 获取今天的天气预报

核心功能已经到位，并且应用的入口点和参数解析器将为应用的用户提供更好的体验。现在，终于到了我们都在等待的时候了，开始实现解析器的时候了。我们将开始实施获取今天天气预报的方法。

由于我在瑞典，我将使用区号`SWXX2372:1:SW`（瑞典斯德哥尔摩）；但是，您可以使用任何您想要的区号。要获取您选择的区号，请转至[https://weather.com](https://weather.com) 并搜索所需区域。选择区域后，将显示当天的天气预报。请注意，URL 会更改，例如，在搜索瑞典斯德哥尔摩时，URL 会更改为：

[https://weather.com/weather/today/l/SWXX2372:1:SW](https://weather.com/weather/today/l/SWXX2372:1:SW)

巴西圣保罗将：

[https://weather.com/weather/today/l/BRXX0232:1:BR](https://weather.com/weather/today/l/BRXX0232:1:BR)

请注意，URL 只有一部分发生了更改，这是我们希望作为参数传递给应用的区号。

# 添加助手方法

首先，我们需要导入一些包：

```py
import re

from weatherterm.core import Forecast
from weatherterm.core import Request
from weatherterm.core import Unit
from weatherterm.core import UnitConverter
```

在初始值设定项中，我们将添加以下代码：

```py
self._base_url = 'http://weather.com/weather/{forecast}/l/{area}'
self._request = Request(self._base_url)

self._temp_regex = re.compile('([0-9]+)\D{,2}([0-9]+)')
self._only_digits_regex = re.compile('[0-9]+')

self._unit_converter = UnitConverter(Unit.FAHRENHEIT)
```

在初始值设定项中，我们定义将用于执行对天气网站的请求的 URL 模板；然后，我们创建一个`Request`对象。这是将为我们执行请求的对象。

正则表达式仅在解析今天的天气预报温度时使用。

我们还定义了一个`UnitConverter`对象，并将默认单位设置为`Fahrenheit`。

现在，我们准备开始添加两个方法，它们将负责实际搜索特定类中的 HTML 元素并返回其内容。第一种方法称为`_get_data`：

```py
def _get_data(self, container, search_items):
    scraped_data = {}

    for key, value in search_items.items():
        result = container.find(value, class_=key)

        data = None if result is None else result.get_text()

        if data is not None:
            scraped_data[key] = data

    return scraped_data
```

这种方法的思想是在符合某些条件的容器中搜索项目。`container`只是 HTML 中的一个 DOM 元素，`search_items`是一个字典，其中键是 CSS 类，值是 HTML 元素的类型。它可以是 DIV、SPAN 或任何您希望从中获取值的内容。

它开始循环通过`search_items.items()`并使用 find 方法查找容器中的元素。如果找到该项，我们将使用`get_text`提取 DOM 元素的文本，并将其添加到字典中，当没有更多的项可搜索时，将返回该字典。

我们要实现的第二种方法是`_parser`方法。这将利用我们刚刚实现的`_get_data`：

```py
def _parse(self, container, criteria):
    results = [self._get_data(item, criteria)
               for item in container.children]

    return [result for result in results if result]
```

在这里，我们也得到了一个`container`和`criteria`，就像`_get_data`方法一样。容器是一个 DOM 元素，标准是我们要查找的节点字典。第一个理解获取容器的所有子元素，并将它们传递给`_get_data`方法。

结果将是一个包含所有已找到项的词典列表，我们将只返回不为空的词典。

为了得到今天的天气预报，我们只需要实施另外两种辅助方法。让我们实现一个名为`_clear_str_number`的方法：

```py
def _clear_str_number(self, str_number):
    result = self._only_digits_regex.match(str_number)
    return '--' if result is None else result.group()
```

此方法将使用正则表达式确保只返回数字。

最后一种需要实现的方法是`_get_additional_info`方法：

```py
def _get_additional_info(self, content):
    data = tuple(item.td.span.get_text()
                 for item in content.table.tbody.children)
    return data[:2]
```

此方法循环遍历表行，获取每个单元格的文本。这种理解将返回许多关于天气的信息，但我们只对第一个`2`感兴趣，即风和湿度。

# 实施今日天气预报

是时候开始添加`_today_forecast`方法的实现了，但是首先，我们需要导入`BeautifulSoup`。在文件顶部，添加以下导入语句：

```py
from bs4 import BeautifulSoup
```

现在，我们可以开始添加`_today_forecast`方法：

```py
def _today_forecast(self, args):
    criteria = {
        'today_nowcard-temp': 'div',
        'today_nowcard-phrase': 'div',
        'today_nowcard-hilo': 'div',
        }

    content = self._request.fetch_data(args.forecast_option.value,
                                       args.area_code)

    bs = BeautifulSoup(content, 'html.parser')

    container = bs.find('section', class_='today_nowcard-container')

    weather_conditions = self._parse(container, criteria)

    if len(weather_conditions) < 1:
        raise Exception('Could not parse weather foreecast for 
        today.')

    weatherinfo = weather_conditions[0]

    temp_regex = re.compile(('H\s+(\d+|\-{,2}).+'
                             'L\s+(\d+|\-{,2})'))
    temp_info = temp_regex.search(weatherinfo['today_nowcard-hilo'])
    high_temp, low_temp = temp_info.groups()

    side = container.find('div', class_='today_nowcard-sidecar')
    humidity, wind = self._get_additional_info(side)

    curr_temp = self._clear_str_number(weatherinfo['today_nowcard- 
    temp'])

    self._unit_converter.dest_unit = args.unit

    td_forecast = Forecast(self._unit_converter.convert(curr_temp),
                           humidity,
                           wind,
                           high_temp=self._unit_converter.convert(
                               high_temp),
                           low_temp=self._unit_converter.convert(
                               low_temp),
                           description=weatherinfo['today_nowcard-
                            phrase'])

    return [td_forecast]
```

这是在命令行上使用`-td`或`--today`标志时将调用的函数。让我们把这段代码分解一下，这样我们就可以很容易地理解它的功能了。理解此方法非常重要，因为这些方法解析来自其他天气预报选项（五天、十天和周末）的数据，这些选项与此非常相似。

该方法的签名非常简单；它只获取`args`，这是在`__main__`方法中创建的`Argument`对象。在这个方法中，我们要做的第一件事是创建一个包含我们希望在标记中找到的所有 DOM 元素的`criteria`字典：

```py
criteria = {
    'today_nowcard-temp': 'div',
    'today_nowcard-phrase': 'div',
    'today_nowcard-hilo': 'div',
}
```

如前所述，`criteria`字典的键是 DOM 元素的 CSS 类的名称，值是 HTML 元素的类型：

*   `today_nowcard-temp`类是包含当前温度的 DOM 元素的 CSS 类
*   `today_nowcard-phrase`类是 DOM 元素的 CSS 类，包含天气条件文本（Cloudy、Sunny 等）
*   `today_nowcard-hilo`类是包含最高和最低温度的 DOM 元素的 CSS 类

接下来，我们将获取、创建并使用`BeautifulSoup`解析 DOM：

```py
content = self._request.fetch_data(args.forecast_option.value, 
                                   args.area_code)

bs = BeautifulSoup(content, 'html.parser')

container = bs.find('section', class_='today_nowcard-container')

weather_conditions = self._parse(container, criteria)

if len(weather_conditions) < 1:
    raise Exception('Could not parse weather forecast for today.')

weatherinfo = weather_conditions[0]
```

首先，我们使用我们在核心模块上创建的`Request`类的`fetch_data`方法，并传递两个参数；第一个是 forecast 选项，第二个参数是我们在命令行上传递的区号。
获取数据后，我们创建一个通过`content`和`parser`的`BeautifulSoup`对象。因为我们要返回 HTML，所以我们使用`html.parser`。

现在是开始寻找我们感兴趣的 HTML 元素的时候了。记住，我们需要找到一个将成为容器的元素，`_parser`函数将搜索子元素，并尝试查找我们在字典标准中定义的项目。对于今天的天气预报，包含我们需要的所有数据的元素是一个带有`today_nowcard-container`CSS 类的`section`元素。

`BeautifulSoup`包含`find`方法，我们可以使用该方法在 HTML DOM 中查找具有特定条件的元素。注意，关键字参数被称为`class_`而不是`class`，因为`class`在 Python 中是一个保留字。

现在我们有了 container 元素，我们可以将它传递给`_parse`方法，该方法将返回一个列表。我们检查结果列表是否包含至少一个元素，如果结果列表为空则引发异常。如果它不是空的，我们只获取第一个元素并将其分配给`weatherinfo`变量。`weatherinfo`变量现在包含一个字典，其中包含我们要查找的所有项目。

下一步是划分最高和最低温度：

```py
temp_regex = re.compile(('H\s+(\d+|\-{,2}).+'
                         'L\s+(\d+|\-{,2})'))
temp_info = temp_regex.search(weatherinfo['today_nowcard-hilo'])
high_temp, low_temp = temp_info.groups()
```

我们想用`today_nowcard-hilo`CSS 类解析从 DOM 元素中提取的文本，文本应该类似于`H 50 L 60`、`H -- L 60`等等。提取所需文本的简单方法是使用正则表达式：

`H\s+(\d+|\-{,2}).L\s+(\d+|\-{,2})`

我们可以把这个正则表达式分成两部分。首先，我们想要得到最高温度-`H\s+(\d+|\-{,2})`；这意味着它将匹配一个后跟一些空格的`H`，然后它将分组一个匹配数字或最多两个破折号的值。之后，它将匹配任何字符。最后是第二部分，基本上也是这样；但是，它开始匹配一个`L`。

在执行 search 方法之后，它将获得调用`groups()`函数返回的正则表达式组，在本例中，该函数将返回两个组，一个用于最高温度，另一个用于最低温度。

我们想向用户提供的其他信息是关于风和湿度的信息。包含此信息的容器元素有一个名为`today_nowcard-sidecar`的 CSS 类：

```py
side = container.find('div', class_='today_nowcard-sidecar')
wind, humidity = self._get_additional_info(side)
```

我们只需找到容器并将其传递到`_get_additional_info`方法，该方法将循环遍历容器的子元素，提取文本并最终为我们返回结果。

最后，该方法的最后一部分：

```py
curr_temp = self._clear_str_number(weatherinfo['today_nowcard-temp'])

self._unit_converter.dest_unit = args.unit

td_forecast = Forecast(self._unit_converter.convert(curr_temp),
                       humidity,
                       wind,
                       high_temp=self._unit_converter.convert(
                           high_temp),
                       low_temp=self._unit_converter.convert(
                           low_temp),
                       description=weatherinfo['today_nowcard- 
                        phrase'])

return [td_forecast]
```

由于当前温度包含一个特殊字符（度符号），我们不希望在此时使用它，因此我们使用`_clr_str_number`方法传递`weatherinfo`字典的`today_nowcard-temp`项。

现在我们已经获得了所需的所有信息，我们构造了`Forecast`对象并返回它。注意，我们在这里返回一个数组；这是因为我们将要实施的所有其他选项（五天、十天和周末预测）都将返回一个列表，以便保持一致；此外，为了方便我们在终端上显示这些信息，我们还返回了一个列表。

另一件需要注意的事情是，我们正在使用我们的`UnitConverter`转换方法将所有温度转换为命令行中选择的单位。

再次运行该命令时：

```py
$ python -m weatherterm -u Fahrenheit -a SWXX2372:1:SW -p WeatherComParser -td
```

您应该会看到类似以下内容的输出：

![](img/1f2ea039-104c-4786-a400-ae107a248609.png)

祝贺您已经实现了第一个 web 抓取应用。接下来，让我们添加其他预测选项。

# 获取五天和十天天气预报

我们目前正在从（[weather.com](https://weather.com/en-IN/)上抓取天气预报的网站也提供
五天和十天的天气预报，因此在本节中，我们也将实现解析这些预报选项的方法。

显示五天和十天数据的页面的标记非常相似；它们具有相同的 DOM 结构和共享相同的 CSS 类，这使得我们更容易实现一种方法，该方法将适用于这两个选项。让我们继续向`wheater_com_parser.py`文件添加一个新方法，内容如下：

```py
def _parse_list_forecast(self, content, args):
    criteria = {
        'date-time': 'span',
        'day-detail': 'span',
        'description': 'td',
        'temp': 'td',
        'wind': 'td',
        'humidity': 'td',
    }

    bs = BeautifulSoup(content, 'html.parser')

    forecast_data = bs.find('table', class_='twc-table')
    container = forecast_data.tbody

    return self._parse(container, criteria)
```

正如我前面提到的，五天和十天天气预报的 DOM 非常相似，因此我们创建了`_parse_list_forecast`方法，这两种方法都可以使用。首先，我们定义标准：

*   `date-time`是一个`span`元素，包含一个表示一周中某一天的字符串
*   `day-detail`是一个`span`元素，包含一个带有日期的字符串，例如`SEP 29`
*   `description`是`TD`元素，包含天气条件，例如``Cloudy``
*   `temp`是`TD`元素，包含高温、低温等温度信息
*   `wind`是`TD`元素，包含风信息
*   `humidity`是一个`TD`元素，包含湿度信息

现在我们有了标准，我们创建了一个`BeatufulSoup`对象，传递内容和`html.parser`。我们想要得到的所有数据都在表中，表中有一个名为`twc-table`的 CSS 类。我们找到表并将`tbody`元素定义为容器。
最后，我们运行`_parse`方法，通过我们定义的`container`和`criteria`。此函数的返回如下所示：

```py
[{'date-time': 'Today',
  'day-detail': 'SEP 28',
  'description': 'Partly Cloudy',
  'humidity': '78%',
  'temp': '60°50°',
  'wind': 'ESE 10 mph '},
 {'date-time': 'Fri',
  'day-detail': 'SEP 29',
  'description': 'Partly Cloudy',
  'humidity': '79%',
  'temp': '57°48°',
  'wind': 'ESE 10 mph '},
 {'date-time': 'Sat',
  'day-detail': 'SEP 30',
  'description': 'Partly Cloudy',
  'humidity': '77%',
  'temp': '57°49°',
  'wind': 'SE 10 mph '},
 {'date-time': 'Sun',
  'day-detail': 'OCT 1',
  'description': 'Cloudy',
  'humidity': '74%',
  'temp': '55°51°',
  'wind': 'SE 14 mph '},
 {'date-time': 'Mon',
  'day-detail': 'OCT 2',
  'description': 'Rain',
  'humidity': '87%',
  'temp': '55°48°',
  'wind': 'SSE 18 mph '}]
```

我们需要创建的另一个方法是为我们准备数据的方法，例如，解析和转换温度值并创建`Forecast`对象。添加一个名为`_prepare_data`的新方法，内容如下：

```py
def _prepare_data(self, results, args):
    forecast_result = []

    self._unit_converter.dest_unit = args.unit

    for item in results:
        match = self._temp_regex.search(item['temp'])
        if match is not None:
            high_temp, low_temp = match.groups()

        try:
            dateinfo = item['weather-cell']
            date_time, day_detail = dateinfo[:3], dateinfo[3:]
            item['date-time'] = date_time
            item['day-detail'] = day_detail
        except KeyError:
            pass

        day_forecast = Forecast(
            self._unit_converter.convert(item['temp']),
            item['humidity'],
            item['wind'],
            high_temp=self._unit_converter.convert(high_temp),
            low_temp=self._unit_converter.convert(low_temp),
            description=item['description'].strip(),
            forecast_date=f'{item["date-time"]} {item["day-
             detail"]}',
            forecast_type=self._forecast_type)
        forecast_result.append(day_forecast)

    return forecast_result
```

这个方法很简单。首先，循环遍历结果并应用我们创建的正则表达式来分割`item['temp']`中存储的高温和低温。如果存在匹配项，它将获取组并将值分配给`high_temp`和`low_temp`。

之后，我们创建一个`Forecast`对象，并将其附加到稍后将返回的列表中。

最后，我们添加了当使用`-5d`或`-10d`标志时将调用的方法。创建另一个名为`_five_and_ten_days_forecast`的方法，其内容如下：

```py
def _five_and_ten_days_forecast(self, args):
    content = self._request.fetch_data(args.forecast_option.value, 
    args.area_code)
    results = self._parse_list_forecast(content, args)
    return self._prepare_data(results)
```

此方法仅获取通过`forecast_option`值和区号的页面内容，因此可以构建 URL 来执行请求。当返回数据时，我们将其传递给`_parse_list_forecast`，它将返回`Forecast`对象列表（每天一个）；最后，我们使用`_prepare_data`方法准备要返回的数据。

在运行命令之前，我们需要在我们实现的命令行工具中启用此选项；转到`__main__.py`文件，在`-td`标志定义之后，添加以下代码：

```py
argparser.add_argument('-5d', '--fivedays',
                       dest='forecast_option',
                       action='store_const',
                       const=ForecastType.FIVEDAYS,
                       help='Shows the weather forecast for the next         
                       5 days')
```

现在，再次运行应用，但这次使用`-5d`或`--fivedays`标志：

```py
$ python -m weatherterm -u Fahrenheit -a SWXX2372:1:SW -p WeatherComParser -5d
```

它将产生以下输出：

```py
>> [Today SEP 28]
 High 60° / Low 50° (Partly Cloudy)
 Wind: ESE 10 mph / Humidity: 78%

>> [Fri SEP 29]
 High 57° / Low 48° (Partly Cloudy)
 Wind: ESE 10 mph / Humidity: 79%

>> [Sat SEP 30]
 High 57° / Low 49° (Partly Cloudy)
 Wind: SE 10 mph / Humidity: 77%

>> [Sun OCT 1]
 High 55° / Low 51° (Cloudy)
 Wind: SE 14 mph / Humidity: 74%

>> [Mon OCT 2]
 High 55° / Low 48° (Rain)
 Wind: SSE 18 mph / Humidity: 87%
```

为了结束本节，让我们在`__main__.py`文件中，在`-5d`标志定义的正下方，加入获取未来十天天气预报的选项。添加以下代码：

```py
argparser.add_argument('-10d', '--tendays',
                       dest='forecast_option',
                       action='store_const',
                       const=ForecastType.TENDAYS,
                       help='Shows the weather forecast for the next  
                       10 days')
```

如果您运行与我们过去获取五天预测相同的命令，但将`-5d`标志替换为`-10d`，如下所示：

```py
$ python -m weatherterm -u Fahrenheit -a SWXX2372:1:SW -p WeatherComParser -10d
```

您应该看到十天天气预报输出：

```py
>> [Today SEP 28]
 High 60° / Low 50° (Partly Cloudy)
 Wind: ESE 10 mph / Humidity: 78%

>> [Fri SEP 29]
 High 57° / Low 48° (Partly Cloudy)
 Wind: ESE 10 mph / Humidity: 79%

>> [Sat SEP 30]
 High 57° / Low 49° (Partly Cloudy)
 Wind: SE 10 mph / Humidity: 77%

>> [Sun OCT 1]
 High 55° / Low 51° (Cloudy)
 Wind: SE 14 mph / Humidity: 74%

>> [Mon OCT 2]
 High 55° / Low 48° (Rain)
 Wind: SSE 18 mph / Humidity: 87%

>> [Tue OCT 3]
 High 56° / Low 46° (AM Clouds/PM Sun)
 Wind: S 10 mph / Humidity: 84%

>> [Wed OCT 4]
 High 58° / Low 47° (Partly Cloudy)
 Wind: SE 9 mph / Humidity: 80%

>> [Thu OCT 5]
 High 57° / Low 46° (Showers)
 Wind: SSW 8 mph / Humidity: 81%

>> [Fri OCT 6]
 High 57° / Low 46° (Partly Cloudy)
 Wind: SW 8 mph / Humidity: 76%

>> [Sat OCT 7]
 High 56° / Low 44° (Mostly Sunny)
 Wind: W 7 mph / Humidity: 80%

>> [Sun OCT 8]
 High 56° / Low 44° (Partly Cloudy)
 Wind: NNE 7 mph / Humidity: 78%

>> [Mon OCT 9]
 High 56° / Low 43° (AM Showers)
 Wind: SSW 9 mph / Humidity: 79%

>> [Tue OCT 10]
 High 55° / Low 44° (AM Showers)
 Wind: W 8 mph / Humidity: 79%

>> [Wed OCT 11]
 High 55° / Low 42° (AM Showers)
 Wind: SE 7 mph / Humidity: 79%

>> [Thu OCT 12]
 High 53° / Low 43° (AM Showers)
 Wind: NNW 8 mph / Humidity: 87%
```

正如你所看到的，在我写这本书的时候，瑞典的天气不是很好。

# 获取周末天气预报

我们将在应用中实现的最后一个天气预报选项是获取即将到来的周末天气预报的选项。此实现与其他实现略有不同，因为周末天气返回的数据与今天、五天和十天的天气预报略有不同。

DOM 结构不同，一些 CSS 类名也不同。如果您还记得我们以前实现的方法，那么我们总是使用`_parser`方法，它为我们提供了一些参数，比如容器 DOM 和带有搜索条件的字典。该方法的返回值也是一个字典，其中键是我们正在搜索的 DOM 的类名，值是该 DOM 元素中的文本

由于周末页面的 CSS 类名不同，我们需要实现一些代码来获取结果数组，并重命名所有键，以便`_prepare_data`函数可以正确使用刮取的结果。

话虽如此，让我们继续在`weatherterm/core`目录中创建一个名为`mapper.py`的新文件，其内容如下：

```py
class Mapper:

    def __init__(self):
        self._mapping = {}

    def _add(self, source, dest):
        self._mapping[source] = dest

    def remap_key(self, source, dest):
        self._add(source, dest)

    def remap(self, itemslist):
        return [self._exec(item) for item in itemslist]

    def _exec(self, src_dict):
        dest = dict()

        if not src_dict:
            raise AttributeError('The source dictionary cannot be  
            empty or None')

        for key, value in src_dict.items():
            try:
                new_key = self._mapping[key]
                dest[new_key] = value
            except KeyError:
                dest[key] = value
        return dest
```

`Mapper`类获取一个包含字典的列表，并重命名我们想要重命名的特定键。这里的重要方法是`remap_key`和`remap`。`remap_key`有两个参数，`source`和`dest`。`source`是我们希望重命名的密钥，`dest`是该密钥的新名称。`remap_key`方法将其添加到名为`_mapping`的内部字典中，该字典稍后将用于查找新的密钥名。

`remap`方法只是获取一个包含字典的列表，对于该列表中的每个项目，它调用`_exec`方法，该方法首先创建一个全新的字典，然后检查字典是否为空。在这种情况下，它会引发一个`AttributeError`。

如果字典中有键，我们将遍历它的项，搜索当前项的键在映射字典中是否有新名称。如果找到新的密钥名称，将使用新的密钥名称创建新项目；否则，我们就保留原来的名字。循环结束后，返回列表，其中包含具有新名称的键的所有词典。

现在，我们只需要将其添加到`weatherterm/core`目录中的`__init__.py`文件中：

```py
from .mapper import Mapper
```

在`weatherterm/parsers`的`weather_com_parser.py`文件中，我们需要导入`Mapper`：

```py
from weatherterm.core import Mapper
```

有了映射器，我们可以继续在`weather_com_parser.py`文件中创建`_weekend_forecast`方法，如下所示：

```py
def _weekend_forecast(self, args):
    criteria = {
        'weather-cell': 'header',
        'temp': 'p',
        'weather-phrase': 'h3',
        'wind-conditions': 'p',
        'humidity': 'p',
    }

    mapper = Mapper()
    mapper.remap_key('wind-conditions', 'wind')
    mapper.remap_key('weather-phrase', 'description')

    content = self._request.fetch_data(args.forecast_option.value,
                                       args.area_code)

    bs = BeautifulSoup(content, 'html.parser')

    forecast_data = bs.find('article', class_='ls-mod')
    container = forecast_data.div.div

    partial_results = self._parse(container, criteria)
    results = mapper.remap(partial_results)

    return self._prepare_data(results, args)
```

该方法首先以与其他方法完全相同的方式定义标准；但是，DOM 结构略有不同，一些 CSS 名称也有所不同：

*   `weather-cell`：包含预测日期：`FriSEP 29`
*   `temp`：包含温度（高、低）：`57°F48°F`
*   `weather-phrase`：包含天气条件：`Cloudy`
*   `wind-conditions`：风信息
*   `humidity`：湿度百分比

如您所见，为了使其与`_prepare_data`方法配合使用，我们需要重命名结果集中字典中的一些键—`wind-conditions`应该是`wind`，而`weather-phrase`应该是`description`。

幸运的是，我们引入了`Mapper`类来帮助我们：

```py
mapper = Mapper()
mapper.remap_key('wind-conditions', 'wind')
mapper.remap_key('weather-phrase', 'description')
```

我们创建一个`Mapper`对象，然后说，将`wind-conditions`重新映射到`wind`和`weather-phrase`到`description`：

```py
content = self._request.fetch_data(args.forecast_option.value,
                                   args.area_code)

bs = BeautifulSoup(content, 'html.parser')

forecast_data = bs.find('article', class_='ls-mod')
container = forecast_data.div.div

partial_results = self._parse(container, criteria)
```

我们获取所有数据，使用`html.parser`创建`BeautifulSoup`对象，并找到包含我们感兴趣的子元素的容器元素。对于 weekend forecast，我们感兴趣的是使用 CSS 类`ls-mod`获取`article`元素，在`article`中，我们进入第一个子元素，它是一个 DIV，并获取它的第一个子元素，它也是一个 DIV 元素。

HTML 应该如下所示：

```py
<article class='ls-mod'>
  <div>
    <div>
      <!-- this DIV will be our container element -->
    </div>
  </div>
</article>
```

这就是为什么我们首先找到文章，将其分配给`forecast_data`，然后使用`forecast_data.div.div`，从而得到所需的 DIV 元素。

定义容器后，将其与容器元素一起传递给`_parse`方法；当我们返回结果时，我们只需要运行`Mapper`实例的`remap`方法，在调用`_prepare_data`之前，它将为我们规范化数据。

现在，在我们运行应用并获取周末天气预报之前的最后一个细节是，我们需要在`ArgumentParser`中包含`--w`和`--weekend`标志。打开`weatherterm`目录中的`__main__.py`文件，在`--tenday`标志下方添加以下代码：

```py
argparser.add_argument('-w', '--weekend',
                       dest='forecast_option',
                       action='store_const',
                       const=ForecastType.WEEKEND,
                       help=('Shows the weather forecast for the 
                             next or '
                             'current weekend'))
```

伟大的现在，使用`-w`或`--weekend`标志运行应用：

```py
>> [Fri SEP 29]
 High 13.9° / Low 8.9° (Partly Cloudy)
 Wind: ESE 10 mph / Humidity: 79%

>> [Sat SEP 30]
 High 13.9° / Low 9.4° (Partly Cloudy)
 Wind: SE 10 mph / Humidity: 77%

>> [Sun OCT 1]
 High 12.8° / Low 10.6° (Cloudy)
 Wind: SE 14 mph / Humidity: 74%
```

注意，这一次，我使用`-u`标志选择摄氏度。输出中的所有温度都以摄氏度而不是华氏度表示。

# 总结

在本章中，您学习了 Python 中面向对象编程的基础知识；我们介绍了如何创建类、使用继承以及使用`@property`装饰器来创建 getter 和 setter。

我们介绍了如何使用 inspect 模块来获取有关模块、类和函数的更多信息。最后但并非最不重要的一点是，我们利用功能强大的软件包`Beautifulsoup`解析 HTML，并`Selenium`向天气网站发出请求。

我们还学习了如何使用 Python 标准库中的`argparse`模块实现命令行工具，这使我们能够提供更易于使用的工具和非常有用的文档。

接下来，我们将围绕 SpotifyRESTAPI 开发一个小包装器，并使用它创建一个远程控制终端。****