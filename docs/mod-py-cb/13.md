# 十三、应用集成

在本章中，我们将介绍以下配方：

*   查找配置文件
*   对配置文件使用 YAML
*   将 Python 用于配置文件
*   使用类作为配置值的命名空间
*   为作文设计脚本
*   使用日志记录控制和审核输出
*   将两个应用程序合并为一个
*   使用命令设计模式组合许多应用程序
*   管理复合应用程序中的参数和配置
*   包装和组合 CLI 应用程序
*   包装程序并检查输出
*   控制复杂的步骤序列

# 导言

Python 的可扩展库为我们提供了对大量计算资源的丰富访问。这使得 Python 程序在集成组件以创建复杂的复合处理方面特别强大。

在*使用 argparse 获取命令行输入*、*使用 cmd 创建命令行应用程序*、*使用[第 5 章](05.html#page "Chapter 5. User Inputs and Outputs")中的操作系统环境设置*配方、*用户输入和输出*中，创建顶级应用程序的具体技术（主要）显示了应用程序脚本。在[第 9 章](09.html#page "Chapter 9. Input/Output, Physical Format, and Logical Layout")、*输入/输出、物理格式、逻辑布局*中，我们查看了文件系统输入和输出。在[第 12 章](12.html#page "Chapter 12. Web Services")、*Web 服务*中，我们研究了如何创建服务器，这些服务器是接收客户端请求的主要应用程序。

所有这些示例都展示了 Python 应用程序编程的一些方面。还有一些其他技术很有帮助：

*   正在处理来自文件的配置。在[第 5 章](05.html#page "Chapter 5. User Inputs and Outputs")中*使用 argparse 获取命令行输入*配方*用户输入和输出*中，我们展示了解析命令行参数的技术。在*使用操作系统环境设置*的配方中，我们谈到了其他类型的配置细节。在本章中，我们将介绍一些处理配置文件的方法。有许多文件格式可用于存储长期配置信息：
    *   `configparser`模块处理的 INI 文件格式。
    *   YAML 文件格式非常容易使用，但需要一个目前不属于 Python 发行版的附加模块。我们将在*使用 YAML 进行配置文件*配方中了解这一点。
    *   属性文件格式是 Java 编程的典型格式，可以在 Python 中处理，而无需编写太多代码。语法与 Python 脚本重叠。
    *   对于 Python 脚本，带有赋值语句的文件看起来很像属性文件，并且使用`compile()`和`exec()`方法非常容易处理。我们将在*使用 Python 进行配置文件*配方中了解这一点。
    *   带有类定义的 Python 模块是一种变体，它使用 Python 语法，但将设置隔离到单独的类中。这可以通过`import`语句进行处理。我们将在*中使用类作为配置*的名称空间来了解这一点。
*   在本章中，我们将探讨设计应用程序的方法，这些应用程序可以组合起来创建更大、更复杂的复合应用程序。
*   我们将研究复合应用程序可能带来的复杂性，以及集中一些功能（如命令行解析）的需要。
*   我们将扩展[第 6 章](06.html#page "Chapter 6. Basics of Classes and Objects")、*类和对象基础*和[第 7 章](07.html#page "Chapter 7. More Advanced Class Design")、*更高级的类设计*中的一些概念，并将命令设计模式的思想应用到 Python 程序中。

# 查找配置文件

许多应用程序将具有配置选项的层次结构。特定版本中可能内置了默认值。可能存在服务器范围（或群集范围）的值。可能存在特定于用户的值，甚至可能存在特定于程序调用的本地配置文件。

在许多情况下，这些配置参数将写入文件中，以便易于更改。Linux 的共同传统是将系统范围的配置放在`/etc`目录中。用户的个人更改将位于其主目录中，通常命名为`~username`。

我们如何为配置文件支持丰富的位置层次结构？

## 准备好了吗

示例将是一个向用户提供手牌的 web 服务。该服务在[第 12 章](12.html#page "Chapter 12. Web Services")、*Web 服务*中的几个配方中显示。我们将忽略该服务的一些细节，以便我们能够集中精力从各种文件系统位置获取配置参数。

我们将遵循**bash**shell 的设计模式，它在几个地方查找配置文件：

1.  它以`/etc/profile`文件开头。
2.  读取该文件后，它将按以下顺序查找其中一个文件：
    1.  `~/.bash_profile`。
    2.  `~/.bash_login`。
    3.  `~/.profile`。

在兼容 POSIX 的操作系统中，shell 将`~`扩展为登录用户的主目录。这被定义为`HOME`环境变量的值。一般来说，Python`pathlib`模块可以自动处理这个问题。

有几种方法可以保留程序的配置参数：

*   使用类定义具有极大的灵活性和相对简单的 Python 语法。它可以使用普通继承来包含默认值。当有多个参数源时，它就不起作用了，因为没有简单的方法来改变类定义。
*   对于映射参数，我们可以使用`ChainMap`集合搜索多个字典，每个字典来自不同的源。
*   对于`SimpleNamespace`实例，`types`模块提供了这个类，这个类是可变的，可以从多个源进行更新。
*   来自`argparse`模块的`Namespace`实例非常方便，因为它反映了来自命令行的选项。

bashshell 中的设计模式使用两个单独的文件。当我们包括应用程序范围的默认值时，实际上有三个级别的配置。这可以通过映射和来自`collections`模块的`ChainMap`类优雅地完成。

在后面的菜谱中，我们将研究解析和处理配置文件的方法。在本配方中，我们假设已定义一个函数`load_config_file()`，该函数将从文件内容加载配置映射：

```py
    def load_config_file(config_file): 
        '''Loads a configuration mapping object with contents 
        of a given file. 

        :param config_file: File-like object that can be read. 
        :returns: mapping with configuration parameter values 
        ''' 
        # Details omitted. 

```

我们将分别研究实现此功能的方法。本章的*使用 YAML 处理配置文件*和*使用 Python 处理配置文件*配方中介绍了实现的各种变化。

`pathlib`模块可以帮助进行此处理。该模块提供了`Path`类定义，该类定义提供了大量有关操作系统文件的复杂信息。更多信息，请参见[第 9 章](09.html#page "Chapter 9. Input/Output, Physical Format, and Logical Layout")、*输入/输出、物理格式、逻辑布局*中的*使用 pathlib 处理文件名*配方。

### 为什么选择这么多？

在讨论这种设计时，有时会出现一个侧栏主题：为什么有这么多选择？为什么不确切地指定两个地方呢？

答案取决于设计的背景。当创建一个全新的应用程序时，可以仅选择两个。但是，在替换遗留应用程序时，通常会有一个在某些方面比遗留位置更好的新位置，但遗留位置仍然需要支持。经过几次这样的进化变化后，通常会看到文件的许多替代位置。

此外，由于 Linux 发行版之间的差异，通常会看到一个发行版的典型差异，而另一个发行版的非典型差异。当然，在处理 Windows 时，也会有该平台独有的各种文件路径。

## 怎么做。。。

1.  导入`Path`类和`ChainMap`类：

    ```py
            from pathlib import Path 
            from collections import ChainMap

    ```

2.  定义获取配置文件的整体功能：

    ```py
            def get_config():

    ```

3.  为各个位置创建路径。这些称为纯路径，因为它们与文件系统没有关系。它们以*潜在*文件的名称开始：

    ```py
            system_path = Path('/etc/profile') 
            home_path = Path('~').expanduser() 
            local_paths = [home_path/'.bash_profile', 
                home_path/'.bash_login', 
                home_path/'.profile'] 

    ```

4.  定义应用程序的内置默认值：

    ```py
            configuration_items = [ 
                dict( 
                    some_setting = 'Default Value', 
                    another_setting = 'Another Default', 
                    some_option = 'Built-In Choice', 
                ) 
            ] 

    ```

5.  每个单独的配置文件都是从键到值的映射。各种映射对象将形成一个列表；这将成为最终的`ChainMap`配置映射。我们将通过附加项来组装地图列表，然后在加载文件后颠倒顺序。
6.  如果存在系统范围的配置文件，则加载此文件：

    ```py
            if system_path.exists(): 
                with system_path.open() as config_file: 
                    configuration_items.append(config_file) 

    ```

7.  Iterate through other locations looking for a file to load. This loads the first of the files that it finds:

    ```py
            for config_path in local_paths:
                if config_path.exists(): 
                    with config_path.open() as config_file: 
                        configuration_items.append(config_file) 
                    break

    ```

    我们已经包含了在找到第一个文件后停止的**if break**模式。这将从 For All 的默认语义修改循环，以表示存在。有关更多信息，请参阅“避免中断语句的潜在问题”配方。

8.  反转列表并创建最终的`ChainMap`。列表需要反转，以便首先搜索本地文件，然后搜索系统设置，最后搜索应用程序默认设置：

    ```py
            configuration = ChainMap(*reversed(configuration_items)) 

    ```

9.  Return the final configuration mapping:

    ```py
            return configuration

    ```

    一旦我们构建了`configuration`对象，我们就可以像使用简单映射一样使用最终配置。此对象支持所有预期的字典操作。

## 它是如何工作的。。。

任何面向对象语言最优雅的特性之一就是能够创建简单的对象集合。在这种情况下，对象是文件系统`Path`对象。

如[第 9 章](09.html#page "Chapter 9. Input/Output, Physical Format, and Logical Layout")*输入/输出、物理格式、逻辑布局*中*使用 pathlib 处理文件名*配方中所述，`Path`对象有一个`resolve()`方法，可以返回从纯`Path`构建的具体`Path`。在这个配方中，我们使用`exists()`方法来确定是否可以建造一条具体的道路。`open()`方法用于读取文件时，将解析纯`Path`并打开相关文件。

在*创建字典[第 4 章](04.html#page "Chapter 4. Built-in Data Structures – list, set, dict")中插入和更新*配方*内置数据结构【列表、集合、dict*中，我们了解了使用字典的基础知识。在这里，我们把几本词典合并成一个链。如果密钥不在链的第一个字典中，则会检查链中的后续字典。这是一种为映射中的每个键提供默认值的简便方法。

下面是一个手动创建`ChainMap`的示例：

```py
>>> from collections import ChainMap 
>>> config = ChainMap( 
...     {'another_setting': 2}, 
...     {'some_setting': 1}, 
...     {'some_setting': 'Default Value', 
...      'another_setting': 'Another Default', 
...      'some_option': 'Built-In Choice'})

```

`config`对象由三个单独的映射构建。第一个可能是来自本地文件的详细信息，例如`~/.bash_login`。第二个可能是来自`/etc/profile`文件的系统范围的设置。第三个包含应用程序范围的默认值。

以下是我们查询此对象的值时看到的内容：

```py
>>> config['another_setting'] 
2 
>>> config['some_setting'] 
1 
>>> config['some_option'] 
'Built-In Choice'

```

任何给定键的值都取自映射链中该键的第一个实例。这允许使用一种非常简单的方法，使本地值覆盖覆盖内置默认值的系统范围值。

## 还有更多。。。

在[第 11 章](11.html#page "Chapter 11. Testing")、*测试*中的*模拟外部资源*配方中，我们研究了模拟外部资源的方法，以便编写一个不会意外删除文件的单元测试。此配方中代码的测试需要通过模拟`Path`类来模拟文件系统资源。下面是单元测试的外观，从测试类的高级大纲开始：

```py
    import unittest 
    from unittest.mock import * 

    class GIVEN_get_config_WHEN_load_THEN_overrides(unittest.TestCase): 
        def setUp(self): 

        def runTest(self): 

```

这为单元测试提供了样板结构。模拟一个`Path`变得相当复杂，因为涉及到许多不同的对象。以下是发生的对象创建类型的摘要：

1.  对`Path`类的调用将创建一个`Path`对象。测试过程将创建两个`Path`对象，因此我们可以使用`side_effect`功能返回其中的每一个。我们需要根据待测试单元中的代码确保值的顺序正确：

    ```py
            self.mock_path = Mock( 
                side_effect = [self.mock_system_path, self.mock_home_path] 
            ) 

    ```

2.  对于`system_path`的值，会调用`Path`对象`exists()`方法；这将确定具体文件是否存在。然后会有打开文件并读取内容的调用：

    ```py
            self.mock_path = Mock( 
                side_effect = [self.mock_system_path, self.mock_home_path] 
            ) 

    ```

3.  对于`home_path`的值，将调用`expanduser()`方法将`~`更改为正确的主目录：

    ```py
            self.mock_home_path = Mock( 
                expanduser = Mock( 
                    return_value = self.mock_expanded_home_path 
                ) 
            ) 

    ```

4.  扩展的`home_path`然后与`/`操作符一起创建三个备选目录：

    ```py
            self.mock_expanded_home_path = MagicMock( 
                __truediv__ = Mock( 
                    side_effect = [self.not_exist, self.exist, self.exist] 
                ) 
            ) 

    ```

5.  为了单元测试的目的，我们决定第一条搜索路径不存在。另外两个确实存在，但我们希望只读取其中一个。第二个将被忽略：
    *   对于不存在的模拟路径，我们可以使用：

        ```py
                    self.not_exist = Mock( 
                        exists = Mock(return_value=False) )
        ```

    *   For the mock paths that exist, we'll have something more complex:

        ```py
                    self.exist = Mock( exists = Mock(return_value=True), open = mock_open() ) 

        ```

        我们还必须通过模拟模块中的`mock_open()`函数处理文件。这可以处理用作上下文管理器的文件的所有各种细节，这变得相当复杂。`with`语句需要`__enter__()`和`__exit__()`方法，由`mock_open()`处理。

我们必须以相反的顺序组装这些模拟对象。这确保每个变量在使用前都已创建。以下是整个`setUp()`方法，以正确的顺序显示对象：

```py
    def setUp(self): 
        self.mock_system_path = Mock( 
            exists = Mock(return_value=True), 
            open = mock_open() 
        ) 
        self.exist = Mock( 
            exists = Mock(return_value=True), 
            open = mock_open() 
        ) 
        self.not_exist = Mock( 
            exists = Mock(return_value=False) 
        ) 
        self.mock_expanded_home_path = MagicMock( 
            __truediv__ = Mock( 
                side_effect = [self.not_exist, self.exist, self.exist] 
            ) 
        ) 
        self.mock_home_path = Mock( 
            expanduser = Mock( 
                return_value = self.mock_expanded_home_path 
            ) 
        ) 
        self.mock_path = Mock( 
            side_effect = [self.mock_system_path, self.mock_home_path] 
        ) 

        self.mock_load = Mock( 
            side_effect = [{'some_setting': 1}, {'another_setting': 2}] 
        ) 

```

除了用于`Path`操作的模拟之外，我们还添加了一个模拟模块。`mock_load`对象是未定义`load_config_file()`的替代对象。我们希望将此测试与路径处理分开，因此 mock 对象使用`side_effect`属性返回两个单独的值，期望它将被精确调用两次。

下面是一些测试，这些测试将确认路径搜索是否如广告所示工作。每个测试都从应用两个补丁开始，以创建用于测试`get_config()`功能的修改上下文：

```py
    def runTest(self): 
        with patch('__main__.Path', self.mock_path), \ 
        patch('__main__.load_config_file', self.mock_load): 
            config = get_config() 
        # print(config) 
        self.assertEqual(2, config['another_setting']) 
        self.assertEqual(1, config['some_setting']) 
        self.assertEqual('Built-In Choice', config['some_option']) 

```

第一次使用`patch()`将`Path`类替换为`self.mock_path`。第二次使用`patch()`将`load_config_file()`功能替换为`self.mock_load`功能；此函数将返回两个小的配置文档。在这两种情况下，被修补的上下文都是当前模块，`__name__`值为`"__main__"`。在单元测试位于单独模块中的情况下，将导入正在测试的模块，并使用该模块的名称。

我们可以通过检查对`self.mock_load`的调用来检查`load_config_file()`是否被正确调用。在这种情况下，每个配置文件都应该有一个：

```py
    self.mock_load.assert_has_calls( 
        [
            call(self.mock_system_path.open.return_value.__enter__.return_value), 
            call(self.exist.open.return_value.__enter__.return_value) 
        ] 
    ) 

```

我们已确保先检查`self.mock_system_path`文件。注意调用链-`Path()`返回一个`Path`对象。该对象的`open()`必须返回一个将用作上下文的值。上下文的`__enter__()`方法是`load_config_file()`函数将使用的对象。

我们已经确定另一条路径是`exists()`方法返回`True`的路径。以下是对生成的文件名的检查：

```py
    self.mock_expanded_home_path.assert_has_calls( 
        [call.__truediv__('.bash_profile'), 
        call.__truediv__('.bash_login'), 
        call.__truediv__('.profile')] 
    ) 

```

`/`操作符通过`__truediv__()`方法实现。每个调用都会在`Path`实例中构建一个单独的实例。我们可以确认，总体而言，`Path`对象只使用了两次。一次用于文字`'/etc/profile'`和一次用于文字`'~'`：

```py
    self.mock_path.assert_has_calls( 
        [call('/etc/profile'), call('~')] 
    ) 

```

请注意，有两个文件对`exists()`方法进行了`True`应答。然而，我们预计这两项中只有一项将得到核查。找到该文件后，将忽略第二个文件。下面是一个测试，它确认只有一个存在的检查：

```py
    self.exist.assert_has_calls( [call.exists()] ) 

```

为了完整起见，我们还检查了存在的文件是否会经历整个上下文管理序列：

```py
    self.exist.open.assert_has_calls( 
        [call(), call().__enter__(), call().__exit__(None, None, None)] 
    )

```

第一个调用是对`self.exist`对象的`open()`方法的调用。此函数的返回值是一个上下文，它将执行`__enter__()`方法和`__exit__()`方法。在前面的代码中，我们检查是否读取了来自`__enter__()`的返回值以获取配置文件内容。

## 另见

*   在*使用 YAML 作为配置文件*和*使用 Python 作为配置文件*的方法中，我们将研究实现`load_config_file()`功能的方法。
*   在[第 11 章](11.html#page "Chapter 11. Testing")*测试*中的*模拟外部资源*配方中，我们研究了测试此类与外部资源交互的功能的方法。

# 配置文件使用 YAML

Python 提供了多种打包应用程序输入和配置文件的方法。我们将研究用 YAML 符号编写文件，因为它优雅而简单。

我们如何用 YAML 符号表示配置细节？

## 准备好了吗

Python 没有内置 YAML 解析器。我们需要使用`pip`包管理系统将`pyyaml`项目添加到我们的库中。以下是安装的外观：

```py
MacBookPro-SLott:pyweb slott$ pip3.5 install pyyaml 

Collecting pyyaml 

 Downloading PyYAML-3.11.zip (371kB) 

 100% |████████████████████████████████| 378kB 2.5MB/s

Installing collected packages: pyyaml 
  Running setup.py install for pyyaml ... done 
Successfully installed pyyaml-3.11

```

YAML 语法的优雅之处在于使用了简单的缩进来显示文档的结构。下面是我们可能在 YAML 中编码的一些设置的示例：

```py
query: 
  mz: 
    - ANZ532 
    - AMZ117 
    - AMZ080 
url: 
  scheme: http 
  netloc: forecast.weather.gov 
  path: /shmrn.php 
description: > 
  Weather forecast for Offshore including the Bahamas

```

本文档可被视为许多相关 URL 的规范，这些 URL 都类似于[http://forecast.weather.gov/shmrn.php?mz=ANZ532](http://forecast.weather.gov/shmrn.php?mz=ANZ532) 。该文档包含有关从方案、网络位置、基本路径和多个查询字符串生成 URL 的信息。`yaml.load()`功能可以加载此 YAML 文档；它将创建以下 Python 结构：

```py
{'description': 'Weather forecast for Offshore including the Bahamas\n', 
 'query': {'mz': ['ANZ532', 'AMZ117', 'AMZ080']}, 
 'url': {'netloc': 'forecast.weather.gov', 
         'path': 'shmrn.php', 
         'scheme': 'http'}}

```

dict 结构的*dict 可以被应用程序用来定制其操作。在本例中，它指定了一系列要查询的 URL，以组装更大的天气简报。*

我们将经常使用*查找配置文件*方法来检查各种位置以查找给定的配置文件。这种灵活性对于创建易于在各种平台上使用的应用程序来说通常是必不可少的。

在这个配方中，我们将构建上一个示例中缺少的部分，`load_config_file()`函数。以下是需要填写的模板：

```py
    def load_config_file(config_file) -> dict: 
        '''Loads a configuration mapping object with contents 
        of a given file. 

        :param config_file: File-like object that can be read. 
        :returns: mapping with configuration parameter values 
        ''' 
        # Details omitted. 

```

## 怎么做。。。

1.  导入`yaml`模块：

    ```py
            import yaml 

    ```

2.  使用`yaml.load()`功能加载 YAML 语法文档：

    ```py
            def load_config_file(config_file) -> dict: 
                '''Loads a configuration mapping object with contents 
                of a given file. 

                :param config_file: File-like object that can be read. 
                :returns: mapping with configuration parameter values 
                ''' 
                document = yaml.load(config_file) 
            return document 

    ```

## 它是如何工作的。。。

YAML 语法规则在[中定义 http://yaml.org](http://yaml.org) 。YAML 的思想是提供类似 JSON 的数据结构，并提供更灵活、更人性化的语法。JSON 是更通用的 YAML 语法的特例。

这里的折衷是，JSON 中的一些空格和换行符无关紧要—有可见的标点符号来显示文档的结构。在一些 YAML 变体中，换行符和缩进决定了文档的结构；使用空白意味着换行符对 YAML 文档很重要。

JSON 语法中可用的主要数据结构如下：

*   **序列**：`[item, item, ...]`
*   **映射**：`{key: value, key: value, ...}`
*   **标量**：
    *   字符串：`"value"`
    *   编号：`3.1415926`
    *   文字：`true`、`false`和`null`

JSON 语法是 YAML 的一种风格；这就是所谓的流动风格。在这种样式中，文档结构由显式指示符标记。语法要求`{…}`和`[…]`显示结构。

YAML 提供的替代方案是块样式。文档结构由换行和缩进定义。此外，长字符串标量值可以使用简单、带引号和折叠的语法样式。以下是可选 YAML 语法的工作原理：

*   **Block sequence** : We preface each line of a sequence with a -. This looks like a bullet list, and is easy to read. Here's an example:

    ```py
     zoneid: 
            - ANZ532 
            - AMZ117 
            - AMZ080

    ```

    加载后，将创建一个包含 Python 中字符串列表的字典：`{zoneid: ['ANZ532', 'AMZ117', 'AMZ080']}`。

*   **Block mapping** : We can use simple `key: value` syntax to associate a key with a simple scalar. We can use `key:` on a line by itself; the value is indented on the following lines. Here's an example:

    ```py
     url: 
            scheme: http 
            netloc: marine.weather.gov

    ```

    这将创建一个嵌套字典，在 Python 中如下所示：`{'url': {'scheme': 'http', 'netloc': 'marine.weather.gov'}}`。

我们还可以使用显式键和值标记，`?`和`:`。当键是特别长的字符串或更复杂的对象时，这会有所帮助：

```py
? scheme 
: http 
? netloc 
: marine.weather.gov

```

YAML 的一些更高级的功能将利用键和值之间的明确分离：

*   对于短字符串标量值，我们可以将其保留为普通值，YAML 规则将简单地使用所有字符，去掉前导和尾随空格。这些示例都使用这种字符串值假设。
*   引号可以用于字符串，就像在 JSON 中一样。
*   对于较长的字符串，YAML 引入了`|`前缀；之后的行将保留，所有间距和换行符都保持不变。

它还引入了`>`前缀，它将单词保留为一个长文本字符串，任何新行都被视为单个空白字符。这在运行文本时很常见。

在这两种情况下，缩进确定文档中有多少部分是文本的一部分。

*   在某些情况下，该值可能不明确。例如，美国邮政编码为所有数字-`22102`。这应该理解为一个字符串，即使 YAML 规则将其解释为一个数字。当然，引用也会有所帮助。更明确地说，值前面的本地标记`!!str`将强制使用特定的数据类型。例如，`!!str 22102`确保数字将被视为字符串对象。

## 还有更多。。。

YAML 中还有许多 JSON 中没有的附加功能：

*   注释，以`#`开头，一直到行末。他们几乎可以去任何地方。JSON 不允许注释。
*   文档开始，由新文档开始处的`---`行指示。这允许 YAML 文件包含许多单独的对象。JSON 仅限于每个文件一个文档。每个文件一个文档的替代方法是更复杂的解析算法。YAML 提供了一个显式的文档分隔符和一个非常简单的解析接口。
*   YAML 文件包含两个单独的文件：

    ```py
     >>> import yaml 
          >>> yaml_text = ''' 
          ... --- 
          ... id: 1 
          ... text: "Some Words." 
          ... --- 
          ... id: 2 
          ... text: "Different Words." 
          ... ''' 
          >>> document_iterator = iter(yaml.load_all(yaml_text)) 
          >>> document_1 = next(document_iterator) 
          >>> document_1['id'] 
          1 
          >>> document_2 = next(document_iterator) 
          >>> document_2['text'] 
          'Different Words.'

    ```

*   `yaml_text`值包含两个 YAML 文档，每个文档都以`---`开头。`load_all()`函数是一个迭代器，一次加载一个文档。应用程序必须迭代此结果以处理流中的每个文档。
*   文件结束。`...`行是文档的结尾。
*   映射的复杂键；JSON 映射键仅限于可用的标量类型字符串、数字、`true`、`false`和`null`。YAML 允许映射键更加复杂。
*   重要的是 Python 需要一个可哈希的、不可变的对象作为映射键。这意味着一个复杂的键必须转换成一个不可变的 Python 对象，通常是一个`tuple`。为了创建特定于 Python 的对象，我们需要使用更复杂的局部标记。这里有一个例子：

    ```py
     >>> yaml.load(''' 
          ... ? !!python/tuple ["a", "b"] 
          ... : "value" 
          ... ''') 
          {('a', 'b'): 'value'}

    ```

*   本例使用`?`和`:`标记映射的键和值。我们这样做是因为键是一个复杂的对象。键`value`使用一个本地标记`!!python/tuple`来创建一个元组，而不是默认的元组，默认的元组应该是一个`list`。键的文本使用流类型 YAML 值`["a", "b"]`。
*   JSON 没有设置一个集合。YAML 允许我们使用`!!set`标记来创建集合，而不是简单的序列。集合中的项由`?`前缀标识，因为它们被视为映射的键，而映射没有值。
*   请注意，`!!set`标记与集合中的值处于相同的缩进级别。缩进在`data_values`：

    ```py
     >>> import yaml 
          >>> yaml_text = ''' 
          ... document: 
          ...     id: 3 
          ...     data_values: 
          ...       !!set 
          ...       ? some 
          ...       ? more 
          ...       ? words 
          ... ''' 
          >>> some_document = yaml.load(yaml_text) 
          >>> some_document['document']['id'] 
          3 
          >>> some_document['document']['data_values'] == {'some', 'more', 'words'} 
          True

    ```

    的字典键内
*   `!!set`本地标记将以下序列修改为`set`对象，而不是默认的列表对象。结果集等于预期的 Python 集对象`{'some', 'more', 'words'}`。
*   Python 可变对象规则必须应用于集合的内容。不可能构建一组`list`对象，因为列表实例没有散列值。必须使用`!!python/tuple`本地标记来构建一组元组。
*   我们可以创建一个包含两个元组序列的 Python 列表，也可以实现有序映射。`yaml`模块没有为我们创建`OrderedDict`：

    ```py
     >>> import yaml 
          >>> yaml_text = ''' 
          ... !!omap 
          ... - key1: string value 
          ... - numerator: 355 
          ... - denominator: 113 
          ... ''' 
          >>> yaml.load(yaml_text) 
          [('key1', 'string value'), ('numerator', 355), ('denominator', 113)]

    ```

*   请注意，如果不指定大量详细信息，则很难执行下一步并从此创建一个`OrderedDict`。下面是创建`OrderedDict`实例的 YAML。

    ```py
            !!python/object/apply:collections.OrderedDict 
            args: 
                -   !!omap 
                    -   key1: string value 
                    -   numerator: 355 
                    -   denominator: 113 

    ```

*   `args`关键字需要支持`!!python/object/apply`标签。只有一个位置参数，它是由一系列键和值构建的 YAML`!!omap`。
*   Python objects of almost any class can be built using YAML local tags. Any class with a simple `__init__()` method can be built from a YAML serialization.

    下面是一个简单的类定义：

    ```py
            class Card: 
                def __init__(self, rank, suit): 
                    self.rank = rank 
                    self.suit = suit 
                def __repr__(self): 
                    return "{rank} {suit}".format_map(vars(self)) 

    ```

    我们定义了一个具有两个位置属性的类。以下是此对象的 YAML 描述：

    ```py
            !!python/object/apply:__main__.Card 
            kwds: 
                rank: 7 
                suit: ♣

    ```

    我们使用了`kwds`键为`Card`构造函数提供了两个基于关键字的参数值。Unicode`♣`字符工作良好，因为 YAML 文件是使用 UTF-8 编码编写的文本。

*   In addition to local tags, which start with `!!` , YAML also supports tags that are URIs using the `tag:` scheme. This allows URI-based type specifications that are globally unique. This can make YAML documents easier to process in a variety of contexts.

    标记包括权限名称、日期和以`/`分隔的路径形式表示的特定细节。例如，标记可能看起来像这样-`!<tag:www.someapp.com,2016:rules/rule1>`。

## 另见

*   请参阅*查找配置文件*配方，了解如何在多个文件系统位置搜索配置文件。我们可以轻松地将应用程序默认设置、系统范围设置和个人设置构建到单独的文件中，并由应用程序组合

# 配置文件使用 Python

Python 提供了多种打包应用程序输入和配置文件的方法。我们将研究用 Python 符号编写文件，因为它优雅而简单。

许多包在单独的模块中使用赋值语句来提供配置参数。特别是 Flask 项目可以做到这一点。我们在*中使用 RESTful API*配方的 Flask 框架和[第 12 章](12.html#page "Chapter 12. Web Services")、*Web 服务*中的许多相关配方研究了 Flask。

我们如何用 Python 模块表示法表示配置细节？

## 准备好了吗

Python 赋值语句表示法特别优雅。它非常简单，易于阅读，而且非常灵活。如果使用赋值语句，则可以从单独的模块导入配置详细信息。这可能有一个类似于`settings.py`的名称，表明它关注的是配置参数。

由于 Python 将每个导入的模块视为一个全局**单例**对象，因此我们可以让应用程序的几个部分都使用`import settings`语句来获得当前全局应用程序配置参数的一致视图。

但是，在某些情况下，我们可能希望从几个备选设置文件中选择一个。在本例中，我们希望使用比`import`语句更灵活的技术加载文件。

我们希望能够在文本文件中提供如下定义：

```py
    '''Weather forecast for Offshore including the Bahamas 
    ''' 
    query = {'mz': ['ANZ532', 'AMZ117', 'AMZ080']} 
    url = { 
      'scheme': 'http', 
      'netloc': 'forecast.weather.gov', 
      'path': '/shmrn.php' 
    } 

```

这是 Python 语法。参数包括两个变量，`query`和`url.``query`变量的值是一个带有单键的字典，`mz`和一系列值。

这可以被看作是一个规范，用于许多相关的 URL，这些 URL 都类似于[http://forecast.weather.gov/shmrn.php?mz=ANZ532](http://forecast.weather.gov/shmrn.php?mz=ANZ532) 。

我们将经常使用*查找配置文件*方法来检查各种位置以查找给定的配置文件。这种灵活性对于创建易于在各种平台上使用的应用程序来说通常是必不可少的。

在这个配方中，我们将构建上一个示例中缺少的部分，`load_config_file()`函数。以下是需要填写的模板：

```py
    def load_config_file(config_file) -> dict: 
        '''Loads a configuration mapping object with contents 
        of a given file. 

        :param config_file: File-like object that can be read. 
        :returns: mapping with configuration parameter values 
        ''' 
        # Details omitted. 

```

## 怎么做。。。

此代码替换`load_config_file()`功能中的`# Details omitted.`行：

1.  使用内置的`compile()`功能编译配置文件中的代码。此函数需要源文本以及从中读取文本的文件名。文件名对于创建有用且正确的回溯消息至关重要：

    ```py
            code = compile(config_file.read(), config_file.name, 'exec') 

    ```

2.  在代码不来自文件的极少数情况下，一般做法是提供一个名称，如`<string>`，而不是文件名。
3.  执行`compile()`函数创建的代码对象。这需要两种背景。全局上下文提供任何以前导入的模块，以及`__builtins__`模块。本地上下文是创建新变量的地方：

    ```py
            locals = {} 
            exec(code, {'__builtins__':__builtins__}, locals) 
            return locals 

    ```

4.  当代码在脚本文件的最顶层执行时，通常在`if __name__ == "__main__"`条件内，它在全局和局部相同的上下文中执行。当代码在函数、方法或类定义中执行时，该上下文的局部变量与全局变量是分开的。
5.  通过创建一个单独的`locals`对象，我们确保导入的语句不会对任何其他全局变量进行意外更改。

## 它是如何工作的。。。

Python 语言的细节；语法和语义体现在`compile()`和`exec()`函数中。当我们启动脚本时，过程基本上是这样的：

1.  读课文。用`compile()`函数编译，创建代码对象。
2.  使用`exec()`函数执行该代码对象。

`__pycache__`目录保存代码对象，并保存未更改的重新编译文本文件。这对加工没有实质性影响。

`exec()`函数反映 Python 处理全局和局部变量的方式。此函数提供了两个名称空间。这些对通过`globals()`和`locals()`函数运行的脚本可见。

我们提供了两种不同的词典：

*   全局对象的字典。这些变量可以通过`global`语句访问。最常见的用途是提供对导入模块的访问，这些模块始终是全局的。例如，通常会提供`__builtins__`模块。在某些情况下，应添加其他模块。
*   为局部变量提供的字典由每个赋值语句更新。这个本地字典允许我们捕获在`settings`模块中创建的变量。

## 还有更多。。。

这个配方构建了一个配置文件，可以完全是一系列的`name = value`分配。Python 赋值语句语法直接支持该语句。

此外，还提供了全套 Python 编程。必须进行许多工程权衡。

配置文件中可以使用任何语句。然而，这可能导致复杂性。如果处理变得过于复杂，文件将停止配置，并成为应用程序的一级部分。非常复杂的特性应该通过修改应用程序编程来实现，而不是通过修改配置设置来实现。因为 Python 应用程序包含源代码，所以这相对容易做到。

除了简单的赋值语句外，使用`if`语句处理备选方案也是明智的。文件可能会为特定运行时环境的独特功能提供一个部分。例如，`platform`包可用于隔离功能。

可能包括以下内容：

```py
    import platform 
    if platform.system() == 'Windows': 
        tmp = Path(r"C:\TEMP") 
    else: 
        tmp = Path("/tmp") 

```

为了实现这一点，全局变量应该包括`platform`和`Path`。这是一个超出`__builtins__`的合理延伸。

也可以简单地进行一些处理，使一些相关设置更易于组织。例如，一个应用程序可能有许多相关文件。编写如下配置文件可能会有所帮助：

```py
    base = Path('/var/app/') 
    log = base/'log' 
    out = base/'out' 

```

应用程序使用`log`和`out`的值。`base`的值仅用于确保其他两个位置位于同一目录中。

这导致前面显示的`load_config_file()`功能发生以下变化。此版本包括一些附加模块和全局类：

```py
    from pathlib import Path  
    import platform 
    def load_config_file_path(config_file) -> dict: 
        code = compile(config_file.read(), config_file.name, 'exec') 
        globals = {'__builtins__': __builtins__, 
            'Path': Path, 'platform': platform} 
        locals = {} 
        exec(code, globals, locals) 
        return locals 

```

包括`Path`和`platform`意味着可以编写配置文件而不需要`import`语句的开销。这样可以简化设置的准备和维护。

## 另见

*   请参阅*查找配置文件*配方，了解如何在多个文件系统位置搜索配置文件。

# 使用类作为名称空间进行配置

Python 提供了多种打包应用程序输入和配置文件的方法。我们将研究用 Python 符号编写文件，因为它优雅而简单。

许多项目允许使用类定义来提供配置参数。类层次结构的使用意味着可以使用继承技术来简化参数的组织。特别是烧瓶包装可以做到这一点。我们查看了配方中的烧瓶，*使用用于 RESTful API 的烧瓶框架*，以及一些相关配方。

我们如何用 Python 类表示法表示配置细节？

## 准备好了吗

定义类属性的 Python 表示法特别优雅。它非常简单，易于阅读，并且相当灵活。我们只需很少的工作，就可以定义一种复杂的配置语言，允许用户快速可靠地更改 Python 应用程序的配置参数。

我们可以将这种语言建立在类定义的基础上。这使我们能够在单个模块中打包许多配置备选方案。应用程序可以加载模块并从模块中选择相关的类定义。

我们希望能够提供如下定义：

```py
    class Configuration: 
        """ 
        Weather forecast for Offshore including the Bahamas 
        """ 
        query = {'mz': ['ANZ532', 'AMZ117', 'AMZ080']} 
        url = { 
          'scheme': 'http', 
          'netloc': 'forecast.weather.gov', 
          'path': '/shmrn.php' 
        } 

```

我们可以在一个`settings`模块中创建这个`Configuration`类。要使用配置，主应用程序将执行以下操作：

```py
    from settings import Configuration 

```

这将使用具有固定类名的固定文件。尽管明显缺乏灵活性，但这通常比其他替代方案更有用。我们还有两种方式支持复杂的配置文件：

*   我们可以使用`PYTHONPATH`环境变量列出配置模块的多个位置
*   使用多重继承和混合插入将默认设置、系统范围设置和本地化设置组合到配置类定义中

这些技术可能很有帮助，因为配置文件位置只是遵循 Python 查找模块的规则。我们不需要实现自己对配置文件的搜索。

在这个配方中，我们将构建上一个示例中缺少的部分，`load_config_file()`函数。以下是需要填写的模板：

```py
    def load_config_file(config_file) -> dict: 
        '''Loads a configuration mapping object with contents 
        of a given file. 

        :param config_file: File-like object that can be read. 
        :returns: mapping with configuration parameter values 
        ''' 
        # Details omitted. 

```

## 怎么做。。。

此代码替换`load_config_file()`功能中的`# Details omitted.`行：

1.  使用内置的`compile()`函数编译给定文件中的代码。此函数需要源文本以及从中读取文本的文件名。文件名对于创建有用且正确的回溯消息至关重要：

    ```py
            code = compile(config_file.read(), config_file.name, 'exec') 

    ```

2.  执行`compile()`方法创建的代码对象。我们需要提供两个上下文。全局上下文可以提供`__builtins__`模块，加上`Path`类和`platform`模块。本地上下文是创建新变量的地方：

    ```py
            globals = {'__builtins__':__builtins__, 
                       'Path': Path, 
                       'platform': platform} 
            locals = {} 
            exec(code, globals, locals) 
            return locals['Configuration'] 

    ```

3.  这只返回已执行模块设置的局部变量中定义的`Configuration`类。任何其他变量都将被忽略。

## 它是如何工作的。。。

Python 语言语法和语义的细节体现在`compile()`和`exec()`函数中。`exec()`函数反映 Python 处理全局和局部变量的方式。此函数提供了两个名称空间。全局`namespace`实例包括`__builtins__`以及文件中可能使用的类和模块。

局部变量命名空间将在其中创建新类。这个名称空间有一个`__dict__`属性，可以通过 dictionary 方法访问它。因此，我们可以按名称提取类。该函数返回类对象，以便在整个应用程序中使用。

我们可以将任何类型的对象放入类的属性中。我们的示例显示了映射对象。在类级别创建属性时，可以执行的操作没有限制。

我们可以在`class`语句中进行复杂的计算。我们可以使用它来创建从其他属性派生的属性。我们可以执行任何类型的语句，包括`if`语句和`for`语句来创建属性值。

## 还有更多。。。

使用类定义意味着我们可以利用继承来组织配置值。我们可以轻松创建`Configuration`的多个子类，其中一个子类将被选择用于应用程序中。配置可能如下所示：

```py
    class Configuration: 
        """ 
        Generic Configuration 
        """ 
        url = { 
          'scheme': 'http', 
          'netloc': 'forecast.weather.gov', 
          'path': '/shmrn.php' 
        } 

    class Bahamas(Configuration): 
        """ 
        Weather forecast for Offshore including the Bahamas 
        """ 
        query = {'mz': ['AMZ117', 'AMZ080']} 

    class Cheaspeake(Configuration): 
        """ 
        Weather for Cheaspeake Bay 
        """ 
        query = {'mz': ['ANZ532']} 

```

这意味着我们的应用程序必须从`settings`模块中的可用类中选择适当的类。我们可以使用 OS 环境变量或命令行选项来指定要使用的类名。我们的程序是这样执行的：

```py
python3 some_app.py -c settings.Chesapeake

```

这将在`settings`模块中定位`Chesapeake`类。然后，处理将基于该特定配置类中的详细信息。这个想法导致了对`load_config_file()`函数的扩展。

为了选择一个可用的类，我们将提供一个带有类名的附加参数：

```py
    import importlib 
    def load_config_module(name): 
        module_name, _, class_name = name.rpartition('.') 
        settings_module = importlib.import_module(module_name) 
        return vars(settings_module)[class_name] 

```

我们使用了更高级别的`importlib`模块，而不是手动编译和执行该模块。本模块实现`import`语句语义。导入请求的模块；编译并执行，并将结果模块对象分配给变量名`settings_module`。

然后，我们可以查看模块的变量并选择所请求的类。`vars()`内置函数将从模块、类甚至局部变量中提取内部字典。

现在我们可以按如下方式使用此函数：

```py
>>> configuration = load_config_module('settings.Chesapeake') 
>>> configuration.__doc__.strip() 
'Weather for Cheaspeake Bay' 
>>> configuration.query 
{'mz': ['ANZ532']} 
>>> configuration.url['netloc'] 
'forecast.weather.gov'

```

我们已经在`settings`模块中找到了`Chesapeake`配置类。

### 配置表示

使用这样的类的一个结果是，类的默认显示信息量不大。当我们尝试打印配置时，如下所示：

```py
>>> print(configuration) 
<class 'settings.Chesapeake'>

```

这几乎是无用的。它提供了大量信息，但这还远远不够调试。

我们可以使用`vars()`功能查看更多细节。但是，这显示的是局部变量，而不是继承的变量：

```py
>>> pprint(vars(configuration)) 
mappingproxy({'__doc__': '\\n    Weather for Cheaspeake Bay\\n    ', 
              '__module__': 'settings', 
              'query': {'mz': ['ANZ532']}})

```

这是更好的，但仍然不完整。

为了查看所有设置，我们需要一些更复杂的东西。有趣的是，我们不能简单地为这个类定义`__repr__()`。类中定义的方法将应用于此类的实例，而不是类本身。

我们创建的每个类对象都是内置`type`类的实例。我们可以使用一个元类来调整`type`类的行为方式，并实现一个稍微好一点的`__repr__()`方法，该方法检查所有父类的属性。

我们将使用`__repr__`扩展内置类型，它在显示工作配置方面做得更好：

```py
    class ConfigMetaclass(type): 
        def __repr__(self): 
            name = (super().__name__ + '('  
                + ', '.join(b.__name__ for b in super().__bases__) + ')') 
            base_values = {n:v 
                for base in reversed(super().__mro__) 
                    for n, v in vars(base).items() 
                        if not n.startswith('_')} 
            values_text = ['    {0} = {1!r}'.format(name, value)  
                for name, value in base_values.items()] 
            return '\n'.join(["class {}:".format(name)] + values_text) 

```

类名作为`__name__`属性从超类`type`中可用。还包括基类的名称，以显示此配置类的继承层次结构。

`base_values`是根据所有基类的属性构建的。每个类别按照**方法解析顺序**（**MRO**的相反顺序进行检查。在反向 MRO 中加载所有属性值意味着首先加载所有默认值，然后用子类值重写。

包括缺少`_`前缀的名称。带有`_`前缀的名称被悄悄忽略。

结果值用于创建类似于类定义的文本表示。它不是原始的类源代码；这是原始类定义的净效果。

这里有一个`Configuration`类层次结构，它使用这个元类。基类`Configuration`合并了元类，并提供了默认定义。子类使用特定环境或上下文特有的值扩展这些定义：

```py
    class Configuration(metaclass=ConfigMetaclass): 
        unchanged = 'default' 
        override = 'default' 
        feature_override = 'default' 
        feature = 'default' 

    class Customized(Configuration): 
        override = 'customized' 
        feature_override = 'customized' 

```

我们可以利用 Python 多重继承的所有功能来构建`Configuration`类定义。这可以提供将单独功能的详细信息合并到单个配置对象中的能力。

## 另见

*   我们将在[第 6 章](06.html#page "Chapter 6. Basics of Classes and Objects")、*类和对象的基础*和[第 7 章](07.html#page "Chapter 7. More Advanced Class Design")、*更高级的类设计*中查看类定义

# 设计作文脚本

许多大型应用程序实际上是多个小型应用程序的合并。在企业术语中，它们通常被称为包含单个命令行应用程序的应用程序系统。

一些大型、复杂的应用程序包括许多命令。例如，Git 应用程序有许多单独的命令，例如`git pull`、`git commit`和`git push`。这些应用程序也可以看作是独立的应用程序，是整个 Git 应用程序系统的一部分。

应用程序可以从单独的 Python 脚本文件集合开始。在其发展过程中的某个时刻，可能需要重构脚本以组合功能，并从旧的不相交脚本中创建新的复合脚本。另一种方法也是可能的，一个大型应用程序可能被分解并重构成一个新的组织。

我们如何设计一个脚本，使将来的组合和重构尽可能简单？

## 准备好了吗

我们需要区分 Python 脚本的几个设计特性：

*   我们已经了解了收集信息的几个方面：
    *   从命令行界面和环境变量获取高度动态的输入。参见[第 5 章](05.html#page "Chapter 5. User Inputs and Outputs")、*用户输入和输出*中的*使用 argparse 获取命令行输入*配方。
    *   从文件更改配置选项的速度变慢。参见配方，*查找配置文件*、*使用 YAML 查找配置文件*、*使用 Python 查找配置文件*。
    *   对于任何输入文件的读取，请参见[中的*使用 CSV 模块*读取分隔文件、*使用正则表达式读取复杂格式*、*读取 JSON 文档*、*读取 XML 文档*、*读取 HTML 文档*配方第 9 章](09.html#page "Chapter 9. Input/Output, Physical Format, and Logical Layout")、*输入/输出、物理格式和逻辑布局*。
*   产生产出有几个方面：
    *   创建日志并提供支持审核、控制和监视的其他功能。我们将在*使用日志记录控制和审计输出*配方中了解其中一些内容。
    *   创建应用程序的原理输出。这可以打印或写入输出文件，使用与解析输入相同的库模块。
*   应用程序的实际工作。这些是从各种输入解析和输出格式考虑中分离出来的基本特性。此算法仅适用于 Python 数据结构。

这种*关注点分离*表明，任何应用程序，无论多么简单，都应该设计为几个独立的功能。这些应该合并成一个完整的脚本。这使我们能够将输入和输出与核心处理分开。处理是我们经常希望重用的部分。输入和输出格式应该是易于更改的。

作为一个具体的例子，我们将看一个创建骰子滚动序列的简单应用程序。每个序列都将遵循掷骰子游戏的规则。规则如下：

1.  两个骰子的第一卷是*出来*卷：
    1.  两、三或十二的滚动是立即的损失。序列只有一个值，例如，`[(1, 1)]`。
    2.  掷七或十一的骰子是立竿见影的胜利。该序列还具有单个值，例如，`[(3, 4)]`。
2.  任何其他数字都可以确定一个点。该序列从点值开始，直到滚动到 7 或点值：
    1.  最后七分是一种损失，例如，`[(3, 1), (3, 2), (1, 1), (5, 6), (4, 3)]`。
    2.  原始分值的最后一场比赛是一场胜利。至少有两卷。游戏的长度没有上限，例如，`[(3, 1), (3, 2), (1, 1), (5, 6), (1, 3)]`。

输出是具有不同结构的项目序列。其中一些是短名单。有些将是长长的清单。这是使用 YAML 格式文件的理想场所。

该输出可由两个输入控制：创建多少样本，以及是否为随机数生成器设定种子。为了测试的目的，它可以帮助有一个固定的种子。

## 怎么做。。。

1.  Design all of the output display into two broad areas:
    1.  不进行处理但显示结果对象的函数（或类）。
    2.  日志记录可以用于调试、监视、审核或其他控制。这是一个交叉关注点，将嵌入到应用程序的其余部分中。

    对于本例，有两个输出—序列序列和一些附加信息—用于确认处理工作正常。计算每个掷骰子的数量是确定模拟骰子是否公平的简便方法。

    卷的顺序需要写入文件。这表明`write_rolls()`函数被赋予了一个迭代器作为参数。下面是一个函数，它以 YAML 表示法迭代并将值转储到文件：

    ```py
            def write_rolls(output_path, roll_iterator): 
                face_count = Counter() 
                with output_path.open('w') as output_file: 
                    for roll in roll_iterator: 
                        output_file.write( 
                            yaml.dump( 
                                roll, 
                                default_flow_style=True, 
                                explicit_start=True)) 
                        for dice in roll: 
                            face_count[sum(dice)] += 1 
                return face_count 

    ```

    监控输出应显示用于控制加工的输入参数。它还应提供显示骰子公平的计数：

    ```py
            def summarize(configuration, counts): 
                print(configuration) 
                print(counts) 

    ```

2.  Design (or refactor) the essential processing of the application to look like a single function:
    1.  所有输入都是参数。
    2.  所有输出由`return`或`yield`产生。使用`return`创建单个结果。使用`yield`为多个结果生成一个序列迭代。

    在本例中，我们可以很容易地将核心特性设置为发出值序列迭代的函数。输出函数可以使用此迭代器：

    ```py
            def roll_iter(total_games, seed=None): 
                random.seed(seed) 
                for i in range(total_games): 
                    sequence = craps_game() 
                    yield sequence 

    ```

    此函数依赖于`craps_game()`函数来生成请求的样本数。每个示例都是一个完整的游戏，显示所有骰子卷。此函数向此较低级别函数提供`face_count`计数器，以累积一些总数，以确认一切正常工作。

    `craps_game()`函数实现骰子游戏规则，以发出一个或多个骰子的单个序列。这包括一场比赛中的所有掷骰。稍后我们将介绍这个`craps_game()`函数。

3.  Refactor all of the input gathering into a function (or class) that gathers the various input sources. This can include environment variables, command-line arguments, and configuration files. It may also include the names of multiple input files:

    ```py
            def get_options(argv): 
                parser = argparse.ArgumentParser() 
                parser.add_argument('-s', '--samples', type=int) 
                parser.add_argument('-o', '--output') 
                options = parser.parse_args(argv) 

                options.output_path = Path(options.output) 

                if "RANDOMSEED" in os.environ: 
                    seed_text = os.environ["RANDOMSEED"] 
                    try: 
                        options.seed = int(seed_text) 
                    except ValueError: 
                        sys.exit("RANDOMSEED={0!r} invalid".format(seed_text)) 
                else: 
                    options.seed = None 
                return options 

    ```

    此函数用于收集命令行参数。它还检查环境变量的`os.environ`集合。

    参数解析器将处理解析`--samples`和`--output`选项的细节。我们可以利用`argparse`的其他功能更好地验证参数值。

    `output_path`的值是根据`--output`选项的值创建的。类似地，`RANDOMSEED`环境变量的值被验证并放入`options`名称空间。`options`对象的这种用法将所有各种参数保持在一个位置。

4.  Write the final `main()` function, which incorporates the three previous elements, to create the final, overall script:

    ```py
            def main(): 
                options = get_options(sys.argv[1:]) 
                face_count = write_rolls(options.output_path, roll_iter(options.samples, options.seed)) 
                summarize(options, face_count) 

    ```

    这将应用程序的各个方面结合在一起。它解析命令行和环境选项。它创建一个控制总计数器。

    `roll_iter()`功能是核心处理。它采用各种选项，并发出一系列滚动。

`roll_iter()`方法的主输出由`write_rolls()`采集并写入给定的输出路径。控制输出由一个单独的函数编写，因此我们可以在不影响主输出的情况下更改摘要。

## 它是如何工作的。。。

输出如下所示：

```py
slott$ python3 ch13_r05.py --samples 10 --output=x.yaml 

Namespace(output='x.yaml', output_path=PosixPath('x.yaml'), samples=10, seed=None) 

Counter({5: 7, 6: 7, 7: 7, 8: 5, 4: 4, 9: 4, 11: 3, 10: 1, 12: 1}) 

slott$ more x.yaml 

--- [[5, 4], [3, 4]] 

--- [[3, 5], [1, 3], [1, 4], [5, 3]] 

--- [[3, 2], [2, 4], [6, 5], [1, 6]] 

--- [[2, 4], [3, 6], [5, 2]] 

--- [[1, 6]] 

--- [[1, 3], [4, 1], [1, 4], [5, 6], [6, 5], [1, 5], [2, 6], [3, 4]] 

--- [[3, 3], [3, 4]] 

--- [[3, 5], [4, 1], [4, 2], [3, 1], [1, 4], [2, 3], [2, 6]] 

--- [[2, 2], [1, 5], [5, 5], [1, 5], [6, 6], [4, 3]] 

--- [[4, 5], [6, 3]]

```

命令行请求了 10 个样本，并指定了一个输出文件`x.yaml`。控制输出是选项的简单转储。它显示参数值加上`options`对象中设置的附加值。

控制输出包括十个样本的计数。这为诸如 6、7 和 8 之类的值更频繁地出现提供了一些信心。它表明，像 3 和 12 这样的值出现的频率较低。

这里的中心前提是关注点的分离。处理过程有三个不同的方面：

*   **输入**：来自命令行的参数和环境变量由单个函数`get_options()`采集。此函数可以从各种来源获取输入，包括配置文件。
*   **输出**：主要输出由`write_rolls()`功能处理。另一个控制输出是通过在`Counter`对象中累积总计，然后在最后转储此输出来处理的。
*   **过程**：应用程序的基本处理被分解到`roll_iter()`函数中。此函数可以在各种上下文中重用。

本设计的目标是将`roll_iter()`功能与周围的应用程序细节分离。另一个应用程序可能有不同的命令行参数，或不同的输出格式，但重用基本算法。

例如，可能有第二个应用程序对辊序列执行一些统计分析。这可能包括掷骰次数，以及胜负的最终结果。我们可以假设这两个应用程序是`generator.py`（如前所示）和`overview_stats.py`。

在使用这两个应用程序创建卷并对其进行汇总后，用户可能会确定将卷创建和统计概览合并到单个应用程序中是有利的。由于每个应用程序的各个方面都已分离，因此重新排列功能和创建新应用程序变得相对容易。我们现在可以构建一个新的应用程序，该应用程序将从以下两个导入开始：

```py
    from generator import roll_iter, craps_rules 
    from stats_overview import summarize 

```

此新应用程序可以在不更改其他两个应用程序的情况下构建。这使得原始应用程序不会因引入新功能而受到影响。

更重要的是，新的应用程序不涉及任何代码的复制或粘贴。新应用程序导入工作软件，为修复一个应用程序所做的更改也将修复其他应用程序中潜在的错误。

### 提示

通过复制和粘贴进行重用会产生技术债务。避免复制和粘贴代码。

当我们试图从一个应用程序复制代码来创建一个新的应用程序时，我们会造成一种混乱的情况。对一个副本所做的任何更改都不会神奇地修复另一个副本中潜在的 bug。当对一个副本进行更改，而另一个副本没有保持最新时，这是一种*代码腐烂*。

## 还有更多。。。

在上一节中，我们跳过了`craps_rules()`函数的细节。此函数创建一系列骰子掷骰，这些骰子掷骰包含一个由*骰子*组成的游戏。它可以从单卷到无限长的序列。大约 98%的游戏是 13 次或更少的掷骰子。

规则取决于两个骰子的总数。捕获的数据包括骰子的两个独立面。为了支持这些细节，有一个具有以下两个相关属性的`namedtuple`实例是很有帮助的：

```py
    Roll = namedtuple('Roll', ('faces', 'total')) 
    def roll(n=2): 
        faces = list(random.randint(1, 6) for _ in range(n)) 
        total = sum(faces) 
        return Roll(faces, total) 

```

此`roll()`函数创建一个`namedtuple`实例，该实例具有显示骰子面以及骰子总数的序列。`craps_game()`函数将生成足够的规则返回一个完整的游戏：

```py
    def craps_game(): 
        come_out = roll() 
        if come_out.total in [2, 3, 12]: 
            return [come_out.faces] 
        elif come_out.total in [7, 11]: 
            return [come_out.faces] 
        elif come_out.total in [4, 5, 6, 8, 9, 10]: 
            sequence = [come_out.faces] 
            next = roll() 
            while next.total not in [7, come_out.total]: 
                sequence.append(next.faces) 
                next = roll() 
            sequence.append(next.faces) 
            return sequence 
        else: 
            raise Exception("Horrifying Logic Bug") 

```

`craps_game()`函数实现垃圾的规则。如果第一次掷骰是 2、3 或 12，则该序列只有一个值，并且游戏是失败的。如果第一个骰子是 7 或 11，那么序列也只有一个值，游戏就是胜利。其余值建立一个点。滚动顺序从点值开始。序列将继续，直到以 7 或点值结束。

### 设计为类层次结构

`roll_iter()`、`roll()`和`craps_game()`方法之间的密切关系表明，最好将这些函数封装到单个类定义中。下面是一个将所有这些功能捆绑在一起的类：

```py
    class CrapsSimulator: 
        def __init__(self, seed=None): 
            self.rng = random.Random(seed) 
            self.faces = None 
            self.total = None 

        def roll(self, n=2): 
            self.faces = list(self.rng.randint(1, 6) for _ in range(n)) 
            self.total = sum(self._faces) 

        def craps_game(sel): 
            self.roll() 
            if self.total in [2, 3, 12]: 
                return [self.faces] 
            elif self.total in [7, 11]: 
                return [self.faces] 
            elif self.total in [4, 5, 6, 8, 9, 10]: 
                point, sequence = self.total, [self.faces] 
                self.roll() 
                while self.total not in [7, point]: 
                    sequence.append(self.faces) 
                    self.roll() 
                sequence.append(self.faces) 
                return sequence 
            else: 
                raise Exception("Horrifying Logic Bug") 

        def roll_iter(total_games): 
            for i in range(total_games): 
                sequence = self.craps_game() 
                yield sequence 

```

此类包括模拟器的初始化，以包含其自己的随机数生成器。它将使用给定的种子值，或者内部算法将拾取种子值。`roll()`方法将设置`self.total`和`self.faces`实例变量。

`craps_game()`为一局骰子生成一系列骰子。它使用`roll()`方法和两个实例变量`self.total`和`self.faces`来跟踪骰子的状态。

`roll_iter()`方法生成游戏序列。请注意，此方法的签名与前面的`roll_iter()`函数不完全相同。这个类将随机数种子从游戏创建算法中分离出来。

重写`main()`以使用`CrapsSimulator`类留给读者作为练习。由于方法名与原始函数名相似，重构应该不会非常复杂。

## 另见

*   参见[第 5 章](05.html#page "Chapter 5. User Inputs and Outputs")、*用户输入和输出*中的*使用 argparse 获取命令行输入*配方，了解使用`argparse`获取用户输入的背景信息
*   有关跟踪配置文件的方法，请参见*查找配置文件*配方
*   *将日志记录用于控制和审计输出*配方查看日志记录
*   在*将两个应用程序合并为一个*配方中，我们将研究如何组合遵循此设计模式的应用程序

# 使用日志记录控制和审计输出

在*为*配方设计脚本的过程中，我们检查了应用程序的三个方面：

*   收集投入
*   生产量
*   连接输入和输出的基本处理

应用程序产生几种不同类型的输出：

*   帮助用户做出决定或采取行动的原理输出
*   确认程序完全正确运行的控制信息
*   用于跟踪持久数据库中状态更改历史记录的审核摘要
*   任何指示应用程序无法工作原因的错误消息

将所有这些不同的方面都整合到写入标准输出的`print()`请求中是不太理想的。事实上，它可能会导致混乱，因为太多不同的输出被合并到一个流中。

操作系统提供两个输出文件，标准输出和标准错误。在 Python 中，可以通过名为`sys.stdout`和`sys.stderr`的`sys`模块看到这些内容。默认情况下，`print()`方法写入`sys.stdout`文件。我们可以对此进行更改，并将控制、审核和错误消息写入`sys.stderr`。这是朝着正确方向迈出的重要一步。

Python 提供了`logging`包，可用于将辅助输出定向到单独的文件。它还可以用来格式化和过滤额外的输出。

如何正确使用日志记录？

## 准备好了吗

在*为合成*配方设计脚本的过程中，我们研究了一个应用程序，该应用程序生成了一个 YAML 文件，其中包含模拟的原始输出。在本教程中，我们将介绍一个使用原始数据并生成一些统计摘要的应用程序。我们将此应用程序称为`overview_stats.py`。

按照分离输入、输出和处理的设计模式，我们将有一个类似以下内容的应用程序`main()`：

```py
    def main(): 
        options = get_options(sys.argv[1:]) 
        if options.output is not None: 
            report_path = Path(options.output) 
            with report_path.open('w') as result_file: 
                process_all_files(result_file, options.file) 
        else: 
            process_all_files(sys.stdout, options.file) 

```

此函数将从各种来源获取选项。如果命名了输出文件，它将使用`with`语句上下文创建输出文件。然后，此函数将处理所有命令行参数文件，作为收集统计信息的输入。

如果没有提供输出文件名，此函数将写入`sys.stdout`文件。这将显示可以使用 OS shell 的`>`操作符重定向以创建文件的输出。

`main()`函数依赖于`process_all_files()`函数。`process_all_files()`函数将遍历每个参数文件，并从该文件中收集统计信息。下面是该函数的外观：

```py
    def process_all_files(result_file, file_names): 
        for source_path in (Path(n) for n in file_names): 
            with source_path.open() as source_file: 
                game_iter = yaml.load_all(source_file) 
                statistics = gather_stats(game_iter) 
                result_file.write( 
                    yaml.dump(dict(statistics), explicit_start=True) 
                ) 

```

`process_all_files()`函数将`gather_stats()`应用于`file_names`表中的每个文件。生成的集合将写入给定的`result_file`。

### 注

此处显示的功能将处理和输出合并到一个不理想的设计中。我们将在将两个应用程序合并为一个配方的*中解决此设计缺陷。*

基本处理在`gather_stats()`函数中。给定一个文件的路径，这将读取并汇总该文件中的游戏。然后，可以将生成的摘要对象作为整体显示的一部分写入，或者在本例中，将其附加到 YAML 格式的摘要序列中：

```py
    def gather_stats(game_iter): 
        counts = Counter() 
        for game in game_iter: 
            if len(game) == 1 and sum(game[0]) in (2, 3, 12): 
                outcome = "loss" 
            elif len(game) == 1 and sum(game[0]) in (7, 11): 
                outcome = "win" 
            elif len(game) > 1 and sum(game[-1]) == 7: 
                outcome = "loss" 
            elif len(game) > 1 and sum(game[0]) == sum(game[-1]): 
                outcome = "win" 
            else: 
                raise Exception("Wait, What?") 
            event = (outcome, len(game)) 
            counts[event] += 1 
        return counts 

```

此函数确定四个游戏终止规则中的哪一个应用于掷骰子序列。它首先打开给定的源文件，并使用`load_all()`函数迭代所有 YAML 文档。每个文档都是一个游戏，表示为一系列骰子对。

此函数使用第一次（和最后一次）掷骰来确定游戏的总体结果。有四条规则，它们应该列举所有可能的事件逻辑组合。在这种情况下，如果在我们的推理中有一些错误，将引发异常，以提醒我们在某种程度上不符合设计的特殊情况。

游戏被简化为一个具有结果和长度的单一事件。这些被累积成一个`Counter`对象。游戏的结果和长度是我们计算的两个值。这是一个更复杂或复杂的统计分析，可能的替身。

我们已经仔细地将几乎所有与文件相关的注意事项从这个函数中分离出来。`gather_stats()`功能将与任何可编辑的游戏数据源一起使用。

这是这个应用程序的输出。它不是很漂亮；这是一个 YAML 文档，可用于进一步处理：

```py
slott$ python3 ch13_r06.py x.yaml 

--- 

? !!python/tuple [loss, 2] 

: 2 

? !!python/tuple [loss, 3] 

: 1 

? !!python/tuple [loss, 4] 

: 1 

? !!python/tuple [loss, 6] 

: 1 

? !!python/tuple [loss, 8] 

: 1 

? !!python/tuple [win, 1] 

: 1 

? !!python/tuple [win, 2] 

: 1 

? !!python/tuple [win, 4] 

: 1 

? !!python/tuple [win, 7] 

: 1

```

我们需要在所有这些函数中插入日志功能，以显示正在读取的文件以及处理该文件时出现的任何错误或问题。

此外，我们将创建两个日志。其中一个将包含详细信息，另一个将包含所创建文件的最小摘要。第一条日志可以转到`sys.stderr`，程序运行时控制台会显示该日志。另一个日志将附加到一个长期`log`文件中，以涵盖应用程序的所有用途。

有不同需求的一种方法是创建两个记录器，每个记录器具有不同的意图。这两个记录器的配置也将截然不同。另一种方法是创建单个记录器，并使用`Filter`对象来区分针对每个记录器的内容。我们将重点创建单独的记录器，因为它更易于开发和单元测试。

每个记录器都有反映消息严重性的各种方法。`logging`包中定义的严重性等级包括：

*   **调试**：这些消息通常不显示，因为它们的目的是支持调试。
*   **信息**：这些消息提供正常、愉快路径处理的信息。
*   **警告**：这些消息表示处理可能会受到某种方式的影响。警告最合理的用例是当函数或类被弃用时：它们可以工作，但应该被替换。这些信息通常会显示出来。
*   **错误**：处理无效，输出不正确或不完整。对于长时间运行的服务器，单个请求可能有问题，但服务器作为一个整体可以继续运行。
*   **严重**：更严重的错误级别。一般来说，这是由长时间运行的服务器使用的，在这些服务器上，服务器本身无法再运行，并且即将崩溃。

方法名称与严重性级别类似。我们使用`logging.info()`来编写信息级消息。

## 怎么做。。。

1.  We'll start by implementing basic logging features into the existing functions. This means that we'll need the `logging` module:

    ```py
            import logging

    ```

    应用程序的其余部分将使用许多其他软件包：

    ```py
            import argparse 
            import sys 
            from pathlib import Path 
            from collections import Counter 
            import yaml 

    ```

2.  We'll create two logger objects as module globals. The creating functions can go anywhere in the script that creates global variables. One location is to put these early, after the `import` statements. Another common choice is near the end, but outside any `__name__ == "__main__"` script processing. These variables must always be created, even if the module is imported as a library.

    记录者有等级名称。我们将使用应用程序名和内容后缀来命名记录器。`overview_stats.detail`记录器将具有处理细节。`overview_stats.write`记录器将识别读取的文件和写入的文件；这与审核日志的想法类似，因为文件在输出文件集合中写入跟踪状态更改：

    ```py
            detail_log = logging.getLogger("overview_stats.detail") 
            write_log = logging.getLogger("overview_stats.write") 

    ```

    我们现在不需要配置这些记录器。如果我们不做更多的事情，两个记录器对象将静默地接受单独的日志条目，但不会对数据做任何进一步的处理。

3.  We'll rewrite the `main()` function to summarize the two aspects of the processing. This will use the `write_log` logger object to show when a new file is created:

    ```py
            def main(): 
                options = get_options(sys.argv[1:]) 
                if options.output is not None: 
                    report_path = Path(options.output) 
                    with report_path.open('w') as result_file: 
                        process_all_files(result_file, options.file) 
                    write_log.info("wrote {}".format(report_path)) 
                else: 
                    process_all_files(sys.stdout, options.file) 

    ```

    我们添加了`write_log.info("wrote {}".format(result_path))`行，将信息消息放入已写入文件的日志中。

4.  We'll rewrite the `process_all_files()` function to provide a note when a file is read:

    ```py
            def process_all_files(result_file, file_names): 
                for source_path in (Path(n) for n in file_names): 
                    detail_log.info("read {}".format(source_path)) 
                    with source_path.open() as source_file: 
                        game_iter = yaml.load_all(source_file) 
                        statistics = gather_stats(game_iter) 
                    result_file.write( 
                        yaml.dump(dict(statistics), explicit_start=True) 
                    ) 

    ```

    我们已经添加了`detail_log.info("read {}".format(source_path))`行，以便将每个读取的文件的信息消息放入详细日志中。

5.  The `gather_stats()` function can have a log line added to it to track normal operations. Additionally, we've added a log entry for the logic error:

    ```py
            def gather_stats(game_iter): 
                counts = Counter() 
                for game in game_iter: 
                    if len(game) == 1 and sum(game[0]) in (2, 3, 12): 
                        outcome = "loss" 
                    elif len(game) == 1 and sum(game[0]) in (7, 11): 
                        outcome = "win" 
                    elif len(game) > 1 and sum(game[-1]) == 7: 
                        outcome = "loss" 
                    elif len(game) > 1 and sum(game[0]) == sum(game[-1]): 
                        outcome = "win" 
                    else: 
                        detail_log.error("problem with {}".format(game)) 
                        raise Exception("Wait, What?") 
                    event = (outcome, len(game)) 
                    detail_log.debug("game {} -> event {}".format(game, event)) 
                    counts[event] += 1 
                return counts 

    ```

    `detail_log`记录器用于收集调试信息。如果我们将整个日志记录级别设置为包含调试消息，我们将看到这个额外的输出。

6.  `get_options()`函数还将写入调试行。这有助于诊断问题，将选项显示在日志中：

    ```py
            def get_options(argv): 
                parser = argparse.ArgumentParser() 
                parser.add_argument('file', nargs='*') 
                parser.add_argument('-o', '--output') 
                options = parser.parse_args(argv) 
                detail_log.debug("options: {}".format(options)) 
                return options 

    ```

7.  We can add a simple configuration to see the log entries. This works as a first step to simply confirm that there are two loggers and they're being used properly:

    ```py
            if __name__ == "__main__": 
                logging.basicConfig(stream=sys.stderr, level=logging.INFO) 
                main() 

    ```

    此日志记录配置生成默认处理程序对象。此对象只打印给定流上的所有日志消息。此处理程序被分配给根记录器；它将适用于此记录器的所有子项。因此，在前面代码中创建的两个记录器将转到同一个流。

    以下是运行此脚本的示例：

    ```py
     slott$ python3 ch13_r06a.py -o sum.yaml x.yaml 
          INFO:overview_stats.detail:read x.yaml 
          INFO:overview_stats.write:wrote sum.yaml

    ```

    日志中有两行。两者都有信息的严重性。第一行来自`overview_stats.detail`记录器。第二行来自`overview_stats.write`记录器。默认配置将所有记录器发送到`sys.stdout`。

8.  In order to route the different loggers to different destinations, we'll need a more sophisticated configuration than the `basicConfig()` function. We'll use the `logging.config` module. The `dictConfig()` method can provide a complete set of configuration options. The easiest way to do this is to write the configuration in YAML and then convert this to an internal `dict` object using the `yaml.load()` function:

    ```py
                import logging.config 
                config_yaml = ''' 
            version: 1 
            formatters: 
                default: 
                    style: "{" 
                    format: "{levelname}:{name}:{message}" 
                    #   Example: INFO:overview_stats.detail:read x.yaml 
                timestamp: 
                    style: "{" 
                    format: "{asctime}//{levelname}//{name}//{message}" 

            handlers: 
                console: 
                    class: logging.StreamHandler 
                    stream: ext://sys.stderr 
                    formatter: default 
                file: 
                    class: logging.FileHandler 
                    filename: write.log 
                    formatter: timestamp 

            loggers: 
                overview_stats.detail: 
                    handlers: 
                    -   console 
                overview_stats.write: 
                    handlers: 
                    -   file 
                    -   console 
            root: 
                level: INFO 
            ''' 

    ```

    YAML 文档包含在三个撇号字符串中。这使我们可以根据需要写尽可能多的文本。我们使用 YAML 符号在大文本块中定义了五件事：

    *   `version`键的值必须为 1。
    *   `formatters`键的值定义日志格式。如果未指定，默认格式仅显示消息正文，不显示任何级别或记录器信息：
        *   此处定义的`default`格式化程序镜像了`basicConfig()`函数创建的格式。
        *   此处定义的`timestamp`格式化程序是一种更复杂的格式，其中包括记录的日期时间戳。为了使文件更容易解析，使用了一个列分隔符`//`。
    *   `handlers`键定义了两个记录器的两个处理程序。`console`处理程序写入流`sys.stderr`。我们指定了此处理程序将使用的格式化程序。此定义与`basicConfig()`功能创建的配置平行。

    `file`处理程序写入文件。打开文件的默认模式为`a`，将追加到文件中，文件大小没有上限。还有其他处理程序可以在多个文件中旋转，每个文件的大小有限。我们提供了一个显式的文件名和格式化程序，该文件将比控制台上显示的内容更详细：

    *   `loggers`键为应用程序将创建的两个记录器提供配置。任何以`overview_stats.detail`开头的记录器名称将仅由控制台处理程序处理。任何以`overview_stats.write`开头的记录器名称都将转到文件处理程序和控制台处理程序。
    *   `root`键定义顶级记录器。它有一个名称`''`（空字符串），以防我们需要在代码中引用它。在根记录器上设置级别将为此记录器的所有子级设置级别。
9.  使用配置将`main()`功能包装如下：

    ```py
            logging.config.dictConfig(yaml.load(config_yaml)) 
            main()
            logging.shutdown()
    ```

10.  这将在已知状态下启动日志记录。它将处理申请。它将完成所有日志缓冲区并正确关闭所有文件。

## 它是如何工作的。。。

在应用程序中引入日志有三个部分：

*   创建记录器对象
*   将日志请求放置在重要状态更改附近
*   将日志系统作为一个整体进行配置

可以通过多种方式创建记录器。此外，它也可以被忽略。默认情况下，我们可以使用`logging`模块本身作为记录器。例如，如果我们使用`logging.info()`方法，这将隐式地使用根记录器。

更常见的方法是创建一个与模块同名的记录器：

```py
    logger = logging.getLogger(__name__) 

```

对于顶级主脚本，其名称为`"__main__"`。对于导入的模块，名称将与模块名称匹配。

在更复杂的应用程序中，将有各种各样的记录器用于各种目的。在这些情况下，仅以模块命名记录器可能无法提供所需的灵活性。

有两个概念可用于为记录器分配名称。通常，最好选择其中一种，并在整个大型应用程序中坚持使用：

*   遵循包和模块层次结构。这意味着特定于类的记录器可能具有类似于`package.module.class`的名称。同一模块中的其他类将共享一个公共父记录器名称。然后可以为整个包、一个特定模块或一个类设置日志记录级别。
*   遵循基于受众或用例的层次结构。顶级名称将区分日志的受众或目的。我们可能会有顶级的记录者，他们的名字比如`event`、`audit`或者`debug`。这样，所有审核日志记录程序的名称都将以`"audit."`开头。这可以很容易地将给定父项下的所有记录器路由到特定的处理程序。

在配方中，我们使用了第一种命名方式。记录器名称与软件体系结构并行。在所有重要的状态更改附近放置日志记录请求应该相对简单。日志中有各种有趣的状态更改：

*   对持久性资源的任何更改都可能是包含级别信息消息的好地方。任何操作系统更改（通常是对文件系统的更改）都是日志记录的候选项。同样，应该记录数据库更新和更改 web 服务状态的请求。
*   无论何时在进行持续状态更改时出现问题，都应该有一条消息`ERROR`。任何操作系统级别的异常都可以在捕获和处理时记录。
*   在长而复杂的计算中，在导入赋值语句之后记录`DEBUG`消息可能会有所帮助。在某些情况下，这暗示可能需要将长计算分解为函数，以便可以单独测试它们。
*   对内部应用程序资源的任何更改都应该得到一条`DEBUG`消息，以便可以通过日志跟踪对象状态的更改。
*   当应用程序进入错误状态时。这通常是由于一个例外。在某些情况下，`assert`语句将用于检测程序的状态，并在出现问题时引发异常。在`EXCEPTION`级别记录了一些异常。但是，有些异常只需要`DEBUG`级别的消息，因为异常正在被静默或转换。某些异常可能记录在`ERROR`或`CRITICAL`级别。

日志记录的第三个方面是配置记录器，以便将请求路由到适当的目的地。默认情况下，在没有任何配置的情况下，记录器都会安静地创建日志事件，但不会显示它们。

通过最简单的配置，我们可以在控制台上看到所有日志事件。这可以通过`basicConfig()`方法完成，并且涵盖了大量简单的用例，没有任何实际的麻烦。我们可以使用 filename 来提供命名文件，而不是流。也许最重要的特性是通过`basicConfig()`方法在根记录器上设置日志记录级别，提供一种简单的方法来启用调试。

配方中的示例配置使用了两个常见的处理程序`StreamHandler`和`FileHandler`类。还有十几个以上的处理程序，每个处理程序都具有收集和发布日志消息的独特功能。

## 还有更多。。。

*   本应用程序的补充部分请参见*合成设计脚本*配方

# 将两个应用合并为一个

在*为*配方设计脚本的过程中，我们看到了一个简单的应用程序，它通过模拟一个过程来创建一个统计数据集合。在*使用日志记录控制和审计输出*配方中，我们查看了一个汇总统计数据集合的应用程序。在此配方中，我们将结合这两个独立的应用程序来创建一个单一的复合应用程序，该应用程序将创建并汇总统计数据。

有几种常用的方法可以组合这两种应用程序：

*   shell 脚本可以运行模拟器，然后运行分析器
*   Python 程序可以代替 shell 脚本，并使用`runpy`模块运行每个程序
*   我们可以从每个应用程序的基本特性构建一个复合应用程序

在*为*配方设计脚本的过程中，我们检查了应用程序的三个方面：

*   收集投入
*   生产量
*   连接输入和输出的基本处理

在配方中，我们研究了一种设计模式，该模式允许将多个 Python 语言组件组合到一个更大的应用程序中。

我们如何组合应用程序来创建组合？

## 准备好了吗

在*为组合*和*设计脚本时，使用日志记录控制和审计输出*配方，我们遵循了一种将输入收集、基本处理和输出生产分离的设计模式。设计模式背后的目标是将有趣的片段聚集在一起，将它们组合并重新组合成更高层次的结构。

请注意，这两个应用程序之间存在微小的不匹配。我们可以借用数据库工程（以及电气工程）的一句话，称之为阻抗失配。在电气工程中，这是一个电路设计问题，通常通过使用一种称为变压器的装置来解决。这可用于匹配电路组件之间的阻抗。

在数据库工程中，当数据库具有规范化的平面数据，但编程语言使用结构丰富的复杂对象时，就会出现这种问题。对于 SQL 数据库，这是一个常见问题，像**SQLAlchemy**这样的包被用作**对象关系管理**（**ORM**层。该层是平面数据库行（通常来自多个表）和复杂 Python 结构之间的转换器。

在构建复合应用程序时，本例中出现的阻抗失配是一个主要问题。模拟器设计为比统计摘要器运行更频繁。我们有几种选择来解决这类重大问题：

*   **全面重新设计**：这可能不是一个明智的选择，因为这两个组件应用程序有一个已建立的用户基础。在其他情况下，新用例是一个进行全面修复和消除一些技术债务的机会。
*   **包含迭代器**：这意味着在构建复合应用程序时，我们将添加一个`for`语句来执行许多模拟运行，然后将其处理为单个摘要。这与最初的设计意图相似。
*   **一个**的列表：这意味着复合应用程序将运行一个模拟，并将此单一模拟输出提供给摘要器。这修改了结构以进行更多的总结；这些总结可能需要合并到预期的单一结果中。

这两者之间的选择取决于首先导致创建复合应用程序的用户情景。这也可能取决于已建立的用户基础。出于我们的目的，我们假设用户已经意识到 1000 个样本的 1000 次模拟运行是标准的，他们希望遵循*包括迭代器*的设计来创建一个复合流程。

作为练习，读者应追求替代设计。相反，假设用户更愿意在一次模拟中运行 1000000 个样本。因此，用户更希望摘要器使用一种设计的*列表。*

我们还将考虑另一种选择。在本例中，我们将在多个并发工作进程上执行 100 次模拟运行。这将减少创建一百万个样本的时间。这是*的变体，包括迭代器*复合设计。

## 怎么做。。。

1.  遵循将复杂流程分解为独立于输入或输出细节的功能的设计模式。详见*构图脚本设计*配方。
2.  从工作模块导入基本功能。在本例中，这两个模块的名称相对来说比较乏味，`ch13_r05`和`ch13_r06`：

    ```py
            from ch13_r05 import roll_iter 
            from ch13_r06 import gather_stats 

    ```

3.  导入所需的任何其他模块。我们将使用`Counter`函数来准备本例中的摘要：

    ```py
            from collections import Counter 

    ```

4.  Create a new function that combines the existing functions from the other applications. The output from one function is input to another:

    ```py
            def summarize_games(total_games, *, seed=None): 
                game_statistics = gather_stats(roll_iter(total_games, seed=seed)) 
                return game_statistics 

    ```

    在许多情况下，显式地堆栈函数、创建中间结果更有意义。当有多个函数创建一种 map reduce 管道时，这一点尤为重要：

    ```py
            def summarize_games_2(total_games, *, seed=None): 
                game_roll_history = roll_iter(total_games, counts, seed=seed) 
                game_statistics = gather_stats(game_roll_history) 
                return game_statistics 

    ```

    我们用中间变量将处理过程分解为多个步骤。`game_roll_history`变量是`roll_iter()`函数的输出。该发生器的输出是`gather_states()`功能的可调输入，保存在`game_statistics`变量中。

5.  编写使用此复合进程的输出格式化函数。例如，这里是一个执行`summarize_games()`功能的复合过程。这也会写入输出报告：

    ```py
            def simple_composite(games=100000): 
                start = time.perf_counter() 
                stats = summarize_games(games) 
                end = time.perf_counter() 
                games = sum(stats.values()) 
                print('games', games) 
                print(win_loss(stats)) 
                print("{:.2f} seconds".format(end-start)) 

    ```

6.  可以使用`argparse`模块收集命令行选项。在配方中有这样的例子，包括*为合成*配方设计脚本。

## 它是如何工作的。。。

此设计的中心功能是将应用程序的各种关注点分离为独立的函数或类。这两个组件应用程序从一个在输入、过程和输出关注点之间划分的设计开始。从这个基础开始，可以方便地导入和重用处理。这也使得两个原始应用程序保持不变。

目标是从工作模块导入函数，避免复制和粘贴编程。从一个文件复制一个函数并将其粘贴到另一个文件中意味着对其中一个文件所做的任何更改都不太可能对另一个文件所做的任何更改。这两个副本将慢慢分离，导致一种有时被称为*代码腐烂*的现象。

当一个类或函数执行多个操作时，重用的可能性就会降低。这导致了对**重用逆幂律**的观察——一个类或函数*R（c）*的可重用性与该类或函数中的特征数量相反*F（c）*：

*R**c*∝ 1/*F*（*c*）

单一功能有助于重用。多个功能减少了组件的重用机会。

当我们查看*为组合*和*设计脚本并使用日志记录控制和审计输出*配方中的两个原始应用程序时，我们可以看到基本函数几乎没有特性。`roll_iter()`函数模拟了一个游戏，并产生了结果。`gather_stats()`函数从任何数据源收集统计数据。

当然，统计特征的想法取决于抽象的层次。从小规模的角度来看，这些函数可以做很多小事情。从非常大的范围来看，这些功能需要几个助手才能形成一个完整的应用程序；从这个角度来看，单个功能只是特征的一部分。

我们这里的重点是软件的技术特性。这与敏捷的特性概念无关，它是多个用户故事背后的统一概念。在本文中，我们讨论的是软件体系结构的技术特性输入、输出、处理、使用的操作系统资源、依赖性等等。

实际上，相关的技术特性与用户故事相关联。这就把规模问题放到了用户感知的软件属性领域。如果用户看到不止一个特性，这意味着重用可能很困难。

在本例中，一个应用程序创建文件。第二个应用程序汇总了文件。用户的反馈可能表明，区别并不重要，也可能令人困惑。这导致重新设计，从两个原始步骤创建一步操作。

## 还有更多。。。

我们将介绍可以作为复合应用程序一部分的其他三个体系结构功能：

*   **重构**：将两个应用程序合并为一个配方的*没有正确区分处理和输出。当尝试创建复合应用程序时，我们可能需要重构组件模块。*
*   **并发**：并行运行多个`roll_iter()`实例，使用多核。
*   **日志记录**：当多个应用程序组合时，组合的日志记录可能会变得复杂。

### 重构

在某些情况下，有必要重新排列软件以提取有用的功能。在其中一个组件`ch13_r06`模块中，可使用以下功能：

```py
    def process_all_files(result_file, file_names): 
        for source_path in (Path(n) for n in file_names): 
            detail_log.info("read {}".format(source_path)) 
            with source_path.open() as source_file: 
                game_iter = yaml.load_all(source_file) 
                statistics = gather_stats(game_iter) 
                result_file.write( 
                    yaml.dump(dict(statistics), explicit_start=True) 
                ) 

```

这将源文件迭代、详细处理和输出创建结合在一起。`result_file.write()`输出处理是一个单一、复杂的语句，很难从这个函数中提取。

为了在两个应用程序之间正确地重用此功能，我们需要重构`ch13_r06`应用程序，以便文件输出不会隐藏在`process_all_files()`函数中。在这种情况下，重构并不太困难。在某些情况下，选择了错误的抽象，重构非常困难。

一行代码`result_file.write(...)`需要用单独的函数替换。这是一个小变化。细节留给读者作为练习。如果定义为单独的函数，则更容易替换。

这种重构使新函数可用于其他复合应用程序。当多个应用程序共享一个公共功能时，应用程序之间的输出实际上更可能是兼容的。

### 并发

运行多个模拟然后进行一个总结的根本原因是一种 map-reduce 设计。详细的模拟可以使用多个核和多个处理器并行运行。但是，需要通过统计缩减从所有模拟中创建最终摘要。

我们经常使用操作系统功能来运行多个并发进程。POSIX shell 包括`&`操作符，可用于派生并发子流程。Windows 有一个类似的 `**start**` 命令。我们可以直接利用 Python 来产生大量并发计算过程。

其中一个模块是`concurrent`包中的`futures`模块。我们可以通过创建一个`ProcessPoolExecutor`实例来构建一个并行仿真处理器。我们可以向该执行者提交请求，然后从这些并发请求中收集结果：

```py
    import concurrent.futures 

    def parallel(): 
        start = time.perf_counter() 
        total_stats = Counter() 
        worker_list = [] 
        with concurrent.futures.ProcessPoolExecutor() as executor: 
            for i in range(100): 
                worker_list.append(executor.submit(summarize_games, 1000)) 
            for worker in worker_list: 
                stats = worker.result() 
                total_stats.update(stats) 
        end = time.perf_counter() 

        games = sum(total_stats.values()) 
        print('games', games) 
        print(win_loss(total_stats)) 
        print("{:.2f} seconds".format(end-start)) 

```

我们已经初始化了三个对象：`start`、`total_stats`和`worker_list`。`start`对象具有处理开始的时间；`time.perf_counter()`通常是可用的最精确的计时器。`total_stats`是收集最终统计摘要的`Counter`对象。`worker_list`将是单个`Future`对象的列表，每个请求对应一个。

`ProcessPoolExecutor`方法定义了一个处理上下文，在该上下文中可以使用一个工作池来处理请求。默认情况下，池中的工人数量与处理器数量相同。每个工作进程都运行一个导入给定模块的执行器。工作人员可以使用模块中定义的所有函数和类。

执行器的`submit()`方法被赋予一个要执行的函数以及该函数的参数。在本例中，将发出 100 个请求，每个请求将模拟 1000 个游戏并返回这些游戏的掷骰子序列。`submit()`返回一个`Future`对象，该对象是工作请求的模型。

提交所有 100 个请求后，将收集结果。`Future`对象的`result()`方法等待处理完成并收集结果对象。在本例中，结果是 1000 场比赛的统计摘要。然后将这些内容组合在一起，形成整体`total_stats`摘要。

下面是串行和并行执行之间的比较：

```py
games 100000 

Counter({'loss': 50997, 'win': 49003}) 

2.83 seconds 

games 100000 

Counter({'loss': 50523, 'win': 49477}) 

1.49 seconds

```

处理时间缩短了一半。既然有 100 个并发请求，为什么时间没有减少原来时间的 1/100？观察到，在生成子流程、传递请求数据和传递结果数据时，会有相当大的开销。

### 测井

在*使用日志记录控制和审核输出*配方中，我们了解了如何使用`logging`模块进行控制、审核和错误输出。当我们构建一个复合应用程序时，我们必须组合来自每个原始应用程序的日志功能。

日志记录包括三个部分：

1.  创建记录器对象。这通常是一行，如`logger = logging.get_logger('some_name')`。通常在类或模块级别执行一次。
2.  使用记录器对象收集事件。这涉及到诸如`logger.info('some message')`之类的行。这些行分散在整个应用程序中。
3.  Configuring the logging system as a whole. There are two possibilities for log configuration in an application:
    *   尽可能的外部化。在这种情况下，日志配置仅在应用程序的最外层、全局范围内完成：

        ```py
                    if __name__ == "__main__": 
                        logging configuration goes only here. 
                        main() 
                        logging.shutdown() 

        ```

    这保证了日志记录系统只有一个配置。

    *   类、函数或模块内部的某处。在这种情况下，我们可能有几个模块都在尝试进行日志配置。这是日志记录系统可以容忍的。然而，调试时可能会感到困惑。

这些食谱都遵循第一种方法。如果所有应用程序都在最全局的范围内配置日志记录，那么很容易理解如何配置复合应用程序。

在存在多个日志记录配置的情况下，复合应用程序可以遵循两种方法：

*   复合应用程序包含最终配置，该配置有意覆盖所有先前定义的记录器。这是默认值，可以在 YAML 配置文档中通过`incremental: false`明确说明。
*   复合应用程序保留其他应用程序记录器，只修改记录器配置，可能通过设置总体级别。这是通过在 YAML 配置文件中包含`incremental: true`来实现的。

当组合不隔离日志记录配置的 Python 应用程序时，使用增量配置非常有用。为了正确配置复合应用程序的日志记录，阅读和理解每个应用程序的代码可能需要一些时间。

## 另见

*   在*为组合设计脚本*配方中，我们研究了可组合应用程序的核心设计模式

# 使用命令设计模式组合多个应用程序

许多复杂的应用程序套件遵循与 Git 程序使用的设计模式相似的设计模式。有一个基本命令，`git`，带有许多子命令。例如，`git pull`、`git commit`和`git push`。

此设计的核心是单个命令的集合。git 的每一个特性都可以看作是执行给定函数的一个单独的类定义。

当我们输入诸如`git pull`之类的命令时，就好像程序`git`正在定位一个类来实现该命令。

如何创建密切相关的命令族？

## 准备好了吗

我们将想象一个由三个命令构建的应用程序。这是基于*设计合成脚本*、*使用日志记录控制和审计输出*以及*将两个应用程序合并为一个*配方中所示的应用程序。我们将有三个应用程序-*模拟*、*总结*，以及一个名为*模拟*的组合应用程序。

这些特性基于名称为`ch13_r05`、`ch13_r06`和`ch13_r07`的模块。其思想是，我们可以按照命令设计模式将这些单独的模块重组为单个类层次结构。

此设计有两个关键要素：

1.  客户端仅依赖于抽象超类`Command`。
2.  `Command`超类的每个单独子类都有一个相同的接口。我们可以用它们中的任何一个代替任何其他的。

当我们完成这项工作后，整个应用程序脚本就可以创建并执行`Command`子类中的任何一个。

## 怎么做。。。

1.  The overall application will have a structure that attempts to separate the features into two categories—argument parsing and command execution. Each subcommand will include both processing and the output bundled together.

    以下是`Command`超类：

    ```py
            from argparse import Namespace 

            class Command: 
                def execute(self, options: Namespace): 
                    pass 

    ```

    我们将依靠`argparse.Namespace`为每个子类提供非常灵活的选项集合。这不是必需的，但将有助于*管理复合应用程序*中的参数和配置。由于该方法将包括选项解析，因此最好将每个类的重点放在使用`argparse.Namespace`上。

2.  Create a subclass of the `Command` superclass for the `Simulate` command:

    ```py
            import ch13_r05 

            class Simulate(Command): 
                def __init__(self, seed=None): 
                    self.seed = seed 
                def execute(self, options): 
                    self.game_path = Path(options.game_file) 
                    data = ch13_r05.roll_iter(options.games, self.seed) 
                    ch13_r05.write_rolls(self.game_path, data) 

    ```

    我们已经将`ch13_r05`模块的处理和输出包装到此类的`execute()`方法中。

3.  Create a subclass of the `Command` superclass for the `Summarize` command:

    ```py
            import ch13_r06 

            class Summarize(Command): 
                def execute(self, options): 
                    self.summary_path = Path(options.summary_file) 
                    with self.summary_path.open('w') as result_file: 
                        ch13_r06.process_all_files(result_file, options.game_files) 

    ```

    对于这个类，我们已经将文件创建和文件处理包装到该类的`execute()`方法中。

4.  All of the overall processes can be performed by the following `main()` function:

    ```py
            from argparse import Namespace 

            def main(): 
                options_1 = Namespace(games=100, game_file='x.yaml') 
                command1 = Simulate() 
                command1.execute(options_1) 

                options_2 = Namespace(summary_file='y.yaml', game_files=['x.yaml']) 
                command2 = Summarize() 
                command2.execute(options_2) 

    ```

    我们已经创建了两个命令，`Simulate`类的一个实例和`Summarize`类的一个实例。可以执行这些命令，以提供模拟和汇总数据的组合功能。

## 它是如何工作的。。。

为各种子命令创建可互换的多态类是提供可扩展设计的一种简便方法。`Command`设计模式强烈鼓励每个单独的子类具有相同的签名，以便可以创建和执行任何命令。此外，还可以添加适合框架的新命令。

实体设计原则之一是**利斯科夫替代原则**（**LSP**）。`Command`抽象类的任何子类都可以用来代替父类。

每个`Command`实例都有一个简单的接口。有两个特点：

*   `__init__()`方法需要参数解析器创建的名称空间对象。每个类将仅从此命名空间中拾取所需的值，而忽略任何其他值。这允许不需要全局参数的子命令忽略全局参数。
*   `execute()`方法进行处理并写入任何输出。这完全基于初始化期间提供的值。

使用命令设计模式可以很容易地确保它们可以相互交换。整个`main()`脚本可以创建`Simulate`或`Summarize`类的实例。替换原则意味着任何一个实例都可以执行，因为接口是相同的。这种灵活性使解析命令行选项和创建任何可用类的实例变得容易。我们可以扩展这个想法，创建单个命令实例的序列。

## 还有更多。。。

此设计模式的一个更常见的扩展是提供复合命令。在*将两个应用组合成一个*配方中，我们展示了一种创建复合材料的方法。这是另一种方法，它基于定义一个新命令来实现现有命令的组合：

```py
    class CommandSequence(Command): 
        def __init__(self, *commands): 
            self.commands = [command() for command in commands] 
        def execute(self, options): 
            for command in self.commands: 
                command.execute(options) 

```

该类将通过`*commands`参数接受其他`Command`类。此序列将组合所有位置参数值。它将从类中构建各个类实例。

我们可以这样使用这个`CommandSequence`类：

```py
    options = Namespace(games=100, game_file='x.yaml', 
        summary_file='y.yaml', game_files=['x.yaml'] 
    ) 
    sim_sum_command = CommandSequence(Simulate, Summarize) 
    sim_sum_command.execute(options) 

```

我们使用另外两个类——`Simulate`和`Summarize`创建了`CommandSequence`的实例。`__init__()`方法将构建两个对象的内部序列。然后，`sim_sum_command`对象的`execute()`方法将依次执行这两个处理步骤。

此设计虽然简单，但公开了许多实现细节。特别是，这两个类名和中间的`x.yaml`文件是可以封装到更好的类设计中的细节。

如果我们特别关注组合的两个命令，我们可以创建一个稍微好一点的`CommandSequence`参数子类。这将有一个遵循其他`Command`子类模式的`__init__()`方法：

```py
    class SimSum(CommandSequence): 
        def __init__(self): 
            super().__init__(Simulate, Summarize) 

```

该类定义将另外两个类合并到已定义的`CommandSequence`结构中。我们还可以通过稍微修改选项来继续这个想法，以消除来自`Simulate`步骤的`game_file`输出的显式值，这也必须是`Summarize`步骤的`game_files`输入的一部分。

我们希望构建和使用一个更简单的`Namespace`，并提供如下选项：

```py
    options = Namespace(games=100, summary_file='y.yaml') 
    sim_sum_command = SimSum() 
    sim_sum_command.execute(options) 

```

这意味着一些缺失的选项必须通过`execute()`方法注入。我们将此方法添加到`SimSum`类中：

```py
    def execute(self, options): 
        new_namespace = Namespace( 
            game_file='x.yaml', 
            game_files=['x.yaml'], 
            **vars(options) 
        ) 
        super().execute(new_namespace) 

```

此`execute()`方法克隆选项。它添加了两个附加值，这是命令集成的一部分，但不是用户应该提供的。

这种设计避免了更新有状态的选项集。为了保持原始选项对象完好无损，制作了一份副本。`vars()`函数将`Namespace`公开为一个简单的 dict。然后，我们可以使用`**`关键字参数技术将字典转换为新`Namespace`对象的关键字参数。这将创建一个浅拷贝。如果名称空间中的任何有状态对象被更新，那么很明显原始的`options`和`new_namespace`参数都可以访问相同的基础值对象。

由于`new_namespace`是一个独特的集合，我们可以向`Namespace`实例添加新的键和值。这些选项将仅出现在`new_namespace`中，而不显示原始选项对象。

## 另见

*   在*为组合*设计脚本、*使用日志记录控制和审计输出*以及*将两个应用程序合并为一个*配方中，我们查看了这个组合应用程序的组成部分。在大多数情况下，我们需要结合所有这些配方的元素来创建一个有用的应用程序。
*   我们通常需要遵循*在复合应用程序*中管理参数和配置的方法。

# 管理复合应用程序中的参数和配置

当我们拥有单个应用程序的复杂套件（或系统）时，多个应用程序共享公共功能是很常见的。当然，我们可以使用普通继承来定义一个库模块，它为复杂套件中的每个应用程序提供公共类和函数。

创建多个独立应用程序的缺点是，外部 CLI 直接绑定到软件体系结构。重新排列软件组件会变得很尴尬，因为更改也会改变可见的 CLI。

在许多应用程序文件之间协调公共功能可能会变得很尴尬。例如，很难为命令行参数定义各种单字母缩写选项。它需要在所有单个应用程序文件之外保留某种主选项列表。这似乎应该保存在代码的某个地方。

除了继承，还有其他选择吗？我们如何确保可以重构一套应用程序，而无需对 CLI 进行意外更改或需要复杂的附加设计说明？

## 准备好了吗

许多复杂的应用程序套件遵循与 Git 使用的设计模式相似的设计模式。有一个基本命令`git`，带有许多子命令。例如，`git pull`、`git commit`和`git push`。命令行界面的核心可以通过`git`命令集中。然后，可以根据需要组织和重新组织子命令，对 visible CLI 的更改更少。

我们将想象一个由三个命令构建的应用程序。这是基于*设计合成脚本*、*使用日志记录控制和审计输出*以及*中所示的应用程序，将两个应用程序合并为一个*配方。我们将有三个带有三个命令的应用程序：`craps simulate`、`craps summarize`和组合应用程序`craps simsum`。

我们将依靠*中的子命令设计，使用命令设计模式*组合许多应用程序。这将提供一个方便的`Command`子类层次结构：

*   `Command`类是一个抽象的超类
*   `Simulate`子类执行*合成*配方设计脚本中的模拟功能
*   `Summarize`子类使用控制和审计输出的日志记录来执行*中的汇总功能*
*   一个`SimSum`子类可以按照*将两个应用程序组合成一个*配方的思想，执行组合模拟和总结

为了创建一个简单的命令行应用程序，我们需要适当的参数解析。

此参数解析将依赖于`argparse`模块的子命令解析功能。我们可以创建一组应用于所有子命令的通用命令选项。我们还可以为每个子命令创建唯一的选项。

## 怎么做。。。

1.  Define the command interface. This is an exercise in **User Experience** ( **UX** ) design. While most UX is focused on web and mobile device applications, the core principles are appropriate for CLI applications and servers, as well.

    前面，我们注意到根应用程序将是`craps`。它将有以下三个子命令：

    ```py
     craps simulate -o game_file -g games 
          craps summarize -o summary_file game_file ... 
          craps simsum -g games

    ```

2.  定义根 Python 应用程序。与本书中的其他文件一致，我们将其命名为`ch13_r08.py`。在操作系统级别，我们可以提供别名或链接，使可视界面符合用户对`craps`的期望。
3.  我们将从*中导入类定义，使用命令设计模式*组合许多应用程序。这将包括`Command`超类和`Simulate`、`Summarize`和`SimSum`子类。
4.  Create the overall argument parser then create a subparser builder. The `subparsers` object will be used to create each subcommand's argument definition:

    ```py
            import argparse 
            def get_options(argv): 
                parser = argparse.ArgumentParser(prog='craps') 
                subparsers = parser.add_subparsers() 

    ```

    对于每个命令，创建一个解析器并添加该命令特有的参数。

5.  使用模拟独有的两个选项定义`simulate`命令。我们还将提供一个特殊的默认值，用于初始化生成的`Namespace`对象：

    ```py
                simulate_parser = subparsers.add_parser('simulate') 
                simulate_parser.add_argument('-g', '--games', type=int, default=100000) 
                simulate_parser.add_argument('-o', '--output', dest='game_file') 
                simulate_parser.set_defaults(command=Simulate) 

    ```

6.  使用此命令特有的参数定义`summarize`命令。提供将填充`Namespace`对象的默认值：

    ```py
                summarize_parser = subparsers.add_parser('summarize') 
                summarize_parser.add_argument('-o', '--output', dest='summary_file') 
                summarize_parser.add_argument('game_files', nargs='*') 
                summarize_parser.set_defaults(command=Summarize) 

    ```

7.  定义`simsum`命令，同样地，提供一个唯一的默认值，使`Namespace`的处理更容易：

    ```py
                simsum_parser = subparsers.add_parser('simsum') 
                simsum_parser.add_argument('-g', '--games', type=int, default=100000) 
                simsum_parser.add_argument('-o', '--output', dest='summary_file') 
                simsum_parser.set_defaults(command=SimSum) 

    ```

8.  Parse the command-line values. In this case the overall argument to the `get_options()` function is expected to be the value of `sys.argv[1:]` , which includes the arguments to the Python command. We can override the argument value for testing purposes:

    ```py
                options = parser.parse_args(argv) 
                if 'command' not in options: 
                    parser.print_help() 
                    sys.exit(2) 
                return options 

    ```

    整个解析器包括三个子命令解析器。一个处理`craps simulate`命令，另一个处理`craps summarize`，第三个处理`craps simsum`。每个子命令的选项组合略有不同。

    仅通过`set_defaults()`方法设置`command`选项。这将发送有关要执行的命令的有用的附加信息。在本例中，我们提供了必须实例化的类。

9.  The overall application is defined by the following `main()` function:

    ```py
            def main(): 
                options = get_options(sys.argv[1:]) 
                command = options.command(options) 
                command.execute() 

    ```

    这些选项将被解析。每个不同的子命令为`options.command`参数设置一个唯一的类值。此类用于构建`Command`子类的实例。此对象将有一个`execute()`方法来执行此命令的实际工作。

10.  Implement the OS wrapper for the root command. We might have a file named `craps` . The file would have rx permissions so that it was readable by other users. The content of the file could be this line:

    ```py
     python3.5 ch13_r08.py $*

    ```

    这个小 shell 脚本提供了一种简便的方法来输入 `**craps**` 命令，并让它正确地执行一个具有不同名称的 Python 脚本。

    我们可以创建一个 bash shell 别名，如下所示：

    ```py
     alias craps='python3.5 ch13_r08.py'

    ```

    这可以放在`.bashrc`文件中定义 `**craps**` 命令。

## 它是如何工作的。。。

此配方分为两部分：

*   使用`Command`设计模式定义一组相关的多态类。有关这方面的更多信息，请参阅*使用命令设计模式*组合许多应用程序。
*   使用`argparse`模块的特性处理子命令。

这里重要的`argparse`模块特性是解析器的`add_subparsers()`方法。此方法返回用于构建每个不同子命令解析器的对象。我们将此对象分配给变量`subparsers`。

我们还在顶级解析器中定义了一个简单的`command`参数。此参数只能由为每个子解析器定义的默认值填充。这将提供一个值，显示实际调用了哪些子命令。

每个子解析器都是使用子解析器对象的`add_parser()`方法构建的。然后返回的`parser`对象可以定义参数和默认值。

当执行整个解析器时，它将解析在子命令之外定义的任何参数。如果有子命令，则该命令用于确定如何解析其余参数。

请查看以下命令：

```py
craps simulate -g 100 -o x.yaml 

```

将解析此命令以创建一个如下所示的`Namespace`对象：

```py
Namespace(command=<class '__main__.Simulate'>, game_file='x.yaml', games=100)

```

`Namespace`对象中的`command`属性是作为子命令定义的一部分提供的默认值。`game_file`和`games`的值来自`-o`和`-g`选项。

### 指挥设计模式

为不同的子命令创建可互换的多态类可以创建一个易于重构或扩展的设计。`Command`设计模式强烈鼓励每个单独的子类具有相同的签名，以便可以创建和执行任何一个可用的命令类。

实体设计原则之一是利斯科夫替代原则。命令抽象类的任何子类都可以用来代替父类。

每个`Command`都有一个一致的接口：

*   `__init__()`方法需要参数解析器创建的名称空间对象。每个类将仅从此命名空间中拾取所需的值，而忽略任何其他值。这允许不需要全局参数的子命令忽略全局参数。
*   `execute()`方法进行处理并写入任何输出。这完全基于初始化期间提供的值。

使用命令设计模式可以轻松确保它们可以相互交换。替换原则意味着`main()`函数可以简单地创建一个实例，然后执行对象的`execute()`方法。

## 还有更多。。。

我们可以考虑将子命令解析器细节向下推到每个类定义中。例如，`Simulate`类定义了两个参数：

```py
    simulate_parser.add_argument('-g', '--games', type=int, default=100000) 
    simulate_parser.add_argument('-o', '--output', dest='game_file') 

```

`get_option()`函数定义这些关于实现类的细节似乎并不合适。似乎一个适当封装的设计会将这个细节分配给每个`Command`子类。

我们需要添加一个配置给定解析器的静态方法。新的类定义如下所示：

```py
    import ch13_r05 
    class Simulate(Command): 
        def __init__(self, options, *, seed=None): 
            self.games = options.games 
            self.game_file = options.game_file 
            self.seed = seed 
        def execute(self): 
            data = ch13_r05.roll_iter(self.games, self.seed) 
            ch13_r05.write_rolls(self.game_file, data) 
        @staticmethod 
        def configure(simulate_parser): 
            simulate_parser.add_argument('-g', '--games', type=int, default=100000) 
            simulate_parser.add_argument('-o', '--output', dest='game_file') 

```

我们添加了一个`configure()`方法来配置解析器。这一更改使得通过解析命令行值来创建`__init__()`参数变得非常容易。这允许我们重写`get_option()`函数，以及：

```py
    import argparse 
    def get_options(argv): 
        parser = argparse.ArgumentParser(prog='craps') 
        subparsers = parser.add_subparsers() 

        simulate_parser = subparsers.add_parser('simulate') 
        Simulate.configure(simulate_parser) 
        simulate_parser.set_defaults(command=Simulate) 

        # etc. for each class 

```

这将利用静态`configure()`方法提供参数详细信息。命令参数的默认值可以由整体`get_options()`处理，因为它不涉及内部细节。

## 另见

*   请参见*为组合设计脚本*、*使用日志记录控制和审核输出*、*将两个应用程序合并为一个*配方，以了解组件的背景
*   有关参数解析的更多背景信息，请参见[第 5 章](05.html#page "Chapter 5. User Inputs and Outputs")、*用户输入和输出*中的*使用 argparse 获取命令行输入*配方

# 包装和组合 CLI 应用程序

一种常见的自动化涉及到运行多个程序，这些程序实际上都不是 Python 应用程序。因为这些程序不是用 Python 编写的，所以不可能重写每个程序来创建一个复合 Python 应用程序。我们不能按照*将两个应用程序合并为一个*配方。

替代方法不是聚合功能，而是用 Python 包装其他程序以提供更高级别的构造。该用例与编写 shell 脚本的用例非常相似。区别在于使用 Python 而不是 shell 语言。使用 Python 有一些优点：

*   Python 拥有丰富的数据结构集合。shell 只有字符串和字符串数组。
*   Python 有一个优秀的单元测试框架。这使人们确信，Python 版本的 shell 脚本可以正常工作，而不会导致广泛使用的服务崩溃。

我们如何从 Python 内部运行其他应用程序？

## 准备好了吗

在*为*配方设计脚本的过程中，我们发现了一个应用程序，该应用程序进行了一些处理，从而产生了一个相当复杂的结果。出于本配方的目的，我们假设应用程序不是用 Python 编写的。

我们想运行这个程序几百次，但我们不想将必要的命令复制并粘贴到脚本中。此外，由于 shell 很难测试，并且数据结构很少，因此我们希望避免使用 shell。

对于这个配方，我们将假设`ch13_r05`应用程序是本机二进制应用程序；它可能是用 C++或 FORTRAN 语言编写的。这意味着我们不能简单地导入组成应用程序的 Python 模块。相反，我们必须通过运行单独的操作系统进程来处理这个应用程序。

我们将使用`subprocess`模块在操作系统级别运行应用程序。在 Python 中运行另一个二进制程序有两种常见的用例：

*   没有任何输出，或者我们不想在 Python 程序中收集它。第一种情况是典型的操作系统实用程序，它们在成功或失败时返回状态代码。第二种情况很典型，许多子程序都在写入标准错误日志；父 Python 程序只是启动一个子进程。
*   我们需要捕获并可能分析输出以检索信息或确定成功程度。

在这个配方中，我们将看到第一种情况，即输出不是我们需要捕获的东西。在*包装程序并检查输出*配方中，我们将看第二种情况，其中输出由 Python 包装程序检查。

## 怎么做。。。

1.  导入`subprocess`模块：

    ```py
            import subprocess 

    ```

2.  Design the command line. Generally, this should be tested at the OS prompt to be sure that it does the right things:

    ```py
     slott$ python3 ch13_r05.py --samples 10 --output x.yaml

    ```

    输出文件名需要灵活，以便我们可以运行程序数百次。这意味着创建名称为`game_{n}.yaml`的文件。

3.  Write a statement that iterates through the appropriate commands. Each command can be built as a sequence of individual words. Start with the working shell command and split that line on the spaces to create a proper sequence of words:

    ```py
            files = 100 
            for n in range(files): 
                filename = 'game_{n}.yaml'.format_map(vars()) 
                command = ['python3', 'ch13_r05.py', 
                    '--samples', '10', '--output', filename] 

    ```

    这将创建各种命令。我们可以使用`print()`函数来显示每个命令，并确认文件名定义正确。

4.  从`subprocess`模块评估`run()`功能。这将执行给定的命令。提供`check=True`以便在出现问题时会引发`subprocess.CalledProcessError`异常：

    ```py
            subprocess.run(command, check=True)

    ```

5.  为了正确地测试这一点，应该将整个序列转换为正确的函数。如果将来会有更多的相关命令，那么它应该是`Command`类层次结构中的一个子类的方法。请参阅*管理复合应用程序中的参数和配置*配方。

## 它是如何工作的。。。

`subprocess`模块是 Python 程序如何运行给定计算机上可用的其他程序。`run()`函数为我们做了很多事情。

在 POSIX（如 Linux 或 Mac OS X）上下文中，步骤类似于以下顺序：

*   为子流程准备`stdin`、`stdout`和`stderr`文件描述符。在本例中，我们接受了默认值，这意味着子级继承父级使用的文件。如果子进程打印到`stdout`，它将出现在父进程使用的同一控制台上。
*   调用`os.fork()`函数将当前进程拆分为父进程和子进程。父进程将获得子进程的进程 ID；然后它可以等待孩子完成。
*   在子级中，执行`os.execl()`函数（或类似函数），以提供子级将执行的命令路径和参数。
*   然后，子进程使用给定的`stdin`、`stdout`和`stderr`文件运行。
*   同时，父节点使用`os.wait()`等函数等待子节点完成并返回最终状态。
*   由于我们使用了`check=True`选项，`run()`函数将非零状态转换为异常。

操作系统外壳（如 bash）对应用程序开发人员隐藏这些细节。类似地，`subprocess.run()`函数隐藏了创建和等待子进程的细节。

带有`subprocess`模块的 Python 提供了许多类似于 shell 的特性。最重要的是，Python 提供了多组附加功能：

*   更丰富的数据结构集合。
*   识别出现的问题的例外情况。这比在 shell 脚本中插入`if`语句来检查状态代码要简单和可靠得多。
*   一种不使用操作系统资源对脚本进行单元测试的方法。

## 还有更多。。。

我们将向该脚本添加一个简单的清理功能。其思想是，所有输出文件都应作为原子操作创建。我们想要所有的文件，或者不想要任何文件。我们不希望数据文件收集不完整。

这符合酸的性质：

*   **原子性**：整套数据可用或不可用。集合是一个单一的、不可分割的工作单元。
*   **一致性**：文件系统应该从一个内部一致状态移动到另一个内部一致状态。任何摘要或索引都将正确反映实际文件。
*   **隔离**：如果我们想同时处理数据，那么多个并行进程应该可以工作。并发操作不应相互干扰。
*   **耐久性**：文件一旦写入，就应该保留在文件系统中。对于文件，此属性几乎不言而喻。对于更复杂的数据库，有必要考虑可能由数据库客户端确认的事务数据，但实际上还没有写入服务器。

使用具有独立工作目录的操作系统进程实现这些功能中的大多数都相对简单。但是，原子性属性导致需要进行清理操作。

为了清理，我们需要用一个`try:`块包装核心处理。整体功能如下所示：

```py
    import subprocess 
    from pathlib import Path 

    def make_files(files=100): 
        try: 
            for n in range(files): 
                filename = 'game_{n}.yaml'.format_map(vars()) 
                command = ['python3', 'ch13_r05.py', 
                    '--samples', '10', '--output', filename] 
                subprocess.run(command, check=True) 
        except subprocess.CalledProcessError as ex: 
            for partial in Path('.').glob("game_*.yaml"): 
                partial.unlink() 
            raise 

```

异常处理块做两件事。首先，它从当前工作目录中删除任何不完整的文件。其次，它重新引发原始异常，以便故障将传播到客户端应用程序。

由于处理失败，因此引发异常非常重要。在某些情况下，应用程序可能会定义此应用程序特有的新异常。可以改为引发新异常，重新引发原始的`CalledProcessError`异常。

### 单元测试

为了进行单元测试，我们需要模拟两个外部对象。我们需要对`subprocess`模块中的`run()`函数进行模拟。我们不希望实际运行另一个进程，但我们希望确保从`make_files()`函数中正确调用`run()`函数。

我们还需要模拟`Path`类和生成的`Path`对象。它们提供文件名，并将调用`unlink()`方法。我们需要为此创建 mock，以便确保只有适当的文件才会被真正的应用程序解除链接。

使用模拟对象进行测试意味着我们在测试时不会意外删除有用的文件。这是使用 Python 实现这种自动化的一个显著好处。

下面是我们定义各种模拟对象的设置：

```py
    import unittest 
    from unittest.mock import * 

    class GIVEN_make_files_exception_WHEN_call_THEN_run(unittest.TestCase): 
        def setUp(self): 
            self.mock_subprocess_run = Mock( 
                side_effect = [ 
                    None, 
                    subprocess.CalledProcessError(2, 'ch13_r05')] 
            ) 
            self.mock_path_glob_instance = Mock() 
            self.mock_path_instance = Mock( 
                glob = Mock( 
                    return_value = [self.mock_path_glob_instance] 
                ) 
            ) 
            self.mock_path_class = Mock( 
                return_value = self.mock_path_instance 
            ) 

```

我们已经定义了`self.mock_subprocess_run`，它的行为有点像`run()`函数。我们已经使用了`side_effect`属性为这个函数提供了多个返回值。第一个响应将是`None`对象。然而，第二个响应将是`CalledProcessError`例外。此异常需要两个参数、一个进程返回代码和原始命令。

最后显示的`self.mock_path_class`响应对`Path`类请求的调用。这将返回类的模拟实例。`self.mock_path_instance`对象是`Path`的模拟实例。

创建的第一个路径实例将评估`glob()`方法。为此，我们使用了`return_value`属性返回要删除的`Path`实例列表。在这种情况下，返回值将是一个我们希望取消链接的单个`Path`对象。

`self.mock_path_glob_instance`对象是`glob()`的返回。如果算法运行正确，则应取消链接。

以下是本单元测试的`runTest()`方法：

```py
    def runTest(self): 
        with patch('__main__.subprocess.run', self.mock_subprocess_run), \ 
            patch('__main__.Path', self.mock_path_class): 
            self.assertRaises( 
                subprocess.CalledProcessError, make_files, files=3) 
        self.mock_subprocess_run.assert_has_calls( 
            [call( 
                ['python3', 'ch13_r05.py', '--samples', '10', 
                 '--output', 'game_0.yaml'], 
                check=True), 
             call( 
                ['python3', 'ch13_r05.py', '--samples', '10', 
                '--output', 'game_1.yaml'], 
                check=True), 
             ] 
         ) 
         self.assertEqual(2, self.mock_subprocess_run.call_count) 
         self.mock_path_class.assert_called_once_with('.') 
         self.mock_path_instance.glob.assert_called_once_with('game_*.yaml') 
         self.mock_path_glob_instance.unlink.assert_called_once_with() 

```

我们应用了两个修补程序：

*   在`__main__`模块中，对`subprocess`的引用将`run()`功能替换为`self.mock_subprocess_run`对象。这将允许我们跟踪调用`run()`的次数。它将允许我们确认使用正确的参数调用了`run()`。
*   在`__main__`模块中，对`Path`的引用将替换为`self.mock_path_class`对象。这将返回已知值，并允许我们确认仅进行了预期调用。

`self.assertRaises`方法用于确认在此特定修补上下文中调用`make_files()`方法时正确引发`CalledProcessError`异常。`run()`方法的模拟版本将引发一个异常，我们希望确切的异常是停止处理的异常。

模拟的`run()`函数只能调用两次。第一次呼叫将成功。第二个调用将引发异常。我们可以确认使用`Mock`对象的`call_count`属性对`run()`进行了两次调用。

`self.mock_path_instance`方法是作为异常处理的一部分创建的`Path('.')`对象的模拟。此对象必须评估`glob()`方法。测试断言检查参数值以确保使用了`'game_*.yaml'`。

最后，`self.mock_path_glob_instance`是对`Path('.').glob('game_*.yaml')`创建的`Path`对象的模拟。此对象将评估`unlink()`方法。这将导致删除该文件。

此单元测试提供了算法将按广告所示工作的信心。测试是在不占用大量计算资源的情况下完成的。最重要的是，测试是在不意外删除错误文件的情况下完成的。

## 另见

*   这种自动化通常与其他 Python 处理相结合。构图配方见*设计脚本。*
*   目标通常是创建一个复合应用程序；请参阅*管理复合应用程序中的参数和配置*配方。
*   有关此配方的变体，请参见*包装程序并检查输出*配方。

# 包装程序并检查输出

一种常见的自动化涉及到运行多个程序，这些程序实际上都不是 Python 应用程序。在这种情况下，不可能重写每个程序来创建复合 Python 应用程序。为了正确地聚合功能，必须将其他程序包装为 Python 类或模块，以提供更高级别的构造。

这个用例与编写 shell 脚本的用例非常相似。不同之处在于 Python 可以成为比操作系统内置 shell 语言更好的编程语言。

在某些情况下，Python 提供的优势是能够分析输出文件。Python 程序可以转换、过滤或汇总子流程的输出。

我们如何从 Python 内部运行其他应用程序并处理它们的输出？

## 准备好了吗

在*为合成*配方设计脚本的过程中，我们发现了一个进行了一些处理的应用程序，从而产生了一个相当复杂的结果。我们想运行这个程序几百次，但我们不想将必要的命令复制并粘贴到脚本中。此外，由于 shell 很难测试，并且数据结构很少，因此我们希望避免使用 shell。

对于这个配方，我们假定 Application T0.应用程序是用 FORTRAN 或 C++编写的本地二进制应用程序。这意味着我们不能简单地导入组成应用程序的 Python 模块。相反，我们必须通过运行单独的操作系统进程来处理这个应用程序。

我们将使用`subprocess`模块在操作系统级别运行应用程序。在 Python 中运行另一个二进制程序有两种常见的用例：

*   没有任何输出，或者我们不想在 Python 程序中收集它。
*   我们需要捕获并可能分析输出以检索信息或确定成功程度。我们可能需要转换、过滤或汇总日志输出。

在本配方中，我们将研究第二种情况，即必须捕获并汇总输出。在*包装和组合 CLI 应用程序*配方中，我们将查看第一种情况，其中输出被忽略。

下面是一个运行`ch13_r05`应用程序的示例：

```py
slott$ python3 ch13_r05.py --samples 10 --output=x.yaml 

Namespace(output='x.yaml', output_path=PosixPath('x.yaml'), samples=10, seed=None) 

Counter({5: 7, 6: 7, 7: 7, 8: 5, 4: 4, 9: 4, 11: 3, 10: 1, 12: 1})

```

有两行输出写入 OS 标准输出文件。第一部分是选项摘要。输出的第二行是带有文件摘要的`Counter`对象。我们想要捕捉这些`'Counter'`行的细节。

## 怎么做。。。

1.  导入`subprocess`模块：

    ```py
            import subprocess 

    ```

2.  设计命令行。通常，这应该在操作系统提示符下进行测试，以确保它做了正确的事情。我们已经展示了该命令的一个示例。
3.  Define a generator for the various commands to be executed. Each command can be built as a sequence of individual words. The original shell command is split on spaces to create the sequence of words:

    ```py
            def command_iter(files): 
                for n in range(files): 
                    filename = 'game_{n}.yaml'.format_map(vars()) 
                    command = ['python3', 'ch13_r05.py', 
                        '--samples', '10', '--output', filename] 
                    yield command 

    ```

    此生成器将生成一系列命令字符串。客户机可以使用`for`语句来使用每个生成的命令。

4.  Define a function which executes the various commands, collecting the output from each:

    ```py
            def command_output_iter(iterable): 
                for command in iterable: 
                    process = subprocess.run(command, stdout=subprocess.PIPE, check=True) 
                    output_bytes = process.stdout 
                    output_lines = list(l.strip() for l in output_bytes.splitlines()) 
                    yield output_lines 

    ```

    使用参数值`stdout=subprocess.PIPE`意味着父进程将从子进程收集输出。创建操作系统级管道，以便父级可以读取子输出。

    此生成器将生成一系列行列表。每个行列表将是`ch13_r05.py`应用程序的输出行。通常，每个列表中有两行。第一行是参数摘要，第二行是`Counter`对象。

5.  Define an overall process to combine the two generators so that each command that is generated is then executed:

    ```py
            command_sequence = command_iter(100) 
            output_lines_sequence = command_output_iter(command_sequence) 
            for batch in output_lines_sequence: 
                for line in batch: 
                    if line.startswith('Counter'): 
                        batch_counter = eval(line) 
                        print(batch_counter) 

    ```

    `command_sequence`变量是一个生成器，它将生成多个命令。此序列由`command_iter()`函数建立。

    `output_lines_sequence`是一个生成器，它将生成多个输出线列表。这是由`command_output_iter()`函数构建的，该函数将使用给定的`command_sequence object`，运行多个命令，收集输出。

    `output_lines_sequence`中的每一批将是理想情况下两行的列表。以`Counter`开头的线表示`Counter`对象。

    我们已经使用了`eval()`函数从这个文本表示中重新创建了原始`Counter`对象。我们可以使用这些`Counter`对象进行分析或总结。

大多数实际应用程序必须使用比内置的`eval()`更复杂的函数来解释输出。有关处理复杂行格式的信息，请参见[第 1 章](01.html#page "Chapter 1. Numbers, Strings, and Tuples")中的*正则表达式字符串解析*、*数字、字符串和元组*，以及[第 9 章](09.html#page "Chapter 9. Input/Output, Physical Format, and Logical Layout")、*中的*使用正则表达式读取复杂格式的*配方输入/输出、物理格式和逻辑布局*。

## 它是如何工作的。。。

`subprocess`模块是 Python 程序如何运行给定计算机上可用的其他程序。`run()`函数为我们做了很多事情。

在 POSIX（如 Linux 或 Mac OS X）上下文中，步骤与以下类似：

*   为子流程准备`stdin`、`stdout`和`stderr`文件描述符。在本例中，我们已安排父对象从子对象收集输出。子级将生成`stdout`文件到父级使用的共享缓冲区（Linux 术语中的管道）。另一方面，`stderr`输出是单独的，子级继承父级具有的相同连接，错误消息将显示在父级使用的同一控制台上。
*   调用`os.fork()`和`os.execl()`函数，将当前进程拆分为父进程和子进程，然后启动子进程。
*   然后，使用给定的`stdin`、`stdout`和`stderr`运行子进程。
*   同时，父进程在等待子进程完成时正在读取子进程的管道。
*   由于我们使用了`check=True`选项，非零状态被转换为异常。

## 还有更多。。。

我们将在此脚本中添加一个简单的摘要功能。每批样品产生两行输出。输出文本被表达式`list(l.strip() for l in output_bytes.splitlines())`拆分为两行序列。这会将文本拆分为多行，并从每行中删除前导和尾随空格，从而使文本更易于处理。

整个脚本过滤这些行，查找以`'Counter'`开头的行。每一行都是`Counter`对象的文本表示。在线路上使用`eval()`功能将重建原始`Counter`的副本。许多 Python 类定义都是这样工作的，`repr()`和`eval()`函数彼此相反。`repr()`函数将对象转换为文本，`eval()`函数可以将文本转换回对象。并非所有类都是这样，但对许多类来说都是这样。

我们可以创建各种`Counter`对象的摘要。为了做到这一点，有一个生成器来处理批次并生成最终摘要是很有帮助的。

函数应如下所示：

```py
    def process_batches(): 
        command_sequence = command_iter(2) 
        output_lines_sequence = command_output_iter(command_sequence) 
        for batch in output_lines_sequence: 
            for line in batch: 
                if line.startswith('Counter'): 
                    batch_counter = eval(line) 
                    yield batch_counter 

```

这将使用`command_iter()`功能创建处理命令。`command_output_iter()`将处理每个单独的命令，收集整套输出线。

嵌套的`for`语句将检查每个批次的行列表。在每个列表中，它将检查每一行。以`Counter`开头的行将使用`eval()`函数进行评估。产生的`Counter`对象序列就是这个生成器的输出。

我们可以用这样一个过程来总结`Counter`实例的顺序：

```py
    total_counter = Counter() 
    for batch_counter in process_batches(): 
        print(batch_counter) 
        total_counter.update(batch_counter) 
    print("Total") 
    print(total_counter) 

```

我们将创建`Counter`来保存总计`total_counter`。`process_batches()`将从处理的每个文件中生成单个`Counter`实例。这些批处理级对象用于更新`total_counter`。然后，我们可以打印总计，以显示所创建的所有文件中数据的聚合分布。

## 另见

*   有关此方法的另一种方法，请参见*包装和组合 CLI 应用程序*方法。
*   这种自动化通常与其他 Python 处理相结合。构图配方见*设计脚本。*
*   目标通常是创建一个复合应用程序；请参阅*管理复合应用程序中的参数和配置*配方。

# 控制复杂的步骤顺序

在*将两个应用程序合并为一个*配方中，我们研究了如何将多个 Python 脚本合并为一个更长更复杂的操作。在*包装和组合 CLI 应用程序*和*包装程序并检查输出*配方的过程中，我们研究了使用 Python 包装非 Python 程序的方法。

我们如何有效地结合这些技术？我们可以使用 Python 创建更长、更复杂的操作序列吗？

## 准备好了吗

在*为*配方设计脚本的过程中，我们创建了一个应用程序，该应用程序进行了一些处理，从而产生了一个相当复杂的结果。在*使用日志记录控制和审计输出*配方中，我们研究了第二个应用程序，该应用程序基于这些结果创建复杂的统计摘要。

整个过程如下所示：

1.  运行`ch13_r05`程序 100 次，创建 100 个中间文件。
2.  运行`ch13_r06`程序汇总这些中间文件。

我们保持了这一点的简单性，因此很容易关注所涉及的 Python 编程。

出于本配方的目的，我们假设这两个应用程序都不是用 Python 编写的。我们将假装它们是用 Fortran、Ada 或其他与 Python 不直接兼容的语言编写的。

在*将两个应用程序合并为一个*配方中，我们了解了如何组合 Python 应用程序。当应用程序用 Python 编写时，这是首选方法。当应用程序不是用 Python 编写时，需要做一些额外的工作。

此配方使用命令设计模式；这支持命令序列的扩展和修改。

## 怎么做。。。

1.  We'll define an abstract `Command` class. The other commands will be defined as subclasses. We'll push the subprocess processing into this class definition to simplify the subclasses:

    ```py
            import subprocess 
            class Command: 
                def execute(self, options): 
                    self.command = self.create_command(options) 
                    results = subprocess.run(self.command, 
                        check=True, stdout=subprocess.PIPE) 
                    self.output = results.stdout 
                    return self.output 
                def create_command(self, options): 
                    return ['echo', self.__class__.__name__, repr(self.options)] 

    ```

    `execute()`方法首先创建要执行的 OS 级命令。每个子类将为包装的命令提供不同的规则。命令生成后，`subprocess`模块的`run()`功能将处理该命令。

    `create_command()`方法构建由操作系统执行的命令组成的单词序列。这些选项通常用于自定义创建的命令参数。此方法的超类实现提供了一些调试信息。每个子类都必须重写此方法以生成有用的输出。

2.  We can use the `Command` superclass to define a command to simulate the game and create samples:

    ```py
            import ch13_r05 

            class Simulate(Command): 
                def __init__(self, seed=None): 
                    self.seed = seed 
                def execute(self, options): 
                    if self.seed: 
                        os.environ['RANDOMSEED'] = str(self.seed) 
                    super().execute(options) 
                def create_command(self, options): 
                    return ['python3', 'ch13_r05.py`, 
                        '--samples', str(options.samples), 
                        '-o', options.game_file] 

    ```

    在本例中，我们为`execute()`方法提供了一个重写，以便此类可以更改环境变量。这允许集成测试设置特定的随机种子，并确认结果匹配一组固定的预期值。

    `create_command()`方法发出用于`ch13_r05`命令的命令行执行的字。这会将`options.samples`的数值转换为字符串。

3.  We can also use the `Command` superclass to define a command to summarize the various simulation processes:

    ```py
            import ch13_r06 

            class Summarize(Command): 
                def create_command(self, options): 
                    return ['python3', 'ch13_r06.py', 
                        '-o', options.summary_file, 
                        ] + options.game_files 

    ```

    在这种情况下，我们只执行了`create_command()`。此实现为`ch13_r06`命令提供参数。

4.  Given these two commands, the overall main program can follow the design pattern from the *Designing scripts for composition* recipe. We need to gather the options, and then use these options to execute the two commands:

    ```py
            from argparse import Namespace 

            def demo(): 
                options = Namespace(samples=100, 
                    game_file='x12.yaml', game_files=['x12.yaml'], 
                    summary_file='y12.yaml') 
                step1 = Simulate() 
                step2 = Summarize() 
                step1.execute(options) 
                step2.execute(options) 

    ```

    此演示函数`demo()`使用可能来自命令行的参数创建一个`Namespace`实例。它构建了两个处理步骤。最后，它执行每个步骤。

    这种函数为执行一系列应用程序提供了一个高级脚本。它比 shell 灵活得多，因为我们可以利用 Python 丰富的数据结构集合。因为我们使用的是 Python，所以还可以包含单元测试。

## 它是如何工作的。。。

本配方中有两种互锁设计模式：

*   `Command`类层次结构
*   使用`subprocess.run()`函数包装外部命令

`Command`类层次结构背后的思想是将每个单独的步骤或操作变成一个公共抽象超类的子类。在本例中，我们称之为超类`Command`。这两个操作是`Command`类的子类。这保证了我们可以为所有类提供公共特性。

包装外部命令有几个注意事项。一个主要问题是如何构建所需的命令行选项。在这种情况下，`run()`函数将使用单个单词的列表，从而很容易将文字字符串、文件名和数值组合到程序的一组有效选项中。另一个主要问题是如何处理操作系统定义的标准输入、标准输出和标准错误文件。在某些情况下，这些文件可以显示在控制台上。在其他情况下，应用程序可能会捕获这些文件以供进一步分析和处理。

这里的基本思想是将两个考虑因素分开：

1.  要执行的命令的概述。这包括有关序列、迭代、条件处理和序列的潜在更改的问题。这些是与用户情景相关的更高层次的考虑事项。
2.  如何执行每个命令的详细信息。这包括命令行选项、使用的输出文件和其他操作系统级注意事项。这些是实施细节的更多技术考虑。

将两者分开可以更容易地实现或修改用户情景。对操作系统级注意事项的更改不应改变用户情景；该过程可能更快或使用更少的内存，但在其他方面是相同的。类似地，对用户情景的更改不应破坏操作系统级别的考虑。

## 还有更多。。。

复杂的步骤序列可能涉及一个或多个步骤的迭代。因为高级脚本是用 Python 编写的，所以添加迭代是用`for`语句完成的：

```py
    def process_i(options): 
        step1 = Simulate() 
        options.game_files = [] 
        for i in range(options.simulations): 
            options.game_file = 'game_{i}.yaml'.format_map(vars()) 
            options.game_files.append(options.game_file) 
            step1.execute(options) 
        step2 = Summarize() 
        step2.execute(options) 

```

此`process_i()`功能将多次处理`Simulate`步骤。它使用`simulations`选项指定要运行的模拟数量。每次模拟将产生预期数量的样本。

此函数将为每次处理迭代的`game_file`选项设置一个不同的值。每个生成的文件名都是唯一的，从而生成许多示例文件。文件列表也被收集到`game_files`选项中。

当执行下一步`Summarize`类时，它将拥有要处理的适当文件列表。分配给`options`变量的`Namespace`对象可用于跟踪全局状态变化，并将此信息提供给后续处理步骤。

### 构建条件处理

由于高级编程是用 Python 编写的，因此很容易添加不基于包装的两个应用程序的附加处理。一个特性可能是可选的摘要步骤。

例如，如果选项没有`summary_file`选项，则可以跳过处理。这可能导致`process()`函数的版本如下所示：

```py
    def process_c(options): 
        step1 = Simulate() 
        step1.execute(options) 
        if 'summary_file' in options: 
            step2 = Summarize() 
            step2.execute(options) 

```

此`procees_c()`功能将有条件地处理`Summarize`步骤。如果有`summary_file`选项，则执行第二步。否则，它将跳过摘要步骤。

在本例中，以及前面的示例中，我们使用了 Python 编程特性来增强这两个应用程序。

## 另见

*   通常，这些类型的处理步骤是针对更大或更复杂的应用程序进行的。请参阅*将两个应用程序合并为一个*和*管理复合应用程序中的参数和配置，了解更多适用于更大、更复杂复合应用程序的*方法。