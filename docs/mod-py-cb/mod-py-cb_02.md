# 第二章：语句和语法

在本章中，我们将查看以下配方：

+   编写 Python 脚本和模块文件

+   编写长行代码

+   包括描述和文档

+   在文档字符串中更好的 RST 标记

+   设计复杂的 if...elif 链

+   设计一个终止的 while 语句

+   避免 break 语句可能出现的问题

+   利用异常匹配规则

+   避免 except:子句可能出现的问题

+   使用 raise from 语句链接异常

+   使用 with 语句管理上下文

# 介绍

Python 语法设计得非常简单。有一些规则；我们将查看语言中一些有趣的语句，以了解这些规则。仅仅看规则而没有具体的例子可能会令人困惑。

我们将首先介绍创建脚本文件的基础知识。然后我们将继续查看一些常用语句。Python 语言中只有大约二十种不同类型的命令语句。我们已经在第一章中看过两种语句，*Numbers, Strings, and Tuples*：赋值语句和表达式语句。

当我们写这样的东西时：

```py
 **>>> print("hello world")** 

 **hello world** 

```

我们实际上执行的是一个只包含函数`print()`评估的语句。这种语句-在其中我们评估一个函数或对象的方法-是常见的。

我们已经看到的另一种语句是赋值语句。Python 在这个主题上有很多变化。大多数时候，我们将一个值赋给一个变量。然而，有时我们可能会同时给两个变量赋值，就像这样：

```py
 **quotient, remainder = divmod(355, 113)** 

```

这些配方将查看一些更复杂的语句，包括`if`，`while`，`for`，`try`，`with`和`raise`。在探索不同的配方时，我们还将涉及其他一些。

![](img/614271.jpg)

# 编写 Python 脚本和模块文件-语法基础

为了做任何真正有用的事情，我们需要编写 Python 脚本文件。我们可以在交互`>>>`提示符下尝试语言。然而，对于真正的工作，我们需要创建文件。编写软件的整个目的是为我们的数据创建可重复的处理。

我们如何避免语法错误，并确保我们的代码与常用的代码匹配？我们需要查看一些*style*的常见方面-我们如何使用空白来澄清我们的编程。

我们还将研究一些更多的技术考虑因素。例如，我们需要确保以 UTF-8 编码保存我们的文件。虽然 Python 仍然支持 ASCII 编码，但对于现代编程来说，这是一个不好的选择。我们还需要确保使用空格而不是制表符。如果我们尽可能使用 Unix 换行符，我们也会发现事情稍微简单一些。

大多数文本编辑工具都可以正确处理 Unix（换行符）和 Windows 或 DOS（回车换行符）的行尾。任何不能处理这两种行尾的工具都应该避免使用。

## 准备好了

要编辑 Python 脚本，我们需要一个好的编程文本编辑器。Python 自带一个方便的编辑器，IDLE。它工作得相当不错。它让我们可以在文件和交互`>>>`提示之间来回跳转，但它不是一个很好的编程编辑器。

有数十种优秀的编程编辑器。几乎不可能只建议一个。所以我们将建议几个。

ActiveState 有非常复杂的 Komodo IDE。Komodo Edit 版本是免费的，并且与完整的 Komodo IDE 做了一些相同的事情。它可以在所有常见的操作系统上运行；这是一个很好的第一选择，因为无论我们在哪里编写代码，它都是一致的。

请参阅[`komodoide.com/komodo-edit/`](http://komodoide.com/komodo-edit/)。

Notepad++适用于 Windows 开发人员。请参阅[`notepad-plus-plus.org`](https://notepad-plus-plus.org)。

BBEdit 非常适合 Mac OS X 开发人员。请参阅[`www.barebones.com/products/bbedit/`](http://www.barebones.com/products/bbedit/)。

对于 Linux 开发人员，有几个内置的编辑器，包括 VIM、gedit 或 Kate。这些都很好。由于 Linux 倾向于偏向开发人员，可用的编辑器都适合编写 Python。

重要的是，我们在工作时通常会打开两个窗口：

+   我们正在处理的脚本或文件。

+   Python 的`>>>`提示（可能来自 shell，也可能来自 IDLE），我们可以尝试一些东西，看看什么有效，什么无效。我们可能会在 Notepad++中创建脚本，但使用 IDLE 来尝试数据结构和算法。

实际上我们这里有两个配方。首先，我们需要为我们的编辑器设置一些默认值。然后，一旦编辑器正确设置，我们就可以为我们的脚本文件创建一个通用模板。

## 如何做...

首先，我们将看一下我们首选编辑器中需要做的一般设置。我们将使用 Komodo 示例，但基本原则适用于所有编辑器。一旦我们设置了编辑首选项，我们就可以创建我们的脚本文件。

1.  打开首选编辑器。查看首选项页面。

1.  查找首选文件编码的设置。使用 Komodo Edit 首选项，它在**国际化**选项卡上。将其设置为**UTF-8**。

1.  查找缩进设置。如果有一种方法可以使用空格而不是制表符，请检查此选项。使用 Komodo Edit，我们实际上是反过来做的——我们取消**优先使用空格而不是制表符**。

### 注意

规则是：我们想要*空格*；我们不想要*制表符*。

还要将每个缩进的空格设置为四个。这对于 Python 代码来说很典型。它允许我们有几个缩进级别，但仍然保持代码相当窄。

一旦我们确定我们的文件将以 UTF-8 编码保存，并且我们也确定我们使用空格而不是制表符，我们可以创建一个示例脚本文件：

1.  大多数 Python 脚本文件的第一行应该是这样的：

```py
            #!/usr/bin/env python3 

```

这将在你正在编写的文件和 Python 之间建立关联。

对于 Windows，文件名到程序的关联是通过 Windows 控制面板中的一个设置来完成的。在**默认程序**控制面板中，有一个**设置关联**面板。此控制面板显示`.py`文件绑定到 Python 程序。这通常由安装程序设置，我们很少需要更改它或手动设置它。

### 注意

Windows 开发人员可以无论如何包含序言行。这将使 Mac OS X 和 Linux 的人们从 GitHub 下载项目时感到高兴。

1.  在序言之后，应该有一个三引号的文本块。这是我们要创建的文件的文档字符串（称为**docstring**）。这在技术上不是强制性的，但对于解释文件包含的内容至关重要。

```py
        ''' 
        A summary of this script. 
        ''' 

```

因为 Python 的三引号字符串可以无限长，所以可以随意写入必要的内容。这应该是描述脚本或库模块的主要方式。这甚至可以包括它是如何工作的示例。

1.  现在来到脚本的有趣部分：真正执行操作的部分。我们可以编写所有需要完成工作的语句。现在，我们将使用这个作为占位符：

```py
        print('hello world') 

```

有了这个，我们的脚本就有了作用。在其他示例中，我们将看到许多其他用于执行操作的语句。通常会创建函数和类定义，并编写语句来使用函数和类执行操作。

在我们的脚本的顶层，所有语句必须从左边缘开始，并且必须在一行上完成。有一些复杂的语句，其中将嵌套在其中的语句块。这些内部语句块必须缩进。通常情况下，因为我们将缩进设置为四个空格，我们可以按*Tab*键进行缩进。

我们的文件应该是这样的：

```py
    #!/usr/bin/env python3 
    ''' 
    My First Script: Calculate an important value. 
    ''' 

    print(355/113) 

```

## 它是如何工作的...

与其他语言不同，Python 中几乎没有*样板*。只有一行*开销*，甚至`#!/usr/bin/env python3`行通常是可选的。

为什么要将编码设置为 UTF-8？整个语言都是设计为仅使用最初的 128 个 ASCII 字符。

我们经常发现 ASCII 有限制。将编辑器设置为使用 UTF-8 编码更容易。有了这个设置，我们可以简单地使用任何有意义的字符。如果我们将程序保存在 UTF-8 编码中，我们可以将字符如`µ`用作 Python 变量。

如果我们将文件保存为 UTF-8，这是合法的 Python：

```py
    π=355/113 
    print(π) 

```

### 注意

在 Python 中在选择空格和制表符之间保持一致是很重要的。它们都是几乎看不见的，混合它们很容易导致混乱。建议使用空格。

当我们设置编辑器使用四个空格缩进后，我们可以使用键盘上标有 Tab 的按钮插入四个空格。我们的代码将对齐，缩进将显示语句如何嵌套在彼此内。

初始的`#!`行是一个注释：从`#`到行尾的所有内容都会被忽略。像**bash**和**ksh**这样的操作系统 shell 程序会查看文件的第一行，以确定文件包含的内容。文件的前几个字节有时被称为*魔术*，因为 shell 程序正在窥视它们。Shell 程序会寻找`#!`这个两个字符的序列，以确定负责这些数据的程序。我们更喜欢使用`/usr/bin/env`来启动 Python 程序。我们可以利用这一点来通过`env`程序进行 Python 特定的环境设置。

## 还有更多...

*Python 标准库*文档部分源自模块文件中存在的文档字符串。在模块中编写复杂的文档字符串是常见做法。有一些工具，如 Pydoc 和 Sphinx，可以将模块文档字符串重新格式化为优雅的文档。我们将在单独的部分中学习这一点。

此外，单元测试用例可以包含在文档字符串中。像**doctest**这样的工具可以从文档字符串中提取示例并执行代码，以查看文档中的答案是否与运行代码找到的答案匹配。本书的大部分内容都是通过 doctest 验证的。

三引号文档字符串优于`#`注释。`#`和行尾之间的文本会被忽略，并被视为注释。由于这仅限于单行，因此使用得很少。文档字符串的大小可以是无限的；它们被广泛使用。

在 Python 3.5 中，我们有时会在脚本文件中看到这样的东西：

```py
    color = 355/113 # type: float 

```

`# type: float`注释可以被类型推断系统用来确定程序实际执行时可能出现的各种数据类型。有关更多信息，请参阅**Python Enhancement Proposal 484**：[`www.python.org/dev/peps/pep-0484/`](https://www.python.org/dev/peps/pep-0484/)。

有时文件中还包含另一个开销。VIM 编辑器允许我们在文件中保留编辑首选项。这被称为**modeline**。我们经常需要通过在我们的`~/.vimrc`文件中包含`set modeline`设置来启用 modelines。

一旦我们启用了 modelines，我们可以在文件末尾包含一个特殊的`# vim`注释来配置 VIM。

这是一个对 Python 有用的典型 modeline：

```py
    # vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4 

```

这将把 Unicode `u+0009` TAB 字符转换为八个空格，当我们按下*Tab*键时，我们将移动四个空格。这个设置被保存在文件中；我们不需要进行任何 VIM 设置来将这些设置应用到我们的 Python 脚本文件中。

## 另请参阅

+   我们将在*包括描述和文档*和*在文档字符串中编写更好的 RST 标记*这两个部分中学习如何编写有用的文档字符串

+   有关建议的样式的更多信息，请参阅[`www.python.org/dev/peps/pep-0008/`](https://www.python.org/dev/peps/pep-0008/)

# 编写长行代码

有很多时候，我们需要编写非常长的代码行，以至于它们非常难以阅读。许多人喜欢将代码行的长度限制在 80 个字符或更少。这是一个众所周知的图形设计原则，即较窄的行更容易阅读；意见不一，但 65 个字符经常被认为是理想的长度。参见[`webtypography.net/2.1.2`](http://webtypography.net/2.1.2)。

虽然较短的行更容易阅读，但我们的代码可能不遵循这个原则。长语句是一个常见的问题。我们如何将长的 Python 语句分解为更易处理的部分？

## 准备就绪

通常，我们会有一个语句，它非常长且难以处理。比如说我们有这样的东西：

```py
 **>>> import math** 

 **>>> example_value = (63/25) * (17+15*math.sqrt(5)) / (7+15*math.sqrt(5))** 

 **>>> mantissa_fraction, exponent = math.frexp(example_value)** 

 **>>> mantissa_whole = int(mantissa_fraction*2**53)** 

 **>>> message_text = 'the internal representation is {mantissa:d}/2**53*2**{exponent:d}'.format(mantissa=mantissa_whole, exponent=exponent)** 

 **>>> print(message_text)** 

 **the internal representation is 7074237752514592/2**53*2**2** 

```

这段代码包括一个长公式和一个长格式字符串，我们要将值注入其中。这在书中排版时看起来很糟糕。在尝试编辑此脚本时，屏幕上看起来很糟糕。

我们不能简单地将 Python 语句分成块。语法规则明确指出语句必须在单个*逻辑*行上完成。

术语逻辑行是如何进行的一个提示。Python 区分逻辑行和物理行；我们将利用这些语法规则来分解长语句。

## 如何做...

Python 给了我们几种包装长语句使其更易读的方法。

+   我们可以在行尾使用`\`继续到下一行。

+   我们可以利用 Python 的规则，即语句可以跨越多个逻辑行，因为`()`、`[]`和`{}`字符必须平衡。除了使用`()`和`\`，我们还可以利用 Python 自动连接相邻字符串文字的方式，使其成为一个更长的文字；`("a" "b")`与`ab`相同。

+   在某些情况下，我们可以通过将中间结果分配给单独的变量来分解语句。

我们将在本教程的不同部分分别讨论每一个。

### 使用反斜杠将长语句分解为逻辑行

这个技巧的背景是：

```py
 **>>> import math** 

 **>>> example_value = (63/25) * (17+15*math.sqrt(5)) / (7+15*math.sqrt(5))** 

 **>>> mantissa_fraction, exponent = math.frexp(example_value)** 

 **>>> mantissa_whole = int(mantissa_fraction*2**53)** 

```

Python 允许我们使用`\`并换行。

1.  将整个语句写在一行上，即使它很混乱：

```py
 **>>> message_text = 'the internal representation is {mantissa:d}/2**53*2**{exponent:d}'.format(mantissa=mantissa_whole, exponent=exponent)** 

```

1.  如果有*逻辑*断点，在那里插入`\`。有时，没有真正好的断点：

```py
 **>>> message_text = 'the internal representation is \** 

 **... {mantissa:d}/2**53*2**{exponent:d}'.\** 

 **... format(mantissa=mantissa_whole, exponent=exponent)** 

 **>>> message_text** 

 **'the internal representation is 7074237752514592/2**53*2**2'** 

```

为了使其工作，`\`必须是行上的最后一个字符。我们甚至不能在`\`后有一个空格。这很难看出来；因此，我们不鼓励这样做。

尽管这有点难以理解，但`\`总是可以使用的。把它看作是使代码行更易读的最后手段。

### 使用()字符将长语句分解为合理的部分

1.  将整个语句写在一行上，即使它很混乱：

```py
 **>>> import math** 

 **>>> example_value1 = (63/25) * (17+15*math.sqrt(5)) / (7+15*math.sqrt(5))** 

```

1.  添加额外的`()`字符不改变值，但允许将表达式分解为多行：

```py
 **>>> example_value2 = (63/25) * ( (17+15*math.sqrt(5)) / (7+15*math.sqrt(5)) )** 

 **>>> example_value2 == example_value1** 

 **True** 

```

1.  在`()`字符内部断开行：

```py
 **>>> example_value3 = (63/25) * (** 

 **...      (17+15*math.sqrt(5))** 

 **...    / ( 7+15*math.sqrt(5))** 

 **... )** 

 **>>> example_value3 == example_value1** 

 **True** 

```

匹配`()`字符的技术非常强大，适用于各种情况。这是被广泛使用和强烈推荐的。

我们几乎总是可以找到一种方法向语句添加额外的`()`字符。在我们无法添加`()`字符或添加`()`字符无法改善情况的罕见情况下，我们可以退而使用`\`将语句分解为几个部分。

### 使用字符串文字连接

我们可以将`()`字符与另一条规则相结合，该规则结合字符串文字。这对于长而复杂的格式字符串特别有效：

1.  用`()`字符包装一个长字符串值。

1.  将字符串分解为子字符串：

```py
 **>>> message_text = (** 

 **... 'the internal representation '** 

 **... 'is {mantissa:d}/2**53*2**{exponent:d}'** 

 **... ).format(** 

 **... mantissa=mantissa_whole, exponent=exponent)** 

 **>>> message_text** 

 **'the internal representation is 7074237752514592/2**53*2**2'** 

```

我们总是可以将长字符串分解为相邻的片段。通常，当片段被`()`字符包围时，这是最有效的。然后我们可以使用尽可能多的物理行断开。这仅限于那些我们有特别长的字符串值的情况。

### 将中间结果分配给单独的变量

这个技巧的背景是：

```py
 **>>> import math** 

 **>>> example_value = (63/25) * (17+15*math.sqrt(5)) / (7+15*math.sqrt(5))** 

```

我们可以将这分解为三个中间值。

1.  识别整体表达式中的子表达式。将这些分配给变量：

```py
 **>>> a = (63/25)** 

 **>>> b = (17+15*math.sqrt(5))** 

 **>>> c = (7+15*math.sqrt(5))** 

```

这通常相当简单。可能需要一点小心来进行代数运算，以找到合理的子表达式。

1.  用创建的变量替换子表达式：

```py
 **>>> example_value = a * b / c** 

```

这是对原始复杂子表达式的一个必要的文本替换，用一个变量来代替。

我们没有给这些变量起描述性的名称。在某些情况下，子表达式具有一些语义，我们可以用有意义的名称来捕捉。在这种情况下，我们没有理解表达式足够深刻，无法提供深层有意义的名称。相反，我们选择了简短的、任意的标识符。

## 它是如何工作的...

Python 语言手册对逻辑行和物理行进行了区分。逻辑行包含一个完整的语句。它可以通过称为**行连接**的技术跨越多个物理行。手册称这些技术为**显式行连接**和**隐式行连接**。

显式行连接的使用有时是有帮助的。因为很容易忽视，所以通常不受鼓励。这是最后的手段。

隐式行连接的使用可以在许多情况下使用。它通常在语义上与表达式的结构相吻合，因此是受鼓励的。我们可能需要`()`字符作为必需的语法。例如，我们已经将`()`字符作为`print()`函数的语法的一部分。我们可能这样做来分解一个长语句：

```py
 **>>> print(** 

 **...    'several values including',** 

 **...    'mantissa =', mantissa,** 

 **...    'exponent =', exponent** 

 **... )** 

```

## 还有更多...

表达式广泛用于许多 Python 语句。任何表达式都可以添加`()`字符。这给了我们很大的灵活性。

然而，有一些地方可能有一个不涉及特定表达式的长语句。其中最显著的例子是`import`语句 - 它可能变得很长，但不使用可以加括号的任何表达式。

然而，语言设计者允许我们使用`()`字符，以便将一长串名称分解为多个逻辑行：

```py
 **>>> from math import (sin, cos, tan,** 

 **...    sqrt, log, frexp)** 

```

在这种情况下，`()`字符绝对不是表达式的一部分。`()`字符只是额外的语法，包括使语句与其他语句一致。

## 另请参阅

+   隐式行连接也适用于匹配的`[]`字符和`{}`字符。这些适用于我们将在第四章中查看的集合数据结构，*内置数据结构 - 列表、集合、字典*。

# 包括描述和文档

当我们有一个有用的脚本时，我们经常需要为自己和其他人留下关于它的说明，它是如何解决某个特定问题的，以及何时应该使用它的笔记。

因为清晰很重要，有一些格式化的方法可以帮助使文档非常清晰。这个方法还包含了一个建议的大纲，以便文档会相当完整。

## 准备工作

如果我们使用*编写 Python 脚本和模块文件 - 语法基础*的方法来构建一个脚本文件，我们将在我们的脚本文件中放置一个小的文档字符串。我们将扩展这个文档字符串。

还有其他应该使用文档字符串的地方。我们将在第三章和第六章中查看这些额外的位置，*函数定义*和*类和对象的基础知识*。

我们有两种一般类型的模块，我们将编写摘要文档字符串：

+   **库模块**：这些文件将主要包含函数定义以及类定义。在这种情况下，文档字符串摘要可以侧重于模块是什么，而不是它做什么。文档字符串可以提供使用模块中定义的函数和类的示例。在第三章，*函数定义*，和第六章，*类和对象的基础*，我们将更仔细地研究这个函数包或类包的概念。

+   **脚本**：这些通常是我们期望能够完成一些实际工作的文件。在这种情况下，我们希望关注的是做而不是存在。文档字符串应该描述它的功能以及如何使用它。选项、环境变量和配置文件是这个文档字符串的重要部分。

我们有时会创建包含两者的文件。这需要一些仔细的编辑来在做和存在之间取得适当的平衡。在大多数情况下，我们将简单地提供两种文档。

## 如何做...

编写文档的第一步对于库模块和脚本是相同的：

1.  写一个简要概述脚本或模块是什么或做什么。摘要不要深入介绍它的工作原理。就像报纸文章中的导语一样，它介绍了模块的谁、什么、何时、何地、如何和为什么。详细信息将在文档字符串的正文中提供。

工具如 sphinx 和 pydoc 显示信息的方式暗示了特定的样式提示。在这些工具的输出中，上下文是非常清晰的，因此在摘要句中通常可以省略主语。句子通常以动词开头。

例如，像这样的摘要：*这个脚本下载并解码了当前的特殊海洋警告（SMW）*有一个多余的*这个脚本*。我们可以去掉它，然后以动词短语*下载并解码...*开始。

我们可能会这样开始我们的模块文档字符串：

```py
    ''' 
    Downloads and decodes the current Special Marine Warning (SMW) 
    for the area 'AKQ'. 
    ''' 

```

我们将根据模块的一般重点分开其他步骤。

### 为脚本编写文档字符串

当我们记录脚本时，我们需要关注将使用脚本的人的需求。

1.  像之前展示的那样开始，创建一个摘要句。

1.  勾勒出文档字符串的其余部分的大纲。我们将使用**ReStructuredText**（**RST**）标记。在一行上写出主题，然后在主题下面放一行`=`，使它们成为一个适当的章节标题。记得在每个主题之间留下一个空行。

主题可能包括：

+   **概要**：如何运行这个脚本的摘要。如果脚本使用`argparse`模块来处理命令行参数，那么`argparse`生成的帮助文本就是理想的摘要文本。

+   **描述**：这个脚本的更完整的解释。

+   **选项**：如果使用了`argparse`，这是放置每个参数详细信息的地方。通常我们会重复`argparse`的帮助参数。

+   **环境**：如果使用了`os.environ`，这是描述环境变量及其含义的地方。

+   **文件**：由脚本创建或读取的文件名称是非常重要的信息。

+   **示例**：始终有一些使用脚本的示例会很有帮助。

+   **另请参阅**：任何相关的脚本或背景信息。

其他可能有趣的主题包括**退出状态**，**作者**，**错误**，**报告错误**，**历史**或**版权**。在某些情况下，例如关于报告错误的建议，实际上并不属于模块的文档字符串，而是属于项目的 GitHub 或 SourceForge 页面的其他位置。

1.  在每个主题下填写细节。准确性很重要。由于我们将这些文档嵌入到与代码相同的文件中，因此很容易在模块的其他地方检查内容是否正确和完整。

1.  对于代码示例，我们可以使用一些很酷的 RST 标记。回想一下，所有元素都是由空行分隔的。在一个段落中，只使用`::`。在下一个段落中，将代码示例缩进四个空格。

这是一个脚本的 docstring 示例：

```py
    ''' 
    Downloads and decodes the current Special Marine Warning (SMW) 
    for the area 'AKQ' 

    SYNOPSIS 
    ======== 

    :: 

        python3 akq_weather.py 

    DESCRIPTION 
    =========== 

    Downloads the Special Marine Warnings 

    Files 
    ===== 

    Writes a file, ``AKW.html``. 

    EXAMPLES 
    ======== 

    Here's an example:: 

        slott$ python3 akq_weather.py 
        <h3>There are no products active at this time.</h3> 
    ''' 

```

在概要部分，我们使用`::`作为单独的段落。在示例部分，我们在段落末尾使用`::`。这两个版本都是对 RST 处理工具的提示，表明接下来的缩进部分应该被排版为代码。

### 为库模块编写 docstrings

当我们记录库模块时，我们需要关注的是那些将导入模块以在其代码中使用的程序员的需求。

1.  为 docstring 的其余部分草拟一个大纲。我们将使用 RST 标记。在一行上写出主题。在每个主题下面加一行`=`，使主题成为一个适当的标题。记得在每个段落之间留下一个空行。

1.  如前所示开始，创建一个摘要句子。

+   **描述**：模块包含的内容以及模块的用途摘要。

+   **模块内容**：此模块中定义的类和函数。

+   **示例**：使用模块的示例。

1.  为每个主题填写详细信息。模块内容可能是一个很长的类或函数定义列表。这应该是一个摘要。在每个类或函数内部，我们将有一个单独的 docstring，其中包含该项的详细信息。

1.  有关代码示例，请参阅前面的示例。使用`::`作为段落或段落结束。将代码示例缩进四个空格。

## 工作原理...

几十年来，*man page*的大纲已经发展成为 Linux 命令的有用摘要。这种撰写文档的一般方法被证明是有用和有韧性的。我们可以利用这一大量的经验，并结构化我们的文档以遵循 man page 模型。

这两种描述软件的方法都是基于许多单独页面文档的摘要。目标是利用众所周知的主题集。这使得我们的模块文档与常见做法相一致。

我们希望准备模块 docstrings，这些 docstrings 可以被 Sphinx Python 文档生成器使用（参见[`www.sphinx-doc.org/en/stable/`](http://www.sphinx-doc.org/en/stable/)）。这是用于生成 Python 文档文件的工具。Sphinx 中的`autodoc`扩展将读取我们的模块、类和函数上的 docstring 头，以生成最终的文档，看起来像 Python 生态系统中的其他模块。

## 还有更多...

RST 有一个简单的语法规则，即段落之间用空行分隔。

这条规则使得编写的文档可以被各种 RST 处理工具检查，并重新格式化得非常漂亮。

当我们想要包含一段代码块时，我们将有一些特殊的段落：

+   用空行将代码与文本分开。

+   代码缩进四个空格。

+   提供一个`::`前缀。我们可以将其作为自己单独的段落，或者作为引导段落末尾的特殊双冒号：

```py
        Here's an example:: 

            more_code()  

```

+   `::`用于引导段落。

在软件开发中有创新和艺术的地方。文档并不是推动创新的地方。聪明的算法和复杂的数据结构可能是新颖和聪明的。

### 注意

对于只想使用软件的用户来说，独特的语气或古怪的表达并不有趣。在调试时，幽默的风格也不会有帮助。文档应该是平常和常规的。

编写良好的软件文档可能是具有挑战性的。在太少的信息和仅仅重复代码的文档之间存在着巨大的鸿沟。在某个地方，有一个很好的平衡。重要的是要专注于那些对软件或其工作原理了解不多的人的需求。为这些*半知识*用户提供他们需要描述软件做什么以及如何使用它的信息。

在许多情况下，我们需要解决用例的两个部分：

+   软件的预期用途

+   如何自定义或扩展软件

这可能是两个不同的受众。可能有用户与开发人员不同。每个人都有不同的观点，文档的不同部分需要尊重这两种观点。

## 另请参阅

+   我们将在*在 docstrings 中编写更好的 RST 标记*中查看其他技术。

+   如果我们使用了*编写 python 脚本和模块文件-语法基础*的方法，我们将在我们的脚本文件中放置一个文档字符串。当我们在第三章中构建函数时，*函数定义*，以及在第六章中构建类时，*类和对象的基础*，我们将看到其他可以放置文档字符串的地方。

+   有关 Sphinx 的更多信息，请参阅[`www.sphinx-doc.org/en/stable/`](http://www.sphinx-doc.org/en/stable/)。

+   有关 man 页面大纲的更多背景信息，请参阅[`en.wikipedia.org/wiki/Man_page`](https://en.wikipedia.org/wiki/Man_page)。

# 在 docstrings 中编写更好的 RST 标记

当我们有一个有用的脚本时，通常需要留下关于它的功能、工作原理以及何时使用的注释。许多用于生成文档的工具，包括 Docutils，都使用 RST 标记。我们可以使用哪些 RST 功能来使文档更易读？

## 准备工作

在*包括描述和文档*的方法中，我们看到了将基本的文档放入模块中。这是编写我们的文档的起点。有许多 RST 格式规则。我们将看一些对于创建可读文档很重要的规则。

## 如何做...

1.  一定要写下关键点的大纲。这可能会导致创建 RST 部分标题来组织材料。部分标题是一个两行的段落，标题后面跟着一个下划线，使用`=`，`-`，`^`，`~`或其他 Docutils 字符来划线。

标题将看起来像这样。

```py
        Topic 
        ===== 

```

标题文本在一行上，下划线字符在下一行上。这必须被空行包围。下划线字符可以比标题字符多，但不能少。

RST 工具将推断我们使用下划线字符的模式。只要下划线字符一致使用，匹配下划线字符到期望标题的算法将检测到这种模式。这取决于一致性和对部分和子部分的清晰理解。

刚开始时，可以帮助制作一个明确的提醒便条，如下所示：

| **字符** | **级别** |
| --- | --- |
| = | 1 |
| - | 2 |
| ^ | 3 |
| ~ | 4 |

1.  填写各种段落。用空行分隔段落（包括部分标题）。额外的空行不会有害。省略空行将导致 RST 解析器看到一个单一的长段落，这可能不是我们想要的。

我们可以使用内联标记来强调、加重强调、代码、超链接和内联数学等，还有其他一些东西。如果我们打算使用 Sphinx，那么我们将有一个更大的文本角色集合可以使用。我们将很快看到这些技术。

1.  如果编程编辑器有拼写检查器，请使用。这可能会令人沮丧，因为我们经常会有包含拼写检查失败的缩写的代码示例。

## 工作原理...

docutils 转换程序将检查文档，寻找部分和正文元素。一个部分由一个标题标识。下划线用于将部分组织成正确嵌套的层次结构。推断这一点的算法相对简单，并具有以下规则：

+   如果之前已经看到了下划线字符，则已知级别

+   如果之前没有看到下划线字符，则必须缩进到前一个大纲级别的下一级

+   如果没有上一级，这就是第一级

一个正确嵌套的文档可能具有以下下划线字符序列：

```py
    ==== 
    ----- 
    ^^^^^^ 
    ^^^^^^ 
    ----- 
    ^^^^^^ 
    ~~~~~~~~ 
    ^^^^^^ 

```

我们可以看到，第一个大纲字符`=`将是一级。接下来的`-`是未知的，但出现在一级之后，所以必须是二级。第三个标题有`^`，之前未知，必须是三级。下一个`^`仍然是三级。接下来的两个`-`和`^`分别是二级和三级。

当我们遇到新字符`~`时，它位于三级之下，因此必须是四级标题。

### 注意

从这个概述中，我们可以看到不一致会导致混乱。

如果我们在文档的中途改变主意，这个算法就无法检测到。如果出于莫名其妙的原因，我们决定跳过一个级别并尝试在二级部分内有一个四级标题，那是不可能的。

RST 解析器可以识别几种不同类型的正文元素。我们展示了一些。更完整的列表包括：

+   **文本段落**：这些可能使用内联标记来强调或突出不同种类的内容。

+   **文字块**：这些是用`::`引入并缩进空格的。它们也可以用`.. parsed-literal::`指令引入。一个 doctest 块缩进四个空格，并包括 Python 的`>>>`提示符。

+   **列表、表格和块引用**：我们稍后会看到这些。这些可以包含其他正文元素。

+   **脚注**：这些是可以放在页面底部或章节末尾的特殊段落。这些也可以包含其他正文元素。

+   **超链接目标、替换定义和 RST 注释**：这些是专门的文本项目。

## 还有更多...

为了完整起见，我们在这里指出，RST 段落之间用空行分隔。RST 比这个核心规则要复杂得多。

在*包括描述和文档*配方中，我们看了几种不同类型的正文元素：

+   **文本段落**：这是由空行包围的文本块。在其中，我们可以使用内联标记来强调单词，或者使用字体来显示我们正在引用代码元素。我们将在*使用内联标记*配方中查看内联标记。

+   **列表**：这些是以看起来像数字或项目符号开头的段落。对于项目符号，使用简单的`-`或`*`。也可以使用其他字符，但这些是常见的。我们可能有这样的段落。

有项目符号会有帮助，因为：

+   它们可以帮助澄清

+   它们可以帮助组织

+   **编号列表**：有各种被识别的模式。我们可能会使用这样的东西。

四种常见的编号段落：

+   数字后面跟着像`.`或`)`这样的标点符号。

+   一个字母后面跟着像`.`或`)`这样的标点符号。

+   一个罗马数字后面跟着标点符号。

+   一个特殊情况是使用与前面项目相同的标点符号的`#`。这继续了前面段落的编号。

+   **文字块**：代码示例必须以文字形式呈现。这个文本必须缩进。我们还需要用`::`前缀代码。`::`字符必须是一个单独的段落，或者是代码示例的引导结束。

+   **指令**：指令是一个段落，通常看起来像`.. directive::`。它可能有一些内容，缩进以便包含在指令内。它可能看起来像这样：

```py
        ..  important:: 

            Do not flip the bozo bit. 

```

`.. important::`段落是指令。这之后是一个缩进在指令内的短段落文字。在这种情况下，它创建了一个包含*important*警告的单独段落。

### 使用指令

Docutils 有许多内置指令。Sphinx 添加了许多具有各种功能的指令。

最常用的指令之一是警告指令：*注意*，*小心*，*危险*，*错误*，*提示*，*重要*，*注意*，*提示*，*警告*和通用*警告*。这些是复合主体元素，因为它们可以有多个段落和其中嵌套的指令。

我们可能有这样的东西来提供适当的强调：

```py
    ..  note:: Note Title 

        We need to indent the content of an admonition. 
        This will set the text off from other material. 

```

另一个常见的指令是`parsed-literal`指令。

```py
    ..  parsed-literal:: 

        any text 
            *almost* any format 
        the text is preserved 
            but **inline** markup can be used. 

```

这对于提供代码示例非常方便，其中代码的某些部分被突出显示。这样的文字就是一个简单的主体元素，里面只能有文本。它不能有列表或其他嵌套结构。

### 使用内联标记

在段落中，我们可以使用几种内联标记技术：

+   我们可以用`*`将单词或短语括起来以进行`*强调*`。

+   我们可以用`**`将单词或短语括起来以进行`**强调**`。

+   我们用单个反引号（`` ` ``）包围引用。链接后面带有`_`。我们可以用`` `section title`_ ``来指代文档中的特定章节。我们通常不需要在 URL 周围放置任何东西。Docutils 工具可以识别这些。有时我们希望显示一个单词或短语，隐藏 URL。我们可以用这个：`` `the Sphinx documentation <http://www.sphinx-doc.org/en/stable/>`_ ``。
*   我们可以将代码相关的单词使用两个反引号括起来，使其看起来像：

    ```py
    ``code``
    ```

还有一种更一般的技术叫做文本角色。角色看起来比简单地用`*`字符包装一个单词或短语要复杂一些。我们使用`:word:`作为角色名称，后面跟着适用的单词或短语在单个`` ` ``反引号中。文本角色看起来像这样`` :strong:`this` ``。

有许多标准角色名称，包括`:emphasis:`、`:literal:`、`:code:`、`:math:`、`:pep-reference:`、`:rfc-reference:`、`:strong:`、`:subscript:`、`:superscript:`和`:title-reference:`。其中一些也可以用更简单的标记，如`*emphasis*`或`**strong**`。其余只能作为显式角色使用。

此外，我们可以使用一个简单的指令定义新角色。如果我们想要进行非常复杂的处理，我们可以为处理角色提供 docutils 的类定义，从而允许我们调整文档处理的方式。Sphinx 添加了大量角色以支持函数、方法、异常、类和模块之间的详细交叉引用。

## 另请参阅

+   有关 RST 语法的更多信息，请参阅[`docutils.sourceforge.net`](http://docutils.sourceforge.net)。其中包括对 docutils 工具的描述。

+   有关**Sphinx Python Documentation Generator**的信息，请参阅[`www.sphinx-doc.org/en/stable/`](http://www.sphinx-doc.org/en/stable/)。

+   Sphinx 工具添加了许多附加指令和文本角色到基本定义中。

# 设计复杂的 if...elif 链

大多数情况下，我们的脚本会涉及到一系列选择。有时选择很简单，我们可以通过查看代码来判断设计的质量。在其他情况下，选择更加复杂，很难确定我们的 if 语句是否正确设计以处理所有条件。

在最简单的情况下，我们有一个条件，*C*，和它的反义，*C*。这是`if...else`语句的两个条件。一个条件，¬*C*，在`if`子句中说明，另一个在`else`中暗示。

在本解释中，我们将使用 *p* ∨ *q* 表示 Python 的**OR**运算符。我们可以称这两个条件为*完整*，因为：

*C* ∨ *C =* ¬ ***T***

我们称之为完全，因为没有其他条件可以存在。没有第三个选择。这就是**排中律**。这也是`else`子句背后的操作原则。`if`语句体被执行或`else`语句被执行。没有第三个选择。

在实际编程中，我们经常有复杂的选择。我们可能有一组条件，*C* = {*C[1]*，*C[2]*，*C[3]*，...，*C[n]*}。

我们不希望简单地假设：

*C[1]* ∨ *C[2]* ∨ *C[3]* ∨ *...* ∨ *C[n] = **T***

我们可以使用 ![设计复杂的 if...elif 链](img/Image00003.jpg) 来表示与`any(C)`类似的含义，或者`any([C_1, C_2, C_3, ..., C_n])`。我们需要证明![设计复杂的 if...elif 链](img/Image00004.jpg) ；我们不能假设这是`true`。

下面是可能出错的情况——我们可能错过了一些条件，*C[n+1]*，在逻辑混乱中丢失了。错过这个将意味着我们的程序将无法正确处理此案例。

我们如何确定我们没有漏掉什么？

## 准备就绪

让我们看一个具体的例子，一个`if...elif`链。在*Craps*赌场游戏中，有一些适用于两个骰子的投掷的规则。这些规则适用于游戏的第一次投掷，称为*come out*投掷：

+   2，3 或 12，是*Craps*，这对所有在通过线上下的所有赌注来说都是一个损失

+   7 或 11 对所有放在通过线上的赌注都是赢家

+   剩余数字确定了一个*点*

许多玩家把他们的赌注放在通过线上。还有一个*don't pass*线，这个线不常用。我们将使用这三个条件集作为例子来查看这个方法，因为它有一个可能模糊的子句。

## 如何做...

当我们写一个`if`语句时，即使看起来微不足道，我们也需要确保所有条件都被考虑到。

1.  枚举我们所知道的备选方案。在我们的例子中，我们有三条规则：（2，3，12），（7，11），以及模糊的剩余数字。

1.  确定所有可能条件的全集。对于这个例子，有 10 个条件：从 2 到 12 的数字。

1.  将已知的备选方案与宇宙进行比较。这个条件集合*C*与所有可能条件的宇宙*U*之间有三种可能的比较结果：

已知的备选方案比宇宙中的条件还多；*C* ⊃ *U* 。这是一个巨大的设计问题。这需要从根本上重新思考设计。

已知条件和可能条件的宇宙之间存在差距；U \ C ≠ ∅。在某些情况下，很明显我们没有涵盖所有可能的条件。在其他情况下，需要进行一些仔细的推理。我们需要用更精确的东西替换任何模糊或定义不清的术语。

在这个例子中，我们有一个模糊的术语，我们可以用更具体的东西替换。术语**剩余数字**似乎是值的列表（4, 5, 6, 8, 9, 10）。提供这个列表消除了任何可能的空白和疑虑。

已知的备选方案与可能备选方案的宇宙相匹配；*U* ≡ *C* 。有两种常见情况：

+   我们有像*C* ∨ ¬ *C*这样简单的东西。我们可以使用一个单独的`if`和`else`子句——我们不需要使用这个方法，因为我们可以很容易地推断出¬ *C*。

+   我们可能有更复杂的东西。因为我们知道了整个宇宙，我们可以展示 ![如何做...](img/Image00004.jpg) 。我们需要使用这个方法来编写一系列的`if`和`elif`语句，每个条件一个子句。

区分并不总是清晰的。在我们的例子中，我们没有详细说明其中一个条件，但这个条件*大致*是清晰的。如果我们认为缺失的条件是显而易见的，我们可以使用一个`else`子句而不是明确地写出它。如果我们认为缺失的条件可能会被误解，我们应该将其视为模糊的，并使用这个方法。

1.  编写覆盖所有已知条件的`if...elif...elif`链。对于我们的例子，它会像这样：

```py
        dice = die_1 + die_2 
        if dice in (2, 3, 12): 
            game.craps() 
        elif dice in (7, 11): 
            game.winner() 
        elif dice in (4, 5, 6, 8, 9, 10): 
            game.point(die) 

```

1.  添加一个引发异常的`else`子句，就像这样：

```py

        else: 
            raise Exception('Design Problem Here: not all conditions accounted for') 

```

这个额外的 `else` 崩溃条件给了我们一种积极识别逻辑问题的方法。我们可以确信，我们所犯的任何错误都将导致一个引人注目的问题。

## 工作原理...

我们的目标是确保我们的程序始终正常运行。尽管测试有所帮助，但我们仍然可能在设计和测试用例中有错误的假设。

尽管严谨的逻辑是必不可少的，我们仍然可能犯错。此外，其他人可能尝试调整我们的代码并引入错误。更尴尬的是，我们可能对自己的代码进行更改导致程序崩溃。

`else` 崩溃选项迫使我们对每个条件都要明确。不做任何假设。正如我们之前指出的，我们逻辑中的任何错误都将在引发异常时被发现。

`else` 崩溃选项对性能影响不大。一个简单的 `else` 子句比带有条件的 `elif` 子句稍快一些。如果我们认为我们的应用程序性能在任何方面取决于单个表达式的成本，那么我们有更严重的设计问题要解决。评估单个表达式的成本很少是算法中最昂贵的部分。

在设计问题存在的情况下，遇到异常崩溃是一个明智的行为。按照写入警告消息到日志的设计模式并没有太多意义。如果存在这种逻辑漏洞，程序就已经严重出错了，发现问题后尽快找到并修复是很重要的。

## 还有更多...

在许多情况下，我们可以通过检查程序处理的某个点的期望后置条件来推导出一个 `if...elif...elif` 链。例如，我们可能需要一个陈述来建立像 *m* 是 *a* 或 *b* 中较大的一个这样简单的事情。

（为了通过逻辑，我们将避免 `m = max(a, b)` 。）

我们可以这样形式化最终条件：

*(m = a* ∨ *m = b)* ∧ *m > a * ∧ *m > b*

我们可以通过将目标写成一个断言语句来从最终条件开始逆向工作：

```py

    # do something 
    assert (m = a or m = b) and m > a and m > b 

```

一旦我们陈述了目标，我们就可以确定导致该目标的陈述。显然，像 `m = a` 和 `m = b` 这样的赋值语句是合适的��但只在特定条件下。

这些陈述中的每一个都是解决方案的一部分，我们可以推导出一个前提条件，显示何时应该使用该陈述。每个赋值语句的前提条件是 `if` 和 `elif` 表达式。当 `a >= b` 时，我们需要使用 `m = a` ；当 `b >= a` 时，我们需要使用 `m=b` 。将逻辑重新排列成代码给出了这样：

```py

    if a >= b:  
        m = a 
    elif b >= a: 
        m = b 
    else:     raise Exception( 'Design Problem') 
    assert (m = a or m = b) and m > a and m > b 
```

请注意我们的条件宇宙，*U* = { *a ≥ b, b ≥ a* }，是完整的；没有其他可能的关系。还要注意，在边界情况下的 *a = b* ，我们实际上并不关心使用哪个赋值语句。Python 将按顺序处理决策，并执行 `m = a` 。这个选择是一致的事实不应该对我们的 `if...elif...elif` 链的设计产生任何影响。我们应该总是写条件而不考虑子句的评估顺序。

## 另请参阅

+   这类似于**悬挂 else**的语法问题。参见[`en.wikipedia.org/wiki/Dangling_else`](https://en.wikipedia.org/wiki/Dangling_else)。

+   Python 的缩进消除了悬挂 else 语法问题。它并没有解决在复杂的`if...elif...elif`链中确保所有条件都得到适当处理的语义问题。

+   还请参阅[`en.wikipedia.org/wiki/Predicate_transformer_semantics`](https://en.wikipedia.org/wiki/Predicate_transformer_semantics)。

# 设计一个正确终止的 while 语句

大多数情况下，Python 的`for`语句提供了我们需要的所有迭代控制。在许多情况下，我们可以使用内置函数如`map()`，`filter()`和`reduce()`来处理数据集合。

然而，有一些情况我们需要使用`while`语句。其中一些情况涉及到我们无法创建适当的迭代器来遍历项目的数据结构。其他情况涉及与人类用户的交互，我们在从这些人那里得到输入之前没有数据。

## 准备工作

假设我们要提示用户输入密码。我们将使用`getpass`模块，以便没有回显。

此外，为了确保他们已经正确输入了密码，我们将要求他们输入两次并比较结果。这是一个简单的`for`语句不会很好地处理的情况。它可以被迫服役，但结果代码看起来很奇怪：`for`语句有一个显式的上限；提示用户输入实际上没有一个上限。

## 如何做……

我们将介绍一个六步流程，概述了设计这种迭代算法核心的内容。这是当一个简单的`for`语句不能解决我们的问题时需要做的事情。

1.  定义完成。在我们的情况下，我们将有两份密码，`password_text`和`confirming_password_text`。循环后必须为`true`的条件是`password_text == confirming_password_text`。理想情况下，从人们（或文件）那里读取是一个有界的活动。最终，人们会输入匹配的值对。在他们输入匹配的值对之前，我们将无限迭代。

还有其他边界条件。例如，文件结束。或者我们允许人返回到先前的提示。一般来说，我们在 Python 中用异常处理这些其他条件。

当然，我们可以将这些额外条件添加到我们的完成定义中。我们可能需要一个复杂的终止条件，例如文件结尾或`password_text == confirming_password_text`。

在这个例子中，我们将选择异常处理，并假设将使用`try:`块。只在终止条件中有一个单一子句大大简化了设计。

我们可以这样勾画出循环的大致情况：

```py

        # initialize something 
        while # not terminated: 
            # do something 
        assert password_text == confirming_password_text 
```

我们将我们的“完成定义”写成了最后的`assert`语句。我们已经为之后的迭代包含了注释，我们将在后续步骤中填写。

1.  定义一个在循环迭代时为`true`的条件。这被称为**不变量**，因为在循环处理的开始和结束时它总是`true`。通常通过泛化后置条件或引入另一个变量来创建它。

当从人（或文件）那里读取时，我们有一个隐含的状态改变，这是不变量的重要部分。我们可以称之为状态改变中的*获取下一个输入*。我们经常必须清楚地表达，我们的循环将从输入流中获取下一个值。

我们必须确保我们的循环能够正确获取下一个项目，尽管`while`语句体中存在复杂的逻辑。一个常见的错误是存在一个条件，下一个输入实际上没有被获取。这会导致程序*挂起*——在`while`语句体中的`if`语句路径中没有状态改变。不变量没有被正确重置，或者在设计循环时没有被正确表达。

在我们的情况下，不变量将使用一个概念上的`new-input()`条件。当我们使用`getpass()`函数读取新值时，这个条件为`true`。这是我们扩展的循环设计：

```py

        # initialize something 
        # assert the invariant new-input(password_text) 
        # and new-input(confirming_password_text) 
        while # not terminated: 
            # do something 
            # assert the invariant new-input(password_text) 
            # and new-input(confirming_password_text) 
        assert password_text == confirming_password_text 

```

1.  定义离开循环的条件。我们需要确保这个条件取决于不变量为`true`。我们还需要确保，当这个终止条件最终为`false`时，目标状态将变为`true`。

在大多数情况下，循环条件是目标状态的逻辑否定。这里是扩展的设计：

```py

        # initialize something 
        # assert the invariant new-input(password_text)  
        # and new-input(confirming_password_text) 
        while password_text != confirming_password_text: 
            # do something 
            # assert the invariant new-input(password_text)  
            # and new-input(confirming_password_text) 
        assert password_text == confirming_password_text 

```

1.  定义初始化，确保不变量为`true`，并且我们实际上可以测试终止条件。在这种情况下，我们需要为两个变量获取值。现在循环看起来像这样：

```py

        password_text= getpass() 
        confirming_password_text= getpass("Confirm: ") 
        # assert new-input(password_text) 
        # and new-input(confirming_password_text) 
        while password_text != confirming_password_text: 
            # do something 
            # assert new-input(password_text) 
            # and new-input(confirming_password_text) 
        assert password_text == confirming_password_text 

```

1.  编写循环体，将不变量重置为`true`。我们需要编写最少的语句来实现这一点。对于这个示例循环，最少的语句是相当明显的——它们与初始化匹配。我们更新后的循环看起来像这样：

```py

        password_text= getpass() 
        confirming_password_text= getpass("Confirm: ") 
        # assert new-input(password_text) 
        # and new-input(confirming_password_text) 
        while password_text != confirming_password_text: 
            password_text= getpass() 
            confirming_password_text= getpass("Confirm: ") 
            # assert new-input(password_text) 
            # and new-input(confirming_password_text) 
        assert password_text == confirming_password_text 

```

1.  确定一个时钟——一个单调递减的函数，显示每次循环确实朝着终止条件取得进展。

    当从人那里收集输入时，我们被迫做一个假设——最终他们会输入匹配的对。每次循环都使我们离匹配对更近一步。为了正确形式化，我们可以假设在它们匹配之前会有*n*个输入；我们必须展示每次循环减少剩余数量。

    在复杂情况下，我们可能需要将用户的输入视为值列表。对于我们的示例，我们会将用户输入视为一系列对：*[(p[1] , q[1] ),(p[2] , q[2] ),(p[3] , q[3] ),...,(p[n] , q[n] )]*。通过有限的列表，我们可以更容易地推断我们的循环是否真正朝着完成进展。

因为我们基于目标`最终`条件构建了循环，所以我们可以绝对确定它做了我们想要的事情。如果我们的逻辑是合理的，循环将终止，并且将以预期的结果终止。这是所有编程的目标——让机器在给定一些初始状态的情况下达到期望的状态。

移除一些注释后，我们得到了我们的最终循环：

```py

    password_text= getpass() 
    confirming_password_text= getpass("Confirm: ") 
    while password_text != confirming_password_text: 
        password_text= getpass() 
        confirming_password_text= getpass("Confirm: ") 
    assert password_text == confirming_password_text 
```

我们将最终的后置条件保留为一个`assert`语句。对于复杂的循环，它既是一个内置测试，也是一个解释循环工作原理的注释。

这个设计过程通常会产生一个看起来类似于基于直觉开发的循环。有逐步证明直觉设计的没什么问题。一旦我们这样做了几次，我们就可以更有信心地使用循环，因为我们可以证明设计是合理的。

在这种情况下，循环体和初始化碰巧是相同的代码。如果这是一个问题，我们可以定义一个小两行的函数来避免重复代码。我们将在第三章*函数定义*中讨论这个问题。

## 它的工作原理...

我们首先明确循环的目标。我们所做的一切都将确保编写的代码导致该目标条件。实际上，这就是所有软件设计背后的动机——我们始终试图编写导致给定目标状态的最少语句。我们通常是*反向*从目标到初始化。推理链中的每一步实质上都是陈述了某个语句`S`的最弱前置条件，该语句导致我们期望的结果条件。

鉴于后置条件，我们试图解决一个语句和一个前置条件。我们总是在构建这个模式：

```py

    assert pre-condition 
    S 
    assert post-condition 
```

后置条件是我们的完成定义。我们需要假设一个导致完成的语句，`S`，以及该语句的前置条件。总是存在无限数量的替代语句；我们专注于最弱的前置条件——假设最少的那个。

在某个时刻——通常是在编写初始化语句时——我们发现前置条件仅仅是`true`：任何初始状态都可以作为语句的前置条件。这就是我们知道我们的程序可以从任何初始状态开始并按预期完成的方式。这是理想的。

在设计`while`语句时，我们在语句体内有一个嵌套的上下文。语句体应始终处于将不变条件重新设置为`true`的过程中。在我们的例子中，这意味着从用户那里读取更多输入。在其他例子中，我们可能正在处理字符串中的另一个字符，或者从一组数字中取另一个数字。

我们需要证明当不变量为`true`且循环条件为`false`时，我们的最终目标已经实现。当我们从最终目标出发并根据该最终目标创建不变量和循环条件时，这个证明会更容易。

重要的是要耐心地完成每一步，以确保我们的推理是坚实的。我们需要能够证明循环将正常工作。然后我们可以有信心地运行单元测试。

## 另请参阅

+   我们在*避免使用 break 语句可能导致的问题*配方中查看了高级循环设计的其他方面。

+   我们在*设计复杂的 if...elif 链*配方中也研究了这个概念。

+   关于这个话题的经典文章是由**大卫·格里斯**撰写的一篇论文，*关于发展循环不变量和循环的标准策略的注释*。参见[`www.sciencedirect.com/science/article/pii/0167642383900151`](http://www.sciencedirect.com/science/article/pii/0167642383900151)。

+   算法设计是一个大的主题。一本很好的介绍是由斯基耐纳撰写的 *算法设计手册*。参见[`www3.cs.stonybrook.edu/~algorith/`](http://www3.cs.stonybrook.edu/~algorith/)。

# 避免使用 break 语句可能导致的问题

理解`for`语句的常见方式是它创建了一个*对于所有*的条件。在语句结束时，我们可以断言，在集合中的所有项目都进行了一些处理。

这并不是`for`语句的唯一含义。当我们在`for`的主体内引入`break`语句时，我们将语义更改为*存在*。当`break`语句离开`for`（或`while`）语句时，我们只能断言至少存在一个导致语句结束的项目。

这里有一个次要问题。如果循环在不执行`break`的情况下结束了怎么办？我们被迫断言不存在即使一个触发了`break`的项目。**德摩根定律**告诉我们，不存在的条件可以重新陈述为*对于所有*的条件：¬∃[*x*]*B*(*x*) ≡ ∀[*x*]¬ *B*(*x*)。在这个公式中，*B(x)* 是包括`break`的`if`语句的条件。如果我们从未找到 *B(x)*，那么对于所有的项目，¬ *B(x)* 都是`true`。这显示了典型的*对于所有*循环和包括`break`的*存在*循环之间的一些对称性。

离开`for`或`while`语句时为`true`的条件可能是模糊的。它是正常结束的吗？它执行了`break`吗？我们不能*轻易*地判断，所以我们将提供一套给出一些设计指导的配方。

当我们有多个带有各自条件的`break`语句时，这个问题可能变得更加严重。我们如何最小化由复杂的`break`条件带来的问题？

## 准备就绪

让我们找到字符串中第一个出现的`:`或`=`。这是对`for`语句的*存在*修改的一个很好的例子。我们不想处理所有字符，我们想知道最左边存在`:`或`=`的地方。

```py

>>> sample_1 = "some_name = the_value" 
>>> for position in range(len(sample_1)): 
...    if sample_1[position] in '=:': 
...        break 
>>> print('name=', sample_1[:position], 
...     'value=', sample_1[position+1:]) 
name= some_name  value=  the_value

```

这个边缘案例怎么处理？

```py

>>> sample_2 = "name_only" 
>>> for position in range(len(sample_2)): 
...    if sample_2[position] in '=:': 
...        break 
>>> print('name=', sample_2[:position], 
...     'value=', sample_2[position+1:])  
name= name_onl value=

```

那太尴尬了。发生了什么？

## 如何做...

正如我们在*设计正确终止的 while 语句*配方中指出的，每个语句都建立了一个后置条件。在设计循环时，我们需要表达这个条件。在这种情况下，我们没有正确表达后置条件。

理想情况下，后置条件应该是像`text[position] in '=:'`这样简单的东西。但是，如果给定的文本中没有`=`或`:`，简单的后置条件就没有逻辑意义。当没有任何符合条件的字符存在时，我们无法对不在那里的字符的位置做出任何断言。

1.  写出明显的后置条件。我们有时称之为*幸运路径*条件，因为当没有发生任何异常情况时，它是`true`的。

```py

text[position] in '=:' 
```

1.  为边界情况添加后置条件。在这个例子中，我们有两个额外的条件：

    +   没有`=`或`:`。

    +   根本没有字符。`len()`为零，循环实际上什么也没做。在这种情况下，位置变量将永远不会被创建。

```py

                (len(text) == 0 
                or not('=' in text or ':' in text) 
                or text[position] in '=:') 

```

1.  如果正在使用`while`语句，请考虑重新设计为具有完成条件。这可以消除对`break`语句的需要。

1.  如果正在使用`for`语句，请确保进行适当的初始化，并在循环后的语句中添加各种终止条件。在`x = 0`后面跟着`for x = ...`可能看起来多余。在不执行`break`语句的循环中，这是必要的。

```py

      >>> position = -1 # If it's zero length 
      >>> for position in range(len(sample_2)): 
      ...    if sample_2[position] in '=:': 
      ...        break 
      ... 
      >>> if position == -1:   
      ...     print("name=", None, "value=", None) 
      ... elif not(text[position] == ':' or text[position] == '='): 
      ...     print("name=", sample_2, "value=", None) 
      ... else: 
      ...    print('name=', sample_2[:position], 
      ...     'value=', sample_2[position+1:]) 
      name= name_only value= None
```

在`for`后的语句中，我们已经明确列出了所有的终止条件。最终输出，`name= name_only value= None`，确认我们已经正确处理了示例文本。

## 运作原理...

这种方法迫使我们仔细计算后置条件，以确保我们绝对确定知道循环终止的所有原因。

在更复杂的循环中——具有多个`break`语句——后置条件可能很难完全计算出来。循环的后置条件必须包括离开循环的所有原因——*正常*原因以及所有的`break`条件。

在许多情况下，我们可以重构循环以将处理推入循环体中。我们不仅断言`position`是`=`或`:`字符的索引，而且包括分配`name`和`value`值的下一个处理步骤。我们可能会有这样的东西：

```py

    if len(sample_2) > 0: 
        name, value = sample_2, None 
    else: 
        name, value = None, None 
    for position in range(len(sample_2)): 
        if sample_2[position] in '=:': 
            name, value = sample_2[:position], sample2[position:] 
    print('name=', name, 'value=', value) 
```

这个版本基于先前评估的完整后置条件向前推进了一些处理。这种重构很常见。

思路是放弃任何假设或直觉。稍加纪律，我们可以确定任何语句的后置条件。

实际上，我们思考后置条件的次数越多，我们的软件就可以越精确。关于我们软件目标的目标一定要明确，并通过选择使目标变为`true`的最简单的语句来逆向工作。

## 还有更多...

我们也可以在`for`语句上使用`else`子句来确定循环是否正常结束或执行了`break`语句。我们可以像这样使用：

```py

We can also use an else clause on a for statement to determine if the loop finished normally or a break statement was executed. We can use something like this:

    for position in range(len(sample_2)): 
        if sample_2[position] in '=:': 
            name, value = sample_2[:position], sample_2[position+1:] 
            break 
    else: 
        if len(sample_2) > 0: 
            name, value = sample_2, None 
        else: 
            name, value = None, None 
```

`else`条件有时会让人感到困惑，我们不建议使用。不清楚它是否比任何其他替代方案更好。很容易忘记`else`被执行的原因，因为它很少被使用。

## 另请参阅

+   这个主题的经典文章是由 David Gries 撰写的，*关于开发循环不变量和循环的标准策略的注释*。参见[`www.sciencedirect.com/science/article/pii/0167642383900151`](http://www.sciencedirect.com/science/article/pii/0167642383900151)。

# 利用异常匹配规则

`try`语句让我们捕获异常。当异常被引发时，我们有多种处理方式：

+   **忽略它**：如果我们什么都不做，程序会停止。我们可以通过两种方式实现这一点——首先不使用`try`语句，或者在`try`语句中没有匹配的`except`子句。

+   **记录日志**：我们可以写一条消息并让其传播；通常这会导致程序停止。

+   **从中恢复**：我们可以编写一个`except`子句来执行一些恢复操作，以撤消在`try`子句中部分完成的操作的影响。我们可以进一步将`try`语句包装在`while`语句中，并持续重试直到成功。

+   **忽略它**：如果我们什么都不做（即`pass`），那么在`try`语句之后会恢复处理。这会消除异常。

+   **重写它**：我们可以引发一个不同的异常。原始异常成为新引发异常的上下文。

+   **链式处理**：我们将一个不同的异常链接到原始异常。我们将在*使用`raise from`语句链接异常*这个示例中看到这一点。

嵌套上下文怎么办？在这种情况下，内部`try`可能会忽略异常，但外部上下文会处理异常。每个`try`上下文的基本选项都是相同的。软件的整体行为取决于嵌套定义。

我们设计`try`语句的方式取决于 Python 异常形成的类层次结构。详情请参见*第 5.4 节*，*Python 标准库*。例如，`ZeroDivisionError`也是`ArithmeticError`和`Exception`。再举一个例子，`FileNotFoundError`也是`OSError`和`Exception`。

如果我们试图处理详细的异常以及通用的异常，这种层次结构可能会导致混淆。

## 准备工作

假设我们将简单地使用`shutil`来将文件从一个地方复制到另一个地方。可能会引发的大多数异常都表示问题太严重，无法解决。然而，在罕见的`FileExistsError`事件中，我们希望尝试恢复操作。

这是我们想要做的大致概述：

```py

    from pathlib import Path 
    import shutil 
    import os 
    source_path = Path(os.path.expanduser( 
       '~/Documents/Writing/Python Cookbook/source')) 
    target_path = Path(os.path.expanduser( 
       '~/Dropbox/B05442/demo/')) 
    for source_file_path in source_path.glob('*/*.rst'): 
        source_file_detail = source_file_path.relative_to(source_path) 
        target_file_path = target_path / source_file_detail 
        shutil.copy( str(source_file_path), str(target_file_path 
```

我们有两条路径，`source_path`和`target_path`。我们已经定位了`source_path`下所有具有`*.rst`文件的目录。

表达式`source_file_path.relative_to(source_path)`给出了文件名的尾部，即基本目录后的部分。我们使用这个来构建一个在`target`目录下的新路径。

虽然我们可以对许多普通路径处理使用`pathlib.Path`对象，但在 Python 3.5 中，像`shutil`这样的模块期望字符串文件名而不是`Path`对象；我们需要显式转换`Path`对象。我们只能希望 Python 3.6 会改变这一点。

处理`shutil.copy()`函数引发的异常会带来问题。我们需要一个`try`语句，以便我们能够从某些类型的错误中恢复过来。如果我们尝试运行以下代码，我们会看到这种类型的错误：

```py

    FileNotFoundError: [Errno 2] 
        No such file or directory: 
        '/Users/slott/Dropbox/B05442/demo/ch_01_numbers_strings_and_tuples/index.rst' 

```

如何创建一个按正确顺序处理异常的`try`语句？

## 如何做到这一点...

1.  在`try`块中缩进写入我们想要使用的代码：

```py

        try: 
            shutil.copy( str(source_file_path), str(target_file_path) ) 

```

1.  先包括最具体的异常类。在这种情况下，我们针对具体的`FileNotFoundError`和更一般的`OSError`分别有不同的响应。

```py

        try: 
            shutil.copy( str(source_file_path), str(target_file_path) ) 
        except FileNotFoundError: 
            os.makedir( target_file_path.parent ) 
            shutil.copy( str(source_file_path), str(target_file_path) ) 
```

1.  包括稍后的更一般的异常：

```py

        try: 
            shutil.copy( str(source_file_path), str(target_file_path) ) 
        except FileNotFoundError: 
            os.makedirs( str(target_file_path.parent) ) 
            shutil.copy( str(source_file_path), str(target_file_path) ) 
        except OSError as ex: 
            print(ex) 

```

    我们先匹配最具体的异常，然后再匹配更通用的异常。

    我们通过创建缺失的目录来处理`FileNotFoundError`，然后再次执行`copy()`，知道现在它会正常工作。

    我们消除了其他任何`OSError`类的异常。例如，如果有权限问题，那么该错误将被简单地记录。我们的目标是尝试复制所有文件。任何导致问题的文件都将被记录，但复制过程将继续。

## 它是如何工作的...

Python 的异常匹配规则旨在保持简单：

+   按顺序处理`except`子句

+   将实际异常与异常类（或异常类元组）进行匹配。匹配意味着实际异常对象（或异常对象的任何基类）是`except`子句中给定类的对象。

这些规则说明了我们为什么要先放置最具体的异常类，然后是更一般的异常类。像`Exception`这样的通用异常类几乎匹配每一种类型的异常。我们不希望它首先出现，因为不会检查任何其他子句。我们必须始终将通用异常放在最后。

还有一个更通用的类，`BaseException`类。没有好理由来处理这个类的异常。如果我们这样做，我们将捕获`SystemExit`和`KeyboardInterrupt`异常，这会干扰杀死表现不良应用程序的能力。我们仅在定义存在于正常异常层次结构之外的新异常类时才使用`BaseException`类作为超类。

## 还有更多...

我们的示例包括一个嵌套上下文，在其中可能引发第二个异常。考虑到这个`except`子句：

```py

    except FileNotFoundError: 
        os.makedirs( str(target_file_path.parent) ) 
        shutil.copy( str(source_file_path), str(target_file_path) ) 

```

如果`os.makedirs()`或`shutil.copy()`函数引发其他异常，这些异常将不会被这个`try`语句处理。在此引发的任何异常都将导致整个程序崩溃。我们有两种处理方法，都涉及嵌套的`try`语句。

我们可以重写这个以在恢复期间包含一个嵌套的`try`：

```py

    try: 
        shutil.copy( str(source_file_path), str(target_file_path) ) 
    except FileNotFoundError: 
        try: 
            os.makedirs( str(target_file_path.parent) ) 
            shutil.copy( str(source_file_path), str(target_file_path) ) 
        except OSError as ex: 
            print(ex) 
    except OSError as ex: 
        print(ex) 
```

在这个例子中，我们在两个地方重复了`OSError`处理。在我们的嵌套上下文中，我们将记录异常并让它传播，这可能会停止程序。在外部上下文中，我们将做同样的事情。

我们说*可能会停止程序*，因为这段代码可能在`try`语句中使用，该语句可能会处理这些异常。如果没有其他`try`上下文，那么这些未处理的异常将停止程序。

我们还可以重写我们的总体语句，使用嵌套的`try`语句将两种异常处理策略分成更局部和更全局的考虑。它会像这样：

```py

   try: 
        try: 
            shutil.copy( str(source_file_path), str(target_file_path) ) 
        except FileNotFoundError: 
            os.makedirs( str(target_file_path.parent) ) 
            shutil.copy( str(source_file_path), str(target_file_path) ) 
    except OSError as ex: 
        print(ex) 
```

在内部`try`语句中处理`makedirs`的复制只处理`FileNotFoundError`异常。任何其他异常都将传播到外部`try`语句。在这个例子中，我们将异常处理嵌套，使得通用处理包装特定处理。

## 另请参阅

+   在*避免使用`except:`子句可能会出现的问题*的示例中，我们将看到在设计异常时的一些额外考虑因素。

+   在*使用`raise from`语句链接异常*的示例中，我们将看到如何链接异常，以便单个异常类包装不同的详细异常。

# 避免使用`except:`子句可能会出现的问题

在异常处理中有一些常见的错误。这些错误可能会导致程序无响应。

我们可能会犯的错误之一是使用`except:`子句。如果我们对尝试处理的异常不谨慎，还有一些其他错误可能会发生。

这个示例将展示一些我们可以避免的常见异常处理错误。

## 准备就绪

在*避免使用`except:`子句可能会出现的问题*的示例中，我们看到了在设计异常处理时的一些考虑因素。在那个示例中，我们不建议使用`BaseException`，因为我们可能会干扰停止行为异常的 Python 程序。

我们将在这个示例中扩展*不应该做什么*的想法。

## 如何做...

使用`except Exception:`作为最通用的异常管理方式。

处理太多异常可能会干扰我们停止异常的 Python 程序的能力。当我们按下*Ctrl* + *C*，或通过`kill -2`发送`SIGINT`信号时，我们通常希望程序停止。我们很少希望程序写一条消息并继续运行，或者完全停止响应。

还有一些其他类别的异常，我们应该警惕尝试处理：

+   SystemError

+   RuntimeError

+   MemoryError

通常，这些异常意味着 Python 内部某处出现了问题。与其消除这些异常，或尝试进行一些恢复，我们应该允许程序失败，找出根本原因并修复它。

## 它是如何工作的...

有两种技术我们应该避免：

+   不要捕获`BaseException`类

+   不要使用`except:`而不指定异常类。这会匹配所有异常；这将包括我们应该避免尝试处理的异常。

使用`except BaseException`或不指定具体类的`except`可能会导致程序在我们需要停止它的时候变得无响应。

此外，如果我们捕获了其中任何异常，我们可能会干扰这些内部异常的处理方式：

+   `SystemExit`

+   `KeyboardInterrupt`

+   `GeneratorExit`

如果我们静默、包装或重写其中任何一个，我们可能已经制造了一个本不存在的问题。我们可能已经将一个简单的问题加剧成一个更大更神秘的问题。

### 注意

编写一个从不崩溃的程序是一种高贵的愿望。干扰 Python 的一些内部异常不会创建一个更可靠的程序。相反，它会创建一个清晰的失败被掩盖并成为模糊的神秘的程序。

## 另请参见

+   在*利用异常匹配规则*食谱中，我们将探讨设计异常时的一些考虑因素。

+   在*使用`raise from`语句链接异常*食谱中，我们将看看如何链接异常，使得单一异常类包装不同的详细异常。

# 使用`raise from`语句链接异常

在某些情况下，我们可能希望将一些看似不相关的异常合并为一个单一的通用异常。一个复杂的模块通常定义一个适用于模块内部可能出现的许多情况的单一通用`Error`异常。

大多数情况下，通用异常就足够了。如果引发了模块的`Error`，则说明某些地方出了问题。

较少情况下，我们希望获取详细信息以进行调试或监视目的。我们可能希望将它们写入日志，或将详细信息包含在电子邮件中。在这种情况下，我们需要提供支持详细信息，以放大或扩展通用异常。我们可以通过从通用异常链接到根本原因异常来做到这一点。

## 准备就绪

假设我们正在编写一些复杂的字符串处理。我们希望将许多不同类型的详细异常视为单个通用错误，以使我们软件的用户免受实现细节的影响。我们可以将详细信息附加到通用错误。

## 如何做...

1.  要创建一个新的异常，我们可以这样做：

```py

        class Error(Exception): 
            pass 

```

这就足以定义一个新的异常类。

1.  在处理异常时，我们可以使用`raise from`语句将它们链接起来，就像这样：

```py

        try: 
            something 
        except (IndexError, NameError) as exception: 
            print("Expected", exception) 
            raise Error("something went wrong") from exception 
       except Exception as exception: 
            print("Unexpected", exception) 
            raise 

```

    在第一个`except`子句中，我们匹配了两种异常类。无论我们收到哪种类型的异常，我们都将从模块的通用`Error`异常类中引发一个新的异常。新的异常将链接到根本原因异常。

    在第二个`except`子句中，我们匹配了通用的`Exception`类。我们写了一个日志消息并重新引发了异常。在这里，我们不是在链接异常，而是在另一个上下文中简单地继续异常处理。

## 工作原理...

Python 异常类都有一个记录异常原因的位置。我们可以使用`raise Exception from Exception`语句设置这个`__cause__`属性。

当引发此异常时，它的样子是这样的：

```py

>>> class Error(Exception): 
...     pass 
>>> try:  
...     'hello world'[99] 
... except (IndexError, NameError) as exception: 
...     raise Error("index problem") from exception 
... 
Traceback (most recent call last): 
  File "<doctest default[0]>", line 2, in <module> 
    'hello world'[99] 
IndexError: string index out of range

```

刚刚我们看到的异常是以下异常的直接原因：

```py

Traceback (most recent call last): 
  File "/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/doctest.py", line 1318, in __run 
    compileflags, 1), test.globs) 
  File "<doctest default[0]>", line 4, in <module> 
    raise Error("index problem") from exception 
Error: index problem

```

这显示了一个链接的异常。`Traceback`消息中的第一个异常是`IndexError`异常。这是直接原因。`Traceback`中的第二个异常是我们的通用`Error`异常。这是一个通用的摘要异常，被链接到原始原因。

应用程序将在`try:`语句中看到`Error`异常。我们可能会有这样的情况：

```py

    try: 
        some_function() 
    except Error as exception: 
        print(exception) 
        print(exception .__cause__) 
```

这里我们展示了一个名为`some_function()`的函数，它可以引发通用的`Error`异常。如果此函数确实引发了异常，则`except`子句将匹配通用的`Error`异常。我们可以打印异常的消息`exception`，以及根本原因异常`exception.__cause__`。在许多应用程序中，`exception.__cause__`的值可能会被写入调试日志而不是显示给用户。

## 还有更多...

如果在异常处理程序内部引发异常，这也会创建一种链接的异常关系。这是*上下文*关系而不是*原因*关系。

上下文消息看起来相似。消息略有不同。它说`在处理上述异常时，发生了另一个异常:`。第一个`Traceback`将显示原始异常。第二个消息是抛出异常而不使用显式的 from 连接。

通常，上下文是一些未计划的东西，表明`except`处理块中存在错误。例如，我们可能会有这样的情况：

```py

    try: 
        something 
    except ValueError as exception: 
        print("Some message", exceotuib)
```

这将引发一个带有`ValueError`异常上下文的`NameError`异常。`NameError`异常源自将异常变量拼写为`exceotuib`。

## 另请参阅

+   在*利用异常匹配规则*配方中，我们考虑了一些在设计异常时的注意事项

+   在*使用 except:子句避免潜在问题*配方中，我们考虑了一些在设计异常时的额外注意事项

# 使用`with`语句管理上下文

有许多情况下，我们的脚本会与外部资源纠缠在一起。最常见的例子是磁盘文件和到外部主机的网络连接。一个常见的错误是永远保留这些纠缠，无用地捆绑这些资源。这些有时被称为内存**泄漏**，因为每次打开新文件而不关闭先前使用的文件时，可用内存都会减少。

我们希望隔离每个纠缠，以确保资源被正确获取和释放。想法是创建一个上下文，在其中我们的脚本使用外部资源。在上下文结束时，我们的程序不再绑定到资源，我们希望保证资源被释放。

## 准备工作

假设我们想要将数据行以 CSV 格式写入文件。完成后，我们希望确保文件被关闭，并且各种操作系统资源——包括缓冲区和文件句柄——被释放。我们可以在上下文管理器中实现这一点，这可以保证文件将被正确关闭。

由于我们将使用 CSV 文件，我们可以使用`csv`模块来处理格式的细节：

```py

>>> import csv

```

我们还将使用`pathlib`模块来定位我们将要处理的文件：

```py

>>> import pathlib

```

为了有写入内容，我们将使用这个愚蠢的数据源：

```py

>>> some_source = [[2,3,5], [7,11,13], [17,19,23]]

```

这将为我们提供一个学习`with`语句的上下文。

## 如何做...

1.  通过打开文件或使用`urllib.request.urlopen()`创建网络连接来创建上下文。其他常见的上下文包括`zip`文件和`tar`文件：

```py

        target_path = pathlib.Path('code/test.csv') 
        with target_path.open('w', newline='') as target_file: 

```

1.  包括所有处理，缩进在`with`语句内：

```py

        target_path = pathlib.Path('code/test.csv') 
        with target_path.open('w', newline='') as target_file: 
            writer = csv.writer(target_file) 
            writer.writerow(['column', 'data', 'headings']) 
            for data in some_source: 
                writer.writerow(data) 

```

1.  当我们将文件作为上下文管理器使用时，文件将在缩进的上下文块结束时自动关闭。即使引发异常，文件仍会被正确关闭。将在上下文完成并释放资源后执行的处理内容缩进：

```py

        target_path = pathlib.Path('code/test.csv') 
        with target_path.open('w', newline='') as target_file: 
 
            writer = csv.writer(target_file) 
            writer.writerow(['column', 'headings']) 
            for data in some_source: 
                writer.writerow(data) 
 
        print('finished writing', target_path) 

```

`with`上下文之外的语句将在上下文关闭后执行。命名资源——由`target_path.open()`打开的文件——将被正确关闭。

即使`with`语句内部引发异常，文件仍会被正确关闭。上下文管理器会收到异常通知。它可以关闭文件并允许异常传播。

## 工作原理...

上下文管理器会收到代码块中两种退出的通知：

+   正常退出，没有异常

+   引发了异常

上下文管理器将在所有情况下将我们的程序与外部资源解开。文件可以关闭。网络连接可以断开。数据库事务可以提交或回滚。锁可以释放。

我们可以通过在`with`语句内部包含手动异常来进行实验。这可以显示文件已被正确关闭。

```py

    try: 
        target_path = pathlib.Path('code/test.csv') 
        with target_path.open('w', newline='') as target_file: 
            writer = csv.writer(target_file) 
            writer.writerow(['column', 'headings']) 
            for data in some_source: 
                writer.writerow(data) 
                raise Exception("Just Testing") 
    except Exception as exc: 
        print(target_file.closed) 
        print(exc) 
    print('finished writing', target_path) 


```

在这个例子中，我们将真正的工作包装在`try`语句中。这样我们可以在向 CSV 文件写入第一个后引发异常。当异常被引发时，我们可以打印异常。此时，文件也将被关闭。输出仅为：


```py

    True 
    Just Testing 
    finished writing code/test.csv 

```

这向我们表明文件已经正确关闭。它还向我们显示了与异常相关的消息，以确认它是我们手动引发的异常。输出的`test.csv`文件将只包含`some_source`变量的第一行数据。

## 还有更多...

Python 为我们提供了许多上下文管理器。我们注意到，打开的文件是一个上下文，`urllib.request.urlopen()`创建的打开网络连接也是一个上下文。

对于所有文件操作和所有网络连接，我们应该使用`with`语句作为上下文管理器。很难找到这个规则的例外。

事实证明，`decimal`模块使用上下文管理器来允许对十进制算术执行的方式进行本地化更改。我们可以使用`decimal.localcontext()`函数作为上下文管理器，以更改由`with`语句隔离的计算的舍入规则或精度。

我们也可以定义自己的上下文管理器。`contextlib`模块包含函数和装饰器，可以帮助我们在不明确提供上下文管理器的资源周围创建上下文管理器。

在处理锁时，`with`上下文是获取和释放锁的理想方式。请参阅[`docs.python.org/3/library/threading.html#with-locks`](https://docs.python.org/3/library/threading.html#with-locks)了解由`threading`模块创建的锁对象与上下文管理器之间的关系。

## 另请参阅

+   请参阅[`www.python.org/dev/peps/pep-0343/`](https://www.python.org/dev/peps/pep-0343/)了解 with 语句的起源