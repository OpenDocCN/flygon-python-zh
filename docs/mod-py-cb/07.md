# 七、更高级的类设计

在本章中，我们将介绍以下配方：

*   在继承和扩展之间选择——这是一个问题
*   通过多重继承分离关注点
*   利用 Python 的 duck 类型
*   管理全局对象和单例对象
*   使用更复杂的结构–列表映射
*   创建具有可排序对象的类
*   定义有序集合
*   从映射列表中删除

# 导言

在[第 6 章](06.html#page "Chapter 6. Basics of Classes and Objects")*类和对象的基础*中，我们了解了一些涵盖类设计基础的方法。在本章中，我们将更深入地研究 Python 类。

在[第 6 章](06.html#page "Chapter 6. Basics of Classes and Objects")、*类和对象基础*中的*设计具有大量处理的类*和*使用惰性属性的属性*配方中，我们确定了一个设计选择，即包装与扩展选择，这是面向对象编程的核心。可以通过扩展向类中添加功能，也可以创建一个新类来包装现有类以添加新功能。Python 中有许多可用的扩展技术，提供了许多替代方法。

Python 类可以从多个超类继承特性。这可能会导致混淆，但简单的设计模式**mixin**可以防止出现问题。

更大的应用程序可能需要一些由许多类或模块广泛共享的全局数据。这对管理来说是一个挑战。但是，我们可以使用模块来管理全局对象并创建简单的解决方案。

在[第 4 章](04.html#page "Chapter 4. Built-in Data Structures – list, set, dict")、*内置数据结构–列表、集合、dict*中，我们查看了核心内置数据结构。是时候结合一些功能来创建更复杂的对象了。这还可以包括扩展内置数据结构以增加复杂性。

# 在继承和扩展之间选择——这是一个问题

在[第 5 章](05.html#page "Chapter 5. User Inputs and Outputs")中*使用 cmd 创建命令行应用程序*配方中*用户输入和输出*以及*扩展集合–在[第 6 章](06.html#page "Chapter 6. Basics of Classes and Objects")中统计*配方的列表中*类和对象的基础知识*我们研究了扩展类。在这两种情况下，我们的类都是内置类的子类。

扩展的概念有时被称为泛化-专门化关系。有时也称为**是一种关系**。

这里有一个重要的语义问题，我们也可以总结为**包装与扩展问题**：

*   我们真的是说子类是超类的一个例子吗？这就是 is-a 关系。Python 中的一个例子是内置的`Counter`，它扩展了基类`dict`。
*   或者我们是指别的什么？也许有一种联系，有时被称为**有一种关系**。这方面的一个例子是在[第 6 章](06.html#page "Chapter 6. Basics of Classes and Objects")*类和对象基础*中的*设计具有大量处理的*配方的类，其中`CounterStatistics`包装了一个`Counter`对象。

区分这两种技术的好方法是什么？

## 准备好了吗

这个问题有点形而上学哲学，特别关注于**本体论**的思想。本体是定义存在的类别的一种方式。

扩展对象时，我们必须询问以下问题：

> *“这是一个新的对象类，还是现有对象类的混合体？”*

我们将研究两种建模扑克牌组的方法：

*   作为扩展内置`list`类的新对象类
*   作为一个将内置`list`类与其他一些功能结合在一起的包装器

一副牌是一组牌。因此，核心成分是潜在的`Card`对象。我们将使用`namedtuple()`非常简单地定义这一点：

```py
>>> from collections import namedtuple 
>>> Card = namedtuple('Card', ('rank', 'suit')) 
>>> SUITS = '\u2660\u2661\u2662\u2663' 
>>> Spades, Hearts, Diamonds, Clubs = SUITS 
>>> Card(2, Spades) 
Card(rank=2, suit='♣')

```

我们已经使用`namedtuple()`创建了类定义`Card`。这将创建一个具有两个属性的简单类-`rank`和`suit`。

我们还将各种套装`SUITS`定义为 Unicode 字符字符串。为了更容易地创建特定套装的卡片，我们还将字符串分解为四个单独的单字符子字符串。如果交互式环境不能正确显示 Unicode 字符，则可能会遇到问题。可能需要将 OS 环境变量`PYTHONIOENCODING`更改为`UTF-8,`，以便正确编码。

`\u2660`字符串是单个 Unicode 字符。您可以通过`len(SUITS) == 4`确认。如果长度不是 4，请检查是否有多余的空格。

我们将在本食谱的其余部分使用这个`Card`类。在一些纸牌游戏中，使用一副 52 张的牌。在其他游戏中，使用交易鞋。鞋子是一个盒子，允许经销商将多张牌组合在一起，方便交易。

重要的是，各种收集平台、鞋子和内置列表在支持的功能种类上都有相当大的重叠。它们都或多或少有关联吗？或者，它们从根本上是不同的？

## 怎么做。。。

我们将在[第 6 章](06.html#page "Chapter 6. Basics of Classes and Objects")中*类和对象的基础*中使用类封装数据和处理的*配方包装如下：*

1.  使用原始故事或问题陈述中的名词和动词来识别所有类别。
2.  查找不同类的特征集中的重叠。在许多情况下，关系将直接来自问题陈述本身。在前面的示例中，游戏可以从一副牌中发牌，也可以从一只鞋中发牌。在这种情况下，我们可以陈述以下两种观点之一：
    *   鞋是一种特殊的牌组，从 52 卡域的多个副本开始
    *   一副牌是一种专门的鞋子，只有 52 张牌域的一个副本
3.  Create a small ontology that clarifies the relationships among the classes. There are several kinds of relationships.

    有些类彼此独立。它们是为了实现用户故事而链接的。在我们的例子中，`Card`指的是西装的一根线。这两个对象相互独立。许多卡片将共享一个共同的花色串。这些是对象之间的普通参照，没有特殊的设计考虑：

    *   **聚合**：一些对象绑定到集合中，但这些对象具有适当的独立存在性。我们的`Card`对象可能聚合为`Hand`集合。游戏结束后，可以删除`Hand`对象，但`Card`对象仍然存在。我们可以创建一个`Deck`来引用内置的`list`。
    *   **组合**：有些对象绑定到集合中，但没有独立的存在。在看纸牌游戏时，如果没有`Player`，就不可能有`Hand`张纸牌。我们可以说，`Player`对象是由`Hand`的一部分组成的。如果一个`Player`被从游戏中删除，那么`Hand`对象也必须被删除。虽然这对于理解对象之间的关系很重要，但我们将在下一节中介绍一些实际注意事项。
    *   **是-a 或继承**：这是一种观点，即`Shoe`是一个`Deck`，具有一个（或两个）额外特征。这可能是我们设计的核心。我们将在本配方的*扩展-继承*部分详细介绍这一点。

我们已经确定了几个实现关联的路径。聚合和组合案例都是包装技术。继承案例是 extend 技术。我们将分别研究包装技术和扩展技术的聚合和组合。

### 包装-聚合和合成

包装是理解收藏的一种方式。它可以是一个由独立对象聚合而成的类。它也是一个包装现有列表的组合，这意味着基础`Card`对象将由`list`集合和`Deck`集合共享。

1.  定义独立集合。它可能是一个内置集合，例如，`set`、`list`或`dict`。在本例中，它将是一个包含卡片的列表：

    ```py
            domain = [Card(r+1,s) for r in range(13) for s in SUITS] 

    ```

2.  定义聚合类。在本例中，名称有一个`_W`后缀。这不是推荐的做法；这里使用它只是为了使类定义之间的区别更加清楚。稍后，我们将看到此设计的一个稍微不同的变体：

    ```py
            class Deck_W: 

    ```

3.  Use the `__init__()` method of this class as one way to provide the underlying collection object. This will also initialize any stateful variables. We might create an iterator for dealing:

    ```py
            def __init__(self, cards:List[Card]): 
                self.cards = cards.copy() 
                self.deal_iter = iter(cards) 

    ```

    这使用了一个类型提示`List[Card]`。`typing`模块提供了`List`的必要定义。

4.  如果需要，提供其他方法来替换集合或更新集合。这在 Python 中很少见，因为可以直接访问底层属性`cards`。但是，提供一种替代`self.cards`值的方法可能会有所帮助。
5.  Provide the methods appropriate to the aggregate object:

    ```py
            def shuffle(self): 
                random.shuffle(self.cards) 
                self.deal_iter = iter(self.cards) 
            def deal(self) -> Card: 
                return next(self.deal_iter) 

    ```

    `shuffle()`方法将内部列表对象`self.cards`随机化。`deal()`对象创建一个迭代器，可用于单步遍历`self.cards`列表。我们在`deal()`上提供了一个类型提示，以澄清它返回一个`Card`实例。

下面是我们如何使用这个类。我们将共享一个`Card`对象列表。在本例中，`domain`变量是从列表理解中创建的，该列表理解生成了 13 个等级和 4 套西装的所有 52 种组合：

```py
>>> domain = list(Card(r+1,s) for r in range(13) for s in SUITS) 
>>> len(domain) 
52

```

我们可以使用此集合中的项`domain`来创建第二个聚合对象，该对象共享相同的基础`Card`对象。我们将从`domain`变量中的对象列表中构建`Deck_W`对象：

```py
>>> import random 
>>> from ch07_r01 import Deck_W 
>>> d = Deck_W(domain)

```

一旦`Deck_W`对象可用，就可以使用独特的功能：

```py
>>> random.seed(1) 
>>> d.shuffle() 
>>> [d.deal() for _ in range(5)]  
[Card(rank=13, suit='♡'), 
Card(rank=3, suit='♡'), 
Card(rank=10, suit='♡'), 
Card(rank=6, suit='♢'), 
Card(rank=1, suit='♢')]

```

我们已经在随机数生成器中植入种子，以强制卡片具有定义的顺序。这使得单元测试成为可能。之后，我们根据随机种子将牌组洗牌成一个顺序。一旦播种，结果是一致的，使得单元测试变得容易。我们可以从牌组中发五张牌。这显示了`Deck_W`对象`d`如何与`domain`列表共享相同的对象池。

我们可以删除`Deck_W`对象`d`，并从`domain`列表中创建一个新的牌组。这是因为`Card`对象不是合成的一部分。这些卡片独立于`Deck_W`系列。

### 扩展-继承

下面是一种定义扩展对象集合的类的方法。我们将`Deck`定义为包装现有列表的聚合。基础`Card`对象将由列表和`Deck`共享：

1.  Define the extension class as a subclass of a built-in collection. For this example, the name has a `_X` suffix. This not a recommended practice; it's only used here to make the distinctions between two class definitions in this recipe more clear:

    ```py
            class Deck_X(list): 

    ```

    这是一个明确而正式的声明——a`Deck`是一个列表。

2.  使用继承自`list`类的`__init__()`方法。不需要代码。
3.  使用`list`类的其他方法添加、更改或删除`Deck`中的项目。不需要代码。
4.  Provide the appropriate methods to the extended object:

    ```py
            def shuffle(self): 
                random.shuffle(self) 
                self.deal_iter = iter(self) 
            def deal(self) -> Card: 
                return next(self.deal_iter) 

    ```

    `shuffle()`方法将对象作为一个整体进行随机化`self`，因为它是列表的扩展。`deal()`对象创建一个迭代器，可用于单步遍历`self.cards`列表。我们在`deal()`上提供了一个类型提示，以澄清它返回一个`Card`实例。

下面是我们如何使用这个类。首先，我们将构建一副牌：

```py
>>> from ch07_r01 import Deck_X 
>>> d2 = Deck_X(Card(r+1,s) for r in range(13) for s in SUITS) 
>>> len(d2) 
52

```

我们使用生成器表达式来构建单个`Card`对象。我们可以像使用`list()`类函数一样使用`Deck_X()`类函数。在本例中，我们从生成器表达式构建了一个`Deck_X`对象。我们可以建立一个类似的`list`。

我们没有为内置的`__len__()`方法提供实现。这是从`list`类继承而来的，并且工作得很好。

为此实现使用特定于数据组的功能与其他实现完全相同，`Deck_W`：

```py
>>> random.seed(1) 
>>> d2.shuffle() 
>>> [d2.deal() for _ in range(5)]  
[Card(rank=13, suit='♡'), 
Card(rank=3, suit='♡'), 
Card(rank=10, suit='♡'), 
Card(rank=6, suit='♢'), 
Card(rank=1, suit='♢')]

```

我们已经为随机数生成器添加种子，洗牌，并发了五张牌。扩展方法对于`Deck_X`和`Deck_W`同样有效。`shuffle()`和`deal()`方法完成了它们的工作。

## 它是如何工作的。。。

Python 查找方法（或属性）的机制如下：

1.  在类中搜索方法或属性。
2.  如果未在立即类中定义名称，则在所有父类中搜索该方法或属性。

这就是 Python 实现继承思想的方式。搜索父类可以确保两件事：

*   任何超类中定义的任何方法都可用于所有子类
*   任何子类都可以重写方法来替换超类方法

因此，`list`类的子类继承父类的所有特性。它是内置`list`类的特殊变体。

这也意味着所有方法都有可能被子类重写。有些语言有方法锁定方法以防止扩展。单词 T0T.Type 被诸如 C++和 java 语言使用。Python 没有这个功能，子类可以重写任何方法。

为了明确引用超类中的方法，我们可以使用`super()`函数强制搜索超类。这允许子类通过包装方法的超类版本来添加特性。我们这样使用它：

```py
    def some_method(self): 
        # do something extra 
        super().some_method() 

```

在这种情况下，`some_method()`对象将执行一些额外的操作，然后执行该方法的超类版本。这使我们能够方便地扩展类的选定方法。我们可以保留超类特性，同时添加子类特有的特性。

## 还有更多。。。

在设计类时，我们必须在以下几种基本技术中进行选择：

*   **包装**：此技术创建一个新类。必须定义所有必需的方法。这可以为很多代码提供所需的方法。包装可以分解为两种广泛的实现选择：
    *   **聚合**：被包装的对象与包装器独立存在。`Deck_W`示例展示了`Card`对象甚至卡片列表是如何独立于类的。当删除任何`Deck_W`对象时，基础列表将继续存在。
    *   **构成**：被包裹的物体没有独立存在；它们是这篇文章的重要组成部分。这涉及到一个微妙的困难，因为 Python 的引用计数。我们将很快详细了解这一点。
*   **继承扩展**：这是 is-a 关系。扩展内置类时，超类中有很多方法可用。`Deck_X`示例通过创建一个 deck 作为内置`list`类的扩展来展示这种技术。

在研究对象的独立存在时，有一个重要的考虑因素。我们并没有真正从内存中删除对象。相反，Python 使用一种称为引用计数的技术来跟踪对象的使用次数。像`del deck`这样的语句并没有真正删除`deck`对象，而是删除了`deck`变量，这会减少底层对象的引用计数。如果引用计数为零，则不使用该对象，可以将其删除。

考虑下面的例子：

```py
>>> c_2s = Card(2, Spades) 
>>> c_2s 
Card(rank=2, suit='♠') 
>>> another = c_2s 
>>> another 
Card(rank=2, suit='♠')

```

在这一点上，我们有一个对象，`Card(2, Spades)`和两个引用该对象的变量-`c_2s`和`another`。

如果我们用`del`语句删除其中一个变量，那么另一个变量仍然具有对底层对象的引用。在删除两个变量之前，无法从内存中删除对象。

这种考虑使得聚合和组合之间的区别对于 Python 程序员来说几乎无关紧要。在不使用自动垃圾收集或引用计数器的语言中，合成变得很重要，因为对象可能会消失。在 Python 中，对象不能意外消失。我们通常关注聚合，因为删除未使用的对象是完全自动的。

## 另见

*   我们已经查看了[第 4 章](04.html#page "Chapter 4. Built-in Data Structures – list, set, dict")、*内置数据结构中的内置集合–列表、集合、dict*。此外，在[第 6 章](06.html#page "Chapter 6. Basics of Classes and Objects")、*类和对象基础*中，我们了解了如何定义简单集合。
*   在*设计具有大量处理的类*配方中，我们考虑了用一个单独的类包装一个类，该类处理处理处理细节。我们可以将此与[第 6 章](06.html#page "Chapter 6. Basics of Classes and Objects")的*使用惰性属性*配方*类和对象的基础*进行对比，我们将复杂的计算作为属性放入类中；这种设计依赖于扩展。

# 通过多重继承分离关注点

在*继承和扩展之间的选择——is-a 问题*配方中，我们考虑了定义一个由扑克牌对象组成的`Deck`类的想法。出于该示例的目的，我们将每个`Card`对象视为具有一个等级和一套衣服。这造成了一些小问题：

*   卡片的显示屏始终显示数字等级。我们没有看到 J、Q 或 K，而是看到了 11、12 和 13。同样，Ace 显示为 1 而不是 A。
*   许多游戏，如*二十一点*和*克里贝奇*为每个等级分配一个分值。一般来说，脸牌有 10 分。对于 21 点，Ace 有两个不同的点值；根据手中其他牌的总数，它可能值一分或十分。

我们如何处理纸牌游戏规则中的所有变化？

## 准备好了吗

`Card`类实际上是两个功能集的混合体：

1.  一些基本特征，如等级和西装。
2.  一些游戏特有的功能，比如点数。对于像*克里贝奇*这样的游戏，无论什么情况，分数都是一致的。然而，对于*二十一点*，在`Hand`和`Hand`中的`Card`对象之间存在关系。

Python 允许我们定义一个具有多个父类的类。一个类可以同时具有`Card`超类和`GameRules`超类。

为了理解这种设计，我们通常将各种类层次结构划分为两组功能：

*   **基本特征**：包括`rank`和`suit`
*   **混入特性**：这些特性被混入类定义中

其想法是，工人阶级的定义将同时具有基本和混合特征。

## 怎么做。。。

1.  Define the essential class:

    ```py
            class Card: 
                __slots__ = ('rank', 'suit') 
                def __init__(self, rank, suit): 
                    super().__init__() 
                    self.rank = rank 
                    self.suit = suit 
                def __repr__(self): 
                    return "{rank:2d} {suit}".format( 
                        rank=self.rank, suit=self.suit 
                    ) 

    ```

    我们已经定义了一个通用的`Card`类，它适用于等级 2 到 10。我们通过`super().__init__()`包含了对任何超类初始化的显式调用。

2.  Define any subclasses to handle specializations:

    ```py
            class AceCard(Card): 
                def __repr__(self): 
                    return " A {suit}".format( 
                        rank=self.rank, suit=self.suit 
                    ) 
            class FaceCard(Card): 
                def __repr__(self): 
                    names = {11: 'J', 12: 'Q', 13: 'K'} 
                    return " {name} {suit}".format( 
                        rank=self.rank, suit=self.suit, 
                        name=names[self.rank] 
                    ) 

    ```

    我们已经定义了`Card`类的两个子类。`AceCard`类处理 Ace 的特殊格式规则。`FaceCard`类处理 Jack、Queen 和 King 的其他格式规则。

3.  Define a mixin superclass that identifies the additional features that will be added. In some cases, the mixins will all inherit features from a common abstract class. In this example, we'll use a concrete class that handles the rules for Ace through 10:

    ```py
            class CribbagePoints: 
                def points(self): 
                    return self.rank 

    ```

    对于*克里贝奇*的游戏，大多数牌的点数等于该牌的等级。

4.  Define concrete mixin subclasses for the various kinds of features:

    ```py
            class CribbageFacePoints(CribbagePoints): 
                def points(self): 
                    return 10 

    ```

    对于三级脸牌，积分始终为 10。

5.  创建组合基本类和 mixin 类的类定义。虽然在技术上可以在这里添加独特的方法定义，但这通常会导致混淆。目标是拥有两组单独的功能，这些功能可以简单地合并以创建结果类定义。

    ```py
            class CribbageAce(AceCard, CribbagePoints): 
                pass 

            class CribbageCard(Card, CribbagePoints): 
                pass 

            class CribbageFace(FaceCard, CribbageFacePoints): 
                pass 

    ```

6.  创建工厂函数（或工厂类），根据输入参数创建适当的对象：

    ```py
            def make_card(rank, suit): 
                if rank == 1: return CribbageAce(rank, suit) 
                if 2 <= rank < 11: return CribbageCard(rank, suit) 
                if 11 <= rank: return CribbageFace(rank, suit) 

    ```

7.  We can use this function to create a deck of cards like this:

    ```py
     >>> from ch07_r02 import make_card, SUITS 
          >>> import random 
          >>> random.seed(1) 
          >>> deck = [make_card(rank+1, suit) for rank in range(13) for suit in SUITS] 
          >>> random.shuffle(deck) 
          >>> len(deck) 
          52 
          >>> deck[:5] 
          [ K ♡,  3 ♡, 10 ♡,  6 ♢,  A ♢]

    ```

    我们在随机数生成器中植入种子，以确保每次评估`shuffle()`函数时的结果都是相同的。这使得单元测试成为可能。

    我们使用列表理解生成一个包含所有 13 个等级和 4 套西装的卡片列表。这是 52 个单独对象的集合。这些对象属于两个类层次结构。每个对象都是`Card`的子类，也是`CribbagePoints`的子类。这意味着这两个要素集合可用于所有对象。

    例如，我们可以评估每个`Card`对象的`points()`方法：

    ```py
     >>> sum(c.points() for c in deck[:5]) 
          30 

    ```

    该手牌有两张脸牌，加上三张、六张和 A，因此总分为`30`。

## 它是如何工作的。。。

Python 查找方法（或属性）的机制如下：

1.  在类中搜索方法或属性。
2.  如果未在立即类中定义名称，则在所有父类中搜索该方法或属性。父类按适当调用的顺序进行搜索，**方法解析顺序**（**MRO**）。

方法的解析顺序是在创建类时计算的。使用的算法称为 C3。更多信息请访问[https://en.wikipedia.org/wiki/C3_linearization](https://en.wikipedia.org/wiki/C3_linearization) 。该算法确保每个父类搜索一次。它还确保保留了超类的相对顺序，以便在搜索任何父类之前搜索所有子类。

我们可以使用类的`mro()`方法查看方法解析顺序。下面是一个例子：

```py
>>> c = deck[5] 
>>> c 
10 ♢ 
>>> c.__class__.__name__ 
'CribbageCard' 
>>> c.__class__.mro()  
[<class 'ch07_r02.CribbageCard'>, <class 'ch07_r02.Card'>, 
<class 'ch07_r02.CribbagePoints'>, <class 'object'>]

```

我们从牌堆里选了一张牌，`c`。卡片的`__class__`属性是对类的引用。在本例中，类名为`CribbageCard`。此类的`mro()`方法向我们显示用于解析名称的顺序：

1.  首先搜索类本身，`CribbageCard`。
2.  如果不存在，则搜索`Card`。
3.  试着在`CribbagePoints`下一页找到它。
4.  最后使用`object`。

类定义通常使用内部`dict`对象来存储方法定义。这意味着搜索是一种非常快速的哈希查找。开销差异是搜索`object`的时间比搜索`Card`的时间多 3%（当在前面的任何类中都找不到某个内容时）。

如果我们进行 100 万次操作，我们会看到如下数字：

```py
    Card.__repr__ 1.4413
    object.__str__ 1.4789

```

我们比较了在`Card`中定义的找到`__repr__()`的时间与在`object`中定义的找到`__str__()`的时间。超过一百万次重复的额外时间总和为 0.03 秒。

由于成本可以忽略不计，因此此功能是构建类层次结构设计的重要方法。

## 还有更多。。。

有几种关注点，我们可以这样分开：

*   **状态的持久性和表示**：我们可以添加方法来管理转换到一致的外部表示。
*   **安全**：这可能涉及一个 mixin 类，该类执行一致授权检查，该检查成为每个对象的一部分。
*   **日志记录**：可以定义一个 mixin 类，该类创建一个跨各种类一致的记录器。
*   **事件信令和更改通知**：在这种情况下，我们可能有生成状态更改通知的对象和订阅这些通知的对象。这些有时被称为可观察和观察者设计模式。GUI 小部件可以观察对象的状态；当对象更改时，它会通知 GUI 小部件，以便刷新显示。

作为一个小例子，我们可以添加一个 mixin 来引入日志记录。我们将定义这个类，以便在超类列表中首先提供它。由于它位于 MRO 列表的早期，`super()`函数将查找稍后在类列表中定义的方法。

此类将向每个类添加`logger`属性：

```py
    class Logged: 
        def __init__(self, *args, **kw): 
            self.logger = logging.getLogger(self.__class__.__name__) 
            super().__init__(*args, **kw) 
        def points(self): 
            p = super().points() 
            self.logger.debug("points {0}".format(p)) 
            return p 

```

注意，我们使用了`super().__init__()`来执行 MRO 中定义的任何其他类的`__init__()`方法。正如我们刚才提到的，通常最简单的方法是让一个类定义一个对象的基本特性，而所有其他的 mixin 只是向该对象添加特性。

我们已经为`points()`提供了一个定义。这将在 MRO 列表中搜索其他类以实现`points()`。然后，它将记录该方法从另一个类计算的结果。

以下是一些包含`Logged`mixin 功能的类：

```py
    class LoggedCribbageAce(Logged, AceCard, CribbagePoints): 
        pass 
    class LoggedCribbageCard(Logged, Card, CribbagePoints): 
        pass 
    class LoggedCribbageFace(Logged, FaceCard, CribbageFacePoints): 
        pass 

```

这些类中的每一个都是从三个独立的类定义中构建的。因为`Logged`类是首先提供的，所以我们保证所有类都有一致的日志记录。我们还确信，`Logged`中的任何方法都可以使用`super()`在类定义中紧随其后的超类列表中定位实现。

为了利用这些类，我们需要对应用程序进行一个小小的更改：

```py
    def make_logged_card(rank, suit): 
        if rank == 1: return LoggedCribbageAce(rank, suit) 
        if 2 <= rank < 11: return LoggedCribbageCard(rank, suit) 
        if 11 <= rank: return LoggedCribbageFace(rank, suit) 

```

我们需要使用此函数而不是`make_card()`。此函数将使用另一组类定义。

下面是我们如何使用此函数构建一组卡片实例：

```py
    deck = [make_logged_card(rank+1, suit) 
        for rank in range(13) 
            for suit in SUITS] 

```

在创建甲板时，我们将`make_card()`替换为`make_logged_card()`。一旦我们这样做了，我们现在就可以以一致的方式从许多类中获得详细的调试信息。

## 另见

*   当考虑多重继承时，总是考虑包装是否是更好的设计是必不可少的。请参阅*在继承和扩展之间的选择–is-a 问题*配方。

# 利用 Python 的 duck 类型

大多数时候，一个设计涉及到继承，从一个超类到一个或多个子类之间存在着明确的关系。在*继承和扩展之间的选择——本章的 is-a 问题*配方以及[第 6 章](06.html#page "Chapter 6. Basics of Classes and Objects")中的*类和对象基础*中的*扩展集合——统计*配方的列表中，我们已经研究了涉及适当的子类-超类关系的扩展。

Python 没有抽象超类的正式机制。然而，标准库具有支持创建抽象类的`abc`模块。

然而，这并不总是必要的。Python 依靠 duck 类型在类中定位方法。此名称来自以下引用：

> *“当我看到一只像鸭子一样走路、像鸭子一样游泳、像鸭子一样呱呱叫的鸟时，我叫它鸭子。”*

这句话最初出自詹姆斯·惠特科姆·赖利之手。它有时被看作是**诱因推理**的总结：我们从一个观察到一个更完整的理论，包括这个观察。在 Python 类关系的情况下，如果两个对象具有相同的方法和相同的属性，则这与具有公共超类的效果相同。即使除了`object`类之外没有通用的超类定义，它也可以工作。

我们可以将方法和属性的集合称为类的签名。签名唯一地标识类的属性和行为。在 Python 中，签名是动态的，匹配只需在对象的名称空间中查找名称即可。

我们能利用这个吗？

## 准备好了吗

创建一个超类并确保所有子类都扩展这个类通常很容易。但在某些情况下，这可能会很尴尬。例如，如果一个应用程序分布在多个模块中，那么找出一个公共超类并将其单独放在一个单独的模块中以使其能够被广泛地包含可能是一个挑战。

相反，有时更容易避免使用一个公共的超类，并使用 duck 测试简单地检查两个类是否都是等效的。这两个类具有相同的方法和属性，因此，它们实际上是某些超类的成员，而这些超类没有像 Python 代码那样的正式实现。

我们将使用一对简单的类来展示它是如何工作的。这些类都将模拟掷骰子。虽然问题很简单，但我们可以轻松创建各种实现。

## 怎么做。。。

1.  使用所需的方法和属性定义一个类。在本例中，我们将有一个属性`dice`，用于保留最后一次掷骰的结果，还有一个方法`roll()`，用于更改骰子的状态：

    ```py
            class Dice1: 
                def __init__(self, seed=None): 
                    self._rng = random.Random(seed) 
                    self.roll() 
                def roll(self): 
                    self.dice = (self._rng.randint(1,6), 
                        self._rng.randint(1,6)) 
                    return self.dice 

    ```

2.  Define other classes that have the same methods and attributes. Here's a somewhat more complex definition that creates a class that has the same signature as the `Dice1` class:

    ```py
            class Die: 
                def __init__(self, rng): 
                    self._rng= rng 
                def roll(self): 
                    return self._rng.randint(1, 6) 
            class Dice2: 
                def __init__(self, seed=None): 
                    self._rng = random.Random(seed) 
                    self._dice = [Die(self._rng) for _ in range(2)] 
                    self.roll() 
                def roll(self): 
                    self.dice = tuple(d.roll() for d in self._dice) 
                    return self.dice 

    ```

    此类引入了一个附加属性`_dice`。实现中的此更改不会更改单个属性`dice`和方法`roll()`的公布接口。

此时，两个等级可以自由互换：

```py
    def roller(dice_class, seed=None, *, samples=10): 
        dice = dice_class(seed) 
        for _ in range(samples): 
            yield dice.roll() 

```

我们可以按如下方式使用此功能：

```py
>>> from ch07_r03 import roller, Dice1, Dice2 
>>> list(roller(Dice1, 1, samples=5)) 
[(1, 3), (1, 4), (4, 4), (6, 4), (2, 1)] 
>>> list(roller(Dice2, 1, samples=5)) 
[(1, 3), (1, 4), (4, 4), (6, 4), (2, 1)]

```

从`Dice1`和`Dice2`构建的对象具有足够的相似性，因此无法区分。

当然，我们可以按下信封并查找`_dice`属性，以此区分这两个类。我们还可以使用`__class__`来区分这些类。

## 它是如何工作的。。。

当我们编写一个形式为`namespace.name`的表达式时，Python 将在给定的名称空间中查找该名称。算法的工作原理如下：

1.  在对象的`self.__dict__`集合中搜索名称。某些类定义将使用`__slots__`节省空间。有关此优化的更多信息，请参见[第 6 章](06.html#page "Chapter 6. Basics of Classes and Objects")、*类和对象基础*中的*使用【Uuuuuuuuuu 插槽】优化小对象*配方。这通常是如何找到属性值的。
2.  在对象的`self.__class__.__dict__`集合中搜索名称。这通常是找到方法的方式。
3.  正如我们在*继承和扩展之间的选择——is-a 问题*和*中所指出的，通过多重继承*方法分离关注点，搜索可以在类的所有超类中继续进行。此搜索按定义的方法解析顺序进行。

有两个基本结果：

*   该值是不可调用的对象。这就是价值。这是典型的属性。
*   属性的值是类的绑定方法。普通方法和属性都是如此。有关属性的更多信息，请参见[第 6 章](06.html#page "Chapter 6. Basics of Classes and Objects")、*类和对象基础*中的*使用惰性属性*配方。必须计算绑定方法。对于简单方法，参数位于方法名称后的`()`中。对于属性，没有带方法参数值的`()`。

### 注

我们省略了一些关于如何使用描述符的细节。对于最常见的用例，描述符的存在并不重要。

其实质是通过`__dict__`（或`__slots__`名称集合进行搜索。如果对象有一个公共超类，那么我们可以保证找到匹配的名称。如果对象没有公共超类，那么我们就没有相同的保证。我们必须依靠严格的设计和良好的测试覆盖率。

## 还有更多。。。

当我们查看`decimal`模块时，我们会看到一个与所有其他数值类型不同的数值类型示例。为了更好地解决这个问题，`numbers`模块包含了将类注册为`Number`类层次结构的一部分的概念。这将在不使用继承的情况下向层次结构中注入一个新类。

`codecs`模块使用类似的技术添加新的数据编码。我们可以定义一个新的编码并注册它，而无需使用`codecs`模块中定义的任何类。

之前，我们注意到搜索类的方法涉及描述符的概念。在内部，Python 使用描述符对象创建对象的可获取和可设置属性。

描述符对象必须实现特殊方法`__get__`、`__set__`和`__delete__`的某种组合。当属性出现在表达式中时，将使用`__get__`定位该值。当属性出现在赋值的左侧时，则使用`__set__`。在`del`语句中，使用`__delete__`方法。

描述符对象充当中介，因此可以在各种上下文中使用简单属性。直接使用描述符是很少见的。我们可以使用`@property`装饰器为我们构建描述符。

## 另见

*   鸭型问题隐含在*在继承和扩展之间的选择——is-a 问题*配方中；如果我们利用 duck 类型，我们也会声称两个类不是一回事。当我们绕过继承时，我们隐式地声称 is-a 关系不成立。
*   在研究*通过多重继承*分离关注点的方法时，我们还能够利用 duck 类型创建可能没有简单继承层次结构的复合类。因为使用 mixin 设计模式非常简单，所以很少需要 duck 类型。

# 管理全局和单例对象

Python 环境包含许多隐式全局对象。这些对象提供了使用其他对象集合的方便方法。因为集合是隐式的，所以我们避免了显式初始化代码的麻烦。

一个例子是一个隐式随机数生成对象，它是`random`模块的一部分。当我们评估`random.random()`时，我们实际上是在使用`random.Random`类的一个实例，它是`random`模块的一个隐式部分。

这方面的其他例子包括：

*   可用数字类型的集合。默认情况下，我们只有`int`、`float`和`complex`。但是，我们可以添加更多的数字类型，它们将与现有类型无缝配合。有一个可用数字类型的全局注册表。
*   数据编码/解码方法（编解码器）的集合可用。`codecs`模块列出了可用的编码器和解码器。这还涉及隐式注册表。我们可以将编码和解码添加到此注册表。
*   `webbrowser`模块具有已知浏览器的注册表。在大多数情况下，操作系统默认浏览器是用户首选的浏览器，也是正确使用的浏览器，但应用程序也可以启动用户首选浏览器以外的浏览器。还可以注册一个应用程序特有的新浏览器。

我们如何处理这种隐式全局对象？

## 准备好了吗

通常，隐式对象会引起一些混淆。其思想是提供一套功能作为单独的功能，而不是对象的方法。然而，好处是允许独立模块共享一个公共对象，而无需编写任何代码来明确协调模块之间的关系。

作为一个简单的例子，我们将定义一个具有全局单例对象的模块。我们将在[第 13 章](13.html#page "Chapter 13. Application Integration")、*应用集成*中了解更多模块。

我们的全局对象将是一个计数器，我们可以使用它从几个独立的模块或对象中积累集中的数据。我们将使用简单函数提供此对象的接口。

目标是能够写出如下内容：

```py
    for row in source: 
        count('input') 
        some_processing() 
    print(counts()) 

```

这意味着将引用全局计数器的两个函数：

*   `count()`：递增计数器并返回当前值
*   `counts()`：它将提供所有各种计数器值

## 怎么做。。。

有两种方法可以处理全局状态信息。一种技术使用模块全局变量，因为模块是单例对象。另一个使用类级别（静态）变量，因为类定义是单例对象，我们也将展示这两种技术。

### 模块全局变量

1.  创建一个模块文件。这将是一个包含定义的`.py`文件。我们称之为`counter.py`。
2.  If necessary, define a class for the global singleton. In our case, we can use this definition:

    ```py
            from collections import Counter 

    ```

    在某些情况下，可能会使用`types.SimpleNamespace`。在其他情况下，可能需要具有方法和属性的更复杂的类。

3.  Define the one and only instance of the global singleton object:

    ```py
            _global_counter = Counter() 

    ```

    我们在名称中使用了一个前导`_`，使其稍微不那么显眼。严格来说，这不是私人的。然而，许多 Python 工具和实用程序都很自然地忽略了它。

4.  Define any wrapper functions:

    ```py
            def count(key, increment=1): 
                _global_counter[key] += increment 
            def counts(): 
                return _global_counter.most_common() 

    ```

    我们定义了两个使用全局对象`_global_counter`的函数。这些函数封装了计数器如何实现的细节。

现在我们可以在各种地方编写使用`count()`函数的应用程序。但是，计数的事件完全集中在这个对象中。

我们可能有如下代码：

```py
>>> from ch07_r04 import count, counts 
>>> from ch07_r03 import Dice1 
>>> d = Dice1(1) 
>>> for _ in range(1000): 
...     if sum(d.roll()) == 7: count('seven') 
...     else: count('other') 
>>> print(counts()) 
[('other', 833), ('seven', 167)]

```

我们已经从中央模块导入了`count()`和`counts()`函数。我们还导入了`Dice1`对象作为一个方便的对象，可以用来创建一系列事件。当我们创建一个`Dice1`实例时，我们提供一个初始化来强制特定的随机种子。这会产生可重复的结果。

然后我们可以使用对象`d`来创建随机事件。在本演示中，我们将事件分为两个简单的桶，分别标记为`seven`和`other`。`count()`函数使用一个隐含的全局对象。

模拟完成后，我们可以使用`counts()`函数转储结果。这将访问模块中定义的全局对象。

这种技术的好处是多个模块都可以共享`ch07_r04`模块中的全局对象。所需要的只是一份`import`声明。无需进一步协调或管理费用。

### 类级静态变量

1.  Define a class and provide a variable outside the `__init__` method. This variable is part of the class, not part of each individual instance. It's shared by all instances of the class:

    ```py
            from collections import Counter 
            class EventCounter: 
                _counts = Counter() 

    ```

    我们给了类级别变量一个前导下划线，以减少它的公开性。任何使用该类的人都要注意，该属性是一个可能会更改的实现细节。它不是类的可见接口的一部分。

2.  Add methods to update and extract data from this variable:

    ```py
            def count(self, key, increment=1): 
                EventCounter._counts[key] += increment 
            def counts(self): 
                return EventCounter._counts.most_common() 

    ```

    在本例中，我们没有使用`self`来强调变量赋值和实例变量。当我们在赋值语句的右侧使用`self.name`时，名称可能由对象、类或任何超类解析。这是搜索类的一般规则。

    当我们在赋值的左侧使用`self.name`时，将创建一个实例变量。我们必须使用`Class.name`来确保更新类级别变量，而不是创建实例变量。

各种应用程序组件可以创建对象，但所有对象都共享一个通用的类级别值：

```py
>>> from ch07_r04 import EventCounter 
>>> c1 = EventCounter() 
>>> c1.count('input') 
>>> c2 = EventCounter() 
>>> c2.count('input') 
>>> c3 = EventCounter() 
>>> c3.counts() 
[('input', 2)] 

```

在本例中，我们创建了三个单独的对象，`c1`、`c2`和`c3`。由于这三个变量共享一个在`EventCounter`类中定义的公共变量，因此每个变量都可以用于增加该共享变量。这些对象可以是单独模块、单独类或单独函数的一部分，但仍然共享一个公共全局状态。

## 它是如何工作的。。。

Python 导入机制使用`sys.modules`跟踪加载了哪些模块。一旦模块在此映射中，就不会再次加载它。这意味着模块中定义的任何变量都将是单例变量：只有一个实例。

我们有两种方法来共享这些类型的全局单例变量：

*   显式地使用模块名。我们可以简单地在模块中创建一个`Counter`实例，并通过`counter.counter`进行共享。这是可行的，但它暴露了一个实现细节。
*   使用包装函数，如本配方所示。这需要更多的代码，但它允许在不破坏应用程序其他部分的情况下更改实现。

这些函数提供了一种识别全局变量相关特性的方法，同时封装了如何实现该变量的详细信息。这使我们有自由考虑改变实施细节的自由。只要包装器函数具有相同的语义，就可以自由更改实现。

由于我们通常只提供一个类的定义，Python 导入机制倾向于确保类定义是一个合适的单例对象。如果我们错误地复制了一个类定义，并将其粘贴到单个应用程序使用的两个或多个模块中，我们将不会在这些类定义之间共享一个全局对象。这是一个容易避免的错误。

我们如何在这两种机制之间做出选择？选择基于多个类共享一个全局状态所造成的混乱程度。如前一个示例所示，三个变量共享一个共同的`Counter`对象。隐式共享全局状态的存在可能令人困惑。

## 还有更多。。。

共享全局状态在某种程度上与面向对象编程相反。面向对象编程的一个理想是封装单个对象中的所有状态更改。当我们拥有一个共同的全球国家时，我们偏离了这一理想：

*   使用包装器函数使共享对象隐式
*   使用类级别变量隐藏了对象是共享的事实

当然，另一种方法是显式创建全局对象，并以某种更明显的方式使其成为应用程序的一部分。这可能意味着在整个应用程序中将对象作为初始化参数提供给对象。在复杂的应用程序中，这可能是一个相当大的负担。

拥有几个共享的全局对象更具吸引力，因为应用程序变得更简单。当这些对象用于审计、日志记录和安全性等普及功能时，它们可能会有所帮助。

这是一种容易被滥用的技术。依赖太多全局对象的设计可能会令人困惑。它还可能隐藏一些微妙的错误，因为类中对象的封装可能很难识别。由于对象之间的隐式关系，它还可能使单元测试用例难以编写。

# 使用更复杂的结构–列表地图

在[第 4 章](04.html#page "Chapter 4. Built-in Data Structures – list, set, dict")、*内置数据结构–列表、集合、dict*中，我们查看了 Python 中可用的基本数据结构。食谱通常是孤立地观察各种结构。

我们将研究一种常见的组合结构，即从键到列表的映射。这用于积累有关给定键标识的对象的详细信息。这个方法将把一个简单的细节列表转换成一个结构，其中一列包含从其他列获取的值。

## 准备好了吗

我们将使用一个虚拟的 web 日志，该日志已从原始 web 格式转换为**CSV**（**逗号分隔值**）格式。这种转换通常是通过一个正则表达式来完成的，该正则表达式选择了各种语法组。请参见[第 1 章](01.html#page "Chapter 1. Numbers, Strings, and Tuples")*数字、字符串和元组*中的*正则表达式字符串解析*配方，了解解析可能的工作方式。

原始数据如下所示：

```py
[2016-04-24 11:05:01,462] INFO in module1: Sample Message One

[2016-04-24 11:06:02,624] DEBUG in module2: Debugging

[2016-04-24 11:07:03,246] WARNING in module1: Something might have gone wrong

```

文件中的每一行都有时间戳、严重性级别、模块名称和一些文本。解析后，数据实际上是一个简单的事件列表。看起来是这样的：

```py
>>> data = [ 
    ('2016-04-24 11:05:01,462', 'INFO', 'module1', 'Sample Message One'), 
    ('2016-04-24 11:06:02,624', 'DEBUG', 'module2', 'Debugging'), 
    ('2016-04-24 11:07:03,246', 'WARNING', 'module1', 'Something might have gone wrong') 
]

```

我们想检查日志，创建一个按模块组织的所有消息的列表，而不是按时间顺序。这种重组可以简化分析。

## 怎么做。。。

1.  从`collections`导入`defaultdict`：

    ```py
            from collections import defaultdict 

    ```

2.  使用`list`函数作为`defaultdict`

    ```py
            module_details = defaultdict(list) 

    ```

    的默认值
3.  遍历数据，并将其附加到与每个键关联的列表中。`defaultdict`对象将使用`list()`函数为每个新键建立一个空列表：

    ```py
            for row in data: 
                module_details[row[2]].append(row) 

    ```

其结果将是一个字典，该字典将从模块映射到该模块名称的所有日志行的列表。数据如下所示：

```py
    { 
        'module1': [ 
            ('2016-04-24 11:05:01,462', 'INFO', 'module1', 'Sample Message One'), 
            ('2016-04-24 11:07:03,246', 'WARNING', 'module1', 'Something might have gone wrong') 
            ], 
        'module2': [ 
            ('2016-04-24 11:06:02,624', 'DEBUG', 'module2', 'Debugging') 
        ] 
    } 

```

此映射的键是模块名，映射中的值是该模块名的行列表。现在，我们可以将分析重点放在特定模块上。

## 它是如何工作的。。。

对于找不到键时映射的行为，有两种选择：

*   内置的`dict`类在缺少键时引发异常。
*   类`defaultdict`计算一个函数，该函数在缺少键时创建一个默认值。在许多情况下，函数为`int`或`float`以创建默认数值。在这种情况下，函数是`list`创建一个空列表。

我们可以想象使用`set`函数为丢失的密钥创建一个空`set`对象。这将适用于从一个键到共享该键的一组对象的映射。

## 还有更多。。。

当我们考虑 Python 3.5 和进行类型推断的能力时，我们需要有一种方法来描述这种结构：

```py
    from typing import * 
    def summarize(data) -> Mapping[str, List]: 
        the body of the function. 

```

这使用符号`Mapping[str, List]`表示结果是从字符串键到字符串数据项列表的映射。

我们还可以构建一个版本，作为内置`dict`类的扩展：

```py
    class ModuleEvents(dict): 
        def add_event(self, event): 
            if event[2] not in self: 
                self[event[2]] = list() 
            self[event[2]].append(row) 

```

我们已经定义了这个类所独有的方法，`add_event()`。如果`event[2]`中的模块名称键当前不在字典中，则会添加空列表。在`if`语句之后，可以添加一个后置条件来断言密钥现在在字典中。

这允许我们使用如下代码：

```py
    module_details = ModuleEvents() 
    for row in data: 
        module_details.add_event(row) 

```

结果结构与`defaultdict`非常相似。

## 另见

*   在*创建字典[第 4 章](04.html#page "Chapter 4. Built-in Data Structures – list, set, dict")中插入和更新*配方*内置数据结构【列表、集合、dict】*中，我们了解了使用映射的基础知识
*   在[第 4 章](04.html#page "Chapter 4. Built-in Data Structures – list, set, dict")中*内置数据结构*避免函数参数*的可变默认值*中，我们查看了其他使用默认值的地方
*   在[第 6 章](06.html#page "Chapter 6. Basics of Classes and Objects")的*使用更复杂的集合*配方*类和对象的基础*中，我们查看了使用`defaultdict`类的其他示例

# 创建具有可排序对象的类

在模拟纸牌游戏时，能够将`Card`对象按定义的顺序排序通常是至关重要的。当牌形成一个序列，有时称为直牌时，这是一种重要的得分方式。这是扑克、克里比奇、甚至皮诺奇勒等游戏的一部分。

我们的大多数类定义都没有包含将对象按顺序排序所需的功能。许多配方根据`__hash__()`计算的内部哈希值将对象保存在映射或集合中。

为了将项目保存在已排序的集合中，我们需要实现`<`、`>`、`<=`、`>=`、`==`和`!=`的比较方法。这些比较基于每个对象的属性值。

我们如何创建可比较的对象？

## 准备好了吗

皮诺奇勒的游戏通常包括一副 48 张牌。有六个等级——9 级、10 级、杰克级、王后级、国王级和王牌级。有四套标准的西装。这 24 张牌中的每一张在牌组中出现两次。我们必须小心使用诸如 dict 或 set 之类的结构，因为卡片在 Pinochle 中不是唯一的；可能有重复的。

在*通过多重继承分离关注点*配方中，我们使用两个类定义定义扑克牌。`Card`类层次结构定义了每张卡的基本特征。第二组 mixin 类为每张卡提供了特定于游戏的功能。

我们需要为这些卡片添加功能，以创建可以正确订购的对象。为了支持*定义有序收集*配方，我们将研究皮诺奇勒游戏的卡片。

以下是设计的前两个要素：

```py
    from ch07_r02 import AceCard, Card, FaceCard, SUITS 
    class PinochlePoints: 
        _points = {9: 0, 10:10, 11:2, 12:3, 13:4, 14:11} 
        def points(self): 
            return self._points[self.rank] 

```

我们已经导入了现有的`Card`层次结构。我们还定义了一个规则，用于计算在玩把戏时每一张牌的点数，`PinochlePoints`类。这有一个从卡片等级到每张卡片的潜在混淆点的映射。

10 分得 10 分，A 得 11 分，但国王、杰克和王后分别得 4 分、3 分和 2 分。这可能会让新玩家感到困惑。

因为一张王牌的等级高于国王，所以我们将王牌的等级定为 14。这稍微简化了处理过程。

为了使用分类的卡片集合，我们需要为卡片添加另一个功能。我们需要定义比较操作。有六种用于对象比较的特殊方法。

## 怎么做。。。

1.  We're using a mixin design. Therefore, we'll create a new class to hold the comparison features:

    ```py
            class SortedCard: 

    ```

    该类将加入`Card`层次结构的成员和`PinochlePoints`以创建最终的复合类定义。

2.  Define the six comparison methods:

    ```py
            def __lt__(self, other): 
                return (self.rank, self.suit) < (other.rank, other.suit) 

            def __le__(self, other): 
                return (self.rank, self.suit) <= (other.rank, other.suit) 

            def __gt__(self, other): 
                return (self.rank, self.suit) > (other.rank, other.suit) 

            def __ge__(self, other): 
                return (self.rank, self.suit) >= (other.rank, other.suit) 

            def __eq__(self, other): 
                return (self.rank, self.suit) == (other.rank, other.suit) 

            def __ne__(self, other): 
                return (self.rank, self.suit) != (other.rank, other.suit) 

    ```

    我们已经完整地写出了所有六个比较。我们已经将`Card`的相关属性转换为元组，并依靠 Python 内置的元组比较来处理细节。

3.  Write the composite class definitions, built from an essential class and two mixin classes to provide additional features:

    ```py
            class PinochleAce(AceCard, SortedCard, PinochlePoints): 
                pass 

            class PinochleFace(FaceCard, SortedCard, PinochlePoints): 
                pass 

            class PinochleNumber(Card, SortedCard, PinochlePoints): 
                pass 

    ```

    最后一个类包含具有三个独立且基本独立的特性集的元素：基本`Card`特性、mixin 比较特性和 mixin-pinocle 特定特性。

4.  Create a function that will create individual card objects from the classes defined previously:

    ```py
            def make_card(rank, suit): 
                if rank in (9, 10): 
                    return PinochleNumber(rank, suit) 
                elif rank in (11, 12, 13): 
                    return PinochleFace(rank, suit) 
                else: 
                    return PinochleAce(rank, suit) 

    ```

    尽管点规则非常复杂，但复杂性隐藏在`PinochlePoints`类中。将复合类构建为`Card`加`PinochlePoints`的基子类，可以得到一个精确的卡片模型，而不会有太多明显的复杂性。

我们现在可以制作响应比较运算符的卡片：

```py
>>> from ch07_r06a import make_card 
>>> c1 = make_card(9, '♡') 
>>> c2 = make_card(10, '♡') 
>>> c1 < c2 
True 
>>> c1 == c1 
True 
>>> c1 == c2 
False 
>>> c1 > c2 
False

```

下面是一个构建 48 卡组的函数：

```py
    SUITS = '\u2660\u2661\u2662\u2663' 
    Spades, Hearts, Diamonds, Clubs = SUITS 
    def make_deck(): 
        return [make_card(r, s) for _ in range(2) 
            for r in range(9, 15) 
            for s in SUITS] 

```

`SUITS`的值是四个 Unicode 字符。我们本可以分别设置每条西服线，但这似乎稍微简单一点。`make_deck()`函数中的生成器表达式构建每个卡的两个副本。只有六个级别和四套西装。

## 它是如何工作的。。。

Python 对很多事情使用特殊的方法。语言中几乎所有可见的行为都是由于某些特殊的方法名引起的。在这个配方中，我们利用了六个比较运算符。

写下以下内容：

```py
    c1 <= c2 

```

前面的代码被评估为我们编写了以下代码：

```py
    c1.__le__(c2) 

```

这种转换适用于所有表达式运算符。

仔细研究*Python 语言参考文献*的*第 3.3*节，可以发现特殊方法可以分为几个不同的组：

*   基本定制
*   自定义属性访问
*   自定义类创建
*   自定义实例和子类检查
*   模拟可调用对象
*   模拟容器类型
*   模拟数字类型
*   使用语句上下文管理器

在这个食谱中，我们只看了其中的第一类。其他的遵循一些类似的设计模式。

下面是创建此类层次结构实例时的外观。第一个示例将创建 48 卡 Pinochle 卡组：

```py
>>> from ch07_r06a import make_deck 
>>> deck = make_deck() 
>>> len(deck) 
48

```

如果我们看前八张牌，我们可以看到它们是如何从所有等级和套装组合中构建的：

```py
>>> deck[:8] 
[ 9 ♠,  9 ♡,  9 ♢,  9 ♣, 10 ♠, 10 ♡, 10 ♢, 10 ♣]

```

如果我们看牌组的下半部分，我们可以看到它与牌组的上半部分有相同的牌：

```py
>>> deck[24:32] 
[ 9 ♠,  9 ♡,  9 ♢,  9 ♣, 10 ♠, 10 ♡, 10 ♢, 10 ♣]

```

因为`deck`变量是一个简单的列表，所以我们可以洗牌列表对象并挑选 12 张牌。

```py
>>> import random 
>>> random.seed(4) 
>>> random.shuffle(deck) 
>>> sorted(deck[:12]) 
[ 9 ♣, 10 ♣,  J ♠,  J ♢,  J ♢,  Q ♠,  Q ♣,  K ♠,  K ♠,  K ♣, A ♡,  A ♣]

```

重要的部分是`sorted()`函数的使用。因为我们已经定义了适当的比较运算符，所以我们可以对`Card`实例进行排序，并按照预期的顺序显示它们。

## 还有更多。。。

一点形式逻辑表明，我们实际上只需要实现其中两个比较。使用任何两种方法，都可以导出其他所有方法。例如，如果我们只能对小于（`__lt__()`）和等于（`__eq__()`的值进行运算，那么我们可以相当容易地计算缺失的三个值：

*a*≤ *b*≡ *a<b*∨ *a*=*b*

*a*≥ *b*≡ *a>b*∨ *a*=*b*

*a*≠ *b*≡ （*a*=*b*）

Python 显然不为我们做任何此类高级代数。我们需要仔细地做代数，或者如果我们不确定逻辑，我们可以完整地写出所有六个比较。

我们假设每一张`Card`都与另一张卡片相比较。试试这个：

```py
>>> c1 = make_card(9, '♡') 
>>> c1 == 9

```

我们会得到一个例外。

如果需要此功能，我们必须修改比较运算符以处理两种比较：

*   `Card`反对`Card`
*   `Card`反对`int`

这是通过使用`isinstance()`函数区分参数类型来实现的。

我们的每个比较方法都将更改为如下所示：

```py
    def __lt__(self, other): 
        if isinstance(other, Card): 
            return (self.rank, self.suit) < (other.rank, other.suit) 
        else: 
            return self.rank < other 

```

这将使用等级和诉讼比较来处理`Card`与`Card`案件。对于所有其他情况，Python 的普通规则用于将秩与其他值进行比较。如果出于某种模糊的原因，另一个的值是`float`，那么`float()`转换将用于`self.rank`。

## 另见

*   请参阅*定义有序收集*配方，该配方依赖于将这些卡片按顺序排序

# 定义有序集合

在模拟纸牌游戏时，玩家的手可以建模为一组牌或一张牌列表。对于大多数传统的单甲板游戏，一张牌的效果很好，因为任何给定的牌只有一个实例，set 类可以执行非常快速的操作来确认给定的牌是否在牌集中。

然而，在为皮诺奇勒建模时，我们遇到了一个具有挑战性的问题。皮诺奇勒牌组是 48 张牌；它有 9、10、杰克、皇后、国王和王牌中的两个。一个简单的设置不会很好地解决这个问题；我们需要一个多套或包。这是一个允许重复项目的集合。

这些操作仍然局限于成员资格测试。例如，我们可以多次添加对象`Card(9,'♢')`对象，然后多次删除它。

我们有多种方法来创建多集：

*   我们可以使用列表。追加一个项目的成本几乎是固定的，其特征为*O*（1）。搜索项目时出现性能问题。成员资格测试的复杂性往往随着集合的大小而增加。它变成了*O*（n）。
*   我们可以使用映射；该值可以是重复元素显示次数的整数计数。这只需要默认的`__hash__()`方法可用于映射中的每个对象。我们有三种实施方法：
    *   定义我们自己的 dict 子类。
    *   使用`defaultdict`。参见*使用更复杂的结构-列表映射*配方，该配方使用`defaultdict(list)`为每个键创建一个值列表。此列表的`len()`是键出现的次数。实际上，这是一种多重集。
    *   使用`Counter`。这可能非常简单。我们已经研究了许多食谱中的`Counter`。参见[第 4 章](04.html#page "Chapter 4. Built-in Data Structures – list, set, dict")中的*避免函数参数的可变默认值*配方、*内置数据结构–列表、集合、dict*，以及*设计具有大量处理的类*和*使用惰性属性*[第 6 章](06.html#page "Chapter 6. Basics of Classes and Objects")中的配方、*类和对象基础*中的配方，以及本章*管理全局和单例对象*配方中的其他示例。
*   我们可以使用排序列表。插入维护此排序顺序的项目比插入到列表中的项目***O***（*n*日志*<sub>2</sub>n*稍微贵一些）。然而，搜索比未排序的列表花费更少；是***O***（日志*<sub>2</sub>n*）。`bisect`模块提供了一组功能，可以很好地实现这一点。但是，这需要具有全套比较方法的对象。

我们如何构建对象的有序集合？我们如何使用分类集合构建多集或包？

## 准备好了吗

在*创建具有可排序对象的类*配方中，我们定义了可以排序的卡片。这对于使用`bisect`是必要的。本模块中的算法需要在对象之间进行全套比较。

我们将定义一个 multiset 来保存 12 个卡片 pinocle 指针。由于重复，将有一个以上的一个给定的职级和西装卡。

为了将手看作一种集合，我们还需要在手对象上定义一些集合操作符。其思想是定义集合成员和子集运算符。

我们希望 Python 代码等同于以下内容：

*c*∈ *H*

这是给一张牌，*c*和一手牌，*H*={*c*<sub>1</sub>*、c*<sub>2</sub>*、c<sub>3</sub>*、*}*

我们还需要与此等效的代码：

{*J，Q*⊂ *H*

这是一对特殊的牌，称为皮诺奇勒牌和一手牌*H*。

我们需要导入两件东西：

```py
    from ch07_r06a import * 
    import bisect 

```

第一次导入引入了*中的可订购卡片定义，创建了一个具有可订购对象*配方的类。第二个导入引入了各种对分函数，我们将使用这些函数来维护具有重复项的有序集。

## 怎么做。。。

1.  Define a class with an initialization that can load the collection from any iterable source of data:

    ```py
            class Hand: 
                def __init__(self, card_iter): 
                    self.cards = list(card_iter) 
                    self.cards.sort() 

    ```

    我们可以使用它从列表或生成器表达式构建一个`Hand`。如果列表非空，我们需要将项目按顺序排序。`self.cards`列表的`sort()`方法将依赖于`Card`对象实现的各种比较运算符。

    从技术上讲，我们只关心属于`SortedCard`子类的对象，因为这是定义比较方法的地方。

2.  Define a method to add cards to a hand:

    ```py
            def add(self, aCard: Card): 
                bisect.insort(self.cards, aCard) 

    ```

    我们使用了`bisect`算法来确保该卡正确插入`self.cards`列表。

3.  Define a method to find the position of a given card in a hand:

    ```py
            def index(self, aCard: Card): 
                i = bisect.bisect_left(self.cards, aCard) 
                if i != len(self.cards) and self.cards[i] == aCard: 
                    return i 
                raise ValueError 

    ```

    我们使用了`bisect`算法来定位给定的卡。文件中建议对`bisect.bisect_left()`进行额外的`if`测试，以便在加工过程中正确处理边缘情况。

4.  Define the special method that implements the `in` operator:

    ```py
            def __contains__(self, aCard: Card): 
                try: 
                    self.index(aCard) 
                    return True 
                except ValueError: 
                    return False 

    ```

    当我们用 Python 编写`card in some_hand`时，它的计算结果就像我们编写了`some_hand.__contains__(card)`一样。我们使用了`index()`方法来查找卡或引发异常。异常被转换为返回值`False`。

5.  Define an iterator over the hand. This is a simple delegation to the `self.cards` collection:

    ```py
            def __iter__(self): 
                return iter(self.cards) 

    ```

    当我们用 Python 编写`iter(some_hand)`时，它的计算结果就像我们编写了`some_hand.__iter__()`一样。

6.  Define a subset operation between two hand instances:

    ```py
            def __le__(self, other): 
                for card in self: 
                    if card not in other: 
                        return False 
                return True 

    ```

    Python 没有*a*⊂ *b*或*a*⊆ *b*符号，因此<和<=被压入服务，用于比较集合。当我们写`pinochle <= some_hand`来查看手牌是否包含特定的卡片组合时，它的评估就好像我们写了`pinochle.__le__(some_hand)`一样。子集为`self`实例变量，目标`Hand`为其他参数值。

    in 运算符通过`__contains__()`方法实现。这显示了简单 Python 语法是如何通过特殊方法实现的。

我们可以这样使用这个`Hand`类：

```py
>>> from ch07_r06b import make_deck, make_card, Hand 
>>> import random 
>>> random.seed(4) 
>>> deck = make_deck() 
>>> random.shuffle(deck) 
>>> h = Hand(deck[:12]) 
>>> h.cards 
[ 9 ♣, 10 ♣,  J ♠,  J ♢,  J ♢,  Q ♠,  Q ♣,  K ♠,  K ♠,  K ♣, A ♡,  A ♣]

```

手中的卡片已正确分类。这是手的创造方式的结果。

下面是一个使用子集运算符`<=`将特定图案与手作为一个整体进行比较的示例：

```py
>>> pinochle = Hand([make_card(11,'♢'), make_card(12,'♠')]) 
>>> pinochle <= h 
True

```

`Hand`是一个集合，支持迭代。我们可以使用引用整个`Hand`中`Card`对象的生成器表达式：

```py
>>> sum(c.points() for c in h) 
56

```

## 它是如何工作的。。。

我们的`Hand`集合通过包装内部`list`对象并对该对象应用重要约束来工作。这些项目是按顺序排列的。这增加了插入新项目的成本，但降低了搜索项目的成本。

定位项目位置的核心算法是`bisect`模块的一部分，使我们不必编写（和调试）它们。算法并不是很复杂。但利用现有代码似乎更有效。

模块的名称来源于将已排序的列表平分以查找项目的想法。其实质是：

```py
    while lo < hi: 
        mid = (lo+hi)//2 
        if x < a[mid]: hi = mid 
        else: lo = mid+1 

```

这将在列表`a`中搜索给定值`x`。`lo`的值最初为零，`hi`的值最初为列表的大小`len(a)`。

首先，确定中点。如果目标值`x`小于中点值`a[mid]`，则它必须在列表的前半部分：移动`hi`的值，以便只考虑前半部分。

如果目标值`x`大于或等于中点值`a[mid]`，则`x`必须在列表的下半部分：移动`lo`的值，以便只考虑下半部分。

由于列表在每次操作时被切分为两半，因此需要*O*（log*<sub>2</sub>n*步）使`lo`和`hi`的值收敛到应该有目标值的位置。

如果一手牌有 12 张牌，那么第一次比较会丢弃 6 张牌。下一次比较将丢弃另外三个。下一次比较将丢弃最后三次比较中的一次。第四次比较将定位卡应该占据的位置。

如果我们使用一个普通的列表，卡片按随机到达顺序存储，那么找到一张卡片平均需要六次比较。最坏的情况意味着这是 12 张卡中的最后一张，需要对所有 12 张卡进行检查。

与`bisect`的比较次数始终为*O*（log*<sub>2</sub>n*。这是平均水平，也是最糟糕的情况。

## 还有更多。。。

`collections.abc`模块为各种集合定义抽象基类。如果我们想要我们的`Hand`表现得更像其他类型的集合，我们可以利用这些定义。

我们可以在这个类定义中添加许多集合运算符，使其行为更像内置的`MutableSet`抽象类定义。

`MutableSet`是`Set`的扩展。`Set`类是由三个类定义构成的组合：`Sized`、`Iterable`和`Container`。这意味着它必须定义以下方法：

*   `__contains__()`
*   `__iter__()`
*   `__len__()`
*   `add()`
*   `discard()`

我们还需要提供一些作为可变集一部分的其他方法：

*   `clear()`、`pop()`：这些将从集合中删除项目。
*   `remove()`：与`discard()`不同，这将在尝试删除缺失项时引发异常。

为了拥有独特的集合式特征，它还需要一些额外的方法。我们提供了一个基于`__le__()`的子集示例。我们还需要提供以下子集比较：

*   `__le__()`
*   `__lt__()`
*   `__eq__()`
*   `__ne__()`
*   `__gt__()`
*   `__ge__()`
*   `isdisjoint()`

这些通常不是简单的单行定义。为了实现核心比较集，我们通常会编写两个，然后使用逻辑在这两个基础上构建余数。

因为`__eq__()`很简单，所以假设我们有`==`和`<=`运算符的定义。其他的定义如下：

*x*≠ *y*≡ （*x*=*y*）

*x*<*y*≡ （*x*≤ *y*）∧ （*x*=*y*）

*x*>*y*≡ （*x*≤ *y*）

*x*≥ *y*≡ （*x*<*y*）≡ （*x*≤ *y*∨ （*x*=*y*）

为了执行 set 操作，我们需要提供以下内容：

*   `__and__()`和`__iand__()`。这些方法实现 Python`&`操作符和`&=`赋值语句。在两个集合之间，这是集合交叉点，或*a*∩ *b*。
*   `__or__()`和`__ior__()`。这些方法实现 Python`|`操作符和`|=`赋值语句。在两个集合之间，这是集合并集，或*a*∪ *b*。
*   `__sub__()`和`__isub__()`。这些方法实现 Python`-`操作符和`-=`赋值语句。在集合之间，这是集合差异，通常写为*a*-*b*。
*   `__xor__()`和`__ixor__()`。这些方法实现 Python`^`操作符和`^=`赋值语句。当应用于两组之间时，这是对称差异，通常写为*a*∆ *b*。

抽象类允许每个运算符有两个版本。有两种情况：

*   例如，如果我们提供了`__iand__()`，那么语句`A &= B`将被评估为`A.__iand__(B)`。这可能允许有效的实现。
*   如果我们不提供`__iand__()`，则`A &= B`将被评估为`A = A.__and__(B)`。这可能会有点效率低下，因为我们将创建一个新对象。新对象被赋予标签`A`，旧对象将从内存中删除。

要为内置的 set 类提供适当的替换，几乎需要 20 多种方法。一方面，它有很多代码。另一方面，Python 允许我们以透明的方式扩展内置类，并使用具有相同语义的相同运算符。

## 另见

*   请参阅定义 Pinochle 卡的配套配方的*创建具有可订购对象的类*配方

# 从映射列表中删除

从列表中删除项目有一个有趣的结果。具体来说，当`list[x]`项被移除时，将发生以下两种情况之一：

*   第`list[x+1]`项取代了第`list[x]`项
*   项目`x+1 == len(list)`取代`list[x]`，因为`x`是列表中的最后一个索引

这些都是除移除物品外发生的副作用。因为事情可以在列表中移动，所以一次删除多个项目很有挑战性。

当列表包含对`__eq__()`特殊方法有定义的项时，列表`remove()`方法可以删除每个项。当列表项没有简单的`__eq__()`测试时，从列表中删除多个项就变得更具挑战性。

如何从列表中删除多个项目？

## 准备好了吗

我们将使用 dict 结构列表。在本例中，我们得到了一些数据，包括歌曲名称、作者和持续时间。数据如下所示：

```py
>>> source = [ 
...    {'title': 'Eruption', 'writer': ['Emerson'], 'time': '2:43'}, 
...    {'title': 'Stones of Years', 'writer': ['Emerson', 'Lake'], 'time': '3:43'}, 
...    {'title': 'Iconoclast', 'writer': ['Emerson'], 'time': '1:16'}, 
...    {'title': 'Mass', 'writer': ['Emerson', 'Lake'], 'time': '3:09'}, 
...    {'title': 'Manticore', 'writer': ['Emerson'], 'time': '1:49'}, 
...    {'title': 'Battlefield', 'writer': ['Lake'], 'time': '3:57'}, 
...    {'title': 'Aquatarkus', 'writer': ['Emerson'], 'time': '3:54'} 
... ]

```

要使用这种数据结构，我们需要`pprint`函数：

```py
>>> from pprint import pprint

```

我们可以使用`for`语句轻松遍历值列表。问题是，我们如何删除选定的项目？

```py
>>> data = source.copy() 
>>> for item in data: 
...     if 'Lake' in item['writer']: 
...        print("remove", item['title']) 
remove Stones of Years 
remove Mass 
remove Battlefield

```

我们不能在这里简单地使用语句`del item`，因为它对源集合`data`没有影响。此语句仅通过删除`item`变量和关联对象来删除原始列表中项目的局部变量副本。

要从列表中正确删除项目，我们必须使用列表中的索引位置。这是一种显然不起作用的幼稚方法：

```py
>>> data = source.copy() 
>>> for index in range(len(data)):  
...    if 'Lake' in data[index]['writer']: 
...       del data[index] 
Traceback (most recent call last): 
  File "/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/doctest.py", line 1320, in __run 
    compileflags, 1), test.globs) 
  File "<doctest __main__.__test__.chapter[5]>", line 2, in <module> 
    if 'Lake' in data[index]['writer']: 
IndexError: list index out of range

```

根据列表的原始大小，我们不能简单地使用`range(len(data))`。随着项目的删除，列表将变小。索引的值将设置为太大的值。

当删除具有简单相等性测试的简单项时，我们将使用如下内容：

```py
    while x in list: 
        list.remove(x) 

```

问题是我们没有一个在`item['writer']`中用`Lake`标识项目的`__contains__()`实现。我们可以使用 dict 的一个子类来实现`__eq__()`作为`self['writer']`中的字符串参数值。这显然违反了平等的语义，因为它只检查单个字段。

我们无法扩展这些类的内置功能。这里的用例非常特定于问题域，而不是 dict 结构列表的一般特性。

为了并行基本的`while in...remove`循环，我们需要编写如下内容：

```py
>>> def index(data): 
...    for i in range(len(data)): 
...        if 'Lake' in data[i]['writer']: 
...            return i 
>>> data = source.copy() 
>>> position = index(data) 
>>> while position: 
...    del data[position] # or data.pop(position) 
...    position = index(data)

```

我们已经编写了一个函数，`index()`，用于定位目标值的第一个实例。此函数的结果是提供两种信息的单个值：

*   当返回值不是`None`时，列表中存在该项
*   返回值是列表中项目的正确索引

`index()`函数冗长且不灵活。如果我们有备用规则，我们需要编写多个`index()`函数，或者我们需要使测试更加灵活。

更重要的是，考虑当目标值发生时，在 To.t2×n 个 T3 项的列表中出现 T0。通过该回路将有*x*次跳闸。通过回路的每次跳闸检查通过列表的平均**O**（*x*×*n/2*次跳闸。最坏的情况是项目都在列表的末尾，导致处理迭代次数刚好低于**O**（*x*×*n*）。

我们可以做得更好。我们首选的解决方案基于*设计一个 while 语句中的思想，该语句在[第 2 章](02.html#page "Chapter 2. Statements and Syntax")*语句和语法*中正确终止*配方，从而设计一个适当的循环，用于从列表结构中移除复杂项。

## 怎么做。。。

1.  将索引值初始化为零。这将建立一个将遍历数据收集的变量：

    ```py
            i = 0 

    ```

2.  The terminating condition must show that every item in the list has been examined. Additionally, the body of the loop needs to remove all of the items that match the target criteria. This leads to an invariant condition that `item[i]` has not yet been examined. After the item is examined, it may be preserved, which means the index, `i` , must be incremented to reset the not yet examined invariant. If the item is removed, then items will shift forward and `item[i]` will automatically meet the not yet examined invariant:

    ```py
            if 'Lake' in data[i]['writer']: 
                del data[i] # Remove 
            else: 
                i += 1 # Preserve 

    ```

    删除项目时，列表将缩短一个，索引值`i`将指向新的未检查项目。保存项目时，索引值`i`将前进到下一个未检查的项目。

3.  The terminating condition is used to wrap the processing body:

    ```py
            while i != len(data): 

    ```

    在`while`语句末尾，`i`的值表示所有项目都已检查。

    这导致以下情况：

    ```py
     >>> i = 0 
          >>> while i != len(data): 
          ...    if 'Lake' in data[i]['writer']: 
          ...        del data[i] 
          ...    else: 
          ...        i += 1 
          >>> pprint(data) 
          [{'time': '2:43', 'title': 'Eruption', 'writer': ['Emerson']}, 
           {'time': '1:16', 'title': 'Iconoclast', 'writer': ['Emerson']}, 
           {'time': '1:49', 'title': 'Manticore', 'writer': ['Emerson']}, 
           {'time': '3:54', 'title': 'Aquatarkus', 'writer': ['Emerson']}]

    ```

这只对数据进行一次传递，并删除请求的项，而不会引发索引错误，也不会跳过本应删除的项。

## 它是如何工作的。。。

我们的目标是对每个项目进行一次精确的检查，然后将其移除或跨过。循环设计反映了 Python 列表项删除的工作方式。删除项目后，所有后续项目都将在列表中向前移动。

基于`range()`和`len()`函数的简单流程将有两个问题：

*   当项目向前移动并且范围对象生成下一个值时，将跳过项目
*   删除项目后，索引可以超出列表结构的末尾，因为`len()`曾经用于获取原始大小，而不是当前大小

由于这两个问题，循环体中不变条件的设计非常重要。这反映了两种可能的状态变化：

*   如果项目被删除，则索引不得更改。列表本身将发生变化。
*   如果项目被保留，则索引必须更改。

我们可以认为，该回路通过数据进行一次行程，其复杂性为**O**（*n*。这里没有考虑的是每次删除的相对成本。从列表中删除项目`0`意味着每个剩余项目向前移动一个位置。每次删除的成本实际上是*O*（*n*）。因此复杂性更像是**O**（*n×x*），其中*x*项从*n*项列表中移除。

即使这种算法也不是从列表中删除项目的最快方法。

## 还有更多。。。

如果我们放弃删除的想法，我们可以做得更好。创建项目的浅表副本比从列表中删除项目快得多，但会占用更多存储空间。这是一种常见的时间与内存权衡。

我们可以使用如下所示的生成器表达式：

```py
>>> data = [item for item in source if not('Lake' in item['writer'])]

```

这将创建列表中要保留的项目的浅表副本。我们不想保留的项目将被忽略。有关浅拷贝概念的更多信息，请参见[第 4 章](04.html#page "Chapter 4. Built-in Data Structures – list, set, dict")中的*制作对象的浅拷贝和深拷贝*配方，*内置数据结构–列表、集合、记录*。

我们也可以使用高阶函数，例如：

```py
>>> data = list(filter(lambda item: not('Lake' in item['writer']), source))

```

`filter()`函数有两个参数：`lambda`对象和原始数据集。`lambda`对象是函数的一种退化情况：它有参数和一个表达式。在这种情况下，使用单个表达式来决定要传递哪些项。lambda 为`False`的项目被拒收。

`filter()`功能是一个发电机。这意味着我们需要收集所有项来创建最终的列表对象。`for`语句是处理生成器所有结果的一种方法。`list()`和`tuple()`功能还将消耗发电机的所有项目。

实现这一点的第三种方法是编写我们自己的生成器函数，它体现了过滤器的概念。这将使用比生成器或`filter()`函数更多的语句，但可能更清楚。

以下是生成器函数定义：

```py
    def writer_rule(iterable): 
        for item in iterable: 
            if 'Lake' in item['writer']: 
                continue 
            yield item 

```

我们使用`for`语句检查源列表中的每个项目。如果该项目在作者列表中有`'Lake'`，我们将继续`for`声明过程，有效拒绝该项目。如果`'Lake'`不在作者列表中，我们将放弃该项目。

当我们调用此函数时，它将生成有趣的列表。我们可以这样使用`writer_rule()`功能：

```py
>>> from ch07_r07 import writer_rule 
>>> data = list(writer_rule(source)) 
>>> pprint(data) 
[{'time': '2:43', 'title': 'Eruption', 'writer': ['Emerson']}, 
 {'time': '1:16', 'title': 'Iconoclast', 'writer': ['Emerson']}, 
 {'time': '1:49', 'title': 'Manticore', 'writer': ['Emerson']}, 
 {'time': '3:54', 'title': 'Aquatarkus', 'writer': ['Emerson']}] 

```

这将把感兴趣的行累积到一个新的结构中。因为它是一个浅拷贝，所以不会浪费大量的存储空间。

## 另见

*   这是基于*在[第 2 章](02.html#page "Chapter 2. Statements and Syntax")、*语句和语法*中设计了一个正确终止*配方的 while 语句
*   我们还利用了另外两种方法：*制作对象的浅拷贝和深拷贝*以及*在[第 4 章](04.html#page "Chapter 4. Built-in Data Structures – list, set, dict")中对列表*进行切片和切割，*内置数据结构–列表、集合、dict*