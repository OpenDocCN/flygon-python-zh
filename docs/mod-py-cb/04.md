# 四、内置数据结构——列表、集合、目录

在本章中，我们将介绍以下配方：

*   选择数据结构
*   建筑列表–文字、附录和理解
*   切分列表
*   从列表中删除–删除、删除、弹出和筛选
*   反转列表的副本
*   使用集合方法和运算符
*   从集合中删除项目–删除（）、弹出（）和差异
*   创建字典–插入和更新
*   从字典中删除–pop（）方法和 del 语句
*   控制 dict 键的顺序
*   在 doctest 示例中处理字典和集合
*   理解变量、引用和赋值
*   制作对象的浅拷贝和深拷贝
*   避免函数参数的可变默认值

# 导言

Python 拥有丰富的内置数据结构集合。许多有用的编程通常是通过这些内置结构完成的。这些集合涵盖了各种常见情况。

我们将对可用的各种结构以及它们解决的问题进行概述。从那里，我们可以详细查看列表、词典和集合。

注意，我们已经将内置元组和字符串设置为与列表结构不同。有一些重要的相似之处，也有一些不同之处。在[第一章](01.html#page "Chapter 1. Numbers, Strings, and Tuples")*数字、字符串和元组*中，我们强调了字符串和元组的行为方式更像是不可变的数字，而不是可变的集合。

我们还将研究一些更高级的主题，这些主题与 python 如何处理对对象的引用有关。我们还将研究一些与这些数据结构的可变性相关的问题。

# 选择数据结构

Python 提供了许多内置的数据结构来帮助我们处理数据集合。确定哪一个适合某一特定目的可能会令人困惑。

我们如何选择要使用的结构？列表、集合和字典的功能是什么？为什么我们有元组和冻结集？

## 准备好了吗

在我们把数据放入一个集合之前，我们需要考虑我们如何收集数据，以及一旦我们拥有了它，我们将如何处理它。最大的问题总是我们如何在收藏中识别特定的物品。

我们来看看需要回答的几个关键问题。

## 怎么做。。。

1.  Is the programming focused on doing membership tests? An example of this is a collection of valid input values. When the user enters something that's in the collection, their input is valid, otherwise it's invalid.

    简单会员建议使用`set`：

    ```py
            valid_inputs = {"yes", "y", "no", "n"} 
            answer = None 
            while answer not in valid_inputs: 
                answer = input("Continue? [y, n] ").lower() 

    ```

    `set`不按特定顺序保存项目。项目成为成员后，我们将无法再次添加它：

    ```py
     >>> valid_inputs = {"yes", "y", "no", "n"} 
          >>> valid_inputs.add("y") 
          >>> valid_inputs  
          {'no', 'y', 'n', 'yes'} 

    ```

    我们已经创建了一个集合`valid_inputs`，包含四个不同的字符串项。我们无法在已包含`y`的集合中添加另一个`y`。集合的内容不变。

    还要注意，集合中项目的顺序与我们最初提供它们的顺序不完全相同。集合不能维护项目的任何特定顺序，它只能确定集合中是否存在项目。

2.  Are we going to identify items by their position in the collection? An example includes the lines in an input file—the line number is its position in the collection.

    当我们必须使用索引或位置识别项目时，我们必须使用`list`：

    ```py
     >>> month_name_list = ["Jan", "Feb", "Mar", "Apr", 
          ...    "May", "Jun", "Jul", "Aug", 
          ...    "Sep", "Oct", "Nov", "Dec"] 
          >>> month_name_list[8] 
          "Sep" 
          >>> month_name_list.index("Feb") 
          1

    ```

    我们已经创建了一个列表`month_name_list`，包含 12 个字符串项。我们可以通过提供项目的位置来选择项目。我们也可以使用`index()`方法来定位列表中某个项目的索引。

    Python 中的列表始终以位置 0 开头。元组和字符串也是如此。

    如果集合中的项目数是固定的，例如 RGB 颜色有三个值，那么我们可能会看到一个`tuple`而不是一个`list`。如果物品的数量会增长和变化，那么`list`系列比`tuple`系列更好。

3.  Are we going to identify the items in a collection by a key that's not the item's position? An example might include a mapping between strings of characters—words—and integers which represent the frequencies of those words, or a mapping between a color name and the RGB tuple for that color.

    当我们必须用非位置键标识项时，我们使用的是某种映射。内置映射为`dict`。有几个扩展可以添加更多功能：

    ```py
     >>> scheme = {"Crimson": (220, 14, 60), 
          ... "DarkCyan": (0, 139, 139), 
          ... "Yellow": (255, 255, 00)} 
          >>> scheme['Crimson'] 
          (220, 14, 60)

    ```

    在这本词典`scheme`中，我们创建了从颜色名称到 RGB 颜色元组的映射。当我们使用一个键时，例如`"Crimson"`，我们可以检索绑定到该键的值。

4.  Consider the mutability of items in a `set` collection and the keys in a `dict` collection. Each item in a set must be an immutable object. Numbers, strings, and tuples are all immutable, and can be collected into sets. Since a `list` , `dict` , or `set` object is mutable, they can't be used as items in a set. It's impossible to build a `set` of `list` items, for example.

    我们可以将每个`list`项转换为`tuple`，而不是创建`list`项的`set`。我们可以创建一个由不可变的`tuple`项组成的`set`。

    同样，字典键必须是不可变的。我们可以使用数字、字符串或元组作为字典键。我们不能使用`list`或`set`或其他可变映射作为字典键。

## 它是如何工作的。。。

Python 的每个内置集合都提供了一组特定的独特特性。这些系列还提供了大量重叠的功能。对 Python 新手来说，挑战在于识别每个集合的独特特性。

事实证明，`collections.abc`模块通过内置集合提供了一种路线图。`collections.abc`模块定义了支持我们使用的具体类的**抽象基类**（**ABC**s）。我们将使用这组定义中的名称来指导我们完成功能。

从 ABC 中我们可以看到，实际上总共有六种藏品：

*   **集合**：唯一的特点是项目不是成员就是非成员。这意味着无法处理重复项：
    *   **可变集合**：`set`集合
    *   **不可变集合**：`frozenset`集合
*   **序列**：唯一的特点是项目有一个索引位置：
    *   **可变序列**：`list`集合
    *   **不可变序列**：`tuple`集合
*   **映射**：唯一的特点是每个项目都有一个键，该键引用一个值：
    *   **可变映射**：`dict`集合
    *   **不可变映射**：有趣的是，没有内置的冻结映射

Python 的库提供了这些核心集合类型的大量附加实现。我们可以在*Python 标准库*中看到其中的许多。

`collections`模块包含许多内置集合的变体。这些措施包括：

*   `namedtuple`：为元组中的每个项提供名称的`tuple`。使用`rgb_color.red`比使用`rgb_color[0]`更清晰。
*   `deque`：一个双端队列。这是一个可变的序列，每一端都有推送和弹出的优化。我们可以用`list`做类似的事情，但`deque`更有效。
*   `defaultdict`：可以为缺少的密钥提供默认值的`dict`。
*   `Counter`：一种`dict`，用于统计某个键的出现次数。这有时被称为多集或包。
*   `OrderedDict`：保留键创建顺序的`dict`。
*   `ChainMap`：将多个词典组合成一个映射的`dict`。

*Python 标准库*中还有更多内容。我们还可以使用`heapq`模块，该模块定义了优先级队列实现。`bisect`模块包括快速搜索排序列表的方法。这使得列表的性能更接近于字典的快速查找。

## 还有更多。。。

我们可以查看如下数据结构列表：[https://en.wikipedia.org/wiki/List_of_data_structures](https://en.wikipedia.org/wiki/List_of_data_structures) 。

有一些重要的摘要是这个庞大的数据结构索引的一部分。文章的不同部分提供了略微不同的数据结构摘要。我们将快速查看四种分类。

*   **阵列**：存在提供类似功能的变体实现。Python 的`list`结构是典型的，其性能类似于数组的链表实现。
*   **树**：通常，树结构可用于创建集合、顺序列表或键值映射。我们可以将树视为一种实现技术，而不是具有唯一功能集的数据结构。
*   **哈希**：Python 使用哈希实现字典和集合。这导致了良好的速度，但内存消耗大。
*   **图形**：Python 没有内置的图形数据结构。然而，我们可以很容易地用字典表示一个图结构，其中每个节点都有一个相邻节点的列表。

我们只要稍微聪明一点，就可以用 Python 实现几乎任何类型的数据结构。要么内置结构具有基本功能，要么我们可以找到一个可以强制投入使用的内置结构。

## 另见

*   有关高级图形操作，请参见[https://networkx.github.io](https://networkx.github.io) 。

# 建筑清单——文字、附录和理解

如果我们决定创建一个使用项目位置 a`list`的集合，我们有几种方法来构建此结构。我们将研究从单个项构建列表对象的多种方法。

在某些情况下，我们需要一个列表，因为它允许重复的值。很多统计操作都不需要知道项目的位置。对于这一点，多集是有用的，但我们没有将其作为内置结构；用`list`代替多集是很常见的。

## 准备好了吗

假设我们需要对一些文件大小进行一些统计分析。下面是一个简短的脚本，它将为我们提供一些文件的大小：

```py
>>> import pathlib 
>>> home = pathlib.Path('source') 
>>> for path in home.glob('*/index.rst'): 
...     print(path.stat().st_size, path.parent) 
2353 source/ch_01_numbers_strings_and_tuples 
2889 source/ch_02_statements_and_syntax 
2195 source/ch_03_functions 
3094 source/ch_04_built_in_data_structures_list_tuple_set_dict 
725 source/ch_05_user_inputs_and_outputs 
1099 source/ch_06_basics_of_classes_and_objects 
690 source/ch_07_more_advanced_class_design 
1207 source/ch_08_functional_programming_features 
926 source/ch_09_input_output_physical_format_logical_layout 
758 source/ch_10_statistical_programming_and_linear_regression 
615 source/ch_11_testing 
521 source/ch_12_web_services 
1320 source/ch_13_application_integration

```

我们使用了一个`pathlib.Path`对象来表示文件系统中的目录。`glob()`方法扩展与给定模式匹配的所有名称。在本例中，我们使用了一种模式`'*/index.rst'`。我们可以使用`for`语句显示文件 OS`stat`数据的大小。

我们想累积一个具有不同文件大小的`list`对象。由此我们可以计算出总尺寸和平均尺寸。我们可以查找看起来太大或太小的文件。

我们有四种方法来创建`list`对象：

*   我们可以使用由`[]`字符包围的一系列值来创建`list`的文字显示。看起来是这样的：`[value, ... ]`。Python 需要匹配`[`和`]`才能看到完整的逻辑行，因此文字可以跨越物理行。更多信息请参见[第 2 章](02.html#page "Chapter 2. Statements and Syntax")*语句和语法*中的*编写长代码*配方。

    ```py

    [2353, 2889, 2195, 3094, 725, 
          1099, 690, 1207, 926, 758, 
          615, 521, 1320]

    ```

*   我们可以使用`list()`函数将其他一些数据收集转换为列表。我们可以转换一个`set`，或者转换一个`dict`的键，或者转换一个`dict`的值。我们将在*切割列表*配方中看到一个更复杂的例子。
*   我们有`list`方法，允许我们一次构建一个`list`项目。这些方法包括`append()`、`extend()`和`insert()`。我们将在本配方的*中使用 append（）方法*构建列表部分查看`append()`。我们将在*中查看其他方法，还有更多。。。*本配方的一部分。
*   我们有生成器表达式，可以用来构建`list`对象。一种生成器是列表理解。

## 怎么做。。。

### 使用 append（）方法建立列表

1.  创建一个空列表，`[]`：

    ```py
     >>> file_sizes = []

    ```

2.  遍历某个数据源。使用`append()`方法将项目添加到列表中：

    ```py
     >>> home = pathlib.Path('source') 
          >>> for path in home.glob('*/index.rst'): 
          ...     file_sizes.append(path.stat().st_size) 
          >>> print(file_sizes) 
          [2353, 2889, 2195, 3094, 725, 1099, 690,
          1207, 926, 758, 615, 521, 1320] 
          >>> print(sum(file_sizes)) 
          18392

    ```

我们使用路径的`glob()`方法来查找与给定模式匹配的所有文件。路径的`stat()`方法提供 OS**stat**数据结构，包括大小`st_size`，以字节为单位。

当我们打印`list`时，Python 以文字表示法显示它。如果我们需要将列表复制并粘贴到另一个脚本中，这将非常方便。

需要注意的是，`append()`方法不返回值。`append()`方法变异`list`对象，不返回任何内容。

### 提示

通常，任何改变对象的方法都没有返回值。像`append()`、`extend()`、`sort()`和`reverse()`这样的方法没有返回值。他们调整`list`对象本身的结构。

`append()`方法不返回值。

它变异了`list`对象。

像这样的错误代码非常常见：`a = ['some', 'data']``a = a.append('more data')`这显然是错误的。这将把`a`设置为`None`。

正确的方法是这样的陈述，没有任何额外的赋值：

`a.append('more data')`

### 写一份清单

列表理解的目标是创建一个具有类似于列表文字的语法角色的对象：

1.  写下环绕列表对象的环绕括号`[]`。
2.  写入数据源。这将包括目标变量。请注意，结尾没有`:`，因为我们没有编写完整的语句：

    ```py
            for path in home.glob('*/index.rst') 

    ```

3.  Prefix this with the expression to evaluate for each value of the target variable. Again, since this is a simple expression we cannot use complex statements here:

    ```py
            path.stat().st_size 
                for path in home.glob('*/index.rst') 

    ```

    在某些情况下，我们需要添加一个过滤器。这是在`for`条款之后的`if`条款。我们可以使生成器表达式非常复杂。

这是整个`list`对象：

```py
>>> [path.stat().st_size 
...    for path in home.glob('*/index.rst')] 
[2353, 2889, 2195, 3094, 725, 1099, 690, 1207, 926, 758, 615, 521, 1320]

```

现在我们已经创建了一个`list`对象，我们可以将其分配给一个变量，并对数据进行其他计算和总结。

列表理解包括一个生成器表达式，在语言手册中称为**理解**。生成器表达式是附加到`for`子句的数据表达式。由于此生成器是一个表达式，而不是一个完整的语句，因此它的功能有一些限制。重复计算数据表达式，并由`for`子句控制。

### 在生成器表达式上使用 list 函数

我们将创建一个使用生成器表达式的`list`函数：

1.  编写环绕生成器表达式的包装`list()`函数。
2.  我们将重用列表理解版本中的步骤 2 和步骤 3 来创建生成器表达式。下面是生成器表达式：

    ```py
            path.stat().st_size 
                for path in home.glob('*/index.rst') 

    ```

下面是整个列表对象：

```py
>>> list(path.stat().st_size 
...    for path in home.glob('*/index.rst')) 
[2353, 2889, 2195, 3094, 725, 1099, 690, 1207, 926, 758, 615, 521, 1320]

```

## 它是如何工作的。。。

Python`list`对象具有动态大小。当追加或插入项时，或当`list`扩展为另一个`list`时，数组的边界将被调整。类似地，当项目被弹出或删除时，边界会缩小。我们可以快速访问任何项目，访问速度不取决于列表的大小。

在极少数情况下，我们可能希望创建一个具有给定初始大小的`list`，然后分别设置项目的值。我们可以使用如下列表来完成此操作：

```py
    some_list = [None for i in range(100)] 

```

这将创建一个初始大小为 100 个项目的列表，每个项目都是`None`。不过，很少需要这样做，因为列表可以根据需要增加大小。

列表理解语法和`list()`函数都使用生成器中的项，并附加它们以创建新的`list`对象。

## 还有更多。。。

我们创建`list`对象的目标是能够对其进行总结。为此，我们可以使用多种 Python 函数。以下是一些例子：

```py
>>> sizes = list(path.stat().st_size 
...    for path in home.glob('*/index.rst')) 
>>> sum(sizes) 
18392 
>>> max(sizes) 
3094 
>>> min(sizes) 
521 
>>> from statistics import mean 
>>> round(mean(sizes), 3) 
1414.769

```

我们已经使用内置的`sum()`、`min()`和`max()`对这些文档大小进行了一些描述性统计。这些索引文件中哪一个最小？我们想知道最小值在值列表中的位置。我们可以使用`index()`方法：

```py
>>> sizes.index(min(sizes)) 
11

```

我们找到了最小值，然后使用`index()`方法定位最小值的位置。回想一下，索引值从零开始，所以最小的文件是第十二章。

### 扩展列表的其他方式

我们可以扩展列表，也可以在列表的中间或开头插入。我们有两种方法来扩展列表：我们可以使用`+`操作符，也可以使用`extend()`方法。下面是一个创建两个列表并将它们与`+`组合在一起的示例：

```py
>>> ch1 = list(path.stat().st_size 
...    for path in home.glob('ch_01*/*.rst')) 
>>> ch2 = list(path.stat().st_size 
...    for path in home.glob('ch_02*/*.rst')) 
>>> len(ch1) 
13 
>>> len(ch2) 
12 
>>> final = ch1 + ch2 
>>> len(final) 
25 
>>> sum(final) 
104898

```

我们已经创建了一个文件大小列表，名称如`ch_01*/*.rst`。然后，我们创建了第二个文档大小列表，名称模式略有不同，`ch_02*/*.rst`。然后，我们将这两个列表合并成一个最终列表。

我们也可以使用`extend()`方法来实现这一点。我们将重用这两个列表并从中构建一个新列表：

```py
>>> final_ex = [] 
>>> final_ex.extend(ch1) 
>>> final_ex.extend(ch2) 
>>> len(final_ex) 
25 
>>> sum(final_ex) 
104898

```

我们注意到，`append()`不返回值。请注意，`extend()`也不返回值。`extend()`方法使`list`对象发生变异。

我们也可以在列表中任何特定位置之前插入一个值。`insert()`方法接受项目的位置；新值将位于给定位置之前：

```py
>>> p = [3, 5, 11, 13] 
>>> p.insert(0, 2) 
>>> p 
[2, 3, 5, 11, 13] 
>>> p.insert(3, 7) 
>>> p 
[2, 3, 5, 7, 11, 13]

```

我们在一个`list`对象中插入了两个新值。与`append()`和`extend()`一样，`insert()`不返回值。它变异了`list`对象。

## 另见

*   有关复制列表和从列表中选择子列表的方法，请参见*切片和切割列表*配方。
*   有关从列表中删除项目的其他方法，请参见*从列表中删除–删除、删除、弹出和过滤*配方。
*   在*反转列表*配方中，我们将查看反转列表。
*   本文提供了一些关于 Python 集合如何在内部工作的见解：[https://wiki.python.org/moin/TimeComplexity](https://wiki.python.org/moin/TimeComplexity) 。在查看表格时，需要注意的是，**O**（1）表示成本基本不变，**O**（n）表示成本随我们试图处理的项目的指数而变化。这意味着成本随着集合大小的增长而增长。

# 对列表进行切片和切割

很多时候，我们想从列表中挑选项目。最常见的处理方式之一是将列表的第一项作为特例处理。这导致了一种*头尾*处理，即我们对待列表的头部与列表尾部的项目不同。

我们也可以使用这些技术制作列表的副本。

## 准备好了吗

我们有一个电子表格，用来记录大型帆船的燃油消耗量。它具有如下所示的行：

<colgroup><col> <col> <col></colgroup> 
| **日期** | **发动机在**上 | **燃油高度** |
|  | **发动机关闭** |  |
|  | **其他注释** |  |
| 10/25/2013 | 08:24 | 29 |
|  | 13:15 | 27 |
|  | 平静的海洋锚定所罗门岛 |  |
| 10/26/2013 | 09:12 | 27 |
|  | 18:25 | 22 |
|  | 杰克逊河中的波涛汹涌的锚 |  |

燃料高度？对没有浮子传感器来估计油箱中的燃油油位。取而代之的是一个**目测表**，可以直接观察燃油。它的校准深度为英寸。对于所有实际用途来说，油箱都是矩形的，因此显示的深度可以很容易地转换为体积——31 英寸的深度约为 75 加仑。

重要的是电子表格数据没有正确规范化。理想情况下，每一行都遵循数据的第一个范式，每一行都有相同的内容，每一个单元格都只有原子值。

我们的数据没有正常化。我们有四行标题。这是`csv`模块无法直接处理的问题。我们需要做一些切片来删除其他注释中的行。我们希望将每天的两行行程合并起来，以便更容易地计算经过的时间和使用的英寸数。

我们可以这样读取数据：

```py
>>> from pathlib import Path 
>>> import csv 
>>> with Path('code/fuel.csv').open() as source_file: 
...    reader = csv.reader(source_file) 
...    log_rows = list(reader) 
>>> log_rows[0] 
['date', 'engine on', 'fuel height'] 
>>> log_rows[-1] 
['', "choppy -- anchor in jackson's creek", '']

```

我们已经使用`csv`模块读取日志详细信息。`csv.reader()`是一个可编辑的对象。为了将项目收集到单个列表中，我们应用了`list()`函数。我们查看了列表中的第一项和最后一项，以确认我们确实有一个列表结构列表。

原始 CSV 文件的每一行都是一个列表。每个列表都是一个三项子列表。

对于这个配方，我们将使用列表索引表达式的扩展来从列表中分割项目。与索引一样，切片以`[]`字符跟随列表对象。Python 为我们提供了切片表达式的几种变体。一个切片可以包括切片中的两个或三个值，由`:`字符分隔。我们可以写`:stop`、`start:`、`start:stop`、`start:stop:step`或其他任何变体。默认步长值为 1。默认的开始值是列表的开始，默认的停止值是列表的结束。

下面是我们如何对原始行列表进行切片和切分，以挑选出我们需要的行：

## 怎么做。。。

1.  The first thing we need to do is remove the four lines of heading from the list of rows. We'll use two partial slice expressions to divide the list at row four:

    ```py
     >>> head, tail = log_rows[:4], log_rows[4:] 
          >>> head[0] 
          ['date', 'engine on', 'fuel height'] 
          >>> head[-1] 
          ['', '', ''] 
          >>> tail[0] 
          ['10/25/13', '08:24:00 AM', '29'] 
          >>> tail[-1] 
          ['', "choppy -- anchor in jackson's creek", '']

    ```

    我们使用`log_rows[:4]`和`log_rows[4:]`将列表分为两部分。`head`变量将有四行标题。我们真的不想对头部进行任何处理，所以我们忽略了这个变量。然而，`tail`变量具有我们关心的表的行。

2.  We'll use slices with steps to pick the interesting rows. The `[start::step]` version of a slice will pick rows in groups based on the step value. In our case, we'll take two slices. One slice starts on row zero and the other slice starts on row one.

    这是每三行的一个片段，从第 0 行开始：

    ```py
     >>> tail[0::3] 
          [['10/25/13', '08:24:00 AM', '29'],
           ['10/26/13', '09:12:00 AM', '27']]

    ```

    我们还需要每三行，从第一行开始：

    ```py
     >>> tail[1::3] 
          [['', '01:15:00 PM', '27'], ['', '06:25:00 PM', '22']]

    ```

3.  These two slices can then be zipped together:

    ```py
     >>> list( zip(tail[0::3], tail[1::3]) )  
          [(['10/25/13', '08:24:00 AM', '29'], ['', '01:15:00 PM', '27']), 
           (['10/26/13', '09:12:00 AM', '27'], ['', '06:25:00 PM', '22'])]

    ```

    我们已将列表分为两个平行组：

    *   `[0::3]`切片从第一行开始，每三行包含一个。这将是第 0 行、第 3 行、第 6 行、第 9 行，依此类推。
    *   `[1::3]`切片从第二行开始，每三行包含一个。这将是第一行、第四行、第七行、第十行，依此类推。

    我们已经使用了`zip()`函数来交错列表中的这两个序列。这给了我们一个三元组的序列，非常接近我们可以使用的东西。

4.  Flatten the results:

    ```py
     >>> paired_rows = list( zip(tail[0::3], tail[1::3]) ) 
          >>> [a+b for a,b in paired_rows]  
          [['10/25/13', '08:24:00 AM', '29', '', '01:15:00 PM', '27'], 
           ['10/26/13', '09:12:00 AM', '27', '', '06:25:00 PM', '22']]

    ```

    我们使用了*构建列表的列表理解——文字、追加和理解*方法，将每对行中的两个元素组合起来，创建一行。现在我们可以将日期和时间转换为单个`datetime`值。然后我们可以计算时间差，得到船的运行时间，计算高度差，估计燃烧的燃料。

## 它是如何工作的。。。

切片运算符有几种不同的常见形式：

*   `[:]`：表示启动和停止。表达式`S[:]`将复制序列*S*。
*   `[:stop]`：从开始到停止值之前创建一个新列表。
*   `[start:]`：从给定的开始到序列的结束创建一个新列表。
*   `[start:stop]`：选择从开始索引开始并在停止索引之前停止的子列表。Python 以半开的间隔工作。包括起点，不包括终点。
*   `[::step]`：启动和停止是隐含的，包括整个序列。步骤通常不等于一意味着我们将使用步骤从一开始跳过列表。对于给定步骤*s*和大小列表*L*，索引值为![How it works...](img/Image00010.jpg)。
*   `[start::step]`：给出了启动，但暗示了停止。其思想是起点是一个偏移量，步长应用于该偏移量。对于给定的开始、*a*、步骤、*s*和大小列表*L*的索引值为![How it works...](img/Image00011.jpg)。
*   `[:stop:step]`：用于防止处理列表中的最后几项。由于给出了步骤，处理从元素零开始。
*   `[start:stop:step]`：这将从序列的子集中拾取元素。不得使用启动前和停止后的项目。

切片技术适用于列表、元组、字符串和任何其他类型的序列。这不会导致对象发生变异；这将制作项目的副本。

## 还有更多。。。

在*反转列表*配方的副本中，我们将看到切片表达式的更复杂用法。

该副本称为**浅层副本**，因为我们将有两个集合，其中包含对相同底层对象的引用。我们将在*制作对象*的浅拷贝和深拷贝配方中详细介绍这一点。

对于这个特定的示例，我们有另一种方法将多行数据重组为单行数据。我们可以使用生成器函数。我们将在[第 8 章](08.html#page "Chapter 8. Functional and Reactive Programming Features")、*函数式和反应式编程特性*中介绍函数式编程技术。

## 另见

*   有关创建列表的方法，请参见*构建列表–文字、附加和理解*配方
*   有关从列表中删除项目的其他方法，请参见*从列表中删除–删除、删除、弹出和过滤*配方
*   在*反转列表*配方中，我们将查看反转列表

# 从列表中删除–删除、删除、弹出和过滤

有很多次我们想从`list`收藏中删除项目。我们可以从列表中删除项目，然后处理剩余的项目。

删除不需要的项目与使用`filter()`创建只包含所需项目的副本的效果类似。区别在于过滤后的副本将比从列表中删除项目使用更多的内存。我们将展示从列表中删除不需要的项的两种技术。

## 准备好了吗

我们有一个电子表格，用于记录大型帆船的燃油消耗量。它具有如下所示的行：

<colgroup><col> <col> <col></colgroup> 
| **日期** | **发动机在**上 | **燃油高度** |
|  | **发动机关闭** |  |
|  | **其他注释** |  |
| 10/25/2013 | 08:24 | 29 |
|  | 13:15 | 27 |
|  | 平静的海洋锚定所罗门岛 |  |
| 10/26/2013 | 09:12 | 27 |
|  | 18:25 | 22 |
|  | 杰克逊河中的波涛汹涌的锚 |  |

有关此数据的更多背景信息，请参阅*切片和切割列表*配方。

我们可以这样读取数据：

```py
>>> from pathlib import Path 
>>> import csv 
>>> with Path('code/fuel.csv').open() as source_file: 
...    reader = csv.reader(source_file) 
...    log_rows = list(reader) 
>>> log_rows[0] 
['date', 'engine on', 'fuel height'] 
>>> log_rows[-1] 
['', "choppy -- anchor in jackson's creek", '']

```

我们已经使用`csv`模块读取日志详细信息。`csv.reader()`是一个可编辑的对象。为了将项目收集到单个列表中，我们应用了`list()`函数。我们查看了列表中的第一项和最后一项，以确认我们确实有一个列表结构列表。

原始 CSV 文件的每一行都是一个列表。每个列表都有三个项目。

## 怎么做。。。

我们将研究四种从列表中删除内容的方法：

*   `del`声明
*   `remove()`方法
*   `pop()`方法
*   使用`filter()`函数创建拒绝所选行的副本

### 从列表中删除项目

我们可以使用`del`语句从列表中删除项目。

为了便于在交互式提示下理解示例，我们将制作一份列表副本。如果我们从原始的`log_rows`列表中删除行，后续的示例可能很难理解。在实际的程序中，我们不会制作这个额外的副本。我们也可以使用`log_rows[:]`复制原始列表。

```py
>>> tail = log_rows.copy()

```

以下是`del`声明的内容：

```py
>>> del tail[:4] 
>>> tail[0] 
['10/25/13', '08:24:00 AM', '29'] 
>>> tail[-1] 
['', "choppy -- anchor in jackson's creek", '']

```

`del`语句从尾部删除了头行，留下了我们真正需要处理的行。然后，我们可以将它们结合起来，并使用*切片和切割列表*的方法对它们进行总结。

### remove（）方法

我们可以使用`remove()`方法从列表中删除项目。这将从列表中删除匹配项。

我们可能有这样一个列表：

```py
>>> row = ['10/25/13', '08:24:00 AM', '29', '', '01:15:00 PM', '27']

```

这里面有一个无用的`''`字符串：

```py
>>> row.remove('') 
>>> row 
['10/25/13', '08:24:00 AM', '29', '01:15:00 PM', '27']

```

请注意，`remove()`方法不返回值。它改变了现有的列表。这是适用于可变对象的一个重要区别。

### 提示

`remove()`方法不返回值。

它改变列表对象。

看到这样的错误代码是非常常见的：

`a = ['some', 'data']`

`a = a.remove('data')`

这显然是错误的。这将把`a`设置为`None`。

### pop（）方法

我们可以使用`pop()`方法从列表中删除项目。这将根据项目的索引从列表中删除项目。

我们可能有这样一个列表：

```py
>>> row = ['10/25/13', '08:24:00 AM', '29', '', '01:15:00 PM', '27']

```

这里面有一个无用的`''`字符串：

```py
>>> target_position = row.index('') 
>>> target_position 
3 
>>> row.pop(target_position) 
'' 
>>> row 
['10/25/13', '08:24:00 AM', '29', '01:15:00 PM', '27']

```

注意，`pop()`方法做两件事：

*   它变异了`list`对象
*   它返回已删除的值

### filter（）函数

我们还可以通过构建一个副本来删除项目，该副本传递所需的项目并拒绝不需要的项目。下面是我们如何使用`filter()`函数来实现这一点。

1.  Identify the features of the items we wish to pass or reject. The `filter()` function expects a rule for passing data. The logical inverse of that function will reject data.

    在我们的例子中，我们想要的行在第二列中有一个数值。我们可以通过一个辅助函数来最好地检测到这一点。

2.  Write the filter test function. If it's trivial, use a lambda object. Otherwise, write a separate function:

    ```py
     >>> def number_column(row, column=2): 
          ...    try: 
          ...        float(row[column]) 
          ...        return True 
          ...    except ValueError: 
          ...        return False

    ```

    我们使用了内置的`float()`函数来查看给定的字符串是否是正确的数字。如果`float()`函数未引发异常，则数据为有效数字，我们希望传递此行。如果引发异常，则数据不是数字，我们将拒绝该行。

3.  Use the filter test function (or lambda) with the data in the `filter()` function:

    ```py
     >>> tail_rows = list(filter(number_column, log_rows)) 
          >>> len(tail_rows) 
          4 
          >>> tail_rows[0] 
          ['10/25/13', '08:24:00 AM', '29'] 
          >>> tail_rows[-1] 
          ['', '06:25:00 PM', '22']

    ```

    我们提供了我们的测试`number_column()`和原始数据`log_rows`。`filter()`函数的输出是一个 iterable。要从 iterable 结果创建列表，我们将使用`list()`函数。结果只有我们想要的四行；其余行被拒绝。

    我们还没有真正删除这些行。我们创建了一个忽略这些行的副本。最终结果是一样的。

## 它是如何工作的。。。

因为列表是一个可变对象，所以我们可以从列表中删除项。这种技术不适用于元组或字符串。这三个集合都是序列，但只有列表是可变的。

我们只能删除列表中存在索引的项。如果我们试图删除索引超出允许范围的项，我们将得到一个`IndexError`异常。

例如：

```py
>>> row = ['', '06:25:00 PM', '22'] 
>>> del row[3]  
Traceback (most recent call last): 
  File "<pyshell#38>", line 1, in <module> 
    del row[3] 
IndexError: list assignment index out of range

```

## 还有更多。。。

有些时候这是行不通的。如果我们在`for`语句中使用列表，则无法从列表中删除项目。

假设我们要从列表中删除所有偶数项。下面是一个无法正常工作的示例：

```py
>>> data_items = [1, 1, 2, 3, 5, 8, 10, 
...    13, 21, 34, 36, 55] 
>>> for f in data_items: 
...    if f%2 == 0: data_items.remove(f) 
>>> data_items 
[1, 1, 3, 5, 10, 13, 21, 36, 55]

```

结果显然是不对的。为什么列表中还有一些价值相等的项目？

让我们看看处理值为 8 的项时会发生什么。我们将执行`remove()`方法。该值将被删除，所有后续值将向前滑动一个位置。`10`将被移动到`8`之前占据的位置。列表的内部索引将向前移动到下一个位置，其中将包含一个`13`。`10`将永远不会被处理。

如果我们在列表中间插入一个`for`循环中的驱动变量，也会发生不好的事情。在这种情况下，项目将被处理两次。

我们有两种方法可以避免删除时的*跳过问题：*

*   复制一份清单：

    ```py
            for f in data_items[:]: 

    ```

*   使用带有手动索引的`while`循环：

    ```py
     >>> data_items = [1, 1, 2, 3, 5, 8, 10, 
          ...    13, 21, 34, 36, 55] 
          >>> position = 0 
          >>> while position != len(data_items): 
          ...    f= data_items[position] 
          ...    if f%2 == 0: 
          ...        data_items.remove(f) 
          ...    else: 
          ...        position += 1 
          >>> data_items 
          [1, 1, 3, 5, 13, 21, 55]

    ```

我们设计了一个循环，当项目为奇数时，它只增加位置。如果某个项目是偶数，则会将其删除，而其他项目会在列表中向前移动一个位置。

## 另见

*   有关创建列表的方法，请参见*构建列表–文字、附加和理解*配方
*   有关复制列表和从列表中选择子列表的方法，请参见*切片和切割列表*配方
*   在*反转列表*配方中，我们将查看反转列表

# 撤销清单副本

偶尔，我们需要颠倒`list`集合中项目的顺序。例如，某些算法以相反的顺序生成结果。我们将了解转换为特定基数的数字通常从最低有效位到最高有效位的生成方式。我们通常希望先显示具有最高有效位的值。这就需要颠倒列表中的数字顺序。

我们有两种方法来反转列表。首先是`reverse()`方法。还有一个很方便的窍门。

## 准备好了吗

假设我们正在做一个数基之间的转换。我们将看看一个数字是如何在一个基数中表示的，以及我们如何从一个数字计算这个表示。

任何值*v*都可以定义为给定基数*b*中各种数字*d<sub>n</sub>*的多项式函数：

*v*=*d<sub>n</sub>*×*b<sup>n</sup>*+*d<sub>n</sub>*<sub>-1</sub>×*b<sup>n</sup>*<sup>-1</sup>d<sub><sub>-1】</sub><sub>b<sup>n</sup>*<sup>-1】</sup>*</sub></sub>*<sub>-T26】**】**</sub>×*b<sup>n</sup>*<sup>-2</sup>+…+*d*<sub>1</sub>×*b*+*d*<sub>0</sub>*

有理数的位数是有限的。一个无理数将有一个无限的数字序列。

例如，数字`0xBEEF`是以 16 为基数的值。数字为{*B*=11、*E*=14、*F*=15}，基数为*B*=16。

48879=11×16<sup>3</sup>+14×16<sup>2</sup>+14×16+15

我们可以用一种计算效率略高的形式重申这一点：

*v*=（…（*d<sub>n</sub>*×T6】b+*d<sub>n</sub>*<sub>-1</sub>×T14】b+*d【T17 n】*-2×T22】+*<sub>1</sub>×*b*+*d*<sub>0</sub>*

 *在很多情况下，基数不是某个数的一致幂。例如，ISO 日期格式有一个混合基数，包括每周 7 天、每天 24 小时、每小时 60 分钟和每分钟 60 秒。

给定一周数、一周中的一天、一小时、一分钟和一秒钟，我们可以计算给定年份内秒的时间戳*t<sub>s</sub>*。

*t<sub>s</sub>*=（（（*w*×7+*d*×24+*h*）×60+*m*×60+*s*

例如：

```py
>>> week = 13 
>>> day = 2 
>>> hour = 7 
>>> minute = 53 
>>> second = 19 
>>> t_s = (((week*7+day)*24+hour)*60+minute)*60+second 
>>> t_s 
8063599

```

我们如何反转这个计算？如何从总的时间戳中获取各个字段？

我们需要使用`divmod`样式划分。有关一些背景信息，请参见*在真实分区和楼层分区*之间的选择。

将以秒为单位的时间戳*t<sub>s</sub>*转换为单个周、日和时间字段的算法如下所示：

*t<sub>m</sub>*、*s*← *t<sub>s</sub>*/60、*t<sub>s</sub>*mod 60

*t<sub>h</sub>*、*m*← *t<sub>m</sub>*/60、*t<sub>m</sub>*mod 60

*t<sub>d</sub>*、*h*← *t<sub>h</sub>*/60、*t<sub>h</sub>*mod 24

*w*、*d*← *t<sub>d</sub>*/60、*t<sub>d</sub>*mod 7

这有一个方便的模式，可以实现一个非常简单的实现。其结果是按相反顺序生成值：

```py
>>> t_s = 8063599 
>>> fields = [] 
>>> for b in 60, 60, 24, 7: 
...    t_s, f = divmod(t_s, b) 
...    fields.append(f) 
>>> fields.append(t_s) 
>>> fields 
[19, 53, 7, 2, 13]

```

我们已经应用了四次`divmod()`函数，从以秒为单位的时间戳中提取秒、分钟、小时、天和周。这些顺序不对。我们怎样才能扭转局面？

## 怎么做。。。

我们有两种方法：我们可以使用`reverse()`方法，也可以使用`[::-1]`切片表达式。以下是`reverse()`方法：

```py
>>> fields_copy1 = fields.copy() 
>>> fields_copy1.reverse() 
>>> fields_copy1 
[13, 2, 7, 53, 19]

```

我们制作了一份原始列表的副本，这样我们就可以保留一份未变异的副本与变异的副本进行比较。这使得遵循示例变得更容易。我们使用`reverse()`方法来反转列表的副本。

这将改变列表。与其他变异方法一样，它不会返回有用的值。使用这样的语句是错误的：`a = b.reverse()`。`a`的值始终为`None`。

下面是一个带有负步骤的切片表达式：

```py
>>> fields_copy2 = fields[::-1] 
>>> fields_copy2 
[13, 2, 7, 53, 19]

```

在这个例子中，我们制作了一个切片`[::-1]`，它使用了一个隐含的开始和停止，步骤是`-1`。这将按相反顺序拾取列表中的所有项目，以创建新列表。

原来的列表显然是*而不是*被这个`slice`操作变异的。这将创建一个副本。检查`fields`变量的值是否保持不变。

## 它是如何工作的。。。

正如我们在*切片和切割列表*配方中所指出的，切片表示法非常复杂。使用步长为负的切片将创建一个副本（或子集），其中的项目按从右到左的顺序处理，而不是默认的从左到右的顺序。

区分这两种方法很重要：

*   `reverse()`函数修改`list`对象本身。与`append()`和`remove()`等方法一样，此方法没有返回值。因为它会更改列表，所以不会返回值。
*   `[::-1]`切片表达式创建一个新列表。这是原始列表的浅表副本，顺序颠倒。

## 另见

*   请参阅*制作对象的浅拷贝和深拷贝*配方，以了解关于什么是浅拷贝以及为什么要制作深拷贝的更多信息
*   有关创建列表的方法，请参见*构建列表–文字、附加和理解*配方
*   有关复制列表和从列表中选择子列表的方法，请参见*切片和切割列表*配方
*   有关从列表中删除项目的其他方法，请参见*从列表中删除–删除、删除、弹出和过滤*配方

# 使用集合方法和运算符

我们有几种方法来建立一个`set`收藏。我们可以使用`set()`函数将现有集合转换为集合。我们可以使用`add()`方法将项目放入一个集合中。我们还可以使用`update()`方法和并集运算符`|`从其他集合创建更大的集合。

我们将展示一个配方，它使用`set`来显示我们是否从统计数据池中看到了完整的值域。在扫描样本时，配方将建立一个`set`集合。

在进行探索性数据分析时，我们需要回答以下问题：*该数据是随机的吗？*许多数据采集的数据中存在方差，这些方差属于普通噪声。重要的是不要浪费时间对随机数进行复杂的建模和分析。

对于离散或连续的数字数据，如以米为单位的水深，或以字节为单位的文件大小，我们可以使用平均值和标准偏差来查看给定的数据集合是否随机。我们期望样本的平均值与标准偏差测量范围内的总体平均值相匹配。

对于分类数据，如客户 ID 号或电话号码，我们无法计算平均值或标准差。这些值必须以不同的方式进行评估。

确定分类数据随机性的一种技术是**优惠券收集者测试**。通过此测试，我们将了解在找到一套完整的*优惠券*之前需要检查多少项目。客户访问的顺序是随机的吗？或者在访问顺序中是否存在其他分布？如果数据不是随机的，那么我们可以投资更多的研究来找出原因。

Python`set`集合是如何工作的核心。我们将在`set`中添加项目，直到我们见过每位客户一次。

如果客户随机到达，我们可以在业务部门至少见到每位客户一次之前预测预期的访问次数。整个域的总预期到达时间是域中每个客户的到达时间之和。这等于客户数量*n*乘以 n<sup>th</sup>谐波数*H<sub>n</sub>*：

*E*=*n*×*H<sub>n</sub>*=*n*×（（1/1）+（1/2）+（1/3）+（1/*n*）

这是看到所有客户之前的预期平均访问次数。如果实际平均到达时间与此预期相符，则表示所有客户都在访问；我们不需要再浪费时间研究符合我们期望的数据。如果实际平均值与期望值不符，那么一些客户的访问频率就不如其他客户高，我们需要深入研究原因。

## 准备好了吗

我们将使用 Python`set`来表示优惠券的集合。我们需要一组数据，这些数据可能（也可能不）具有*优惠券*的适当分布。我们将看一组八位客户。

这里有一个函数，它模拟以随机顺序到达的客户。客户以半开放区间[0，*n*中的数字表示，可以说所有客户，*c*都符合规则 0≤ *c*<*n*。

```py
>>> import random 
>>> def arrival1(n=8): 
...     while True: 
...         yield random.randrange(n)

```

`arrival1()`函数将产生一系列无休止的值。我们称之为`arrival`，末尾有`1`。这看起来可能是一个拼写错误，但我们使用了`1`后缀，这样我们就可以创建替代实现。

我们需要对生成的值的数量设置一个上限。这是一个对生成的样本数有上限的函数：

```py
>>> def samples(limit, generator): 
...     for n, value in enumerate(generator): 
...         if n == limit: break 
...         yield value

```

此生成器功能使用另一个生成器作为项目源。我们的想法是使用`arrival1()`函数。`samples()`函数枚举较大集合中的项目，并在看到足够的项目时停止。因为`arrival1()`函数是无限的，所以这个边界是必要的。

下面是我们如何使用这些函数来模拟客户的到来。我们将生成一系列客户 ID 号：

```py
>>> random.seed(1) 
>>> list(samples(10, arrival1())) 
[2, 1, 4, 1, 7, 7, 7, 6, 3, 1]

```

我们强制随机数生成器具有特定的种子值，以便生成已知的测试序列。我们将`samples()`函数应用于`arrival1()`函数，以生成 10 次客户访问的序列。七号顾客似乎有很多回头客。零号和五号顾客根本没有出现。

这只是对数据的模拟。企业将使用销售收据来确定客户访问。网站可能会在数据库中记录访问，也可能会刮取 web 日志以确定实际值的顺序。

在我们见到全部八位客户之前，预期的访问量是多少？

```py
>>> from fractions import Fraction 
>>> def expected(n=8): 
...     return n * sum(Fraction(1,(i+1)) for i in range(n))

```

此函数创建分数系列 1/1、1/2，最多 1/*n*。将其相加并乘以*n*。

```py
>>> expected(8) 
Fraction(761, 35) 
>>> round(float(expected(8))) 
22

```

平均而言，我们需要 22 次客户拜访，才能一次见到全部 8 位客户。

在我们看到所有八位客户之前，我们如何使用`set`集合来统计实际访问量？

## 怎么做。。。

当我们逐步完成每次客户访问时，我们将把客户 ID 放入`set`集合中。重复项不会保存在集合中。一旦客户 ID 是集合的成员，再次添加值不会更改集合。我们将总结此配方中的步骤，然后展示完整的功能：

1.  从一个空的`set`和一个零计数器开始。
2.  开始`for`循环以访问所有数据项。
3.  将下一项添加到`set`中。在柜台上加一个。
4.  如果`set`完成，则可以进行计数。这是查看完整套件所需的客户数。让步后，清空`set`并将计数器初始化为零，为下一个客户做准备。

下面是函数：

```py
    def coupon_collector(n, data): 
        count, collection = 0, set() 
        for item in data: 
            count += 1 
            collection.add(item) 
            if len(collection) == n: 
                yield count 
                count, collection = 0, set() 

```

这将在零开始一个`count`，并创建一个空集`collection`，我们将在其中收集客户 ID。我们将按源数据值的顺序逐步检查每一项，`data`。`count`的值表示有多少访客。变量`collection`的值是一组不同的访问者。

`set`的`add()`方法将对集合进行变异，以添加一个不同的值。如果该值已在集合中，则内容不会更改。

当收集的数量达到我们目标人群的数量时，我们就有了一整套优惠券。我们可以得出`count`的值。我们还重置了访问次数，并为我们收集的优惠券创建了一个新的空集。

## 它是如何工作的。。。

由于这是一个生成器，我们需要通过根据结果创建一个`list`对象来捕获数据。下面是我们如何使用`coupon_collector()`函数：

```py
    from statistics import mean 
    expected_time = float(expected(n)) 
    data = samples(100, arrival1()) 
    wait_times = list(coupon_collector(n, data)) 
    average_time = mean(wait_times) 

```

我们已经计算了会见所有客户的预期时间。我们使用`samples(100, arrival1())`作为模拟来创建`data`变量，该变量具有访问序列。在现实生活中，我们会分析销售收入来收集访问序列。

我们对数据进行了优惠券收集测试。这发出了一系列值，显示了创建一套完整的*优惠券*或客户 ID 需要多少客户。此计数顺序应接近预期的访问次数。我们将此序列分配给变量`wait_times`，因为我们测量了在看到样本集中的所有客户之前需要等待的时间。

这使我们能够轻松地将实际数据与预期数据进行比较。我们刚才看到的函数`arrival1()`产生的平均值非常接近预期值。由于输入数据是随机的，因此模拟不会生成与预期精确匹配的值。

优惠券收集器的测试依赖于收集一组优惠券。在这种情况下，术语**集合**用于最能代表数据的精确数学形式。

给定项要么是集合的成员，要么不是。我们不能多次将其添加到集合中。例如，我们可以手动创建集合并向其中添加项目：

```py
>>> collection = set() 
>>> collection.add(1) 
>>> collection 
{1}

```

当我们再次尝试添加此项时，`set`的值不变。

```py
>>> collection.add(1) 
>>> collection 
{1} 
>>> 1 in collection 
True

```

这是收集优惠券的完美数据表示。

请注意，`add()`方法不返回值。它变异了`set`对象。这与`list`采集工作的方式方法类似。通常，改变集合的方法不会返回值。此模式的唯一例外是`pop()`方法，它既变异`set`对象，又返回弹出的值。

## 还有更多。。。

我们有几种方法向`set`添加项目：

*   该示例使用了`add()`方法。这适用于单个项目。
*   我们可以使用`union()`方法。这就像一个操作符，它创建了一个新的结果`set`。它不改变任何一个操作数集。
*   我们可以使用`|`并集运算符来计算两个集合的并集。
*   我们可以使用`update()`方法使用另一个集合中的项目更新一个集合。这会对集合进行变异，并且不会返回值。

对于其中的大多数，我们需要从要添加的项创建一个单例`set`。下面是一个示例，通过将单个项`3`转换为单个项集，将其添加到集合中：

```py
>>> collection 
{1} 
>>> item = 3 
>>> collection.union( {item} ) 
{1, 3} 
>>> collection 
{1} 

```

在这里，我们创建了一个单例集合，`{item}`来自`item`变量的值。然后，我们使用`union()`方法计算一个新集合，即`collection`和`{item}`的并集。

注意，`union()`返回一个结果对象，并保持原始`collection`设置不变。我们需要将其用作`collection = collection.union({item})`来更新`collection`对象。

这是使用联合运算符`|`的另一个备选方案：

```py
>>> collection = collection | {item} 
>>> collection 
{1, 3}

```

这与{1，3}的常用数学表示法相似∪ {3} ≡ {1, 3}.

我们也可以使用`update()`方法：

```py
>>> collection.update( {4} ) 
>>> collection 
{1, 3, 4}

```

此方法对`set`对象进行变异。因为它改变了集合，所以不返回值。

Python 有许多集合运算符。这些是我们可以在复杂表达式中使用的普通运算符符号：

*   `|`为联合体，通常排版为*A*∪ *B*
*   `&`用于交叉口，通常排版为*A*∩ *B*
*   `^`对称性差，常排版为*A*Δ*B*
*   `-`用于减法，通常排版为*A*-*B*

## 另见

*   在*从集合中移除项目–移除、弹出和差异*配方中，我们将了解如何通过移除或替换项目来更新集合

# 从集合中移除项目–移除（）、弹出（）和差异

Python 为我们提供了几种从`set`集合中删除项的方法。我们可以使用`remove()`方法删除特定项目。我们可以使用`pop()`方法删除任意项目。

此外，我们可以使用集合交集、差分和对称差分算子计算新集合：`&`、`-`和`^`。这些将产生一个新的集合，它是给定输入集合的子集。

## 准备好了吗

有时，我们会有日志文件，其中包含具有复杂和不同格式的行。下面是一个长而复杂的日志中的小片段：

```py
>>> log = ''' 
... [2016-03-05T09:29:31-05:00] INFO: Processing ruby_block[print IP] action run (@recipe_files::/home/slott/ch4/deploy.rb line 9) 
... [2016-03-05T09:29:31-05:00] INFO: Installed IP: 111.222.111.222 
... [2016-03-05T09:29:31-05:00] INFO: ruby_block[print IP] called 
... 
...  - execute the ruby block print IP 
... [2016-03-05T09:29:31-05:00] INFO: Chef Run complete in 23.233811181 seconds 
... 
... Running handlers: 
... [2016-03-05T09:29:31-05:00] INFO: Running report handlers 
... Running handlers complete 
... [2016-03-05T09:29:31-05:00] INFO: Report handlers complete 
... Chef Client finished, 2/2 resources updated in 29.233811181 seconds 
... '''

```

我们需要在日志中找到`IP: 111.222.111.222`行。

下面是我们如何做到这一点：

```py
>>> import re 
>>> pattern = re.compile(r"IP: \d+\.\d+\.\d+\.\d+") 
>>> matches = set( pattern.findall(log) ) 
>>> matches 
{'IP: 111.222.111.222'}

```

较大日志文件的问题在于，在某些地方，目标行具有真实信息。这些线条看起来很相似，但只是一些例子。我们还将找到类似于`IP: 1.2.3.4`的行，这是不相关的输出。事实证明，在这些不相关的行中，有几种是我们想要忽略的。

这是一个集合交集和集合减法非常有用的地方。

## 怎么做。。。

1.  创建一组我们想忽略的项目：

    ```py
     >>> to_be_ignored = {'IP: 0.0.0.0', 'IP: 1.2.3.4'}

    ```

2.  从日志中收集所有条目。我们将使用`re`模块进行此操作，如前所示。假设我们拥有的数据包括好地址加上来自日志其他部分的伪地址和占位符地址：

    ```py
     >>> matches = {'IP: 111.222.111.222', 'IP: 1.2.3.4'}

    ```

3.  Remove items from the set of matches using a form of set subtraction. Here are two examples:

    ```py
     >>> matches - to_be_ignored 
          {'IP: 111.222.111.222'} 
          >>> matches.difference(to_be_ignored) 
          {'IP: 111.222.111.222'}

    ```

    请注意，这两个操作符都返回新的集作为其结果。这两种方法都不会改变基础集合对象。

我们经常在这样的语句中使用这些语句：

```py
>>> valid_matches = matches - to_be_ignored 
>>> valid_matches 
{'IP: 111.222.111.222'}

```

这将把结果集分配给一个新变量`valid_matches`，这样我们就可以对这个新的集合进行所需的处理。

在这种情况下，如果该项不在集合中，则不会引发`KeyError`异常。

## 它是如何工作的。。。

`set`对象只跟踪成员身份。项目在`set`中或不在`set`中。我们指定要删除的项。删除项不依赖于索引位置或键值。

因为我们有`set`操作符，所以我们可以从目标`set`中删除一个`set`中的任何项。我们不需要单独处理这些项目。

## 还有更多。。。

我们有几种从集合中删除项目的方法：

*   在这个例子中，我们使用了`difference()`方法和`-`操作符。`difference()`方法的行为类似于运算符，并创建一个新集合。
*   我们也可以使用`difference_update()`方法。这将在适当的位置对集合进行变异。它不返回值。
*   我们可以使用`remove()`方法删除单个项目。
*   我们还可以使用`pop()`方法删除任意项。这不适用于这个示例，因为我们无法控制弹出哪个项。

以下是`difference_update()`方法的外观：

```py
>>> valid_matches = matches.copy() 
>>> valid_matches.difference_update( to_be_ignored ) 
>>> valid_matches 
{'IP: 111.222.111.222'}

```

首先，我们复制了原始`matches`集。这创建了一个新集合，我们将其分配给`valid_matches`集合。然后，我们应用`difference_update()`方法从该集合中删除不需要的项目。

由于集合发生了变异，因此不会返回任何值。此外，由于集合是副本，因此不会修改原始`matches`集合。

我们可以这样做来使用`remove()`方法。请注意，如果集合中没有项目，`remove()`将引发异常。

```py
>>> valid_matches = matches.copy() 
>>> for item in to_be_ignored: 
...    if item in valid_matches: 
...        valid_matches.remove(item) 
>>> valid_matches 
{'IP: 111.222.111.222'}

```

在尝试移除之前，我们测试了该项目是否在`valid_matches`集合中。这是避免引发`KeyError`异常的一种方法。另一种方法是使用`try:`语句来消除异常。

`pop()`方法删除任意项。它对集合进行变异，并返回已删除的项。如果我们试图从空集弹出项目，我们将引发一个`KeyError`异常。

## 另见

*   在*使用集合方法和运算符*配方中，我们将研究其他创建集合的方法

# 创建字典-插入和更新

字典是 Python 映射的一种。内置类型`dict`类提供了许多常见特性。`collections`模块中定义的这些特性有一些常见的变化。

正如我们在*选择数据结构*配方中所指出的，当我们有一些需要映射到给定值的键时，我们将使用字典。例如，我们可能希望将单个单词映射到该单词的长而复杂的定义。或者，可以将某个值转换为该值在数据集中出现的次数。

*键和计数*字典非常常见。我们将看一个详细的配方，它显示了如何初始化字典和更新计数器。

在*使用集合方法和运算符*配方中，我们观察了客户到达企业的情况。在该配方中，我们使用了一组来确定在企业收集完整的访问集之前需要多少访问。

## 准备好了吗

在本食谱中，我们将创建一个直方图，显示每个客户访问的次数。为了创建一些有趣的数据，我们将修改其他配方中使用的示例生成器。

在前面的示例中，我们使用了一个简单、统一的随机数生成器来挑选客户序列。这是另一种选择客户的方法，该客户生成的随机数的分布略有不同：

```py
>>> def arrival2(n=8): 
...     p = 0 
...     while True: 
...         step = random.choice([-1,0,+1]) 
...         p += step 
...         yield abs(p) % n

```

这使用了一种称为**随机游走**的技术来生成下一个客户 ID 号。它将从零开始，然后进行三个更改之一。它可以使用同一客户或两个相邻客户号码中的一个。使用表达式`abs(p) % n`可以计算任何整数值，并将数字*p*映射到范围 0≤ *p*<*n*。

下面是一个生成一些数据的工具，我们可以使用这些数据来模拟客户的到来：

```py
>>> import random 
>>> from ch04_r06 import samples, arrival2 
>>> random.seed(1) 
>>> list( samples(10, arrival2(8)) ) 
[1, 0, 1, 1, 2, 2, 2, 2, 1, 1] 

```

这向我们展示了`arrival2()`函数如何模拟那些倾向于围绕 customer zero 起始值聚集的客户。如果我们在*使用集合方法和运算符*配方中使用它进行优惠券收集器的测试，我们将看到该生成器创建的样本数据无法通过该测试。笨拙的到达时间意味着我们必须先看到数量惊人的客户，然后才能收集到所有 8 个不同的客户。

直方图统计每个客户的出现次数。我们将使用字典将客户 ID 映射到我们见过客户的次数。

## 怎么做。。。

1.  使用`{}`创建一个空字典。我们也可以使用`dict()`创建一个空字典。因为我们将创建一个统计每个客户到达次数的柱状图，所以我们将其称为`histogram`：

    ```py
            histogram = {} 

    ```

2.  对于每个客户号码，如果是新的，则在字典中添加一个空列表。我们可以通过一个`if`语句或者使用字典中的`setdefault()`方法来实现这一点。我们先展示`if`语句版本。稍后，我们将关注`setdefault()`优化。
3.  增加字典中的值。

下面是计算字典中出现次数的结果循环。它通过创建和更新项目来工作：

```py
    for customer in source: 
        if customer not in histogram: 
            histogram[customer]= 0 
        histogram[customer] += 1 

```

完成后，我们将统计每个客户的模拟访问总数。

我们可以把它变成一个方便的条形图来比较频率。我们可以计算一些基本的描述性统计数据，包括平均值和标准差，以查看是否有客户过度代表或代表不足。

## 它是如何工作的。。。

字典的核心功能是从一个不可变的值映射到任何类型的对象。在本例中，我们使用了一个不可变的数字作为键，另一个数字作为值。计数时，我们替换与键关联的值。

这样写似乎有点不寻常：

```py
    histogram[customer] += 1 

```

或者写：

```py
    histogram[customer] = histogram[customer] + 1 

```

并将字典中的值视为被*替换*。当我们编写一个像`histogram[customer] + 1`这样的表达式时，我们正在从另外两个整数对象计算一个新的整数对象。此新对象将替换字典中的旧值。

字典键对象必须是不可变的。我们不能使用`list`、`set`或`dict`作为字典映射中的键。然而，我们可以将一个列表转换成一个不可变的元组，或者将一个`set`转换成一个`frozenset`，这样我们就可以使用其中一个更复杂的对象作为键。

## 还有更多。。。

我们不必使用`if`语句来添加丢失的密钥。我们可以使用字典的`setdefault()`方法。我们的循环如下所示：

```py
    histogram = {} 
    for customer in source: 
        histogram.setdefault(customer, 0) 
        histogram[customer] += 1 

```

如果键值`customer`不存在，则提供默认值。如果密钥确实存在，`setdefault()`方法不做任何操作。

`collections`模块提供了许多可选映射，我们可以使用这些映射来代替默认的`dict`映射。

*   `defaultdict`：这个集合使我们不必显式地编写第二步。我们提供一个初始化函数作为创建`defaultdict`的一部分。我们将很快看一个例子。
*   `OrderedDict`：此集合按最初创建的顺序保留密钥。我们将此保存为*控制 dict 键*配方的顺序。
*   `Counter`：此集合在创建时执行整个**键和计数**算法。我们很快也会看到这一点。

以下是使用`defaultdict`类的版本：

```py
    from collections import defaultdict 
    def summarize_3(source): 
        histogram = defaultdict(int) 
        for item in source: 
            histogram[item] += 1 
        return histogram 

```

我们已经创建了一个`defaultdict`实例，它将使用`int()`函数初始化任何未知的键值。我们向`defaultdict`构造函数提供`int`-函数对象。`defaultdict`将评估给定的函数对象以创建默认值。

这使得我们可以简单地使用`histogram[item] += 1`。如果`item`属性的值是字典中的上一个，则它将递增。如果`item`属性的值不在字典中，则对`int`函数求值，并将其作为默认值。

另一种方法是创建一个`Counter`对象。我们需要导入`Counter`类，以便从原始数据构建`Counter`对象。

```py
>>> from collections import Counter 
>>> def summarize_4(source): 
...    histogram = Counter(source) 
...    return histogram

```

当我们从数据源创建一个`Counter`时，类将扫描数据并统计不同的事件。这个类实现了整个配方。

结果如下：

```py
>>> import random 
>>> from pprint import pprint 
>>> random.seed(1) 
>>> histogram = summarize_4(samples(1000, arrival2(8))) 
>>> pprint(histogram) 
Counter({1: 150, 0: 130, 2: 129, 4: 128, 5: 127, 6: 118, 3: 117, 7: 101})

```

注意，`Counter`对象按计数值的降序显示值。`OrderedDict`对象将按照创建键的顺序显示值。`dict`没有维持秩序。

如果我们想对钥匙下订单，我们可以使用：

```py
>>> for key in sorted(histogram): 
...    print(key, histogram[key]) 
0 130 
1 150 
2 129 
3 117 
4 128 
5 127 
6 118 
7 101

```

## 另见

*   在*从字典中删除–pop（）方法和 del 语句*配方中，我们将了解如何通过删除项来修改字典
*   在*控制 dict 键的顺序*配方中，我们将了解如何控制字典中键的顺序

# 从字典中删除–pop（）方法和 del 语句

字典的一个常见用例是**关联存储**：我们可以保持键和值对象之间的关联。这意味着我们可能正在对字典中的某个项目执行任何**CRUD**操作。

*   创建新的键和值对
*   检索与键关联的值
*   更新与键关联的值
*   从字典中删除键（和值）

在这个主题上，我们有两种常见的变体：

*   我们有内存字典`dict`，以及`collections`模块中关于这个主题的变体。该集合仅在程序运行时存在。
*   我们在`shelve`和`dbm`模块中也有持久性存储。数据收集是文件系统中的一个持久文件。

它们非常相似，`shelf.Shelf`和`dict`对象之间的区别很小。这使我们能够在不对程序进行重大更改的情况下，使用`dict`进行试验并切换到`Shelf`。

一个服务器进程通常会有多个并发会话。创建会话时，可以将会话放置在`dict`或`shelf`中。当会话退出时，可以删除或归档该项目。

我们将模拟处理多个请求的服务的概念。我们将定义一个在具有单个处理线程的模拟环境中工作的服务。我们将避免并发和多处理问题。

## 准备好了吗

在*骰子*的赌场游戏中，玩家可以（而且经常）在游戏中创建和移除多个赌注。规则可能复杂得令人费解，但核心概念包括玩家可能进行的四种下注：

*   **传球线**赌注：就我们而言，这是一个人在游戏开始时买入的方式。
*   **过线赔率**赌注：赌场的游戏表面上没有标记这一点，但这是真正的赌注。这种下注的赔率与通过线下注的赔率不同，并且具有一些统计优势。它也可以被移除。
*   **来线**下注：可在游戏中下注。
*   **来线赔率**赌注：这也是在游戏中进行的。这也可以取下来。

了解所有这些投注选择的最佳方法是模拟游戏和玩家。游戏将需要跟踪玩家的所有下注位置。这可以通过一个字典来完成，在字典中插入赌注，当赌注还清、玩家取下赌注或游戏结束时将其移除。

我们将简化部分模拟，以便我们能够集中精力正确使用字典。这是作为类定义处理得最好的，这样我们就可以正确地将赌注和游戏规则从玩家规则中分离出来。有关类设计的更多信息，请参见[第 6 章](06.html#page "Chapter 6. Basics of Classes and Objects")、*类和对象基础*。

## 怎么做。。。

1.  创建整体字典对象：

    ```py
            working_bets = {} 

    ```

2.  定义要插入到字典中的每个对象的键和值。例如，密钥可能是赌注的描述：`come`、`pass`、`come odds`或`pass odds`。该值可能是下注的金额。通常避免使用货币，而是使用表中最小赌注的单位。通常这些都是简单的整数倍，通常只是表示最小赌注的整数值。
3.  Enter values as the bets are being placed:

    ```py
            working_bets[bet_name] = bet_amount 

    ```

    举个具体的例子，我们有`working_bets["pass"] = 1`。

4.  Remove values as bets are paid off or taken down. We can use the `del` statement or the dictionary `pop()` method:

    ```py
            del working_bets['come odds'] 

    ```

    如果钥匙不存在，这将引发`KeyError`异常。

`pop()`方法同时变异字典并返回与键相关的值。如果密钥不存在，则会引发`KeyError`异常。

```py
    amount = working_bets.pop('come odds') 

```

事实证明，`pop()`可以被赋予一个默认值。如果该键不存在，它将不会引发异常，而是返回默认值。

## 它是如何工作的。。。

因为字典是一个可变对象，所以我们可以从字典中删除键。这将同时删除键和与键关联的值对象。

如果我们试图删除一个不存在的密钥，我们将引发一个`KeyError`异常。

我们可以用如下语句替换字典中的对象：

```py
    working_bets["come"] = 1 
    working_bets["come"] = None 

```

关键词`come`-仍保留在字典中。旧值`1`不再需要，将被新值`None`替换。这与删除项目不同。

## 还有更多。。。

我们只能删除字典的键。如前所述，我们可以将值设置为`None`以删除该值，将键保留在字典中。

当我们在`for`语句中使用字典时，目标变量将被分配键值。例如：

```py
    for bet_name in working_bets: 
        print(bet_name, working_bets[bet_name]) 

```

这将在`working_bets`字典中打印所有键值`bet_name,`和与该下注相关的下注金额。

## 另见

*   在*创建字典–插入和更新*配方中，我们将了解如何创建字典并用键和值填充它们
*   在*控制 dict 键的顺序*配方中，我们将了解如何控制字典中键的顺序

# 控制 dict 键的顺序

在*创建字典–插入和更新*配方中，我们了解了创建字典对象的基础知识。在许多情况下，我们会将项目放入字典，然后分别从字典中获取项目。对钥匙进行订购的想法甚至不构成问题。

在某些情况下，我们可能希望显示词典的内容。在这种情况下，我们通常希望对键施加一些顺序。例如，当我们使用 web 服务时，消息通常是用 JSON 符号编码的字典。在许多情况下，我们希望按特定顺序保留键，以便在调试日志中显示消息时更容易理解。

另一个例子是，当我们使用`csv`模块读取数据时，电子表格中的每一行都可以表示为字典。在这种情况下，我们几乎总是希望将键保持在给定的顺序，以便字典遵循源文件的结构。

## 准备好了吗

对于电子表格中的一行，字典是一个很好的模型。当电子表格有标题行和列标题时，这种方法尤其有效。假设我们在电子表格中收集了一些数据，如下所示：

<colgroup><col> <col> <col></colgroup> 
| **最终版** | **至少** | **大多数** |
| 5. | 0 | 6. |
| -3 | -4 | 0 |
| -1 | -3 | 1. |
| 3. | 0 | 4. |

这显示了最终结果，玩家拥有的最低金额和玩家拥有的最高金额。我们可以使用`csv`模块读取这些数据进行进一步分析：

```py
>>> from pathlib import Path 
>>> import csv 
>>> data_path = Path('code/craps.csv') 
>>> with data_path.open() as data_file: 
...     reader = csv.DictReader(data_file) 
...     data = list(reader) 
>>> for row in data:  
...    print(row) 
{'most': '6', 'least': '0', 'final': '5'} 
{'most': '0', 'least': '-4', 'final': '-3'} 
{'most': '1', 'least': '-3', 'final': '-1'} 
{'most': '4', 'least': '0', 'final': '3'}

```

电子表格的每一行都是一本字典。然而，每一行都有一些特殊之处。不明显，但行中键的顺序与原始`.csv`文件中键的顺序不匹配。

为什么呢？默认的`dict`结构不保证键的任何顺序。如果我们想按特定顺序显示键，该怎么办？

## 怎么做。。。

我们有两种常见的方法来强制对字典的键进行排序：

*   创建一个`OrderedDict`：这将按创建键的顺序保留键
*   在按键上使用`sorted()`：这会将按键按顺序排列

大多数情况下，我们可以简单地使用`OrderedDict`而不是`dict()`或`{}`来创建一个空字典。这将允许我们按所需顺序创建密钥。

然而，有时我们不能轻易地用一个`OrderedDict`实例替换一个`dict`实例。我们选择这个例子是因为我们不能简单地替换由`csv`创建的`dict`类。

下面是我们如何强制行的`dict`键遵循原始`.csv`文件中列的顺序：

1.  获取密钥的首选顺序。在`DictReader`的情况下，reader 对象的`fieldnames`属性具有正确的顺序信息。
2.  使用生成器表达式以正确的顺序创建字段。我们会有这样的：

    ```py
            ((name, raw_row[name]) for name in reader.fieldnames) 

    ```

3.  从生成器创建一个`OrderedDict`。以下是整个序列：

    ```py
     >>> from collections import OrderedDict 
          >>> with data_path.open() as data_file: 
          ...     reader = csv.DictReader(data_file) 
          ...     for raw_row in reader: 
          ...         column_sequence = ((name, raw_row[name]) 
          ...            for name in reader.fieldnames) 
          ...         good_row = OrderedDict(column_sequence) 
          ...         print(good_row) 
          OrderedDict([('final', '5'), ('least', '0'), ('most', '6')]) 
          OrderedDict([('final', '-3'), ('least', '-4'), ('most', '0')]) 
          OrderedDict([('final', '-1'), ('least', '-3'), ('most', '1')]) 
          OrderedDict([('final', '3'), ('least', '0'), ('most', '4')])

    ```

这将按照特定顺序构建具有键的词典。

作为优化，我们可以将这两个步骤组合为一个步骤：

```py
    OrderedDict((name, raw_row[name]) for name in reader.fieldnames) 

```

这将生成`raw_row`对象的有序版本。

## 它是如何工作的。。。

`OrderedDict`类按照键的创建顺序保存键。这个类非常方便，可以确保结构保持易于理解的顺序。

当然，这会带来很小的性能成本。默认的`dict`类为每个键计算一个哈希值，哈希值用于在字典中定位一个空格。这往往会占用更多内存，但执行速度非常快。

`OrderedDict`使用一些额外的存储来保留钥匙的顺序。创建密钥时，这需要一些额外的时间。如果密钥创建倾向于主导算法，我们会注意到速度的减慢。如果键检索倾向于主导设计，那么我们在使用`OrderedDict`时不会看到太多变化。

## 还有更多。。。

在一些包中，比如`pymongo`——有一些可选的有序字典实现。

参见[https://api.mongodb.org/python/current/api/bson/son.html](https://api.mongodb.org/python/current/api/bson/son.html) 。

`bson.son`模块包括`SON`类，这是一个非常方便的有序字典。这主要是为了满足 Mongo 数据库的需求，但对于其他应用程序来说，它也可以很好地工作。

## 另见

*   在*创建字典–插入和更新*配方中，我们将了解如何创建字典。
*   在*从字典中删除–pop（）方法和 del 语句*配方中，我们将了解如何通过删除项来修改字典。

# 在 doctest 示例中处理字典和集合

我们将看看在这个配方中编写适当测试的一个小方面。我们将在[第 11 章](11.html#page "Chapter 11. Testing")、*测试*中全面介绍测试。本章中的数据结构`dict`和`set`在编写适当的测试时都包含一些复杂性。

由于`dict`键（和`set`成员）没有顺序，我们的测试结果将出现问题。我们需要一个可重复的结果，但无法保证收集的顺序。这可能导致测试结果与我们的预期不符。

假设我们的测试需要集合`{"Poe", "E", "Near", "A", "Raven"}`。由于集合没有定义顺序，Python 可以按任意顺序显示该集合：

```py
>>> {"Poe", "E", "Near", "A", "Raven"}  
{'E', 'Poe', 'Raven', 'Near', 'A'} 

```

元素是相同的，但是 Python 的整个输出行是不同的。`doctest`包依赖于来自示例的文本输出，该文本输出与 Python 的 REPL 生成的输出*相同*。

我们如何才能确保我们的 doctest 示例真正起作用？

## 准备好了吗

让我们看一个涉及`set`对象的示例：

```py
>>> words = set( 
... '''Beautiful is better than ugly. 
... Explicit is better than implicit. 
... Simple is better than complex. 
... Complex is better than complicated. 
... '''.replace('.', ' ').split()) 
>>> words  
{'complicated', 'Simple', 'ugly', 'implicit', 'Beautiful', 
'complex', 'is', 'Explicit', 'better', 'Complex', 'than'} 

```

这个例子很简单。然而，每次处理这个示例时，结果往往会有所不同。事实上，在研究安全算法时，顺序的不同被认为是很重要的。这被称为**散列随机化**问题，当散列值是可预测的时，它可能成为一个安全漏洞。

当我们使用`doctest`模块时，我们需要有完全一致的示例。正如我们将在[第 11 章](11.html#page "Chapter 11. Testing")、*测试*中看到的，`doctest`模块在定位示例方面很聪明，但在确保实际结果与预期结果匹配方面却不是天才。

问题主要局限于集合和词典。这两个集合由于散列随机化而无法保证密钥顺序。

## 怎么做。。。

当我们需要确保集合或字典中的项具有特定顺序时，我们可以将集合转换为排序序列。

我们有两个选择：

*   将集合转换为排序序列
*   将字典转换为（键、值）两个元组的排序序列

这两种食谱是相似的。下面是我们需要执行的操作，以将集合强制转换为规范化结构：

```py
>>> list(sorted(words))  
['Beautiful', 'Complex', 'Explicit', 'Simple', 'better', 
'complex', 'complicated', 'implicit', 'is', 'than', 'ugly'] 

```

对于字典，我们经常使用以下内容：

```py
    list(sorted(some_dictionary.items())) 

```

这将把字典中的每一项提取为一个`(key, value)`二元组。元组将按键按顺序排序。结果序列将转换为一个列表，以便与预期结果进行比较。

## 它是如何工作的。。。

当遇到无法强制执行订单的集合时，我们必须找到具有两个属性的集合：

*   相同的内容
*   某种一致的顺序

Python 的内置结构是三个主题的变体：

*   序列
*   设置
*   映射

由于序列是唯一具有保证顺序的序列，因此我们可以将集合和映射转换为序列。事实证明，使用`sorted()`函数很容易做到这一点。

对于集合，我们将对项目进行排序。对于映射，我们将对`(key, value)`两个元组进行排序。这使我们确信，示例的输出正是所需的。

## 还有更多。。。

我们将在[第 11 章](11.html#page "Chapter 11. Testing")、*测试*中查看其他几种有微小变化的数据：

*   浮点数
*   日期
*   对象 ID 和回溯
*   随机序列

所有这些都需要放在具有可预测输出的上下文中，以便测试能够重复工作。两种数据结构`set`和`dict`是本章的主题。我们将在相关章节中介绍其他变体。

# 理解变量、引用和赋值

变量究竟是如何工作的？当我们将一个可变对象分配给两个变量时会发生什么？我们可以很容易地有两个变量共享对公共对象的引用；当共享对象是可变的时，这可能会导致潜在的混乱结果。规则很简单，结果通常是显而易见的。

我们将关注这个规则：**Python 共享引用。它不复制数据**。

我们需要看看这个关于参考文献共享的规则意味着什么。

我们将创建两个数据结构，一个是可变的，另一个是不可变的。我们将使用两种序列，尽管我们可以用两种集合做类似的事情：

准备就绪后，我们将创建两个数据结构，一个是可变的，另一个是不可变的。我们将使用两种序列，尽管我们可以用两种集合做类似的事情：

```py
>>> mutable = [1, 1, 2, 3, 5, 8]

>>> immutable = (5, 8, 13, 21)

```

可以更改和共享可变数据结构。不变的数据结构也是共享的，但很难判断它是共享的。

我们不能用映射轻松地做到这一点，因为 Python 不提供方便的不可变映射。

## 怎么做。。。

1.  Assign each collection to an additional variable. This will create two references to the structure:

    ```py
     >>> mutable_b = mutable 
          >>> immutable_b = immutable 

    ```

    我们现在有两个对列表`[1, 1, 2, 3, 5, 8]`的引用和两个对元组`(5, 8, 13, 21)`的引用。

    我们可以使用`is`操作符确认这一点。这将确定两个变量是否引用相同的基础对象：

    ```py
     >>> mutable_b is mutable 
          True 
          >>> immutable_b is immutable 
          True

    ```

2.  Make a change to one of the two references to the collection. For mutable structures, we have methods like `append()` or `add()` :

    ```py
     >>> mutable += [mutable[-2] + mutable[-1]]

    ```

    对于列表结构，`+=`赋值实际上是`extend()`方法的内部使用。

    我们可以用不变的结构做类似的事情：

    ```py
     >>> immutable += (immutable[-2] + immutable[-1],)

    ```

    由于元组没有类似于`extend()`的方法，+=将构建一个新的元组对象，并用该新对象替换`immutable`的值。

3.  查看结构的另一个参考：

    ```py
     >>> mutable_b 
          [1, 1, 2, 3, 5, 8, 13] 
          >>> mutable is mutable_b 
          True 
          >>> immutable_b 
          (5, 8, 13, 21) 
          >>> immutable 
          (5, 8, 13, 21, 34) 

    ```

两个变量`mutable`和`mutable_b`指的是同一个底层对象。因此，我们可以使用任意一个变量来更改对象，并查看反映在另一个变量值中的更改。

两个变量`immutable_b`和`immutable,`一开始是指同一个对象。因为对象不能就地变异，所以对一个变量的更改意味着将一个新对象分配给该变量。另一个变量仍然牢牢地附着在原始对象上。

## 它是如何工作的。。。

在 Python 中，变量是附加到对象的标签。我们可以把它们想象成我们暂时粘在物体上的明亮颜色的胶粘笔记。

变量是对基础对象的引用。当我们把一个对象赋给一个变量时，我们给了一个对底层对象的引用一个名称。当我们在表达式中使用变量时，Python 会定位变量所引用的对象。

对于可变对象，对象的方法可以修改对象的状态。引用对象的所有变量都将反映状态更改，因为变量只是引用，而不是完整副本。

在赋值语句中使用变量时，有两种可能的操作：

*   对于为`+=`等适当赋值运算符提供定义的可变对象，将赋值转换为特殊方法；在本例中，`__iadd__`。特殊方法将改变对象的内部状态。
*   对于不提供赋值定义的不可变对象，如`+=`，赋值被转换为`=`和`+`。`+`操作符生成一个新对象，变量名附加到该新对象。以前引用被替换对象的其他变量不受影响，它们继续引用旧对象。

Python 跟踪对象被引用的位置数。当引用数变为零时，对象不再在任何地方使用，并且可以从内存中删除。

## 还有更多。。。

除了对象之外，C++语言或 java 语言都具有原始类型。在这些语言中，`+=`语句利用硬件指令或 Java 虚拟机的功能来调整基元类型的值。

Python 没有这种优化。数字是不可变的对象。当我们这样做的时候：

```py
>>> a = 355 
>>> a += 113

```

我们没有调整对象`355`的内部状态。这不依赖于内部`__iadd__`特殊方法。这就像我们写的：

```py
>>> a = a + 113

```

计算表达式`a + 113`，并创建一个新的不可变整数对象。此新对象被赋予标签`a`。以前分配给`a`的旧值不再需要。

## 另见

*   在*制作对象的浅拷贝和深拷贝*配方中，我们将研究复制可变结构的方法

# 制作物体的浅拷贝和深拷贝

在本章中，我们讨论了赋值语句如何共享对对象的引用。对象通常不会被复制。当我们写作时：

```py
    a = b 

```

我们现在有两个对同一底层对象的引用。如果`b`是一个列表，`a`和`b`都是对同一个可变列表的引用。

正如我们在*理解变量、引用和赋值*配方中看到的，`a`变量的更改会更改`a`和`b`引用的列表对象。

大多数时候，这是我们想要的行为。在很少的情况下，我们希望从一个原始对象创建两个独立的对象。

当两个变量引用同一基础对象时，有两种方法可以断开存在的连接：

*   制作结构的浅拷贝
*   制作结构的深度副本

## 准备好了吗

我们必须作出特殊安排来复制一件物品。我们已经看到了几种这样做的语法。

*   **序列**–`list`和`tuple`：我们可以使用`sequence[:]`通过使用空切片表达式复制序列。我们还可以使用`sequence.copy()`复制一个名为`sequence`的变量。
*   **映射**–`dict`：我们可以使用`mapping.copy()`复制一个名为`mapping`的字典。
*   **集合**–`set`和`frozenset`：我们可以使用`someset.copy()`克隆一个名为`someset`的集合。

重要的是这些都是肤浅的拷贝。

浅层表示两个集合将包含对相同基础对象的引用。如果底层对象是不可变的数字或字符串，那么这种区别并不重要。当我们无法在集合中对项目进行变异时，只需替换这些项目即可。

如果我们有`a = [1, 1, 2, 3]`，我们就不能对`a[0]`进行任何突变。`a[0]`中的编号`1`没有内部状态。我们只能替换对象。

然而，当我们有一个涉及可变对象的集合时，就会出现问题。首先，我们将创建一个对象，然后创建一个副本：

```py
>>> some_dict = {'a': [1, 1, 2, 3]} 
>>> another_dict = some_dict.copy() 

```

我们得把这本词典复制一份。这两个副本看起来很相似，因为它们都包含对相同对象的引用。存在对不可变字符串`a`的共享引用。以及对可变列表`[1, 1, 2, 3]`的共享引用。我们可以显示`another_dict`的值，以查看它看起来像`some_dict`。

```py
>>> another_dict 
{'a': [1, 1, 2, 3]} 

```

下面是当我们更新字典副本中的共享列表时发生的情况：

```py
>>> some_dict['a'].append(5) 
>>> another_dict 
{'a': [1, 1, 2, 3, 5]} 

```

我们对两个`dict`对象`some_dict`和`another_dict`之间共享的可变`list`对象进行了更改。

我们可以通过`id()`功能看到该项是共享的：

```py
>>> id(some_dict['a']) == id(another_dict['a']) 
True 

```

因为两个`id()`值相同，所以它们是相同的底层对象。与键`a`关联的值在`some_dict`和`another_dict`中都是相同的可变列表。我们也可以使用`is`操作符来查看它们是同一个对象。

此突变效应适用于包含其他作为项的`list`对象的`list`集合，也适用于：

```py
>>> some_list = [[2, 3, 5], [7, 11, 13]] 
>>> another_list = some_list.copy() 
>>> some_list is another_list 
False 
>>> some_list[0] is another_list[0] 
True 

```

我们制作了一个对象`some_list`的副本，并将其分配给变量`another_list`。顶级`list`对象是不同的，`list`中的项目是共享引用。我们使用`is`操作符显示每个列表中的项零都是对相同底层对象的引用。

因为我们不能对可变对象做一个详细的描述，所以我们不必考虑创建共享项目的集合的浅拷贝。

如果我们想完全断开两个副本的连接怎么办？我们如何制作深拷贝而不是浅拷贝？

## 怎么做。。。

Python 通常通过共享引用来工作。它只是不情愿地复制对象。默认行为是创建浅层副本，共享对集合中项目的引用。下面是我们制作深度拷贝的方法：

1.  导入`copy`库：

    ```py
     >>> import copy

    ```

2.  使用`copy.deepcopy()`函数复制一个对象以及该对象中包含的所有可变项：

    ```py
     >>> some_dict = {'a': [1, 1, 2, 3]} 
          >>> another_dict = copy.deepcopy(some_dict)

    ```

这将创建没有共享引用的副本。对一个副本的可变内部项的更改不会对其他任何地方产生任何影响：

```py
>>> some_dict['a'].append(5) 
>>> some_dict 
{'a': [1, 1, 2, 3, 5]} 
>>> another_dict 
{'a': [1, 1, 2, 3]}

```

我们更新了`some_dict`中的一个项目，它对`another_dict`中的副本没有影响。我们可以通过`id()`函数看到对象是不同的：

```py
>>> id(some_dict['a']) == id(another_dict['a']) 
False

```

由于`id()`值不同，因此它们是不同的对象。我们也可以使用`is`操作符来确定它们是不同的对象。

## 它是如何工作的。。。

制作浅拷贝相对容易。我们可以使用生成器表达式编写自己的算法版本：

```py
>>> copy_of_list = [item for item in some_list] 
>>> copy_of_dict = {key:value for key, value in some_dict.items()} 

```

在`list`案例中，新`list`的项目是对源列表中项目的引用。类似地，在`dict`情况下，键和值是对源字典的键和值的引用。

`deepcopy()`函数使用递归算法查看每个可变集合的内部。

对于`list`来说，概念算法是这样的：

```py
    immutable = (numbers.Number, tuple, str, bytes) 
    def deepcopy_list(some_list: 
        copy = [] 
        for item in some_list: 
            if isinstance(item, immutable): 
                copy.append(item) 
            else: 
                copy.append(deepcopy(item)) 

```

当然，实际的代码不是这样的。它在处理每种不同 Python 类型的方式上更聪明一些。然而，这确实提供了一些关于`deepcopy()`函数如何工作的提示。

事实证明，还有一些额外的考虑因素。最重要的考虑因素是一个包含对自身的引用的对象。

我们可以这样做：

```py
    a = [1, 2, 3] 
    a.append(a) 

```

这是一个令人困惑但在技术上有效的 Python 构造。当试图编写一个简单的递归操作来访问列表中的所有项目时，这将导致出现问题。为了克服这一问题，使用了内部缓存，以便只复制一次项。之后，可以在缓存中找到内部引用。

## 另见

*   在*理解变量、引用和赋值*配方中，我们将了解 Python 如何更喜欢创建对对象的引用。

# 避免函数参数的可变默认值

在[第 3 章](03.html#page "Chapter 3. Function Definitions")、*函数定义*中，我们了解了 Python 函数定义的许多方面。在带有可选参数的*设计函数*配方中，我们展示了处理可选参数的配方。当时，我们没有详细讨论作为默认值提供对可变结构的引用的问题。我们将仔细研究函数参数的可变默认值的后果。

## 准备好了吗

让我们想象一个创建或更新可变`Counter`对象的函数。我们称之为`gather_stats()`。

理想情况下，它可以如下所示：

```py
>>> from collections import Counter 
>>> from random import randint, seed 
>>> def gather_stats(n, samples=1000, summary=Counter()): 
...     summary.update( 
...         sum(randint(1,6) for d in range(n)) 
...             for _ in range(samples)) 
...     return summary

```

这显示了两层功能的*糟糕*设计。第一个故事没有提供参数集合。该函数创建并返回统计信息的集合。下面是这个故事的例子：

```py
>>> seed(1) 
>>> s1 = gather_stats(2) 
>>> s1 
Counter({7: 168, 6: 147, 8: 136, 9: 114, 5: 110, 10: 77, 11: 71, 4: 70, 3: 52, 12: 29, 2: 26})

```

第二个故事允许我们提供一个显式的参数值，以便统计信息更新给定的对象。下面是这个故事的一个例子：

```py
>>> seed(1) 
>>> mc = Counter() 
>>> gather_stats(2, summary=mc)  
Counter... 
>>> mc 
Counter({7: 168, 6: 147, 8: 136, 9: 114, 5: 110, 10: 77, 11: 71, 4: 70, 3: 52, 12: 29, 2: 26})

```

我们设置了随机数种子，以确保两个随机值序列是相同的。如果我们提供一个`Counter`对象或使用默认的`Counter`对象，那么很容易确认结果是相同的。在第二个示例中，我们为函数提供了一个显式的`Counter`对象，名为`mc`。

`gather_stats()`函数返回一个值。在编写脚本时，我们只需忽略返回的值。在使用 Python 的交互式 REPL 时，输出会被打印出来。我们展示了`Counter...`而不是冗长的输出。

在执行前两个操作后执行以下操作时会出现问题：

```py
>>> seed(1) 
>>> s3 = gather_stats(2) 
>>> s3 
Counter({7: 336, 6: 294, 8: 272, 9: 228, 5: 220, 10: 154, 11: 142, 4: 140, 3: 104, 12: 58, 2: 52})

```

请注意，计数加倍。出了点问题。因为这只在我们多次使用默认故事时发生，所以它可能通过单元测试套件，并且看起来是正确的。

正如我们在*制作对象*的浅拷贝和深拷贝中看到的，Python 更喜欢共享引用。这种分享的结果如下：

```py
>>> s1 is s3 
True

```

这意味着两个变量`s1`和`s2`都是对同一基础对象的引用。看来我们已经更新了一些共享集合。

这是否意味着`s1`的值发生了变化？

```py
>>> s1 
Counter({7: 336, 6: 294, 8: 272, 9: 228, 5: 220, 10: 154, 11: 142, 4: 140, 3: 104, 12: 58, 2: 52})

```

是的，这个`gather_stats()`函数的默认用法似乎是共享一个对象。我们如何避免这种情况？

## 怎么做。。。

有两种方法可以解决此问题：

*   提供一个不可变的默认值
*   改变设计

我们首先来看不可变的默认值。改变设计通常是一个更好的主意。为了了解为什么更改设计更好，我们将展示纯技术解决方案。

当我们为函数提供默认值时，默认对象只创建一次，之后将永远共享。以下是备选方案：

1.  将任何可变的默认参数值替换为`None`：

    ```py
            def gather_stats(n, samples=1000, summary=None): 

    ```

2.  添加一个`if`语句来检查参数值`None`并用一个新的可变对象替换它：

    ```py
            if summary is None: summary = Counter() 

    ```

这将使我们确信，每次在没有参数值的情况下对函数求值时，我们都会创建一个新的可变对象。我们将避免一次又一次地共享单个可变对象。

提供可变对象作为函数默认值的理由很少。在大多数情况下，我们应该考虑改变设计，而不是使用可变对象作为参数的默认值。在难得的情况下，我们确实有一个复杂的算法，它可以更新一个对象或创建一个新的新对象，我们应该考虑定义两个单独的函数。

我们将重构此函数，使其如下所示：

```py
    def create_stats(n, samples=1000): 
        return update_stats(n, samples, Counter()) 
    def update_stats(n, samples=1000, summary): 
        summary.update( 
            sum(randint(1,6) for d in range(n)) 
                for _ in range(samples)) 

```

我们创建了两个独立的函数。这将把两个故事分开，这样就不会有混淆。首先，可选可变参数的想法不是一个好主意。

## 它是如何工作的。。。

正如我们前面提到的，Python 更喜欢共享引用。它很少创建对象的副本。因此，函数参数值的默认值将是共享对象。Python 不容易创建新的对象。

这条规则非常重要，经常会让不熟悉 Python 的程序员感到困惑。

### 提示

不要对函数使用可变默认值。

可变对象（`set`、`list`、`dict`不应是函数参数的默认值。

这条规则适用于核心语言。但是，它并不适用于整个标准库。在某些情况下，有一些聪明的替代方法。

## 还有更多。。。

在标准库中，有一些很酷的技术示例，展示了如何创建新的默认对象。一个广泛使用的例子是在`defaultdict`系列中。当我们创建`defaultdict`时，我们提供了一个无参数函数，用于创建新的字典条目。

当字典中缺少键时，将计算给定函数以计算新的默认值。在`defaultdict(int)`的例子中，我们使用`int()`函数来创建一个不可变的对象。正如我们所看到的，不可变对象的默认值不会导致任何问题，因为不可变对象没有内部状态。

当我们做`defaultdict(list)`或`defaultdict(set)`时，我们看到了这种设计模式的真正威力。当钥匙丢失时，会创建一个新的空的`list`（或`set`）。

`defaultdict`使用的函数评估模式不适用于函数本身的操作方式。大多数情况下，我们为函数参数提供的默认值是不可变的对象，如数字、字符串或元组。必须用`lambda`包装一个不可变的对象当然是可能的，但令人厌烦，因为这是一种常见的情况。

为了利用这种技术，我们需要修改示例函数的设计。我们将不再更新函数中的现有计数器对象。我们将始终创建一个全新的对象。我们可以修改创建对象的类别。

这里有一个函数，允许我们在不希望使用默认`Counter`类的情况下插入另一个类。

```py
>>> def gather_stats(n, samples=1000, summary_func=lambda x:Counter(x)): 
...     summary = summary_func( 
...         sum(randint(1,6) for d in range(n)) 
...             for _ in range(samples)) 
...     return summary

```

对于这个版本，我们将初始化值定义为一个参数的函数。默认情况下，此单参数函数将应用于随机样本的生成器函数。我们可以用另一个收集数据的单参数函数重写这个函数。这将使用能够收集数据的任何类型的对象构建一个新对象。

下面是一个使用`list()`的示例：

```py
>>> seed(1) 
>>> gather_stats(2, 12, summary_func=list) 
[7, 4, 5, 8, 10, 3, 5, 8, 6, 10, 9, 7]

```

在本例中，我们提供了`list()`函数来创建包含单个随机样本的列表。

下面是一个没有参数值的示例。它将创建一个`Counter`对象：

```py
>>> seed(1) 
>>> gather_stats(2, 12) 
Counter({5: 2, 7: 2, 8: 2, 10: 2, 3: 1, 4: 1, 6: 1, 9: 1})

```

在本例中，我们使用了默认值。函数从随机样本中创建了一个`Counter()`对象。

## 另见

*   请参阅*创建字典–插入和更新*配方，其中显示了`defaultdict`的工作原理*