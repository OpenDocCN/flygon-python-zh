# 排序

排序意味着重新组织数据，使其按从小到大的顺序排列。排序是数据结构和计算中最重要的问题之一。数据在排序之前经常被排序，因为这样可以非常高效地检索，无论是一组姓名、电话号码，还是简单待办事项清单上的项目。

在本章中，我们将学习一些最重要和流行的排序技术，包括以下内容：

+   冒泡排序

+   插入排序

+   选择排序

+   快速排序

+   堆排序

在本章中，我们通过考虑它们的渐近行为来比较不同的排序算法。一些算法相对容易开发，但性能可能较差，而其他算法在实现上稍微复杂一些，但在对长列表进行排序时表现良好。

排序后，对一组项目进行搜索操作变得更加容易。我们将从最简单的排序算法开始；即冒泡排序算法。

# 技术要求

用于解释本章概念的所有源代码都在以下 GitHub 存储库中提供：[`github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter10`](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter10)。

# 排序算法

排序意味着将列表中的所有项目按其大小的升序排列。我们将讨论一些最重要的排序算法，它们各自具有不同的性能属性，涉及运行时复杂性。排序算法根据它们的内存使用、复杂性、递归性以及它们是否基于比较等考虑进行分类。

一些算法使用更多的 CPU 周期，因此具有糟糕的渐近值。其他算法在对一些值进行排序时会消耗更多的内存和其他计算资源。另一个考虑因素是排序算法如何适合递归、迭代或两者表达。有些算法使用比较作为排序元素的基础。冒泡排序算法就是一个例子。非比较排序算法的例子包括桶排序和鸽巢排序算法。

# 冒泡排序算法

冒泡排序算法的思想非常简单。给定一个无序列表，我们比较列表中相邻的元素，每次比较后，将它们按大小顺序放置。这是通过交换相邻的项目来实现的，如果它们的顺序不正确。这个过程对于 n 个项目的列表会重复 n-1 次。在每次迭代中，最大的元素都会被放在最后。例如，在第一次迭代中，最大的元素将被放在列表的最后位置，然后，相同的过程将对剩下的 n-1 个项目进行。在第二次迭代中，第二大的元素将被放在列表的倒数第二个位置，然后该过程将重复，直到列表排序完成。

让我们以只有两个元素{5, 2}的列表来理解冒泡排序的概念，如下图所示：

![](img/21f97a06-89a0-4128-a1e8-580c48e3d76b.png)

为了对这个列表进行排序，我们只需将值交换到正确的位置，**2** 占据索引**0**，**5** 占据索引**1**。为了有效地交换这些元素，我们需要一个临时存储区域：

![](img/3e4f61f4-3eb8-413a-bbda-27ab37970caa.png)

冒泡排序算法的实现从交换方法开始，如前图所示。首先，元素**5**将被复制到临时位置`temp`。然后，元素**2**将被移动到索引**0**。最后，**5**将从 temp 移动到索引**1**。最终，元素将被交换。列表现在包含元素`[2, 5]`。以下代码将交换`unordered_list[j]`的元素与`unordered_list[j+1]`的元素，如果它们不按正确顺序排列的话：

```py
    temp = unordered_list[j] 
    unordered_list[j] = unordered_list[j+1] 
    unordered_list[j+1] = temp 
```

现在我们已经能够交换一个包含两个元素的数组，使用相同的思路对整个列表进行排序应该很简单。

让我们考虑另一个例子，以了解冒泡排序算法对包含**6**个元素的无序列表进行排序的工作原理，例如{**45**，**23**，**87**，**12**，**32**，**4**}。在第一次迭代中，我们开始比较前两个元素**45**和**23**，并交换它们，因为**45**应该放在**23**之后。然后，我们比较下一个相邻值**45**和**87**，看它们是否按正确顺序排列。如果它们没有按正确顺序排列，则交换它们。我们可以看到，在冒泡排序的第一次迭代后，最大的元素**87**被放置在列表的最后位置：

![](img/25605a4a-d41e-4ce3-826e-20fb3d1373c6.png)

第一次迭代后，我们只需要排列剩下的`(n-1)`个元素；我们通过比较剩下的五个元素的相邻元素来重复相同的过程。第二次迭代后，第二大的元素**45**被放置在列表中倒数第二个位置，如下图所示：

![](img/da1be0d7-4d4c-4d22-aea5-5f96dee1e07c.png)

接下来，我们需要比较剩下的`(n-2)`个元素，将它们排列如下图所示：

![](img/87da0f01-1e66-4064-8810-5fcc9f1daa5e.png)

同样地，我们比较剩下的元素来对它们进行排序：

![](img/4ccbf25c-3e8e-40f9-a2e7-9ec1141a3987.png)

最后，在剩下的两个元素中，我们将它们按正确顺序放置，以获得最终排序的列表，如下图所示：

![](img/e9d0d690-e962-400f-8610-6b7c2519d5e8.png)

冒泡排序算法的实现将在一个双嵌套循环中工作，其中内部循环重复比较和交换给定列表中每次迭代中的相邻元素，而外部循环则跟踪内部循环应重复多少次。内部循环的实现如下：

```py
    for j in range(iteration_number): 
        if unordered_list[j] > unordered_list[j+1]: 
            temp = unordered_list[j] 
            unordered_list[j] = unordered_list[j+1] 
            unordered_list[j+1] = temp
```

在实现冒泡排序算法时，了解循环需要运行多少次才能完成所有交换是很重要的。例如，要对一个包含三个数字的列表`[3, 2, 1]`进行排序，我们最多需要交换两次元素。这等于列表长度减 1，可以写成`iteration_number = len(unordered_list)-1`。我们减 1 是因为它确切地给出了需要运行的最大迭代次数。让我们通过以下示例来展示这一点，在一个包含 3 个数字的列表中，通过在恰好两次迭代中交换相邻元素，最大的数字最终位于列表的最后位置：

![](img/97ed985d-c7fa-4bb3-9a07-2d3d831f886a.png)

`if`语句确保如果两个相邻元素已经按正确顺序排列，则不会发生不必要的交换。内部`for`循环只会导致相邻元素的交换在我们的列表中确切地发生两次。

为了使整个列表排序，这个交换操作需要发生多少次？我们知道，如果我们重复整个交换相邻元素的过程多次，列表将被排序。外部循环用于实现这一点。列表中元素的交换导致以下动态：

![](img/22b48f43-84eb-4f09-9156-a48f21eb1d6e.png)

我们意识到最多需要四次比较才能使我们的列表排序。因此，内部和外部循环都必须运行`len(unordered_list)-1`次，以便对所有元素进行排序，如下所示：

```py
iteration_number = len(unordered_list)-1 
    for i in range(iteration_number): 
        for j in range(iteration_number): 
            if unordered_list[j] > unordered_list[j+1]: 
                temp = unordered_list[j] 
                unordered_list[j] = unordered_list[j+1] 
                unordered_list[j+1] = temp
```

即使列表包含许多元素，也可以使用相同的原则。冒泡排序也有很多变体，可以最小化迭代和比较的次数。

例如，有一种冒泡排序算法的变体，如果在内部循环中没有交换，我们就会简单地退出整个排序过程，因为内部循环中没有任何交换操作表明列表已经排序。在某种程度上，这可以帮助加快算法的速度。

冒泡排序是一种低效的排序算法，其最坏情况和平均情况的运行时间复杂度为`O(n²)`，最佳情况的复杂度为`O(n)`。通常，不应该使用冒泡排序算法对大型列表进行排序。但是，在相对较小的列表上，它的性能还算不错。

# 插入排序算法

将相邻元素交换以对项目列表进行排序的想法也可以用于实现插入排序。插入排序算法维护一个始终排序的子列表，而列表的另一部分保持未排序。我们从未排序的子列表中取出元素，并将它们插入到排序的子列表的正确位置，使得这个子列表保持排序。

在插入排序中，我们从一个元素开始，假设它已经排序，然后从未排序的子列表中取出另一个元素，并将其放在排序的子列表中正确的位置（相对于第一个元素）。这意味着我们的排序子列表现在有两个元素。然后，我们再次从未排序的子列表中取出另一个元素，并将其放在排序的子列表中正确的位置（相对于已排序的两个元素）。我们反复遵循这个过程，将未排序的子列表中的所有元素一个接一个地插入到排序的子列表中。阴影元素表示有序子列表，在每次迭代中，未排序子列表中的一个元素被插入到排序子列表的正确位置。

让我们考虑一个例子来理解插入排序算法的工作原理。在我们的例子中，我们将对包含`6`个元素的列表`{45, 23, 87, 12, 32, 4}`进行排序。首先，我们从`1`个元素开始，假设它已经排序，然后从未排序的子列表中取出下一个元素`23`，并将其插入到排序的子列表中的正确位置。在下一次迭代中，我们从未排序的子列表中取出第三个元素`87`，并再次将其插入到排序的子列表中的正确位置。我们一直遵循相同的过程，直到所有元素都在排序的子列表中。整个过程如下图所示：

![](img/2be1efdb-8fd8-43d6-add6-aede489e3815.png)

为了理解插入排序算法的实现，让我们以另一个包含`5`个元素的示例列表`{5, 1, 100, 2, 10}`为例，并用详细的解释来检查这个过程。

让我们考虑以下数组：

![](img/52c67297-48cb-4fb1-a6e6-863f02db06bb.png)

该算法通过使用`for`循环在**1**和**4**索引之间运行来开始。我们从索引**1**开始，因为我们假设索引**0**处的子数组已经按正确的顺序排序：

![](img/c140fcb5-08aa-4ad5-bafe-33fd12a82214.png)

在循环执行的开始，我们有以下内容：

```py
    for index in range(1, len(unsorted_list)): 
        search_index = index 
        insert_value = unsorted_list[index] 
```

在每次运行`for`循环的开始时，将`unsorted_list[index]`处的元素存储在`insert_value`变量中。稍后，当我们找到列表的排序部分中的适当位置时，`insert_value`将存储在该索引或位置上：

```py
    for index in range(1, len(unsorted_list)): 
        search_index = index 
        insert_value = unsorted_list[index] 

        while search_index > 0 and unsorted_list[search_index-1] > 
              insert_value : 
            unsorted_list[search_index] = unsorted_list[search_index-1] 
            search_index -= 1 

        unsorted_list[search_index] = insert_value 
```

`search_index`用于向`while`循环提供信息；也就是说，确切地找到下一个需要插入到排序子列表中的元素的位置。

`while`循环向后遍历列表，受两个条件的指导：首先，如果`search_index > 0`，那么意味着在列表的排序部分中还有更多的元素；其次，`while`循环运行时，`unsorted_list[search_index-1]`必须大于`insert_value`变量。`unsorted_list[search_index-1]`数组将执行以下操作之一：

+   在`while`循环第一次执行之前，指向`unsorted_list[search_index]`之前的一个元素

+   在`while`循环第一次运行后，指向`unsorted_list[search_index-1]`之前的一个元素

在我们的示例列表中，`while`循环将被执行，因为*5 > 1*。在`while`循环的主体中，`unsorted_list[search_index-1]`处的元素存储在`unsorted_list[search_index]`处。`search_index -= 1`将列表向后遍历，直到它的值为`0`。

我们的列表现在如下所示：

![](img/86df775f-a6fb-4bd2-9b93-0038bbdc97dc.png)

在`while`循环退出后，`search_index`的最后已知位置（在这种情况下为`0`）现在帮助我们知道在哪里插入`insert_value`：

![](img/ad028833-87aa-466e-8b28-8cb081f129b8.png)

在`for`循环的第二次迭代中，`search_index`的值将为**2**，这是数组中第三个元素的索引。此时，我们从左向右（朝向索引**0**）开始比较。**100**将与**5**进行比较，但因为**100**大于**5**，`while`循环不会执行。**100**将被替换为它自己，因为`search_index`变量从未被减少。因此，`unsorted_list[search_index] = insert_value`将不会产生影响。

当`search_index`指向索引**3**时，我们将**2**与**100**进行比较，并将**100**移动到存储**2**的位置。然后我们将**2**与**5**进行比较，并将**5**移动到最初存储**100**的位置。此时，`while`循环将中断，**2**将存储在索引**1**中。数组将部分排序，值为`[1, 2, 5, 100, 10]`。

前面的步骤将为列表最后一次发生。

插入排序算法被认为是稳定的，因为它不会改变具有相等键的元素的相对顺序。它也只需要消耗列表占用的内存，因为它是原地交换的。

插入排序算法的最坏情况运行时间复杂度为**`O(n²)`**，最佳情况复杂度为`O(n)`。

# 选择排序算法

另一个流行的排序算法是选择排序。选择排序算法首先找到列表中最小的元素，并将其与列表中的第一个位置存储的数据交换。因此，它使子列表排序到第一个元素。接下来，识别出剩余列表中最小的元素（即剩余列表中最小的元素），并将其与列表中的第二个位置交换。这使得初始的两个元素排序。该过程重复进行，列表中剩余的最小元素应该与列表中第三个索引处的元素交换。这意味着前三个元素现在已排序。这个过程重复了`(n-1)`次来对`n`个项目进行排序。

让我们通过一个示例来理解算法的工作原理。我们将使用选择排序算法对以下 4 个元素的列表进行排序：

![](img/00f7ef2b-0bcf-4184-995c-2bebd03c2d85.png)

从索引**0**开始，我们搜索列表中存在于索引**1**和最后一个元素索引之间的最小项。找到这个元素后，将其与索引**0**处的数据交换。我们只需重复此过程，直到列表完全排序。

在列表中搜索最小的项目是一个递增的过程：

![](img/11f39ec5-3839-4437-9724-52c16ca07749.png)

对元素**2**和**5**进行比较，选择**2**，因为它是这两个值中较小的值，因此这两个元素被交换。

交换操作后，数组如下所示：

![](img/394c7330-7323-4726-88e1-bd3c7546399a.png)

此外，在索引**0**处，我们将**2**与**65**进行比较：

![](img/09719f77-d0ec-4f7a-8a48-d1fd6609a8e6.png)

由于**65**大于**2**，这两个元素不会交换。在索引**0**处的元素**2**和索引**3**处的元素**10**之间进行了进一步比较。在这种情况下不会发生交换。当我们到达列表中的最后一个元素时，最小的元素将占据索引**0**。

在下一次迭代中，我们从索引**1**开始比较元素。我们重复整个过程，将索引**1**处存储的元素与从索引**2**到最后一个索引的所有元素进行比较。

第二次迭代从比较**5**和**65**开始，结果如下：

![](img/d4fd4df3-f7aa-4980-9d86-39af6d2d5108.png)

一旦我们发现**5**是从索引**1**到**3**的子列表中的最小值，我们将其放在索引**1**处。同样，从子列表**2**和**3**的索引中找到的下一个最小元素被放置在索引**3**处。

以下是选择排序算法的实现。函数的参数是我们想要按大小顺序排列的未排序项目列表：

```py
    def selection_sort(unsorted_list): 

        size_of_list = len(unsorted_list) 

        for i in range(size_of_list): 
            for j in range(i+1, size_of_list): 

                if unsorted_list[j] < unsorted_list[i]: 
                    temp = unsorted_list[i] 
                    unsorted_list[i] = unsorted_list[j] 
                    unsorted_list[j] = temp 
```

该算法通过使用外部`for`循环多次遍历列表`size_of_list`。因为我们将`size_of_list`传递给`range`方法，它将产生一个从**0**到`size_of_list-1`的序列。

内部循环负责遍历列表，并在遇到小于`unsorted_list[i]`指向的元素时交换元素。注意，内部循环从`i+1`开始，直到`size_of_list-1`。

内部循环从`i+1`开始搜索最小元素，但使用`j`索引：

![](img/6a9bbfe0-c944-46d0-8109-daedd157611d.png)

前面的图表显示了算法搜索下一个最小项的方向。

选择排序算法的最坏情况和最佳情况运行时间复杂度均为`O(n2)`。

# 快速排序算法

快速排序算法对于排序非常有效。快速排序算法属于分治类算法，类似于归并排序算法，其中我们将问题分解为更简单的小块来解决。

# 列表分区

快速排序的概念是对给定的列表或数组进行分区。为了对列表进行分区，我们首先选择一个枢轴。列表中的所有元素将与此枢轴进行比较。在分区过程结束时，所有小于枢轴的元素将位于枢轴的左侧，而所有大于枢轴的元素将位于数组中枢轴的右侧。

# 枢轴选择

为了简单起见，我们将数组中的第一个元素作为枢轴。这种枢轴选择在性能上会下降，特别是在对已排序列表进行排序时。随机选择数组中间或最后一个元素作为枢轴并不会改善快速排序的性能。我们将在下一章讨论更好的选择枢轴和找到列表中最小元素的方法。

# 举例说明

在这个算法中，我们将一个未排序的数组分成两个子数组，使得分区点（也称为枢轴）左侧的所有元素都应该小于枢轴，而枢轴右侧的所有元素都应该大于枢轴。在快速排序算法的第一次迭代之后，选择的枢轴点被放置在列表中的正确位置。第一次迭代之后，我们得到两个无序的子列表，并在这两个子列表上再次执行相同的过程。因此，快速排序算法将列表分成两部分，并递归地在这两个子列表上应用快速排序算法以对整个列表进行排序。

我们首先选择一个枢轴点，所有项目都将与其进行比较，并在第一次迭代结束时，该值将被放置在有序列表中的正确位置。接下来，我们使用两个指针，一个左指针和一个右指针。左指针最初指向索引**1**处的值，右指针指向最后一个索引处的值。快速排序算法的主要思想是移动在枢轴值错误一侧的项目。因此，我们从左指针开始，从左到右移动，直到找到一个比枢轴值大的位置。类似地，我们将右指针向左移动，直到找到一个小于枢轴值的值。接下来，我们交换左右指针指示的这两个值。我们重复相同的过程，直到两个指针交叉；换句话说，右指针索引指示的值小于左指针索引的值时。

让我们以一个数字列表{**45**, **23**, **87**, **12**, **72**, **4**, **54**, **32**, **52**}为例，来理解快速排序算法的工作原理。假设我们列表中的枢轴点是第一个元素**45**。我们从索引**1**处向右移动左指针，并在找到值**87**时停止，因为（**87**>**45**）。接下来，我们将右指针向左移动，并在找到值**32**时停止，因为（**32**<**45**）。

现在，我们交换这两个值，如下图所示：

![](img/7b232879-1527-4f8e-ac01-f56791cc7982.png)

之后，我们重复相同的过程，将左指针向右移动，并在找到值**72**时停止，因为（**72**>**45**）。接下来，我们将右指针向左移动，并在找到值**4**时停止，因为（**4**<**45**）。现在，我们交换这两个值，因为它们与枢轴值的方向相反。我们重复相同的过程，并在右指针索引值小于左指针索引值时停止。在这里，我们找到**4**作为分割点，并将其与枢轴值交换。如下图所示：

![](img/e05dddc1-22ab-495c-847c-b2765ed7d23c.png)

在快速排序算法的第一次迭代之后，可以观察到枢轴值**45**被放置在列表中的正确位置。

现在我们有了两个子列表：

1.  枢轴值**45**左侧的子列表具有小于**45**的值。

1.  枢轴值右侧的另一个子列表包含大于 45 的值。我们将在这两个子列表上递归应用快速排序算法，并重复此过程，直到整个列表排序完成。

![](img/18334875-62fb-4170-bb9b-47f0b4b3a210.png)

# 实施

分区步骤对于理解快速排序算法的实现非常重要，因此我们将从实现分区开始进行检查。

让我们看另一个例子来理解实现。考虑以下整数列表。我们将使用分区函数对此列表进行分区，如下所示：

![](img/29b930cc-1cd7-4a9c-a5ba-54d2a951a9c5.png)

考虑以下代码：

```py
     def partition(unsorted_array, first_index, last_index): 

        pivot = unsorted_array[first_index] 
        pivot_index = first_index 
        index_of_last_element = last_index 

        less_than_pivot_index = index_of_last_element 
        greater_than_pivot_index = first_index + 1 
        ...
```

分区函数接收数组的第一个和最后一个元素的索引作为其参数，我们需要对其进行分区。

主元的值存储在`pivot`变量中，而其索引存储在`pivot_index`中。我们没有使用`unsorted_array[0]`，因为当调用未排序数组参数时，索引`0`不一定指向该数组中的第一个元素。主元的下一个元素的索引，即**左指针**，`first_index + 1`，标记了我们开始在数组中寻找大于主元的元素的位置，即`greater_than_pivot_index = first_index + 1`。**右指针**`less_than_pivot_index`变量指向`less_than_pivot_index = index_of_last_element`列表中最后一个元素的位置，我们从这里开始寻找小于主元的元素：

```py
    while True: 

        while unsorted_array[greater_than_pivot_index] < pivot and 
              greater_than_pivot_index < last_index: 
              greater_than_pivot_index += 1 

        while unsorted_array[less_than_pivot_index] > pivot and 
              less_than_pivot_index >= first_index: 
              less_than_pivot_index -= 1 
```

在执行主`while`循环的开始时，数组如下所示：

![](img/16a3edea-4e3f-4532-82a8-500df977e3b9.png)

第一个内部`while`循环向右移动一个索引，直到落在索引**2**上，因为该索引处的值大于**43**。此时，第一个`while`循环中断并且不再继续。在第一个`while`循环的条件测试中，只有在`while`循环的测试条件评估为`True`时，才会评估`greater_than_pivot_index += 1`。这使得对大于主元的元素的搜索向右边的下一个元素进行。

第二个内部`while`循环每次向左移动一个索引，直到落在索引**5**上，其值**20**小于**43**：

![](img/5de935b0-20a7-4973-8819-81babd0768f0.png)

此时，内部的`while`循环都无法再执行：

```py
    if greater_than_pivot_index < less_than_pivot_index: 
        temp = unsorted_array[greater_than_pivot_index] 
            unsorted_array[greater_than_pivot_index] =    
                unsorted_array[less_than_pivot_index] 
            unsorted_array[less_than_pivot_index] = temp 
    else: 
        break
```

由于`greater_than_pivot_index < less_than_pivot_index`，`if`语句的主体交换了这些索引处的元素。`else`条件在任何时候`greater_than_pivot_index`变得大于`less_than_pivot_index`时打破无限循环。在这种情况下，这意味着`greater_than_pivot_index`和`less_than_pivot_index`已经交叉。

我们的数组现在如下所示：

![](img/b8479f3c-29f3-48f0-9807-ded22d7670e7.png)

当`less_than_pivot_index`等于**3**且`greater_than_pivot_index`等于**4**时，执行`break`语句。

一旦退出`while`循环，我们就会交换`unsorted_array[less_than_pivot_index]`处的元素和作为主元索引返回的`less_than_pivot_index`处的元素：

```py
    unsorted_array[pivot_index]=unsorted_array[less_than_pivot_index] 
    unsorted_array[less_than_pivot_index]=pivot 
    return less_than_pivot_index 
```

以下图表显示了代码在分区过程的最后一步中如何交换**4**和**43**：

![](img/31e49e1a-1589-4a9d-9404-1571133a1f64.png)

总之，第一次调用`quick_sort`函数时，它是围绕索引**0**的元素进行分区的。在分区函数返回后，我们得到的数组顺序为[**4**，**3**，**20**，**43**，**89**，**77**]。

正如你所看到的，主元**43**右边的所有元素都大于**43**，而左边的元素都小于**43**。因此，分区完成。

使用分割点**43**和索引**3**，我们将递归地对两个子数组进行排序，即[**4**，**30**，**20**]和[**89**，**77**]，使用刚刚经历的相同过程。

主`quick_sort`函数的主体如下：

```py
    def quick_sort(unsorted_array, first, last): 
        if last - first <= 0: 
            return 
    else: 
        partition_point = partition(unsorted_array, first, last) 
        quick_sort(unsorted_array, first, partition_point-1) 
        quick_sort(unsorted_array, partition_point+1, last) 
```

`quick_sort`函数是一个非常简单的方法，代码不超过六行。繁重的工作由`partition`函数完成。当调用`partition`方法时，它返回分区点。这是`unsorted_array`数组中的一个点，其中所有左边的元素都小于主元值，而右边的元素都大于它。

当我们在分区进程之后立即打印`unsorted_array`的状态时，我们清楚地看到了分区是如何发生的：

```py
Output:
[43, 3, 20, 89, 4, 77]
[4, 3, 20, 43, 89, 77]
[3, 4, 20, 43, 89, 77]
[3, 4, 20, 43, 77, 89]
[3, 4, 20, 43, 77, 89]
```

退一步，让我们在第一次分区后对第一个子数组进行排序。当`[4, 3, 20]`子数组的分区停止时，`greater_than_pivot_index` 在索引 `2`，`less_than_pivot_index` 在索引 `1`。此时，两个标记被认为已经交叉。因为 `greater_than_pivot_index` 大于 `less_than_pivot_index`，`while` 循环的进一步执行将停止。将主元 `4` 与 `3` 交换，同时索引 `1` 被返回为分区点。

在快速排序算法中，分区算法需要 `O(n)` 时间。由于快速排序算法遵循“分而治之”的范式，它需要 `O(log n)` 时间；因此，快速排序算法的整体平均情况运行时间复杂度为 `O(n) * O(log n) = O(n log n)`。快速排序算法给出了最坏情况的运行时间复杂度为 `O(n²)`。快速排序算法的最坏情况复杂度是每次选择最坏的主元点，并且其中一个分区始终只有一个元素。例如，如果列表已经排序，最坏情况复杂度将发生在分区选择最小元素作为主元点时。当最坏情况复杂度发生时，可以通过使用随机化快速排序来改进快速排序算法。与其他上述排序算法相比，快速排序算法在对大量数据进行排序时非常高效。

# 堆排序算法

在第八章《图和其他算法》中，我们实现了一个二叉堆数据结构。我们的实现始终确保，在从堆中移除或添加元素后，使用 `sink()` 和 `arrange()` 辅助方法来维护堆顺序属性。

堆数据结构可以用来实现一种称为堆排序的排序算法。简而言之，让我们创建一个包含以下项目的简单堆：

```py
    h = Heap() 
    unsorted_list = [4, 8, 7, 2, 9, 10, 5, 1, 3, 6] 
    for i in unsorted_list: 
        h.insert(i) 
    print("Unsorted list: {}".format(unsorted_list)) 
```

堆 `h` 被创建，`unsorted_list` 中的元素被插入。在每次调用 `insert` 方法后，堆顺序属性都会通过随后调用 `float` 方法得到恢复。循环结束后，元素 `4` 将位于我们的堆顶。

我们的堆中的元素数量为 `10`。如果我们在 `h` 堆对象上调用 `pop` 方法 10 次，并存储被弹出的实际元素，我们最终得到一个排序好的列表。每次 `pop` 操作后，堆都会被调整以保持堆顺序属性。

`heap_sort` 方法如下：

```py
    class Heap: 
        ... 
        def heap_sort(self): 
            sorted_list = [] 
            for node in range(self.size): 
                n = self.pop() 
                sorted_list.append(n) 

            return sorted_list 
```

`for` 循环简单地调用 `pop` 方法 `self.size` 次。现在，循环结束后，`sorted_list` 将包含一个排序好的项目列表。

`insert` 方法被调用了 *n* 次。加上 `arrange()` 方法，`insert` 操作的最坏情况运行时间为 `O(n log n)`，`pop` 方法也是如此。因此，这种排序算法的最坏情况运行时间为 `O(n log n)`。

不同排序算法的复杂性比较如下表所示：

| **算法** | **最坏情况** | **平均情况** | **最佳情况** |
| 冒泡排序 | `O(n²)` | `O(n²)` | `O(n)` |
| 插入排序 | `O(n²)` | `O(n²)` | `O(n)` |
| 选择排序 | `O(n²)` | `O(n²)` | `O(n²)` |
| 快速排序 | `O(n²)` | `O(n log n)` | `O(n log n)` |
| 堆排序 | `O(n log n)` | `O(n log n)` | `O(n log n)` |

# 总结

在本章中，我们探讨了许多重要和流行的排序算法，这些算法对许多实际应用非常有用。我们讨论了冒泡排序、插入排序、选择排序、快速排序和堆排序算法，以及它们在 Python 中的实现解释。快速排序比其他排序算法表现要好得多。在所有讨论的算法中，快速排序保留了它所排序的列表的索引。在下一章中，我们将利用这一特性来探讨选择算法。

在下一章中，我们将讨论与选择策略和算法相关的概念。
