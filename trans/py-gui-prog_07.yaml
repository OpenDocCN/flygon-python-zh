- en: Navigating Records with Treeview
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Treeview导航记录
- en: You've received another request for features in the application. Now that your
    users can open arbitrary files, they'd like to be able to see what's in those
    files and correct old records using the data entry form they've grown accustomed
    to, rather than having to switch over to a spreadsheet. In a nutshell, it's finally
    time to implement read and update capabilities in our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您收到了应用程序中的另一个功能请求。现在，您的用户可以打开任意文件，他们希望能够查看这些文件中的内容，并使用他们已经习惯的数据输入表单来更正旧记录，而不必切换到电子表格。简而言之，现在终于是时候在我们的应用程序中实现读取和更新功能了。
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Modifying our CSV model for read and update capabilities
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改我们的CSV模型以实现读取和更新功能
- en: Discovering the ttk `Treeview` widget, and building a list of records with it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现ttk`Treeview`小部件，并使用它构建记录列表
- en: Implementing record loading and updating in our data record form
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的数据记录表单中实现记录加载和更新
- en: Redesigning the menu and application with read and update in mind
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新设计菜单和应用程序，考虑到读取和更新
- en: Implementing read and update in the model
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模型中实现读取和更新
- en: Our entire design up to this point has been centered around a form that only
    appends data to a file; adding read and update capabilities is a fundamental change
    that will touch nearly every portion of the application. It may seem like a daunting
    task, but by taking it one component at a time, we'll see that the changes are
    not so overwhelming.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的整个设计都是围绕着一个只能向文件追加数据的表单；添加读取和更新功能是一个根本性的改变，几乎会触及应用程序的每个部分。这可能看起来是一项艰巨的任务，但通过逐个组件地进行，我们会发现这些变化并不那么令人难以承受。
- en: 'The first thing we should do is update our documentation, starting with the
    `Requirements` section:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该做的第一件事是更新我们的文档，从`Requirements`部分开始：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And, of course, also update the part that is not required that follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还要更新后面不需要的部分：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, it's a simple matter of making the code match with the documentation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需让代码与文档匹配即可。
- en: Adding read and update to our model
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将读取和更新添加到我们的模型中
- en: 'Open `models.py` and consider what''s missing from the `CSVModel` class:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`models.py`并考虑`CSVModel`类中缺少的内容：
- en: We'll need a method that can retrieve all records in a file so we can display
    them. We'll call it `get_all_records()`.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一种方法，可以检索文件中的所有记录，以便我们可以显示它们。我们将其称为`get_all_records()`。
- en: We'll need a method to fetch individual records from the file by row number.
    We can call this `get_record()`.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一种方法来按行号从文件中获取单个记录。我们可以称之为`get_record()`。
- en: We'll need to save records in a way that can not only append new records, but
    update existing records as well. We can update our `save_record()` method to accommodate
    this.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要以一种既能追加新记录又能更新现有记录的方式保存记录。我们可以更新我们的`save_record()`方法来适应这一点。
- en: Implementing  get_all_records()
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`get_all_records()`
- en: 'Start a new method called `get_all_records()`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个名为`get_all_records()`的新方法：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first thing we've done is check if the model's file exists yet. Remember
    that when our application starts, it generates a default filename pointing to
    a file that likely doesn't exist yet, so `get_all_records()` will need to handle
    this situation gracefully. It makes sense to return an empty list in this case,
    since there's no data if the file doesn't exist.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的第一件事是检查模型的文件是否已经存在。请记住，当我们的应用程序启动时，它会生成一个默认文件名，指向一个可能尚不存在的文件，因此`get_all_records()`将需要优雅地处理这种情况。在这种情况下返回一个空列表是有道理的，因为如果文件不存在，就没有数据。
- en: 'If the file does exist, let''s open it in read-only mode and get all the records:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件存在，让我们以只读模式打开它并获取所有记录：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'While not terribly efficient, pulling the entire file into memory and converting
    it into a list is acceptable in our case, since we know that our largest files
    should be limited to a mere 401 rows: 20 plots times 5 labs plus a header row.
    This code is just a little too trusting, however. We should at least do some sanity
    checks to make sure that the user has actually opened a CSV file containing the
    proper fields and not some other arbitrary file.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是非常高效，但在我们的情况下，将整个文件加载到内存中并将其转换为列表是可以接受的，因为我们知道我们的最大文件应该限制在仅401行：20个图形乘以5个实验室加上标题行。然而，这段代码有点太信任了。我们至少应该进行一些合理性检查，以确保用户实际上已经打开了包含正确字段的CSV文件，而不是其他任意文件。
- en: 'Let''s check that the file has the correct field structure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查文件是否具有正确的字段结构：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we first find any missing fields by converting a list of our `fields`
    dictionary `keys` and the CSV file's `fieldnames` to Python `set` objects. We
    can subtract the `fieldnames` set from `keys` and determine which fields, if any,
    are missing in the file. If there are any, we'll raise an exception; otherwise,
    we convert the CSV data to `list`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先通过将我们的`fields`字典`keys`的列表和CSV文件的`fieldnames`转换为Python`set`对象来找到任何缺失的字段。我们可以从`keys`中减去`fieldnames`集合，并确定文件中缺少的字段。如果有任何字段缺失，我们将引发异常；否则，我们将CSV数据转换为`list`。
- en: Python `set` objects are very useful for comparing the content of the `list`,
    `tuple`, and other sequence objects. They provide an easy way to get information
    such as the difference (items in `x` that are not in `y`) or intersection (items
    in both `x` and `y`) between two sets, or allow you to compare sequences without
    respect to order.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`set`对象非常有用，可以比较`list`、`tuple`和其他序列对象的内容。它们提供了一种简单的方法来获取诸如差异（`x`中的项目不在`y`中）或交集（`x`和`y`中的项目）之类的信息，或者允许您比较不考虑顺序的序列。
- en: Before we can return the `records` list, we need to correct one issue; all data
    in a CSV file is stored as text, and read by Python as a string. Most of this
    is not a problem, since Tkinter will take care of converting strings to `float`
    or `int` as necessary, but `bool` values are stored in the CSV file as the strings
    `True` and `False`, and coercing these values directly back to `bool` doesn't
    work. `False` is a non-empty string, and all non-empty strings evaluate to `True`
    in Python.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以返回`records`列表之前，我们需要纠正一个问题；CSV文件中的所有数据都存储为文本，并由Python作为字符串读取。这大多数情况下不是问题，因为Tkinter会负责根据需要将字符串转换为`float`或`int`，但是`bool`值在CSV文件中存储为字符串`True`和`False`，直接将这些值强制转换回`bool`是行不通的。`False`是一个非空字符串，在Python中所有非空字符串都会被视为`True`。
- en: 'To fix this, let''s first define a list of strings that should be interpreted
    as `True`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们首先定义一个应被解释为`True`的字符串列表：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Any values not in this list will be considered `False`. We'll do a case-insensitive
    comparison, so there are only lowercase values in our list.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 不在此列表中的任何值都将被视为`False`。我们将进行不区分大小写的比较，因此我们的列表中只有小写值。
- en: 'Next, we create a list of fields that are `boolean` fields using a list comprehension
    as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用列表推导式创建一个包含`boolean`字段的字段列表，如下所示：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We know that `Equipment Fault` is our only boolean field, so technically we
    could just hardcode that here, but it's a good idea to design your model so that
    any changes to the schema will be automatically handled appropriately by the logic
    portions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`Equipment Fault`是我们唯一的布尔字段，因此从技术上讲，我们可以在这里硬编码它，但是最好设计您的模型，以便对模式的任何更改都将自动适当地处理逻辑部分。
- en: 'Now, let''s check these boolean fields in each row by adding the following
    code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过添加以下代码来检查每行中的布尔字段：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For every record, we iterate through our list of the boolean fields and check
    its value against our list of truthy strings, setting the value of the item accordingly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每条记录，我们遍历我们的布尔字段列表，并根据我们的真值字符串列表检查其值，相应地设置该项的值。
- en: 'With the boolean values fixed, we can return our `records` list as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 修复布尔值后，我们可以将我们的`records`列表返回如下：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Implementing  get_record()
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现`get_record()`
- en: Our `get_record()` method needs to take a row number and return a single dictionary
    containing the data for that row.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`get_record()`方法需要接受行号并返回包含该行数据的单个字典。
- en: 'This is pretty simple if we leverage our `get_all_records()` method as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们利用我们的`get_all_records()`方法，这就非常简单了，如下所示：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since our files are small and there's very little overhead to pulling all the
    records, we can simply do that and then dereference the record we need.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的文件很小，拉取所有记录的开销很小，我们可以简单地这样做，然后取消引用我们需要的记录。
- en: Keep in mind that it's possible to pass `rownum` that doesn't exist in our records
    list; in this case, we'd get `IndexError`; our calling code will need to catch
    this error and deal with it appropriately.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，可能会传递不存在于我们记录列表中的`rownum`；在这种情况下，我们会得到`IndexError`；我们的调用代码将需要捕获此错误并适当处理。
- en: Adding update to save_record()
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将更新添加到`save_record()`
- en: To convert our `save_record()` method so that we can update records, the first
    thing we'll need to do is provide the ability to pass in a row number to update.
    The default will be `None`, which will indicate that the data is a new row that
    should be appended.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的`save_record()`方法转换为可以更新记录的方法，我们首先需要做的是提供传入要更新的行号的能力。默认值将是`None`，表示数据是应追加的新行。
- en: 'The new method signature looks like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 新的方法签名如下：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our existing logic doesn't need to change, but it should only be run if `rownum`
    is `None`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现有的逻辑不需要更改，但只有在`rownum`为`None`时才应运行。
- en: 'So, the first thing to do in the method is check `rownum`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在该方法中要做的第一件事是检查`rownum`：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For relatively small files, the simplest way to update a single row is to load
    the entire file into a list, change the row in the list, and then write the entire
    list back to a clean file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相对较小的文件，更新单行的最简单方法是将整个文件加载到列表中，更改列表中的行，然后将整个列表写回到一个干净的文件中。
- en: 'Under the `if` block, we''ll add the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`块下，我们将添加以下代码：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once again, we leverage our `get_all_records()` method to fetch the CSV file's
    content into a list. We then replace the dictionary in the requested row with
    the `data` dictionary provided. Finally, we open the file in write mode (`w`),
    which will clear its content and replace it with whatever we write to the file,
    and write the header and all records back to the file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 再次利用我们的`get_all_records()`方法将CSV文件的内容提取到列表中。然后，我们用提供的`data`字典替换请求行中的字典。最后，我们以写模式（`w`）打开文件，这将清除其内容并用我们写入文件的内容替换它，并将标题和所有记录写回文件。
- en: The approach we're taking makes it unsafe for two users to work in the save
    CSV file simultaneously. Creating software that allows for multiple users editing
    a single file is notoriously difficult, and many programs simply opt to prevent
    it in the first place using lock files or other protection mechanisms.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采取的方法使得两个用户同时在保存CSV文件中工作是不安全的。创建允许多个用户编辑单个文件的软件是非常困难的，许多程序选择使用锁文件或其他保护机制来防止这种情况。
- en: This method is finished, and that's all we need to change in our model to enable
    updating and viewing. Now, it's time to add the necessary features to our GUI.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法已经完成了，这就是我们需要在模型中进行的所有更改，以实现更新和查看。现在，是时候向我们的GUI添加必要的功能了。
- en: Implementing a record list view
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现记录列表视图
- en: The record list view will allow our users to browse the content of the file
    and open records for viewing or editing. Our users are accustomed to seeing this
    data in a spreadsheet, laid out in a table-like format, so it makes sense to design
    our view in a similar fashion. Since our view mainly exists for finding and selecting
    individual records, we don't need to display all the information; just enough
    for the users to distinguish one record from another.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 记录列表视图将允许我们的用户浏览文件的内容，并打开记录进行查看或编辑。我们的用户习惯于在电子表格中看到这些数据，以表格格式呈现，因此设计我们的视图以类似的方式是有意义的。由于我们的视图主要存在于查找和选择单个记录，我们不需要显示所有信息；只需要足够让用户区分一个记录和另一个记录。
- en: A quick analysis shows that we need CSV row number, `Date`, `Time`, `Lab`, and
    `Plot`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '快速分析表明我们需要CSV行号、`Date`、`Time`、`Lab`和`Plot`。 '
- en: For building table-like views with selectable rows, Tkinter gives us the ttk 
    `Treeview` widget. To build our record list view, we'll need to learn about `Treeview`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于构建具有可选择行的类似表格的视图，Tkinter为我们提供了ttk `Treeview`小部件。为了构建我们的记录列表视图，我们需要了解`Treeview`。
- en: The ttk Treeview
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ttk Treeview
- en: The `Treeview` is a ttk widget designed to show columns of data in a hierarchical
    structure.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Treeview`是一个ttk小部件，设计用于以分层结构显示数据的列。'
- en: 'Perhaps the best example of this kind of data is a filesystem tree:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这种数据的最好例子是文件系统树：
- en: Each row can represent a file or directory
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一行可以代表一个文件或目录
- en: Each directory can contain additional files or directories
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个目录可以包含额外的文件或目录
- en: Each row can have additional data properties, such as permissions, size, or
    ownership information
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一行都可以有额外的数据属性，比如权限、大小或所有权信息
- en: To explore how `Treeview` works, we'll create a simple file browser with some
    help from `pathlib`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索`Treeview`的工作原理，我们将借助`pathlib`创建一个简单的文件浏览器。
- en: In previous chapters, we used `os.path` to work with file paths. `pathlib` is
    a new addition to the Python 3 standard library that provides a more object-oriented
    approach to paths.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们使用`os.path`来处理文件路径。`pathlib`是Python 3标准库的一个新添加，它提供了更面向对象的路径处理方法。
- en: 'Open a new file called `treeview_demo.py` and start with this template:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个名为`treeview_demo.py`的新文件，并从这个模板开始：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''ll start by getting a list of all the file paths under the current working
    directory. `Path` has a method called `glob` that will give us such a list as
    follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先获取当前工作目录下所有文件路径的列表。`Path`有一个名为`glob`的方法，将给我们提供这样的列表，如下所示：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`glob()` expands wildcard characters like `*` and `?` against a filesystem
    tree. The name goes back to a very early Unix command, though the same wildcard
    syntax is now used across most modern operating systems.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`glob()`会对文件系统树扩展通配符字符，比如`*`和`?`。这个名称可以追溯到一个非常早期的Unix命令，尽管现在相同的通配符语法在大多数现代操作系统中都被使用。'
- en: '`Path(''.'')` creates a path object referencing the current working directory,
    and `**/*` is a special wildcard syntax that recursively grabs all objects under
    the path. The result is a list of the `Path` objects that include every directory
    and file under our current directory.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path(''.'')` 创建一个引用当前工作目录的路径对象，`**/*` 是一个特殊的通配符语法，递归地抓取路径下的所有对象。结果是一个包含当前目录下每个目录和文件的`Path`对象列表。'
- en: 'With that done, we can create and configure our `Treeview` widget by executing
    the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以通过执行以下代码来创建和配置我们的`Treeview`小部件：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Like any Tkinter widget, the first argument to `Treeview` is its `parent` widget.
    Each column in the `Treeview` widget is given an identifying string; by default,
    there is always one column named `"#0"`. This column represents the basic identifying
    information about each item in the tree, such as a name or ID number. To add more
    columns, we specify them using the `columns` argument. This list contains any
    number of strings that will be used to identify the subsequent columns.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何Tkinter小部件一样，`Treeview`的第一个参数是它的`parent`小部件。`Treeview`小部件中的每一列都被赋予一个标识字符串；默认情况下，总是有一个名为`"#0"`的列。这一列代表树中每个项目的基本标识信息，比如名称或ID号。要添加更多列，我们使用`columns`参数来指定它们。这个列表包含任意数量的字符串，用于标识随后的列。
- en: Finally, we set `selectmode`, which determines how users can select items in
    the tree.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置`selectmode`，确定用户如何在树中选择项目。
- en: 'The following table shows the options for `selectmode`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了`selectmode`的选项：
- en: '| **Value** | **Behavior** |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **Value** | **Behavior** |'
- en: '| `selectmode` | Selections can be made |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `selectmode` | 可以进行选择 |'
- en: '| `none` (as a string, not the `None` object) | No selections can be made |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `none`（作为字符串，而不是`None`对象） | 不能进行选择 |'
- en: '| `browse` | User can select one item only |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `browse` | 用户只能选择一个项目 |'
- en: '| `extended` | User can select multiple items |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `extended` | 用户可以选择多个项目 |'
- en: In this case, we're preventing selection, so we set it to `none`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在阻止选择，所以将其设置为`none`。
- en: 'To show how we use the column names, we''ll set some headings for the columns:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示我们如何使用列名，我们将为列设置一些标题：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Treeview` heading method is for manipulating the column `heading` widget;
    it takes the column name, and then any number of attributes you want to assign
    to the column's `heading` widget.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Treeview` heading方法用于操作列`heading`小部件；它接受列名，然后是要分配给列`heading`小部件的任意数量的属性。'
- en: 'Those attributes can include:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性可以包括：
- en: '`text`: The text displayed for the heading. By default, it''s blank.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`：标题显示的文本。默认情况下为空。'
- en: '`anchor`: The alignment of the text; it can be any of eight cardinal directions
    or `center`, specified as strings or Tkinter constants.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anchor`：文本的对齐方式；可以是八个基本方向之一或`center`，指定为字符串或Tkinter常量。'
- en: '`command`: A command to run when the heading is clicked. This might be used
    to order the rows by that column, or select all the values in the column, for
    example.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command`：单击标题时要运行的命令。这可能用于按该列对行进行排序，或选择该列中的所有值，例如。'
- en: '`image`: An image to display in the heading.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`：要在标题中显示的图像。'
- en: 'Finally, we pack the column into the `root` widget and expand it to fill the
    widget:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们将列打包到`root`小部件中，并扩展它以填充小部件： '
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In addition to configuring the headers, we can configure some attributes of
    the column itself using the `Treeview.column` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配置标题之外，我们还可以使用`Treeview.column`方法配置列本身的一些属性。
- en: 'For example, we can add the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以添加以下代码：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we've set `stretch` to `True` in the first column, which will
    cause it to expand to fill available; and we've set the `width` value on the `size`
    column to `200` pixels.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们已将第一列中的`stretch`设置为`True`，这将导致它扩展以填充可用空间；我们还将`size`列上的`width`值设置为`200`像素。
- en: 'The column parameters that can be set include:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置的列参数包括：
- en: '`stretch`: Whether or not to expand this column to fill the available space.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stretch`：是否将此列扩展以填充可用空间。'
- en: '`width`: The width of the column in pixels.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`：列的宽度，以像素为单位。'
- en: '`minwidth`: The minimum width to which the column can be resized, in pixels.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minwidth`：列可以调整的最小宽度，以像素为单位。'
- en: '`anchor`: The alignment of the text in the column. Can be any of eight cardinal
    directions or center, specified as strings or Tkinter constants.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anchor`：列中文本的对齐方式。可以是八个基本方向或中心，指定为字符串或Tkinter常量。'
- en: With the tree view configured, it now needs to be filled with data. Populating
    a `Treeview` with data is done one row at a time using the `insert` method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 树视图配置完成后，现在需要填充数据。使用`insert`方法逐行填充`Treeview`的数据。
- en: 'The `insert` method looks like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert`方法如下所示：'
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first argument specifies the `parent` item for the inserted row. This is
    not the `parent` widget, but rather the `parent` row under which the inserted
    row belongs in the hierarchical structure. The value is a string that refers to
    the `iid` of the `parent` item. For top-level items, this value should be an empty
    string.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数指定插入行的`parent`项目。这不是`parent`小部件，而是层次结构中插入行所属的`parent`行。该值是一个字符串，指的是`parent`项目的`iid`。对于顶级项目，该值应为空字符串。
- en: The next argument specifies where the item should be inserted. It's either a
    numerical index or `end`, which places the item at the end of the list.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个参数指定应将项目插入的位置。它可以是数字索引或`end`，将项目放在列表末尾。
- en: 'After this, we specify keyword arguments, which can include:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以指定关键字参数，包括：
- en: '`text`: This is the value to be shown in the first column.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`：这是要显示在第一列中的值。'
- en: '`values`: This is a list of values for the remaining columns.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`values`：这是剩余列的值列表。'
- en: '`image`: This is an image object to display in the far left of the column.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`：这是要显示在列最左侧的图像对象。'
- en: '`iid`: The item ID string. This will be automatically assigned if you don''t
    specify it.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iid`：项目ID字符串。如果不指定，将自动分配。'
- en: '`open`: Whether or not the row is open (displaying child items) at the start.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`：行在开始时是否打开（显示子项）。'
- en: '`tags`: A list of tag strings.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tags`：标签字符串列表。'
- en: 'To insert our paths into the `Treeview`, let''s iterate our `paths` list as
    follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的路径插入`Treeview`，让我们按如下方式遍历我们的`paths`列表：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Before calling `insert`, we need to extract and prepare some data from the path
    object. `path.stat()` will give us an object containing various file information.
    `path.parent` provides us the containing path; however, we need to change the
    name of the `root` path (currently a single dot) to an empty string, which is
    how `Treeview` represents the `root` node.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`insert`之前，我们需要从路径对象中提取和准备一些数据。`path.stat()`将给我们一个包含各种文件信息的对象。`path.parent`提供了包含路径；但是，我们需要将`root`路径的名称（当前为单个点）更改为一个空字符串，这是`Treeview`表示`root`节点的方式。
- en: 'Now, we add the `insert` call as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们按如下方式添加`insert`调用：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By using the path string as the item ID, we can then specify it as a parent
    for its child objects. We use only the object `name` (without the containing path)
    as our display value, then `st_size` and `st_mtime` for populating the size and
    modification time columns.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用路径字符串作为项目ID，我们可以将其指定为其子对象的父级。我们仅使用对象的`name`（不包含路径）作为我们的显示值，然后使用`st_size`和`st_mtime`来填充大小和修改时间列。
- en: 'Run this script and you should see a simple file tree browser that looks something
    like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本，您应该会看到一个简单的文件树浏览器，类似于这样：
- en: '![](assets/1ceeffaf-50a0-4c9e-97d3-525c1026367f.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1ceeffaf-50a0-4c9e-97d3-525c1026367f.png)'
- en: The `Treeview` widgets doesn't offer any kind of sorting functionality by default,
    but we can add it fairly easily.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Treeview`小部件默认不提供任何排序功能，但我们可以相当容易地添加它。'
- en: 'First, let''s create a sorting function by adding the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过添加以下代码创建一个排序函数：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code snippet, the `sort` function takes a `Treeview` widget
    and the ID of a column in which we'll sort. It starts by getting a list of all
    the `iid` values using the `get_children()` method of `Treeview`. Next, it sorts
    the various `iid` values using the value of `col` for each item as a key; rather
    confusingly, the `set()` method of `Treeview` is used to retrieve the value of
    the column (there is no `get()` method). Finally, we iterate the list and use
    the `move()` method to move each item to a new index under its parent (which is
    retrieved using the `parent()` method).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，`sort`函数接受一个`Treeview`小部件和我们将对其进行排序的列的ID。它首先使用`Treeview`的`get_children()`方法获取所有`iid`值的列表。接下来，它使用`col`的值作为键对各种`iid`值进行排序；令人困惑的是，`Treeview`的`set()`方法用于检索列的值（没有`get()`方法）。最后，我们遍历列表，并使用`move()`方法将每个项目移动到其父级下的新索引（使用`parent()`方法检索）。
- en: 'To make our columns sortable, add this function as a callback to the headers
    using the `command` argument as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的列可排序，使用`command`参数将此函数作为回调添加到标题中，如下所示：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Implementing our record list with Treeview
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`Treeview`实现我们的记录列表
- en: Now that we understand how to use the `Treeview` widget, let's start building
    our record list widget.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了如何使用`Treeview`小部件，让我们开始构建我们的记录列表小部件。
- en: 'We''ll begin by subclassing `tkinter.Frame`, just as we did with our record
    form:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过子类化`tkinter.Frame`来开始，就像我们在记录表单中所做的那样。
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To save ourselves from some repetitious code, we'll define our column properties
    and defaults in class constants. This also makes it easier to tweak them to suit
    our needs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省一些重复的代码，我们将在类常量中定义我们的列属性和默认值。这也使得更容易调整它们以满足我们的需求。
- en: 'Start out your class with the following properties:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下属性开始你的类：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Recall that we're going to be displaying `Date`, `Time`, `Lab`, and `Plot`.
    For the first default column, we'll show the CSV row number. We've also set the `width`
    and `anchor` values for some columns, and configured the `Date` field to stretch.
    We'll use these values when configuring the `Treeview` widget in `__init__()`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们将显示`Date`，`Time`，`Lab`和`Plot`。对于第一个默认列，我们将显示CSV行号。我们还为一些列设置了`width`和`anchor`值，并配置了`Date`字段以进行拉伸。我们将在`__init__()`中配置`Treeview`小部件时使用这些值。
- en: 'Let''s start our `__init__()` definition as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下方式开始定义我们的`__init__()`：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As with other views, we're going to accept a dictionary of callback methods
    from the `Application` object, and save it as an instance property.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他视图一样，我们将从`Application`对象接受回调方法的字典，并将其保存为实例属性。
- en: Configuring a Treeview widget
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Treeview小部件
- en: 'Now, let''s create our `Treeview` widget by executing the following code snippet:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过执行以下代码片段来创建我们的`Treeview`小部件：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that we're excluding the `#0` column from our `columns` list; it should
    never be specified here since it's automatically created. We're also choosing
    the `browse` select mode, so that users can select individual rows of the CSV
    file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在从我们的`columns`列表中排除`＃0`列；它不应在这里指定，因为它会自动创建。我们还选择了`browse`选择模式，这样用户就可以选择CSV文件的单独行。
- en: 'Let''s go ahead and add our `Treeview` widget to `RecordList` and make it fill
    the widget:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续将我们的`Treeview`小部件添加到`RecordList`并使其填充小部件：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, configure the columns and headings of `Treeview` by iterating through
    the `column_defs` dictionary:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过迭代`column_defs`字典来配置`Treeview`的列和标题：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For each set of items, let''s extract the configuration values we need as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每组项目，让我们按如下方式提取我们需要的配置值：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we''ll use those values to configure the heading and columns:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用这些值来配置标题和列：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Adding a scrollbar
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加滚动条
- en: The ttk `Treeview` does not have a scrollbar by default; it *can* be scrolled,
    using the keyboard or mouse-wheel controls, but users would reasonably expect
    a scrollbar on a scrollable area to help them visualize the size of the list and
    their current position in it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ttk的`Treeview`默认没有滚动条；它*可以*使用键盘或鼠标滚轮控件进行滚动，但用户合理地期望在可滚动区域上有滚动条，以帮助他们可视化列表的大小和当前位置。
- en: 'Fortunately, ttk provides us with a `Scrollbar` object that can be connected
    to our `Treeview` widget:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，ttk为我们提供了一个可以连接到我们的`Treeview`小部件的`Scrollbar`对象：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, `Scrollbar` takes the following two important arguments:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Scrollbar`接受以下两个重要参数：
- en: '`orient`: This argument determines whether it is a horizontal or vertical scroll'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`orient`：此参数确定是水平滚动还是垂直滚动'
- en: '`command`: This argument provides a callback for scrollbar move events'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command`：此参数为滚动条移动事件提供回调'
- en: In this case, we set the callback to the tree view's `yview` method, which is
    used to make the `Treeview` scroll up and down.  The other option would be `xview`,
    which would be used for horizontal scrolling.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将回调设置为树视图的`yview`方法，该方法用于使`Treeview`上下滚动。另一个选项是`xview`，它将用于水平滚动。
- en: 'We also need to connect our `Treeview` back to the scrollbar:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将我们的`Treeview`连接回滚动条：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If we don't do this, our `Scrollbar` won't know how far down the list we've
    scrolled or how long the list is, and can't set the size or location of the bar
    widget appropriately.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不这样做，我们的`Scrollbar`将不知道我们已经滚动了多远或列表有多长，并且无法适当地设置滚动条小部件的大小或位置。
- en: With our `Scrollbar` configured, we need to place it on the widget—conventionally,
    just to the right of the widget being scrolled.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了我们的`Scrollbar`后，我们需要将其放置在小部件上——通常是在要滚动的小部件的右侧。
- en: 'We can use our `grid` layout manager for this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的`grid`布局管理器来实现这一点：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice we set `sticky` to north, south, and west. North and south make sure
    the scrollbar stretches the entire height of the widget, and west makes sure it's
    snug against the `Treeview` widget to the left of it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`sticky`设置为north、south和west。north和south确保滚动条拉伸到小部件的整个高度，west确保它紧贴着`Treeview`小部件的左侧。
- en: Populating the Treeview
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充Treeview
- en: 'Now that we have our `Treeview` widget, we''ll create a `populate()` method
    to populate it with data:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`Treeview`小部件，我们将创建一个`populate()`方法来填充它的数据：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `rows` argument will take a list of the `dict` data types, such as what
    is returned from `model`. The idea is that the controller will fetch a list from
    the model and then pass it to this method.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`rows`参数将接受`dict`数据类型的列表，例如从`model`返回的类型。其想法是控制器将从模型中获取一个列表，然后将其传递给此方法。'
- en: 'Before refilling `Treeview`, we need to empty it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新填充`Treeview`之前，我们需要清空它：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The   `get_children()` method of `Treeview` returns a list of every row's `iid`.
    We're iterating this list, passing each `iid` to the `Treeview.delete()` method,
    which, as you'd expect, deletes the row.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Treeview`的`get_children()`方法返回每行的`iid`列表。我们正在迭代此列表，将每个`iid`传递给`Treeview.delete()`方法，正如您所期望的那样，删除该行。'
- en: 'With the `Treeview` cleared, we can iterate through the `rows` list and populate
    the table:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 清除`Treeview`后，我们可以遍历`rows`列表并填充表格：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first thing we do here is create a list of all the keys we actually want
    to fetch from each row; this is just the list of keys from `self.column_defs`
    minus the `"#0"` column.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里要做的第一件事是创建一个我们实际想要从每一行获取的所有键的列表；这只是从`self.column_defs`减去`＃0`列的键列表。
- en: Next, we iterate through the rows using the `enumerate()` function to generate
    a row number. For each row, we'll create a list of values in the proper order
    using a list comprehension, then insert the list to the end of the `Treeview` widget
    with the `insert()` method. Notice that we're just using the row number (converted
    to a string) as both `iid` and `text` for the row.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `enumerate()` 函数迭代行以生成行号。对于每一行，我们将使用列表推导创建正确顺序的值列表，然后使用 `insert()`
    方法将列表插入到 `Treeview` 小部件的末尾。请注意，我们只是将行号（转换为字符串）用作行的 `iid` 和 `text`。
- en: The last thing we need to do in this function is a small usability tweak. To
    make our `Treeview` keyboard friendly, we need to focus the first item so that
    keyboard users can immediately start to navigate it via the arrow keys.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中我们需要做的最后一件事是进行一些小的可用性调整。为了使我们的 `Treeview` 对键盘友好，我们需要将焦点放在第一项上，这样键盘用户就可以立即开始使用箭头键进行导航。
- en: 'Doing this in a `Treeview` widget actually takes three method calls as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Treeview` 小部件中实际上需要三个方法调用，如下所示：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: First, `focus_set` moves focus to `Treeview`. Next, `selection_set(0)` selects
    the first record in the list. Finally, `focus('0')` focuses the row with `iid`
    of `0`. And, of course, we only do this if there are any rows at all.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`focus_set` 将焦点移动到 `Treeview`。接下来，`selection_set(0)` 选择列表中的第一条记录。最后，`focus('0')`
    将焦点放在 `iid` 为 `0` 的行上。当然，我们只在有任何行的情况下才这样做。
- en: Responding to record selection
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应记录选择
- en: The purpose of this widget is for users to select and open records; therefore,
    we need a way to do that. It would be nice to be able to trigger this from an
    event like a double-click or keyboard selection.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小部件的目的是让用户选择和打开记录；因此，我们需要一种方法来做到这一点。最好能够从双击或键盘选择等事件触发这一点。
- en: 'The `Treeview` widget has three special events which we can use to trigger
    a callback as shown in the following table:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`Treeview` 小部件有三个特殊事件，我们可以使用它们来触发回调，如下表所示：'
- en: '| **Event string** | **Triggered when** |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| **事件字符串** | **触发时** |'
- en: '| `<<TreeviewSelect>>` | A row is selected, such as by clicking it with a mouse
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `<<TreeviewSelect>>` | 选择行，例如通过鼠标点击 |'
- en: '| `<<TreeviewOpen>>` | A row is opened by a double-click or by selecting it
    and hitting *Enter* |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `<<TreeviewOpen>>` | 通过双击或选择并按 *Enter* 打开行 |'
- en: '| `<<TreeviewClose>>` | An open row is closed |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `<<TreeviewClose>>` | 关闭打开的行 |'
- en: '`<<TreeviewOpen>>` sounds like the event we want; even though we''re not using
    a hierarchical list, the user is still conceptually opening the record, and the
    triggering action (double-click) seems intuitive. We''ll bind this event to a
    method that will open the selected record.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`<<TreeviewOpen>>` 听起来像我们想要的事件；即使我们没有使用分层列表，用户仍然在概念上打开记录，并且触发动作（双击）似乎很直观。我们将将此事件绑定到一个方法，该方法将打开所选记录。'
- en: 'Add this code at the end of `__init__()`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到 `__init__()` 的末尾：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `on_open_record()` method is quite simple; add this code to the class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_open_record()` 方法非常简单；将此代码添加到类中：'
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It's as simple as retrieving the selected ID from `Treeview`, then calling a
    function provided by our controller in the `callbacks` dictionary with the selected
    ID. It will be up to the controller to do something appropriate here.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 只需从 `Treeview` 中检索所选 ID，然后使用控制器中的 `callbacks` 字典提供的函数调用所选 ID。这将由控制器来做一些适当的事情。
- en: The `RecordList` class is now complete, but some of our other view classes need
    attention.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecordList` 类现在已经完成，但是我们的其他视图类需要注意。'
- en: Modifying the record form for read and update
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改记录表单以进行读取和更新
- en: As long as we're editing views, we'll need to look at our `DataRecordForm` view
    and adjust it to make it capable of updating records.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们在编辑视图，我们就需要查看我们的 `DataRecordForm` 视图，并调整它以使其能够更新记录。
- en: 'Take a moment and consider the following changes we''ll need to make:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间考虑一下我们需要进行的以下更改：
- en: The form will need some way to load in a record provided by the controller.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单将需要一种方式来加载控制器提供的记录。
- en: The form will need to keep track of what record it's editing, or if it's a new
    record.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单将需要跟踪它正在编辑的记录，或者是否是新记录。
- en: Our user will need some visual indication of what record is being edited.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的用户需要一些视觉指示来指示正在编辑的记录。
- en: Our Save button is currently in the application. It doesn't really make sense
    in any context other than the form, so it should probably be part of the form.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的保存按钮当前在应用程序中。它在表单之外没有任何意义，因此它可能应该是表单的一部分。
- en: This means our form will need a callback to call when the save button is clicked.
    We'll need to provide it with a `callbacks` dictionary like we did with our other
    views.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着我们的表单将需要一个在单击保存按钮时调用的回调。我们需要像我们的其他视图一样为它提供一个 `callbacks` 字典。
- en: Updating __init__()
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 `__init__()`
- en: 'Let''s start working through these with our `__init__()` method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的 `__init__()` 方法开始逐步进行这些工作：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We're adding a new argument, `callbacks`, and storing it as an instance property.
    This will give the controller a way to provide methods for the view to call.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在添加一个新的参数 `callbacks`，并将其存储为实例属性。这将为控制器提供一种方法来提供视图调用的方法。
- en: 'Next, our `__init__()` method should set up a variable in which to store the
    current record:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的 `__init__()` 方法应该设置一个变量来存储当前记录：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We'll use `None` to indicate that no record is loaded and the form is being
    used to create a new record. Otherwise, this value will be an integer referencing
    a row in the CSV data.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `None` 来指示没有加载记录，表单正在用于创建新记录。否则，这个值将是一个引用 CSV 数据中行的整数。
- en: We could use a Tkinter variable here, but there's no real advantage in this
    case, and we wouldn't be able to use `None` as a value.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里使用一个 Tkinter 变量，但在这种情况下没有真正的优势，而且我们将无法使用 `None` 作为值。
- en: 'At the top of the form, before the first form fields, let''s add a label that
    will keep track of which record we''re editing:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单顶部，在第一个表单字段之前，让我们添加一个标签，用于跟踪我们正在编辑的记录：
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We're placing this in row `0`, column `0`, but the first `LabelFrame` is also
    in that location. You'll need to go through each `LabelFrame` and increment the
    `row` value in its call to `grid`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其放在第`0`行，第`0`列，但第一个`LabelFrame`也在那个位置。您需要逐个检查每个`LabelFrame`，并在其对`grid`的调用中递增`row`值。
- en: We'll make sure this label gets updated whenever a record is loaded into the
    form.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将确保每当记录加载到表单中时，此标签都会得到更新。
- en: 'At the very end of the widget, after the `Notes` field, let''s add our new
    Save button as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在小部件的最后，`Notes`字段之后，让我们添加我们的新保存按钮如下：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The button will call an `on_save()` method from the `callbacks` dictionary when
    clicked. We'll need to make sure to provide this method when creating `DataRecordForm`
    in `Application`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击按钮时，按钮将调用`callbacks`字典中的`on_save()`方法。在`Application`中创建`DataRecordForm`时，我们需要确保提供这个方法。
- en: Adding a load_record() method
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加`load_record()`方法
- en: The last thing to add in our view is a method for loading in a new record. This
    method will need to set up our form with a given row number and data dictionary
    from the controller.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的视图中添加的最后一件事是加载新记录的方法。这个方法需要使用控制器中给定的行号和数据字典设置我们的表单。
- en: 'Let''s call it `load_record()` as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其命名为`load_record()`如下：
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The first thing we should do is set the form''s `current_record` value from
    the `rownum` provided:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该首先从提供的`rownum`设置表单的`current_record`值：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Recall that `rownum` could be `None`, indicating that this is a new record.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`rownum`可能是`None`，表示这是一个新记录。
- en: 'Let''s check for that by executing the following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过执行以下代码来检查：
- en: '[PRE47]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If we're going to be inserting a new record, we simply want to reset the form,
    then set the label to indicate that this is a new record.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要插入新记录，我们只需重置表单，然后将标签设置为指示这是新记录。
- en: Note that our `if` condition here checks specifically whether `rownum` is `None`;
    we can't just check the truth value of `rownum`, since `0` is a valid `rownum`
    for updating!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里的`if`条件专门检查`rownum`是否为`None`；我们不能只检查`rownum`的真值，因为`0`是一个有效的用于更新的`rownum`！
- en: 'If we do have a valid `rownum`, we''ll need it to act differently:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个有效的`rownum`，我们需要让它表现得不同：
- en: '[PRE48]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this block, we first set the label appropriately with the row number we're
    editing.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个块中，我们首先使用正在编辑的行号适当地设置标签。
- en: Then, we cycle through the keys and widgets of our `inputs` dictionary and pull
    in the matching values from the `data` dictionary. We also attempt to call the
    `trigger_focusout_validation()` method on each widget's input, since it's possible
    that the CSV file contains invalid data. If the input has no such method (that
    is, if we used a regular Tkinter widget rather than one of our custom ones, such
    as with `Checkbutton`), we just do nothing.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们循环遍历`inputs`字典的键和小部件，并从`data`字典中提取匹配的值。我们还尝试在每个小部件的输入上调用`trigger_focusout_validation()`方法，因为CSV文件可能包含无效数据。如果输入没有这样的方法（也就是说，如果我们使用的是常规的Tkinter小部件而不是我们的自定义小部件之一，比如`Checkbutton`），我们就什么也不做。
- en: Updating the rest of the application
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新应用程序的其余部分
- en: Before our changes to the form can take effect, we need to update the remaining
    portions of our application for the new functionality. Our main menu needs some
    navigation items so that users can switch between the record list and the form,
    and controller methods need to be created or updated in `Application` to bring
    together our new model and view functionality.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对表单进行更改生效之前，我们需要更新应用程序的其余部分以实现新功能。我们的主菜单需要一些导航项，以便用户可以在记录列表和表单之间切换，并且需要在`Application`中创建或更新控制器方法，以整合我们的新模型和视图功能。
- en: Main menu changes
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主菜单更改
- en: Since we're already in the `views.py` file, let's start by updating our main
    menu view with some commands to switch between the record list and record form.
    We'll add a `Go` menu containing two more options to our menu that will allow
    switching between the record list and a blank record form.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在`views.py`文件中，让我们首先通过一些命令来在我们的主菜单视图中切换记录列表和记录表单。我们将在我们的菜单中添加一个`Go`菜单，其中包含两个选项，允许在记录列表和空白记录表单之间切换。
- en: 'Add the following lines between the `Options` and `Help` menus:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Options`和`Help`菜单之间添加以下行：
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As before, we're binding these menu commands to functions in the `callbacks`
    dictionary, which we'll need to add in our `Application` class.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们将这些菜单命令绑定到`callbacks`字典中的函数，我们需要在`Application`类中添加这些函数。
- en: Connecting the pieces in Application
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中连接各部分
- en: 'Let''s quickly take stock of the following changes we''re going to need to
    make in our `Application` class:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速盘点一下我们需要在`Application`类中进行的以下更改：
- en: We need to add an instance of our `RecordList` view
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要添加一个`RecordList`视图的实例
- en: We'll need to update our use of `CSVModel` so that we can access data from it
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要更新我们对`CSVModel`的使用，以便可以从中访问数据
- en: We'll need to implement or refactor several callback methods used by our views
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要实现或重构视图使用的几个回调方法
- en: Adding the RecordList view
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加`RecordList`视图
- en: 'We''ll create the `RecordList` object in `__init__()`, just after `DataRecordForm`, by
    executing the following code snippet:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`__init__()`中创建`RecordList`对象，就在`DataRecordForm`之后，通过执行以下代码片段：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Notice that when we call `grid()`, we're adding the `RecordList` view to the
    grid cell that already contains `DataRecordForm`. **This is intentional**. When
    we do this, Tkinter just stacks the second widget on top of the first, like laying
    one piece of paper on top of another; we'll add code in a moment to control which
    view is visible by raising one or the other to the top of the stack. Notice that
    we also stick the widget to all sides of the cell. Without this code, bits of
    one widget might be visible behind the other.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们调用`grid()`时，我们将`RecordList`视图添加到已经包含`DataRecordForm`的网格单元中。**这是有意的**。当我们这样做时，Tkinter会将第二个小部件堆叠在第一个小部件上，就像将一张纸放在另一张纸上一样；我们将在稍后添加代码来控制哪个视图可见，通过将其中一个提升到堆栈的顶部。请注意，我们还将小部件粘贴到单元格的所有边缘。如果没有这段代码，一个小部件的一部分可能会在另一个小部件的后面可见。
- en: 'Similarly, we need to update the `grid` call for the record form as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们需要更新记录表单的`grid`调用如下：
- en: '[PRE51]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Moving the model
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动模型
- en: 'Currently, our data model object is only created in the `on_save()` method,
    and is recreated every time the user saves. Some of the other callbacks we''re
    going to write will need access to the model as well, so instead we''ll create
    a single data model instance that can be shared by all the methods when the `Application` class
    is started or whenever a new filename is chosen. Let''s take a look at the following
    steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的数据模型对象仅在`on_save()`方法中创建，并且每次用户保存时都会重新创建。我们将要编写的其他一些回调函数也需要访问模型，因此我们将在`Application`类启动或选择新文件时创建一个可以由所有方法共享的单个数据模型实例。让我们看看以下步骤：
- en: 'First, edit the `Application.__init__()` method right after the `default_filename`
    is created:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在创建`default_filename`后编辑`Application.__init__()`方法：
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Next, the `on_file_select()` method needs to recreate the `data_model` object
    whenever the filename is changed.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，每当文件名更改时，`on_file_select()`方法需要重新创建`data_model`对象。
- en: 'Change the end of `on_file_select()` to the following code:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`on_file_select()`的结尾更改为以下代码：
- en: '[PRE53]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, `self.data_model` will always point to a current data model and all our
    methods can use it for saving or reading data.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`self.data_model`将始终指向当前数据模型，我们的所有方法都可以使用它来保存或读取数据。
- en: Populating the record list
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充记录列表
- en: The `Treeview` widget is added to our application, but we need a way to fill
    it with data.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`Treeview`小部件已添加到我们的应用程序中，但我们需要一种方法来用数据填充它。'
- en: 'We''ll create a method called `populate_recordlist()` by executing the following
    code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过执行以下代码创建一个名为`populate_recordlist()`的方法：
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The logic is simple enough: just get all the rows from the model and send them
    to the record list''s `populate()` method.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑很简单：只需从模型中获取所有行并将它们发送到记录列表的`populate()`方法。
- en: 'We could write it as simply as this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地写成这样：
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Remember, though, that in the event of a problem with the file, `get_all_records()`
    will raise an `Exception`; we need to catch that exception and let the user know
    things are wrong.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 但要记住，如果文件出现问题，`get_all_records()`将引发一个`Exception`；我们需要捕获该异常并让用户知道出了问题。
- en: 'Update the code with the `try` and `except` blocks as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新代码：
- en: '[PRE56]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this case, if we get an exception from `get_all_records()`, we'll display
    an error dialog showing the `Exception` text.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们从`get_all_records()`获得异常，我们将显示一个显示`Exception`文本的错误对话框。
- en: The `RecordList` view should be repopulated any time a new model gets created;
    currently, that happens in `Application.__init__()` and `Application.on_file_select()`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecordList`视图应在创建新模型时重新填充；目前，这在`Application.__init__()`和`Application.on_file_select()`中发生。'
- en: 'Update `__init__()` just after the record list is created:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建记录列表后立即更新`__init__()`：
- en: '[PRE57]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Update `on_file_select()` at the very end, inside the `if filename:` block
    as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if filename:`块的最后，更新`on_file_select()`如下：
- en: '[PRE58]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Adding the new callbacks
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新的回调函数
- en: 'Looking over our view code, the following callback functions need to be added
    to our `callbacks` dictionary:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的视图代码，以下回调函数需要添加到我们的`callbacks`字典中：
- en: '`show_recordlist()`: This function is called when the user clicks the Record
    List option in the menu, it should cause the record list to be visible'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show_recordlist()`：当用户点击菜单中的记录列表选项时调用此函数，它应该导致记录列表可见'
- en: '`new_record()`: This function is called when the user clicks New Record in
    the menu, it should show a reset `DataRecordForm`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new_record()`：当用户点击菜单中的新记录时调用此函数，它应该显示一个重置的`DataRecordForm`'
- en: '`on_open_record()`: This function is called when a record list item is opened,
    it should show `DataRecordForm` which is populated with the ID and data of the
    record'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_open_record()`：当打开记录列表项时调用此函数，它应该显示填充有记录ID和数据的`DataRecordForm`'
- en: '`on_save()`: This function is called when the Save button (now part of `DataRecordForm`)
    is clicked, it should cause the data in the record form to be updated or inserted
    in the model'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_save()`：当点击保存按钮（现在是`DataRecordForm`的一部分）时调用此函数，它应该导致记录表单中的数据被更新或插入模型。'
- en: 'We''ll start with `show_recordlist()`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`show_recordlist()`开始：
- en: '[PRE59]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Remember that when we laid out the main application, we stacked `recordlist`
    on top of the data entry form, so that one obscured the other. The `tkraise()`
    method can be called on any Tkinter widget to raise it to the top of a stack of
    widgets. Calling it here will raise our `RecordList` widget to the top and obscure
    the data entry form.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们布置主应用程序时，我们将`recordlist`叠放在数据输入表单上，以便一个遮挡另一个。`tkraise()`方法可以在任何Tkinter小部件上调用，将其提升到小部件堆栈的顶部。在这里调用它将使我们的`RecordList`小部件升至顶部并遮挡数据输入表单。
- en: 'Don''t forget to add the following content to the `callbacks` dictionary:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将以下内容添加到`callbacks`字典中：
- en: '[PRE60]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Both the `new_record()` and `on_open_record()` callbacks cause `recordform`
    to be displayed; one is called without a row number, and the other is called with
    a row number. We can easily answer both of these in a single method.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`new_record()`和`on_open_record()`回调都会导致`recordform`被显示；一个在没有行号的情况下调用，另一个在有行号的情况下调用。我们可以在一个方法中轻松地回答这两个问题。'
- en: 'Let''s call that method `open_record()`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称这个方法为`open_record()`：
- en: '[PRE61]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Remember that our `DataRecordForm.load_record()` method takes a row number and
    a `data` dictionary, and that if the row number is `None`, it resets the form
    for a new record. So, all we need to do is set the row number and record accordingly
    and pass them into the `load_record()` method.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们的`DataRecordForm.load_record()`方法需要一个行号和一个`data`字典，如果行号是`None`，它会重置表单以进行新记录。所以，我们只需要设置行号和记录，然后将它们传递给`load_record()`方法。
- en: 'First, we''ll handle `rownum` being `None`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将处理`rownum`为`None`的情况：
- en: '[PRE62]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Without a row number, there is no record. Easy enough.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 没有行号，就没有记录。很简单。
- en: 'Now, if there is a row number, we need to attempt to fetch that row from the
    model and use that for `record`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果有行号，我们需要尝试从模型中获取该行并将其用于`record`：
- en: '[PRE63]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note that Tkinter may be passing in `rownum` as a string, since the `iid` values
    of `Treeview` are strings. We'll do a safety cast to `int`, since that's what
    our model expects.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Tkinter可能会将`rownum`作为字符串传递，因为`Treeview`的`iid`值是字符串。我们将进行安全转换为`int`，因为这是我们的模型所期望的。
- en: Remember that in the event of a problem reading the file, the model throws an
    `Exception`, so we should catch this.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果在读取文件时出现问题，模型会抛出`Exception`，所以我们应该捕获这个异常。
- en: 'Place the call to `get_record()` inside a `try` block:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 将`get_record()`的调用放在`try`块中：
- en: '[PRE64]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the event of an `Exception`, we'll display an error dialog and return from
    the function without changing anything.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现`Exception`的情况下，我们将显示一个错误对话框，并在不改变任何内容的情况下从函数中返回。
- en: 'With `rownum` and `record` set correctly, we can now pass them to `DataRecordForm`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 有了正确设置的`rownum`和`record`，现在我们可以将它们传递给`DataRecordForm`：
- en: '[PRE65]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, we need to raise the `form` widget so that it''s on top of the record
    list:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要提升`form`小部件，使其位于记录列表的顶部：
- en: '[PRE66]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, we can update our `callbacks` dictionary to point those keys to the new
    method:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新我们的`callbacks`字典，将这些键指向新的方法：
- en: '[PRE67]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You could argue that we shouldn't have the same method in here twice, and just
    have our views pull the same key; however, it makes sense to let the views refer
    to callbacks semantically—that is, in terms of what they intend to accomplish,
    rather than how it's accomplished—and then letting the controller determine which
    piece of code best meets that semantic need. If, at some point, we need to separate
    these into two methods, we'll only need to do that in `Application`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以说我们不应该在这里有相同的方法，而只是让我们的视图拉取相同的键；然而，让视图在语义上引用回调是有意义的——也就是说，根据它们打算实现的目标，而不是它是如何实现的——然后让控制器确定哪段代码最符合这个语义需求。如果在某个时候，我们需要将这些分成两个方法，我们只需要在`Application`中做这个操作。
- en: 'We already have a method for `on_save()`, so that''s simple enough to add to
    our callbacks:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了一个`on_save()`方法，所以将其添加到我们的回调中就足够简单了：
- en: '[PRE68]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: However, our current `on_save()` method only handles inserting new records.
    We'll need to fix that.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们当前的`on_save()`方法只处理插入新记录。我们需要修复这个问题。
- en: First, we can remove the two lines that fetch the filename and create the model,
    since we can just use the `Application` object's `data_model` property.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以删除获取文件名和创建模型的两行，因为我们可以直接使用`Application`对象的`data_model`属性。
- en: 'Now, replace the next couple of lines with this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用以下内容替换下面的两行：
- en: '[PRE69]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We simply need to get the data and current record from `DataRecordForm`, then
    pass them to the model's `save_record()` method. Remember that if we send `rownum`
    of `None`, the model will insert a new record; otherwise it will update the record
    at that row number.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要从`DataRecordForm`中获取数据和当前记录，然后将它们传递给模型的`save_record()`方法。记住，如果我们发送`None`的`rownum`，模型将插入一个新记录；否则，它将更新该行号的记录。
- en: Because `save_record()` can throw a couple of different exceptions, it's under
    a `try` block here.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`save_record()`可能会抛出几种不同的异常，所以它在这里是在一个`try`块下面。
- en: 'First, if we try to update a row number that doesn''t exist, we''ll get `IndexError`,
    so let''s catch that:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们尝试更新一个不存在的行号，我们会得到`IndexError`，所以让我们捕获它：
- en: '[PRE70]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the event of the problem, we're going to show an error dialog and update
    the status text.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现问题的情况下，我们将显示一个错误对话框并更新状态文本。
- en: The `save_record()` method can also throw a generic `Exception`, since it calls
    the model's `get_all_records()` method.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`save_record()`方法也可能会抛出一个通用的`Exception`，因为它调用了模型的`get_all_records()`方法。'
- en: 'We''ll catch this as well and show an appropriate error:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也会捕获这个异常，并显示一个适当的错误：
- en: '[PRE71]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The remaining code in this method should only be run if no exceptions were
    thrown, so move it under an `else` block:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法中剩下的代码只有在没有抛出异常时才应该运行，所以将它移动到一个`else`块下面：
- en: '[PRE72]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Since inserting or updating records will usually cause a change in the record
    list, we should also repopulate the record list after a successful file save.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于插入或更新记录通常会导致记录列表的更改，所以在成功保存文件后，我们还应该重新填充记录列表。
- en: 'Add the following line under the `if` block:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`块下面添加以下行：
- en: '[PRE73]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Finally, we only want to reset the record form if we're inserting new files;
    if not, we should do nothing.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只想在插入新文件时重置记录表单；如果不是，我们应该什么都不做。
- en: 'Put the call to `recordform.reset()` under an `if` block:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 将对`recordform.reset()`的调用放在一个`if`块下面：
- en: '[PRE74]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Cleaning up
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: Before coming out of `application.py`, make sure to remove the Save button code,
    since we've moved that piece of UI to the `DataRecordForm`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在退出`application.py`之前，确保删除保存按钮的代码，因为我们已经将该UI部分移动到`DataRecordForm`中。
- en: 'Look for these lines in `__init__()` to remove them:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__()`中查找这些行并删除它们：
- en: '[PRE75]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You can also move the `statusbar` position up one row:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将`statusbar`的位置上移一行：
- en: '[PRE76]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Testing our program
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的程序
- en: 'At this point, you should be able to run the application and load in a sample
    CSV file as shown in the following screenshot:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该能够运行应用程序并加载一个示例CSV文件，如下面的截图所示：
- en: '![](assets/3b8b74a3-4a1c-4b7d-b269-4110be95eabf.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3b8b74a3-4a1c-4b7d-b269-4110be95eabf.png)'
- en: Make sure to try opening a record, editing and saving it, as well as inserting
    new records and opening different files.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 确保尝试打开记录，编辑和保存它，以及插入新记录和打开不同的文件。
- en: 'You should also test the following error conditions:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该测试以下错误条件：
- en: Try opening a file that isn't a CSV file, or a CSV with incorrect fields. What
    happens?
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试打开一个不是CSV文件的文件，或者一个带有不正确字段的CSV文件。会发生什么？
- en: Open a valid CSV file, select a record for editing, then, before clicking Save,
    select a different or empty file. What happens?
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个有效的CSV文件，选择一个记录进行编辑，然后在点击保存之前，选择一个不同的或空文件。会发生什么？
- en: Open two copies of the program and point them to the saved CSV file. Try alternating
    edit or update actions between the programs. Note what happens.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开两个程序的副本，并将它们指向保存的CSV文件。尝试在程序之间交替编辑或更新操作。注意发生了什么。
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have changed our program from being an append-only form to an application
    capable of loading, viewing, and updating data from existing files. You learned
    how to make a read-write model, work with the ttk `Treeview`, and modify the existing
    views and controller to read and update records.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将我们的程序从仅追加的形式改变为能够从现有文件加载、查看和更新数据的应用程序。您学会了如何制作读写模型，如何使用ttk `Treeview`，以及如何修改现有的视图和控制器来读取和更新记录。
- en: In our next chapter, we'll be learning how to modify the look and feel of our
    application. We'll learn about using widget attributes, styles, and themes, as
    well as working with bitmapped graphics.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一章中，我们将学习如何修改应用程序的外观和感觉。我们将学习如何使用小部件属性、样式和主题，以及如何使用位图图形。
