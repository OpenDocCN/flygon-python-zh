- en: Date and Time
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期和时间
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下技巧：
- en: Time-zone-aware datetime—retrieving a reliable value for the current datetime
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时区感知的datetime-检索当前datetime的可靠值
- en: Parsing dates—how to parse dates according to the ISO 8601 format
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析日期-如何根据ISO 8601格式解析日期
- en: Saving dates—how to store datetimes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存日期-如何存储datetime
- en: From timestamp to datetime—converting to and from timestamps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从时间戳到datetime-转换为时间戳和从时间戳转换为datetime
- en: Displaying dates in a user format—formatting dates according to our user language
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以用户格式显示日期-根据用户语言格式化日期
- en: Going to tomorrow—how to compute a datetime that refers to tomorrow
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去明天-如何计算指向明天的datetime
- en: Going to next month—how to compute a datetime that refers to next month
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去下个月-如何计算指向下个月的datetime
- en: Weekdays—how to build a date that refers to the *n^(th)* Monday/Friday of the
    month
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作日-如何构建一个指向本月第*n*个星期一/星期五的日期
- en: Workdays—how to get workdays in a time range
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作日-如何在时间范围内获取工作日
- en: Combining dates and times—making a datetime out of a date and time
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合日期和时间-从日期和时间创建一个datetime
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Dates are a part of our lives and we are used to handling times and dates as
    a basic process. Even a small kid knows what time it is or what *tomorrow* means.
    But, try to talk to someone on the other side of the world and suddenly the concepts
    of *tomorrow*, *midnight*, and so on start to become very complex.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 日期是我们生活的一部分，我们习惯于处理时间和日期作为一个基本的过程。即使是一个小孩也知道现在是什么时间或者*明天*是什么意思。但是，试着和世界另一端的人交谈，突然之间*明天*、*午夜*等概念开始变得非常复杂。
- en: When you say tomorrow, are you talking about your tomorrow or mine? If you schedule
    a process that should run at midnight, which midnight is it?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你说明天时，你是在说你的明天还是我的明天？如果你安排一个应该在午夜运行的进程，那么是哪一个午夜？
- en: To make everything harder, we have leap seconds, odd time zones, daylight savings,
    and so on. When you try to approach dates in software, especially in software
    as a service that might be used by people around the world, suddenly it becomes
    clear that dates are a complex affair.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让一切变得更加困难，我们有闰秒，奇怪的时区，夏令时等等。当你尝试在软件中处理日期时，特别是在可能被世界各地的人使用的软件中，突然之间就会明白日期是一个复杂的事务。
- en: This chapter includes some recipes that, while being short, can save you headaches
    and bugs when working with user-provided dates.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括一些短小的技巧，可以在处理用户提供的日期时避免头痛和错误。
- en: Time-zone-aware datetime
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时区感知的datetime
- en: Python datetimes are usually *naive*, which means they don't know which time
    zone they refer to. This can be a major problem because, given a datetime, it's
    impossible to know when it actually refers to.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python datetimes通常是*naive*，这意味着它们不知道它们所指的时区。这可能是一个主要问题，因为给定一个datetime，我们无法知道它实际指的是什么时候。
- en: The most common error in working with dates in Python is trying to get the current
    datetime through `datetime.datetime.now()`, as all `datetime` methods work with
    naive dates, it's impossible to know which time that value represents.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中处理日期最常见的错误是尝试通过`datetime.datetime.now()`获取当前datetime，因为所有`datetime`方法都使用naive日期，所以无法知道该值代表的时间。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps for this recipe:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成这个技巧：
- en: 'The only reliable way to retrieve the current datetime is by using `datetime.datetime.utcnow()`.
    Independently of where the user is and how the system is configured, it will always
    return the UTC time. So we need to make it time-zone-aware to be able to decline
    it to any time zone in the world:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索当前datetime的唯一可靠方法是使用`datetime.datetime.utcnow()`。无论用户在哪里，系统如何配置，它都将始终返回UTC时间。因此，我们需要使其具有时区感知能力，以便能够将其拒绝到世界上的任何时区：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we have a time-zone-aware current time, it is possible to convert it to
    any other time zone, so that we can display to our users the value in their own
    time zone:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了一个具有时区感知能力的当前时间，就可以将其转换为任何其他时区，这样我们就可以向我们的用户显示他们自己时区的值：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, given I''m currently in the UTC+01:00 time zone, I can grab the current
    time-zone-aware time for UTC and then display it in my own time zone:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，假设我目前在UTC+01:00时区，我可以获取UTC的具有时区感知能力的当前时间，然后在我的时区中显示它：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All Python datetimes, by default, come without any time zone specified, but
    by setting `tzinfo`, we can make them aware of the time zone they refer to.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Python datetimes，默认情况下都没有指定任何时区，但通过设置`tzinfo`，我们可以使它们意识到它们所指的时区。
- en: If we just grab our current time (`datetime.datetime.now()`), there is no easy
    way for us to know from within our software which time zone we are grabbing the
    time from. The only time zone we can always rely on is UTC, for that reason. Whenever
    retrieving the current time, it's best always to rely on `datetime.datetime.utcnow()`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是获取当前时间（`datetime.datetime.now()`），我们无法轻松地从软件内部知道我们正在获取时间的时区。因此，我们唯一可以依赖的时区是UTC。每当检索当前时间时，最好始终依赖于`datetime.datetime.utcnow()`。
- en: Once we have a date for UTC, as we know it's actually for the UTC time zone,
    we can easily attach the `datetime.timezone.utc` time zone (the only one that
    Python provides out of the box) and make it time-zone-aware.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了UTC的日期，因为我们知道它实际上是UTC时区的日期，我们可以轻松地附加`datetime.timezone.utc`时区（Python提供的唯一时区）并使其具有时区感知能力。
- en: 'The `now` function does that: it grabs the datetime and makes it time-zone-aware.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`now`函数可以做到这一点：它获取datetime并使其具有时区感知能力。'
- en: As our datetime is now time-zone-aware, from that moment on, we can rely on
    the `datetime.datetime.astimezone` method to convert to any time zone we want.
    So, if we know that our user is on UTC+01:00, we can display the datetime with
    the user's local value instead of showing a UTC value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的datetime现在具有时区感知能力，从那一刻起，我们可以依赖于`datetime.datetime.astimezone`方法将其转换为任何我们想要的时区。因此，如果我们知道我们的用户在UTC+01:00，我们可以显示datetime的用户本地值，而不是显示UTC值。
- en: That's exactly what the `astimezone` function does. Once a datetime and an offset
    from UTC are provided, it returns a date that refers to a local time zone based
    on that offset.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是`astimezone`函数所做的。一旦提供了日期时间和与UTC的偏移量，它将返回一个日期，该日期是基于该偏移量的本地时区。
- en: There's more...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You might have noticed that while this solution works, it lacks more advanced
    features. For example, I'm currently on UTC+01:00, but according to my country's
    Daylight Savings policy, I might be on UTC+02:00\. Also, we only support offsets
    based on an integer hour, and while that's the most common case, there are time
    zones, such as India's or Iran's, that have a half-hour offset.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，虽然这个解决方案有效，但缺乏更高级的功能。例如，我目前在UTC+01:00，但根据我的国家的夏令时政策，我可能在UTC+02:00。此外，我们只支持基于整数小时的偏移量，虽然这是最常见的情况，但有一些时区，如印度或伊朗，有半小时的偏移量。
- en: While we can extend our support for time zones to include these oddities, for
    more advanced cases you should probably rely on the `pytz` package, which ships
    time zones for the full IANA time zone database.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以扩展我们对时区的支持以包括这些奇怪的情况，但对于更复杂的情况，您可能应该依赖于`pytz`软件包，该软件包为完整的IANA时区数据库提供了时区。
- en: Parsing dates
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析日期
- en: When receiving a datetime from another software or from a user, it will probably
    be in a string format. Formats such as JSON don't even define how a date should
    be represented, but it's usually a best practice to provide those in the ISO 8601
    format.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一个软件或用户那里接收日期时间时，它可能是以字符串格式。例如JSON等格式甚至不定义日期应该如何表示，但通常最好的做法是以ISO 8601格式提供这些日期。
- en: The ISO 8601 format is usually defined as `[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss]+-[TZ]`,
    for example `2018-03-19T22:00+0100` would refer to March 19 at 10 P.M. on the
    UTC+01:00 time zone.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ISO 8601格式通常定义为`[YYYY]-[MM]-[DD]T[hh]:[mm]:[ss]+-[TZ]`，例如`2018-03-19T22:00+0100`将指的是UTC+01:00时区的3月19日晚上10点。
- en: ISO 8601 conveys all the information you need to represent a date and time,
    so it's a good way to marshal a datetime and send it across a network.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ISO 8601传达了表示日期和时间所需的所有信息，因此这是一种将日期时间编组并通过网络发送的好方法。
- en: Sadly, it has many oddities (for example, the `+00` time zone can also be written
    as `Z`, or you can omit the `:` between hours, minutes, and seconds), so parsing
    it might sometimes cause trouble.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，它有许多奇怪之处（例如，`+00`时区也可以写为`Z`，或者您可以省略小时、分钟和秒之间的`:`），因此解析它有时可能会引起麻烦。
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to follow:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要遵循的步骤：
- en: 'Due to all the variants ISO 8601 allows, there is no easy way to throw it to
    `datetime.datetime.strptime` and get back a datetime for all case; we must coalesce
    all possible formats to a single one and then parse that one:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于ISO 8601允许所有这些变体，没有简单的方法将其传递给`datetime.datetime.strptime`，并为所有情况返回一个日期时间；我们必须将所有可能的格式合并为一个格式，然后解析该格式：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The previous implementation of `parse_iso8601` copes with most possible ISO
    8601 representations:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`parse_iso8601`的先前实现处理了大多数可能的ISO 8601表示：'
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The basic idea of `parse_iso8601` is that whatever dialect of ISO 8601 is received
    before parsing it, we will transform it into the form of `[YYYY][MM][DD]T[hh][mm][ss]+-[TZ]`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_iso8601`的基本思想是，无论在解析之前收到ISO 8601的方言是什么，我们都将其转换为`[YYYY][MM][DD]T[hh][mm][ss]+-[TZ]`的形式。'
- en: The hardest part is detecting the time zone, as that can be separated by `+`, `-`,
    or can even be `Z`. Once the time zone is extracted, we can just get rid of all
    examples of `-` in the date and all instances of `:` in times.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最难的部分是检测时区，因为它可以由`+`、`-`分隔，甚至可以是`Z`。一旦提取了时区，我们可以摆脱日期中所有`-`的示例和时间中所有`:`的实例。
- en: Note that before extracting the time zone we separated the time from the date,
    as both the date and the time zone might contain the `-` character, and we don't
    want our parser to get confused.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在提取时区之前，我们将时间与日期分开，因为日期和时区都可能包含`-`字符，我们不希望我们的解析器感到困惑。
- en: There's more...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Parsing dates can become very complex. While our `parse_iso8601` will work when
    interacting with most systems that serve a date in string format (such as JSON),
    you will quickly face cases where it falls short due to all the ways a datetime
    can be expressed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 解析日期可能变得非常复杂。虽然我们的`parse_iso8601`在与大多数以字符串格式提供日期的系统（如JSON）交互时可以工作，但您很快就会面临它因日期时间可以表示的所有方式而不足的情况。
- en: For example, we might receive back a value such as `2 weeks ago` or `July 4,
    2013 PST`. Trying to parse all these cases is not very convenient and can get
    complicated pretty quickly. In case you have to handle these special cases, you
    should probably rely on an external package such as `dateparser`, `dateutil`,
    or `moment`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能会收到一个值，例如`2周前`或`2013年7月4日PST`。尝试解析所有这些情况并不是很方便，而且可能很快变得复杂。如果您必须处理这些特殊情况，您可能应该依赖于外部软件包，如`dateparser`、`dateutil`或`moment`。
- en: Saving dates
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存日期
- en: Sooner or later, we all have to save a date somewhere, sending it to a database
    or saving it into a file. Maybe we will be converting it into JSON to send it
    to another software.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 迟早，我们都必须在某个地方保存一个日期，将其发送到数据库或将其保存到文件中。也许我们将其转换为JSON以将其发送到另一个软件。
- en: Many database systems do not track time zones. Some of them have a configuration
    option that states what time zone they should work with, but in most cases, the
    date you provide will be saved as is.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据库系统不跟踪时区。其中一些具有配置选项，指定它们应该使用的时区，但在大多数情况下，您提供的日期将按原样保存。
- en: This leads to unexpected bugs or behaviors in many cases. Suppose you were a
    good boy scout and properly did all the work required to receive a datetime preserving
    its time zone. Now you have a datetime of `2018-01-15 15:30:00 UTC+01:00` and,
    once you store it in your database, `UTC+01:00` will easily be lost, even if you
    store it in a file yourself, storing and restoring the time zone is usually a
    bothersome work.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致许多情况下出现意外的错误或行为。假设您是一个好童子军，并且正确地完成了接收保留其时区的日期时间所需的所有工作。现在您有一个`2018-01-15
    15:30:00 UTC+01:00`的日期时间，一旦将其存储在数据库中，`UTC+01:00`将很容易丢失，即使您自己将其存储在文件中，存储和恢复时区通常是一项麻烦的工作。
- en: For this reason, you should always ensure you convert your datetimes to UTC
    before storing them somewhere, that will always guarantee that, independently
    from which time zone the datetime came from, it will always represent the right
    time when you load it back.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您应该始终确保在将日期时间存储在某个地方之前将其转换为UTC，这将始终保证，无论日期时间来自哪个时区，当您将其加载回来时，它将始终表示正确的时间。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The steps for this recipe are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱的步骤如下：
- en: 'To save a datetime, we want a function that ensures that datetime always refers
    to UTC before actually storing it:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存日期时间，我们希望有一个函数，确保日期时间在实际存储之前始终指的是UTC：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `asutc` function can be used with any datetime to ensure it''s moved to
    UTC before actually storing it:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`asutc`函数可用于任何日期时间，以确保在实际存储之前将其移至UTC：'
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The functioning of this recipe is pretty straightforward, through the `datetime.datetime.astimezone`
    method, the date is always converted to its UTC representation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱的功能非常简单，通过`datetime.datetime.astimezone`方法，日期始终转换为其UTC表示。
- en: This ensures it will work for both where your storage keeps track of time zones
    (as the date will still be time-zone-aware, but the time zone will be UTC) and
    when your storage doesn't preserve time zones (as a UTC date without a time zone
    still represents the same UTC date as if the delta was zero).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保它将适用于存储跟踪时区的地方（因为日期仍将是时区感知的，但时区将是UTC），以及当存储不保留时区时（因为没有时区的UTC日期仍然表示与零增量相同的UTC日期）。
- en: From timestamps to datetimes
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从时间戳到日期时间
- en: Timestamps are the representation of a date in the number of seconds from a
    specific moment. Usually, as the value that a computer can represent is limited
    in size, that is normally taken from January 1st, 1970.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳是从特定时刻开始的秒数的表示。通常，由于计算机可以表示的值在大小上是有限的，通常从1970年1月1日开始。
- en: If you ever received a value such as `1521588268` as a datetime representation,
    you might be wondering how that can be converted into an actual datetime.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您收到一个值，例如`1521588268`作为日期时间表示，您可能想知道如何将其转换为实际的日期时间。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Most recent Python versions introduced a method to quickly convert datetimes
    back and forth from timestamps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的Python版本引入了一种快速将日期时间与时间戳相互转换的方法：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There's more...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As pointed out in the recipe introduction, there is a limit to how big a number
    can be for a computer. For that reason, it's important to note that while `datetime.datetime`
    can represent practically any date, a timestamp can't.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如食谱介绍中指出的，计算机可以表示的数字有一个限制。因此，重要的是要注意，虽然`datetime.datetime`可以表示几乎任何日期，但时间戳却不能。
- en: 'For example, trying to represent a datetime from `1300` will succeed but it
    will fail to convert it to a timestamp:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尝试表示来自`1300`的日期时间将成功，但将无法将其转换为时间戳：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A timestamp is only able to represent dates starting from January 1st, 1970.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳只能表示从1970年1月1日开始的日期。
- en: 'The same is true also in the reverse direction for faraway dates, while `253402214400`
    represents the timestamp for December 31, 9999, trying to create a datetime from
    a date later than that value will fail:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于遥远的日期，反向方向也是如此，而`253402214400`表示9999年12月31日的时间戳，尝试从该值之后的日期创建日期时间将失败：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A datetime is only able to represent dates from the year 1 to 9999.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 日期时间只能表示从公元1年到9999年的日期。
- en: Displaying dates in user format
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以用户格式显示日期
- en: When displaying dates from software, it's easy to confuse users if they don't
    know the format you are going to rely on.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中显示日期时，如果用户不知道您将依赖的格式，很容易使用户感到困惑。
- en: We already know that time zones play an important role and that when displaying
    a time we always want to show it as time-zone-aware, but even dates can have their
    ambiguities. If you write 3/4/2018, will it be April 3^(rd) or March 4^(th)?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道时区起着重要作用，并且在显示时间时我们总是希望将其显示为时区感知，但是日期也可能存在歧义。如果您写3/4/2018，它是4月3日还是3月4日？
- en: 'For this reason, you usually have two choices:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常有两种选择：
- en: Go for the international format (2018-04-03)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用国际格式（2018-04-03）
- en: Localize the date (April 3, 2018)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地化日期（2018年4月3日）
- en: When possible, it's obviously better to be able to localize the date format,
    so that our users will see a value that they can easily recognize.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的话，最好能够本地化日期格式，这样我们的用户将看到一个他们可以轻松识别的值。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'This recipe requires the following steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱需要以下步骤：
- en: 'The `locale` module in the Python standard library provides a way to get formatting
    for the localization supported by your system. By using it, we can format dates
    in any way allowed by the target system:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python标准库中的`locale`模块提供了一种获取系统支持的本地化格式的方法。通过使用它，我们可以以目标系统允许的任何方式格式化日期：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Calling `format_date` will properly give the output as a string representation
    of the date in the expected `locale` module:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`format_date`将正确地给出预期`locale`模块中日期的字符串表示：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `format_date` function is divided into two major parts.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`format_date`函数分为两个主要部分。'
- en: The first is provided by the `switchlocale` context manager, which is in charge
    of enabling the requested `locale` (locales are process-wide), giving back control
    to the wrapped block of code and then restoring the original `locale`. This way,
    we can use the requested `locale` only within the context manager and not influence
    any other part of our software.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个由`switchlocale`上下文管理器提供，它负责启用请求的`locale`（locale是整个进程范围的），并在包装的代码块中返回控制，然后恢复原始`locale`。这样，我们可以仅在上下文管理器中使用请求的`locale`，而不影响软件的任何其他部分。
- en: The second is what happens within the context manager itself. Using `locale.nl_langinfo`,
    the date-and-time format string (`locale.D_T_FMT`) is requested to the currently
    enabled `locale`. That gives back a string that tells us how to format a datetime
    in the currently active `locale`. The returned string will be something like `'%a
    %e %b %X %Y'`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是上下文管理器内部发生的事情。使用`locale.nl_langinfo`，请求当前启用的`locale`的日期时间格式字符串（`locale.D_T_FMT`）。这会返回一个字符串，告诉我们如何在当前活动的`locale`中格式化日期时间。返回的字符串将类似于`'%a
    %e %b %X %Y'`。
- en: Then the date itself is formatted according to the retrieved format string through
    `datetime.strftime`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后日期本身根据通过`datetime.strftime`检索到的格式字符串进行格式化。
- en: Note that the returned string will usually contain the `%a` and `%b` formatters,
    which represent the *current weekday* and *current month* names. As the name of
    a weekday or month changes for each language, the Python interpreter will emit
    the name of the weekday or month in the currently enabled `locale`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，返回的字符串通常会包含`%a`和`%b`格式化符号，它们代表*当前星期*和*当前月份*的名称。由于星期几或月份的名称对每种语言都是不同的，Python解释器将以当前启用的`locale`发出星期几或月份的名称。
- en: So, we not only formatted the date the way the user expected, but the resulting
    output will also be in the user's language.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不仅按照用户的期望格式化了日期，而且结果输出也将是用户的语言。
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While this solution seems very convenient, it's important to note that it relies
    on switching `locale` on the fly.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个解决方案看起来非常方便，但重要的是要注意它依赖于动态切换`locale`。
- en: Switching `locale` is a very expensive operation, so if you have a lot of values
    to format (such as a `for` loop or thousand of dates), it might be far too slow.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 切换`locale`是一个非常昂贵的操作，所以如果你有很多值需要格式化（比如`for`循环或成千上万的日期），这可能会太慢。
- en: Also switching `locale` is not thread-safe, so you won't be able to apply this
    recipe in multithreaded software, unless all the switching of `locale` happens
    before other threads are started.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，切换`locale`也不是线程安全的，所以除非所有的`locale`切换发生在其他线程启动之前，否则你将无法在多线程软件中应用这个食谱。
- en: If you want to handle localization in a robust and thread-safe way, you might
    want to check the babel package. Babel has support for the localization of dates
    and numbers, and it works in a way that doesn't require setting a global state,
    thus behaving properly even in threaded environments.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想以一种健壮且线程安全的方式处理本地化，你可能想要检查babel包。Babel支持日期和数字的本地化，并且以一种不需要设置全局状态的方式工作，因此即使在多线程环境中也能正确运行。
- en: Going to tomorrow
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前往明天
- en: When you have a date, it's common to need to apply math to that date. For example
    maybe you want to move to tomorrow or to yesterday.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个日期时，通常需要对该日期进行数学运算。例如，也许你想要移动到明天或昨天。
- en: Datetimes support math operations, such as adding or subtracting to them, but
    when time is involved, it's not easy to get the exact number of seconds you need
    to add or subtract to move to the next or previous day.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 日期时间支持数学运算，比如对它们进行加减，但涉及时间时，很难得到你需要添加或减去的确切秒数，以便移动到下一天或前一天。
- en: For this reason, this recipe will show off an easy way to move to the next or
    previous day from any given date.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个食谱将展示一种从任意给定日期轻松移动到下一个或上一个日期的方法。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, here are the steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，以下是步骤：
- en: 'The `shiftdate` function will allow us to move to a date by any number of days:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`shiftdate`函数将允许我们按任意天数移动到一个日期：'
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using it is as simple as just providing the days you want to add or remove:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用它就像简单地提供你想要添加或移除的天数一样简单：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can use it to go to tomorrow:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用它去到明天：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Or to go to yesterday:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者前往昨天：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Or even to go into the next month:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 甚至前往下个月：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Usually what we want when moving datetime is to go to the beginning of a day.
    Suppose you want to find all events that happen tomorrow out of a list of events,
    you really want to search for `day_after_tomorrow > event_time >= tomorrow` as
    you want to find all events that happened from tomorrow at midnight up to the
    day after tomorrow at midnight.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在移动日期时间时，我们想要去到一天的开始。假设你想要在事件列表中找到明天发生的所有事件，你真的想要搜索`day_after_tomorrow > event_time
    >= tomorrow`，因为你想要找到从明天午夜开始到后天午夜结束的所有事件。
- en: So, simply changing the day itself won't work, because our datetime also has
    a time associated with it. If we just add a day to the date, we will actually
    end up being somewhere in the range of hours that are included in tomorrow.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，简单地改变日期本身是行不通的，因为我们的日期时间也与时间相关联。如果我们只是在日期上加一天，实际上我们会在明天包含的小时范围内结束。
- en: That's the reason why the `shiftdate` function always replaces the time of the
    provided date with midnight.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么`shiftdate`函数总是用午夜替换提供的日期时间的原因。
- en: Once the date has been moved to midnight, we just add to it a `timedelta` equal
    to the number of specified days. If this number is negative, we will just move
    back in time as `D + -1 == D -1`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦日期被移动到午夜，我们只需添加一个等于指定天数的`timedelta`。如果这个数字是负数，我们将会向后移动时间，因为`D + -1 == D -1`。
- en: Going to next month
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前往下个月
- en: Another frequent need when moving dates is to be able to move the date to the
    next or previous month.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动日期时，另一个经常需要的需求是能够将日期移动到下个月或上个月。
- en: If you read the *Going to tomorrow* recipe, you will see many similarities with
    this recipe even though there are some additional changes that are required when
    working with months that are not needed when working with days, as months have
    a variable duration.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读了*前往明天*的食谱，你会发现与这个食谱有很多相似之处，尽管在处理月份时需要一些额外的变化，而在处理天数时是不需要的，因为月份的持续时间是可变的。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps for this recipe:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个食谱执行以下步骤：
- en: 'The `shiftmonth` function will allow us to move our date back and forth by
    any number of months:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`shiftmonth`函数将允许我们按任意月数前后移动我们的日期：'
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using it is as simple as just providing the months you want to add or remove:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用它就像简单地提供你想要添加或移除的月份一样简单：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can use it to go to the next month:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用它去到下个月：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Or back to the previous month:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者回到上个月：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Or even to move by any number of months:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 甚至可以按月份移动：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you tried to compare this recipe with the *Going to tomorrow* one, you would
    notice that this one got far more complex even though its purpose is very similar.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试将此配方与*前往明天*进行比较，您会注意到，尽管其目的非常相似，但这个配方要复杂得多。
- en: Just as when moving across days we are interested in moving at a specific point
    in time during the day (usually the beginning), when moving months, we don't want
    to end up being in a random day and time in the new month.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在移动天数时，我们有兴趣在一天中的特定时间点移动一样（通常是开始时），当移动月份时，我们不希望最终处于新月份的随机日期和时间。
- en: 'That explains the last part of our recipe, where for any datetime resulting
    from our math expression, we reset the time to midnight of the first day of the
    month:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了我们配方的最后一部分，对于我们数学表达式产生的任何日期时间，我们将时间重置为该月的第一天的午夜：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Like for the days recipe, this allows us to check for conditions, such as `two_month_from_now
    > event_date >= next_month`, as we will catch all events from midnight of the
    first day up to 23:59 of the last day.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对于天数配方一样，这使我们能够检查条件，例如`two_month_from_now > event_date >= next_month`，因为我们将捕捉从该月的第一天午夜到上个月的最后一天23:59的所有事件。
- en: The part you might be wondering about is the `for` loop.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道的部分是`for`循环。
- en: Differently from when we have to move by days (which all have an equal duration
    of 24 hours), when moving by months, we need to account for the fact that each
    of them will have a different duration.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们必须按天数移动（所有天数的持续时间相等为24小时）不同，当按月份移动时，我们需要考虑到每个月的持续时间不同的事实。
- en: This is why, when moving forward, we set the current date to be the 5^(th) of
    the month and then we add 28 days. Adding 28 days by itself wouldn't suffice as
    it would only work for February, and if you are wondering, adding 31 days won't
    work either, because in the case of February, you would be moving by two months
    instead of just one.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在向前移动时，我们将当前日期设置为月份的第5天，然后添加28天。仅仅添加28天是不够的，因为它只适用于2月，如果您在想，添加31天也不起作用，因为在2月的情况下，您将移动两个月而不是一个月。
- en: That is why we set the current date to be the 5^(th) of the month because we
    want to pick a day from which we know for sure that adding 28 days to it will
    move us into the next month.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们将当前日期设置为月份的第5天，因为我们想要选择一个日期，我们确切地知道向其添加28天将使我们进入下一个月。
- en: So, for example, picking the 1^(st) of the month would work, because March 1^(st)
    + 28 days = March 29^(th), so we would still be in March. While March 5^(th) +
    28 days = April 2^(nd), April 5^(th) + 28 days = May 3^(rd), and Feb 5^(th) +
    28 days = March 5^(th). So for any given month, we are always moving into the
    the next one when adding 28 days to the 5^(th).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，选择月份的第一天将有效，因为3月1日+28天=3月29日，所以我们仍然在3月。而3月5日+28天=4月2日，4月5日+28天=5月3日，2月5日+28天=3月5日。因此，对于任何给定的月份，我们在将5日加28天时总是进入下一个月。
- en: The fact that we always move on to a different day won't really matter as that
    day will always be replaced with the 1^(st) of the month.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是移动到不同的日期并不重要，因为该日期总是会被替换为该月的第一天。
- en: As there isn't any fixed amount of days we can move that ensure we always move
    exactly into the next month, we can't move just by adding `days * months`, so
    we have to do this in a `for` loop and continuously move into the next month a
    `months` number of times.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法移动确保我们总是准确地移动到下一个月的固定天数，所以我们不能仅通过添加`天数*月份`来移动，因此我们必须在`for`循环中执行此操作，并连续移动`月份`次数。
- en: When moving back, things get far easier. As all months begin with the first
    of the month, we can just move there and then subtract one day. We will always
    end up being on the last day of the previous month.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当向后移动时，事情变得容易得多。由于所有月份都从月份的第一天开始，我们只需移动到那里，然后减去一天。我们总是会在上个月的最后一天。
- en: Weekdays
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作日
- en: Building a date for the 20^(th) of the month or for the 3^(rd) week of the month
    is pretty straightforward, but what if you have to build the date for the 3^(rd)
    Monday of the month?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为月份的第20天或第3周构建日期非常简单，但如果您必须为月份的第3个星期一构建日期呢？
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Go through these steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'To approach this problem, we are going to actually generate all the month days
    that match the requested weekday:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将实际生成所有与请求的工作日匹配的月份日期：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, once we have a list of those, grabbing the *n^(th)* day is just a matter
    of indexing the resulting list. For example, to grab the Mondays from March:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，一旦我们有了这些列表，抓取*第n个*日期只是简单地索引结果列表。例如，要抓取3月的星期一：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'So grabbing the 3^(rd) Monday of March would be:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以抓取三月的第三个星期一将是：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: At the beginning of the recipe, we create a date for the first day of the requested
    month. Then we just move forward one day at a time until the month finishes and
    we set aside all days that match the requested weekday.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方的开始，我们为所请求的月份的第一天创建一个日期。然后我们每次向前移动一天，直到月份结束，并将所有与请求的工作日匹配的日期放在一边。
- en: The weekdays go from one for Monday to seven for Sunday.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 星期从星期一到星期日分别为1到7。
- en: Once we have all the Mondays, Fridays, or whatever days of the month, we can
    just index the resulting list to grab only the ones we are actually interested
    in.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了所有星期一、星期五或者月份的其他日期，我们只需索引结果列表，抓取我们真正感兴趣的日期。
- en: Workdays
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作日
- en: In many management applications, you only have to consider workdays, and Saturdays
    and Sundays won't matter. You are not working during those days, so from a work
    point of view, they don't exist.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多管理应用程序中，您只需要考虑工作日，星期六和星期日并不重要。在这些日子里，您不工作，所以从工作的角度来看，它们不存在。
- en: So when computing days included in a given timespan for a project management
    or work-related application, you can ignore those days.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在计算项目管理或与工作相关的应用程序的给定时间跨度内包含的日期时，您可以忽略这些日期。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We want to grab the list of days between two dates as far as they are working
    days:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要获取两个日期之间的工作日列表：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For example, if it''s March 22^(nd), 2018, which is a Thursday, and I want
    to know the working days up to the next Monday (which is March 26^(th)), I can
    easily ask for `workdays`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果是2018年3月22日，这是一个星期四，我想知道工作日直到下一个星期一（即3月26日），我可以轻松地要求`workdays`：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So we know that two days are left: Thursday itself and Friday.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们知道还剩下两天：星期四本身和星期五。
- en: In case you are in a part of the world where you work on Sunday and maybe don't
    on Fridays, the `excluded` argument can be used to signal which days should be
    excluded from working days.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在世界的某个地方工作日是星期日，可能不是星期五，`excluded`参数可以用来指示哪些日期应该从工作日中排除。
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The recipe is pretty straightforward, we just start from the provided date (`d`),
    add one day at a time and loop until we reach `end`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法非常简单，我们只是从提供的日期（`d`）开始，每次加一天，直到达到`end`。
- en: We consider the provided arguments to be datetimes, thus we loop comparing only
    the date, as we don't want to randomly include and exclude the last day depending
    on times provided in `d` and `end`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为提供的参数是日期时间，因此我们循环比较只有日期，因为我们不希望根据`d`和`end`中提供的时间随机包括和排除最后一天。
- en: This allows `datetime.datetime.utcnow()` to provide us with the first argument
    without having to care about when the function was called. Only the dates themselves
    will be compared, without their times.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许`datetime.datetime.utcnow()`为我们提供第一个参数，而不必关心函数何时被调用。只有日期本身将被比较，而不包括它们的时间。
- en: Combining dates and times
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合日期和时间
- en: Sometimes you will have separated dates and times. This is particularly frequent
    when they are entered by a user. From an interaction point of view, it's usually
    easier to pick a date and then pick a time than to pick a date and a time together.
    Or you might be combining inputs from two different sources.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您会有分开的日期和时间。当它们由用户输入时，这种情况特别频繁。从交互的角度来看，通常更容易选择一个日期然后选择一个时间，而不是一起选择日期和时间。或者您可能正在组合来自两个不同来源的输入。
- en: In all those cases, you will end up with a date and a time that you want to
    combine in a single `datetime.datetime` instance.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，您最终会得到一个日期和时间，您希望将它们组合成一个单独的`datetime.datetime`实例。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The Python standard library provides support for such operations out of the
    box, so having any two of those:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库提供了对这些操作的支持，因此拥有其中的任何两个：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can easily combine them into a single entity:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地将它们组合成一个单一的实体：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There's more...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If your `time` instance has a time zone (`tzinfo`), combining the date with
    the time will also preserve it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的`time`实例有一个时区（`tzinfo`），将日期与时间组合也会保留它：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If your time doesn''t have a time zone, you can still specify one when combining
    the two values:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的时间没有时区，您仍然可以在组合这两个值时指定一个时区：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Providing a time zone when combining is only supported for Python 3.6+. If you
    are working with a previous Python version, you will have to set the time zone
    into the time value.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在组合时提供时区仅支持Python 3.6+。如果您使用之前的Python版本，您将不得不将时区设置为时间值。
