- en: System Programming Packages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统编程包
- en: Throughout this chapter, we will look at the main modules we can find in Python
    for working with the Python interpreter, the operating system, and executing commands.
    We will review how to work with the file system, reading, and creating files.
    Also, we'll review threads-management and other modules for multithreading and
    concurrency. We'll end this chapter with a review about the `socket.io` module
    for implementing asynchronous servers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Python中的主要模块，用于与Python解释器、操作系统和执行命令。我们将回顾如何使用文件系统，读取和创建文件。此外，我们将回顾线程管理和其他用于多线程和并发的模块。我们将以对`socket.io`模块实现异步服务器的回顾结束本章。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing system modules in Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Python中的系统模块
- en: Working with the filesystem
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文件系统
- en: Threads in Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的线程
- en: Multithreading and concurrency in Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的多线程和并发
- en: Python `Socket.io`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python `Socket.io`
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Examples and source code for this chapter are available in the GitHub repository
    in the `chapter 2` folder: [https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security.](https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security.)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例和源代码可在GitHub存储库的`chapter 2`文件夹中找到：[https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security.](https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security.)
- en: You will need some basic knowledge about command-execution in operating systems,
    and to install the Python distribution on your local machine.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一些关于操作系统中的命令执行的基本知识，并在本地计算机上安装Python发行版。
- en: Introducing system modules in python
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Python中的系统模块
- en: Throughout this section, we'll explain the main modules you can find in Python
    for working with the Python interpreter, the operating system, and executing commands
    with the sub-procces module.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释Python中用于与Python解释器、操作系统以及使用子进程模块执行命令的主要模块。
- en: The system module
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统模块
- en: The `sys` module will allow us to interact with the interpreter and it contains
    most of the information related to the execution in progress, updated by the interpreter,
    as well as a series of functions and low-level objects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys`模块将允许我们与解释器进行交互，并且它包含了与正在进行的执行相关的大部分信息，由解释器更新，以及一系列函数和低级对象。'
- en: '`**sys.argv**` contains the list of parameters for executing a script. The
    first item in the list is the name of the script followed by the list of parameters.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`**sys.argv**`包含执行脚本的参数列表。列表中的第一项是脚本的名称，后面是参数列表。'
- en: We may, for example, want to parse command-line arguments at runtime. The sys.argv
    list contains all the command-line arguments. The first sys.argv[0] index contains
    the name of the Python interpreter script. The remaining items in argv array contain
    the next command-line arguments. Thus, if we are passing three additional arguments,
    sys.argv should contain four items.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能希望在运行时解析命令行参数。sys.argv列表包含所有命令行参数。sys.argv[0]索引包含Python解释器脚本的名称。argv数组中的其余项目包含下一个命令行参数。因此，如果我们传递了三个额外的参数，sys.argv应该包含四个项目。
- en: 'You can find the following code in the `**sys_arguments.py**` file in :'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`**sys_arguments.py**`文件中找到以下代码：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The previous script can be executed with some parameters, such as the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本可以使用一些参数执行，例如以下内容：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we execute the previous script with three parameters, we can see the following
    result:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用三个参数执行前面的脚本，我们可以看到以下结果：
- en: '![](assets/65980509-35c9-4adc-abe0-556185adc047.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/65980509-35c9-4adc-abe0-556185adc047.png)'
- en: 'In this example, we obtain many system variables:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们获得了许多系统变量：
- en: '![](assets/75dd2dae-c18d-4937-a697-07d4de09d0b8.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/75dd2dae-c18d-4937-a697-07d4de09d0b8.png)'
- en: 'These are the main attributes and methods to recover that information:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是恢复该信息的主要属性和方法：
- en: '**sys.platform**: Returns the current operating system'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sys.platform**：返回当前操作系统'
- en: '**sys.stdin,sys,stdout,sys.stderr**: File objects that point respectively to
    the standard input, standard output, and standard error output'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sys.stdin,sys,stdout,sys.stderr**：分别指向标准输入、标准输出和标准错误输出的文件对象'
- en: '**sys.version**: Returns the interpreter version'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sys.version**：返回解释器版本'
- en: '**sys.getfilesystemencoding()**: Returns the encoding used by the filesystem'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sys.getfilesystemencoding()**：返回文件系统使用的编码'
- en: '**sys.getdefaultencoding()**: Returns the default encoding'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sys.getdefaultencoding()**：返回默认编码'
- en: '**sys.path**: Returns a list of all the directories in which the interpreter
    searches for the modules when the import directive is used or when the names of
    the files are used without their full path'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sys.path**：返回解释器在导入指令使用或在不使用完整路径的文件名时搜索模块的所有目录列表'
- en: You can find more information on the Python online module documents at [http://docs.python.org/library/sys](http://docs.python.org/library/sys).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Python在线模块文档中找到更多信息：[http://docs.python.org/library/sys](http://docs.python.org/library/sys)。
- en: The operating system module
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统模块
- en: The operating system(os) module is the best mechanism to access the different
    functions in our operating system. The use of this module will depend on the operating
    system that is used. If we use this module, we will have to adapt the script if
    we go from one operating system to another.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统(os)模块是访问操作系统中不同函数的最佳机制。使用此模块将取决于所使用的操作系统。如果使用此模块，我们将不得不根据从一个操作系统切换到另一个操作系统来调整脚本。
- en: This module allows us to interact with the OS environment, filesystem, and permissions.
    In this example, we check whether the name of a text file passed as a command-line
    argument exists as a file in the current execution path and the current user has
    read permissions to that file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块允许我们与操作系统环境、文件系统和权限进行交互。在此示例中，我们检查作为命令行参数传递的文本文件的名称是否存在于当前执行路径中，并且当前用户是否具有对该文件的读取权限。
- en: 'You can find the following code in the `check_filename.py` file in `os` module
    subfolder:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`os`模块子文件夹中的`check_filename.py`文件中找到以下代码：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Contents of the current working directory
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当前工作目录的内容
- en: In this example, the `os` module is used to list the contents of the current
    working directory with the `os.getcwd()` method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`os`模块用于使用`os.getcwd()`方法列出当前工作目录的内容。
- en: 'You can find the following code in the `show_content_directory.py` file in the `os`
    module subfolder:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`os`模块子文件夹中的`show_content_directory.py`文件中找到以下代码：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These are the main steps for the previous code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上述代码的主要步骤：
- en: Import the `os` module.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`os`模块。
- en: Use the `os` module, call the  `**os.getcwd()**` method to retrieve the current
    working directory path, and store that value on the pwd variable.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`os`模块，调用`**os.getcwd()**`方法检索当前工作目录路径，并将该值存储在pwd变量中。
- en: Obtain the the list of directories from the current directory path. Use the
    `**os.listdir()**` method to obtain the file names and directories in the current
    working directory.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前目录路径的目录列表。使用`**os.listdir()**`方法获取当前工作目录中的文件名和目录。
- en: Iterate over the list directory to get the files and directories.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历列表目录以获取文件和目录。
- en: 'The following are the main methods for recovering information from the operating
    system module:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从操作系统模块中恢复信息的主要方法：
- en: '**os.system()**: Allows us to execute a shell command'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**os.system()**：允许我们执行shell命令'
- en: '**os.listdir(path)**: Returns a list with the contents of the directory passed
    as an argument'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**os.listdir(path)**：返回作为参数传递的目录的内容列表'
- en: '**os.walk(path)**: Navigates all the directories in the provided path directory,
    and returns three values: the path directory, the names for the sub directories,
    and a list of filenames in the current directory path.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**os.walk(path)**：导航提供的路径目录中的所有目录，并返回三个值：路径目录，子目录的名称以及当前目录路径中的文件名的列表。'
- en: In this example, we check the files and directories inside the current path.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们检查当前路径内的文件和目录。
- en: 'You can find the following code in the** `check_files_directory.py`** file
    in `os` module subfolder:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`os`模块子文件夹中的**`check_files_directory.py`**文件中找到以下代码：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Determining the operating system
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定操作系统
- en: The next script determines whether the code is running on Windows OS or the
    Linux platform. The `**platform.system()**` method informs us of the running operating
    system. Depending on the return value, we can see the ping command is different
    in Windows and Linux. Windows OS uses ping –n 1 to send one packet of the ICMP
    ECHO request, whereas Linux or another OS uses ping –c 1.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个脚本确定代码是否在Windows OS或Linux平台上运行。`**platform.system()**`方法告诉我们正在运行的操作系统。根据返回值，我们可以看到在Windows和Linux中ping命令是不同的。Windows
    OS使用ping -n 1发送一个ICMP ECHO请求的数据包，而Linux或其他操作系统使用ping -c 1。
- en: 'You can find the following code in the** `operating_system.py`** file in `os`
    module subfolder:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`os`模块子文件夹中的**`operating_system.py`**文件中找到以下代码：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Subprocess module
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子进程模块
- en: The standard subprocess module allows you to invoke processes from Python and
    communicate with them, send data to the input (stdin), and receive the output
    information (stdout). Using this module is the recommended way to execute operating
    system commands or launch programs (instead of the traditional `os.system ()`)
    and optionally interact with them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的子进程模块允许您从Python调用进程并与它们通信，将数据发送到输入(stdin)，并接收输出信息(stdout)。使用此模块是执行操作系统命令或启动程序（而不是传统的`os.system()`）并可选择与它们交互的推荐方法。
- en: 'Running a child process with your subprocess is simple. Here, the **Popen**
    constructor **starts the process**. You can also pipe data from your Python program
    into a subprocess and retrieve its output. With the **help(subprocess)** command,
    we can see that information:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用子进程运行子进程很简单。在这里，**Popen**构造函数**启动进程**。您还可以将数据从Python程序传输到子进程并检索其输出。使用**help(subprocess)**命令，我们可以看到相关信息：
- en: '![](assets/5cb9d517-d7b9-4466-80cc-23aadaf26abc.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5cb9d517-d7b9-4466-80cc-23aadaf26abc.png)'
- en: The simplest way to execute a command or invoke a process is via the `call()`
    function (from Python 2.4 to 3.4) or `run()` (for Python 3.5+). For example, the
    following code executes a command that list files in the current path.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令或调用进程的最简单方法是通过`call()`函数（从Python 2.4到3.4）或`run()`（对于Python 3.5+）。例如，以下代码执行列出当前路径中文件的命令。
- en: 'You can find this code in the** `SystemCalls.py`** file in subprocess subfolder:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`subprocess`子文件夹中的**`SystemCalls.py`**文件中找到此代码：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To be able to use the terminal commands (such as clear or cls to clean the
    console, cd to move in the directory tree, and so on), it is necessary to indicate
    shell = True parameter:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用终端命令（例如清除或cls清理控制台，cd移动到目录树中等），需要指定shell = True参数：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, it asks the user to write their name and then print a greeting
    on the screen. Via a subprocess we can invoke it with Popen method, enter a name
    programmatically, and get the greeting as a Python string.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，它要求用户写下他们的名字，然后在屏幕上打印一个问候语。通过子进程，我们可以使用Popen方法调用它，以编程方式输入一个名字，并将问候语作为Python字符串获取。
- en: 'The `Popen ()` instances incorporate the `terminate ()` and `kill ()` methods
    to terminate or kill a process, respectively. Distributions of Linux distinguish
    between the SIGTERM and SIGKILL signals:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Popen()`实例包括`terminate()`和`kill()`方法，分别用于终止或杀死进程。Linux的发行版区分SIGTERM和SIGKILL信号：'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The Popen function it gives more flexibilty if we compare with the call function
    since it executes the command as a child program in a new process. For example,
    on Unix systems, the class uses `os.execvp()`. and on Windows, it uses the Windows
    `CreateProcess()` function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与调用函数相比，Popen函数提供了更多的灵活性，因为它在新进程中执行命令作为子程序。例如，在Unix系统上，该类使用`os.execvp()`。在Windows上，它使用Windows
    `CreateProcess()`函数。
- en: You can get more information about the Popen constructor and methods that provide
    Popen class in the official documentation: [https://docs.python.org/2/library/subprocess.html#popen-constructor](https://docs.python.org/3.5/library/subprocess.html#popen-constructor).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中找到有关Popen构造函数和Popen类提供的方法的更多信息：[https://docs.python.org/2/library/subprocess.html#popen-constructor](https://docs.python.org/3.5/library/subprocess.html#popen-constructor)。
- en: In this example, we are using the `subprocess` module to call the `ping` command
    and obtain the output of this command to evaluate whether a specific IP address
    responds with `ECHO_REPLY`. Also, we use the `sys` module to check the operating
    system where we are executing the script.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`subprocess`模块调用`ping`命令，并获取该命令的输出，以评估特定IP地址是否响应`ECHO_REPLY`。此外，我们使用`sys`模块来检查我们执行脚本的操作系统。
- en: 'You can find the following code in the** `PingScanNetWork.py`** file in subprocess
    subfolder:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`PingScanNetWork.py`文件的subprocess子文件夹中找到以下代码：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To execute this script, we need to pass the network we are analyzing and the
    machine number we want to check as parameters:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此脚本，我们需要将我们正在分析的网络和我们想要检查的机器编号作为参数传递：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the result of scanning the 129.168.56 network and one machine:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是扫描129.168.56网络和一个机器的结果：
- en: '![](assets/6b324c6f-76c0-4706-88dc-bd48a61849d2.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6b324c6f-76c0-4706-88dc-bd48a61849d2.png)'
- en: Working with the filesystem in Python
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中处理文件系统
- en: Throughout this section, we explain the main modules you can find in Python
    for working with the filesystem, accessing files and directories, reading and
    creating files, and operations with and without the context manager.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们解释了Python中用于处理文件系统、访问文件和目录、读取和创建文件以及使用和不使用上下文管理器的主要模块。
- en: Accessing files and directories
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问文件和目录
- en: In this section, we review how we can work with the filesystem and perform tasks
    such as browsing directories or reading each file individually.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾如何处理文件系统并执行诸如浏览目录或逐个读取每个文件的任务。
- en: Recursing through directories
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归浏览目录
- en: 'In some cases, it is necessary to iterate recursively through the main directory
    to discover new directories. In this example, we see how we can browse a directory
    recursively and retrieve the names of all files within that directory:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，需要递归迭代主目录以发现新目录。在这个例子中，我们看到如何递归浏览目录并检索该目录中所有文件的名称：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Checking whether a specific path is a file or directory
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查特定路径是否为文件或目录
- en: 'We can check whether a certain string is a file or directory. For this, we
    can use the `os.path.isfile()` method, which returns `True` if it is a file and
    `False` if it is a directory:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查某个字符串是否为文件或目录。为此，我们可以使用`os.path.isfile()`方法，如果是文件则返回`True`，如果是目录则返回`False`：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Checking whether a file or directory exists
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查文件或目录是否存在
- en: 'If you want to check whether a file exists in the current working path directory,
    you can use the `os.path.exists()` function, passing the file or directory you
    want to check as the parameter:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要检查当前工作路径目录中是否存在文件，可以使用`os.path.exists()`函数，将要检查的文件或目录作为参数传递：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Creating directories in Python
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中创建目录
- en: 'You can create your own directory using the `os.makedirs()` function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`os.makedirs()`函数创建自己的目录：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code checks whether the my_dir directory exists; if it does not exist,
    it will call  `os.makedirs` **('**`my_dir`**')** to create the directory.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码检查`my_dir`目录是否存在；如果不存在，它将调用`os.makedirs` **('**`my_dir`**')**来创建该目录。
- en: If you create the directory after verifying that the directory does not exist,
    before your call to `os.makedirs` ('`my_dir`') is executed, you may generate an
    error or an exception.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在验证目录不存在后创建目录，在执行对`os.makedirs`('`my_dir`')的调用之前，可能会生成错误或异常。
- en: 'If you want to be extra careful and catch any potential exceptions, you can
    wrap your call to os.makedirs(''`my_dir`'') in a **try...except** block:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要更加小心并捕获任何潜在的异常，您可以将对`os.makedirs('`my_dir`')`的调用包装在**try...except**块中：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Reading and writing files in Python
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中读写文件
- en: Now we are going to review the methods for reading and writing files.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将回顾读取和写入文件的方法。
- en: File methods
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件方法
- en: These are the functions that can be used on a file object.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是可以在文件对象上使用的函数。
- en: '**file.write(string)**: Prints a string to a file, there is no return.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**file.write(string)**：将字符串打印到文件，没有返回。'
- en: '**file.read([bufsize])**: Reads up to “bufsize” number of bytes from the file.
    If run without the buffer size option, reads the entire file.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**file.read([bufsize])**：从文件中读取最多“bufsize”字节数。如果没有缓冲区大小选项运行，则读取整个文件。'
- en: '**file.readline([bufsize])**: Reads one line from the file (keeps the newline).'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**file.readline([bufsize])**：从文件中读取一行（保留换行符）。'
- en: '**file.close()**: Closes the file and destroys the file object. Python will
    do this automatically, but it’s still good practice when you’re done with a file.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**file.close()**：关闭文件并销毁文件对象。Python会自动执行这个操作，但当您完成一个文件时，这仍然是一个好习惯。'
- en: Opening a file
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开文件
- en: 'The classic way of working with files is to use the `open()` method. This method
    allows you to open a file, returning an object of the file type:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文件的经典方法是使用`open()`方法。这种方法允许您打开一个文件，返回一个文件类型的对象：
- en: '**open(name[, mode[, buffering]])**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**open(name[, mode[, buffering]])**'
- en: 'The opening modes of the file can be r(read), w(write), and a(append). We can
    add to these the b (binary), t (text), and + (open reading and writing) modes.
    For example, you can add a "+" to your option, which allows read/write to be done
    with the same object:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的打开模式可以是r（读取）、w（写入）和a（追加）。我们可以在这些模式中添加b（二进制）、t（文本）和+（打开读写）模式。例如，您可以在选项中添加“+”，这允许使用同一个对象进行读/写：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To read a file, we have several possibilities:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取文件，我们有几种可能性：
- en: 'The `readlines()` method that reads all the lines of the file and joins them
    in a sequence. This method is very useful if you want to read the entire file
    at once: ` >>> allLines = file.readlines()`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readlines()`方法读取文件的所有行并将它们连接成一个序列。如果您想一次读取整个文件，这个方法非常有用：` >>> allLines = file.readlines()`。'
- en: 'If we want to read the file line by line, we can use the `readline()` method.
    In this way, we can use the file object as an iterator if we want to read all
    the lines of a file one by one:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想逐行读取文件，我们可以使用`readline()`方法。这样，如果我们想逐行读取文件的所有行，我们可以将文件对象用作迭代器：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With a Context Manager
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文管理器
- en: There are multiple ways to create files in Python, but the cleanest way to do
    this is by using the **with** keyword, in this case we are using the **Context
    Manager Approach**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中创建文件的多种方法，但最干净的方法是使用**with**关键字，这种情况下我们使用**上下文管理器方法**。
- en: Initially, Python provided the open statement to open files. When we are using
    the open statement, Python delegates into the developer the responsibility to
    close the file when it's no longer need to use it. This practice lead to errors
    since developers sometimes forgot to close it. Since Python 2.5, developers can
    use the with statement to handle this situation safely. The **with statement**
    automatically closes the file even if an exception is raised.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Python提供了open语句来打开文件。当我们使用open语句时，Python将开发者的责任委托给开发者，当不再需要使用文件时关闭文件。这种做法会导致错误，因为开发者有时会忘记关闭文件。自Python
    2.5以来，开发者可以使用with语句安全地处理这种情况。**with语句**会自动关闭文件，即使发生异常也是如此。
- en: 'The with command allows many operations on a file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: with命令允许对文件进行多种操作：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this way, we have the advantage: the file is closed automatically and we
    don’t need to call the `close()` method.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就有了优势：文件会自动关闭，我们不需要调用`close()`方法。
- en: You can find the below code in the filename `**create_file.py**`
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在文件名为`**create_file.py**`的文件中找到下面的代码
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous script uses the context manager to open a file and returns this
    as a file object. Within this block,  we then call file.write ("this is a test
    file"), which writes it to our created file. In this case, the with statement
    then handles closing the file for us and we don’t have to worry about it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的脚本使用上下文管理器打开一个文件，并将其作为文件对象返回。在这个块中，我们调用file.write("this is a test file")，将其写入我们创建的文件。在这种情况下，with语句会自动处理文件的关闭，我们不需要担心它。
- en: For more information about the with statement, you can check out the official
    documentation at [https://docs.python.org/2/reference/compound_stmts.html#the-with-statement](https://docs.python.org/2/reference/compound_stmts.html#the-with-statement).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有关with语句的更多信息，您可以查看官方文档[https://docs.python.org/2/reference/compound_stmts.html#the-with-statement](https://docs.python.org/2/reference/compound_stmts.html#the-with-statement)。
- en: Reading a file line by line
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐行读取文件
- en: 'We can iterate over a file in a line-by-line way:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以逐行迭代文件：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we join all these functionalities with exception-management
    when we are working with files.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当我们处理文件时，我们将所有这些功能与异常管理结合起来。
- en: 'You can find the following code in the** `create_file_exceptions.py`** file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在**`create_file_exceptions.py`**文件中找到以下代码：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Threads in Python
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的线程
- en: In this section, we are going to introduce the concept of threads and how we
    can manage them with `Python` modules.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍线程的概念以及如何使用`Python`模块管理它们。
- en: Introduction to Threads
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程介绍
- en: Threads are streams that can be scheduled by the operating system and can be
    executed across a single core in a concurrent way or in parallel way across multiple
    cores. Threads can interact with shared resources, such as memory, and they can
    also modify things simultaneously or even in parallel.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是可以由操作系统调度并在单个核心上以并发方式或在多个核心上以并行方式执行的流。线程可以与共享资源（如内存）交互，并且它们也可以同时或甚至并行地修改事物。
- en: Types of threads
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程类型
- en: 'There are two distinct types of threads:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同类型的线程：
- en: '**Kernel-level threads**: Low-level threads, the user can not interact with
    them directly.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核级线程**：低级线程，用户无法直接与它们交互。'
- en: '**User-level threads**: High-level threads, we can interact with them in our
    code.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户级线程**：高级线程，我们可以在我们的代码中与它们交互。'
- en: Processes vs Threads
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程与线程
- en: 'Processes are full programs.They have their own PID (process ID) and PEB (Process
    Environment Block).These are the main features of processes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是完整的程序。它们有自己的PID（进程ID）和PEB（进程环境块）。这些是进程的主要特点：
- en: Processes can contain multiple threads.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程可以包含多个线程。
- en: If a process terminates, the associated threads do as well.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个进程终止，相关的线程也会终止。
- en: 'Threads are a concept similar to processes: they are also code in execution.
    However, the threads are executed within a process, and the threads of the process
    share resources among themselves, such as memory. These are the main features
    of threads:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是一个类似于进程的概念：它们也是正在执行的代码。然而，线程是在一个进程内执行的，并且进程的线程之间共享资源，比如内存。这些是线程的主要特点：
- en: Threads can only be associated with one Process.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程只能与一个进程关联。
- en: Processes can continue after threads terminate (as long as there is at least
    one thread left).
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程可以在线程终止后继续（只要还有至少一个线程）。
- en: Creating a simple Thread
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的线程
- en: A thread is the mechanism for a program to perform a task several times in parallel.
    Therefore, in a script, we can launch the same task on a single processor a certain
    number of times.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是程序在并行执行任务的机制。因此，在脚本中，我们可以在单个处理器上多次启动相同的任务。
- en: 'For working with threads in Python, we have two options:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中处理线程有两种选择：
- en: The thread module provides primitive operations to write multithreaded programs.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程模块提供了编写多线程程序的原始操作。
- en: The threading module provides a more convenient interface.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程模块提供了更方便的接口。
- en: 'The `thread` module will allow us to work with multiple threads:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread`模块将允许我们使用多个线程：'
- en: In this example, we create four threads, and each one prints a different message
    on the screen that is passed as a parameter in the `thread_message (message)`
    method.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了四个线程，每个线程在屏幕上打印不同的消息，这些消息作为参数传递给`thread_message(message)`方法。
- en: 'You can find the following code in the** `threads_init.py`** file in threads
    subfolder:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在threads子文件夹中的**`threads_init.py`**文件中找到以下代码：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can see more information about the `start_new_thread()` method if we invoke
    the help(thread) command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用help(thread)命令，可以查看更多关于`start_new_thread()`方法的信息：
- en: '![](assets/9fa9be64-d35f-47de-a4fb-d15a493af04b.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9fa9be64-d35f-47de-a4fb-d15a493af04b.png)'
- en: Threading module
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程模块
- en: In addition to the `thread` module, we have another approach to using the `threading`
    module. The threading module relies on the `thread` module to provide us a higher
    level, more complete, and object-oriented API. The threading module is based slightly
    on the Java threads model.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`thread`模块，我们还有另一种使用`threading`模块的方法。线程模块依赖于`thread`模块为我们提供更高级、更完整和面向对象的API。线程模块在某种程度上基于Java线程模型。
- en: The threading module contains a Thread class that we must extend to create our
    own threads of execution. The run method will contain the code that we want the
    thread to execute. If we want to specify our own constructor, it must call threading.
    `Thread .__ init __ (self)` to initialize the object correctly.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 线程模块包含一个Thread类，我们必须扩展它以创建自己的执行线程。run方法将包含我们希望线程执行的代码。如果我们想要指定自己的构造函数，它必须调用threading.`Thread
    .__ init __ (self)`来正确初始化对象。
- en: 'Before creating a new thread in Python, we review the Python Thread class init
    method constructor and see what parameters we need to pass in:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中创建新线程之前，我们要检查Python Thread类的init方法构造函数，并查看需要传递的参数：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The Thread class constructor accepts five arguments as parameters:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Thread类构造函数接受五个参数作为参数：
- en: '**group**: A special parameter that is reserved for future extensions.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**group**：保留给未来扩展的特殊参数。'
- en: '**target**: The callable object to be invoked by the run method().'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**target**：要由run方法()调用的可调用对象。'
- en: '**name**: Our thread''s name.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**name**：我们线程的名称。'
- en: '**args**: Argument tuple for target invocation.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**args**：用于目标调用的参数元组。'
- en: '**kwargs**: Dictionary keyword argument to invoke the base class constructor.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kwargs**：调用基类构造函数的字典关键字参数。'
- en: 'We can get more information about the `init()` method if we invoke the **help(threading)**
    command in a Python interpreter console:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Python解释器控制台中调用**help(threading)**命令，可以获取有关`init()`方法的更多信息：
- en: '![](assets/f0c2a3d8-c36e-4ec1-9e17-1c6c8ab60a9d.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f0c2a3d8-c36e-4ec1-9e17-1c6c8ab60a9d.png)'
- en: 'Let’s create a simple script that we’ll then use to create our first thread:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的脚本，然后用它来创建我们的第一个线程：
- en: 'You can find the following code in the** `threading_init.py`** file in threads
    subfolder:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在threads子文件夹中的**`threading_init.py`**文件中，您可以找到以下代码：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In order for the thread to start executing its code, it is enough to create
    an instance of the class that we just defined and call its start method. The code
    of the main thread and that of the one that we have just created will be executed
    concurrently.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使线程开始执行其代码，只需创建我们刚刚定义的类的实例并调用其start方法即可。主线程的代码和我们刚刚创建的线程的代码将同时执行。
- en: We have to instantiate a Thread object and invoke the `start()` method. Run
    is our logic that we wish to *run* in parallel inside each of our threads, so
    we can use the `run()` method to launch a new thread. This method will contain
    the code that we want to execute in parallel.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须实例化一个Thread对象并调用`start()`方法。Run是我们希望在每个线程内并行运行的逻辑，因此我们可以使用`run()`方法启动一个新线程。此方法将包含我们希望并行执行的代码。
- en: In this script, we are creating four threads.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，我们正在创建四个线程。
- en: 'You can find the following code in the** `threading_example.py`** file in threads
    subfolder:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在threads子文件夹中的**`threading_example.py`**文件中，您可以找到以下代码：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can also use the `thread.join()` method to wait until the thread terminates.
    The join method is used so that the thread that executes the call is blocked until
    the thread on which it is called ends. In this case, it is used so that the main
    thread does not finish its execution before the children, which could result in
    some platforms in the termination of the children before finishing its execution.
    The join method can take a floating point number as a parameter, indicating the
    maximum number of seconds to wait.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`thread.join()`方法等待线程终止。join方法用于使执行调用的线程在被调用的线程结束之前被阻塞。在这种情况下，它用于使主线程在子线程之前不结束其执行，否则可能导致某些平台在子线程结束执行之前终止子线程。join方法可以接受浮点数作为参数，表示等待的最大秒数。
- en: 'You can find the following code in the** `threading_join.py`** file in threads
    subfolder:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在threads子文件夹中的**`threading_join.py`**文件中，您可以找到以下代码：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Multithreading and concurrency in Python
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的多线程和并发
- en: In this section, we are going to introduce the concepts of multithreading and
    concurrency and how we can manage them with python modules.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍多线程和并发的概念，以及如何使用Python模块来管理它们。
- en: Introduction to Multithreading
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程简介
- en: The idea behind multithreading applications is that they allow us to have copies
    of our code and execute them on additional threads. This allows a program to execute
    multiple operations simultaneously. In addition, when a process is blocked, for
    example to wait for input/output operations, the operating system can allocate
    computation time to other processes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程应用程序的理念是允许我们在额外的线程上有代码的副本并执行它们。这允许程序同时执行多个操作。此外，当一个进程被阻塞时，例如等待输入/输出操作，操作系统可以将计算时间分配给其他进程。
- en: When we mention multiprocess processors, we're referring to a processor that
    can execute multiple threads simultaneously. These typically have two or more
    threads that actively compete for execution time within a kernel and when one
    thread is stopped, the processing kernel starts executing another thread.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提到多处理器时，我们指的是可以同时执行多个线程的处理器。这些处理器通常有两个或更多个线程，在内核中积极竞争执行时间，当一个线程停止时，处理内核开始执行另一个线程。
- en: The context changes between these subprocesses very quickly and gives the impression
    that the computer is running the processes in parallel, which gives us the ability
    to multitask.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些子进程之间的上下文变化非常快，给人一种计算机在并行运行进程的印象，这使我们能够进行多任务处理。
- en: Multithreading in Python
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的多线程
- en: 'Python has an API that allow us to write applications with multiple threads. To
    get started with multithreading, we are going to create a new thread inside a
    `python` class and call it** `ThreadWorker.py`.** This class extends from `threading.Thread`
    and contains the code to manage one thread:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个API，允许我们使用多个线程编写应用程序。为了开始多线程，我们将在`python`类内部创建一个新线程，并将其命名为**`ThreadWorker.py`**。这个类继承自`threading.Thread`，并包含管理一个线程的代码：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that we have our thread worker class, we can start to work on our main
    class. Create a new python file, call it `main.py`, and put the following code
    in:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的线程工作类，我们可以开始在我们的主类上工作了。创建一个新的python文件，命名为`main.py`，并放入以下代码：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Documentation about the threading module is available at [https://docs.python.org/3/library/threading.html](https://docs.python.org/3/library/threading.html).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有关线程模块的文档可在[https://docs.python.org/3/library/threading.html](https://docs.python.org/3/library/threading.html)找到。
- en: Limitations with classic python threads
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典Python线程的限制
- en: One of the main problems with the classic implementation of Python threads is
    that their execution is not completely asynchronous. It's known that the execution
    of python threads is not completely parallel and adding multiple threads often
    multiplies the execution times. Therefore, performing these tasks reduces the
    time of execution.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Python经典线程的一个主要问题是它们的执行并不完全是异步的。众所周知，Python线程的执行并不完全是并行的，**添加多个线程**通常会使执行时间加倍。因此，执行这些任务会减少执行时间。
- en: The execution of the threads in Python is controlled by the GIL (Global Interpreter
    Lock) so that only one thread can be executed at the same time, independently
    of the number of processors with which the machine counts.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Python中线程的执行受GIL（全局解释器锁）控制，因此一次只能执行一个线程，无论机器有多少个处理器。
- en: This makes it possible to write C extensions for Python much more easily, but
    it has the disadvantage of limiting performance a lot, so in spite of everything,
    in Python, sometimes we may be more interested in using processes than threads,
    which do not suffer from this limitation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以更容易地为Python编写C扩展，但它的缺点是会大大限制性能，因此尽管如此，在Python中，有时我们可能更有兴趣使用进程而不是线程，后者不会受到这种限制的影响。
- en: By default, the thread change is performed every 10 bytecode instructions, although
    it can be modified using the sys.setcheckinterval function. It also changes the
    thread when the thread is put to sleep with time.sleep or when an input/output
    operation begins, which can take a long time to finish, and therefore, if the
    change is not made, we would have the CPU long time without executing code,waiting
    for the I/O operation to finish.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，线程更改是在每10个字节码指令执行时进行的，尽管可以使用sys.setcheckinterval函数进行修改。它还在线程使用time.sleep休眠或开始输入/输出操作时进行更改，这可能需要很长时间才能完成，因此，如果不进行更改，CPU将长时间没有执行代码，等待I/O操作完成。
- en: To minimize the effect of GIL on the performance of our application, it is convenient
    to call the interpreter with the -O flag, which will generate an optimized bytecode
    with fewer instructions, and, therefore, less context changes. We can also consider
    using processes instead of threads, as we discussed, such as the `ProcessPoolExecutors`
    module.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化GIL对我们应用程序性能的影响，最好使用-O标志调用解释器，这将生成一个优化的字节码，指令更少，因此上下文更改更少。我们还可以考虑使用进程而不是线程，正如我们讨论的那样，比如`ProcessPoolExecutors`模块。
- en: More about the **GIL** can be found at [https://wiki.python.org/moin/GlobalInterpreterLock](https://wiki.python.org/moin/GlobalInterpreterLock).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有关**GIL**的更多信息，请参阅[https://wiki.python.org/moin/GlobalInterpreterLock](https://wiki.python.org/moin/GlobalInterpreterLock)。
- en: Concurrency in python with ThreadPoolExecutor
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ThreadPoolExecutor在Python中进行并发
- en: In this section, we review the **ThreadPoolExecutor** class that provides an
    interface to execute tasks asynchronously.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们回顾了提供执行任务异步的接口的**ThreadPoolExecutor**类。
- en: Creating ThreadPoolExecutor
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ThreadPoolExecutor
- en: 'We can define our **ThreadPoolExecutor** object with the init constructor:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用init构造函数定义我们的**ThreadPoolExecutor**对象：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can create our ThreadPoolExecutor if we pass to the constructor the maximum
    number of workers as the parameter. In this example, we have defined five as the
    maximum number of threads, which means that this group of subprocesses will only
    have five threads working simultaneously.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将最大工作线程数作为参数传递给构造函数，我们就可以创建ThreadPoolExecutor。在这个例子中，我们已经将最大线程数定义为五，这意味着这组子进程只会同时有五个线程在工作。
- en: 'In order to use our `ThreadPoolExecutor`, we can call the `submit()` method,
    which takes a function for executing that code in an asynchronous way as a parameter:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们的`ThreadPoolExecutor`，我们可以调用`submit()`方法，该方法以一个函数作为参数，以异步方式执行该代码：
- en: '`executor.submit(myFunction())`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`executor.submit(myFunction())`'
- en: ThreadPoolExecutor in practice
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ThreadPoolExecutor实践
- en: In this example, we analyze the creation of an object of the `ThreadPoolExecutor`
    class. We define a `view_thread()` function that allows us to display the current
    thread identifier with the `threading.get_ident()` method.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们分析了`ThreadPoolExecutor`类的对象的创建。我们定义了一个`view_thread()`函数，允许我们使用`threading.get_ident()`方法显示当前线程标识符。
- en: We define our main function where the executor object is initialized as an instance
    of the ThreadPoolExecutor class and over this object we execute a new set of threads.
    Then we obtain the thread has been executed with the `threading.current_thread()`
    method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了我们的主函数，其中executor对象被初始化为ThreadPoolExecutor类的一个实例，并在这个对象上执行一组新的线程。然后我们使用`threading.current_thread()`方法获得已执行的线程。
- en: 'You can find the following code in the `**threadPoolConcurrency.py**` file
    in concurrency subfolder:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在concurrency子文件夹中的**threadPoolConcurrency.py**文件中找到以下代码：
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We see that the three different values in the script output are three different
    thread identifiers, and we obtain three distinct daemon threads:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到脚本输出中的三个不同值是三个不同的线程标识符，我们获得了三个不同的守护线程：
- en: '![](assets/459803de-3951-439d-8852-1c26a2480765.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/459803de-3951-439d-8852-1c26a2480765.png)'
- en: Executing ThreadPoolExecutor with Context Manager
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用上下文管理器执行ThreadPoolExecutor
- en: 'Another way to instantiate ThreadPoolExecutor to use it as a context manager
    with the `with` statement:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实例化ThreadPoolExecutor的方法是使用`with`语句作为上下文管理器：
- en: '`with ThreadPoolExecutor(max_workers=2) as executor:`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`with ThreadPoolExecutor(max_workers=2) as executor:`'
- en: In this example, within our main function, we use our ThreadPoolExecutor as
    a context manager and then call `future = executor.submit(message, (message))`
    twice to process each message in the threadpool.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，在我们的主函数中，我们将ThreadPoolExecutor作为上下文管理器使用，然后两次调用`future = executor.submit(message,
    (message))`来在线程池中处理每条消息。
- en: 'You can find the following code in the `threadPoolConcurrency2.py` file in concurrency
    subfolder:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在concurrency子文件夹的`threadPoolConcurrency2.py`文件中找到以下代码：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Python Socket.io
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python Socket.io
- en: In this section, we review how we can use the socket.io module to create a webserver
    based in Python.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾如何使用socket.io模块来创建基于Python的Web服务器。
- en: Introducing WebSockets
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍WebSockets
- en: WebSockets is a technology that offers realtime communication between a client
    and server through a TCP connection, and eliminates the need for customers to
    be continually checking whether API endpoints have updates or new content. Clients
    create a single connection to a WebSocket server and remain pending to listen
    for new events or messages from the server.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets是一种技术，通过TCP连接在客户端和服务器之间提供实时通信，并消除了客户端不断检查API端点是否有更新或新内容的需要。客户端创建到WebSocket服务器的单个连接，并保持等待以监听来自服务器的新事件或消息。
- en: The main advantage of websockets is that they are more efficient as they reduce
    the network load and send information to a large number of clients in the form
    of messages.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Websockets的主要优势在于它们更有效，因为它们减少了网络负载，并以消息的形式向大量客户端发送信息。
- en: aiohttp and asyncio
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: aiohttp和asyncio
- en: aiohttp is a library to build server and client applications built in asyncio.
    The library uses the advantages of websockets natively to communicate different
    parts of the application asynchronously.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: aiohttp是一个在asyncio中构建服务器和客户端应用程序的库。该库原生使用websockets的优势来异步通信应用程序的不同部分。
- en: The documentation is available at [http://aiohttp.readthedocs.io/en/stable](http://aiohttp.readthedocs.io/en/stable/).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可以在[http://aiohttp.readthedocs.io/en/stable](http://aiohttp.readthedocs.io/en/stable/)找到。
- en: asyncio is a python module that helps to do concurrent programming of a single
    thread in python. Already in python 3.6, the documentation is available at [https://docs.python.org/3/library/asyncio.html](https://docs.python.org/3/library/asyncio.html).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: asyncio是一个帮助在Python中进行并发编程的模块。在Python 3.6中，文档可以在[https://docs.python.org/3/library/asyncio.html](https://docs.python.org/3/library/asyncio.html)找到。
- en: Implementing a Server with socket.io
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用socket.io实现服务器
- en: The Socket.IO server is available in the official python repository and can
    be installed via pip: `pip install python-socketio.`
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.IO服务器可以在官方Python存储库中找到，并且可以通过pip安装：`pip install python-socketio.`
- en: The full documentation is available at [https://python-socketio.readthedocs.io/en/latest/](https://python-socketio.readthedocs.io/en/latest/).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的文档可以在[https://python-socketio.readthedocs.io/en/latest/](https://python-socketio.readthedocs.io/en/latest/)找到。
- en: 'The following is an example that works in python 3.5 where we implement a Socket.IO
    server using the aiohttp framework for asyncio:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个在Python 3.5中工作的示例，我们在其中使用aiohttp框架实现了一个Socket.IO服务器：
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the previous code, we implemented a server based on socket.io that uses the
    aiohttp module. As you can see in the code, we define two methods, the `index
    ()` method, which will return a response message upon receiving a request on the
    "/" root endpoint, and a `print_message ()` method that contains the `@socketio.on`
    (' message ') annotation. This annotation causes the function to listen for message-type
    events, and when these events occur, it will act on those events.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们实现了一个基于socket.io的服务器，该服务器使用了aiohttp模块。正如你在代码中看到的，我们定义了两种方法，`index()`方法，它将在“/”根端点接收到请求时返回一个响应消息，以及一个`print_message()`方法，其中包含`@socketio.on('message')`注释。这个注释使函数监听消息类型的事件，当这些事件发生时，它将对这些事件进行操作。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the main system modules for python programming,
    such as os for working with the operating system, sys for working with the filesystem,
    and sub-proccess for  executing commands. We also reviewed how to work with the
    filesystem, reading and creating files, managing threads, and concurrency.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Python编程的主要系统模块，如用于操作系统的os模块，用于文件系统的sys模块，以及用于执行命令的sub-proccess模块。我们还回顾了如何处理文件系统，读取和创建文件，管理线程和并发。
- en: In the next [chapter](bd1e16c1-2ce3-4edc-b61d-9845d978c2bd.xhtml), we will explore
    the socket package for resolving IP addresses and domains, and implement client
    and servers with TCP and UDP protocols.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨用于解析IP地址和域的socket包，并使用TCP和UDP协议实现客户端和服务器。
- en: Questions
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the main module that allows us to interact with the python interpreter?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许我们与Python解释器交互的主要模块是什么？
- en: What is the main module that allows us to interact with the OS environment,
    filesystem, and permissions?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许我们与操作系统环境、文件系统和权限交互的主要模块是什么？
- en: What are the module and the method used to list the contents of the current
    working directory?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于列出当前工作目录内容的模块和方法是什么？
- en: What is the module to execute a command or invoke a process via the call() function?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行命令或通过call()函数调用进程的模块是什么？
- en: What is the approach that we can follow in python to handle files and manage
    exceptions in an easy and secure way?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python中处理文件和管理异常的简单和安全方法是什么？
- en: What is the difference between processes and threads?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程和线程之间的区别是什么？
- en: What are the main modules in python for creating and managing threads?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python中用于创建和管理线程的主要模块是什么？
- en: What is the limitation that python has when working with threads?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python在处理线程时存在的限制是什么？
- en: Which class provides a high-level interface for executing input/output tasks
    in an asynchronous way?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个类提供了一个高级接口，用于以异步方式执行输入/输出任务？
- en: What is the function in the threading module that determines which thread has
    performed?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线程模块中的哪个函数确定了哪个线程执行了？
- en: Further reading
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'In these links, you will find more information about the mentioned tools and
    the official python documentation for some of the modules we discussed:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些链接中，您将找到有关提到的工具的更多信息，以及我们讨论的一些模块的官方Python文档：
- en: '[https://docs.python.org/3/tutorial/inputoutput.html](https://docs.python.org/3/tutorial/inputoutput.html)'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/tutorial/inputoutput.html](https://docs.python.org/3/tutorial/inputoutput.html)'
- en: '[https://docs.python.org/3/library/threading.html](https://docs.python.org/3/library/threading.html)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/threading.html](https://docs.python.org/3/library/threading.html)'
- en: '[https://wiki.python.org/moin/GlobalInterpreterLock](https://wiki.python.org/moin/GlobalInterpreterLock)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://wiki.python.org/moin/GlobalInterpreterLock](https://wiki.python.org/moin/GlobalInterpreterLock)'
- en: '[https://docs.python.org/3/library/concurrent.futures.html](https://docs.python.org/3/library/concurrent.futures.html)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/concurrent.futures.html](https://docs.python.org/3/library/concurrent.futures.html)'
- en: Readers interested in web server programming with technologies such aiohttp
    and asyncio should look to frameworks such as Flask ([http://flask.pocoo.org](http://flask.pocoo.org))
    and Django ([https://www.djangoproject.com](https://www.djangoproject.com)).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对使用aiohttp和asyncio等技术进行Web服务器编程感兴趣的读者，应该查看诸如Flask（[http://flask.pocoo.org](http://flask.pocoo.org)）和Django（[https://www.djangoproject.com](https://www.djangoproject.com)）等框架。
