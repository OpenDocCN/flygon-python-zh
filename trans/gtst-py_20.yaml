- en: Python Object-Oriented Shortcuts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python面向对象的快捷方式
- en: 'There are many aspects of Python that appear more reminiscent of structural
    or functional programming than object-oriented programming. Although object-oriented
    programming has been the most visible paradigm of the past two decades, the old
    models have seen a recent resurgence. As with Python''s data structures, most
    of these tools are syntactic sugar over an underlying object-oriented implementation;
    we can think of them as a further abstraction layer built on top of the (already
    abstracted) object-oriented paradigm. In this chapter, we''ll be covering a grab
    bag of Python features that are not strictly object-oriented:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python的许多方面看起来更像结构化或函数式编程，而不是面向对象编程。尽管面向对象编程在过去的二十年中是最可见的范式，但旧模型最近又出现了。与Python的数据结构一样，这些工具大多是在基础面向对象实现之上的一层语法糖；我们可以将它们看作是建立在（已经抽象化的）面向对象范式之上的进一步抽象层。在本章中，我们将涵盖一些不严格面向对象的Python特性：
- en: Built-in functions that take care of common tasks in one call
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置函数可以一次性处理常见任务
- en: File I/O and context managers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件I/O和上下文管理器
- en: An alternative to method overloading
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法重载的替代方法
- en: Functions as objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为对象
- en: Python built-in functions
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python内置函数
- en: There are numerous functions in Python that perform a task or calculate a result
    on certain types of objects without being methods on the underlying class. They
    usually abstract common calculations that apply to multiple types of classes.
    This is duck typing at its best; these functions accept objects that have certain
    attributes or methods, and are able to perform generic operations using those
    methods. We've used many of the built-in functions already, but let's quickly
    go through the important ones and pick up a few neat tricks along the way.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有许多函数可以在某些类型的对象上执行任务或计算结果，而不是作为基础类的方法。它们通常抽象出适用于多种类型的类的常见计算。这是鸭子类型的最佳体现；这些函数接受具有某些属性或方法的对象，并能够使用这些方法执行通用操作。我们已经使用了许多内置函数，但让我们快速浏览一下重要的函数，并学习一些巧妙的技巧。
- en: The len() function
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: len()函数
- en: 'The simplest example is the `len()` function, which counts the number of items
    in some kind of container object, such as a dictionary or list. You''ve seen it
    before, demonstrated as follows::'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的例子是`len()`函数，它计算某种容器对象中的项目数量，比如字典或列表。你之前已经见过它，演示如下：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You may wonder why these objects don't have a length property instead of having
    to call a function on them. Technically, they do. Most objects that `len()` will
    apply to have a method called `__len__()` that returns the same value. So `len(myobj)`
    seems to call `myobj.__len__()`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么这些对象没有一个长度属性，而是必须在它们上调用一个函数。从技术上讲，它们是有的。大多数`len()`适用的对象都有一个名为`__len__()`的方法，返回相同的值。所以`len(myobj)`似乎调用了`myobj.__len__()`。
- en: Why should we use the `len()` function instead of the `__len__` method? Obviously, `__len__`
    is a special double-underscore method, suggesting that we shouldn't call it directly.
    There must be an explanation for this. The Python developers don't make such design
    decisions lightly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们应该使用`len()`函数而不是`__len__`方法？显然，`__len__`是一个特殊的双下划线方法，这表明我们不应该直接调用它。这一定有一个解释。Python开发人员不会轻易做出这样的设计决定。
- en: The main reason is efficiency. When we call `__len__` on an object, the object
    has to look the method up in its namespace, and, if the special `__getattribute__`
    method (which is called every time an attribute or method on an object is accessed)
    is defined on that object, it has to be called as well. Furthermore, the `__getattribute__`
    for that particular method may have been written to do something nasty, such as
    refusing to give us access to special methods such as `__len__`! The `len()` function
    doesn't encounter any of this. It actually calls the `__len__` function on the
    underlying class, so `len(myobj)` maps to `MyObj.__len__(myobj)`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 主要原因是效率。当我们在对象上调用`__len__`时，对象必须在其命名空间中查找该方法，并且如果该对象上定义了特殊的`__getattribute__`方法（每次访问对象的属性或方法时都会调用），它也必须被调用。此外，该方法的`__getattribute__`可能被编写为执行一些不好的操作，比如拒绝让我们访问特殊方法，比如`__len__`！`len()`函数不会遇到这些问题。它实际上调用了基础类的`__len__`函数，所以`len(myobj)`映射到了`MyObj.__len__(myobj)`。
- en: Another reason is maintainability. In the future, Python developers may want
    to change `len()` so that it can calculate the length of objects that don't have
    `__len__`, for example, by counting the number of items returned in an iterator.
    They'll only have to change one function instead of countless `__len__` methods
    in many objects across the board.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是可维护性。将来，Python开发人员可能希望更改`len()`，以便它可以计算没有`__len__`的对象的长度，例如，通过计算迭代器返回的项目数量。他们只需要更改一个函数，而不是在整个对象中无数的`__len__`方法。
- en: 'There is one other extremely important and often overlooked reason for `len()`
    being an external function: backward compatibility. This is often cited in articles
    as *for historical reasons*, which is a mildly dismissive phrase that an author
    will use to say something is the way it is because a mistake was made long ago
    and we''re stuck with it. Strictly speaking, `len()` isn''t a mistake, it''s a
    design decision, but that decision was made in a less object-oriented time. It
    has stood the test of time and has some benefits, so do get used to it.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`len()`作为外部函数还有一个极其重要且经常被忽视的原因：向后兼容性。这经常在文章中被引用为*出于历史原因*，这是作者用来表示某事之所以是某种方式是因为很久以前犯了一个错误，我们现在被困在这种方式中的一种委婉的说法。严格来说，`len()`并不是一个错误，而是一个设计决定，但这个决定是在一个不太面向对象的时代做出的。它经受住了时间的考验，并且有一些好处，所以要习惯它。'
- en: Reversed
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反转
- en: The `reversed()` function takes any sequence as input, and returns a copy of
    that sequence in reverse order. It is normally used in `for` loops when we want
    to loop over items from back to front.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`reversed()`函数接受任何序列作为输入，并返回该序列的一个副本，顺序相反。通常在`for`循环中使用，当我们想要从后向前循环遍历项目时。'
- en: 'Similar to `len`, `reversed` calls the `__reversed__()` function on the class
    for the parameter. If that method does not exist, `reversed` builds the reversed
    sequence itself using calls to `__len__` and `__getitem__`, which are used to
    define a sequence. We only need to override `__reversed__` if we want to somehow
    customize or optimize the process, as demonstrated in the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与`len`类似，`reversed`在参数的类上调用`__reversed__()`函数。如果该方法不存在，`reversed`将使用对`__len__`和`__getitem__`的调用来构建反转的序列，这些方法用于定义序列。如果我们想要以某种方式自定义或优化过程，我们只需要重写`__reversed__`，就像下面的代码所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `for` loops at the end print reversed versions of a normal list, and instances
    of the two custom sequences. The output shows that `reversed` works on all three
    of them, but has very different results when we define `__reversed__` ourselves:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`for`循环打印了正常列表的反转版本，以及两个自定义序列的实例。输出显示`reversed`适用于它们三个，但当我们自己定义`__reversed__`时，结果却大不相同：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we reverse `CustomSequence`, the `__getitem__` method is called for each
    item, which just inserts an `x` before the index. For `FunkyBackwards`, the `__reversed__`
    method returns a string, each character of which is output individually in the
    `for` loop.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们反转`CustomSequence`时，`__getitem__`方法会为每个项目调用，它只是在索引之前插入一个`x`。对于`FunkyBackwards`，`__reversed__`方法返回一个字符串，其中每个字符在`for`循环中单独输出。
- en: The preceding two classes aren't very good sequences, as they don't define a
    proper version of `__iter__`, so a forward `for` loop over them would never end.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个类不是很好的序列，因为它们没有定义一个适当版本的`__iter__`，所以对它们进行正向`for`循环永远不会结束。
- en: Enumerate
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: 'Sometimes, when we''re looping over a container in a `for` loop, we want access
    to the index (the current position in the list) of the current item being processed.
    The `for` loop doesn''t provide us with indexes, but the `enumerate` function
    gives us something better: it creates a sequence of tuples, where the first object
    in each tuple is the index and the second is the original item.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当我们在`for`循环中循环遍历容器时，我们希望访问当前正在处理的项目的索引（列表中的当前位置）。`for`循环不提供索引，但`enumerate`函数给了我们更好的东西：它创建了一个元组序列，其中每个元组中的第一个对象是索引，第二个对象是原始项目。
- en: 'This is useful if we need to use index numbers directly. Consider some simple
    code that outputs each of the lines in a file with line numbers:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要直接使用索引号，这是很有用的。考虑一些简单的代码，输出文件中的每一行及其行号：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running this code using its own filename as the input file shows how it works:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自己的文件名作为输入文件运行此代码，可以显示它是如何工作的：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `enumerate` function returns a sequence of tuples, our `for` loop splits
    each tuple into two values, and the `print` statement formats them together. It
    adds one to the index for each line number, since `enumerate`, like all sequences,
    is zero-based.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`enumerate`函数返回一个元组序列，我们的`for`循环将每个元组拆分为两个值，并且`print`语句将它们格式化在一起。对于每行号，它会将索引加一，因为`enumerate`，像所有序列一样，是从零开始的。'
- en: 'We''ve only touched on a few of the more important Python built-in functions.
    As you can see, many of them call into object-oriented concepts, while others
    subscribe to purely functional or procedural paradigms. There are numerous others
    in the standard library; some of the more interesting ones include the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是涉及了一些更重要的Python内置函数。正如你所看到的，其中许多调用面向对象的概念，而其他一些则遵循纯函数式或过程式范例。标准库中还有许多其他函数；一些更有趣的包括以下内容：
- en: '`all` and `any`, which accept an iterable object and return `True` if all,
    or any, of the items evaluate to true (such as a non-empty string or list, a non-zero
    number, an object that is not `None`, or the literal `True`).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all`和`any`，它们接受一个可迭代对象，并在所有或任何项目评估为true时返回`True`（例如非空字符串或列表，非零数，不是`None`的对象，或文字`True`）。'
- en: '`eval`, `exec`, and `compile`, which execute string as code inside the interpreter.
    Be careful with these ones; they are not safe, so don''t execute code an unknown
    user has supplied to you (in general, assume all unknown users are malicious,
    foolish, or both).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eval`、`exec`和`compile`，它们将字符串作为代码在解释器中执行。对于这些要小心；它们不安全，所以不要执行未知用户提供给你的代码（一般来说，假设所有未知用户都是恶意的、愚蠢的，或两者兼有）。'
- en: '`hasattr`, `getattr`, `setattr`, and `delattr`, which allow attributes on an
    object to be manipulated by their string names.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasattr`、`getattr`、`setattr`和`delattr`，它们允许通过它们的字符串名称操作对象的属性。'
- en: '`zip`, which takes two or more sequences and returns a new sequence of tuples,
    where each tuple contains a single value from each sequence.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip`接受两个或多个序列，并返回一个新的元组序列，其中每个元组包含来自每个序列的单个值。'
- en: And many more! See the interpreter help documentation for each of the functions
    listed in `dir(__builtins__)`.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有更多！查看`dir(__builtins__)`中列出的每个函数的解释器帮助文档。
- en: File I/O
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件I/O
- en: Our examples so far that have touched the filesystem have operated entirely
    on text files without much thought as to what is going on under the hood. Operating
    systems, however, actually represent files as a sequence of bytes, not text. Reading
    textual data from a file is a fairly involved process. Python, especially Python
    3, takes care of most of this work for us behind the scenes. Aren't we lucky?!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的示例都是在文件系统上操作文本文件，而没有考虑底层发生了什么。然而，操作系统实际上将文件表示为一系列字节，而不是文本。从文件中读取文本数据是一个相当复杂的过程。Python，特别是Python
    3，在幕后为我们处理了大部分工作。我们真是幸运！
- en: The concept of files has been around since long before anyone coined the term
    *object-oriented programming*. However, Python has wrapped the interface that
    operating systems provide in a sweet abstraction that allows us to work with file
    (or file-like, vis-à-vis duck typing) objects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的概念早在有人创造术语“面向对象编程”之前就已经存在。然而，Python已经将操作系统提供的接口包装成一个甜蜜的抽象，使我们能够使用文件（或类似文件，即鸭子类型）对象。
- en: The `open()` built-in function is used to open a file and return a file object.
    For reading text from a file, we only need to pass the name of the file into the
    function. The file will be opened for reading, and the bytes will be converted
    to text using the platform default encoding.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`open()`内置函数用于打开文件并返回文件对象。要从文件中读取文本，我们只需要将文件名传递给函数。文件将被打开以进行读取，并且字节将使用平台默认编码转换为文本。'
- en: 'Of course, we don''t always want to read files; often we want to write data
    to them! To open a file for writing, we need to pass a `mode` argument as the
    second positional argument, with a value of `"w"`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们并不总是想要读取文件；通常我们想要向其中写入数据！要打开文件进行写入，我们需要将`mode`参数作为第二个位置参数传递，并将其值设置为“w”：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We could also supply the value `"a"` as a mode argument, to append to the end
    of the file, rather than completely overwriting existing file content.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将值“a”作为模式参数提供，以便将其附加到文件的末尾，而不是完全覆盖现有文件内容。
- en: These files with built-in wrappers for converting bytes to text are great, but
    it'd be awfully inconvenient if the file we wanted to open was an image, executable,
    or other binary file, wouldn't it?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些具有内置包装器以将字节转换为文本的文件非常好，但是如果我们要打开的文件是图像、可执行文件或其他二进制文件，那将非常不方便，不是吗？
- en: To open a binary file, we modify the mode string to append `'b'`. So, `'wb'`
    would open a file for writing bytes, while `'rb'` allows us to read them. They
    will behave like text files, but without the automatic encoding of text to bytes.
    When we read such a file, it will return `bytes` objects instead of `str`, and
    when we write to it, it will fail if we try to pass a text object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开二进制文件，我们修改模式字符串以附加“b”。因此，“wb”将打开一个用于写入字节的文件，而“rb”允许我们读取它们。它们将像文本文件一样运行，但不会自动将文本编码为字节。当我们读取这样的文件时，它将返回`bytes`对象而不是`str`，当我们向其写入时，如果尝试传递文本对象，它将失败。
- en: These mode strings for controlling how files are opened are rather cryptic and
    are neither Pythonic nor object-oriented. However, they are consistent with virtually
    every other programming language out there. File I/O is one of the fundamental
    jobs an operating system has to handle, and all programming languages have to
    talk to the operating system using the same system calls. Just be glad that Python
    returns a file object with useful methods instead of the integer that most major
    operating systems use to identify a file handle!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用于控制文件打开方式的模式字符串相当神秘，既不符合Python的风格，也不是面向对象的。但是，它们与几乎所有其他编程语言一致。文件I/O是操作系统必须处理的基本工作之一，所有编程语言都必须使用相同的系统调用与操作系统进行通信。只要Python返回一个带有有用方法的文件对象，而不是大多数主要操作系统用于标识文件句柄的整数，就应该感到高兴！
- en: Once a file is opened for reading, we can call the `read`, `readline`, or `readlines`
    methods to get the contents of the file. The `read` method returns the entire
    contents of the file as a `str` or `bytes` object, depending on whether there
    is `'b'` in the mode. Be careful not to use this method without arguments on huge
    files. You don't want to find out what happens if you try to load that much data
    into memory!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被打开以进行读取，我们就可以调用`read`、`readline`或`readlines`方法来获取文件的内容。`read`方法返回文件的整个内容作为`str`或`bytes`对象，具体取决于模式中是否有“b”。不要在大文件上不带参数地使用此方法。您不希望知道如果尝试将这么多数据加载到内存中会发生什么！
- en: It is also possible to read a fixed number of bytes from a file; we pass an
    integer argument to the `read` method, describing how many bytes we want to read.
    The next call to `read` will load the next sequence of bytes, and so on. We can
    do this inside a `while` loop to read the entire file in manageable chunks.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以从文件中读取固定数量的字节；我们将整数参数传递给`read`方法，描述我们要读取多少字节。对`read`的下一次调用将加载下一个字节序列，依此类推。我们可以在`while`循环中执行此操作，以以可管理的块读取整个文件。
- en: The `readline` method returns a single line from the file (where each line ends
    in a newline, a carriage return, or both, depending on the operating system on
    which the file was created). We can call it repeatedly to get additional lines.
    The plural `readlines` method returns a list of all the lines in the file. Like
    the `read` method, it's not safe to use on very large files. These two methods
    even work when the file is open in `bytes` mode, but it only makes sense if we
    are parsing text-like data that has newlines at reasonable positions. An image
    or audio file, for example, will not have newline characters in it (unless the
    newline byte happened to represent a certain pixel or sound), so applying `readline`
    wouldn't make sense.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`readline`方法返回文件中的一行（每行以换行符、回车符或两者结尾，具体取决于创建文件的操作系统）。我们可以重复调用它以获取其他行。复数`readlines`方法返回文件中所有行的列表。与`read`方法一样，它不适用于非常大的文件。这两种方法甚至在文件以`bytes`模式打开时也可以使用，但只有在解析具有合理位置的换行符的文本数据时才有意义。例如，图像或音频文件不会包含换行符（除非换行符字节恰好表示某个像素或声音），因此应用`readline`是没有意义的。'
- en: For readability, and to avoid reading a large file into memory at once, it is
    often better to use a `for` loop directly on a file object. For text files, it
    will read each line, one at a time, and we can process it inside the loop body.
    For binary files, it's better to read fixed-sized chunks of data using the `read()`
    method, passing a parameter for the maximum number of bytes to read.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，并且避免一次将大文件读入内存，通常最好直接在文件对象上使用`for`循环。对于文本文件，它将一次读取每一行，我们可以在循环体内处理它。对于二进制文件，最好使用`read()`方法读取固定大小的数据块，传递一个参数以读取的最大字节数。
- en: Writing to a file is just as easy; the `write` method on file objects writes
    a string (or bytes, for binary data) object to the file. It can be called repeatedly
    to write multiple strings, one after the other. The `writelines` method accepts
    a sequence of strings and writes each of the iterated values to the file. The
    `writelines` method does *not* append a new line after each item in the sequence.
    It is basically a poorly named convenience function to write the contents of a
    sequence of strings without having to explicitly iterate over it using a `for`
    loop.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 写入文件同样简单；文件对象上的`write`方法将一个字符串（或字节，用于二进制数据）对象写入文件。可以重复调用它来写入多个字符串，一个接着一个。`writelines`方法接受一个字符串序列，并将迭代的每个值写入文件。`writelines`方法在序列中的每个项目后面*不*添加新行。它基本上是一个命名不当的便利函数，用于写入字符串序列的内容，而无需使用`for`循环显式迭代它。
- en: Lastly, and I do mean lastly, we come to the `close` method. This method should
    be called when we are finished reading or writing the file, to ensure any buffered
    writes are written to the disk, that the file has been properly cleaned up, and
    that all resources associated with the file are released back to the operating
    system. Technically, this will happen automatically when the script exits, but
    it's better to be explicit and clean up after ourselves, especially in long-running
    processes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我是指最后，我们来到`close`方法。当我们完成读取或写入文件时，应调用此方法，以确保任何缓冲写入都写入磁盘，文件已经得到适当清理，并且与文件关联的所有资源都已释放回操作系统。从技术上讲，当脚本退出时，这将自动发生，但最好是明确地清理自己，特别是在长时间运行的进程中。
- en: Placing it in context
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放在上下文中
- en: The need to close files when we are finished with them can make our code quite
    ugly. Because an exception may occur at any time during file I/O, we ought to
    wrap all calls to a file in a `try`...`finally` clause. The file should be closed
    in the `finally` clause, regardless of whether I/O was successful. This isn't
    very Pythonic. Of course, there is a more elegant way to do it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成文件时需要关闭文件，这可能会使我们的代码变得非常丑陋。因为在文件I/O期间可能会发生异常，我们应该将对文件的所有调用都包装在`try`...`finally`子句中。文件应该在`finally`子句中关闭，无论I/O是否成功。这并不是很Pythonic。当然，有一种更优雅的方法来做。
- en: 'If we run `dir` on a file-like object, we see that it has two special methods
    named `__enter__` and `__exit__`. These methods turn the file object into what
    is known as a **context manager**. Basically, if we use a special syntax called
    the `with` statement, these methods will be called before and after nested code
    is executed. On file objects, the `__exit__` method ensures the file is closed,
    even if an exception is raised. We no longer have to explicitly manage the closing
    of the file. Here is what the `with` statement looks like in practice:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在类似文件的对象上运行`dir`，我们会发现它有两个名为`__enter__`和`__exit__`的特殊方法。这些方法将文件对象转换为所谓的**上下文管理器**。基本上，如果我们使用一个称为`with`语句的特殊语法，这些方法将在嵌套代码执行之前和之后被调用。对于文件对象，`__exit__`方法确保文件被关闭，即使发生异常。我们不再需要显式地管理文件的关闭。下面是`with`语句在实践中的样子：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `open` call returns a file object, which has `__enter__` and `__exit__`
    methods. The returned object is assigned to the variable named `file` by the `as`
    clause. We know the file will be closed when the code returns to the outer indentation
    level, and that this will happen even if an exception is raised.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`open`调用返回一个文件对象，该对象具有`__enter__`和`__exit__`方法。返回的对象通过`as`子句分配给名为`file`的变量。我们知道当代码返回到外部缩进级别时，文件将被关闭，即使发生异常也会发生这种情况。'
- en: The `with` statement is used in several places in the standard library, where
    start up or cleanup code needs to be executed. For example, the `urlopen` call
    returns an object that can be used in a `with` statement to clean up the socket
    when we're done. Locks in the threading module can automatically release the lock
    when the statement has been executed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`语句在标准库中的几个地方使用，需要执行启动或清理代码。例如，`urlopen`调用返回一个对象，可以在`with`语句中使用，以在完成后清理套接字。线程模块中的锁可以在语句执行后自动释放锁。'
- en: 'Most interestingly, because the `with` statement can apply to any object that
    has the appropriate special methods, we can use it in our own frameworks. For
    example, remember that strings are immutable, but sometimes you need to build
    a string from multiple parts. For efficiency, this is usually done by storing
    the component strings in a list and joining them at the end. Let''s create a simple
    context manager that allows us to construct a sequence of characters and automatically
    convert it to a string upon exit:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的是，因为`with`语句可以应用于具有适当特殊方法的任何对象，我们可以在自己的框架中使用它。例如，记住字符串是不可变的，但有时需要从多个部分构建字符串。出于效率考虑，通常通过将组件字符串存储在列表中并在最后将它们连接起来来完成。让我们创建一个简单的上下文管理器，允许我们构建一个字符序列，并在退出时自动将其转换为字符串：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code adds the two special methods required of a context manager to the
    `list` class it inherits from. The `__enter__` method performs any required setup
    code (in this case, there isn't any) and then returns the object that will be
    assigned to the variable after `as` in the `with` statement. Often, as we've done
    here, this is just the context manager object itself. The `__exit__` method accepts
    three arguments. In a normal situation, these are all given a value of `None`.
    However, if an exception occurs inside the `with` block, they will be set to values
    related to the type, value, and traceback for the exception. This allows the `__exit__`
    method to perform any cleanup code that may be required, even if an exception
    occurred. In our example, we take the irresponsible path and create a result string
    by joining the characters in the string, regardless of whether an exception was
    thrown.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将`list`类中所需的两个特殊方法添加到它继承的`list`类中。`__enter__`方法执行任何必需的设置代码（在本例中没有），然后返回将分配给`with`语句中`as`后面的变量的对象。通常，就像我们在这里做的那样，这只是上下文管理器对象本身。`__exit__`方法接受三个参数。在正常情况下，它们都被赋予`None`的值。然而，如果`with`块内发生异常，它们将被设置为与异常类型、值和回溯相关的值。这允许`__exit__`方法执行可能需要的任何清理代码，即使发生异常。在我们的例子中，我们采取了不负责任的路径，并通过连接字符串中的字符创建了一个结果字符串，而不管是否抛出异常。
- en: 'While this is one of the simplest context managers we could write, and its
    usefulness is dubious, it does work with a `with` statement. Have a look at it
    in action:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是我们可以编写的最简单的上下文管理器之一，它的用处是可疑的，但它确实可以与`with`语句一起使用。看看它的运行情况：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code constructs a string of 15 random characters. It appends these to a
    `StringJoiner` using the `append` method it inherited from `list`. When the `with`
    statement goes out of scope (back to the outer indentation level), the `__exit__`
    method is called, and the `result` attribute becomes available on the joiner object.
    We then print this value to see a random string.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码构造了一个包含15个随机字符的字符串。它使用从`list`继承的`append`方法将这些字符附加到`StringJoiner`上。当`with`语句超出范围（回到外部缩进级别）时，将调用`__exit__`方法，并且`joiner`对象上的`result`属性变得可用。然后我们打印这个值来看一个随机字符串。
- en: An alternative to method overloading
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法重载的替代方法
- en: One prominent feature of many object-oriented programming languages is a tool
    called **method overloading**. Method overloading simply refers to having multiple
    methods with the same name that accept different sets of arguments. In statically
    typed languages, this is useful if we want to have a method that accepts either
    an integer or a string, for example. In non-object-oriented languages, we might
    need two functions, called `add_s` and `add_i`, to accommodate such situations.
    In statically typed object-oriented languages, we'd need two methods, both called
    `add`, one that accepts strings, and one that accepts integers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 许多面向对象的编程语言的一个显著特点是一个称为**方法重载**的工具。方法重载简单地指的是具有相同名称的多个方法，这些方法接受不同的参数集。在静态类型的语言中，如果我们想要一个方法既可以接受整数也可以接受字符串，这是很有用的。在非面向对象的语言中，我们可能需要两个函数，称为`add_s`和`add_i`，来适应这种情况。在静态类型的面向对象语言中，我们需要两个方法，都称为`add`，一个接受字符串，一个接受整数。
- en: In Python, we've already seen that we only need one method, which accepts any
    type of object. It may have to do some testing on the object type (for example,
    if it is a string, convert it to an integer), but only one method is required.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们已经看到我们只需要一个方法，它接受任何类型的对象。它可能需要对对象类型进行一些测试（例如，如果它是一个字符串，将其转换为整数），但只需要一个方法。
- en: However, method overloading is also useful when we want a method with the same
    name to accept different numbers or sets of arguments. For example, an email message
    method might come in two versions, one of which accepts an argument for the *from* email
    address. The other method might look up a default *from* email address instead.
    Python doesn't permit multiple methods with the same name, but it does provide
    a different, equally flexible, interface.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，方法重载在我们希望一个方法接受不同数量或一组不同的参数时也很有用。例如，电子邮件消息方法可能有两个版本，其中一个接受*from*电子邮件地址的参数。另一个方法可能会查找默认的*from*电子邮件地址。Python不允许使用相同名称的多个方法，但它提供了一个不同的、同样灵活的接口。
- en: 'We''ve seen some of the possible ways to send arguments to methods and functions
    in previous examples, but now we''ll cover all the details. The simplest function
    accepts no arguments. We probably don''t need an example, but here''s one for
    completeness:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的例子中看到了向方法和函数传递参数的一些可能方式，但现在我们将涵盖所有细节。最简单的函数不接受任何参数。我们可能不需要一个例子，但为了完整起见，这里有一个：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And here''s how it''s called:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的名字：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A function that does accept arguments will provide the names of those arguments
    in a comma-separated list. Only the name of each argument needs to be supplied.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接受参数的函数将在逗号分隔的列表中提供这些参数的名称。只需要提供每个参数的名称。
- en: 'When calling the function, these positional arguments must be specified in
    order, and none can be missed or skipped. This is the most common way in which
    we''ve specified arguments in our previous examples:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数时，这些位置参数必须按顺序指定，不能遗漏或跳过任何一个。这是我们在之前的例子中指定参数的最常见方式：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To call it, type the following::'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用它，输入以下内容：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Any type of object can be passed as an argument: an object, a container, a
    primitive, even functions and classes. The preceding call shows a hardcoded string,
    an unknown variable, and an integer passed into the function.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的对象都可以作为参数传递：对象、容器、原始类型，甚至函数和类。前面的调用显示了一个硬编码的字符串、一个未知的变量和一个整数传递到函数中。
- en: Default arguments
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认参数
- en: If we want to make an argument optional, rather than creating a second method
    with a different set of arguments, we can specify a default value in a single
    method, using an equals sign. If the calling code does not supply this argument,
    it will be assigned a default value. However, the calling code can still choose
    to override the default by passing in a different value. Often, a default value
    of `None`, or an empty string or list, is suitable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使一个参数变为可选的，而不是创建一个带有不同参数集的第二个方法，我们可以在单个方法中指定一个默认值，使用等号。如果调用代码没有提供这个参数，它将被分配一个默认值。但是，调用代码仍然可以选择通过传递不同的值来覆盖默认值。通常，`None`、空字符串或空列表是合适的默认值。
- en: 'Here''s a function definition with default arguments:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是带有默认参数的函数定义：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first three arguments are still mandatory and must be passed by the calling
    code. The last two parameters have default arguments supplied.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个参数仍然是必需的，并且必须由调用代码传递。最后两个参数有默认参数。
- en: 'There are several ways we can call this function. We can supply all arguments
    in order, as though all the arguments were positional arguments, as can be seen
    in the following::'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以多种方式调用这个函数。我们可以按顺序提供所有参数，就好像所有参数都是位置参数一样，如下所示：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Alternatively, we can supply just the mandatory arguments in order, leaving
    the keyword arguments to be assigned their default values:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以按顺序只提供必需的参数，将关键字参数分配为它们的默认值：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also use the equals sign syntax when calling a function to provide values
    in a different order, or to skip default values that we aren''t interested in.
    For example, we can skip the first keyword arguments and supply the second one:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在调用函数时使用等号语法，以不同的顺序提供值，或者跳过我们不感兴趣的默认值。例如，我们可以跳过第一个关键字参数并提供第二个参数：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Surprisingly, we can even use the equals sign syntax to mix up the order of
    positional arguments, so long as all of them are supplied:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，我们甚至可以使用等号语法来改变位置参数的顺序，只要所有参数都被提供：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You may occasionally find it useful to make a *keyword-only* argument, that
    is, an argument that must be supplied as a keyword argument. You can do that by
    placing a `*` before the keyword-only arguments:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔你可能会发现创建一个*仅限关键字*参数很有用，也就是说，必须作为关键字参数提供的参数。你可以通过在关键字参数前面加上`*`来实现这一点：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function has one positional argument, `x`, and three keyword arguments,
    `y`, `a`, and `b`. `x` and `y` are both mandatory, but `a` can only be passed
    as a keyword argument. `y` and `b` are both optional with default values, but
    if `b` is supplied, it can only be a keyword argument.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有一个位置参数`x`，和三个关键字参数`y`、`a`和`b`。`x`和`y`都是必需的，但是`a`只能作为关键字参数传递。`y`和`b`都是可选的，默认值是，但是如果提供了`b`，它只能作为关键字参数。
- en: 'This function fails if you don''t pass `a`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不传递`a`，这个函数会失败：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It also fails if you pass `a` as a positional argument:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`a`作为位置参数传递，也会失败：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'But you can pass `a` and `b` as keyword arguments:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你可以将`a`和`b`作为关键字参数传递：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With so many options, it may seem hard to pick one, but if you think of the
    positional arguments as an ordered list, and keyword arguments as sort of like
    a dictionary, you'll find that the correct layout tends to fall into place. If
    you need to require the caller to specify an argument, make it mandatory; if you
    have a sensible default, then make it a keyword argument. Choosing how to call
    the method normally takes care of itself, depending on which values need to be
    supplied, and which can be left at their defaults.  Keyword-only arguments are
    relatively rare, but when the use case comes up, they can make for a more elegant
    API.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有这么多的选项，可能很难选择一个，但是如果你把位置参数看作是一个有序列表，关键字参数看作是一种字典，你会发现正确的布局往往会自然而然地形成。如果你需要要求调用者指定一个参数，那就把它设为必需的；如果有一个合理的默认值，那就把它设为关键字参数。根据需要提供哪些值，以及哪些可以保持默认值，选择如何调用方法通常会自行解决。关键字参数相对较少见，但是当使用情况出现时，它们可以使API更加优雅。
- en: 'One thing to take note of with keyword arguments is that anything we provide
    as a default argument is evaluated when the function is first interpreted, not
    when it is called. This means we can''t have dynamically generated default values.
    For example, the following code won''t behave quite as expected:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，关键字参数的默认值是在函数首次解释时进行评估的，而不是在调用时进行的。这意味着我们不能有动态生成的默认值。例如，以下代码的行为不会完全符合预期：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If we run this code, it outputs the number `8` first, but then it outputs the
    number `5` for the call with no arguments. We had set the variable to the number
    `6`, as evidenced by the last line of output, but when the function is called,
    the number `5` is printed; the default value was calculated when the function
    was defined, not when it was called.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，首先输出数字`8`，但是后来对没有参数的调用输出数字`5`。我们已经将变量设置为数字`6`，这可以从输出的最后一行看出，但是当调用函数时，打印出的是数字`5`；默认值是在函数定义时计算的，而不是在调用时。
- en: 'This is tricky with empty containers such as lists, sets, and dictionaries.
    For example, it is common to ask calling code to supply a list that our function
    is going to manipulate, but the list is optional. We''d like to make an empty
    list as a default argument. We can''t do this; it will create only one list, when
    the code is first constructed, demonstrated as follows::'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这在空容器（如列表、集合和字典）中有些棘手。例如，通常会要求调用代码提供一个我们的函数将要操作的列表，但是列表是可选的。我们希望将一个空列表作为默认参数。我们不能这样做；它只会在代码首次构建时创建一个列表，如下所示：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Whoops, that's not quite what we expected! The usual way to get around this
    is to make the default value `None`, and then use the `iargument = argument if
    argument else []` idiom inside the method. Pay close attention!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，这不是我们预期的结果！通常的解决方法是将默认值设为`None`，然后在方法内部使用`iargument = argument if argument
    else []`这种习惯用法。请注意！
- en: Variable argument lists
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变参数列表
- en: Default values alone do not allow us all the flexible benefits of method overloading.
    One thing that makes Python really slick is the ability to write methods that
    accept an arbitrary number of positional or keyword arguments without explicitly
    naming them. We can also pass arbitrary lists and dictionaries into such functions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅使用默认值并不能让我们获得方法重载的所有灵活优势。使Python真正灵活的一件事是能够编写接受任意数量的位置或关键字参数而无需显式命名它们的方法。我们还可以将任意列表和字典传递给这样的函数。
- en: 'For example, a function to accept a link or list of links and download the
    web pages could use such variadic arguments, or **varargs**. Instead of accepting
    a single value that is expected to be a list of links, we can accept an arbitrary
    number of arguments, where each argument is a different link. We do this by specifying
    the `*` operator in the function definition, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个接受链接或链接列表并下载网页的函数可以使用这样的可变参数，或**varargs**。我们可以接受任意数量的参数，其中每个参数都是不同的链接，而不是接受一个预期为链接列表的单个值。我们可以通过在函数定义中指定`*`运算符来实现这一点：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `*links` parameter says, *I''ll accept any number of arguments and put
    them all in a list named* `links`. If we supply only one argument, it''ll be a
    list with one element; if we supply no arguments, it''ll be an empty list. Thus,
    all these function calls are valid:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`*links`参数表示，“我将接受任意数量的参数，并将它们全部放入一个名为`links`的列表中”。如果我们只提供一个参数，它将是一个只有一个元素的列表；如果我们不提供参数，它将是一个空列表。因此，所有这些函数调用都是有效的：'
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also accept arbitrary keyword arguments. These arrive in the function
    as a dictionary. They are specified with two asterisks (as in `**kwargs`) in the
    function declaration. This tool is commonly used in configuration setups. The
    following class allows us to specify a set of options with default values:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以接受任意关键字参数。这些参数以字典的形式传递给函数。它们在函数声明中用两个星号（如`**kwargs`）指定。这个工具通常用于配置设置。下面的类允许我们指定一组具有默认值的选项：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'All the interesting stuff in this class happens in the `__init__` method. We
    have a dictionary of default options and values at the class level. The first
    thing the `__init__` method does is make a copy of this dictionary. We do that
    instead of modifying the dictionary directly, in case we instantiate two separate
    sets of options. (Remember, class-level variables are shared between instances
    of the class.) Then, `__init__` uses the `update` method on the new dictionary
    to change any non-default values to those supplied as keyword arguments. The `__getitem__`
    method simply allows us to use the new class using indexing syntax. Here''s a
    session demonstrating the class in action:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中所有有趣的东西都发生在`__init__`方法中。我们在类级别有一个默认选项和值的字典。`__init__`方法做的第一件事就是复制这个字典。我们这样做是为了避免直接修改字典，以防我们实例化两组不同的选项。（记住，类级别的变量在类的实例之间是共享的。）然后，`__init__`方法使用新字典上的`update`方法将任何非默认值更改为提供的关键字参数。`__getitem__`方法简单地允许我们使用索引语法使用新类。下面是一个演示该类运行情况的会话：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We're able to access our `options` instance using dictionary indexing syntax,
    and the dictionary includes both default values and the ones we set using keyword
    arguments.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够使用字典索引语法访问我们的`options`实例，字典中包括默认值和我们使用关键字参数设置的值。
- en: The keyword argument syntax can be dangerous, as it may break the *explicit
    is better than implicit* rule. In the preceding example, it's possible to pass
    arbitrary keyword arguments to the `Options` initializer to represent options
    that don't exist in the default dictionary. This may not be a bad thing, depending
    on the purpose of the class, but it makes it hard for someone using the class
    to discover what valid options are available. It also makes it easy to enter a
    confusing typo (*Debug* instead of *debug*, for example) that adds two options
    where only one should have existed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数语法可能是危险的，因为它可能违反“明确胜于隐式”的规则。在前面的例子中，可以向`Options`初始化程序传递任意关键字参数，以表示默认字典中不存在的选项。这可能不是一件坏事，取决于类的目的，但它使得使用该类的人很难发现有哪些有效选项可用。它还使得很容易输入令人困惑的拼写错误（例如*Debug*而不是*debug*），从而添加了两个选项，而本应只有一个选项存在。
- en: 'Keyword arguments are also very useful when we need to accept arbitrary arguments
    to pass to a second function, but we don''t know what those arguments will be.
    We saw this in action in [Chapter 17](63f74e80-a17c-456d-969e-2a36ffb0067b.xhtml),
    *When Objects Are Alike*, when we were building support for multiple inheritance.
    We can, of course, combine the variable argument and variable keyword argument
    syntax in one function call, and we can use normal positional and default arguments
    as well. The following example is somewhat contrived, but demonstrates the four
    types in action:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要接受要传递给第二个函数的任意参数时，关键字参数也非常有用，但我们不知道这些参数是什么。我们在[第17章](63f74e80-a17c-456d-969e-2a36ffb0067b.xhtml)中看到了这一点，*当对象相似*，当我们为多重继承构建支持时。当然，我们可以在一个函数调用中结合使用可变参数和可变关键字参数语法，并且我们也可以使用普通的位置参数和默认参数。下面的例子有些牵强，但演示了这四种类型的作用：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This example processes an arbitrary list of files. The first argument is a target
    folder, and the default behavior is to move all remaining non-keyword argument
    files into that folder. Then there is a keyword-only argument, `verbose`, which
    tells us whether to print information on each file processed. Finally, we can
    supply a dictionary containing actions to perform on specific filenames; the default
    behavior is to move the file, but if a valid string action has been specified
    in the keyword arguments, it can be ignored or copied instead. Notice the ordering
    of the parameters in the function; first, the positional argument is specified,
    then the `*filenames` list, then any specific keyword-only arguments, and finally,
    a `**specific` dictionary to hold remaining keyword arguments.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例处理一个任意文件列表。第一个参数是目标文件夹，默认行为是将所有剩余的非关键字参数文件移动到该文件夹中。然后是一个仅限关键字参数`verbose`，它告诉我们是否要打印每个处理的文件的信息。最后，我们可以提供一个包含要对特定文件名执行的操作的字典；默认行为是移动文件，但如果在关键字参数中指定了有效的字符串操作，它可以被忽略或复制。请注意函数参数的排序；首先指定位置参数，然后是`*filenames`列表，然后是任何特定的仅限关键字参数，最后是一个`**specific`字典来保存剩余的关键字参数。
- en: We create an inner helper function, `print_verbose`, which will print messages
    only if the `verbose` key has been set. This function keeps code readable by encapsulating
    this functionality in a single location.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个内部辅助函数`print_verbose`，它只在设置了`verbose`键时才打印消息。通过将此功能封装在一个单一位置中，该函数使代码易于阅读。
- en: 'In common cases, assuming the files in question exist, this function could
    be called as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在常见情况下，假设所涉及的文件存在，可以调用此函数如下：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This command would move the files `one` and `two` into the `move_here` directory,
    assuming they exist (there's no error checking or exception handling in the function,
    so it would fail spectacularly if the files or target directory didn't exist).
    The move would occur without any output, since `verbose` is `False` by default.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将文件`one`和`two`移动到`move_here`目录中，假设它们存在（函数中没有错误检查或异常处理，因此如果文件或目标目录不存在，它将失败）。移动将在没有任何输出的情况下发生，因为`verbose`默认为`False`。
- en: 'If we want to see the output, we can call it with the help of the following
    command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要看到输出，我们可以使用以下命令调用它：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This moves one file named `three`, and tells us what it's doing. Notice that
    it is impossible to specify `verbose` as a positional argument in this example;
    we must pass a keyword argument. Otherwise, Python would think it was another
    filename in the `*filenames` list.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将移动名为`three`的一个文件，并告诉我们它在做什么。请注意，在此示例中不可能将`verbose`指定为位置参数；我们必须传递关键字参数。否则，Python会认为它是`*filenames`列表中的另一个文件名。
- en: 'If we want to copy or ignore some of the files in the list, instead of moving
    them, we can pass additional keyword arguments, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要复制或忽略列表中的一些文件，而不是移动它们，我们可以传递额外的关键字参数，如下所示：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will move the sixth file and copy the fourth, but won''t display any output,
    since we didn''t specify `verbose`. Of course, we can do that too, and keyword
    arguments can be supplied in any order, demonstrated as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将移动第六个文件并复制第四个文件，但不会显示任何输出，因为我们没有指定`verbose`。当然，我们也可以这样做，关键字参数可以以任何顺序提供，如下所示：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Unpacking arguments
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解压参数
- en: 'There''s one more nifty trick involving variable arguments and keyword arguments.
    We''ve used it in some of our previous examples, but it''s never too late for
    an explanation. Given a list or dictionary of values, we can pass those values
    into a function as if they were normal positional or keyword arguments. Have a
    look at this code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个关于可变参数和关键字参数的巧妙技巧。我们在之前的一些示例中使用过它，但现在解释一下也不算晚。给定一个值列表或字典，我们可以将这些值传递到函数中，就好像它们是普通的位置或关键字参数一样。看看这段代码：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here''s what it looks like when we run it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行它时，它看起来像这样：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The function accepts three arguments, one of which has a default value. But
    when we have a list of three arguments, we can use the `*` operator inside a function
    call to unpack it into the three arguments. If we have a dictionary of arguments,
    we can use the `**` syntax to unpack it as a collection of keyword arguments.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受三个参数，其中一个具有默认值。但是当我们有一个包含三个参数的列表时，我们可以在函数调用内部使用`*`运算符将其解压为三个参数。如果我们有一个参数字典，我们可以使用`**`语法将其解压缩为一组关键字参数。
- en: This is most often useful when mapping information that has been collected from
    user input or from an outside source (for example, an internet page or a text
    file) to a function or method call.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这在将从用户输入或外部来源（例如互联网页面或文本文件）收集的信息映射到函数或方法调用时最常用。
- en: Remember our earlier example that used headers and lines in a text file to create
    a list of dictionaries with contact information? Instead of just adding the dictionaries
    to a list, we could use keyword unpacking to pass the arguments to the `__init__`
    method on a specially built `Contact` object that accepts the same set of arguments.
    See if you can adapt the example to make this work.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们之前的例子吗？它使用文本文件中的标题和行来创建包含联系信息的字典列表。我们可以使用关键字解压缩将这些字典传递给专门构建的`Contact`对象上的`__init__`方法，该对象接受相同的参数集。看看你是否可以调整示例使其正常工作。
- en: 'This unpacking syntax can be used in some areas outside of function calls,
    too. The `Options` class earlier had an `__init__` method that looked like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解压缩语法也可以在函数调用之外的某些领域中使用。`Options`类之前有一个`__init__`方法，看起来像这样：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'An even more succinct way to do this would be to unpack the two dictionaries
    like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 更简洁的方法是解压缩这两个字典，如下所示：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Because the dictionaries are unpacked in order from left to right, the resulting
    dictionary will contain all the default options, with any of the kwarg options
    replacing some of the keys. Here''s an example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字典按从左到右的顺序解压缩，结果字典将包含所有默认选项，并且任何kwarg选项都将替换一些键。以下是一个示例：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Functions are objects too
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数也是对象
- en: Programming languages that overemphasize object-oriented principles tend to
    frown on functions that are not methods. In such languages, you're expected to
    create an object to sort of wrap the single method involved. There are numerous
    situations where we'd like to pass around a small object that is simply called
    to perform an action. This is most frequently done in event-driven programming,
    such as graphical toolkits or asynchronous servers; we'll see some design patterns
    that use it in [Chapter 22](f09b264b-a4c5-4a1e-9911-8f00ca74144c.xhtml), *Python Design
    Patterns I*, and [Chapter 23](3e7c30d8-a939-4a5e-9eb4-53d9f24a0306.xhtml), *Python **Design
    Patterns II*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 过分强调面向对象原则的编程语言往往不赞成不是方法的函数。在这样的语言中，你应该创建一个对象来包装涉及的单个方法。有许多情况下，我们希望传递一个简单的对象，只需调用它执行一个动作。这在事件驱动编程中最常见，比如图形工具包或异步服务器；我们将在[第22章](f09b264b-a4c5-4a1e-9911-8f00ca74144c.xhtml)
    *Python 设计模式 I* 和[第23章](3e7c30d8-a939-4a5e-9eb4-53d9f24a0306.xhtml) *Python 设计模式
    II* 中看到一些使用它的设计模式。
- en: 'In Python, we don''t need to wrap such methods in an object because functions
    already are objects! We can set attributes on functions (though this isn''t a
    common activity), and we can pass them around to be called at a later date. They
    even have a few special properties that can be accessed directly. Here''s yet
    another contrived example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们不需要将这样的方法包装在对象中，因为函数本身就是对象！我们可以在函数上设置属性（尽管这不是常见的活动），并且我们可以传递它们以便在以后的某个日期调用它们。它们甚至有一些可以直接访问的特殊属性。这里是另一个刻意的例子：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If we run this code, we can see that we were able to pass two different functions
    into our third function, and get different output for each one:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这段代码，我们可以看到我们能够将两个不同的函数传递给我们的第三个函数，并为每个函数获得不同的输出：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We set an attribute on the function, named `description` (not very good descriptions,
    admittedly). We were also able to see the function's `__name__` attribute, and
    to access its class, demonstrating that the function really is an object with
    attributes. Then, we called the function by using the callable syntax (the parentheses).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数上设置了一个属性，名为 `description`（诚然不是很好的描述）。我们还能看到函数的 `__name__` 属性，并访问它的类，证明函数确实是一个带有属性的对象。然后，我们使用可调用语法（括号）调用了函数。
- en: 'The fact that functions are top-level objects is most often used to pass them
    around to be executed at a later date, for example, when a certain condition has
    been satisfied. Let''s build an event-driven timer that does just this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是顶级对象的事实最常用于传递它们以便在以后的某个日期执行，例如，当某个条件已满足时。让我们构建一个事件驱动的定时器，就是这样做的：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In production, this code should definitely have extra documentation using docstrings!
    The `call_after` method should at least mention that the `delay` parameter is
    in seconds, and that the `callback` function should accept one argument: the timer
    doing the calling.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，这段代码肯定应该使用文档字符串进行额外的文档化！`call_after` 方法至少应该提到 `delay` 参数是以秒为单位的，并且 `callback`
    函数应该接受一个参数：调用者定时器。
- en: We have two classes here. The `TimedEvent` class is not really meant to be accessed
    by other classes; all it does is store `endtime` and `callback`. We could even
    use a `tuple` or `namedtuple` here, but as it is convenient to give the object
    a behavior that tells us whether or not the event is ready to run, we use a class
    instead.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有两个类。`TimedEvent` 类实际上并不是其他类可以访问的；它只是存储 `endtime` 和 `callback`。我们甚至可以在这里使用
    `tuple` 或 `namedtuple`，但是为了方便给对象一个行为，告诉我们事件是否准备好运行，我们使用了一个类。
- en: 'The `Timer` class simply stores a list of upcoming events. It has a `call_after`
    method to add a new event. This method accepts a `delay` parameter representing
    the number of seconds to wait before executing the callback, and the `callback`
    function itself: a function to be executed at the correct time. This `callback`
    function should accept one argument.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timer` 类简单地存储了一个即将到来的事件列表。它有一个 `call_after` 方法来添加一个新事件。这个方法接受一个 `delay` 参数，表示在执行回调之前等待的秒数，以及
    `callback` 函数本身：在正确的时间执行的函数。这个 `callback` 函数应该接受一个参数。'
- en: The `run` method is very simple; it uses a generator expression to filter out
    any events whose time has come, and executes them in order. The *timer* loop then
    continues indefinitely, so it has to be interrupted with a keyboard interrupt
    (*Ctrl* + *C*, or *Ctrl* + *Break*). We sleep for half a second after each iteration
    so as to not grind the system to a halt.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`run` 方法非常简单；它使用生成器表达式来过滤出任何时间到达的事件，并按顺序执行它们。*定时器* 循环然后无限继续，因此必须使用键盘中断（*Ctrl*
    + *C*，或 *Ctrl* + *Break*）来中断。我们在每次迭代后睡眠半秒，以免使系统停滞。'
- en: The important things to note here are the lines that touch callback functions.
    The function is passed around like any other object and the timer never knows
    or cares what the original name of the function is or where it was defined. When
    it's time to call the function, the timer simply applies the parenthesis syntax
    to the stored variable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要事情是涉及回调函数的行。函数像任何其他对象一样被传递，定时器从不知道或关心函数的原始名称是什么，或者它是在哪里定义的。当该函数被调用时，定时器只是将括号语法应用于存储的变量。
- en: 'Here''s a set of callbacks that test the timer:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一组测试定时器的回调：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This example allows us to see how multiple callbacks interact with the timer.
    The first function is the `format_time` function. It uses the format string syntax
    to add the current time to the message; we'll read about them in the next chapter.
    Next, we create three simple callback methods that simply output the current time
    and a short message telling us which callback has been fired.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子让我们看到多个回调是如何与定时器交互的。第一个函数是 `format_time` 函数。它使用格式字符串语法将当前时间添加到消息中；我们将在下一章中了解它们。接下来，我们创建了三个简单的回调方法，它们只是输出当前时间和一个简短的消息，告诉我们哪个回调已经被触发。
- en: 'The `Repeater` class demonstrates that methods can be used as callbacks too,
    since they are really just functions that happen to be bound to an object. It
    also shows why the `timer` argument to the callback functions is useful: we can
    add a new timed event to the timer from inside a presently running callback. We
    then create a timer and add several events to it that are called after different
    amounts of time. Finally, we start the timer running; the output shows that events
    are run in the expected order:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Repeater`类演示了方法也可以用作回调，因为它们实际上只是绑定到对象的函数。它还展示了回调函数中的`timer`参数为什么有用：我们可以在当前运行的回调内部向计时器添加新的定时事件。然后，我们创建一个计时器，并向其添加几个在不同时间后调用的事件。最后，我们启动计时器；输出显示事件按预期顺序运行：'
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Python 3.4 introduced a generic event loop architecture similar to this.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.4引入了类似于这种通用事件循环架构。
- en: Using functions as attributes
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数作为属性
- en: 'One of the interesting effects of functions being objects is that they can
    be set as callable attributes on other objects. It is possible to add or change
    a function to an instantiated object, demonstrated as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作为对象的一个有趣效果是它们可以被设置为其他对象的可调用属性。可以向已实例化的对象添加或更改函数，如下所示：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This code creates a very simple class with a `print` method that doesn't tell
    us anything we didn't know. Then, we create a new function that tells us something
    we don't believe.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个非常简单的类，其中包含一个不告诉我们任何新信息的`print`方法。然后，我们创建了一个告诉我们一些我们不相信的新函数。
- en: 'When we call `print` on an instance of the `A` class, it behaves as expected.
    If we then set the `print` method to point at a new function, it tells us something
    different:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`A`类的实例上调用`print`时，它的行为符合预期。如果我们将`print`方法指向一个新函数，它会告诉我们一些不同的东西：
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It is also possible to replace methods on classes instead of objects, although,
    in that case, we have to add the `self` argument to the parameter list. This will
    change the method for all instances of that object, even ones that have already
    been instantiated. Obviously, replacing methods like this can be both dangerous
    and confusing to maintain. Somebody reading the code will see that a method has
    been called and look up that method on the original class. But the method on the
    original class is not the one that was called. Figuring out what really happened
    can become a tricky, frustrating debugging session.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以替换类的方法而不是对象的方法，尽管在这种情况下，我们必须将`self`参数添加到参数列表中。这将更改该对象的所有实例的方法，即使已经实例化了。显然，这样替换方法可能既危险又令人困惑。阅读代码的人会看到已调用一个方法，并查找原始类上的该方法。但原始类上的方法并不是被调用的方法。弄清楚到底发生了什么可能会变成一个棘手而令人沮丧的调试过程。
- en: It does have its uses though. Often, replacing or adding methods at runtime
    (called **monkey patching**) is used in automated testing. If testing a client-server
    application, we may not want to actually connect to the server while testing the
    client; this may result in accidental transfers of funds or embarrassing test
    emails being sent to real people. Instead, we can set up our test code to replace
    some of the key methods on the object that sends requests to the server so that
    it only records that the methods have been called.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，它确实有其用途。通常，在运行时替换或添加方法（称为**monkey patching**）在自动化测试中使用。如果测试客户端-服务器应用程序，我们可能不希望在测试客户端时实际连接到服务器；这可能导致意外转账或向真实人发送尴尬的测试电子邮件。相反，我们可以设置我们的测试代码，以替换发送请求到服务器的对象上的一些关键方法，以便它只记录已调用这些方法。
- en: Monkey-patching can also be used to fix bugs or add features in third-party
    code that we are interacting with, and does not behave quite the way we need it
    to. It should, however, be applied sparingly; it's almost always a *messy hack*.
    Sometimes, though, it is the only way to adapt an existing library to suit our
    needs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Monkey-patching也可以用于修复我们正在交互的第三方代码中的错误或添加功能，并且不会以我们需要的方式运行。但是，应该谨慎使用；它几乎总是一个*混乱的黑客*。不过，有时它是适应现有库以满足我们需求的唯一方法。
- en: Callable objects
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可调用对象
- en: Just as functions are objects that can have attributes set on them, it is possible
    to create an object that can be called as though it were a function.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如函数是可以在其上设置属性的对象一样，也可以创建一个可以像函数一样被调用的对象。
- en: 'Any object can be made callable by simply giving it a `__call__` method that
    accepts the required arguments. Let''s make our `Repeater` class, from the timer
    example, a little easier to use by making it a callable, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地给它一个接受所需参数的`__call__`方法，任何对象都可以被调用。让我们通过以下方式使我们的计时器示例中的`Repeater`类更易于使用：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This example isn''t much different from the earlier class; all we did was change
    the name of the `repeater` function to `__call__` and pass the object itself as
    a callable. Note that, when we make the `call_after` call, we pass the argument
    `Repeater()`. Those two parentheses are creating a new instance of the class;
    they are not explicitly calling the class. This happens later, inside the timer.
    If we want to execute the `__call__` method on a newly instantiated object, we''d
    use a rather odd syntax: `Repeater()()`. The first set of parentheses constructs
    the object; the second set executes the `__call__` method. If we find ourselves
    doing this, we may not be using the correct abstraction. Only implement the `__call__`
    function on an object if the object is meant to be treated like a function.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与之前的类并没有太大不同；我们只是将`repeater`函数的名称更改为`__call__`，并将对象本身作为可调用对象传递。请注意，当我们进行`call_after`调用时，我们传递了参数`Repeater()`。这两个括号创建了一个类的新实例；它们并没有显式调用该类。这发生在稍后，在计时器内部。如果我们想要在新实例化的对象上执行`__call__`方法，我们将使用一个相当奇怪的语法：`Repeater()()`。第一组括号构造对象；第二组执行`__call__`方法。如果我们发现自己这样做，可能没有使用正确的抽象。只有在对象需要被视为函数时才实现`__call__`函数。
- en: Case study
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: To tie together some of the principles presented in this chapter, let's build
    a mailing list manager. The manager will keep track of email addresses categorized
    into named groups. When it's time to send a message, we can pick a group and send
    the message to all email addresses assigned to that group.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将本章介绍的一些原则联系起来，让我们构建一个邮件列表管理器。该管理器将跟踪分类为命名组的电子邮件地址。当发送消息时，我们可以选择一个组，并将消息发送到分配给该组的所有电子邮件地址。
- en: 'Now, before we start working on this project, we ought to have a safe way to
    test it, without sending emails to a bunch of real people. Luckily, Python has
    our back here; like the test HTTP server, it has a built-in **Simple Mail Transfer
    Protocol** (**SMTP**) server that we can instruct to capture any messages we send
    without actually sending them. We can run the server with the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始这个项目之前，我们应该有一个安全的方法来测试它，而不是向一群真实的人发送电子邮件。幸运的是，Python 在这方面有所帮助；就像测试 HTTP
    服务器一样，它有一个内置的**简单邮件传输协议**（**SMTP**）服务器，我们可以指示它捕获我们发送的任何消息，而不实际发送它们。我们可以使用以下命令运行服务器：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Running this command at command prompt will start an SMTP server running on
    port 1025 on the local machine. But we've instructed it to use the `DebuggingServer`
    class (this class comes with the built-in SMTP module), which, instead of sending
    mails to the intended recipients, simply prints them on the terminal screen as
    it receives them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令提示符下运行此命令将在本地机器上的端口 1025 上启动运行 SMTP 服务器。但我们已经指示它使用`DebuggingServer`类（这个类是内置
    SMTP 模块的一部分），它不是将邮件发送给预期的收件人，而是在接收到邮件时简单地在终端屏幕上打印它们。
- en: 'Now, before writing our mailing list, let''s write some code that actually
    sends mail. Of course, Python supports this in the standard library, too, but
    it''s a bit of an odd interface, so we''ll write a new function to wrap it all
    cleanly, as can be seen in the following code snipet:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在编写我们的邮件列表之前，让我们编写一些实际发送邮件的代码。当然，Python 也支持这一点在标准库中，但它的接口有点奇怪，所以我们将编写一个新的函数来清晰地包装它，如下面的代码片段所示：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We won't cover the code inside this method too thoroughly; the documentation
    in the standard library can give you all the information you need to use the `smtplib`
    and `email` modules effectively.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过分深入讨论此方法内部的代码；标准库中的文档可以为您提供使用`smtplib`和`email`模块所需的所有信息。
- en: We've used both variable argument and keyword argument syntax in the function
    call. The variable argument list allows us to supply a single string in the default
    case of having a single `to` address, as well as permitting multiple addresses
    to be supplied if required. Any extra keyword arguments are mapped to email headers.
    This is an exciting use of variable arguments and keyword arguments, but it's
    not really a great interface for the person calling the function. In fact, it
    makes many things the programmer will want to do impossible.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数调用中使用了变量参数和关键字参数语法。变量参数列表允许我们在默认情况下提供单个`to`地址的字符串，并允许在需要时提供多个地址。任何额外的关键字参数都映射到电子邮件标头。这是变量参数和关键字参数的一个令人兴奋的用法，但实际上并不是对调用函数的人来说一个很好的接口。事实上，它使程序员想要做的许多事情都变得不可能。
- en: The headers passed into the function represent auxiliary headers that can be
    attached to a method. Such headers might include `Reply-To`, `Return-Path`, or
    *X-pretty-much-anything*. But in order to be a valid identifier in Python, a name
    cannot include the `-` character. In general, that character represents subtraction.
    So, it's not possible to call a function with `Reply-To``=``my@email.com`. As
    often happens, it appears we were too eager to use keyword arguments because they
    are a shiny new tool we just learned.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给函数的标头表示可以附加到方法的辅助标头。这些标头可能包括`Reply-To`、`Return-Path`或*X-pretty-much-anything*。但是为了在
    Python 中成为有效的标识符，名称不能包括`-`字符。一般来说，该字符表示减法。因此，不可能使用`Reply-To``=``my@email.com`调用函数。通常情况下，我们太急于使用关键字参数，因为它们是我们刚学会的一个闪亮的新工具。
- en: 'We''ll have to change the argument to a normal dictionary; this will work because
    any string can be used as a key in a dictionary. By default, we''d want this dictionary
    to be empty, but we can''t make the default parameter an empty dictionary. So,
    we''ll have to make the default argument `None`, and then set up the dictionary
    at the beginning of the method, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不将参数更改为普通字典；这将起作用，因为任何字符串都可以用作字典中的键。默认情况下，我们希望这个字典是空的，但我们不能使默认参数为空字典。因此，我们将默认参数设置为`None`，然后在方法的开头设置字典，如下所示：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If we have our debugging SMTP server running in one terminal, we can test this
    code in a Python interpreter:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一个终端中运行我们的调试 SMTP 服务器，我们可以在 Python 解释器中测试这段代码：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, if we check the output from the debugging SMTP server, we get the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们检查调试 SMTP 服务器的输出，我们会得到以下结果：
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Excellent, it has *sent* our email to the two expected addresses with subject
    and message contents included. Now that we can send messages, let's work on the
    email group management system. We'll need an object that somehow matches email
    addresses with the groups they are in. Since this is a many-to-many relationship
    (any one email address can be in multiple groups; any one group can be associated
    with multiple email addresses), none of the data structures we've studied seem
    ideal. We could try a dictionary of group names matched to a list of associated
    email addresses, but that would duplicate email addresses. We could also try a
    dictionary of email addresses matched to groups, resulting in a duplication of
    groups. Neither seems optimal. For fun, let's try this latter version, even though
    intuition tells me the groups to email address solution would be more straightforward.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，它已经*发送*了我们的电子邮件到两个预期地址，并包括主题和消息内容。现在我们可以发送消息了，让我们来完善电子邮件组管理系统。我们需要一个对象，以某种方式将电子邮件地址与它们所在的组匹配起来。由于这是多对多的关系（任何一个电子邮件地址可以在多个组中；任何一个组可以与多个电子邮件地址相关联），我们学习过的数据结构似乎都不太理想。我们可以尝试一个将组名与相关电子邮件地址列表匹配的字典，但这样会重复电子邮件地址。我们也可以尝试一个将电子邮件地址与组匹配的字典，这样会重复组。两者都不太理想。出于好玩，让我们尝试后一种版本，尽管直觉告诉我，将组与电子邮件地址的解决方案可能更加直接。
- en: 'Since the values in our dictionary will always be collections of unique email
    addresses, we can store them in a `set` container. We can use `defaultdict` to
    ensure that there is always a `set` container available for each key, demonstrated
    as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字典中的值始终是唯一电子邮件地址的集合，我们可以将它们存储在一个 `set` 容器中。我们可以使用 `defaultdict` 来确保每个键始终有一个
    `set` 容器可用，如下所示：
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let''s add a method that allows us to collect all the email addresses
    in one or more groups. This can be done by converting the list of groups to a
    set:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个方法，允许我们收集一个或多个组中的所有电子邮件地址。这可以通过将组列表转换为集合来完成：
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'First, look at what we''re iterating over: `self.email_map.items()`. This method,
    of course, returns a tuple of key-value pairs for each item in the dictionary.
    The values are sets of strings representing the groups. We split these into two
    variables named `e` and `g`, short for email and groups. We add the email address
    to the set of return values only if the passed-in groups intersect with the email
    address groups. The `g``&``groups` syntax is a shortcut for `g.intersection(groups)`;
    the `set` class does this by implementing the special `__and__` method to call
    `intersection`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，看一下我们正在迭代的内容：`self.email_map.items()`。当然，这个方法返回字典中每个项目的键值对元组。值是表示组的字符串集合。我们将这些拆分成两个变量，命名为
    `e` 和 `g`，分别代表电子邮件和组。只有当传入的组与电子邮件地址的组相交时，我们才将电子邮件地址添加到返回值的集合中。`g``&``groups` 语法是
    `g.intersection(groups)` 的快捷方式；`set` 类通过实现特殊的 `__and__` 方法来调用 `intersection`。
- en: This code could be made a wee bit more concise using a set comprehension, which
    we'll discuss in [Chapter 21](b9232138-1747-4f88-b7ac-002c40332e92.xhtml), *The
    Iterator Pattern*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合推导式可以使这段代码更加简洁，我们将在[第21章](b9232138-1747-4f88-b7ac-002c40332e92.xhtml) *迭代器模式*
    中讨论。
- en: 'Now, with these building blocks, we can trivially add a method to our `MailingList`
    class that sends messages to specific groups:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这些基本组件，我们可以轻松地向我们的 `MailingList` 类添加一个发送消息到特定组的方法：
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This function relies on variable argument lists. As input, it takes a list of
    groups as variable arguments. It gets the list of emails for the specified groups
    and passes those as variable arguments into `send_email`, along with other arguments
    that were passed into this method.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数依赖于可变参数列表。作为输入，它接受可变参数作为组的列表。它获取指定组的电子邮件列表，并将它们作为可变参数传递到 `send_email` 中，以及传递到这个方法中的其他参数。
- en: 'The program can be tested by ensuring that the SMTP debugging server is running
    in one command prompt, and, in a second prompt, loading the code using the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过确保 SMTP 调试服务器在一个命令提示符中运行，并在第二个提示符中使用以下命令加载代码来测试程序：
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create a `MailingList` object with the help of the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个 `MailingList` 对象：
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, create a few fake email addresses and groups, along the lines of:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一些虚假的电子邮件地址和组，如下所示：
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, use a command like this to send emails to specific groups:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用以下命令发送电子邮件到特定组：
- en: '[PRE57]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Emails to each of the addresses in the specified groups should show up in the
    console on the SMTP server.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 指定组中的每个地址的电子邮件应该显示在 SMTP 服务器的控制台上。
- en: The mailing list works fine as it is, but it's kind of useless; as soon as we
    exit the program, our database of information is lost. Let's modify it to add
    a couple of methods to load and save the list of email groups from and to a file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 邮件列表目前运行良好，但有点无用；一旦我们退出程序，我们的信息数据库就会丢失。让我们修改它，添加一些方法来从文件中加载和保存电子邮件组的列表。
- en: In general, when storing structured data on disk, it is a good idea to put a
    lot of thought into how it is stored. One of the reasons myriad database systems
    exist is that if someone else has put this thought into how data is stored, you
    don't have to. We'll be looking at some data serialization mechanisms in the next
    chapter, but for this example, let's keep it simple and go with the first solution
    that could possibly work.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当将结构化数据存储在磁盘上时，最好仔细考虑它的存储方式。存在众多数据库系统的原因之一是，如果其他人已经考虑过数据的存储方式，那么你就不必再去考虑。我们将在下一章中研究一些数据序列化机制，但在这个例子中，让我们保持简单，选择可能有效的第一个解决方案。
- en: The data format I have in mind is to store each email address followed by a
    space, followed by a comma-separated list of groups. This format seems reasonable,
    and we're going to go with it because data formatting isn't the topic of this
    chapter. However, to illustrate just why you need to think hard about how you
    format data on disk, let's highlight a few problems with the format.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我心目中的数据格式是存储每个电子邮件地址，后跟一个空格，再跟着一个逗号分隔的组列表。这个格式看起来是合理的，我们将采用它，因为数据格式化不是本章的主题。然而，为了说明为什么你需要认真考虑如何在磁盘上格式化数据，让我们强调一下这种格式的一些问题。
- en: First, the space character is technically legal in email addresses. Most email
    providers prohibit it (with good reason), but the specification defining email
    addresses says an email can contain a space if it is in quotation marks. If we
    are to use a space as a sentinel in our data format, we should technically be
    able to differentiate between that space and a space that is part of an email.
    We're going to pretend this isn't true, for simplicity's sake, but real-life data
    encoding is full of stupid issues like this.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，空格字符在技术上是电子邮件地址中合法的。大多数电子邮件提供商禁止它（有充分的理由），但定义电子邮件地址的规范说，如果在引号中，电子邮件可以包含空格。如果我们要在我们的数据格式中使用一个空格作为标记，我们应该在技术上能够区分该空格和电子邮件中的空格。为了简单起见，我们将假装这不是真的，但是现实生活中的数据编码充满了这样的愚蠢问题。
- en: 'Second, consider the comma-separated list of groups. What happens if someone
    decides to put a comma in a group name? If we decide to make commas illegal in
    group names, we should add validation to enforce such naming in our `add_to_group`
    method. For pedagogical clarity, we''ll ignore this problem too. Finally, there
    are many security implications we need to consider: can someone get themselves
    into the wrong group by putting a fake comma in their email address? What does
    the parser do if it encounters an invalid file?'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，考虑逗号分隔的组列表。如果有人决定在组名中放一个逗号会发生什么？如果我们决定在组名中将逗号设为非法字符，我们应该添加验证来强制在我们的`add_to_group`方法中执行这样的命名。为了教学上的清晰，我们也将忽略这个问题。最后，我们需要考虑许多安全性问题：有人是否可以通过在他们的电子邮件地址中放一个假逗号来将自己放入错误的组？如果解析器遇到无效文件会怎么做？
- en: The takeaway from this discussion is to try to use a data storage method that
    has been field tested, rather than designing our own data serialization protocols.
    There are a ton of bizarre edge cases you might overlook, and it's better to use
    code that has already encountered and fixed those edge cases.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从这次讨论中得出的要点是，尽量使用经过现场测试的数据存储方法，而不是设计我们自己的数据序列化协议。你可能会忽视很多奇怪的边缘情况，最好使用已经遇到并解决了这些边缘情况的代码。
- en: 'But forget that. Let''s just write some basic code that uses an unhealthy dose
    of wishful thinking to pretend this simple data format is safe, demonstrated as
    follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 但是忘了这些。让我们只写一些基本的代码，使用大量的一厢情愿来假装这种简单的数据格式是安全的，如下所示：
- en: '[PRE58]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The code to do this is as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作的代码如下：
- en: '[PRE59]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the `save` method, we open the file in a context manager and write the file
    as a formatted string. Remember the newline character; Python doesn't add that
    for us. The `load` method first resets the dictionary (in case it contains data
    from a previous call to `load`). It adds a call to the standard library `suppress`
    context manager, available as `from contextlib import suppress`. This context
    manager catches any I/O Errors and ignores them. Not the best error handling,
    but it's prettier than try...finally...pass.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在`save`方法中，我们在上下文管理器中打开文件并将文件写为格式化字符串。记住换行符；Python不会为我们添加它。`load`方法首先重置字典（以防它包含来自先前调用`load`的数据）。它添加了对标准库`suppress`上下文管理器的调用，可用作`from
    contextlib import suppress`。这个上下文管理器捕获任何I/O错误并忽略它们。这不是最好的错误处理，但比try...finally...pass更美观。
- en: Then, the load method uses the `for`...`in` syntax, which loops over each line
    in the file. Again, the newline character is included in the line variable, so
    we have to call `.strip()` to take it off. We'll learn more about such string
    manipulation in the next chapter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，load方法使用`for`...`in`语法，循环遍历文件中的每一行。同样，换行符包含在行变量中，所以我们必须调用`.strip()`来去掉它。我们将在下一章中学习更多关于这种字符串操作的知识。
- en: 'Before using these methods, we need to make sure the object has a `self.data_file`
    attribute, which can be done by modifying `__init__` as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些方法之前，我们需要确保对象有一个`self.data_file`属性，可以通过修改`__init__`来实现：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can test these two methods in the interpreter as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在解释器中测试这两种方法：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The resulting `addresses.db` file contains the following lines, as expected:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`addresses.db`文件包含如下行，如预期的那样：
- en: '[PRE62]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can also load this data back into a `MailingList` object successfully:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以成功地将这些数据加载回`MailingList`对象中：
- en: '[PRE63]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As you can see, I forgot to add the `load` command, and it might be easy to
    forget the `save` command as well. To make this a little easier for anyone who
    wants to use our `MailingList` API in their own code, let''s provide the methods
    to support a context manager:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我忘记了添加`load`命令，也可能很容易忘记`save`命令。为了让任何想要在自己的代码中使用我们的`MailingList` API的人更容易一些，让我们提供支持上下文管理器的方法：
- en: '[PRE64]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'These simple methods just delegate their work to load and save, but we can
    now write code like this in the interactive interpreter and know that all the
    previously stored addresses were loaded on our behalf, and that the whole list
    will be saved to the file when we are done:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的方法只是将它们的工作委托给加载和保存，但是现在我们可以在交互式解释器中编写这样的代码，并知道以前存储的所有地址都已经被加载，当我们完成时整个列表将被保存到文件中：
- en: '[PRE65]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Exercises
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: If you haven't encountered the `with` statements and context managers before,
    I encourage you, as usual, to go through your old code, find all the places where
    you were opening files, and make sure they are safely closed using the `with`
    statement. Look for places to write your own context managers as well. Ugly or
    repetitive `try`...`finally` clauses are a good place to start, but you may find
    them useful any time you need to do before and/or after tasks in context.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有遇到`with`语句和上下文管理器，我鼓励你像往常一样，浏览你的旧代码，找到所有打开文件的地方，并确保它们使用`with`语句安全关闭。还要寻找编写自己的上下文管理器的地方。丑陋或重复的`try`...`finally`子句是一个很好的起点，但你可能会发现在任何需要在上下文中执行之前和/或之后任务的地方都很有用。
- en: You've probably used many of the basic built-in functions before now. We covered
    several of them, but didn't go into a great deal of detail. Play with `enumerate`,
    `zip`, `reversed`, `any`, and `all`, until you know you'll remember to use them
    when they are the right tool for the job. The `enumerate` function is especially
    important, because not using it results in some pretty ugly `while` loops.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前已经使用过许多基本的内置函数。我们涵盖了其中几个，但没有详细讨论。尝试使用`enumerate`、`zip`、`reversed`、`any`和`all`，直到你记住在合适的时候使用它们为止。`enumerate`函数尤其重要，因为不使用它会导致一些非常丑陋的`while`循环。
- en: Also explore some applications that pass functions around as callable objects,
    as well as using the `__call__` method to make your own objects callable. You
    can get the same effect by attaching attributes to functions or by creating a
    `__call__` method on an object. In which case would you use one syntax, and when
    would it be more suitable to use the other?
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 还要探索一些将函数作为可调用对象传递的应用，以及使用`__call__`方法使自己的对象可调用。您可以通过将属性附加到函数或在对象上创建`__call__`方法来实现相同的效果。在哪种情况下会使用一种语法，什么时候更适合使用另一种语法呢？
- en: Our mailing list object could overwhelm an email server if there is a massive
    number of emails to be sent out. Try refactoring it so that you can use different
    `send_email` functions for different purposes. One such function could be the
    version we used here. A different version might put the emails in a queue to be
    sent by a server in a different thread or process. A third version could just
    output the data to the terminal, obviating the need for a dummy SMTP server. Can
    you construct the mailing list with a callback such that the `send_mailing` function
    uses whatever is passed in? It would default to the current version if no callback
    is supplied.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有大量邮件需要发送，我们的邮件列表对象可能会压倒邮件服务器。尝试重构它，以便你可以为不同的目的使用不同的`send_email`函数。其中一个函数可能是我们在这里使用的版本。另一个版本可能会将邮件放入队列，由不同的线程或进程发送。第三个版本可能只是将数据输出到终端，从而避免了需要虚拟的SMTP服务器。你能构建一个带有回调的邮件列表，以便`send_mailing`函数使用传入的任何内容吗？如果没有提供回调，它将默认使用当前版本。
- en: The relationship between arguments, keyword arguments, variable arguments, and
    variable keyword arguments can be a bit confusing. We saw how painfully they can
    interact when we covered multiple inheritance. Devise some other examples to see
    how they can work well together, as well as to understand when they don't.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 参数、关键字参数、可变参数和可变关键字参数之间的关系可能有点令人困惑。当我们涵盖多重继承时，我们看到它们如何痛苦地相互作用。设计一些其他示例，看看它们如何很好地协同工作，以及了解它们何时不起作用。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We covered a grab bag of topics in this chapter. Each represented an important
    non-object-oriented feature that is popular in Python. Just because we can use
    object-oriented principles does not always mean we should!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了一系列主题。每个主题都代表了Python中流行的重要非面向对象的特性。仅仅因为我们可以使用面向对象的原则，并不总是意味着我们应该这样做！
- en: However, we also saw that Python typically implements such features by providing
    a syntax shortcut to traditional object-oriented syntax. Knowing the object-oriented
    principles underlying these tools allows us to use them more effectively in our
    own classes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也看到Python通常通过提供语法快捷方式来实现这些功能，以传统的面向对象语法。了解这些工具背后的面向对象原则使我们能够更有效地在自己的类中使用它们。
- en: We discussed a series of built-in functions and file I/O operations. There are
    a whole bunch of different syntaxes available to us when calling functions with
    arguments, keyword arguments, and variable argument lists. Context managers are
    useful for the common pattern of sandwiching a piece of code between two method
    calls. Even functions are objects, and, conversely, any normal object can be made
    callable.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了一系列内置函数和文件I/O操作。在调用带参数、关键字参数和可变参数列表的函数时，我们有许多不同的语法可用。上下文管理器对于在两个方法调用之间夹入一段代码的常见模式非常有用。甚至函数本身也是对象，反之亦然，任何普通对象都可以被调用。
- en: 'In the next chapter, we''ll learn more about string and file manipulation,
    and even spend some time with one of the least object-oriented topics in the standard
    library: regular expressions.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于字符串和文件操作的知识，甚至花一些时间来了解标准库中最不面向对象的主题之一：正则表达式。
