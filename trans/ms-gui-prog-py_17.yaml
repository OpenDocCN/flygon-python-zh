- en: Embedding Data Plots with QtCharts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QtCharts嵌入数据图
- en: The world is full of data. From server logs to financial records, sensor telemetry
    to census statistics, there seems to be no end to the raw data that programmers
    are tasked to sift through and extract meaning from. In addition to this, nothing
    distills a set of raw data into meaningful information as effectively as a good
    chart or graph. While there are some great charting tools such as `matplotlib`
    available for Python, PyQt offers its own `QtCharts` library, which is a simple
    toolkit for constructing charts, graphs, and other data visualizations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 世界充满了数据。从服务器日志到财务记录，传感器遥测到人口普查统计数据，程序员们需要筛选和提取意义的原始数据似乎没有尽头。除此之外，没有什么比一个好的图表或图形更有效地将一组原始数据提炼成有意义的信息。虽然Python有一些很棒的图表工具，比如`matplotlib`，PyQt还提供了自己的`QtCharts`库，这是一个用于构建图表、图形和其他数据可视化的简单工具包。
- en: 'In this chapter, we''re going to explore data visualization using `QtCharts`
    in the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题中使用`QtCharts`进行数据可视化：
- en: Making a simple chart
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的图表
- en: Displaying real-time data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示实时数据
- en: Styling Qt charts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt图表样式
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In addition to the basic PyQt setup we''ve been using throughout the book,
    you will need to install PyQt support for the `QtCharts` library. This support
    is not part of the default PyQt install, but it can be easily installed from PyPI,
    as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在整本书中一直使用的基本PyQt设置之外，您还需要为`QtCharts`库安装PyQt支持。这种支持不是默认的PyQt安装的一部分，但可以通过PyPI轻松安装，如下所示：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You''ll also need the `psutil` library, which can be installed from PyPI. We
    already used this library in [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml),
    *Creating 2D Graphics with QPainter,* so if you have been through that chapter,
    then you should already have it. If not, it can be easily installed using the
    following command:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要`psutil`库，可以从PyPI安装。我们已经在[第12章](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml)中使用过这个库，*使用QPainter创建2D图形*，所以如果您已经阅读了那一章，那么您应该已经有了它。如果没有，可以使用以下命令轻松安装：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Finally, you may want to download the example code for this chapter from [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter14](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter14).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可能希望从[https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter14](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter14)下载本章的示例代码。
- en: Check out the following video to see the code in action: [http://bit.ly/2M5y67f](http://bit.ly/2M5y67f)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的运行情况：[http://bit.ly/2M5y67f](http://bit.ly/2M5y67f)
- en: Making a simple chart
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的图表
- en: In [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml), *Creating 2D Graphics
    with QPainter,* we created a CPU activity graph using the Qt graphics framework
    and the `psutil` library. While that approach to building a chart worked fine,
    it took a lot of work to create a rudimentary chart that lacked simple niceties
    such as axis labels, a title, or a legend. The `QtChart` library is also based
    on the Qt graphics framework, but simplifies the creation of a variety of feature-complete
    charts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml) *使用QPainter创建2D图形*中，我们使用Qt图形框架和`psutil`库创建了一个CPU活动图。虽然这种构建图表的方法效果很好，但是创建一个缺乏简单美观性的基本图表需要大量的工作。`QtChart`库也是基于Qt图形框架的，但简化了各种功能完备的图表的创建。
- en: To demonstrate how it works, we're going to build a more complete system monitoring
    program that includes several charts derived from data provided by the `psutil`
    library.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示它的工作原理，我们将构建一个更完整的系统监控程序，其中包括几个图表，这些图表是从`psutil`库提供的数据派生出来的。
- en: Setting up the GUI
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置GUI
- en: To begin our program, copy the Qt application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow,* to a new file called `system_monitor.py`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的程序，将Qt应用程序模板从[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml) *使用QMainWindow构建应用程序*复制到一个名为`system_monitor.py`的新文件中。
- en: 'At the top of the application, we need to import the `QtChart` library:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序的顶部，我们需要导入`QtChart`库：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We''re also going to need the `deque` class and the `psutil` library, just
    like we needed them in [Chapter 12](https://cdp.packtpub.com/mastering_gui_programming_with_python/wp-admin/post.php?post=37&action=edit#post_35), *Creating
    2D Graphics with QPainter*:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要`deque`类和`psutil`库，就像我们在[第12章](https://cdp.packtpub.com/mastering_gui_programming_with_python/wp-admin/post.php?post=37&action=edit#post_35)
    *使用QPainter创建2D图形*中所需要的那样：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our program will contain several charts, each in its own tab. So, we will create
    a tab widget in `MainWindow.__init__()` to hold all the charts:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序将包含几个图表，每个图表都在自己的选项卡中。因此，我们将在`MainWindow.__init__()`中创建一个选项卡小部件来容纳所有的图表：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that the main framework of the GUI is in place, we'll start creating our
    chart classes and adding them to the GUI.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在GUI的主要框架已经就位，我们将开始创建我们的图表类并将它们添加到GUI中。
- en: Building a disk usage chart
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建磁盘使用情况图
- en: The first chart we'll create is a bar chart for displaying the disk space used
    by each storage partition on the computer. Each detected partition will have a
    bar indicating what percentage of its space is being used.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的第一个图表是一个条形图，用于显示计算机上每个存储分区使用的磁盘空间。每个检测到的分区都将有一个条形表示其使用空间的百分比。
- en: 'Let''s start by creating a class for the chart:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为图表创建一个类开始：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The class is subclassed from the `QtChart.QChartView` class; this subclass of
    `QGraphicsView` is a widget that can display `QChart` objects. Just like the Qt
    graphics framework, the `QtChart` framework is based on a model-view design. In
    this case, the `QChart` object is analogous to a `QGraphicsScene` object, which
    will be attached to the `QChartView` object for display.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该类是从`QtChart.QChartView`类派生的；这个`QGraphicsView`的子类是一个可以显示`QChart`对象的小部件。就像Qt图形框架一样，`QtChart`框架也是基于模型-视图设计的。在这种情况下，`QChart`对象类似于`QGraphicsScene`对象，它将附加到`QChartView`对象以进行显示。
- en: 'Let''s create our `QChart` object, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的`QChart`对象，如下所示：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `QChart` object receives a title but, otherwise, doesn't require a lot of
    configuration; notice that it says nothing about being a bar chart either. Unlike
    other charting libraries you may have used, the `QChart` object doesn't determine
    what kind of chart we're creating. It's simply a container for data plots.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`QChart`对象接收一个标题，但是，除此之外，不需要太多的配置；请注意，它也没有说它是条形图。与您可能使用过的其他图表库不同，`QChart`对象不确定我们正在创建什么样的图表。它只是数据图的容器。'
- en: The actual type of chart is determined by adding one or more **series** objects
    to the chart. A series represents a single set of plotted data on a chart. `QtChart`
    contains many series classes, all derived from `QAbstractSeries`, each of which represents
    a different kind of chart style.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的图表类型是通过向图表添加一个或多个**系列**对象来确定的。一个系列代表图表上的单个绘制数据集。`QtChart`包含许多系列类，所有这些类都是从`QAbstractSeries`派生的，每个类代表不同类型的图表样式。
- en: 'Some of these classes are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些类如下：
- en: '| Class | Chart type | Useful for |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 图表类型 | 有用于 |'
- en: '| --- | --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `QLineSeries` | Straight-line plot | Points sampled from continuous data
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `QLineSeries` | 直线图 | 从连续数据中采样的点 |'
- en: '| `QSplineSeries` | Line plot, but with curves | Points sampled from continuous
    data |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `QSplineSeries` | 线图，但带有曲线 | 从连续数据中采样的点 |'
- en: '| `QBarSeries` | Bar chart | Comparing values by category |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `QBarSeries` | 条形图 | 按类别比较值 |'
- en: '| `QStackedBarSeries` | Stacked bar chart | Comparing subdivided values by
    category |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `QStackedBarSeries` | 堆叠条形图 | 按类别比较细分值 |'
- en: '| `QPieSeries` | Pie chart | Relative percentages |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `QPieSeries` | 饼图 | 相对百分比 |'
- en: '| `QScatterSeries` | Scatter Plot | Collections of points |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `QScatterSeries` | 散点图 | 点的集合 |'
- en: A complete list of available series types can be found at [https://doc.qt.io/qt-5/qtcharts-overview.html](https://doc.qt.io/qt-5/qtcharts-overview.html).
    Our chart will be comparing disk usage percentages across multiple partitions,
    so the most sensible type of series to use from among these options seems to be
    the `QBarSeries` class. Each partition will be a *category* that will have a single
    value (the usage percentage) associated with it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://doc.qt.io/qt-5/qtcharts-overview.html](https://doc.qt.io/qt-5/qtcharts-overview.html)找到可用系列类型的完整列表。我们的图表将比较多个分区的磁盘使用百分比，因此在这些选项中使用最合理的系列类型似乎是`QBarSeries`类。每个分区将是一个*类别*，并且将与之关联一个单个值（使用百分比）。
- en: 'Let''s create the `QBarSeries` class, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`QBarSeries`类，如下：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After creating the series object, we can add it to our chart using the `addSeries()`
    method. As you might suspect from the name of this method, we can actually add
    multiple series to the chart, and they don't all need to be of the same type.
    We could, for example, combine a bar and line series in the same chart. In our
    case, though, we're only going to have one series.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建系列对象后，我们可以使用`addSeries()`方法将其添加到我们的图表中。从这个方法的名称，您可能会怀疑，我们实际上可以将多个系列添加到图表中，它们不一定都是相同类型的。例如，我们可以在同一个图表中结合条形和线系列。但在我们的情况下，我们只会有一个系列。
- en: 'To append data to our series, we have to create something called a **bar set**:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要向我们的系列附加数据，我们必须创建一个称为**条形集**的东西：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Qt bar charts are designed to show data in categories, but also allow for different
    sets of data to be compared across those categories. For instance, if you wanted
    to compare the relative sales success of several of your company's products in
    various US cities, you could use the cities as your categories and create a bar
    set for each product.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Qt条形图旨在显示类别数据，但也允许比较这些类别中的不同数据集。例如，如果您想要比较公司产品在美国各个城市的相对销售成功情况，您可以使用城市作为类别，并为每种产品创建一个条形集。
- en: In our case, the categories are going to be the partitions on the system, and
    we have only one set of data that we want to see for each of those partitions
    – that is, the disk usage percent.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，类别将是系统上的分区，我们只有一个数据集要查看每个分区的数据 - 即磁盘使用百分比。
- en: 'So, we''ll create a single bar set to append to our series:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建一个要附加到我们系列的单个条形集：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `QBarSet` constructor takes a single argument, which represents the label
    for the dataset. This `QBarSet` object is the object to which we're going to append
    our actual data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`QBarSet`构造函数接受一个参数，表示数据集的标签。这个`QBarSet`对象是我们要附加实际数据的对象。'
- en: 'So, let''s go ahead and retrieve that data:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们继续检索数据：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code utilizes the `disk_partitions()` function of `pustil` to list all
    the writable partitions on the system (we aren't interested in read-only devices,
    such as optical drives, since their usage is irrelevant). For each partition,
    we use the `disk_usage()` function to retrieve a named tuple of information about
    disk usage. The `percent` property of this tuple contains the usage percentage
    of the disk, so we append that value to our bar set. We also append the device
    name of the partition to a list of partitions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码利用了`pustil`的`disk_partitions()`函数列出系统上所有可写的分区（我们对只读设备不感兴趣，例如光驱，因为它们的使用是无关紧要的）。对于每个分区，我们使用`disk_usage()`函数检索有关磁盘使用情况的命名元组信息。这个元组的`percent`属性包含磁盘使用百分比，因此我们将该值附加到我们的条形集。我们还将分区的设备名称附加到分区列表中。
- en: At this point, our chart contains a data series and can display the bars for
    the data. However, it would be difficult to extract much meaning from the chart
    because there would be no **axes** labeling the data. To fix this, we need to
    create a couple of axis objects to represent the *x* and *y *axes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的图表包含一个数据系列，并且可以显示数据的条形。但是，从图表中提取出很多意义将会很困难，因为没有**轴**来标记数据。为了解决这个问题，我们需要创建一对轴对象来表示*x*和*y*轴。
- en: 'We''ll start with the *x* axis, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从*x*轴开始，如下：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`QtCharts` offers different types of axis objects to handle different approaches
    to organizing data. Our *x* axis is made up of categories—one for each partition
    found on the computer – so, we''ve created a `QBarCategoryAxis` object to represent
    the *x* axis. To define the categories used, we pass a list of strings to the `append()`
    method.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`QtCharts`提供了不同类型的轴对象来处理组织数据的不同方法。我们的*x*轴由类别组成——每个类别代表计算机上找到的一个分区——因此，我们创建了一个`QBarCategoryAxis`对象来表示*x*轴。为了定义使用的类别，我们将一个字符串列表传递给`append()`方法。'
- en: It's important that the order of our categories matches the order in which data
    is appended to the bar set, since each data point is categorized according to
    its position in the series.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们的类别的顺序要与数据附加到条形集的顺序相匹配，因为每个数据点根据其在系列中的位置进行分类。
- en: Once created, an axis has to be attached both to the chart and to the series;
    this is because the chart needs to know about the axis object so that it can properly
    label and scale the axis. This is accomplished by passing the axis object to the
    chart's `setAxisX()` method. The series also needs to know about the axis object
    so that it can scale the plots correctly for the chart, which we accomplish by
    passing it to the series object's `attachAxis()` method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，轴必须同时附加到图表和系列上；这是因为图表需要了解轴对象，以便能够正确地标记和缩放轴。这是通过将轴对象传递给图表的`setAxisX()`方法来实现的。系列还需要了解轴对象，以便能够为图表正确地缩放绘图，我们通过将其传递给系列对象的`attachAxis()`方法来实现。
- en: 'Our *y* axis represents a percentage, so we''ll need an axis type that handles
    values between `0` and `100`. We will use a `QValueAxis` object for this, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的*y*轴表示百分比，所以我们需要一个处理`0`到`100`之间的值的轴类型。我们将使用`QValueAxis`对象，如下所示：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`QValueAxis` represents an axis that displays a scale of numeric values, and
    allows us to set an appropriate range for the values. Once created, we can attach
    it to both the chart and the series.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`QValueAxis`表示显示数字值刻度的轴，并允许我们为值设置适当的范围。创建后，我们可以将其附加到图表和系列上。'
- en: 'At this point, we can create an instance of our chart view object in `MainView.__init__()`
    and add it to the tab widget:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以在`MainView.__init__()`中创建图表视图对象的实例，并将其添加到选项卡小部件中：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you run the application at this point, you should get a display of your
    partition usage percentages:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时运行应用程序，您应该会得到分区使用百分比的显示：
- en: '![](assets/a5c9d296-9255-447f-bb1a-c03e0f2da444.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a5c9d296-9255-447f-bb1a-c03e0f2da444.png)'
- en: 'Your display will look slightly different, depending on your OS and drive configurations.
    The preceding diagram looks pretty good, but one small improvement we can make
    is to actually put percentage labels on our bars so that readers can see the precise
    data values. This can be done back in `DiskUsageChartView.__init__()` by adding
    the following line:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您的显示可能会有所不同，这取决于您的操作系统和驱动器配置。前面的图看起来很不错，但我们可以做一个小小的改进，即在我们的条形上实际放置百分比标签，以便读者可以看到精确的数据值。这可以通过在`DiskUsageChartView.__init__()`中添加以下行来完成：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now when we run the program, we get labeled bars, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们运行程序时，我们会得到带有标签的条形，如下所示：
- en: '![](assets/fa104c14-f8df-45ab-8620-39906e58bc21.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fa104c14-f8df-45ab-8620-39906e58bc21.png)'
- en: Well, it seems this author is due for a larger hard drive!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，看来这位作者需要一个更大的硬盘了！
- en: Displaying real-time data
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示实时数据
- en: Now that we have seen how easy it is to create a static chart, let's take a
    look at the process of creating a chart that updates in real time. Essentially,
    the process is the same, but we'll need to periodically update the chart's data
    series with fresh data. To demonstrate this, let's make a real-time CPU usage
    monitor.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了创建静态图表有多么容易，让我们来看看创建实时更新图表的过程。基本上，过程是相同的，但是我们需要定期使用新数据更新图表的数据系列。为了演示这一点，让我们制作一个实时CPU使用率监视器。
- en: Building a CPU usage chart
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建CPU使用率图表
- en: 'Let''s start our CPU monitor in a new class called `CPUUsageView`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个名为`CPUUsageView`的新类中启动我们的CPU监视器：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Just as we did with our disk usage chart, we're basing this class on `QChartView`
    and beginning the constructor by creating a `QChart` object. We've also defined
    a title, and, just as we did in [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml),
    *Creating 2D Graphics with QPainter*, configured a number of data points to display
    at one time. We're going to do a lot more points this time, though, so that we
    can get a more detailed chart.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在磁盘使用图表中所做的那样，我们基于`QChartView`创建了这个类，并在构造函数中创建了一个`QChart`对象。我们还定义了一个标题，并且，就像我们在[第12章](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml)中所做的那样，*使用QPainter创建2D图形*，配置了一次显示多少个数据点。不过这次我们要显示更多的点，这样我们就可以得到更详细的图表了。
- en: 'After creating the chart object, the next step is to create the series object:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图表对象后，下一步是创建系列对象：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, we're using the `QSplineSeries` object; we could have also used `QLineSeries`,
    but the spline version will connect our data point using cubic spline curves for
    a smooth appearance, which is similar to what we achieved using Bezier curves
    in [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml), *Creating 2D Graphics
    with QPainter*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用`QSplineSeries`对象；我们也可以使用`QLineSeries`，但是样条版本将使用三次样条曲线连接我们的数据点，使外观更加平滑，这类似于我们在[第12章](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml)中使用贝塞尔曲线所实现的效果，*使用QPainter创建2D图形*。
- en: 'Next, we need to populate the series object with some default data, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用一些默认数据填充系列对象，如下所示：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once again, we're creating a `deque` object to store the data points and filling
    it with zeros. We then append this data to our series by creating a list of `QPoint`
    objects from our `deque` object using a list comprehension. Unlike the `QBarSeries`
    class, data is appended directly to the `QSplineSeries` object; there is nothing
    analogous to the `QBarSet` class for line-based series.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次创建一个`deque`对象来存储数据点，并用零填充它。然后，我们通过使用列表推导式从我们的`deque`对象创建一个`QPoint`对象的列表，将这些数据附加到我们的系列中。与`QBarSeries`类不同，数据直接附加到`QSplineSeries`对象；对于基于线的系列，没有类似于`QBarSet`类的东西。
- en: 'Now that our series is set up, let''s work on the axes:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的系列已经设置好了，让我们来处理轴：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because our data is mostly (*x*, *y*) coordinates, both our axes are `QValueAxis`
    objects. However, the value of our *x* axis coordinate is essentially meaningless
    (it's just the index of the CPU usage value in the `deque` object), so we'll hide
    those labels by setting the axis's `labelsVisible` property to `False`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的数据主要是(*x*, *y*)坐标，我们的两个轴都是`QValueAxis`对象。然而，我们的*x*轴坐标的值基本上是没有意义的（它只是`deque`对象中CPU使用值的索引），因此我们将通过将轴的`labelsVisible`属性设置为`False`来隐藏这些标签。
- en: Note that this time, we passed the series object along with the axis when setting
    the chart's *x* and *y *axes with `setAxisX()` and `setAxisY`. Doing this automatically
    attaches the axis to the series as well, and saves us an extra method call for
    each axis.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次我们在使用`setAxisX()`和`setAxisY`设置图表的*x*和*y*轴时，将系列对象与轴一起传递。这样做会自动将轴附加到系列上，并为每个轴节省了额外的方法调用。
- en: 'Since we''re using curves here, we should make one appearance optimization:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这里使用曲线，我们应该进行一次外观优化：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `QChartView` object's `renderHint` property can be used to activate **anti-aliasing**,
    which will improve the smoothness of the spline curves.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`QChartView`对象的`renderHint`属性可用于激活**抗锯齿**，这将改善样条曲线的平滑度。'
- en: The basic framework for our chart is now complete; what we need now is a way
    to collect the data and update the series.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图表的基本框架现在已经完成；现在我们需要一种方法来收集数据并更新系列。
- en: Updating the chart data
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新图表数据
- en: 'Our first step in updating our data is to create a method that calls `psutil.cpu_percent()`
    and updates the `deque` object:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 更新数据的第一步是创建一个调用`psutil.cpu_percent()`并更新`deque`对象的方法：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To update the chart, we only need to update the data in the series. There are
    a couple of ways to do this; for example, we could completely remove all the data
    in the chart and `append()` new values.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新图表，我们只需要更新系列中的数据。有几种方法可以做到这一点；例如，我们可以完全删除图表中的所有数据，并`append()`新值。
- en: 'A better approach is to `replace()` the values, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是`replace()`值，如下所示：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, we generate a new set of `QPoint` objects from our `deque` object using
    a list comprehension, and then pass the list to the series object's `replace()`
    method, which swaps out all the data. This method is somewhat faster than wiping
    out all the data and repopulating the series, although either approach works.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用列表推导从我们的`deque`对象生成一组新的`QPoint`对象，然后将列表传递给系列对象的`replace()`方法，该方法交换所有数据。这种方法比清除所有数据并重新填充系列要快一些，尽管任何一种方法都可以。
- en: 'Now that we have the refresh method, we just need to call it periodically;
    back in `__init__()`, let''s add a timer:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了刷新方法，我们只需要定期调用它；回到`__init__()`，让我们添加一个定时器：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This timer will call `refresh_stats()` every `200` milliseconds, updating the
    series and, consequently, the chart.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定时器将每200毫秒调用`refresh_stats()`，更新系列，因此也更新了图表。
- en: 'Back in `MainView.__init__()`, let''s add our CPU chart:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`MainView.__init__()`，让我们添加CPU图表：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, you can run the application and click on the CPU Usage tab to see a chart
    that is similar to the following diagram:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以运行应用程序，单击CPU使用率选项卡，查看类似于以下图表的图表：
- en: '![](assets/57289362-6e4b-409f-bd5a-6d2d74860221.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/57289362-6e4b-409f-bd5a-6d2d74860221.png)'
- en: Try doing some CPU-intensive tasks to generate some interesting data for the
    chart.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试进行一些CPU密集型任务，为图表生成一些有趣的数据。
- en: Panning and zooming around the chart
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图表周围进行平移和缩放
- en: With our refresh method being called five times a second, the data in this series
    is pretty detailed for such a small chart. A dense chart such as this one is something
    a user might like to explore in more detail. To implement this capability, we
    can take advantage of the `QChart` object's methods for panning and zooming around
    the chart image, and allow the user to get a better view of the data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的刷新方法每秒调用五次，因此该系列中的数据对于这样一个小图表来说相当详细。这样密集的图表可能是用户希望更详细地探索的内容。为了实现这一功能，我们可以利用`QChart`对象的方法来在图表图像周围进行平移和缩放，并允许用户更好地查看数据。
- en: 'To configure interactive controls for the `CPUUsageView` class, we can override
    the `keyPressEvent()` method, just as we did in our game in [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml), *Creating
    2D Graphics with QPainter*:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`CPUUsageView`类配置交互控件，我们可以重写`keyPressEvent()`方法，就像我们在[第12章](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml)中的游戏中所做的那样，*使用QPainter创建2D图形*：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code is similar to the code that we used in our tank game—we create a `dict`
    object to map key codes to callback functions, and then check our event object
    to see whether one of the mapped keys was pressed. If it was, then we call the
    `callback` method.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们在坦克游戏中使用的代码类似——我们创建一个`dict`对象来将键码映射到回调函数，然后检查我们的事件对象，看看是否按下了其中一个映射的键。如果是的话，我们就调用`callback`方法。
- en: The first of these methods we've mapped is `QChart.scroll()`. `scroll()` takes
    *x* and *y *values and moves the chart within the chart view by that amount. Here,
    we've mapped the arrow keys to `lambda` functions, which scroll the chart appropriately.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们映射的第一个方法是`QChart.scroll()`。`scroll()`接受*x*和*y*值，并将图表在图表视图中移动相应的量。在这里，我们将箭头键映射到`lambda`函数，以适当地滚动图表。
- en: The other methods we've mapped are `zoomIn()` and `zoomOut()`. These do precisely
    what their names suggest, each zooming in or out by a factor of two. If we wanted
    to customize the amount of zoom, then we could alternately call the `zoom()` method,
    which takes a float value indicating the zoom factor.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们映射的其他方法是`zoomIn()`和`zoomOut()`。它们确切地执行它们的名称所暗示的操作，分别放大或缩小两倍。如果我们想要自定义缩放的量，那么我们可以交替调用`zoom()`方法，该方法接受一个表示缩放因子的浮点值。
- en: If you run this program now, you should find that you can move the chart around
    using the arrow keys and zoom in or out using the angle brackets (remember to
    press *Shift* on most keyboards to get an angle bracket).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行此程序，您应该会发现可以使用箭头键移动图表，并使用尖括号放大或缩小（请记住在大多数键盘上按*Shift*以获得尖括号）。
- en: Styling Qt charts
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt图表样式
- en: As good as Qt charts look by default, let's face it—nobody wants to be stuck
    with defaults when it comes to style. Fortunately, `QtCharts` offers a wide variety
    of options for styling the different components of our visualizations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Qt图表默认看起来很好，但让我们面对现实吧——在样式方面，没有人想被困在默认设置中。幸运的是，QtCharts为我们的可视化组件提供了各种各样的样式选项。
- en: To explore these options, we're going to build a third chart to show physical
    and swap memory usage, and then style it to our own preferences.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这些选项，我们将构建第三个图表来显示物理和交换内存使用情况，然后根据我们自己的喜好进行样式化。
- en: Building the memory chart
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建内存图表
- en: 'We''ll start this chart view object just like we started the others in the
    previous sections:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像在前面的部分中一样开始这个图表视图对象：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This class starts in a similar way to our disk usage chart – by subclassing
    `QChartView`, defining a chart, defining a series, and then defining some bar
    sets. This time, however, we are going to use `QStackedBarSeries`. The stacked
    bar is just like the regular bar chart, except that each bar set is stacked vertically
    rather than placed side by side. This kind of chart is useful for displaying a
    series of relative percentages, which is exactly what we're going to display.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的开始方式与我们的磁盘使用图表类似——通过子类化`QChartView`，定义图表，定义系列，然后定义一些条形集。然而，这一次，我们将使用`QStackedBarSeries`。堆叠条形图与常规条形图类似，只是每个条形集是垂直堆叠而不是并排放置。这种图表对于显示一系列相对百分比很有用，这正是我们要显示的。
- en: In this case, we're going to have two bar sets – one for physical memory usage
    and the other for swap memory usage, each as a percentage of the total memory
    (physical and swap). By using a stacked bar, the total memory usage will be represented
    by the bar height, while the individual segments will show the swap and physical
    components of that total.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将有两个条形集——一个用于物理内存使用，另一个用于交换内存使用，每个都是总内存（物理和交换）的百分比。通过使用堆叠条形图，总内存使用将由条形高度表示，而各个部分将显示该总内存的交换和物理组件。
- en: 'To hold our data, we''ll once again set up a `deque` object with the default
    data and append the data to the bar sets:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保存我们的数据，我们将再次使用`deque`对象设置默认数据，并将数据附加到条形集中：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This time, each data point in the `deque` object needs to have two values:
    the first for the physical data and the second for the swap. We''re representing
    this by using a two-tuple sequence for each data point.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，`deque`对象中的每个数据点需要有两个值：第一个是物理数据，第二个是交换数据。我们通过使用每个数据点的两元组序列来表示这一点。
- en: 'The next step, once again, is to set up our axes:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，再次是设置我们的轴：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, like the CPU usage chart, our *x* axis just represents the somewhat meaningless
    index number of the data, so we're just going to hide the labels. Our *y* axis,
    on the other hand, represents a percentage, so we'll set its range from `0` to
    `100`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，就像CPU使用图表一样，我们的*x*轴只表示数据的无意义索引号，所以我们只是要隐藏标签。另一方面，我们的*y*轴表示一个百分比，所以我们将其范围设置为`0`到`100`。
- en: 'Now, we''ll create our `refresh` method to update the chart data:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们的`refresh`方法来更新图表数据：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `psutil` library has two functions for examining memory usage: `virtual_memory()`,
    which returns information about the physical RAM; and `swap_memory()`, which returns
    information about the swap file usage. We're applying some basic arithmetic to
    find out the percentage of total memory (swap and physical) used by swap and physical
    memory. We then append this data to the `deque` object and iterate through it
    to replace the data in the bar sets.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`psutil`库有两个函数用于检查内存使用情况：`virtual_memory()`返回有关物理RAM的信息；`swap_memory()`返回有关交换文件使用情况的信息。我们正在应用一些基本算术来找出交换和物理内存使用的总内存百分比，然后将这些数据附加到`deque`对象中，并通过迭代来替换条形集中的数据。'
- en: 'Finally, we''ll add our timer back in `__init__()` to call the refresh method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将在`__init__()`中再次添加我们的定时器来调用刷新方法：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The chart view class should now be fully functional, so let's add it to the
    `MainWindow` class and test it out.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图表视图类现在应该是完全功能的，所以让我们将其添加到`MainWindow`类中并进行测试。
- en: 'To do this, add the following code in `MainWindow.__init__()`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，在`MainWindow.__init__()`中添加以下代码：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you run the program at this point, you should have a working memory usage
    monitor that updates once per second. It's nice, but it looks too default-like;
    so, let's style things up a bit.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时运行程序，应该会有一个每秒更新一次的工作内存使用监视器。这很好，但看起来太像默认设置了；所以，让我们稍微调整一下样式。
- en: Chart styling
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图表样式
- en: To give our memory chart a healthy dose of individuality, let's head back up
    to `MemoryChartView.__init__()` and start adding in code to style the various
    elements of the chart.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给我们的内存图表增添一些个性，让我们回到`MemoryChartView.__init__()`，开始添加代码来样式化图表的各个元素。
- en: 'One of the easiest, yet most interesting, changes that we can make is to activate
    the chart''s built-in animations:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的最简单但最有趣的改变之一是激活图表的内置动画：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `QChart` object's `animationOptions` property determines which of the built-in
    chart animations will be run when the chart is created or updated. The options
    include `GridAxisAnimations`, which animate the drawing of the axes; `SeriesAnimations`,
    which animate updates to the series data; `AllAnimations`, which we've used here
    to activate both grid and series animations; and `NoAnimations`, which, as you
    might guess, is used to turn all the animations off (this is, of course, the default).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`QChart`对象的`animationOptions`属性确定图表创建或更新时将运行哪些内置图表动画。选项包括`GridAxisAnimations`，用于动画绘制轴；`SeriesAnimations`，用于动画更新系列数据；`AllAnimations`，我们在这里使用它来激活网格和系列动画；以及`NoAnimations`，你可能猜到了，用于关闭所有动画（当然，这是默认设置）。'
- en: 'If you run the program now, you''ll see that the grid and axes sweep into place
    and each bar pops up from the bottom of the chart in a smooth animation. The animations
    themselves are preset for each series type; note that we can''t do much to customize
    them other than set the easing curve and duration:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行程序，你会看到网格和轴扫过来，并且每个条形从图表底部平滑地弹出。动画本身是预设的每个系列类型；请注意，我们除了设置缓和曲线和持续时间外，无法对其进行自定义：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we've set the chart's `animationEasingCurve` property to a `QtCore.QEasingCurve`
    object with an *out bounce* easing curve. We've also slowed the animation time
    to a full second. If you run the program now, you'll see the animations bounce
    and last slightly longer.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将图表的`animationEasingCurve`属性设置为一个具有*out bounce*缓和曲线的`QtCore.QEasingCurve`对象。我们还将动画时间延长到整整一秒。如果你现在运行程序，你会看到动画会反弹并持续时间稍长。
- en: 'Another simple tweak we can make is enabling the chart''s drop shadow, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过启用图表的阴影来进行另一个简单的调整，如下所示：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Setting `dropShadowEnabled` to `True` will cause a drop shadow to be displayed
    around the chart's plot area, giving it a subtle 3D effect.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将`dropShadowEnabled`设置为`True`将导致在图表绘图区域周围显示一个阴影，给它一个微妙的3D效果。
- en: 'A more dramatic change in appearance comes by setting the chart''s `theme`
    property, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置图表的`theme`属性，我们可以实现外观上的更明显的变化，如下所示：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Although this is called a chart theme, it mainly affects the colors used for
    the plots. Qt 5.12 ships with eight chart themes, which can be found at [https://doc.qt.io/qt-5/qchart.html#ChartTheme-enum](https://doc.qt.io/qt-5/qchart.html#ChartTheme-enum).
    Here, we've configured the *Brown Sand* theme, which will utilize earth tones
    for our data plots.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这被称为图表主题，但它主要影响了绘图所使用的颜色。Qt 5.12附带了八种图表主题，可以在[https://doc.qt.io/qt-5/qchart.html#ChartTheme-enum](https://doc.qt.io/qt-5/qchart.html#ChartTheme-enum)找到。在这里，我们配置了*Brown
    Sand*主题，它将使用土地色调来展示我们的数据绘图。
- en: In the case of our stacked bar chart, this means each part of the stack will
    get a different color from the theme.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的堆叠条形图，这意味着堆栈的每个部分将从主题中获得不同的颜色。
- en: 'Another very noticeable change we can make is done by setting the chart''s
    background. This can be done by setting the `backgroundBrush` property to a custom
    `QBrush` object:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置图表的背景来进行另一个非常显著的改变。这可以通过将`backgroundBrush`属性设置为自定义的`QBrush`对象来实现：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this case, we've created a linear gradient and used it to create a `QBrush`
    object for the background (see [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml),
    *Styling Qt Applications,* for more discussion on this).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建了一个线性渐变，并使用它来创建了一个背景的`QBrush`对象（有关更多讨论，请参阅[第6章](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml)，*Qt应用程序的样式*）。
- en: 'The background also has a `QPen` object, which is used to draw the border around
    the plot area:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 背景也有一个`QPen`对象，用于绘制绘图区域的边框：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you run the program at this point, you might find the text a little hard
    to read. Unfortunately, there isn''t an easy way to update the look of all the
    text in the chart at once – we need to do it piece by piece. We can start with
    the chart''s title text by setting the `titleBrush` and `titleFont` properties,
    as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行程序，可能会发现文字有点难以阅读。不幸的是，没有一种简单的方法可以一次更新图表中所有的文字外观 - 我们需要逐个进行。我们可以从图表的标题文字开始，通过设置`titleBrush`和`titleFont`属性来实现：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Fixing the rest of the text cannot be done through the `chart` object. For that,
    we need to look at styling the other objects in the chart.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 修复剩下的文字不能通过`chart`对象完成。为此，我们需要查看如何对图表中的其他对象进行样式设置。
- en: Styling axes
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修饰轴
- en: 'The font and color of the labels used on the chart''s axes must be set through
    our axis''s objects:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图表轴上使用的标签的字体和颜色必须通过我们的轴对象进行设置：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we've set the *y* axis font and color by using the `setLabelsFont()` and
    `setLabelsBrush()` methods, respectively. Note that we could set the *x* axis
    label font and color as well, but there isn't much point since we're not showing
    the *x *labels.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`setLabelsFont()`和`setLabelsBrush()`方法分别设置了*y*轴的字体和颜色。请注意，我们也可以设置*x*轴标签的字体和颜色，但由于我们没有显示*x*标签，所以没有太大意义。
- en: 'The axis objects also give us access to styling our grid lines, using the `gridLinePen`
    property:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 轴对象还可以让我们通过`gridLinePen`属性来设置网格线的样式：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, we''ve set up a dashed silver `QPen` object to draw the grid lines of
    our *x* and *y *axes. Incidentally, if you want to change how many grid lines
    are drawn on the chart, that can be done by setting the axis object''s `tickCount`
    property:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了一个虚线银色的`QPen`对象来绘制*x*和*y*轴的网格线。顺便说一句，如果你想改变图表上绘制的网格线数量，可以通过设置轴对象的`tickCount`属性来实现：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The default tick count is `5`, and the minimum is `2`. Note that this number
    includes the top and bottom lines, so to have a grid line at every 10 percent,
    we've set the axis to `11` ticks.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的刻度数是`5`，最小值是`2`。请注意，这个数字包括顶部和底部的线，所以为了让网格线每10%显示一条，我们将轴设置为`11`个刻度。
- en: 'To help users distinguish between tightly-packed grid lines, we can also enable
    **shades** on the axis object:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助用户区分紧密排列的网格线，我们还可以在轴对象上启用**阴影**：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, if you run the application, this causes every alternate region
    between the grid lines to be shaded according to the configured color rather than
    using the default background.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果你运行应用程序，这会导致网格线之间的每个交替区域根据配置的颜色进行着色，而不是使用默认的背景。
- en: Styling the legend
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修饰图例
- en: The final thing that we might want to fix in this chart is the **legend**. This
    is the part of the chart that explains which color goes with which bar set. The
    legend is represented by a `QLegend` object, which is automatically created and
    updated by the `QChart` object as we add bar sets or series objects.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中我们可能想要修复的最后一件事是**图例**。这是图表中解释哪种颜色对应哪个条形集的部分。图例由`QLegend`对象表示，它会随着我们添加条形集或系列对象而自动创建和更新。
- en: 'We can retrieve the chart''s `QLegend` object using the `legend()` accessor
    method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`legend()`访问器方法来检索图表的`QLegend`对象：
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'By default, the legend doesn''t have a background and simply draws directly
    on the chart background. We can change that to improve readability, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，图例没有背景，只是直接绘制在图表背景上。我们可以改变这一点以提高可读性，如下所示：
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We first turn on the background by setting `backgroundVisible` to `True` and
    then configuring a brush for the background by setting the `brush` property to
    a `QBrush` object.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过将`backgroundVisible`设置为`True`来打开背景，然后通过将`brush`属性设置为`QBrush`对象来配置背景的刷子。
- en: 'The color and font of the text can also be configured, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 文本的颜色和字体也可以进行配置，如下所示：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can set the label color using `setLabelColor()`, or use a brush for finer
    control using the `setLabelBrush()` method.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`setLabelColor()`设置标签颜色，或者使用`setLabelBrush()`方法更精细地控制刷子。
- en: 'Finally, we can configure the shape of the markers that are used to indicate
    the colors:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以配置用于指示颜色的标记的形状：
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The options here include `MarkerShapeCircle`, `MarkerShapeRectangle`, and `MarkerShapeFromSeries`,
    the last of which chooses a shape that is appropriate to the series being drawn
    (for example, a short line for line or spline plots, or a dot for scatter plots).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的选项包括`MarkerShapeCircle`，`MarkerShapeRectangle`和`MarkerShapeFromSeries`，最后一个选择适合正在绘制的系列的形状（例如，线条或样条图的短线，或散点图的点）。
- en: 'At this point, your memory chart should look something like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的内存图表应该看起来像这样：
- en: '![](assets/039075c6-d675-44f1-84d3-393b24627858.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/039075c6-d675-44f1-84d3-393b24627858.png)'
- en: Not bad! Now, try your own color, brush, pen, and font values to see what you
    can create!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 不错！现在，尝试使用自己的颜色、刷子、笔和字体值，看看您能创造出什么！
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to visualize data using `QtChart`. You created
    a static table, an animated real-time table, and a fancy chart with custom colors
    and fonts. You also learned how to create bar charts, stacked bar charts, and
    spline charts.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何使用`QtChart`可视化数据。您创建了一个静态表格，一个动画实时表格，以及一个带有自定义颜色和字体的花哨图表。您还学会了如何创建柱状图、堆叠柱状图和样条图。
- en: In the next chapter, we're going to explore the use of PyQt on the Raspberry
    Pi. You'll learn how to install a recent version of PyQt and how to interface
    your PyQt applications with circuits and external hardware using the unique capabilities
    of the Pi.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨在树莓派上使用PyQt的用法。您将学习如何安装最新版本的PyQt，以及如何利用树莓派的独特功能将您的PyQt应用程序与电路和外部硬件进行接口。
- en: Questions
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge on this chapter:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些问题来测试您对本章的了解：
- en: 'Consider the following descriptions of datasets. Suggest a style of chart for
    each:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑以下数据集的描述。为每个数据集建议一种图表样式：
- en: Web server hit counts by date
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按日期的Web服务器点击次数
- en: Sales figures by salesperson per month
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个销售人员每月的销售数据
- en: The percentage of support tickets for the past year by a company department
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公司部门过去一年的支持票比例
- en: The yield of a plot of bean plants against the plant's height, for several hundred
    plants
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几百株豆类植物的产量与植物高度的图表
- en: Which chart component has not been configured in the following code, and what
    will the result be?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码中尚未配置哪个图表组件，结果将是什么？
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: What's wrong with the following code?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码有什么问题？
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You want to create a bar chart comparing Bob and Alice''s sales figures for
    the quarter. What code needs to be added? Note that axes are not required here:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您想创建一个柱状图，比较鲍勃和爱丽丝本季度的销售数据。需要添加什么代码？请注意，这里不需要轴：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Given a `QChart` object named `chart`, write some code so that the chart has
    a black background and blue data plots.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个名为`chart`的`QChart`对象，写一些代码，使图表具有黑色背景和蓝色数据绘图。
- en: Style the other two charts in the system monitor script using the techniques
    you used for the `Memory Usage` chart. Experiment with different brushes and pens,
    and see whether you can find other properties to set.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您为`内存使用情况`图表使用的技术为系统监视器脚本中的另外两个图表设置样式。尝试不同的刷子和笔，看看是否可以找到其他要设置的属性。
- en: '`QPolarChart` is a subclass of `QChart`, which allows you to construct a polar
    chart. Investigate the use of the polar chart in the Qt documentation and see
    whether you can create a polar chart of an appropriate dataset.'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QPolarChart`是`QChart`的一个子类，允许您构建极坐标图。在Qt文档中调查极坐标图的使用，并查看是否可以创建一个适当数据集的极坐标图。'
- en: '`psutil.cpu_percent()` takes an optional argument, `percpu`, which will create
    a list of values showing usage information per CPU core. Update your application
    to use this option and separately display each CPU core''s activity on one chart.'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`psutil.cpu_percent()`接受一个可选参数`percpu`，它将创建一个显示每个CPU核使用信息的值列表。更新您的应用程序以使用此选项，并分别在一个图表上显示每个CPU核的活动。'
- en: Further reading
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For further information, please refer to the following links:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参考以下链接：
- en: The `QtCharts` overview can be found at [https://doc.qt.io/qt-5/qtcharts-index.html](https://doc.qt.io/qt-5/qtcharts-index.html)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QtCharts`概述可以在[https://doc.qt.io/qt-5/qtcharts-index.html](https://doc.qt.io/qt-5/qtcharts-index.html)找到'
- en: More documentation on the `psutil` library can be found at [https://psutil.readthedocs.io/en/latest/](https://psutil.readthedocs.io/en/latest/)
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`psutil`库的更多文档可以在[https://psutil.readthedocs.io/en/latest/](https://psutil.readthedocs.io/en/latest/)找到'
- en: This guide from the University of California at Berkeley offers some guidelines
    for choosing the right kind of plot for different types of data: [http://guides.lib.berkeley.edu/data-visualization/type](http://guides.lib.berkeley.edu/data-visualization/type)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加州大学伯克利分校的这篇指南为不同类型的数据选择合适的图表提供了一些指导：[http://guides.lib.berkeley.edu/data-visualization/type](http://guides.lib.berkeley.edu/data-visualization/type)
