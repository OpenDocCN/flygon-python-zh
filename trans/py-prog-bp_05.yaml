- en: Building a Web Messenger with Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用微服务构建Web Messenger
- en: In today's application development world, Microservices have become the standard
    in designing and architecting distributed systems. Companies like Netflix have
    pioneered this shift and revolutionized the way in which software companies operate,
    from having small autonomous teams to designing systems that scale with ease.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的应用程序开发世界中，微服务已成为设计和构建分布式系统的标准。像Netflix这样的公司开创了这一变革，并从拥有小型自治团队到设计轻松扩展的系统的方式，彻底改变了软件公司的运营方式。
- en: In this chapter, I will guide you through the process of creating two microservices
    that will work together to make a messaging web application that uses Redis as
    a datastore. Messages will automatically expire after a configurable amount of
    time, so for the purpose of this chapter, let's call it TempMessenger.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将指导您完成创建两个微服务的过程，这两个微服务将共同工作，创建一个使用Redis作为数据存储的消息传递Web应用程序。消息在可配置的时间后会自动过期，因此在本章中，让我们称其为TempMessenger。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is Nameko?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Nameko？
- en: Creating your first Nameko microservice
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个Nameko微服务
- en: Storing messages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储消息
- en: Nameko Dependency Providers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nameko依赖提供程序
- en: Saving messages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存消息
- en: Retrieving all messages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索所有消息
- en: Displaying messages in the web browser
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Web浏览器中显示消息
- en: Sending messages via `POST` requests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`POST`请求发送消息
- en: Browser polling for messages
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器轮询消息
- en: TempMessenger Goals
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TempMessenger目标
- en: 'Before starting, let''s define some goals for our application:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们为我们的应用定义一些目标：
- en: A user can go to a website and send messages
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以访问网站并发送消息
- en: A user can see messages that others have sent
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以查看其他人发送的消息
- en: Messages automatically expire after a configurable amount of time
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息在可配置的时间后会自动过期
- en: To achieve this, we will be using Nameko - A microservices framework for Python.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用Nameko - 一个用于Python的微服务框架。
- en: 'If at any point during this chapter you would like to refer to all of the code
    in this chapter in its entirety, feel free to see it, with tests, at: [http://url.marcuspen.com/github-ppb](http://url.marcuspen.com/github-ppb).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在本章的任何时候，您想要参考本章中的所有代码，请随时查看：[http://url.marcuspen.com/github-ppb](http://url.marcuspen.com/github-ppb)。
- en: Requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: 'In order to partake in this chapter, your local machine will need the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了参与本章，您的本地计算机将需要以下内容：
- en: An internet connection
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: Docker - If you haven't installed Docker already, see the official documentation: [http://url.marcuspen.com/docker-install](http://url.marcuspen.com/docker-install)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker - 如果您尚未安装Docker，请参阅官方文档：[http://url.marcuspen.com/docker-install](http://url.marcuspen.com/docker-install)
- en: All other requirements will be installed as we progress through the chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本章中的进展，所有其他要求都将被安装。
- en: All instructions in this chapter are tailored towards macOS or Debian/Ubuntu
    systems. I have, however,  taken care to only use cross-platform dependencies.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有说明都针对macOS或Debian/Ubuntu系统。但是，我已经注意到只使用跨平台依赖项。
- en: 'Throughout this chapter, there will be blocks of code. Different types of code
    will have their own prefixes, which are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将会有代码块。不同类型的代码将有它们自己的前缀，如下所示：
- en: '`$`: To be executed in your terminal, always within your virtualenv'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`：在您的终端中执行，始终在您的虚拟环境中'
- en: '`>>>`: To be executed in your Nameko/Python shell'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>>`：在您的Nameko/Python shell中执行'
- en: 'No prefix: Block of Python code to be used in your editor'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 无前缀：要在您的编辑器中使用的Python代码块
- en: What is Nameko?
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Nameko？
- en: Nameko is an open-source framework used for building microservices in Python.
    Using Nameko, you can create microservices that communicate with each other using
    **RPC** (**Remote Procedure Calls**) via **AMQP** (**Advanced Message Queueing
    Protocol**).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Nameko是一个用于构建Python微服务的开源框架。使用Nameko，您可以创建使用**AMQP**（**高级消息队列协议**）通过**RPC**（**远程过程调用**）相互通信的微服务。
- en: RPCs
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPC
- en: 'RPC stands for Remote Procedure Call, and I''ll briefly explain this with a
    short example based on a cinema booking system. Within this cinema booking system,
    there are many microservices, but we will focus on the booking service, which
    is responsible for managing bookings, and the email service, which is responsible
    for sending emails. The booking service and email service both exist on different
    machines and both are unaware of where the other one is. When making a new booking,
    the booking service needs to send an email confirmation to the user, so it makes
    a Remote Procedure Call to the email service, which could look something like
    this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: RPC代表远程过程调用，我将用一个基于电影院预订系统的简短示例来简要解释这一点。在这个电影院预订系统中，有许多微服务，但我们将专注于预订服务，它负责管理预订，以及电子邮件服务，它负责发送电子邮件。预订服务和电子邮件服务都存在于不同的机器上，并且都不知道对方在哪里。在进行新预订时，预订服务需要向用户发送电子邮件确认，因此它对电子邮件服务进行远程过程调用，可能看起来像这样：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice in the preceding code how the booking service makes the call as if it
    were executing code that was local to it? It does not care about the network or
    the protocol and it doesn''t even give details on which email address it needs
    to send it to. For the booking service, email addresses and any other email related
    concepts are irrelevant! This allows the booking service to adhere to the **Single
    Responsibility Principle**, a term introduced by Robert C. Martin in his article
    *Principles of Object Orientated Design* ([http://url.marcuspen.com/bob-ood](http://url.marcuspen.com/bob-ood)),
    which states that:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在上述代码中，预订服务如何进行调用，就好像它在本地执行代码一样？它不关心网络或协议，甚至不提供需要发送到哪个电子邮件地址的详细信息。对于预订服务来说，电子邮件地址和任何其他与电子邮件相关的概念都是无关紧要的！这使得预订服务能够遵守**单一责任原则**，这是由Robert
    C. Martin在他的文章*面向对象设计原则*（[http://url.marcuspen.com/bob-ood](http://url.marcuspen.com/bob-ood)）中介绍的一个术语，该原则规定：
- en: '"A Class should have only one reason to change"'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: “一个类应该只有一个变化的原因”
- en: The scope of this quote can also be extended to microservices, and is something
    we should keep in mind when developing them. This will allow us to keep our microservices
    self-contained and cohesive. If the cinema decided to change its email provider,
    then the only service that should need to change is the email service, keeping
    the work required minimal, which in turn reduces the risk of bugs and possible
    downtime.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个引用的范围也可以扩展到微服务，并且在开发它们时我们应该牢记这一点。这将使我们能够保持我们的微服务自包含和内聚。如果电影院决定更改其电子邮件提供商，那么唯一需要更改的服务应该是电子邮件服务，从而最小化所需的工作量，进而减少错误和可能的停机时间的风险。
- en: However, RPCs do have their downsides when compared to other techniques such
    as REST, the main one being that it can be hard to see when a call is remote.
    One could make unnecessary remote calls without realizing it, which can be expensive
    since they go over the network and use external resources. So when using RPCs,
    it's important to make them visibly different.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与其他技术（如REST）相比，RPC确实有其缺点，主要是很难看出调用是否是远程的。一个人可能在不知情的情况下进行不必要的远程调用，这可能很昂贵，因为它们需要通过网络并使用外部资源。因此，在使用RPC时，重要的是要使它们在视觉上有所不同。
- en: How Nameko uses AMQP
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nameko如何使用AMQP
- en: AMQP stands for Advanced Message Queueing Protocol, which is used by Nameko
    as the transport for our RPCs. When our Nameko services make RPCs to each other,
    the requests are placed on the messaging queue, which are then consumed by the
    destination service. Nameko services use workers to consume and carry out requests;
    when an RPC is made, the target service will spawn a new worker to carry out the
    task. Once it's complete, it dies. Since there can be multiple workers executing
    tasks simultaneously, Nameko can scale up to the amount of workers it has available.
    If all workers are exhausted, then messages will stay on the queue until a free
    worker is available.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: AMQP代表高级消息队列协议，Nameko将其用作RPC的传输。当我们的Nameko服务相互进行RPC时，请求被放置在消息队列中，然后被目标服务消耗。Nameko服务使用工作程序来消耗和执行请求；当进行RPC时，目标服务将生成一个新的工作程序来执行任务。任务完成后，工作程序就会终止。由于可以有多个工作程序同时执行任务，Nameko可以扩展到其可用的工作程序数量。如果所有工作程序都被耗尽，那么消息将保留在队列中，直到有空闲的工作程序可用。
- en: You can also scale Nameko horizontally by increasing the amount of instances
    running your service. This is known as clustering, which is also where the name
    *Nameko* originates, since Nameko mushrooms grow in clusters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过增加运行服务的实例数量来水平扩展Nameko。这被称为集群，也是*Nameko*名称的由来，因为Nameko蘑菇是成簇生长的。
- en: Nameko can also respond to requests from other protocols such as HTTP and websockets.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Nameko还可以响应来自其他协议（如HTTP和Websockets）的请求。
- en: RabbitMQ
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RabbitMQ
- en: RabbitMQ is used as the message broker for Nameko and allows it to utilize AMQP.
    Before we start, you will need to install it on your machine; to do so, we will
    use Docker, which is available on all major operating systems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ被用作Nameko的消息代理，并允许其利用AMQP。在开始之前，您需要在您的机器上安装它；为此，我们将使用Docker，在所有主要操作系统上都可用。
- en: For those new to Docker, it allows us to run our code in a standalone, self-contained
    environment called a container. Within a container is everything that is required
    for that code to run independently from anything else. You can also download and
    run pre-built containers, which is how we are going to run RabbitMQ. This saves
    us from installing it on our local machine and minimizes the amount of issues
    that can arise from running RabbitMQ on different platforms such as macOS or Windows.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不熟悉Docker的人来说，它允许我们在一个独立的、自包含的环境中运行我们的代码，称为容器。容器中包含了代码独立运行所需的一切。您还可以下载和运行预构建的容器，这就是我们将要运行RabbitMQ的方式。这样可以避免在本地机器上安装它，并最大程度地减少在不同平台（如macOS或Windows）上运行RabbitMQ时可能出现的问题。
- en: If you do not already have Docker installed, please visit [http://url.marcuspen.com/docker-install](http://url.marcuspen.com/docker-install)
    where there are detailed installation instructions for all platforms. The rest
    of this chapter will assume that you already have Docker installed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装Docker，请访问[http://url.marcuspen.com/docker-install](http://url.marcuspen.com/docker-install)获取详细的安装说明。本章的其余部分将假定您已经安装了Docker。
- en: Starting a RabbitMQ container
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动RabbitMQ容器
- en: 'In your terminal, execute the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的终端中执行以下命令：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will start a RabbitMQ container with the following setup:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用以下设置启动一个RabbitMQ容器：
- en: '`-d`: Specifies we want to run the container in daemon mode (background process).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：指定我们要在守护进程模式（后台进程）下运行容器。'
- en: '`-p`: Allows us to expose ports `5672` and `15672` on the container to our
    local machine. These are needed for Nameko to communicate with RabbitMQ.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`：允许我们在容器上将端口`5672`和`15672`暴露到本地机器。这些端口是Nameko与RabbitMQ通信所需的。'
- en: '`--name`: Sets the container name to `rabbitmq`.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name`：将容器名称设置为`rabbitmq`。'
- en: 'You can check that your new RabbitMQ container is running by executing:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行以下命令来检查您的新RabbitMQ容器是否正在运行：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installing Python requirements
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Python要求
- en: For this project, I'll be using Python 3.6, which, at the time of writing, is
    the latest stable release of Python. I recommend always using the latest stable
    version of Python, not only for the new features but to also ensure the latest
    security updates are applied to your environment at all times.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我将使用Python 3.6，这是我写作时的最新稳定版本的Python。我建议始终使用最新的稳定版本的Python，不仅可以获得新功能，还可以确保环境中始终应用最新的安全更新。
- en: 'Pyenv is a really simple way to install and switch between different versions
    of Python: [http://url.marcuspen.com/pyenv](http://url.marcuspen.com/pyenv).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Pyenv是一种非常简单的安装和切换不同版本的Python的方法：[http://url.marcuspen.com/pyenv](http://url.marcuspen.com/pyenv)。
- en: I also strongly recommend using virtualenv to create an isolated environment
    to install our Python requirements. Installing Python requirements without a virtual
    environment can cause unexpected side-effects with other Python applications,
    or worse, your operating system!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我还强烈建议使用virtualenv创建一个隔离的环境来安装我们的Python要求。在没有虚拟环境的情况下安装Python要求可能会导致与其他Python应用程序或更糟糕的操作系统产生意外的副作用！
- en: 'To learn more about virtualenv and how to install it visit: [http://url.marcuspen.com/virtualenv](http://url.marcuspen.com/virtualenv)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关virtualenv及其安装方法的更多信息，请访问：[http://url.marcuspen.com/virtualenv](http://url.marcuspen.com/virtualenv)
- en: Normally, when dealing with Python packages, you would create a `requirements.txt`
    file, populate it with your requirements and then install it. I'd like to show
    you a different way that will allow you to easily keep track of Python package
    versions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在处理Python包时，您会创建一个`requirements.txt`文件，填充它的要求，然后安装它。我想向您展示一种不同的方法，可以让您轻松地跟踪Python包的版本。
- en: 'To get started, let''s install `pip-tools` within your virtualenv:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请在您的虚拟环境中安装`pip-tools`：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now create a new folder called `requirements` and create two new files:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为`requirements`的新文件夹，并创建两个新文件：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `base.in` file will contain the requirements needed in order for the core
    of our service to run, whereas the `test.in` file will contain the requirements
    needed in order to run our tests. It's important to keep these requirements separate,
    especially when deploying code in a microservice architecture. It's okay for our
    local machines to have test packages installed, but a deployed version of our
    code should be as minimal and lightweight as possible.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`base.in`文件将包含运行我们服务核心所需的要求，而`test.in`文件将包含运行我们测试所需的要求。将这些要求分开是很重要的，特别是在微服务架构中部署代码时。我们的本地机器可以安装测试包，但是部署版本的代码应尽可能简洁和轻量。'
- en: 'In the `base.in` file, put the following line:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`base.in`文件中，输入以下行：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `test.in` file, put the following line:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test.in`文件中，输入以下行：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Provided you are in the directory containing your `requirements` folder, run
    the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在包含`requirements`文件夹的目录中，运行以下命令：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will generate two files, `base.txt`, and `test.txt`. Here''s a small sample
    of the `base.txt`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成两个文件，`base.txt`和`test.txt`。以下是`base.txt`的一个小样本：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice how we now have a file that contains all of the latest dependencies and
    sub-dependencies of Nameko. It specifies which versions are required and also
    what caused each sub-dependency to be installed. For example, `six` is required
    by `nameko` and `mock`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们现在有一个文件，其中包含了Nameko的所有最新依赖和子依赖。它指定了所需的版本，还指出了每个子依赖被安装的原因。例如，`six`是由`nameko`和`mock`需要的。
- en: This makes it extremely easy to troubleshoot upgrade issues in the future by
    being able to easily track version changes between each release of your code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以非常容易地通过跟踪每个代码发布版本之间的版本更改来解决未来的升级问题。
- en: 'At the time of writing, Nameko is currently version 2.8.3 and Pytest is 3.4.0\.
    Feel free to use newer versions of these packages if available, but if you have
    any issues throughout the book then revert back to these by appending the version
    number in your `base.in` or `test.in` file as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Nameko当前版本为2.8.3，Pytest为3.4.0。如果有新版本可用，请随时使用，但如果在本书中遇到任何问题，请通过在您的`base.in`或`test.in`文件中附加版本号来恢复到这些版本：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To install the requirements, simply run:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这些要求，只需运行：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `pip-sync` command installs all requirements specified in the files while
    also removing any packages that are in your environment that aren''t specified.
    It''s a nice way to keep your virtualenv clean. Alternatively, you can also use:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip-sync`命令安装文件中指定的所有要求，同时删除环境中未指定的任何包。这是保持您的虚拟环境干净的好方法。或者，您也可以使用：'
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating your first Nameko microservice
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的第一个Nameko微服务
- en: 'Let''s start by creating a new folder titled `temp_messenger` and placing a
    new file inside, named `service.py`, with the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个名为`temp_messenger`的新文件夹，并在其中放置一个名为`service.py`的新文件，其中包含以下代码：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We first start by importing `rpc` from `nameko.rpc`. This will allow us to decorate
    our methods with the `rpc` decorator and expose them as entrypoints into our service.
    An entrypoint is any method in a Nameko service that acts as a gateway into our
    service.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过从`nameko.rpc`导入`rpc`开始。这将允许我们使用`rpc`装饰器装饰我们的方法，并将它们公开为我们服务的入口点。入口点是Nameko服务中的任何方法，它作为我们服务的网关。
- en: In order to create a Nameko service, we simply create a new class, `KonnichiwaService`,
    and assign it a `name` attribute. The `name` attribute gives it a namespace; this
    will be used later when we attempt to make a remote call to the service.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个Nameko服务，我们只需创建一个名为`KonnichiwaService`的新类，并为其分配一个`name`属性。`name`属性为其提供了一个命名空间；这将在我们尝试远程调用服务时使用。
- en: We've written a method on our service which simply returns the word `Konnichiwa!`.
    Notice how this method is decorated with `rpc`. The `konnichiwa` method is now
    going to be exposed via RPC.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在服务上编写了一个简单返回单词`Konnichiwa!`的方法。注意这个方法是用`rpc`装饰的。`konnichiwa`方法现在将通过RPC公开。
- en: 'Before we test this code out we need to create a small `config` file which
    will tell Nameko where to access RabbitMQ and what RPC exchange to use. Create
    a new file, `config.yaml`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试这段代码之前，我们需要创建一个小的`config`文件，告诉Nameko在哪里访问RabbitMQ以及使用什么RPC交换。创建一个新文件`config.yaml`：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `AMQP_URI` configuration here is correct for users who have started the
    RabbitMQ container using the instructions given earlier. If you have adjusted
    the username, password or location, ensure that your changes are reflected here.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`AMQP_URI`配置对于使用先前给出的说明启动RabbitMQ容器的用户是正确的。如果您已调整了用户名、密码或位置，请确保您的更改在这里反映出来。
- en: 'You should now have a directory structure that resembles the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该有一个类似以下的目录结构：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now in your terminal, within the root of your project directory, execute the
    following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在您的终端中，在项目目录的根目录中，执行以下操作：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should have the following output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会得到以下输出：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Making a call to our service
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对我们的服务进行调用
- en: 'Our microservice is now running! In order to make our own calls, we can launch
    a Python shell that has Nameko integrated to allow us to call our entrypoints.
    To access it, open a new terminal window and execute the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的微服务现在正在运行！为了进行我们自己的调用，我们可以启动一个集成了 Nameko 的 Python shell，以允许我们调用我们的入口点。要访问它，请打开一个新的终端窗口并执行以下操作：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This should give you access to a Python shell with the ability to make Remote
    Procedure Calls. Let''s try that out:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您提供一个 Python shell，可以进行远程过程调用。让我们试一试：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It worked! We have successfully made a call to our Konnichiwa Service and received
    some output back. When we executed this code in our Nameko shell, we put a message
    on the queue, which was then received by our `KonnichiwaService`. It then spawned
    a new worker to carry out the work of the `konnichiwa` RPC.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！我们已成功调用了我们的 Konnichiwa 服务，并收到了一些输出。当我们在 Nameko shell 中执行此代码时，我们将一条消息放入队列，然后由我们的
    `KonnichiwaService` 接收。然后它生成一个新的 worker 来执行 `konnichiwa` RPC 的工作。
- en: Unit-testing a Nameko microservice
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试 Nameko 微服务
- en: 'According to the documentation, [http://url.marcuspen.com/nameko](http://url.marcuspen.com/nameko),
    Nameko is:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，[http://url.marcuspen.com/nameko](http://url.marcuspen.com/nameko)，Nameko
    是：
- en: '"A microservices framework for Python that lets service developers concentrate
    on application logic and encourages testability."'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: “一个用于 Python 的微服务框架，让服务开发人员专注于应用逻辑并鼓励可测试性。”
- en: We will now focus on the testability part of Nameko; it provides some very useful
    tools for isolating and testing its services.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将专注于 Nameko 的可测试性部分；它提供了一些非常有用的工具，用于隔离和测试其服务。
- en: 'Create a new folder, `tests`, and place two new files inside, `__init__.py`
    (which can be left blank) and `test_service.py`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件夹 `tests`，并在其中放入两个新文件，`__init__.py`（可以留空）和 `test_service.py`：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When running outside of the test environment, Nameko spawns a new worker for
    each entrypoint that is called. Earlier, when we tested our `konnichiwa` RPC,
    the Konnichiwa Service would have been listening for new messages on the Rabbit
    queue. Once it received a new message for the `konnichiwa` entrypoint, it would
    spawn a new worker that would carry out that method and then die.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试环境之外运行时，Nameko 会为每个被调用的入口点生成一个新的 worker。之前，当我们测试我们的 `konnichiwa` RPC 时，Konnichiwa
    服务会监听 Rabbit 队列上的新消息。一旦它收到了 `konnichiwa` 入口点的新消息，它将生成一个新的 worker 来执行该方法，然后消失。
- en: 'To learn more about the anatomy of Nameko services, see: [http://url.marcuspen.com/nam-key](http://url.marcuspen.com/nam-key).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Nameko 服务解剖学的信息，请参阅：[http://url.marcuspen.com/nam-key](http://url.marcuspen.com/nam-key)。
- en: For our tests, Nameko provides a way to emulate that via a `woker_factory`.
    As you can see, our test uses `worker_factory`, which we pass our service class,
    `KonnichiwaService`. This will then allow us to call any entrypoint on that service
    and access the result.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的测试，Nameko 提供了一种通过 `woker_factory` 模拟的方法。正如您所看到的，我们的测试使用了 `worker_factory`，我们将我们的服务类
    `KonnichiwaService` 传递给它。这将允许我们调用该服务上的任何入口点并访问结果。
- en: 'To run the test, from the root of your code directory, simply execute:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，只需从代码目录的根目录执行：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That's it. The test suite should now pass. Have a play around and try to make
    it break.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。测试套件现在应该通过了。尝试一下并尝试使其出错。
- en: Exposing HTTP entrypoints
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露 HTTP 入口点
- en: 'We will now create a new microservice responsible for handling HTTP requests.
    First of all, let''s amend our imports in the `service.py` file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个新的微服务，负责处理 HTTP 请求。首先，让我们在 `service.py` 文件中修改我们的导入：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Beneath the `KonnichiwaService` we made earlier, insert the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前创建的 `KonnichiwaService` 下面，插入以下内容：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice how the follows a similar pattern to the `KonnichiwaService`. It has
    a `name` attribute and a method decorated in order to expose it as an entrypoint.
    In this case, it is decorated with the `http` entrypoint. We specify inside the
    `http` decorator that it is a `GET` request and the location of that request -
    in this case, the root of our website.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它如何遵循与 `KonnichiwaService` 类似的模式。它有一个 `name` 属性和一个用于将其公开为入口点的方法。在这种情况下，它使用
    `http` 入口点进行装饰。我们在 `http` 装饰器内指定了它是一个 `GET` 请求以及该请求的位置 - 在这种情况下，是我们网站的根目录。
- en: 'There is also one more crucial difference: This service holds a reference to
    the Konnichiwa Service via an `RpcProxy` object. `RpcProxy` allows us to make
    calls to another Nameko service via RPC. We instantiate it with the `name` attribute,
    which we specified earlier in `KonnichiwaService`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个至关重要的区别：这个服务通过 `RpcProxy` 对象持有对 Konnichiwa 服务的引用。`RpcProxy` 允许我们通过 RPC 调用另一个
    Nameko 服务。我们使用 `name` 属性来实例化它，这是我们之前在 `KonnichiwaService` 中指定的。
- en: 'Let''s try this out - simply restart the Nameko using the command from earlier
    (this is needed to take into account any changes to the code) and go to `http://localhost:8000/`
    in your browser of choice:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试 - 只需使用之前的命令重新启动 Nameko（这是为了考虑代码的任何更改），然后在您选择的浏览器中转到 `http://localhost:8000/`：
- en: '![](assets/10d861cc-6456-4160-b51e-71bc67b982c9.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/10d861cc-6456-4160-b51e-71bc67b982c9.png)'
- en: It worked! We've now successfully made two microservices—one responsible for
    showing a message and one responsible for serving web requests.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！我们现在成功地创建了两个微服务——一个负责显示消息，一个负责提供 Web 请求。
- en: Integration testing Nameko microservices
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nameko 微服务的集成测试
- en: Earlier we looked at testing a service in isolation by spawning a single worker.
    This is great for unit testing but it is not a viable option for integration testing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们通过生成单个 worker 来测试隔离的服务。这对于单元测试来说很好，但不适用于集成测试。
- en: 'Nameko gives us the ability to test multiple services working in tandem in
    a single test. Look at the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Nameko 使我们能够在单个测试中测试多个服务协同工作的能力。看看下面的内容：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see in the preceding code, Nameko also gives us access to the following
    test fixtures:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，Nameko 还为我们提供了以下测试装置：
- en: '`web_session`: Gives us a session in which to make HTTP requests to the service'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web_session`：为我们提供了一个会话，用于向服务发出 HTTP 请求'
- en: '`web_config`: Allows us to access the configuration for the service (outside
    of testing, this is equivalent to the `config.yaml` file)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web_config`：允许我们访问服务的配置（在测试之外，这相当于`config.yaml`文件）'
- en: '`container_factory`: This allows us to simulate a service as a whole rather
    than just an instance of a worker, which is necessary when integration testing'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container_factory`：这允许我们模拟整个服务而不仅仅是一个工作实例，这在集成测试时是必要的'
- en: 'Since this is running the actual services, we need to specify the location
    of the AMQP broker by injecting it into the `web_config`. Using `container_factory`,
    we create two containers: `web_server` and `konnichiwa`. We then start both containers.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是运行实际服务，我们需要通过将其注入到`web_config`中来指定AMQP代理的位置。使用`container_factory`，我们创建两个容器：`web_server`和`konnichiwa`。然后启动两个容器。
- en: It's then a simple case of using `web_session` to make a `GET` request to the
    root of our site and checking that the result is what we expect.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后只需使用`web_session`发出`GET`请求到我们网站的根目录，并检查结果是否符合我们的预期。
- en: As we go through the rest of the chapter, I encourage you to write your own
    tests for the code, as it will not only prevents bugs but also help to solidify
    your knowledge on this topic. It's also a good way to experiment with your own
    ideas and modifications to the code as they can tell you quickly if you have broken
    anything.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们继续阅读本章的其余部分时，我鼓励您为代码编写自己的测试，因为这不仅可以防止错误，还可以帮助巩固您对这个主题的知识。这也是一个尝试您自己的想法和对代码进行修改的好方法，因为它们可以快速告诉您是否有任何错误。
- en: 'For more information on testing Nameko services, see: [http://url.marcuspen.com/nam-test](http://url.marcuspen.com/nam-test).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有关测试Nameko服务的更多信息，请参见：[http://url.marcuspen.com/nam-test](http://url.marcuspen.com/nam-test)。
- en: Storing messages
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储消息
- en: The messages we want our application to display need to be temporary. We could
    use a relational database for this, such as PostgreSQL, but that would mean having
    to design and maintain a database for something as simple as text.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望应用程序显示的消息需要是临时的。我们可以使用关系数据库，如PostgreSQL，但这意味着必须为像文本这样简单的东西设计和维护数据库。
- en: An introduction to Redis
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redis简介
- en: Redis is an in-memory data store. The entire dataset can be stored in memory
    making reads and writes much faster than relational databases, which is useful
    for data that is not going to need persistence. In addition, we can store data
    without making a schema, which is fine if we are not going to need complex queries.
    In our case, we simply need a data store that will allow us to store messages,
    get messages, and expire messages. Redis fits our use case perfectly!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是一个内存数据存储。整个数据集可以存储在内存中，使读写速度比关系数据库快得多，这对于不需要持久性的数据非常有用。此外，我们可以在不制作模式的情况下存储数据，如果我们不需要复杂的查询，这是可以接受的。在我们的情况下，我们只需要一个数据存储，它将允许我们存储消息，获取消息并使消息过期。Redis完全符合我们的用例！
- en: Starting a Redis container
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动Redis容器
- en: 'In your terminal, execute the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的终端中，执行以下操作：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will start a Redis container with the following setup:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用以下设置启动一个Redis容器：
- en: '`-d`: Specifies we want to run the container in daemon mode (background process).'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：指定我们要在守护程序模式（后台进程）中运行容器。'
- en: '`-p`: Allows us to expose port `6379` on the container to our local machine.
    This are needed for Nameko to communicate with Redis.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`：允许我们将容器上的端口`6379`暴露到本地机器上。这对于Nameko与Redis通信是必需的。'
- en: '`--name`: Sets the container name to `redis`.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name`：将容器名称设置为`redis`。'
- en: 'You can check that your new Redis container is running by executing:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行以下操作来检查新的Redis容器是否正在运行：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Installing the Python Redis client
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Python Redis客户端
- en: You will also need to install the Python Redis client to allow you to interact
    with Redis via Python. To do this, I recommend amending your `base.in` file from
    earlier to include `redis` and recompiling it to generate your new `base.txt`
    file. Alternatively, you can run `pip install redis`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要安装Python Redis客户端，以便通过Python与Redis进行交互。为此，我建议您修改之前的`base.in`文件以包括`redis`并重新编译它以生成新的`base.txt`文件。或者，您可以运行`pip
    install redis`。
- en: Using Redis
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redis
- en: 'Let''s briefly look at the types of Redis commands that could be useful to
    us for TempMessenger:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地看一下对于TempMessenger对我们有用的Redis命令类型：
- en: '`SET`: Sets a given key to hold a given string. It also allows us to set an
    expiration in seconds or milliseconds.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SET`：设置给定键来保存给定的字符串。它还允许我们设置以秒或毫秒为单位的过期时间。'
- en: '`GET`: Gets the value of the data stored with the given key.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：获取存储在给定键处的数据的值。'
- en: '`TTL`: Gets the time-to-live for a given key in seconds.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TTL`：以秒为单位获取给定键的生存时间。'
- en: '`PTTL`: Gets the time-to-live for a given key in milliseconds.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PTTL`：以毫秒为单位获取给定键的生存时间。'
- en: '`KEYS`: Returns a list of all keys in the data store.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEYS`：返回数据存储中的所有键的列表。'
- en: 'To try them out, we can use `redis-cli` which is a program that ships with
    our Redis container. To access it, first log in to the container by executing
    the following in your terminal:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试它们，我们可以使用`redis-cli`，这是随Redis容器一起提供的程序。要访问它，首先通过在终端中执行以下操作登录到容器：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then access `redis-cli` in the same terminal window by simply running:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过简单地运行以下内容在同一个终端窗口中访问`redis-cli`：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There are some examples given as follows on how to use `redis-cli`; if you're
    not familiar with Redis then I encourage you to experiment with the commands yourself.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用`redis-cli`的一些示例；如果您对Redis不熟悉，我鼓励您自己尝试使用这些命令。
- en: 'Set some data, `hello`, to key `msg1`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将一些数据`hello`设置为键`msg1`：
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Get data stored at key, `msg1`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 获取存储在键`msg1`处的数据：
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Set some more data, `hi there`, at key `msg2`  and retrieve it:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在键`msg2`处设置一些更多的数据`hi there`并检索它：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Retrieve all keys currently stored in Redis:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 检索当前存储在Redis中的所有键：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Save data at `msg3` with an expiry of 15 seconds:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在`msg3`上保存数据，过期时间为15秒：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Get the time-to-live for `msg3` in seconds:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`msg3`的生存时间（以秒为单位）：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Get the time-to-live for `msg3` in milliseconds:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以毫秒为单位获取`msg3`的生存时间：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Retrieve `msg3` before it expires:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在`msg3`过期之前检索：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Retrieve `msg3` after it expires:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`msg3`过期后检索：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Nameko Dependency Providers
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nameko依赖提供者
- en: When building microservices, Nameko encourages the use of dependency providers
    to communicate with external resources such as databases, servers, or anything
    that our application depends on. By using a dependency provider, you can hide
    away logic that is specific only to that dependency, keeping your service level
    code clean and agnostic to the ins-and-outs of interfacing with this external
    resource.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建微服务时，Nameko鼓励使用依赖提供程序与外部资源进行通信，如数据库、服务器或我们的应用程序所依赖的任何东西。通过使用依赖提供程序，您可以隐藏掉只对该依赖性特定的逻辑，使您的服务级代码保持干净，并且对于与这个外部资源进行交互的细节保持不可知。
- en: By structuring our microservices like this, we have the ability to easily swap
    out or re-use dependency providers in other services.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式构建我们的微服务，我们可以轻松地在其他服务中交换或重用依赖提供程序。
- en: 'Nameko provides a list of open source dependency providers that are ready to
    use: [http://url.marcuspen.com/nam-ext](http://url.marcuspen.com/nam-ext)[.](https://nameko.readthedocs.io/en/stable/community_extensions.html)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Nameko提供了一系列开源依赖提供程序，可以直接使用：[http://url.marcuspen.com/nam-ext](http://url.marcuspen.com/nam-ext)。
- en: Adding a Redis Dependency Provider
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个Redis依赖提供程序
- en: Since Redis is an external resource for our application, we will create a dependency
    provider for it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Redis是我们应用程序的外部资源，我们将为它创建一个依赖提供程序。
- en: Designing the Client
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计客户端
- en: 'First, let''s create a new folder named `dependencies` inside of our `temp_messenger`
    folder. Inside, place a new file, `redis.py`. We will now create a Redis client
    with a simple method that will get a message, given a key:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`temp_messenger`文件夹内创建一个名为`dependencies`的新文件夹。在里面，放置一个新文件`redis.py`。我们现在将创建一个Redis客户端，其中包含一个简单的方法，将根据一个键获取一条消息：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We start off our code by implementing the `__init__` method, which creates
    our Redis client and assigns it to `self.redis`. `StrictRedis` that can take a
    number of optional arguments, however, we have only specified the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实现`__init__`方法来开始我们的代码，该方法创建我们的Redis客户端并将其分配给`self.redis`。`StrictRedis`可以接受许多可选参数，但是我们只指定了以下参数：
- en: '`url`: Rather than specifying the host, port and database number separately,
    we can use `StrictRedis`'' `from_url`, which will allow us to specify all three
    with a single string, like so—`redis://localhost:6379/0`. This is a lot more convenient
    when it comes to storing it in our `config.yaml` later.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url`：我们可以使用`StrictRedis`的`from_url`，而不是分别指定主机、端口和数据库号，这将允许我们使用单个字符串指定所有三个，如`redis://localhost:6379/0`。当将其存储在我们的`config.yaml`中时，这将更加方便。'
- en: '`decode_responses`: This will automatically convert the data we get from Redis
    into a Unicode string. By default, data is retrieved in bytes.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decode_responses`：这将自动将我们从Redis获取的数据转换为Unicode字符串。默认情况下，数据以字节形式检索。'
- en: 'Now, in the same class, let''s implement a new method:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在同一个类中，让我们实现一个新的方法：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Outside of our new class, let''s also implement a new error class:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新类之外，让我们还实现一个新的错误类：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here we have a method, `get_message`, that takes a `message_id` that will be
    used as our Redis key. We use the `get` method on our Redis client to retrieve
    the message with our given key. When retrieving values from Redis, if the key
    does not exist, it will simply return `None`. Since this method expects there
    to be a message, we should handle raising an error ourselves. In this case, we've
    made a simple exception, `RedisError`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个方法`get_message`，它接受一个`message_id`作为我们的Redis键。我们使用Redis客户端的`get`方法来检索具有给定键的消息。当从Redis检索值时，如果键不存在，它将简单地返回`None`。由于这个方法期望有一条消息，我们应该自己处理引发错误。在这种情况下，我们制作了一个简单的异常`RedisError`。
- en: Creating the Dependency Provider
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建依赖提供程序
- en: 'So far we''ve created a Redis Client with a single method. We now need to create
    a Nameko Dependency Provider to utilize this client for use with our services.
    In the same `redis.py` file, update your imports to include the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个具有单个方法的Redis客户端。现在我们需要创建一个Nameko依赖提供程序，以利用这个客户端与我们的服务一起使用。在同一个`redis.py`文件中，更新您的导入以包括以下内容：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s implement the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现以下代码：
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding code, you can see that our new `MessageStore` class inherits
    from the `DependencyProvider` class. The methods we have specified in our new
    MessageStore class will be called at certain moments of our microservice lifecycle:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，您可以看到我们的新`MessageStore`类继承自`DependencyProvider`类。我们在新的MessageStore类中指定的方法将在我们的微服务生命周期的某些时刻被调用。
- en: '`setup`: This will be called before our Nameko services starts. Here we get
    the Redis URL from `config.yaml` and create a new `RedisClient` using the code
    we made earlier.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup`：这将在我们的Nameko服务启动之前调用。在这里，我们从`config.yaml`获取Redis URL，并使用我们之前制作的代码创建一个新的`RedisClient`。'
- en: '`stop`: When our Nameko services begin to shut down, this will be called.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop`：当我们的Nameko服务开始关闭时，这将被调用。'
- en: '`get_dependency`: All dependency providers need to implement this method. When
    an entrypoint fires, Nameko creates a worker and injects the result of `get_dependency`
    for each dependency specified in the service into the worker. In our case, this
    means that our workers will all have access to an instance of `RedisClient`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_dependency`：所有依赖提供程序都需要实现这个方法。当入口点触发时，Nameko创建一个worker，并将`get_dependency`的结果注入到服务中指定的每个依赖项的worker中。在我们的情况下，这意味着我们的worker都将可以访问`RedisClient`的一个实例。'
- en: 'Nameko offers more methods to control how your dependency providers function
    at different moments of the service lifecycle: [http://url.marcuspen.com/nam-writ](http://url.marcuspen.com/nam-writ).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Nameko提供了更多的方法来控制您的依赖提供程序在服务生命周期的不同时刻如何运行：[http://url.marcuspen.com/nam-writ](http://url.marcuspen.com/nam-writ)。
- en: Creating our Message Service
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的消息服务
- en: 'In our `service.py`, we can now make use of our new Redis Dependency Provider.
    Let''s start off by creating a new service, which will replace our Konnichiwa
    Service from earlier. First, we need to update our imports at the top of our file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`service.py`中，我们现在可以利用我们的新的Redis依赖提供程序。让我们首先创建一个新的服务，它将替换我们之前的Konnichiwa服务。首先，我们需要在文件顶部更新我们的导入：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we can create our new service:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建我们的新服务：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is similar to our earlier services; however, this time we are specifying
    a new class attribute, `message_store`. Our RPC entrypoint, `get_message`, can
    now make use of this and call `get_message` in our `RedisClient` and simply return
    the result.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前的服务类似；但是，这次我们正在指定一个新的类属性`message_store`。我们的RPC入口点`get_message`现在可以使用这个属性，并调用我们的`RedisClient`中的`get_message`，然后简单地返回结果。
- en: We could have done all of this by creating a new Redis client within our RPC
    entrypoint and implementing a Redis `GET`. However, by creating a dependency provider,
    we promote reusability and hide away the unwanted behavior of Redis returning
    `None` when a key does not exist. This is just a small example of why Dependency
    Providers are extremely good at decoupling our services from external dependencies.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以通过在我们的RPC入口点内创建一个新的Redis客户端并实现Redis的`GET`来完成所有这些。然而，通过创建一个依赖提供者，我们促进了可重用性，并隐藏了Redis在键不存在时返回`None`的不需要的行为。这只是一个小例子，说明了为什么依赖提供者非常擅长将我们的服务与外部依赖解耦。
- en: Putting it all together
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: 'Let''s try out the code we have just created. Start by saving a new key-value
    pair to Redis using the `redis-cli`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下我们刚刚创建的代码。首先使用`redis-cli`将一个新的键值对保存到Redis中：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now start our Nameko services:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动我们的Nameko服务：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can now use `nameko shell` to make remote calls to our new `MessageService`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`nameko shell`来远程调用我们的新`MessageService`：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As expected, we were able to retrieve a message that we set earlier using `redis-cli`
    via our `MessageService` entrypoint.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们能够通过我们的`MessageService`入口点使用`redis-cli`检索到我们之前设置的消息。
- en: 'Let''s now try to get a message that does not exist:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试获取一个不存在的消息：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This isn't the prettiest of errors and there are certain things we can do to
    reduce the traceback with this, but the final line states the exception we defined
    earlier and clearly shows us why that request failed.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是最漂亮的错误，有一些事情我们可以做来减少这个回溯，但最后一行说明了我们之前定义的异常，并清楚地显示了为什么该请求失败。
- en: We will now move on to saving messages.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将继续保存消息。
- en: Saving messages
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存消息
- en: Earlier, I introduced the Redis `SET` method. This will allow us to save a message
    to Redis, but first, we need to create a new method in our dependency provider
    that will handle this.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我介绍了Redis的`SET`方法。这将允许我们将消息保存到Redis，但首先，我们需要在我们的依赖提供者中创建一个新的方法来处理这个问题。
- en: We could simply create a new method that called `redis.set(message_id, message)`,
    but how would we handle new message IDs? It would be a bit troublesome if we expected
    the user to input a new message ID for each message they wanted to send, right?
    An alternative is to have the message service generate a new random message ID
    before it calls the dependency provider, but that would clutter our service with
    logic that could be handled by the dependency itself.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地创建一个调用`redis.set(message_id, message)`的新方法，但是我们如何处理新的消息ID呢？如果我们期望用户为他们想要发送的每条消息输入一个新的消息ID，那将会有些麻烦，对吧？另一种方法是让消息服务在调用依赖提供者之前生成一个新的随机消息ID，但这样会使我们的服务充斥着依赖本身可以处理的逻辑。
- en: We'll solve this by having the dependency create a random string to be used
    as the message ID.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过让依赖创建一个随机字符串来解决这个问题，以用作消息ID。
- en: Adding a save message method to our Redis client
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的Redis客户端中添加保存消息的方法
- en: 'In `redis.py`, let''s amend our imports to include `uuid4`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在`redis.py`中，让我们修改我们的导入以包括`uuid4`：
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`uuid4` generates us a unique random string that we can use for our message.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`uuid4`为我们生成一个唯一的随机字符串，我们可以用它来作为我们消息的ID。'
- en: 'We can now add our new `save_message` method to the `RedisClient`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将我们的新的`save_message`方法添加到`RedisClient`中：
- en: '[PRE49]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: First off, we generate a new message ID using `uuid4().hex`. The `hex` attribute
    gives us the UUID as a 32-character hexadecimal string. We then use it as a key
    to save the message and return it.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`uuid4().hex`生成一个新的消息ID。`hex`属性将UUID作为一个32字符的十六进制字符串返回。然后我们将其用作键来保存消息并返回它。
- en: Adding a save message RPC
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个保存消息的RPC
- en: 'Let''s now create the RPC method that is going to call our new client method.
    In our `MessageService`, add the following method:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个RPC方法，用来调用我们的新客户端方法。在我们的`MessageService`中，添加以下方法：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Nothing fancy here, but notice how easy it is becoming to add new functionality
    to our service. We are separating logic that belongs in the dependency from our
    entrypoints, and at the same time making our code reusable. If another RPC method
    we create in the future needs to save a message to Redis, we can easily do so
    without having to recreate the same code again.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么花哨的，但请注意，向我们的服务添加新功能变得如此容易。我们正在将属于依赖的逻辑与我们的入口点分离，并同时使我们的代码可重用。如果我们将来创建的另一个RPC方法需要将消息保存到Redis中，我们可以轻松地这样做，而不必再次创建相同的代码。
- en: Let's test this out by only using the `nameko shell` - remember to restart your
    Nameko service for changes to take effect!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用`nameko shell`来测试一下 - 记得重新启动Nameko服务以使更改生效！
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The ID returned here is random and will differ from the one you get from your
    session.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里返回的ID是随机的，与您在会话中获得的ID不同。
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see, we have successfully saved a message and used the UUID that
    is returned to retrieve our message.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已成功保存了一条消息，并使用返回的UUID检索了我们的消息。
- en: This is all well and good, but for the purposes of our app we don't expect the
    user to have to supply a message UUID in order to read messages. Let's make this
    a bit more practical and look at how we can get all of the messages in our Redis
    store.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，但是为了我们应用的目的，我们不希望用户必须提供消息UUID才能读取消息。让我们把这变得更实用一点，看看我们如何获取我们Redis存储中的所有消息。
- en: Retrieving all messages
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索所有消息
- en: Similar to our previous steps, we will need to add a new method to our Redis
    dependency in order to add more functionality. This time, we will be creating
    a method that will iterate through all of our keys in Redis and return the corresponding
    messages in a list.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的步骤类似，为了添加更多功能，我们需要在我们的Redis依赖中添加一个新的方法。这次，我们将创建一个方法，它将遍历Redis中的所有键，并以列表的形式返回相应的消息。
- en: Adding a get all messages method to our Redis client
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的Redis客户端中添加一个获取所有消息的方法
- en: 'Let''s add the following to our `RedisClient`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将以下内容添加到我们的`RedisClient`中：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We start off by using `self.redis.keys()` to gather all keys that are stored
    in Redis, which, in our case, are the message IDs. We then have a list comprehension
    that will iterate through all of the message IDs and create a dictionary for each
    one, containing the message ID itself and the message that is stored in Redis,
    using `self.redis.get(message_id)`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`self.redis.keys()`来收集存储在Redis中的所有键，这在我们的情况下是消息ID。然后，我们有一个列表推导式，它将遍历所有消息ID并为每个消息ID创建一个字典，其中包含消息ID本身和存储在Redis中的消息，使用`self.redis.get(message_id)`。
- en: For large scale applications in a production environment, it is not recommended
    to use the Redis `KEYS` method, since this will block the server until it has
    finished completing its operation. For more information, see: [http://url.marcuspen.com/rediskeys](http://url.marcuspen.com/rediskeys).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产环境中的大型应用程序，不建议使用Redis的`KEYS`方法，因为这将阻塞服务器直到完成操作。更多信息，请参阅：[http://url.marcuspen.com/rediskeys](http://url.marcuspen.com/rediskeys)。
- en: Personally, I prefer to use a list comprehension here to build the list of messages,
    but if you are struggling to understand this method, I recommend writing it as
    a standard for loop.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我更喜欢在这里使用列表推导式来构建消息列表，但如果您在理解这种方法方面有困难，我建议将其编写为标准的for循环。
- en: 'For the sake of this example, see the following code for the same method built
    as a for loop:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，可以查看以下代码，该代码是使用for循环构建的相同方法：
- en: '[PRE54]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Both of these methods do exactly the same thing. Which do you prefer? I'll leave
    that choice to you...
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都是完全相同的。你更喜欢哪个？我把这个选择留给你...
- en: Whenever I write a list or dictionary comprehension, I always start by having
    a test that checks the output of my function or method. I then write my code with
    a comprehension and test it to ensure the output is correct. I'll then change
    my code to a for loop and ensure the test still passes. After that, I look at
    both versions of my code and decide which one looks the most readable and clean.
    Unless the code needs to be super efficient, I always opt for code that reads
    well, even if that means a few more lines. This approach pays off in the long
    run when it comes to reading back and maintaining that code later!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我编写列表或字典推导式时，我总是从测试函数或方法的输出开始。然后我用推导式编写我的代码并测试它以确保输出是正确的。然后，我将我的代码更改为for循环并确保测试仍然通过。之后，我会查看我的代码的两个版本，并决定哪个看起来最可读和干净。除非代码需要非常高效，我总是选择阅读良好的代码，即使这意味着多写几行。当以后需要阅读和维护该代码时，这种方法在长远来看是值得的！
- en: We now have a way to obtain all messages in Redis. In the preceding code, I
    could have simply returned a list of messages with no dictionaries involved, just
    the string value of the message. But what if we wanted to add more data to each
    message later? For example, some metadata to say when the message was created
    or how long the message has until it expires... we'll get to that part later!
    Using a dictionary here for each message will allow us to easily evolve our data
    structures later on.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一种方法可以获取Redis中的所有消息。在上述代码中，我本可以简单地返回一个消息列表，而不涉及任何字典，只是消息的字符串值。但是，如果我们以后想要为每条消息添加更多数据呢？例如，一些元数据来表示消息创建的时间或消息到期的时间...我们以后会涉及到这部分！在这里为每条消息使用字典将使我们能够轻松地以后演变我们的数据结构。
- en: We can now look at adding a new RPC to our `MessageService` that will allow
    us to get all of the messages.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以考虑向我们的`MessageService`中添加一个新的RPC，以便我们可以获取所有消息。
- en: Adding a get all messages RPC
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加获取所有消息的RPC
- en: 'In our `MessageService` class, simply add:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`MessageService`类中，只需添加：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: I'm sure that by now, I probably do not need to explain what is going on here!
    We are simply calling the method we made earlier in our Redis dependency and returning
    the result.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信到现在为止，我可能不需要解释这里发生了什么！我们只是调用了我们之前在Redis依赖中制作的方法，并返回结果。
- en: Putting it all together
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容放在一起
- en: 'Within your virtualenv, using `nameko shell`, we can now test this out.:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的虚拟环境中，使用`nameko shell`，我们现在可以测试这个功能。
- en: '[PRE56]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There we have it! We can now retrieve all of the messages in our data store.
    (For the sake of space and readability, I've truncated the message IDs.)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以检索数据存储中的所有消息了。（出于空间和可读性考虑，我已经截断了消息ID。）
- en: There is one issue with the messages that are returned here - can you spot what
    it is? The order in which we put the messages into Redis is not the same order
    that we have received when we get them out again. We'll come back to this later,
    but for now, let's move on to displaying these messages in our web browser.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这里返回的消息存在一个问题-你能发现是什么吗？我们将消息放入Redis的顺序与我们再次取出它们的顺序不同。我们以后会回到这个问题，但现在让我们继续在我们的Web浏览器中显示这些消息。
- en: Displaying messages in the web browser
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Web浏览器中显示消息
- en: Earlier, we added the `WebServer` microservice to handle HTTP requests; we will
    now amend this so that when a user lands on the root home page, they are shown
    all of the messages in our data store.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们添加了`WebServer`微服务来处理HTTP请求；现在我们将对其进行修改，以便当用户登陆根主页时，他们会看到我们数据存储中的所有消息。
- en: One way to do this is to use a templating engine such as Jinja2.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种方法是使用Jinja2等模板引擎。
- en: Adding a Jinja2 Dependency Provider
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Jinja2依赖提供程序
- en: Jinja2 is a templating engine for Python that is extremely similar to the templating
    engine in Django. For those who are familiar with Django, you should feel right
    at home using it.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2是Python的模板引擎，与Django中的模板引擎非常相似。对于熟悉Django的人来说，使用它应该感觉非常熟悉。
- en: Before we start, you should amend your `base.in` file to include `jinja2`, re-compile
    your requirements and install them. Alternatively, simply run `pip install jinja2`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，您应该修改您的`base.in`文件，包括`jinja2`，重新编译您的要求并安装它们。或者，只需运行`pip install jinja2`。
- en: Creating the template renderer
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模板渲染器
- en: 'When generating a simple HTML template in Jinja2, the following three steps
    are required:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jinja2中生成简单的HTML模板需要以下三个步骤：
- en: Creating a template environment
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模板环境
- en: Specifying the template
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定模板
- en: Rendering the template
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染模板
- en: With these three steps, it's important to identify which parts are never subject
    (or at least extremely unlikely) to change while our application is running...
    and which are. Keep this in mind as I explain through the following code.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这三个步骤，重要的是要确定哪些部分在我们的应用程序运行时永远不会改变（或者至少极不可能改变）...以及哪些会改变。在我解释以下代码时，请记住这一点。
- en: 'In your dependencies directory, add a new file, `jinja2.py` and start with
    the following code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的依赖目录中，添加一个新文件`jinja2.py`，并从以下代码开始：
- en: '[PRE57]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In our `__init__` method, we require a package name and a template directory.
    With these, we can then create the template environment. The environment requires
    a loader, which is simply a way of being able to load our template files from
    a given package and directory. We've also specified that we want to enable auto-escaping
    on our HTML files for security.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`__init__`方法中，我们需要一个包名称和一个模板目录。有了这些，我们就可以创建模板环境。环境需要一个加载器，这只是一种能够从给定的包和目录加载我们的模板文件的方法。我们还指定我们要在我们的HTML文件上启用自动转义以确保安全。
- en: We've then made a `render_home` method that will allow us to render our `home.html`
    template once we've made it. Notice how we render our template with `messages`...
    you'll see why later!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个`render_home`方法，它将允许我们渲染我们的`home.html`模板。请注意我们如何使用`messages`来渲染我们的模板...稍后你会明白的！
- en: Can you see why I've structured the code this way? Since the `__init__` method
    is always executed, I've put the creation of our template environment there, since
    this is unlikely to ever change while our application is running.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出我为什么以这种方式构建代码吗？由于`__init__`方法总是被执行，我把我们的模板环境的创建放在那里，因为这在我们的应用程序运行时几乎不会改变。
- en: However, which template we want to render and the variables we give to that
    template are always going to change, depending on what page the user is trying
    to access and what data is available at that given moment in time. With the preceding
    structure, it becomes trivial to add a new method for each webpage of our application.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们要渲染的模板以及我们给该模板的变量总是会改变的，这取决于用户尝试访问的页面以及在那个特定时刻可用的数据。有了上述结构，为我们应用程序的每个网页添加一个新方法变得微不足道。
- en: Creating our homepage template
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的主页模板
- en: Let's now look at the HTML required for our template. Let's start by creating
    a new directory next to our dependencies, titled `templates`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们模板所需的HTML。让我们首先在我们的依赖旁边创建一个名为`templates`的新目录。
- en: 'Inside our new directory, create the following `home.html` file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新目录中，创建以下`home.html`文件：
- en: '[PRE58]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This HTML is nothing fancy, and neither is the templating logic! If you are
    unfamiliar to Jinja2 or Django templating then you're probably thinking that this
    HTML looks weird with the curly braces everywhere. Jinja2 uses these to allow
    us to input Python-like syntax into our template.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HTML并不花哨，模板逻辑也不复杂！如果你对Jinja2或Django模板不熟悉，那么你可能会觉得这个HTML看起来很奇怪，到处都是花括号。Jinja2使用这些花括号允许我们在模板中输入类似Python的语法。
- en: In the preceding example, we start off with an `if` statement to see if we have
    any messages (the format and structure of `messages` will be the same as the messages
    that are returned by the `get_all_messages` RPC we made earlier). If we do, then
    we have some more logic, including a for loop that will iterate and display the
    value of `'message'` for each dictionary in our `messages` list.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们首先使用`if`语句来查看是否有任何消息（`messages`的格式和结构将与我们之前制作的`get_all_messages` RPC返回的消息相同）。如果有，那么我们有一些更多的逻辑，包括一个for循环，它将迭代并显示我们`messages`列表中每个字典的`'message'`的值。
- en: If there are no messages, then we will just show the `No messages!` text.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有消息，那么我们将只显示`没有消息！`文本。
- en: 'To learn more about Jinja2, visit: [http://url.marcuspen.com/jinja2](http://url.marcuspen.com/jinja2).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Jinja2的信息，请访问：[http://url.marcuspen.com/jinja2](http://url.marcuspen.com/jinja2)。
- en: Creating the Dependency Provider
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建依赖提供者
- en: 'We will now need to expose our `TemplateRenderer` as a Nameko Dependency Provider.
    In the `jinja2.py` file we made earlier, update our imports to include the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将我们的`TemplateRenderer`公开为Nameko依赖提供者。在我们之前创建的`jinja2.py`文件中，更新我们的导入以包括以下内容：
- en: '[PRE59]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then add the following code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加以下代码：
- en: '[PRE60]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This is extremely similar to our previous Redis dependency. We specify a `setup`
    method that creates an instance of our `TemplateRenderer` and a `get_dependency`
    method that will inject it into the worker.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前的Redis依赖非常相似。我们指定了一个`setup`方法，用于创建我们的`TemplateRenderer`的实例，以及一个`get_dependency`方法，用于将其注入到worker中。
- en: This is now ready to be used by our `WebServer`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以被我们的`WebServer`使用了。
- en: Making a HTML response
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HTML响应
- en: 'We can now start to use our new Jinja2 dependency in our `WebServer`. First,
    we need to include it in our imports of `service.py`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在我们的`WebServer`中使用我们的新的Jinja2依赖项。首先，我们需要在`service.py`的导入中包含它：
- en: '[PRE61]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s now amend our `WebServer` class to be the following:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修改我们的`WebServer`类如下：
- en: '[PRE62]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Notice how we have assigned a new attribute, `templates`, like we did earlier
    in our `MessageService` with `message_store`. Our HTTP entrypoint now talks to
    our `MessageService`, retrieves all of the messages in Redis, and uses them to
    create a rendered template using our new Jinja2 dependency. We then return the
    result.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经像之前在我们的`MessageService`中使用`message_store`一样，为它分配了一个新的属性`templates`。我们的HTTP入口现在与我们的`MessageService`通信，从Redis中检索所有消息，并使用它们来使用我们的新Jinja2依赖项创建一个渲染模板。然后我们返回结果。
- en: Putting it all together
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容放在一起
- en: 'Restart your Nameko services and let''s try this out in the browser:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动您的Nameko服务，让我们在浏览器中尝试一下：
- en: '![](assets/cb3800d5-490c-4191-b33d-48391301b765.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cb3800d5-490c-4191-b33d-48391301b765.png)'
- en: It's worked... sort of! The messages we stored in Redis earlier are present,
    which means the logic in our template is functioning properly, but we also have
    all of the HTML tags and indentation from our `home.html`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 它起作用了...有点！我们之前存储在Redis中的消息现在存在，这意味着我们模板中的逻辑正常运行，但我们也有来自`home.html`的所有HTML标签和缩进。
- en: The reason for this is because we haven't yet specified any headers for our
    HTTP response to indicate that it is HTML. To do this, let's create a small helper
    function outside of our `WebServer` class, which will convert our rendered template
    into a response with proper headers and a status code.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们还没有为我们的HTTP响应指定任何头部，以表明它是HTML。为了做到这一点，让我们在`WebServer`类之外创建一个小的辅助函数，它将把我们的渲染模板转换为一个带有正确头部和状态码的响应。
- en: 'In our `service.py`, amend our imports to include:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`service.py`中，修改我们的导入以包括：
- en: '[PRE63]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then add the following function outside of our classes:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在我们的类之外添加以下函数：
- en: '[PRE64]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This function creates a headers dictionary, which contains the correct content
    type, HTML. We then create and return a `Response` object with an HTTP status
    code of `200`, our headers, and the content, which in our case will be the rendered
    template.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数创建一个包含正确内容类型HTML的头部字典。然后我们创建并返回一个`Response`对象，其中包括HTTP状态码`200`，我们的头部和内容，而在我们的情况下，内容将是渲染的模板。
- en: 'We can now amend our HTTP entrypoint to use our new helper function:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以修改我们的HTTP入口点以使用我们的新的辅助函数：
- en: '[PRE65]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Our `home` HTTP entrypoint now makes use of the `create_html_reponse`, giving
    it the rendered template, and then returns the response that is made. Let''s try
    this out again in our browser:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`home` HTTP入口点现在使用`create_html_reponse`，给它渲染的模板，然后返回所做的响应。让我们在浏览器中再试一次：
- en: '![](assets/4fa4561f-41cd-471f-9798-b7b696ff5924.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4fa4561f-41cd-471f-9798-b7b696ff5924.png)'
- en: As you can now see, our messages now display as we expect them with no HTML
    tags to be found! Have a try at deleting all data in Redis with the `flushall`
    command using the `redis-cli` and reload the webpage. What happens?
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到，我们的消息现在按我们的期望显示，没有找到任何HTML标签！尝试使用`redis-cli`中的`flushall`命令删除Redis中的所有数据，然后重新加载网页。会发生什么？
- en: We will now move on to sending messages.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将继续发送消息。
- en: Sending messages via POST requests
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过POST请求发送消息
- en: So far we've made good progress; we have a site that has the ability to display
    all of the messages in our data store with two microservices. One microservice
    handles the storing and retrieval of our messages, and the other acts as a web
    server for our users. Our `MessageService` already has the ability to save messages;
    let's expose that in our `WebServer` via a `POST` request.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们取得了很好的进展；我们有一个网站，它有能力显示我们数据存储中的所有消息，还有两个微服务。一个微服务处理我们消息的存储和检索，另一个充当我们用户的Web服务器。我们的`MessageService`已经有了保存消息的能力；让我们通过`POST`请求在我们的`WebServer`中暴露它。
- en: Adding a send messages POST request
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加发送消息的POST请求
- en: 'In our `service.py`, add the following import:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`service.py`中，添加以下导入：
- en: '[PRE66]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now add the following to our `WebServer` class:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们的`WebServer`类中添加以下内容：
- en: '[PRE67]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: With our new `POST` entrypoint, we start off by extracting the data from the
    request. We specify the parameter `as_text=True`, because we would otherwise get
    the data back as bytes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的新的`POST`入口点，我们首先从请求中提取数据。我们指定参数`as_text=True`，因为否则我们会得到数据的字节形式。
- en: Once we have that data, we can then attempt to load it from JSON into a Python
    dictionary. If the data is not valid JSON then this can cause a `JSONDecodeError`
    in our service, so it's best to handle that nicely and return a bad request status
    code of `400`. Without this exception handling, our service would return an internal
    server error, which has a status code of `500`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了那些数据，我们就可以尝试将其从JSON加载到Python字典中。如果数据不是有效的JSON，那么这可能会在我们的服务中引发`JSONDecodeError`，因此最好处理得体，并返回一个`400`的错误请求状态码。如果没有这个异常处理，我们的服务将返回一个内部服务器错误，状态码为`500`。
- en: Now that the data is in a dictionary format, we can obtain the message inside
    it. Again, we have some defensive code which will handle any occurrences of an
    absent `'message'` key and return another `400`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据以字典格式存在，我们可以获取其中的消息。同样，我们有一些防御性代码，它将处理任何缺少`'message'`键的情况，并返回另一个`400`。
- en: We then proceed to save the message using the `save_message` RPC we made earlier
    in our `MessageService`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们继续使用我们之前在`MessageService`中创建的`save_message` RPC来保存消息。
- en: 'With this, TempMessenger now has the ability to save new messages via an HTTP
    `POST` request! If you wanted to, you can test this out using curl or another
    API client, like so:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，TempMessenger现在有了通过HTTP `POST`请求保存新消息的能力！如果你愿意，你可以使用curl或其他API客户端来测试这一点，就像这样：
- en: '[PRE68]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We will now update our `home.html` template to include the ability to use this
    new `POST` request.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将更新我们的`home.html`模板，以包括使用这个新的`POST`请求的能力。
- en: Adding an AJAX POST request in jQuery
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在jQuery中添加一个AJAX POST请求
- en: Now before we start, let me say that at the time of writing, I am in no way
    a JavaScript expert. My expertise lie more in back-end programming than front-end.
    That being said, if you have worked in web development for more than 10 minutes,
    then you know that trying to avoid JavaScript is near impossible. At some point,
    we will probably have to dabble in some just to deliver a piece of work.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我说一下，写作时，我绝对不是JavaScript专家。我的专长更多地在于后端编程而不是前端。话虽如此，如果你在网页开发中工作超过10分钟，你就会知道试图避免JavaScript几乎是不可能的。在某个时候，我们可能会不得不涉足一些JavaScript来完成一些工作。
- en: With that in mind, *please do not be scared off!*
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，请*不要被吓到*！
- en: The code you are about to read is something that I learned just by reading the
    jQuery documentation, so it's extremely simple. If you are comfortable with front-end
    code then I'm sure there are probably a million different and probably better
    ways to do this in JavaScript, so please amend as you see fit.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 你即将阅读的代码是我仅仅通过阅读jQuery文档学到的，所以它非常简单。如果你对前端代码感到舒适，我相信可能有一百万种不同的，可能更好的方法来用JavaScript做到这一点，所以请根据自己的需要进行修改。
- en: 'You will first need to add the following after the `<!DOCTYPE html>`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先需要在`<!DOCTYPE html>`之后添加以下内容：
- en: '[PRE69]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This will download and run the latest version of jQuery in the browser.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在浏览器中下载并运行最新版本的jQuery。
- en: 'In our `home.html`, before the closing `</body>` tag, add the following:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`home.html`中，在闭合的`</body>`标签之前，添加以下内容：
- en: '[PRE70]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We start off here with some simple HTML to add a basic form. This only has a
    text input and a submit button. On its own, it will render a text box and a submit
    button, but it will not do anything.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的HTML开始，添加一个基本的表单。这只有一个文本输入和一个提交按钮。单独使用时，它将呈现一个文本框和一个提交按钮，但不会做任何事情。
- en: 'Let''s now follow that code with some jQuery JavaScript:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用一些jQuery JavaScript跟随这段代码：
- en: '[PRE71]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This will now add some functionality to our submit button. Let''s briefly cover
    what is happening here:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这将为我们的提交按钮添加一些功能。让我们简要地介绍一下这里发生了什么：
- en: This will create an event listener for our page that listens for the `postMessage`
    event.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将为我们的页面创建一个监听器，监听`postMessage`事件。
- en: We also prevent the default behavior of our submit button using `event.preventDefault();`.
    In this case, it would submit our form and attempt to perform a `GET` on `/messages?message=I%27m+a+new+message`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还使用`event.preventDefault();`阻止了提交按钮的默认行为。在这种情况下，它将提交我们的表单，并尝试在`/messages?message=I%27m+a+new+message`上执行`GET`。
- en: Once that is triggered, we then find the message and URL in our form.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦触发了，我们就可以在我们的表单中找到消息和URL。
- en: With these, we then construct our AJAX request, which is a POST request.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这些，我们就构建了我们的AJAX请求，这是一个POST请求。
- en: We use `JSON.stringify` to convert our payload into valid JSON data.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`JSON.stringify`将我们的有效负载转换为有效的JSON数据。
- en: Remember earlier, when we had to construct a response and supply header information
    to say that our content type was `text/html`? Well, we are doing the same thing
    here in our AJAX request, but this time, our content type is `application/json`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还记得之前，当我们需要构建一个响应并提供头信息以说明我们的内容类型是`text/html`时吗？好吧，我们在我们的AJAX请求中也在做同样的事情，但这次我们的内容类型是`application/json`。
- en: We set the `datatype` to `json`. This tells the browser the type of data we
    are expecting back from the server.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`datatype`设置为`json`。这告诉浏览器我们期望从服务器返回的数据类型。
- en: We also register a callback that reloads the webpage if the request is successful.
    This will allow us to see our new message on the page (and any other new ones)
    since it will get all of the messages again. This forced page reload is not the
    most elegant way of handling this, but it will do for now.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还注册了一个回调函数，如果请求成功，就重新加载网页。这将允许我们在页面上看到我们的新消息（和任何其他新消息），因为它将再次获取所有消息。这种强制页面重新加载并不是处理这个问题的最优雅方式，但现在可以这样做。
- en: 'Let''s restart Nameko and try this out in the browser:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新启动Nameko并在浏览器中尝试一下：
- en: '![](assets/e58ffe52-a0b1-40b3-9733-27e950d20384.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e58ffe52-a0b1-40b3-9733-27e950d20384.png)'
- en: Provided you haven't cleared the data from Redis (this can be done by manually
    deleting them or by simply restarting your machine), you should still see the
    old messages from earlier.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 只要您没有清除Redis中的数据（可以通过手动删除或简单地重新启动您的机器来完成），您应该仍然可以看到之前的旧消息。
- en: 'Once you''ve typed your message, click the Post button to submit your new message:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 输入消息后，点击“发布”按钮提交您的新消息：
- en: '![](assets/19fa394e-4f12-420b-916c-91e819e7edcf.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/19fa394e-4f12-420b-916c-91e819e7edcf.png)'
- en: Looks like it worked! Our application now has the ability to send new messages.
    We will now move onto the last requirement for our application, which is to expire
    messages after a given period of time.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好像成功了！我们的应用程序现在可以发送新消息了。我们现在将继续进行我们应用程序的最后一个要求，即在一定时间后过期消息。
- en: Expiring messages in Redis
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Redis中过期的消息
- en: We are now onto the last requirement for our app, expiring messages. Since we
    are using Redis to store our messages, this becomes a trivial task.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要实现应用程序的最后一个要求，即过期消息。由于我们使用Redis来存储消息，这变得非常简单。
- en: 'Let''s look back at our `save_message` method in our Redis dependency. Redis''
    `SET` has some optional parameters; the two we are most interested in here are
    `ex` and `px`. Both allow us to set the expiry of the data we are about to save,
    with one difference: `ex` is in seconds and `px` is in milliseconds:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们Redis依赖中的`save_message`方法。Redis的`SET`有一些可选参数；我们在这里最感兴趣的是`ex`和`px`。两者都允许我们设置要保存的数据的过期时间，但有一个区别：`ex`是以秒为单位的，而`px`是以毫秒为单位的：
- en: '[PRE72]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the preceding code, you can see that the only amendment to the code I've
    made is to add `ex=10` to the `redis.set` method; this will cause all of our messages
    to expire in 10 seconds. Restart your Nameko services now and try this out. When
    you send a new message, wait 10 seconds and refresh the page, and it should be
    gone.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，您可以看到我对代码所做的唯一修改是在`redis.set`方法中添加了`ex=10`；这将导致我们所有的消息在10秒后过期。现在重新启动您的Nameko服务并尝试一下。当您发送新消息后，等待10秒并刷新页面，它应该消失了。
- en: '**Please note** that if there were any messages in Redis before you made this
    change, they will still be present, since they were saved without an expiry. To
    remove them, delete all data in Redis with the `flushall` command using the `redis-cli`.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**请注意**，如果在您进行此更改之前Redis中有任何消息，它们仍将存在，因为它们是在没有过期时间的情况下保存的。要删除它们，请使用`redis-cli`使用`flushall`命令删除Redis中的所有数据。'
- en: Feel free to play around with the expiry time, setting it to whatever you wish
    with either the `ex` or `px` parameters. One way you could make this better is
    to move the expiry time constant to the configuration file, which is then loaded
    whenever you start Nameko, but for now, this will suffice.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试设置过期时间，使用`ex`或`px`参数将其设置为您希望的任何时间。您可以将过期时间常量移到配置文件中，然后在启动Nameko时加载，这样可以使其更好，但现在这样就足够了。
- en: Sorting messages
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序消息
- en: One thing you will quickly notice with the current state of our app is that
    the messages are not in any order at all. When you send a new message it could
    be inserted anywhere in the thread of messages, making our app pretty inconvenient,
    to say the least!
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 您很快会注意到我们应用程序的当前状态是，消息根本没有任何顺序。当您发送新消息时，它可能会被插入到消息线程的任何位置，这使得我们的应用程序非常不方便，至少可以这么说！
- en: 'To remedy this, we will sort the messages by the amount of time left before
    they expire. First, we will have to amend our `get_all_messages` method in our
    Redis dependency to also get the time-to-live for each message:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将按剩余时间对消息进行排序。首先，我们将不得不修改我们的Redis依赖中的`get_all_messages`方法，以便为每条消息获取剩余时间：
- en: '[PRE73]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As you can see in the preceding code, we have added a new `expires_in` value
    to each message. This uses the Redis PTTL command, which returns the time to live
    in milliseconds for a given key. Alternatively, we could also use the Redis TTL
    command, which returns the time to live in seconds, but we want this to be as
    precise as possible to make our sorting more accurate.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码中所示，我们为每条消息添加了一个新的`expires_in`值。这使用了Redis的PTTL命令，该命令返回给定键的存活时间（以毫秒为单位）。或者，我们也可以使用Redis的TTL命令，该命令返回以秒为单位的存活时间，但我们希望尽可能精确，以使我们的排序更准确。
- en: Now, when our `MessageService` calls `get_all_messages`, it will also know how
    long each message has to live. With this, we can create a new helper function
    to sort the messages.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们的`MessageService`调用`get_all_messages`时，它还将知道每条消息的存活时间。有了这个，我们可以创建一个新的辅助函数来对消息进行排序。
- en: 'First, add the following to our imports:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将以下内容添加到我们的导入中：
- en: '[PRE74]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Outside of the `MessageService` class, create the following function:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MessageService`类之外，创建以下函数：
- en: '[PRE75]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This uses Python's built-in `sorted` function, which has the ability to return
    a sorted list from a given iterable; in our case the iterable is `messages`. We
    use `key` to specify what we want `messages` to be sorted by. Since we want the
    `messages` to be sorted by `expires_in`, we use an `itemgetter` to extract it
    to be used as the comparison. We've given the `sort_messages_by_expiry` function
    an optional parameter, `reverse`, which, if set to `True`, will make `sorted`
    return the sorted list in a reverse order.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了Python内置的`sorted`函数，该函数能够从给定的可迭代对象返回一个排序后的列表；在我们的情况下，可迭代对象是`messages`。我们使用`key`来指定我们希望`messages`按照什么进行排序。由于我们希望`messages`按照`expires_in`进行排序，因此我们使用`itemgetter`来提取它以用作比较。我们给`sort_messages_by_expiry`函数添加了一个可选参数`reverse`，如果设置为`True`，则会使`sorted`以相反的顺序返回排序后的列表。
- en: 'With this new helper function, we can now amend our `get_all_messages` RPC
    in our `MessageService`:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个新的辅助函数，我们现在可以修改我们`MessageService`中的`get_all_messages` RPC：
- en: '[PRE76]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Our app will now return our messages, sorted with the newest messages at the
    bottom. If you''d like to have the newest messages at the top, then simply change
    `sorted_messages` to be:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用现在将返回我们的消息，按照最新的消息在底部排序。如果您希望最新的消息在顶部，则只需将`sorted_messages`更改为：
- en: '[PRE77]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Our app now fits all the acceptance criteria we specified earlier. We have the
    ability to send messages and get existing messages, and they all expire after
    a configurable amount of time. One thing that is less than ideal is that we rely
    on a browser refresh to fetch the latest state of the messages. We can fix this
    in a number of ways, but I will demonstrate one of the simplest ways to solve
    this; via polling.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用现在符合我们之前指定的所有验收标准。我们有发送消息和获取现有消息的能力，并且它们在可配置的时间后都会过期。不太理想的一点是，我们依赖浏览器刷新来获取消息的最新状态。我们可以通过多种方式来解决这个问题，但我将演示解决这个问题的最简单的方法之一；通过轮询。
- en: By using polling, the browser can constantly make a request to the server to
    get the latest messages without forcing a page refresh. We will have to introduce
    some more JavaScript to achieve this, but so would any other method.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 通过轮询，浏览器可以不断地向服务器发出请求，以获取最新的消息，而无需强制刷新页面。为了实现这一点，我们将不得不引入一些更多的JavaScript，但任何其他方法也都需要。
- en: Browser polling for messages
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器轮询消息
- en: When the browser makes a poll to get the latest messages, our server should
    return the messages in a JSON format. To achieve this, we'll need to create a
    new HTTP endpoint that returns the messages as JSON, without using the Jinja2
    templating. We will first construct a new helper function to create a JSON response,
    setting the correct headers.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器进行轮询以获取最新消息时，我们的服务器应以JSON格式返回消息。为了实现这一点，我们需要创建一个新的HTTP端点，以JSON格式返回消息，而不使用Jinja2模板。我们首先构建一个新的辅助函数来创建一个JSON响应，设置正确的标头。
- en: 'Outside of our WebServer, create the following function:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的WebServer之外，创建以下函数：
- en: '[PRE78]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This is similar to our `create_html_response` from earlier, but here it sets
    the Content-Type to `'application/json'` and converts our data into a valid JSON
    object.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于我们之前的`create_html_response`，但是这里将Content-Type设置为`'application/json'`，并将我们的数据转换为有效的JSON对象。
- en: 'Now, within the WebServer, create the following HTTP entrypoint:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在WebServer中，创建以下HTTP入口点：
- en: '[PRE79]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This will call our `get_all_messages` RPC and return the result as a JSON response
    to the browser. Notice how we are using the same URL, `/messages`, as we do in
    our endpoint, here to send a new message. This is a good example of being RESTful.
    We use a POST request to `/messages` to create a new message and we use a GET
    request to `/messages` to get all messages.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用我们的`get_all_messages` RPC，并将结果作为JSON响应返回给浏览器。请注意，我们在这里使用与我们在端点中使用的相同URL`/messages`，来发送新消息。这是RESTful的一个很好的例子。我们使用POST请求到`/messages`来创建新消息，我们使用GET请求到`/messages`来获取所有消息。
- en: Polling with JavaScript
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript进行轮询
- en: To enable our messages to update automatically without a browser refresh, we
    will create two JavaScript functions—`messagePoll`, which will get the latest
    messages, and `updateMessages`, which will update the HTML with these new messages.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的消息在没有浏览器刷新的情况下自动更新，我们将创建两个JavaScript函数——`messagePoll`，用于获取最新消息，以及`updateMessages`，用于使用这些新消息更新HTML。
- en: 'Start by replacing the Jinja2 `if` block in our `home.html`, which iterates
    through our list of messages, with the following line:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的`home.html`中替换Jinja2 `if`块开始，该块遍历我们的消息列表，并使用以下行替换：
- en: '[PRE80]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This will be used later to hold our new list of messages generated by our jQuery
    function.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在稍后用于保存我们的jQuery函数生成的新消息列表。
- en: 'Inside the `<script>` tags in our `home.html`, write the following code:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`home.html`的`<script>`标签中，编写以下代码：
- en: '[PRE81]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This is another AJAX request, similar to the one we made earlier to send a
    new message, with a few differences:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个AJAX请求，类似于我们之前发送新消息时所做的请求，但有一些不同之处：
- en: Here, we are performing a `GET` request to the new endpoint we made in our `WebServer`
    instead of a `POST` request.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们执行了一个`GET`请求到我们在`WebServer`中创建的新端点，而不是一个`POST`请求。
- en: If successful, we use the `success` callback to call the `updateMessages` function
    that we will create later.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果成功，我们使用`success`回调来调用我们稍后将创建的`updateMessages`函数。
- en: Set `timeout` to 500 milliseconds - this is the amount of time in which we should
    expect a response from our server before giving up.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`timeout`设置为500毫秒 - 这是我们应该在放弃之前从服务器收到响应的时间。
- en: Use `complete`, which allows us to define what happens once the `success` or
    `error` callback has completed - in this case, we set it to call `poll` again
    after 1000 milliseconds using the `setTimeout` function.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`complete`，它允许我们定义`success`或`error`回调完成后发生的事情 - 在这种情况下，我们设置它在1000毫秒后再次调用`poll`，使用`setTimeout`函数。
- en: 'We will now create the `updateMessages` function:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建`updateMessages`函数：
- en: '[PRE82]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'By using this function, we can replace all of the code in our HTML template
    that generates the list of messages in the Jinja2 template. Let''s go through
    this step-by-step:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个函数，我们可以替换Jinja2模板中生成消息列表的所有代码。让我们一步一步来：
- en: First, we get the `messageContainer` within the HTML so that we can update it.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们获取HTML中的`messageContainer`，以便我们可以更新它。
- en: We generate an empty `messageList` array.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们生成一个空的`messageList`数组。
- en: We generate the `emptyMessages` text.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们生成`emptyMessages`文本。
- en: 'We check if the amount of messages is equal to 0:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查消息的数量是否等于0：
- en: If so, we use `.html()` to replace `messageContainer` HTML with `"No messages!"`.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，我们使用`.html()`将`messageContainer`的HTML替换为`"没有消息！"`。
- en: Otherwise, for each message in `messages`, we first strip any HTML tags that
    could be present using jQuery's built-in `.text()` function. Then we wrap the
    message in `<p>` tags and append them to the `messageList` using `.push()`.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，对于`messages`中的每条消息，我们首先使用jQuery的内置`.text()`函数去除可能存在的任何HTML标签。然后我们将消息包装在`<p>`标签中，并使用`.push()`将它们附加到`messageList`中。
- en: Finally, we use `.html()` to replace the `messageContainer` HTML with the `messagesList`.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`.html()`将`messageContainer`的HTML替换为`messagesList`。
- en: In point *4b*, it's important to escape any HTML tags that could be present
    in the message, as a malicious user could send a nasty script as a message, which
    would be executed by everyone using the app!
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在*4b*点，重要的是要转义消息中可能存在的任何HTML标签，因为恶意用户可能发送一条恶意脚本作为消息，这将被每个使用该应用程序的人执行！
- en: This is by no means the best way to solve the issue of having to force refresh
    the browser to update the messages, but it is one of the simplest ways for me
    to demonstrate in this book. There are probably more elegant ways to achieve the
    polling, and if you really wanted to do this properly then WebSockets is by far
    your best option here.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝不是解决不得不强制刷新浏览器以更新消息的问题的最佳方法，但对我来说，这是在本书中演示的最简单的方法之一。可能有更优雅的方法来实现轮询，如果你真的想要做到这一点，那么WebSockets绝对是你在这里的最佳选择。
- en: Summary
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This now brings us to a close with the guide to writing the TempMessenger application.
    If you have never used Nameko before or written a microservice, I hope I have
    given you a good base to build on when it comes to keeping services small and
    to the point.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就结束了编写TempMessenger应用程序的指南。如果你以前从未使用过Nameko或编写过微服务，我希望我已经为你提供了一个很好的基础，以便在保持服务小而简洁方面进行构建。
- en: We started by creating a service with a single RPC method and then used that
    within another service via HTTP. We then looked at ways in which we can test Nameko
    services with fixtures that allow us to spawn workers and even the services themselves.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个具有单个RPC方法的服务，然后通过HTTP在另一个服务中使用它。然后我们看了一下我们如何使用允许我们生成工作者甚至服务本身的固定装置来测试Nameko服务。
- en: We introduced dependency providers and created a Redis client with the ability
    to get a single message. With that, we expanded the Redis dependency with methods
    that allowed us to save new messages, expire messages, and return them all in
    a list.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了依赖提供程序，并创建了一个Redis客户端，具有获取单个消息的能力。然后，我们扩展了Redis依赖，增加了允许我们保存新消息、过期消息并以列表形式返回它们的方法。
- en: We looked at how we can return HTML to the browser using Jinja2, and at creating
    a dependency provider. We even looked at some JavaScript and JQuery to enable
    us to make requests from the browser.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了如何使用Jinja2将HTML返回给浏览器，并创建了一个依赖提供程序。我们甚至看了一些JavaScript和JQuery，使我们能够从浏览器发出请求。
- en: One of the main themes you will have probably noticed is the need to keep dependency
    logic away from your service code. By doing this we keep our services agnostic
    to the workings that are specific to only that dependency. What if we decided
    to switch Redis for a MySQL database? In our code, it would just be a case of
    creating a new dependency provider for MySQL and new client methods that mapped
    to the ones our `MessageService` expects. We'd then make the minimal change of
    swapping Redis for MySQL in our `MessageService`. If we did not write our code
    in this way then we would have to invest more time and effort to make changes
    to our service. We'd also introduce more scope for bugs to arise.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到的一个主题是需要将依赖逻辑与服务代码分开。通过这样做，我们使我们的服务对只有该依赖特定的工作保持不可知。如果我们决定将Redis替换为MySQL数据库呢？在我们的代码中，只需创建一个新的MySQL依赖提供程序和映射到我们的`MessageService`期望的方法的新客户端方法。然后我们只需最小的更改，将Redis替换为MySQL。如果我们没有以这种方式编写代码，那么我们将不得不投入更多的时间和精力来对我们的服务进行更改。我们还会引入更多的错误可能性。
- en: If you are familiar with other Python frameworks, you should now see how Nameko
    allows us to easily create scalable microservices while still giving us a more
    *batteries not included *approach when compared to something like Django. When
    it comes to writing small services that serve a single purpose that are focused
    on backend tasks, Nameko can be a perfect choice.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉其他Python框架，你现在应该看到Nameko如何让我们轻松创建可扩展的微服务，同时与像Django这样的框架相比，它给我们提供了更多的*不包括电池*的方法。当涉及编写专注于后端任务的小服务时，Nameko可能是一个完美的选择。
- en: In the next chapter, we will look at extending TempMessenger with a User Authentication
    microservice using a PostgreSQL database.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用PostgreSQL数据库来扩展TempMessenger，添加一个用户认证微服务。
