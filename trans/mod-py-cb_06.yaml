- en: Chapter 6. Basics of Classes and Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。类和对象的基础知识
- en: 'In this chapter, we will look at the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下配方：
- en: Using a class to encapsulate data and processing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类封装数据和处理
- en: Designing classes with lots of processing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计具有大量处理的类
- en: Designing classes with little unique processing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计具有少量独特处理的类
- en: Optimizing small objects with __slots__
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用__slots__优化小对象
- en: Using more sophisticated collections
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更复杂的集合
- en: Extending a collection – a list that does statistics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展集合-执行统计的列表
- en: Using properties for lazy attributes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用惰性属性
- en: Using settable properties to update eager attributes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可设置属性来更新急切属性
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The point of computing is to process data. Even when building something like
    an interactive game, both the game state and the player's actions are the data;
    the processing computes the next game state and the display update.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 计算的目的是处理数据。即使构建像交互式游戏这样的东西，游戏状态和玩家的行动也是数据；处理计算下一个游戏状态和显示更新。
- en: Some games can have a relatively complex internal state. When we think of console
    games with multiple players and sophisticated graphics, there are complex, real-time
    state changes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一些游戏可能有相对复杂的内部状态。当我们考虑具有多个玩家和复杂图形的控制台游戏时，会有复杂的实时状态变化。
- en: On the other hand, when we think of a casino game, such as *Craps* , the game
    state is very simple. There may be no point established, or one of the numbers
    4, 5, 6, 8, 9, or 10 may be the established point. The transitions are relatively
    simple, and are often denoted by moving markers and chips around on the casino
    table. The data includes the current state, player actions, and rolls of the dice.
    The processing is the rules of the game.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当我们想到像*Craps*这样的赌场游戏时，游戏状态非常简单。可能没有建立点，或者4、5、6、8、9或10中的一个数字可能是已建立的点。转换相对简单，通常通过在赌场桌上移动标记和筹码来表示。数据包括当前状态、玩家行动和骰子的投掷。处理是游戏规则。
- en: A game such as *Blackjack* has a somewhat more complex internal state change
    as each card is accepted. In games where the hands can be split, the state of
    play can become quite complex. The data includes the current game state, the player's
    commands, and the cards drawn from the deck. Processing is defined by the rules
    of the game as modified by any house rules.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 像*Blackjack*这样的游戏在每张牌被接受时有一个稍微复杂的内部状态变化。在手牌可以分开的游戏中，游戏状态可能会变得非常复杂。数据包括当前游戏状态、玩家的命令和从牌堆中抽出的牌。处理由游戏规则定义，这些规则可能会受到任何庄家规则的修改。
- en: In the case of *craps* , the player may place bets. Interestingly, the player's
    input has no effect on the game state. The internal state of the game object is
    determined entirely by the next throw of the dice. This leads to a class design
    that's relatively easy to visualize.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在*craps*的情况下，玩家可以下注。有趣的是，玩家的输入对游戏状态没有影响。游戏对象的内部状态完全由骰子的下一次投掷决定。这导致了一个相对容易可视化的类设计。
- en: In this chapter, we will create classes that implement a number of statistical
    formulae. The math can be a little daunting at first. Almost everything will be
    based on the summation of a sequence of values, often shown as ∑ *x* . In many
    cases, this can be implemented using Python's `sum()` function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建实现多个统计公式的类。一开始数学可能有点令人生畏。几乎所有东西都基于一系列值的总和，通常表示为∑ *x*。在许多情况下，这可以使用Python的`sum()`函数来实现。
- en: Using a class to encapsulate data and processing
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类封装数据和处理
- en: The essential idea of computing is to process data. This is exemplified when
    we write functions that process data. We looked at this in [Chapter 3](text00039.html#page
    "Chapter 3. Function Definitions") , *Function Definitions* .
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 计算的基本思想是处理数据。当我们编写处理数据的函数时，这一点得到了体现。我们在[第3章](text00039.html#page "第3章。函数定义")中已经看到了这一点，*函数定义*。
- en: Often, we'd like to have a number of closely related functions that work with
    a common data structure. This concept is the heart of object-oriented programming.
    A class definition will contain a number of methods that all control the internal
    state of an object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望有许多与共同数据结构一起工作的相关函数。这个概念是面向对象编程的核心。类定义将包含许多控制对象内部状态的方法。
- en: The unifying concept behind a class definition is often captured as a summary
    of the responsibilities allocated to the class. How can we do this effectively?
    What's a good way to design a class?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义背后的统一概念通常被概括为分配给类的责任的摘要。我们如何有效地做到这一点？设计类的好方法是什么？
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's look at a simple, stateful object—a pair of dice. The context for this
    is an application that simulates the casino game of *Craps* . The goal is to use
    a simulation of results to help invent a better playing strategy. This will save
    us from losing real money while we try to beat the house edge.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的、有状态的对象——一对骰子。这是一个模拟*Craps*赌场游戏的应用程序的背景。目标是利用结果的模拟来帮助发明更好的游戏策略。这将使我们在试图击败庄家优势时不会失去真钱。
- en: There's an important distinction between the class definition and an instance
    of the class, called an **object** . We call this idea **object-oriented programming**
    as a whole. Our focus is on writing class definitions. Our overall application
    will create instances of the classes. The behavior that emerges from the collaboration
    of the instances is the overall goal of the design process.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义和类的实例之间有一个重要的区别，称为**对象**。我们将这个想法称为**面向对象编程**。我们的重点是编写类定义。我们的整体应用程序将创建类的实例。从实例的协作中产生的行为是设计过程的总体目标。
- en: Most of the design effort is on class definitions. Because of this, the name
    object-oriented programming can be misleading.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分设计工作都在类定义上。因此，面向对象编程这个名字可能会误导人。
- en: The idea of **emergent behavior** is an essential ingredient in object-oriented
    programming. We don't specify every behavior of a program. Instead, we decompose
    the program into objects, and define the object's state and behavior via the object's
    classes. The programming decomposes into class definitions based on their responsibilities
    and collaborations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**新兴行为**的概念是面向对象编程中的一个重要组成部分。我们不指定程序的每个行为。相反，我们将程序分解为对象，并通过对象的类定义对象的状态和行为。编程根据其责任和协作分解为类定义。'
- en: An object should be viewed as a thing—a noun. The behaviors of the class should
    be viewed as verbs. This gives us a hint as to how we can proceed to design classes
    that work effectively.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对象应该被视为一个东西——一个名词。类的行为应该被视为动词。这给了我们一个提示，关于我们如何可以继续设计有效工作的类。
- en: Object-oriented design is often easiest to understand when it relates to tangible
    real-world things. It's often easier to write software to simulate a playing card
    than to create software that implements an **Abstract Data Type** .
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当与有形的现实世界的事物相关联时，面向对象设计通常更容易理解。模拟一张纸牌的游戏往往比创建实现**抽象数据类型**的软件更容易。
- en: For this example, we'll simulate the rolling of dice. For some games, such as
    the casino game of *Craps* , two dice are used. We'll define a class that models
    the pair of dice. To be sure that the example is tangible, we'll model the pair
    of dice in the context of simulating a casino game.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将模拟掷骰子。对于一些游戏，比如赌场游戏*Craps*，会使用两个骰子。我们将定义一个模拟一对骰子的类。为了确保例子是有形的，我们将在模拟赌场游戏的情境中模拟一对骰子。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Write down simple sentences that describe what an instance of the class does.
    We can call these the problem statements. It''s essential to focus on short sentences,
    and emphasize the nouns and verbs:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写下简单的句子，描述类的实例做什么。我们可以称这些为问题陈述。专注于简短的句子，并强调名词和动词是至关重要的：
- en: The game of *Craps* has two standard dice.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Craps*游戏有两个标准骰子。'
- en: Each die has six faces, with point values from one to six.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个骰子有六个面，点数从一到六。
- en: Dice are rolled by a player.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家掷骰子。
- en: The total of the dice changes the state of the *craps* game. Those rules are
    separate from the dice, however.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 骰子的总和改变了*craps*游戏的状态。然而，这些规则与骰子是分开的。
- en: If the two dice match, the number was rolled the hard way. If the two dice do
    not match, the number was easy. Some bets depend on this hard-easy distinction.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个骰子匹配，这个数字是通过困难方式掷出的。如果两个骰子不匹配，这个数字是容易掷出的。一些赌注取决于这种困难和容易的区别。
- en: Identify all of the nouns in the sentences. Nouns may identify different classes
    of objects. These are **collaborators** . Examples include player and game. Nouns
    may also identify attributes of objects in questions. Examples include face and
    point value.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别句子中的所有名词。名词可能标识不同类的对象。这些是**合作者**。例如玩家和游戏。名词也可能标识所讨论对象的属性。例如面和点数。
- en: Identify all the verbs in the sentences. Verbs are generally methods of the
    class in question. Examples include rolled and match. Sometimes, they are methods
    of other classes. One example is change the state, which applies to *Craps* .
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别句子中的所有动词。动词通常是所讨论的类的方法。例如，rolled和match。有时，它们是其他类的方法。一个例子是改变状态，这适用于*Craps*。
- en: Identify any adjectives. Adjectives are words or phrases that clarify a noun.
    In many cases, some adjectives will clearly be properties of an object. In other
    cases, the adjectives will describe relationships among objects. In our example,
    a phrase such as *the total of the dice* is an example of a prepositional phrase
    taking the role of an adjective. The *the total of* phrase modifies the noun *the
    dice* . The total is a property of the pair of dice.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别任何形容词。形容词是澄清名词的词或短语。在许多情况下，一些形容词显然是对象的属性。在其他情况下，形容词将描述对象之间的关系。在我们的例子中，诸如*骰子的总和*这样的短语就是一个介词短语作为形容词的例子。*骰子的总和*短语修改了名词*骰子*。总和是一对骰子的属性。
- en: 'Start writing the class with the `class` statement:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`class`语句开始编写类：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Initialize the object''s attributes in the `__init__` method:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__init__`方法中初始化对象的属性：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We'll model the internal state of the dice with the `self.faces` attribute.
    The `self` variable is required to be sure that we're referencing an attribute
    of a given instance of a class. The object is identified by the value of the instance
    variable, `self` .
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用`self.faces`属性来模拟骰子的内部状态。`self`变量是必需的，以确保我们引用的是类的给定实例的属性。对象由实例变量`self`的值来标识。
- en: We could also put some other properties here. The alternative is to implement
    the properties as separate methods. The details of this design decision are the
    subject of the *Using properties for lazy attributes* recipe later on in this
    chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在这里放一些其他属性。另一种选择是将属性实现为单独的方法。这种设计决策的细节将在本章后面的*使用属性进行惰性属性*中讨论。
- en: 'Define the object''s methods based on the various verbs. In our case, we have
    several methods that must be defined:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据不同的动词定义对象的方法。在我们的例子中，我们必须定义几种方法：
- en: 'Here''s how we can implement dice are rolled by a player:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是我们如何实现玩家掷骰子的方法：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We've updated the internal state of the dice by setting the `self.faces` attribute.
    Again, the `self` variable is essential for identifying the object to be updated.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`self.faces`属性来更新骰子的内部状态。同样，`self`变量对于标识要更新的对象是至关重要的。
- en: Note that this method mutates the internal state of the object. We've elected
    to not return a value. This makes our approach somewhat like the approach of Python's
    built-in collection classes. Any method that mutates the object does not return
    a value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个方法改变了对象的内部状态。我们选择不返回一个值。这使得我们的方法有点像Python内置的集合类的方法。任何改变对象的方法都不返回一个值。
- en: This method helps implement the total of the dice changes the state of the *craps*
    game. The game is a separate object, but this method provides a total that fits
    the sentence.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法有助于实现骰子的总和改变了*craps*游戏的状态。游戏是一个独立的对象，但这个方法提供了一个符合句子的总和。
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These two methods help answer the hardways and easyways questions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法有助于回答hardways和easyways的问题。
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's rare in a casino game to have a rule that has a simple logical inverse.
    It's more common to have a rare third alternative that has a remarkably bad payoff
    rule. In this case, we could have defined `easyway` as return `not self.hardway()`
    .
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在赌场游戏中很少有一个具有简单逻辑反义的规则。更常见的是有一个罕见的第三种选择，它有一个非常糟糕的回报规则。在这种情况下，我们可以将`easyway`定义为返回`not
    self.hardway()`。
- en: 'Here''s an example of using the class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用该类的示例：
- en: 'First, we''ll seed the random number generator with a fixed value so that we
    can get a fixed sequence of results. This is a way of creating a unit test for
    this class:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将用一个固定值来初始化随机数生成器，这样我们就可以得到一个固定的结果序列。这是为这个类创建一个单元测试的一种方式：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''ll create a `Dice` object, `d1` . We can then set its state with the `roll()`
    method. We''ll then look at the `total()` method to see what was rolled. We''ll
    examine the state by looking at the faces attribute:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个`Dice`对象，`d1`。然后我们可以用`roll()`方法设置它的状态。然后我们将查看`total()`方法来看看掷出了什么。我们可以通过查看`faces`属性来检查状态：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''ll create a second `Dice` object, `d2` . We can then set its state with
    the `roll()` method. We''ll look at the result of the `total()` method, as well
    as the `hardway()` method. We''ll examine the state by looking at the `faces`
    attribute:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建第二个`Dice`对象，`d2`。然后我们可以用`roll()`方法设置它的状态。我们将查看`total()`方法的结果，以及`hardway()`方法。我们可以通过查看`faces`属性来检查状态：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since the two objects are independent instances of the `Dice` class, a change
    to `d2` has no effect on `d1` :'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这两个对象是`Dice`类的独立实例，对`d2`的更改不会影响`d1`：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The core idea here is to use ordinary rules of grammar—nouns, verbs, and adjectives—as
    a way to identify basic features of a class. Nouns represent things. A good descriptive
    sentence should focus on tangible, real-world things more than ideas or abstractions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的核心思想是利用语法的普通规则——名词、动词和形容词——作为识别类的基本特征的一种方式。名词代表事物。一个好的描述性句子应该更多地关注有形的、现实世界的事物，而不是想法或抽象概念。
- en: In our example, dice are real things. We try to avoid using abstract terms such
    as randomizers or event generators. It's easier to describe the tangible features
    of real things, and then locate an abstract implementation that offers some of
    the tangible features.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，骰子是真实的事物。我们尽量避免使用抽象术语，比如随机器或事件生成器。更容易描述真实事物的有形特征，然后找到一个提供一些有形特征的抽象实现。
- en: The idea of rolling the dice is an example physical action that we can model
    with a method definition. Clearly, this action changes the state of the object.
    In rare cases—one time in 36—the next state will happen to match the previous
    state.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 掷骰子的想法是一个我们可以用方法定义来模拟的物理动作的例子。显然，这个动作改变了对象的状态。在罕见的情况下——36次中有一次——下一个状态恰好与上一个状态匹配。
- en: 'Adjectives often hold the potential for confusion. The following are descriptions
    of the most common ways in which adjectives operate:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 形容词经常会引起混淆。以下是形容词操作最常见的方式的描述：
- en: Some adjectives, such as first, last, least, most, next, previous, and so on,
    will have a simple interpretation. These can have a lazy implementation as a method,
    or an eager implementation as an attribute value.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些形容词，比如first、last、least、most、next、previous等，会有一个简单的解释。这些可以作为方法的懒惰实现，或作为属性值的急切实现。
- en: Some adjectives are a more complex phrase, such as *the total of the dice* .
    This is an adjective phrase built from a noun (total) and a preposition (of).
    This, too, can be seen as a method or an attribute.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些形容词是更复杂的短语，比如*骰子的总和*。这是一个由名词（总和）和介词（of）构成的形容词短语。这也可以被视为一个方法或属性。
- en: Some adjectives involve nouns that appear elsewhere in our software. We might
    have a phrase such as *the state of the Craps game* , where *state of* modifies
    another object, the *Craps* game. This is clearly only tangentially related to
    the dice themselves. This may reflect a relationship between dice and game.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些形容词涉及到在我们的软件中出现的其他名词。我们可能会有一个短语，比如*Craps游戏的状态*，其中*状态*修改另一个对象，*Craps*游戏。这显然只是与骰子本身有关的间接关系。这可能反映了骰子和游戏之间的关系。
- en: 'We might add a sentence to the problem statement such as *the dice are part
    of the game* . This can help clarify the presence of a relationship between game
    and dice. Prepositional phrases, such as *are part of* , can always be reversed
    to create the statement from the other object''s point of view: for example, *The
    game contains dice* . This can help clarify the relationships among objects.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在问题陈述中添加一句话，比如*骰子是游戏的一部分*。这可以帮助澄清游戏和骰子之间的关系。例如，介词短语*是...的一部分*总是可以颠倒过来，从另一个对象的角度来创建陈述：例如*游戏包含骰子*。这可以帮助澄清对象之间的关系。
- en: In Python, the attributes of an object are by default dynamic. We don't specify
    a fixed list of attributes. We can initialize some (or all) of the attributes
    in the `__init__()` method of a class definition. Since attributes aren't static,
    we have considerable flexibility in our design.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，对象的属性默认是动态的。我们不指定一个固定的属性列表。我们可以在类定义的`__init__()`方法中初始化一些（或全部）属性。由于属性不是静态的，我们在设计上有相当大的灵活性。
- en: There's more...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Capturing the essential internal state and methods that cause state change
    is the first step in good class design. We can summarize some helpful design principles
    using the acronym **S.O.L.I.D** .:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 捕捉内部状态和导致状态改变的方法是良好类设计的第一步。我们可以使用缩写**S.O.L.I.D**总结一些有用的设计原则。：
- en: '**Single Responsibility Principle** : A class should have one clearly defined
    responsibility.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一责任原则**：一个类应该有一个明确定义的责任。'
- en: '**Open/Closed Principle** : A class should be open to extension-generally via
    inheritance, but closed to modification. We should design our classes so that
    we don''t need to tweak the code to add or change features.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则**：一个类应该对扩展开放-通常通过继承，但对修改关闭。我们应该设计我们的类，以便我们不需要调整代码来添加或更改功能。'
- en: '**Liskov Substitution Principle** : We need to design inheritance so that a
    subclass can be used in place of the superclass.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换原则**：我们需要设计继承，使得子类可以替换父类。'
- en: '**Interface Segregation Principle** : When writing a problem statement, we
    want to be sure that collaborating classes have as few dependencies as possible.
    In many cases, this principle will lead us to decompose large problems into many
    small class definitions.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**：在编写问题陈述时，我们希望确保协作类的依赖尽可能少。在许多情况下，这个原则会导致我们将大问题分解为许多小类定义。'
- en: '**Dependency Inversion Principle** : It''s less than ideal for a class to depend
    directly on other classes. It''s better if a class depends on an abstraction,
    and a concrete implementation class is substituted for the abstract class.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖反转原则**：一个类直接依赖于其他类并不理想。最好是一个类依赖于一个抽象，而具体的实现类替换抽象类。'
- en: The goal is to create classes that have the proper behavior and also adhere
    to the design principles.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是创建具有适当行为并遵守设计原则的类。
- en: See also
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: See the *Using properties for lazy attributes* recipe, where we'll look at the
    choice between an eager attribute and a lazy property
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见*使用属性进行延迟属性*配方，我们将讨论急切属性和延迟属性之间的选择
- en: In [Chapter 7](text00079.html#page "Chapter 7. More Advanced Class Design")
    , *More Advanced Class Design* , we'll look in more depth at class design techniques
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](text00079.html#page "第7章。更高级的类设计") ，*更高级的类设计*，我们将更深入地研究类设计技术
- en: See [Chapter 11](text00120.html#page "Chapter 11. Testing") , *Testing* , for
    recipes on how to write appropriate unit tests for the class
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见[第11章](text00120.html#page "第11章。测试") ，*测试*，了解如何为类编写适当的单元测试的方法
- en: Designing classes with lots of processing
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计具有大量处理的类
- en: Most of the time, an object will contain all of the data that defines its internal
    state. However, this isn't always true. There are cases where a class doesn't
    really need to hold the data, but instead can hold the processing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，一个对象将包含定义其内部状态的所有数据。然而，这并不总是正确的。有些情况下，一个类并不真正需要保存数据，而是可以保存处理过程。
- en: Some prime examples of this design are statistical processing algorithms, which
    are often outside the data being analyzed. The data might be in a `list` or `Counter`
    object. The processing might be a separate class.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的一些典型例子是统计处理算法，这些算法通常在被分析的数据之外。数据可能在`list`或`Counter`对象中。处理可能是一个单独的类。
- en: In Python, of course, this kind of processing is often implemented using functions.
    See [Chapter 3](text00039.html#page "Chapter 3. Function Definitions") , *Function
    Definitions* for more information on this. In some languages, all code must take
    the form of a class, leading to some extra complexity.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Python中，这种处理通常是使用函数实现的。有关更多信息，请参见[第3章](text00039.html#page "第3章。函数定义") ，*函数定义*。在某些语言中，所有代码必须采用类的形式，这会导致一些额外的复杂性。
- en: How can we design a class that makes use of Python's array of sophisticated
    built-in collections?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何设计一个利用Python的各种复杂内置集合的类？
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures – list,
    set, dict") , *Built-in Data Structures – list, set, dict* , specifically the
    *Using set methods and operators* recipe, we looked at a statistical process called
    the **Coupon Collector's Test** . The concept is that each time we perform some
    process, we save a coupon that describes some aspect or parameter for the process.
    The question is, how many times do I have to perform the process before I collect
    a complete set of coupons?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](text00048.html#page "第4章。内置数据结构-列表、集合、字典") ，*内置数据结构-列表、集合、字典*，特别是*使用集合方法和运算符*配方中，我们研究了一种称为**优惠券收集器测试**的统计过程。其概念是每次执行某个过程时，我们保存一个描述该过程的某个方面或参数的优惠券。问题是，在收集完整的优惠券之前，我需要执行多少次该过程？
- en: If we have customers assigned to different demographic groups based on their
    purchasing habits, we might ask how many online sales we have to make before we've
    seen someone from each of the groups. If the groups are all about the same size,
    it's trivial to predict the average number of customers we encounter before we
    get a complete set of coupons. If the groups are different sizes, it's a little
    more complex to compute the expected time before collecting a full set of coupons.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们根据客户的购买习惯将客户分配到不同的人口统计群体中，我们可能会问在我们看到每个群体的人之前我们需要进行多少次在线销售。如果这些群体的规模大致相同，那么预测在收集完整的优惠券之前我们遇到的平均客户数量是微不足道的。如果这些群体的规模不同，计算在收集完整的优惠券之前的预期时间就会更加复杂。
- en: Let's say we've collected data using a `Counter` object. For more information
    on the various collections, see [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Built-in Data Structures – list, set, dict*
    , specifically the *Using set methods and operators* and *Avoiding mutable default
    values for function parameters* recipes. In this case, the customers fall into
    eight categories with approximately equal numbers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用`Counter`对象收集了数据。有关各种集合的更多信息，请参见[第4章](text00048.html#page "第4章。内置数据结构-列表、集合、字典")
    ，*内置数据结构-列表、集合、字典*，特别是*使用集合方法和运算符*和*避免函数参数的可变默认值*配方。在这种情况下，客户分为八个大致相等的类别。
- en: 'The data looks like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 数据看起来是这样的：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The key is the number of visits needed to get a full set of coupons. The value
    is the number of times that it took the given number of visits. In the preceding
    line of code `15` visits were required seven different times. `17` visits were
    required five times. This has a long tail. At one point, there were `45` individual
    visits before a full set of eight coupons was collected.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是需要多少次访问才能获得完整的优惠券集。值是需要给定次数的访问次数。在前一行代码中，需要15次访问七次。需要17次访问五次。这有一个很长的尾巴。有一次，收集完整的八张优惠券需要45次单独的访问。
- en: 'We want to compute some statistics on this `Counter` . We have two overall
    strategies for doing this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想对这个`Counter`进行一些统计。我们有两种整体策略来做到这一点：
- en: '**Extend** : We can extend the `Counter` class definition to add statistical
    processing. The complexity of this varies with the kind of processing that we
    want to introduce. We''ll cover this in detail in the *Extending a collection
    – a list that does statistics* recipe, as well as [Chapter 7](text00079.html#page
    "Chapter 7. More Advanced Class Design") , *More Advanced Class Design* .'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展**：我们可以扩展`Counter`类定义以添加统计处理。这取决于我们想要引入的处理类型的复杂性。我们将在*扩展集合 - 进行统计的列表*食谱中详细介绍这一点，以及[第7章](text00079.html#page
    "第7章。更高级的类设计")中的*更高级的类设计*。'
- en: '**Wrap** : We can wrap the `Counter` object in another class that provides
    just the features we need. When we do this, though, we''ll often have to expose
    some additional methods that are an important part of Python, but which don''t
    matter much for our application. We''ll look at this in [Chapter 7](text00079.html#page
    "Chapter 7. More Advanced Class Design") , *More Advanced Class Design* .'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：我们可以将`Counter`对象封装在另一个类中，该类仅提供我们需要的功能。不过，当我们这样做时，通常需要公开一些额外的方法，这些方法是Python的重要部分，但对于我们的应用程序并不重要。我们将在[第7章](text00079.html#page
    "第7章。更高级的类设计")中讨论这一点，*更高级的类设计*。'
- en: There's a variation on wrapping where we use a statistical computation object
    to wrap an object from a built-in collection. This often leads to an elegant solution.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 封装的变体是我们使用统计计算对象来封装内置集合中的对象。这通常会导致一个优雅的解决方案。
- en: 'We have two ways to design the processing. These two design alternatives apply
    to both overall architectural choices:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种设计处理的方式。这两种设计选择都适用于整体架构选择：
- en: '**Eager** : This means that we''ll compute the statistics as soon as possible.
    The values can then be attributes of the class. While this can improve performance,
    it also means that any change to the data collection will invalidate the eagerly
    computed values. We have to examine the overall context to see if this can happen.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**急切**：这意味着我们将尽快计算统计数据。这些值可以成为类的属性。虽然这可以提高性能，但也意味着对数据收集的任何更改都将使急切计算的值无效。我们必须检查整体上下文，看看是否会发生这种情况。'
- en: '**Lazy** : This means we won''t compute anything until it''s required via a
    method function or property. We''ll look at this in the *Using properties for
    lazy attributes* recipe.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**懒惰**：这意味着我们不会计算任何东西，直到通过方法函数或属性需要。我们将在*使用属性进行延迟属性*食谱中讨论这一点。'
- en: The essential math for both designs is the same. The only question is when the
    computation is done.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种设计的基本数学是相同的。唯一的问题是何时进行计算。
- en: 'We compute the mean using a sum of the expected values. The expected value
    is the frequency of a value multiplied by the value. The mean, *μ* , is this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用预期值的总和来计算平均值。预期值是值的频率乘以值。平均值*μ*就是这样的：
- en: '![Getting ready](Image00013.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](Image00013.jpg)'
- en: Here, *k* is the key from the `Counter` , *C* , and *f[k]* is the frequency
    value for the given key from the `Counter` .
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*k*是来自`Counter`的键，*C*，*f[k]*是来自`Counter`的给定键的频率值。
- en: 'The standard deviation, *σ* , depends on the mean, *μ* . This also involves
    computing a sum of values, each of which is weighted by frequency. The following
    is the formula:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 标准差*σ*取决于平均值*μ*。这还涉及计算一系列值的总和，每个值都由频率加权。以下是公式：
- en: '![Getting ready](Image00014.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](Image00014.jpg)'
- en: Here, *k* is the key from the `Counter` , *C* , and *f[k]* is the frequency
    value for the given key from the `Counter` . The total number of items in the
    `Counter` is ![Getting ready](Image00015.jpg)  . This is the sum of the frequencies.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*k*是来自`Counter`的键，*C*，*f[k]*是来自`Counter`的给定键的频率值。`Counter`中的项目总数是![准备就绪](Image00015.jpg)。这是频率的总和。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Define the class with a descriptive name:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一个描述性的名称定义类：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Write the `__init__` method to include the object to which this object will
    be connected:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`__init__`方法以包括将连接到该对象的对象：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We've defined a method function that takes a `Counter` object as an argument
    value. This `Counter` object is saved as part of the `Counter_Statistics` instance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个方法函数，它以`Counter`对象作为参数值。这个`Counter`对象被保存为`Counter_Statistics`实例的一部分。
- en: 'Initialize any other local variables that might be useful. Since we''re going
    to calculate values eagerly, the most eager possible time is when the object is
    created. We''ll write references to some yet to be defined functions:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化可能有用的任何其他本地变量。由于我们将急切地计算值，最急切的可能时间是在创建对象时。我们将写一些尚未定义的函数的引用：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We've eagerly computed the mean and standard deviation from the `Counter` object,
    and saved them in two instance variables.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经急切地从`Counter`对象计算了平均值和标准差，并将它们保存在两个实例变量中。
- en: 'Define the required methods for the various values. Here''s the calculation
    of the mean:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为各种值定义所需的方法。这是平均值的计算：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here''s how we can calculate the standard deviation:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们如何计算标准差的方法：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that this calculation requires that the mean is computed first and the
    `self.mean` instance variable has been created.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个计算要求首先计算平均值，并且`self.mean`实例变量已经被创建。
- en: Also, this uses `math.sqrt()` . Be sure to add the needed `import math` statement
    in the Python file.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这使用了`math.sqrt()`。确保在Python文件中添加所需的`import math`语句。
- en: 'Here''s how we can create some sample data:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何创建一些样本数据的方法：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've imported functions such as `expected()` , `arrival1()` , and `coupon_collector()`
    from the `ch04_r06` module. We've also imported the `Counter` collection from
    the standard library `collections` module.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`ch04_r06`模块导入了`expected()`、`arrival1()`和`coupon_collector()`等函数。我们还从标准库的`collections`模块导入了`Counter`集合。
- en: We defined a function, `raw_data()` , that will generate a number of customer
    visits. By default, it will be 1,000 visits. The domain will be eight different
    classes of customers; each class will have an equal number of members. We'll use
    the `coupon_collector()` function to step through the data, emitting the number
    of visits required to collect a full set of eight coupons.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`raw_data()`的函数，它将生成一定数量的顾客访问。默认情况下，将会有1,000次访问。领域将包括八种不同类别的顾客；每个类别将有相同数量的成员。我们将使用`coupon_collector()`函数来遍历数据，输出收集到完整的八张优惠券所需的访问次数。
- en: This data is then used to assemble a `Counter` object. This will have the number
    of customers required to get a full set of coupons. Each number of customers will
    also have a frequency showing how often that number of visits occurred.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用这些数据来组装一个`Counter`对象。这将包括获取完整一套优惠券所需的顾客数量。每个顾客数量还将有一个频率，显示该访问次数发生的频率。
- en: 'Here''s how we can analyze the `Counter` object:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何分析`Counter`对象的方法：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, we imported the `random` module so that we could pick a known seed value.
    This makes it easier to test and demonstrate an application because the random
    numbers are consistent. We also imported the `CounterStatistics` class from the
    `ch06_r02` module.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入了`random`模块，以便我们可以选择一个已知的种子值。这样可以更容易地测试和演示应用程序，因为随机数是一致的。我们还从`ch06_r02`模块导入了`CounterStatistics`类。
- en: Once we have all of the items defined, we can force the `seed` to a known value,
    and generate the coupon collector test results. The `raw_data()` function will
    emit a `Counter` object, which we called data.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了所有的项目，我们就可以将“seed”强制设定为一个已知的值，并生成收集优惠券的测试结果。`raw_data()`函数将会生成一个我们称之为数据的`Counter`对象。
- en: We'll use the `Counter` object to create an instance of the `CounterStatistics`
    class. We'll assign this to the `stats` variable. Creating this instance will
    also compute some summary statistics. These values are available as the `stats.mean`
    attribute and the `stats.stddev` attribute.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Counter`对象来创建`CounterStatistics`类的一个实例。我们将把这个实例分配给`stats`变量。创建这个实例也将计算一些摘要统计数据。这些值可以作为`stats.mean`属性和`stats.stddev`属性获得。
- en: For a set of eight coupons, the theoretical average is `21.7` visits to collect
    all coupons. It looks like the results from `raw_data()` show behavior that matches
    the expectation of random visits. This is sometimes called the **null hypothesis**
    —the data is random.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一组八张优惠券，理论平均值是`21.7`次访问以收集所有优惠券。看起来`raw_data()`的结果显示了与随机访问预期相匹配的行为。这有时被称为**零假设**——数据是随机的。
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This class encapsulates two complex algorithms, but doesn't include any data
    that changes state. This kind of class doesn't need to retain a lot of data. Instead,
    the design performs all of the computations as soon as possible.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类封装了两个复杂的算法，但不包括任何改变状态的数据。这种类不需要保留大量数据。相反，设计尽快执行所有计算。
- en: We wrote a high-level specification for the processing and placed it in the
    `__init__()` method. Then we wrote methods to implement the processing steps that
    were specified. We can set as many attributes as are needed, making this a very
    flexible approach.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为处理编写了一个高级规范，并将其放在`__init__()`方法中。然后我们编写了实现指定处理步骤的方法。我们可以设置所需的属性数量，使其成为一种非常灵活的方法。
- en: The advantage of this design is that the attribute values can be used repeatedly.
    The cost of computation is paid once; each time an attribute value is used, no
    further calculating is required.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的优点是属性值可以被重复使用。计算成本只需支付一次；每次使用属性值时，无需进一步计算。
- en: The disadvantage of this design is that a change to the underlying `Counter`
    object makes the `CounterStatistics` object obsolete. Generally, we use this kind
    of design when the `Counter` isn't going to change. The example creates a single,
    static `Counter` , which is used to create `CounterStatistics` .
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的缺点是，对底层`Counter`对象的更改会使`CounterStatistics`对象过时。通常，当`Counter`不会改变时，我们使用这种设计。该示例创建了一个单一的静态`Counter`，用于创建`CounterStatistics`。
- en: There's more...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If we need to have stateful objects, we can add update methods that can change
    the `Counter` object. For example, we can introduce a method to add another value
    by delegating the work to the associated `Counter` . This switches the design
    pattern from a simple connection between computation and collection to a proper
    wrapper around the collection.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要有状态的对象，我们可以添加更新方法，可以改变`Counter`对象。例如，我们可以引入一个方法，通过委托工作给相关的`Counter`来添加另一个值。这将把设计模式从计算和收集之间的简单连接转变为对集合的适当封装。
- en: 'The method might look like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法可能如下所示：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we've updated the state of the `Counter` . Then, we recomputed all of
    the derived values. This kind of processing might create tremendous computation
    overheads. There needs to be a compelling reason to recompute the mean and standard
    deviation after every value is changed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们更新了`Counter`的状态。然后，我们重新计算了所有的派生值。这种处理可能会产生巨大的计算开销。需要有一个令人信服的理由，在每次值改变后重新计算均值和标准差。
- en: There are considerably more efficient solutions. For example, if we save two
    intermediate sums and an intermediate count, we can update the sums and counts
    by computing the mean and standard deviation efficiently.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更高效的解决方案。例如，如果我们保存两个中间和一个中间计数，我们可以通过高效地计算平均值和标准差来更新这些和计数。
- en: 'For this, we might have an `__init__()` method that looks like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可能有一个看起来像这样的`__init__()`方法：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've written this method to work either with a `Counter` or without a `Counter`
    . If no data is provided, it will start with an empty collection, and zero values
    for the various sums. When the count is zero, the mean and standard deviation
    have no meaningful value, so `None` is provided.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了这个方法，可以使用`Counter`或不使用`Counter`。如果没有提供数据，它将从一个空集合开始，并且各种总和的值为零。当计数为零时，均值和标准差没有有意义的值，因此提供`None`。
- en: If a `Counter` is provided, then a `count` , `sum` , and sum of squares are
    computed. These can be incrementally adjusted easily, quickly recomputing the
    `mean` and standard deviation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了`Counter`，那么将计算`count`，`sum`和平方和。这些可以很容易地进行增量调整，快速重新计算`mean`和标准差。
- en: 'When a single new value is added, the following method will incrementally recompute
    the various derived values:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加一个新值时，以下方法将逐渐重新计算各种派生值：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Updating the `Counter` object, the `count` , the `sum` , and the sum of squares
    is clearly necessary to be sure that the `count` , `sum` , and sum of squares
    values match the `self.raw_counter` collection at all times. Since we know the
    `count` must be at least `1` , the mean is easy to compute. The standard deviation
    requires at least two values, and is computed from the `sum` and sum of squares.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`Counter`对象，`count`，`sum`和平方和显然是必要的，以确保`count`，`sum`和平方和值始终与`self.raw_counter`集合匹配。由于我们知道`count`至少必须是`1`，因此均值很容易计算。标准差需要至少两个值，并且是从`sum`和平方和计算的。
- en: 'Here''s the formula for this variation on standard deviation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是标准差变体的公式：
- en: '![There''s more...](Image00016.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](Image00016.jpg)'
- en: This involves computing two sums. One sum involves frequency times the value
    squared. The other sum involves the frequency and the value, with the overall
    sum being squared. We've used *C* to represent the total number of values; this
    is the sum of the frequencies.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及计算两个总和。一个总和涉及频率乘以值的平方。另一个总和涉及频率和值，总和是平方的。我们用*C*来表示值的总数；这是频率的总和。
- en: See also
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In the *Extending a collection – a list that does statistics* recipe, we'll
    look at a different design approach where these functions are used to extend a
    class definition.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*扩展集合 - 进行统计的列表*中，我们将看一个不同的设计方法，这些函数用于扩展类定义。
- en: We'll look at different approach in the *Using properties for lazy attributes*
    recipe. This alternative recipe will use properties and compute the attributes
    as needed.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在*使用属性进行惰性属性*中看到不同的方法。这种替代方法将使用属性，并根据需要计算属性。
- en: In the *Designing classes with little unique processing* recipe we'll look at
    a class with no real processing. It acts as a polar opposite of this class.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*设计具有少量独特处理的类*中，我们将看一个没有真正处理的类。它作为这个类的完全相反。
- en: Designing classes with little unique processing
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计具有少量独特处理的类
- en: In some cases, an object is a container of rather complex data, but doesn't
    really do very much processing on that data. Indeed, in many cases, a class can
    be designed that depends only on built-in Python features and doesn't require
    any unique method functions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一个对象是相当复杂的数据的容器，但实际上并不对这些数据进行太多处理。事实上，在许多情况下，可以设计一个仅依赖于内置Python功能并且不需要任何独特方法函数的类。
- en: In many cases, Python's built-in container classes can cover almost all of the
    various use cases for us. The small problem is that the syntax for a dictionary
    or a list isn't quite so elegant as the syntax for attributes of an object.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，Python的内置容器类可以几乎覆盖我们的各种用例。小问题是字典或列表的语法不像对象的属性语法那样优雅。
- en: How can we create a class that allows us to use `object.attribute` syntax instead
    of `object['attribute']` ?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如何创建一个允许我们使用`object.attribute`语法而不是`object['attribute']`的类？
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are really only two cases for any kind of class design:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何类设计，实际上只有两种情况：
- en: Is it stateless? Does it embody a number of attributes, but never changes?
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是无状态的吗？它包含了许多属性，但从不改变吗？
- en: Is it stateful? Will there be state changes for the various attributes?
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是有状态的吗？各种属性会发生状态变化吗？
- en: A stateful design is slightly more general. We can always use a stateful implementation
    and avoid making any changes to the object to support stateless objects. However,
    there are some significant storage and performance advantages of using truly stateless
    objects.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态的设计略微更一般。我们总是可以使用有状态的实现，并避免对对象进行任何更改以支持无状态对象。然而，使用真正无状态的对象有一些重要的存储和性能优势。
- en: 'We''ll use two kinds of class to illustrate both kinds of design:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两种类来说明两种设计：
- en: '**Stateless** : We''ll define a class to describe simple playing cards that
    have a rank and a suit. Since a card''s rank and suit don''t change, we''ll create
    a small stateless class for this.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：我们将定义一个类来描述简单的扑克牌，它有一个等级和一个花色。由于一张牌的等级和花色不会改变，我们将为此创建一个小的无状态类。'
- en: '**Stateful** : We''ll define a class to describe a player''s current state
    in a game of *Blackjack* where there is a dealer''s hand, the player''s hand(s),
    plus an optional insurance bet. There are a number of aspects of play that grow
    during each hand.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有状态**：我们将定义一个类来描述*Blackjack*游戏中玩家当前状态，其中有一个庄家的手，玩家的手，以及一个可选的保险赌注。在每一手中，有许多方面的游戏都在增加。'
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll look at stateless objects and then stateful objects. For stateful objects
    that have no methods, we have two more choices: We can use a new class or we can
    leverage an existing class. These choices lead to three small recipes.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将先看无状态对象，然后是有状态对象。对于没有方法的有状态对象，我们有两个选择：我们可以使用一个新类，或者我们可以利用一个现有的类。这些选择导致三个小的配方。
- en: Stateless objects
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无状态对象
- en: 'We''ll base stateless objects on `collections.namedtuple` .:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将基于`collections.namedtuple`来构建无状态对象。：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define the class name, which will be used twice:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义类名，将使用两次：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Define the attributes of the object:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义对象的属性：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here''s how we can use this class definition to create `Card` objects:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用这个类定义来创建`Card`对象：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''ve created a new class, named `Card` , which has two attribute names: `rank`
    and `suit` . After defining the class, we can create an instance of the class.
    We built a single card object, `eight_hearts` , with a rank of eight and a suit
    of ♡.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个名为`Card`的新类，它有两个属性名称：`rank`和`suit`。在定义类之后，我们可以创建类的实例。我们创建了一个单个的卡片对象`eight_hearts`，它的rank是八，suit是♡。
- en: We can refer to attributes of this object with their name or their position
    within the tuple. When we use `eight_hearts.rank` or `eight_hearts[0]` , we'll
    see the rank attribute because it's defined first in the sequence of attribute
    names.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用对象的名称或元组内的位置引用该对象的属性。当我们使用`eight_hearts.rank`或`eight_hearts[0]`时，我们将看到rank属性，因为它是在属性名称序列中首先定义的。
- en: 'This kind of class definition is relatively rare. It has a fixed, defined set
    of attributes. Generally, Python class definitions have dynamic attributes. Also,
    the object is immutable. Here''s an example of attempting to change the instance
    attributes:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类定义相对较少见。它具有固定的、定义好的属性集。通常，Python类定义具有动态属性。此外，对象是不可变的。以下是尝试更改实例属性的示例：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We attempted to change the `suit` attribute of the object. This raised an `AttributeError`
    exception.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试更改对象的`suit`属性。这引发了一个`AttributeError`异常。
- en: Stateful objects with a new class
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用新类创建有状态对象
- en: 'Define the new class:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义新类：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''ve written an empty class definition. An instance of this class is created
    easily with something like the following:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经编写了一个空的类定义。可以使用类似以下的方式轻松创建此类的实例：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can then add attributes to the object with statements such as the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用以下语句向对象添加属性：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: While this can work out well, it's often helpful to add a few more features
    to a class definition. Generally, we'll add methods, including the `__init__()`
    method, to initialize the instance variables of the object.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能效果很好，但通常有助于向类定义添加更多功能。通常，我们会添加方法，包括`__init__()`方法，以初始化对象的实例变量。
- en: Stateful objects using an existing class
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用现有类的有状态对象
- en: 'Rather than defining an empty class, we can also use modules in the standard
    library. We can use the `argparse` module or the `types` module for this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与其定义一个空类，我们也可以使用标准库中的模块。我们可以使用`argparse`模块或`types`模块来实现这一点：
- en: Import the module.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入模块。
- en: 'The `argparse` module includes the class `Namespace` , which can be used instead
    of an empty class definition:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`argparse`模块包括`Namespace`类，可以用来代替空的类定义：'
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can also use the `SimpleNamespace` from the types module. It looks like
    this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`types`模块中的`SimpleNamespace`。它看起来像这样：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create the class as a reference to the `SimpleNamespace` or `Namespace` :'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类创建为对`SimpleNamespace`或`Namespace`的引用：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Any of these techniques will define a class that can have an indefinite number
    of attributes. However, the `SimpleNamespace` has a more flexible constructor
    than defining our own class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术中的任何一种都将定义一个可以具有无限数量属性的类。然而，`SimpleNamespace`比定义我们自己的类具有更灵活的构造函数：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We've created a new class named `Player` . We don't provide a list of attributes,
    since they're dynamic.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个名为`Player`的新类。我们没有提供属性列表，因为它们是动态的。
- en: When we constructed the `player_1` object, we provided a list of attributes
    that we'd like to create as part of that object. After creating the object, we
    can then make state changes to it; we set the `player_1.bet` value, updated the
    `player_1.stake` , and also updated the `player_1.hand` .
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建`player_1`对象时，我们提供了一个要作为该对象一部分创建的属性列表。创建对象后，我们可以对其进行状态更改；我们设置了`player_1.bet`值，更新了`player_1.stake`，还更新了`player_1.hand`。
- en: When we display the object, all of the attributes are shown. Typically, they're
    provided in alphabetical order, making it slightly easier to write unit test examples.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们显示对象时，所有属性都会显示出来。通常，它们以字母顺序提供，这样稍微容易编写单元测试示例。
- en: When we use a `namedtuple()` function, we're creating a class object. We provide
    a class name as a string, as well as attribute names that will parallel the positional
    values for a tuple. The resulting object needs to be assigned to a variable, and
    it's best practice to make sure that the class name provided as an argument to
    the `nametuple()` function and the variable name are the same.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`namedtuple()`函数时，我们正在创建一个类对象。我们提供一个类名作为字符串，以及与元组的位置值相对应的属性名称。结果对象需要分配给一个变量，并且最好确保作为`nametuple()`函数参数提供的类名和变量名相同。
- en: The class object created by `namedtuple()` is the same kind of class object
    that would be created by the `class` statement. Indeed, if you want to see the
    source, you can use `print(Card._source)` to see exactly what was used to create
    the class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`namedtuple()`创建的类对象与`class`语句创建的类对象是相同类型的类对象。实际上，如果您想要查看源代码，可以使用`print(Card._source)`来查看创建类时使用的确切内容。'
- en: A `namedtuple` class is essentially a tuple with the added feature of named
    attributes. Like all other tuple objects, it's immutable—once built, it cannot
    be changed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`namedtuple`类本质上是一个具有命名属性的元组。与所有其他元组对象一样，它是不可变的——一旦构建，就无法更改。'
- en: When we use the `SimpleNamespace` , we're using a very simple class definition
    that has (almost) no methods. Because attributes are generally dynamic, this class
    allows us to `set` , `get` , and `delete` attributes freely.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`SimpleNamespace`时，我们使用的是一个几乎没有方法的非常简单的类定义。因为属性通常是动态的，所以这个类允许我们自由地`set`，`get`和`delete`属性。
- en: Classes that are not subclasses of `tuple` or that use `__slots__` (a topic
    we'll look at in the *Optimizing small objects with __slots__* recipe) are very
    flexible. There are also some very advanced techniques for altering the way attributes
    behave. These rely on deeper knowledge of how Python's special method names work.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 不是`tuple`的子类或使用`__slots__`（我们将在*使用__slots__优化小对象*中查看的主题）的类非常灵活。还有一些非常高级的技术可以改变属性行为的方式。这些依赖于对Python特殊方法名称如何工作的更深入了解。
- en: There's more...
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In many cases, we''ll decompose our application processing into two broad categories
    of class definitions:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们将把应用程序处理分解为两类类定义：
- en: '**Data – collections and items** : We''ll use built-in collection classes,
    collections from the standard library, and perhaps even items based on `namedtuple()`
    , or `SimpleNamespace` , or other class definitions that seem to focus on generic
    collections of data.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据-集合和项目**：我们将使用内置的集合类、标准库中的集合，甚至基于`namedtuple()`、`SimpleNamespace`或其他似乎专注于通用数据集合的类定义的项目。'
- en: '**Processing** : We''ll define classes in a way similar to the example shown
    in the *Designing classes with lots of processing* recipe. These processing classes
    generally depend on data objects.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理**：我们将以与*设计具有大量处理的类*配方中所示的示例类似的方式定义类。这些处理类通常依赖于数据对象。'
- en: The idea of cleanly separating the data from the processing fits with several
    of the S.O.L.I.D. design principles. In particular, it aligns our classes with
    the Single Responsibility Principle, the Open/Closed Principle, and the Interface
    Segregation Principle. We can create classes with the kind of narrow focus that
    makes change (via subclass extension) relatively simple.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰地将数据与处理分离的想法符合几个S.O.L.I.D.设计原则。特别是，它使我们的类与单一职责原则、开闭原则和接口隔离原则保持一致。我们可以创建具有狭窄焦点的类，这使得通过子类扩展变得相对简单。
- en: See also
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In the *Designing classes with lots of processing* recipe we'll look at a class
    that is entirely processing and almost no data. It acts as the polar opposite
    of this class.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*设计具有大量处理的类*配方中，我们将看到一个完全处理而几乎没有数据的类。它充当了这个类的完全相反的极端。
- en: Optimizing small objects with __slots__
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`__slots__`优化小对象
- en: The general case for an object allows a dynamic collection of attributes, each
    of which has a dynamic value. There's a special case for an immutable object that's
    based on the `tuple` class. We looked at both of these in the *Designing classes
    with little unique processing* recipe.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的一般情况允许动态属性集合，每个属性都有动态值。基于`tuple`类的不可变对象有一个特殊情况。我们在*设计具有少量独特处理的类*配方中都看到了这两种情况。
- en: There's a middle ground—an object with a fixed number of attributes, but the
    values of the attributes can be changed. By changing the class from an unlimited
    collection of attributes to a fixed set of attributes, it turns out that we can
    also save memory and processing time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个中间地带-一个具有固定数量属性的对象，但属性的值可以改变。通过将类从无限属性集合更改为固定属性集合，我们还可以节省内存和处理时间。
- en: How can we create optimized classes with a fixed set of attributes?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何创建具有固定属性集的优化类？
- en: Getting ready
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s look at the idea of a hand of playing cards in the casino game of *Blackjack*
    . There are two parts to a hand:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在*Blackjack*赌场游戏中一手扑克牌的概念。一手牌有两个部分：
- en: The cards
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 牌
- en: The bet
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赌注
- en: Both have dynamic values. But there are only these two things. It's common to
    get more cards. It's also possible to raise the bet via a double down play.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都具有动态值。但只有这两个东西。通常会获得更多的牌。也可能通过加倍下注来提高赌注。
- en: The idea of a split will create additional hands. Each split hand is a separate
    object, with a distinct collection of cards and a unique bet.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 分牌的想法将创建额外的手牌。每个分牌手是一个独立的对象，具有不同的牌集和独特的赌注。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We''ll leverage the `__slots__` special name when creating the class:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建类时，我们将利用`__slots__`特殊名称：
- en: 'Define the class with a descriptive name:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个具有描述性名称的类：
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Define the list of attribute names:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义属性名称列表：
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This identifies the only two attributes that are allowed for instances of this
    class. Any attempt to add another attribute will raise an `AttributeError` exception.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这标识了允许该类的实例的唯一两个属性。任何尝试添加其他属性的尝试都将引发`AttributeError`异常。
- en: 'Add an initialization method:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个初始化方法：
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Generally, each hand starts as a bet. The dealer then deals two initial cards
    to the hand. Under some circumstances, though, we might want to rebuild a `Hand`
    object from a sequence of `Card` instances.We've used a feature of the `or` operator.
    If the left side operand is not a false-like value (that is, `None` ,) then that's
    the value of an `or` expression. If the left side operand is false-like, then
    the right side operand is evaluated. For more information on why this is necessary,
    see the *Designing functions with optional parameters* recipe in [Chapter 3](text00039.html#page
    "Chapter 3. Function Definitions") , *Function Definitions* .
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，每手牌都以赌注开始。然后庄家向手牌发两张初始牌。但在某些情况下，我们可能想要从一系列`Card`实例重新构建一个`Hand`对象。我们使用了`or`运算符的一个特性。如果左侧操作数不是假值（即`None`），那么它就是`or`表达式的值。如果左侧操作数是假值，那么将评估右侧操作数。有关为什么这是必要的更多信息，请参阅[第3章](text00039.html#page
    "第3章。函数定义")中的*设计具有可选参数的函数*配方，*函数定义*。
- en: 'Add a method to update the collection. We''ve called it `deal` because it''s
    used to deal a new card to the `Hand` :'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个更新集合的方法。我们称之为`deal`，因为它用于向`Hand`发牌：
- en: '[PRE35]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add a `__repr__()` method so that it can be printed easily:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`__repr__()`方法，以便可以轻松打印：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here''s how we can use this class to build a hand of cards. We''ll need the
    definition of the `Card` class based on the example in the *Designing classes
    with little unique processing* recipe:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用这个类来构建一手牌的方法。我们将需要基于*设计具有少量独特处理的类*配方中的示例来定义`Card`类：
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We've imported the `Card` and `Hand` class definitions. We built an instance
    of a `Hand` , `h1` , with a bet of twice the table minimum. We then added two
    cards to the hand via the `deal()` method of the `Hand` class. This shows how
    the `h1.hand` value can be mutated.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了`Card`和`Hand`类的定义。我们创建了一个`Hand`的实例`h1`，赌注是桌面最低赌注的两倍。然后我们通过`Hand`类的`deal()`方法向手牌添加了两张牌。这展示了`h1.hand`值如何被改变。
- en: This example also displays the instance of `h1` to show the bet and the sequence
    of cards. The `__repr__()` method produces output that's in Python syntax.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例还显示了`h1`的实例，以显示赌注和牌的顺序。`__repr__()`方法生成了Python语法的输出。
- en: 'We can also replace the `h1.bet` value when the player doubles down (yes, this
    is a crazy thing to do when showing 12):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家加倍下注时，我们还可以替换`h1.bet`的值（是的，在显示12时这是一个疯狂的事情）：
- en: '[PRE38]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When we displayed the `Hand` object, `h1` , it showed that the `bet` attribute
    was changed.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们显示`Hand`对象`h1`时，它显示`bet`属性已更改。
- en: 'Here''s what happens when we try to create a new attribute:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试创建一个新属性时会发生什么：
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We attempted to create an attribute named `some_other_attribute` on the `Hand`
    object, `h1` . This raised an `AttributeError` exception. Using `__slots__` means
    that new attributes cannot be added to the object.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试在`Hand`对象`h1`上创建一个名为`some_other_attribute`的属性。这引发了一个`AttributeError`异常。使用`__slots__`意味着不能向对象添加新属性。
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When we create a class definition, the behavior is defined in part by the object
    class and the `type()` function. Implicitly, a class is assigned a special `__new__()`
    method that handles the internal house-keeping required to create a new object.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个类定义时，行为部分由对象类和`type()`函数定义。隐式地，一个类被分配了一个特殊的`__new__()`方法，用于处理创建新对象所需的内部工作。
- en: 'Python has three essential paths:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Python有三条基本路径：
- en: The default behavior, which builds a `__dict__` attribute in each object. Because
    the object's attributes are kept in a dictionary, we can add, change, and delete
    attributes freely. This flexibility requires the use of a relatively large amount
    of memory for the dictionary object.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认行为会在每个对象中构建一个`__dict__`属性。因为对象的属性被保存在字典中，我们可以自由地添加、更改和删除属性。这种灵活性需要为字典对象使用相对较大的内存。
- en: The `__slots__` behavior, which avoids the `__dict__` attribute. Because the
    object has only the attributes named in the `__slots__` sequence, we can't add
    or delete attributes. We can change the values of only the defined attributes.
    This lack of flexibility means that less memory is used for each object.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__slots__`行为避免了`__dict__`属性。因为对象只有`__slots__`序列中命名的属性，我们不能添加或删除属性。我们只能更改已定义属性的值。这种缺乏灵活性意味着每个对象使用的内存更少。'
- en: The subclass of `tuple` behavior. These are immutable objects. The easiest way
    to create these is with `namedtuple()` . Once built, they cannot be changed. When
    measuring memory use, these are the thriftiest of all classes of objects.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tuple`的子类行为。这些是不可变的对象。创建它们的最简单方法是使用`namedtuple()`。一旦创建，它们就不能被更改。在测量内存使用时，这些是所有对象类中最节俭的。'
- en: The `__slots__` optimization is used infrequently in Python. The default class
    behavior provides the most flexibility and makes altering a class easy. In some
    cases, however, a large application might be constrained by the amount of memory
    used, and switching just one class to `__slots__` can have a dramatic improvement
    in performance.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Python中很少使用`__slots__`优化。默认的类行为提供了最大的灵活性，并且使得更改类变得容易。然而，在某些情况下，一个大型应用程序可能会受到内存使用量的限制，将一个类切换到`__slots__`可能会显著提高性能。
- en: There's more...
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It's possible to tailor the way the `__new__()` method works to replace the
    default `__dict__` attribute with a different kind of dictionary. This is a rather
    advanced technique because it exposes some more of the inner workings of classes
    and objects.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调整`__new__()`方法的工作方式，以替换默认的`__dict__`属性为不同类型的字典。这是一种相当高级的技术，因为它暴露了一些更多的类和对象的内部工作。
- en: Python relies on a metaclass to create instances of a class. The default metaclass
    is the `type` class. The idea is that the metaclass provides a few pieces of functionality
    that are used to create the object. Once the empty object has been created, then
    the class `__init__()` method will initialize the empty object.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Python依赖于元类来创建类的实例。默认的元类是`type`类。这个想法是元类提供了一些功能，用于创建对象。一旦空对象被创建，类的`__init__()`方法将初始化空对象。
- en: Generally, a metaclass will provide a definition of `__new__()` , and perhaps
    `__prepare__()` , if there's a need to customize the namespace object. There's
    a widely used example in the Python Language Reference document that tweaks the
    namespace used to create a class.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，元类将提供`__new__()`的定义，也许还有`__prepare__()`，如果有必要自定义命名空间对象。Python语言参考文档中有一个广泛使用的示例，调整了用于创建类的命名空间。
- en: For more details, see [https://docs.python.org/3/reference/datamodel.html#metaclass-example](https://docs.python.org/3/reference/datamodel.html#metaclass-example)
    .
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参见[https://docs.python.org/3/reference/datamodel.html#metaclass-example](https://docs.python.org/3/reference/datamodel.html#metaclass-example)。
- en: See also
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The more common cases of an immutable object or a completely flexible object
    are covered in the *Designing classes with little unique processing* recipe.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变对象或完全灵活对象的更常见的情况在*设计具有少量独特处理的类*示例中有所涵盖。
- en: Using more sophisticated collections
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用更复杂的集合
- en: Python has a wide variety of built-in collections. In [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structures
    – list, set, dict* , we looked at them closely. In the *Choosing a data structure*
    recipe we provided a kind of decision tree to help locate the appropriate data
    structure from the available choices.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Python有各种各样的内置集合。在[第4章](text00048.html#page "第4章。内置数据结构 - list, set, dict")中，我们仔细研究了它们。在*选择数据结构*的示例中，我们提供了一种决策树，以帮助从可用选择中找到适当的数据结构。
- en: When we fold in the standard library, we have more choices, and more decisions
    to make. How can we choose the right data structure for our problem?
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将标准库整合进来时，我们有更多的选择，也有更多的决策要做。我们如何为我们的问题选择正确的数据结构？
- en: Getting ready
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we put data into a collection, we'll need to consider how we'll gather
    the data, and what we'll do with the collection once we have it. The big question
    is always how we'll identify a particular item within the collection. We'll look
    at a few key questions that we need to answer to help select a proper collection
    for our needs.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在将数据放入集合之前，我们需要考虑如何收集数据，以及一旦拥有集合后我们将如何处理它。最重要的问题始终是我们将如何识别集合中的特定项目。我们将看一下一些关键问题，以帮助选择适合我们需求的合适集合。
- en: Here's the overview of the alternative collections. They're in three modules.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是备选集合的概述。它们在三个模块中。
- en: 'The `collections` module contains a number of variations on the built-in collections.
    These include the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections`模块包含许多内置集合的变体。其中包括以下内容：'
- en: '`deque` : A double-ended queue. It''s a mutable sequence with optimizations
    for pushing and popping from each end. Note that the class name starts with a
    lower-case letter; this is atypical for Python.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deque`：双端队列。它是一个可变序列，具有从每一端推送和弹出的优化。请注意，类名以小写字母开头；这在Python中是不典型的。'
- en: '`defaultdict` : A mapping that can provide a default value for a missing key.
    Note that the class name starts with a lower-case letter; this is atypical for
    Python.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultdict`：可以为缺失的键提供默认值的映射。请注意，类名以小写字母开头；这在Python中是不典型的。'
- en: '`Counter` : A mapping that is designed to count occurrences of a key. This
    is sometimes called a multiset or a bag.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Counter`：旨在计算键的出现次数的映射。有时被称为多重集或袋子。'
- en: '`OrderedDict` : A mapping that retains the order in which keys where created.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderedDict`：保留创建键的顺序的映射。'
- en: '`ChainMap` : A mapping that combines several dictionaries into a single mapping.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChainMap`：将几个字典组合成单个映射的映射。'
- en: The `heapq` module includes a priority queue implementation. This is a specialized
    sequence that maintains items in a sorted order.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`heapq`模块包括优先队列实现。这是一种专门的序列，它以排序顺序维护项目。'
- en: The `bisect` module includes methods for searching a sorted list. This creates
    some overlap between the dictionary features and the list features.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`bisect`模块包括用于搜索排序列表的方法。这在字典功能和列表功能之间创建了一些重叠。'
- en: How to do it...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'There are a number of questions we need to answer to decide if we need a library
    data collection instead of one of the built-in collections:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些问题需要回答，以决定我们是否需要库数据集合而不是内置集合：
- en: Is the structure a buffer between the producer and the consumer? Does some part
    of the algorithm produce data items and another part consume the data items?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结构是否是生产者和消费者之间的缓冲？算法的某些部分是否产生数据项，另一部分是否消耗数据项？
- en: 'A common naive approach is for the producer to accumulate items in a list,
    and then the consumer processes the items from the list. This approach will tend
    to build a large intermediate data structure. A change in focus can interleave
    production and consumption, reducing the amount of memory used:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者通常会以列表中累积项目，然后消费者从列表中处理项目的一种天真的方法。这种方法往往会构建一个大型的中间数据结构。改变焦点可以交错生产和消费，减少内存使用量。
- en: A queue is used for **First-In-First-Out** ( **FIFO** ) processing. Items are
    inserted at one end and consumed from the other end. We can use `list.append()`
    and `list.pop(0)` to simulate this, though `collections.deque` will be more efficient;
    we can use `deque.append()` and `deque.popleft()` .
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列用于**先进先出**（**FIFO**）处理。项目从一端插入，从另一端消耗。我们可以使用`list.append()`和`list.pop(0)`来模拟这一过程，尽管`collections.deque`会更有效；我们可以使用`deque.append()`和`deque.popleft()`。
- en: A stack is used for **Last-In-First-Out** ( **LIFO** ) processing. Items are
    inserted and consumed from the same end. We can use `list.append()` and `list.pop()`
    to simulate this, though `collections.deque` will be more efficient; we can use
    `deque.append()` and `deque.pop()` .
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈用于**后进先出**（**LIFO**）处理。项目从同一端插入和消耗。我们可以使用`list.append()`和`list.pop()`来模拟这一过程，尽管`collections.deque`会更有效；我们可以使用`deque.append()`和`deque.pop()`。
- en: A priority queue (or heap queue) keeps the queue sorted in some order, distinct
    from the arrival order. This is often used for optimizing work, including graph
    search algorithms. We can simulate this by using `list.append()` , `list.sort(key=lambda
    x:x.priority)` , and `list.pop(-1)` . Since this involves a sort after each insert,
    it's terribly inefficient. Using the `heapq` module is considerably more efficient.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先队列（或堆队列）保持队列按某种顺序排序，与到达顺序不同。这通常用于优化工作，包括图搜索算法。我们可以通过使用`list.append()`，`list.sort(key=lambda
    x:x.priority)`和`list.pop(-1)`来模拟这一过程。由于这涉及每次插入后的排序，效率非常低。使用`heapq`模块要高效得多。
- en: How do we want to deal with missing keys from a dictionary?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望如何处理字典中缺失的键？
- en: Raise an exception. This is the way the built-in `dict` class works.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引发异常。这是内置`dict`类的工作方式。
- en: Create a default item. This is how a `defaultdict` works. We must provide a
    function that returns the default value. Common examples include `defaultdict(int)`
    and `defaultdict(float)` to use a default value of zero. We can also use `defauldict(list)`
    and `defauldict(set)` to create dictionary-of-list or dictionary-of-set structures.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建默认项目。这就是`defaultdict`的工作原理。我们必须提供一个返回默认值的函数。常见的例子包括`defaultdict(int)`和`defaultdict(float)`以使用默认值为零。我们还可以使用`defauldict(list)`和`defauldict(set)`来创建字典列表或字典集结构。
- en: 'In some cases, we''ll need to to provide a different literal value as the default:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要提供不同的文字值作为默认值：
- en: '[PRE40]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This uses a lambda object to define a very small function that has no name and
    always returns the string `N/A` . This will create a default item of `N/A` for
    missing keys.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用lambda对象来定义一个没有名称并始终返回字符串`N/A`的非常小的函数。这将为缺失的键创建一个默认项目`N/A`。
- en: The `defaultdict(int)` used to count items is so common that the `Counter` class
    does exactly this.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict(int)`用于计算项目是如此常见，`Counter`类正好做到了这一点。'
- en: How do we want to handle the order of keys in a dictionary?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望如何处理字典中键的顺序？
- en: Order doesn't matter; we always set and get items by key. This is the behavior
    of a built-in `dict` class. Key ordering depends on hash randomization, and is,
    therefore, unpredictable.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序不重要；我们总是通过键设置和获取项目。这是内置`dict`类的行为。键的排序取决于哈希随机化，因此是不可预测的。
- en: We want to preserve the insert order as well as rapidly find items using their
    key. The `OrderedDict` class provides this unique combination of features. It
    has the same interface as the built-in `dict` class, but preserves the insert
    order of the keys.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望保留插入顺序，同时快速使用它们的键找到项目。`OrderedDict`类提供了这些独特的特性组合。它具有与内置`dict`类相同的接口，但保留了键的插入顺序。
- en: 'We want the keys sorted into their proper order. While a sorted list does this,
    the lookup time for a given key is quite slow. We can use the bisect module to
    provide rapid access to items within a sorted list. This requires a three step
    algorithm:'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望按照正确的顺序对键进行排序。虽然排序列表可以做到这一点，但对于给定的键来说，查找时间相当慢。我们可以使用bisect模块来提供对排序列表中项目的快速访问。这需要一个三步算法：
- en: Build the list, perhaps via `append()` or `extend()` .
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建列表，可能通过`append()`或`extend()`。
- en: Sort the list. `list.sort()` is all we need for this.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对列表进行排序。`list.sort()`就足够了。
- en: Do retrievals from the sorted list, using the `bisect` module.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从排序列表中检索，使用`bisect`模块。
- en: How will we build the dictionary?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将如何构建字典？
- en: We have a simple algorithm to create items. In this case, a built-in dict may
    be sufficient.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个简单的算法来创建项目。在这种情况下，内置的dict可能就足够了。
- en: We have multiple dictionaries that will need to be merged. This can happen when
    reading configuration files. We might have an individual configuration, a system-wide
    configuration, and a default application configuration that all need to be merged.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有多个需要合并的字典。这可能发生在读取配置文件时。我们可能有一个单独的配置，一个系统范围的配置，以及一个需要合并的默认应用程序配置。
- en: '[PRE41]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How can we combine these?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何结合这些？
- en: '[PRE42]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The resulting `config` object will do a sequential search through the various
    dictionaries. It will look in the user, system, and application dictionaries for
    a given key.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`config`对象将通过各种字典进行顺序搜索。它将在用户、系统和应用程序字典中查找给定的键。
- en: How it works...
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'There are two principle resource constraints on data processing:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 数据处理有两个主要的资源约束：
- en: Storage
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储
- en: Time
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间
- en: 'All of our programming must respect these constraints. In most cases, the two
    are in opposition: anything we do to reduce storage use tends to increase processing
    time, and anything we do to reduce processing time increases storage use.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的编程都必须遵守这些约束。在大多数情况下，这两者是相互对立的：我们为了减少存储使用而做的任何事情往往会增加处理时间，而我们为了减少处理时间而做的任何事情会增加存储使用。
- en: 'The time aspect is formalized via a complexity metric. There''s considerable
    analysis of the complexity of an algorithm:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 时间方面通过复杂度度量来形式化。对算法的复杂性进行了相当多的分析：
- en: 'Operations that are described as *O* (1) happen in constant time. In this case,
    the complexity doesn''t change with the volume of data. For some collections,
    the actual overall long-term average is nearly  ***O*** (1) with minor exceptions.
    List `append` operations are an example: they''re all about the same complexity.
    Once in a while, though, a behind the scenes memory management operation will
    add some time.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述为*O*(1)的操作以恒定时间发生。在这种情况下，复杂性不随数据量的增加而改变。对于一些集合，实际的长期平均值几乎是*O*(1)，只有少量例外。列表`append`操作就是一个例子：它们的复杂性都差不多。不过，偶尔在幕后的内存管理操作会增加一些时间。
- en: Operations that are described as  *O* (n) happen in linear time. The cost grows
    as the volume of data grows. Finding an item in a list has this complexity. Finding
    an item in a dictionary is closer to  *O* (1) because it's (nearly) the same low
    complexity, no matter how large the dictionary is.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述为*O*(n)的操作以线性时间发生。随着数据量的增加，成本也会增加。在列表中查找项目具有这种复杂性。在字典中查找项目更接近*O*(1)，因为它的复杂性很低，无论字典有多大，都是（几乎）相同的。
- en: Operations that are  ***O*** ( *n* log *n* ) grow more quickly than the volume
    of data. The `bisect` module includes search algorithms that have this complexity.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述为*O*(*n* log *n*)的操作增长速度比数据量快。`bisect`模块包括具有这种复杂性的搜索算法。
- en: 'There are even worse cases: some algorithms have a complexity of *O(n² )* or
    even *O(n!)* . We''d like to avoid these through clever design and smarter data
    structures.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 甚至有更糟的情况：一些算法的复杂性是*O(n²)*甚至*O(n!)*。我们希望通过巧妙的设计和更智能的数据结构来避免这些情况。
- en: The various data structures reflect unique time and storage trade-offs.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 各种数据结构反映了独特的时间和存储权衡。
- en: There's more...
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As a concrete and extreme example, let''s look at searching a web log file
    for a particular sequence of events. We have two overall design strategies:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个具体而极端的例子，让我们来看看在Web日志文件中搜索特定事件序列。我们有两种总体设计策略：
- en: Read all of the events into a list structure with something like `file.read().splitlines()`
    . We can then use a `for` statement to iterate through the list looking for the
    combination of events. While the initial read may take some time, the search will
    be very fast because the log is all in memory.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有事件读入类似`file.read().splitlines()`的列表结构中。然后我们可以使用`for`语句来遍历列表，寻找事件的组合。虽然初始读取可能需要一些时间，但搜索会非常快，因为日志都在内存中。
- en: Read each event from a log file. If the event is part of the pattern, save just
    this event. We might use a `defaultdict` with the IP address as the key and a
    list of events as the value. This will take longer to read the logs, but the resulting
    structure in memory will be much smaller.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从日志文件中读取每个事件。如果事件是模式的一部分，只保存这个事件。我们可以使用`defaultdict`，以IP地址作为键，以事件列表作为值。这将需要更长的时间来读取日志，但内存中的结果结构将会小得多。
- en: The first algorithm, read everything into memory, is often wildly impractical.
    On a large web server, the logs might involve hundreds of gigabytes, or perhaps
    even terabytes, of data. This won't fit into any computer's memory.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个算法，将所有内容读入内存，通常是非常不切实际的。在大型Web服务器上，日志可能涉及数百GB，甚至是TB级别的数据。这是无法容纳在任何计算机内存中的。
- en: 'The second approach has a number of alternative implementations:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法有许多替代实现：
- en: '**Single process** : The general approach to most of the Python recipes here
    assumes that we''re creating an application that runs as a single process.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单个进程**：这里大多数Python配方的一般方法假设我们正在创建一个作为单个进程运行的应用程序。'
- en: '**Multiple processes** : We might expand the row-by-row search into a multi-processing
    application using the `multiprocessing` or `concurrent` package. We will create
    a collection of worker processes, each of which can process a subset of the available
    data and return the results to a consumer that combines the results. On a modern
    multiprocessor, multi-core computer, this can be a very effective use of resources.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多个进程**：我们可以将逐行搜索扩展为使用`multiprocessing`或`concurrent`包的多进程应用程序。我们将创建一组工作进程，每个进程可以处理可用数据的子集，并将结果返回给组合结果的消费者。在现代多处理器、多核计算机上，这可以非常有效地利用资源。'
- en: '**Multiple hosts** : The extreme case requires multiple servers, each of which
    handles a subset of the data. This requires more elaborate coordination among
    the hosts to share result sets. Generally, a framework such as Hadoop is required
    for this kind of processing.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多个主机**：极端情况需要多个服务器，每个服务器处理数据的一个子集。这需要更复杂的协调来共享结果集。通常，这种处理需要像Hadoop这样的框架。'
- en: We'll often decompose a large search into map and reduce processing. The map
    phase applies some processing or filtering to every item in the collection. The
    reduce phase combines map results into summary or aggregate objects. In many cases,
    there is a complex hierarchy of **MapReduce** operations applied to the results
    of previous MapReduce operations.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常将大型搜索分解为映射和减少处理。映射阶段对集合中的每个项目应用一些处理或过滤。减少阶段将映射结果组合成摘要或聚合对象。在许多情况下，有一种复杂的**MapReduce**操作层次结构应用于先前MapReduce操作的结果。
- en: See also
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Choosing a data structure* recipe in [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structures
    – list, set, dict* , for a foundational set of decisions for selecting data structures
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](text00048.html#page "第4章。内置数据结构 - 列表、集合、字典")的*选择数据结构*配方中，*内置数据结构 - 列表、集合、字典*，有一组基本的决策，用于选择数据结构
- en: Extending a collection – a list that does statistics
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展集合 - 进行统计的列表
- en: In the *Designing classes with lots of processing* recipe we looked at a way
    to distinguish between a complex algorithm and a collection. We showed how to
    encapsulate the algorithm and the data into separate classes.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在*设计具有大量处理的类*配方中，我们看了一种区分复杂算法和集合的方法。我们展示了如何将算法和数据封装到单独的类中。
- en: The alternative design strategy is to extend the collection to incorporate a
    useful algorithm.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种设计策略是将集合扩展到包含有用的算法。
- en: How can we extend Python's built-in collections?
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何扩展Python的内置集合？
- en: Getting ready
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll create a sophisticated list that can compute the sums and averages of
    the items in the list. This will require that our application only puts numbers
    in the list; otherwise, there will be `ValueError` exceptions.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个复杂的列表，可以计算列表中项目的总和和平均值。这将要求我们的应用程序只将数字放入列表；否则，将会有`ValueError`异常。
- en: How to do it...
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Pick a name for the list that also does simple statistics. Define the class
    as an extension to the built-in `list` class:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个名称，也可以进行简单的统计。将类定义为内置`list`类的扩展：
- en: '[PRE43]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This shows the syntax for defining an extension to a built-in class. If we provide
    a body that consists only of the `pass` statement, then the new `StatsList` class
    can be used anywhere the `list` class is used.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了定义内置类的扩展的语法。如果我们提供的主体只包含`pass`语句，那么新的`StatsList`类可以在任何使用`list`类的地方使用。
- en: When we write this, the `list` class is called the superclass of `StatsList`
    .
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们写这个时，`list`类被称为`StatsList`的超类。
- en: 'Define the additional processing as new methods. The `self` variable will be
    an object that has inherited all of the attributes and methods from the superclass.
    Here''s a `sum()` method:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将附加处理定义为新方法。`self`变量将是一个从超类继承了所有属性和方法的对象。这是一个`sum()`方法：
- en: '[PRE44]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We've used a generator expression to make it perfectly clear that the `sum()`
    function is applied to every item in the list. Using a generator expression allows
    us to do calculations or introduce filters very easily.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了生成器表达式，以清楚地表明`sum()`函数应用于列表中的每个项目。使用生成器表达式可以让我们非常容易地进行计算或引入过滤器。
- en: 'Here''s another method that we often apply to a list. This counts items:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们经常应用于列表的另一种方法。这计算项目数：
- en: '[PRE45]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will count the items in the list. Rather than use the `len()` function,
    we opted to use a generator expression in case we want to add filtering features
    in the future.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这将计算列表中的项目数。我们选择使用生成器表达式，而不是使用`len()`函数，以防将来想要添加过滤功能。
- en: 'Here''s the `mean` function:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`mean`函数：
- en: '[PRE46]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here are some additional methods:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是一些附加方法：
- en: '[PRE47]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `sum2()` method computes the sum of the squares of values in the list. This
    is used to compute variance. The variance is then used to compute the standard
    deviation of the values in the list.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum2()`方法计算列表中值的平方和。这用于计算方差。然后使用方差来计算列表中值的标准差。'
- en: 'The `StatsList` object inherits all the features of a `list` object. It is
    extended by the methods that we added. Here''s an example of using this collection:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`StatsList`对象继承了`list`对象的所有特性。它通过我们添加的方法进行了扩展。以下是使用此集合的示例：'
- en: '[PRE48]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We''ve created two `StatsList` objects from a literal list of objects. We used
    the `extend()` method to combine the two objects. Here''s the resulting object:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从对象的文字列表中创建了两个`StatsList`对象。我们使用`extend()`方法来合并这两个对象。以下是结果对象：
- en: '[PRE49]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here''s how we can use the additional methods which we defined on this object:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何使用我们在此对象上定义的附加方法：
- en: '[PRE50]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We''ve displayed the results of the `mean()` and `variance()` methods. Of course,
    all the features of the built-in `list` class are all present in our extension:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了`mean()`和`variance()`方法的结果。当然，内置`list`类的所有特性都存在于我们的扩展中：
- en: '[PRE51]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We used the built-in `sort()` method and used the index feature to extract an
    item from the list. Because there are an odd number of values, this is the median
    value. Note that this mutates the `list` object, changing the order of the items.
    This isn't the best possible implementation for this algorithm.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用内置的`sort()`方法，并使用索引功能从列表中提取一个项目。因为值的数量是奇数，这是中位数值。请注意，这会改变`list`对象的顺序。这不是这个算法的最佳实现。
- en: How it works...
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: One of the essential features of class definition is the concept of inheritance.
    When we create a superclass-subclass relationship, the subclass inherits all of
    the features of the superclass. This is sometimes called the generalization-specialization
    relationship. The superclass is a more generalized class; the subclass is more
    specialized because it adds or modifies features.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义的一个基本特征是继承的概念。当我们创建超类-子类关系时，子类继承了超类的所有特性。这有时被称为泛化-特化关系。超类是一个更一般化的类；子类更专业化，因为它添加或修改了特性。
- en: All of the built-in classes can be extended to add features. In this example,
    we added some statistical processing which created a subclass that's a specialized
    kind of list.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内置类都可以扩展以添加特性。在这个例子中，我们添加了一些统计处理，创建了一个特殊类型的列表子类。
- en: 'There''s an important tension between the two design strategies:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 两种设计策略之间存在重要的紧张关系：
- en: '**Extending** : In this case, we extended a class to add features. The features
    are deeply entrenched with this single data structure, and we can''t easily use
    them for a different kind of sequence.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展**：在这种情况下，我们扩展了一个类以添加特性。这些特性与这个单一数据结构紧密结合，我们不能轻易地将它们用于不同类型的序列。'
- en: '**Wrapping** : In designing classes with lots of processing, we kept the processing
    separate from the collection. This leads to some more complexity in juggling two
    objects.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包装**：在设计具有大量处理的类时，我们将处理与集合分开。这会导致在操纵两个对象时更复杂一些。'
- en: It's difficult to suggest that one of these is inherently superior to the other.
    In many cases, we'll find that wrapping may have an advantage because it seems
    to be a better fit the S.O.L.I.D. design principles. However, there will always
    be cases where it's clearly appropriate to extend a built-in collection.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 很难建议其中一个在本质上优于另一个。在许多情况下，我们会发现包装可能具有优势，因为它似乎更符合S.O.L.I.D.设计原则。然而，总会有一些情况，其中明显适合扩展内置集合。
- en: There's more...
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The idea of generalization can lead to superclasses that are abstractions. An
    abstract class is incomplete, and requires a subclass to extend it and provide
    missing implementation details. We can't make an instance of an abstract class
    because it would be missing features that make it useful.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 泛化的概念可能导致超类是抽象的。抽象类是不完整的，需要一个子类来扩展它并提供缺失的实现细节。我们不能创建抽象类的实例，因为它会缺少使其有用的特性。
- en: As we noted in the *Choosing a data structure* recipe in [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structures
    – list, set, dict* , there are abstract superclasses for all of the built-in collections.
    Rather than start from a concrete class, we can also start our design from an
    abstract base class.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第4章](text00048.html#page "第4章。内置数据结构-列表、集合、字典")的*选择数据结构*配方中所指出的，*内置数据结构-列表、集合、字典*，所有内置集合都有抽象超类。我们可以从一个抽象基类开始设计，而不是从一个具体类开始。
- en: 'We could, for example, start a class definition like this:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以开始一个类定义如下：
- en: '[PRE52]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In order to finish this class, we''ll need to provide an implementation for
    a number of special methods:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个类，我们需要为许多特殊方法提供实现：
- en: '`__getitem__()`'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__getitem__()`'
- en: '`__setitem__()`'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__setitem__()`'
- en: '`__delitem__()`'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__delitem__()`'
- en: '`__iter__()`'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__iter__()`'
- en: '`__len__()`'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__len__()`'
- en: Each of these methods is missing from the abstract class; they have no concrete
    implementation in the `Mapping` class. Once we've provided workable implementations
    for each method, we can then make instances of the new subclass.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的每一个在抽象类中都是缺失的；它们在`Mapping`类中没有具体的实现。一旦我们为每个方法提供了可行的实现，我们就可以创建新子类的实例。
- en: See also
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In the *Designing classes with lots of processing* recipe we took a different
    approach. In that recipe, we left the complex algorithms in a separate class.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*设计具有大量处理的类*配方中，我们采取了不同的方法。在那个配方中，我们将复杂的算法留在了一个单独的类中。
- en: Using properties for lazy attributes
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性进行惰性属性
- en: In the *Designing classes with lots of processing* recipe we defined a class
    that eagerly computed a number of attributes of the data in a collection. The
    idea there was to compute the values as soon as possible, so that the attributes
    would have no further computational cost.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在*设计具有大量处理的类*配方中，我们定义了一个类，它急切地计算了集合中数据的许多属性。那里的想法是尽快计算值，以便属性不会有进一步的计算成本。
- en: We described this as **eager** processing, since the work was done as soon as
    possible. The other approach is **lazy** processing, where the work is done as
    late as possible.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这描述为**急切**处理，因为工作尽快完成。另一种方法是**惰性**处理，其中工作尽可能晚地完成。
- en: What if we have values that are used rarely, and are very expensive to compute?
    What can we do to minimize the up-front computation, and only compute values when
    they are truly needed?
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有很少使用但计算成本很高的值，我们该怎么做来最小化前期计算，只在真正需要时计算值？
- en: Getting ready...
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪...
- en: Let's say we've collected data using a `Counter` object. For more information
    on the various collections, see [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Built-in Data Structures – list, set, dict*
    , specifically the *Using set methods and operators* and *Avoiding mutable default
    values for function parameters* recipes. In this case, the customers fall into
    eight categories with approximately equal numbers.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用`Counter`对象收集了数据。有关各种集合的更多信息，请参见[第4章](text00048.html#page "第4章。内置数据结构
    - 列表、集合、字典")，*内置数据结构 - 列表、集合、字典*，特别是*使用集合方法和运算符*和*避免函数参数的可变默认值*配方。在这种情况下，客户分为八个大致相等的类别。
- en: 'The data looks like this:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 数据看起来像这样：
- en: '[PRE53]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this collection, each key is the number of visits needed to get a full set
    of coupons. The values are the numbers of times that the visits occurred. In the
    preceding data that we saw, there were seven occasions where `15` visits were
    needed to get a full set of coupons. We can see from the sample data that there
    were five occasions where `17` visits were needed. This has a long tail. At only
    one point, there were `45` individual visits before a full set of eight coupons
    was collected.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个集合中，每个键都是获取完整优惠券所需的访问次数。值是发生访问的次数。在我们看到的先前数据中，有七次需要`15`次访问才能获得完整的优惠券。我们可以从样本数据中看到，有五次需要`17`次访问。这有一个长尾。只有一个点，需要`45`次单独访问才能收集到八张优惠券的完整集。
- en: 'We want to compute some statistics on this `Counter` . We have two overall
    strategies for doing this:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要计算这个`Counter`上的一些统计数据。我们有两种总体策略可以做到这一点：
- en: '**Extend** : We covered this in detail in the *Extending a collection – a list
    that does statistics* recipe, and we will cover this in [Chapter 7](text00079.html#page
    "Chapter 7. More Advanced Class Design") , *More Advanced Class Design* .'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展：我们在*扩展集合 - 进行统计的列表*配方中详细介绍了这一点，我们将在[第7章](text00079.html#page "第7章。更高级的类设计")中介绍这一点，*更高级的类设计*。
- en: '**Wrap** : We can wrap the `Counter` object in another class that provides
    just the features we need. We''ll look at this in [Chapter 7](text00079.html#page
    "Chapter 7. More Advanced Class Design") , *More Advanced Class Design* .'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装：我们可以将`Counter`对象包装在另一个类中，该类仅提供我们需要的功能。我们将在[第7章](text00079.html#page "第7章。更高级的类设计")中查看这一点，*更高级的类设计*。
- en: A common variation on wrapping uses a statistical computation object with a
    separate data collection object. This variation on wrapping often leads to an
    elegant solution.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 包装的常见变体使用具有单独数据收集对象的统计计算对象。这种包装的变体通常会导致优雅的解决方案。
- en: 'No matter which class architecture we choose, we have two ways to design the
    processing:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们选择哪种类架构，我们都有两种设计处理的方式：
- en: '**Eager** : This means that we''ll compute the statistics as soon as possible.
    This was the approach followed in the *Designing classes with lots of processing*
    recipe.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 急切：这意味着我们将尽快计算统计数据。这是在*设计具有大量处理的类*配方中采用的方法。
- en: '**Lazy** : This means we won''t compute anything until it''s required via a
    method function or property. In the *Extending a collection - a list that does
    statistics* recipe, we added methods to a collection class. These additional methods
    are examples of lazy calculation. The statistical values are computed only when
    required.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒惰：这意味着在需要通过方法函数或属性时才会计算任何东西。在*扩展集合 - 进行统计的列表*配方中，我们向集合类添加了方法。这些额外的方法是懒惰计算的例子。只有在需要时才计算统计值。
- en: The essential math for both designs is the same. The only question is when the
    computation is done.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种设计的基本数学是相同的。唯一的问题是计算何时完成。
- en: 'The mean, *μ* , is this:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值*μ*是这样的：
- en: '![Getting ready...](Image00013.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![准备好...](Image00013.jpg)'
- en: Here, *k* is the key from the `Counter` , *C* , and *f[k]* is the frequency
    value for the given key from the `Counter` .
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*k*是来自`Counter`的键，*C*，*f[k]*是给定键的频率值来自`Counter`。
- en: 'The standard deviation, *σ* , depends on the mean, *μ* . The formula is this:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 标准偏差*σ*取决于平均值*μ*。公式如下：
- en: '![Getting ready...](Image00014.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![准备好...](Image00014.jpg)'
- en: Here, *k* is the key from the `Counter` , *C* , and *f[k]* is the frequency
    value for the given key from the `Counter` . The total number of items in the
    counter is ![Getting ready...](Image00015.jpg)  .
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*k*是来自`Counter`的键，*C*，*f[k]*是给定键的频率值来自`Counter`。计数器中的项目总数是![准备好...](Image00015.jpg)。
- en: How to do it...
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Define the class with a descriptive name:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个具有描述性名称的类：
- en: '[PRE54]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Write the initialization method to include the object to which this object
    will be connected:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写初始化方法以包括将连接到该对象的对象：
- en: '[PRE55]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We've defined a method function that takes a `Counter` object as an argument
    value. This `counter` object is saved as part of the `Counter_Statistics` instance.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个方法函数，它以`Counter`对象作为参数值。这个`counter`对象被保存为`Counter_Statistics`实例的一部分。
- en: 'Define some useful helper methods. Each of these is decorated with `@property`
    to make it behave like a simple attribute:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一些有用的辅助方法。每个方法都使用`@property`进行装饰，使其表现得像一个简单的属性：
- en: '[PRE56]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Define the required methods for the various values. Here''s the calculation
    of the mean. This too is decorated with `@property` . The other methods can be
    referenced as if they are attributes, even though they are proper method functions:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义各种值所需的方法。这是平均值的计算。这也是用`@property`装饰的。其他方法可以被引用，就像它们是属性一样，尽管它们是适当的方法函数：
- en: '[PRE57]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here''s how we can calculate the standard deviation:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们如何计算标准偏差的方法：
- en: '[PRE58]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that we've been using `math.sqrt()` . Be sure to add the required `import
    math` statement in the Python file.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们一直在使用`math.sqrt()`。确保在Python文件中添加所需的`import math`语句。
- en: 'Here''s how we can create some sample data:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们如何创建一些样本数据的方法：
- en: '[PRE59]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We've imported functions such as `expected()` , `arrival1()` , and `coupon_collector()`
    from the `ch04_r06` module. We've imported the `Counter` collection from the standard
    library `collections` module.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从`ch04_r06`模块导入了`expected()`、`arrival1()`和`coupon_collector()`等函数。我们从标准库`collections`模块导入了`Counter`集合。
- en: We defined a function, `raw_data()` , that will generate a number of customer
    visits. By default, it will be 1,000 visits. The domain will be eight different
    classes of customers; each class will have an equal number of members. We'll use
    the `coupon_collector()` function to step through the data, emitting the number
    of visits required to collect a full set of eight coupons.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`raw_data()`的函数，它将生成一定数量的客户访问。默认情况下，将有1,000次访问。域将包括八种不同类别的客户；每个类别将有相等数量的成员。我们将使用`coupon_collector()`函数来遍历数据，发出收集完整八张优惠券所需的访问次数。
- en: This data is then used to assemble a `Counter` object. This will have the number
    of customers required to get a full set of coupons. Each number of customers will
    also have a frequency showing how often that number of visits occurred.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用这些数据来组装一个`Counter`对象。这将显示获得完整一套优惠券所需的客户数量。每个客户数量还将显示该访问次数发生的频率。
- en: 'Here''s how we can analyze the `Counter` object:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们如何分析`Counter`对象的方法：
- en: '[PRE60]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: First, we imported the `random` module so that we could pick a known `seed`
    value. This makes it easier to test and demonstrate an application because the
    random numbers are consistent. We also imported the `LazyCounterStatistics` class
    from the `ch06_r07` module.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入了`random`模块，以便我们可以选择一个已知的`seed`值。这样做可以更容易地测试和演示应用程序，因为随机数是一致的。我们还从`ch06_r07`模块中导入了`LazyCounterStatistics`类。
- en: Once we have all of the items defined, we can force the seed to a known value,
    and generate the coupon collector test results. The `raw_data()` function will
    emit a `Counter` object, which we called `data` .
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了所有的项目，我们可以强制将种子设为已知值，并生成收集器测试结果。`raw_data()`函数将发出一个`Counter`对象，我们称之为`data`。
- en: We'll use the `Counter` object to create an instance of the `LazyCounterStatistics`
    class. We'll assign this to the `stats` variable. When we print the value for
    the `stats.mean` property and the `stats.stddev` property, the methods are invoked
    to do the appropriate calculations of the various values.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Counter`对象来创建`LazyCounterStatistics`类的一个实例。我们将把这个实例分配给`stats`变量。当我们打印`stats.mean`属性和`stats.stddev`属性的值时，方法将被调用来做各种值的适当计算。
- en: For a set of eight coupons, the theoretical average is 21.7 visits to collect
    all coupons. It looks like the results from `raw_data()` show behavior that matches
    the expectation of random visits. This is sometimes called the null hypothesis—the
    data is random.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 对于八张优惠券，理论平均值是21.7次访问以收集所有优惠券。看起来`raw_data()`的结果显示了与随机访问预期相匹配的行为。这有时被称为零假设——数据是随机的。
- en: In this case, the data really was random. We've validated our approach. We can
    now use this software on real-world data with some confidence that it behaves
    correctly.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数据确实是随机的。我们验证了我们的方法。现在我们可以相当有信心地在真实世界的数据上使用这个软件，因为它的行为是正确的。
- en: How it works...
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The idea of lazy calculation works out well when the value is used rarely. In
    this example, the count is computed twice as part of computing the variance and
    standard deviation.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰计算的想法在很少使用值的情况下效果很好。在这个例子中，计数在计算方差和标准差时被计算了两次。
- en: This shows that being naive about a lazy design may not be optimal in some cases.
    This is an easy problem to fix, in general. We can always create additional local
    variables to save intermediate results.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明对于懒惰设计的天真看法在某些情况下可能不是最佳的。这是一个很容易修复的问题。我们总是可以创建额外的本地变量来保存中间结果。
- en: To make this class look like the class that performs eager calculations, we
    used the `@property` decorator. This makes a method function appear to be an attribute.
    This can only work for method functions that have no argument values.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个类看起来像执行急切计算的类，我们使用了`@property`装饰器。这使得一个方法函数看起来像一个属性。这只对没有参数值的方法函数起作用。
- en: In all cases, an attribute that's computed eagerly can be replaced by a lazy
    property. The principle reason for creating eager attribute variables is to optimize
    computation costs. In the case where a value is used rarely, a lazy property can
    avoid an expensive calculation.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，急切计算的属性都可以被懒惰的属性替换。创建急切属性变量的主要原因是为了优化计算成本。在很少使用值的情况下，懒惰的属性可以避免昂贵的计算。
- en: There's more...
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some situations in which we can further optimize a property to limit
    the amount of recomputation that's done. This requires a careful analysis of the
    use cases in order to understand the pattern of updates to the underlying data.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，我们可以进一步优化属性，以限制重新计算的数量。这需要仔细分析使用情况，以了解对底层数据的更新模式。
- en: In the situation where a collection is loaded with data and an analysis is performed,
    we can cache results to save computing them a second time.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载数据并执行分析的情况下，我们可以缓存结果以节省第二次计算它们的成本。
- en: 'We might do something like this:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会这样做：
- en: '[PRE61]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This technique uses an attribute to save a copy of the count calculation. This
    value can be computed once and returned as often as needed with no cost for recalculation.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术使用一个属性来保存计数计算的副本。这个值可以计算一次，并在需要时无需重新计算地返回。
- en: This optimization is only helpful if the state of the `raw_counter` object never
    changes. In an application that updates the underlying `Counter` , this cached
    value would become out of date. That kind of application would need to recreate
    the `LazyCounterStatistics` every time the `Counter` was updated.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在`raw_counter`对象的状态永远不会改变的情况下，这种优化才有帮助。在更新底层`Counter`的应用程序中，这个缓存值将变得过时。这种应用程序需要在每次更新`Counter`时重新创建`LazyCounterStatistics`。
- en: See also...
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: In the *Designing classes with lots of processing* recipe, we defined a class
    that eagerly computed a number of attributes. This represents a different strategy
    for managing the cost of the computation.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*设计具有大量处理的类*配方中，我们定义了一个急切计算多个属性的类。这代表了管理计算成本的不同策略。
- en: Using settable properties to update eager attributes
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可设置的属性来更新急切属性
- en: In several of the previous recipes, we've looked at the important distinction
    between eager and lazy computation. See the *Designing classes with lots of processing*
    recipe for an example of eagerly computing a result and setting object attributes.
    See the *Using properties for lazy attributes* recipe for a way to use properties
    to lazily compute a result.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的几个示例中，我们已经看到了急切和懒惰计算之间的重要区别。请参阅*设计具有大量处理的类*示例，了解急切计算结果并设置对象属性的示例。请参阅*使用属性进行懒惰属性*示例，了解使用属性懒惰地计算结果的方法。
- en: When an object is stateful, then attribute values must be changed throughout
    the object's life. It's common to use methods to eagerly compute attribute changes,
    but this isn't really necessary.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象具有状态时，属性值必须在对象的整个生命周期中进行更改。通常使用方法急切地计算属性更改，但这并不是必需的。
- en: 'We have the following choices for stateful objects:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有状态的对象，我们有以下选择：
- en: 'Set attribute values via methods:'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过方法设置属性值：
- en: Compute results eagerly, putting results in attributes
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 急切地计算结果，将结果放在属性中
- en: Compute results lazily, using properties that have syntax that looks like a
    simple attribute
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒惰地计算结果，使用看起来像简单属性的属性
- en: 'Set values via attributes:'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过属性设置值：
- en: If results are computed lazily via properties, then the new state can be reflected
    in these calculations
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果结果是通过属性懒惰地计算的，那么新状态可以反映在这些计算中
- en: What can we do if we want to use attribute-like syntax for setting a value,
    but we also want to perform eager calculations?
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用类似属性的语法来设置值，但又想进行急切计算，我们可以怎么做？
- en: 'This gives us another variation: we can use a property setter to have attribute-like
    syntax. This method can also perform eager calculations of the results.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们另一个变化：我们可以使用属性设置器来使用类似属性的语法。这种方法还可以对结果进行急切的计算。
- en: For example, we'll use a fairly complex looking object that has several attributes
    that are derived from other attributes. How can we eagerly compute values from
    attribute changes?
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将使用一个外观相当复杂的对象，它有几个属性是从其他属性派生出来的。我们如何急切地计算属性更改的值？
- en: Getting ready
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: Consider a class that represents a leg of a voyage. It has three principle features—rate,
    time, and distance. Looking at this in general, it's possible to eagerly compute
    any one value from a change in the other two.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个表示航程的腿的类。它有三个主要特征——速率、时间和距离。总的来说，可以从其他两个属性的变化中急切地计算任何一个值。
- en: We can add features to make this quite a bit more complex. For example, if the
    distance is computed from latitude and longitude, the general approach has to
    be modified somewhat. If we're using specific points instead of a more flexible
    distance, then a distance calculation may involve something like rate, time, starting
    point, and bearing. This involves two interlocked calculations. We won't go quite
    so far in this example; we'll stick to a simpler rate-time-distance calculation.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加功能，使其变得更加复杂。例如，如果距离是从纬度和经度计算出来的，一般的方法必须稍作修改。如果我们使用特定的点而不是更灵活的距离，那么距离计算可能涉及速率、时间、起点和方位角之类的东西。这涉及到两个相互关联的计算。在这个例子中，我们不会走得那么远；我们将坚持更简单的速率-时间-距离计算。
- en: 'Since two attributes must be set to compute the third, the object will have
    a fairly complex set of internal states:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 由于必须设置两个属性才能计算第三个属性，对象将具有相当复杂的内部状态：
- en: 'No attributes have been set: everything is unknown.'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有属性被设置：一切都是未知的。
- en: 'One item has been set: nothing can be computed yet.'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已设置一个项目：还不能计算任何东西。
- en: 'Two distinct items have been set: now the third can be computed.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经设置了两个不同的项目：现在可以计算第三个。
- en: 'After this, it''s ideal to support additional attribute changes. The essential
    rule is to compute appropriate new values based on the most recent two distinct
    changes:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，最好支持额外的属性更改。基本规则是根据最近的两个不同的更改计算适当的新值：
- en: If rate, *r* , and time, *t* , are the last two things that were changed, compute
    the distance, *d* . Use *d = r * t* .
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果速率，*r*，和时间，*t*，是最后更改的两个属性，计算距离，*d*。使用*d = r * t*。
- en: If rate, *r* , and distance, *d* , are the last two things that were changed,
    compute the time, *t* . Use *t = d/r* .
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果速率，*r*，和距离，*d*，是最后更改的两个属性，计算时间，*t*。使用*t = d/r*。
- en: If time, *t* , and distance, *d* , are the last two things that were changed,
    compute the rate, *r* . Use *r = d/t* .
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果时间，*t*，和距离，*d*，是最后更改的两个属性，计算速率，*r*。使用*r = d/t*。
- en: 'We''d like the object to behave like this:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望对象的行为如下：
- en: '[PRE62]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This has the distinct advantage of offering a very simple interface to the `leg`
    object. An application merely sets any two attributes and the calculation is performed
    eagerly to provide a value for the remaining attribute.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个明显的优势，即为`leg`对象提供了一个非常简单的接口。应用程序只需设置任何两个属性，计算就会急切地执行，以为剩余的属性提供一个值。
- en: How to do it...
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll break this into two parts. First, the general overview of defining settable
    properties, then the details of how to track state changes:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这分为两部分。首先是定义可设置属性的概述，然后是如何跟踪状态变化的细节：
- en: Define a class with a meaningful name.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个有意义的类名。
- en: 'Provide hidden attributes. These will be exposed as properties:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供隐藏属性。这些将被公开为属性：
- en: '[PRE63]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'For each gettable property, provide a method to compute the property value.
    In many cases, these will parallel the hidden attributes:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个可获取的属性，提供一个计算属性值的方法。在许多情况下，这些方法将与隐藏属性并行：
- en: '[PRE64]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'For each settable property, provide a method to set the property value:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个可设置的属性，提供一个设置属性值的方法：
- en: '[PRE65]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The setter method has a special property decorator based on the getter method
    name. In this example, the `@property` decorator on the `rate()` method also creates
    a `rate.setter` decorator that can be used to define the setter method for this
    attribute.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 设置方法具有基于获取方法名称的特殊属性装饰器。在这个例子中，`@property`装饰器在`rate()`方法上还创建了一个`rate.setter`装饰器，可以用来定义该属性的设置方法。
- en: Note that the method names for the getter and setter are identical. The `@property`
    and `@rate.setter` decorations distinguish the two methods from each other.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，getter和setter的方法名称是相同的。`@property`和`@rate.setter`装饰区分了这两个方法。
- en: In this example, we've saved the value into the hidden attribute, `self._rate`
    . Then, the `_calculate()` method is used to eagerly calculate all of the hidden
    attributes, if possible.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将值保存到隐藏属性`self._rate`中。然后，如果可能的话，使用`_calculate()`方法急切地计算所有隐藏属性。
- en: 'This can be repeated for all other properties. In our case, the code for time
    and distance are similar:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这可以重复应用到所有其他属性上。在我们的例子中，时间和距离的代码是相似的：
- en: '[PRE66]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The details of tracking the state change rely on a feature of the `collections.deque`
    class. The rule for calculation can be implemented as a two-element bounded queue
    of distinct changes. As each distinct field is changed, we can enqueue the field
    name. The two distinct names in the queue are the last two fields changed; the
    third can be determined from this by set subtraction:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪状态更改的细节依赖于`collections.deque`类的一个特性。计算规则可以实现为两个元素的有界队列，其中包含不同的更改。当每个不同的字段被更改时，我们可以将字段名称入队。队列中的两个不同名称是最近更改的最后两个字段；第三个可以通过集合减法从中确定：
- en: 'Import the `deque` class:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`deque`类：
- en: '[PRE67]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Initialize the queue in the `__init__()` method:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__init__()`方法中初始化队列：
- en: '[PRE68]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Enqueue each distinct change. Determine what''s missing from the queue, and
    compute this:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 入队每个不同的更改。确定队列中缺少什么，并计算出来：
- en: '[PRE69]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If the latest change is not already in the queue, it's appended. Since the queue
    has a bounded size, the oldest item, the one least recently changed, is silently
    popped to keep the queue size fixed.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最新的更改尚未在队列中，它将被追加。由于队列有一个有界的大小，最老的项目，即最近更改的项目，将被悄悄地弹出以保持队列大小固定。
- en: The difference between the set of available properties, and the set of properties
    recently changed is a single property name. This is the name least recently set;
    the value for this can be computed from the other two that were set more recently.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 可用属性集和最近更改的属性集之间的差异是一个属性名称。这是最近设置的名称；这个值可以从更近设置的其他两个值计算出来。
- en: How it works...
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This works because Python implements a property with a kind of class called
    a **Descriptor** . A descriptor class can have methods for getting a value, setting
    a value, and deleting a value. Depending on the context, one of these methods
    is used implicitly:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Python实现了一种称为**描述符**的类的属性。描述符类可以有获取值、设置值和删除值的方法。根据上下文，其中一个方法会被隐式使用：
- en: When a descriptor object is used in an expression, the `__get__` method is used
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在表达式中使用描述符对象时，将使用`__get__`方法
- en: When a descriptor is on the left side of an assignment statement, the `__set__`
    method is used
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个描述符出现在赋值语句的左侧时，将使用`__set__`方法
- en: When a descriptor appears in a `del` statement, the `__delete__` method is used
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当描述符出现在`del`语句中时，将使用`__delete__`方法
- en: 'The `@property` decorator does three things:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`@property`装饰器做了三件事：'
- en: Modifies the following method to be wrapped up in a descriptor object. The method
    that follows is modified to be the descriptor's `__get__` method. It will compute
    values when used in an expression.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改后面的方法，将其包装成一个描述符对象。后面的方法被修改为描述符的`__get__`方法。在表达式中使用时，它将计算值。
- en: Adds a `method.setter` decorator. This decorator will modify the method that
    follows to be the descriptor's `__set__` method. When the name is used on the
    left side of an assignment statement, the given method is executed.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`method.setter`装饰器。这个装饰器将修改后面的方法成为描述符的`__set__`方法。当名称在赋值语句的左侧使用时，给定的方法将被执行。
- en: Adds a `method.deleter` decorator. This decorator will modify the method that
    follows to be the descriptor's `__delete__` method. When the name is used in a
    `del` statement, the given method is executed.
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`method.deleter`装饰器。这个装饰器将修改后面的方法成为描述符的`__delete__`方法。当名称在`del`语句中使用时，给定的方法将被执行。
- en: This allows the building of an attribute name that can be used to provide values,
    set values, and even delete values.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许构建一个属性名称，可以用来提供值、设置值，甚至删除值。
- en: There's more...
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are a few more refinements we could make to this class. We'll look at
    two more advanced techniques for initialization and calculation.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个类还有一些更多的改进。我们将看看两种更高级的初始化和计算技术。
- en: Initialization
  id: totrans-514
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化
- en: 'We can provide a way to properly initialize an instance with some values. This
    change makes it possible to do the following:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供一种正确初始化实例的方法。这个改变使得可以做到以下几点：
- en: '[PRE70]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The example shows how this helps in planning a voyage by a sailboat. If the
    distance to cover is `38.2` nautical miles, and the goal is to finish in `7` hours,
    the boat must reach a speed of `5.46` knots. To shave a half hour off the trip
    requires a speed of `5.88` knots.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何通过帆船规划航行。如果要覆盖的距离是`38.2`海里，目标是在`7`小时内完成，船必须达到`5.46`节的速度。要缩短半个小时的行程需要达到`5.88`节的速度。
- en: 'For this to work, the `__init__()` method needs to be changed. The internal
    `dequeue` object must be built right away. As each attribute is set, the internal
    `_calculate()` method must be used to track the setting:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，需要更改`__init__()`方法。内部的`dequeue`对象必须立即构建。当设置每个属性时，必须使用内部的`_calculate()`方法来跟踪设置：
- en: '[PRE71]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `dequeue` function is created first. As each individual field value is set,
    the change is logged in the queue of changed attributes. If two fields are set,
    the third will be computed.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建`dequeue`函数。当设置每个单独的字段值时，更改将被记录在更改属性的队列中。如果设置了两个字段，第三个将被计算。
- en: If all three fields are set, then the last two changes—time and distance, in
    this case—will compute a value for `rate` . This will overwrite the provided value.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了所有三个字段，那么最后两个更改——在这种情况下是时间和距离——将计算出`rate`的值。这将覆盖提供的值。
- en: Calculation
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算
- en: Currently, the various calculations are buried inside an `if` statement. This
    makes changes difficult because a subclass would be forced to supply the entire
    method rather than simply supplying a calculation change.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，各种计算都隐藏在一个`if`语句中。这使得更改变得困难，因为子类将被迫提供整个方法，而不仅仅是提供计算更改。
- en: 'We can remove the `if` statement using an introspection technique. The overall
    design would be better with explicit calculation methods:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用内省技术来移除`if`语句。整体设计会更好，使用显式计算方法：
- en: '[PRE72]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The following version of `_calculate()` makes use of these methods:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 以下版本的`_calculate()`利用了这些方法：
- en: '[PRE73]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: When the value of compute is a singleton set, using the `pop()` method extracts
    that one value from the set. Prepending `calc_` to this string gives the name
    of a method that will compute the desired value.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算的值是一个单例集合时，使用`pop()`方法从集合中提取该值。在这个字符串前加上`calc_`会得到一个计算所需值的方法的名称。
- en: The `getattr()` function does a lookup to find the requested method of the object,
    `self` . This is then evaluated as a bound function. It can update attributes
    with the desired result.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '`getattr()`函数进行查找以找到对象`self`的请求方法，然后将其作为绑定函数进行评估。它可以使用所需的结果更新属性。'
- en: Refactoring the calculations into separate methods makes the class more open
    to extension. We can now create a subclass that includes revised calculations,
    but preserves the overall features of the class.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 将计算重构为单独的方法使得类更容易扩展。现在我们可以创建一个包括修订计算但保留类的整体特性的子类。
- en: See also
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information on working with sets, see the *Using set methods and operators*
    recipe in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures
    – list, set, dict") , *Built-in Data Structures – list, set, dict* .
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关使用集合的更多信息，请参阅[第4章](text00048.html#page "第4章。内置数据结构 - 列表，集合，字典")中的*使用集合方法和运算符*配方，*内置数据结构
    - 列表，集合，字典*。
- en: A `dequeue` , effectively, is a list that's highly optimized for append and
    pop operations. See the *Deleting from a list – deleting, removing, popping, and
    filtering* recipe in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data
    Structures – list, set, dict") , *Built-in Data Structures – list, set, dict*
    .
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dequeue`实际上是一个针对追加和弹出操作进行了高度优化的列表。请参阅[第4章](text00048.html#page "第4章。内置数据结构
    - 列表，集合，字典")中的*从列表中删除 - 删除，移除，弹出和过滤*配方，*内置数据结构 - 列表，集合，字典*。'
