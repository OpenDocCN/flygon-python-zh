["```py\nfrom abq_data_entry.application import Application\n\napp = Application()\napp.mainloop()\n```", "```py`), or in a block by ending a lead-in line with a double colon and indenting the code block.\n*   Tables can either be created by surrounding columns of text with `=` symbols, separated by spaces to indicate the column breaks, or by constructing ASCII-art tables from `|`, `-`, and `+`. Tables can be tedious to create in a plain text editor, but some programming tools have plugins to generate the RST tables.\n\nWe've used RST already in [Chapter 2](3ec510a4-0919-4f25-9c34-f7bbd4199912.xhtml), *Designing GUI Applications with Tkinter,* to create our program specification; there, you saw the use of titles, headers, bullets, and a table. Let's walk through creating our `README.rst` file:\n\n1.  Open the file and start with the title and description, as follows:\n\n```", "```py\n\n2.  Next, we'll list the authors by adding\u00a0the following code:\n\n```", "```py\n\nAdd yourself, of course. Eventually, other people might work on your application; they should add their names here with the dates they worked on it. Now, add the requirements as follows:\n\n```", "```py\n\nRight now, we only need Python 3 and Tkinter, but as our application grows we may be expanding this list. Our application doesn't really need to be installed, and has no configuration options, so for now we can skip those sections. Instead, we'll skip to `Usage` as follows:\n\n```", "```py\n\nThere really isn't much to know about running the program other than this command; no command-line switches or arguments. We don't know of any bugs, so we'll just leave some general notes at the end as follows:\n\n```", "```py\n\nIt seems prudent to tell the user where the file will be saved and what it will be called, since that's hardcoded into the program right now. Also, we should mention the fact that the user should have some kind of spreadsheet, since the program can't edit or view the data. That finishes the `README.rst` file. Save it and let's move on to the `docs` folder.\n\n# Populating the docs folder\n\nThe `docs`\u00a0folder is where documentation goes. This can be any kind of documentation: user manuals, program specifications, API references, diagrams, and so on.\n\nFor now, you copy in the program specification we wrote in previous chapters, your interface mockups, and a copy of the form used by the technicians.\n\nAt some point, you might need to write a user manual, but for now the program is simple enough not to need it.\n\n# Making a\u00a0Python package\n\nCreating your own Python package is surprisingly easy. A Python package consists of the following three things:\n\n*   A directory\n*   One or more Python files in that directory\n*   A file called `__init__.py` in the directory\n\nOnce you've done this, you can import your package in whole or in part, just like you would import standard library packages, provided your script is in the same parent directory as the package directory.\n\nNote that\u00a0 `__init__.py` in a module is somewhat analogous to what `self.__init__()` is for a class. Code inside it will run whenever the package is imported. The Python community generally discourages putting much code in this file, though, and since no code is actually required, we'll leave this file empty.\n\nLet's start building our application's package. Create the following six empty files under `abq_data_entry`:\n\n*   `__init__.py`\n*   `widgets.py`\n*   `views.py`\n*   `models.py`\n*   `application.py`\n*   `constants.py`\n\nEach of those Python files is called a **module**. A module is nothing more than a Python file inside a package directory. Your directory structure should now look like this:\n\n![](assets/06efc903-784c-426e-be9b-ddeb66de7849.png)\n\nAt this point, you have a working package, albeit with no actual code in it. To test this, open a Terminal/command-line window, change to your `ABQ_Data_Entry` directory, and start a Python shell.\n\nNow, type the following command:\n\n```", "```py\n\nThis should work without error. Of course, it doesn't do anything, but we'll get to that next.\n\nDon't confuse the term package here with the actual distributable Python packages, such as those you download using `pip`.\u00a0\n\n# Splitting our application into multiple files\n\nNow that our directory structure is in order, we need to start dissecting our application script and splitting it up into our module files. We'll also need to create our model class. Open up your `abq_data_entry.py` file from [Chapter 4](43851b46-13ed-4f6f-b754-bc9fe4f522d9.xhtml), *Reducing User Error with Validation and Automation,* and let's begin!\n\n# Creating the models module\n\nWhen your application is all about data, it's good to begin with the model. Remember that the job of a model is to manage the storage, retrieval, and processing of our application's data, usually with respect to its persistent storage format (in this case, CSV). To accomplish this, our model should contain all the knowledge about our data.\n\nCurrently, our application has nothing like a model; knowledge about the application's data is scattered into the form fields, and the `Application` object simply takes whatever data the form contains and stuffs it directly into a CSV file when a save operation is requested. Since we aren't yet retrieving or updating information, our application has no actual knowledge about what's inside the CSV file.\n\nTo move our application to an MVC architecture, we'll need to create a model class that both manages data storage and retrieval, and represents the authoritative source of knowledge about our data. In other words, we have to encode the knowledge contained in our data dictionary here in our model. We don't really know what we'll *do* with this knowledge yet, but this is where it belongs.\n\nThere are a few ways we could store this data, such as creating a custom field class or a\u00a0`namedtuple` object, but we'll keep it simple for now and just use a dictionary, mapping field names to field metadata.\n\nThe field metadata will likewise be stored as a dictionary of attributes about the field, which will include:\u00a0\n\n*   Whether or not the field is required\n*   The type of data stored in the field\n*   The list of possible values, if applicable\n*   The minimum, maximum, and increment of values, if applicable\n\nTo store the data type for each field, let's define some data types. Open the `constants.py` file and add the following code:\n\n```", "```py\n\nWe've created a class called `FieldTypes` that simply stores some named integer values, which will describe the different types of data we're going to store. We could just use Python types here, but it's useful to differentiate between certain types of data that are likely to be the same Python type (such as `long`, `short`, and `date` strings). Note that the integer values here are basically meaningless; they just need to be different from one another.\n\nPython 3 has an `Enum` class, which we could have used here, but it adds very little that we actually need in this case. You may want to investigate this class if you're creating a lot of constants such as our `FieldTypes` class and need additional features.\n\nNow, open\u00a0`models.py`, where we'll import `FieldTypes` and create our model class and field definitions as follows:\n\n```", "```py\n\nNotice the way we import `FieldTypes`:\u00a0\u00a0`from .constants import FieldTypes`. The dot in front of `constants` makes this a **relative import**. Relative imports can be used inside a Python package to locate other modules in the same package. In this case, we're in the\u00a0`models` module, and we need to access the\u00a0`constants` module inside the\u00a0`abq_data_entry` package. The single dot represents our current parent module (`abq_data_entry`), and thus\u00a0`.constants` means the\u00a0`constants` module of the\u00a0`abq_data_entry` package.\n\nRelative imports also distinguish our custom modules from modules in\u00a0`PYTHONPATH`. Thus, we don't have to worry about any third-party or standard library packages conflicting with our module names.\n\nIn addition to field attributes, we're also documenting the order of fields here. In Python 3.6 and later, dictionaries retain the order they were defined by; if you're using an older version of Python 3, you'd need to use the `OrderedDict` class from the `collections` standard library module to preserve the field order.\n\nNow that we have a class that understands which fields need to be stored, we need to migrate our save logic from the application class into the model.\n\nThe code in our current script is as follows:\n\n```", "```py\n\nLet's go through this code and determine what goes to the model and what stays in the controller (that is, the `Application` class):\n\n*   The first two lines define the filename we're going to use. This could go into the model, but thinking ahead, it seems that the users may want to be able to open arbitrary files or define the filename manually. This means the application will need to be able to tell the model which filename to work with, so it's better to leave the logic that determines the name in the controller.\n*   The `newfile` line determines whether the file exists or not. As an implementation detail of the data storage medium, this is clearly the model's problem, not the application's.\n*   `data = self.recordform.get()` pulls data from the form. Since our model has no knowledge of the form's existence, this needs to stay in the controller.\n*   The last block opens the file, creates a `csv.DictWriter` object, and appends the data. This is definitely the model's concern.\n\nNow, let's begin moving code into the `CSVModel` class:\n\n1.  To start the process, let's create a constructor for `CSVModel` that allows us to pass in a filename:\n\n```", "```py\n\nThe constructor is pretty simple; it just takes a `filename` parameter and stores it as a property. Now, we'll migrate the save logic as follows:\n\n```", "```py\n\nThis is essentially the logic we chose to copy from `Application.on_save()`, but with one difference; in the call to `csv.DictWriter()`, the `fieldnames`\u00a0parameter is defined by the model's `fields` list rather than the keys of the `data` dict. This allows our model to manage the format of the CSV file itself, and not depend on what the form gives it.\n\n2.  Before we're done, we need to take care of our module imports. The `save_record()` method uses the `os` and `csv` libraries, so we need to import them. Add this to the top of the file as follows:\n\n```", "```py\n\nWith the model in place, let's start working on our view components.\n\n# Moving the widgets\n\nWhile we could put all of our UI-related code in one `views` file, we have a lot of widget classes that should really be put in their own file to limit the complexity of the `views` file.\n\nSo instead, we're going to move all of the code for our widget classes into the `widgets.py` file. Widgets include all the classes that implement reusable GUI components, including compound widgets like `LabelInput`. As we develop more of these, we'll add them to this file.\n\nOpen `widgets.py` and copy in all of the code for `ValidatedMixin`, `DateInput`, `RequiredEntry`, `ValidatedCombobox`, `ValidatedSpinbox`, and `LabelInput`. These are our widgets.\n\nThe\u00a0`widgets.py`\u00a0file will need to import any module dependencies used by the code being copied in. We'll need to look through our code and find what libraries we use and import them. Obviously, we need `tkinter` and `ttk`, so add those at the top as follows:\n\n```", "```py\n\nOur `DateInput`\u00a0class uses the `datetime` class from the `datetime` library, so import that too, as follows:\n\n```", "```py\n\nFinally, our `ValidatedSpinbox`\u00a0class makes use of the `Decimal` class and `InvalidOperation` exception from the `decimal` library as follows:\n\n```", "```py\n\nThis is all we need in `widgets.py` for now, but we'll revisit this file as we refactor our view logic.\n\n# Moving the views\n\nNext, we need to create the `views.py` file. Views are larger GUI components, like our `DataRecordForm` class. Currently it's our only view, but we'll be creating more views in later chapters, and they'll be added here.\n\nOpen the `views.py` file and copy in the `DataRecordForm` class, then go back to the top to deal with the module imports. Again, we'll need `tkinter` and `ttk`, and our file saving logic relies on `datetime` for the filename.\n\nAdd them to the top of the file as follows:\n\n```", "```py\n\nWe aren't done, though; our actual widgets aren't here and we'll need to import them. Since we're going to be doing a lot of importing of objects between our files, let's pause for a moment to consider the best way to handle these imports.\n\nThere are three ways we could import objects:\n\n*   Use a wildcard import to bring in all the classes from `widgets.py`\n*   Explicitly import all the needed classes from `widgets.py` using the `from ... import ...` format\n*   Import `widgets` and keep our widgets in their own namespace\n\nLet's consider the relative merits of those ways:\n\n*   The first option is by far the easiest, but it can cause us headaches as the application expands. A wildcard import will bring in every name defined at the global scope within the module. That includes not just the classes we defined, but any imported modules, aliases, and defined variables or functions. This can lead to unintended consequences and subtle bugs as the application expands in complexity.\n*   The second option is cleaner, but means we'll need to maintain the list of imports as we add new classes and use them in different files, and this leads to a long and ugly imports section that is hard for humans to parse.\n*   The third option is by far the best, as it keeps all names within a namespace and keeps the code elegantly simple. The only downside is that we'll need to update our code so that all references to widget classes include the module name as well. To keep this from being unwieldy, let's alias the `widgets` module to something short, like `w`.\n\nAdd the following code to your imports:\n\n```", "```py\n\nNow, we just need to go through the code and prepend `w.` to all instances of `LabelInput`, `RequiredEntry`, `DateEntry`, `ValidatedCombobox`, and `ValidatedSpinbox`. This should be easy enough to do in IDLE or any other text editor using a series of search and replace actions.\n\nFor example, `line 1` of the form is as follows:\n\n```", "```py\n\nBefore you go through and change that everywhere, though, let's stop and take a moment to refactor some of the redundancy out of this code.\n\n# Removing redundancy in our view logic\n\nLook at the field definitions in the view logic: they contain a lot of information that is also in our model. Minimums, maximums, increments, and possible values are defined both here and in our model code. Even the type of the\u00a0input widget is related directly to the type of data being stored. Ideally, this should only be defined one place, and that place should be the model. If we needed to update the model for some reason, our form would be out of sync.\n\nWhat we need to do is to pass the field specification from our model into the view class and let the widgets' details be defined from that specification.\n\nSince our widget instances are being defined inside the `LabelInput` class, we're going to enhance that class with the ability to automatically work out the `input` class and arguments from our model's field specification format. Open up the `widgets.py` file and import the\u00a0`FieldTypes` class, just as you did in\u00a0`model.py`.\u00a0\n\nNow, locate the `LabelInput` class and add the following code before the `__init__()` method:\n\n```", "```py\n\n```", "```py\n\nThis code acts as a key to translate our model's field types into a widget type and variable type appropriate for the field type.\n\nNow, we need to update `__init__()` to take a `field_spec` parameter and, if given, use it to define the input widget as follows:\n\n```", "```py\n\nLet's break down the changes:\n\n1.  First, we've added `field_spec` as a keyword argument with `None` as a default. We might want to use this class in a situation where there isn't a field specification, so we keep this parameter optional.\n2.  If there is\u00a0`field_spec` given, we're going to do the following things:\n    *   We'll grab the `type` value and use that with our class's field key to get `input_class`. In case we want to override this, an explicitly passed `input_class` will override the detected one.\n    *   We'll determine the appropriate variable type in the same way. Once again, if\u00a0`input_var` is explicitly passed, we'll prefer that, otherwise we'll use the one determined from the field type. We'll create an instance either way and store it in `self.variable`.\n    *   For `min`, `max`, `inc`, and `values`, if the key exists in the field specification, and the corresponding `from_`, `to`, `increment`, or `values` argument has not been passed in explicitly, we'll set up the `input_args` variable with the `field_spec`\u00a0value.\n3.  If `field_spec` wasn't passed in, we need to assign `self.variable` from the `input_var` argument.\n4.  We're using `self.variable` now instead of `input_var` for assigning the input's variable, since those values might not necessarily be the same anymore and `self.variable` will contain the correct reference.\n\nNow, we can update our view code to take advantage of this new ability. Our `DataRecordForm`\u00a0class will need access to the model's `fields` dictionary, which it can then use to send a field specification to the `LabelInput`\u00a0class.\n\nBack in the `views.py`\u00a0file, edit the method signature so that we can pass in a dictionary of field specifications:\n\n```", "```py\n\nWith access to the `fields` dictionary, we can just get the field specification from it and pass that into the `LabelInput`\u00a0class instead of specifying the input class, input variable, and input arguments.\n\nNow, the first line looks like this:\n\n```", "```py\n\nGo ahead and update the rest of the widgets the same way, replacing `input_class`, `input_var`, and `input_args` with `field_spec`. Note that when you get to the height fields, you'll need to keep the part of `input_args` that defines `min_var`, `max_var`, and `focus_update_var`.\n\nFor example, the following is the `Min Height` input definition:\n\n```", "```py\n\nThat does it. Now, any changes to our field specification can be made solely in the model, and the form will simply do the correct thing.\n\n# Creating the application file\n\nFinally, let's create our controller class, `Application`, by following these steps:\n\n1.  Open the `application.py` file and copy in the `Application` class definition from the script.\n2.  The first thing we'll fix is our imports. At the top of the file, add the following code:\n\n```", "```py\n\nWe need `tkinter` and `ttk`, of course, and `datetime` to define our filename. Although we only need one class each from\u00a0`views` and `models`, we're going to keep them in their own namespaces anyway. It's likely we're going to have many more views as the application expands, and possibly more models.\n\n3.  We need to update the call to `DataRecordForm` in `__init__()` for the new namespace and make sure we pass in the required field specification dictionary as follows:\n\n```", "```py\n\n4.  Finally, we need to update `Application.on_save()` to use the model, as follows:\n\n```", "```py\n\nAs you can see, using our model is pretty seamless; we just created a `CSVModel`\u00a0class by passing in the filename, and then passed the form's data to `save_record()`.\n\n# Running the application\n\nThe application is now completely migrated to the new data format. To test it, navigate to the application root folder, `ABQ_Data_Entry`, and execute the following command:\n\n```", "```py\n\nIt should look and act just like the single script from [Chapter 4](43851b46-13ed-4f6f-b754-bc9fe4f522d9.xhtml), *Reducing User Error with Validation and Automation,* and run without errors, as shown in the following screenshot:\n\n![](assets/4151fc4d-d11b-4bf1-a5a3-df5ab3971dca.png)\n\nSuccess!\n\n# Using version control software\n\nOur code is nicely structured for expansion, but there's one more critical item we should address: **version control**. You may already be familiar with a **version control system** (**VCS**), sometimes called **revision control** or **source code management**, but if not, it's an indispensable tool for dealing with a large and changing codebase.\n\nWhen working on an application, we sometimes think we know what needs to be changed, but it turns out we're wrong. Sometimes we don't know exactly how to code something, and it takes several attempts to find the correct approach. Sometimes we need to revert to code that was changed a long time back. Sometimes we have multiple people working on the same piece of code, and we need to merge their changes together. Version control systems were created to address these issues and more.\n\nThere are dozens of different version control systems, but most of them work essentially the same:\n\n*   You have a working copy of the code that you make changes to\n*   You periodically select changes to commit back to the master copy\n*   You can checkout older versions of the code at any point, then revert back to the master copy\n*   You can create branches of the code to experiment with different approaches, new features, or large refactors\n*   You can later merge these branches back into the master copy\n\nVCS provides a safety net that gives you the freedom to change your code without the fear that you'll hopelessly ruin it: reverting to a known working state is just a few quick commands away. It also helps us to document changes to our code, and collaborate with others if the opportunity arises.\n\nThere are dozens of VC systems available, but by far the most popular for many years now is **Git**.\n\n# A super-quick guide to using Git\n\nGit was created by Linus Torvalds to be the version control software for the Linux kernel project, and has since grown to be the most popular VC software in the world. It is utilized by source sharing sites like GitHub, Bitbucket, SourceForge, and GitLab. Git is extremely powerful, and mastering it can take months or years; fortunately, the basics can be grasped in a few minutes.\n\nFirst, you'll need to install Git; visit [https://git-scm.com/downloads](https://git-scm.com/downloads) for instructions on how to install Git on macOS, Windows, Linux, or other Unix operating systems.\n\n# Initializing and configuring a Git repository\n\nOnce Git is installed, we need to initialize and configure our project directory as a Git repository by following these steps:\n\n1.  Run the following command in the application's root directory (`ABQ_Data_Entry`):\n\n```", "```py\n\nThis command creates a hidden directory under our project root called `.git`\u00a0and initializes it with the basic files that make up the repository. The\u00a0`.git`\u00a0directory will contain all the data and metadata about our saved revisions.\n\n2.  Before we add any files to the repository, we need to instruct Git to ignore certain kinds of files. For example, Python creates bytecode (`.pyc`) files whenever it executes a file, and we don't want to save these as part of our code. To do this, create a file in your project root called `.gitignore` and put the following lines in it:\n\n```", "```py\n\n# Adding and committing code\n\nNow that our repository is initialized, we can add files and directories to our Git repository using the following commands:\n\n```", "```py\n\nAt this point, our files are staged, but not yet committed to the repository. You can check the status of your repository and the files in it at any time by entering `git status`.\n\nYou should get the following output:\n\n```", "```py\n\nThis shows you that all the files under `abq_data_entry` and `docs`, as well as the files you specified directly, are staged to be committed to the repository.\n\nLet's go ahead and commit the changes as follows:\n\n```", "```py\n\nThe `-m` flag here passes in a commit message, which is stored with the commit. Each time you commit code to the repository, you will be required to write a message. You should always make these messages as meaningful as possible, detailing what changes you made and the rationale behind them.\n\n# Viewing and using our commits\n\nTo view your repository's history, run the `git log` command as follows:\n\n```"]