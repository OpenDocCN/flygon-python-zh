- en: Handling Events with Signals and Slots
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用信号和插槽处理事件
- en: Composing widgets into a nice-looking form is a good first step for designing
    an application, but for a GUI to be of any use, it needs to be connected to code
    that actually does something. In order to do this in PyQt, we need to learn about
    one of Qt's most vital features, **signals and slots**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 将小部件组合成一个漂亮的表单是设计应用程序的一个很好的第一步，但是为了GUI能够发挥作用，它需要连接到实际执行操作的代码。为了在PyQt中实现这一点，我们需要了解Qt最重要的功能之一，**信号和插槽**。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Signal and slot basics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号和插槽基础
- en: Creating custom signals and slots
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义信号和插槽
- en: Automating our calendar form
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化我们的日历表单
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Along with the basic requirements listed in [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting
    Started with PyQt*, you will need your calendar-form code and Qt Designer files
    from [Chapter 2](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml), *Building Comprehensive
    Forms with QtWidgets*. You may also wish to download the example code from our
    GitHub repository at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter03](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter03).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml)中列出的基本要求外，*使用PyQt入门*，您还需要来自[第2章](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml)*使用QtWidgets构建全面表单*的日历表单代码和Qt
    Designer文件。您可能还希望从我们的GitHub存储库[https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter03](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter03)下载示例代码。
- en: Check out the following video to see the code in action: [http://bit.ly/2M5OFQo](http://bit.ly/2M5OFQo)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码是如何运行的：[http://bit.ly/2M5OFQo](http://bit.ly/2M5OFQo)
- en: Signal and slot basics
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号和插槽基础
- en: A **signal** is a special property of an object that can be emitted in response
    to a type of **event**. An event may be something such as a user action, a timeout,
    or the completion of an asynchronous method call.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号**是对象的特殊属性，可以在对应的**事件**类型中发出。事件可以是用户操作、超时或异步方法调用的完成等。'
- en: '**Slots** are object methods that can receive a signal and act in response
    to it. We connect signals to slots in order to configure our application''s response
    to an event.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**插槽**是可以接收信号并对其做出响应的对象方法。我们连接信号到插槽，以配置应用程序对事件的响应。'
- en: All classes descended from `QObject` (which accounts for most classes in Qt,
    including all `QWidget` classes) can send and receive signals. Each different
    class has its own set of signals and slots appropriate for the function of that
    class.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有从`QObject`继承的类（这包括Qt中的大多数类，包括所有`QWidget`类）都可以发送和接收信号。每个不同的类都有适合该类功能的一组信号和插槽。
- en: 'For example, `QPushButton` has a `clicked` signal that is emitted whenever
    the button is clicked by a user. The `QWidget` class has a `close()` slot that
    causes it to close if it''s a top-level window. We could connect the two like
    this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`QPushButton`有一个`clicked`信号，每当用户点击按钮时就会发出。`QWidget`类有一个`close()`插槽，如果它是顶级窗口，就会导致它关闭。我们可以这样连接两者：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you copy this code into our application template and run it, you'll find
    that clicking the Quit button closes the window and ends the program. The syntax
    for connecting a signal to a slot in PyQt5 is `object1.signalName.connect(object2.slotName)`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将此代码复制到我们的应用程序模板中并运行它，您会发现单击“退出”按钮会关闭窗口并结束程序。在PyQt5中连接信号到插槽的语法是`object1.signalName.connect(object2.slotName)`。
- en: 'You can also make connections when creating an object by passing a slot to
    a signal as a keyword argument. For example, the previous code could be rewritten
    as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在创建对象时通过将插槽作为关键字参数传递给信号来进行连接。例如，前面的代码可以重写如下：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: C++ and older versions of PyQt use a very different syntax for signals and slots,
    which uses `SIGNAL()` and `SLOT()` wrapper functions. These don't exist in PyQt5,
    so bear this in mind if you're following an older tutorial or non-Python documentation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C++和旧版本的PyQt使用非常不同的信号和插槽语法，它使用`SIGNAL()`和`SLOT()`包装函数。这些在PyQt5中不存在，所以如果您在遵循旧教程或非Python文档，请记住这一点。
- en: 'Signals can also carry data with them that slots can receive. For example, `QLineEdit`
    has a `textChanged` signal that sends the text entered into the widget along with
    the signal. The line edit also has a `setText()` slot that accepts a string argument.
    We could connect those like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 信号还可以携带数据，插槽可以接收。例如，`QLineEdit`有一个`textChanged`信号，随信号发送进小部件的文本一起。该行编辑还有一个接受字符串参数的`setText()`插槽。我们可以这样连接它们：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we've connected the `textChanged` signal of `entry1` to the
    `setText()` slot of `entry2`. That means whenever the text is changed in `entry1`,
    it will signal `entry2` with the text entered; `entry2` will set its own text
    to the received string, causing it to mirror whatever is entered in `entry1`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`entry1`的`textChanged`信号连接到`entry2`的`setText()`插槽。这意味着每当`entry1`中的文本发生变化时，它将用输入的文本信号`entry2`；`entry2`将把自己的文本设置为接收到的字符串，导致它镜像`entry1`中输入的任何内容。
- en: 'In PyQt5, a slot doesn''t have to be an official Qt slot method; it can be
    any Python callable, such as a custom method or a built-in function. For example,
    let''s connect the `entry2` widget''s `textChanged` to good old `print()`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在PyQt5中，插槽不必是官方的Qt插槽方法；它可以是任何Python可调用对象，比如自定义方法或内置函数。例如，让我们将`entry2`小部件的`textChanged`连接到老式的`print()`：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, you'll see that every change to `entry2` is printed to the console. The
    `textChanged` signal basically calls `print()` every time it fires, passing in
    the text carried with the signal.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您会发现对`entry2`的每次更改都会打印到控制台。`textChanged`信号基本上每次触发时都会调用`print()`，并传入信号携带的文本。
- en: 'Signals can even be connected to other signals, for example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 信号甚至可以连接到其他信号，例如：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We've connected the `entry2` widget's `returnPressed` signal (which is emitted
    whenever the user presses *return*/*Enter* while focused on the widget) to the
    `entry1` widget's `editingFinished` signal, which in turn is connected to a `lambda`
    function that prints a message. When you connect a signal to another signal, the
    event and data are passed from one signal to the next. The net result is that
    triggering `returnPressed` on `entry2` causes `editingFinished` to be emitted
    by `entry1`, which in turn runs the `lambda` function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`entry2`小部件的`returnPressed`信号（每当用户在小部件上按下*return*/*Enter*时发出）连接到`entry1`小部件的`editingFinished`信号，而`editingFinished`信号又连接到一个打印消息的`lambda`函数。当你连接一个信号到另一个信号时，事件和数据会从一个信号传递到下一个信号。最终结果是在`entry2`上触发`returnPressed`会导致`entry1`发出`editingFinished`，然后运行`lambda`函数。
- en: Restrictions on signal and slot connections
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号和槽连接的限制
- en: While PyQt offers amazing flexibility by allowing us to connect signals to any
    Python callable, there are a few rules and limitations that you need to keep in
    mind. C++, unlike Python, is a **statically typed** language, which means that
    variables and function arguments must be given a type (`string`, `integer`, `float`,
    or one of many other types) and any value stored in the variable or passed to
    that function must have a matching type. This is called **type safety**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管PyQt允许我们将信号连接到任何Python可调用对象，但有一些规则和限制需要牢记。与Python不同，C++是一种**静态类型**语言，这意味着变量和函数参数必须给定一个类型（`string`、`integer`、`float`或许多其他类型），并且存储在变量中或传递给该函数的任何值必须具有匹配的类型。这被称为**类型安全**。
- en: 'Native Qt signals and slots are type-safe. Suppose, for instance, we tried
    to connect a line edit''s `textChanged` signal to the button''s `clicked` signal,
    like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 原生的Qt信号和槽是类型安全的。例如，假设我们尝试将行编辑的`textChanged`信号连接到按钮的`clicked`信号，如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This won''t work, because `textChanged` emits a string, and `clicked` emits
    (and therefore expects to receive) a Boolean. If you run this, you''ll get an
    error such as this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是行不通的，因为`textChanged`发出一个字符串，而`clicked`发出（并且因此期望接收）一个布尔值。如果你运行这个，你会得到这样的错误：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Slots can have multiple implementations, each with its own **signature**, allowing
    the same slot to take different argument types. This is called an **overloaded**
    slot. As long as our signal signature matches any of the overloaded slots, we
    can make the connection and Qt will work out which one we're connecting to.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 槽可以有多个实现，每个实现都有自己的**签名**，允许相同的槽接受不同的参数类型。这被称为**重载**槽。只要我们的信号签名与任何重载的槽匹配，我们就可以建立连接，Qt会确定我们连接到哪一个。
- en: When connecting to a slot that is a Python function, we don't have to be worried
    about argument types because Python is **dynamically typed** (though it's up to
    us to make sure our Python code does the right thing with whatever object is passed
    to it). As with any call to a Python function, however, we do need to make sure
    we pass in enough arguments to satisfy the function signature.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接到一个是Python函数的槽时，我们不必担心参数类型，因为Python是**动态类型**的（尽管我们需要确保我们的Python代码对传递给它的任何对象都做正确的事情）。然而，与对Python函数的任何调用一样，我们确实需要确保传入足够的参数来满足函数签名。
- en: 'For example, let''s add a method to our `MainWindow` class, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们向`MainWindow`类添加一个方法，如下所示：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This instance method needs three arguments (`self` is automatically passed).
    Let''s try to connect a button''s `clicked` signal to it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实例方法需要三个参数（`self`会自动传递）。让我们尝试将按钮的`clicked`信号连接到它：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code doesn''t object to the connection itself, but when you click the
    button, the program crashes with this error:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码本身并不反对连接，但当你点击按钮时，程序会崩溃并显示以下错误：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since the `clicked` signal only sends one argument, the function call is incomplete
    and it throws an exception. This can be solved by making `arg2` and `arg3` into
    keyword arguments (by adding default values), or by creating a wrapper function
    that populates them with values some other way.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`clicked`信号只发送一个参数，函数调用是不完整的，会抛出异常。可以通过将`arg2`和`arg3`变成关键字参数（添加默认值），或者创建一个以其他方式填充它们的包装函数来解决这个问题。
- en: Incidentally, the inverse situation—where the slot takes fewer arguments than
    the signal sends—is not a problem. Qt just drops the extra data from the signal.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，槽接收的参数比信号发送的参数少的情况并不是问题。Qt只是从信号中丢弃额外的数据。
- en: 'So, for example, there is no problem connecting `clicked` to a method with
    no arguments, like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，将`clicked`连接到一个没有参数的方法是没有问题的，如下所示：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating custom signals and slots
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义信号和槽
- en: Setting callbacks for button clicks and text changes is a common and very obvious
    use for signals and slots, but it is really only the beginning. At its core, the
    signals and slots mechanism can be seen as a way for any two objects in an application
    to communicate while remaining **loosely coupled**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为按钮点击和文本更改设置回调是信号和槽的常见和非常明显的用法，但这实际上只是开始。在本质上，信号和槽机制可以被看作是应用程序中任何两个对象进行通信的一种方式，同时保持**松散耦合**。
- en: Loose coupling refers to keeping the amount of information two objects need
    to know about each other to a minimum. It's an essential trait to preserve when
    designing large, complex applications because it isolates code and prevents inadvertent
    breakage. The opposite is tight coupling, where one object's code depends heavily
    on the internal structures of another.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 松散耦合是指保持两个对象彼此需要了解的信息量最少。这是设计大型复杂应用程序时必须保留的重要特性，因为它隔离了代码并防止意外的破坏。相反的是紧密耦合，其中一个对象的代码严重依赖于另一个对象的内部结构。
- en: In order to take full advantage of this functionality, we'll need to learn how
    to create our own custom signals and slots.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用这一功能，我们需要学习如何创建自己的自定义信号和槽。
- en: Sharing data between windows using custom signals
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义信号在窗口之间共享数据
- en: Suppose you have a program that pops up a form window. When the user finishes
    filling in the form and submits it, we need to get the entered data back to the
    main application class for processing. There are a few ways we could approach
    this; for instance, the main application could watch for click events on the pop-up
    window's **Submit** button, then grab the data from its fields before destroying
    the dialog. But that approach requires the main form to know all about the pop-up
    dialog's widgets, and any refactor of the popup would risk breaking code in the
    main application window.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个弹出表单窗口的程序。当用户完成填写表单并提交时，我们需要将输入的数据传回主应用程序类进行处理。我们可以采用几种方法来解决这个问题；例如，主应用程序可以监视弹出窗口的**提交**按钮的单击事件，然后在销毁对话框之前从其字段中获取数据。但这种方法要求主窗体了解弹出对话框的所有部件，而且任何对弹出窗口的重构都可能破坏主应用程序窗口中的代码。
- en: 'Let''s try a different approach using signals and slots. Open a fresh copy
    of our application template from [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml),
    *Getting Started with PyQt*, and start a new class called `FormWindow`, like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用信号和槽的不同方法。从[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml)中打开我们应用程序模板的新副本，*PyQt入门*，并开始一个名为`FormWindow`的新类，就像这样：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first thing we've defined in this class is a custom signal called `submitted`.
    To define a custom signal, we need to call the `QtCore.pyqtSignal()` function.
    The arguments to `pyqtSignal()` are the data types our signal will be carrying,
    in this case, `str`. We can use Python `type` objects here, or strings naming
    a C++ data type (`'QString'`, for example).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中我们定义的第一件事是一个名为`submitted`的自定义信号。要定义自定义信号，我们需要调用`QtCore.pyqtSignal()`函数。`pyqtSignal()`的参数是我们的信号将携带的数据类型，在这种情况下是`str`。我们可以在这里使用Python
    `type`对象，或者命名C++数据类型的字符串（例如`'QString'`）。
- en: 'Now let''s build the form by defining the `__init__()` method as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过定义`__init__()`方法来构建表单，如下所示：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we''re defining a `QLineEdit` for data entry and a `QPushButton` for
    submitting the form. The button-click signal is bound to a method called `onSubmit`,
    which we''ll define next:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个用于数据输入的`QLineEdit`和一个用于提交表单的`QPushButton`。按钮单击信号绑定到一个名为`onSubmit`的方法，我们将在下面定义：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this method, we call the `submitted` signal's `emit()` method, passing in
    the contents of `QLineEdit`. This means that any connected slots will be called
    with the string retrieved from `self.edit.text()`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们调用`submitted`信号的`emit()`方法，传入`QLineEdit`的内容。这意味着任何连接的槽都将使用从`self.edit.text()`检索到的字符串进行调用。
- en: After emitting the signal, we close the `FormWindow`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 发射信号后，我们关闭`FormWindow`。
- en: 'Down in our `MainWindow` constructor, let''s build an application that uses
    it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`MainWindow`构造函数中，让我们构建一个使用它的应用程序：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we've created a `QLabel` and a `QPushButton` and added them to a vertical
    layout. When clicked, the button calls a method called `onChange()`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`QLabel`和一个`QPushButton`，并将它们添加到垂直布局中。单击按钮时，按钮调用一个名为`onChange()`的方法。
- en: 'The `onChange()` method looks like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`onChange()`方法看起来像这样：'
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method creates an instance of our `FormWindow`. It then binds our custom
    signal, `FormWindow.submitted`, to the `setText` slot of the label; `setText`
    takes a single string for an argument, and our signal sends a single string.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法创建了一个`FormWindow`的实例。然后将我们的自定义信号`FormWindow.submitted`绑定到标签的`setText`槽；`setText`接受一个字符串作为参数，而我们的信号发送一个字符串。
- en: If you run this application, you'll see that when you submit the pop-up form
    window, the text in the label does indeed change.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此应用程序，您会看到当您提交弹出窗口表单时，标签中的文本确实会更改。
- en: The beauty of this design is that `FormWindow` doesn't need to know anything
    whatsoever about `MainWindow`, and `MainWindow` only needs to know that `FormWindow`
    has a `submitted` signal that emits the entered string. We could easily modify
    the structure and internals of either class, without causing issues for the other,
    as long as the same signal emits the same piece of data.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的美妙之处在于`FormWindow`不需要知道任何关于`MainWindow`的东西，而`MainWindow`只需要知道`FormWindow`有一个`submitted`信号，该信号发射输入的字符串。只要相同的信号发射相同的数据，我们可以轻松修改任一类的结构和内部，而不会对另一类造成问题。
- en: '`QtCore` also contains a `pyqtSlot()` function, which we can use as a decorator
    to indicate that a Python function or method is intended as a slot.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`QtCore`还包含一个`pyqtSlot()`函数，我们可以将其用作装饰器，表示Python函数或方法旨在作为槽使用。'
- en: 'For example, we can decorate our `MainWindow.onChange()` method to declare
    it as a slot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以装饰我们的`MainWindow.onChange()`方法来声明它为一个槽：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is purely optional, since we can use any Python callable as a slot, though
    it does give us the ability to enforce type safety. For instance, if we wanted
    to require that `onChange()` should always receive a string, we could decorate
    it like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这纯粹是可选的，因为我们可以使用任何Python可调用对象作为槽，尽管这确实给了我们强制类型安全的能力。例如，如果我们希望要求`onChange()`始终接收一个字符串，我们可以这样装饰它：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you do this and run the program, you''ll see that our attempt to connect
    a `clicked` signal would fail:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您这样做并运行程序，您会看到我们尝试连接`clicked`信号会失败：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Apart from imposing type safety, declaring a method as a slot reduces its memory
    usage and provides a small improvement in speed. So, while it's entirely optional,
    it may be worth doing for methods that will only ever be used as slots.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除了强制类型安全外，将方法声明为槽还会减少其内存使用量，并提供一点速度上的改进。因此，虽然这完全是可选的，但对于只会被用作槽的方法来说，这可能值得做。
- en: Overloading signals and slots
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号和槽的重载
- en: Just as C++ signals and slots can be overloaded to accept different argument
    signatures, we can overload our custom PyQt signals and slots. For instance, suppose
    that, if a valid integer string is entered into our pop-up window, we'd like to
    emit it as both a string and an integer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 就像C++信号和槽可以被重载以接受不同的参数签名一样，我们也可以重载我们自定义的PyQt信号和槽。例如，假设如果在我们的弹出窗口中输入了一个有效的整数字符串，我们希望将其作为字符串和整数发射出去。
- en: 'To do this, we first have to redefine our signal:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们首先必须重新定义我们的信号：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Instead of just passing in a single variable type, we''re passing in two lists
    of variable types. Each list represents the argument list of a signal signature.
    So, we''ve registered two signals here: one that sends out a string only, and
    one that sends out an integer and a string.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅传入单个变量类型，而是传入两个变量类型的列表。每个列表代表一个信号签名的参数列表。因此，我们在这里注册了两个信号：一个只发送字符串，一个发送整数和字符串。
- en: 'In `FormWindow.onSubmit()`, we can now examine the text in the line edit and
    send out the signal with the appropriate signature:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FormWindow.onSubmit()`中，我们现在可以检查行编辑中的文本，并使用适当的签名发送信号：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we test the text in `self.edit` to see whether it's a valid number string.
    If it is, we convert it to `int` and emit the `submitted` signal with the integer
    and string version of the text. The syntax for selecting a signature is to follow
    the signal name with square brackets containing a list of the argument types.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们测试`self.edit`中的文本，以查看它是否是有效的数字字符串。如果是，我们将其转换为`int`，并使用整数和文本版本的文本发出`submitted`信号。选择签名的语法是在信号名称后跟一个包含参数类型列表的方括号。
- en: 'Back in the main window, we''ll define two new methods to handle these signals:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 回到主窗口，我们将定义两种新方法来处理这些信号：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ve created two slots—one that accepts a string and another that accepts
    an integer and a string. We can now connect the two signals in `FormWindow` to
    the appropriate slot like so:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了两个插槽——一个接受字符串，另一个接受整数和字符串。现在我们可以将`FormWindow`中的两个信号连接到适当的插槽，如下所示：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the script, and you'll find now that entering a string of digits will print
    a different message than an alphanumeric string.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，您会发现输入一串数字会打印与字母数字字符串不同的消息。
- en: Automating our calendar form
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化我们的日历表单
- en: 'To see how signal and slot usage works in an actual application, let''s take
    the calendar form that we built in [Chapter 2](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml), *Building
    Forms with QtWidgets*, and turn it into a working calendar application. To do
    this, we''re going to need to make the following changes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解信号和插槽在实际应用程序中的使用方式，让我们拿我们在[第2章](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml)
    *使用QtWidgets构建表单*中构建的日历表单，并将其转换为一个可工作的日历应用程序。为此，我们需要进行以下更改：
- en: The app needs a way to store events that we enter.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序需要一种方法来存储我们输入的事件。
- en: The All Day checkbox should disable the time entry when checked.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全天复选框应在选中时禁用时间输入。
- en: Selecting a day on the calendar should populate the event list with the events
    for that day.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在日历上选择一天应该用当天的事件填充事件列表。
- en: Selecting an event in the event list should populate the form with the event's
    details.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事件列表中选择一个事件应该用事件的详细信息填充表单。
- en: Clicking Add/Update should update the saved event details if an event was selected,
    or add a new event if one was not.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击“添加/更新”应该更新保存的事件详细信息，如果选择了事件，或者如果没有选择事件，则添加一个新事件。
- en: Clicking Delete should remove the selected event.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击删除应该删除所选事件。
- en: If no event is selected, Delete should be disabled.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有选择事件，删除应该被禁用。
- en: Selecting New… as a category should open a dialog allowing us to enter a new
    category. If we choose to enter one, it should be selected.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择“新建…”作为类别应该打开一个对话框，允许我们输入一个新的类别。如果我们选择输入一个，它应该被选中。
- en: We'll first go through this using our hand-coded form, then talk about how to
    approach the same issue using Qt Designer files.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用我们手工编码的表单进行这一过程，然后讨论如何使用Qt Designer文件解决同样的问题。
- en: Using our hand-coded form
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我们手工编码的表单
- en: To get started, copy your `calendar_form.py` file from [Chapter 2](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml), *Building
    Forms with QtWidgets,* into a new file called `calendar_app.py` and open it in
    your editor. We're going to start editing our `MainWindow` class and flesh it
    out into a complete application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请将您的`calendar_form.py`文件从[第2章](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml)
    *使用QtWidgets构建表单*复制到一个名为`calendar_app.py`的新文件中，并在编辑器中打开它。我们将开始编辑我们的`MainWindow`类，并将其完善为一个完整的应用程序。
- en: 'To handle storing the events, we''ll just create a `dict` property in `MainWindow`,
    like so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理存储事件，我们将在`MainWindow`中创建一个`dict`属性，如下所示：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''re not going to bother persisting data to disk, though you can certainly
    add such a feature if you wish. Each item in `dict` will use a `date` object as
    its key and contain a list of `dict` objects holding the details of all the events
    on that date. The layout of the data will look something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算将数据持久化到磁盘，尽管如果您愿意，您当然可以添加这样的功能。`dict`中的每个项目将使用`date`对象作为其键，并包含一个包含该日期上所有事件详细信息的`dict`对象列表。数据的布局将看起来像这样：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, let's dig into the form automation. The easiest change to make is disabling
    the time entry when the All Day checkbox is clicked since this automation only
    requires dealing with built-in signals and slots.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们深入研究表单自动化。最简单的更改是在单击“全天”复选框时禁用时间输入，因为这种自动化只需要处理内置信号和插槽。
- en: 'In the `__init__()` method, we''ll add this code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__()`方法中，我们将添加这段代码：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `QCheckBox.toggled` signal is emitted whenever the checkbox is toggled on
    or off, and sends out a Boolean indicating whether the checkbox is (post-change)
    unchecked (`False`) or checked (`True`). This connects nicely to `setDisabled`,
    which will disable the widget on `True` or enable it on `False`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`QCheckBox.toggled`信号在复选框切换开或关时发出，并发送一个布尔值，指示复选框是（更改后）未选中（`False`）还是选中（`True`）。这与`setDisabled`很好地连接在一起，它将在`True`时禁用小部件，在`False`时启用它。'
- en: Creating and connecting our callback methods
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和连接我们的回调方法
- en: The rest of our required automation doesn't map to built-in Qt slots, so before
    we can connect any more signals, we'll need to create some methods that will be
    used to implement the slots. We'll create all these as methods of the `MainWindow`
    class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的其余自动化不适用于内置的Qt插槽，因此在连接更多信号之前，我们需要创建一些将用于实现插槽的方法。我们将把所有这些方法创建为`MainWindow`类的方法。
- en: 'Before we start with the callbacks, we''ll create a utility method to clear
    out the form, which several of the callback methods will need. It looks like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始处理回调之前，我们将创建一个实用方法来清除表单，这是几个回调方法将需要的。它看起来像这样：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Essentially, this method goes through the fields in our form and sets them all
    to default values. Unfortunately, this requires a different method call for each
    widget, so we just have to spell it all out.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这个方法会遍历我们表单中的字段，并将它们全部设置为默认值。不幸的是，这需要为每个小部件调用不同的方法，所以我们必须把它全部写出来。
- en: Now let's go through the callback methods.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看回调方法。
- en: The populate _list () method
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: populate_list()方法
- en: 'The first actual callback method is `populate_list()`, which looks like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个实际的回调方法是`populate_list()`，它如下所示：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will be called whenever the calendar selection is changed, and its job
    is to repopulate the `event_list` widget with the events from that day. It starts
    by clearing the list and the form. It then retrieves the selected date from the
    calendar widget using its `selectedDate()` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在日历选择更改时调用，并且其工作是使用该天的事件重新填充`event_list`小部件。它首先清空列表和表单。然后，它使用其`selectedDate()`方法从日历小部件中检索所选日期。
- en: Then, we cycle through the list of events for the selected date's `self.events`
    dictionary, building a string containing the time and event title and adding it
    to the `event_list` widget. Note that our event time is a `QTime` object, so to
    use it as a string we need to convert it using its `toString()` method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们循环遍历所选日期的`self.events`字典的事件列表，构建一个包含时间和事件标题的字符串，并将其添加到`event_list`小部件中。请注意，我们的事件时间是一个`QTime`对象，因此要将其用作字符串，我们需要使用它的`toString()`方法进行转换。
- en: See the `QTime` documentation at [https://doc.qt.io/qt-5/qtime.html](https://doc.qt.io/qt-5/qtime.html)
    for details on how to format time values as strings.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何将时间值格式化为字符串的详细信息，请参阅[https://doc.qt.io/qt-5/qtime.html](https://doc.qt.io/qt-5/qtime.html)中的`QTime`文档。
- en: 'To connect this method, back in `__init__()`, we add this code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接这个方法，在`__init__()`中，我们添加了这段代码：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `selectionChanged` signal is emitted whenever a new day is selected on the
    calendar. It does not send any data with the signal, so our callback does not
    expect any.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectionChanged`信号在日历上选择新日期时发出。它不发送任何数据，因此我们的回调函数不需要任何数据。'
- en: The populate _form () method
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: populate_form()方法
- en: 'The next callback is `populate_form()`, which will be called when an event
    is selected and populate the event details form. It begins like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的回调是`populate_form()`，当选择事件时将调用它并填充事件详细信息表单。它开始如下：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we start by clearing the form, then retrieving the selected date from
    the calendar, and the selected event from the event list. When no event is selected,
    `QListWidget.currentRow()` returns a value of `-1`; in that case, we'll just return,
    leaving the form blank.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先清空表单，然后从日历中检索所选日期，并从事件列表中检索所选事件。当没有选择事件时，`QListWidget.currentRow()`返回值为`-1`；在这种情况下，我们将只是返回，使表单保持空白。
- en: 'The remainder of the method looks like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的其余部分如下：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since the items on the list widget are displayed in the same order that they're
    stored in the `events` dictionary, we can use the row number of the selected item
    to retrieve an event from the selected date's list.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表小部件上显示的项目与`events`字典中存储的顺序相同，因此我们可以使用所选项目的行号来从所选日期的列表中检索事件。
- en: Once the data is retrieved, we just need to set each widget to the saved value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据被检索，我们只需要将每个小部件设置为保存的值。
- en: 'Back in `__init__()`, we''ll connect the slot like so:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`__init__()`中，我们将连接槽如下：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`QListWidget` emits `itemSelectionChanged` whenever a new item is selected.
    It doesn''t send any data with it, so again, our callback expects none.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`QListWidget`在选择新项目时发出`itemSelectionChanged`。它不发送任何数据，因此我们的回调函数也不需要任何数据。'
- en: The save _event () method
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: save_event()方法
- en: 'The `save_event()` callback will be called whenever the Add/Update button is
    pushed. It starts like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`save_event()`回调将在单击添加/更新按钮时调用。它开始如下：'
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this code, we are now calling the accessor methods to retrieve the values
    from the widgets and assign them to the appropriate keys of the event's dictionary.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们现在调用访问器方法来从小部件中检索值，并将它们分配给事件字典的适当键。
- en: 'Next, we''ll retrieve the current event list for the selected date and determine
    whether this is an addition or an update:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检索所选日期的当前事件列表，并确定这是添加还是更新：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Remember that `QListWidget.currentRow()` returns `-1` if no items are selected.
    In which case, we want to append our new event to the list. Otherwise, we replace
    the selected event with our new event dictionary:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果没有选择项目，`QListWidget.currentRow()`会返回`-1`。在这种情况下，我们希望将新事件追加到列表中。否则，我们将所选事件替换为我们的新事件字典：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To finish this method, we're going to sort the list using the time value. Remember
    that we're using `None` for an all-day event, so those will be sorted first by
    replacing them in the sort with a `QTime` of 0:00.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个方法，我们将使用时间值对列表进行排序。请记住，我们对全天事件使用`None`，因此它们将首先通过在排序中用`QTime`的0:00替换它们来进行排序。
- en: After sorting, we replace the event list for the current date with our newly
    sorted list and repopulate the `QListWidget` with the new list.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 排序后，我们用新排序的列表替换当前日期的事件列表，并用新列表重新填充`QListWidget`。
- en: 'We''ll connect the `add_button` widget''s `clicked` event by adding this code
    to `__init__()`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在`__init__()`中添加以下代码来连接`add_button`小部件的`clicked`事件：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The delete _event () method
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: delete_event()方法
- en: 'The `delete_event` method will be called whenever the Delete button is clicked,
    and it looks like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete_event`方法将在单击删除按钮时调用，它如下所示：'
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once again, we retrieve the current date and currently selected row and use
    them to locate the event in `self.events` that we want to delete. After deleting
    the item from the list, we set the list widget to no selection by setting `currentRow`
    to `-1`. Then, we clear the form and populate the list widget.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们检索当前日期和当前选择的行，并使用它们来定位我们想要删除的`self.events`中的事件。在从列表中删除项目后，我们通过将`currentRow`设置为`-1`来将列表小部件设置为无选择。然后，我们清空表单并填充列表小部件。
- en: Note that we don't bother checking to see whether the currently selected row
    is `-1`, because we plan to disable the delete button when no row is selected.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要检查当前选择的行是否为`-1`，因为我们计划在没有选择行时禁用删除按钮。
- en: 'This callback is pretty simple to connect to the `del_button` back in `__init__()`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个回调很容易连接到`__init__()`中的`del_button`：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The check _delete _btn () method
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查`_delete _btn()`方法
- en: 'Our last callback is the simplest of all, and it looks like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个回调是最简单的，它看起来像这样：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This method simply checks whether there is no event currently selected in the
    event list widget, and it enables or disables the delete button accordingly.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只是检查当前事件列表小部件中是否没有事件被选中，并相应地启用或禁用删除按钮。
- en: 'Back in `__init__()`, let''s connect to this callback:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`__init__()`，让我们连接到这个回调：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We're connecting this callback to the `itemSelectionChanged` signal. Note that
    we've already connected that signal to another slot as well. Signals can be connected
    to any number of slots without a problem. We also call the method directly, so
    that the `del_button` will start out disabled.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个回调连接到`itemSelectionChanged`信号。请注意，我们已经将该信号连接到另一个插槽。信号可以连接到任意数量的插槽而不会出现问题。我们还直接调用该方法，以便`del_button`一开始就被禁用。
- en: Building our new category pop-up form
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的新类别弹出表单
- en: 'The last feature we want in our application is the ability to add new categories
    to our combo box. The basic workflow we need to implement is this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中的最后一个功能是能够向组合框添加新类别。我们需要实现的基本工作流程是：
- en: When a user changes the event category, check whether they selected New…
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户更改事件类别时，检查他们是否选择了“新…”
- en: If so, open a form in a new window that lets them type in a category
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这样，打开一个新窗口中的表单，让他们输入一个类别
- en: When the form is submitted, emit the name of the new category
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当表单提交时，发出新类别的名称
- en: When that signal is emitted, add a new category to the combo box and select
    it
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发出该信号时，向组合框添加一个新类别并选择它
- en: If the user opts not to enter a new category, default the combo box to Select
    Category…
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户选择不输入新类别，则将组合框默认为“选择类别…”
- en: 'Let''s start by implementing our pop-up form. This will be just like the form
    example we went through earlier in this chapter, and it looks like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从实现我们的弹出表单开始。这将与我们在本章前面讨论过的表单示例一样，它看起来像这样：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This class is the same as our `FormWindow` class with the addition of a label
    and a Cancel button. The `cancel_btn` widget will call the window's `close()`
    method when clicked, causing the window to close without emitting any signals.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类与我们的`FormWindow`类相同，只是增加了一个标签和一个取消按钮。当点击`cancel_btn`小部件时，将调用窗口的`close()`方法，导致窗口关闭而不发出任何信号。
- en: 'Back in `MainWindow`, let''s implement a method to add a new category to the
    combo box:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`MainWindow`，让我们实现一个方法，向组合框添加一个新类别：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This method is pretty simple; it just receives a category text, adds it to the
    end of the combo box, and sets the combo box selection to the new category.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常简单；它只是接收一个类别文本，将其添加到组合框的末尾，并将组合框选择设置为新类别。
- en: 'Now we need to write a method that will create an instance of our pop-up form
    whenever New… is selected:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要编写一个方法，每当选择“新…”时，它将创建我们弹出表单的一个实例：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This method takes the `text` value to which the category has been changed and
    checks to see whether it's New…. If it is, we create our `CategoryWindow` object
    and connect its `submitted` signal to our `add_category()` method. Then, we set
    the current index to `0`, which is our Select Category… option.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法接受已更改类别的`text`值，并检查它是否为“新…”。如果是，我们创建我们的`CategoryWindow`对象，并将其`submitted`信号连接到我们的`add_category()`方法。然后，我们将当前索引设置为`0`，这是我们的“选择类别…”选项。
- en: Now, when `CategoryWindow` is shown, the user will either click Cancel, in which
    case the window will close and the combo box will be set to Select Category… where
    `on_category_change()` left it, or the user will enter a category and click Submit,
    in which case `CategoryWindow` will emit a `submitted` signal with the new category.
    The `add_category()` method will receive that new category, add it, and set the
    combo box to it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当`CategoryWindow`显示时，用户要么点击取消，窗口将关闭并且组合框将被设置为“选择类别…”，就像`on_category_change()`留下的那样，要么用户将输入一个类别并点击提交，这样`CategoryWindow`将发出一个带有新类别的`submitted`信号。`add_category()`方法将接收到新类别，将其添加，并将组合框设置为它。
- en: Our calendar app is now complete; fire it up and give it a try!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的日历应用现在已经完成；启动它并试试吧！
- en: Using Qt Designer .ui files
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt Designer .ui文件
- en: Now let's back up and go through that same process using the Qt Designer files
    we created in [Chapter 2](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml), *Building
    Forms with QtWidgets*. This will require a rather different approach, but the
    end product will be the same.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回过头来使用我们在[第2章](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml)中创建的Qt Designer文件，*使用QtWidgets构建表单*。这将需要一种完全不同的方法，但最终产品将是一样的。
- en: To work through this section, you'll need both your `calendar_form.ui` file
    from [Chapter 2](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml), *Building Forms
    with QtWidgets* and a second `.ui` file for the category window. You can build
    this form on your own as practice, or use the one included with the example code
    for this chapter. If you choose to build your own, make sure to name each object
    just as we did in the code in the last section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本节的工作，您需要[第2章](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml)中的`calendar_form.ui`文件，*使用QtWidgets构建表单*，以及第二个`.ui`文件用于类别窗口。您可以自己练习构建这个表单，也可以使用本章示例代码中包含的表单。如果选择自己构建，请确保将每个对象命名为我们在上一节的代码中所做的那样。
- en: Connecting slots in Qt Designer
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Qt Designer中连接插槽
- en: Qt Designer has a limited capability to connect signals and slots to our GUI.
    For Python developers, its mainly only useful for connecting built-in Qt signals
    to built-in Qt slots between widgets in the same window. Connecting signals to
    Python callables or custom PyQt signals isn't really possible.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Qt Designer对于连接信号和插槽到我们的GUI的能力有限。对于Python开发人员，它主要只能用于在同一窗口中的小部件之间连接内置的Qt信号到内置的Qt插槽。连接信号到Python可调用对象或自定义的PyQt信号实际上是不可能的。
- en: 'In the calendar GUI, we do have one example of a native Qt signal-slot connection—the
    `allday_check` widget is connected to the `event_time` widget. Let''s look at
    how to connect these in Qt Designer:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在日历GUI中，我们确实有一个原生的Qt信号-槽连接示例——`allday_check`小部件连接到`event_time`小部件。让我们看看如何在Qt
    Designer中连接这些：
- en: Open the `calendar_form.ui` file in Qt Designer
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Qt Designer中打开`calendar_form.ui`文件
- en: At the lower-right side of the screen, find the Signal/Slot Editor panel
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕右下角找到Signal/Slot Editor面板
- en: Click the + icon to add a new connection
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击+图标添加一个新的连接
- en: Under Sender, open the pop-up menu and select `allday_check`
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Sender下，打开弹出菜单，选择`allday_check`
- en: Under Signal, choose toggled(bool)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Signal下，选择toggled(bool)
- en: For Receiver, choose `event_time`
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Receiver，选择`event_time`
- en: Finally, for Slot, choose setDisabled(bool)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于Slot，选择setDisabled(bool)
- en: 'The resulting entry should look like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的条目应该是这样的：
- en: '![](assets/f8145b67-f651-4977-9b7f-6e0c23b01bf5.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f8145b67-f651-4977-9b7f-6e0c23b01bf5.png)'
- en: If you're building your own `category_window.ui` file, make sure you also connect
    the cancel button's `clicked` signal to the category window's `closed` slot.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建自己的`category_window.ui`文件，请确保你还将取消按钮的`clicked`信号连接到类别窗口的`closed`槽。
- en: Converting .ui files to Python
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将.ui文件转换为Python
- en: If you were to open your `calendar_form.ui` file in a text editor, you'd see
    that it is neither Python nor C++, but rather an XML representation of the GUI
    you've designed. PyQt offers us a few choices for how to use the `.ui` file in
    a Python application.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在文本编辑器中打开你的`calendar_form.ui`文件，你会看到它既不是Python也不是C++，而是你设计的GUI的XML表示。PyQt为我们提供了几种选择，可以在Python应用程序中使用`.ui`文件。
- en: 'The first approach is to convert the XML into Python using the `pyuic5` tool
    included with PyQt. Open a command-line window in the directory where your `.ui`
    files are and run the following command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是使用PyQt附带的`pyuic5`工具将XML转换为Python。在存放`.ui`文件的目录中打开命令行窗口，运行以下命令：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will generate a file called `calendar_form.py`. If you open this file
    in your code editor, you''ll see that it contains a single class definition for
    a `Ui_MainWindow` class, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个名为`calendar_form.py`的文件。如果你在代码编辑器中打开这个文件，你会看到它包含一个`Ui_MainWindow`类的单个类定义，如下所示：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice that this class is not a subclass of `QWidget` or even `QObject`. By
    itself, this class will not display the window we built. Instead, this class will
    build the GUI we designed inside another widget, which we must create with code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个类既不是`QWidget`的子类，也不是`QObject`的子类。这个类本身不会显示我们构建的窗口。相反，这个类将在另一个小部件内部构建我们设计的GUI，我们必须用代码创建它。
- en: To do that, we'll import the class into another script, create a `QWidget` to
    serve as a container, and call the `setupUi()` method with our widget container
    as an argument.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将这个类导入到另一个脚本中，创建一个`QWidget`作为容器，并将`setupUi()`方法与我们的小部件容器作为参数一起调用。
- en: Don't be tempted to edit or add code to the generated Python file. If you ever
    want to update your GUI using Qt Designer, you'll lose all your edits when you
    generate the new file. Treat the generated code as if it were a third-party library.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 不要试图编辑或添加代码到生成的Python文件中。如果你想使用Qt Designer更新你的GUI，当你生成新文件时，你会丢失所有的编辑。把生成的代码当作第三方库来对待。
- en: Start by copying the PyQt app template from [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting
    Started with PyQt*, into the directory with `calendar_form.py` and call it `calendar_app.py`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml)，*PyQt入门*中复制PyQt应用程序模板到存放`calendar_form.py`的目录，并将其命名为`calendar_app.py`。
- en: 'At the top of the file, import the `Ui_MainWindow` class like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部像这样导入`Ui_MainWindow`类：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There are a few ways we can use this class, but the cleanest is to use **multiple
    inheritances** by adding it as a second parent class for `MainWindow`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以几种方式使用这个类，但最干净的方法是通过将它作为`MainWindow`的第二个父类进行**多重继承**。
- en: 'Update the `MainWindow` class definition like so:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`MainWindow`类定义如下：
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that our window's base class (the first parent class) remains `QWidget`.
    This base class needs to match the base class we chose when we initially designed
    the form (see [Chapter 2](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml), *Building
    Forms with QtWidgets*).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们窗口的基类（第一个父类）仍然是`QWidget`。这个基类需要与我们最初设计表单时选择的基类匹配（参见[第2章](2e39f2dd-7df5-4139-8c26-1fec2dfb68d0.xhtml)，*使用QtWidgets构建表单*）。
- en: 'Now, inside the constructor, we can call `setupUi`, like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在构造函数内部，我们可以调用`setupUi`，像这样：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you run the application at this point, you''ll see that the calendar GUI
    is all there, including our connection between `allday_check` and `event_time`.
    You can then add the remaining connections and modifications into the `MainWindow`
    constructor, like so:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这一点运行应用程序，你会看到日历GUI都在那里，包括我们在`allday_check`和`event_time`之间的连接。然后，你可以将其余的连接和修改添加到`MainWindow`构造函数中，如下所示：
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The callback methods for this class are identical to the ones we defined in
    our code-only example. Go ahead and copy those into the `MainWindow` class.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的回调方法与我们在代码中定义的方法是相同的。继续把它们复制到`MainWindow`类中。
- en: 'Another way to use the `Ui_` class created by `pyuic5` is to instantiate it
    as a property of our container widget. We''ll try this with our category window;
    add this class to the top of the file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pyuic5`创建的`Ui_`类的另一种方法是将其实例化为容器小部件的属性。我们将尝试在类别窗口中使用这个方法；在文件顶部添加这个类：
- en: '[PRE49]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After creating the `Ui_CategoryWindow` object as a property of `CategoryWindow`,
    we then call its `setupUi()` method to build the GUI on `CategoryWindow`. However,
    all our references to the widgets are now under the `self.ui` namespace. So, for
    example, `category_entry` is not `self.category_entry` but `self.ui.category_entry`.
    While this approach is slightly more verbose, it may help to avoid name collisions
    if you're building a particularly complex class.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`Ui_CategoryWindow`对象创建为`CategoryWindow`的属性之后，我们调用它的`setupUi()`方法来在`CategoryWindow`上构建GUI。然而，我们所有对小部件的引用现在都在`self.ui`命名空间下。因此，例如，`category_entry`不是`self.category_entry`，而是`self.ui.category_entry`。虽然这种方法稍微冗长，但如果你正在构建一个特别复杂的类，它可能有助于避免名称冲突。
- en: Automatic signal and slot connections
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动信号和插槽连接
- en: 'Take another look at the `Ui_` class generated by `pyuic5` and notice the last
    line of code in `setupUi`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看由`pyuic5`生成的`Ui_`类，并注意`setupUi`中的最后一行代码：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`connectSlotsByName()` is a method that will automatically connect signals
    and slots by matching up signals to methods named in the `on_object_name_signal()` format, where
    `object_name` matches the `objectName` property of a `PyQt` object and `signal`
    is the name of one of its built-in signals.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`connectSlotsByName()`是一种方法，它将通过将信号与以`on_object_name_signal()`格式命名的方法进行匹配来自动连接信号和插槽，其中`object_name`与`PyQt`对象的`objectName`属性匹配，`signal`是其内置信号之一的名称。'
- en: For example, in our `CategoryWindow`, we would like to create a callback that
    runs when `submit_btn` is clicked (if you made your own `.ui` file, make sure
    you named your submit button `submit_btn`). That will happen automatically if
    we name the callback `on_submit_btn_clicked()`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的`CategoryWindow`中，我们希望创建一个回调，当单击`submit_btn`时运行（如果您制作了自己的`.ui`文件，请确保您将提交按钮命名为`submit_btn`）。如果我们将回调命名为`on_submit_btn_clicked()`，那么这将自动发生。
- en: 'The code looks like this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE51]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If we get the names to match up, we don't have to explicitly call `connect()`
    anywhere; the callback will be wired up automatically.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使名称匹配，我们就不必在任何地方显式调用`connect()`；回调将自动连接。
- en: You can use `connectSlotsByName()` with hand-coded GUIs as well; you just need
    to explicitly set each widget's `objectName` property so that the method has something
    to match the name against. Variable names alone won't work.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在手工编码的GUI中使用`connectSlotsByName()`；您只需要显式设置每个小部件的`objectName`属性，以便该方法有东西与名称匹配。仅仅变量名是行不通的。
- en: Using .ui files without conversion
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不进行转换的情况下使用.ui文件
- en: If you don't mind a little conversion overhead during runtime, you can actually
    avoid the step of manually converting your `.ui` files by converting them on the
    fly inside your program using PyQt's `uic` library (on which `pyuic5` is based).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不介意在运行时进行一些转换开销，实际上可以通过使用PyQt的`uic`库（`pyuic5`基于此库）在程序内部动态转换您的`.ui`文件，从而避免手动转换这一步。
- en: 'Let''s try this with our `MainWindow` GUI. Start by commenting out your import
    of `Ui_MainWindow` and importing `uic`, like so:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用我们的`MainWindow` GUI。首先将您对`Ui_MainWindow`的导入注释掉，并导入`uic`，如下所示：
- en: '[PRE52]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, before your `MainWindow` class definition, call `uic.loadUiType()`, as
    follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您的`MainWindow`类定义之前，调用`uic.loadUiType()`，如下所示：
- en: '[PRE53]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`loadUiType()` takes a path to the `.ui` file and returns a tuple containing
    the generated UI class and the Qt base class on which it is based (in this case,
    `QWidget`).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadUiType()`接受一个`.ui`文件的路径，并返回一个包含生成的UI类和其基于的Qt基类（在本例中为`QWidget`）的元组。'
- en: 'We can then use these as the parent classes for our `MainWindow` class, like
    so:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将这些用作我们的`MainWindow`类的父类，如下所示：
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The downside of this approach is the additional conversion time, but with the
    added benefit of a simpler build and fewer files to maintain. This is a good approach
    to take during early development, when you may be iterating on your GUI design
    frequently.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是额外的转换时间，但带来了更简单的构建和更少的文件维护。这是在早期开发阶段采取的一个很好的方法，当时您可能经常在GUI设计上进行迭代。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about Qt's inter-object communication feature,
    signals and slots. You learned how to use them to automate form behavior, to connect
    functionality to user events, and to communicate between different windows in
    an application.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了Qt的对象间通信功能，即信号和插槽。您学会了如何使用它们来自动化表单行为，将功能连接到用户事件，并在应用程序的不同窗口之间进行通信。
- en: In the next chapter, we're going to learn about `QMainWindow`, a class that
    simplifies building common application components. You'll learn how to quickly
    create menus, toolbars, and dialog, as well as how to save settings.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习`QMainWindow`，这是一个简化常见应用程序组件构建的类。您将学会如何快速创建菜单、工具栏和对话框，以及如何保存设置。
- en: Questions
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge of this chapter:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些问题来测试您对本章的了解：
- en: 'Look at the following table and determine which of the connections could actually
    be made, and which would result in an error. You may need to look up the signatures
    of these signals and slots in the documentation:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看下表，并确定哪些连接实际上可以进行，哪些会导致错误。您可能需要在文档中查找这些信号和插槽的签名：
- en: '| # | Signal | Slot |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| # | 信号 | 插槽 |'
- en: '| --- | --- | --- |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | `QPushButton.clicked` | `QLineEdit.clear` |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `QPushButton.clicked` | `QLineEdit.clear` |'
- en: '| 2 | `QComboBox.currentIndexChanged` | `QListWidget.scrollToItem` |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `QComboBox.currentIndexChanged` | `QListWidget.scrollToItem` |'
- en: '| 3 | `QLineEdit.returnPressed` | `QCalendarWidget.setGridVisible` |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `QLineEdit.returnPressed` | `QCalendarWidget.setGridVisible` |'
- en: '| 4 | `QLineEdit.textChanged` | `QTextEdit.scrollToAnchor` |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `QLineEdit.textChanged` | `QTextEdit.scrollToAnchor` |'
- en: The `emit()` method does not exist on a signal object until the signal has been
    bound (that is, connected to a slot). Rewrite the `CategoryWindow.onSubmit()`
    method from our first `calendar_app.py` file to protect against the possibility
    of `submitted` being unbound.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在信号对象上，`emit()`方法在信号被绑定（即连接到插槽）之前是不存在的。重写我们第一个`calendar_app.py`文件中的`CategoryWindow.onSubmit()`方法，以防`submitted`未绑定的可能性。
- en: You find an object in the Qt documentation with a slot that requires a `QString`
    as an argument. Can you connect your custom signal that sends Python's `str`?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在Qt文档中找到一个对象，该对象的插槽需要`QString`作为参数。您能连接发送Python的`str`的自定义信号吗？
- en: You find an object in the Qt documentation with a slot that requires a `QVariant`
    as an argument. What built-in Python types could you send to this slot?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在Qt文档中找到一个对象，该对象的插槽需要`QVariant`作为参数。您可以将哪些内置的Python类型发送到这个插槽？
- en: 'You''re trying to create a dialog window that takes time and emits it when
    the user has finished editing the value. You''re trying to use automatic slot
    connections, but your code isn''t doing anything. Determine what is missing:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您正在尝试创建一个对话框窗口，该窗口需要时间，并在用户完成编辑值时发出。您正在尝试使用自动插槽连接，但您的代码没有做任何事情。确定缺少了什么：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You've created a `.ui` file in Qt Designer for a calculator application, and
    you're trying to get it working in code, but it's not working. What are you doing
    wrong in the following source code?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在Qt Designer中为一个计算器应用程序创建了一个`.ui`文件，现在你试图让它在代码中工作，但是它不起作用。在下面的源代码中你做错了什么？
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You''re trying to create a new button class that emits an integer value when
    clicked; unfortunately, nothing happens when you click the button. Look at the
    following code and try to make it work:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在尝试创建一个新的按钮类，当点击时会发出一个整数值；不幸的是，当你点击按钮时什么也不会发生。看看下面的代码，试着让它工作起来：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Further reading
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Check out these resources for more information:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下资源以获取更多信息：
- en: PyQt's documentation on signal and slot support can be found here at [http://pyqt.sourceforge.net/Docs/PyQt5/signals_slots.html](http://pyqt.sourceforge.net/Docs/PyQt5/signals_slots.html)
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyQt关于信号和槽支持的文档可以在这里找到：[http://pyqt.sourceforge.net/Docs/PyQt5/signals_slots.html](http://pyqt.sourceforge.net/Docs/PyQt5/signals_slots.html)
- en: PyQt's documentation on using Qt Designer can be found here at [http://pyqt.sourceforge.net/Docs/PyQt5/designer.html](http://pyqt.sourceforge.net/Docs/PyQt5/designer.html)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyQt关于使用Qt Designer的文档可以在这里找到：[http://pyqt.sourceforge.net/Docs/PyQt5/designer.html](http://pyqt.sourceforge.net/Docs/PyQt5/designer.html)
