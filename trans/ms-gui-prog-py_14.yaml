- en: Creating Rich Text with QTextDocument
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QTextDocument创建富文本
- en: Whether drafting business memos in a word processor, writing a blog entry, or
    generating reports, much of the world's computing involves the creation of text
    documents. Most of these applications require the ability to produce not just
    plain alphanumeric strings, but rich text as well. Rich text (as opposed to plain
    text) means text that includes styles and formatting features such as font faces,
    colors, lists, tables, and images.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是在文字处理器中起草商业备忘录、写博客文章还是生成报告，世界上大部分的计算都涉及文档的创建。这些应用程序大多需要能够生成不仅仅是普通的字母数字字符串，还需要生成富文本。富文本（与纯文本相对）意味着包括字体、颜色、列表、表格和图像等样式和格式特性的文本。
- en: 'In this chapter, we''re going to learn how PyQt allows us to work with rich
    text by covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习PyQt如何允许我们通过以下主题处理富文本：
- en: Creating rich text using markup
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标记创建富文本
- en: Manipulating rich text using `QTextDocument`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QTextDocument`操纵富文本
- en: Printing rich text
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印富文本
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll need the basic Python and Qt setup you've been using
    since [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting Started
    with PyQt*. You might like to have the example code that can be found at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter11](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter11) as
    a reference.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您将需要自[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml)以来一直在使用的基本Python和Qt设置。您可能希望参考可以在[https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter11](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter11)找到的示例代码。
- en: Check out the following video to see the code in action: [http://bit.ly/2M5P4Cq](http://bit.ly/2M5P4Cq)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际效果：[http://bit.ly/2M5P4Cq](http://bit.ly/2M5P4Cq)
- en: Creating rich text using markup
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标记创建富文本
- en: Every application that supports rich text must have some format to represent
    that text in memory and when saving it to a file. Some formats use custom binary
    code, such as the `.``doc` and `.``rtf` files used by older versions of Microsoft
    Word. In other cases, a plain-text **markup language** is used. In a markup language,
    special strings called **tags** indicate the placement of rich text features.
    Qt takes the markup approach and represents rich text using a subset of **hypertext
    markup language** (**HTML**) version 4.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个支持富文本的应用程序都必须有一些格式来表示内存中的文本，并在将其保存到文件时。有些格式使用自定义二进制代码，例如旧版本Microsoft Word使用的`.doc`和`.rtf`文件。在其他情况下，使用纯文本**标记语言**。在标记语言中，称为**标签**的特殊字符串指示富文本特性的放置。Qt采用标记方法，并使用**超文本标记语言**（**HTML**）第4版的子集表示富文本。
- en: Rich text markup in Qt is rendered by the `QTextDocument` object, and as such
    it is only usable on widgets that use `QTextDocument` to store their contents.
    This includes the `QLabel`, `QTextEdit`, and `QTextBrowser` widgets. In this section,
    we're going to create a demo script to explore the syntax and capabilities of
    this markup language.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Qt中的富文本标记由`QTextDocument`对象呈现，因此它只能用于使用`QTextDocument`存储其内容的小部件。这包括`QLabel`、`QTextEdit`和`QTextBrowser`小部件。在本节中，我们将创建一个演示脚本，以探索这种标记语言的语法和功能。
- en: Given the popularity and ubiquity of web development, it's likely that you already
    know a bit about HTML; in case you don't, the following section will act as a
    quick introduction.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于Web开发的普及和普遍性，您可能已经对HTML有所了解；如果您不了解，下一节将作为一个快速介绍。
- en: HTML basics
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML基础
- en: 'An HTML document is composed of text content interspersed with tags to indicate
    non-plain text features. A tag is simply a word enclosed in angle brackets, as
    follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: HTML文档由文本内容和标签组成，以指示非纯文本特性。标签只是用尖括号括起来的单词，如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice the `</sometag>` code at the end of the preceding example. This is called
    a **closing tag**, and it's simply like the opening tag but with a forward slash
    (`/`) before the tag name. Closing tags are generally only used for tags that
    enclose (or have the ability to enclose) text content.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面示例中的`</sometag>`代码。这被称为**闭合标签**，它与开放标签类似，但标签名称前面有一个斜杠（`/`）。通常只有用于包围（或有能力包围）文本内容的标签才使用闭合标签。
- en: 'Consider the following example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `b`, `em`, and `u` tags require a closing tag because they enclose a portion
    of the content and indicate a change in appearance. The `br` and `hr` tags (*break* and
    *horizontal rule*, respectively) simply indicate non-textual items to include
    in the document, so they have no closing tags.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`b`、`em`和`u`标签需要闭合标签，因为它们包围内容的一部分并指示外观的变化。`br`和`hr`标签（*换行*和*水平线*，分别）只是指示包含在文档中的非文本项，因此它们没有闭合标签。'
- en: If you want to see what any of these examples look like, you can copy them into
    a text file and open them in your web browser. Also, check out the `html_examples.html`
    file in the example code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看看这些示例中的任何一个是什么样子，您可以将它们复制到一个文本文件中，然后在您的Web浏览器中打开它们。还可以查看示例代码中的`html_examples.html`文件。
- en: 'Sometimes, complex structures are created by nesting tags, such as in the following
    list:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，通过嵌套标签创建复杂结构，例如以下列表：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, the `ol` tag starts an ordered list (a list that uses sequential numbers
    or letters, rather than bullet characters). Each item in the list is indicated
    by the `li` (list item) tag. Note that when nesting tags use a closing tag, the
    tags must be closed in the correct order, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ol`标签开始一个有序列表（使用顺序数字或字母的列表，而不是项目符号字符）。列表中的每个项目由`li`（列表项）标签表示。请注意，当嵌套标签使用闭合标签时，标签必须按正确顺序关闭，如下所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding incorrect example would not work because the inner tag (`<i>`)
    was closed after the outer tag (`<b>`).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的错误示例不起作用，因为内部标签（`<i>`）在外部标签（`<b>`）之后关闭。
- en: 'HTML tags can have attributes, which are key-value pairs that are used to configure
    the tag, as shown in the following example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: HTML标签可以有属性，这些属性是用于配置标签的键值对，如下例所示：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding tag is an `img` (image) tag that's used for showing images. Its
    attributes are `src` (indicating the image file path), `width` (indicating the
    width to display the image), and `height` (indicating the height to display).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的标签是一个用于显示图像的`img`（图像）标签。 其属性是`src`（指示图像文件路径），`width`（指示显示图像的宽度）和`height`（指示显示的高度）。
- en: HTML attributes are space-delimited, so don't put commas between them. Values
    can be quoted using single or double-quotes, or left unquoted if they contain
    no spaces or other confusing characters (such as a closing angle bracket); in
    general, however, it's usually best to double-quote them. In Qt HTML, sizes are
    usually specified in `px` (pixels) or `%` (percent), though in modern web HTML,
    other units are commonly used.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: HTML属性是以空格分隔的，所以不要在它们之间放逗号。 值可以用单引号或双引号引用，或者如果它们不包含空格或其他令人困惑的字符（例如闭合尖括号）则不引用；
    但通常最好用双引号引用它们。 在Qt HTML中，大小通常以`px`（像素）或`％`（百分比）指定，尽管在现代Web HTML中，通常使用其他单位。
- en: Style sheet syntax
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式表语法
- en: 'Modern HTML is styled using **Cascading Style Sheets** (**CSS**). You learned
    about CSS in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml), *Styling
    Qt Applications*, when we discussed QSS. To review, CSS allows you to make declarations
    about the way a tag will look, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现代HTML使用**层叠样式表**（**CSS**）进行样式设置。 在[第6章](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml)中，*为Qt应用程序设置样式*，我们讨论了QSS时学习了CSS。
    回顾一下，CSS允许您对标签的外观进行声明，如下所示：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding CSS directive will make all the content inside bold tags (between
    `<b>` and `</b>`) appear in a red 16 point font.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的CSS指令将使粗体标签内的所有内容（在`<b>`和`</b>`之间）以红色16点字体显示。
- en: 'Certain tags can also have modifiers, for example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 某些标签也可以有修饰符，例如：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding CSS applies to `<a>` (anchor) tag contents, but *only* when the
    anchor is hovered over by the mouse pointer. Modifiers like this are also called
    **pseudo-classes**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的CSS适用于`<a>`（锚点）标签内容，但仅当鼠标指针悬停在锚点上时。 这样的修饰符也称为**伪类**。
- en: Semantic versus cosmetic tags
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语义标签与装饰标签
- en: Some HTML tags describe how a piece of content should appear. We call these
    **cosmetic** tags. For example, the `<i>` tag indicates that text should be printed
    in an italic font. Consider, though, that italics are used in modern printing
    for many reasons—to emphasize a word, to indicate a title of a published work,
    or to indicate that a phrase is from a foreign language. To differentiate between
    these uses, HTML also has *semantic* tags. For example, `<em>` means emphasis,
    and will result in italic text in most situations. But unlike the `<i>` tag, it
    also indicates *why* the text should be italic. Older versions of HTML generally
    focused on cosmetic tags, whereas newer versions focus increasingly on semantic
    tags.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一些HTML标签描述了内容应该如何显示。 我们称这些为**装饰**标签。 例如，`<i>`标签表示文本应以斜体字打印。 但请注意，斜体字在现代印刷中有许多用途-强调一个词，表示已出版作品的标题，或表示短语来自外语。
    为了区分这些用途，HTML还有*语义*标签。 例如，`<em>`表示强调，并且在大多数情况下会导致斜体文本。 但与`<i>`标签不同，它还指示文本应该以何种方式斜体。
    HTML的旧版本通常侧重于装饰标签，而较新版本则越来越注重语义标签。
- en: Qt's rich-text HTML supports a few semantic tags, but they are merely aliases
    for equivalent cosmetic tags.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Qt的富文本HTML支持一些语义标签，但它们只是等效的装饰标签。
- en: There is much more to the modern HTML and CSS that's used on web pages than
    we've described here, but what we've covered is sufficient for understanding the
    limited subset used by Qt widgets. If you want to learn more, take a look at the
    resources under the, *Further reading* section at the end of this chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现代HTML和CSS在网页上使用的内容远不止我们在这里描述的，但我们所涵盖的内容足以理解Qt小部件使用的有限子集。 如果您想了解更多，请查看本章末尾的*进一步阅读*部分中的资源。
- en: Structure and heading tags
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构和标题标签
- en: To experiment with rich text markup, we're going to write an advertisement for
    our next big game, *Fight Fighter 2*, and view it in a QTextBrowser. To begin,
    get a copy of the application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow,* and call it `qt_richtext_demo.py`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试丰富的文本标记，我们将为我们的下一个大型游戏*Fight Fighter 2*编写广告，并在QTextBrowser中查看它。 首先，从[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)中获取应用程序模板，*使用QMainWindow构建应用程序*，并将其命名为`qt_richtext_demo.py`。
- en: 'In `MainWindow.__init__()`, add in a `QTextBrowser` object as the main widget,
    like so:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainWindow.__init__（）`中，像这样添加一个`QTextBrowser`对象作为主窗口小部件：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`QTextBrowser` is based on `QTextEdit`, but is read-only and preconfigured
    to navigate hypertext links. After creating the text browser, we open the `fight_fighter2.html`
    file and insert its contents into the browser using the `insertHtml()` method.
    Now, we can edit `fight_fighter2.html` and see how it is rendered in PyQt.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTextBrowser`基于`QTextEdit`，但是只读并预先配置为导航超文本链接。 创建文本浏览器后，我们打开`fight_fighter2.html`文件，并使用`insertHtml（）`方法将其内容插入浏览器。
    现在，我们可以编辑`fight_fighter2.html`并查看它在PyQt中的呈现方式。'
- en: 'Open `fight_fighter2.html` in your editor and begin with the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中打开`fight_fighter2.html`并从以下代码开始：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: HTML documents are built hierarchically, with the outermost tag usually being
    `<html>`. However, we can also use `<qt>` as the outermost tag when passing HTML
    to a `QTextDocument`-based widget, which is a good idea as it reminds us that
    we're writing the Qt-supported subset of HTML, not actual HTML.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: HTML文档是按层次结构构建的，最外层的标签通常是`<html>`。 但是，当将HTML传递给基于`QTextDocument`的小部件时，我们还可以使用`<qt>`作为最外层的标签，这是一个好主意，因为它提醒我们正在编写Qt支持的HTML子集，而不是实际的HTML。
- en: Inside that, we have a `<body>` tag. This tag is also optional, but it will
    make styling easier down the road.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们有一个`<body>`标签。 这个标签也是可选的，但它将使未来的样式更容易。
- en: Next, we've got a title inside an `<h1>` tag. The *H* here stands for heading,
    and tags `<h1>` through `<h6>` indicate section headings from the outermost to
    the innermost. This tag will be rendered in a larger and bolder font, indicating
    that it is the title of the section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`<h1>`标签内有一个标题。这里的*H*代表标题，标签`<h1>`到`<h6>`表示从最外层到最内层的部分标题。这个标签将以更大更粗的字体呈现，表明它是部分的标题。
- en: Following the heading, we have an `<hr>` tag to add a horizontal line. By default,
    `<hr>` produces a single-pixel-thick black line, but that can be customized using
    style sheets.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在标题之后，我们有一个`<hr>`标签来添加水平线。默认情况下，`<hr>`会产生一个单像素厚的黑线，但可以使用样式表进行自定义。
- en: 'Let''s add the following regular text content:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加以下常规文本内容：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `<p>` tag, or paragraph tag, indicates a block of text. It is not strictly
    necessary to enclose text content in paragraph tags, but understand that HTML
    does not respect new lines by default. If you want to get distinct paragraphs
    separated by line breaks, you need to enclose them in paragraph tags. (You can
    also insert `<br>` tags, but the paragraph tag is considered a cleaner approach
    as it is more semantic.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`<p>`标签，或段落标签，表示一块文本。在段落标签中不严格需要包含文本内容，但要理解HTML默认不会保留换行。如果你想要通过换行来分隔不同的段落，你需要将它们放在段落标签中。（你也可以插入`<br>`标签，但是段落标签被认为是更语义化的更干净的方法。）'
- en: 'Next, add the first child heading, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加第一个子标题，如下所示：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Any child section under `<h1>` should be `<h2>`; any child section inside `<h2>`
    should be `<h3>`, and so on. Heading tags are examples of semantic tags, and indicate
    the level of the document hierarchy.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<h1>`下的任何子部分应该是`<h2>`；在`<h2>`内的任何子部分应该是`<h3>`，依此类推。标题标签是语义标签的例子，表示文档层次结构的级别。
- en: Never select heading levels based on the appearance they produce—for example,
    don't use `<h4>` under `<h1>` just because you want smaller header text. Use them
    semantically and adjust the look using styles (see the *Fonts, colors, images,
    and styles*, sectionfor more information).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要根据它们产生的外观来选择标题级别——例如，不要在`<h1>`下使用`<h4>`，只是因为你想要更小的标题文本。使用它们语义化，并使用样式来调整外观（参见*字体、颜色、图片和样式*部分了解更多信息）。
- en: Typography tags
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排版标签
- en: 'Qt rich text supports many tags for altering the basic appearance of the text,
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Qt富文本支持许多标签来改变文本的基本外观，如下所示：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this example, we''ve used the following tags:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了以下标签：
- en: '| Tag | Result |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 标签 | 结果 |'
- en: '| --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<i>` | *Italic* |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `<i>` | *斜体* |'
- en: '| `<b>` | **Bold** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `<b>` | **粗体** |'
- en: '| `<u>` | Underlined |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `<u>` | 下划线 |'
- en: '| `<s>` | Strikethrough |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `<s>` | 删除线 |'
- en: 'These are cosmetic tags, and each of them alters the appearance of the text
    inside the tag as indicated. In addition to these tags, some lesser-used tags
    for the sizing and position of text are supported, including the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是装饰性标签，它们每个都会改变标签内文本的外观。除了这些标签，还支持一些用于文本大小和位置的较少使用的标签，包括以下内容：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, we can see the `<sup>` and `<sub>` tags, which provide
    superscript and subscript text, respectively, and the `<big>` and `<small>` tags,
    which provide slightly bigger or smaller fonts.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到`<sup>`和`<sub>`标签，分别提供上标和下标文本，以及`<big>`和`<small>`标签，分别提供稍微更大或更小的字体。
- en: Hyperlinks
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超链接
- en: 'Hyperlinks can also be added to Qt rich text using the `<a>` (anchor) tag,
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 超链接也可以使用`<a>`（锚点）标签添加到Qt富文本中，如下所示：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The exact behavior of hyperlinks varies according to the widget displaying the
    hyperlink and the settings of the widget.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 超链接的确切行为取决于显示超链接的部件和部件的设置。
- en: The QTextBrowser by default will attempt to navigate to a hyperlink within the
    widget; keep in mind, however, that these links will only work if they are resource
    URLs or local file paths. `QTextBrowser` lacks a network stack and cannot be used
    to browse the internet.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTextBrowser`默认会尝试在部件内导航到超链接；但请记住，这些链接只有在它们是资源URL或本地文件路径时才会起作用。`QTextBrowser`缺乏网络堆栈，不能用于浏览互联网。'
- en: 'It can, however, be configured to open URLs in an external browser; back in
    the Python script, add the following line of code to `MainWindow.__init__()`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它可以配置为在外部浏览器中打开URL；在Python脚本中，添加以下代码到`MainWindow.__init__()`：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This utilizes `QDesktopServices.openUrl()` to open the anchor's `href` value
    in the desktop's default browser. You should configure this setting whenever you
    want to support external hyperlinks in a document.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这利用`QDesktopServices.openUrl()`来在桌面的默认浏览器中打开锚点的`href`值。每当你想要在文档中支持外部超链接时，你应该配置这个设置。
- en: External hyperlinks can also be configured on `QLabel` widgets, but not within
    a `QTextEdit` widget.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 外部超链接也可以在`QLabel`部件上进行配置，但不能在`QTextEdit`部件内进行配置。
- en: 'Documents can also use hyperlinks for navigating within a document itself,
    as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 文档也可以使用超链接来在文档内部导航，如下所示：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we've added an anchor pointing to `#Features` (with a pound sign), followed
    by a number of breaks to simulate more content. When a user clicks the link, it
    will scroll the browser widget to the anchor tag with a `name` (not `href`) attribute
    of `Features` (without the pound sign).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个指向`#Features`（带有井号）的锚点，然后是一些换行来模拟更多的内容。当用户点击链接时，它将滚动浏览器部件到具有`name`属性（而不是`href`）为`Features`的锚点标签（不带井号）。
- en: This feature can be useful for doing things such as providing a navigable table
    of contents.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能对于提供可导航的目录表格非常有用。
- en: Lists and tables
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表和表格
- en: Lists and tables are very useful for presenting orderly information in a way
    that users can quickly parse.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和表格非常有用，可以以用户能够快速解析的方式呈现有序信息。
- en: 'An example of a list is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的一个例子如下：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Lists in Qt rich text can be of the ordered or unordered variety. In the preceding
    example, we have an unordered list (`<ul>`). The optional `type` attribute allows
    you to specify what kind of bullets should be used. In this case, we've chosen
    `square`; other options for unordered lists include `circle` and `disc`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Qt富文本中的列表可以是有序或无序的。在上面的例子中，我们有一个无序列表（`<ul>`）。可选的`type`属性允许您指定应使用什么样的项目符号。在这种情况下，我们选择了`square`；无序列表的其他选项包括`circle`和`disc`。
- en: Each item in a list is specified using the `<li>` (list item) tag. We can also
    nest a list inside a list item to make a sublist. In this case, we've added an
    ordered list, which will use sequential numbers to indicate new items. Ordered
    lists also accept the `type` attribute; valid values are `a` (lower case letters),
    `A` (upper case letters), or `1` (sequential numbers).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`<li>`（列表项）标签指定列表中的每个项目。我们还可以在列表项内部嵌套一个列表，以创建一个子列表。在这种情况下，我们添加了一个有序列表，它将使用顺序号来指示新项目。有序列表还接受`type`属性；有效值为`a`（小写字母）、`A`（大写字母）或`1`（顺序号）。
- en: '`&gt;` in the last bullet item is an example of an HTML entity. These are special
    codes that are used to display HTML special characters such as angle brackets,
    or non-ASCII characters, such as the copyright symbol. Entities start with an
    ampersand and end with a colon and contain a string indicating the character to
    display. The `gt`, in this case, stands for *greater than*. An official list of
    entities can be found at [https://dev.w3.org/html5/html-author/charref](https://dev.w3.org/html5/html-author/charref),
    though not all may be supported by `QTextDocument`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个项目中的`&gt;`是HTML实体的一个例子。这些是特殊代码，用于显示HTML特殊字符，如尖括号，或非ASCII字符，如版权符号。实体以一个和号开始，以一个冒号结束，并包含一个指示要显示的字符的字符串。在这种情况下，`gt`代表*greater
    than*。可以在[https://dev.w3.org/html5/html-author/charref](https://dev.w3.org/html5/html-author/charref)找到官方实体列表，尽管并非所有实体都受`QTextDocument`支持。
- en: 'Creating HTML tables is somewhat more involved, as it requires many levels
    of nesting. The hierarchy for table tags is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 创建HTML表格稍微复杂，因为它需要多层嵌套。表标签的层次结构如下：
- en: The table itself is defined by a `<table>` tag
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表格本身由`<table>`标签定义
- en: The heading portion of the table is defined by the `<thead>` tag
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表的标题部分由`<thead>`标签定义
- en: Each row of the table (header or data) is defined by a `<tr>` (table row) tag
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表的每一行（标题或数据）由`<tr>`（表行）标签定义
- en: Within each row, table cells are defined by either a `<th>` (table heading)
    tag or a `<td>` (table data) tag
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每一行中，表格单元格由`<th>`（表头）标签或`<td>`（表数据）标签定义
- en: 'Let''s start a table with the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用以下代码开始一个表格：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding example, we've started with the opening `<table>` tag. The
    `border` attribute specifies a width for the table border in pixels; in this case,
    we want a two-pixel border. Keep in mind that this border goes around each cell
    and does not collapse (that is, merge with an adjacent cell's border), so in actuality,
    we'll have a four-pixel border between each cell. Table borders can have different
    styles; by default, the *ridge* style is used, so this border will be shaded to
    look slightly three-dimensional.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们从开头的`<table>`标签开始。`border`属性指定了表格边框的宽度（以像素为单位）；在这种情况下，我们希望有一个两像素的边框。请记住，这个边框围绕每个单元格，不会合并（也就是说，不会与相邻单元格的边框合并），因此实际上，每个单元格之间将有一个四像素的边框。表格边框可以有不同的样式；默认情况下使用*ridge*样式，因此这个边框将被着色，看起来略微立体。
- en: Inside the `<thead>` section, there is a table row filled with table heading
    cells. By setting the `bgcolor` attribute of the row, we can change the background
    color of all the header cells to grey.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<thead>`部分，有一行表格，填满了表头单元格。通过设置行的`bgcolor`属性，我们可以将所有表头单元格的背景颜色更改为灰色。
- en: 'Now, let''s add some data rows with the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用以下代码添加一些数据行：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, the rows contain `<td>` cells for the actual table
    data. Note that we can use the `rowspan` and `colspan` attributes on individual
    cells to make them take up additional rows and columns, and the `bgcolor` attribute
    can also be applied to individual cells.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，行包含了用于实际表格数据的`<td>`单元格。请注意，我们可以在单个单元格上使用`rowspan`和`colspan`属性，使它们占用额外的行和列，并且`bgcolor`属性也可以应用于单个单元格。
- en: It's possible to wrap the data rows in a `<tbody>` tag to differentiate it from
    the `<thead>` section, but this doesn't actually have any useful impact in Qt
    rich text HTML.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将数据行包装在`<tbody>`标签中，以使其与`<thead>`部分区分开，但这实际上在Qt富文本HTML中没有任何有用的影响。
- en: Fonts, colors, images, and styles
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字体、颜色、图像和样式
- en: 'Rich text fonts can be set using the `<font>` tag, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`<font>`标签设置富文本字体，如下所示：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`<font>` may be unfamiliar to those who have learned more modern HTML, as it
    was deprecated in HTML 5\. As you can see, though, it can be used to set the `face`,
    `size`, and `color` attributes of the text enclosed in the tags.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`<font>`对于那些学习了更现代HTML的人可能会感到陌生，因为它在HTML 5中已被弃用。但正如您所看到的，它可以用来设置标签中的文本的`face`、`size`和`color`属性。'
- en: The `<tt>` (typewriter type) tag is shorthand for using mono-spaced fonts and
    is useful for presenting things like inline code, keyboard shortcuts, and terminal
    output.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`<tt>`（打字机类型）标签是使用等宽字体的简写，对于呈现内联代码、键盘快捷键和终端输出非常有用。'
- en: 'If you prefer to use more modern CSS-style font configuration, this can be
    done by setting the `style` attribute on a block-level tag like `<div>`, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用更现代的CSS样式字体配置，可以通过在块级标签（如`<div>`）上设置`style`属性来实现：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Within the `style` attribute, you can set any of the supported CSS values to
    be applied to that block.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`style`属性中，您可以设置任何支持的CSS值，以应用于该块。
- en: Document-wide styles
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档范围的样式
- en: Qt rich text documents do *not* support HTML `<style>` tags or `<link>` tags
    for setting a document-wide style sheet. Instead, you can use the `setDefaultStyleSheet()`
    method of the `QTextDocument` object to set a CSS style sheet that will be applied
    to all viewed documents.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Qt富文本文档*不*支持HTML `<style>`标签或`<link>`标签来设置文档范围的样式表。相反，您可以使用`QTextDocument`对象的`setDefaultStyleSheet()`方法来设置一个CSS样式表，该样式表将应用于所有查看的文档。
- en: 'Back in `MainWindow.__init__()`, add the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`MainWindow.__init__()`，添加以下内容：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note, however, that this must be added *before* the HTML is inserted into the
    widget. The `defaultStyleSheet` method is only applied to newly inserted HTML.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，这必须在HTML插入小部件之前添加。`defaultStyleSheet`方法仅适用于新插入的HTML。
- en: Also note that certain aspects of the appearance are not properties of the document,
    but of the widget. Notably, the background color of the document cannot be set
    by altering the body's styles.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，外观的某些方面不是文档的属性，而是小部件的属性。特别是，文档的背景颜色不能通过修改`body`的样式来设置。
- en: 'Instead, set the widget''s style sheet, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，设置小部件的样式表，如下所示：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Keep in mind that the widget's style sheet uses QSS, whereas the document's
    style sheet uses CSS. The difference is minimal, but could come into play in certain
    situations.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，小部件的样式表使用QSS，而文档的样式表使用CSS。区别是微小的，但在某些情况下可能会起作用。
- en: Images
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图片
- en: 'An image can be inserted using the `<img>` tag, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`<img>`标签插入图像，如下所示：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `src` attribute should be a file or resource path to an image file supported
    by Qt (see [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml), *Styling Qt
    Applications*, for more information about image format support). The `width` and
    `height` attributes can be used to force a certain size.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`src`属性应该是Qt支持的图像文件的文件或资源路径（有关图像格式支持的更多信息，请参见[第6章](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml)，*Qt应用程序的样式*）。`width`和`height`属性可用于强制指定特定大小。'
- en: Differences between Qt rich text and Web HTML
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Qt富文本和Web HTML之间的区别
- en: If you have any experience in web design or development, you have no doubt already
    noted several differences between Qt's rich text markup and the HTML used in modern
    web browsers. It's important to keep these in mind as you create rich text, so
    let's go over the main differences.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有网页设计或开发经验，您无疑已经注意到Qt的富文本标记与现代网页浏览器中使用的HTML之间的几个区别。在创建富文本时，重要的是要记住这些区别，所以让我们来看一下主要的区别。
- en: First, Qt rich text is based on HTML 4 and CSS 2.1; as you have seen, it includes
    some deprecated tags, such as `<font>`, and excludes many of the more modern tags,
    such as `<section>` or `<figure>`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Qt富文本基于HTML 4和CSS 2.1；正如您所见，它包括一些已弃用的标签，如`<font>`，并排除了许多更现代的标签，如`<section>`或`<figure>`。
- en: Furthermore, Qt rich text is based on only a subset of those specifications,
    so it lacks support for many tags. For example, there are no input- or form-related
    tags, such as `<select>` or `<textarea>`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Qt富文本基于这些规范的一个子集，因此它不支持许多标签。例如，没有输入或表单相关的标签，如`<select>`或`<textarea>`。
- en: '`QTextDocument` is also less forgiving than most web browser renderers when
    it comes to syntax errors and case. For example, when setting a default style
    sheet, the case of the tag name needs to match the case used in the document,
    or the style won''t apply. In addition, failing to use block-level tags (such
    as `<p>`, `<div>`, and so on) around content can lead to unpredictable results.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTextDocument`在语法错误和大小写方面也比大多数网页浏览器渲染器更严格。例如，当设置默认样式表时，标签名称的大小写需要与文档中使用的大小写匹配，否则样式将不会应用。此外，未使用块级标签（如`<p>`、`<div>`等）包围内容可能会导致不可预测的结果。'
- en: In short, it's best not to think of Qt rich text markup as true HTML, but rather
    as a similar but separate markup language. If you have any questions about whether
    a particular tag or style directive is supported, consult the support reference
    at [https://doc.qt.io/qt-5/richtext-html-subset.html](https://doc.qt.io/qt-5/richtext-html-subset.html).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，最好不要将Qt富文本标记视为真正的HTML，而是将其视为一种类似但独立的标记语言。如果您对特定标记或样式指令是否受支持有任何疑问，请参阅[https://doc.qt.io/qt-5/richtext-html-subset.html](https://doc.qt.io/qt-5/richtext-html-subset.html)上的支持参考。
- en: Manipulating rich text using QTextDocument
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QTextDocument操作富文本
- en: In addition to allowing us to specify rich text in markup, Qt provides us with
    an API to create and manipulate rich text programmatically. This API is called
    the **Qt Scribe Framework**, and it's built around the `QTextDocument` and `QTextCursor`
    classes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许我们在标记中指定富文本外，Qt还为我们提供了一个API来编程创建和操作富文本。这个API称为**Qt Scribe Framework**，它是围绕`QTextDocument`和`QTextCursor`类构建的。
- en: To demonstrate how to create a document using the `QTextDocument` and `QTextCursor`
    classes, we're going to build a simple invoice generator application. Our application
    will take data from a widget form and use it to generate a rich text document
    programmatically.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 演示如何使用`QTextDocument`和`QTextCursor`类创建文档，我们将构建一个简单的发票生成器应用程序。我们的应用程序将从小部件表单中获取数据，并使用它来编程生成富文本文档。
- en: Creating the invoice application GUI
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建发票应用程序GUI
- en: Get a fresh copy of our PyQt application template and call it `invoice_maker.py`.
    We'll begin our application by creating the GUI elements, and then develop the
    method that will actually build the document.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 获取我们的PyQt应用程序模板的最新副本，并将其命名为`invoice_maker.py`。我们将通过创建GUI元素开始我们的应用程序，然后开发实际构建文档的方法。
- en: 'Start your script with a data entry form class, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个数据输入表单类开始您的脚本，如下所示：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Like with most of the forms we've created, this class is based on `QWidget`
    and starts by defining a `submitted` signal to carry a dictionary of the form's
    values. Here, we have also added various inputs to `QFormLayout` to enter basic
    invoice data such as customer name, customer address, and invoice date.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们创建的大多数表单一样，这个类基于`QWidget`，并通过定义一个`submitted`信号来携带表单值的字典来开始。在这里，我们还向`QFormLayout`添加了各种输入，以输入基本的发票数据，如客户名称、客户地址和发票日期。
- en: 'Next, we''ll add `QTableWidget` for entering the invoice''s line items, as
    follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加`QTableWidget`以输入发票的行项目，如下所示：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Each row of this table widget contains a description of the task, the rate for
    the work, and the number of hours worked. Because the values in the last two columns
    are numbers, we're using the table widget's `setCellWidget()` method to replace
    the default `QLineEdit` widgets in those cells with `QSpinBox` widgets.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 该表格小部件的每一行都包含任务的描述、工作的费率和工作的小时数。因为最后两列中的值是数字，所以我们使用表格小部件的`setCellWidget()`方法来用`QSpinBox`小部件替换这些单元格中的默认`QLineEdit`小部件。
- en: 'Finally, we''ll add a `submit` button with the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用以下代码添加一个`submit`按钮：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `submit` button calls an `on_submit()` method, which starts as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`submit`按钮调用一个`on_submit()`方法，开始如下：'
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This method is simply going to extract the values that are entered into the
    form, make a few calculations, and emit the resulting data `dict` with the `submitted`
    signal. Here, we started by grabbing the values from each of the form's input
    widgets into a Python dictionary using the appropriate method for each widget.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法只是简单地提取输入表单中输入的值，进行一些计算，并使用`submitted`信号发射生成的数据`dict`。在这里，我们首先通过使用每个小部件的适当方法将表单的每个输入小部件的值放入Python字典中。
- en: 'Next, we need to retrieve the line items'' data, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要检索行项目的数据，如下所示：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For each row in the table widget that has a description, we're going to retrieve
    all the data, calculate a total cost by multiplying the rate and hours, and append
    all the data to the list in our `data` dictionary.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表格小部件中具有描述的每一行，我们将检索所有数据，通过将费率和工时相乘来计算总成本，并将所有数据附加到我们的`data`字典中的列表中。
- en: 'Finally, we''ll calculate a grand total cost and append that with the following
    code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将计算一个总成本，并使用以下代码将其附加到：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After summing the cost in each line, we will add it to the data dictionary and
    emit our `submitted` signal with the data.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一行的成本总和之后，我们将其添加到数据字典中，并使用数据发射我们的`submitted`信号。
- en: 'This takes care of our `form` class, so let''s set up the main application
    layout in `MainWindow`. Down in `MainWindow.__init__()`, add the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的`form`类，所以让我们在`MainWindow`中设置主应用程序布局。在`MainWindow.__init__()`中，添加以下代码：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The main widget is given a horizontal layout to contain the form and the view
    widget for the formatted invoice. We then connect the form's `submitted` signal
    to a `build_invoice()` method, which we will create on the view object.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 主小部件被赋予一个水平布局，以包含格式化发票的表单和视图小部件。然后，我们将表单的`submitted`信号连接到视图对象上将创建的`build_invoice()`方法。
- en: This is the main GUI and logic for the application; now all that's left to do
    is create our `InvoiceView` class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序的主要GUI和逻辑；现在我们只需要创建我们的`InvoiceView`类。
- en: Building InvoiceView
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建InvoiceView
- en: The `InvoiceView` class is where all the hard work takes place; we will base
    it on a read-only `QTextEdit` widget, and it will contain a `build_invoice()`
    method that, when called with a dictionary of data, will construct a formatted
    invoice document using the Qt Scribe framework.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvoiceView`类是所有繁重工作发生的地方；我们将其基于只读的`QTextEdit`小部件，并且它将包含一个`build_invoice()`方法，当使用数据字典调用时，将使用Qt
    Scribe框架构建格式化的发票文档。'
- en: 'Let''s start with the constructor, as shown in the following example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构造函数开始，如下例所示：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To begin, we've defined class variables for the document's width and height.
    We've chosen these values to give us the aspect ratio of a standard US letter-sized
    document at a reasonable size for the average computer monitor. Inside the constructor,
    we use the calculated value to set a fixed size for the widget. This is all we
    need to do in the constructor, so it's now time to get to the real work—building
    a document.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为文档的宽度和高度定义了类变量。我们选择这些值是为了给我们一个标准的美国信件大小文档的纵横比，适合于普通计算机显示器的合理尺寸。在构造函数中，我们使用计算出的值来设置小部件的固定大小。这是我们在构造函数中需要做的所有事情，所以现在是时候开始真正的工作了——构建一个文档。
- en: 'Let''s begin with `build_invoice()`, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`build_invoice()`开始，如下所示：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see in the preceding example, the method starts by creating a fresh
    `QTextDocument` object and assigning it to the view's `document` property. Then,
    the `pageSize` property is set using the document dimensions calculated in the
    class definition. Note that our QTextEdit-based view already has a `document`
    object that we could retrieve, but we're creating a fresh object so that the method
    will start with an empty document each time it is called.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的示例中所看到的，该方法首先创建一个新的`QTextDocument`对象，并将其分配给视图的`document`属性。然后，使用在类定义中计算的文档尺寸设置`pageSize`属性。请注意，我们基于QTextEdit的视图已经有一个我们可以检索的`document`对象，但我们正在创建一个新的对象，以便该方法每次调用时都会以空文档开始。
- en: Editing documents with `QTextDocument` may feel a bit backward from the way
    we have been creating GUI forms, where we typically create objects, and then configure
    and place them on the layout.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`QTextDocument`编辑文档可能会感觉有点不同于我们创建GUI表单的方式，通常我们会创建对象，然后配置并将它们放置在布局中。
- en: 'Instead, the `QTextDocument` workflow is more like a word processor:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`QTextDocument`的工作流更像是一个文字处理器：
- en: There is a `cursor` that always points to some location in the document
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个`cursor`始终指向文档中的某个位置
- en: There is an active text style, paragraph style, or another block-level style
    whose settings will be applied to whatever is entered
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个活动文本样式、段落样式或另一个块级样式，其设置将应用于输入的任何内容
- en: To add content, users start by positioning the cursor, configuring the styles,
    and finally creating the content
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要添加内容，用户首先要定位光标，配置样式，最后创建内容
- en: 'So, clearly, the first step is to get a reference to the cursor; do this with
    the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，显然，第一步是获取光标的引用；使用以下代码来实现：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `QTextCursor` object is the tool that we use to insert content, and it has
    many methods for inserting different types of elements into the document.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTextCursor`对象是我们用来插入内容的工具，并且它有许多方法可以将不同类型的元素插入文档中。'
- en: 'For example, at this point, we could just start inserting text content, as
    follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这一点上，我们可以开始插入文本内容，如下所示：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: However, before we start writing content to our document, we should build a
    basic document framework to work within. To do this, we need to understand how
    `QTextDocument` objects are structured.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们开始向文档中写入内容之前，我们应该构建一个基本的文档框架来进行工作。为了做到这一点，我们需要了解`QTextDocument`对象的结构。
- en: The QTextDocument structure
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QTextDocument结构
- en: 'Just like an HTML document, a `QTextDocument` object is a hierarchical structure.
    It is made up of **frames**, **blocks**, and **fragments**, which are defined
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 就像HTML文档一样，`QTextDocument`对象是一个分层结构。它由**框架**、**块**和**片段**组成，定义如下：
- en: A frame is represented by the `QTextFrame` object, and is a rectangular region
    of a document that can contain any type of content, including other frames. At
    the top of our hierarchy is the **root frame**, which contains all the document's
    contents.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架由`QTextFrame`对象表示，是文档的矩形区域，可以包含任何类型的内容，包括其他框架。在我们的层次结构顶部是**根框架**，它包含了文档的所有内容。
- en: A block, represented by the `QTextBlock` object, is a region of text surrounded
    by line breaks, such as a paragraph or a list item.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个块，由`QTextBlock`对象表示，是由换行符包围的文本区域，例如段落或列表项。
- en: 'A fragment, represented by the `QTextFragment` object, is a contiguous region
    of text inside a block that shares a common text formatting. For example, if you
    have a sentence containing a word in bold, that represents three text fragments:
    the sentence before the bold word, the bold word, and the sentence after the bold
    word.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 片段，由`QTextFragment`对象表示，是块内的连续文本区域，共享相同的文本格式。例如，如果您有一个句子中包含一个粗体字，那么代表三个文本片段：粗体字之前的句子，粗体字，和粗体字之后的句子。
- en: Other items, such as tables, lists, and images, are subclassed from one of these
    preceding classes.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他项目，如表格、列表和图像，都是从这些前面的类中派生出来的。
- en: 'We''re going to organize our document by inserting a set of sub-frames under
    the root frame so that we can easily navigate to the section of the document we
    want to work on. Our document will have the following four frames:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在根框架下插入一组子框架来组织我们的文档，以便我们可以轻松地导航到我们想要处理的文档部分。我们的文档将有以下四个框架：
- en: The **logo frame** will contain the company logo and contact information
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标志框架**将包含公司标志和联系信息'
- en: The **customer address frame** will hold the customer name and address
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户地址框架**将保存客户姓名和地址'
- en: The **terms frame** will hold a list of the invoice terms and conditions
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条款框架**将保存发票条款和条件的列表'
- en: The **line items frame** will hold a table of the line-items and totals
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行项目框架**将保存行项目和总计的表格'
- en: 'Let''s create some text frames to outline the structure of our document. We''ll
    start by saving a reference to the root frame so that we can easily return to
    it after creating a sub-frame, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一些文本框架来概述我们文档的结构。我们将首先保存对根框架的引用，以便在创建子框架后可以轻松返回到它，如下所示：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that we have that, we can retrieve a cursor position for the end of the
    root frame at any point by calling the following command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有了这个，我们可以通过调用以下命令在任何时候为根框架的末尾检索光标位置：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The cursor's `setPosition()` method places our cursor at any given position,
    and the root frame's `lastPosition()` method retrieves the position at the end
    of the root frame.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 光标的`setPosition()`方法将我们的光标放在任何给定位置，根框架的`lastPosition()`方法检索根框架末尾的位置。
- en: 'Now, let''s define the first sub-frame, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义第一个子框架，如下所示：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A frame must be created with a `QTextFrameFormat` object defining its format,
    so before we can write the frame, we have to define our formatting. Unfortunately,
    the frame format's properties cannot be set using keyword arguments, so we must
    configure it using setter methods instead. In this example, we've set a two-pixel
    border around the frame, as well as ten pixels of padding.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 框架必须使用定义其格式的`QTextFrameFormat`对象创建，因此在我们写框架之前，我们必须定义我们的格式。不幸的是，框架格式的属性不能使用关键字参数设置，因此我们必须使用setter方法进行配置。在这个例子中，我们设置了框架周围的两像素边框，以及十像素的填充。
- en: Once the format object is created, we call the cursor's `insertFrame()` method
    to create a new frame with our configured format.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦格式对象被创建，我们调用光标的`insertFrame()`方法来使用我们配置的格式创建一个新框架。
- en: '`insertFrame()` returns the `QTextFrame` object created, and also positions
    our document''s cursor inside the new frame. Since we aren''t ready to add content
    to this frame, and we don''t want to create the next frame inside of it, we need
    to return to the root frame before creating the next frame by using the following
    code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertFrame()`返回创建的`QTextFrame`对象，并且将我们文档的光标定位在新框架内。由于我们还没有准备好向这个框架添加内容，并且我们不想在其中创建下一个框架，所以我们需要使用以下代码返回到根框架之前创建下一个框架：'
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding example, we're using the frame format to set the width of this
    frame to one-third of the width of the document and to make it float to the right.
    *Floating* a document frame means that it will be pushed to one side of the document
    and other content will flow around it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们使用框架格式来将此框架的宽度设置为文档宽度的三分之一，并使其浮动到右侧。*浮动*文档框架意味着它将被推到文档的一侧，其他内容将围绕它流动。
- en: 'Now, we''ll add the terms frame, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加术语框架，如下所示：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This time, we're going to make the frame half of the document's width and float
    it to the left.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将使框架的宽度为文档宽度的一半，并将其浮动到左侧。
- en: In theory, these two frames should be next to each other. In practice, due to
    a quirk in the `QTextDocument` class' rendering, the top of the second frame will
    be a line below the top of the first one. This is OK for our demo, but if you
    need actual columns, use a table instead.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，这两个框架应该相邻。实际上，由于`QTextDocument`类渲染中的一个怪癖，第二个框架的顶部将在第一个框架的顶部下面一行。这对我们的演示来说没问题，但如果您需要实际的列，请改用表格。
- en: 'Finally, let''s add the frame to hold our line items table, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加一个框架来保存我们的行项目表格，如下所示：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Once again, we've moved the cursor back to the root frame and inserted a new
    frame. This time, the format adds a margin of 25 pixels to the frame.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将光标移回到根框架并插入一个新框架。这次，格式将在框架上添加25像素的边距。
- en: Note that we don't have to do any special configuration of the `QTextFrameFormat`
    objects if we don't want to, but we *do* have to create one for each frame, and
    we *do* need to set up any configuration on them *before* creating the new frame.
    Note that it's also possible to reuse frame formats if you have many frames with
    the same configuration.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们不想对`QTextFrameFormat`对象进行任何特殊配置，我们就不必这样做，但是*必须*为每个框架创建一个对象，并且*必须*在创建新框架之前对它们进行任何配置。请注意，如果您有许多具有相同配置的框架，也可以重用框架格式。
- en: Character formats
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符格式
- en: Just like frames must be created with a frame format, text content must be created
    with a **character format**, which defines properties such as the font and alignment
    of the text. Before we start adding content to our frames, we should define some
    common character formats to use for different parts of the document.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 就像框架必须使用框架格式创建一样，文本内容必须使用**字符格式**创建，该格式定义了文本的字体和对齐等属性。在我们开始向框架添加内容之前，我们应该定义一些常见的字符格式，以便在文档的不同部分使用。
- en: 'This is done using the `QTextCharFormat` class, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`QTextCharFormat`类完成的，如下所示：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding example, we''ve created the following three formats:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了以下三种格式：
- en: '`std_format`, which will be used for regular text. We aren''t changing anything
    from the default settings.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`std_format`，将用于常规文本。我们不会改变默认设置。'
- en: '`logo_format`, which will be used for our company logo. We''re customizing
    its font and adding an underline, as well as setting its vertical alignment.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logo_format`，将用于我们的公司标志。我们正在自定义其字体并添加下划线，以及设置其垂直对齐。'
- en: '`label_format`, which will be used for labels; they will be in 12-point font
    and bold.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label_format`，将用于标签；它们将使用12号字体并加粗。'
- en: Note that `QTextCharFormat` allows you to make many font configurations directly
    using setter methods, or you can even configure a `QFont` object to assign to
    the format. We'll use these three formats when we add our text content for the
    remainder of the document.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`QTextCharFormat`允许您直接使用setter方法进行许多字体配置，或者甚至可以配置一个`QFont`对象分配给格式。我们将在文档的其余部分添加文本内容时使用这三种格式。
- en: Adding basic content
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加基本内容
- en: 'Now, let''s add some basic content to our `logo_frame` with the following command:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令向我们的`logo_frame`添加一些基本内容：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Just like we called the root frame''s `lastPosition` method to get the position
    at its end, we can call the logo frame''s `firstPosition()` method to get the
    position at the beginning of the frame. Once there, we can insert content, such
    as a logo image, as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们调用根框架的`lastPosition`方法来获取其末尾的位置一样，我们可以调用标志框架的`firstPosition()`方法来获取框架开头的位置。一旦在那里，我们可以插入内容，比如标志图像，如下所示：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Images can be inserted just like this—by passing a path to the image as a string.
    However, this method offers little in the way of configuration, so let''s try
    a slightly more involved approach:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图片可以像这样插入——通过将图像的路径作为字符串传递。然而，这种方法在配置方面提供的内容很少，所以让我们尝试一种稍微复杂的方法：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: By using a `QTextImageFormat` object, we can configure various aspects of the
    image first, such as its height and width, then add it along with an enum constant
    specifying its positioning policy. In this case, `FloatLeft` will cause the image
    to align to the left of the frame, and subsequent text will wrap around it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`QTextImageFormat`对象，我们可以首先配置图像的各个方面，如其高度和宽度，然后将其添加到枚举常量指定其定位策略。在这种情况下，`FloatLeft`将导致图像与框架的左侧对齐，并且随后的文本将围绕它。
- en: 'Now, let''s write the following text in the block:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在块中写入以下文本：
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Using our `logo_format`, we have written a text fragment containing the company
    name and then inserted a new block so, we can add another fragment containing
    the address on another line. Note that passing a character format is optional;
    if we don't do it, the fragment will be inserted with the currently active format,
    just as it is in a word processor.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`logo_format`，我们已经编写了一个包含公司名称的文本片段，然后插入了一个新块，这样我们就可以在另一行上添加包含地址的另一个片段。请注意，传递字符格式是可选的；如果我们不这样做，片段将以当前活动格式插入，就像在文字处理器中一样。
- en: 'That takes care of our logo, so now let''s deal with the customer address block,
    as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完我们的标志后，现在让我们来处理客户地址块，如下所示：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Text blocks can have formats just like frames and characters. Let''s create
    a text block format to use with our customer address using the following code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 文本块可以像框架和字符一样具有格式。让我们使用以下代码创建一个文本块格式，用于我们的客户地址：
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Text block formats allow you to change the sort of settings you''d change in
    a paragraph of text: margins, line heights, indents, and alignment. Here, we''ve
    set the text alignment to the right-aligned, a right margin of 25 pixels, and
    the line-height to 1.5 lines. There are multiple ways to specify the height in
    `QTextDocument`, and the second argument to `setLineHeight()` determines how the
    value passed in will be interpreted. In this case, we''re using the `ProportionalHeight`
    mode, which interprets the value as a percentage of the line-height.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 文本块格式允许您更改文本段落中更改的设置：边距、行高、缩进和对齐。在这里，我们将文本对齐设置为右对齐，右边距为25像素，行高为1.5行。在`QTextDocument`中有多种指定高度的方法，`setLineHeight()`的第二个参数决定了传入值的解释方式。在这种情况下，我们使用`ProportionalHeight`模式，它将传入的值解释为行高的百分比。
- en: 'We can pass our block format object to any `insertBlock` call, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的块格式对象传递给任何`insertBlock`调用，如下所示：
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Each time we insert a block, it's like starting a new paragraph. Our multi-line
    address string will be inserted as one paragraph, but note that it will still
    be spaced to 1.5 lines.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 每次插入一个块，就像开始一个新段落一样。我们的多行地址字符串将被插入为一个段落，但请注意，它仍将被间隔为1.5行。
- en: Inserting a list
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入列表
- en: 'Our invoice terms will be presented as an unordered bullet list. Ordered and
    unordered lists can be inserted into `QTextDocument` using the cursor''s `insertList()`
    method, as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的发票条款将以无序项目列表的形式呈现。有序和无序列表可以使用光标的`insertList()`方法插入到`QTextDocument`中，如下所示：
- en: '[PRE49]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The argument for `insertList()` can be either a `QTextListFormat` object or
    a constant from the `QTextListFormat.Style` enum. In this case, we're using the
    latter, specifying that we want a list with disc-style bullets.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertList()`的参数可以是`QTextListFormat`对象，也可以是`QTextListFormat.Style`枚举中的常量。在这种情况下，我们使用了后者，指定我们希望使用圆盘样式的项目列表。'
- en: Other options for list formats include `ListCircle` and `ListSquare` for unordered
    lists, and `ListDecimal`, `ListLowerAlpha`, `ListUpperAlpha`, `ListUpperRoman`,
    and `ListLowerRoman` for ordered lists.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 列表格式的其他选项包括`ListCircle`和`ListSquare`用于无序列表，以及`ListDecimal`、`ListLowerAlpha`、`ListUpperAlpha`、`ListUpperRoman`和`ListLowerRoman`用于有序列表。
- en: 'Now, we''ll define some items to insert into our list, as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义要插入到我们的列表中的一些项目，如下所示：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Note that we''re using markup in the preceding example, rather than raw strings.
    You can still use markup when creating a document with `QTextCursor`; however,
    you''ll need to tell the cursor it''s inserting HTML rather than plain text by
    calling `insertHtml()` rather than `insertText()`, as shown in the following example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上面的示例中，我们使用的是标记，而不是原始字符串。在使用`QTextCursor`创建文档时，仍然可以使用标记；但是，您需要通过调用`insertHtml()`而不是`insertText()`来告诉光标它正在插入HTML而不是纯文本，如下例所示：
- en: '[PRE51]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: After calling `insertList()`, our cursor is positioned inside the first list
    item, so we now need to call `insertBlock()` to get to subsequent items (we don't
    want to do this for the first item, since we're already in a bullet point, hence
    the `if i > 0` check).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`insertList()`之后，我们的光标位于第一个列表项内，因此现在我们需要调用`insertBlock()`来到达后续项目（对于第一个项目，我们不需要这样做，因为我们已经处于项目符号中，因此需要进行`if
    i > 0`检查）。
- en: Unlike `insertText()`, `insertHtml()` does not accept a character format object.
    You have to rely on your markup to determine the formatting.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与`insertText()`不同，`insertHtml()`不接受字符格式对象。您必须依靠您的标记来确定格式。
- en: Inserting a table
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入表格
- en: The last thing we're going to insert in our invoice is a table containing our
    line items. `QTextTable` is a subclass of `QTextFrame`, and just like a frame,
    we'll need to create a format object for it before we can create the table itself.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要在发票中插入的最后一件事是包含我们的行项目的表格。`QTextTable`是`QTextFrame`的子类，就像框架一样，我们需要在创建表格本身之前为其创建格式对象。
- en: 'The class we need is the `QTextTableFormat` class:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的类是`QTextTableFormat`类：
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we've configured the `headerRowCount` property, which indicates that the
    first row is a header row and should be repeated at the top of each page. This
    is equivalent to putting the first row in a `<thead>` tag in markup.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们配置了`headerRowCount`属性，该属性表示第一行是标题行，并且应在每页顶部重复。这相当于在标记中将第一行放在`<thead>`标记中。
- en: We're also setting the width, but instead of using pixel values, we're making
    use of a `QTextLength` object. This class is somewhat confusingly named because
    it doesn't refer specifically to the length of text, but rather to any generic
    length you might need in `QTextDocument`. `QTextLength` objects can be of the
    percentage, fixed, or variable type; in this case, we're specifying `PercentageLength`
    with a value of `100`, or 100%.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了宽度，但是我们没有使用像素值，而是使用了`QTextLength`对象。这个类的命名有些令人困惑，因为它不是特指文本的长度，而是指您可能在`QTextDocument`中需要的任何通用长度。`QTextLength`对象可以是百分比、固定或可变类型；在这种情况下，我们指定了值为`100`或100%的`PercentageLength`。
- en: 'Now, let''s insert our table with the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下代码插入我们的表格：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When inserting a table into `QTextDocument`, we not only need to define a format,
    but also a number of rows and columns. To do that, we've created a tuple of the
    headers, then calculated the rows and columns by taking the length of the line
    item list (adding 1 for the header row), and the length of the headers tuple.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在将表格插入`QTextDocument`时，我们不仅需要定义格式，还需要指定行数和列数。为此，我们创建了标题的元组，然后通过计算行项目列表的长度（为标题行添加1），以及标题元组的长度来计算行数和列数。
- en: We then need to position the cursor in the line items frame and insert our table.
    Just like other insert methods, `insertTable()` positions our cursor inside the
    inserted item, in the first column of the first row.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将光标定位在行项目框中并插入我们的表格。就像其他插入方法一样，`insertTable()`将我们的光标定位在插入的项目内部，即第一行的第一列。
- en: 'We can now insert our heading row with the following code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码插入我们的标题行：
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Up to this point, we've been positioning the cursor by passing an exact position
    to `setPosition()`. `QTextCursor` objects also have a `movePosition()` method
    which can take a constant from the `QTextCursor.MoveOperation` enum. This enum
    defines constants representing about two dozen different cursor movements, such
    as `StartOfLine`, `PreviousBlock`, and `NextWord`. In this case, the `NextCell`
    movement takes us to the next cell in a table.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直通过将确切位置传递给`setPosition()`来定位光标。`QTextCursor`对象还具有`movePosition()`方法，该方法可以接受`QTextCursor.MoveOperation`枚举中的常量。该枚举定义了表示约两打不同光标移动的常量，例如`StartOfLine`、`PreviousBlock`和`NextWord`。在这种情况下，`NextCell`移动将我们带到表格中的下一个单元格。
- en: 'We can use the same idea to insert our data, like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的方法来插入我们的数据，如下所示：
- en: '[PRE55]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this case, we're iterating every column of every row in the data list and
    using `insertText()` to add the data to the cell. If the column number is `1`
    or `3`, that is, a monetary value, we need to add a currency symbol to the display.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在迭代数据列表中每一行的每一列，并使用`insertText()`将数据添加到单元格中。如果列号为`1`或`3`，即货币值，我们需要在显示中添加货币符号。
- en: 'We also need to add one more row to hold the grand total for the invoice. To
    add an extra row in our table, we can use the following `QTextTable.appendRows()`
    method:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加一行来保存发票的总计。要在表格中添加额外的行，我们可以使用以下`QTextTable.appendRows()`方法：
- en: '[PRE56]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To position our cursor into a particular cell in the new row, we can use the
    table object''s `cellAt()` method to retrieve a `QTableCell` object, then use
    that object''s `lastCursorPosition()` method, which returns a new cursor positioned
    at the end of the cell, as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将光标定位到新行中的特定单元格中，我们可以使用表对象的`cellAt()`方法来检索一个`QTableCell`对象，然后使用该对象的`lastCursorPosition()`方法，该方法返回一个位于单元格末尾的新光标，如下所示：
- en: '[PRE57]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: That's the last bit of content we need to write to the invoice document, so
    let's go ahead and test it out.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要写入发票文档的最后一部分内容，所以让我们继续测试一下。
- en: Finishing and testing
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成和测试
- en: 'Now, if you run your application, fill in the fields, and hit Create Invoice,
    you should see something like the following screenshot:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您运行您的应用程序，填写字段，然后点击创建发票，您应该会看到类似以下截图的内容：
- en: '![](assets/79fad3bf-5ad0-4208-a822-82277ebe1785.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/79fad3bf-5ad0-4208-a822-82277ebe1785.png)'
- en: Looking good! Of course, that invoice won't do us much good if we can't print
    or export it. So, in the next section, we'll look at how to handle the printing
    of documents.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！当然，如果我们无法打印或导出发票，那么这张发票对我们就没有什么用处。因此，在下一节中，我们将看看如何处理文档的打印。
- en: Printing rich text
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印富文本
- en: Nothing strikes terror into the hearts of programmers like being asked to implement
    printer support. The act of turning pristine digital bits into ink on paper is
    messy in real life and can be just as messy in the software world. Fortunately,
    Qt provides the `QtPrintSupport` module, a cross-platform print system that can
    easily turn `QTextDocument` into hard-copy format, no matter what OS we're using.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么能像被要求实现打印机支持那样让程序员心生恐惧。将原始的数字位转化为纸上的墨迹在现实生活中是混乱的，在软件世界中也可能一样混乱。幸运的是，Qt提供了`QtPrintSupport`模块，这是一个跨平台的打印系统，可以轻松地将`QTextDocument`转换为硬拷贝格式，无论我们使用的是哪个操作系统。
- en: Updating the Invoice app for print support
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新发票应用程序以支持打印
- en: Readers outside the United States almost certainly groaned when we hard-coded
    the dimensions of our document to 8.5×11, but never fear—we're going to make some
    changes that will allow us to set the size based on a user's selection of document
    sizes.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将文档的尺寸硬编码为8.5×11时，美国以外的读者几乎肯定会感到沮丧，但不要担心——我们将进行一些更改，以便根据用户选择的文档尺寸来设置尺寸。
- en: 'In the `InvoiceView` class, create the following new method, `set_page_size()`,
    to set the page size:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在`InvoiceView`类中，创建以下新方法`set_page_size()`，以设置页面大小：
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This method will receive a `QRect` object, from which it will extract width
    and height values to update the document's settings, the widget's fixed size,
    and the document's page size.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将接收一个`QRect`对象，从中提取宽度和高度值以更新文档的设置、小部件的固定大小和文档的页面大小。
- en: 'Down in `MainWindow.__init__()`, add a toolbar to control printing and set
    up the following actions:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainWindow.__init__()`中，添加一个工具栏来控制打印，并设置以下操作：
- en: '[PRE59]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We'll implement each of these callbacks as we walk through how to set up each
    aspect of the print process.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置每个打印过程的各个方面时，我们将实现这些回调。
- en: Configuring the printer
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置打印机
- en: 'Printing begins with a `QtPrintSupport.QPrinter` object, which represents a
    printed document in memory. The basic workflow of printing in PyQt is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 打印始于一个`QtPrintSupport.QPrinter`对象，它代表内存中的打印文档。在PyQt中打印的基本工作流程如下：
- en: Create a `QPrinter` object
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`QPrinter`对象
- en: Configure the `QPrinter` object using its methods or printer configuration dialogs
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用其方法或打印机配置对话框配置`QPrinter`对象
- en: Print `QTextDocument` to the `QPrinter` object
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`QTextDocument`打印到`QPrinter`对象
- en: Pass the `QPrinter` object to the operating system's print dialog, from which
    the user can print using a physical printer
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`QPrinter`对象传递给操作系统的打印对话框，用户可以使用物理打印机进行打印
- en: 'In `MainWindow.__init__()`, let''s create our `QPrinter` object, as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainWindow.__init__()`中，让我们创建我们的`QPrinter`对象，如下所示：
- en: '[PRE60]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Once the printer is created, we can configure a wide number of properties; here,
    we've simply set the orientation and page size (to the US letter defaults, once
    again, but feel free to change this to your preferred paper size).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 打印机创建后，我们可以配置许多属性；在这里，我们只是设置了方向和页面大小（再次设置为美国信纸默认值，但可以随意更改为您喜欢的纸张大小）。
- en: 'Anything you can configure in a printer settings dialog can be configured via
    the `QPrinter` method, but ideally, we''d rather let the user make these decisions.
    So, let''s implement the following `printer_config()` method:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`QPrinter`方法配置打印机设置对话框中的任何内容，但理想情况下，我们宁愿让用户做出这些决定。因此，让我们实现以下`printer_config()`方法：
- en: '[PRE61]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `QPageSetupDialog` object is a `QDialog` subclass that presents all the
    options that are available for the `QPrinter` object. We pass into it our `QPrinter`
    object, which causes any changes that have been made in the dialog to be applied
    to that printer object. On Windows and macOS, Qt will use the OS-provided print
    dialogs by default; on other platforms, a Qt-specific dialog will be used.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPageSetupDialog`对象是一个`QDialog`子类，显示了`QPrinter`对象可用的所有选项。我们将我们的`QPrinter`对象传递给它，这将导致对话框中所做的任何更改应用于该打印机对象。在Windows和macOS上，Qt将默认使用操作系统提供的打印对话框；在其他平台上，将使用一个特定于Qt的对话框。'
- en: 'Now that the user can configure paper size, we need to allow the page size
    used by `InvoiceView` to reset after each change. So, let''s add the following
    method to `MainWindow`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以配置纸张大小，我们需要允许`InvoiceView`在每次更改后重置页面大小。因此，让我们在`MainWindow`中添加以下方法：
- en: '[PRE62]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `QPrinter.pageRect()` method extracts a `QRect` object, defining the configured
    page size. Since our `InvoiceView.set_page_size()` method accepts a `QRect`, we
    just need to pass this object along to it.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPrinter.pageRect()`方法提取了一个`QRect`对象，定义了配置的页面大小。由于我们的`InvoiceView.set_page_size()`方法接受一个`QRect`，我们只需要将这个对象传递给它。'
- en: Note that we've passed a constant into `pageRect()`, indicating that we want
    the size in **points**. A pointis 1/72 of an inch, so our widget size will be
    72 × the physical page size in inches. You can request the page rectangle in a
    variety of units (including millimeters, picas, inches, and so on) if you want
    to do your own calculations to scale the widget's size.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经将一个常量传递给`pageRect()`，表示我们希望以**点**为单位获取大小。点是英寸的1/72，因此我们的小部件大小将是物理页面尺寸的72倍英寸。如果您想要自己计算以缩放小部件大小，您可以请求以各种单位（包括毫米、Picas、英寸等）获取页面矩形。
- en: Unfortunately, the `QPrinter` object is not a `QObject` descendant, so that
    we cannot use signals to determine when its parameters were changed.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`QPrinter`对象不是`QObject`的后代，因此我们无法使用信号来确定其参数何时更改。
- en: Now, add a call to `self._update_preview_size()` to the end of `printer_config()`,
    so that it will be called whenever the user configures the page. You'll find that
    if you change the size of the paper in the printer configuration dialog, your
    preview widget will resize accordingly.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`printer_config()`的末尾添加对`self._update_preview_size()`的调用，这样每当用户配置页面时都会被调用。您会发现，如果您在打印机配置对话框中更改纸张的大小，您的预览小部件将相应地调整大小。
- en: Printing a page
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印一页
- en: Before we can physically print a document, we have to first print `QTextDocument`
    to the `QPrinter` object. This is done by passing the printer object to the document's
    `print()` method.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际打印文档之前，我们必须首先将`QTextDocument`打印到`QPrinter`对象中。这是通过将打印机对象传递给文档的`print()`方法来完成的。
- en: 'We''ll create the following method to do that for us:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以下方法来为我们执行这些操作：
- en: '[PRE63]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note that this doesn't actually cause your printing device to start putting
    ink on the page – it just loads the document into the `QPrinter` object.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这实际上并不会导致您的打印设备开始在页面上放墨水-它只是将文档加载到`QPrinter`对象中。
- en: 'To actually print it to paper, a printer dialog is needed; so, add the following
    method to `MainView`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际将其打印到纸张上，需要打印对话框；因此，在`MainView`中添加以下方法：
- en: '[PRE64]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this method, we first call our internal method to load the document into
    the `QPrinter` object, then pass the object to a `QPrintDialog` object, which
    we execute by calling its `exec()` method. This will display the printing dialog,
    which the user can then use to send the document off to a physical printer.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们首先调用我们的内部方法将文档加载到`QPrinter`对象中，然后将对象传递给`QPrintDialog`对象，通过调用其`exec()`方法来执行。这将显示打印对话框，用户可以使用它将文档发送到物理打印机。
- en: If you don't need the printing dialog to block program execution, you can call
    its `open()` method instead. We're blocking in the preceding example so we can
    perform actions once the dialog is closed.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不需要打印对话框来阻止程序执行，您可以调用其`open()`方法。在前面的示例中，我们正在阻止，以便在对话框关闭后执行操作。
- en: After the dialog has closed, we call `_update_preview_size()` to grab the new
    paper size and update our widget and document. In theory, we could connect the
    dialog's `accepted` signal to that method, but in practice, there are some race
    conditions that may cause this to fail.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框关闭后，我们调用`_update_preview_size()`来获取新的纸张大小并更新我们的小部件和文档。理论上，我们可以将对话框的`accepted`信号连接到该方法，但实际上，可能会出现一些竞争条件导致失败。
- en: Print previewing
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印预览
- en: 'Nobody likes to waste paper by printing something that isn''t right, so we
    should add a `print_preview` function. `QPrintPreviewDialog` exists for this purpose
    and works very much like other printing dialogs, as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人喜欢浪费纸张打印不正确的东西，所以我们应该添加一个`print_preview`函数。`QPrintPreviewDialog`就是为此目的而存在的，并且与其他打印对话框非常相似，如下所示：
- en: '[PRE65]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Once again, we just need to pass the printer object to the dialog's constructor
    and call `exec()`. We also need to connect the dialog's `paintRequested` signal
    to a slot that will update the document in `QPrinter` so that the dialog can make
    sure the preview is up to date. Here, we've connected it to our `_print_document()`
    method, which does exactly what is required.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们只需要将打印机对象传递给对话框的构造函数并调用`exec()`。我们还需要将对话框的`paintRequested`信号连接到一个插槽，该插槽将更新`QPrinter`中的文档，以便对话框可以确保预览是最新的。在这里，我们将其连接到我们的`_print_document()`方法，该方法正是所需的。
- en: Exporting to PDF
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出为PDF
- en: In this paperless digital age, the PDF file has replaced the hard copy for many
    purposes, so an easy export to PDF function is always a good thing to add. `QPrinter`
    can do this for us easily.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个无纸化的数字时代，PDF文件已经取代了许多用途的硬拷贝，因此，添加一个简单的导出到PDF功能总是一件好事。`QPrinter`可以轻松为我们做到这一点。
- en: 'Add the following `export_pdf()` method to `MainView`:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainView`中添加以下`export_pdf()`方法：
- en: '[PRE66]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, we're going to start by asking the user for a filename. If they provide
    one, we'll configure our `QPrinter` object with the filename, set the output format
    to `PdfFormat`, and then print the document. When writing to a file, `QTextDocument.print()`
    will take care of writing the data and saving the file for us, so we don't need
    to do anything else here.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将首先要求用户提供文件名。如果他们提供了文件名，我们将使用该文件名配置我们的`QPrinter`对象，将输出格式设置为`PdfFormat`，然后打印文档。在写入文件时，`QTextDocument.print()`将负责写入数据并为我们保存文件，因此我们在这里不需要做其他事情。
- en: That covers all your printing needs for the invoice program! Take some time
    to test this functionality and see how it works with your printers.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了发票程序的所有打印需求！花些时间测试这个功能，看看它如何与您的打印机配合使用。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you mastered working with rich text documents in PyQt5\. You
    learned how to use Qt's HTML subset to add rich text formatting in the `QLabel`, `QTextEdit`,
    and `QTextBrowser` widgets. You worked through constructing a QTextDocument programmatically
    using the `QTextCursor` interface. Finally, you learned how to bring your `QTextDocument`
    objects into the real world using Qt's printing support module.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您掌握了在PyQt5中处理富文本文档的方法。您学会了如何使用Qt的HTML子集在`QLabel`、`QTextEdit`和`QTextBrowser`小部件中添加富文本格式。您通过使用`QTextCursor`接口编程方式构建了`QTextDocument`。最后，您学会了如何使用Qt的打印支持模块将`QTextDocument`对象带入现实世界。
- en: In [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml), *Creating 2D Graphics
    with QPainter*, you'll learn some advanced concepts of two-dimensional graphics.
    You'll learn to work with `QPainter` objects to create graphics, build custom
    widgets, and create an animation.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml)中，*使用QPainter创建2D图形*，你将学习一些二维图形的高级概念。你将学会如何使用`QPainter`对象来创建图形，构建自定义小部件，并创建动画。
- en: Questions
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用这些问题来测试你对本章的了解：
- en: 'The following HTML isn''t displaying as you''d hoped. Find as many errors as
    you can:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下HTML显示的不如你希望的那样。找出尽可能多的错误：
- en: '[PRE67]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: What is wrong with the following Qt HTML snippets?
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下Qt HTML代码有什么问题？
- en: '[PRE68]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This snippet is supposed to implement a table of contents. Why doesn't it work
    correctly?
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码应该实现一个目录。为什么它不能正确工作？
- en: '[PRE69]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Using `QTextCursor`, add a sidebar to the right-hand side of your document.
    Explain how you would go about this.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`QTextCursor`，在文档的右侧添加一个侧边栏。解释一下你会如何做到这一点。
- en: 'You are trying to create a document with `QTextCursor`. It should have a top
    and bottom frame; in the top frame, there should be a title, and in the bottom
    frame, an unordered list. Correct the following code so that it does that:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在尝试使用`QTextCursor`创建一个文档。它应该有一个顶部和底部的框架；在顶部框架中应该有一个标题，在底部框架中应该有一个无序列表。请纠正以下代码，使其实现这一点：
- en: '[PRE70]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You're creating your own `QPrinter` subclass to add a signal when the page size
    changes. Will the following code work?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你正在创建自己的`QPrinter`子类以在页面大小更改时添加一个信号。以下代码会起作用吗？
- en: '[PRE71]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`QtPrintSupport` contains a class called `QPrinterInfo`. Using this class,
    print a list of the names, makes, models, and default page sizes of all of the
    printers on your system.'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QtPrintSupport`包含一个名为`QPrinterInfo`的类。使用这个类，在你的系统上打印出所有打印机的名称、制造商、型号和默认页面大小的列表。'
- en: Further reading
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For further information, please refer to the following links:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参考以下链接：
- en: Qt's overview of the Scribe framework can be found at [https://doc.qt.io/qt-5/richtext.html](https://doc.qt.io/qt-5/richtext.html)
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt对Scribe框架的概述可以在[https://doc.qt.io/qt-5/richtext.html](https://doc.qt.io/qt-5/richtext.html)找到
- en: Advanced document layouts can be defined using the `QAbstractTextDocumentLayout`
    and `QTextLine` classes; information about how to use these classes can be found
    at [https://doc.qt.io/qt-5/richtext-layouts.html](https://doc.qt.io/qt-5/richtext-layouts.html)
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`QAbstractTextDocumentLayout`和`QTextLine`类来定义高级文档布局；关于如何使用这些类的信息可以在[https://doc.qt.io/qt-5/richtext-layouts.html](https://doc.qt.io/qt-5/richtext-layouts.html)找到
- en: An overview of Qt's printing system can be found at [https://doc.qt.io/qt-5/qtprintsupport-index.html](https://doc.qt.io/qt-5/qtprintsupport-index.html)
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt的打印系统概述可以在[https://doc.qt.io/qt-5/qtprintsupport-index.html](https://doc.qt.io/qt-5/qtprintsupport-index.html)找到
