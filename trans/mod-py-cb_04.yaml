- en: Chapter 4. Built-in Data Structures – list, set, dict
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。内置数据结构 - 列表、集合、字典
- en: 'In this chapter we''ll look at the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下内容：
- en: Choosing a data structure
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择数据结构
- en: Building lists – literals, appending, and comprehensions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建列表 - 文字、附加和理解
- en: Slicing and dicing a list
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片和切割列表
- en: Deleting from a list – deleting, removing, popping, and filtering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从列表中删除 - 删除、移除、弹出和过滤
- en: Reversing a copy of a list
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转列表的副本
- en: Using set methods and operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集合方法和运算符
- en: Removing items from a set – remove(), pop(), and difference
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从集合中删除项目 - remove()，pop()和difference
- en: Creating dictionaries – inserting and updating
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建字典 - 插入和更新
- en: Removing from dictionaries – the pop() method and the del statement
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字典中删除 - pop()方法和del语句
- en: Controlling the order of dict keys
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制字典键的顺序
- en: Handling dictionaries and sets in doctest examples
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在doctest示例中处理字典和集合
- en: Understanding variables, references, and assignment
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解变量、引用和赋值
- en: Making shallow and deep copies of objects
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作对象的浅层和深层副本
- en: Avoiding mutable default values for function parameters
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免函数参数的可变默认值
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Python has a rich collection of built-in data structures. A great deal of useful
    programming is commonly done with these built-in structures. These collections
    cover a variety of common situations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Python具有丰富的内置数据结构。这些内置结构通常用于进行大量有用的编程。这些集合涵盖了各种常见情况。
- en: We'll look at an overview of the various structures that are available and what
    problems they solve. From there, we can look at lists, dictionaries, and sets
    in detail.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将概述可用的各种结构以及它们解决的问题。从那里，我们可以详细了解列表、字典和集合。
- en: Note that we've set the built-in tuple and string aside as being different from
    the list structure. There are some important similarities as well as some differences.
    In [Chapter 1](text00014.html#page "Chapter 1. Numbers, Strings, and Tuples")
    , *Numbers, Strings, and Tuples* , we emphasized the way strings and tuples behave
    more like immutable numbers than mutable collections.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将内置的元组和字符串设置为与列表结构不同。它们有一些重要的相似之处，也有一些不同之处。在[第1章](text00014.html#page
    "第1章。数字、字符串和元组")中，*数字、字符串和元组*，我们强调了字符串和元组的行为更像不可变的数字，而不是可变的集合。
- en: We'll also look at some more advanced topics related to how python handles references
    to objects. We'll look at some issues related to the mutability of these data
    structures, as well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将研究一些与Python处理对象引用相关的更高级的主题。我们还将研究与这些数据结构的可变性相关的一些问题。
- en: Choosing a data structure
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择数据结构
- en: Python offers a number of built-in data structures to help us work with collections
    of data. It can be confusing to determine which is appropriate for a given purpose.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了许多内置数据结构，帮助我们处理数据集合。确定哪种数据结构适合特定目的可能会令人困惑。
- en: How do we choose which structure to use? What are the features of lists, sets,
    and dictionaries? Why do we have tuples and frozen sets?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何选择要使用的结构？列表、集合和字典有哪些特点？为什么有元组和冻结集？
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Before we put data into a collection, we'll need to consider how we'll gather
    the data, and what we'll do with the collection once we have it. The big question
    is always how we'll identify a particular item within the collection.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在将数据放入集合之前，我们需要考虑如何收集数据，以及一旦我们拥有了集合，我们将如何处理它。最重要的问题始终是我们将如何识别集合中的特定项目。
- en: We'll look at a few key questions that we need to answer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究一些需要回答的关键问题。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Is the programming focused on doing membership tests? An example of this is
    a collection of valid input values. When the user enters something that's in the
    collection, their input is valid, otherwise it's invalid.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程是否专注于执行成员资格测试？其中一个例子是有效输入值的集合。当用户输入集合中的内容时，他们的输入是有效的，否则是无效的。
- en: 'Simple membership suggests using a `set` :'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 简单成员资格建议使用`set`：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A `set` holds items in no particular order. Once an item is a member, we can''t
    add it again:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`不按特定顺序保存项目。一旦项目是成员，我们就无法再次添加它：'
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have created a set, `valid_inputs` , with four distinct string items. We
    can't add another `y` to a set which already contains `y` . The contents of the
    set doesn't change.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`valid_inputs`的集合，其中包含四个不同的字符串项目。我们不能向已包含`y`的集合中再添加`y`。集合的内容不会改变。
- en: Also note that the order of the items in the set isn't exactly the order in
    which we initially provided them. A set can't maintain any particular order to
    the items, it can only determine if an item exists in the set.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，集合中项目的顺序并不完全与我们最初提供它们的顺序相同。集合无法保持任何特定的项目顺序，它只能确定集合中是否存在某个项目。
- en: Are we going to identify items by their position in the collection? An example
    includes the lines in an input file—the line number is its position in the collection.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否将通过其在集合中的位置来识别项目？一个例子包括输入文件中的行 - 行号是其在集合中的位置。
- en: 'When we must identify an item using an index or position, we must use a `list`
    :'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们必须使用索引或位置来标识项目时，我们必须使用`list`：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have created a list, `month_name_list` , with 12 string items. We can pick
    an item by providing its position. We can also use the `index()` method to locate
    the index of an item in the list.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`month_name_list`的列表，其中包含12个字符串项目。我们可以通过提供其位置来选择一个项目。我们还可以使用`index()`方法来定位列表中项目的索引。
- en: Lists in Python always start with position zero. This is true for tuples and
    strings, also.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的列表始终从位置零开始。元组和字符串也是如此。
- en: If the number of items in the collection is fixed—for example RGB colors have
    three values—then we might be looking at a `tuple` instead of a `list` . If the
    number of items will grow and change, then the `list` collection is a better choice
    than the `tuple` collection.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合中的项目数量是固定的 - 例如RGB颜色有三个值 - 那么我们可能会考虑使用`tuple`而不是`list`。如果项目数量会增长和变化，那么`list`集合比`tuple`集合更好。
- en: Are we going to identify the items in a collection by a key that's not the item's
    position? An example might include a mapping between strings of characters—words—and
    integers which represent the frequencies of those words, or a mapping between
    a color name and the RGB tuple for that color.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过一个不是项目位置的键来识别集合中的项目吗？ 一个例子可能包括字符串之间的映射 - 单词和表示这些单词频率的整数之间的映射，或者颜色名称和该颜色的RGB元组之间的映射。
- en: 'When we must identify items with a non-positional key, we''re using some kind
    of mapping. The built-in mapping is `dict` . There are several extensions that
    add more features:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们必须使用非位置键标识项目时，我们使用某种映射。内置映射是`dict`。有几个扩展可以添加更多功能：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this dictionary, `scheme` , we've created a mapping from color names to the
    RGB color tuples. When we use a key, for example `"Crimson"` , we can retrieve
    the value bound to that key.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，`scheme`，我们创建了从颜色名称到RGB颜色元组的映射。当我们使用一个键，例如`"Crimson"`，我们可以检索绑定到该键的值。
- en: Consider the mutability of items in a `set` collection and the keys in a `dict`
    collection. Each item in a set must be an immutable object. Numbers, strings,
    and tuples are all immutable, and can be collected into sets. Since a `list` ,
    `dict` , or `set` object is mutable, they can't be used as items in a set. It's
    impossible to build a `set` of `list` items, for example.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑`set`集合中项目的可变性和`dict`集合中的键。集合中的每个项目必须是不可变对象。数字、字符串和元组都是不可变的，可以收集到集合中。由于`list`、`dict`或`set`对象是可变的，它们不能作为集合中的项目。例如，无法构建`list`项目的`set`。
- en: Rather than create a `set` of `list` items, we can transform each `list` item
    into a `tuple` . We can create a `set` of immutable `tuple` items.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是创建`list`项目的`set`，我们可以将每个`list`项目转换为不可变的`tuple`。我们可以创建不可变的`tuple`项目的`set`。
- en: Similarly, dictionary keys must be immutable. We can use a number, or a string,
    or a tuple as a dictionary key. We can't use a `list` , or a `set` , or another
    mutable mapping as a dictionary key.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，字典键必须是不可变的。我们可以使用数字、字符串或元组作为字典键。我们不能使用`list`、`set`或另一个可变映射作为字典键。
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Each of Python's built-in collections offers a specific set of unique features.
    The collections also offer a large number of overlapping features. The challenge
    for programmers new to Python is to identify the unique features of each collection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Python的每个内置集合都提供一组特定的独特功能。这些集合还提供了大量重叠的功能。对于刚接触Python的程序员来说，挑战在于识别每个集合的独特功能。
- en: It turns out that the `collections.abc` module provides a kind of road map through
    the built-in collections. The `collections.abc` module defines the **Abstract
    Base Classes** ( **ABC** s) that support the concrete classes we use. We'll use
    the names from this set of definitions to guide us through the features.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，`collections.abc`模块提供了一种通过内置集合的路线图。`collections.abc`模块定义了支持我们使用的具体类的**抽象基类**（**ABC**）。我们将使用这组定义中的名称来指导我们了解这些功能。
- en: 'From the ABCs, we can see that there are actually places for a total of six
    kinds of collections:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从ABC中，我们可以看到实际上有六种不同类型的集合：
- en: '**Set** : The unique feature is that items are either members or not. This
    means duplicates can''t be handled:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：独特的特点是项目要么是成员，要么不是。这意味着无法处理重复项：'
- en: '**Mutable set** : The `set` collection'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可变集合**：`set`集合'
- en: '**Immutable set** : The `frozenset` collection'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变集合**：`frozenset`集合'
- en: '**Sequence** : The unique feature is that items are provided with an index
    position:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列**：独特的特点是项目提供了索引位置：'
- en: '**Mutable sequence** : The `list` collection'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可变序列**：`list`集合'
- en: '**Immutable sequence** : The `tuple` collection'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变序列**：`tuple`集合'
- en: '**Mapping** : The unique feature is that each item has a key that refers to
    a value:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**：独特的特点是每个项目都有一个指向值的键：'
- en: '**Mutable mapping** : The `dict` collection'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可变映射**：`dict`集合'
- en: '**Immutable mapping** : Interestingly, there''s no built-in frozen mapping'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变映射**：有趣的是，没有内置的冻结映射'
- en: Python's libraries offer a large number of additional implementations of these
    core collection types. We can see many of these in the *Python Standard Library*
    .
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Python的库提供了大量这些核心集合类型的附加实现。我们可以在*Python标准库*中看到许多这些。
- en: 'The `collections` module contains a number of variations on the built-in collections.
    These include:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections`模块包含许多内置集合的变体。这些包括：'
- en: '`namedtuple` : A `tuple` that offers names for each item in a tuple. It''s
    slightly more clear to use `rgb_color.red` than `rgb_color[0]` .'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namedtuple`：为元组中的每个项目提供名称的`tuple`。使用`rgb_color.red`比`rgb_color[0]`更清晰一些。'
- en: '`deque` : A double-ended queue. It''s a mutable sequence with optimizations
    for pushing and popping from each end. We can do similar things with a `list`
    , but the `deque` is more efficient.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deque`：双端队列。它是一个可变序列，具有从每一端推送和弹出的优化。我们可以使用`list`做类似的事情，但`deque`更有效。'
- en: '`defaultdict` : A `dict` that can provide a default value for a missing key.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultdict`：可以为缺失的键提供默认值的`dict`。'
- en: '`Counter` : A `dict` which is designed to count occurrences of a key. This
    is sometimes called a multiset or a bag.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Counter`：旨在计算键出现次数的`dict`。有时被称为多重集或袋子。'
- en: '`OrderedDict` : A `dict` which retains the order in which keys were created.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderedDict`：保留创建键的顺序的`dict`。'
- en: '`ChainMap` : A `dict` which combines several dictionaries into a single mapping.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChainMap`：将几个字典组合成单个映射的`dict`。'
- en: There's more in the *Python Standard Library* . We can also use the `heapq`
    module which defines a priority queue implementation. The `bisect` module includes
    methods for searching a sorted list very quickly. This allows a list to have performance
    that is a little closer to the fast lookups of a dictionary.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Python标准库*中还有更多。我们还可以使用`heapq`模块，该模块定义了优先级队列实现。`bisect`模块包括快速搜索排序列表的方法。这使得列表的性能更接近于字典的快速查找。
- en: There's more...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can look at a list of data structures like this: [https://en.wikipedia.org/wiki/List_of_data_structures](https://en.wikipedia.org/wiki/List_of_data_structures)
    .'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看这样的数据结构列表：[https://en.wikipedia.org/wiki/List_of_data_structures](https://en.wikipedia.org/wiki/List_of_data_structures)。
- en: There are some important summaries that are part of this giant index of data
    structures. Different parts of the article provide slightly different summaries
    of data structures. We'll take a quick look at four classifications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些重要的摘要是数据结构的一部分。文章的不同部分提供了略有不同的数据结构摘要。我们将快速浏览四个分类。
- en: '**Arrays** : There are variant implementations that offer similar features.
    Python''s `list` structure is typical, and offers performance similar to a linked-list
    implementation of an array.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数组**：有变体实现提供类似的功能。Python的`list`结构是典型的，并且提供了类似于数组的链表实现的性能。'
- en: '**Trees** : Generally, tree structures can be used to create sets, sequential
    lists, or key-value mappings. We can look at a tree as an implementation technique,
    rather than a data structure with a unique feature set.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树**：通常，树结构可以用来创建集合、顺序列表或键值映射。我们可以将树看作是一种实现技术，而不是具有独特特征集的数据结构。'
- en: '**Hashes** : Python uses hashes to implement dictionaries and sets. This leads
    to good speed but large memory consumption.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希**：Python使用哈希来实现字典和集合。这导致速度快但内存消耗大。'
- en: '**Graphs** : Python doesn''t have a built-in graph data structure. However,
    we can easily represent a graph structure with a dictionary where each node has
    a list of adjacent nodes.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图表**：Python没有内置的图表数据结构。然而，我们可以用一个字典来轻松表示图表结构，其中每个节点都有一个相邻节点的列表。'
- en: We can—with a little cleverness—implement almost any kind of data structure
    in Python. Either the built-in structures have the essential features, or we can
    locate a built-in structure that can be pressed into service.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以——稍微聪明一点——在Python中实现几乎任何类型的数据结构。要么内置结构具有基本特征，要么我们可以找到一个内置结构，可以被利用起来。
- en: See also
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For advanced graph manipulation, see [https://networkx.github.io](https://networkx.github.io)
    .
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关高级图形操作，请参阅[https://networkx.github.io](https://networkx.github.io)。
- en: Building lists – literals, appending, and comprehensions
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建列表-文字，附加和推导
- en: If we've decided to create a collection that uses an item's position—a `list`
    —we have several ways of building this structure. We'll look at a number of ways
    we can build a list object from individual items.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定创建一个使用项目位置的集合-`list`，我们有几种构建这个结构的方法。我们将看一些我们可以从单个项目构建`list`对象的方法。
- en: In some cases, we'll need a list because it allows duplicate values. A great
    many statistical operations don't require knowing the position of an item. A multiset
    would be useful for this, but we don't have this as a built-in structure; it's
    very common to use a `list` instead of a multiset.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要一个列表，因为它允许重复的值。许多统计操作不需要知道项目的位置。对于这个，多重集将是有用的，但我们没有这个作为内置结构；使用`list`而不是多重集是非常常见的。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s say we need to do some statistical analyses on some file sizes. Here''s
    a short script that will provide us with the sizes of some files:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要对一些文件大小进行一些统计分析。下面是一个简短的脚本，将为我们提供一些文件的大小：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We've used a `pathlib.Path` object to represent a directory in our file system.
    The `glob()` method expands all names that match a given pattern. In this case,
    we used a pattern of `'*/index.rst'` . We can use the `for` statement to display
    the size from the file's OS `stat` data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`pathlib.Path`对象来表示文件系统中的目录。`glob()`方法扩展与给定模式匹配的所有名称。在这种情况下，我们使用了一个模式`'*/index.rst'`。我们可以使用`for`语句从文件的OS`stat`数据中显示大小。
- en: We'd like to accumulate a `list` object that has the various file sizes. From
    that we can compute total size, and average size. We can look for files which
    seem too large or too small.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要累积一个具有各种文件大小的`list`对象。从中我们可以计算总大小和平均大小。我们可以寻找看起来太大或太小的文件。
- en: 'We have four ways to create `list` objects:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有四种创建`list`对象的方法：
- en: 'We can create literal display of a `list` using a sequence of values surrounded
    by `[]` characters. It looks like this: `[value, ... ]` . Python needs to match
    the `[` and `]` to see a complete logical line, so the literal can span physical
    lines. For more information see the *Writing long lines of code* recipe in [Chapter
    2](text00027.html#page "Chapter 2. Statements and Syntax") , *Statements and Syntax*
    .'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用一系列值围绕在`[]`字符中来创建`list`的文字显示。它看起来像这样：`[value, ...]`。Python需要匹配`[`和`]`来看到一个完整的逻辑行，因此文字可以跨越物理行。有关更多信息，请参阅[第2章](text00027.html#page
    "第2章。语句和语法")中的*编写长行代码*配方，*语句和语法*。
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can convert some other data collection into a list using the `list()` function.
    We can convert a `set` , or the keys of a `dict` , or the values of a `dict` .
    We'll look at a more sophisticated example of this in the *Slicing and dicing
    a list* recipe.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`list()`函数将其他数据集转换为列表。我们可以转换`set`，或`dict`的键，或`dict`的值。我们将在*Slicing and
    dicing a list*配方中看到一个更复杂的例子。
- en: We have `list` methods that allow us to build a `list` one item a time. These
    methods include `append()` , `extend()` and `insert()` . We'll look at `append()`
    in the *Building a list with the append() method* section of this recipe. We'll
    look at the other methods in the *There's More...* section of this recipe.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一些`list`方法，允许我们一次构建一个`list`。这些方法包括`append()`，`extend()`和`insert()`。我们将在本配方的*使用append()方法构建列表*部分中查看`append()`。我们将在本配方的*还有更多...*部分中查看其他方法。
- en: We have generator expressions which can be used to build `list` objects. One
    kind of generator is a list comprehension.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有生成器表达式，可以用来构建`list`对象。一种生成器是列表推导。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Building a list with the append() method
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用append()方法构建列表
- en: 'Create an empty list, `[]` :'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空列表，`[]`：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Iterate through some source of data. Append the items to the list using the
    `append()` method:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过一些数据源进行迭代。使用`append()`方法将项目附加到列表中：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We used the path's `glob()` method to find all files that match the given pattern.
    The `stat()` method of a path provides the OS **stat** data structure, which includes
    the size, `st_size` , in bytes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用路径的`glob()`方法来查找与给定模式匹配的所有文件。路径的`stat()`方法提供了包括大小`st_size`在内的OS **stat**数据结构，以字节为单位。
- en: When we print the `list` , Python displays it in literal notation. This is handy
    if we ever need to copy and paste the list into another script.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印`list`时，Python会以文字表示法显示它。如果我们需要复制并粘贴列表到另一个脚本中，这很方便。
- en: It's very important to note that the `append()` method does not return a value.
    The `append()` method mutates the `list` object, and does not return anything.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要注意，`append()`方法不返回值。`append()`方法改变了`list`对象，并且不返回任何东西。
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Generally, any method that mutates an object has no return value. Methods like
    `append()` , `extend()` , `sort()` , and `reverse()` have no return value. They
    adjust the structure of the `list` object itself.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，任何改变对象的方法都没有返回值。像`append()`，`extend()`，`sort()`和`reverse()`这样的方法没有返回值。它们调整`list`对象本身的结构。
- en: The `append()` method does not return a value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`append()`方法不返回值。'
- en: It mutates the `list` object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 它会改变`list`对象。
- en: 'It''s surprisingly common to see wrong code like this: `a = [''some'', ''data'']`
    `a = a.append(''more data'')` This is emphatically wrong. This will set `a` to
    `None` .'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，经常会看到错误的代码，像这样：`a = ['some', 'data']` `a = a.append('more data')` 这是错误的。这将把`a`设置为`None`。
- en: 'The correct approach is a statement like this, without any additional assignment:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的方法是这样的陈述，没有任何额外的赋值：
- en: '`a.append(''more data'')`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`a.append(''more data'')`'
- en: Writing a list comprehension
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写一个列表推导
- en: 'The goal of a list comprehension is to create an object that occupies a syntax
    role similar to a list literal:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导的目标是创建一个对象，其语法角色类似于列表文字：
- en: Write the wrapping `[]` brackets that surround the list object.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写包围列表对象的`[]`括号。
- en: 'Write the source of the data. This will include the target variable. Note that
    there''s no `:`  at the end because we''re not writing a complete statement:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写数据的来源。这将包括目标变量。请注意，末尾没有`:`，因为我们不是在写一个完整的语句：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Prefix this with the expression to evaluate for each value of the target variable.
    Again, since this is a simple expression we cannot use complex statements here:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个表达式之前加上要评估的目标变量的每个值。同样，由于这是一个简单的表达式，我们不能在这里使用复杂的语句：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In some cases, we'll need to add a filter. This is an `if` clause after the
    `for` clause. We can make the generator expression quite sophisticated.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要添加一个过滤器。这是在`for`子句之后的`if`子句。我们可以使生成器表达式非常复杂。
- en: 'Here''s the entire `list` object:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整个`list`对象：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we've created a `list` object, we can assign it to a variable and do
    other calculations and summaries on the data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个`list`对象，我们可以将其分配给一个变量，并对数据进行其他计算和总结。
- en: The list comprehension includes a generator expression, called a **comprehension**
    in the language manual. The generator expression is a data expression attached
    to a `for` clause. Since this generator is an expression, not a complete statement,
    there are some limitations on what it can do. The data expression is evaluated
    repeatedly, and is controlled by the `for` clause.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导包括一个生成器表达式，称为语言手册中的**推导**。生成器表达式是附加到`for`子句的数据表达式。由于这个生成器是一个表达式，而不是一个完整的语句，它有一些限制。数据表达式会被重复评估，并由`for`子句控制。
- en: Using the list function on a generator expression
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用生成器表达式的列表函数
- en: 'We''ll create a `list` function that uses the generator expression:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个使用生成器表达式的`list`函数：
- en: Write the wrapping `list()` function that surrounds the generator expression.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写包围生成器表达式的`list()`函数。
- en: 'We''ll reuse steps two and three from the list comprehension version to create
    a generator expression. Here''s the generator expression:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重用列表推导版本的步骤二和步骤三来创建一个生成器表达式。这是生成器表达式：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s the entire list object:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整个列表对象：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A Python `list` object has a dynamic size. The bounds of the array are adjusted
    when items are appended or inserted, or the `list` is extended with another `list`
    . Similarly, the bounds shrink when items are popped or deleted. We can access
    any item very quickly, and the speed of access doesn't depend on the size of the
    list.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`list`对象具有动态大小。当添加或插入项目，或者使用另一个`list`扩展`list`时，数组的边界会调整。同样，当弹出或删除项目时，边界会收缩。我们可以非常快速地访问任何项目，访问速度不取决于列表的大小。
- en: 'In rare cases, we might want to create a `list` with a given initial size,
    and then set the values of the items separately. We can do this with a list comprehension
    like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些罕见的情况下，我们可能需要创建一个具有给定初始大小的`list`，然后分别设置项目的值。我们可以使用类似于这样的列表推导来实现：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will create a list with an initial size of 100 items, each of which is
    `None` . It's rare to need this, though, because lists can grow in size as needed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个初始大小为100个项目的列表，每个项目都是`None`。尽管很少需要这样做，因为列表可以根据需要增长。
- en: The list comprehension syntax and the `list()` function both consume items from
    a generator and append them to create a new `list` object.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导语法和`list()`函数都会从生成器中消耗项目并将它们附加到创建一个新的`list`对象。
- en: There's more...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Our goal in creating a `list` object was to be able to summarize it. We can
    use a variety of Python functions for this. Here are some examples:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建`list`对象的目标是能够对其进行总结。我们可以使用各种Python函数来实现这一点。以下是一些例子：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''ve used the built-in `sum()` , `min()` , and `max()` to produce some descriptive
    statistics of these document sizes. Which of these index files is the smallest?
    We want to know the position of the minimum in the list of values. We can use
    the `index()` method for this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了内置的`sum()`，`min()`和`max()`来生成这些文档大小的一些描述性统计数据。这些索引文件中哪一个是最小的？我们想知道值列表中最小值的位置。我们可以使用`index()`方法来实现：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've found the minimum, and then used the `index()` method to locate the position
    of that minimal value. Recall that the index values start at zero, so the smallest
    file is for the twelfth chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经找到了最小值，然后使用`index()`方法来找到该最小值的位置。请记住，索引值从零开始，因此最小的文件是第十二章的文件。
- en: Other ways to extend a list
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他扩展列表的方法
- en: 'We can extend a list, as well as insert into the middle or beginning of a list.
    We have two ways to extend a list: we can use the `+` operator or we can use the
    `extend()` method. Here''s an example of creating two lists and putting them together
    with `+` :'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以扩展列表，以及在列表的中间或开头插入。我们有两种方法来扩展列表：我们可以使用`+`运算符，也可以使用`extend()`方法。以下是一个创建两个列表并使用`+`将它们放在一起的示例：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have created a list of sizes of documents with names like `ch_01*/*.rst`
    . We then created a second list of sizes of documents with a slightly different
    name pattern, `ch_02*/*.rst` . We then combined the two lists into a final list.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个包含名称为`ch_01*/*.rst`的文档大小的列表。然后我们创建了一个包含稍有不同名称模式`ch_02*/*.rst`的文档大小的第二个列表。然后我们将这两个列表合并成一个最终列表。
- en: 'We can do this using the `extend()` method, also. We''ll reuse the two lists
    and build a new list from them:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`extend()`方法来做到这一点。我们将重复使用这两个列表，并从中构建一个新列表：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We noted that `append()` does not return a value. Note that `extend()` does
    not return a value, either. The `extend()` method mutates the `list` object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到`append()`不返回值。请注意，`extend()`也不返回值。`extend()`方法会改变`list`对象。
- en: 'We can insert a value prior to any particular position in a list, also. The
    `insert()` method accepts the position of an item; the new value will be before
    the given position:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在列表中的任何特定位置之前插入一个值。`insert()`方法接受一个项目的位置；新值将在给定位置之前：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've inserted two new values into a `list` object. As with `append()` and `extend()`
    , `insert()` does not return a value. It mutates the `list` object.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向`list`对象插入了两个新值。与`append()`和`extend()`一样，`insert()`也不返回值。它会改变`list`对象。
- en: See also
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Slicing and dicing a list* recipe for ways to copy lists and pick sublists
    from a list.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅*切片和切块列表*的方法，了解复制列表和从列表中选择子列表的方法。
- en: See the *Deleting from a list – deleting, removing, popping, and filtering*
    recipe for other ways to remove items from a list.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅*从列表中删除 - 删除、移除、弹出和过滤*的方法，以了解从列表中删除项目的其他方法。
- en: In the *Reversing a copy of a list* recipe we'll look at reversing a list.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*反转列表的副本*的方法中，我们将研究如何反转列表。
- en: 'This article provides some insights into how Python collections work internally:
    [https://wiki.python.org/moin/TimeComplexity](https://wiki.python.org/moin/TimeComplexity)
    . When looking at the tables, it''s important to note that **O** (1) means that
    the cost is essentially constant, and **O** (n) means the cost varies with the
    index of the item we''re trying to process. This means that the cost grows as
    the size of the collection grows.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本文介绍了Python集合内部工作的一些见解：[https://wiki.python.org/moin/TimeComplexity](https://wiki.python.org/moin/TimeComplexity)。在查看表格时，重要的是要注意**O**（1）表示成本基本上是恒定的，而**O**（n）表示成本随着我们尝试处理的项目的索引而变化。这意味着成本随着集合的大小而增加。
- en: Slicing and dicing a list
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片和切块列表
- en: There are many times when we want to pick items from a list. One of the most
    common kinds of processing is to treat the first item of a list as a special case.
    This leads to a kind of *head-tail* processing where we treat the head of a list
    differently from the items in the tail of a list.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多时候我们想从列表中挑选项目。最常见的一种处理方式是将列表的第一项视为特殊情况。这导致了一种*头尾*处理，我们将列表的头部与列表尾部的项目区别对待。
- en: We can use these techniques to make a copy of a list, also.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用这些技术来制作列表的副本。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We have a spreadsheet that was used to record fuel consumption on a large sailboat.
    It has rows which look like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个用于记录大型帆船燃油消耗的电子表格。它的行看起来像这样：
- en: '| **date** | **engine on** | **fuel height** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: 日期 | 发动机启动 | 燃油高度
- en: '|  | **engine off** |  |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: 发动机关闭
- en: '|  | **Other notes** |  |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: 其他注意事项
- en: '| 10/25/2013 | 08:24 | 29 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: 10/25/2013 08:24 29
- en: '|  | 13:15 | 27 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: 13:15 27
- en: '|  | calm seas—anchor solomon''s island |  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: 风平浪静 - 锚在所罗门岛
- en: '| 10/26/2013 | 09:12 | 27 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: 10/26/2013 09:12 27
- en: '|  | 18:25 | 22 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: 18:25 22
- en: '|  | choppy—anchor in jackson''s creek |  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: 颠簸 - 锚在杰克逊溪
- en: Fuel height? Yes. There's no float sensor to estimate the level of fuel in the
    tanks. Instead there's a **sight-gauge** that allows direct observation of the
    fuel. It's calibrated in inches of depth. For all practical purposes the tank
    is rectangular, so the depth shown can be converted to volume pretty easily—31
    inches of depth is about 75 gallons.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 燃油高度？是的。没有浮标传感器来估计油箱中的燃油水平。相反，有一个**视觉量规**，可以直接观察燃油。它以深度英寸为单位进行校准。在实际情况下，油箱是矩形的，因此显示的深度可以很容易地转换为体积
    - 31英寸的深度约为75加仑。
- en: What's important is that the spreadsheet data is not properly normalized. Ideally,
    each row follows the first normal form for data with each row having identical
    content, and each cell having only atomic values.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，电子表格数据没有得到适当的规范化。理想情况下，每行都遵循数据的第一正规形式，每行具有相同的内容，每个单元格只有原子值。
- en: Our data is not properly normalized. We have four rows of headings. This is
    something the `csv` module can't deal with directly. We need to do some slicing
    to remove the rows from other notes. We'd like to combine the two rows of each
    day's travel to make it easier to compute an elapsed time and the number of inches
    used.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据没有得到适当的规范化。我们有四行标题。这是`csv`模块无法直接处理的。我们需要做一些切片来删除其他注意事项中的行。我们希望将每天旅行的两行合并在一起，以便更容易计算经过的时间和使用的英寸数。
- en: 'We can read the data like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样读取数据：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We've used the `csv` module to read the log details. A `csv.reader()` is an
    iterable object. In order to collect the items into a single list, we applied
    the `list()` function. We looked at the first and last item in the list to confirm
    that we really have a list of lists structure.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`csv`模块来读取日志详情。`csv.reader()`是一个可迭代对象。为了将项目收集到一个单独的列表中，我们应用了`list()`函数。我们查看了列表中的第一个和最后一个项目，以确认我们确实有一个列表的列表结构。
- en: Each row of the original CSV file is a list. Each of those lists is a three
    item sublist.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 原始CSV文件的每一行都是一个列表。这些列表中的每一个都是一个三项子列表。
- en: For this recipe, we'll use an extension of a list index expression to slice
    items from a list. The slice, like the index, follows the list object in `[]`
    characters. Python offers us several variations on the slice expression. A slice
    can include two or three values in the slice, separated by `:` characters. We
    can write `:stop` , `start:` , `start:stop` , `start:stop:step` , or any of several
    other variations. The default step value is one. The default start value is the
    beginning of the list and the default stop value is the end of the list.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将使用列表索引表达式的扩展来从列表中切片项目。切片和索引一样，跟在`[]`字符后面。Python为我们提供了几种切片表达式的变体。切片可以包括两个或三个值，用`:`字符分隔。我们可以写`：stop`，`start：`，`start:stop`，`start:stop:step`，或者其他几种变体。默认的步长值是一。默认的起始值是列表的开头，默认的停止值是列表的结尾。
- en: 'Here''s how we can slice and dice the raw list of rows to pick out the rows
    we need:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何切片和处理原始的行列表，以挑选出我们需要的行：
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The first thing we need to do is remove the four lines of heading from the
    list of rows. We''ll use two partial slice expressions to divide the list at row
    four:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是从行列表中删除四行标题。我们将使用两个部分切片表达式来在第四行处分割列表：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We've sliced the list into two sections using `log_rows[:4]` and `log_rows[4:]`
    . The `head` variable will have the four lines of headings. We don't really want
    to do any processing with the head, so we ignore that variable. The `tail` variable,
    however, has the rows of the sheet we care about.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`log_rows[:4]`和`log_rows[4:]`将列表切片成两个部分。`head`变量将包含四行标题。我们实际上不想对头部进行任何处理，所以我们忽略了那个变量。然而，`tail`变量有我们关心的表的行。
- en: We'll use slices with steps to pick the interesting rows. The `[start::step]`
    version of a slice will pick rows in groups based on the step value. In our case,
    we'll take two slices. One slice starts on row zero and the other slice starts
    on row one.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用带步长的切片来挑选有趣的行。切片的`[start::step]`版本将根据步长值选择行。在我们的情况下，我们将取两个切片。一个切片从第零行开始，另一个切片从第一行开始。
- en: 'Here''s a slice of every third row, starting with row zero:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是每三行的一个切片，从第零行开始：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ll also want every third row, starting with row one:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要每三行，从第一行开始：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These two slices can then be zipped together:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后这两个切片可以被合并在一起：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''ve sliced the list into two parallel groups:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将列表切片成了两个并行的组：
- en: The `[0::3]` slice starts with the first row, and includes every third row.
    This will be rows zero, three, six, nine, and so on.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[0::3]`切片从第一行开始，包括每三行。这将是第零行，第三行，第六行，第九行，依此类推。'
- en: The `[1::3]` slice starts with the second row, and includes every third row.
    This will be rows one, four, seven, ten, and so on.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[1::3]`切片从第二行开始，包括每三行。这将是第一行，第四行，第七行，第十行，依此类推。'
- en: We've used the `zip()` function to interleave these two sequences from the list.
    This gives us a sequence of three tuples that's very close to something we can
    work with.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`zip()`函数来交错这两个列表中的序列。这给了我们一个非常接近我们可以处理的三个元组的序列。
- en: 'Flatten the results:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展平结果：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've used a list comprehension from the *Building lists – literals, appending,
    and comprehensions* recipe to combine the two elements in each pair of rows to
    create a single row. Now we're in a position to convert the date and time into
    a single `datetime` value. We can then compute the difference in times to get
    the running time for the boat, and the difference in heights to estimate the fuel
    burned.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了来自*构建列表-文字，附加和理解*食谱的列表理解，将每对行中的两个元素组合成一个单独的行。现在我们可以将日期和时间转换为单个的`datetime`值。然后我们可以计算时间差来得到船的运行时间，以及计算高度差来估算燃烧的燃料。
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The slice operator has several different common forms:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 切片操作符有几种不同的常见形式：
- en: '`[:]` : The start and stop are implied. The expression `S[:]` will copy the
    sequence, *S* .'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:]`：起始和结束被隐含。表达式`S[:]`将复制序列*S*。'
- en: '`[:stop]` : This makes a new list from the beginning to just before the stop
    value.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:stop]`：这将从开头创建一个新的列表，直到停止值之前。'
- en: '`[start:]` : This makes a new list from the given start to the end of the sequence.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[start：]`：这将从给定的起始位置创建一个新的列表，直到序列的末尾。'
- en: '`[start:stop]` : This picks a sublist starting from the start index and stopping
    just before the stop index. Python works with half-open intervals. The start is
    included, the end is not included.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[start:stop]`：这将从起始索引开始选择一个子列表，并在停止索引之前停止。Python使用半开区间。起始值包括在内，结束值不包括在内。'
- en: '`[::step]` : The start and stop are implied and include the entire sequence.
    The step—generally not equal to one—means we''ll skip through the list from the
    start using the step. For a given step, *s* , and a list of size | *L* |, the
    index values are ![How it works...](Image00010.jpg)  .'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[::step]`：起始和结束被隐含，并包括整个序列。步长-通常不等于一-意味着我们将使用步长从起始位置跳过列表。对于给定的步长*s*和大小为|*L*|的列表，索引值为![How
    it works...](Image00010.jpg)。'
- en: '`[start::step]` : The start is given, but the stop is implied. The idea is
    that the start is an offset, and the step applies to that offset. For a given
    start, *a* , step, *s* , and a list of size | *L* |, the index values are ![How
    it works...](Image00011.jpg)  .'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[start::step]`：给出了起始值，但结束值被隐含。这个想法是起始值是一个偏移量，步长适用于该偏移量。对于给定的起始值*a*，步长*s*，和大小为|*L*|的列表，索引值为![How
    it works...](Image00011.jpg)。'
- en: '`[:stop:step]` : This is used to prevent processing the last few items in a
    list. Since the step is given, processing begins with element zero.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:stop:step]`：这用于防止处理列表中的最后几个项目。由于给定了步长，处理从零开始。'
- en: '`[start:stop:step]` : This will pick elements from a subset of the sequence.
    Items prior to start and after stop will not be used.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[start:stop:step]`：这将从序列的子集中选择元素。开始之前和结束之后的项目将不会被使用。'
- en: The slicing technique works for lists, tuples, strings, and any other kind of
    sequence. This does not cause the object to be mutated; this will make a copy
    of the items.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 切片技术适用于列表、元组、字符串和任何其他类型的序列。这不会导致对象被改变；这将复制项目。
- en: There's more...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the *Reversing a copy of a list* recipe, we'll look at an even more sophisticated
    use of slice expressions.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Reversing a copy of a list*方法中，我们将看到对切片表达式的更复杂的使用。
- en: The copy is called a **shallow copy** because we'll have two collections that
    contain references to the same underlying objects. We'll look at this in detail
    in the *Making shallow and deep copies of objects* recipe.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个复制被称为**浅复制**，因为我们将有两个包含对相同基础对象的引用的集合。我们将在*Making shallow and deep copies of
    objects*方法中详细讨论这一点。
- en: For this specific example, we have another way of restructuring multiple rows
    of data into single rows of data. We can use a generator function. We'll look
    at functional programming techniques in [Chapter 8](text00088.html#page "Chapter 8. Functional
    and Reactive Programming Features") , *Functional and Reactive Programming Features*
    .
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的例子，我们有另一种将多行数据重组为单行数据的方法。我们可以使用一个生成器函数。我们将在[第8章](text00088.html#page
    "第8章. 函数式和反应式编程特性")中看到函数式编程技术，*函数式和反应式编程特性*。
- en: See also
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Building lists – literals, appending, and comprehensions* recipe for
    ways to create lists
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看*Building lists – literals, appending, and comprehensions*方法以了解创建列表的方法
- en: See the *Deleting from a list – deleting, removing, popping, and filtering*
    recipe for other ways to remove items from a list
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看*Deleting from a list – deleting, removing, popping, and filtering*方法以了解从列表中移除项目的其他方法
- en: In the *Reversing a copy of a list* recipe we'll look at reversing a list
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*Reversing a copy of a list*方法中，我们将看到对列表进行反转
- en: Deleting from a list – deleting, removing, popping, and filtering
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从列表中删除项目 – 删除、移除、弹出和过滤
- en: There are many times when we want to remove items from a `list` collection.
    We might delete items from a list, and then process the items which are left over.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多时候我们想要从`list`集合中移除项目。我们可能会从列表中删除项目，然后处理剩下的项目。
- en: Removing unneeded items has a similar effect as using the `filter()` to create
    a copy which has only the needed items. The distinction is that a filtered copy
    will use more memory than deleting items from a list. We'll show both techniques
    for removing unwanted items from a list.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 删除不需要的项目会产生与使用`filter()`创建仅包含所需项目的副本类似的效果。区别在于，过滤后的副本将使用比从列表中删除项目更多的内存。我们将展示从列表中移除不需要的项目的这两种技术。
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We have a spreadsheet that is used to record fuel consumption on a large sailboat.
    It has rows which look like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个用于记录大型帆船燃油消耗的电子表格。它的行看起来像这样：
- en: '| **date** | **engine on** | **fuel height** |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| **日期** | **引擎开启** | **燃油高度** |'
- en: '|  | **engine off** |  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|  | **引擎关闭** |  |'
- en: '|  | **Other notes** |  |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|  | **其他说明** |  |'
- en: '| 10/25/2013 | 08:24 | 29 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: 10/25/2013 | 08:24 | 29 |
- en: '|  | 13:15 | 27 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|  | 13:15 | 27 |'
- en: '|  | calm seas—anchor solomon''s island |  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|  | 平静的海域—锚所罗门岛 |  |'
- en: '| 10/26/2013 | 09:12 | 27 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: 10/26/2013 | 09:12 | 27 |
- en: '|  | 18:25 | 22 |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|  | 18:25 | 22 |'
- en: '|  | choppy—anchor in jackson''s creek |  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|  | 波涛汹涌—锚在杰克逊溪 |  |'
- en: For more background on this data, see the *Slicing and dicing a list * recipe.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此数据的更多背景信息，请参阅*Slicing and dicing a list*方法。
- en: 'We can read the data like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样读取数据：
- en: '[PRE25]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We've used the `csv` module to read the log details. A `csv.reader()` is an
    iterable object. In order to collect the items into a single list, we applied
    the `list()` function. We looked at the first and last item in the list to confirm
    that we really have a list-of-lists structure.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`csv`模块读取日志详情。`csv.reader()`是一个可迭代对象。为了将项目收集到一个单一列表中，我们应用了`list()`函数。我们查看了列表中的第一个和最后一个项目，以确认我们确实有一个列表的列表结构。
- en: Each row of the original CSV file is a list. Each of those lists has three items.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 原始CSV文件的每一行都是一个列表。这些列表中的每一个都有三个项目。
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll look at four ways to remove things from a list:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到从列表中删除项目的四种方法：
- en: The `del` statement
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`del`语句'
- en: The `remove()` method
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove()`方法'
- en: The `pop()` method
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop()`方法'
- en: Using the `filter()` function to create a copy that rejects selected rows
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`filter()`函数创建一个拒绝选定行的副本
- en: Deleting items from a list
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从列表中删除项目
- en: We can remove items from a list using the `del` statement.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`del`语句从列表中移除项目。
- en: To make it easy to follow the examples at the interactive prompt, we'll make
    a copy of the list. If we deleted rows from the original `log_rows` list, subsequent
    examples might be hard to follow. In a practical program, we would not make this
    extra copy. We could also have used `log_rows[:]` to copy the original list.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便在交互提示符下跟随示例，我们将复制列表。如果我们从原始的`log_rows`列表中删除行，后续的示例可能会难以跟随。在实际程序中，我们不会做这个额外的复制。我们也可以使用`log_rows[:]`来复制原始列表。
- en: '[PRE26]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here''s how the `del` statement looks:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`del`语句的样子如下：'
- en: '[PRE27]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `del` statement removed the header rows from the tail, leaving behind the
    rows that we really need to process. We can then combine these and summarize them
    using the *Slicing and dicing a list* recipe.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`del`语句从尾部删除了标题行，留下了我们真正需要处理的行。然后我们可以使用*Slicing and dicing a list*方法将它们合并并进行总结。'
- en: The remove() method
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`remove()`方法'
- en: We can remove items from a list using the `remove()` method. This removes matching
    items from a list.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`remove()`方法从列表中移除项目。这会从列表中移除匹配的项目。
- en: 'We might have a list that looks like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一个看起来像这样的列表：
- en: '[PRE28]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This has a useless `''''` string in it:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个无用的`''`字符串：
- en: '[PRE29]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that the `remove()` method does not return a value. It mutates the list
    in place. This is an important distinction that applies to mutable objects.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`remove()`方法不返回值。它会直接改变列表。这是一个适用于可变对象的重要区别。
- en: Tip
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `remove()` method does not return a value.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()`方法不返回值。'
- en: It mutates the list object.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 它改变了列表对象。
- en: 'It''s surprisingly common to see wrong code like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这样错误的代码实际上是非常常见的：
- en: '`a = [''some'', ''data'']`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`a = [''some'', ''data'']`'
- en: '`a = a.remove(''data'')`'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`a = a.remove(''data'')`'
- en: This is emphatically wrong. This will set `a` to `None` .
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是绝对错误的。这将把`a`设置为`None`。
- en: The pop() method
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pop()方法
- en: We can remove items from a list using the `pop()` method. This removes items
    from a list based on their index.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`pop()`方法从列表中删除项目。这将根据它们的索引从列表中删除项目。
- en: 'We might have a list that looks like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一个看起来像这样的列表：
- en: '[PRE30]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This has a useless `''''` string in it:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个无用的`''`字符串：
- en: '[PRE31]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that the `pop()` method does two things:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`pop()`方法有两个作用：
- en: It mutates the `list` object
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它改变了`list`对象
- en: It returns the value which was removed
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它返回被移除的值
- en: The filter() function
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: filter()函数
- en: We can also remove items by building a copy that passes the desirable items
    and rejects the undesirable items. Here's how we can do this with the `filter()`
    function.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过构建传递合适项目并拒绝不合适项目的副本来删除项目。以下是我们如何使用`filter()`函数来实现这一点。
- en: Identify the features of the items we wish to pass or reject. The `filter()`
    function expects a rule for passing data. The logical inverse of that function
    will reject data.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别我们希望通过或拒绝的项目的特征。`filter()`函数期望通过数据的规则。该函数的逻辑反函数将拒绝数据。
- en: In our case, the rows we want have a numeric value in column two. We can best
    detect this with a little helper function.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们希望的行在第二列中有一个数值。我们可以通过一个小的辅助函数最好地检测到这一点。
- en: 'Write the filter test function. If it''s trivial, use a lambda object. Otherwise,
    write a separate function:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写过滤测试函数。如果很简单，可以使用lambda对象。否则，编写一个单独的函数：
- en: '[PRE32]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We've used the built-in `float()` function to see if a given string is a proper
    number. If the `float()` function does not raise an exception, the data is a valid
    number, and we want to pass this row. If an exception is raised, the data was
    not numeric, and we'll reject the row.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用内置的`float()`函数来查看给定的字符串是否是一个合适的数字。如果`float()`函数没有引发异常，则数据是有效的数字，我们希望通过这一行。如果引发了异常，则数据不是数字，我们将拒绝这一行。
- en: 'Use the filter test function (or lambda) with the data in the `filter()` function:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`filter()`函数中的数据测试函数（或lambda）：
- en: '[PRE33]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We provided our test, `number_column()` and the original data, `log_rows` .
    The output from the `filter()` function is an iterable. To create a list from
    the iterable result, we'll use the `list()` function. The result has just the
    four rows we want; the remaining rows were rejected.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了我们的测试，`number_column()`和原始数据，`log_rows`。`filter()`函数的输出是一个可迭代对象。为了从可迭代结果创建一个列表，我们将使用`list()`函数。结果只有我们想要的四行；其余的行被拒绝了。
- en: We haven't really deleted the rows. We've created a copy which omits those rows.
    The end result is the same.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有真正删除行。我们创建了一个省略这些行的副本。最终结果是一样的。
- en: How it works...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Because a list is a mutable object, we can remove items from the list. This
    technique doesn't work for tuples or strings. All three collections are sequences,
    but only the list is mutable.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 因为列表是一个可变对象，我们可以从列表中删除项目。这种技术对于元组或字符串不起作用。这三个集合都是序列，但只有列表是可变的。
- en: We can only remove items with an index that's present in the list. If we attempt
    to remove an item with an index outside the allowed range, we'll get an `IndexError`
    exception.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能删除列表中存在的索引的项目。如果我们尝试删除超出允许范围的索引的项目，将会得到`IndexError`异常。
- en: 'For example:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE34]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There's more...
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some times where this doesn't work. If we use a list in a `for` statement,
    we can't delete items from the list.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这种方法不起作用。如果我们在`for`语句中使用列表，我们无法从列表中删除项目。
- en: 'Let''s say we want to remove all even items from a list. Here''s an example
    that does not work properly:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要从列表中删除所有偶数项。以下是一个不正常工作的示例：
- en: '[PRE35]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The result is clearly not right. Why are some even-valued items left in the
    list?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显然不正确。为什么列表中还有一些偶数值的项目？
- en: Let's look at what happens when processing the item with a value of eight. We'll
    execute the `remove()` method. The value will be removed, and all the subsequent
    values will be slid forward one position. The `10` will be moved into the position
    formerly occupied by the `8` . The list's internal index will move forward to
    the next position, which will have a `13` in it. The `10` will never be processed.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在处理值为八的项目时会发生什么。我们将执行`remove()`方法。该值将被移除，并且所有后续的值将向前滑动一个位置。`10`将被移动到以前由`8`占据的位置。列表的内部索引将向前移动到下一个位置，该位置将有一个`13`。`10`将永远不会被处理。
- en: Bad things also happen if we insert into the middle of a list, the driving iterable
    in a `for` loop. In that case, items will be processed twice.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在列表的中间插入，在`for`循环中的驱动可迭代对象中也会发生不好的事情。在这种情况下，项目将被处理两次。
- en: 'We have two ways to avoid the *skip-when-delete* problem:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法可以避免*跳过-删除*问题：
- en: 'Make a copy of the list:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作列表的副本：
- en: '[PRE36]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Use a `while` loop with a manual index:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`while`循环和手动索引：
- en: '[PRE37]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We've designed a loop which only increments the position if the item is odd.
    If an item is even it's removed, and the other items are moved forward one position
    in the list.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计了一个循环，只有在项目为奇数时才增加位置。如果项目是偶数，则将其删除，并将其他项目向列表中的下一个位置移动。
- en: See also
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Building lists – literals, appending, and comprehensions* recipe for
    ways to create lists
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关创建列表的方法，请参阅*构建列表-文字，附加和理解*配方
- en: See the *Slicing and dicing a list* recipe for ways to copy lists and pick sublists
    from a list
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关从列表中复制列表和从列表中选择子列表的方法，请参阅*切片和切块列表*配方
- en: In the *Reversing a copy of a list* recipe we'll look at reversing a list
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*反转列表的副本*配方中，我们将研究如何反转列表
- en: Reversing a copy of a list
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反转列表的副本
- en: Once in a while, we need to reverse the order of the items in a `list` collection.
    Some algorithms, for example, produce results in a reversed order. We'll look
    at the way numbers converted to a specific base are often generated from least-significant
    to most-significant digit. We generally want to display the values with the most-significant
    digit first. This leads to a need to reverse the sequence of digits in a list.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，我们需要反转`list`集合中项目的顺序。例如，一些算法产生的结果是倒序的。我们将看看数字转换为特定基数时通常是如何从最低位到最高位生成的。我们通常希望以最高位数字优先显示值。这导致需要反转列表中数字的顺序。
- en: We have two ways to reverse a list. First, there's the `reverse()` method. Then
    there's this handy trick.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法来反转一个列表。首先是`reverse()`方法。然后是这个方便的技巧。
- en: Getting ready
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's say we're doing a conversion among number bases. We'll look at how a number
    is represented in a base, and how we can compute that representation from a number.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在进行数字基数之间的转换。我们将看看一个数字在一个基数中是如何表示的，以及我们如何从一个数字计算出那个表示。
- en: 'Any value, *v* , can be defined as a polynomial function of the various digits,
    *d[n]* , in a given base, *b* :'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 任何值*v*都可以定义为给定基数*b*中各个数字*d[n]*的多项式函数：
- en: '*v* = *d[n]* × *b^n* + *d[n]* [-1] × *b^n* ^(-1) + *d[n]* [-2] × *b^n* ^(-2)
    + ... + *d* [1] × *b* + *d* [0]'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '*v* = *d[n]* × *b^n* + *d[n]* [-1] × *b^n* ^(-1) + *d[n]* [-2] × *b^n* ^(-2)
    + ... + *d* [1] × *b* + *d* [0]'
- en: A rational number has a finite number of digits. An irrational number would
    have an infinite series of digits.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 有理数有有限数量的数字。无理数将有无限系列的数字。
- en: For example, the number `0xBEEF` is a base 16 value. The digits are { *B* =
    11, *E* = 14, *F* = 15}, the base *b* = 16.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，数字`0xBEEF`是一个16进制值。数字是{*B* = 11, *E* = 14, *F* = 15}，基数*b* = 16。
- en: 48879 = 11 × 16³ + 14 × 16² + 14 × 16 + 15
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 48879 = 11 × 16³ + 14 × 16² + 14 × 16 + 15
- en: 'We can restate this in a form that''s slightly more efficient to compute:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新陈述这个形式，这样计算起来稍微更有效率一些：
- en: '*v* = (...(( *d[n]* × *b* + *d[n]* [-1] ) × *b* + *d[n]* [-2] ) × *b* + ...
    + *d* [1] ) × *b* + *d* [0]'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*v* = (...(( *d[n]* × *b* + *d[n]* [-1] ) × *b* + *d[n]* [-2] ) × *b* + ...
    + *d* [1] ) × *b* + *d* [0]'
- en: There are many cases where the base isn't a consistent power of some number.
    The ISO date format, for example, has a mixed base that involves 7 days per week,
    24 hours per day, 60 minutes per hour, and 60 seconds per minute.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，基数不是某个数字的一致幂。例如，ISO日期格式涉及每周7天，每天24小时，每小时60分钟和每分钟60秒的混合基数。
- en: Given a week number, a day of the week, an hour, a minute, and a second, we
    can compute a timestamp of seconds, *t[s]* , within the given year.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个周数、一周中的某一天、一个小时、一分钟和一秒，我们可以计算给定年份内的秒级时间戳*t[s]*。
- en: '*t[s]* = ((( *w* × 7 + *d* ) × 24 + *h* ) × 60 + *m* ) × 60 + *s*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '*t[s]* = ((( *w* × 7 + *d* ) × 24 + *h* ) × 60 + *m* ) × 60 + *s*'
- en: 'For example:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE38]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How do we invert this calculation? How do we get the various fields from the
    overall timestamp?
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何反转这个计算？我们如何从整体时间戳中获取各个字段？
- en: We'll need to use `divmod`  style division. For some background, see the *Choosing
    between True Division and Floor Division* recipe.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`divmod`风格的除法。有关背景，请参阅*选择真除法和地板除法之间*的配方。
- en: 'The algorithm for converting a timestamp in seconds, *t[s]* , to individual
    week, day, and time fields looks like this:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 将秒级时间戳*t[s]*转换为单独的周、天和时间字段的算法如下：
- en: '*t[m]* , *s*  ← *t[s]* /60, *t[s]* mod 60'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*t[m]*，*s*  ← *t[s]* /60, *t[s]* mod 60'
- en: '*t[h]* , *m*  ← *t[m]* /60, *t[m]* mod 60'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '*t[h]*，*m*  ← *t[m]* /60, *t[m]* mod 60'
- en: '*t[d]* , *h*  ← *t[h]* /60, *t[h]* mod 24'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '*t[d]*，*h*  ← *t[h]* /60, *t[h]* mod 24'
- en: '*w* , *d*  ← *t[d]* /60, *t[d]* mod 7'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '*w*，*d*  ← *t[d]* /60, *t[d]* mod 7'
- en: 'This has a handy pattern that leads to a very simple implementation. It has
    a consequence of producing the values in reverse order:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个方便的模式，可以导致一个非常简单的实现。它有一个产生值的顺序相反的后果：
- en: '[PRE39]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We've applied the `divmod()` function four times to extract seconds, minutes,
    hours, days, and weeks from a timestamp given in seconds. These are in the wrong
    order. How can we reverse them?
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经应用了`divmod()`函数四次，从以秒为单位给定的时间戳中提取秒、分钟、小时、天和周。这些顺序是错误的。我们如何将它们反转？
- en: How to do it...
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We have two approaches: we can use the `reverse()` method or we can use a `[::-1]`
    slice expression. Here''s the `reverse()` method:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法：我们可以使用`reverse()`方法，或者我们可以使用`[::-1]`切片表达式。这是`reverse()`方法：
- en: '[PRE40]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We made a copy of the original list, so that we could keep an unmutated copy
    to compare with the mutated copy. This makes it easier to follow the examples.
    We applied the `reverse()` method to reverse a copy of the list.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们制作了原始列表的副本，这样我们就可以保留一个未改变的副本，以便与改变后的副本进行比较。这样更容易跟踪示例。我们应用了`reverse()`方法来反转列表的副本。
- en: 'This will mutate the list. As with other mutating methods, it does not return
    a useful value. It''s an error to use a statement like this: `a = b.reverse()`
    . The value of `a` will always be `None` .'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这将改变列表。与其他变异方法一样，它不会返回一个有用的值。使用类似这样的语句是错误的：`a = b.reverse()`。`a`的值将始终是`None`。
- en: 'Here''s a slice expression with a negative step:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有负步长的切片表达式：
- en: '[PRE41]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this example, we made a slice `[::-1]` which uses an implied start and stop,
    and the step was `-1` . This picks all of the items in the list in reverse order
    to create a new list.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们做了一个切片`[::-1]`，它使用了一个隐含的开始和结束，步长为`-1`。这会选择列表中所有项目的倒序来创建一个新列表。
- en: The original list is emphatically *not* mutated by this `slice` operation. This
    creates a copy. Check the value of the `fields` variable to see that it's unchanged.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`slice`操作绝对不会改变原始列表。这会创建一个副本。检查`fields`变量的值，看看它是否没有改变。
- en: How it works...
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As we noted in the *Slicing and dicing a list* recipe, the slice notation is
    quite sophisticated. Using a slice with a negative step size will create a copy
    (or a subset) with items processed in right to left order instead of the default
    left to right order.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*切片和切块列表*配方中指出的，切片表示法非常复杂。使用负步长的切片将创建一个副本（或子集），其中的项目按从右到左的顺序处理，而不是默认的从左到右的顺序。
- en: 'It''s important to distinguish between these two methods:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要区分这两种方法：
- en: The `reverse()` function modifies the `list` object itself. As with methods
    like `append()` and `remove()` there is no return value from this method. Because
    it changes the list, it doesn't return a value.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse()`函数修改了`list`对象本身。与`append()`和`remove()`等方法一样，这个方法没有返回值。因为它改变了列表，所以不会返回值。'
- en: The `[::-1]` slice expression creates a new list. This is a shallow copy of
    the original list, with the order reversed.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[::-1]`切片表达式创建一个新的列表。这是原始列表的浅复制，顺序被颠倒。'
- en: See also
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Making shallow and deep copies of objects* recipe for more information
    on what a shallow copy is and why we might want to make a deep copy
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关浅复制和深复制对象的更多信息，请参阅*制作浅复制和深复制对象*食谱，了解浅复制是什么，以及为什么我们可能需要进行深复制。
- en: See the *Building lists – literals, appending, and comprehensions* recipe for
    ways to create lists
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关创建列表的方法，请参阅*构建列表-文字，附加和理解*食谱
- en: See the *Slicing and dicing a list* recipe for ways to copy lists and pick sublists
    from a list
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关从列表中复制列表和选择子列表的方法，请参阅*切片和切块列表*食谱
- en: See the *Deleting from a list – deleting, removing, popping, and filtering*
    recipe for other ways to remove items from a list
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关从列表中删除项目的其他方法，请参阅*从列表中删除-删除，移除，弹出和过滤*食谱
- en: Using set methods and operators
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用集合方法和运算符
- en: We have several ways to build a `set` collection. We can use the `set()` function
    to convert an existing collection to a set. We can use the `add()` method to put
    items into a set. We can also use the `update()` method and the union operator,
    `|` , to create a larger set from other sets.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法来构建`set`集合。我们可以使用`set()`函数将现有集合转换为集合。我们可以使用`add()`方法将项目放入集合。我们还可以使用`update()`方法和并集运算符`|`来从其他集合创建一个更大的集合。
- en: We'll show a recipe that uses a `set` to show whether or not we've seen a complete
    domain of values from a pool of statistical data. The recipe will build a `set`
    collection as the samples are being scanned.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示一个使用`set`来显示我们是否已经从统计数据池中看到了完整值域的食谱。该食谱将在扫描样本时构建一个`set`集合。
- en: 'When doing exploratory data analysis, we need to answer the question: *Is this
    data random?* Many data collections have variances in the data that are ordinary
    noise. It''s important not to waste time doing complex modeling and analysis of
    random numbers.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行探索性数据分析时，我们需要回答一个问题：*这些数据是随机的吗？*许多数据集中的数据方差是普通噪音。重要的是不要浪费时间对随机数进行复杂的建模和分析。
- en: For discrete or continuous numeric data, like the depth of water in meters,
    or the size of a file in bytes, we can use averages and standard deviations to
    see if a given collection of data is random. We expect a sample's mean to match
    the population mean within boundaries that are measured by the standard deviation.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 对于离散或连续的数值数据，如水的深度（以米为单位）或文件的大小（以字节为单位），我们可以使用平均值和标准偏差来查看给定数据集是否是随机的。我们期望样本的均值在由标准偏差测量的边界内与总体均值相匹配。
- en: For categorical data, like customer ID numbers or phone numbers, we can't compute
    averages or standard deviations. These values have to be evaluated in a different
    way.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分类数据，如客户ID号码或电话号码，我们无法计算平均值或标准偏差。这些值必须以不同的方式进行评估。
- en: One technique for determining the randomness of categorical data is the **Coupon
    Collector's Test** . With this test, we will see how many items have to be examined
    before we have found a complete set of *coupons* . Is a sequence of customer visits
    random? Or is there some other distribution in the sequence of visits? If the
    data is not random, then we can invest in more research into the causes.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 确定分类数据的随机性的一种技术是**优惠券收集者测试**。通过这个测试，我们将看到在找到完整的*优惠券*集之前必须检查多少项目。顾客访问的顺序是随机的吗？还是在访问顺序中有其他分布？如果数据不是随机的，那么我们可以投资更多的研究来了解原因。
- en: The Python `set` collection is central to how this works. We'll add items to
    a `set` until we've seen each customer once.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`set`集合对于这个工作至关重要。我们将向`set`添加项目，直到我们至少见过每个客户一次。
- en: 'If customers arrive randomly, we can predict an expected number of visits before
    the business has seen each customer at least once. The overall expected arrival
    time for the entire domain is the sum of the arrival times for each customer in
    the domain. This is equal to the number of customers, *n* , times the n^(th) Harmonic
    Number, *H[n]* :'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户随机到达，我们可以预测在企业至少见过每个客户之前的预期访问次数。整个域的预期到达时间是域中每个客户的到达时间之和。这等于客户数量*n*乘以第n个调和数*H[n]*：
- en: '*E* = *n* × *H[n]* = *n* × ((1/1) + (1/2) + (1/3) + (1/ *n* ))'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*E* = *n* × *H[n]* = *n* × ((1/1) + (1/2) + (1/3) + (1/ *n* ))'
- en: This is the expected average number of visits before all customers have been
    seen. If the actual average arrival time matches this expectation that means all
    customers are visiting; we don't need to waste any more time on studying data
    that fits our expectations. If the actual average doesn't match expectations,
    then some customers are not visiting as frequently as others, and we need to pursue
    a deeper study of why.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有客户被看到之前的预期平均访问次数。如果实际平均到达时间与预期相匹配，这意味着所有客户都在访问；我们不需要再浪费时间研究符合我们期望的数据。如果实际平均值与预期不符，则一些客户访问的频率不如其他客户频繁，我们需要深入研究原因。
- en: Getting ready
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We'll use a Python `set` to represent the collection of coupons. We'll need
    a population of data that may (or may not) have a proper distribution of *coupons*
    . We'll look at a set of eight customers.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python的`set`来表示优惠券的集合。我们需要一个可能（或可能不）具有正确分布的*优惠券*的数据集。我们将查看一个包含八个客户的集合。
- en: Here's a function that simulates customers arriving in a random order. The customers
    are represented as numbers in the half-open interval [0, *n* ], we can say that
    all customers, *c* , fit the rule 0 ≤ *c* < *n* .
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个模拟顾客以随机顺序到达的函数。顾客以半开区间[0，*n*]中的数字表示，我们可以说所有顾客*c*符合规则0 ≤ *c* < *n*。
- en: '[PRE42]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `arrival1()` function will yield an endless sequence of values. We've called
    this `arrival` with a `1` on the end. It may look like a spelling mistake, but
    we've used the `1` suffix so that we can create alternative implementations.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`arrival1()`函数将产生一个无限序列的值。我们在末尾加上了`1`，这可能看起来像是拼写错误，但我们使用了`1`后缀，以便我们可以创建替代实现。'
- en: 'We need to put an upper bound on the number of values generated. Here''s a
    function that has an upper limit on the number of samples produced:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对生成的值的数量设置一个上限。以下是一个具有生成样本数量上限的函数：
- en: '[PRE43]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This generator function uses another generator as a source of items. The idea
    is that we'll use the `arrival1()` function. The `samples()` function enumerates
    the items from a larger collection and stops when enough items have been seen.
    Since the `arrival1()` function is infinite, this boundary is essential.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成函数使用另一个生成器作为项目的来源。这个想法是我们将使用`arrival1()`函数。`samples()`函数枚举了来自更大集合的项目，并在看到足够的项目时停止。由于`arrival1()`函数是无限的，这个边界是必不可少的。
- en: 'Here''s how we use these functions to simulate the arrival of customers. We''ll
    produce a sequence of customer ID numbers:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何使用这些函数来模拟顾客的到达。我们将产生一系列顾客ID号码：
- en: '[PRE44]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We forced the random number generator to have a specific seed value so that
    we would produce a known test sequence. We applied the `samples()` function to
    the `arrival1()` function to produce a sequence of 10 customer visits. Customer
    seven seemed to have a lot of repeat business. Customers zero and five never showed
    up at all.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强制随机数生成器具有特定的种子值，以便我们可以产生一个已知的测试序列。我们将`samples()`函数应用于`arrival1()`函数，以产生一个包含10次顾客访问的序列。第七位顾客似乎有很多重复的业务。顾客零和五根本没有出现。
- en: This is just a simulation of data. A business would use sales receipts to determine
    customer visits. A web site might record visits in a database, or might scrape
    the web logs to determine the sequence of actual values.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是数据的模拟。企业将使用销售收据来确定顾客访问。网站可能会在数据库中记录访问，或者可能会抓取网络日志来确定实际值的序列。
- en: What's the expected number of visits before we've seen all eight customers?
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到所有八个顾客之前，预期的访问次数是多少？
- en: '[PRE45]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This function creates the series of fractions 1/1, 1/2, up to 1/ *n* . These
    are summed and multiplied by *n* .
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数创建了一系列分数1/1，1/2，直到1/*n*。这些分数被求和并乘以*n*。
- en: '[PRE46]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: On an average, it will take 22 customer visits before we'll see all eight of
    our customers once.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 平均来说，我们需要22次顾客访问才能看到我们的八个顾客中的所有人一次。
- en: How do we use the `set` collection to create statistics on the actual number
    of visits before we've seen all eight customers?
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用`set`集合来统计在我们看到所有八个顾客之前的实际访问次数？
- en: How to do it...
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'As we step through each customer visit, we''ll put the customer ID into a `set`
    collection. Duplicates aren''t saved in a set. Once a customer ID is a member
    of the set, adding the value again doesn''t change the set. We''ll summarize the
    steps in this recipe and then show the complete function:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们逐个顾客访问时，我们将把顾客ID放入一个`set`集合中。重复项不会保存在集合中。一旦顾客ID成为集合的成员，再次添加该值不会改变集合。我们将总结这个步骤，然后展示完整的函数：
- en: Start with an empty `set` and a zero counter.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个空的`set`和一个零计数器开始。
- en: Begin a `for` loop to visit all of the data items.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个`for`循环来访问所有数据项。
- en: Add the next item to the `set` . Add one to the counter.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下一个项目添加到`set`中。计数器加一。
- en: If the `set` is complete, the count can be yielded. This is the number of customers
    required to see a complete set. After yielding, empty the `set` and initialize
    the counter to zero in preparation for the next customer.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`set`已经完成，可以产生计数。这是需要看到完整集合的顾客数量。产生后，清空`set`并将计数器初始化为零，以准备下一个顾客。
- en: 'Here''s the function:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是函数：
- en: '[PRE47]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will start a `count` at zero and create an empty set, `collection` , in
    which we'll collect customer ID's. We'll step through each item in the sequence
    of source data values, `data` . The value of `count` shows how many visitors there
    are. The value of the variable `collection` is the set of distinct visitors.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从零开始计数，并创建一个空集`collection`，我们将收集顾客ID。我们将逐个遍历源数据值序列`data`中的每个项目。`count`的值显示了有多少访客。变量`collection`的值是不同访客的集合。
- en: The `add()` method of a `set` will mutate the set to add a distinct value. If
    the value is already in the set, there's no change to the content.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`的`add()`方法将改变集合以添加一个不同的值。如果该值已经在集合中，则内容不会发生变化。'
- en: When the size of the collection is the size of our target population, we've
    got a complete set of coupons. We can yield the value of the `count` . We also
    reset the count of visits and create a new empty set for our collection of coupons.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当集合的大小等于我们的目标人口的大小时，我们就有了一个完整的优惠券集合。我们可以产生`count`的值。我们还重置了访问计数，并为我们的优惠券集合创建了一个新的空集。
- en: How it works...
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Since this is a generator, we''ll need to capture the data by creating a `list`
    object from the results. Here''s how we''d use the `coupon_collector()` function:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个生成器，我们需要通过从结果创建一个`list`对象来捕获数据。以下是我们如何使用`coupon_collector()`函数：
- en: '[PRE48]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We've computed the expected time to see all `n` customers. We've used `samples(100,
    arrival1())` as a simulation to create the `data` variable which has a sequence
    of visits. In real life, we'd analyze sales receipts to gather this sequence of
    visits.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经计算了看到所有`n`个顾客的预期时间。我们使用`samples(100, arrival1())`作为模拟来创建`data`变量，其中包含一系列访问。在现实生活中，我们会分析销售收据来收集这一系列访问。
- en: We applied the Coupon Collector's Test to the data. This emitted a sequence
    of values that showed how many customers had to arrive to create a complete set
    of *coupons* or customer ID's. This sequence of counts should be close to the
    expected number of visits. We've assigned this sequence to the variable `wait_times`
    because we've measured the time we need to wait before seeing all of the customers
    in our sample set.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对数据应用了收集者测试。这产生了一个值序列，显示了需要多少客户到达才能创建一个完整的 *优惠券* 或客户 ID 的集合。这个计数序列应该接近预期的访问次数。我们将这个序列分配给变量
    `wait_times`，因为我们测量了在看到我们样本集中的所有客户之前需要等待的时间。
- en: This lets us easily compare the actual data with the expected data. The function
    that we just saw, `arrival1()` , produces averages that are quite close to the
    expected values. Since the input data is random, the simulation won't produce
    values that precisely match the expectation.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们可以轻松地将实际数据与预期数据进行比较。我们刚刚看到的函数 `arrival1()` 产生的平均值与预期值非常接近。由于输入数据是随机的，模拟不会产生与预期完全匹配的值。
- en: The Coupon Collector's Test relies on collecting a set of coupons. In this case,
    the term **set** is used in exact mathematical formalism that best represents
    the data.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 收集者测试依赖于收集一组优惠券。在这种情况下，术语 **set** 是用于精确的数学形式化来最好地表示数据。
- en: 'A given item either is a member of a set or it is not. We can''t add it to
    the set more than once. For example, we can create a set manually and add an item
    to it:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的项目要么是集合的成员，要么不是。我们不能将其添加到集合中超过一次。例如，我们可以手动创建一个集合并向其添加一个项目：
- en: '[PRE49]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When we attempt to add this item again, the value of the `set` doesn't change.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试再次添加这个项目时，`set` 的值不会改变。
- en: '[PRE50]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is the perfect data representation for collecting coupons.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这是收集优惠券的完美数据表示。
- en: Note that the `add()` method does not return a value. It mutates the `set` object.
    This is similar to the way methods of the `list` collection work. Generally, a
    method that mutates the collection does not return a value. The only exception
    to this pattern is the `pop()` method, which both mutates the `set` object and
    returns the popped value.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`add()` 方法不会返回一个值。它改变了 `set` 对象。这类似于 `list` 集合的方法工作方式。通常，改变集合的方法不会返回一个值。唯一的例外是
    `pop()` 方法，它既改变了 `set` 对象，又返回了弹出的值。
- en: There's more...
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We have several ways to add items to a `set` :'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以向 `set` 添加项目：
- en: The example used the `add()` method. This works with a single item.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例使用了 `add()` 方法。这适用于单个项目。
- en: We can use the `union()` method. This is like an operator—it creates a new result
    `set` . It does not mutate either of the operand sets.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `union()` 方法。这类似于一个运算符——它创建一个新的结果 `set`。它不会改变任何一个操作数集合。
- en: We can use the `|` union operator to compute the union of two sets.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `|` 并集运算符来计算两个集合的并集。
- en: We can use the `update()` method to update one set with items from another set.
    This mutates a set, and does not return a value.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `update()` 方法从另一个集合中更新一个集合。这会改变一个集合，并且不会返回一个值。
- en: 'For most of these, we''ll need to create a singleton `set` from the item we''re
    going to add. Here''s an example of adding a single item, `3` , to a set by turning
    it into a singleton set:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数情况，我们需要从要添加的项目创建一个单例 `set`。以下是将单个项目 `3` 添加到一个集合中的示例：
- en: '[PRE51]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we've created a singleton set, `{item}` from the value of the `item` variable.
    We then used the `union()` method to compute a new set that is the union of `collection`
    and `{item}` .
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从变量 `item` 的值创建了一个单例集合 `{item}`。然后我们使用了 `union()` 方法来计算一个新的集合，即 `collection`
    和 `{item}` 的并集。
- en: Note that `union()` returns a resulting object and leaves the original `collection`
    set untouched. We would need to use this as `collection = collection.union({item})`
    to update the `collection` object.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`union()` 返回一个结果对象，并且不会改变原始的 `collection` 集合。我们需要使用 `collection = collection.union({item})`
    来更新 `collection` 对象。
- en: 'This is yet another alternative that uses the union operator, `|` :'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种使用并集运算符 `|` 的替代方法：
- en: '[PRE52]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This parallels common mathematical notation for {1, 3} ∪ {3} ≡ {1, 3}.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 {1, 3} ∪ {3} ≡ {1, 3} 的常见数学表示法相似。
- en: 'We can also use the `update()` method:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `update()` 方法：
- en: '[PRE53]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This method mutates the `set` object. Because it mutates the set, it does not
    return a value.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法改变了 `set` 对象。因为它改变了集合，所以它不会返回一个值。
- en: 'Python has a number of set operators. These are ordinary operator symbols that
    we can use in complex expressions:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有许多集合运算符。这些是我们可以在复杂表达式中使用的普通运算符符号：
- en: '`|` for union, often typeset as *A* ∪ *B*'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`|` 用于并集，通常排版为 *A* ∪ *B*'
- en: '`&` for intersection, often typeset as *A* ∩ *B*'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&` 用于交集，通常排版为 *A* ∩ *B*'
- en: '`^` for symmetric difference, often typeset as *A* Δ *B*'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^` 用于对称差，通常排版为 *A* Δ *B*'
- en: '`-` for subtraction, often typeset as *A* - *B*'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-` 用于减法，通常排版为 *A* - *B*'
- en: See also
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In the *Removing items from a set – remove, pop, and difference* recipe we'll
    look at how we can update a set by removing or replacing items
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *从集合中移除项目 - remove、pop 和 difference* 配方中，我们将看看如何通过移除或替换项目来更新一个集合
- en: Removing items from a set – remove(), pop(), and difference
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从集合中移除项目 - remove()、pop() 和 difference
- en: Python gives us several ways to remove items from a `set` collection. We can
    use the `remove()` method to remove a specific item. We can use the `pop()` method
    to remove an arbitrary item.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: Python 给了我们几种方法来从 `set` 集合中移除项目。我们可以使用 `remove()` 方法来移除特定的项目。我们可以使用 `pop()`
    方法来移除一个任意的项目。
- en: 'Additionally, we can compute a new set using set intersection, difference,
    and symmetric difference operators: `&` , `-` , and `^` . These will produce a
    new set which is a subset of a given input set.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用集合交集、差集和对称差运算符 `&`、`-` 和 `^` 来计算一个新的集合，这个新的集合是给定输入集合的子集。
- en: Getting ready
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Sometimes we''ll have log files that contain lines with complex and varied
    formats. Here''s a small snippet from a long, complex log:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们会有包含复杂和各种格式的行的日志文件。这是一个来自长而复杂的日志的小片段：
- en: '[PRE54]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We need to find the `IP: 111.222.111.222` lines in the log.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '我们需要在日志中找到 `IP: 111.222.111.222` 行。'
- en: 'Here''s how we''d do that:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要做的：
- en: '[PRE55]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The problem with the larger log file is that there are places where the target
    line has real information. These are mingled with lines that look similar, but
    are just examples. We''ll also find lines like `IP: 1.2.3.4` , which is irrelevant
    output. It turns out that there are several of these irrelevant kinds of lines
    that we''d like to ignore.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '较大日志文件的问题在于目标行中有真实信息的地方。这些与看似相似但只是示例的行混在一起。我们还会发现像`IP: 1.2.3.4`这样的行，这是无关紧要的输出。事实证明，有几种这些我们想要忽略的无关紧要的行。'
- en: This is a place where set intersection and set subtraction can be very helpful.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这是集合交集和集合减法非常有帮助的地方。
- en: How to do it...
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a set of items we''d like to ignore:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个我们想要忽略的项目集：
- en: '[PRE56]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Collect all entries from the log. We''ll use the `re` module for this, as shown
    earlier. Assume we have data that includes good addresses plus dummy and placeholder
    addresses from other parts of the log:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集日志中的所有条目。我们将使用`re`模块进行此操作，如前所示。假设我们的数据包括来自日志其他部分的良好地址以及虚拟和占位符地址：
- en: '[PRE57]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Remove items from the set of matches using a form of set subtraction. Here
    are two examples:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用集合减法形式从匹配集中删除项目。以下是两个示例：
- en: '[PRE58]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that both of these are operators which return new sets as their results.
    Neither of these will mutate the underlying set objects.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两者都是返回新集合作为其结果的运算符。这两者都不会改变基础集合对象。
- en: 'We''ll often use these in statements like this:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常在这样的语句中使用这些：
- en: '[PRE59]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This will assign the resulting set to a new variable, `valid_matches` , so that
    we can do the required processing on this new set.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把结果集分配给一个新变量`valid_matches`，这样我们就可以对这个新集合进行所需的处理。
- en: In this case, if the item is not present in the set, it does not raise a `KeyError`
    exception.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果项目不在集合中，它不会引发`KeyError`异常。
- en: How it works...
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A `set` object only tracks membership. An item is either in the `set` or it's
    not in the `set` . We specify the item we want to remove. Removing an item doesn't
    depend on an index position or a key value.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`对象仅跟踪成员资格。项目要么在`set`中，要么不在`set`中。我们指定要删除的项目。删除项目不依赖于索引位置或键值。'
- en: Because we have `set` operators, we can remove any of the items in one `set`
    from a target `set` . We don't need to process the items individually.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们有`set`运算符，我们可以从目标`set`中删除任何`set`中的项目。我们不需要逐个处理项目。
- en: There's more...
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We have several ways to remove items from a set:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以从集合中删除项目：
- en: In the example, we used the `difference()` method and the `-` operator. The
    `difference()` method behaves like an operator and creates a new set.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在示例中，我们使用了`difference()`方法和`-`运算符。`difference()`方法的行为类似于运算符，并创建一个新的集合。
- en: We can also use the `difference_update()` method. This will mutate a set in
    place. It does not return a value.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用`difference_update()`方法。这将就地改变一个集合。它不返回值。
- en: We can remove an individual item with the `remove()` method.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`remove()`方法删除单个项目。
- en: We can also remove an arbitrary item with the `pop()` method. This doesn't apply
    to this example very well because we can't control which item is popped.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用`pop()`方法删除任意项目。这在这个示例中并不适用得很好，因为我们无法控制弹出哪个项目。
- en: 'Here''s how the `difference_update()` method looks:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`difference_update()`方法的外观如下：'
- en: '[PRE60]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: First, we made a copy of the original `matches` set. This created a new set
    that we assigned the `valid_matches` set. We then applied the `difference_update()`
    method to remove the undesirable items from this set.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们复制了原始的`matches`集合。这创建了一个新的集合，我们将其分配给`valid_matches`集合。然后，我们应用了`difference_update()`方法，从这个集合中删除了不需要的项目。
- en: Since the set was mutated, no value is returned. Also, since the set is a copy,
    this doesn't modify the original `matches` set.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集合被改变，因此不会返回任何值。而且，由于集合是一个副本，这不会修改原始的`matches`集合。
- en: We could do something like this to use the `remove()` method. Note that `remove()`
    will raise an exception if an item is not present in the set.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用`remove()`方法。请注意，如果集合中不存在项目，`remove()`将引发异常。
- en: '[PRE61]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We tested to see if the item was in the `valid_matches` set before attempting
    to remove it. This is one way to avoid the raising a `KeyError` exception. The
    alternative is to use a `try:` statement to silence the exception.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试了一下`valid_matches`集合中是否存在该项目，然后再尝试删除它。这是避免引发`KeyError`异常的一种方法。另一种方法是使用`try:`语句来消除异常。
- en: The `pop()` method removes an arbitrary item. It both mutates the set and returns
    the item which was removed. If we try to pop items from an empty set, we'll raise
    a `KeyError` exception.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop()`方法删除一个任意项目。它既改变了集合，又返回了被删除的项目。如果我们尝试从空集合中弹出项目，我们将引发`KeyError`异常。'
- en: See also
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: In the *Using set methods and operators* recipe we'll look at other ways to
    create sets
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*使用集合方法和运算符*配方中，我们将看看创建集合的其他方法
- en: '![](image/614271.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![](image/614271.jpg)'
- en: Creating dictionaries – inserting and updating
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建字典-插入和更新
- en: A dictionary is one kind of Python mapping. The built-in type `dict` class provides
    a number of common features. There are some common variations on these features
    defined in the `collections` module.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是Python映射的一种。内置类型`dict`类提供了许多常见功能。在`collections`模块中定义了这些功能的一些常见变体。
- en: As we noted in the *Choosing a data structure* recipe, we'll use a dictionary
    when we have some key that we need to map to a given value. For example, we might
    want to map a single word to a long, complex definition of the word. Or perhaps
    some value to a count of the number of times that value has occurred in a dataset.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*选择数据结构*配方中所指出的，当我们有一些需要映射到给定值的键时，我们将使用字典。例如，我们可能希望将单词映射到单词的长而复杂的定义。或者将某个值映射到数据集中该值出现的次数。
- en: The *key and count* dictionary is very common. We'll look at a detailed recipe
    that shows how to initialize the dictionary and update the counter.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '*键和计数*字典非常常见。我们将看一个详细的配方，展示如何初始化字典并更新计数器。'
- en: In the *Using set methods and operators* recipe we looked at the arrival of
    customers at a business. In that recipe, we used a set to determine how many visits
    were required before the business had collected a complete set of visits.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *使用集合方法和运算符* 配方中，我们研究了客户到达企业的情况。在那个配方中，我们使用了一个集合来确定企业在收集完整的访问集之前需要多少次访问。
- en: Getting ready
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we'll look at creating a histogram that shows how many times
    each customer visited. In order to create some interesting data, we'll modify
    the sample generator that was used in the other recipe.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看看如何创建一个显示每个客户访问次数的直方图。为了创建一些有趣的数据，我们将修改在其他配方中使用的样本生成器。
- en: 'In the earlier example, we used a simple, uniform random number generator to
    pick the sequence of customers. This is an alternative way to pick customers that
    generates random numbers with a slightly different distribution:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的例子中，我们使用了一个简单的均匀随机数生成器来选择客户的顺序。这是选择生成具有稍微不同分布的随机数的客户的另一种方法：
- en: '[PRE62]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This uses a technique called **random walk** to generate the next customer ID
    number. It will start with zero and then make one of three changes. It may use
    the same customer or one of the two adjacent customer numbers. Using the expression
    `abs(p) % n` allows us to compute any integer value and map the number, *p* ,
    to the range 0 ≤ *p* < *n* .
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了一种称为**随机游走**的技术来生成下一个客户ID号。它将从零开始，然后进行三种更改之一。它可能使用相同的客户或两个相邻的客户号中的一个。使用表达式
    `abs(p) % n` 允许我们计算任何整数值，并将数字 *p* 映射到范围 0 ≤ *p* < *n*。
- en: 'Here''s a tool to generate some data that we can use to simulate the arrival
    of customers:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个工具，可以生成一些数据，我们可以用来模拟客户到达：
- en: '[PRE63]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This shows us how the `arrival2()` function simulates customers who tend to
    cluster around the starting value of customer zero. If we use this for the Coupon
    Collector's Test in the *Using set methods and operators* recipe, we'll see that
    this generator creates sample data that fails that test spectacularly. The clumpy
    arrival times mean we have to see an extraordinary number of customers before
    we've collected all eight distinct customers.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了 `arrival2()` 函数如何模拟倾向于围绕客户零的起始值聚集的客户。如果我们在 *使用集合方法和运算符* 配方中使用这个来进行优惠券收集器测试，我们会发现这个生成器创建的样本数据在这个测试中表现得非常糟糕。这种聚集到达时间意味着我们必须在收集到所有八个不同的客户之前看到非常多的客户。
- en: A histogram counts the number of occurrences of each customer. We'll use a dictionary
    to map from customer ID to the number of times we've seen the customer.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图统计每个客户的出现次数。我们将使用字典将客户ID映射到我们见过客户的次数。
- en: How to do it...
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create an empty dictionary with `{}` . We can also use `dict()` to create an
    empty dictionary. Since we''re going to create a histogram that counts the number
    of times each customer arrived, we''ll call it `histogram` :'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `{}` 创建一个空字典。我们也可以使用 `dict()` 创建一个空字典。由于我们将创建一个统计每个客户到达次数的直方图，我们将称其为 `histogram`：
- en: '[PRE64]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: For each customer number, if it's new, add an empty list to the dictionary.
    We can do this with an `if` statement or we can use the `setdefault()` method
    of the dictionary. We'll show the `if` statement version first. Later, we'll look
    at the `setdefault()` optimization.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个客户号，如果是新的，则向字典添加一个空列表。我们可以使用 `if` 语句来实现这一点，或者我们可以使用字典的 `setdefault()` 方法。我们将首先展示
    `if` 语句版本。稍后，我们将看看 `setdefault()` 优化。
- en: Increment the value in the dictionary.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加字典中的值。
- en: 'Here''s the resulting loop to count occurrences in a dictionary. It works by
    creating and updating items:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于计算字典中出现次数的循环。它通过创建和更新项目来工作：
- en: '[PRE65]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: When this is done, we'll have a count of the total number of simulated visits
    from each customer.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们将统计每个客户的模拟访问总数。
- en: We can turn this into a handy bar chart to compare the frequencies. We can compute
    some basic descriptive statistics including the mean and standard deviation to
    see if any customer is over-represented or under-represented.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其转换为一个方便的条形图来比较频率。我们可以计算一些基本的描述性统计数据，包括均值和标准差，以查看是否有任何客户被过度或不足地代表。
- en: How it works...
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The core feature of a dictionary is a mapping from an immutable value to an
    object of any kind. In this case, we've used an immutable number as the key, and
    another number as the value. As we count, we replace the value associated with
    the key.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的核心特性是从不可变值到任何类型的对象的映射。在这种情况下，我们使用一个不可变的数字作为键，另一个数字作为值。当我们计数时，我们替换与键关联的值。
- en: 'It can seem a little unusual to write:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 写起来可能有点不寻常：
- en: '[PRE66]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Or to write:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 或者写成：
- en: '[PRE67]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: and think of the value in the dictionary as being *replaced* . When we write
    an expression like `histogram[customer] + 1` we're computing a new integer object
    from two other integer objects. This new object replaces the old value in the
    dictionary.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 并将字典中的值视为*替换*。当我们写出像 `histogram[customer] + 1` 这样的表达式时，我们正在从另外两个整数对象计算一个新的整数对象。这个新对象替换了字典中的旧值。
- en: It's essential that dictionary key objects be immutable. We cannot use a `list`
    , `set` , or `dict` as the key in a dictionary mapping. We can, however, transform
    a list into an immutable tuple, or make a `set` into a `frozenset` so that we
    can use one of these more complex objects as a key.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 字典键对象的不可变性至关重要。我们不能使用 `list` 、`set` 或 `dict` 作为字典映射中的键。但是，我们可以将列表转换为不可变元组，或者将
    `set` 转换为 `frozenset` ，以便我们可以使用其中一个更复杂的对象作为键。
- en: There's more...
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We don''t have to use an `if` statement to add missing keys. We can use the
    `setdefault()` method of a dictionary, instead. Our loop would look like this:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必使用 `if` 语句来添加缺少的键。我们可以使用字典的 `setdefault()` 方法。我们的循环将如下所示：
- en: '[PRE68]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If the key value, `customer` , doesn't exist, a default value is provided. If
    the key does exist, the `setdefault()` method does nothing.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键值 `customer` 不存在，则提供默认值。如果键存在，则 `setdefault()` 方法不起作用。
- en: The `collections` module provides a number of alternative mappings that we can
    use instead of the default `dict` mapping.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections` 模块提供了许多替代映射，可以用来代替默认的 `dict` 映射。'
- en: '`defaultdict` : This collection saves us from having to write step two explicitly.
    We provide an initialization function as part of creating a `defaultdict` . We''ll
    look at an example soon.'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultdict`：这个集合使我们免于明确编写第二步。我们在创建`defaultdict`时提供一个初始化函数。我们很快会看一个例子。'
- en: '`OrderedDict` : This collection retains the keys in the order they were initially
    created. We''ll save this for the *Controlling the order of dict keys* recipe.'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderedDict`：这个集合保留了键最初创建的顺序。我们将把这个保存在*控制字典键的顺序*配方中。'
- en: '`Counter` : This collection does the entire **key-and-count** algorithm as
    it is being created. We''ll look at this soon too.'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Counter`：这个集合在创建时执行整个**键和计数**算法。我们很快也会看到这个。'
- en: 'Here''s the version using the `defaultdict` class:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`defaultdict`类的版本如下：
- en: '[PRE69]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We've created a `defaultdict` instance that will initialize any unknown key
    values using the `int()` function. We provide `int` —the function object—to the
    `defaultdict` constructor. The `defaultdict` will evaluate the given function
    object to create default values.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`defaultdict`实例，它将使用`int()`函数初始化任何未知的键值。我们将`int`-函数对象-提供给`defaultdict`构造函数。`defaultdict`将评估给定的函数对象以创建默认值。
- en: This allows us to simply use `histogram[item] += 1` . If the value of the `item`
    attribute was previous in the dictionary, it will be incremented. If the value
    of the `item` attribute was not already in the dictionary, the `int` function
    is evaluated and that becomes the default value.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以简单地使用`histogram[item] += 1`。如果`item`属性的值先前在字典中，它将被递增。如果`item`属性的值尚未在字典中，将评估`int`函数，并成为默认值。
- en: The other way we can do this is by creating a `Counter` object. We need to import
    the `Counter` class so that we can build the `Counter` object from the raw data.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过创建一个`Counter`对象来做到这一点。我们需要导入`Counter`类，以便我们可以从原始数据构建`Counter`对象。
- en: '[PRE70]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: When we create a `Counter` from a source of data, the class will scan the data
    and count the distinct occurrences. This class implements the entire recipe.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从数据源创建一个`Counter`时，该类将扫描数据并计算不同的出现次数。这个类实现了整个配方。
- en: 'Here''s how the result looks:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE71]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note that a `Counter` object displays the values in descending order of count
    value. An `OrderedDict` object will display the values in the order in which the
    keys were created. A `dict` maintains no order.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Counter`对象以计数值的降序显示值。`OrderedDict`对象将按照键创建的顺序显示值。`dict`不保持顺序。
- en: 'If we want to impose an order on the keys, we can use:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想对键施加顺序，我们可以使用：
- en: '[PRE72]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: See also
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In the *Removing from dictionaries – the pop() method and the del statement*
    recipe we'll look at how dictionaries can be modified by removing items
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*从字典中删除- pop()方法和del语句*配方中，我们将看看如何通过删除项目来修改字典
- en: In the *Controlling the order of dict keys* recipe we'll look at how we can
    control the order of keys in a dictionary
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*控制字典键的顺序*配方中，我们将看看如何控制字典中键的顺序
- en: Removing from dictionaries – the pop() method and the del statement
  id: totrans-523
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从字典中删除- pop()方法和del语句
- en: 'A common use case for a dictionary is as an **associative store** : we can
    keep an association between key and value objects. This means that we may be doing
    any of the **CRUD** operations on an item in the dictionary.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的一个常见用例是作为**关联存储**：我们可以在键和值对象之间保持关联。这意味着我们可能在字典中对项目进行任何**CRUD**操作。
- en: Create a new key and value pair
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的键值对
- en: Retrieve the value associated with a key
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索与键关联的值
- en: Update the value associated with a key
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新与键关联的值
- en: Delete the key (and value) from the dictionary
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字典中删除键（和值）
- en: 'We have two common variations on this theme:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种常见的变体：
- en: We have the in-memory dictionary, `dict` , and the variations on this theme
    in the `collections` module. The collection only exists while our program is running.
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有内存中的字典`dict`，以及`collections`模块中对这个主题的变体。这个集合只在我们的程序运行时存在。
- en: We also have persistent storage in the `shelve` and `dbm` modules. The data
    collection is a persistent file in the file system.
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还在`shelve`和`dbm`模块中有持久存储。数据集合是文件系统中的持久文件。
- en: These are very similar, the distinctions between a `shelf.Shelf` and `dict`
    object are minor. This allows us to experiment with a `dict` and switch to a `Shelf`
    without making dramatic changes to a program.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这些非常相似，`shelf.Shelf`和`dict`对象之间的区别很小。这使我们可以在不对程序进行重大更改的情况下尝试`dict`并切换到`Shelf`。
- en: A server process will often have multiple, concurrent sessions. When sessions
    are created, they can be placed into `dict` or `shelf` . When the session exits,
    the item can be deleted or perhaps archived.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器进程通常会有多个并发会话。当会话创建时，它们可以被放入`dict`或`shelf`中。当会话退出时，项目可以被删除或存档。
- en: We'll simulate this concept of a service that handles multiple requests. We'll
    define a service that works in a simulated environment with a single processing
    thread. We'll avoid concurrency and multi-processing considerations.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模拟处理多个请求的服务概念。我们将定义一个在模拟环境中使用单个处理线程的服务。我们将避免并发和多处理考虑。
- en: Getting ready
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: 'In the casino game of *Craps* , a player can (and often does) create and remove
    multiple bets during a game. The rules can be bafflingly complex, but the core
    concepts include four kinds of bets a player might make:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Craps*赌场游戏中，玩家可以（并经常）在游戏中创建和删除多个赌注。规则可能非常复杂，但核心概念包括玩家可能进行的四种赌注：
- en: 'A **pass line** bet: For our purposes, this is how one buys in at the start
    of a game.'
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过线**投注：对于我们的目的，这是游戏开始时的购买方式。'
- en: 'A **pass line odds** bet: This is not marked on the playing surface in a casino,
    but it''s a real bet. This bet pays off at different odds than the pass line bet,
    and has some statistical advantages. It can be removed, also.'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过线赔率**投注：这在赌场的游戏表面上没有标记，但这是一个真正的赌注。这个赌注的赔率与过线赌注不同，并且具有一些统计优势。它也可以被移除。'
- en: 'A **come line** bet: This can be placed during a game.'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来线**投注：这可以在游戏进行中放置。'
- en: 'A **come line odds** bet: This, too, is placed during a game. This can be taken
    down, also.'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**come line odds**赌注：这也是在游戏中下注的。这也可以被取消。'
- en: The best way to understand all of these betting choices is to simulate the game
    and a player. The game will need to track all of the bets a player places. This
    can be done using a dictionary where bets are inserted, and removed when they
    pay off, the player takes them down, or the game ends.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 了解所有这些赌注选择的最佳方法是模拟游戏和玩家。游戏将需要跟踪玩家下注的所有赌注。这可以通过使用一个字典来完成，其中下注被插入，当它们得到回报时被移除，玩家将它们取消，或者游戏结束。
- en: We'll simplify parts of the simulation so that we can focus on using a dictionary
    properly. This is handled best as a class definition so that we can properly isolate
    bets and game rules from player rules. For more information on class design, see
    [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects") ,
    *Basics of Classes and Objects* .
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简化模拟的部分，以便我们可以专注于正确使用字典。这最好作为一个类定义来处理，这样我们可以正确地将赌注和游戏规则与玩家规则隔离开来。有关类设计的更多信息，请参见[第6章](text00070.html#page
    "第6章。类和对象的基础")，*类和对象的基础*。
- en: How to do it...
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create the overall dictionary object:'
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建整个字典对象：
- en: '[PRE73]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Define the key and value for each object we''re inserting into the dictionary.
    For example, the key might be a description of the bet: `come` , `pass` , `come
    odds` , or `pass odds` . The value might be the amount of the bet. It''s common
    to avoid working in currency, and instead work in units of the table minimum bet.
    Usually these are simple integer multiples, most often just the integer value
    one to represent the minimum bet.'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们要插入字典的每个对象定义键和值。例如，键可以是赌注的描述：`come`，`pass`，`come odds`或`pass odds`。值可以是赌注的金额。通常我们避免使用货币，而是使用桌面最低赌注的单位。通常这些都是简单的整数倍数，最常见的是整数值1来表示最低赌注。
- en: 'Enter values as the bets are being placed:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下注时输入值：
- en: '[PRE74]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: For a concrete example, we'd have `working_bets["pass"] = 1` .
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 具体例子，我们会有`working_bets["pass"] = 1`。
- en: 'Remove values as bets are paid off or taken down. We can use the `del` statement
    or the dictionary `pop()` method:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着赌注得到回报或取消，删除值。我们可以使用`del`语句或字典的`pop()`方法：
- en: '[PRE75]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: If the key is not present, this will raise a `KeyError` exception.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键不存在，这将引发`KeyError`异常。
- en: The `pop()` method both mutates the dictionary and returns a value associated
    with the key. If the key doesn't exist, this will raise an `KeyError` exception.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop()`方法既改变了字典，又返回与键相关联的值。如果键不存在，这将引发`KeyError`异常。'
- en: '[PRE76]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: It turns out that `pop()` can be given a default value. If the key is not present,
    it will not raise an exception, but will return the default value instead.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，`pop()`可以给出一个默认值。如果键不存在，它不会引发异常，而是返回默认值。
- en: How it works...
  id: totrans-556
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Because a dictionary is a mutable object, we can remove keys from a dictionary.
    This will delete both the key and the value object associated with the key.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字典是一个可变对象，我们可以从字典中删除键。这将同时删除键和与键相关联的值对象。
- en: If we try to delete a key which does not exist, we'll raise a `KeyError` exception.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试删除一个不存在的键，将引发`KeyError`异常。
- en: 'We can replace an object in a dictionary with statements like this:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用如下语句替换字典中的对象：
- en: '[PRE77]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The key—`come` —remains in the dictionary. The old value, `1` , is no longer
    required and will be replaced by the new value, `None` . This is not the same
    as deleting an item.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 键—`come`—仍然保留在字典中。旧值`1`不再需要，并将被新值`None`替换。这与删除项目不同。
- en: There's more...
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can only remove the keys of a dictionary. As we noted earlier, we can set
    the value to `None` to remove the value, leaving the key in the dictionary.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能删除字典的键。正如我们之前提到的，我们可以将值设置为`None`以删除该值，但保留字典中的键。
- en: 'When we use a dictionary in a `for` statement, the target variable will be
    assigned key values. For example:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`for`语句中使用字典时，目标变量将被分配键值。例如：
- en: '[PRE78]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This will print all of the key values, `bet_name,` and the bet amount associated
    with that bet in the `working_bets` dictionary.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出`working_bets`字典中与该赌注相关的所有键值，`bet_name`和赌注金额。
- en: See also
  id: totrans-567
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: In the *Creating dictionaries – inserting and updating* recipe we'll look at
    how we create dictionaries and fill them with keys and values
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*创建字典-插入和更新*的示例中，我们将看看如何创建字典并填充它们的键和值
- en: In the *Controlling the order of dict keys* recipe we'll look at how we can
    control the order of keys in a dictionary
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*控制字典键的顺序*的示例中，我们将看看如何控制字典中键的顺序
- en: Controlling the order of dict keys
  id: totrans-570
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制字典键的顺序
- en: In the *Creating dictionaries – inserting and updating* recipe we looked at
    the basics of creating a dictionary object. In many cases, we'll put items into
    a dictionary and fetch items from a dictionary individually. The idea of an order
    to the keys doesn't even enter into the problem.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在*创建字典-插入和更新*的示例中，我们看了一下创建字典对象的基础知识。在许多情况下，我们会将项目放入字典中，并从字典中单独获取项目。键的顺序甚至不会成为问题。
- en: There are some cases where we might want to display the contents of a dictionary.
    In this case, we often want to impose some order on the keys. For example, when
    we work with web services, the messages are often dictionaries encoded in JSON
    notation. In many cases we'd like to keep the keys in a particular order so that
    the message is easier to understand when it's displayed in a debugging log.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，我们可能想要显示字典的内容。在这种情况下，我们通常希望对键施加一些顺序。例如，当我们使用Web服务时，消息通常是以JSON表示的字典。在许多情况下，我们希望保持特定顺序的键，以便在调试日志中显示消息时更容易理解。
- en: As another example, when we read data with the `csv` module each row from a
    spreadsheet can be represented as a dictionary. In this case, we almost always
    want to keep the keys in a given order so that the dictionary follows the structure
    of the source file.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，当我们使用`csv`模块读取数据时，电子表格中的每一行都可以表示为一个字典。在这种情况下，我们几乎总是希望保持键的顺序，以使字典遵循源文件的结构。
- en: Getting ready
  id: totrans-574
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'A dictionary is a good model for a row from a spreadsheet. This works particularly
    well when the spreadsheet has a heading row with column titles. Let''s say we
    have some data collected in a spreadsheet that looks like this:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是电子表格中的一行很好的模型。当电子表格有标题行和列标题时，这种模型特别有效。假设我们在电子表格中收集了一些数据，看起来像这样：
- en: '| **final** | **least** | **most** |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '| **final** | **least** | **most** |'
- en: '| 5 | 0 | 6 |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 0 | 6 |'
- en: '| -3 | -4 | 0 |'
  id: totrans-578
  prefs: []
  type: TYPE_TB
  zh: '| -3 | -4 | 0 |'
- en: '| -1 | -3 | 1 |'
  id: totrans-579
  prefs: []
  type: TYPE_TB
  zh: '| -1 | -3 | 1 |'
- en: '| 3 | 0 | 4 |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0 | 4 |'
- en: 'This shows the final outcome, the lowest amount the player had, and the highest
    amount the player had. We can use the `csv` module to read this data for further
    analysis:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了最终结果，玩家拥有的最少金额和最多金额。我们可以使用`csv`模块读取这些数据进行进一步分析：
- en: '[PRE79]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Each row of the spreadsheet is a dictionary. However, there's something peculiar
    about each row. It's not obvious, but the order of the keys in the row doesn't
    match the order of the keys in the original `.csv` file.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 电子表格的每一行都是一个字典。然而，每一行都有一些奇怪的地方。虽然不明显，但行中键的顺序与原始`.csv`文件中键的顺序不匹配。
- en: Why is that? The default `dict` structure does not guarantee any ordering for
    the keys. What if we want to show the keys in a specific order?
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？默认的`dict`结构不保证键的任何顺序。如果我们想按特定顺序显示键会怎样？
- en: How to do it...
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We have two common ways to force an ordering on the keys of a dictionary:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种常见的方法来强制字典键的顺序：
- en: 'Create an `OrderedDict` : This keeps keys in the order they are created'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`OrderedDict`：这可以保持键的创建顺序
- en: 'Use `sorted()` on the keys: This puts the keys into a sorted order'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在键上使用`sorted()`：这会将键放入排序顺序
- en: Most of the time, we can simply use `OrderedDict` instead of `dict()` or `{}`
    to create an empty dictionary. This will allow us to create keys in the required
    order.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们可以简单地使用`OrderedDict`而不是`dict()`或`{}`来创建一个空字典。这将允许我们按所需的顺序创建键。
- en: Sometimes, however, we can't easily replace a `dict` instance with an `OrderedDict`
    instance. We've chosen this example because we can't trivially replace the `dict`
    class that is created by `csv` .
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们不能轻松地用`OrderedDict`实例替换`dict`实例。我们选择了这个例子，因为我们不能轻易地替换由`csv`创建的`dict`类。
- en: 'Here''s how we can force the row''s `dict` keys to follow the order of the
    columns in the original `.csv` file:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何强制行的`dict`键遵循原始`.csv`文件中列的顺序的方法：
- en: Get the preferred order of keys. In the case of a `DictReader` the `fieldnames`
    attribute of the reader object has the proper order information.
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取键的首选顺序。对于`DictReader`，读取器对象的`fieldnames`属性具有正确的顺序信息。
- en: 'Use a generator expression to create the fields in the proper order. We''ll
    have something like this:'
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用生成器表达式按正确顺序创建字段。我们会有类似这样的东西：
- en: '[PRE80]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create an `OrderedDict` from the generator. Here''s the whole sequence:'
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从生成器创建一个`OrderedDict`。整个顺序如下：
- en: '[PRE81]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This builds dictionaries with keys in a specific order.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以按特定顺序构建字典。
- en: 'As an optimization, we can combine the two steps into a single step:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 作为优化，我们可以将这两个步骤合并为一个步骤：
- en: '[PRE82]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This will build an ordered version of the `raw_row` object.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建一个`raw_row`对象的有序版本。
- en: How it works...
  id: totrans-601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `OrderedDict` class keeps the keys in the order they are created. This class
    is very handy for assuring a structure remains in an order that's easier to understand.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderedDict`类保持键的创建顺序。这个类对于确保结构保持更容易理解的顺序非常方便。'
- en: There's a small performance cost to this, of course. The default `dict` class
    computes a hash for each key, and the hash values are used to locate a space in
    the dictionary. This tends to use more memory, but performs extremely quickly.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这会有一些性能成本。默认的`dict`类为每个键计算一个哈希值，并使用哈希值来定位字典中的空间。这倾向于使用更多内存，但执行速度非常快。
- en: The `OrderedDict` uses some additional storage to retain the ordering for the
    keys. This requires some additional time when a key is created. If key creation
    tends to dominate the algorithm, we'll notice the slowdown. If key retrieval tends
    to dominate the design, then we won't see much change when using an `OrderedDict`
    .
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderedDict`使用一些额外的存储来保持键的顺序。这在创建键时需要额外的时间。如果键的创建倾向于主导算法，我们会注意到减速。如果键的检索倾向于主导设计，那么使用`OrderedDict`时我们不会看到太多变化。'
- en: There's more...
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In some packages—like `pymongo` —there are some alternative ordered dictionary
    implementations.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些包中——比如`pymongo`——有一些替代的有序字典实现。
- en: See [https://api.mongodb.org/python/current/api/bson/son.html](https://api.mongodb.org/python/current/api/bson/son.html)
    .
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://api.mongodb.org/python/current/api/bson/son.html](https://api.mongodb.org/python/current/api/bson/son.html)。
- en: The `bson.son` module includes the `SON` class which is a very handy ordered
    dictionary. This is focused on the needs of the Mongo database, but it works very
    nicely for other applications, also.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '`bson.son`模块包括`SON`类，这是一个非常方便的有序字典。它专注于Mongo数据库的需求，但也非常适用于其他应用。'
- en: See also
  id: totrans-609
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In the *Creating dictionaries – inserting and updating* recipe we'll look at
    how we can create dictionaries.
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*创建字典-插入和更新*的示例中，我们将看看如何创建字典。
- en: In the *Removing from dictionaries – the pop() method and the del statement*
    recipe we'll look at how dictionaries can be modified by removing items.
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*从字典中删除-使用pop()方法和del语句*的示例中，我们将看看如何通过删除项目来修改字典。
- en: Handling dictionaries and sets in doctest examples
  id: totrans-612
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在doctest示例中处理字典和集合
- en: We will look at one small aspect of writing a proper test in this recipe. We'll
    look at testing overall in [Chapter 11](text00120.html#page "Chapter 11. Testing")
    , *Testing* . The data structures in this chapter—`dict` and `set` —both include
    some complexity when it comes to writing proper tests.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个示例中看一下编写正确测试的一个小方面。我们将在[第11章](text00120.html#page "第11章。测试")中看到整体测试，*测试*。在本章中的数据结构——`dict`和`set`——在编写正确测试时都包含一些复杂性。
- en: Since `dict` keys (and `set` members) have no order, our test results will have
    a problem. We need to have a repeatable result, but there's no way to guarantee
    the order of the collection. This can lead to test results which don't properly
    match our expectations.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`dict`键（和`set`成员）没有顺序，我们的测试结果会有问题。我们需要有可重复的结果，但没有办法保证集合的顺序。这可能导致测试结果与我们的期望不符。
- en: 'Assume that our test expects the set `{"Poe", "E", "Near", "A", "Raven"}` .
    Since there''s no defined order to a set, Python can display this set in any order:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的测试期望集合`{"Poe", "E", "Near", "A", "Raven"}`。由于集合没有定义的顺序，Python可以以任何顺序显示这个集合：
- en: '[PRE83]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The elements are the same, but the overall line of output from Python isn't
    the same. The `doctest` package relies on the literal output from the example
    being *identical* to the output produced by Python's REPL.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 元素是相同的，但来自Python的整体输出并不相同。`doctest`包依赖于示例的文字输出与Python的REPL产生的输出*完全相同*。
- en: How can we be sure our doctest examples really work?
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确保我们的doctest示例真的有效？
- en: Getting ready
  id: totrans-619
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s look at an example that involves a `set` object:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个涉及“集合”对象的例子：
- en: '[PRE84]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This example is simple. The results, however, will often vary each time we process
    this example. Indeed, when working on secure algorithms, it's considered important
    to have the order vary. This is called the **hash randomization** problem—when
    the hashed values are predictable, it can become a security vulnerability.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很简单。然而，结果往往会在每次处理这个例子时有所不同。事实上，在处理安全算法时，让顺序变化被认为是很重要的。这被称为**哈希随机化**问题——当哈希值是可预测的时，它可能成为安全漏洞。
- en: When we use the `doctest` module, we need to have examples that are perfectly
    consistent. As we'll see in [Chapter 11](text00120.html#page "Chapter 11. Testing")
    , *Testing* , the `doctest` module is clever about locating examples, but it's
    not a genius about assuring that actual results match expected results.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`doctest`模块时，我们需要有完全一致的示例。正如我们将在[第11章](text00120.html#page "第11章。测试")中看到的，*测试*，`doctest`模块在定位示例方面很聪明，但在确保实际结果与预期结果匹配方面并不是一个天才。
- en: And the problem is—mostly—confined to sets and dictionaries. These are two collections
    where key ordering cannot be guaranteed because of hash randomization.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 问题主要是出现在集合和字典中。这两个集合中，由于哈希随机化，无法保证键的顺序。
- en: How to do it...
  id: totrans-625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: When we need to be sure that items in a set or dictionary have a particular
    order, we can convert the collection to a sorted sequence.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要确保集合或字典中的项目具有特定顺序时，我们可以将集合转换为排序序列。
- en: 'We have two choices:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种选择：
- en: Convert a set to a sorted sequence
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将集合转换为排序序列
- en: Convert a dictionary to a sorted sequence of (key, value) two-tuples
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字典转换为排序的(key, value)两元组序列
- en: 'Both of these recipes are similar. Here''s what we need to do to force a set
    into a normalized structure:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个配方都很相似。这是我们需要做的事情，以将一个集合强制转换为一个规范化的结构：
- en: '[PRE85]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'For a dictionary, we''ll often use this:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字典，我们经常会使用这个：
- en: '[PRE86]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This will extract each item in the dictionary as a `(key, value)` two-tuple.
    The tuples will be sorted into order by the key. The resulting sequence will be
    turned into a list so that it can be compared with the expected results.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提取字典中的每个项目作为“(key, value)”两元组。元组将按键排序。生成的序列将被转换为列表，以便与预期结果进行比较。
- en: How it works...
  id: totrans-635
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When confronted with a collection that fails to impose an order, we have to
    locate a collection with two properties:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对一个不强加顺序的集合时，我们必须找到一个具有两个属性的集合：
- en: The same content
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的内容
- en: Some kind of consistent order
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某种一致的顺序
- en: 'Python''s built-in structures are variations on three themes:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: Python的内置结构是三个主题的变体：
- en: Sequence
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列
- en: Set
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Mapping
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射
- en: Since the only one with a guaranteed order is the sequence, we can convert sets
    and mappings into sequences. This, it turns out, is easy to do with the `sorted()`
    function.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 由于唯一具有保证顺序的是序列，我们可以将集合和映射转换为序列。结果表明，使用`sorted()`函数很容易做到这一点。
- en: For sets, we'll sort the items. For mappings, we'll sort the `(key, value)`
    two-tuples. This assures us that the output from our example is precisely what
    is required.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集合，我们将对项目进行排序。对于映射，我们将对“(key, value)”两元组进行排序。这可以确保我们的示例输出恰好符合要求。
- en: There's more...
  id: totrans-645
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We''ll look at several other kinds of data that has minor variations in [Chapter
    11](text00120.html#page "Chapter 11. Testing") , *Testing* :'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第11章](text00120.html#page "第11章。测试")中看到几种数据的微小变化，*测试*：
- en: Floating-point numbers
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数
- en: Dates
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期
- en: Object ID's and Tracebacks
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象ID和回溯
- en: Random sequences
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机序列
- en: All of these need to be put into a context with a predictable output so that
    tests will work repeatedly. The two data structures, `set` and `dict` , are the
    subjects of this chapter. We'll cover other variations in the relevant chapters.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都需要放入一个具有可预测输出的上下文中，以便测试能够重复工作。两种数据结构，“集合”和“字典”，是本章的主题。我们将在相关章节中涵盖其他变化。
- en: Understanding variables, references, and assignment
  id: totrans-652
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解变量、引用和赋值
- en: How do variables really work? What happens when we assign a mutable object to
    two variables? We can easily have two variables that share references to a common
    object; this can lead to potentially confusing results when the shared object
    is mutable. The rules are simple and the consequences are generally obvious.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 变量真正是如何工作的？当我们将一个可变对象分配给两个变量时会发生什么？我们很容易有两个变量共享对一个公共对象的引用；当共享对象是可变的时，这可能导致潜在的混乱结果。规则很简单，后果通常是显而易见的。
- en: 'We''ll focus on this rule: **Python shares references. It doesn''t copy data**
    .'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于这个规则：**Python共享引用。它不复制数据**。
- en: We need to look at what this rule on reference sharing means.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要看看这个关于引用共享的规则意味着什么。
- en: 'We''ll create two data structures, one is mutable and one is immutable. We''ll
    use two kinds of sequences, although we could do something similar with two kinds
    of sets:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两种数据结构，一种是可变的，一种是不可变的。我们将使用两种序列，尽管我们可以使用两种集合做类似的事情：
- en: 'Getting ready We''ll create two data structures, one is mutable and one is
    immutable. We''ll use two kinds of sequences, although we could do something similar
    with two kinds of sets:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好了我们将创建两种数据结构，一种是可变的，一种是不可变的。我们将使用两种类型的序列，尽管我们也可以用两种类型的集合做类似的事情：
- en: '[PRE87]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The mutable data structure can be changed and shared. The immutable data structure
    is also shared, but it's much harder to tell that it's being shared.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 可变数据结构可以被改变和共享。不可变数据结构也可以被共享，但很难确定它是否被共享。
- en: We can't easily do this with a mapping because Python doesn't offer a handy
    immutable mapping.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法轻松地对映射进行这样的操作，因为Python没有提供方便的不可变映射。
- en: How to do it...
  id: totrans-661
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Assign each collection to an additional variable. This will create two references
    to the structure:'
  id: totrans-662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个集合分配给一个额外的变量。这将创建两个对结构的引用：
- en: '[PRE88]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: we now have two references to the list `[1, 1, 2, 3, 5, 8]` and two references
    to the tuple `(5, 8, 13, 21)` .
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个对列表`[1, 1, 2, 3, 5, 8]`的引用和两个对元组`(5, 8, 13, 21)`的引用。
- en: 'We can confirm this using the `is` operator. This determines if two variables
    refer to the same underlying object:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`is`运算符来确认这一点。这确定了两个变量是否指向同一个基础对象：
- en: '[PRE89]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Make a change to one of the two references to the collection. For mutable structures,
    we have methods like `append()` or `add()` :'
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对集合的两个引用中的一个进行更改。对于可变结构，我们有`append()`或`add()`等方法：
- en: '[PRE90]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: For a list structure, the `+=` assignment is really an internal use of the `extend()`
    method.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表结构，`+=`赋值实际上是内部使用`extend()`方法。
- en: 'We can do a similar thing with an immutable structure:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用不可变结构做类似的事情：
- en: '[PRE91]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Since a tuple has no method like `extend()` , the += will build a new tuple
    object and replace the value of `immutable` with that new object.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元组没有像`extend()`这样的方法，`+=`将构建一个新的元组对象，并用该新对象替换`immutable`的值。
- en: 'Look at the other reference to the structure:'
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看结构的另一个引用：
- en: '[PRE92]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The two variables `mutable` and `mutable_b` refer to the same underlying object.
    Because of that, we can use either variable to change the object and see the change
    reflected in the other variable's value.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 两个变量`mutable`和`mutable_b`指向同一个基础对象。因此，我们可以使用任一变量来改变对象，并看到改变反映在另一个变量的值中。
- en: The two variables, `immutable_b` and `immutable,` started out referring to the
    same object. Because the object cannot be mutated in place, a change to one variable
    means that a new object is assigned to that variable. The other variable remains
    firmly attached to the original object.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 两个变量`immutable_b`和`immutable`最初指向同一个对象。因为对象无法就地突变，对一个变量的更改意味着一个新对象被分配给该变量。另一个变量仍然牢固地附着在原始对象上。
- en: How it works...
  id: totrans-677
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In Python, a variable is a label that's attached to an object. We can think
    of them like adhesive notes in bright colors that we stick on the object temporarily.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，变量是附加到对象的标签。我们可以把它们想象成暂时贴在对象上的明亮颜色的粘贴纸。
- en: A variable is a reference to the underlying object. When we assign an object
    to a variable, we're giving a name to a reference to the underlying object. When
    we use a variable in an expression, Python locates the object to which the variable
    refers.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是对基础对象的引用。当我们将一个对象分配给一个变量时，我们给基础对象的引用起了一个名字。当我们在表达式中使用一个变量时，Python会定位变量所指的对象。
- en: For mutable objects, a method of an object can modify the object's state. All
    variables that refer to the object will reflect the state change because a variable
    is just a reference, not a complete copy.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可变对象，对象的方法可以修改对象的状态。所有引用对象的变量将反映状态的改变，因为变量只是一个引用，而不是完全的副本。
- en: 'When we use a variable on an assignment statement there are two possible actions:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在赋值语句中使用一个变量时，有两种可能的操作：
- en: For mutable objects that provide definitions for appropriate assignment operators
    like `+=` , the assignment is transformed into a special method; in this case,
    `__iadd__` . The special method will mutate the object's internal state.
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于提供适当赋值运算符定义的可变对象，赋值被转换为一个特殊方法；在这种情况下，是`__iadd__`。这个特殊方法将改变对象的内部状态。
- en: For immutable objects that do not provide definitions for assignment like `+=`
    , the assignment is transformed into `=` and `+` . A new object is built by the
    `+` operator and the variable name is attached to that new object. Other variables
    which previously referred to the object being replaced are not affected, they
    continue to refer to old objects.
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不提供`+=`赋值定义的不可变对象，赋值被转换为`=`和`+`。`+`运算符建立了一个新对象，并将变量名附加到该新对象。先前引用被替换的对象的其他变量不受影响，它们继续引用旧对象。
- en: Python tracks the number of places that an object is referenced. When the number
    of references becomes zero, the object is no longer used anywhere, and can be
    removed from memory.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: Python跟踪对象被引用的次数。当引用次数变为零时，对象不再被任何地方使用，可以从内存中删除。
- en: There's more...
  id: totrans-685
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Languages like C++ or Java have primitive types in addition to objects. In these
    languages, a `+=` statement leverages a feature of the hardware instructions or
    the Java Virtual Machine to tweak the value of a primitive type.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 像C++或Java这样的语言除了对象之外还有原始类型。在这些语言中，`+=`语句利用了硬件指令或Java虚拟机的特性来调整原始类型的值。
- en: 'Python doesn''t have this kind of optimization. Numbers are immutable objects.
    When we do something like this:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有这种优化。数字是不可变对象。当我们做这样的事情时：
- en: '[PRE93]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We''re not tweaking the internal state of the object `355` . This does not
    rely on the internal `__iadd__` special method. This behaves as if we had written:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是在调整对象`355`的内部状态。这不依赖于内部的`__iadd__`特殊方法。这的行为就像我们写了：
- en: '[PRE94]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The expression `a + 113` is evaluated, and a new immutable integer object is
    created. This new object is given the label `a` . The old value previously assigned
    to `a` is no longer needed.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`a + 113`被评估，一个新的不可变整数对象被创建。这个新对象被标记为`a`。以前分配给`a`的旧值不再需要。
- en: See also
  id: totrans-692
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In the *Making shallow and deep copies of objects* recipe we'll look at ways
    we can copy mutable structures
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*制作对象的浅复制和深复制*中，我们将看看如何复制可变结构
- en: Making shallow and deep copies of objects
  id: totrans-694
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作对象的浅复制和深复制
- en: 'Throughout this chapter, we''ve talked about how assignment statements share
    references to objects. Objects are not normally copied. When we write:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们谈到了赋值语句共享对对象的引用。对象通常不会被复制。当我们写：
- en: '[PRE95]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: we now have two references to the same underlying object. If `b` is a list,
    both `a` and `b` are references to the same, mutable list.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个对同一基础对象的引用。如果`b`是一个列表，`a`和`b`都是对同一个可变列表的引用。
- en: As we saw in the *Understanding variables, references, and assignment* recipe,
    a change to the `a` variable changes the list object that both `a` and `b` refer
    to.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*理解变量、引用和赋值*中看到的，对`a`变量的更改会改变`a`和`b`都引用的列表对象。
- en: Most of the time, this is the behavior we want. There are rare situations in
    which we want to actually have two independent objects created from one original
    object.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这是我们想要的行为。在极少数情况下，我们实际上希望从一个原始对象创建两个独立的对象。
- en: 'There are two ways to break the connection that exists when two variables are
    references to the same underlying object:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个变量引用同一基础对象时，有两种方法可以断开连接：
- en: Making a shallow copy of the structure
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作结构的浅复制
- en: Making a deep copy of the structure
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深复制结构
- en: Getting ready
  id: totrans-703
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We have to make special arrangements to make a copy of an object. We've seen
    several kinds of syntax for doing that.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做特殊安排来复制一个对象。我们已经看到了几种用于复制的语法。
- en: '**Sequences** – `list` and `tuple` : We can use `sequence[:]` to copy a sequence
    by using an empty slice expression. We can also use `sequence.copy()` to make
    a copy of a variable named `sequence` .'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列** - `list`和`tuple`：我们可以使用`sequence[:]`通过使用空切片表达式来复制一个序列。我们也可以使用`sequence.copy()`来复制一个名为`sequence`的变量。'
- en: '**Mappings** – `dict` : We can use `mapping.copy()` to copy a dictionary named
    `mapping` .'
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射** - `dict`：我们可以使用`mapping.copy()`来复制一个名为`mapping`的字典。'
- en: '**Sets** – `set` and `frozenset` : We can use `someset.copy()` to clone a set
    named `someset` .'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合** - `set`和`frozenset`：我们可以使用`someset.copy()`来克隆一个名为`someset`的集合。'
- en: What's important is that these are all *shallow* copies.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是这些都是*浅*复制。
- en: Shallow means that two collections will contain references to the same underlying
    objects. If the underlying objects are immutable numbers or strings, this distinction
    doesn't matter. When we can't mutate items inside the collection, the items are
    simply replaced.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 浅意味着两个集合将包含对相同基础对象的引用。如果基础对象是不可变的数字或字符串，则这种区别并不重要。当我们无法改变集合中的项目时，项目将被简单地替换。
- en: If we have `a = [1, 1, 2, 3]` , we can't perform any mutation on `a[0]` . The
    number `1` in `a[0]` has no internal state. We can only replace the object.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有`a = [1, 1, 2, 3]`，我们无法对`a[0]`进行任何变异。`a[0]`中的数字`1`没有内部状态。我们只能替换对象。
- en: 'Questions arise, however, when we have a collection that involves mutable objects.
    First, we''ll create an object, then we''ll create a copy:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当涉及到可变对象的集合时，会出现问题。首先，我们将创建一个对象，然后我们将创建一个副本：
- en: '[PRE96]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We have to make a shallow copy of the dictionary. The two copies look alike
    because they both contain references to the same objects. There's a shared reference
    to the immutable string `a` . And a shared reference to the mutable list `[1,
    1, 2, 3]` . We can display the value of `another_dict` to see that it looks like
    `some_dict` .
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须对字典进行浅复制。这两个副本看起来是一样的，因为它们都包含对相同对象的引用。对于不可变字符串`a`有一个共享引用。对于可变列表`[1, 1, 2,
    3]`也有一个共享引用。我们可以显示`another_dict`的值，看看它是否与`some_dict`相似。
- en: '[PRE97]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Here''s what happens when we update the shared list that''s inside the copy
    of the dictionary:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更新字典副本中的共享列表时会发生什么：
- en: '[PRE98]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: We made a change to a mutable `list` object that's shared between two `dict`
    objects, `some_dict` and `another_dict` .
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对一个可变的`list`对象进行了更改，这个对象在`some_dict`和`another_dict`两个`dict`对象之间共享。
- en: 'We can see that the item is shared by using the `id()` function:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`id()`函数来查看项目是否共享：
- en: '[PRE99]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Because the two `id()` values are the same, these are the same underlying object.
    The value associated with the key `a` is the same mutable list in both `some_dict`
    and `another_dict` . We can also use the `is` operator to see that they're the
    same object.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 因为两个`id()`值相同，这些是同一个基础对象。与键`a`关联的值在`some_dict`和`another_dict`中是相同的可变列表。我们还可以使用`is`运算符来查看它们是否是同一个对象。
- en: 'This mutation effect works for `list` collections that contain other `list`
    objects as items, also:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变异效果也适用于包含其他`list`对象的`list`集合：
- en: '[PRE100]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: We've made a copy of an object, `some_list` , and assigned it to the variable
    `another_list` . The top-level `list` object is distinct, but the items within
    the `list` are shared references. We used the `is` operator to show that item
    zero in each list are both references to the same underlying objects.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 我们复制了一个对象`some_list`，并将其分配给变量`another_list`。顶层`list`对象是不同的，但`list`中的项目是共享引用。我们使用`is`运算符来显示每个列表中的第一个项目都是对同一基础对象的引用。
- en: Because we can't make a `set` of mutable objects, we don't really have to consider
    making shallow copies of sets which share items.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不能创建一个包含可变对象的`set`，所以我们不需要考虑制作共享项目的浅复制。
- en: What if we want to completely disconnect two copies? How do we make a deep copy
    instead of a shallow copy?
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要完全断开两个副本之间的连接怎么办？如何进行深复制而不是浅复制？
- en: How to do it...
  id: totrans-726
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Python generally works by sharing references. It only makes copies of objects
    reluctantly. The default behavior is to make a shallow copy, sharing references
    to the items within a collection. Here''s how we make deep copies:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: Python通常通过共享引用来工作。它只会勉强复制对象。默认行为是进行浅复制，共享集合内部项目的引用。这是我们如何进行深复制的方法：
- en: 'Import the `copy` library:'
  id: totrans-728
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`copy`库：
- en: '[PRE101]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Use the `copy.deepcopy()` function to duplicate an object and all of the mutable
    items contained within that object:'
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`copy.deepcopy()`函数来复制一个对象以及该对象中包含的所有可变项目：
- en: '[PRE102]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This will create copies that have no shared references. A change to one copy''s
    mutable internal items won''t have any effect anywhere else:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建没有共享引用的副本。对一个副本的可变内部项目的更改不会在其他任何地方产生任何影响：
- en: '[PRE103]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We updated an item in `some_dict` and it had no effect on the copy in `another_dict`
    . We can see that the objects are distinct with the `id()` function:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新了`some_dict`中的一个项目，但它对`another_dict`中的副本没有产生影响。我们可以使用`id()`函数看到这些对象是不同的：
- en: '[PRE104]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Since the `id()` values are different, these are distinct objects. We can also
    use the `is` operator too see that they're distinct objects.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`id()`值不同，这些是不同的对象。我们还可以使用`is`运算符来查看它们是不同的对象。
- en: How it works...
  id: totrans-737
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Making a shallow copy is relatively easy. We can write our own version of the
    algorithm using generator expressions:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 制作浅拷贝相对容易。我们可以使用生成器表达式编写我们自己的算法版本：
- en: '[PRE105]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: In the `list` case, the items for the new `list` are references to the items
    in the source list. Similarly, in the `dict` case, the keys and values are references
    to the keys and values of the source dictionary.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 在`list`情况下，新`list`的项目是对源列表中项目的引用。同样，在`dict`情况下，键和值是对源字典键和值的引用。
- en: The `deepcopy()` function uses a recursive algorithm to look inside each mutable
    collection.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '`deepcopy()`函数使用递归算法来查看每个可变集合的内部。'
- en: 'For a `list` the conceptual algorithm is something like this:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`list`，概念上的算法大致如下：
- en: '[PRE106]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The actual code doesn't look like this, of course. It's a bit more clever in
    the way it handles each distinct Python type. This does, however, provide some
    hints as to how the `deepcopy()` function works.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的代码当然不是这样的。它在处理每个不同的Python类型的方式上更加聪明。然而，这确实提供了一些关于`deepcopy()`函数工作原理的提示。
- en: It turns out that there are some additional considerations. The most import
    consideration is an object which contains a reference to itself.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明还有一些额外的考虑。最重要的考虑是一个包含对自身引用的对象。
- en: 'We could do this:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样做：
- en: '[PRE107]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: This is a confusing, but technically valid, Python construct. It will lead to
    problems when attempting to write a naïve recursive operation to visit all items
    in the list. In order to overcome this, an internal cache is used so that items
    are only copied once. After that, an internal reference can be found in the cache.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个令人困惑但在技术上有效的Python构造。当尝试编写一个天真的递归操作来访问列表中的所有项目时，这将导致问题。为了克服这个问题，使用内部缓存，以便项目只被复制一次。之后，可以在缓存中找到内部引用。
- en: See also
  id: totrans-749
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In the *Understanding variables, references, and assignment* recipe we'll look
    at how Python prefers to create references to objects.
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*理解变量、引用和赋值*配方中，我们将看看Python更喜欢创建对对象的引用。
- en: Avoiding mutable default values for function parameters
  id: totrans-751
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免函数参数的可变默认值
- en: In [Chapter 3](text00039.html#page "Chapter 3. Function Definitions") , *Function
    Definitions* , we looked at many aspects of Python function definitions. In the
    *Designing functions with optional parameters* recipe we showed a recipe for handling
    optional parameters. At the time, we didn't dwell on the issue of providing a
    reference to a mutable structure as a default. We'll take a close look at the
    consequences of a mutable default value for a function parameter.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00039.html#page "第3章。函数定义")中，*函数定义*，我们看了Python函数定义的许多方面。在*设计带有可选参数的函数*配方中，我们展示了处理可选参数的配方。当时，我们没有深入讨论将对可变结构提供引用作为默认值的问题。我们将仔细研究函数参数的可变默认值的后果。
- en: Getting ready
  id: totrans-753
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's imagine a function that either creates or updates a mutable `Counter`
    object. We'll call it `gather_stats()` .
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个函数，它可以创建或更新一个可变的`Counter`对象。我们将其称为`gather_stats()`。
- en: 'Ideally, it could look like this:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，它可能看起来像这样：
- en: '[PRE108]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'This shows a *bad* design for a function with two stories. The first story
    offers no argument collection. The function creates and returns a collection of
    statistics. Here''s the example of this story:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了一个具有两个故事的*不好*设计的函数。第一个故事没有参数集合。函数创建并返回一组统计数据。这是这个故事的例子：
- en: '[PRE109]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The second story allows us to provide an explicit parameter value so that the
    statistics update a given object. Here''s an example of this story:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个故事允许我们提供一个显式的参数值，以便统计数据更新给定的对象。这是这个故事的例子：
- en: '[PRE110]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: We've set the random number seed to be sure that the two sequences of random
    values are identical. This makes it easy to confirm that the results are the same
    if we provide a `Counter` object or use the default `Counter` object. In the second
    example, we provided an explicit `Counter` object, named `mc` to the function.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了随机数种子，以确保两个随机值序列是相同的。这样可以很容易地确认，如果我们提供一个`Counter`对象或使用默认的`Counter`对象，结果是相同的。在第二个例子中，我们向函数提供了一个显式的`Counter`对象，命名为`mc`。
- en: The `gather_stats()` function returns a value. When writing a script, we'd simply
    ignore the returned value. When working Python's interactive REPL the output is
    printed. We've shown `Counter...` instead of the lengthy output.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '`gather_stats()`函数返回一个值。在编写脚本时，我们只需忽略返回的值。在使用Python的交互式REPL时，输出会被打印出来。我们显示了`Counter...`而不是冗长的输出。'
- en: 'The problem arises when we do the following operation after doing the preceding
    two operations:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在执行前两个操作后执行以下操作时，问题就出现了：
- en: '[PRE111]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Note that the counts are doubled. Something has gone wrong. Since this only
    happens when we use the default story more than once, it may pass a unit test
    suite and appear correct.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，计数加倍了。出现了问题。由于这仅在我们多次使用默认故事时发生，它可能通过单元测试套件并且看起来是正确的。
- en: 'As we saw in the *Making shallow and deep copies of objects* recipe, Python
    prefers to share references. A consequence of that sharing is the following:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*制作对象的浅拷贝和深拷贝*配方中看到的，Python更喜欢共享引用。共享的一个后果是：
- en: '[PRE112]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This means that two variables, `s1` and `s2` , are both references to the same
    underlying object. It appears that we've updated some shared collection.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着两个变量`s1`和`s2`都是对同一基础对象的引用。看起来我们已经更新了一些共享的集合。
- en: Does that mean the value of `s1` changed?
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着`s1`的值改变了？
- en: '[PRE113]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Yes, the default use of this `gather_stats()` function seems to be sharing a
    single object. How can we avoid this?
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这个 `gather_stats()` 函数的默认使用似乎在共享一个单一对象。我们如何避免这种情况？
- en: How to do it...
  id: totrans-772
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'There are two approaches to solving this problem:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题有两种方法：
- en: Provide an immutable default
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个不可变的默认值
- en: Change the design
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变设计
- en: We'll look at the immutable default first. Changing the design is generally
    a better idea. In order to see why it's better to change the design, we'll show
    the purely technical solution.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看看不可变的默认值。通常改变设计是一个更好的主意。为了看到为什么改变设计更好，我们将展示纯技术解决方案。
- en: 'When we provide default values for functions, the default object is created
    exactly once and shared forever after. Here''s the alternative:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为函数提供默认值时，默认对象只会被创建一次，并且永远共享。这里是替代方案：
- en: 'Replace any mutable default parameter value with `None` :'
  id: totrans-778
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用 `None` 替换任何可变的默认参数值：
- en: '[PRE114]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Add an `if` statement to check for an argument value of `None` and replace
    it with a fresh, new mutable object:'
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `if` 语句来检查参数值是否为 `None`，并将其替换为一个新的可变对象：
- en: '[PRE115]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: This will assure us that every time the function is evaluated with no argument
    value for a parameter, we create a fresh, new mutable object. We will avoid sharing
    a single mutable object over and over again.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保每次函数在没有参数值的情况下被评估时，我们都创建一个新的可变对象。我们将避免一次又一次地共享一个可变对象。
- en: There are very few good reasons for providing a mutable object as a default
    value to a function. In most cases, we should consider changing the design, and
    not using a mutable object as a default value for a parameter. In the rare case
    where we really do have a complex algorithm which can update an object or create
    a fresh new object, we should consider defining two separate functions.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 提供可变对象作为函数的默认值的很少有好理由。在大多数情况下，我们应该考虑改变设计，不要使用可变对象作为参数的默认值。在极少数情况下，如果我们真的有一个可以更新对象或创建新对象的复杂算法，我们应该考虑定义两个单独的函数。
- en: 'We''d refactor this function to look like this:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重构这个函数，使其看起来像这样：
- en: '[PRE116]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: We've created two separate functions. This will separate the two stories so
    that there's no confusion. The idea of optional mutable arguments is not a good
    idea in the first place.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个单独的函数。这将分开两个故事，以避免混淆。可选的可变参数的想法本来就不是一个好主意。
- en: How it works...
  id: totrans-787
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As we noted earlier, Python prefers to share references. It rarely creates copies
    of objects. Therefore, default values for function parameter values will be shared
    objects. Python doesn't easily create fresh, new objects.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前指出的，Python 更喜欢共享引用。它很少创建对象的副本。因此，函数参数值的默认值将是共享对象。Python 不容易创建新的对象。
- en: The rule is very important and often confuses programmers new to Python.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则非常重要，经常让刚接触 Python 的程序员感到困惑。
- en: Tip
  id: totrans-790
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't use mutable defaults for functions.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在函数中使用可变默认值。
- en: A mutable object (`set` , `list` , `dict` ) should not be a default value for
    a function parameter.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 可变对象（`set`、`list`、`dict`）不应该是函数参数的默认值。
- en: This rule applies to the core language. It doesn't apply throughout the standard
    library, however. There are cases where there are some clever alternative approaches.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则适用于核心语言。然而，它并不适用于整个标准库。有些情况下，有一些巧妙的替代方法。
- en: There's more...
  id: totrans-794
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the standard library, there are some examples of a cool technique that shows
    how we can create fresh default objects. One widely-used example is in the `defaultdict`
    collection. When we create a `defaultdict` we provide a no-argument function that
    will be used to create new dictionary entries.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库中，有一些示例展示了一个很酷的技术，它展示了我们如何创建新的默认对象。一个广泛使用的例子是 `defaultdict` 集合。当我们创建一个 `defaultdict`
    时，我们提供一个无参数函数，用于创建新的字典条目。
- en: When a key is missing from the dictionary, the given function is evaluated to
    compute a fresh default value. In the case of `defaultdict(int)` we're using the
    `int()` function to create an immutable object. As we've seen, a default value
    of an immutable object doesn't cause any problems because the immutable object
    has no internal state.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 当字典中缺少一个键时，给定的函数将被评估以计算一个新的默认值。在 `defaultdict(int)` 的情况下，我们使用 `int()` 函数来创建一个不可变对象。正如我们所见，不可变对象的默认值不会引起任何问题，因为不可变对象没有内部状态。
- en: When we do `defaultdict(list)` or `defaultdict(set)` we see the real power of
    this design pattern. When a key is missing, a fresh, empty `list` (or `set` )
    is created.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `defaultdict(list)` 或 `defaultdict(set)` 时，我们可以看到这种设计模式的真正力量。当一个键缺失时，会创建一个新的空
    `list`（或 `set`）。
- en: The evaluate-a-function pattern used by `defaultdict` does not apply to the
    way functions themselves operate. Most of the time the default values we provide
    for function parameters are immutable objects like numbers, strings, or tuples.
    Having to wrap an immutable object with a `lambda` is certainly possible, but
    irksome because it's such a common case.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict` 使用的评估函数模式并不适用于函数本身的操作方式。大多数情况下，我们为函数参数提供的默认值是不可变对象，比如数字、字符串或元组。必须使用
    `lambda` 来包装一个不可变对象，这当然是可能的，但令人讨厌，因为这是一个很常见的情况。'
- en: In order to leverage this technique, we need to modify the design of our example
    function. We will no longer update an existing counter object in the function.
    We'll always create a fresh, new object. We can modify what class of object is
    created.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这种技术，我们需要修改我们示例函数的设计。我们将不再在函数中更新现有的计数器对象。我们将始终创建一个新的对象。我们可以修改创建的对象的类。
- en: Here's a function that allows us to plug in a different class in the case where
    we don't want the default `Counter` class to be used.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数，允许我们在我们不想使用默认的 `Counter` 类时插入一个不同的类。
- en: '[PRE117]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: For this version, we've defined an initialization value to be a function of
    one argument. The default will apply this one-argument function to a generator
    function for the random samples. We can override this function with another one-argument
    function that will collect data. This will build a fresh object using any kind
    of object that can gather data.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个版本，我们定义了一个初始化值，它是一个参数的函数。默认情况下，这个单参数函数将应用于随机样本的生成函数。我们可以用另一个单参数函数覆盖这个函数，这个函数将收集数据。这将使用任何可以收集数据的对象构建一个新的对象。
- en: 'Here''s an example using `list()` :'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`list()`的示例：
- en: '[PRE118]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: In this case, we provided the `list()` function to create a list with the individual
    random samples in it.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们提供了`list()`函数来创建一个包含各个随机样本的列表。
- en: 'Here''s an example without an argument value. It will create a `Counter` object:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个没有参数值的示例。它将创建一个`Counter`对象：
- en: '[PRE119]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: In this case, we've used the default value. The function created a `Counter()`
    object from the random samples.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了默认值。该函数从随机样本创建了一个`Counter()`对象。
- en: See also
  id: totrans-809
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Creating dictionaries – inserting and updating* recipe, which shows
    how `defaultdict` works
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅*创建字典-插入和更新*配方，其中显示了`defaultdict`的工作原理
