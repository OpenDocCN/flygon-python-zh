- en: Chapter 12. Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。Web服务
- en: 'In this chapter, we''ll look at the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看以下配方：
- en: Implementing web services with WSGI
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WSGI实现Web服务
- en: Using the Flask framework for RESTful APIs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask框架进行RESTful API
- en: Parsing the query string in a request
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析请求中的查询字符串
- en: Making REST requests with urllib
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用urllib进行REST请求
- en: Parsing the URL path
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析URL路径
- en: Parsing a JSON request
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析JSON请求
- en: Implementing authentication for web services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Web服务实施身份验证
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Providing web services involves solving several interrelated problems. There
    are a number of applicable protocols that must be followed, each with its own
    unique design considerations. The core of web services are the various standards
    that define the HTTP.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 提供Web服务涉及解决几个相互关联的问题。必须遵循一些适用的协议，每个协议都有其独特的设计考虑。Web服务的核心是定义HTTP的各种标准。
- en: 'HTTP involves two parties; a client and a server:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP涉及两方；客户端和服务器：
- en: The client makes requests of the server
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端向服务器发出请求
- en: The server sends responses back to the client
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器向客户端发送响应
- en: The relationship is highly asymmetric. We expect a server to process concurrent
    requests from multiple clients. Because the client requests arrive asynchronously,
    the server cannot easily distinguish those requests that originate from a single
    human user. The idea of a human user's session is implemented by designing a server
    that provides a session token (or cookie) to track the human's sense of current
    state.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系是高度不对称的。我们期望服务器处理来自多个客户端的并发请求。因为客户端请求是异步到达的，服务器不能轻易区分那些来自单个人类用户的请求。通过设计提供会话令牌（或cookie）来跟踪人类当前状态的服务器来实现人类用户会话的概念。
- en: The HTTP protocol is flexible and extensible. One popular use case for HTTP
    is to serve content in the form of web pages. Web pages are generally encoded
    as HTML documents, often with links to graphics, style sheets, and JavaScript
    code. We've looked at parsing HTML in the *Reading HTML documents* recipe from
    [Chapter 9](text00099.html#page "Chapter 9. Input/Output, Physical Format, and
    Logical Layout") , *Input/Output, Physical Format, and Logical Layout* .
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议是灵活和可扩展的。HTTP的一个流行用例是以网页的形式提供内容。网页通常被编码为HTML文档，通常包含指向图形、样式表和JavaScript代码的链接。我们已经在[第9章](text00099.html#page
    "第9章。输入/输出、物理格式和逻辑布局")的*读取HTML文档*中查看了解析HTML的信息，*输入/输出、物理格式和逻辑布局*。
- en: 'Serving web page content further decomposes into two kinds of content:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 提供网页内容进一步分解为两种内容：
- en: Static content is essentially a download of files. A program such as GUnicorn,
    NGINGX, or Apache HTTPD can reliably serve static files. Each URL defines a path
    to a file, and the server downloads the file to the browser.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态内容本质上是文件的下载。诸如GUnicorn、NGINGX或Apache HTTPD之类的程序可以可靠地提供静态文件。每个URL定义了文件的路径，服务器将文件下载到浏览器。
- en: Dynamic content is built by an application as needed. In this case, we'll use
    a Python application to build unique HTML (or possibly the graphics) in response
    to a request.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态内容是根据需要由应用程序构建的。在这种情况下，我们将使用Python应用程序响应请求构建唯一的HTML（或可能是图形）。
- en: The other very popular use case for HTTP is to provide web services. In this
    case, the standard HTTP requests and responses will exchange data in formats other
    than HTML. One of the most popular formats for encoding information is JSON. We've
    looked at processing JSON documents in the *Reading JSON documents* recipe from
    [Chapter 9](text00099.html#page "Chapter 9. Input/Output, Physical Format, and
    Logical Layout") , *Input/Output, Physical Format, and Logical Layout* .
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP的另一个非常流行的用例是提供Web服务。在这种情况下，标准的HTTP请求和响应将以HTML以外的格式交换数据。编码信息的最流行格式之一是JSON。我们已经在[第9章](text00099.html#page
    "第9章。输入/输出、物理格式和逻辑布局")的*读取JSON文档*中查看了处理JSON文档的信息，*输入/输出、物理格式和逻辑布局*。
- en: Web services can be seen as a variation on using HTTP to serve dynamic content.
    A client can prepare documents in JSON. The server includes a Python application
    that creates response documents, also in JSON notation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务可以被视为使用HTTP提供动态内容的一种变体。客户端可以准备JSON文档。服务器包括一个创建JSON表示的Python应用程序。
- en: In some cases, the services have a very narrow focus. It's possible to bundle
    a service and database persistence into a single package. This might involve creating
    a server that has an NGINX-based web interface plus a database using MongoDB or
    Elastic. The entire package—web service plus persistence—can be called a **microservice**
    .
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，服务的焦点非常狭窄。将服务和数据库持久性捆绑到一个单一的包中是可能的。这可能涉及创建一个具有基于NGINX的Web界面以及使用MongoDB或Elastic的数据库的服务器。整个包
    - Web服务加持久性 - 可以称为**微服务**。
- en: The documents exchanged by a web service encode a representation of an object's
    state. A client application in JavaScript may have an object state that is sent
    to a server. A server in Python may transfer a representation of object state
    to a client. This is called **Representational State Transfer** ( **REST** ).
    A service using REST processing is often called RESTful.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务交换的文档编码了对象状态的表示。JavaScript中的客户端应用程序可能具有发送到服务器的对象状态。Python中的服务器可能会将对象状态的表示传输给客户端。这被称为**表述性状态转移**（**REST**）。使用REST处理的服务通常被称为RESTful。
- en: 'Handling HTTP for HTML or JSON can be designed as a number of transformation
    functions. The idea is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 处理HTML或JSON的HTTP可以设计为一系列转换函数。思路如下：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The response is built from the request by some function, `F(r, s)` , which relies
    on the request plus some persistent state in a database on the server.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是通过某个函数`F(r, s)`从请求中构建的，该函数依赖于服务器上数据库中的请求加上一些持久状态。
- en: 'These functions form nested shells or wrappers around a core service. For example,
    the core processing may be wrapped with additional steps to be sure that the user
    making the request is authorized to change the database state. We might summarize
    this as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数形成了围绕核心服务的嵌套外壳或包装器。例如，核心处理可能被包装以确保发出请求的用户被授权更改数据库状态。我们可以总结如下：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The authorization processing may be wrapped in processing to authenticate user''s
    credentials. All of this may be further wrapped in a shell that assures that the
    client application software expects responses in JSON notation. Using multiple
    layers like this can provide consistent operation for many different core services.
    The overall process might start looking like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 授权处理可能被包装在处理中，以验证用户的凭据。所有这些可能进一步包装在一个外壳中，以确保客户端应用程序软件期望以JSON表示形式进行响应。像这样使用多个层可以为许多不同的核心服务提供一致的操作。整个过程可能开始看起来像这样：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This kind of design fits naturally with a stack of transformational functions.
    This idea gives us some guidance in ways to design complex web services that include
    many protocols and many rules for creating a valid response.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计自然适用于一系列转换函数。这个想法为我们提供了一些指导，指导我们设计包括许多协议和创建有效响应的许多规则的复杂Web服务的方式。
- en: A good RESTful implementation should also provide a great deal of information
    about the service. One way to provide this information is through the OpenAPI
    specification. For information on the OpenAPI (Swagger) specification, see [http://swagger.io/specification/](http://swagger.io/specification/)
    .
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的RESTful实现还应该提供关于服务的大量信息。提供此信息的一种方式是通过OpenAPI规范。有关OpenAPI（Swagger）规范的信息，请参阅[http://swagger.io/specification/](http://swagger.io/specification/)。
- en: The core of the OpenAPI specification is a JSON schema specification. For more
    information on this, see [http://json-schema.org](http://json-schema.org) .
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI规范的核心是JSON模式规范。有关更多信息，请参阅[http://json-schema.org](http://json-schema.org)。
- en: 'The two foundational ideas are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个基本思想如下：
- en: We write in JSON a specification for the requests that are sent to the service
    and the responses provided by the service.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们以JSON格式编写了发送到服务的请求和服务提供的响应的规范。
- en: We provide the specification at a fixed URL, often `/swagger.json` . This can
    be queried by a client to determine the details of how the service works.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在固定的URL上提供规范，通常是`/swagger.json`。客户端可以查询此URL以确定服务的详细信息。
- en: Creating Swagger documents can be challenging. The `swagger-spec-validator`
     project can help. See [https://pypi.python.org/pypi/swagger-spec-validator](https://pypi.python.org/pypi/swagger-spec-validator)
    . This is a Python package that we can use to confirm that a Swagger specification
    meets the OpenAPI requirements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Swagger文档可能具有挑战性。`swagger-spec-validator`项目可以提供帮助。请参阅[https://pypi.python.org/pypi/swagger-spec-validator](https://pypi.python.org/pypi/swagger-spec-validator)。这是一个Python包，我们可以使用它来确认Swagger规范是否符合OpenAPI要求。
- en: In this chapter, we'll look at a number of recipes for creating RESTful web
    services and also serving static or dynamic content.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨创建RESTful Web服务以及提供静态或动态内容的一些方法。
- en: Implementing web services with WSGI
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WSGI实现Web服务
- en: 'Many web applications will have several layers. The layers can often be summarized
    into three common patterns:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Web应用程序将具有多个层。这些层通常可以总结为三种常见模式：
- en: A presentation layer might run on a mobile device or a website. This is the
    visible, external view.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示层可能在移动设备或网站上运行。这是可见的外部视图。
- en: An application layer is often implemented as web services. This layer does the
    processing for the web or mobile presentation.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层通常实现为Web服务。该层对Web或移动演示进行处理。
- en: A persistence layer handles retention of data and transaction state over a single
    session as well as across multiple sessions from a single user. This will support
    the application layer.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久层处理数据的保留和事务状态，以及来自单个用户的多个会话中的数据。这将支持应用程序层。
- en: A Python-based website or web services application will adhere to the **Web
    Services Gateway Interface** ( **WSGI** ) standard. This provides a uniform way
    for a frontend web server such as Apache HTTPD, NGINX, or GUnicorn to use Python
    to provide the dynamic content.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Python的网站或Web服务应用程序将遵守**Web服务网关接口**（**WSGI**）标准。这为前端Web服务器（如Apache HTTPD、NGINX或GUnicorn）提供了一种统一的方式来使用Python提供动态内容。
- en: Python has a wide variety of RESTful API frameworks. In the *Using the Flask
    framework for RESTful APIs* recipe, we'll look at Flask. In some cases, however,
    the core WSGI features are all we need.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Python有各种各样的RESTful API框架。在*使用Flask框架创建RESTful API*的示例中，我们将看到Flask。然而，在某些情况下，核心WSGI功能可能是我们所需要的。
- en: How can we create applications that support layered composition following the
    WSGI standard?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何创建支持遵循WSGI标准的分层组合的应用程序？
- en: Getting ready
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The WSGI standard defines an overall framework for composable web applications.
    The idea behind this is to define each application so that it stands alone and
    can be trivially connected to other applications. The overall website is built
    from a collection of shells or wrappers.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI标准定义了一个可组合的Web应用程序的总体框架。其背后的想法是定义每个应用程序，使其能够独立运行，并可以轻松连接到其他应用程序。整个网站是由一系列外壳或包装器构建的。
- en: This is a bare-bones approach to web server development. WSGI isn't a sophisticated
    framework; it's a minimal standard. We'll look at some ways to simplify the design
    using a better framework in the *Using the Flask framework for RESTful APIs* recipe.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种基本的Web服务器开发方法。WSGI不是一个复杂的框架；它是一个最小的标准。我们将在*使用Flask框架创建RESTful API*的示例中探讨一些简化设计的方法。
- en: 'The essence of web services are the HTTP request and response. A server receives
    requests and creates responses. The HTTP request includes several pieces of data:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务的本质是HTTP请求和响应。服务器接收请求并创建响应。HTTP请求包括几个数据部分：
- en: 'The URL for the resource. A URL can be as complex as `http://www.example.com:8080/?query#fragment`
    . There are several parts to a URL:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源的URL。URL可以像`http://www.example.com:8080/?query#fragment`这样复杂。URL有几个部分：
- en: 'The scheme `http` : This ends with `:` .'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方案`http`：以`:`结束。
- en: 'The host `www.example.com` : This is prefixed with `//` . It may include an
    optional port number. In this case, it''s `8080` .'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机`www.example.com`：这是以`//`为前缀的。它可能包括一个可选的端口号。在这种情况下，它是`8080`。
- en: 'The path to the resource: The `/`  character in this example. The path, in
    some form, is required. It is often more complex than a simple `/` .'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源的路径：在本例中是`/`字符。路径以某种形式是必需的。它通常比简单的`/`更复杂。
- en: 'A query string prefaced with `?` : In this example, the query string is just
    the key `query` with no value.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`?`为前缀的查询字符串：在本例中，查询字符串只是带有没有值的键`query`。
- en: 'A fragment identifier prefaced with `#` : In this example, the fragment is
    `fragment` . For HTML documents, this can be the `id` value of a particular tag;
    the browser will scroll to the named tag.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`#`为前缀的片段标识符：在本例中，片段是`fragment`。对于HTML文档，这可以是特定标签的`id`值；浏览器将滚动到命名标签。
- en: Almost all of these URL elements are optional. We can make use of the query
    string (or the fragment) to provide additional format information about the request.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有这些URL元素都是可选的。我们可以利用查询字符串（或片段）来提供有关请求的附加格式信息。
- en: 'The WSGI standard requires that the URL is parsed. The various pieces put into
    the environment. Each piece will be assigned a separate key:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI标准要求解析URL。各种片段放入环境中。每个片段将被分配一个单独的键：
- en: '**Methods** : Common HTTP methods include `HEAD` , `OPTIONS` , `GET` , `POST`
    , `PUT` , and `DELETE` .'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法**：常见的HTTP方法包括`HEAD`，`OPTIONS`，`GET`，`POST`，`PUT`和`DELETE`。'
- en: '**Request headers** : The headers are additional information that support the
    request. Headers are used, for example, to define the kind of content that can
    be accepted.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求标头**：标头是支持请求的附加信息。例如，标头用于定义可以接受的内容类型。'
- en: '**Attached content** : A request might include input from an HTML form, or
    a file to be uploaded.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**附加内容**：请求可能包括来自HTML表单的输入，或要上传的文件。'
- en: The HTTP response is similar to a request in many ways. It contains response
    headers and the response body. The headers will include details such as the encoding
    of the content so that the client can render it correctly. If a server is providing
    HTML content and is maintaining a server session, then the cookies are sent in
    headers as part of each request and response.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应在许多方面类似于请求。它包含响应标头和响应正文。标头将包括诸如内容的编码，以便客户端可以正确地呈现它的细节。如果服务器提供HTML内容并维护服务器会话，那么cookie将作为每个请求和响应的一部分在标头中发送。
- en: 'WSGI is designed to help create application components that can be used to
    build larger and more sophisticated applications. A WSGI application generally
    acts like a wrapper, insulating other applications from bad requests, unauthorized
    users, or unauthenticated users. To do this, each WSGI application must follow
    a common, standard definition. Each application must be either a function or a
    callable object, that has the following signature:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI旨在帮助创建可以用于构建更大更复杂应用程序的应用程序组件。WSGI应用程序通常充当包装器，保护其他应用程序免受错误请求、未经授权的用户或未经身份验证的用户的影响。为了做到这一点，每个WSGI应用程序必须遵循一个共同的标准定义。每个应用程序必须是一个函数或可调用对象，并具有以下签名：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `environ` parameter is a dictionary that includes information about the
    request. This includes all of the HTTP details, plus the OS context, plus the
    WSGI server context. The `start_response` parameter is a function that must be
    called prior to returning the response body. This provides the status and the
    headers for the response.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`environ`参数是一个包含有关请求的信息的字典。这包括所有HTTP细节，加上操作系统上下文，加上WSGI服务器上下文。`start_response`参数是一个必须在返回响应正文之前调用的函数。这提供了响应的状态和标头。'
- en: The return value from the WSGI application function is the HTTP response body.
    This is generally a sequence of strings or an iterable over string values. The
    idea here is that a WSGI application might be part of a larger container that
    will stream the response in pieces from the server to the client as the response
    is being built.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI应用程序函数的返回值是HTTP响应正文。这通常是一系列字符串或字符串值的可迭代对象。这里的想法是，WSGI应用程序可能是一个更大容器的一部分，该容器将从服务器向客户端流式传输响应，因为响应正在构建。
- en: Since all WSGI applications are callable functions, they can be composed easily.
    A complex web server might have several WSGI components to handle details of authentication,
    authorization, standard headers, audit logging, performance monitoring, and so
    on. These aspects are generally independent of the underlying content; they're
    universal features of all web applications or RESTful services.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有WSGI应用程序都是可调用函数，它们可以很容易地组合。一个复杂的网络服务器可能有几个WSGI组件来处理身份验证、授权、标准标头、审计日志、性能监控等细节。这些方面通常独立于底层内容；它们是所有网络应用程序或RESTful服务的通用特性。
- en: 'We''ll look at a relatively simple web service that emits playing cards from
    either a deck or a shoe. We''ll rely on the `Card` class definition from the *Optimizing
    small objects with __slots__* recipe from [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* . Here''s the core
    `Card` class with rank and suit information:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一个相对简单的网络服务，它可以从牌组或鞋子中发出纸牌。我们将依赖于来自[第6章](text00070.html#page "第6章。类和对象的基础")*类和对象的基础*的*使用__slots__优化小对象*配方中的`Card`类定义。这是核心的`Card`类，带有等级和花色信息：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We've defined a small base class for playing cards. Each instance of the class
    has two attributes, `rank` and `suit` . We've omitted the hash and comparison
    method definitions. To follow the *Creating a class that has orderable objects*
    recipe from [Chapter 7](text00079.html#page "Chapter 7. More Advanced Class Design")
    , *More Advanced Class Design* , this class would need a number of additional
    special methods. This recipe will avoid those complications.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为纸牌定义了一个小的基类。该类的每个实例都有两个属性，`rank`和`suit`。我们省略了哈希和比较方法的定义。要遵循[第7章](text00079.html#page
    "第7章。更高级的类设计")*更高级的类设计*中的*创建具有可排序对象的类*配方，这个类需要许多额外的特殊方法。这个配方将避免这些复杂性。
- en: We've defined a `to_json()` method that is handy for serializing this complex
    object into a consistent JSON format. This method emits a dictionary representation
    of the state of the `Card` . If we want to deserialize `Card` objects from JSON
    notation, we'll need to also create an `object_hook` function. We don't need it
    for this recipe, though, since we won't accept `Card` objects as input.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`to_json()`方法，用于将这个复杂对象序列化为一致的JSON格式。该方法发出`Card`状态的字典表示。如果我们想要从JSON表示中反序列化`Card`对象，我们还需要创建一个`object_hook`函数。不过，对于这个示例，我们不需要它，因为我们不会接受`Card`对象作为输入。
- en: 'We''ll also need a `Deck` class as a container of `Card` instances. An instance
    of this class can create the `Card` instances as well as acting as a stateful
    object that can deal cards. Here''s the class definition:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个`Deck`类作为`Card`实例的容器。该类的一个实例可以创建`Card`实例，同时充当一个有状态的对象，可以发牌。以下是类定义：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `create_deck()` method uses a generator to create all 52 combinations of
    the thirteen ranks and four suits. Each suit is defined by a single character:
    ♣, ♢, ♡, or ♠. The example spells out the Unicode character names using `\N{}`
    sequences.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_deck()`方法使用生成器来创建所有52种组合的十三个等级和四种花色。每种花色由一个单字符定义：♣，♢，♡或♠。示例使用`\N{}`序列来拼写Unicode字符名称。'
- en: If a value of `n` is provided when creating the `Deck` instance, the container
    will create multiple copies of the 52-card deck. This multideck shoe is sometimes
    used to speed up play by reducing the time spent shuffling. Once the sequence
    of `Card` instances has been created, it is shuffled using the `random` module.
    For repeatable test cases, a fixed seed can be provided.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在创建`Deck`实例时提供了`n`的值，容器将创建52张牌的多个副本。这种多副牌鞋有时用于通过减少洗牌时间来加快游戏速度。一旦`Card`实例的序列被创建，就会使用`random`模块对其进行洗牌。对于可重复的测试用例，可以提供一个固定的种子。
- en: The `deal()` method will use the value of `self.offset` to determine where to
    start dealing. This value starts at `0` and is incremented after each hand of
    cards is dealt. The `hand_size` argument determines how many cards will be in
    the next hand. This method updates the state of the object by incrementing the
    value of `self.offset` so that the cards are dealt just once.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`deal()`方法将使用`self.offset`的值来确定从哪里开始发牌。这个值从`0`开始，并在每发一手牌后递增。`hand_size`参数决定下一手牌有多少张。该方法通过递增`self.offset`的值来更新对象的状态，以便牌只被发一次。'
- en: 'Here''s one way to use this class to create `Card` objects:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用这个类创建`Card`对象的一种方法：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To create a sensible test, we provided a fixed seed value. The script created
    a single deck using `Deck()` . We can then deal a hand of five `Card` instances
    from the deck.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个合理的测试，我们提供了一个固定的种子值。脚本使用`Deck()`创建了一副牌。然后我们可以从牌组中发出五张`Card`实例。
- en: 'In order to use this as part of a web service, we''ll also need to produce
    useful output in JSON notation. Here''s an example of how that would look:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将其作为Web服务的一部分使用，我们还需要以JSON表示形式产生有用的输出。以下是一个示例，展示了这样的输出：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've used `deck.deal(5)` to deal a hand with five more cards from the deck.
    The expression `list(card.to_json() for card in deck.deal(5))` will use the `to_json()`
    method of each `Card` object to emit the small dictionary representation of that
    object. The list of dictionary structure was then serialized into JSON notation.
    The `sort_keys=True` option is handy for creating a repeatable test case. It's
    not generally necessary for RESTful web services.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`deck.deal(5)`来从牌组中发5张牌。表达式`list(card.to_json() for card in deck.deal(5))`将使用每个`Card`对象的`to_json()`方法来发出该对象的小字典表示。然后将字典结构的列表序列化为JSON表示形式。`sort_keys=True`选项对于创建可重复的测试用例很方便。对于RESTful
    Web服务通常不是必需的。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import needed modules and objects. We''ll use the `HTTPStatus` class because
    it defines the commonly-used HTTP status codes. The `json` module is required
    to produce JSON responses. We''ll also use the `os` module to initialize a random
    number seed:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的模块和对象。我们将使用`HTTPStatus`类，因为它定义了常用的HTTP状态码。需要`json`模块来生成JSON响应。我们还将使用`os`模块来初始化随机数种子：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Import or define the underlying classes, `Card` and `Deck` . Generally, it's
    a good idea to define these as a separate module. The basic features should exist
    and be tested outside the web services environment. The idea is that web services
    should wrap existing, working software.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入或定义底层类，`Card`和`Deck`。通常，最好将这些定义为一个单独的模块。基本功能应该存在并在Web服务环境之外进行测试。这样做的想法是Web服务应该包装现有的、可工作的软件。
- en: 'Create objects that are shared by all sessions. The value of `deck` is a module
    global variable:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建所有会话共享的对象。`deck`的值是一个模块全局变量：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We've relied on the `os` module to examine the environment variables. If the
    environment variable `DEAL_APP_SEED` is defined, we'll seed the random number
    generator with the string value. Otherwise, we'll rely on the built-in randomization
    features of the `random` module.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们依赖`os`模块来检查环境变量。如果环境变量`DEAL_APP_SEED`被定义，我们将使用该字符串值来生成随机数。否则，我们将依赖`random`模块的内置随机化特性。
- en: 'Define the target WSGI application as a function. This function will respond
    to a request by dealing a hand of cards and then creating a JSON representation
    of the `Card` information:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目标WSGI应用程序定义为一个函数。该函数将通过发一手牌来响应请求，然后创建`Card`信息的JSON表示形式：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `deal_cards()` function deals the next group of cards from the `deck` .
    The OS environment can define a `HAND_SIZE` environment variable to change the
    size of the deal. The global `deck` object is used to perform the relevant processing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`deal_cards()`函数从`deck`中发牌下一组牌。操作系统环境可以定义`HAND_SIZE`环境变量来改变发牌的大小。全局`deck`对象用于执行相关处理。'
- en: The status line for a response is a string that has the numeric value and phrase
    for the HTTP status of `OK` . This can be followed by headers. This example includes
    the `Content-Type` header to provide information to the client; the content is
    a JSON document and that the bytes for this document are encoded using `utf-8`
    . Finally, the document itself is the return value from this function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的状态行是一个字符串，其中包含HTTP状态为`OK`的数值和短语。这可以跟随标头。这个例子包括`Content-Type`标头，向客户端提供信息；内容是一个JSON文档，这个文档的字节使用`utf-8`进行编码。最后，文档本身是这个函数的返回值。
- en: 'For demonstration and debugging purposes, it''s helpful to build a server that
    runs the WSGI application. We''ll use the `wsgiref` module''s server. There are
    good servers defined in Werkzeug. Servers such as GUnicorn are even better:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出于演示和调试目的，构建一个运行WSGI应用程序的服务器是有帮助的。我们将使用`wsgiref`模块的服务器。在Werkzeug中定义了良好的服务器。像GUnicorn这样的服务器甚至更好：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once the server is running, we can open a browser to see `http://localhost:8080/`
    . This will return a batch of five cards. Each time we refresh, we get a different
    batch of cards.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器运行后，我们可以打开浏览器查看`http://localhost:8080/`。这将返回一批五张卡片。每次刷新，我们都会得到不同的一批卡片。
- en: This works because entering a URL in the browser executes a `GET` request with
    a minimal set of headers. Since our WSGI application didn't require any specific
    headers, and responded to any HTTP method, it will return a result.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在浏览器中输入URL会执行一个带有最小一组标头的`GET`请求。由于我们的WSGI应用程序不需要任何特定的标头，并且对任何HTTP方法都有响应，它将返回一个结果。
- en: 'The result is a JSON document that represents five cards dealt from the current
    deck. Each card is represented with a class name, `rank` , and `suit` :'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个JSON文档，表示从当前牌组中发出的五张卡片。每张卡片都用一个类名`rank`和`suit`表示：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can create web pages with clever JavaScript programs to fetch batches of
    cards. These web pages and JavaScript programs can animate dealing, and include
    graphics for the card images.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建带有聪明的JavaScript程序的网页来获取一批卡片。这些网页和JavaScript程序可以用于动画处理，并包括卡片图像的图形。
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The WSGI standard defines an interface between a web server and an application.
    This is based on the the Apache HTTPD **Common Gateway Interface** ( **CGI** ).
    The CGI was designed to run shell scripts or separate binaries. The WSGI is an
    enhancement to this legacy concept.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI标准定义了Web服务器和应用程序之间的接口。这是基于Apache HTTPD的**公共网关接口**（**CGI**）。CGI旨在运行shell脚本或单独的二进制文件。WSGI是对这一传统概念的增强。
- en: 'The WSGI standard defines the environment dictionary with a variety of information:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI标准使用环境字典定义了各种信息：
- en: A number of keys in the dictionary reflect the request after some preliminary
    parsing and data conversion.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典中的许多键反映了一些初步解析和数据转换后的请求。
- en: '`REQUEST_METHOD` : The HTTP request method, such as `GET` or `POST` .'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REQUEST_METHOD`：HTTP请求方法，如`GET`或`POST`。'
- en: '`SCRIPT_NAME` : The initial portion of the request URL''s path. This is generally
    taken as an overall application object or function.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCRIPT_NAME`：请求URL路径的初始部分。这通常被视为整体应用程序对象或函数。'
- en: '`PATH_INFO` : The remainder of the request URL''s path, designating a location
    of a resource. In this example, no path parsing is performed.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATH_INFO`：请求URL路径的其余部分，指定资源的位置。在这个例子中，不执行路径解析。'
- en: '`QUERY_STRING` : The portion of the request URL that follows the `?` , if any:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QUERY_STRING`：请求URL中跟随`?`后的部分，如果有的话：'
- en: '`CONTENT_TYPE` : The contents of any Content-Type header value in the HTTP
    request.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONTENT_TYPE`：HTTP请求中任何Content-Type标头值的内容。'
- en: '`CONTENT_LENGTH` : The contents of any Content-Length header value in the HTTP
    request.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONTENT_LENGTH`：HTTP请求中任何Content-Length标头值的内容。'
- en: '`SERVER_NAME` and `SERVER_PORT` : The server name and port number from the
    request.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SERVER_NAME`和`SERVER_PORT`：请求中的服务器名称和端口号。'
- en: '`SERVER_PROTOCOL` : The version of the protocol the client used to send the
    request. Typically, this will be something like `HTTP/1.0` or `HTTP/1.1` .'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SERVER_PROTOCOL`：客户端用于发送请求的协议版本。通常情况下，这可能是类似于`HTTP/1.0`或`HTTP/1.1`的内容。'
- en: '**The HTTP headers** : These will have keys that start with `HTTP_` and contain
    the header name in all uppercase letters.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP标头**：这些标头将以`HTTP_`开头，并且以全部大写字母包含标头名称的键。'
- en: 'Generally the contents of a request are not the only data that''s required
    to create a meaningful response from a server. Often, additional information is
    required. This information generally includes two other kinds of data:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，请求的内容不是从服务器创建有意义的响应所需的唯一数据。通常需要额外的信息。这些信息通常包括另外两种类型的数据：
- en: '**OS environment** : The environment variables that were in place when the
    service was started provide configuration details for the server. This could provide
    a path to a directory that contains static content. It could provide information
    used for authenticating users.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统环境**：在服务启动时存在的环境变量为服务器提供配置详细信息。这可能提供一个包含静态内容的目录路径。它可能提供用于验证用户的信息。'
- en: '**WSGI server context** : These keys start with `wsgi.` and are always lowercase.
    The values include some additional information on the internal state of a server
    that adheres to the WSGI standard. There are two particularly interesting objects
    that upload files and logging support:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WSGI服务器上下文**：这些键以`wsgi.`开头，始终为小写。值包括一些关于遵循WSGI标准的服务器内部状态的附加信息。有两个特别有趣的对象，用于上传文件和日志支持：'
- en: '`wsgi.input` : It is a file-like object. From this, the HTTP request body bytes
    can be read. This will often have to be decoded based on the `Content-Type` header.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wsgi.input`：它是一个类似文件的对象。可以从中读取HTTP请求体字节。这通常需要根据`Content-Type`标头进行解码。'
- en: '`wsgi.errors` : It is a file-like object to which error output can be written.
    This is the server''s log.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wsgi.errors`：这是一个类似文件的对象，可以将错误输出写入其中。这是服务器的日志。'
- en: The return value from a WSGI function can be a sequence object or an iterable.
    Returning an iterable is the way a very large document can be built in pieces
    and downloaded via a number of smaller buffers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI函数的返回值可以是序列对象或可迭代对象。返回可迭代对象是构建非常大的文档并通过多个较小的缓冲区下载的方法。
- en: This example WSGI application does not check the request path. Any path can
    be used to retrieve a hand of cards. A more sophisticated application might parse
    the path to determine information about the size of a hand being requested or
    the size of the deck from which the hand should be dealt.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例WSGI应用程序不检查请求路径。可以使用任何路径来检索一手牌。更复杂的应用程序可能会解析路径以确定有关所请求的手牌大小或应该从中发牌的牌组大小的信息。
- en: There's more...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A web service can be visualized as a number of common pieces that are connected
    together into nested shells or layers. The uniform interface for WSGI applications
    encourages this kind of composition of reusable features.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务可以被视为连接到嵌套外壳或层中的一些常见部分。WSGI应用程序的统一接口鼓励可重用功能的这种组合。
- en: 'There are a number of common techniques that are used to protect and produce
    dynamic content. These techniques are cross-cutting concerns for web service applications.
    We have a few choices for this as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多常见的技术用于保护和生成动态内容。这些技术是Web服务应用程序的横切关注点。我们有以下几种选择：
- en: We can write lots of `if` statements in a single application
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在单个应用程序中编写许多`if`语句。
- en: We can extract the common programming and create a common wrapper that separates
    security concerns from the construction of content
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以提取常见的编程并创建一个将安全性问题与内容构建分离的通用包装器
- en: A wrapper is simply another WSGI application that doesn't produce a result directly.
    Instead, a wrapper hands off the work of producing results to another WSGI application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 包装器只是另一个不直接产生结果的WSGI应用程序。相反，包装器将产生结果的工作交给另一个WSGI应用程序。
- en: We might, for example, need a wrapper that confirms that a JSON response is
    expected. This wrapper will distinguish requests for human-centric HTML from application-focused
    JSON.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能需要一个确认期望JSON响应的包装器。此包装器将区分人类为中心的HTML请求和面向应用程序的JSON请求。
- en: To make more flexible applications, it's often helpful to use a callable object
    instead of a simple function. Doing this makes configuration of the various applications
    and wrappers considerably more flexible. We'll combine the idea of a JSON filter
    with a callable object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建更灵活的应用程序，通常使用可调用对象而不是简单的函数是有帮助的。这样做可以使各种应用程序和包装器的配置更加灵活。我们将将JSON过滤器的概念与可调用对象结合起来。
- en: 'The outline of this object looks like the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象的概述如下：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We'll create a callable object from this class definition by providing another
    app. The other app, `json_app` , will be wrapped by this callable object.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供另一个应用程序，`json_app`，我们将从这个类定义中创建一个可调用对象。
- en: 'We''ll use it like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像这样使用它：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will wrap the original `deal_cards()` WSGI application. We can now use
    the composite `json_wrapper` object as a WSGI application. When the server calls
    `json_wrapper(environ, start_response)` , that will invoke the `__call__()` method
    of the object, which—in this example, will pass the request to the `deal_cards()`
    function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包装原始的`deal_cards()`WSGI应用程序。现在我们可以将复合`json_wrapper`对象用作WSGI应用程序。当服务器调用`json_wrapper(environ,
    start_response)`时，将调用对象的`__call__()`方法，在这个例子中，将请求传递给`deal_cards()`函数。
- en: 'Here''s the more complete wrapper application. This wrapper will check the
    HTTP Accept header for the characters `"json"` . It will also check the query
    string for `?$format=json` to see if a JSON-formatted request was made. An instance
    of this class can be configured to reference the `deal_cards()` WSGI application:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更完整的包装器应用程序。此包装器将检查HTTP Accept标头中的字符`"json"`。它还将检查查询字符串以查看是否进行了`?$format=json`的JSON格式请求。此类的一个实例可以配置为引用`deal_cards()`WSGI应用程序：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `__call__()` method checks the Accept header as well as the query string.
    If the string `json` appears anywhere in the HTTP Accept header, then the given
    application is invoked. The environment is updated to include header information
    used by this wrapper.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`__call__()`方法检查Accept标头以及查询字符串。如果HTTP Accept标头中的字符串`json`出现在任何位置，则调用给定的应用程序。环境将更新以包括此包装器使用的标头信息。'
- en: If the HTTP Accept header is not present or doesn't require a JSON response,
    then the query string is checked. This fall-back can be helpful because it is
    difficult to change the headers sent by a browser; using the query string is a
    browser-friendly alternative to the Accept header. The `parse_qs()` function will
    decompose the query string into a dictionary of keys and values. If the query
    string has `$format` as a key, then this is checked to see if the value includes
    `'json'` . If this is true, then the environment is updated with the format information
    found in the query string.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果HTTP Accept标头不存在或不需要JSON响应，则会检查查询字符串。这种回退可能会有所帮助，因为很难更改浏览器发送的标头；使用查询字符串是Accept标头的浏览器友好替代方案。`parse_qs()`函数将查询字符串分解为键和值的字典。如果查询字符串中有`$format`作为键，则会检查其值是否包含`'json'`。如果是这样，则环境将使用查询字符串中找到的格式信息进行更新。
- en: In both cases, the environment is modified when calling the wrapped application.
    The function being wrapped only needs to check the WSGI environment for format
    information. This wrapper object returns the response without any further modification.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，调用被包装的应用程序时会修改环境。被包装的函数只需要检查WSGI环境中的格式信息。这个包装器对象返回响应而不进行任何进一步的修改。
- en: If the request does not request JSON, then a `400 BAD REQUEST` response is sent
    with a simple text message. This will provide some guidance as to why the query
    was unacceptable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求不要求JSON，则会发送`400 BAD REQUEST`响应，并附带简单的文本消息。这将提供一些关于为什么查询不可接受的指导。
- en: 'We use this `JSON_Filter` wrapper class definition as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`JSON_Filter`包装类定义如下：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Instead of making a server from `deal_cards()` , we''ve created an instance
    of the `JSON_Filter` class that references the `deal_cards()` function. This will
    behave almost exactly like the version shown earlier. The important difference
    is that this requires either an Accept header or a URL like this: `http://localhost:8080/?$format=json`
    .'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有从`deal_cards()`创建服务器，而是创建了一个引用`deal_cards()`函数的`JSON_Filter`类的实例。这将几乎与之前显示的版本完全相同。重要的区别是这需要一个Accept头或者一个像这样的URL：`http://localhost:8080/?$format=json`。
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This example has a subtle semantic issue. The `GET` method changes the state
    of the server. This is generally a bad idea.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例有一个微妙的语义问题。`GET`方法改变了服务器的状态。这通常是一个坏主意。
- en: Because we're looking at a browser, it's difficult to sort out problems. There
    isn't much debugging support available here. This means that `print()` functions
    as well as log messages are essential for debugging. Because of the way WSGI works,
    it's essential to print to `sys.stderr` . It is easier to work with Flask, which
    we'll show in the *Using the Flask framework for RESTful APIs* recipe.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在浏览器中查看，很难解决问题。这里几乎没有可用的调试支持。这意味着`print()`函数以及日志消息对于调试是必不可少的。由于WSGI的工作方式，将打印到`sys.stderr`是必不可少的。使用Flask更容易，我们将在*使用Flask框架进行RESTful
    API*的示例中展示。
- en: HTTP supports a number of methods, including `GET` , `POST` , `PUT` , and `DELETE`
    . Generally, it's sensible to map these methods to database **CRUD** operations;
    Create is done with `POST` , Retrieve is done with `GET` , Update is done with
    `PUT` , and Delete maps to `DELETE` . This means that a `GET` operation will not
    change the state of the database.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP支持许多方法，包括`GET`，`POST`，`PUT`和`DELETE`。通常，将这些方法映射到数据库**CRUD**操作是明智的；使用`POST`进行创建，使用`GET`进行检索，使用`PUT`进行更新，使用`DELETE`进行删除。这意味着`GET`操作不会改变数据库的状态。
- en: This leads to the idea that a web service's `GET` operation should be idempotent.
    A series of `GET` operations without any other `POST` , `PUT` , or `DELETE` operation
    should return the same result each time. In this recipe, each `GET` returns a
    different result. This is a semantic problem with using `GET` to deal cards.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一个观点，即Web服务的`GET`操作应该是幂等的。一系列`GET`操作而没有其他`POST`，`PUT`或`DELETE`操作应该每次返回相同的结果。在这个示例中，每个`GET`都返回不同的结果。这是使用`GET`来处理卡片的一个语义问题。
- en: For our purpose of demonstrating the basics, the distinction is minor. In a
    large and more complex web application, the distinction is an important consideration.
    Since the deal service is not idempotent, there's a point of view that suggests
    it should be accessed with the `POST` method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们演示基础知识的目的，这个区别是微不足道的。在一个更大更复杂的Web应用程序中，这个区别是一个重要的考虑因素。由于发牌服务不是幂等的，有一种观点认为它应该使用`POST`方法访问。
- en: To make it easy to explore using a browser, we've avoided checking the method
    in the WSGI application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便在浏览器中进行探索，我们避免检查WSGI应用程序中的方法。
- en: See also
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Python has a wide variety of RESTful API frameworks. In the *Using the Flask
    framework for RESTful APIs* recipe, we'll look at the Flask framework.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python有各种各样的RESTful API框架。在*使用Flask框架进行RESTful API*的示例中，我们将看一下Flask框架。
- en: 'There are three places to look for detailed information on the overall WSGI
    standard:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有三个地方可以查找有关WSGI标准的详细信息：
- en: '**PEP 3333** : See [https://www.python.org/dev/peps/pep-3333/](https://www.python.org/dev/peps/pep-3333/)
    .'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PEP 3333**：请参阅[https://www.python.org/dev/peps/pep-3333/](https://www.python.org/dev/peps/pep-3333/)。'
- en: '**The Python standard library** : It includes the `wsgiref` module. This is
    the reference implementation in the standard library.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python标准库**：它包括`wsgiref`模块。这是标准库中的参考实现。'
- en: '**The Werkzeug project** : See [http://werkzeug.pocoo.org](http://werkzeug.pocoo.org)
    . This is an external library with numerous WSGI utilities. This is used widely
    to implement proper WSGI applications.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Werkzeug项目**：请参阅[http://werkzeug.pocoo.org](http://werkzeug.pocoo.org)。这是一个具有众多WSGI实用程序的外部库。这被广泛用于实现适当的WSGI应用程序。'
- en: Also, see [http://docs.oasis-open.org/odata/odata-json-format/v4.0/odata-json-format-v4.0.html](http://docs.oasis-open.org/odata/odata-json-format/v4.0/odata-json-format-v4.0.html)
    for more information on JSON-formatting of data for web services.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另请参阅[http://docs.oasis-open.org/odata/odata-json-format/v4.0/odata-json-format-v4.0.html](http://docs.oasis-open.org/odata/odata-json-format/v4.0/odata-json-format-v4.0.html)以获取有关为Web服务格式化数据的JSON的更多信息。
- en: Using the Flask framework for RESTful APIs
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flask框架进行RESTful API
- en: In the *Implementing web services with WSGI* recipe, we looked at building RESTful
    APIs and microservices using the WSGI components available in the Python standard
    library. This leads to a large amount of programming to handle a number of common
    cases.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用WSGI实现Web服务*的示例中，我们看到了如何使用Python标准库中可用的WSGI组件构建RESTful API和微服务。这导致了大量的编程来处理许多常见情况。
- en: How can we simplify all of the common web application programming and eliminate
    boilerplate code?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何简化所有常见的Web应用程序编程并消除样板代码？
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, we'll need to add the Flask framework to our environment. This generally
    relies on using `pip` to install the latest release of Flask and the other related
    projects, `itsdangerous` , `Jinja2` , `click` , `MarkupSafe` , and `Werkzeug`
    .
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将Flask框架添加到我们的环境中。这通常依赖于使用`pip`安装Flask的最新版本以及其他相关项目，`itsdangerous`，`Jinja2`，`click`，`MarkupSafe`和`Werkzeug`。
- en: 'The installation looks like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 安装看起来像下面这样：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can see that `Jinja2` and `MarkupSafe` were already installed. The missing
    elements were located by `pip` , downloaded, and installed. Windows users won't
    use the `sudo` command.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`Jinja2`和`MarkupSafe`已经安装。缺少的元素被`pip`找到，下载并安装。Windows用户不会使用`sudo`命令。
- en: Flask allows us to dramatically simplify our web services application. Instead
    of creating a large and possibly complex WSGI-compatible function or callable
    object, we can create a module with separate functions. Each function can handle
    a specific pattern of URL paths.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Flask允许我们大大简化我们的网络服务应用程序。我们不需要创建一个大型且可能复杂的WSGI兼容函数或可调用对象，而是可以创建一个具有单独函数的模块。每个函数可以处理特定的URL路径模式。
- en: We'll look at the same core card-dealing functions we had in the *Implementing
    web services with WSGI* recipe. The `Card` class defines a simple playing card.
    The `Deck` class defines a deck of cards.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看与*使用WSGI实现网络服务*食谱中相同的核心发牌功能。`Card`类定义了一个简单的扑克牌。`Deck`类定义了一副牌。
- en: 'Because Flask handles the details of URL parsing for us, we can create a much
    more sophisticated web service quite easily. We''ll define a path that looks like
    this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Flask为我们处理URL解析的细节，所以我们可以很容易地创建一个更复杂的网络服务。我们将定义一个路径，看起来像这样：
- en: '`/dealer/hand/?cards=5` .'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dealer/hand/?cards=5`。'
- en: 'This route has three important pieces of information:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个路由有三个重要的信息：
- en: The first part of the path, `/dealer/` , is the overall web service.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径的第一部分`/dealer/`是整个网络服务。
- en: The next part of the path, `hand/` , is a specific resource, a hand of cards.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径的下一部分`hand/`是一个特定的资源，一手牌。
- en: The query string, `?cards=5` , defines the cards parameter for the query. This
    is the size of the hand being requested. This is limited to a range of 1 to 52
    cards. A value that's out of range will get a `400` status code because the query
    is invalid.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询字符串`?cards=5`定义了查询的cards参数。这是请求的手牌大小。这限制在1到52张牌的范围内。超出范围的值将得到`400`状态码，因为查询无效。
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import some core definitions from the `flask` package. The `Flask` class defines
    the overall application. The `request` object holds the current web request:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`flask`包中导入一些核心定义。`Flask`类定义了整个应用程序。`request`对象保存当前的web请求：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `jsonify()` function will return a JSON-format object from a Flask view
    function. The `abort()` function returns an HTTP error status and ends processing
    of the request.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsonify()`函数将从Flask视图函数返回一个JSON格式对象。`abort()`函数返回一个HTTP错误状态并结束请求的处理。'
- en: 'Import the underlying classes, `Card` and `Deck` . Ideally, these are imported
    from a separate module. It should be possible to test all of the features outside
    the web services environment:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入底层类`Card`和`Deck`。理想情况下，这些应该从一个单独的模块中导入。应该可以在web服务环境之外测试所有功能：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In order to properly shuffle, we''ll also need the `random` module:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确洗牌，我们还需要`random`模块：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create the `Flask` object. This is the overall web services application. We''ll
    call the Flask application `''dealer''` , and we''ll also assign the object to
    a global variable, `dealer` :'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Flask`对象。这是整个网络服务应用程序。我们将称Flask应用程序为“dealer”，并且还将将对象分配给全局变量`dealer`：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Create any objects used throughout the application. These can be assigned to
    the `Flask` object, `dealer` , as attributes. Be sure to create a unique name
    that doesn't conflict with any of Flask's internal attributes. The alternative
    is to use module globals.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用程序中使用的任何对象。这些可以分配给`Flask`对象`dealer`作为属性。确保创建一个不会与Flask的内部属性冲突的唯一名称。另一种方法是使用模块全局变量。
- en: 'Stateful global objects must be able to work in a multi-threaded environment,
    or threading must be explicitly disabled:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态的全局对象必须能够在多线程环境中工作，或者必须显式禁用线程：
- en: '[PRE22]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For this recipe, the implementation of the `Deck` class is not thread-safe,
    so we'll rely on having a single-threaded server. The `deal()` method should use
    the `Lock` class from the `threading` module to define an exclusive lock to assure
    proper operation with concurrent threads.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，`Deck`类的实现不是线程安全的，所以我们将依赖于单线程服务器。`deal()`方法应该使用`threading`模块中的`Lock`类来定义一个独占锁，以确保与并发线程的正确操作。
- en: 'Define a route—a URL pattern—to a view function that performs a specific request.
    This is a decorator, placed immediately in front of the function. It will bind
    the function to the Flask application:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个路由-到执行特定请求的视图函数的URL模式。这是一个装饰器，直接放在函数的前面。它将把函数绑定到Flask应用程序：
- en: '[PRE23]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Define the view function, which retrieves data or updates the application state.
    In this example, the function does both:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义视图函数，检索数据或更新应用程序状态。在这个例子中，函数两者都做：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Flask parses the string after the `?` in the URL—the query string—to create
    the `request.args` value. A client application or browser can set this value with
    a query string such as `?cards=13` . This will deal 13-card hands for bridge.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Flask解析URL中`?`后面的字符串-查询字符串-以创建`request.args`值。客户端应用程序或浏览器可以使用查询字符串设置此值，例如`?cards=13`。这将为桥牌发牌13张牌。
- en: If the hand size value from the query string is inappropriate, the `abort()`
    function will end processing and return an HTTP status code of `400` . This indicates
    that the request was unacceptable. This is a minimal response, with no more detailed
    content.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查询字符串中的手牌大小值不合适，`abort()`函数将结束处理并返回`400`的HTTP状态码。这表示请求不可接受。这是一个最小的响应，没有更详细的内容。
- en: The real work of the application is a single statement, `cards = dealer.deck.deal(hand_size)`
    . The idea here is to wrap existing functionality in a web framework. The features
    can be tested without the web application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的真正工作是一个简单的语句，`cards = dealer.deck.deal(hand_size)`。这里的想法是在web框架中包装现有功能。可以在没有web应用程序的情况下测试这些功能。
- en: 'The response is handled by the `jsonify()` function: this creates a response
    object. The body of the response which will be a Python object represented in
    JSON notation. If we need to add headers to the response, we can update `response.headers`
    to include additional information.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 响应由`jsonify()`函数处理：这将创建一个响应对象。响应的主体将是以JSON表示的Python对象。如果我们需要向响应添加标头，我们可以更新`response.headers`以包含其他信息。
- en: 'Define the main program which runs the server:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义运行服务器的主程序：
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We've included the `debug=True` option to provide rich debugging information
    in the browser as well as the Flask log file. Once the server is running, we can
    open a browser to see `http://localhost:5000/` . This will return a batch of five
    cards. Each time we refresh, we get a different batch of cards.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了`debug=True`选项，以在浏览器和Flask日志文件中提供丰富的调试信息。服务器运行后，我们可以打开浏览器查看`http://localhost:5000/`。这将返回一批五张卡片。每次刷新，我们都会得到不同的一批卡片。
- en: This works because entering a URL in the browser executes a `GET` request with
    a minimal set of headers. Since our WSGI application didn't require any specific
    headers, and responded to all of the HTTP methods, it will return a result.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在浏览器中输入URL会执行一个带有最小一组标头的`GET`请求。由于我们的WSGI应用程序不需要任何特定的标头，并且响应所有的HTTP方法，它将返回一个结果。
- en: 'The result is a JSON document with five cards. Each card is represented by a
    class name, `rank` , and `suit` information:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含五张卡片的JSON文档。每张卡片由一个类名、`rank`和`suit`信息表示：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To see more than five cards, the URL can be modified. For example, this will
    return a bridge hand: `http://127.0.0.1:5000/dealer/hand/?cards=13` .'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看超过五张卡片，可以修改URL。例如，这将返回一个桥牌手：`http://127.0.0.1:5000/dealer/hand/?cards=13`。
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A Flask application consists of an application object with a number of individual
    view functions. In this recipe, we created a single view function, `deal()` .
    Applications often have numerous functions. A complex website may have many applications,
    each of which has many functions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Flask应用程序由一个带有许多个别视图函数的应用程序对象组成。在这个食谱中，我们创建了一个单独的视图函数`deal()`。应用程序通常有许多函数。一个复杂的网站可能有许多应用程序，每个应用程序都有许多函数。
- en: A route is a mapping between a URL pattern and a view function. This makes it
    possible to have routes which contain parameters that are used by the view function.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是URL模式和视图函数之间的映射。这使得可能有包含视图函数使用的参数的路由。
- en: The `@flask.route` decorator is the technique used to add each route and view
    function into the overall Flask instance. The view function is bound into the
    overall application based on the route pattern.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`@flask.route`装饰器是用于将每个路由和视图函数添加到整个Flask实例中的技术。视图函数根据路由模式绑定到整个应用程序中。'
- en: 'The `run()` method of a `Flask` object does the following kinds of processing.
    This isn''t precisely how Flask works, but it provides a broad outline of the
    various steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flask`对象的`run()`方法执行以下类型的处理。这并不完全是Flask的工作方式，但它提供了各种步骤的大致轮廓：'
- en: It waits for an HTTP request. Flask follow the WSGI standard, the request arrives
    in the form of a dictionary. For more information on WSGI, see the *Implementing
    web services with WSGI* recipe.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它等待HTTP请求。Flask遵循WSGI标准，请求以字典的形式到达。有关WSGI的更多信息，请参阅*使用WSGI实现Web服务*食谱。
- en: It creates a Flask `Request` object from the WSGI environment. The `request`
    object has all of the information from the request, including all of the URL elements,
    query string elements, and any attached documents.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从WSGI环境中创建一个Flask`Request`对象。`request`对象包含来自请求的所有信息，包括所有URL元素、查询字符串元素和任何附加的文档。
- en: Flask then examines the various routes, looking for a route which matches the
    request's path.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask然后检查各种路由，寻找与请求路径匹配的路由。
- en: If a route is found, then the view function is executed. The function creates
    a `Response` object. This is the return value from a view function.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到路由，则执行视图函数。该函数创建一个`Response`对象。这是视图函数的返回值。
- en: If a route is not found, a `404 NOT FOUND` response is sent automatically.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找不到路由，则会自动发送`404 NOT FOUND`响应。
- en: The WSGI pattern is followed to prepare status and headers to start sending
    the response. The `Response` object that was returned from the view function is
    then provided as a stream of bytes.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循WSGI模式准备状态和标头以开始发送响应。然后提供从视图函数返回的`Response`对象作为字节流。
- en: A Flask application can contain a number of methods that make it very easy to
    provide a web service. Flask exposes some of these methods as standalone functions
    that are implicitly bound to the request or the session. This makes it slightly
    simpler to write view functions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Flask应用程序可以包含许多方法，这使得提供Web服务非常容易。Flask将其中一些方法公开为与请求或会话隐式绑定的独立函数。这使得编写视图函数稍微简单一些。
- en: There's more...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In the *Implementing web services with WSGI*  recipe, we wrapped the application
    in a generic test that confirmed that the request had one of two properties. We
    used the following two rules:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用WSGI实现Web服务*食谱中，我们将应用程序包装在一个通用测试中，确认请求具有两个属性中的一个。我们使用了以下两条规则：
- en: An Accept header that required JSON
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个要求JSON的Accept标头
- en: A query string with `$format=json` in it
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中包含`$format=json`的查询字符串
- en: If we're writing a complex RESTful application server, we often want this kind
    of test applied to all of the view functions. We'd rather not repeat the code
    for this test.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在编写一个复杂的RESTful应用程序服务器，我们通常希望对所有视图函数应用这种类型的测试。我们不想重复这个测试的代码。
- en: We can—of course—combine the WSGI solution from the *Implementing web services
    with WSGI* recipe with the Flask application to build a composite application.
    We can also accomplish this entirely within Flask. The pure Flask solution is
    a bit simpler than the WSGI solution, making it desirable.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以将*使用WSGI实现Web服务*食谱中的WSGI解决方案与Flask应用程序结合起来构建一个复合应用程序。我们也可以完全在Flask中完成这个任务。纯Flask解决方案比WSGI解决方案稍微简单一些，因此更受欢迎。
- en: 'We''ve seen the Flask `@flask.route` decorator. Flask has a number of other
    decorators that can be used to define various stages in request and response processing.
    In order to apply a test to the incoming request, we can use the `@flask.before_request`
    decorator. All of the functions with this decoration will be invoked prior to
    the request being processed:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Flask的`@flask.route`装饰器。Flask还有许多其他装饰器，可以用来定义请求和响应处理中的各个阶段。为了对传入的请求应用测试，我们可以使用`@flask.before_request`装饰器。所有带有此装饰的函数将在处理请求之前被调用：
- en: '[PRE27]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When a `@flask.before_request` decorator fails to return a value (or returns
    `None` ), then processing will continue. The routes will be checked, and a view
    function will be evaluated.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当`@flask.before_request`装饰器未能返回值（或返回`None`）时，处理将继续。路由将被检查，并且将评估视图函数。
- en: In this example, if the Accept header includes `json`  or the `$format` query
    parameter is `json` , then the function returns `None` . This means that the normal
    view function will then be found to process the request.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果接受头包括`json`或者`$format`查询参数是`json`，那么函数返回`None`。这意味着正常的视图函数将被找到来处理请求。
- en: When a `@flask.before_request` decorator returns a value, this is the final
    result, and processing stops. In this example, the `check_json()` function may
    return an `abort()` response, which will stop processing. The `abort()` response
    becomes the final response from the Flask application. This makes it very easy
    to return error messages.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当`@flask.before_request`装饰器返回一个值时，这就是最终结果，处理停止。在这个例子中，`check_json()`函数可能返回一个`abort()`响应，这将停止处理。`abort()`响应成为Flask应用程序的最终响应。这使得返回错误消息非常容易。
- en: 'We can now use a browser''s address window to enter a URL like the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用浏览器的地址栏输入以下URL：
- en: '`http://127.0.0.1:5000/dealer/hand/?cards=13&$format=json`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://127.0.0.1:5000/dealer/hand/?cards=13&$format=json`'
- en: This will return a 13-card hand, and the request now explicitly requests the
    result in JSON format. It is instructive to try other values for `$format` as
    well as omitting the `$format` key entirely.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个13张牌的手，并且请求现在明确要求以JSON格式返回结果。尝试其他值作为`$format`以及完全省略`$format`键也是有益的。
- en: Tip
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This example has a subtle semantic issue. The `GET` method changes the state
    of the server. This is generally a bad idea.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子有一个微妙的语义问题。`GET`方法改变了服务器的状态。这通常是一个坏主意。
- en: HTTP supports a number of methods that parallel database CRUD operations. Create
    is done with `POST` , Retrieve is done with `GET` , Update is done with `PUT`
    , and Delete maps to `DELETE` .
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP支持一些与数据库CRUD操作相对应的方法。创建使用`POST`，检索使用`GET`，更新使用`PUT`，删除映射到`DELETE`。
- en: This idea then leads to the idea that a web services `GET` operation should
    be idempotent. A series of `GET` operations—without any other `POST` , `PUT` ,
    or `DELETE` —should return the same result each time. In this example, each `GET`
    returns a different result. Since the deal service is not idempotent, it should
    be accessed with the `POST` method.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法导致了Web服务`GET`操作应该是幂等的想法。一系列`GET`操作——没有其他`POST`，`PUT`或`DELETE`——应该每次返回相同的结果。在这个例子中，每个`GET`都返回不同的结果。由于发牌服务不是幂等的，应该使用`POST`方法访问它。
- en: 'To make it easy to explore using a browser, we''ve avoided checking the method
    in the Flask route. Ideally, the route decorator should look like the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便使用浏览器进行探索，我们避免在Flask路由中检查方法。理想情况下，路由装饰器应该如下所示：
- en: '[PRE28]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Doing this makes it difficult to use a browser to see that the service is working.
    In the *Making REST requests with urllib* recipe we'll look at creating a client,
    and switching to using `POST` for the method.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会使得使用浏览器查看服务是否工作变得困难。在*使用urllib进行REST请求*中，我们将看到如何创建客户端，并切换到使用`POST`进行方法。
- en: See also
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: For background in web services, see the *Implementing web services with WSGI*
    recipe.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Web服务的背景，请参阅*使用WSGI实现Web服务*。
- en: See [http://flask.pocoo.org/docs/0.11/](http://flask.pocoo.org/docs/0.11/) for
    details of Flask.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Flask的详细信息，请参阅[http://flask.pocoo.org/docs/0.11/](http://flask.pocoo.org/docs/0.11/)。
- en: See [https://www.packtpub.com/web-development/learning-flask-framework](https://www.packtpub.com/web-development/learning-flask-framework)
    to learn more about the Flask framework. Also, [https://www.packtpub.com/web-development/mastering-flask](https://www.packtpub.com/web-development/mastering-flask)
    has more information on mastering Flask.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[https://www.packtpub.com/web-development/learning-flask-framework](https://www.packtpub.com/web-development/learning-flask-framework)了解更多关于Flask框架的信息。另外，[https://www.packtpub.com/web-development/mastering-flask](https://www.packtpub.com/web-development/mastering-flask)有更多关于掌握Flask的信息。
- en: Parsing the query string in a request
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析请求中的查询字符串
- en: A URL is a complex object. It contains at least six separate pieces of information.
    More information can be included via optional elements.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: URL是一个复杂的对象。它至少包含六个单独的信息。可以通过可选元素包含更多信息。
- en: 'A URL such as `http://127.0.0.1:5000/dealer/hand/?cards=13&$format=json` has
    several fields:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 例如`http://127.0.0.1:5000/dealer/hand/?cards=13&$format=json`的URL有几个字段：
- en: '`http` is the scheme. `https` is for secure connections using encrypted sockets.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http`是方案。`https`用于使用加密套接字进行安全连接。'
- en: '`127.0.0.1` can be called the authority, although network location is more
    commonly used. This particular IP address means the localhost and is a kind of
    loopback to the localhost. The name localhost maps to this IP address.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`127.0.0.1`可以称为授权，尽管网络位置更常用。这个特定的IP地址意味着本地主机，是本地主机的一种回环。本地主机的名称映射到这个IP地址。'
- en: '`5000` is the port number, and is part of the authority.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5000`是端口号，是授权的一部分。'
- en: '`/dealer/hand/` is the path to a resource.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dealer/hand/`是资源的路径。'
- en: '`cards=13&$format=json` is a query string, and it''s separated from the path
    by the `?` character.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cards=13&$format=json`是一个查询字符串，它与路径由`?`字符分隔开。'
- en: 'The query string can be quite complex. While not an official standard, it''s
    possible (and common) for a query string to have a repeated key. The following
    query string is valid, though perhaps confusing:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串可能非常复杂。虽然不是官方标准，但查询字符串可能有重复的键。以下查询字符串是有效的，尽管可能令人困惑：
- en: '[PRE29]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We've repeated the `cards` key. The web service will provide a thirteen-card
    hand and a five-card hand.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重复了`cards`键。Web服务将提供13张牌和5张牌。
- en: '[ *The author is unaware of any card games with hands of varying sizes. The
    lack of a good user story makes this example somewhat contrived.* ]'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[*作者不知道有任何手牌大小不同的纸牌游戏。缺乏一个好的用户故事使得这个例子有些牵强。*]'
- en: 'The ability to repeat a key breaks the possibility of a simple mapping between
    a URL query string and a built-in Python dictionary. There are several possible
    solutions to this problem:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 重复键的能力破坏了URL查询字符串和内置Python字典之间简单映射的可能性。这个问题有几种可能的解决方案：
- en: Each key in the dictionary must be associated with a `list` that contains all
    of the values. This is awkward for the most common case where a key is not repeated;
    each list has only a single item. This solution is implemented via the `parse_qs()`
    in `urllib.parse` .
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典中的每个键必须与包含所有值的`list`相关联。对于最常见的情况，即键不重复的情况，这很麻烦；每个列表只有一个项目。这个解决方案是通过`urllib.parse`中的`parse_qs()`实现的。
- en: Each key is only saved once and the first (or last) value is kept, the other
    values are dropped. This is awful.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个键只保存一次，第一个（或最后一个）值被保留，其他值被丢弃。这太糟糕了。
- en: A dictionary not used. Instead the query string can be parsed into a list of
    *(key, value* *)* pairs. This also allows keys to be duplicated. For the common
    case with unique keys, the list can be converted to a dictionary. For the uncommon
    case, the duplicated keys can be handled some other way. This is implemented by
    the `parse_qsl()` in `urllib.parse` .
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用字典。相反，查询字符串可以解析为*(键，值)*对的列表。这也允许键重复。对于具有唯一键的常见情况，列表可以转换为字典。对于不常见的情况，可以以其他方式处理重复的键。这是由`urllib.parse`中的`parse_qsl()`实现的。
- en: Is there a better way to handle a query string? Can we have a more sophisticated
    structure that behaves like a dictionary with single values for the common case,
    and a more complex object for the rare cases where a field key is duplicated and
    has multiple values?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有更好的方法来处理查询字符串？我们是否可以有一个更复杂的结构，行为类似于字典，对于常见情况具有单个值，并且对于罕见情况具有重复键和多个值的更复杂对象？
- en: Getting ready
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Flask depends on another project, `Werkzeug` . When we install Flask using `pip`
    , the requirements will lead `pip` to also install the Werkzeug toolkit. Werkzeug
    has a data structure that provides an excellent way to handle query strings.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Flask依赖于另一个项目`Werkzeug`。当我们使用`pip`安装Flask时，要求将导致`pip`也安装Werkzeug工具包。Werkzeug有一个数据结构，提供了处理查询字符串的绝佳方式。
- en: We'll modify the example in the *Using the Flask framework for RESTful APIs*
    recipe to use a somewhat more complex query string. We'll add a second route that
    deals multiple hands. The sizes of each hand will be specified in a query string
    that allows repeated keys.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改*使用Flask框架进行RESTful API*配方中的示例，以使用更复杂的查询字符串。我们将添加一个第二个路由，用于发放多手牌。每手牌的大小将在允许重复键的查询字符串中指定。
- en: How to do it...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Start with the *Using the Flask framework for RESTful APIs* recipe. We'll be
    adding a new view function to an existing web application.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*使用Flask框架进行RESTful API*配方开始。我们将向现有Web应用程序添加一个新的视图函数。
- en: 'Define a route—a URL pattern—to a view function that performs a specific request.
    This is a decorator, placed immediately in front of the function. It will bind
    the function to the Flask application:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个路由——一个URL模式——到执行特定请求的视图函数。这是一个装饰器，直接放在函数前面。它将把函数绑定到Flask应用程序上：
- en: '[PRE30]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define a view function that responds to requests sent to the particular route:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个视图函数，响应发送到特定路由的请求：
- en: '[PRE31]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Within the view function, extract the values of a unique key with the `get()`
    method or use ordinary `[]` syntax that is appropriate for the built-in dict type.
    This returns individual values without the complication of a list for the common
    case where the list would only have a single element.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图函数中，使用`get()`方法提取唯一键的值，或者使用适用于内置dict类型的普通`[]`语法。这会返回单个值，而不会出现列表的复杂情况，其中列表只有一个元素的常见情况。
- en: 'For repeated keys, use the `getlist()` method. This returns each of the values
    as a list. Here''s a view function that looks for a query string such as `?card=5&card=5`
    to deal two five-card hands:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于重复的键，使用`getlist()`方法。这会将每个值作为列表返回。以下是一个查找查询字符串的视图函数，例如`?card=5&card=5`来发放两手五张牌：
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function will get all of the `cards` keys from the query string. If the
    values are all integers, and each value is in the range 1 to 52 (inclusive), then
    the values are valid, and the view function will return a result. If there are
    no `cards` key values in the query, then four hands of 13 cards will be dealt.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将从查询字符串中获取所有`cards`键。如果值都是整数，并且每个值都在1到52的范围内（包括1和52），那么这些值就是有效的，视图函数将返回一个结果。如果查询中没有`cards`键值，那么将发放13张牌的四手牌。
- en: 'The response will be a JSON representation of each hand as a small dictionary
    with two keys: a hand ID, and the cards from the hand.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将是每手牌的JSON表示，作为一个小字典，有两个键：手牌ID和手牌上的牌。
- en: 'Define a main program that runs the server:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个运行服务器的主程序：
- en: '[PRE33]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once the server is running, we can open a browser to see this URL:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器运行后，我们可以打开浏览器查看这个URL：
- en: '`http://localhost:5000/?cards=5&cards=5&$format=json`'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://localhost:5000/?cards=5&cards=5&$format=json`'
- en: 'The result is a JSON document with two hands of five cards. We''ve elided some
    details to emphasize the structure of the response:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个JSON文档，其中有两手五张牌。我们省略了一些细节，以强调响应的结构：
- en: '[PRE34]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Because the web service parses the query string, it's trivial to add more complex
    hand sizes to the query string. The example includes the `$format=json` based
    on the *Using the Flask framework for RESTful APIs* recipe.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Web服务解析查询字符串，向查询字符串添加更复杂的手牌大小是微不足道的。示例包括基于*使用Flask框架进行RESTful API*配方的`$format=json`。
- en: If the `@dealer.before_request` function, `check_json()` , is implemented to
    check for JSON, then the `$format` is required. If the `@dealer.before_request`
    function, `check_json()` , is not implemented, then the additional information
    in the query string is ignored.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实现了`@dealer.before_request`函数`check_json()`来检查JSON，那么就需要`$format`。如果未实现`@dealer.before_request`函数`check_json()`，那么查询字符串中的附加信息将被忽略。
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Werkzeug—`Multidict` class is a very handy data structure. This is an extension
    to the built-in dictionary. It allows multiple, distinct values for a given key.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Werkzeug的`Multidict`类是一个非常方便的数据结构。这是内置字典的扩展。它允许为给定的键有多个不同的值。
- en: We can build something like this using the `defaultdict` class from the `collections`
    module. The definition would be `defaultdict(list)` . The problem with this definition
    is that the value of every key is a list, even when the list only has a single
    item as a value.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`collections`模块中的`defaultdict`类构建类似的东西。定义将是`defaultdict(list)`。这个定义的问题是每个键的值都是一个列表，即使列表只有一个项目作为值。
- en: The advantage provided by the `Multidict` class are the variations on the `get()`
    method. The `get()` method returns the first value when there are many copies
    of a key or the only value when the key occurs only once. This has a default parameter,
    as well. This method parallels the method of the built-in `dict` class.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`Multidict`类提供的优势是`get()`方法的变体。当一个键有多个副本时，`get()`方法返回第一个值，或者当键只出现一次时返回唯一的值。这也有一个默认参数。这个方法与内置的`dict`类的方法相对应。'
- en: The `getlist()` method, however, returns a list of all values for a given key.
    This method is unique to the `Multidict` class. We can use this method to parse
    more complex query strings.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`getlist()`方法返回给定键的所有值的列表。这种方法是`Multidict`类的独特方法。我们可以使用这种方法来解析更复杂的查询字符串。
- en: One common technique that's used to validate query strings is to pop items as
    they are validated. This is done with the `pop()` and `poplist()` methods. These
    will remove the key from the `Multidict`  class. If any keys remain after checking
    all the valid keys, these extras can be considered syntax errors, and the web
    request rejected with `abort(HTTPStatus.BAD_REQUEST)` .
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 用于验证查询字符串的常见技术是在验证时弹出项目。这是通过`pop()`和`poplist()`方法完成的。这些方法将从`Multidict`类中删除键。如果在检查所有有效键后仍然存在键，则这些额外的键可以被视为语法错误，并且Web请求将被拒绝并显示`abort(HTTPStatus.BAD_REQUEST)`。
- en: There's more...
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The query string uses relatively simple syntax rules. There are one or more
    key-value pairs using `=`  as the punctuation between key and value. The separator
    between each pair is the `&`  character. Because of the meaning of other characters
    in parsing a URL, there is one other rule that's important—the keys and values
    must be encoded.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串使用相对简单的语法规则。使用`=`作为键和值之间的标点符号的一个或多个键值对。每对之间的分隔符是`&`字符。由于其他字符在解析URL时的含义，还有一个重要的规则——键和值必须被编码。
- en: 'The URL encoding rules require that certain characters be replaced with HTML
    entities. The technique is called percent encoding. This means that when we put
    `&` into the value of a query string, it must be encoded as `%26` , here''s an
    example showing this encoding:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: URL编码规则要求用HTML实体替换某些字符。这种技术称为百分比编码。这意味着当我们将`&`放入查询字符串的值中时，它必须被编码为`%26`，下面是一个显示这种编码的示例：
- en: '[PRE35]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The value `this&that`  was encoded to `this%26that` .
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 值`this&that`被编码为`this%26that`。
- en: 'There''s a short list of characters which must have the `%` -encoding rules
    applied. This comes from the *RFC 3986* , refer to *section 2.2* , *Reserved Characters*
    . The list includes these characters:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有一小部分字符必须应用`%`编码规则。这来自*RFC 3986*，参见*第2.2节*，*保留字符*。列表包括这些字符：
- en: '[PRE36]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Generally, the JavaScript code associated with a web page will handle encoding
    query strings. If we're writing an API client in Python, we need to use the `urlencode()`
    function to properly encode query strings. Flask handles the decoding automatically
    for us.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，与网页关联的JavaScript代码将处理编码查询字符串。如果我们在Python中编写API客户端，我们需要使用`urlencode()`函数来正确编码查询字符串。Flask会自动处理解码。
- en: There's a practical size limit on the query string. Apache HTTPD, for example,
    has a `LimitRequestLine` configuration parameter with a default value of `8190`
    . This limits the overall URL to this size.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串有一个实际的大小限制。例如，Apache HTTPD有一个`LimitRequestLine`配置参数，默认值为`8190`。这将限制整个URL的大小。
- en: 'In the OData specifications ([http://docs.oasis-open.org/odata/odata/v4.0/](http://docs.oasis-open.org/odata/odata/v4.0/)
    ), there are several kinds of value that are suggested for the query options.
    This specification suggests that our web services should support the following
    kinds of query option:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在OData规范（[http://docs.oasis-open.org/odata/odata/v4.0/](http://docs.oasis-open.org/odata/odata/v4.0/)）中，建议查询选项使用几种类型的值。该规范建议我们的Web服务应支持以下类型的查询选项：
- en: For a URL that identifies an entity or a collection of entities, the `$expand`
    and `$select` options can be used. Expanding a result means that the query will
    provide additional details. The select query will impose additional criteria on
    the collection.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于标识实体或实体集合的URL，可以使用`$expand`和`$select`选项。扩展结果意味着查询将提供额外的细节。选择查询将对集合施加额外的条件。
- en: A URL that identifies a collection should support `$filter` , `$search` , `$orderby`
    , `$count` , `$skip` , and `$top` options. These don't make sense for a URL that
    returns a single item. The `$filter` and `$search` options accept complex conditions
    for finding data. The `$orderby` option defines a particular order to impose on
    the results.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识集合的URL应支持`$filter`、`$search`、`$orderby`、`$count`、`$skip`和`$top`选项。这对于返回单个项目的URL没有意义。`$filter`和`$search`选项接受用于查找数据的复杂条件。`$orderby`选项定义了对结果施加的特定顺序。
- en: The `$count` option changes the query fundamentally. It will return the count
    of items instead of the items themselves.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`$count`选项从根本上改变了查询。它将返回项目的计数而不是项目本身。'
- en: The `$top` and `$skip` options are used to page through data. If the count is
    large, it's common to use the `$top` option to limit the results to a specific
    number that will be shown on a web page. The value of the `$skip` option determines
    which page of data will be shown. For example, `$top=20$skip=40` would be page
    3 of the results—the top twenty after skipping 40.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`$top`和`$skip`选项用于浏览数据。如果计数很大，通常使用`$top`选项将结果限制为在网页上显示的特定数量。`$skip`选项的值确定将显示哪一页数据。例如，`$top=20$skip=40`将是结果的第3页-跳过40后的前20个。'
- en: Generally, all URLs should support the `$format` option to specify the format
    of the result. We've been focusing on JSON, but a more sophisticated service might
    offer CSV output or even XML.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有URL都应支持`$format`选项以指定结果的格式。我们一直专注于JSON，但更复杂的服务可能提供CSV输出，甚至XML。
- en: See also
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Using the Flask framework for RESTful APIs* recipe for the basics of
    using Flask for web services.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅*使用Flask框架进行RESTful API*配方，了解如何使用Flask进行Web服务的基础知识。
- en: In the *Making REST requests with urllib* recipe, we'll look at how to write
    a client application that can prepare complex query strings.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*使用urllib进行REST请求*配方中，我们将看看如何编写一个能够准备复杂查询字符串的客户端应用程序。
- en: Making REST requests with urllib
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用urllib进行REST请求
- en: 'A web application has two essential parts:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序有两个基本部分：
- en: '**A client** : This can be a user''s browser, but may also be a mobile device
    app. In some cases, a web server may be a client of other web servers.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：这可以是用户的浏览器，但也可能是移动设备应用程序。在某些情况下，Web服务器可能是其他Web服务器的客户端。'
- en: '**A server** : This provides the web services and resources we''ve been looking
    at, in the *Implementing web services with WSGI* , *Using the Flask framework
    for RESTful APIs* , and *Parsing the query string in a request* recipes, as well
    as other recipes, such as *Parsing a JSON request* and *Implementing authentication
    for web services* .'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器**：这提供了我们一直在寻找的Web服务和资源，即*使用WSGI实现Web服务*，*使用Flask框架进行RESTful API*和*解析请求中的查询字符串*配方，以及其他配方，如*解析JSON请求*和*为Web服务实现身份验证*。'
- en: A browser-based client will generally be written in JavaScript. Mobile apps
    are written in a variety of languages, with a focus on Java for Android devices
    and Objective-C with Swift for iOS devices.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 基于浏览器的客户端通常是用JavaScript编写的。移动应用程序是用各种语言编写的，重点是Android设备的Java和iOS设备的Objective-C和Swift。
- en: There are several user stories that involve RESTful API clients written in Python.
    How can we create a Python program that is a client of RESTful web services?
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个用户故事涉及用Python编写的RESTful API客户端。我们如何创建一个Python程序，作为RESTful Web服务的客户端？
- en: Getting ready
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We''ll assume that we have a web server based on the *Implementing web services
    with WSGI* , *Using the Flask framework for RESTful APIs* , or *Parsing the query
    string in a request* recipe. We can write a formal specification for this server''s
    behavior in the following way:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设我们有一个基于*使用Flask框架进行RESTful API*或*解析请求中的查询字符串*配方的Web服务器。我们可以以以下方式为该服务器的行为编写正式规范：
- en: '[PRE37]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This document provides us some guidance on how to consume these services using
    Python's `urllib` module. It also describes what the expected responses should
    be, giving us guidance on how to handle the responses.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档为我们提供了如何使用Python的`urllib`模块来消耗这些服务的指导。它还描述了预期的响应应该是什么，为我们提供了如何处理这些响应的指导。
- en: 'Some of the fields in this specification define a base URL. These three fields,
    in particular, provide this information:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 规范中的某些字段定义了基本URL。特别是这三个字段提供了这些信息：
- en: '[PRE38]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `produces`  and `consumes`  fields provide information that helps to build
    and verify the HTTP headers. The request `Content-Type` header must be a **Multipurpose
    Internet Mail Extensions** ( **MIME** ) type that the server consumes. Similarly,
    the request Accept header must specify a MIME type that the server produces. In
    both cases, we'll supply `application/json` .
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`produces`和`consumes`字段提供了帮助构建和验证HTTP标头的信息。请求的`Content-Type`标头必须是服务器消耗的**多用途互联网邮件扩展**（**MIME**）类型。同样，请求的Accept标头必须指定服务器生成的MIME类型。在这两种情况下，我们将提供`application/json`。'
- en: The detailed service definitions are provided in the `paths` section of the
    specification. The `/hands` path, for example, shows the details of how to make
    a request for multiple hands. The path detail is a suffix for the `basePath` value.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 详细的服务定义在规范的`paths`部分中提供。例如，`/hands`路径显示了如何请求多个手的详细信息。路径详细信息是`basePath`值的后缀。
- en: When the HTTP method is `get` , then parameters are provided in the query. The
    `cards` parameter in the query provides an integer number of cards, and it can
    be repeated multiple times.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当HTTP方法为`get`时，参数是在查询中提供的。查询中的`cards`参数提供了一个整数卡的数量，并且可以多次重复。
- en: The response will include at least the response described. In this case, the
    HTTP status will be `200` , and the body of the response has a minimal description.
    It's possible to provide a more formal schema definition for the response, we'll
    omit that from this example.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 响应将至少包括所描述的响应。在这种情况下，HTTP状态将是`200`，响应的正文具有最少的描述。可以为响应提供更正式的模式定义，我们将在此示例中省略。
- en: How to do it...
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import the `urllib` components that are required. We''ll be making URL requests,
    and building more complex objects, such as query strings. We''ll need the `urllib.request`
    and `urllib.parse` modules for these two features. Since the expected response
    is in JSON, then the `json` module will be useful as well:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的`urllib`组件。我们将发出URL请求，并构建更复杂的对象，如查询字符串。我们将需要`urllib.request`和`urllib.parse`模块来实现这两个功能。由于预期的响应是JSON格式，因此`json`模块也将很有用：
- en: '[PRE39]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Define the query string that will be used. In this case, all of the values
    happen to be fixed. In a more complex application, some might be fixed and some
    might be based on user inputs:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义将要使用的查询字符串。在这种情况下，所有值恰好是固定的。在更复杂的应用程序中，一些值可能是固定的，而另一些可能基于用户输入：
- en: '[PRE40]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Use the query to build the pieces of the full URL:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用查询构建完整URL的各个部分：
- en: '[PRE41]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this case, we're using a `ParseResult` object to hold the relevant parts
    of the URL. This class isn't graceful about missing items, so we must provide
    explicit `None` values for parts of the URL that aren't being used.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`ParseResult`对象来保存URL的相关部分。这个类对于缺少的项目并不优雅，所以我们必须为URL的未使用部分提供明确的`None`值。
- en: We could use `"http://127.0.0.1:5000/dealer/hand/?cards=5"` in our script. However,
    this condensed string is awkward to change. It's useful as a compact message when
    making the request, but it's not ideal for making flexible, maintainable, and
    testable programs.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在脚本中使用`"http://127.0.0.1:5000/dealer/hand/?cards=5"`。然而，这种紧凑的字符串很难更改。在发出请求时，它作为一个紧凑的消息很有用，但不太适合制作灵活、可维护和可测试的程序。
- en: 'Using this long constructor has the advantage of providing explicit values
    for each part of a URL. In more complex applications, the individual pieces are
    built from an analysis of the JSON Swagger specification document shown previously:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个长构造函数的优点是为URL的每个部分提供明确的值。在更复杂的应用程序中，这些单独的部分是从先前显示的JSON Swagger规范文档的分析中构建的：
- en: 'Build a final `Request` instance. We''ll use the URL built from a variety of
    pieces. We''ll explicitly provide an HTTP method (browsers tend to use `GET`  as
    a default). Also, we can provide explicit headers:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建最终的`Request`实例。我们将使用从各种部分构建的URL。我们将明确提供一个HTTP方法（浏览器通常使用`GET`作为默认值）。此外，我们可以提供明确的头部：
- en: '[PRE42]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We've provided the HTTP Accept header to state MIME type results that will be
    produced by the server, and accepted by the client. We've provided the HTTP `Content-Type`
    header to state the request consumed by the server, and provided by our client
    script.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提供了HTTP Accept头部来声明服务器将产生的MIME类型结果，并被客户端接受。我们已经提供了HTTP `Content-Type`头部来声明服务器消耗的请求，并由我们的客户端脚本提供。
- en: 'Open a context to process the response. The `urlopen()` function makes the
    request, handling all of the complexities of the HTTP protocol. The final `result`
    object is available for processing as a response:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个上下文来处理响应。`urlopen()`函数发出请求，处理HTTP协议的所有复杂性。最终的`result`对象可用于作为响应进行处理：
- en: '[PRE43]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Generally, there are three attributes of the response that are of particular
    interest:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一般来说，响应的三个属性特别重要：
- en: '[PRE44]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `status` is the final status code. We expect a HTTP status `200` for a normal
    request. The `headers` include all of the headers that are part of the response.
    We might, for example, want to check that the `response.headers['Content-Type']`
    really is `application/json` .
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`status`是最终的状态码。我们期望一个正常请求的HTTP状态码为`200`。`headers`包括响应的所有头部。例如，我们可能想要检查`response.headers[''Content-Type'']`是否真的是`application/json`。'
- en: The value of `response.read()` are the bytes downloaded from the server. We'll
    often need to decode these to get proper Unicode characters. The `utf-8` encoding
    scheme is very common. We can use `json.loads()` to create a Python object from
    the JSON document.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`response.read()`的值是从服务器下载的字节。我们经常需要解码这些字节以获得正确的Unicode字符。`utf-8`编码方案非常常见。我们可以使用`json.loads()`从JSON文档创建一个Python对象。'
- en: 'When we run this, we''ll see the following output:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个时，我们会看到以下输出：
- en: '[PRE45]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The initial `200` is the status, showing that everything worked properly. There
    were four headers provided by the server. Finally, the internal Python object
    was an array of small dictionaries that provided information about the cards which
    were dealt.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的`200`是状态，显示一切都正常工作。服务器提供了四个头部。最后，内部Python对象是一组小字典，提供了有关已发牌的卡片的信息。
- en: To reconstruct `Card` objects, we'd need to use a slightly more clever JSON
    parser. See the *Reading JSON documents* recipe in [Chapter 9](text00099.html#page
    "Chapter 9. Input/Output, Physical Format, and Logical Layout") , *Input/Output,
    Physical Format, and Logical Layout* .
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要重建`Card`对象，我们需要使用一个稍微聪明的JSON解析器。参见[第9章](text00099.html#page "第9章. 输入/输出、物理格式和逻辑布局")中的*读取JSON文档*配方，*输入/输出、物理格式和逻辑布局*。
- en: How it works...
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We''ve built up the request through several explicit steps:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过几个明确的步骤构建了请求：
- en: The query data started as a simple dictionary with keys and values.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询数据最初是一个简单的带有键和值的字典。
- en: The `urlencode()` function turned the query data into a query string, properly
    encoded.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`urlencode()`函数将查询数据转换为查询字符串，正确编码。'
- en: The URL as a whole started as individual components in a `ParseResult` object.
    This makes each piece visible, and changeable. For this particular API, the pieces
    are largely fixed. In other APIs, the path and the query portion of the URL might
    both have dynamic values.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个URL最初作为`ParseResult`对象中的各个组件开始。这使得每个部分都是可见的，并且可以更改。对于这个特定的API，这些部分基本上是固定的。在其他API中，URL的路径和查询部分可能都具有动态值。
- en: The request as a whole was built from URL, method, and a dictionary of headers.
    This example did not provide a separate document as the body of a request. If
    a complex document is sent, or a file is uploaded, this is also done by providing
    details to the `Request` object.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整个请求是由URL、方法和头部字典构建的。这个例子没有提供单独的文档作为请求的主体。如果发送复杂的文档，或者上传文件，也可以通过向`Request`对象提供详细信息来完成。
- en: The step by step assembly isn't required for a simple application. In the simple
    cases, a literal string value for the URL might be acceptable. At the other extreme,
    a more complex application may print out intermediate results as a debugging aid
    to be sure that the request is being constructed correctly.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步组装对于简单的应用程序并不是必需的。在简单的情况下，URL的字面字符串值可能是可以接受的。在另一个极端，一个更复杂的应用程序可能会打印出中间结果作为调试辅助，以确保请求被正确构造。
- en: The other benefit of spelling out the details like this is to provide a handy
    avenue for unit testing. See [Chapter 11](text00120.html#page "Chapter 11. Testing")
    , *Testing* , for more information. We can often decompose a web client into request
    building and request processing. The request building can be tested carefully
    to be sure that all of the elements are set properly. The request processing can
    be tested with dummy results that don't involve a live connection to a remote
    server.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这样详细说明的另一个好处是提供一个方便的单元测试途径。有关更多信息，请参见[第11章](text00120.html#page "第11章。测试") ，*测试*。我们经常可以将Web客户端分解为请求构建和请求处理。可以仔细测试请求构建，以确保所有元素都设置正确。请求处理可以使用不涉及与远程服务器的实时连接的虚拟结果进行测试。
- en: There's more...
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: User authentication is often an important part of a web service. For HTML-based
    websites—where user interaction is emphasized—people expect the server to understand
    a long-running sequence of transactions via a session. The person will authenticate
    themselves once (often with a username and password) and the server will use this
    information until the person logs out or the session expires.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 用户身份验证通常是Web服务的重要组成部分。对于基于HTML的网站——强调用户交互——人们希望服务器能够理解通过会话的长时间运行的事务序列。用户将进行一次身份验证（通常使用用户名和密码），服务器将使用这些信息直到用户注销或会话过期。
- en: For RESTful web services, there is rarely the concept of a session. Each request
    is processed separately, and the server is not expected to maintain a complex
    long-running transaction state. This responsibility shifts to the client application.
    The client is required to make appropriate requests to build up a complex document
    that can be presented as a single transaction.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 对于RESTful Web服务，很少有会话的概念。每个请求都是单独处理的，服务器不需要维护复杂的长时间运行的事务状态。这个责任转移到了客户端应用程序。客户端需要进行适当的请求来构建一个可以呈现为单个事务的复杂文档。
- en: For RESTful APIs, each request may include authentication information. We'll
    look at this in detail in the *Implementing Authentication for web services* recipe.
    For now, we'll look at providing additional details via headers. This will fit
    comfortably with our RESTful client script.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 对于RESTful API，每个请求可能包括身份验证信息。我们将在*为Web服务实现身份验证*配方中详细讨论这一点。现在，我们将通过标题提供额外的细节。这将与我们的RESTful客户端脚本很好地契合。
- en: 'There are a number of ways that authentication information is provided to a
    web server:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多提供身份验证信息给Web服务器的方法：
- en: Some services use the HTTP `Authorization` header. When used with the Basic
    mechanism a client can provide a username and password with each request.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些服务使用HTTP的`Authorization`标题。当与基本机制一起使用时，客户端可以在每个请求中提供用户名和密码。
- en: Some services will invent an entirely new header with a name such as API-Key.
    The value for this header might be a complex string that has encoded information
    about the requestor.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些服务将发明一个全新的标题，名称为API密钥。该标题的值可能是一个复杂的字符串，其中包含有关请求者的编码信息。
- en: Some services will invent a header with a name such as `X-Auth-Token` . This
    may be used in a multi-step operation where a username and password credentials
    are sent as part of an initial request. The result will include a string value
    (a token) that can be used for subsequent API requests. Often, the token has a
    short expiration period and must be renewed.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些服务将发明一个名为`X-Auth-Token`的标题。这可能在多步操作中使用，其中用户名和密码凭据作为初始请求的一部分发送。结果将包括一个字符串值（令牌），可用于后续API请求。通常，令牌具有短暂的过期时间，并且必须更新。
- en: Generally, these methods require the **Secure Socket Layer** ( **SSL** ) protocol.
    This is available as the `https` scheme. In order to handle the SSL protocol,
    the servers (and sometimes the clients) must have proper certificates. These are
    used as part of the negotiation between client and server to set up the encrypted
    socket pair.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些方法需要**安全套接字层**（**SSL**）协议。这可以作为`https`方案使用。为了处理SSL协议，服务器（有时也是客户端）必须具有适当的证书。这些证书用作客户端和服务器之间的协商的一部分，以建立加密套接字对。
- en: 'All of these authentication techniques have a feature in common—they rely on
    sending additional information in headers. They differ slightly in which header
    is used, and what information is sent. In the simplest case, we might have something
    like the following:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些身份验证技术都有一个共同的特点——它们依赖于在标题中发送附加信息。它们在使用的标题和发送的信息方面略有不同。在最简单的情况下，我们可能会有以下内容：
- en: '[PRE46]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This hypothetical request would be for a web service that requires a password
    provided in an `X-Authentication` header. In the *Implementing Authentication
    for web services* recipe, we'll add an authentication feature to the web server.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这个假设的请求将是针对需要在`X-Authentication`标题中提供密码的Web服务。在*为Web服务实现身份验证*配方中，我们将向Web服务器添加身份验证功能。
- en: The OpenAPI (Swagger) specification
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OpenAPI（Swagger）规范
- en: Many servers will explicitly provide a specification as a file at a fixed, standard
    URL path of `/swagger.json` . The OpenAPI specification was formerly known as
    **Swagger** , and the filename that provides the interface reflects that history.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 许多服务器将明确提供规范作为固定的标准URL路径`/swagger.json`的文件。OpenAPI规范以前被称为**Swagger**，提供接口的文件名反映了这一历史。
- en: 'If provided, we can get a website''s OpenAPI specification in the following
    way:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供，我们可以以以下方式获取网站的OpenAPI规范：
- en: '[PRE47]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Once we have the specification, we can use it to get the details for the service
    or resource. We can use the technical information in the specification to build
    URLs, query strings, and headers.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了规范，我们可以使用它来获取服务或资源的详细信息。我们可以使用规范中的技术信息来构建URL、查询字符串和标题。
- en: Adding Swagger to the server
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Swagger添加到服务器
- en: For our little demonstration server, one additional view function is required
    to provide the OpenAPI Swagger specification. We can update the `ch12_r03.py`
    module to respond to a request for `swagger.json` .
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的小型演示服务器，需要一个额外的视图函数来提供OpenAPI Swagger规范。我们可以更新`ch12_r03.py`模块以响应对`swagger.json`的请求。
- en: 'There are several ways to handle this important information:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种处理这些重要信息的方法：
- en: A separate, static file. That's what's shown in this recipe. It's a very simple
    way to provide the required content.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个单独的静态文件。这就是这个配方中显示的内容。这是提供所需内容的一种非常简单的方式。
- en: 'Here''s a view function we can add that will send a file. Of course, we also
    need to put the specification into the named file:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们可以添加的视图函数，它将发送一个文件。当然，我们还需要将规范放入命名文件中：
- en: '[PRE48]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The drawback of this approach is that the specification is separate from the
    implementation module.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是规范与实现模块分开。
- en: Embed the specification as a large blob of text in the module. We could, for
    example, provide the specification as the docstring for the module itself. This
    provides a visible place to put important documentation, but it makes it more
    difficult to include docstring test cases at the module level.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将规范嵌入模块中的大块文本。例如，我们可以将规范提供为模块本身的文档字符串。这提供了一个可见的地方来放置重要的文档，但这使得在模块级别包含文档字符串测试用例更加困难。
- en: 'This view function sends the module docstring, assuming that the string is
    a valid JSON document:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图函数发送模块文档字符串，假设该字符串是一个有效的JSON文档：
- en: '[PRE49]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This has the disadvantage of requiring that we check the syntax of the docstring
    to be sure that it's valid JSON. This is in addition to validating that the module
    implementation actually conforms to the specification.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是需要检查文档字符串的语法以确保其是有效的JSON。这除了验证模块实现实际上是否符合规范之外。
- en: 'Create a Python specification object in proper Python syntax. This can then
    be encoded into JSON and transmitted. This view function sends a `specification`
    object. This will have to be a valid Python object that can be serialized into
    JSON notation:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在适当的Python语法中创建一个Python规范对象。然后可以将其编码为JSON并传输。这个视图函数发送一个 `specification` 对象。这将是一个有效的Python对象，可以序列化为JSON表示法：
- en: '[PRE50]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In all cases, there are several benefits to having a formal specification available:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，拥有正式规范可用有几个好处：
- en: Client applications can download the specification to fine-tune their processing.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序可以下载规范以微调其处理。
- en: When examples are included, the specification becomes a series of test cases
    for both client and server.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当包含示例时，规范成为客户端和服务器的一系列测试用例。
- en: The various details of the specification can also be used by the server application
    to provide validation rules, defaults, and other details.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 规范的各种细节也可以被服务器应用程序用来提供验证规则、默认值和其他细节。
- en: See also
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Parsing the query string in a request* recipe introduces the core web service
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解析请求中的查询字符串* 配方介绍了核心Web服务'
- en: The *Implementing Authentication for web services* recipe will add authentication
    to make the service more secure
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为Web服务实现身份验证* 配方将添加身份验证以使服务更安全'
- en: Parsing the URL path
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析URL路径
- en: A URL is a complex object. It contains at least six separate pieces of information.
    More can be included as optional values.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: URL是一个复杂的对象。它至少包含六个单独的信息片段。可以包括更多作为可选值。
- en: 'A URL such as `http://127.0.0.1:5000/dealer/hand/player_1?$format=json` has
    several fields:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如 `http://127.0.0.1:5000/dealer/hand/player_1?$format=json` 的URL具有几个字段：
- en: '`http` is the scheme. `https` is for secure connections using encrypted sockets.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http` 是方案。`https` 用于使用加密套接字进行安全连接。'
- en: '`127.0.0.1`  can be called the authority, although network location is more
    commonly used. This particular IP address means the localhost and is a kind of
    loopback to the localhost. The name localhost maps to this IP address.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`127.0.0.1` 可以称为权限，尽管网络位置更常用。这个特定的IP地址意味着本地主机，是一种回环到本地主机的方式。localhost映射到这个IP地址。'
- en: '`5000` is the port number, and is part of the authority.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`5000` 是端口号，是权限的一部分。'
- en: '`/dealer/hand/player_1` is the path to a resource.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /dealer/hand/player_1 是资源的路径。
- en: '`$format=json` is a query string.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$format=json` 是一个查询字符串。'
- en: The path to a resource can be quite complex. It's common in RESTful web services
    to use the path information to identify groups of resources, individual resources,
    and even relationships among resources.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的路径可能非常复杂。在RESTful Web服务中，使用路径信息来标识资源组、单个资源甚至资源之间的关系是很常见的。
- en: How can we handle complex path parsing?
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理复杂的路径解析？
- en: Getting ready
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Most web services provide access to some kind of resource. In the *Implementing
    Web services with WSGI* , *Using the Flask framework for RESTful APIs* , and *Parsing
    the query string in a request* recipes, the resource was identified on the URL
    path as a hand or hands. This is—in a way—misleading.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Web服务提供对某种资源的访问。在*使用Flask框架实现RESTful API* 和*解析请求中的查询字符串* 配方中，资源在URL路径上被标识为手或手。这在某种程度上是误导性的。
- en: 'There are actually two resources that are involved in those web services:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些Web服务涉及两个资源：
- en: A deck, which can be shuffled to produce one or more random hands
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一副牌，可以洗牌以产生一个或多个随机手
- en: A hand, which was treated as a transient response to a request
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一只手，被视为对请求的瞬态响应
- en: To make matters even more confusing, the hand resource was created via a `GET`
    request instead of the more common `POST` request. This is confusing because a
    `GET` request is never expected to change the state of the server.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 更让事情变得更加混乱的是，手资源是通过 `GET` 请求而不是更常见的 `POST` 请求创建的。这很令人困惑，因为不会预期 `GET` 请求改变服务器的状态。
- en: For simple explorations and technical spikes, `GET` requests are helpful. Because
    a browser can make `GET` requests, these are a good way to explore some aspects
    of web services design.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的探索和技术尖刺，`GET` 请求是有帮助的。因为浏览器可以发出 `GET` 请求，这是探索Web服务设计某些方面的好方法。
- en: 'A redesign can provide explicit access to a randomized instance of the `Deck`
    class. One feature of the deck will be hands of cards. This parallels the idea
    of `Deck` as a collection and `Hands` as a resource within the collection:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 重新设计可以提供对 `Deck` 类的随机实例的显式访问。牌组的一个特性将是牌的手。这与将 `Deck` 视为集合和 `Hands` 作为集合内资源的想法相一致：
- en: '`/dealer/decks` : A `POST` request will create a new deck object. The response
    to this request is taken that is used to identify the unique deck.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dealer/decks`：`POST`请求将创建一个新的牌组对象。对这个请求的响应被用来标识唯一的牌组。'
- en: '`/dealer/deck/{id}/hands` : A `GET` request to this will get a hand object
    from the given deck identifier. The query string will specify how many cards.
    The query string can use the `$top` option to limit how many hands are returned.
    It can also use the `$skip` option to skip over some hands and get cards for later
    hands.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dealer/deck/{id}/hands`：对此的`GET`请求将从给定的牌组标识符获取一个手牌对象。查询字符串将指定多少张牌。查询字符串可以使用`$top`选项来限制返回多少手牌。它还可以使用`$skip`选项跳过一些手牌，并获取以后的手牌的牌。'
- en: These queries will require an API client. They can't easily be done from a browser.
    One possibility is to use Postman as a plug-in to the Chrome browser. We'll leverage
    the *Making REST requests with urllib* recipe as the starting point for a client
    to process these more complex APIs.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查询将需要一个API客户端。它们不能轻松地从浏览器中完成。一个可能的方法是使用Postman作为Chrome浏览器的插件。我们将利用*使用urllib进行REST请求*的方法作为处理这些更复杂API的客户端的起点。
- en: How to do it...
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll decompose this into two parts: server and client.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这分解成两部分：服务器和客户端。
- en: Server
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器
- en: 'Start with the *Parsing the query string in a request* recipe as a template
    for a Flask application. We''ll be changing the view functions in that example:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*解析请求中的查询字符串*的模板开始，作为Flask应用程序的模板。我们将改变那个例子中的视图函数：
- en: '[PRE51]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Import any additional modules. In this case, we''ll use the `uuid` module to
    create a unique key for a shuffled deck:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入任何额外的模块。在这种情况下，我们将使用`uuid`模块为洗牌后的牌组创建一个唯一的键：
- en: '[PRE52]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We''ll also use the Werkzeug `BadRequest` response. This allows us to provide
    a detailed error message. This is a little nicer than using `abort(400)` for an
    erroneous request:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用Werkzeug的`BadRequest`响应。这使我们能够提供详细的错误消息。这比对于错误请求使用`abort(400)`要好一点：
- en: '[PRE53]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Define the global state. This includes the collection of decks. It also includes
    the random number generator. For testing purposes, it can help to have a way to
    force a particular seed value:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义全局状态。这包括牌组的集合。它还包括随机数生成器。为了测试目的，有一种方法可以强制使用特定的种子值：
- en: '[PRE54]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Define a route—a URL pattern—to a view function that performs a specific request.
    This is a decorator, placed immediately in front of the function. It will bind
    the function to the Flask application:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个路由——到执行特定请求的视图函数的URL模式。这是一个装饰器，直接放在函数的前面。它将把函数绑定到Flask应用程序：
- en: '[PRE55]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We've defined the decks resource and limited the route to only handling `HTTP
    POST` requests. This narrows the semantics of this particular endpoint—a `POST`
    request generally means that the URL will create something new in the server.
    In this example, it creates a new instance in the collection of decks.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了牌组资源，并将路由限制为只处理`HTTP POST`请求。这缩小了这个特定端点的语义——`POST`请求通常意味着URL将在服务器上创建新的东西。在这个例子中，它在牌组集合中创建了一个新实例。
- en: 'Define the view function that supports this resource:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义支持这个资源的视图函数：
- en: '[PRE56]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `uuid1()` function will create a universally unique ID based on the current
    host and a randomly-seeded sequence generator. The string version of this is a
    long hexadecimal string that looks like `93b8fc06-5395-11e6-9e73-38c9861bf556`
    .
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`uuid1()`函数将基于当前主机和随机种子序列生成器创建一个通用唯一ID。这个字符串版本是一个长的十六进制字符串，看起来像`93b8fc06-5395-11e6-9e73-38c9861bf556`。'
- en: 'We''ll use this string as a key for creating a new instance of `Deck` . The
    response will be a small JSON document with two fields:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个字符串作为创建`Deck`的新实例的键。响应将是一个带有两个字段的小JSON文档：
- en: The `status` field will be `'ok'` because everything worked. This allows us
    to perhaps provide other state information that includes warnings or errors.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`字段将是`''ok''`，因为一切都正常。这使我们可以提供其他包括警告或错误的状态信息。'
- en: The `id` field has the ID string for the deck just created. This allows the
    server to have multiple, concurrent games, each of which is distinguished by a
    deck ID.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`字段具有刚刚创建的牌组的ID字符串。这允许服务器拥有多个并发游戏，每个游戏都由一个牌组ID区分。'
- en: The response is created with the `make_response()` function so that we can provide
    an HTTP status of `201 CREATED` instead of the default of `200 OK` . This distinction
    is important because this request changes the state of the server.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是使用`make_response()`函数创建的，这样我们就可以提供`201 CREATED`的HTTP状态，而不是默认的`200 OK`。这种区别很重要，因为这个请求改变了服务器的状态。
- en: 'Define a route that requires a parameter. In this case, the route will include
    the specific deck ID to deal from:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个需要参数的路由。在这种情况下，路由将包括要处理的特定牌组ID：
- en: '[PRE57]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `<id>` makes this a path template instead of a simple, literal path. Flask
    will parse the `/` characters and separate the `<id>` field.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`<id>`使这成为一个路径模板，而不是一个简单的文字路径。Flask将解析`/`字符并分隔`<id>`字段。'
- en: 'Define a view function that has parameters which match the template. Since
    the template included `<id>` , the view function has a parameter named `id` as
    well:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个视图函数，其参数与模板匹配。由于模板包含`<id>`，视图函数也有一个名为`id`的参数：
- en: '[PRE58]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If the value of the `id` parameter is not one of the keys to the decks collection,
    the function makes a `404 NOT FOUND` response. Rather than use the `abort()` function,
    this function uses `BadRequest` to include an explanatory error message. We could
    also have used the `make_response()` function in Flask.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`id`参数的值不是牌组集合的键之一，函数将生成`404 NOT FOUND`响应。这个函数使用`BadRequest`而不是`abort()`函数，以包括解释性的错误消息。我们也可以在Flask中使用`make_response()`函数。
- en: The values of `$top` , `$skip` , and `cards` from the query string are also
    extracted by this function. For this example, all of the values happen to be integers,
    so the `int()` function is used for each value. A rudimentary sanity check is
    performed on the query parameters. An additional check is actually required, and
    the reader is encouraged to think through all of the possible bad parameters that
    might be used.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数还从查询字符串中提取“$top”、“$skip”和“cards”的值。在此示例中，所有值都恰好是整数，因此对每个值使用“int()”函数。对查询参数执行了一个基本的合理性检查。实际上需要进行额外的检查，鼓励读者思考可能使用的所有可能的不良参数。
- en: The `subset` variable is the portion of the deck being dealt. We've sliced the
    deck to start after `skip` sets of `cards` ; we've included just `top` sets of
    `cards` in this slice. From that slice, the `hands` sequence decomposes the subset
    into the `top` number of hands, each of which has `cards` in it. This sequence
    is converted to JSON via the `jsonify()` function, and is returned.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: “subset”变量是正在发牌的牌组部分。我们已经对牌组进行了切片，以在“skip”组“cards”后开始；我们在这个切片中只包括“top”组“cards”。从该切片中，“hands”序列将子集分解为“top”数量的手牌，每个手牌中都有“cards”。通过“jsonify()”函数将此序列转换为JSON，并返回。
- en: The default status is `200 OK` , which is appropriate here because this query
    is an idempotent `GET` request. Each time a query is sent, the same set of cards
    will be returned.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 默认状态是“200 OK”，这是合适的，因为此查询是幂等的“GET”请求。每次发送查询时，将返回相同的一组牌。
- en: 'Define a main program that runs the server:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个运行服务器的主程序：
- en: '[PRE59]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Client
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端
- en: 'This will be similar to the client module from the *Making REST requests with
    urllib* recipe:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这将类似于*使用urllib进行REST请求*食谱中的客户端模块：
- en: 'Import the essential modules for working with RESTful APIs:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入用于处理RESTful API的基本模块：
- en: '[PRE60]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'There''s a sequence of steps to make the `POST` request that will create a
    new, shuffled deck. This starts by defining the URL in pieces, by creating a `ParseResult`
    object manually. This will be collapsed into a single string later:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一系列步骤来进行“POST”请求，以创建一个新的洗牌牌组。首先通过手动创建“ParseResult”对象来定义URL的各个部分。稍后将将其合并为单个字符串：
- en: '[PRE61]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Build a `Request` object from the URL, method, and headers:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从URL、方法和标头构建“Request”对象：
- en: '[PRE62]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The default method is `GET` , which is unsuitable for this API request.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 默认方法是“GET”，这对于此API请求是不合适的。
- en: Send the request and process the response object. For debugging purposes, it
    can be helpful to print status and header information. Generally, we only need
    to be sure that the status was the expected `201` .
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求并处理响应对象。出于调试目的，打印状态和标头信息可能会有所帮助。通常，我们只需要确保状态是预期的“201”。
- en: 'The response document should be a JSON serialization of a Python dictionary
    with two fields, status and ID. This client confirms the status in the response
    is `ok`  before using the value in the `id` field:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 响应文档应该是Python字典的JSON序列化，具有两个字段，状态和ID。此客户端在使用“id”字段中的值之前确认响应中的状态为“ok”：
- en: '[PRE63]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In many RESTful APIs, there will be a location header, which provides a URL
    that links to the object that was created.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多RESTful API中，将会有一个位置标头，它提供了一个链接到创建的对象的URL。
- en: 'Create a URL that includes inserting the ID into a URL path, as well as providing
    some query string arguments. This is done by creating a dictionary to model the
    query string, and then building a URL using a `ParseResult` object:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个URL，其中包括将ID插入URL路径以及提供一些查询字符串参数。这是通过创建一个模拟查询字符串的字典，然后使用“ParseResult”对象构建URL来完成的：
- en: '[PRE64]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We've inserted the `id` value into the path using `"/decks/{id}/hands/".format(id=id)`
    . Another way to do this is `"/".join(["", "decks", id, "hands", ""])` . Note
    that the empty strings are a way to force the `"/"` to appear at the beginning
    and end.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用“"/decks/{id}/hands/".format(id=id)”将“id”值插入路径。另一种方法是使用“"/".join(["", "decks",
    id, "hands", ""])”。请注意，空字符串是强制“/”出现在开头和结尾的一种方法。
- en: 'Make the `Request` object using the full URL, the method, and the standard
    headers:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用完整URL、方法和标准标头创建“Request”对象：
- en: '[PRE65]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Send the request and process the response. We''ll confirm that the response
    is `200 OK` . The response can then be parsed to get the details of the cards
    that are part of the requested hand:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求并处理响应。我们将确认响应为“200 OK”。然后可以解析响应以获取所请求手牌的详细信息：
- en: '[PRE66]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: When we run this, it will create a fresh, new `Deck` instance. Then it will
    deal four hands of 13 cards each. The query defines the exact number of hands
    and the number of cards in each hand.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，它将创建一个新的“Deck”实例。然后它将发出四手牌，每手13张牌。查询定义了每手的确切数量和每手中的牌数。
- en: How it works...
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The server defines two routes that follow a common pattern for a collection
    and an instance of the collection. It's typical to define collection paths with
    a plural noun, `decks` . Using a plural noun means that the CRUD operations are
    focused on creating instances within the collection.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器定义了遵循集合和集合实例的常见模式的两个路由。通常使用复数名词“decks”来定义集合路径。使用复数名词意味着CRUD操作侧重于在集合内创建实例。
- en: In this case, the Create operation is implemented with a `POST` method of the
    `/dealer/decks` path. Retrieve could be supported by writing an additional view
    function to handle the `GET` method of the `/dealer/decks` path. This would expose
    all of the deck instances in the decks collection.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用“POST”方法的“/dealer/decks”路径实现了创建操作。通过编写一个额外的视图函数来处理“/dealer/decks”路径的“GET”方法，可以支持检索。这将公开牌组集合中的所有牌组实例。
- en: If Delete is supported, this could use the `DELETE` method of `/dealer/decks`
    . Update (using the `PUT` method) doesn't seem to fit with the idea of a server
    that creates random decks.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果支持删除，可以使用“DELETE”方法的“/dealer/decks”。更新（使用“PUT”方法）似乎不符合创建随机牌组的服务器的想法。
- en: Within the `/dealer/decks` collection, a specific deck is identified by the
    `/dealer/decks/<id>` path. The design calls for using the `GET` method to fetch
    several hands of cards from the given deck.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/dealer/decks` 集合中，特定的牌堆由 `/dealer/decks/<id>` 路径标识。设计要求使用 `GET` 方法从给定的牌堆中获取几手牌。
- en: The remaining CRUD operations—Create, Update, and Delete—don't make much sense
    for this kind of `Deck` object. Once the `Deck` object is created, then a client
    application can interrogate the deck for various hands.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的CRUD操作——创建、更新和删除——对于这种类型的 `Deck` 对象并没有太多意义。一旦创建了 `Deck` 对象，客户端应用程序就可以查询各种手牌。
- en: Deck slicing
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 牌堆切片
- en: 'The dealing algorithm makes several slices of a deck of cards. The slices are
    based on the fact that the size of a deck, *D* , must contain enough cards for
    the the number of hands, *h* , and the number of cards in each hand, *c* . The
    number of hands and cards per hand must be no larger than the size of the deck:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 发牌算法对一副牌进行了几次切片。这些切片是基于一副牌的大小，*D* ，必须包含足够的牌来满足手数，*h* ，以及每手的牌数，*c* 。手数和每手的牌数必须不大于牌的大小：
- en: '*h* × *c* ≤ *D*'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '*h* × *c* ≤ *D*'
- en: 'The social ritual of dealing often involves cutting the deck, which is a very
    simple shuffle done by the non-dealing player. Traditionally, each  *h* ^(th)
    card is assigned to each hand, *H* [n] :'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 发牌的社交仪式通常涉及切牌，这是由非发牌玩家进行的非常简单的洗牌。传统上，每隔 *h* 张牌分配给每个手牌 *H* [n] ：
- en: '*H[n] =* { *D[n]* [+] *[h]* [×] *[i]*  :0 ≤ *i* < *c* }'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '*H[n] =* { *D[n]* [+] *[h]* [×] *[i]*  :0 ≤ *i* < *c* }'
- en: The idea in the preceding formula is that hand *H[n=0]*  has cards *H[0] = {
    D[0] , D[h] , D[2h] , ..., D[c×h ] }* , hand *H[n=1]*  has cards *H[1] = { D[1]
    , D[1+h] , D[1+2h] , ..., D[1+c×h] }* , and so on. This distribution of cards
    looks more fair than simply handing each player the next batch of *c* cards.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的公式中，*H[n=0]*  手中有牌 *H[0] = { D[0] , D[h] , D[2h] , ..., D[c×h ] }* ，*H[n=1]*
     手中有牌 *H[1] = { D[1] , D[1+h] , D[1+2h] , ..., D[1+c×h] }* ，依此类推。这种发牌方式看起来比简单地将每个玩家的下一批
    *c* 张牌发给他们更公平。
- en: 'This isn''t really necessary, and our Python program deals cards in batches
    that are slightly easier to compute with Python:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是真正必要的，我们的Python程序以稍微更容易用Python计算的批次发牌：
- en: '*H[n]* = { *D* [*n* × *c* +1] : 0 ≤ *i* < *c* }'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '*H[n]* = { *D* [*n* × *c* +1] : 0 ≤ *i* < *c* }'
- en: The Python code creates hand *H[n=0]*  with cards *H* [0] *=* { *D* [0] *, D*
    [1] *, D* [2] *, ..., D[c-]* [1] }, hand *H[n=1]*  has cards *H* [0 ] *=* { *D[c]
    , D[c+]* [1] *, D[c+]* [2] *, ..., D* [2c- *1*] }, and so on. Given a random deck,
    this is just as fair as any other allocation of cards. It's slightly simpler to
    enumerate in Python because it involves list slicing. For more information on
    slicing, see the *Slicing and dicing a list* recipe in [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structures
    – list, set, dict* .
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: Python 代码创建了手 *H[n=0]*  ，其中有牌 *H* [0] *=* { *D* [0] *, D* [1] *, D* [2] *, ...,
    D[c-]* [1] }，手 *H[n=1]*  有牌 *H* [0 ] *=* { *D[c] , D[c+]* [1] *, D[c+]* [2] *,
    ..., D* [2c- *1*] }，依此类推。对于一副随机的牌，这与任何其他分配牌的方式一样公平。在Python中，这稍微简单一些，因为它涉及到列表切片。有关切片的更多信息，请参阅[第4章](text00048.html#page
    "第4章. 内置数据结构 – 列表、集合、字典")中的 *切片和切块列表* 配方，*内置数据结构 – 列表、集合、字典* 。
- en: Client side
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端
- en: 'The client side of this transaction is a sequence of RESTful requests:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这个交易的客户端是一系列RESTful请求：
- en: 'Ideally, the operations start with a `GET` to `swagger.json` to get the server''s
    specifications. Depending on the server, this may be as simple as:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理想情况下，操作从 `GET` 到 `swagger.json` 开始，以获取服务器的规范。根据服务器的不同，这可能会很简单：
- en: '[PRE67]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Then, there's a `POST` to create a new `Deck` instance. This requires creating
    a `Request` object so that the method can be set to `POST` .
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，有一个 `POST` 来创建一个新的 `Deck` 实例。这需要创建一个 `Request` 对象，以便可以将方法设置为 `POST` 。
- en: Then, there's a `GET` to get some hands from the deck instance. This can be
    done by tweaking the URL as a string template. It's slightly more general to work
    the URL as a collection of individual fields instead of a trivial string.
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，有一个 `GET` 来从牌堆实例中获取一些手牌。这可以通过调整URL作为字符串模板来完成。将URL作为一组单独字段而不是一个简单的字符串进行处理，稍微更一般化。
- en: 'There are two ways to handle errors from RESTful applications:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种处理RESTful应用程序错误的方法：
- en: Use a simple status response such as `abort(HTTPStatus.NOT_FOUND)` for a resource
    that's not found.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于未找到的资源，使用 `abort(HTTPStatus.NOT_FOUND)` 等简单的状态响应。
- en: Use `make_response(message, HTTPStatus.BAD_REQUEST)` for a request that is in
    some way invalid. The message can provide needed details.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于某种方式无效的请求，使用 `make_response(message, HTTPStatus.BAD_REQUEST)` 。消息可以提供所需的详细信息。
- en: For some other status codes, such as `403 Forbidden` , we might not want to
    provide too many details. In the case of an authorization issue, it's often a
    bad idea to provide too many details. For this, `abort(HTTPStatus.FORBIDDEN)`
    might be appropriate.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些其他状态码，比如 `403 Forbidden` ，我们可能不想提供太多细节。在授权问题的情况下，提供太多细节通常是一个坏主意。对于这种情况，`abort(HTTPStatus.FORBIDDEN)`
    可能是合适的。
- en: There's more...
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We''ll look at some features that we should consider adding to the server:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一些应该考虑添加到服务器的功能：
- en: Check for `JSON`  in the Accept header
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接受标头中检查 `JSON`
- en: Provide a Swagger specification
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供Swagger规范
- en: It's common to use a header to distinguish between RESTful API requests and
    other requests to a server. The Accept header can provide a MIME type that distinguishes
    requests for JSON content from requests for user-oriented content.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标头来区分RESTful API请求和对服务器的其他请求是很常见的。接受标头可以提供一个MIME类型，用于区分对JSON内容的请求和对面向用户的内容的请求。
- en: 'The `@dealer.before_request` decorator can be used to inject a function that
    filters each request. This filter can distinguish proper RESTful API requests
    based on the following requirements:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`@dealer.before_request` 装饰器可用于注入一个过滤每个请求的函数。这个过滤器可以根据以下要求区分适当的RESTful API请求：'
- en: The Accept header includes a MIME type that includes `json` . Typically, the
    full MIME string is `application/json` .
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受标头包括一个包含 `json` 的MIME类型。通常，完整的MIME字符串是 `application/json` 。
- en: Additionally, we can make an exception for the `swagger.json` file. This can
    be treated as a RESTful API request irrespective of any other indicators.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们可以为`swagger.json`文件做一个例外。这可以被视为一个RESTful API请求，而不考虑任何其他指示。
- en: 'Here''s the additional code that implements this:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现这一点的额外代码：
- en: '[PRE68]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This filter will simply return an uninformative `400 BAD REQUEST` response.
    To provide a more explicit error message might divulge too much information about
    the server's implementation. If it seems helpful, however, we can replace `abort()`
    with `make_response()` to return a more detailed error.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过滤器将简单地返回一个不详细的`400 BAD REQUEST`响应。提供更明确的错误消息可能会泄露关于服务器实现的太多信息。然而，如果有帮助的话，我们可以用`make_response()`替换`abort()`来返回更详细的错误。
- en: Providing a Swagger specification
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供Swagger规范
- en: A well-behaved RESTful API provides the OpenAPI specification for the various
    services available. This is generally packaged in the `/swagger.json` route. This
    doesn't necessarily mean that a literal file is available. Instead, this path
    is used as a focus to provide the detailed interface specification in JSON notation
    following the Swagger 2.0 specification.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 一个行为良好的RESTful API为各种可用的服务提供了OpenAPI规范。这通常打包在`/swagger.json`路由中。这并不一定意味着有一个字面上的文件可用。相反，这个路径被用作一个重点，以提供遵循Swagger
    2.0规范的详细接口规范的JSON表示。
- en: 'We''ve defined the route, `/swagger.json` , and bound a function, `swagger3()`
    , to this route. This function will create a JSON representation of a global object,
    specification:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了路由`/swagger.json`，并将函数`swagger3()`绑定到这个路由。这个函数将创建一个全局对象`specification`的JSON表示：
- en: '[PRE69]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `specification` object has the following outline. Important details have
    been replaced with `...` to emphasize the overall structure. The details are as
    follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`specification`对象的大纲如下。重要细节已被替换为`...`以强调整体结构。细节如下：'
- en: '[PRE70]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The two paths correspond to the two `@dealer.route` decorators in the server.
    This is why it's often helpful to start the design of a server with a Swagger
    specification, and then build the code to meet specification.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个路径对应于服务器中的两个`@dealer.route`装饰器。这就是为什么通常有助于从Swagger规范开始设计服务器，然后构建代码以满足规范。
- en: Note the small syntax difference. Flask uses `/decks/<id>/hands` where the OpenAPI
    Swagger specification uses `/decks/{id}/hands` . This small thing means we can't
    trivially copy and paste between Python and Swagger documents.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 注意小的语法差异。Flask使用`/decks/<id>/hands`，而OpenAPI Swagger规范使用`/decks/{id}/hands`。这一小细节意味着我们不能在Python和Swagger文档之间轻松地复制和粘贴。
- en: 'Here''s the `/decks` path. This shows the input parameters that come from the
    query string. It also shows the details of the `201` response that contains the
    deck ID information:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`/decks`路径。这显示了来自查询字符串的输入参数。它还显示了包含牌组ID信息的`201`响应的细节：
- en: '[PRE71]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `/decks/{id}/hands` path has a similar structure. It defines all of the
    parameters that are available in the query string. It also defines the various
    responses; a `200` response that contains the cards and define the `404` response
    when the ID value was not found.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`/decks/{id}/hands`路径具有类似的结构。它定义了查询字符串中可用的所有参数。它还定义了各种响应；一个包含卡片的`200`响应，并在未找到ID值时定义了`404`响应。'
- en: 'We''ve omitted some of the details of the parameters for each path. We''ve
    also omitted details on the structure of the deck. The outline, however, summarizes
    the RESTful API:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了每个路径的参数的一些细节。我们还省略了关于牌组结构的细节。然而，大纲总结了RESTful API：
- en: The `swagger` key must be set to `2.0` .
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swagger`键必须设置为`2.0`。'
- en: The `info` key can provide a great deal of information. This example only has
    the minimal requirements.
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`键可以提供大量信息。这个例子只有最低要求。'
- en: The `schemes` , `host` , and `basePath` fields define some of the common elements
    of the URLs used for this service.
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schemes`、`host`和`basePath`字段定义了此服务使用的URL的一些常见元素。'
- en: The `consumes` field states what the request `Content-Type` should include.
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`consumes`字段说明了请求的`Content-Type`应该包括什么。'
- en: The `produces` field states both; that the request Accept header must state,
    as well as what the response `Content-Type` will be.
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`produces`字段同时说明了请求的Accept头必须说明什么，以及响应的`Content-Type`将是什么。'
- en: The `paths` field identifies all of the paths that provide a response on this
    server. This shows the `/decks` and the `/decks/{id}/hands` paths.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paths`字段标识了在此服务器上提供响应的所有路径。这显示了`/decks`和`/decks/{id}/hands`路径。'
- en: The `swagger3()` function transforms this Python object into JSON notation and
    returns it. This implements what appears to be a download of a `swagger.json`
    file. The content specifies the resources provided by the RESTful API server.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`swagger3()`函数将这个Python对象转换为JSON表示法并返回它。这实现了似乎是下载`swagger.json`文件的功能。内容指定了RESTful
    API服务器提供的资源。'
- en: Using a Swagger specification
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Swagger规范
- en: 'In the client programming, we''ve used simple literal values for building the
    URL. The example looked like the following:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端编程中，我们使用简单的字面值来构建URL。示例看起来像下面这样：
- en: '[PRE72]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Parts of this can come from the Swagger specification. We could, for example,
    use `specification['host']` and `specification['basePath']` instead of the `netloc`
    value and the first part of the `path` value. This use of the Swagger specification
    can provide a little bit of extra flexibility.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 其中的一部分可以来自Swagger规范。例如，我们可以使用`specification['host']`和`specification['basePath']`来代替`netloc`值和`path`值的第一部分。这种对Swagger规范的使用可以提供一点额外的灵活性。
- en: The Swagger specification is meant for consumption by tools that are used by
    people to make design decisions. The real purpose it to drive automated testing
    of APIs. Often, Swagger specifications will contain detailed examples that can
    help to clarify how to write a client application.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger规范是为了供人们用于做设计决策的工具消费而设计的。其真正目的是驱动API的自动化测试。通常，Swagger规范会包含详细的示例，可以帮助澄清如何编写客户端应用程序。
- en: See also
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Making REST requests with urllib* and *Parsing the query string in
    a request* recipes for more examples of RESTful web services
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关更多RESTful web服务示例，请参阅*使用urllib进行REST请求*和*解析请求中的查询字符串*配方
- en: Parsing a JSON request
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析JSON请求
- en: Many web services involve a request to create a new persistent object or make
    an update to an existing persistent object. In order to do these kinds of operation,
    the application will need input from the client.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 许多web服务涉及请求创建新的持久对象或对现有持久对象进行更新。为了执行这些操作，应用程序将需要来自客户端的输入。
- en: A RESTful web service will generally accept input (and produce output) in the
    form of JSON documents. For more information on JSON, see the *Reading JSON documents*
    recipe in [Chapter 9](text00099.html#page "Chapter 9. Input/Output, Physical Format,
    and Logical Layout") , *Input/Output, Physical Format, and Logical Layout*
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful web服务通常会接受JSON文档形式的输入（和产生输出）。有关JSON的更多信息，请参阅[第9章](text00099.html#page
    "第9章 输入/输出、物理格式和逻辑布局")中的*阅读JSON文档*配方，*输入/输出、物理格式和逻辑布局*
- en: How can we parse JSON inputs from web clients? What's an easy way to validate
    the input?
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解析来自web客户端的JSON输入？验证输入的简单方法是什么？
- en: Getting ready
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll extend the Flask application from the  *Parsing the query string in
    a request*  recipe to add a user registration feature; this will add a player
    who can then request cards. The player is a resource that will involve the essential
    CRUD operations:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展Flask应用程序，从“解析请求中的查询字符串”配方中添加用户注册功能；这将添加一个玩家，然后玩家可以请求卡片。玩家是一个资源，将涉及基本的CRUD操作：
- en: A client can do a `POST` to the `/players` path to create a new player. This
    will include a payload of a document that describes the player. The service will
    validate the document, and if it's valid, create a new, persistent `Player` instance.
    The response will include the ID assigned to the player. If the document is invalid,
    a response will be sent back detailing the problems.
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可以对`/players`路径执行`POST`以创建新玩家。这将包括描述玩家的文档有效负载。服务将验证文档，如果有效，创建一个新的持久`Player`实例。响应将包括分配给玩家的ID。如果文档无效，将发送响应详细说明问题。
- en: A client can do a `GET` to the `/players` path to get the list of players.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可以对`/players`路径执行`GET`以获取玩家列表。
- en: A client can do a `GET` to the `/players/<id>` path to get the details of a
    specific player.
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可以对`/players/<id>`路径执行`GET`以获取特定玩家的详细信息。
- en: A client can do a `PUT` to the `/players/<id>` path to update the details of
    a specific player. As with the initial `POST` , this requires a payload document
    that must be validated.
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可以对`/players/<id>`路径执行`PUT`以更新特定玩家的详细信息。与初始的`POST`一样，这需要验证有效负载文档。
- en: A client can do a `DELETE` to the `/players/<id>` path to remove a player.
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端可以对`/players/<id>`路径执行`DELETE`以删除玩家。
- en: As with the *Parsing the query string in a request* recipe, we'll implement
    both the client and the server portion of these services. The server will handle
    the essential `POST` and `GET` operations. We'll leave the `PUT` and `DELETE`
    operations as exercises for the reader.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 与“解析请求中的查询字符串”配方一样，我们将实现这些服务的客户端和服务器部分。服务器将处理基本的`POST`和`GET`操作。我们将把`PUT`和`DELETE`操作留给读者作为练习。
- en: We'll need a JSON validator. See [https://pypi.python.org/pypi/jsonschema/2.5.1](https://pypi.python.org/pypi/jsonschema/2.5.1)
    . This is particularly good. It's helpful to have a Swagger specification validator
    as well. See [https://pypi.python.org/pypi/swagger-spec-validator](https://pypi.python.org/pypi/swagger-spec-validator)
    .
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个JSON验证器。请参阅[https://pypi.python.org/pypi/jsonschema/2.5.1](https://pypi.python.org/pypi/jsonschema/2.5.1)。这特别好。还有一个Swagger规范验证器也很有帮助。请参阅[https://pypi.python.org/pypi/swagger-spec-validator](https://pypi.python.org/pypi/swagger-spec-validator)。
- en: 'If we install the `swagger-spec-validator` package, this also installs the
    latest copy of the `jsonschema` project. Here''s how the whole sequence might
    look:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们安装`swagger-spec-validator`包，这也会安装`jsonschema`项目的最新副本。整个序列可能如下所示：
- en: '[PRE73]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We used the `pip` command to install the `swagger-spec-validator` package. This
    installation also checked that `jsonschema` , `setuptools` , and `six` were already
    installed.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`pip`命令安装了`swagger-spec-validator`包。此安装还检查了`jsonschema`，`setuptools`和`six`是否已安装。
- en: 'There''s a hint about using `--upgrade` . It can help to use a command such
    as this to upgrade a package: `pip install jsonschema --upgrade` . This might
    be necessary if there''s a version of `jsonschema` that''s below version 2.5.0.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个关于使用`--upgrade`的提示。使用类似以下命令升级包可能有所帮助：`pip install jsonschema --upgrade`。如果`jsonschema`的版本低于2.5.0，则可能需要这样做。
- en: How to do it...
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll decompose this into three parts: Swagger specification, server, and
    client.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这分解为三部分：Swagger规范、服务器和客户端。
- en: Swagger specification
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Swagger规范
- en: 'Here''s the outline of the Swagger specification:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是Swagger规范的概要：
- en: '[PRE74]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The first fields are essential boilerplate for RESTful web services. The `paths`
    and `definitions` will be filled in with the URLs and the schema definitions that
    are part of the service.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 首先的字段是RESTful web服务的基本样板。`paths`和`definitions`将填入服务的URL和模式定义。
- en: 'Here''s the schema definition used to validate a new player. This goes inside
    the definition of the overall specification:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是用于验证新玩家的模式定义。这将放在整体规范的定义中：
- en: '[PRE75]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The overall input document is formally described as having a type of object.
    There are four properties of that object:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 整体输入文档正式描述为对象类型。该对象有四个属性：
- en: A name, which is a string
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名字，这是一个字符串
- en: An e-mail address, which is a string with a specific format
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个电子邮件地址，这是一个特定格式的字符串
- en: A Twitter URL, which is a string with a given format
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter URL，这是一个特定格式的字符串
- en: A year, which is a number
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一年，这是一个数字
- en: There are a few defined formats that are part of the JSON schema specification
    language. The `email` and `url` formats are widely used. The complete list of
    formats includes `date-time` , `hostname` , `ipv4` , `ipv6` , and `uri` . For
    details on defining a schema, see [http://json-schema.org/documentation.html](http://json-schema.org/documentation.html)
    .
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: JSON模式规范语言中有一些定义的格式。`email`和`url`格式被广泛使用。格式的完整列表包括`date-time`、`hostname`、`ipv4`、`ipv6`和`uri`。有关定义模式的详细信息，请参见[http://json-schema.org/documentation.html](http://json-schema.org/documentation.html)。
- en: 'Here''s the overall `players` path that''s used to create a new player or get
    the entire collection of players:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是用于创建新玩家或获取所有玩家集合的整体`players`路径：
- en: '[PRE76]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This path defines two methods—`post` and `get` . The `post` method has one parameter,
    called `player` . This parameter is the body of the request, and it follows the
    player schema provided in the definitions section.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 该路径定义了两种方法——`post`和`get`。`post`方法有一个名为`player`的参数。这个参数是请求的主体，并且遵循定义部分提供的玩家模式。
- en: The `get` method is shown without any parameters or any formal definition of
    the structure of the response.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`方法显示了没有任何参数或响应结构的正式定义。'
- en: 'Here''s the definition of a path to get details about a specific player:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个用于获取有关特定玩家的详细信息的路径的定义：
- en: '[PRE77]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: That path is similar to the one shown in the *Parsing the URL path* recipe.
    The `player` key is provided in the URL. The response when a player ID is valid
    is shown in detail. The response has a defined schema that also uses the player
    schema definition in the definitions section.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 该路径类似于*解析URL路径*配方中所示的路径。URL中提供了`player`键。显示了当玩家ID有效时的响应细节。响应具有一个定义的模式，该模式还使用了定义部分中的玩家模式定义。
- en: This specification will be part of the server. It can be provided by a view
    function defined in the `@dealer.route('/swagger.json')` route. It's often simplest
    to create a file with this specification document in it.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范将成为服务器的一部分。它可以由在`@dealer.route('/swagger.json')`路由中定义的视图函数提供。通常最简单的方法是创建一个包含这个规范文档的文件。
- en: Server
  id: totrans-561
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器
- en: 'Start with the *Parsing the query string in a request* recipe as a template
    for a Flask application. We''ll be changing the view functions:'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以*解析请求中的查询字符串*配方作为Flask应用程序的模板开始。我们将改变视图函数：
- en: '[PRE78]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Import the additional libraries required. We''ll use the JSON schema for validation.
    We''ll also compute hashes of strings to serve as useful external identifiers
    in URLs:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的额外库。我们将使用JSON模式进行验证。我们还将计算字符串的哈希值，以作为URL中有用的外部标识符：
- en: '[PRE79]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Create the application and the database of players. We''ll use a simple global
    variable. A larger application might use a proper database server to save this
    information:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用程序和玩家数据库。我们将使用一个简单的全局变量。一个更大的应用程序可能会使用一个适当的数据库服务器来保存这些信息：
- en: '[PRE80]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Define the route for posting to the overall collection of `players` :'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义用于发布到整体`players`集合的路由：
- en: '[PRE81]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Define the function that will parse the input document, validate the content,
    and then create the persistent `player` object:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义将解析输入文档、验证内容，然后创建持久`player`对象的函数：
- en: '[PRE82]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This function follows a common four-step design:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数遵循一个常见的四步设计：
- en: Validate the input document. The schema is defined as part of the overall Swagger
    specification.
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证输入文档。模式被定义为整体Swagger规范的一部分。
- en: Create a key and confirm that it's unique. This is a key that's derived from
    the data. We might also create unique keys using the `uuid` module.
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个密钥并确认它是唯一的。这是从数据中派生出来的一个密钥。我们也可以使用`uuid`模块创建唯一的密钥。
- en: Persist the new document in the database. In this example, it's only a single
    statement, `players[id] = document` . This follows the ideal that a RESTful API
    is built around classes and functions that already provide a complete implementation
    of the features.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新文档持久化到数据库中。在这个例子中，它只是一个单一的语句，`players[id] = document`。这遵循了RESTful API围绕已经提供了完整功能实现的类和函数构建的理念。
- en: Build a response document.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个响应文档。
- en: 'Define a main program that runs the server:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个运行服务器的主程序：
- en: '[PRE83]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We can add other methods to see multiple players or individual players. These
    will follow the essential designs of the *Parsing the URL path* recipe. We'll
    look at these in the next section.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加其他方法来查看多个玩家或单个玩家。这些将遵循*解析URL路径*配方的基本设计。我们将在下一节中看到这些。
- en: Client
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端
- en: 'This will be similar to the client module from the *Parsing the URL path* recipe:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 这将类似于*解析URL路径*配方中的客户端模块：
- en: 'Import the essential modules for working with RESTful APIs:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入用于处理RESTful API的基本模块：
- en: '[PRE84]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Create the URL in pieces by creating a `ParseResult` object manually. This
    will be collapsed into a single string later:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过手动创建`ParseResult`对象来逐步创建URL。稍后将把它合并成一个字符串：
- en: '[PRE85]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Create an object that can be serialized to a JSON document and posted to the
    server. Studying `swagger.json` shows what this document''s schema must be. The
    `document` will include the required four properties:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可以序列化为JSON文档并发布到服务器的对象。研究`swagger.json`可以了解这个文档的模式必须是什么样的。`文档`将包括必需的四个属性：
- en: '[PRE86]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We''ll combine URL, document, method, and headers to create the complete request.
    This will use `urlunparse()` to collapse the URL parts into a single string. The
    `Content-Type` header alerts the server that we''re going to provide a text document
    in JSON notation:'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将结合URL、文档、方法和标头来创建完整的请求。这将使用`urlunparse()`将URL部分合并成一个字符串。`Content-Type`标头通知服务器我们将提供一个JSON格式的文本文档：
- en: '[PRE87]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: We've included the `charset` option, which specifies the specific encoding used
    to create bytes from Unicode strings. Since `utf-8` encoding is the default, this
    isn't required. In the rare case that a different encoding is used, this shows
    how to provide the alternative.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包括了`charset`选项，它指定了用于从Unicode字符串创建字节的特定编码。由于`utf-8`编码是默认的，这是不需要的。在使用不同编码的罕见情况下，这显示了如何提供替代方案。
- en: 'Send the request and process the `response` object. For debugging purposes,
    it can be helpful to print the `status` and `headers` information. Generally,
    we only need to be sure that the `status` was the expected `201 CREATED` :'
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送请求并处理`response`对象。出于调试目的，打印`status`和`headers`信息可能会有所帮助。通常，我们只需要确保`status`是预期的`201
    CREATED`：
- en: '[PRE88]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We've examined the response document to assure that it includes the two expected
    fields.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查响应文档以确保它包含两个预期字段。
- en: We can also include other queries in this client. We might want to retrieve
    all players or retrieve a specific player. These will follow the design shown
    in the *Parsing the URL path* recipe.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在这个客户端中包含其他查询。我们可能想要检索所有玩家或检索特定的玩家。这些将遵循*解析URL路径*配方中所示的设计。
- en: How it works...
  id: totrans-595
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Flask automatically examines inbound documents to parse them. We can simply
    use `request.json` to leverage the automated JSON parsing that's built-in to Flask.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: Flask会自动检查传入的文档以解析它们。我们可以简单地使用`request.json`来利用Flask内置的自动JSON解析。
- en: If the input is not actually JSON, then the Flask framework will return a `400
    BAD REQUEST` response. This happens when our server application references the
    `json` property of the request. We can use a `try` statement to capture the `400
    BAD REQUEST` response object and make changes to it, or possibly return a different
    response.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入实际上不是JSON，那么Flask框架将返回`400 BAD REQUEST`响应。当我们的服务器应用程序引用请求的`json`属性时，就会发生这种情况。我们可以使用`try`语句来捕获`400
    BAD REQUEST`响应对象并对其进行更改，或者可能返回不同的响应。
- en: 'We''ve used the `jsonschema` package to validate the input document. This will
    check a number of features of the JSON document:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`jsonschema`包来验证输入文档。这将检查JSON文档的许多特性：
- en: It checks if the overall type of the JSON document matches the overall type
    of the schema. In this example, the schema required an object, which is a `{}`
    JSON structure.
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它检查JSON文档的整体类型是否与模式的整体类型匹配。在这个例子中，模式要求一个对象，即`{}` JSON结构。
- en: For each property defined in the schema and present in the document, it confirms
    that the value in the document matches the schema definition. This means that
    the value fits one of the defined JSON types. If there are other validation rules
    like a format, or a range specification, or a number of elements for an array,
    these constraints are checked also. This check proceeds recursively through all
    levels of the schema.
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于模式中定义的每个属性并且在文档中存在的属性，它确认文档中的值是否与模式定义匹配。这意味着该值符合定义的JSON类型之一。如果有其他验证规则，比如格式、范围规范或数组的元素数量，也会进行检查。这个检查会递归地通过模式的所有级别进行。
- en: If there's a required list of fields, it checks that all of these are actually
    present in the document.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有一个必需的字段列表，它会检查这些字段是否实际上都存在于文档中。
- en: For this recipe, we've kept the details of the schema to a minimum. A common
    feature that we've omitted in this example is the list of required properties.
    We can also provide considerably more detailed attribute descriptions. The year,
    for example, should probably have a minimum value of `1900` .
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将模式的细节保持在最低限度。在这个例子中省略的一个常见特性是必需属性的列表。我们还可以提供更详细的属性描述。例如，年份可能应该有一个最小值为`1900`。
- en: We've kept the database update processing to a minimum in this example. In some
    cases, the database insert might involve a much more complex process where a database
    client connection is used to execute a command that changes the state of a database
    server. Ideally, the database processing is kept to a minimum—the application-specific
    details are often imported from a separate module and presented as RESTful API
    resources.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们尽量将数据库更新处理保持在最低限度。在某些情况下，数据库插入可能涉及一个更复杂的过程，其中数据库客户端连接用于执行改变数据库服务器状态的命令。理想情况下，数据库处理应尽量保持在最低限度——应用程序特定的细节通常从一个单独的模块导入，并呈现为RESTful
    API资源。
- en: In a larger application, there might be a `player_db` module that included all
    of the player database processing. This module would define all of the classes
    and functions. This would often provide the detailed schema definitions for a
    `player` object. The RESTful API service would import these classes, functions,
    and schema specifications and expose them for external consumers.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个更大的应用程序中，可能会有一个包含所有玩家数据库处理的`player_db`模块。该模块将定义所有的类和函数。这通常会为`player`对象提供详细的模式定义。RESTful
    API服务将导入这些类、函数和模式规范，并将其暴露给外部消费者。
- en: There's more...
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The Swagger specification allows examples of response documents. This is often
    helpful in several ways:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger规范允许响应文档的示例。这通常在几个方面很有帮助：
- en: It's common to start designing the sample document that is part of the response.
    Writing a schema specification that describes a document can be difficult and
    the schema validation feature helps to ensure that the specification matches the
    document.
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始设计作为响应一部分的示例文档是很常见的。编写描述文档的模式规范可能很困难，模式验证功能有助于确保规范与文档匹配。
- en: Once the specification is complete, the next step is to write the server-side
    programming. It's helpful to have unit tests that leverage schema example documents.
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦规范完成，下一步就是编写服务器端编程。有利于编写利用模式示例文档的单元测试。
- en: For users of the Swagger specification, a concrete example of the response can
    be used to design the client, and write unit tests for the client-side programming.
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Swagger规范的用户，可以使用响应的具体示例来设计客户端，并为客户端编程编写单元测试。
- en: 'We can use the following code to confirm that a server has a valid Swagger
    specification. If this raises an exception, either there''s no Swagger document
    or the document doesn''t properly fit the Swagger schema:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码来确认服务器是否具有有效的Swagger规范。如果出现异常，要么没有Swagger文档，要么文档不符合Swagger模式：
- en: '[PRE89]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Location header
  id: totrans-612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置标头
- en: The `201 CREATED` response included a small document with some status information.
    The status information included the key that was assigned to the newly-created
    record.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '`201 CREATED`响应包含了一份包含一些状态信息的小文档。状态信息包括分配给新创建记录的键。'
- en: 'It''s also common for a `201 CREATED` response to have an additional location
    header in the response. This header will provide a URL that can be used to recover
    the document which was created. For this application, the location would be a
    URL, like the following example: `http://127.0.0.1:5000/dealer/players/75f1bfbda3a8492b74a33ee28326649c`
    .'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '`201 CREATED`响应通常还会在响应中包含一个额外的位置标头。此标头将提供一个URL，可用于检索创建的文档。对于此应用程序，位置将是一个URL，如以下示例：`http://127.0.0.1:5000/dealer/players/75f1bfbda3a8492b74a33ee28326649c`。'
- en: The location header can be saved by a client. A complete URL is slightly simpler
    than creating a URL from a URL template and a value.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 位置标头可以被客户端保存。完整的URL比从URL模板和值创建URL稍微简单。
- en: 'The server can build this header as follows:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以构建此标头如下：
- en: '[PRE90]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This relies on the Flask `url_for()` function. This function takes the name
    of a view function, and any parameters that come from the URL path. It then uses
    the route for the view function to construct a complete URL. This will include
    all the information for the currently running server. After the header is inserted,
    the `response` object can be returned.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 这依赖于Flask的`url_for()`函数。此函数接受视图函数的名称和来自URL路径的任何参数。然后，它使用视图函数的路由来构造完整的URL。这将包括当前运行服务器的所有信息。插入标头后，可以返回`response`对象。
- en: Additional resources
  id: totrans-619
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'The server should be able to respond with a list of players. Here''s a minimal
    implementation that simply transforms the data into a large JSON document:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器应该能够响应玩家列表。以下是一个最小实现，只是将数据转换为一个大的JSON文档：
- en: '[PRE91]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: A more sophisticated implementation would support the `$top` and `$skip` query
    parameters to page through the list of players. Additionally, a `$filter` option
    might be useful to implement a search for a subset of players.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的实现将支持`$top`和`$skip`查询参数，以浏览玩家列表。此外，`$filter`选项可能有助于实现对玩家子集的搜索。
- en: 'In addition to the generic query for all players, we need to implement a method
    that will return an individual player. This kind of view function is often just
    as simple, as shown in the following code:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对所有玩家的通用查询外，我们还需要实现一个将返回单个玩家的方法。这种视图函数通常就像下面的代码一样简单：
- en: '[PRE92]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This function confirms that the given ID is a proper key value in the database.
    If the key is not in the database, the database document is transformed into JSON
    notation and returned.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数确认给定的ID是数据库中的正确键值。如果键不在数据库中，则将数据库文档转换为JSON表示并返回。
- en: Query for a specific player
  id: totrans-626
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询特定玩家
- en: 'Here''s the client processing required to locate a specific value in the database.
    This involves multiple steps:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是定位数据库中特定值所需的客户端处理。这涉及多个步骤：
- en: 'First, we''ll create the URL for a particular player:'
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将为特定玩家创建URL：
- en: '[PRE93]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We've built the URL from pieces of information. This is created as a `ParseResult`
    object with separate fields.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从信息片段构建了URL。这被创建为一个`ParseResult`对象，具有单独的字段。
- en: 'Given the URL, we can then create a `Request` object:'
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定URL后，我们可以创建一个`Request`对象：
- en: '[PRE94]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Once we have the `request` object, we can then make the request, and retrieve
    the response. We need to confirm that the response status is `200` . If so, we
    can then parse the body of the response to get the JSON document that describes
    a given player:'
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了`request`对象，我们就可以发出请求并检索响应。我们需要确认响应状态为`200`。如果是，我们就可以解析响应正文以获取描述给定玩家的JSON文档：
- en: '[PRE95]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: If the player doesn't exist, the `urlopen()` function will raise an exception.
    We can enclose this in a `try` statement to capture the `403 NOT FOUND` exceptions
    that could be raised if the player ID doesn't exist.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家不存在，`urlopen()`函数将引发异常。我们可以将其放在`try`语句中，以捕获可能引发的`403 NOT FOUND`异常，如果玩家ID不存在。
- en: Exception handling
  id: totrans-636
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常处理
- en: 'Here''s the general pattern for all client requests. This includes the explicit
    `try` statement:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有客户端请求的一般模式。这包括显式的`try`语句：
- en: '[PRE96]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'There are actually two general kinds of exception:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有两种一般类型的异常：
- en: '**Lower-level exceptions** : This exception indicates that the server can''t
    be contacted. The `ConnectionError` exception is a common example of this lower-level
    exception. This is a subclass of the `OSError` exception.'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**较低级别的异常**：此异常表示无法联系服务器。`ConnectionError`异常是此较低级别异常的常见示例。这是`OSError`异常的子类。'
- en: '**The HTTPError exceptions from the urllib module** : This exception means
    that the overall HTTP protocol worked, but the response from the server was not
    a successful status code. Success is generally a value in the range `200` to `299`
    .'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来自urllib模块的HTTPError异常**：此异常表示整体HTTP协议运行正常，但来自服务器的响应不是成功的状态代码。成功通常是在`200`到`299`范围内的值。'
- en: The `HTTPError` exception has similar attributes to a proper response. It includes
    a status, headers, and a body.
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTPError`异常具有与正确响应类似的属性。它包括状态、标头和正文。'
- en: In some cases, an `HTTPError` exception might be one of several expected responses
    from a server. It might not indicate an error or problem. It might simply be another
    meaningful status code.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，`HTTPError`异常可能是服务器的几种预期响应之一。它可能不表示错误或问题。它可能只是另一个有意义的状态代码。
- en: See also
  id: totrans-644
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Parsing the URL path* recipe for other examples of URL processing.
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅*解析URL路径*配方，了解其他URL处理示例。
- en: The *Making REST requests with urllib* recipe shows other examples of query
    string processing.
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用urllib进行REST请求*配方显示了其他查询字符串处理的示例。'
- en: Implementing authentication for web services
  id: totrans-647
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Web服务实现身份验证
- en: 'Security, in general, is a pervasive issue. Every part of an application will
    have security considerations. Parts of the implementation of security will involve
    two closely-related issues:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，安全性是一个普遍的问题。应用程序的每个部分都会有安全性考虑。安全实施的部分将涉及两个密切相关的问题：
- en: '**Authentication** : A client must provide some evidence of who they are. This
    might involve signed certificates or it might involve credentials like a username
    and password. It might involve multiple factors, such as an SMS message to a phone
    that the user should have access to. The web server must validate this authentication.'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：客户端必须提供一些关于自己的证据。这可能涉及签名证书，也可能涉及像用户名和密码这样的凭据。它可能涉及多个因素，例如发送短信到用户应该有访问权限的电话。Web服务器必须验证此身份验证。'
- en: '**Authorization** : A server must define areas of authority and allocate these
    to groups of users. Furthermore, individual users must be defined as members of
    the authorization groups.'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：服务器必须定义权限区域，并将其分配给用户组。此外，必须将个别用户定义为授权组的成员。'
- en: While it's technically possible to define authorization on an individual basis,
    this tends to become awkward as a site or application grows and changes. It's
    easier to define security for groups. In some cases, a group may (initially) have
    only a single individual.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从技术上讲可以基于个人基础定义授权，但随着站点或应用程序的增长和变化，这往往变得笨拙。更容易为组定义安全性。在某些情况下，一个组可能（最初）只有一个人。
- en: Application software must implement authorization decisions. For Flask, the
    authorization can be part of each view function. The connection of individual
    to group and group to view function defines the resources available to any specific
    user.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 应用软件必须实施授权决策。对于Flask，授权可以成为每个视图函数的一部分。个人与组的连接以及组与视图函数的连接定义了任何特定用户可用的资源。
- en: Confusingly, the HTTP standards provide authentication credentials using the
    HTTP `Authorization` header. This may lead to some confusion because the header's
    name doesn't precisely reflect its purpose.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 令人困惑的是，HTTP标准使用HTTP `Authorization`头提供身份验证凭据。这可能会导致一些混淆，因为头的名称并不完全反映其目的。
- en: 'There are a variety of ways that authentication details can be provided from
    a web client to a web server. Here are a few of the alternatives:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方式可以从Web客户端提供身份验证详细信息到Web服务器。以下是一些替代方案：
- en: '**Certificates** : Certificates which are encrypted and include a digital signature
    as well as a reference to a **Certificate** **Authority** ( **CA** ): These are
    exchanged by the **Secure Socket Layer** ( **SSL** ). In some environments, both
    client and server must have certificates that are used for mutual authentication.
    In other environments, the server provides a certificate of authenticity, but
    the client does not. This is common for the `https` scheme. The server doesn''t
    verify the client''s certificate.'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书**：加密的证书包括数字签名以及对**证书** **颁发机构**（**CA**）的引用：这些由**安全套接字层**（**SSL**）交换。在某些环境中，客户端和服务器都必须具有用于相互认证的证书。在其他环境中，服务器提供真实性证书，但客户端不提供。这在`https`方案中很常见。服务器不验证客户端的证书。'
- en: '**Static API keys or tokens** : A web service might provide a simple, fixed
    key. This might be issued with advice to keep it secret, much like a password.'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态API密钥或令牌**：Web服务可能提供一个简单的固定密钥。这可能会附带保密建议，就像密码一样。'
- en: '**Usernames and passwords** : The web server might identify users by a username
    and password. User identity might be further confirmed using e-mail or SMS messages.'
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户名和密码**：Web服务器可能通过用户名和密码识别用户。用户身份可能进一步通过电子邮件或短信消息进行确认。'
- en: '**Third-party authentication** : This might involve using a service such as
    OpenID. For details, see [http://openid.net](http://openid.net) . This will involve
    a callback URL so that notification information can be returned by the OpenID
    provider.'
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三方身份验证**：这可能涉及使用OpenID等服务。有关详细信息，请参见[http://openid.net](http://openid.net)。这将涉及回调URL，以便OpenID提供者可以返回通知信息。'
- en: Additionally, there's a question of how the user information gets loaded into
    a web server. Some websites are self-service, with users providing some minimal
    contact information and being granted access to the content.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个问题，即用户信息如何加载到Web服务器中。有些网站是自助服务的，用户提供一些最小的联系信息并被授予访问内容的权限。
- en: In many cases, websites aren't self-service. A user might be carefully vetted
    before being allowed access. Access might involve contracts and fees for access
    to data or services. In some cases, one company will purchase licenses for their
    employees, providing a finite list of users who have access to a given suite of
    web services.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，网站不是自助服务的。在允许访问之前，用户可能会经过仔细审查。访问可能涉及合同和访问数据或服务的费用。在某些情况下，一家公司将为其员工购买许可证，为一组特定的Web服务提供访问权限的用户列表。
- en: This recipe will show a self-service application in which there is no defined
    set of users. This means that there must be a web service to create new users
    that doesn't require any authentication. All other services will require a properly
    authenticated user.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将展示一个自助服务应用程序，其中没有定义一组用户。这意味着必须有一个Web服务来创建不需要任何身份验证的新用户。所有其他服务将需要一个经过适当身份验证的用户。
- en: Getting ready
  id: totrans-662
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We''ll implement a version of HTTP-based authentication using the `Authorization`
    header. There are two variations on this theme:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Authorization`头实现基于HTTP的身份验证的版本。这个主题有两种变体：
- en: '**HTTP basic authentication** : This uses a simple username and password string.
    It relies on the SSL layer to encrypt the traffic between client and server.'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP基本身份验证**：这使用简单的用户名和密码字符串。它依赖于SSL层来加密客户端和服务器之间的流量。'
- en: '**HTTP digest authentication** : This uses a much more complex hash of username,
    password, and a nonce provided by the server. The server computes the expected
    hash value. If the hash values match, then the same bytes were used to compute
    the hash, and the password must have been valid. This doesn''t require SSL.'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP摘要身份验证**：这使用了用户名、密码和服务器提供的一次性随机数的更复杂的哈希。服务器计算预期的哈希值。如果哈希值匹配，则使用相同的字节来计算哈希，密码必须是有效的。这不需要SSL。'
- en: SSL is frequently used by web servers to establish their authenticity. Because
    this technology is so pervasive, it means that HTTP basic authentication can be
    used. This is a huge simplification in RESTful API processing, since each request
    will include the `Authorization` header and secure sockets will be used between
    client and server.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: SSL经常被Web服务器用来建立它们的真实性。因为这项技术如此普遍，这意味着可以使用HTTP基本身份验证。这在RESTful API处理中是一个巨大的简化，因为每个请求都将包括`Authorization`头，并且客户端和服务器之间将使用安全套接字。
- en: Configuring SSL
  id: totrans-667
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置SSL
- en: The details of getting and configuring certificates is outside of the realm
    of Python programming. The OpenSSL package provides tools for creating self-signed
    certificates that can be used for configuring a secure server. CAs such as Comodo
    Group and Symantec offer trusted certificates that are widely recognized by OS
    vendors, as well as the Mozilla Foundation.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 获取和配置证书的详细信息超出了Python编程的范围。OpenSSL软件包提供了用于创建用于配置安全服务器的自签名证书的工具。像Comodo Group和Symantec这样的CA提供了被OS供应商广泛认可的受信任的证书，以及Mozilla基金会。
- en: 'There are two parts to creating a certificate with OpenSSL:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenSSL创建证书有两个部分：
- en: 'Create a private key file. This is generally done with the following OS-level
    command:'
  id: totrans-670
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个私钥文件。通常使用以下OS级命令完成：
- en: '[PRE97]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The `openssl genrsa 1024` command created a private key file, which was saved
    under the name `ssl.key` .
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '`openssl genrsa 1024`命令创建了一个私钥文件，保存在名为`ssl.key`的文件中。'
- en: 'Create a certificate using the key file. The following command is one way to
    handle this:'
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用密钥文件创建证书。以下命令是处理此事的一种方式：
- en: '[PRE98]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: You are about to be asked to enter information that will be incorporated into
    your certificate request. What you are about to enter is what is called a **Distinguished
    Name**  ( **DN** ). There are quite a few fields but you can leave some blank.
    For some fields there will be a default value. If you enter `.` , the field will
    be left blank.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 您即将被要求输入将被合并到您的证书请求中的信息。您即将输入的是所谓的**Distinguished Name**（**DN**）。有相当多的字段，但您可以留下一些空白。对于某些字段，将有一个默认值。如果输入`.`，该字段将被留空。
- en: '[PRE99]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The command `openssl req -new -x509 -nodes -sha1 -days 365 -key ssl.key` created
    the private certificate file, which was saved in `ssl.cert` . This certificate
    is privately signed, and doesn't have a CA. It provides only a limited set of
    features.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '`openssl req -new -x509 -nodes -sha1 -days 365 -key ssl.key`命令创建了私有证书文件，保存在`ssl.cert`中。这个证书是私下签署的，没有CA。它只提供了有限的功能集。'
- en: These two steps create two files: `ssl.cert` and `ssl.key` . We'll use these
    files below to secure the server.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤创建了两个文件：`ssl.cert`和`ssl.key`。我们将在下面使用这些文件来保护服务器。
- en: Users and credentials
  id: totrans-679
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户和凭据
- en: 'In order for users to be able to supply a username and a password, we''ll need
    to store this information on the server. There''s a very important rule about
    user credentials:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户能够提供用户名和密码，我们需要在服务器上存储这些信息。关于用户凭据有一个非常重要的规则：
- en: Tip
  id: totrans-681
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Never store credentials. Never.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要存储凭据。永远不要。
- en: It should be clear that storing plain text passwords is an invitation to a security
    disaster. What's less obvious is that we can't even store encrypted passwords.
    When the key used to encrypt the passwords is compromised, that will lead to a
    loss of all of the user identities.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，存储明文密码是对安全灾难的邀请。不太明显的是，我们甚至不能存储加密密码。当用于加密密码的密钥被破坏时，将导致所有用户身份的丢失。
- en: How can a user's password be checked if we do not store the password?
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不存储密码，如何检查用户的密码？
- en: The solution is to store a hash instead of a password. The first time the password
    is created, the server saves the hashed summary. Each time after that, the user's
    input is hashed and compared with the saved hash. If the two hashes match, then
    the password must have been correct. What's central is the extreme difficulty
    of recovering a password from the hash.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是存储哈希而不是密码。第一次创建密码时，服务器保存了哈希摘要。之后每次，用户的输入都会被哈希并与保存的哈希进行比较。如果两个哈希匹配，则密码必须是正确的。核心问题是从哈希中恢复密码的极端困难。
- en: 'There is a three-step process to create the initial hash value for a password:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 创建密码的初始哈希值有一个三步过程：
- en: Create a random `salt` value. Generally, 16 bytes from `os.urandom()` are used.
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个随机的`salt`值。通常使用`os.urandom()`生成16字节。
- en: Use the `salt` plus the password to create a `hash` value. Generally, the `hashlib`
    is used for this. Specifically, `hashlib.pbkdf2_hmac()` . A specific digest algorithm
    is used for this, for example, `md5`  or` sha224` .
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`salt`加上密码创建`hash`值。通常情况下，使用`hashlib`来实现。具体来说，使用`hashlib.pbkdf2_hmac()`。为此使用特定的摘要算法，例如`md5`或`sha224`。
- en: Save the digest name, the `salt` , and the hashed bytes. Often this is combined
    into a single string that looks like—`md5$salt$hash` . The `md5` is a literal.
    The `$` separates the algorithm name, `salt` , and `hash` values.
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存摘要名称、`salt`和哈希字节。通常这些被合并成一个看起来像`md5$salt$hash`的单个字符串。`md5`是一个文字。`$`分隔算法名称、`salt`和`hash`值。
- en: 'When a password needs to be checked, a similar process is followed:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要检查密码时，会遵循类似的过程：
- en: Given the username, locate the saved hash string. This will have a three-part
    structure of the digest algorithm name, saved salt, and hashed bytes. The elements
    may be separated by `$` .
  id: totrans-691
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据用户名，找到保存的哈希字符串。这将具有摘要算法名称、保存的盐和哈希字节的三部分结构。这些元素可以用`$`分隔。
- en: Use the saved salt plus the user-supplied candidate password to create a computed
    `hash` value.
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用保存的盐加上用户提供的候选密码创建计算的`hash`值。
- en: If the computed hash bytes match the saved hash bytes, we know the digest algorithm
    and salt matched; therefore, the password must have matched as well.
  id: totrans-693
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果计算的哈希字节与保存的哈希字节匹配，我们知道摘要算法和盐匹配；因此，密码也必须匹配。
- en: We'll define a simple class to retain user information as well as the hashed
    password. We can use Flask's `g` object to save the user information during request
    processing.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个简单的类来保留用户信息以及哈希密码。我们可以使用Flask的`g`对象在请求处理期间保存用户信息。
- en: Flask view function decorator
  id: totrans-695
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Flask视图函数装饰器
- en: 'There are several alternatives for handling the authentication checks:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种处理身份验证检查的替代方法：
- en: If every route has the same security requirements, then the `@dealer.before_request`
    function can be used to validate all `Authorization` headers. This would require
    some exception processing for the `/swagger.json` route and the self-service route
    that allows an unauthorized user to create their new username and password credentials.
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果每个路由都具有相同的安全要求，那么`@dealer.before_request`函数可以用于验证所有`Authorization`标头。这将需要一些异常处理，用于`/swagger.json`路由和允许未经授权的用户创建其新用户名和密码凭据的自助服务路由。
- en: When some routes require authentication and some don't, it works out well to
    introduce a decorator for the routes that need authentication.
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一些路由需要身份验证而另一些不需要时，引入需要身份验证的路由的装饰器是很好的。
- en: 'A Python decorator is a function that wraps another function to extend its
    functionality. The core technique looks like this:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: Python装饰器是一个包装另一个函数以扩展其功能的函数。核心技术看起来像这样：
- en: '[PRE100]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The idea is to replace a given function, The `function` in this example, with
    a new function, `decorated_function` . Within the body of the decorated function,
    it executes the original function. Some processing can be done before and some
    processing done after the function being decorated.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是用一个新函数`decorated_function`来替换给定的函数`function`。在装饰函数的主体内，它执行原始函数。在装饰的函数之前可以进行一些处理，在函数之后也可以进行一些处理。
- en: 'In a Flask context, we''ll put our decorators after the `@route` decorator:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask上下文中，我们将在`@route`装饰器之后放置我们的装饰器：
- en: '[PRE101]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We've wrapped the `view_function()` with the `@decorate` decorator. A decorator
    can check authentication to be sure that the user is known. We can do a wide variety
    of processing in these functions.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`@decorate`装饰器包装了`view_function()`。装饰器可以检查身份验证，以确保用户已知。我们可以在这些函数中进行各种处理。
- en: How to do it...
  id: totrans-705
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We''ll decompose this into four parts:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这分解为四个部分：
- en: Defining the `User` class
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`User`类
- en: Defining a view decorator
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义视图装饰器
- en: Creating the server
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建服务器
- en: Creating an example client
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个示例客户端
- en: Defining the User class
  id: totrans-711
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义用户类
- en: 'This class definition provides an example of a definition of an individual
    `User` object:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类定义提供了一个单独的`User`对象的定义示例：
- en: 'Import modules that are required to create and check the password:'
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的模块以创建和检查密码：
- en: '[PRE102]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Other useful modules include `json` so that a `User` object can be properly
    serialized.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有用的模块包括`json`，以便可以正确序列化`User`对象。
- en: 'Define the `User` class:'
  id: totrans-716
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`User`类：
- en: '[PRE103]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Since we''ll be changing some aspects of password generation and checking,
    we''ll provide two constants as part of the overall class definition:'
  id: totrans-718
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将更改密码生成和检查的某些方面，因此我们将作为整体类定义的一部分提供两个常量：
- en: '[PRE104]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We'll use the **SHA-384** digest algorithm. This provides 64-byte summaries.
    We'll use 100,000 rounds for the **Password-Based Key Derivation Function 2**
    ( **PBKDF2** ) algorithm.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**SHA-384**摘要算法。这提供了64字节的摘要。我们将使用**基于密码的密钥派生函数2**（**PBKDF2**）算法进行100,000轮。
- en: 'Most of the time, we''ll create users from a JSON document. This will be a
    dictionary that can be turned into keyword argument values using `**` :'
  id: totrans-721
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数情况下，我们将从JSON文档创建用户。这将是一个可以使用`**`转换为关键字参数值的字典：
- en: '[PRE105]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Note that we don't expect to set the password directly. Instead, we'll set the
    password separately from creating the user document.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不希望直接设置密码。相反，我们将单独设置密码，而不是创建用户文档时。
- en: We've omitted additional authorization details, such as a list of groups to
    which the user belongs. We've also omitted an indicator showing that the password
    needs to be changed.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了其他授权细节，例如用户所属的组列表。我们还省略了一个指示密码需要更改的指示器。
- en: 'Define the algorithm for setting the password `hash` value:'
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义设置密码`hash`值的算法：
- en: '[PRE106]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: We've built a random salt using `os.urandom()` . We've then built the complete
    `hash` value using the given digest algorithm, the password, and `salt` . We've
    used a configurable number of rounds.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`os.urandom()`构建了一个随机盐。然后，我们使用给定的摘要算法、密码和`salt`构建了完整的`hash`值。我们使用可配置的轮数。
- en: Note that the hash computation works in bytes, not Unicode characters. We've
    encoded the password into bytes using the `utf-8` encoding.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，哈希计算是按字节而不是Unicode字符进行的。我们使用`utf-8`编码将密码编码为字节。
- en: We assembled a string using the name of the digest algorithm, the salt, and
    the encoded `hash` value. We've used URL-safe `base64` encoding of the bytes so
    that the full, hashed password value can be displayed easily. It can be saved
    in any kind of database because it uses only `A-Z` , `a-z` , `0-9` , `-` and `_`
    .
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用摘要算法的名称、盐和编码的`hash`值组装了一个字符串。我们使用URL安全的`base64`编码字节，以便可以轻松显示完整的哈希密码值。它可以保存在任何类型的数据库中，因为它只使用`A-Z`，`a-z`，`0-9`，`-`和`_`。
- en: Note that `urlsafe_b64encode()` creates a string of byte values. These must
    be decoded to see what Unicode characters they represent. We use the ASCII encoding
    scheme here because `base64` only uses sixty-four standard ASCII characters.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`urlsafe_b64encode()`创建一个字节值的字符串。这些必须解码才能看到它们代表的Unicode字符。我们在这里使用ASCII编码方案，因为`base64`只使用六十四个标准ASCII字符。
- en: 'Define an algorithm for checking a password hash value:'
  id: totrans-731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义检查密码哈希值的算法：
- en: '[PRE107]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: We've decomposed the password hash into `digest` , `salt` , and `expected_hash`
    value. Since the various parts were `base64` encoded, they must be decoded to
    recover the original bytes.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将密码哈希分解为`digest`、`salt`和`expected_hash`值。由于各部分都是`base64`编码的，因此必须对其进行解码以恢复原始字节。
- en: Note that the hash computation works in bytes, not Unicode characters. We've
    encoded the password into bytes using the `utf-8` encoding. The computed results
    of `hashlib.pbkdf2_hmac()` are compared with the expected results. If they match,
    then the passwords must have been the same.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，哈希计算以字节而不是Unicode字符工作。我们使用`utf-8`编码将密码编码为字节。`hashlib.pbkdf2_hmac()`的计算结果与预期结果进行比较。如果它们匹配，那么密码必须是相同的。
- en: 'Here''s a demonstration of how this class is used:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个类如何使用的演示：
- en: '[PRE108]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: This test case can be included in the class docstring. See the *Using docstrings
    for testing* recipe in [Chapter 11](text00120.html#page "Chapter 11. Testing")
    , *Testing* , for more information on this kind of test case.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试用例可以包含在类docstring中。有关这种测试用例的更多信息，请参见[第11章](text00120.html#page "第11章。测试")中的*使用docstring进行测试*配方，*测试*。
- en: In more complex applications, there may also be a definition for the collection
    of users. This often uses a database of some kind to facilitate locating users
    and inserting new users.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的应用程序中，可能还会有一个用户集合的定义。这通常使用某种数据库来定位用户和插入新用户。
- en: Defining a view decorator
  id: totrans-739
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义视图装饰器
- en: 'Import the `@wraps` decorator from `functools` . This helps define decorators
    by assuring that the new function has the original name and docstring copied from
    the function that is being decorated:'
  id: totrans-740
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`functools`导入`@wraps`装饰器。这有助于通过确保新函数具有从被装饰的函数复制的原始名称和文档字符串来定义装饰器：
- en: '[PRE109]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In order to check passwords, we''ll need the `base64` module to help decompose
    the value of the `Authorization` header. We''ll also need to report errors and
    update the Flask processing context using the global `g` object:'
  id: totrans-742
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查密码，我们需要`base64`模块来帮助分解`Authorization`头的值。我们还需要报告错误，并使用全局`g`对象更新Flask处理上下文：
- en: '[PRE110]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Define the decorator. All decorators have this essential outline. We''ll replace
    the `processing here` part in the next step:'
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义装饰器。所有装饰器都有这个基本的轮廓。我们将在下一步中替换`这里处理`部分：
- en: '[PRE111]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Here are the processing steps to examine the header. Note that every problem
    encountered simply aborts processing with the `401 UNAUTHORIZED` as the status
    code. To prevent hackers from exploring the algorithm, all of the results are
    identical even though the root causes are different:'
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是检查头的处理步骤。请注意，遇到的每个问题都会简单地中止处理，并将`401 UNAUTHORIZED`作为状态码。为了防止黑客探索算法，尽管根本原因不同，但所有结果都是相同的：
- en: '[PRE112]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'There are a number of conditions that must be successfully passed:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 必须成功通过一些条件：
- en: An `Authorization` header must be present
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须存在`Authorization`头
- en: The header must specify basic authentication
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题必须指定基本身份验证
- en: The value must include a `username:password` string encoded using `base64`
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该值必须包括使用`base64`编码的`username:password`字符串
- en: The username must be a known username
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名必须是已知的用户名
- en: The computed hash from the password must match the expected password hash
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从密码计算出的哈希值必须与预期的密码哈希值匹配
- en: Any single failure leads to a `401 UNAUTHORIZED` response.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 任何单个失败都会导致`401 UNAUTHORIZED`响应。
- en: Creating the server
  id: totrans-755
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建服务器
- en: 'This parallels the server shown in the *Parsing a JSON request* recipe. There
    are some important modifications:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 这与*解析JSON请求*配方中显示的服务器相似。有一些重要的修改：
- en: Create the local self-signed certificate or purchase a certificate from a certificate
    authority. For this recipe, we'll assume the two filenames are `ssl.cert` and
    `ssl.key` .
  id: totrans-757
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建本地自签名证书或从证书颁发机构购买证书。对于这个配方，我们假设两个文件名分别是`ssl.cert`和`ssl.key`。
- en: 'Import the modules required to build a server. Also import the `User` class
    definition:'
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入构建服务器所需的模块。还要导入`User`类定义：
- en: '[PRE113]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Include the `@authorization_required` decorator definition.
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括`@authorization_required`装饰器定义。
- en: 'Define a route with no authentication. This will be used to create new users.
    A similar view function was defined in the *Parsing a JSON request* recipe. This
    version requires a password property in the incoming document. This will be the
    plain-text password that''s used to create the hash. The plain text password is
    not saved anywhere; only the hash is retained:'
  id: totrans-761
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个无需身份验证的路由。这将用于创建新用户。在*解析JSON请求*配方中定义了一个类似的视图函数。这个版本需要传入文档中的密码属性。这将是用于创建哈希的明文密码。明文密码不会保存在任何地方；只有哈希值会被保留：
- en: '[PRE114]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: After creating the user, the password is set separately. This follows the pattern
    set by some applications where users are loaded in bulk. This processing might
    provide a temporary password for each user, which must be immediately changed.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户后，密码将单独设置。这遵循了一些应用程序设置的模式，其中用户是批量加载的。这个处理可能为每个用户提供一个临时密码，必须立即更改。
- en: Note that each user is assigned a cryptic ID. The assigned ID is computed from
    a hex digest of their Twitter handle. This is unusual, but it shows that there's
    a great deal of flexibility available.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个用户都被分配了一个神秘的ID。分配的ID是从他们的Twitter句柄的十六进制摘要计算出来的。这是不寻常的，但它表明有很大的灵活性可用。
- en: If we wanted users to choose their own username, we'd need to add that to the
    request document. We would use that username instead of the computed ID value.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望用户选择自己的用户名，我们需要将其添加到请求文档中。我们将使用该用户名而不是计算出的ID值。
- en: 'Define a route for which authentication is required. A similar view function
    was defined in the *Parsing a JSON request* recipe. This version uses the `@authorization_required`
    decorator:'
  id: totrans-766
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为需要身份验证的路由定义路由。在*解析JSON请求*配方中定义了一个类似的视图函数。这个版本使用`@authorization_required`装饰器：
- en: '[PRE115]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Most of the other routes will have similar `@authorization_required` decorators.
    Some routes, such as the `/swagger.json` route, will not require authorization.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数其他路由将具有类似的`@authorization_required`装饰器。一些路由，如`/swagger.json`路由，将不需要授权。
- en: 'The `ssl` module defines the `ssl.SSLContext` class. The context can be loaded
    with the self-signed certificate and private key file created previously. The
    context is then used by the Flask object''s `run()` method. This will change scheme
    in the URL from `http://127.0.01:5000` to `https://127.0.0.1:5000` :'
  id: totrans-769
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ssl`模块定义了`ssl.SSLContext`类。上下文可以加载以前创建的自签名证书和私钥文件。然后Flask对象的`run()`方法使用该上下文。这将从`http://127.0.01:5000`的URL中更改方案为`https://127.0.0.1:5000`：'
- en: '[PRE116]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Creating an example client
  id: totrans-771
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个示例客户端
- en: 'Create an SSL context that will work with a self-signed certificate:'
  id: totrans-772
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与自签名证书一起使用的SSL上下文：
- en: '[PRE117]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This context can be used with all `urllib` requests. This will politely ignore
    the lack of CA signature on the certificate.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 这个上下文可以用于所有`urllib`请求。这将礼貌地忽略证书上缺少CA签名。
- en: 'Here''s how we use this context to fetch the Swagger specification:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用这个上下文来获取Swagger规范的方式：
- en: '[PRE118]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Create the URL for creating a new player instance. Note that we must use `https`
    for the scheme. We''ve built a `ParseResult` object to show the various pieces
    of the URL separately:'
  id: totrans-777
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于创建新玩家实例的URL。请注意，我们必须使用`https`作为方案。我们已经构建了一个`ParseResult`对象，以便分别显示URL的各个部分：
- en: '[PRE119]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Create a Python object that will be serialized into a JSON document. This schema
    is similar to the example shown in the *Parsing a JSON request* recipe. This includes
    one extra property, which is the plain text:'
  id: totrans-779
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Python对象，将被序列化为JSON文档。这个模式类似于*解析JSON请求*食谱中显示的示例。这包括一个额外的属性，即纯文本：
- en: '[PRE120]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Because the SSL layer uses an encrypted socket, sending a plain text password
    like this is feasible.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 因为SSL层使用加密套接字，所以发送这样的纯文本密码是可行的。
- en: 'We''ll combine URL, document, method, and headers to create the complete `Request`
    object. This will use `urlunparse()` to collapse the URL parts into a single string.
    The `Content-Type` header alerts the server that we''re going to provide a text
    document in JSON notation:'
  id: totrans-782
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将URL、文档、方法和标头组合成完整的`Request`对象。这将使用`urlunparse()`将URL部分合并为一个字符串。`Content-Type`标头通知服务器我们将以JSON表示法提供文本文档：
- en: '[PRE121]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'We can post this document to create a new player:'
  id: totrans-784
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以发布此文档以创建新玩家：
- en: '[PRE122]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The happy path will receive a `201` status response, and the user will be created.
    The response will include the assigned user ID plus a redundant status code.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 快乐路径将收到`201`状态响应，并且用户将被创建。响应将包括分配的用户ID和多余的状态代码。
- en: If the user is a duplicate, or the document doesn't match the schema, then there
    will be an `HTTPError` exception raised. This may have useful error messages that
    can be displayed.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户是重复的，或者文档不匹配模式，那么将会引发`HTTPError`异常。这可能会有有用的错误消息可以显示。
- en: 'We can use the assigned ID and the known password to create an `Authorization`
    header:'
  id: totrans-788
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用分配的ID和已知密码创建一个`Authorization`标头：
- en: '[PRE123]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The `Authorization` header has a two-word value: `b"BASIC " + credentials`
    . The word `BASIC` is required. The credentials must be a `base64` encoding of
    the `username:password` string. In this example, the username is a specific ID
    assigned when the user was created.'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '`Authorization`标头有一个两个单词的值：`b"BASIC " + credentials`。单词`BASIC`是必需的。凭据必须是`username:password`字符串的`base64`编码。在这个例子中，用户名是在创建用户时分配的特定ID。'
- en: 'Here''s a URL to query all of the players. We''ve built a `ParseResult` object
    to show the various pieces of the URL separately:'
  id: totrans-791
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个查询所有玩家的URL。我们已经构建了一个`ParseResult`对象，以便分别显示URL的各个部分：
- en: '[PRE124]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'We can combine the URL, method, and headers into a single `Request` object.
    This includes the `Authorization` header, which has the `base64` encoding of username
    and password:'
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将URL、方法和标头组合成一个单独的`Request`对象。这包括`Authorization`标头，其中包含用户名和密码的`base64`编码：
- en: '[PRE125]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The `Request` object can be used to make the query from the server and process
    the response with `urllib` :'
  id: totrans-795
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Request`对象可用于从服务器进行查询并使用`urllib`处理响应：'
- en: '[PRE126]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The expected status is `200` . The response should be a JSON document with a
    list of known `players` .
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 预期状态是`200`。响应应该是一个已知`players`列表的JSON文档。
- en: How it works...
  id: totrans-798
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'There are three parts to this recipe:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱有三个部分：
- en: '**Using SSL to provide a secure channel** : This makes it possible to exchange
    usernames and passwords directly. Instead of the more complex HTTP digest authentication,
    we can use the simpler HTTP basic authentication scheme. There are a variety of
    other authentication schemes used by web services; most of them require SSL.'
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用SSL提供安全通道**：这使得直接交换用户名和密码成为可能。我们可以使用更简单的HTTP基本身份验证方案，而不是更复杂的HTTP摘要身份验证。Web服务使用各种其他身份验证方案；其中大多数需要SSL。'
- en: '**Using best practices for password hashing** : Saving passwords in any form
    is a security risk. Rather than save plain passwords, or even encrypted passwords,
    we only save a computed hash value of a password and a random salt string. This
    assures us that it''s nearly impossible to reverse engineer passwords from the
    hashed values.'
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用最佳的密码哈希实践**：以任何形式保存密码都是安全风险。我们不保存纯文本密码，甚至加密密码，而是只保存密码的计算哈希值和一个随机盐字符串。这确保我们几乎不可能从哈希值中逆向工程密码。'
- en: '**Using a decorator** : It is used to distinguish between routes that require
    authentication and routes that do not require authentication. This allows a great
    deal of flexibility in creating a web service.'
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用装饰器**：它用于区分需要身份验证和不需要身份验证的路由。这允许在创建Web服务时具有很大的灵活性。'
- en: In cases where all routes require authentication, we could add the password
    check algorithm to the `@dealer.before_request` function. This would centralize
    all authentication checks. It would also mean that a separate administrative process
    is required to define users and hashed passwords.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有路由都需要身份验证的情况下，我们可以将密码检查算法添加到`@dealer.before_request`函数中。这将集中所有身份验证检查。这也意味着需要一个单独的管理流程来定义用户和散列密码。
- en: What's essential here is that the security check on the server is a simple `@authorization_required`
    decorator. It's very easy to be sure that it is in place on all view functions.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是服务器上的安全检查是一个简单的`@authorization_required`装饰器。很容易确保它在所有视图函数中都存在。
- en: There's more...
  id: totrans-805
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This server has a relatively simple set of authorization rules:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务器有一套相对简单的授权规则：
- en: Most routes require a valid user. This was implemented by the presence of the
    `@authorization_required` decorator in the view function.
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数路由需要有效用户。这是通过在视图函数中存在`@authorization_required`装饰器来实现的。
- en: A `GET` for `/dealer/swagger.json` and a `POST` to `/dealer/players` do not
    require a valid user. This was implemented by the absence of an additional decorator.
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`/dealer/swagger.json`的`GET`和`/dealer/players`的`POST`不需要有效用户。这是通过缺少额外装饰器来实现的。
- en: In many cases, we'll have a considerably more complex configuration of privileges,
    groups, and users. The principle of least privilege suggests that the users should
    be segregated into groups, and that each group has the fewest privileges possible
    to accomplish their goals.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们将有一个更复杂的特权、组和用户配置。最小特权原则建议用户应该被分隔成组，并且每个组应该具有尽可能少的特权来实现他们的目标。
- en: This often means that we'll have an administrative group that creates new users,
    but has no other access to use the RESTful web services. Users can access the
    web services, but are unable to create any additional users.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常意味着我们将有一个管理组来创建新用户，但没有其他访问权限来使用RESTful Web服务。用户可以访问Web服务，但无法创建任何其他用户。
- en: 'This requires several changes to our data model. We should define user groups
    and assign users to those groups:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要对我们的数据模型进行几处更改。我们应该定义用户组并将用户分配到这些组中：
- en: '[PRE127]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'We can then expand the definition of `User` to include group membership:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以扩展`User`的定义以包括组成员资格：
- en: '[PRE128]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'When we create a new instance of the `GroupUser` class, we can also assign
    them to a particular group:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`GroupUser`类的新实例时，我们也可以将它们分配到特定的组中：
- en: '[PRE129]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'We can now expand our decorator to check the `groups` attribute of the authenticated
    user. A decorator with parameters is a bit more complex than a parameterless decorator:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以扩展我们的装饰器来检查经过身份验证的用户的`groups`属性。带参数的装饰器比无参数的装饰器复杂一些：
- en: '[PRE130]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: A decorator with a parameter works by creating a concrete decorator that includes
    the parameter. The concrete decorator, `group_member_decorator` , will wrap a
    given view function. This will parse the `Authorization` header, locate the `GroupUser`
    instance and check the group membership.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 带参数的装饰器通过创建一个包含参数的具体装饰器来工作。具体装饰器`group_member_decorator`将包装给定的视图函数。这将解析`Authorization`头，找到`GroupUser`实例并检查组成员资格。
- en: We've used `# Check Password and determine user` as a placeholder for a refactored
    function to check the `Authorization` header. The core functionality of the `@authorization_required`
    decorator needs to be extracted into a stand-alone function so it can be used
    in several places.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`＃Check Password and determine user`作为一个重构函数来检查`Authorization`头的占位符。`@authorization_required`装饰器的核心功能需要被提取到一个独立的函数中，以便在多个地方使用。
- en: 'We can then use this decorator as follows:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用这个装饰器如下：
- en: '[PRE131]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This narrows the scope of privilege for each individual view function. It provides
    assurance that the principle of least privilege is followed by the RESTful web
    services.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 这缩小了每个单独视图函数的特权范围。它确保了RESTful Web服务遵循最小特权原则。
- en: Creating a command-line interface
  id: totrans-824
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个命令行界面
- en: When working with a site that has special administrator privileges, we often
    need to provide a way to create an initial administrative user. This user can
    then create all of the users with non-administrative privileges. This is often
    done with a CLI application which is run by the administrative user directly on
    the web server.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 在与具有特殊管理员特权的站点一起工作时，我们经常需要提供一种创建初始管理用户的方式。然后，这个用户可以创建所有具有非管理特权的用户。这通常是通过在Web服务器上直接由管理用户运行的CLI应用程序来完成的。
- en: Flask supports this with a decorator that defines commands that must be run
    outside the RESTful web services environment. We can use `@dealer.cli.command()`
    to define a command that is run from the command line. This command can, for example,
    load the initial administrative user. A command might be created to load users
    from a list, also.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: Flask支持使用装饰器定义必须在RESTful Web服务环境之外运行的命令。我们可以使用`@dealer.cli.command()`来定义一个从命令行运行的命令。例如，这个命令可以加载初始的管理用户。也可以创建一个命令来从列表中加载用户。
- en: The `getpass` module is a way for an administrative user to provide their initial
    password in a way that won't be echoed on a terminal. This can provide confidence
    that the site's credentials are being processed securely.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '`getpass`模块是管理用户以不会在终端上回显的方式提供他们的初始密码的一种方式。这可以确保站点的凭据正在安全处理。'
- en: Building the Authentication header
  id: totrans-828
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建身份验证头
- en: 'Web services that rely on an HTTP basic `Authorization` header can be supported
    in one of two common ways:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于HTTP基本`Authorization`头的Web服务可以通过两种常见的方式来支持：
- en: Build the `Authorization` header with the credentials and include this in each
    request. To do this, we need to provide the proper `base64` encoding of the string
    `username:password` . This alternative has the advantage of being relatively simple.
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用凭据构建`Authorization`头，并在每个请求中包含它。为此，我们需要提供字符串`username:password`的正确`base64`编码。这种替代方法的优势在于相对简单。
- en: 'Use the `urllib` features to provide the `Authorization` header automatically:'
  id: totrans-831
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`urllib`功能自动提供`Authorization`头：
- en: '[PRE132]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: We've created an instance of `HTTPBasicAuthHandler` . This is populated with
    all of the usernames and passwords that might be required. For complex applications
    that gather data from multiple sites, there may be more than one set of credentials
    added to the handler.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`HTTPBasicAuthHandler`的实例。这个实例包含了可能需要的所有用户名和密码。对于从多个站点收集数据的复杂应用程序，可能需要向处理程序添加多组凭据。
- en: Instead of using `with urllib.request.urlopen(request) as response:` , we would
    now use `with password_opener(request) as response:` . The `Authorization` header
    is added to the request by the `password_opener` object.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`with password_opener(request) as response:`而不是`with urllib.request.urlopen(request)
    as response:`。`password_opener`对象会在请求中添加`Authorization`头。
- en: This alternative has the advantage of being relatively flexible. We can switch
    to using `HTTPDigestAuthHandler` without any difficulties. We can also add additional
    usernames and passwords.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 这种替代方案的优势在于相对灵活。我们可以在不遇到任何困难的情况下切换到使用`HTTPDigestAuthHandler`。我们还可以添加额外的用户名和密码。
- en: The realm information is sometimes confusing. A realm is a container for multiple
    URLs. When a server requires authentication, it will respond with a `401` status
    code. This response will include an `Authenticate` header that names a realm to
    which the credentials must belong. Since the realm contains multiple site URLs,
    the realm information tends to be extremely static. `HTTPBasicAuthHandler` uses
    the realm and URL information to choose which of the usernames and passwords to
    supply in the authorization response.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候领域信息会让人感到困惑。领域是多个URL的容器。当服务器需要身份验证时，它会响应`401`状态码。这个响应将包括一个`Authenticate`头，指定凭据必须属于的领域。由于领域包含多个站点URL，领域信息往往非常静态。`HTTPBasicAuthHandler`使用领域和URL信息来选择在授权响应中提供哪些用户名和密码。
- en: It's often necessary to write a technical spike that attempts a connection,
    and prints the headers on the `401` response just to see what the realm string
    is. Once the realm is known, `HTTPBasicAuthHandler` can be built. An alternative
    is to use the developer modes available in some browsers to examine the headers
    and see the details of the `401` response.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要编写一个技术性的尝试连接的技术性尝试，并打印`401`响应中的头部，以查看领域字符串是什么。一旦领域已知，就可以构建`HTTPBasicAuthHandler`。另一种方法是使用一些浏览器中可用的开发者模式来检查头部并查看`401`响应的详细信息。
- en: See also
  id: totrans-838
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Proper SSL configuration of a server generally involves using certificates signed
    by a CA. This involves a certificate chain that starts with the server and includes
    certificates for the various authorities that issued the certificates.
  id: totrans-839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器的适当SSL配置通常涉及使用由CA签名的证书。这涉及一个以服务器为起点并包括为各种颁发证书的各种机构的证书链。
- en: Many web service implementations use servers such as GUnicorn or NGINX. These
    servers generally handle the HTTP and HTTPS issues outside our application. They
    can also handle complex chains and bundles of certificates.
  id: totrans-840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多Web服务实现使用诸如GUnicorn或NGINX之类的服务器。这些服务器通常在我们的应用程序之外处理HTTP和HTTPS问题。它们还可以处理复杂的证书链和捆绑包。
- en: For details, see [http://docs.gunicorn.org/en/stable/settings.html#ssl](http://docs.gunicorn.org/en/stable/settings.html#ssl)
    and also [http://nginx.org/en/docs/http/configuring_https_servers.html](http://nginx.org/en/docs/http/configuring_https_servers.html)
    .
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关详细信息，请参阅[http://docs.gunicorn.org/en/stable/settings.html#ssl](http://docs.gunicorn.org/en/stable/settings.html#ssl)和[http://nginx.org/en/docs/http/configuring_https_servers.html](http://nginx.org/en/docs/http/configuring_https_servers.html)。
