- en: Using GPIOs as Input
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GPIO作为输入
- en: In the previous chapter, we understood how GPIOs are used for output. But, as
    the name suggests, the GPIO can be used for both input and output purposes. In
    this chapter, we will see how you can go ahead and use these pins to input the
    data over to Raspberry Pi.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了GPIO如何用于输出。但是，正如其名称所示，GPIO既可以用于输入也可以用于输出。在本章中，我们将看到如何使用这些引脚将数据输入到树莓派上。
- en: 'The topics which we will cover in this chapter are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题有：
- en: A deeper dive into GPIOs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解GPIO
- en: Interfacing the PIR sensor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与PIR传感器的接口
- en: Interfacing the ultrasonic proximity sensor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与超声波接近传感器的接口
- en: Interfacing through I2C
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过I2C进行接口
- en: A deeper dive into GPIOs
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解GPIO
- en: 'I am sure you remember this line of code from the previous chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你还记得上一章的这行代码：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As explained earlier, this basically tells us how GPIO the pin will behave
    in a certain program. By now, you must have guessed that by changing this single
    line of code we can change the behavior of the pin and convert it from output
    to input. This is how you would do it:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面解释的，这基本上告诉我们在某个程序中GPIO引脚的行为。到现在为止，你一定已经猜到，通过改变这一行代码，我们可以改变引脚的行为，并将其从输出转换为输入。这就是你会这样做的方式：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you write this line of code in your program, the microcontroller will know
    that during the time that the program is being run, the pin number `18` will only
    be used for input purposes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在程序中写入这行代码，微控制器将知道在程序运行时，引脚号`18`只用于输入目的。
- en: 'To understand how this would actually work, let''s head back to our hardware
    and see how it can be done. Firstly, you need to connect an LED to any of the
    pins; we will be using pin number `23` in this program. Secondly, you need to
    connect a switch on pin number `24`. You can refer the diagram that follows for
    making the connections:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这实际上是如何工作的，让我们回到我们的硬件，看看它是如何完成的。首先，你需要将LED连接到任何一个引脚；在这个程序中，我们将使用引脚号`23`。其次，你需要在引脚号`24`上连接一个开关。你可以参考接下来的图表来进行连接：
- en: '![](Images/d427ad85-89bc-4344-ad6d-be910c696a1a.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d427ad85-89bc-4344-ad6d-be910c696a1a.png)'
- en: 'Once you connect it, you can go ahead and write this program:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接好，你可以继续编写这个程序：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once the program is uploaded, then, as soon as you press the push button, the
    LED will turn itself on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序上传，当你按下按钮时，LED将自行打开。
- en: Let's understand what exactly is happening. `while True:` is basically an infinite
    loop; once you apply this loop, the code running inside it is repeated over and
    over again until something breaks it, and by break I mean some interruption that
    causes the program to stop and exit. Now, ideally we exit the program by pressing
    *Ctrl* + *C* whenever there is an infinite loop.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解到底发生了什么。`while True:`基本上是一个无限循环；一旦应用了这个循环，循环内运行的代码会一遍又一遍地重复，直到有什么东西打破它，而所谓的打破是指导致程序停止并退出的某种中断。现在，理想情况下，我们通过按下*Ctrl*
    + *C*来退出程序，每当有一个无限循环时。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the above line, the program understands where it has to look; in this program.
    In this line we are telling the program that we are looking for GPIO `24`, which
    is an input:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的一行中，程序理解它需要查找的地方；在这个程序中。在这一行中，我们告诉程序我们正在寻找GPIO `24`，这是一个输入：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If the button is high, in other words when the button is pressed and the current
    is reaching the pin number `24`, then the GPIO pin number `23` will be set to
    high:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按钮是高的，换句话说，当按钮被按下并且电流到达引脚号`24`时，那么GPIO引脚号`23`将被设置为高：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the pin number `24` is not true, it will follow this line of code and will
    keep the pin number `23` low, in other words switched off.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引脚号`24`不为真，它将遵循这行代码，并保持引脚号`23`低，换句话说关闭。
- en: So, there it is, your first program for using the GPIOs for input purposes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是你用于输入目的的第一个GPIO程序。
- en: Interfacing the PIR sensor
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与PIR传感器的接口
- en: So far, so good! In this unit, we will go ahead and interface out first sensor,
    which is a passive infrared, commonly known as a PIR sensor. This sensor is a
    very special sensor and is used very commonly in automation projects. Its low
    energy consumption makes it a superb contender for IoT projects as well. So let's
    see how it works.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利！在这个单元中，我们将继续接口我们的第一个传感器，即被动红外传感器，通常称为PIR传感器。这个传感器是一个非常特殊的传感器，在自动化项目中非常常见。它的低能耗使其成为物联网项目的绝佳竞争者。所以让我们看看它是如何工作的。
- en: You must have noticed that when we heat a metal to a high temperature, it slowly
    gets dark red in color, and when we heat it further, it gets brighter and slowly
    goes from red to yellow as depicted in the below diagram which shows a red hot
    steel tab. Now, as the temperature increases, the wavelength of the emitted radiation
    decreases; that is why with the increase in temperature the color changes from
    red to yellow, as yellow has a shorter wavelength compared to red.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定注意到了，当我们将金属加热到高温时，它慢慢变成深红色，当我们进一步加热时，它变得更亮，慢慢从红色变成黄色，如下图所示，显示了一个红热的钢片。现在，随着温度的升高，发射辐射的波长减小；这就是为什么随着温度的升高，颜色从红色变成黄色，因为黄色的波长比红色短。
- en: '![](Images/92c35129-4393-4222-b0cf-ee8a9ae585d9.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/92c35129-4393-4222-b0cf-ee8a9ae585d9.png)'
- en: But the interesting part is that even when the objects are not heated enough,
    they emit radiation; in fact, any object that is above the temperate of absolute
    zero emits some form of radiation. Some we can see with the naked eye, others
    we can't. So, at room temperature, objects emit infrared radiation which has a
    higher wavelength compared to visible light. Hence, we don't see it with our eyes.
    Nonetheless, it is still there.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但有趣的是，即使物体没有被加热到足够的温度，它们也会发射辐射；事实上，任何高于绝对零度温度的物体都会发射某种形式的辐射。有些我们能用肉眼看到，有些我们看不到。因此，在室温下，物体会发射红外辐射，其波长比可见光更长。因此，我们的眼睛看不到它。尽管如此，它仍然存在。
- en: What this PIR sensor does is that it senses the infrared light from the objects
    around it and whenever an object moves, it can sense the overall change in its
    pattern and, based on that, can detect if there is any movement that has happened
    in its proximity.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个PIR传感器的作用是感知周围物体发出的红外光，每当物体移动时，它可以感知其模式的整体变化，并且基于此可以检测到其附近是否发生了任何运动。
- en: 'We assume that whenever there is someone in a room there will be some inherent
    movement that will happen, and hence this sensor is very commonly used as an occupancy
    sensor. Now, let''s connect this sensor and see how we can use it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设当房间里有人时，会有一些固有的运动发生，因此这种传感器非常常用作占用传感器。现在，让我们连接这个传感器，看看我们如何使用它：
- en: '![](Images/c64b669a-44f1-44ba-a145-09adac7bb2d8.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c64b669a-44f1-44ba-a145-09adac7bb2d8.png)'
- en: 'Once you have connected it as per the preceding diagram, go ahead and upload
    the code: :'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您按照上图连接好了，就可以上传代码了：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, let's see what is happening. The logic is very simple. As soon as the PIR
    sensor detects movement, it turns its output pin to high. All we have to do is
    to monitor that pin and that's basically it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看发生了什么。逻辑非常简单。一旦PIR传感器检测到运动，它就会将输出引脚设置为高电平。我们所要做的就是监视该引脚，基本上就是这样。
- en: The logic is entirely similar to that of a push-button switch, and it will also
    work in a similar manner. So not much explaining is needed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与按键开关完全相似，它也会以类似的方式工作。因此，不需要太多解释。
- en: Interfacing the ultrasonic proximity sensor
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口超声波接近传感器
- en: First, the basics. A proximity sensor is a type of sensor that senses the proximity
    of an object from it. There is a universe full of sensors that are available to
    accomplish this task and numerous technologies that allow us to do so. As the
    name says, the ultrasonic proximity sensor works on the principal of ultrasonic
    sound waves. The working principle is quite easy to understand. The ultrasonic
    sensor sends a beam of ultrasonic sound waves; these waves are inaudible to human
    ears, but nonetheless it is still a sound wave and it also behaves like a sound
    wave.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，基础知识。接近传感器是一种传感器，它可以感知到与其接近的物体。有许多传感器可以完成这项任务，以及许多技术可以让我们这样做。正如其名称所示，超声波接近传感器是基于超声波的工作原理。工作原理非常容易理解。超声波传感器发射一束超声波；这些波对人耳来说是听不见的，但它仍然是一种声波，它也像声波一样行为。
- en: Now, as we know, sound bounces off different surfaces and forms an echo. You
    must have experienced this echo when speaking in an empty room. You can hear your
    own sound but with a slight delay. This delay is caused by the property of sound.
    A sound is a wave, hence it has a speed. Sound waves have a set speed of travel.
    So, to cover a specific distance, they take some time. By calculating this time,
    we can derive how far the sound waves are going before getting bounced off from
    a surface.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道声音会反射不同的表面并形成回声。当您在空房间说话时，您一定有过这种回声的经历。您可以听到自己的声音，但有轻微的延迟。这种延迟是由声音的特性引起的。声音是一种波，因此它有速度。声波有固定的传播速度。因此，为了覆盖特定的距离，它们需要一定的时间。通过计算这段时间，我们可以推导出声波在从表面反射之前走过的距离。
- en: Similarly, in this sensor, we shoot ultrasonic sound waves in a specific direction
    and then sense the echo which bounces back. Naturally, there would be a delay
    in receiving the echo; the delay would be directly proportional to the distance
    of the object from the sensor and, based on this delay, we could easily compute
    the distance.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在这种传感器中，我们向特定方向发射超声波，然后感知反射回来的回声。自然地，接收回声会有一定的延迟；这个延迟会与物体距离传感器的距离成正比，基于这个延迟，我们可以轻松计算出距离。
- en: 'Now, to work with the proximity sensor, we need to understand the physical
    architecture of the sensor to wire it correctly. There are four pins in the sensor,
    which are:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要使用接近传感器，我们需要了解传感器的物理结构以正确接线。传感器上有四个引脚，它们是：
- en: VCC (positive)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VCC（正极）
- en: Trigger
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发
- en: Echo
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回声
- en: GND (ground)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GND（地线）
- en: 'I obviously don''t have any need to explain what VCC and ground does. So, let''s
    move on straight to trigger. Whenever the pin is high for 10 microseconds, the
    ultrasonic sensor will send eight cycles of 40 kHz sound waves to the target.
    Once the trigger cycle is completed, the **ECHO** is set to high. Once it receives
    the echo signal back, the **ECHO** pin is set back to low. Here is a diagram to
    show how it actually happens:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 显然我不需要解释VCC和地线的作用。因此，让我们直接转到触发。每当引脚高电平持续10微秒时，超声波传感器将向目标发送8个40kHz的声波周期。一旦触发周期完成，**ECHO**被设置为高电平。一旦接收到回声信号，**ECHO**引脚就会被设置回低电平。以下是一个图表，展示了它实际发生的过程：
- en: '![](Images/6a520177-aaa6-416d-bf7a-a89a47338191.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6a520177-aaa6-416d-bf7a-a89a47338191.png)'
- en: 'That is all we need to know for now. Subsequently, we will learn more as we
    move along. Now, to go ahead and make it live, connect it as per the diagram:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们现在需要知道的全部。随后，随着我们的学习，我们会了解更多。现在，继续并让它运行起来，按照图表连接：
- en: '![](Images/bb00f6f6-880c-4cb0-a37f-139d1a48dc2f.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bb00f6f6-880c-4cb0-a37f-139d1a48dc2f.png)'
- en: 'Once the connection is made, the following is the code that you need to run:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 连接完成后，需要运行以下代码：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, once you run this program, the output on your screen will be showing you
    the distance of the object once in every 0.2 seconds. Now, you must be wondering
    how this is communicating all these readings:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦您运行这个程序，屏幕上的输出将每0.2秒显示一次物体的距离。现在，您一定想知道这是如何传达所有这些读数的：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We are assigning pin `23` to give pulse to **TRIGGER** pin of the sensor when
    required:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分配引脚`23`在需要时给传感器的**TRIGGER**引脚提供脉冲：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are assigning pin `24` to receive the logic to confirm the receipt of the
    echo signal:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分配引脚`24`来接收逻辑以确认接收到回声信号：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will be using the preceding as variables, and every time the loop starts
    we are assigning them a value which is `0`; this is to wipe off the previous reading
    that we would have stored during the course of program:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上述作为变量，并且每次循环开始时，我们都会给它们赋值为`0`；这是为了清除在程序过程中存储的先前读数：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We keep the trigger pin number `23` high for 0.000010 seconds so that the ultrasonic
    sensor can send a brief pulse of ultrasonic waves:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保持触发引脚编号`23`高0.000010秒，以便超声波传感器可以发送一脉冲超声波：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This while statement will keep noting down the time of the `pulse_start` variable
    until the time pin number `24` is low. The final reading of the time will be stored
    in the `pulse_start` variable, as in noting down the time when the pulse was sent:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个while语句将一直记录`pulse_start`变量的时间，直到引脚编号`24`的时间为低电平。最终的时间读数将存储在`pulse_start`变量中，即记录脉冲发送的时间：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `while` statement in this loop will start noting the time when the input
    on pin number `24` is high and it will keep noting the time until the pin number
    `24` remains high. The final reading of the time will be stored in the `pulse_stop`
    variable, as in noting down the time when the pulse is received:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环中的`while`语句将开始记录引脚编号`24`高电平的时间，并将一直记录时间，直到引脚编号`24`保持高电平。时间的最终读数将存储在`pulse_stop`变量中，即记录脉冲接收的时间：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this statement we are calculating the overall time it took for the pulse
    to travel from the sensor to the object and bounce back to the receiver on the
    sensor:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个声明中，我们正在计算脉冲从传感器到物体再反弹到传感器接收器所需的总时间：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is an arithmetic formula given by the manufacturer to convert the time
    duration it took for the ultrasonic waves to travel into the actual distance in
    centimeters. You may ask how did we get to this equation?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是制造商提供的一个算术公式，用于将超声波传播所需的时间转换为厘米的实际距离。你可能会问我们是如何得到这个方程的？
- en: 'Let me give you a brief about it. With elementary physics we would remember
    this simple equation: *Speed* = *Distance* / *Time*.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我简要介绍一下。通过初等物理，我们会记得这个简单的方程：*速度* = *距离* / *时间*。
- en: Now you may also recall that the speed of sound is 343 meters per second. Now
    1 meter has 100 centimeters hence to convert this speed into centimeters per second,
    we would have to multiply the speed by 100, hence the speed would be 34,300 centimeters
    per second.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能还记得声音的速度是343米每秒。现在1米有100厘米，因此要将这个速度转换为每秒厘米，我们必须将速度乘以100，因此速度将是每秒34,300厘米。
- en: 'Now we know one element of the equation which is the speed. So lets put the
    value of speed into the equation. Now the equation would look something like this:
    *34,300* = *Distance* / *Time*.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道方程的一个元素，即速度。所以让我们把速度的值放入方程中。现在方程看起来会是这样：*34,300* = *距离* / *时间*。
- en: 'Now we know one thing that the distance which the sound is travelling is twice
    the actual distance. How ? Because the sound first goes from the sensor to the
    object. Then it bounces off that surface and reaches back to the sensor. So essentially
    it is covering twice the distance. Hence we to adapt this equation we have to
    make a small change: *34,300* / *2* = *Distance* / *Time*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道声音传播的距离是实际距离的两倍。为什么？因为声音首先从传感器传向物体。然后它从表面反射回来并到达传感器。因此，它实质上覆盖了两倍的距离。因此，为了适应这个方程，我们必须做出一个小改变：*34,300*
    / *2* = *距离* / *时间*
- en: 'Now what we want out of this equation is distance So lets take all other part
    to the other side. Now the formula would look something like this: *17,150* *
    *Time* = *Distance*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想从这个方程中得到距离，所以让我们把所有其他部分移到另一边。现在方程看起来会是这样：*17,150* * *时间* = *距离*
- en: So here we have it the formula for the distance.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这里有距离的公式。
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As the distance the ultrasonic waves have traveled is twice the actual distance
    (once for going towards the object and second for bouncing back to the sensor),
    we divide it by half to get the actual distance:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于超声波传播的距离是实际距离的两倍（一次是朝物体前进，第二次是反弹到传感器），我们将其除以二得到实际距离：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we will print the measured distance via the following statement. Anything
    that is in the quotation marks `''...''` will be written the way it has been written.
    However, `distance` is written without quotation marks, and distance is a variable.
    Hence, the variable stored in the distance will be written in the final output
    on the screen:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过以下声明打印测得的距离。任何在引号内的内容`'...'`都将按原样写入。但是，`distance`没有引号，distance是一个变量。因此，存储在距离中的变量将在屏幕上的最终输出中写入：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The code will pause on this line for a time of 0.2 seconds. If we did not have
    this pause, then the values would come out at an incredible speed which would
    be hard for us to read or understand. If you are tinkering around, I would recommend
    removing this statement and running the code to see what happens.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将在这一行暂停0.2秒。如果没有这个暂停，那么值将以令人难以理解的速度出现，这对我们来说将很难阅读或理解。如果你在摆弄，我建议删除这个声明并运行代码看看会发生什么。
- en: Interfacing through I2C
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过I2C进行接口
- en: So far, so good. Electronic circuits can be very interesting and, while they
    seem very complex, often we find that the working can be very simple. In the previous
    section, we interfaced one sensor at a time. We can go ahead and interface multiple
    sensors, but we are limited by the number of GPIOs that are present. We have also
    seen that some sensors such as ultrasonic sensors may use more than one GPIO pin
    for their working. This further reduces the number of sensors that we can interface
    with the microcontroller. Once we move on to more complex circuits, we will also
    realize that the wiring can be really messy and if a problem occurs then finding
    what's wrong becomes one tedious task.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好。电子电路可能非常有趣，虽然它们看起来非常复杂，但我们经常发现工作非常简单。在前一节中，我们一次只接口一个传感器。我们可以继续接口多个传感器，但我们受到现有GPIO数量的限制。我们还看到一些传感器，如超声波传感器可能使用多个GPIO引脚进行工作。这进一步减少了我们可以与微控制器接口的传感器数量。一旦我们转向更复杂的电路，我们还会意识到布线可能会变得非常混乱，如果出现问题，找出问题所在将变得非常繁琐。
- en: 'Now, there is an even bigger problem that we face while designing robotic systems
    and that''s the problem of timing—all the work done in a system has to be synchronized.
    Most of the systems are currently sequential in nature, as in the output of one
    unit becomes the input of another:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在设计机器人系统时面临的一个更大的问题是时间的问题——系统中的所有工作都必顶同步。目前大多数系统都是顺序的，即一个单元的输出成为另一个单元的输入：
- en: '![](Images/5a879310-c166-4e61-abad-0342052b4c5b.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5a879310-c166-4e61-abad-0342052b4c5b.png)'
- en: Now, for the task to be completed, the **PROCESSING UNIT 1** has to deliver
    the input to **PROCESSING UNIT 2** when needed, and the same goes for **PROCESSING
    UNIT 3**. If the data is not timed perfectly, then either the **PROCESSING UNIT
    2** will keep waiting for the input from **PROCESSING UNIT 1** or, even worse,
    the **PROCESSING UNIT 1** will send the data to **PROCESSING UNIT 2** at a time
    when it does not need it. In which case, the data will get lost and the process
    will have some errors.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了完成任务，当需要时，**处理单元1**必须将输入传递给**处理单元2**，**处理单元3**也是如此。如果数据的时间不完美，那么**处理单元2**要么会一直等待**处理单元1**的输入，要么更糟糕的是，**处理单元1**会在**处理单元2**不需要数据的时候发送数据。在这种情况下，数据将丢失，过程将出现一些错误。
- en: 'Hence, to solve this problem, the computer scientists back in the day invented
    a system of pulsing. The clock pulse is a very simple square wave which has a
    50% duty cycle (recollect **pulse width modulation** (**PWM**)). The circuits
    are designed to do one operation at either the rising or the falling edge of the
    clock pulse. Due to this synchronization, every part of the circuit knows when
    to work. Here is what the clock pulse looks like:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了解决这个问题，当时的计算机科学家发明了一种脉冲系统。时钟脉冲是一个非常简单的方波，具有50%的占空比（回想一下脉冲宽度调制（PWM））。电路被设计为在时钟脉冲的上升沿或下降沿执行一次操作。由于这种同步，电路的每个部分都知道何时工作。时钟脉冲的样子如下：
- en: '![](Images/f64ababd-856f-4586-98d6-47e74b222ce7.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f64ababd-856f-4586-98d6-47e74b222ce7.png)'
- en: 'Now, coming back to the point, we have two problems:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到问题上，我们有两个问题：
- en: There is a physical limit to how many devices/sensors can be connected to the
    robot
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器人连接的设备/传感器存在物理限制
- en: How to time the sensors and interconnected circuits to work in harmony
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使传感器和互连电路的时间协调工作
- en: 'To solve these problems, we use a very commonly used protocol called **I2C**,
    which stands for **Inter-integrated Circuits**. This protocol is extremely useful
    when we need to connect multiple devices on the same set of GPIOs, such as when
    we have only one set of GPIO pins over which multiple sensors can be linked. This
    is made possible due to unique addresses allocated to each hardware. This address
    is used to identify a sensor and then to communicate with it accordingly. Now,
    to implement the I2C protocol we need two lines; these lines are as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，我们使用了一个非常常用的协议，称为I2C，代表着互联集成电路。当我们需要在相同的GPIO上连接多个设备时，比如只有一组GPIO引脚可以连接多个传感器时，这个协议非常有用。这是由于为每个硬件分配了唯一的地址。该地址用于识别传感器，然后相应地与其通信。现在，要实现I2C协议，我们需要两条线路；这些线路如下：
- en: Data
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据
- en: Clock
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时钟
- en: As you may have guessed, the clock line is used to send a clock pulse to the
    devices attached to it and the data is the bus over which the data flows to and
    fro.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的那样，时钟线用于向连接的设备发送时钟脉冲，数据是数据流动的总线。
- en: Now, the entire I2C architecture works on a master-slave configuration, wherein
    the master generates the clock signal all the time for the slave devices and the
    slave devices have to constantly look for the clock pulse and the data packets
    sent by the master devices. Let's see how it's done.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，整个I2C架构是基于主从配置工作的，其中主设备始终为从设备生成时钟信号，从设备必须不断寻找主设备发送的时钟脉冲和数据包。让我们看看是如何完成的。
- en: 'As mentioned earlier, there are two lines: the data line, which is referred
    to as **Serial Data** (**SDA**), and the clock line, which is referred to as **Serial
    Clock** (**SCL**). From now on, we will be using the terms SCL and SDA:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有两条线路：数据线称为串行数据（SDA），时钟线称为串行时钟（SCL）。从现在开始，我们将使用SCL和SDA这些术语：
- en: '![](Images/4fc1c316-1172-4c9d-a435-6c062a673bf1.png)Lets look at the main pointers
    shown in the diagram:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/4fc1c316-1172-4c9d-a435-6c062a673bf1.png)让我们看看图中显示的主要要点：'
- en: '**Start condition**: To start a communication, a start condition is created
    indicating that the communication is about to happen. This condition is depicted
    by the master by keeping the SDA line low before the SCL. This indicates all the
    slave devices are ready for communication.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**起始条件**：为了开始通信，创建一个起始条件，表示通信即将发生。主设备通过在SCL之前保持SDA线低来表示这个条件。这表示所有从设备都准备好进行通信。'
- en: '**Address frame**: Once the communication is started the master sends the address
    of the device that needs to be communicated with. This is a 7-bit address. In
    every clock pulse, a bit is sent, hence it takes seven clock pulses to send the
    7-bit address. After that 7-bit address is a read/write bit. This indicates to
    the device whether the master would like to write in this operation or if it wants
    to read some data. Hence, the total address frame is of 8 bits, which takes eight
    clock pulses to be sent. After these eight pulses, during the ninth clock pulse,
    the master waits for the acknowledgement from the device. This acknowledgement
    is sent by the slave device when the SDA line is pulled low by the slave device
    which is being addressed. With this strategy, the master knows that the address
    sent by it has been received and the slave device is now ready for the communication.
    If the acknowledgement is not sent back, then it is up to the master what has
    to be done.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**地址帧**：一旦通信开始，主设备发送需要通信的设备的地址。这是一个7位地址。在每个时钟脉冲中，一个位被发送，因此需要七个时钟脉冲来发送7位地址。在这7位地址之后是读/写位。这表明设备是否在这个操作中想要写入，还是想要读取一些数据。因此，总地址帧是8位，需要八个时钟脉冲来发送。在这八个脉冲之后，在第九个时钟脉冲期间，主设备等待来自设备的确认。当SDA线被被寻址的从设备拉低时，从设备发送这个确认。通过这种策略，主设备知道它发送的地址已经被接收，并且从设备现在准备好进行通信。如果没有发送确认，那么由主设备决定接下来该做什么。'
- en: '**Data frame**: Once the acknowledgement is sent, depending on if it is a read
    or write operation, the data is either written by the master onto the slave or,
    in read operation, the data is sent by the slave over to the master. The length
    of this data frame can be arbitrary.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据帧**：一旦确认被发送，根据是读操作还是写操作，数据要么由主设备写入从设备，要么在读操作中，数据由从设备发送到主设备。这个数据帧的长度可以是任意的。'
- en: '**Stop frame**: Once the data transfer is completed, the stop condition is
    made by the master to indicate that the communication has to stop. This condition
    is done when the SDA line goes from low to high after the SCL line goes from low
    to high.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止帧**：一旦数据传输完成，主设备发出停止条件，表示通信必须停止。当SDA线在SCL线从低电平变为高电平后，此条件被执行。'
- en: So this is basically how I2C communication works. For every device we have a
    7-bit address, hence we can connect up to 128 devices on a single bus. That's
    a lot of devices. The chances of running out of physical limits is almost negligible.
    Now let's go ahead and see how we can connect the sensors via this protocol. Generally,
    it is not required to do the core programming for the I2C, as it is lengthy and
    cumbersome. That's where the magic of open source comes in. There are a lot of
    developers across the globe who are working on these sensors and most of them
    are generous enough to make a library and share it for ease of programming. These
    libraries are available online and most of them take care of the complex process
    of communication.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是I2C通信的工作原理。对于每个设备，我们有一个7位地址，因此我们可以在单个总线上连接多达128个设备。这是很多设备。几乎可以忽略物理限制用完的可能性。现在让我们继续看看如何通过这种协议连接传感器。通常，不需要为I2C进行核心编程，因为这很冗长和繁琐。这就是开源的魔力所在。全球有很多开发人员正在研究这些传感器，其中大多数人足够慷慨，制作了一个库并分享给大家以便编程。这些库可以在线获取，其中大多数库都处理了通信的复杂过程。
- en: Now is the time that we interface our first I2C device, which is an analogue
    to digital converter. You must be wondering why we use this converter in the first
    place. Recall the time when we started understanding GPIO pins. These magic pins
    can be used both as input and output; you may also remember that these pins can
    either be on or off—these are all digital pins, not only when it comes to output
    but also for input. But there are a huge amount of sensors that work over analogue
    communication. Due to the digital architecture of Raspberry Pi, it is difficult
    to interface these sensors directly. Hence, we use an **analogue to digital converter**
    (**ADC**), this converter converts the analogue value of the sensors to the digital
    bits that are understandable by Raspberry Pi.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们接口第一个I2C设备的时候了，这是一个模拟到数字转换器。你一定会想为什么我们首先使用这个转换器。回想一下我们开始理解GPIO引脚的时候。这些神奇的引脚可以用作输入和输出；你可能还记得这些引脚可以是开或关状态——这些都是数字引脚，不仅在输出时，也在输入时。但是有大量的传感器是通过模拟通信工作的。由于树莓派的数字架构，直接接口这些传感器是困难的。因此，我们使用**模拟到数字转换器**（**ADC**），这个转换器将传感器的模拟值转换为树莓派可以理解的数字位。
- en: We will be connecting an LDR, the resistor will change the value of resistance
    based on how much light is falling onto it. Hence, the voltage will be dependent
    upon how much light is falling over the LDR.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将连接一个LDR，电阻将根据光线的多少改变电阻值。因此，电压将取决于光线照射在LDR上的多少。
- en: 'Now let''s see how it is practically done. Take up your Pi and let''s get going.
    To start, firstly we need to enable I2C on our Raspberry Pi; follow the steps
    listed here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何实际操作。拿起你的树莓派，让我们开始吧。首先，我们需要在树莓派上启用I2C；按照这里列出的步骤进行操作：
- en: Open the terminal (*Ctrl* + *Shift* + *T*)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端（*Ctrl* + *Shift* + *T*）
- en: Type `sudo raspi-config`
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`sudo raspi-config`
- en: 'Select the interfacing options:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择接口选项：
- en: '![](Images/c42f873e-fc46-4598-b399-6153ec9543d3.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c42f873e-fc46-4598-b399-6153ec9543d3.png)'
- en: 'Then go to Advanced Options:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后转到高级选项：
- en: '![](Images/72d2ad53-f4e4-44a9-8efc-e866f072c910.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/72d2ad53-f4e4-44a9-8efc-e866f072c910.png)'
- en: 'Then select I2C to enable it. Then select Yes:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后选择I2C以启用它。然后选择是：
- en: '![](Images/674dfc12-0f37-469c-958a-06bd15727f78.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/674dfc12-0f37-469c-958a-06bd15727f78.png)'
- en: 'Now install the `adafruit` library to interface the ADC1115:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在安装`adafruit`库以接口ADC1115：
- en: 'Open the terminal and copy the following command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并复制以下命令：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command downloads the libraries and the dependencies over to Raspberry
    Pi
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将库和依赖项下载到树莓派上
- en: 'Now type the following:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在输入以下内容：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This command installs the libraries and the dependencies over to Raspberry Pi.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将库和依赖项安装到树莓派上。
- en: 'Now that the software is set up, let''s get the hardware ready. Connect Raspberry
    Pi to the ADS1115 as shown in the following diagram:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在软件已经设置好了，让我们准备好硬件。按照下图将树莓派连接到ADS1115：
- en: '![](Images/4444a5ef-efce-4a02-b51d-7d9c20970323.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4444a5ef-efce-4a02-b51d-7d9c20970323.png)'
- en: 'Once you are ready, go ahead and upload this code in Pi:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好后，继续在Pi上上传这段代码：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that there can be times when this code may not work, in which case try
    tweaking the value of threshold:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有时这段代码可能不起作用，如果是这样，请尝试调整阈值的值：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What you might have noticed is that whenever the LDR is faced towards a light
    source, the LED also switches on, and whenever it is away from light, the LED
    switches off.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，每当LDR面向光源时，LED也会亮起，而当它远离光线时，LED会熄灭。
- en: 'So now you have interfaced an I2C device. Let''s understand how this code is
    actually working:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经接口了一个I2C设备。让我们了解这段代码实际上是如何工作的：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding line of code imports the `Adafruit_ADS1x15` library in the code
    so that we can use all its functions during the program.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码导入了`Adafruit_ADS1x15`库，以便我们在程序中使用它的所有函数。
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding line of code creates the instance of the library `Adafruit_ADS1x115`.
    The line `.ADS1115()` is the function for creating the instance as `adc`. Understood
    anything? Let me put it in English.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码创建了库`Adafruit_ADS1x115`的实例。`.ADS1115()`是创建实例`adc`的函数。明白了吗？让我用英语解释一下。
- en: 'Now, instead of writing `Adafruit_ADS1x15` all the time, we can simply write
    `adc` to call the library functions. Further, you can use any word instead of
    `adc`; it can be your cat''s name or your neighbor''s name, and it would still
    work:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以简单地写`adc`而不是一直写`Adafruit_ADS1x15`，来调用库函数。此外，你可以使用任何单词代替`adc`；它可以是你猫的名字或你邻居的名字，它仍然可以工作：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the value to which the sensing would be done. `1` depicts that the sensing
    would happen in full range. Which for our ADC is from a voltage range of 0V to
    +/-4.096V.  Now changing the gain would result in change of the sensing range.
    I.e. if we change the value of gain to `2` Then the Range in which the sensing
    would happen would be Half of the original range i.w. 0 to +/- 2.048 Volts.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是传感将进行的值。`1`表示传感将在整个范围内进行。对于我们的ADC来说，范围是从0V到+/-4.096V的电压范围。现在改变增益会导致传感范围的改变。也就是说，如果我们将增益值更改为`2`，那么传感范围将是原始范围的一半，即0到+/-2.048伏。
- en: Now you must be asking what is the voltage range and why are we changing the
    gain ?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会问电压范围是多少，为什么我们要改变增益？
- en: 'The reason is simple. There are different types of analog sensors. Which give
    output in a wide variety of voltage range. Some sensors can give you output in
    the range of 0.5 volt to 4 volt others can give you from 0.1 volt to 0.98 volts.
    Now if we set the gain to `1` then the all of these sensors could be easily interfaced.
    As all of them fall in between the sensing range of 0 to 4.098 Volts. However
    as it is a 16 bit ADC hence the total number of discrete values that the ADC can
    provide would be in between 2^(16) or 65,536 readings. Hence at the gain of `1`
    the minimum voltage change that the ADC could detect would be: *4.096 */ *65536*
    = *0.000062*.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 原因很简单。有不同类型的模拟传感器。它们的输出电压范围各不相同。有些传感器的输出范围是0.5伏到4伏，其他的可以是0.1伏到0.98伏。现在，如果我们将增益设置为`1`，那么所有这些传感器都可以轻松接口。因为它们都在0到4.098伏的感应范围内。然而，由于它是一个16位ADC，因此ADC可以提供的离散值的总数将在2^(16)或65,536个读数之间。因此，在增益为`1`时，ADC可以检测到的最小电压变化为：*4.096*
    / *65536* = *0.000062*。
- en: 'But if increase the gain to `4` then the sensing range would reduce to a mere
    `0` to +/- 1.0245\. So this would be able to work with the output range between
    0.1 volt to 0.98 volt. But now lets see the minimum voltage change that it could
    detect: *1.0245* / *65536* = *0.00001563*.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果增益增加到`4`，那么传感范围将减少到仅为`0`到+/-1.0245。因此，这将能够处理0.1伏到0.98伏之间的输出范围。但现在让我们看看它可以检测到的最小电压变化：*1.0245*
    / *65536* = *0.00001563*。
- en: Now as you can see the minimum voltage that can be detected is very low. Which
    is a good thing for the compatibility with sensor.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到可以检测到的最小电压非常低。这对于与传感器的兼容性是一件好事。
- en: 'Now, it is up to you as to what gain value you want. The LDR is working on
    5V, hence it is better for us to use the entire gain reading of `1`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以决定你想要什么增益值。LDR在5V上工作，因此最好使用整个增益读数为`1`：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When you look closely at the ADC hardware, you will notice that there are various
    pins including **A0**, **A1**, **A2**, and **A4** This is a four-channel ADC—it
    can convert four analogue inputs and convert them into digital data. As we are
    only using one single data stream, we will be letting Pi know which pin it is
    connected on. With the following line, we are telling Pi to start the process
    of converting the data:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你仔细观察ADC硬件时，你会注意到有各种引脚，包括**A0**、**A1**、**A2**和**A4**。这是一个四通道ADC——它可以将四个模拟输入转换为数字数据。由于我们只使用一个数据流，我们将让Pi知道它连接在哪个引脚上。通过下面的代码，我们告诉Pi开始转换数据的过程：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the following line, we are instructing the ADC to stop the conversion, and
    that's where the code ends.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行中，我们指示ADC停止转换，代码到此结束。
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was all about interfacing sensors with GPIOs so that the data can
    be retrieved by sensors.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讲述了如何将传感器与GPIO进行接口，以便传感器可以检索数据。
