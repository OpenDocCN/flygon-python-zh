["```py\n    def load_config_file(config_file): \n        '''Loads a configuration mapping object with contents \n        of a given file. \n\n        :param config_file: File-like object that can be read. \n        :returns: mapping with configuration parameter values \n        ''' \n        # Details omitted. \n\n```", "```py\n            from pathlib import Path \n            from collections import ChainMap\n\n    ```", "```py\n            def get_config():\n\n    ```", "```py\n            system_path = Path('/etc/profile') \n            home_path = Path('~').expanduser() \n            local_paths = [home_path/'.bash_profile', \n                home_path/'.bash_login', \n                home_path/'.profile'] \n\n    ```", "```py\n            configuration_items = [ \n                dict( \n                    some_setting = 'Default Value', \n                    another_setting = 'Another Default', \n                    some_option = 'Built-In Choice', \n                ) \n            ] \n\n    ```", "```py\n            if system_path.exists(): \n                with system_path.open() as config_file: \n                    configuration_items.append(config_file) \n\n    ```", "```py\n            for config_path in local_paths:\n                if config_path.exists(): \n                    with config_path.open() as config_file: \n                        configuration_items.append(config_file) \n                    break\n\n    ```", "```py\n            configuration = ChainMap(*reversed(configuration_items)) \n\n    ```", "```py\n            return configuration\n\n    ```", "```py\n **>>> from collections import ChainMap \n>>> config = ChainMap( \n...     {'another_setting': 2}, \n...     {'some_setting': 1}, \n...     {'some_setting': 'Default Value', \n...      'another_setting': 'Another Default', \n...      'some_option': 'Built-In Choice'})** \n\n```", "```py\n **>>> config['another_setting'] \n2 \n>>> config['some_setting'] \n1 \n>>> config['some_option'] \n'Built-In Choice'** \n\n```", "```py\n    import unittest \n    from unittest.mock import * \n\n    class GIVEN_get_config_WHEN_load_THEN_overrides(unittest.TestCase): \n        def setUp(self): \n\n        def runTest(self): \n\n```", "```py\n            self.mock_path = Mock( \n                side_effect = [self.mock_system_path, self.mock_home_path] \n            ) \n\n    ```", "```py\n            self.mock_path = Mock( \n                side_effect = [self.mock_system_path, self.mock_home_path] \n            ) \n\n    ```", "```py\n            self.mock_home_path = Mock( \n                expanduser = Mock( \n                    return_value = self.mock_expanded_home_path \n                ) \n            ) \n\n    ```", "```py\n            self.mock_expanded_home_path = MagicMock( \n                __truediv__ = Mock( \n                    side_effect = [self.not_exist, self.exist, self.exist] \n                ) \n            ) \n\n    ```", "```py\n                    self.not_exist = Mock( \n                        exists = Mock(return_value=False) )\n        ```", "```py\n                    self.exist = Mock( exists = Mock(return_value=True), open = mock_open() ) \n\n        ```", "```py\n    def setUp(self): \n        self.mock_system_path = Mock( \n            exists = Mock(return_value=True), \n            open = mock_open() \n        ) \n        self.exist = Mock( \n            exists = Mock(return_value=True), \n            open = mock_open() \n        ) \n        self.not_exist = Mock( \n            exists = Mock(return_value=False) \n        ) \n        self.mock_expanded_home_path = MagicMock( \n            __truediv__ = Mock( \n                side_effect = [self.not_exist, self.exist, self.exist] \n            ) \n        ) \n        self.mock_home_path = Mock( \n            expanduser = Mock( \n                return_value = self.mock_expanded_home_path \n            ) \n        ) \n        self.mock_path = Mock( \n            side_effect = [self.mock_system_path, self.mock_home_path] \n        ) \n\n        self.mock_load = Mock( \n            side_effect = [{'some_setting': 1}, {'another_setting': 2}] \n        ) \n\n```", "```py\n    def runTest(self): \n        with patch('__main__.Path', self.mock_path), \\ \n        patch('__main__.load_config_file', self.mock_load): \n            config = get_config() \n        # print(config) \n        self.assertEqual(2, config['another_setting']) \n        self.assertEqual(1, config['some_setting']) \n        self.assertEqual('Built-In Choice', config['some_option']) \n\n```", "```py\n    self.mock_load.assert_has_calls( \n        [\n            call(self.mock_system_path.open.return_value.__enter__.return_value), \n            call(self.exist.open.return_value.__enter__.return_value) \n        ] \n    ) \n\n```", "```py\n    self.mock_expanded_home_path.assert_has_calls( \n        [call.__truediv__('.bash_profile'), \n        call.__truediv__('.bash_login'), \n        call.__truediv__('.profile')] \n    ) \n\n```", "```py\n    self.mock_path.assert_has_calls( \n        [call('/etc/profile'), call('~')] \n    ) \n\n```", "```py\n    self.exist.assert_has_calls( [call.exists()] ) \n\n```", "```py\n    self.exist.open.assert_has_calls( \n        [call(), call().__enter__(), call().__exit__(None, None, None)] \n    )\n\n```", "```py\n **MacBookPro-SLott:pyweb slott$ pip3.5 install pyyaml** \n\n **Collecting pyyaml** \n\n **Downloading PyYAML-3.11.zip (371kB)** \n\n **100% |\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 378kB 2.5MB/s** \n\n **Installing collected packages: pyyaml \n  Running setup.py install for pyyaml ... done \nSuccessfully installed pyyaml-3.11** \n\n```", "```py\n **query: \n  mz: \n    - ANZ532 \n    - AMZ117 \n    - AMZ080 \nurl: \n  scheme: http \n  netloc: forecast.weather.gov \n  path: /shmrn.php \ndescription: > \n  Weather forecast for Offshore including the Bahamas** \n\n```", "```py\n **{'description': 'Weather forecast for Offshore including the Bahamas\\n', \n 'query': {'mz': ['ANZ532', 'AMZ117', 'AMZ080']}, \n 'url': {'netloc': 'forecast.weather.gov', \n         'path': 'shmrn.php', \n         'scheme': 'http'}}** \n\n```", "```py\n    def load_config_file(config_file) -> dict: \n        '''Loads a configuration mapping object with contents \n        of a given file. \n\n        :param config_file: File-like object that can be read. \n        :returns: mapping with configuration parameter values \n        ''' \n        # Details omitted. \n\n```", "```py\n            import yaml \n\n    ```", "```py\n            def load_config_file(config_file) -> dict: \n                '''Loads a configuration mapping object with contents \n                of a given file. \n\n                :param config_file: File-like object that can be read. \n                :returns: mapping with configuration parameter values \n                ''' \n                document = yaml.load(config_file) \n            return document \n\n    ```", "```py\n     **zoneid: \n            - ANZ532 \n            - AMZ117 \n            - AMZ080** \n\n    ```", "```py\n     **url: \n            scheme: http \n            netloc: marine.weather.gov** \n\n    ```", "```py\n **? scheme \n: http \n? netloc \n: marine.weather.gov** \n\n```", "```py\n     **>>> import yaml \n          >>> yaml_text = ''' \n          ... --- \n          ... id: 1 \n          ... text: \"Some Words.\" \n          ... --- \n          ... id: 2 \n          ... text: \"Different Words.\" \n          ... ''' \n          >>> document_iterator = iter(yaml.load_all(yaml_text)) \n          >>> document_1 = next(document_iterator) \n          >>> document_1['id'] \n          1 \n          >>> document_2 = next(document_iterator) \n          >>> document_2['text'] \n          'Different Words.'** \n\n    ```", "```py\n     **>>> yaml.load(''' \n          ... ? !!python/tuple [\"a\", \"b\"] \n          ... : \"value\" \n          ... ''') \n          {('a', 'b'): 'value'}** \n\n    ```", "```py\n     **>>> import yaml \n          >>> yaml_text = ''' \n          ... document: \n          ...     id: 3 \n          ...     data_values: \n          ...       !!set \n          ...       ? some \n          ...       ? more \n          ...       ? words \n          ... ''' \n          >>> some_document = yaml.load(yaml_text) \n          >>> some_document['document']['id'] \n          3 \n          >>> some_document['document']['data_values'] == {'some', 'more', 'words'} \n          True** \n\n    ```", "```py\n     **>>> import yaml \n          >>> yaml_text = ''' \n          ... !!omap \n          ... - key1: string value \n          ... - numerator: 355 \n          ... - denominator: 113 \n          ... ''' \n          >>> yaml.load(yaml_text) \n          [('key1', 'string value'), ('numerator', 355), ('denominator', 113)]** \n\n    ```", "```py\n            !!python/object/apply:collections.OrderedDict \n            args: \n                -   !!omap \n                    -   key1: string value \n                    -   numerator: 355 \n                    -   denominator: 113 \n\n    ```", "```py\n            class Card: \n                def __init__(self, rank, suit): \n                    self.rank = rank \n                    self.suit = suit \n                def __repr__(self): \n                    return \"{rank} {suit}\".format_map(vars(self)) \n\n    ```", "```py\n            !!python/object/apply:__main__.Card \n            kwds: \n                rank: 7 \n                suit: \u2663\n\n    ```", "```py\n    '''Weather forecast for Offshore including the Bahamas \n    ''' \n    query = {'mz': ['ANZ532', 'AMZ117', 'AMZ080']} \n    url = { \n      'scheme': 'http', \n      'netloc': 'forecast.weather.gov', \n      'path': '/shmrn.php' \n    } \n\n```", "```py\n    def load_config_file(config_file) -> dict: \n        '''Loads a configuration mapping object with contents \n        of a given file. \n\n        :param config_file: File-like object that can be read. \n        :returns: mapping with configuration parameter values \n        ''' \n        # Details omitted. \n\n```", "```py\n            code = compile(config_file.read(), config_file.name, 'exec') \n\n    ```", "```py\n            locals = {} \n            exec(code, {'__builtins__':__builtins__}, locals) \n            return locals \n\n    ```", "```py\n    import platform \n    if platform.system() == 'Windows': \n        tmp = Path(r\"C:\\TEMP\") \n    else: \n        tmp = Path(\"/tmp\") \n\n```", "```py\n    base = Path('/var/app/') \n    log = base/'log' \n    out = base/'out' \n\n```", "```py\n    from pathlib import Path  \n    import platform \n    def load_config_file_path(config_file) -> dict: \n        code = compile(config_file.read(), config_file.name, 'exec') \n        globals = {'__builtins__': __builtins__, \n            'Path': Path, 'platform': platform} \n        locals = {} \n        exec(code, globals, locals) \n        return locals \n\n```", "```py\n    class Configuration: \n        \"\"\" \n        Weather forecast for Offshore including the Bahamas \n        \"\"\" \n        query = {'mz': ['ANZ532', 'AMZ117', 'AMZ080']} \n        url = { \n          'scheme': 'http', \n          'netloc': 'forecast.weather.gov', \n          'path': '/shmrn.php' \n        } \n\n```", "```py\n    from settings import Configuration \n\n```", "```py\n    def load_config_file(config_file) -> dict: \n        '''Loads a configuration mapping object with contents \n        of a given file. \n\n        :param config_file: File-like object that can be read. \n        :returns: mapping with configuration parameter values \n        ''' \n        # Details omitted. \n\n```", "```py\n            code = compile(config_file.read(), config_file.name, 'exec') \n\n    ```", "```py\n            globals = {'__builtins__':__builtins__, \n                       'Path': Path, \n                       'platform': platform} \n            locals = {} \n            exec(code, globals, locals) \n            return locals['Configuration'] \n\n    ```", "```py\n    class Configuration: \n        \"\"\" \n        Generic Configuration \n        \"\"\" \n        url = { \n          'scheme': 'http', \n          'netloc': 'forecast.weather.gov', \n          'path': '/shmrn.php' \n        } \n\n    class Bahamas(Configuration): \n        \"\"\" \n        Weather forecast for Offshore including the Bahamas \n        \"\"\" \n        query = {'mz': ['AMZ117', 'AMZ080']} \n\n    class Cheaspeake(Configuration): \n        \"\"\" \n        Weather for Cheaspeake Bay \n        \"\"\" \n        query = {'mz': ['ANZ532']} \n\n```", "```py\n **python3 some_app.py -c settings.Chesapeake** \n\n```", "```py\n    import importlib \n    def load_config_module(name): \n        module_name, _, class_name = name.rpartition('.') \n        settings_module = importlib.import_module(module_name) \n        return vars(settings_module)[class_name] \n\n```", "```py\n **>>> configuration = load_config_module('settings.Chesapeake') \n>>> configuration.__doc__.strip() \n'Weather for Cheaspeake Bay' \n>>> configuration.query \n{'mz': ['ANZ532']} \n>>> configuration.url['netloc'] \n'forecast.weather.gov'** \n\n```", "```py\n **>>> print(configuration) \n<class 'settings.Chesapeake'>** \n\n```", "```py\n **>>> pprint(vars(configuration)) \nmappingproxy({'__doc__': '\\\\n    Weather for Cheaspeake Bay\\\\n    ', \n              '__module__': 'settings', \n              'query': {'mz': ['ANZ532']}})** \n\n```", "```py\n    class ConfigMetaclass(type): \n        def __repr__(self): \n            name = (super().__name__ + '('  \n                + ', '.join(b.__name__ for b in super().__bases__) + ')') \n            base_values = {n:v \n                for base in reversed(super().__mro__) \n                    for n, v in vars(base).items() \n                        if not n.startswith('_')} \n            values_text = ['    {0} = {1!r}'.format(name, value)  \n                for name, value in base_values.items()] \n            return '\\n'.join([\"class {}:\".format(name)] + values_text) \n\n```", "```py\n    class Configuration(metaclass=ConfigMetaclass): \n        unchanged = 'default' \n        override = 'default' \n        feature_override = 'default' \n        feature = 'default' \n\n    class Customized(Configuration): \n        override = 'customized' \n        feature_override = 'customized' \n\n```", "```py\n            def write_rolls(output_path, roll_iterator): \n                face_count = Counter() \n                with output_path.open('w') as output_file: \n                    for roll in roll_iterator: \n                        output_file.write( \n                            yaml.dump( \n                                roll, \n                                default_flow_style=True, \n                                explicit_start=True)) \n                        for dice in roll: \n                            face_count[sum(dice)] += 1 \n                return face_count \n\n    ```", "```py\n            def summarize(configuration, counts): \n                print(configuration) \n                print(counts) \n\n    ```", "```py\n            def roll_iter(total_games, seed=None): \n                random.seed(seed) \n                for i in range(total_games): \n                    sequence = craps_game() \n                    yield sequence \n\n    ```", "```py\n            def get_options(argv): \n                parser = argparse.ArgumentParser() \n                parser.add_argument('-s', '--samples', type=int) \n                parser.add_argument('-o', '--output') \n                options = parser.parse_args(argv) \n\n                options.output_path = Path(options.output) \n\n                if \"RANDOMSEED\" in os.environ: \n                    seed_text = os.environ[\"RANDOMSEED\"] \n                    try: \n                        options.seed = int(seed_text) \n                    except ValueError: \n                        sys.exit(\"RANDOMSEED={0!r} invalid\".format(seed_text)) \n                else: \n                    options.seed = None \n                return options \n\n    ```", "```py\n            def main(): \n                options = get_options(sys.argv[1:]) \n                face_count = write_rolls(options.output_path, roll_iter(options.samples, options.seed)) \n                summarize(options, face_count) \n\n    ```", "```py\n **slott$ python3 ch13_r05.py --samples 10 --output=x.yaml** \n\n **Namespace(output='x.yaml', output_path=PosixPath('x.yaml'), samples=10, seed=None)** \n\n **Counter({5: 7, 6: 7, 7: 7, 8: 5, 4: 4, 9: 4, 11: 3, 10: 1, 12: 1})** \n\n **slott$ more x.yaml** \n\n **--- [[5, 4], [3, 4]]** \n\n **--- [[3, 5], [1, 3], [1, 4], [5, 3]]** \n\n **--- [[3, 2], [2, 4], [6, 5], [1, 6]]** \n\n **--- [[2, 4], [3, 6], [5, 2]]** \n\n **--- [[1, 6]]** \n\n **--- [[1, 3], [4, 1], [1, 4], [5, 6], [6, 5], [1, 5], [2, 6], [3, 4]]** \n\n **--- [[3, 3], [3, 4]]** \n\n **--- [[3, 5], [4, 1], [4, 2], [3, 1], [1, 4], [2, 3], [2, 6]]** \n\n **--- [[2, 2], [1, 5], [5, 5], [1, 5], [6, 6], [4, 3]]** \n\n **--- [[4, 5], [6, 3]]** \n\n```", "```py\n    from generator import roll_iter, craps_rules \n    from stats_overview import summarize \n\n```", "```py\n    Roll = namedtuple('Roll', ('faces', 'total')) \n    def roll(n=2): \n        faces = list(random.randint(1, 6) for _ in range(n)) \n        total = sum(faces) \n        return Roll(faces, total) \n\n```", "```py\n    def craps_game(): \n        come_out = roll() \n        if come_out.total in [2, 3, 12]: \n            return [come_out.faces] \n        elif come_out.total in [7, 11]: \n            return [come_out.faces] \n        elif come_out.total in [4, 5, 6, 8, 9, 10]: \n            sequence = [come_out.faces] \n            next = roll() \n            while next.total not in [7, come_out.total]: \n                sequence.append(next.faces) \n                next = roll() \n            sequence.append(next.faces) \n            return sequence \n        else: \n            raise Exception(\"Horrifying Logic Bug\") \n\n```", "```py\n    class CrapsSimulator: \n        def __init__(self, seed=None): \n            self.rng = random.Random(seed) \n            self.faces = None \n            self.total = None \n\n        def roll(self, n=2): \n            self.faces = list(self.rng.randint(1, 6) for _ in range(n)) \n            self.total = sum(self._faces) \n\n        def craps_game(sel): \n            self.roll() \n            if self.total in [2, 3, 12]: \n                return [self.faces] \n            elif self.total in [7, 11]: \n                return [self.faces] \n            elif self.total in [4, 5, 6, 8, 9, 10]: \n                point, sequence = self.total, [self.faces] \n                self.roll() \n                while self.total not in [7, point]: \n                    sequence.append(self.faces) \n                    self.roll() \n                sequence.append(self.faces) \n                return sequence \n            else: \n                raise Exception(\"Horrifying Logic Bug\") \n\n        def roll_iter(total_games): \n            for i in range(total_games): \n                sequence = self.craps_game() \n                yield sequence \n\n```", "```py\n    def main(): \n        options = get_options(sys.argv[1:]) \n        if options.output is not None: \n            report_path = Path(options.output) \n            with report_path.open('w') as result_file: \n                process_all_files(result_file, options.file) \n        else: \n            process_all_files(sys.stdout, options.file) \n\n```", "```py\n    def process_all_files(result_file, file_names): \n        for source_path in (Path(n) for n in file_names): \n            with source_path.open() as source_file: \n                game_iter = yaml.load_all(source_file) \n                statistics = gather_stats(game_iter) \n                result_file.write( \n                    yaml.dump(dict(statistics), explicit_start=True) \n                ) \n\n```", "```py\n    def gather_stats(game_iter): \n        counts = Counter() \n        for game in game_iter: \n            if len(game) == 1 and sum(game[0]) in (2, 3, 12): \n                outcome = \"loss\" \n            elif len(game) == 1 and sum(game[0]) in (7, 11): \n                outcome = \"win\" \n            elif len(game) > 1 and sum(game[-1]) == 7: \n                outcome = \"loss\" \n            elif len(game) > 1 and sum(game[0]) == sum(game[-1]): \n                outcome = \"win\" \n            else: \n                raise Exception(\"Wait, What?\") \n            event = (outcome, len(game)) \n            counts[event] += 1 \n        return counts \n\n```", "```py\n **slott$ python3 ch13_r06.py x.yaml** \n\n **---** \n\n **? !!python/tuple [loss, 2]** \n\n **: 2** \n\n **? !!python/tuple [loss, 3]** \n\n **: 1** \n\n **? !!python/tuple [loss, 4]** \n\n **: 1** \n\n **? !!python/tuple [loss, 6]** \n\n **: 1** \n\n **? !!python/tuple [loss, 8]** \n\n **: 1** \n\n **? !!python/tuple [win, 1]** \n\n **: 1** \n\n **? !!python/tuple [win, 2]** \n\n **: 1** \n\n **? !!python/tuple [win, 4]** \n\n **: 1** \n\n **? !!python/tuple [win, 7]** \n\n **: 1** \n\n```", "```py\n            import logging\n\n    ```", "```py\n            import argparse \n            import sys \n            from pathlib import Path \n            from collections import Counter \n            import yaml \n\n    ```", "```py\n            detail_log = logging.getLogger(\"overview_stats.detail\") \n            write_log = logging.getLogger(\"overview_stats.write\") \n\n    ```", "```py\n            def main(): \n                options = get_options(sys.argv[1:]) \n                if options.output is not None: \n                    report_path = Path(options.output) \n                    with report_path.open('w') as result_file: \n                        process_all_files(result_file, options.file) \n                    write_log.info(\"wrote {}\".format(report_path)) \n                else: \n                    process_all_files(sys.stdout, options.file) \n\n    ```", "```py\n            def process_all_files(result_file, file_names): \n                for source_path in (Path(n) for n in file_names): \n                    detail_log.info(\"read {}\".format(source_path)) \n                    with source_path.open() as source_file: \n                        game_iter = yaml.load_all(source_file) \n                        statistics = gather_stats(game_iter) \n                    result_file.write( \n                        yaml.dump(dict(statistics), explicit_start=True) \n                    ) \n\n    ```", "```py\n            def gather_stats(game_iter): \n                counts = Counter() \n                for game in game_iter: \n                    if len(game) == 1 and sum(game[0]) in (2, 3, 12): \n                        outcome = \"loss\" \n                    elif len(game) == 1 and sum(game[0]) in (7, 11): \n                        outcome = \"win\" \n                    elif len(game) > 1 and sum(game[-1]) == 7: \n                        outcome = \"loss\" \n                    elif len(game) > 1 and sum(game[0]) == sum(game[-1]): \n                        outcome = \"win\" \n                    else: \n                        detail_log.error(\"problem with {}\".format(game)) \n                        raise Exception(\"Wait, What?\") \n                    event = (outcome, len(game)) \n                    detail_log.debug(\"game {} -> event {}\".format(game, event)) \n                    counts[event] += 1 \n                return counts \n\n    ```", "```py\n            def get_options(argv): \n                parser = argparse.ArgumentParser() \n                parser.add_argument('file', nargs='*') \n                parser.add_argument('-o', '--output') \n                options = parser.parse_args(argv) \n                detail_log.debug(\"options: {}\".format(options)) \n                return options \n\n    ```", "```py\n            if __name__ == \"__main__\": \n                logging.basicConfig(stream=sys.stderr, level=logging.INFO) \n                main() \n\n    ```", "```py\n     **slott$ python3 ch13_r06a.py -o sum.yaml x.yaml \n          INFO:overview_stats.detail:read x.yaml \n          INFO:overview_stats.write:wrote sum.yaml** \n\n    ```", "```py\n                import logging.config \n                config_yaml = ''' \n            version: 1 \n            formatters: \n                default: \n                    style: \"{\" \n                    format: \"{levelname}:{name}:{message}\" \n                    #   Example: INFO:overview_stats.detail:read x.yaml \n                timestamp: \n                    style: \"{\" \n                    format: \"{asctime}//{levelname}//{name}//{message}\" \n\n            handlers: \n                console: \n                    class: logging.StreamHandler \n                    stream: ext://sys.stderr \n                    formatter: default \n                file: \n                    class: logging.FileHandler \n                    filename: write.log \n                    formatter: timestamp \n\n            loggers: \n                overview_stats.detail: \n                    handlers: \n                    -   console \n                overview_stats.write: \n                    handlers: \n                    -   file \n                    -   console \n            root: \n                level: INFO \n            ''' \n\n    ```", "```py\n            logging.config.dictConfig(yaml.load(config_yaml)) \n            main()\n            logging.shutdown()\n    ```", "```py\n    logger = logging.getLogger(__name__) \n\n```", "```py\n            from ch13_r05 import roll_iter \n            from ch13_r06 import gather_stats \n\n    ```", "```py\n            from collections import Counter \n\n    ```", "```py\n            def summarize_games(total_games, *, seed=None): \n                game_statistics = gather_stats(roll_iter(total_games, seed=seed)) \n                return game_statistics \n\n    ```", "```py\n            def summarize_games_2(total_games, *, seed=None): \n                game_roll_history = roll_iter(total_games, counts, seed=seed) \n                game_statistics = gather_stats(game_roll_history) \n                return game_statistics \n\n    ```", "```py\n            def simple_composite(games=100000): \n                start = time.perf_counter() \n                stats = summarize_games(games) \n                end = time.perf_counter() \n                games = sum(stats.values()) \n                print('games', games) \n                print(win_loss(stats)) \n                print(\"{:.2f} seconds\".format(end-start)) \n\n    ```", "```py\n    def process_all_files(result_file, file_names): \n        for source_path in (Path(n) for n in file_names): \n            detail_log.info(\"read {}\".format(source_path)) \n            with source_path.open() as source_file: \n                game_iter = yaml.load_all(source_file) \n                statistics = gather_stats(game_iter) \n                result_file.write( \n                    yaml.dump(dict(statistics), explicit_start=True) \n                ) \n\n```", "```py\n    import concurrent.futures \n\n    def parallel(): \n        start = time.perf_counter() \n        total_stats = Counter() \n        worker_list = [] \n        with concurrent.futures.ProcessPoolExecutor() as executor: \n            for i in range(100): \n                worker_list.append(executor.submit(summarize_games, 1000)) \n            for worker in worker_list: \n                stats = worker.result() \n                total_stats.update(stats) \n        end = time.perf_counter() \n\n        games = sum(total_stats.values()) \n        print('games', games) \n        print(win_loss(total_stats)) \n        print(\"{:.2f} seconds\".format(end-start)) \n\n```", "```py\n **games 100000** \n\n **Counter({'loss': 50997, 'win': 49003})** \n\n **2.83 seconds** \n\n **games 100000** \n\n **Counter({'loss': 50523, 'win': 49477})** \n\n **1.49 seconds** \n\n```", "```py\n                    if __name__ == \"__main__\": \n                        logging configuration goes only here. \n                        main() \n                        logging.shutdown() \n\n        ```", "```py\n            from argparse import Namespace \n\n            class Command: \n                def execute(self, options: Namespace): \n                    pass \n\n    ```", "```py\n            import ch13_r05 \n\n            class Simulate(Command): \n                def __init__(self, seed=None): \n                    self.seed = seed \n                def execute(self, options): \n                    self.game_path = Path(options.game_file) \n                    data = ch13_r05.roll_iter(options.games, self.seed) \n                    ch13_r05.write_rolls(self.game_path, data) \n\n    ```", "```py\n            import ch13_r06 \n\n            class Summarize(Command): \n                def execute(self, options): \n                    self.summary_path = Path(options.summary_file) \n                    with self.summary_path.open('w') as result_file: \n                        ch13_r06.process_all_files(result_file, options.game_files) \n\n    ```", "```py\n            from argparse import Namespace \n\n            def main(): \n                options_1 = Namespace(games=100, game_file='x.yaml') \n                command1 = Simulate() \n                command1.execute(options_1) \n\n                options_2 = Namespace(summary_file='y.yaml', game_files=['x.yaml']) \n                command2 = Summarize() \n                command2.execute(options_2) \n\n    ```", "```py\n    class CommandSequence(Command): \n        def __init__(self, *commands): \n            self.commands = [command() for command in commands] \n        def execute(self, options): \n            for command in self.commands: \n                command.execute(options) \n\n```", "```py\n    options = Namespace(games=100, game_file='x.yaml', \n        summary_file='y.yaml', game_files=['x.yaml'] \n    ) \n    sim_sum_command = CommandSequence(Simulate, Summarize) \n    sim_sum_command.execute(options) \n\n```", "```py\n    class SimSum(CommandSequence): \n        def __init__(self): \n            super().__init__(Simulate, Summarize) \n\n```", "```py\n    options = Namespace(games=100, summary_file='y.yaml') \n    sim_sum_command = SimSum() \n    sim_sum_command.execute(options) \n\n```", "```py\n    def execute(self, options): \n        new_namespace = Namespace( \n            game_file='x.yaml', \n            game_files=['x.yaml'], \n            **vars(options) \n        ) \n        super().execute(new_namespace) \n\n```", "```py\n     **craps simulate -o game_file -g games \n          craps summarize -o summary_file game_file ... \n          craps simsum -g games** \n\n    ```", "```py\n            import argparse \n            def get_options(argv): \n                parser = argparse.ArgumentParser(prog='craps') \n                subparsers = parser.add_subparsers() \n\n    ```", "```py\n                simulate_parser = subparsers.add_parser('simulate') \n                simulate_parser.add_argument('-g', '--games', type=int, default=100000) \n                simulate_parser.add_argument('-o', '--output', dest='game_file') \n                simulate_parser.set_defaults(command=Simulate) \n\n    ```", "```py\n                summarize_parser = subparsers.add_parser('summarize') \n                summarize_parser.add_argument('-o', '--output', dest='summary_file') \n                summarize_parser.add_argument('game_files', nargs='*') \n                summarize_parser.set_defaults(command=Summarize) \n\n    ```", "```py\n                simsum_parser = subparsers.add_parser('simsum') \n                simsum_parser.add_argument('-g', '--games', type=int, default=100000) \n                simsum_parser.add_argument('-o', '--output', dest='summary_file') \n                simsum_parser.set_defaults(command=SimSum) \n\n    ```", "```py\n                options = parser.parse_args(argv) \n                if 'command' not in options: \n                    parser.print_help() \n                    sys.exit(2) \n                return options \n\n    ```", "```py\n            def main(): \n                options = get_options(sys.argv[1:]) \n                command = options.command(options) \n                command.execute() \n\n    ```", "```py\n     **python3.5 ch13_r08.py $*** \n\n    ```", "```py\n     **alias craps='python3.5 ch13_r08.py'** \n\n    ```", "```py\n **craps simulate -g 100 -o x.yaml** \n\n```", "```py\n **Namespace(command=<class '__main__.Simulate'>, game_file='x.yaml', games=100)** \n\n```", "```py\n    simulate_parser.add_argument('-g', '--games', type=int, default=100000) \n    simulate_parser.add_argument('-o', '--output', dest='game_file') \n\n```", "```py\n    import ch13_r05 \n    class Simulate(Command): \n        def __init__(self, options, *, seed=None): \n            self.games = options.games \n            self.game_file = options.game_file \n            self.seed = seed \n        def execute(self): \n            data = ch13_r05.roll_iter(self.games, self.seed) \n            ch13_r05.write_rolls(self.game_file, data) \n        @staticmethod \n        def configure(simulate_parser): \n            simulate_parser.add_argument('-g', '--games', type=int, default=100000) \n            simulate_parser.add_argument('-o', '--output', dest='game_file') \n\n```", "```py\n    import argparse \n    def get_options(argv): \n        parser = argparse.ArgumentParser(prog='craps') \n        subparsers = parser.add_subparsers() \n\n        simulate_parser = subparsers.add_parser('simulate') \n        Simulate.configure(simulate_parser) \n        simulate_parser.set_defaults(command=Simulate) \n\n        # etc. for each class \n\n```", "```py\n            import subprocess \n\n    ```", "```py\n     **slott$ python3 ch13_r05.py --samples 10 --output x.yaml** \n\n    ```", "```py\n            files = 100 \n            for n in range(files): \n                filename = 'game_{n}.yaml'.format_map(vars()) \n                command = ['python3', 'ch13_r05.py', \n                    '--samples', '10', '--output', filename] \n\n    ```", "```py\n            subprocess.run(command, check=True)\n\n    ```", "```py\n    import subprocess \n    from pathlib import Path \n\n    def make_files(files=100): \n        try: \n            for n in range(files): \n                filename = 'game_{n}.yaml'.format_map(vars()) \n                command = ['python3', 'ch13_r05.py', \n                    '--samples', '10', '--output', filename] \n                subprocess.run(command, check=True) \n        except subprocess.CalledProcessError as ex: \n            for partial in Path('.').glob(\"game_*.yaml\"): \n                partial.unlink() \n            raise \n\n```", "```py\n    import unittest \n    from unittest.mock import * \n\n    class GIVEN_make_files_exception_WHEN_call_THEN_run(unittest.TestCase): \n        def setUp(self): \n            self.mock_subprocess_run = Mock( \n                side_effect = [ \n                    None, \n                    subprocess.CalledProcessError(2, 'ch13_r05')] \n            ) \n            self.mock_path_glob_instance = Mock() \n            self.mock_path_instance = Mock( \n                glob = Mock( \n                    return_value = [self.mock_path_glob_instance] \n                ) \n            ) \n            self.mock_path_class = Mock( \n                return_value = self.mock_path_instance \n            ) \n\n```", "```py\n    def runTest(self): \n        with patch('__main__.subprocess.run', self.mock_subprocess_run), \\ \n            patch('__main__.Path', self.mock_path_class): \n            self.assertRaises( \n                subprocess.CalledProcessError, make_files, files=3) \n        self.mock_subprocess_run.assert_has_calls( \n            [call( \n                ['python3', 'ch13_r05.py', '--samples', '10', \n                 '--output', 'game_0.yaml'], \n                check=True), \n             call( \n                ['python3', 'ch13_r05.py', '--samples', '10', \n                '--output', 'game_1.yaml'], \n                check=True), \n             ] \n         ) \n         self.assertEqual(2, self.mock_subprocess_run.call_count) \n         self.mock_path_class.assert_called_once_with('.') \n         self.mock_path_instance.glob.assert_called_once_with('game_*.yaml') \n         self.mock_path_glob_instance.unlink.assert_called_once_with() \n\n```", "```py\n **slott$ python3 ch13_r05.py --samples 10 --output=x.yaml** \n\n **Namespace(output='x.yaml', output_path=PosixPath('x.yaml'), samples=10, seed=None)** \n\n **Counter({5: 7, 6: 7, 7: 7, 8: 5, 4: 4, 9: 4, 11: 3, 10: 1, 12: 1})** \n\n```", "```py\n            import subprocess \n\n    ```", "```py\n            def command_iter(files): \n                for n in range(files): \n                    filename = 'game_{n}.yaml'.format_map(vars()) \n                    command = ['python3', 'ch13_r05.py', \n                        '--samples', '10', '--output', filename] \n                    yield command \n\n    ```", "```py\n            def command_output_iter(iterable): \n                for command in iterable: \n                    process = subprocess.run(command, stdout=subprocess.PIPE, check=True) \n                    output_bytes = process.stdout \n                    output_lines = list(l.strip() for l in output_bytes.splitlines()) \n                    yield output_lines \n\n    ```", "```py\n            command_sequence = command_iter(100) \n            output_lines_sequence = command_output_iter(command_sequence) \n            for batch in output_lines_sequence: \n                for line in batch: \n                    if line.startswith('Counter'): \n                        batch_counter = eval(line) \n                        print(batch_counter) \n\n    ```", "```py\n    def process_batches(): \n        command_sequence = command_iter(2) \n        output_lines_sequence = command_output_iter(command_sequence) \n        for batch in output_lines_sequence: \n            for line in batch: \n                if line.startswith('Counter'): \n                    batch_counter = eval(line) \n                    yield batch_counter \n\n```", "```py\n    total_counter = Counter() \n    for batch_counter in process_batches(): \n        print(batch_counter) \n        total_counter.update(batch_counter) \n    print(\"Total\") \n    print(total_counter) \n\n```", "```py\n            import subprocess \n            class Command: \n                def execute(self, options): \n                    self.command = self.create_command(options) \n                    results = subprocess.run(self.command, \n                        check=True, stdout=subprocess.PIPE) \n                    self.output = results.stdout \n                    return self.output \n                def create_command(self, options): \n                    return ['echo', self.__class__.__name__, repr(self.options)] \n\n    ```", "```py\n            import ch13_r05 \n\n            class Simulate(Command): \n                def __init__(self, seed=None): \n                    self.seed = seed \n                def execute(self, options): \n                    if self.seed: \n                        os.environ['RANDOMSEED'] = str(self.seed) \n                    super().execute(options) \n                def create_command(self, options): \n                    return ['python3', 'ch13_r05.py`, \n                        '--samples', str(options.samples), \n                        '-o', options.game_file] \n\n    ```", "```py\n            import ch13_r06 \n\n            class Summarize(Command): \n                def create_command(self, options): \n                    return ['python3', 'ch13_r06.py', \n                        '-o', options.summary_file, \n                        ] + options.game_files \n\n    ```", "```py\n            from argparse import Namespace \n\n            def demo(): \n                options = Namespace(samples=100, \n                    game_file='x12.yaml', game_files=['x12.yaml'], \n                    summary_file='y12.yaml') \n                step1 = Simulate() \n                step2 = Summarize() \n                step1.execute(options) \n                step2.execute(options) \n\n    ```", "```py\n    def process_i(options): \n        step1 = Simulate() \n        options.game_files = [] \n        for i in range(options.simulations): \n            options.game_file = 'game_{i}.yaml'.format_map(vars()) \n            options.game_files.append(options.game_file) \n            step1.execute(options) \n        step2 = Summarize() \n        step2.execute(options) \n\n```", "```py\n    def process_c(options): \n        step1 = Simulate() \n        step1.execute(options) \n        if 'summary_file' in options: \n            step2 = Summarize() \n            step2.execute(options) \n\n```"]