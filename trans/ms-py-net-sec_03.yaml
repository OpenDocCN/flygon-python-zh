- en: Socket Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字编程
- en: his chapter will introduce you to some of the basics of Python networking using
    the `socket` module. Along the way, we'll build clients, servers with TCP, and
    **user datagram** **protocol** (**UDP**) protocols. Sockets Programming covers
    using TCP and UDP sockets from Python for writing low-level network applications.
    We will also cover HTTPS and TLS for secure data transport.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍使用`socket`模块进行Python网络编程的一些基础知识。在此过程中，我们将使用TCP和**用户数据报** **协议**（**UDP**）协议构建客户端和服务器。套接字编程涵盖了使用Python编写低级网络应用程序的TCP和UDP套接字。我们还将介绍HTTPS和TLS以进行安全数据传输。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the sockets and how to implement them in Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解套接字及如何在Python中实现它们
- en: Understanding the TCP Programming Client and Server in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Python中TCP编程客户端和服务器
- en: Understand the UDP Programming Client and Server in Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Python中UDP编程客户端和服务器
- en: Understand socket methods for resolving IP addresses and domains
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解解析IP地址和域的套接字方法
- en: Applying all concepts in practical uses cases, such as port scanning, and managing
    exceptions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有概念应用于实际用例，如端口扫描和异常处理
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Examples and source code for this chapter are available in the GitHub repository
    in the `chapter 3` folder: [https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security](https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例和源代码可在GitHub存储库的`第3章`文件夹中找到：[https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security](https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security)。
- en: You will need to install a Python distribution on your local machine with at
    least 2 GB memory and some basic knowledge about network protocols.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在本地计算机上安装一个至少有2GB内存的Python发行版，并具有一些关于网络协议的基本知识。
- en: Introduction to sockets
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字介绍
- en: Sockets are the main component that allows us to take advantage of the operating
    system's capabilities to interact with the network. You can think of sockets as
    a point-to-point communication channel between a client and a server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是允许我们利用操作系统与网络进行交互的主要组件。您可以将套接字视为客户端和服务器之间的点对点通信通道。
- en: Network sockets are an easy way to establish a communication between processes
    that are on the same or different machines. The concept of a socket is very similar
    to that of UNIX file descriptors. Commands such as `read()` and `write()` ( to
    work with the file system ) work in a similar way to sockets.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 网络套接字是在同一台或不同机器上的进程之间建立通信的一种简单方式。套接字的概念与UNIX文件描述符非常相似。诸如`read()`和`write()`（用于处理文件系统）的命令以类似的方式工作于套接字。
- en: A network socket address consists of an IP address and port number. The goal
    of a socket is to communicate processes through the network.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 网络套接字地址由IP地址和端口号组成。套接字的目标是通过网络通信进程。
- en: Network sockets in Python
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的网络套接字
- en: Communication between different entities in a network is based on Python's classic
    concept of sockets. A socket is defined by the IP address of the machine, the
    port on which it listens, and the protocol it uses.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中不同实体之间的通信基于Python的套接字经典概念。套接字由机器的IP地址、它监听的端口和它使用的协议定义。
- en: 'Creating a socket in Python it is done through the `socket.socket()` method.
    The general syntax of the socket method is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中创建套接字是通过`socket.socket()`方法完成的。套接字方法的一般语法如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These **arguments** represent the address families and the protocol of the transport
    layer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些**参数**代表传输层的地址族和协议。
- en: Depending on socket type, sockets are classified into flow sockets (`socket.SOCK_STREAM`)
    or datagram sockets (`socket.SOCK_DGRAM`), based on whether the service uses TCP
    or UDP. `socket.SOCK_DGRAM` is used for UDP communications, and `socket.SOCK_STREAM`
    for TCP connections.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据套接字类型，套接字根据是否使用TCP或UDP服务，被分类为流套接字（`socket.SOCK_STREAM`）或数据报套接字（`socket.SOCK_DGRAM`）。`socket.SOCK_DGRAM`用于UDP通信，`socket.SOCK_STREAM`用于TCP连接。
- en: 'Sockets can also be classified according to the family. We have UNIX sockets
    (`socket.AF_UNIX`) which were created before the concept of networks and are based
    on files, the `socket.AF_INET` socket which is the one that interests us, the `socket.AF_INET6
    for IPv6` socket, and so on:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字还可以根据家族进行分类。我们有UNIX套接字（`socket.AF_UNIX`），它是在网络概念之前创建的，基于文件；我们感兴趣的是`socket.AF_INET`套接字；`socket.AF_INET6用于IPv6`套接字，等等：
- en: '![](assets/8617f5df-4575-4951-ab3a-1d6add4a165a.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8617f5df-4575-4951-ab3a-1d6add4a165a.png)'
- en: The socket module
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字模块
- en: Types and functions needed to work with sockets can be found in Python in the
    `socket` module. The `socket` module exposes all of the necessary pieces to quickly
    write TCP and UDP clients and servers. The `socket` module has almost everything
    you need to build a socket server or client. In the case of Python, the socket
    returns an object to which the socket methods can be applied.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，可以在`socket`模块中找到用于处理套接字的类型和函数。`socket`模块公开了快速编写TCP和UDP客户端和服务器所需的所有必要部分。`socket`模块几乎包含了构建套接字服务器或客户端所需的一切。在Python的情况下，套接字返回一个对象，可以对其应用套接字方法。
- en: This module comes installed by default when you install the Python distribution.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当您安装Python发行版时，默认情况下会安装此模块。
- en: 'To check it, we can do so from the Python interpreter:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查它，我们可以在Python解释器中这样做：
- en: '![](assets/51894bae-8aea-48b5-baf5-676c2046591f.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/51894bae-8aea-48b5-baf5-676c2046591f.png)'
- en: 'In this screenshot, we see all the constants and methods that we have available
    in this module. The constants we see in the first instance within the structure
    that has returned the object. Among the most-used constants, we can highlight
    the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕截图中，我们看到此模块中可用的所有常量和方法。我们首先在返回的结构中看到的常量。在最常用的常量中，我们可以突出显示以下内容：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A typical call to build a socket that works at the TCP level is:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 构建在TCP级别工作的套接字的典型调用如下：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Socket methods
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字方法
- en: 'These are the general socket methods we can use in both clients and servers:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们可以在客户端和服务器中使用的一般套接字方法：
- en: '`socket.recv(buflen)`: This method receives data from the socket. The method
    argument indicates the maximum amount of data it can receive.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.recv(buflen)`: 这个方法从套接字接收数据。方法参数指示它可以接收的最大数据量。'
- en: '`socket.recvfrom(buflen)`: This method receives data and the sender''s address.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.recvfrom(buflen)`: 这个方法接收数据和发送者的地址。'
- en: '`socket.recv_into(buffer)`: This method receives data into a buffer.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.recv_into(buffer)`: 这个方法将数据接收到缓冲区中。'
- en: '`socket.recvfrom_into(buffer)`: This method receives data into a buffer.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.recvfrom_into(buffer)`: 这个方法将数据接收到缓冲区中。'
- en: '`socket.send(bytes)`: This method sends bytes data to the specified target.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.send(bytes)`: 这个方法将字节数据发送到指定的目标。'
- en: '`socket.sendto(data, address)`: This method sends data to a given address.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.sendto(data, address)`: 这个方法将数据发送到给定的地址。'
- en: '`socket.sendall(data)`: This method sends all the data in the buffer to the
    socket.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.sendall(data)`: 这个方法将缓冲区中的所有数据发送到套接字。'
- en: '`socket.close()`: This method releases the memory and finishes the connection.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.close()`: 这个方法释放内存并结束连接。'
- en: Server socket methods
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器套接字方法
- en: 'In a **client-server architecture**, there is a central server that provides
    services to a set of machines that connect. These are the main methods we can
    use from the point of view of the server:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在**客户端-服务器架构**中，有一个提供服务给一组连接的机器的中央服务器。这些是我们可以从服务器的角度使用的主要方法：
- en: '`socket.bind(address)`: This method allows us to connect the address with the
    socket, with the requirement that the socket must be open before establishing
    the connection with the address'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.bind(address)`: 这个方法允许我们将地址与套接字连接起来，要求在与地址建立连接之前套接字必须是打开的'
- en: '`socket.listen(count)`: This method accepts as a parameter the maximum number
    of connections from clients and starts the TCP listener for incoming connections'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.listen(count)`: 这个方法接受客户端的最大连接数作为参数，并启动用于传入连接的TCP监听器'
- en: '`socket.accept()`: This method allows us to accept connections from the client.
    This method returns two values: `client_socket` and client address. `client_socket`
    is a new socket object used to send and receive data. Before using this method,
    you must call the `socket.bind(address)` and `socket.listen(q)` methods'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.accept()`: 这个方法允许我们接受来自客户端的连接。这个方法返回两个值：`client_socket` 和客户端地址。`client_socket`
    是一个用于发送和接收数据的新套接字对象。在使用这个方法之前，必须调用`socket.bind(address)`和`socket.listen(q)`方法。'
- en: Client socket methods
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端套接字方法
- en: 'This is the socket method we can use in our socket client for connecting with
    the server:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以在套接字客户端中用于与服务器连接的套接字方法：
- en: '`socket.connect(ip_address)`: This method connects the client to the server
    IP address'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.connect(ip_address)`: 这个方法将客户端连接到服务器IP地址'
- en: We can obtain more information about this method with the `help(socket)` command.
    We learn that this method does the same as the `connect_ex` method and also offers
    the possibility of returning an error in the event of not being able to connect
    with that address.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`help(socket)`命令获取有关这个方法的更多信息。我们了解到这个方法与`connect_ex`方法相同，并且在无法连接到该地址时还提供了返回错误的可能性。
- en: 'We can obtain more information about these methods with the `help(socket)`
    command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`help(socket)`命令获取有关这些方法的更多信息：
- en: '![](assets/6d26def8-753b-4270-8ae2-909cb98b0051.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6d26def8-753b-4270-8ae2-909cb98b0051.png)'
- en: Basic client with the socket module
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用套接字模块的基本客户端
- en: In this example, we are testing how to send and receive data from a website.Once
    the connection is established, we can send and receive data. Communication with
    the socket can be done very easily thanks to two functions, `send ()` and `recv
    ()`, used for TCP communications. For UDP communication, we use `sendto ()`, and `recvfrom
    ()`
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在测试如何从网站发送和接收数据。一旦建立连接，我们就可以发送和接收数据。通过两个函数`send()`和`recv()`，可以非常容易地与套接字通信，用于TCP通信。对于UDP通信，我们使用`sendto()`和`recvfrom()`
- en: In this `socket_data.py` script, we create a socket object with the `AF_INET`
    and `SOCK_STREAM` parameters. We then connect the client to the remote host and
    send it some data. The last step is to receive some data back and print out the
    response. We use an infinite loop (while `True`) and we check whether the data
    variable is empty. If this condition occurs, we finish the loop.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`socket_data.py`脚本中，我们使用`AF_INET`和`SOCK_STREAM`参数创建了一个套接字对象。然后将客户端连接到远程主机并发送一些数据。最后一步是接收一些数据并打印出响应。我们使用一个无限循环（while
    `True`）并检查数据变量是否为空。如果发生这种情况，我们结束循环。
- en: 'You can find the following code in the `socket_data.py` file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`socket_data.py`文件中找到以下代码：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating a simple TCP client and TCP server
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的TCP客户端和TCP服务器
- en: The idea behind creating this application is that a socket client can establish
    a connection against a given host, port, and protocol. The socket server is responsible
    for receiving connections from clients in a specific port and protocol.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这个应用的想法是，套接字客户端可以针对给定的主机、端口和协议建立连接。套接字服务器负责在特定端口和协议上接收来自客户端的连接。
- en: Creating a server and client with sockets
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用套接字创建服务器和客户端
- en: To create a socket, the `socket.socket()` constructor is used, which can take
    the family, type, and protocol as optional parameters. By default, the `AF_INET`
    family and the `SOCK_STREAM` type are used.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个套接字，使用`socket.socket()`构造函数，可以将家族、类型和协议作为可选参数。默认情况下，使用`AF_INET`家族和`SOCK_STREAM`类型。
- en: In this section, we will see how to create a couple of client and server scripts
    as an example.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何创建一对客户端和服务器脚本作为示例。
- en: 'The first thing we have to do is create a socket object for the server:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是为服务器创建一个套接字对象：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We now have to indicate on which port our server will listen using the bind
    method. For IP sockets, as in our case, the bind argument is a tuple that contains
    the host and the port. The host can be left empty, indicating to the method that
    you can use any name that is available.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须使用bind方法指示服务器将监听哪个端口。对于IP套接字，就像我们的情况一样，bind参数是一个包含主机和端口的元组。主机可以留空，表示可以使用任何可用的名称。
- en: 'The `bind(IP,PORT)` method allows you to associate a host and a port with a
    specific socket, taking into account that ports `1-1024` are reserved for the
    standard protocols:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind(IP,PORT)`方法允许将主机和端口与特定套接字关联起来，考虑到`1-1024`端口保留用于标准协议：'
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Finally, we use listen to make the socket accept incoming connections and to
    start listening. The listen method requires a parameter that indicates the number
    of maximum connections we want to accept.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用listen方法使套接字接受传入的连接并开始监听。listen方法需要一个参数，指示我们要接受的最大连接数。
- en: The `accept` method keeps waiting for incoming connections, blocking execution
    until a message arrives.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`accept`方法继续等待传入连接，阻塞执行直到消息到达。'
- en: 'To accept requests from a client socket, the `accept()` method should be used.
    In this way, the server socket waits to receive an input connection from another
    host:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要接受来自客户端套接字的请求，应该使用`accept()`方法。这样，服务器套接字等待接收来自另一台主机的输入连接：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can obtain more information about these methods with the `help(socket)`
    command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`help(socket)`命令获取有关这些方法的更多信息：
- en: '![](assets/d1606fe2-424f-4112-9426-0d1abf78022c.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d1606fe2-424f-4112-9426-0d1abf78022c.png)'
- en: 'Once we have this socket object, we can communicate with the client through
    it, using the `recv` and `send` methods (or `recvfrom` and `sendfrom` in UDP)
    that allow us to receive or send messages, respectively. The send method takes
    as parameters the data to send, while the `recv` method takes as a parameter the
    maximum number of bytes to accept:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个套接字对象，我们就可以通过它与客户端进行通信，使用`recv`和`send`方法（或UDP中的`recvfrom`和`sendfrom`）来接收或发送消息。send方法的参数是要发送的数据，而`recv`方法的参数是要接受的最大字节数：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To create a client, we have to create the socket object, use the connect method
    to connect to the server, and use the send and recv methods we saw earlier. The
    connect argument is a tuple with host and port, exactly like bind:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建客户端，我们必须创建套接字对象，使用connect方法连接到服务器，并使用之前看到的send和recv方法。connect参数是一个包含主机和端口的元组，与bind完全相同：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's see a complete example. In this example, the client sends to the server
    any message that the user writes and the server repeats the received message.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个完整的例子。在这个例子中，客户端向服务器发送用户写的任何消息，服务器重复接收到的消息。
- en: Implementing the TCP serverIn this example, we are going to create a multithreaded
    TCP server.
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现TCP服务器在本例中，我们将创建一个多线程TCP服务器。
- en: The server socket opens a TCP socket on `localhost:9999` and listens to requests
    in an infinite loop. When you receive a request from the client socket, it will
    return a message indicating that a connection has been made from another machine.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器套接字在`localhost:9999`上打开一个TCP套接字，并在无限循环中监听请求。当您从客户端套接字接收到请求时，它将返回一条消息，指示已从另一台机器建立连接。
- en: The while loop keeps the server program alive and does not allow the code to
    end. The `server.listen(5)` statement listens to the connection and waits for
    the client. This instruction tells the server to start listening with the maximum
    backlog of connections set to `5`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: while循环使服务器程序保持活动状态，并且不允许代码结束。`server.listen(5)`语句监听连接并等待客户端。此指令告诉服务器以最大连接数设置为`5`开始监听。
- en: 'You can find the following code in the `tcp_server.py` file inside the `tcp_client_server`
    folder:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`tcp_server.py`文件中的`tcp_client_server`文件夹中找到以下代码：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Implementing the TCP client
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现TCP客户端
- en: The client socket opens the same type of socket as that on which the server
    is listening and sends a message. The server responds and ends its execution,
    closing the client socket.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端套接字打开与服务器正在侦听的套接字相同类型的套接字并发送消息。服务器做出响应并结束执行，关闭客户端套接字。
- en: 'You can find the following code in the `tcp_client.py` file inside the `tcp_client_server`
    folder:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`tcp_client.py`文件中的`tcp_client_server`文件夹中找到以下代码：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding code, the `new: s.connect((host,port))` method connects the
    client to the server, and the `s.recv(1024)` method receives the strings sent
    by the server.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '在上述代码中，`new: s.connect((host,port))`方法将客户端连接到服务器，`s.recv(1024)`方法接收服务器发送的字符串。'
- en: Creating a simple UDP client and UDP server
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个简单的UDP客户端和UDP服务器
- en: In this section, we review how you can set up your own UDP client-server application
    with Python's `Socket` module. The application will be a server that listens for
    all connections and messages over a specific port and prints out any messages
    to the console.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何使用Python的`Socket`模块设置自己的UDP客户端服务器应用程序。该应用程序将是一个服务器，它监听特定端口上的所有连接和消息，并将任何消息打印到控制台。
- en: Introduction to the UDP protocol
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP协议简介
- en: 'UDP is a protocol that is on the same level as TCP, that is, above the IP layer.
    It offers a service in disconnected mode to the applications that use it. This
    protocol is suitable for applications that require efficient communication that
    doesn''t have to worry about packet loss. The typical applications of UDP are
    internet telephony and video-streaming. The header of a UDP frame is composed
    of four fields:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: UDP是与TCP处于同一级别的协议，即在IP层之上。它为使用它的应用程序提供了一种断开连接模式的服务。该协议适用于需要高效通信且无需担心数据包丢失的应用程序。UDP的典型应用包括互联网电话和视频流。UDP帧的标头由四个字段组成：
- en: The UDP port of origin
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP源端口
- en: The UDP destination port
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP目的端口
- en: The length of the UDP message
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UDP消息的长度
- en: The chekSum as the error-control field
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查和校验和作为错误控制字段
- en: The only difference regarding working with TCP in Python is that when creating
    the socket, you have to use `SOCK_DGRAM` instead of `SOCK_STREAM`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中使用TCP的唯一区别是，在创建套接字时，必须使用`SOCK_DGRAM`而不是`SOCK_STREAM`。
- en: The main difference between TCP and UDP is that UDP is not connection-oriented,
    this means that there is no guarantee our packets will reach their destinations,
    and no error notification if a delivery fails.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP之间的主要区别在于UDP不是面向连接的，这意味着我们的数据包不一定会到达目的地，并且如果传输失败，也不会收到错误通知。
- en: UDP client and server with the socket module
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用socket模块的UDP客户端和服务器
- en: In this example, we'll create a synchronous UDP server, which  means each request
    must wait until the end of the process of the previous request. The `bind()` method
    will be used to associate the port with the IP address. For the reception of the
    message, we use the `recvfrom()` and `sendto()` methods for the sending.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个同步UDP服务器，这意味着每个请求必须等待前一个请求的过程结束。`bind()`方法将用于将端口与IP地址关联起来。对于消息的接收，我们使用`recvfrom()`和`sendto()`方法进行发送。
- en: Implementing the UDP Server
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现UDP服务器
- en: 'The main difference with TCP is that UDP does not control the errors of the
    packets that are sent. The only difference between a TCP socket and a UDP socket
    that must specify `SOCK_DGRAM` instead of `SOCK_STREAM` when creating the socket
    object. Use the following code to create the UDP server:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与TCP的主要区别在于UDP不控制发送的数据包的错误。TCP套接字和UDP套接字之间的唯一区别是在创建套接字对象时必须指定`SOCK_DGRAM`而不是`SOCK_STREAM`。使用以下代码创建UDP服务器：
- en: 'You can find the following code in the **`udp_server.py` **file inside the `udp_client_server`
    folder:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`udp_client_server`文件夹中的`udp_server.py`文件中找到以下代码：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous code, we see that `socket.SOCK_DGRAM` creates a UDP socket,
    and data, **`addr = s.recvfrom(buffer)`** returns the data and the source's address.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们看到`socket.SOCK_DGRAM`创建了一个UDP套接字，而`data，**`addr = s.recvfrom(buffer)`**返回了数据和源地址。
- en: Now that we have finished our server, we need to implement our client program.
    The server that will be continuously listening on our defined IP address and port
    number for any UDP messages. It is essential that this server is run prior to
    the execution of the Python client script or the client script will fail.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了服务器，需要实现我们的客户端程序。服务器将持续监听我们定义的IP地址和端口号，以接收任何UDP消息。在执行Python客户端脚本之前，必须先运行该服务器，否则客户端脚本将失败。
- en: Implementing the UDP client
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现UDP客户端
- en: 'To begin implementing the client, we will need to declare the IP address that
    we will be trying to send our UDP messages to, as well as the port number. This
    port number is arbitrary but you must ensure you aren''t using a socket that has
    already been taken:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始实现客户端，我们需要声明要尝试发送UDP消息的IP地址，以及端口号。这个端口号是任意的，但你必须确保你没有使用已经被占用的套接字：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now it''s time to create the socket through which we will be sending our UDP
    message to the server:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建我们将用来向服务器发送UDP消息的套接字了：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And finally, once we''ve constructed our new socket, it''s time to write the
    code that will send our UDP message:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦我们构建了新的套接字，就该编写发送UDP消息的代码了：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can find the following code in the **`udp_client.py` **fileinside the `udp_client_server`
    folder:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`udp_client_server`文件夹中的`udp_client.py`文件中找到以下代码：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we try to use `SOCK_STREAM` with the UDP socket, we get  `error: Traceback
    (most recent call last): File ".\udp_server.py", line 15, in <module> data,addr
    = socket_server.recvfrom(buffer)socket.error: [Errno 10057] A request to send
    or receive data was disallowed because the socket is not connected and no address
    was supplied`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们尝试在UDP套接字中使用`SOCK_STREAM`，我们会得到`error: Traceback (most recent call last):
    File ".\udp_server.py", line 15, in <module> data,addr = socket_server.recvfrom(buffer)socket.error:
    [Errno 10057] A request to send or receive data was disallowed because the socket
    is not connected and no address was supplied`。'
- en: Resolving IP addresses and domains
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析IP地址和域名
- en: In this chapter, we have looked at how to build sockets in Python, both oriented
    to connection with TCP and not oriented to connection with UDP. In this section,
    we'll review useful methods to get more information about an IP address or domain.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经学习了如何在Python中构建套接字，包括面向TCP连接和不面向连接的UDP。在本节中，我们将回顾一些有用的方法，以获取有关IP地址或域名的更多信息。
- en: Gathering information with sockets
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用套接字收集信息
- en: 'Useful methods to gather more information are:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 收集更多信息的有用方法包括：
- en: '`gethostbyaddr(address)`: Allows us to obtain a domain name from the IP address'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gethostbyaddr(address)`:允许我们从IP地址获取域名'
- en: '`gethostbyname(hostname)`: Allows us to obtain an IP address from a domain
    name'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gethostbyname(hostname)`:允许我们从域名获取IP地址'
- en: 'We can get more information about these methods with the `help(socket)` command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`help(socket)`命令获取有关这些方法的更多信息：
- en: '![](assets/dcfa6c52-52f4-4d99-95c6-fe9fcf06dd81.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dcfa6c52-52f4-4d99-95c6-fe9fcf06dd81.png)'
- en: 'Now we are going to detail some methods related to the host, IP address, and
    domain resolution. For each one, we will show a simple example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将详细介绍一些与主机、IP地址和域名解析相关的方法。对于每个方法，我们将展示一个简单的例子：
- en: '`socket.gethostbyname(hostname)`: This method converts a hostname to the IPv4
    address format. The IPv4 address is returned in the form of a string. This method
    is equivalent to the `nslookup` command we can find in many operating systems:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.gethostbyname(hostname)`:该方法将主机名转换为IPv4地址格式。IPv4地址以字符串形式返回。这个方法相当于我们在许多操作系统中找到的`nslookup`命令：'
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`socket.gethostbyname_ex(name)`: This method returns many IP addresses for
    a single domain name. It means one domain runs on multiple IPs:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.gethostbyname_ex(name)`:该方法返回单个域名的多个IP地址。这意味着一个域名运行在多个IP上：'
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`socket.getfqdn([domain])`: This is used to find the fully-qualified name of
    a domain:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.getfqdn([domain])`:用于查找域的完全限定名称：'
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`socket.gethostbyaddr(ip_address)`: This method returns a tuple (`hostname`,
    `name`, `ip_address_list`) where hostname is the hostname that responds to the
    given IP address, the name is a list of names associated with the same address,
    and `the_address_list` is a list of IP addresses for the same network interface
    on the same host:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.gethostbyaddr(ip_address)`:该方法返回一个元组（`hostname`，`name`，`ip_address_list`），其中`hostname`是响应给定IP地址的主机名，`name`是与同一地址关联的名称列表，`ip_address_list`是同一主机上同一网络接口的IP地址列表：'
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`socket.getservbyname(servicename[, protocol_name])`: This method allows you
    to obtain the port number from the port name:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.getservbyname(servicename[, protocol_name])`：此方法允许您从端口名称获取端口号：'
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`socket.getservbyport(port[, protocol_name])`: This method performs the reverse
    operation of the previous, allowing you to obtain the port name from the port
    number:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket.getservbyport(port[, protocol_name])`：此方法执行与前一个方法相反的操作，允许您从端口号获取端口名称：'
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The following script is an example of how we can use these methods to obtain
    information from Google servers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本是一个示例，演示了如何使用这些方法从Google服务器获取信息。
- en: 'You can find the following code in the `socket_methods.py` file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`socket_methods.py`文件中找到以下代码：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `socket.connect_ex(address)` method is used to implement port-scanning with
    sockets. This script shows ports are open in the localhost machine with the loopback
    IP address interface of `127.0.0.1`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.connect_ex(address)`方法用于使用套接字实现端口扫描。此脚本显示了在本地主机上使用回环IP地址接口`127.0.0.1`的打开端口。'
- en: 'You can find the following code in the `socket_ports_open.py` file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`socket_ports_open.py`文件中找到以下代码：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Reverse lookup
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反向查找
- en: This command obtains the host name from the IP address. For this task, we can
    use the `gethostbyaddr()` function. In this script, we obtain the host name from
    the IP address of `8.8.8.8`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令从IP地址获取主机名。为此任务，我们可以使用`gethostbyaddr()`函数。在此脚本中，我们从`8.8.8.8`的IP地址获取主机名。
- en: 'You can find the following code in the `socket_reverse_lookup.py` file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`socket_reverse_lookup.py`文件中找到以下代码：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Practical use cases for sockets
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字的实际用例
- en: In this section, we'll review how we can implement port-scanning with sockets
    and how to manage exceptions when we are working with sockets.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何使用套接字实现端口扫描以及在使用套接字时如何处理异常。
- en: Port scanner with sockets
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用套接字进行端口扫描
- en: Sockets are the fundamental building block for network communications and in
    an easy way we can check whether a specific port is open, closed, or filtered
    by calling the `connect_ex` method.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字是网络通信的基本构建模块，我们可以通过调用`connect_ex`方法来轻松地检查特定端口是打开、关闭还是被过滤。
- en: For example, we could have a function that accepts by parameters an IP and a
    list of ports and return for each port whether it is open or closed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以编写一个函数，该函数接受IP和端口列表作为参数，并针对每个端口返回该端口是打开还是关闭。
- en: In this example, we need to import the socket and `sys` modules. If we execute
    the function from our main program, we see how it checks each of the ports and
    returns whether it is open or closed for a specific IP address. The first parameter
    can be either an IP address or a domain name since the module is able to resolve
    a name from an IP and vice versa.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们需要导入socket和`sys`模块。如果我们从主程序执行该函数，我们可以看到它如何检查每个端口，并返回特定IP地址的端口是打开还是关闭。第一个参数可以是IP地址，也可以是域名，因为该模块能够从IP解析名称，反之亦然。
- en: 'You can find the following code in the `check_ports_socket.py`file inside the `port_scan`
    folder:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`port_scan`文件夹中的`check_ports_socket.py`文件中找到以下代码：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The following Python code will allow you to scan a local or remote host for
    open ports. The program scans for select ports on a certain IP address entered
    by the user and reflects the open ports back to the user. If the port is closed,
    it also shows information about the reason for that, for example by timeout connection.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Python代码将允许您扫描本地或远程主机的开放端口。该程序会扫描用户输入的特定IP地址上的选定端口，并将开放的端口反馈给用户。如果端口关闭，它还会显示有关关闭原因的信息，例如超时连接。
- en: You can find the following code in the `socket_port_scanner.py`file inside the `port_scan`
    folder.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`port_scan`文件夹中的`socket_port_scanner.py`文件中找到以下代码。
- en: 'The script starts with information related to the IP address and ports introduced
    by the user:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本从用户输入的IP地址和端口相关信息开始：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We continue the script with a for loop from `startPort` to `endPort` to analyze
    each port in between.We finish by showing the total time to complete the port
    scanning:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续脚本，使用从`startPort`到`endPort`的for循环来分析每个端口。最后，我们显示完成端口扫描所需的总时间：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the execution of the previous script, we can see ports that are open and
    the time in seconds for complete port-scanning:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行上一个脚本时，我们可以看到打开的端口以及完成端口扫描所需的时间（以秒为单位）：
- en: '![](assets/4cd90073-6b11-4d10-bc57-cf996c26d4db.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4cd90073-6b11-4d10-bc57-cf996c26d4db.png)'
- en: The following Python script will allow us to scan an IP address with the `portScanning`
    and `socketScan` functions. The program scans for selected ports on a specific
    domain resolved from the IP address entered by the user by parameter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Python脚本将允许我们使用`portScanning`和`socketScan`函数扫描IP地址。该程序会扫描用户输入的IP地址解析出的特定域上的选定端口。
- en: 'In this script, the user must enter as mandatory parameters the host and a
    port, separated by a comma:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，用户必须输入主机和端口作为必填参数，用逗号分隔：
- en: '![](assets/fb2d53e2-8076-426f-a13f-c52a0c3148e9.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fb2d53e2-8076-426f-a13f-c52a0c3148e9.png)'
- en: 'You can find the following code in the `socket_portScan.py`file inside the `port_scan`
    folder:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`port_scan`文件夹中的`socket_portScan.py`文件中找到以下代码：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is our main program when we get mandatory parameters host and ports for
    the script execution. Once we have obtained these parameters, we call the `portScanning`
    function which will resolve the IP address and host name, and will call the `socketScan`
    function that will use the `socket` module to determine the port state:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的主程序，当我们获取脚本执行的必填参数主机和端口时。一旦我们获得这些参数，我们调用`portScanning`函数，该函数将解析IP地址和主机名，并调用`socketScan`函数，该函数将使用`socket`模块确定端口状态：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the execution of the previous script, we can see that all ports are closed
    in the `google-public-dns-a.google.com` domain:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行上一个脚本时，我们可以看到`google-public-dns-a.google.com`域中的所有端口都已关闭。
- en: '![](assets/45a671e7-9e5a-47e5-84df-0880e69b1ec8.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/45a671e7-9e5a-47e5-84df-0880e69b1ec8.png)'
- en: Managing socket exceptions
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理套接字异常
- en: 'In order to handle exceptions, we''ll use the try and except blocks. Different
    types of exceptions are defined in Python''s socket library for different errors.
    These exceptions are described here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理异常，我们将使用try和except块。Python的套接字库为不同的错误定义了不同类型的异常。这些异常在这里描述：
- en: '`exception socket.timeout`: This block catches exceptions related to the expiration
    of waiting times.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exception socket.timeout`：此块捕获与等待时间到期相关的异常。'
- en: '`exception socket.gaierror`: This block catches errors during the search for
    information about IP addresses, for example when we are using the `getaddrinfo()`
    and `getnameinfo()` methods.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exception socket.gaierror`：此块捕获在搜索有关IP地址的信息时发生的错误，例如当我们使用`getaddrinfo()`和`getnameinfo()`方法时。'
- en: '`exception socket.error`: This block catches generic input and output errors
    and communication. This is a generic block where you can catch any type of exception.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exception socket.error`：此块捕获通用输入和输出错误以及通信。这是一个通用块，您可以捕获任何类型的异常。'
- en: The next example shows you how to handle the exceptions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例向您展示如何处理异常。
- en: 'You can find the following code in the `manage_socket_errors.py` file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`manage_socket_errors.py`文件中找到以下代码：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the previous script, when a connection timeout with an IP address occurs,
    it throws an exception related to the socket connection with the server. If you
    try to get information about specific domains or IP addresses that don''t exist,
    it will probably throw a `socket.gaierror` exception with the `connection error
    to the server:[Errno 11001] getaddrinfo failed` message. If the connection with
    our target is not possible, it will throw a `socket.error` exception with the `Connection
    error: [Errno 10061] No connection could be made because the target machine actively
    refused it` message.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个脚本中，当与IP地址的连接超时时，它会抛出与服务器的套接字连接相关的异常。如果尝试获取不存在的特定域或IP地址的信息，它可能会抛出`socket.gaierror`异常，并显示`连接到服务器的错误：[Errno
    11001] getaddrinfo failed`消息。如果与目标的连接不可能，它将抛出`socket.error`异常，并显示`连接错误：[Errno
    10061] 由于目标计算机积极拒绝，无法建立连接`消息。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the `socket` module for implementing client-server
    architectures in Python with the TCP and UDP protocols.We also reviewed the main
    functions and methods for resolving IP address from domains and vice versa. Finally,
    we implemented practical use cases, such as port scanning with sockets and how
    to manage exceptions when an error is produced.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了`socket`模块，用于在Python中实现客户端-服务器架构的TCP和UDP协议。我们还回顾了从域解析IP地址和反之的主要功能和方法。最后，我们实现了端口扫描和如何在产生错误时处理异常等实际用例。
- en: In the next *[chapter](9e79dfe8-9de4-4aaf-9d24-42b67a7da39c.xhtml)*, we will
    explore http requests packages for working with Python, the REST API, and authentication
    in servers.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个*[章节](9e79dfe8-9de4-4aaf-9d24-42b67a7da39c.xhtml)*中，我们将探讨用Python处理http请求包、REST
    API和服务器身份验证。
- en: Questions
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What method of the `sockets` module allows a domain name to be resolved from
    an IP address?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sockets`模块的哪种方法允许从IP地址解析域名？'
- en: What method of the `socket` module allows a server socket to accept requests
    from a client socket from another host?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`socket`模块的哪种方法允许服务器套接字接受来自另一台主机的客户端套接字的请求？'
- en: What method of the `socket` module allows you to send data to a given address?
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`socket`模块的哪种方法允许您向特定地址发送数据？'
- en: What method of the `socket` module allows you to associate a host and a port
    with a specific socket?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`socket`模块的哪种方法允许您将主机和端口与特定套接字关联起来？'
- en: What is the the difference between the TCP and UDP protocol and how do you implement
    them in Python with the `socket` module?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TCP和UDP协议之间的区别是什么，以及如何在Python中使用`socket`模块实现它们？
- en: What method of the `socket` module allows you to convert a hostname to the IPv4
    address format?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`socket`模块的哪种方法允许您将主机名转换为IPv4地址格式？'
- en: What method of the `socket` module allows you to implement port-scanning with
    sockets and check the port state?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`socket`模块的哪种方法允许您使用套接字实现端口扫描并检查端口状态？'
- en: What exception of the `socket` module allows you catch exceptions related to
    the expiration of waiting times?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`socket`模块的哪个异常允许您捕获与等待时间到期相关的异常？'
- en: What exception of the `socket` module allows you catch errors during the search
    for information about IP addresses?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`socket`模块的哪个异常允许您捕获在搜索有关IP地址的信息时发生的错误？'
- en: What exception of the socket `module` allows you catch generic input and output
    errors and communications?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`socket`模块的哪个异常允许您捕获通用输入和输出错误以及通信？'
- en: Further reading
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'In these links, you will find more information about the mentioned tools and
    the official Python documentation for some of the commented modules:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些链接中，您将找到有关提到的工具和一些评论模块的官方Python文档的更多信息：
- en: '[https://wiki.python.org/moin/HowTo/Sockets](https://wiki.python.org/moin/HowTo/Sockets)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://wiki.python.org/moin/HowTo/Sockets](https://wiki.python.org/moin/HowTo/Sockets)'
- en: '[https://docs.python.org/2/library/socket.html](https://docs.python.org/2/library/socket.html)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/2/library/socket.html](https://docs.python.org/2/library/socket.html)'
- en: '[https://docs.python.org/3/library/socket.html](https://docs.python.org/3/library/socket.html)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/socket.html](https://docs.python.org/3/library/socket.html)'
- en: '[https://www.geeksforgeeks.org/socket-programming-python/](https://www.geeksforgeeks.org/socket-programming-python/)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.geeksforgeeks.org/socket-programming-python/](https://www.geeksforgeeks.org/socket-programming-python/)'
- en: '[https://realpython.com/python-sockets/](https://realpython.com/python-sockets/)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://realpython.com/python-sockets/](https://realpython.com/python-sockets/)'
- en: What's New in Sockets for Python 3.7: [https://www.agnosticdev.com/blog-entry/python/whats-new-sockets-python-37](https://www.agnosticdev.com/blog-entry/python/whats-new-sockets-python-37)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.7中套接字的新功能：[https://www.agnosticdev.com/blog-entry/python/whats-new-sockets-python-37](https://www.agnosticdev.com/blog-entry/python/whats-new-sockets-python-37)
