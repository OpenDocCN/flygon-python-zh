- en: Order Microservice
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订单微服务
- en: In this chapter, we are going to extend the web application that we implemented
    in [Chapter 7](a8e0af3b-67d9-4649-986b-041d136af0e8.xhtml), *Online Video Game
    Store with Django*. I don't know if you noticed, but there are a few important
    things missing in that project. The first is the ability to submit an order. As
    of right now, users can browse products and add items to the shopping cart; however,
    there's no way of sending the order and completing the purchase.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展我们在[第7章](a8e0af3b-67d9-4649-986b-041d136af0e8.xhtml)中实现的Web应用程序，*使用Django创建在线视频游戏商店*。我不知道您是否注意到，在该项目中有一些重要的东西缺失。首先是提交订单的能力。就目前而言，用户可以浏览产品并将商品添加到购物车；但是，没有办法发送订单并完成购买。
- en: Another item that is missing is a page where the users of our application will
    be able to see all the orders that have been sent, as well as a history of their
    orders.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺失的项目是我们应用程序的用户能够查看已发送的所有订单以及其订单历史的页面。
- en: With that said, we are going to create a microservice called *order,* which will
    do everything related to orders made on the site. It will receive orders, update
    orders, and so on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，我们将创建一个名为*order*的微服务，它将处理网站上的所有订单相关事务。它将接收订单，更新订单等等。
- en: 'In this chapter, you will learn:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学到：
- en: The basics of how to create microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建微服务的基础知识
- en: How to use the Django REST Framework to create RESTful APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Django REST框架创建RESTful API
- en: How to consume the services and integrate them with other applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用服务并将其与其他应用程序集成
- en: How to write tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写测试
- en: How to deploy an application on AWS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在AWS上部署应用程序
- en: How to run our web application with Gunicorn behind the HTTP proxy `nginx`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Gunicorn在HTTP代理`nginx`后运行我们的Web应用程序
- en: So, let's get started!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧！
- en: Setting up the environment
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: 'Like all the previous chapters, we are going to start off this chapter by setting
    up the environment that we need to develop our services on. Let''s start by creating
    our working directory:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的所有章节一样，我们将从设置我们需要在其上开发服务的环境开始这一章。让我们首先创建我们的工作目录：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we create our virtual environment with `pipenv`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`pipenv`创建我们的虚拟环境：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you don't know how to use `pipenv`, in the section *Setting up the environment*
    in [Chapter 4](2223dee0-d5de-417e-9ca9-6bf4a6038cb6.xhtml), *Exchange Rates and
    the Currency Conversion Tool,* there is a very good introduction about how to
    get started with `pipenv`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不知道如何使用`pipenv`，在[第4章](2223dee0-d5de-417e-9ca9-6bf4a6038cb6.xhtml)的*设置环境*部分，*汇率和货币转换工具*中，有一个非常好的介绍，介绍了如何开始使用`pipenv`。
- en: 'With the virtual environment created, we need to install the project dependencies.
    For this project, we are going to install Django and the Django REST Framework:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 创建虚拟环境后，我们需要安装项目依赖项。对于这个项目，我们将安装Django和Django REST框架：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The reason that we are using Django and the Django REST Framework instead of
    a simpler framework like Flask is that the main idea of this project is to provide
    a separation of concerns, creating a microservice that will handle orders made
    in the online game store that we developed in the previous chapter. We don't want
    to only provide APIs to be consumed by the web application. It would be great
    to have a simple website so that we can list the orders, see the details of each
    order, and also perform updates such as changing the order's status.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Django和Django REST框架而不是像Flask这样的简单框架的原因是，这个项目的主要目的是提供关注点的分离，创建一个将处理在前一章中开发的在线游戏商店中的订单的微服务。我们不仅希望提供供Web应用程序消费的API。最好有一个简单的网站，以便我们可以列出订单，查看每个订单的详细信息，并执行更新，如更改订单状态。
- en: As you saw in the previous chapter, Django already has a very powerful and flexible
    admin UI that we can customize to provide that kind of functionality to our users--all
    without spending too much time developing a web application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一章中看到的，Django已经拥有一个非常强大和灵活的管理界面，我们可以自定义以向用户提供这种功能，而无需花费太多时间开发Web应用程序。
- en: 'After installing the dependencies, your `Pipfile` should look as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 安装依赖项后，您的`Pipfile`应如下所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Perfect! Now, we can start a new Django project. We are going to create the
    project using the `django-admin` tool. Let''s go ahead and create a project called
    `order`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在，我们可以开始一个新的Django项目。我们将使用`django-admin`工具创建项目。让我们继续创建一个名为`order`的项目：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With the project created, we are going to create a Django app. For this project,
    we are going to create just one app that is going to be called `main`. First,
    we change the directory to the service directory:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，我们将创建一个Django应用程序。对于这个项目，我们将只创建一个名为`main`的应用程序。首先，我们将更改目录到服务目录：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And again, we use the `django-admin` tool to create an app:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次使用`django-admin`工具创建一个应用程序：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After creating the Django app, your project structure should look similar to
    the following structure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Django应用程序后，您的项目结构应该类似于以下结构：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next up, we are going to start creating the model for our service.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始创建我们服务的模型。
- en: Creating the service models
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务模型
- en: 'In the first part of the order service, we are going to create the model that
    will store data about the order coming from the online video game store. Let''s
    go ahead and open the `models.py` file in the main app directory and start adding
    the model:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在订单服务的第一部分，我们将创建一个模型，用于存储来自在线视频游戏商店的订单数据。让我们打开主应用程序目录中的`models.py`文件，并开始添加模型：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will create a class called `OrderCustomer` that inherits from `Model`, and
    define three properties; the `customer_id`, which will correspond to the customer
    ID in the online game store, the `name` of the customer, and lastly, the `email`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`OrderCustomer`的类，它继承自`Model`，并定义三个属性；`customer_id`，它将对应于在线游戏商店中的客户ID，客户的`name`，最后是`email`。
- en: 'Then, we will create the model that will store information about the order:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建存储订单信息的模型：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Order` class inherits from `Model`, and we start this class by adding a
    tuple containing the status that the orders in our application can have. We also
    define a foreign key, `order_customer`, which will create the relationship between
    the `OrderCustomer` and `Order`. It is then time to define other fields, starting
    with `total`, which is the total purchase value of that order. We then have two
    datetime fields; `created_at`, which is the date that the order has been submitted
    by the customer, and `last_update`, which is a field that is going to be used
    when we want to know when the order has a status update.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order`类继承自`Model`，我们通过添加一个包含应用中订单状态的元组来开始这个类。我们还定义了一个外键`order_customer`，它将创建`OrderCustomer`和`Order`之间的关系。然后是定义其他字段的时间，从`total`开始，它是该订单的总购买价值。然后有两个日期时间字段；`created_at`，这是顾客提交订单的日期，`last_update`，这是在我们想知道订单何时有状态更新时将要使用的字段。'
- en: When adding `auto_now_add` to a `DateTimeField`, Django uses the `django.utils.timezone.now`
    function, which will return the current `datetime` object with timezone information.
    DateField uses `datetime.date.today()`, which does not contain timezone information.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`auto_now_add`添加到`DateTimeField`时，Django使用`django.utils.timezone.now`函数，该函数将返回带有时区信息的当前`datetime`对象。DateField使用`datetime.date.today()`，它不包含时区信息。
- en: 'The last model that we are going to create is `OrderItems`. This will hold
    items belonging to an order. We will define it like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要创建的最后一个模型是`OrderItems`。这将保存属于订单的项目。我们将像这样定义它：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we also define a `Meta` class so we can set some metadata to the model.
    In this case, we are setting the `verbose_name_plural` to `Order items` so that
    it looks correctly spelled in the Django admin UI. Then, we define `product_id`,
    `name`, `quantity`, and `price_per_unit`, which refer to the `Game` model in the
    online video game store.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还定义了一个`Meta`类，以便我们可以为模型设置一些元数据。在这种情况下，我们将`verbose_name_plural`设置为`Order
    items`，以便在Django管理界面中正确拼写。然后，我们定义了`product_id`，`name`，`quantity`和`price_per_unit`，它们指的是在线视频游戏商店中的`Game`模型。
- en: Lastly, we have the item quantity and the foreign key `Order`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有项目数量和外键`Order`。
- en: 'Now, we need to edit the `settings.py` file in `microservices/order/order`
    directory and add the main app to `INSTALLED_APPS`. It should look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要编辑`microservices/order/order`目录中的`settings.py`文件，并将主应用程序添加到`INSTALLED_APPS`中。它应该是这样的：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The only thing left is to create and apply the database migrations. First,
    we run the command `makemigrations`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的就是创建和应用数据库迁移。首先，我们运行`makemigrations`命令：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And `migrate` to apply the changes to the database:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`迁移`将更改应用到数据库：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Creating the model's managers
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型的管理器
- en: To make our application more readable and not clutter the endpoints with a lot
    of business logic, we are going to create managers for our model classes. If you
    followed the previous chapter, you should be very familiar with this. In a nutshell,
    managers are an interface that provide query operations to Django models.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序更易读，不要在端点中充斥着大量业务逻辑，我们将为我们的模型类创建管理器。如果您遵循了上一章，您应该对此非常熟悉。简而言之，管理器是为Django模型提供查询操作的接口。
- en: By default, Django adds a manager to every model; it is stored on a property
    named objects. The default manager that Django adds to the models is sometimes
    sufficient and there's no need to create a custom manager, but it is a good practice
    to keep all database-related code within the model. This will make our code more
    consistent, readable, and easier to test and maintain.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Django为每个模型添加一个管理器；它存储在名为objects的属性上。Django添加到模型的默认管理器有时是足够的，不需要创建自定义管理器，但是将所有与数据库相关的代码保持在模型内是一个好习惯。这将使我们的代码更一致、可读，并且更易于测试和维护。
- en: In our case, the only model we are interested in creating is a custom model
    manager called Order, but before we start implementing the order manager, we need
    to create a few helper classes. The first class that we need to create is a class
    that will define custom exceptions that may occur when performing queries on our
    database. Of course, we could use the exceptions that are already defined in the
    standard library, but it is always a good practice to create exceptions that make
    sense within the context of your application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们感兴趣创建的唯一模型是名为Order的自定义模型管理器，但在我们开始实现订单管理器之前，我们需要创建一些辅助类。我们需要创建的第一个类是一个将定义在执行数据库查询时可能发生的自定义异常的类。当然，我们可以使用标准库中已经定义的异常，但是在应用程序的上下文中创建有意义的异常总是一个好习惯。
- en: The three exceptions that we are going to create are `InvalidArgumentError`,
    `OrderAlreadyCompletedError`, and `OrderCancellationError`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要创建的三个异常是`InvalidArgumentError`，`OrderAlreadyCompletedError`和`OrderCancellationError`。
- en: 'The exception `InvalidArgumentError` will be raised when invalid arguments
    are passed to the functions that we are going to define in the manager, so let''s
    go ahead and create a file called `exceptions.py` in the main app directory with
    the following contents:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当将无效参数传递给我们将在管理器中定义的函数时，将引发异常`InvalidArgumentError`，因此让我们继续在主应用程序目录中创建一个名为`exceptions.py`的文件，并包含以下内容：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we define a class called `InvalidArgumentError` that inherits from `Exception`,
    and the only thing we do in it is override the constructor and receive an argument
    called `argument_name`. With this argument, we can specify what caused the exception
    to be raised.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`InvalidArgumentError`的类，它继承自`Exception`，并且我们在其中唯一要做的事情是重写构造函数并接收一个名为`argument_name`的参数。通过这个参数，我们可以指定引发异常的原因。
- en: We will also customize the exception message, and lastly, we will call the constructor
    on the superclass.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将自定义异常消息，最后，我们将在超类上调用构造函数。
- en: 'We are also going to create an exception that will be raised when we try to
    cancel an order that has the status as canceled, and also when we try to set the
    status of an order to completed when the order is already completed:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建一个异常，当我们尝试取消状态为已取消的订单时，将引发异常，以及当我们尝试将订单的状态设置为已完成时，订单已经完成时：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we are going to add two more custom exceptions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将添加另外两个自定义异常：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These two classes don't do too much. They only inherit from `Exception`. We
    will configure and customize a message for each exception and pass it over to
    the super class initializer. The value of adding custom exception classes is that
    it will improve the readability and maintainability of our applications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类并没有做太多事情。它们只是从`Exception`继承。我们将为每个异常配置和自定义消息，并将其传递给超类初始化程序。自定义异常类的价值在于它将提高我们应用程序的可读性和可维护性。
- en: 'Great! There is only one more thing we need to add before starting with the
    manager. We will create functions in the model manager that will return data filtered
    by status. As you can see, in the definition of the `Order` model, we defined
    the status like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！在开始管理之前，我们只需要添加一件事。我们将在模型管理器中创建函数，该函数将返回按状态过滤的数据。正如您所看到的，在`Order`模型的定义中，我们定义了状态如下：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Which means that if we want to get all the orders with a status of `Completed`,
    we would need to write something similar to the following line:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果我们想要获取所有状态为`Completed`的订单，我们需要编写类似以下行的内容：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There''s only one problem with this code, can you guess what? If you guessed
    that *magic* number, `5`, you are absolutely right! Imagine how frustrated our
    colleagues would be if they needed to maintain this code and see only the number
    `5` there and have no idea what 5 actually means. Because of this, we are going
    to create an enumeration that we can use to express the different statuses. Let''s
    create a file called `status.py` in the `main` app directory and add the following
    enumeration:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码只有一个问题，你能猜到是什么吗？如果你猜到了*魔法*数字`5`，那你绝对是对的！想象一下，如果我们的同事需要维护这段代码，并且只看到那里的数字`5`，并不知道5实际上代表什么，他们会有多沮丧。因此，我们将创建一个枚举，以便用来表示不同的状态。让我们在`main`应用程序目录中创建一个名为`status.py`的文件，并添加以下枚举：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So, now, when we need to get all the orders with a `Completed` status, we can
    do:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，当我们需要获取所有状态为`Completed`的订单时，我们可以这样做：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Much better!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了！
- en: 'Now, let''s create the model manager for it. Create a file called `managers.py`
    in the mail app directory, and we can start by adding a few imports:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为其创建模型管理器。在邮件应用程序目录中创建一个名为`managers.py`的文件，我们可以开始添加一些导入：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we define the `OrderManager` class and the first method called `set_status`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义`OrderManager`类和第一个名为`set_status`的方法：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This method takes two parameters, order, and status. The `order` is an object
    of type `Order` and the status is an item of the `Status` enumeration that we
    created previously.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法需要两个参数，订单和状态。`order`是`Order`类型的对象，状态是我们之前创建的`Status`枚举的一个项目。
- en: We start this method by validating the arguments and raising the corresponding
    exception. First, we validate if the fields have a value and are the correct type.
    If the validation fails, it will raise an `InvalidArgumentError`. Then, we check
    if the order that we are trying to set the status for is already completed; in
    this case, we cannot change it anymore, so we raise an `OrderAlreadyCompletedError`.
    If all the arguments are valid, we set the order's status and save.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过验证参数并引发相应的异常来开始这种方法。首先，我们验证字段是否具有值并且是正确的类型。如果验证失败，它将引发`InvalidArgumentError`。然后，我们检查我们正在为其设置状态的订单是否已经完成；在这种情况下，我们无法再更改它，因此我们引发`OrderAlreadyCompletedError`。如果所有参数都有效，我们设置订单的状态并保存。
- en: 'In our application, we want to be able to cancel an order that is still not
    being processed; in other words, we will allow orders to be canceled only if the
    status is `Received`. Here is what the `cancel_order` method should look like:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们希望能够取消尚未处理的订单；换句话说，我们只允许在状态为`Received`时取消订单。`cancel_order`方法应该如下所示：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method only gets the `order` argument, and first, we need to check if the
    order object is valid and raise an `InvalidArgumentError` if it is invalid. Then,
    we check if the order's status is `not Received`. In this case, we raise an `OrderCancellationError`
    exception. Otherwise, we go ahead and call the `set_status` method, passing `Status.Cancelled` as
    an argument.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法只获取`order`参数，首先，我们需要检查订单对象是否有效，并在无效时引发`InvalidArgumentError`。然后，我们检查订单的状态是否为`not
    Received`。在这种情况下，我们引发`OrderCancellationError`异常。否则，我们继续调用`set_status`方法，传递`Status.Cancelled`作为参数。
- en: 'We also need to get a list of all orders for a given customer:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要获取给定客户的所有订单列表：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `get_all_orders_by_customer` method gets the `customer_id` as an argument. Then,
    we use the filter function to filter orders by the `customer_id` and we also order
    it by status; the orders that are still being processed will be on the top of
    the QuerySet.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_all_orders_by_customer`方法将`customer_id`作为参数。然后，我们使用filter函数来按`customer_id`过滤订单，同时按状态排序；仍在处理中的订单将位于QuerySet的顶部。'
- en: In case the `customer_id` is invalid, for example, if we pass a string instead
    of an integer, a `ValueError` exception will be raised. We catch this exception
    and raise our custom exception `InvalidArgumentError`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`customer_id`无效，例如，如果我们传递的是字符串而不是整数，则会引发`ValueError`异常。我们捕获此异常并引发我们的自定义异常`InvalidArgumentError`。
- en: 'The financial department of our online video game store had the requirement
    of getting a list of all complete and incomplete orders for a specific user, so
    let''s go ahead and add some methods for it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在线视频游戏商店的财务部门要求获取特定用户的所有完整和不完整订单列表，因此让我们为其添加一些方法：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first method, `get_customer_incomplete_orders`, gets an argument called `customer_id`.
    It is like the previous method; we will catch a `ValueError` exception in case
    the `customer_id` is invalid, and raise an `InvalidArgumentError`. The interesting
    part of this method is the filter. Here, we use a `Q()` object, which encapsulates
    an SQL expression in the form of a `Python` object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法`get_customer_incomplete_orders`获取一个名为`customer_id`的参数。就像之前的方法一样；我们将捕获`ValueError`异常，以防`customer_id`无效，并引发`InvalidArgumentError`。这种方法的有趣之处在于过滤器。在这里，我们使用`Q()`对象，它封装了一个`Python`对象形式的SQL表达式。
- en: Here, we have `~Q(status=Status.Completed.value)`, which is the '`not`' operator,
    which is the same as saying the status is not `Status.Complete`. We also filter
    `order_customer_id` to check if it's equal to the method's `customer_id` argument,
    and lastly, we order the QuerySet by status.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`~Q(status=Status.Completed.value)`，这是“not”运算符，等同于状态不是`Status.Complete`。我们还过滤`order_customer_id`以检查它是否等于方法的`customer_id`参数，最后，我们按状态对QuerySet进行排序。
- en: '`get_customer_completed_orders` is basically the same, but this time, we filter
    orders that have a status equal to `Status.Completed`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_customer_completed_orders`基本上是一样的，但这次我们过滤状态等于`Status.Completed`的订单。'
- en: The `Q()` object allows us to write much more complex queries making use of
    `|` (OR) and `&` (AND) operators.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Q()`对象允许我们编写更复杂的查询，利用`|`（或）和`&`（与）运算符。'
- en: 'Next, every department that is responsible for taking care of the order life
    cycle wants an easy way to get orders at a certain stage; for example, the workers
    responsible for shipping the games want to get a list of all orders that have
    a status equal to `Payment Complete` so they can ship these orders to the customers.
    So, we need to add a method that will do just that:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，负责订单生命周期的每个部门都希望有一种简单的方式来获取处于特定阶段的订单；例如，负责发货游戏的工作人员希望获取所有状态等于“支付完成”的订单列表，以便将这些订单发货给客户。因此，我们需要添加一个方法来实现这一点：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is a very simple method; here, we get the status as an argument. We check
    if the status is valid; if not, we raise an `InvalidArgumentError`. Otherwise,
    we continue and filter the orders by status.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的方法；在这里，我们将状态作为参数。我们检查状态是否有效；如果无效，我们引发`InvalidArgumentError`。否则，我们继续并按状态过滤订单。
- en: 'Another requirement from our finance department is to get a list of orders
    in a given date range:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们财务部门的另一个要求是获取特定日期范围内的订单列表：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we get two parameters, `start_date` and `end_date`. As with all the other
    methods, we start by checking if these arguments are valid; in this case, the
    arguments cannot be `None` and have to be an instance of the `Datetime` object.
    If any of the fields are invalid, an `InvalidArgumentError` will be raised. When
    the arguments are valid, we filter the orders using the `created_at` field and
    we also use this special syntax, `created_at__range`, which means that we are
    going to pass a date range and it will be used as a filter. Here, we are passing
    `start_date` and `end_date`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们得到两个参数`start_date`和`end_date`。与所有其他方法一样，我们首先检查这些参数是否有效；在这种情况下，参数不能是`None`，并且必须是`Datetime`对象的实例。如果任何字段无效，将引发`InvalidArgumentError`。当参数有效时，我们使用`created_at`字段过滤订单，还使用了特殊的语法`created_at__range`，这意味着我们将传递一个日期范围，并将其用作过滤器。在这里，我们传递`start_date`和`end_date`。
- en: 'There is just one method that might be interesting to implement and it can
    add value to the administrators of our application. The idea here is to add a
    method that, when called, automatically changes the order to the next status:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有一个有趣的方法可以实现，并且可以为我们应用程序的管理员增加价值。这里的想法是添加一个方法，当调用时，自动将订单更改为下一个状态：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This method gets just one argument, the order. We check if the order is valid,
    and if it is invalid, we raise an `InvalidArgumentError`. We also want to make
    sure that once the order gets to the `Completed` status, it can no longer be changed.
    So, we check if the order is of the status `Completed`, then we raise an `OrderAlreadyCompleted`
    exception. Lastly, we add `1` to the current status and save the object.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只接受一个参数，即订单。我们检查订单是否有效，如果无效，我们引发`InvalidArgumentError`。我们还希望确保一旦订单达到“已完成”状态，就不能再更改。因此，我们检查订单是否处于“已完成”状态，然后引发`OrderAlreadyCompleted`异常。最后，我们将当前状态加1并保存对象。
- en: 'Now, we can change our `Order` model so that it makes use of the `OrderManager`
    that we just created. Open the model.py file in the main app directory, and at
    the end of the `Order` class, add the following line:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更改我们的`Order`模型，使其使用我们刚刚创建的`OrderManager`。打开主应用程序目录中的model.py文件，在`Order`类的末尾添加以下行：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So, now we can access all the methods that we defined in the `OrderManager`
    through `Order.objects`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过`Order.objects`访问我们在`OrderManager`中定义的所有方法。
- en: Next up, we are going to add tests to our model manager methods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们的模型管理器方法添加测试。
- en: Learning to test
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习测试
- en: So far in this book, we haven't covered how to create tests. Now is a good time
    to do that, so we are going to create tests for the methods that we created in
    the model manager.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们还没有涵盖如何创建测试。现在是一个很好的时机，所以我们将为模型管理器中创建的方法创建测试。
- en: Why do we need tests? The short answer to this question is that tests will allow
    us to know that the methods or functions are doing the right thing. The other
    reason (and one of the most important, in my opinion) is that tests give us more
    confidence when it comes to performing changes in the code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么需要测试？对这个问题的简短回答是，测试将使我们知道方法或函数是否做了正确的事情。另一个原因（也是我认为最重要的原因之一）是，测试在进行代码更改时给我们更多的信心。
- en: Django has great tools out of the box for creating unit and integration tests,
    and combined with frameworks like Selenium, it is possible to basically test all
    of our application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Django在开箱即用的情况下提供了出色的工具来创建单元测试和集成测试，并结合像Selenium这样的框架，可以基本上测试我们应用的所有部分。
- en: With that said, let's create our first tests. Django creates a file called `test.py`
    in the `app` directory when creating a new Django app. You can write your tests
    in there, or if you prefer to keep the project more organized by separating the
    tests into multiple files, you can remove that file and create a directory called
    `tests` and place all your tests files in there. Since we are only going to create
    tests for the Order model manager, we are going to keep all the tests in the `tests.py`
    file that Django created for us.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这些，让我们创建我们的第一个测试。当创建一个新的Django应用程序时，Django会在`app`目录中创建一个名为`test.py`的文件。您可以在其中编写您的测试，或者如果您更喜欢通过将测试分成多个文件来使项目更有组织性，您可以删除该文件并创建一个名为`tests`的目录，并将所有测试文件放在其中。由于我们只打算为Order模型管理器创建测试，我们将把所有测试都放在Django为我们创建的`tests.py`文件中。
- en: Creating the test files
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建测试文件
- en: 'Open the `test.py` file and let''s start by adding a few imports:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`test.py`文件，让我们首先添加一些导入：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Great! We start by importing the relative delta function so we can easily perform
    date operations, like adding days or months to a date. This will be very helpful
    when testing the methods that get orders for a certain period of time.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！我们首先导入相对增量函数，这样我们就可以轻松进行日期操作，比如向日期添加天数或月数。这在测试按一定时间段获取订单的方法时将非常有帮助。
- en: Now, we import some Django-related things. First is the `TestCase` class, which
    is a subclass of `unittest.TestCase`. Since we are going to write tests that will
    interact with the database, it is a good idea to use `django.tests.TestCase` instead
    of `unittest.TestCase`. Django's `TestCase` implementation will make sure that
    your test is running within a transaction to provide isolation. This way, we will
    not have unpredictable results when running the test because of data created by
    another test in the test suite.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们导入一些与Django相关的内容。首先是`TestCase`类，它是`unittest.TestCase`的子类。由于我们将编写与数据库交互的测试，最好使用`django.tests.TestCase`而不是`unittest.TestCase`。Django的`TestCase`实现将确保您的测试在事务中运行，以提供隔离。这样，当运行测试时，由于测试套件中另一个测试创建的数据，我们将不会有不可预测的结果。
- en: We also import some of the model classes that we are going to use in our test,
    the `Order`, the `OrderCustomer` models, and also the Status class when we are
    going to test the method that changes order statuses.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还导入了一些我们将在测试中使用的模型类，`Order`，`OrderCustomer`模型，以及在测试更改订单状态的方法时使用的Status类。
- en: When writing tests for your application, we don't want to only test the *good* scenarios,
    we also want to test when things go wrong, and bad arguments are passed to the
    functions and methods that are being tested. For this reason, we are importing
    our custom error classes, so we can make sure that the right exception is being
    raised in the right situation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在为应用程序编写测试时，我们不仅要测试*好*的情况，还要测试当出现问题时，当错误的参数传递给正在测试的函数和方法时。因此，我们导入我们自定义的错误类，以确保在正确的情况下引发正确的异常。
- en: 'Now that we have the imports in place, it is time to create the class and the
    method that will set up data for our tests:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了必要的内容，是时候创建类和方法来为我们的测试设置数据了：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we create a class called `OrderModelTestCase`, inheriting from the `django.test.TestCase`.
    Then, we define the `setUpTestData` method, which will be the method that will
    be responsible for setting up the data that will be used by each test.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`OrderModelTestCase`的类，继承自`django.test.TestCase`。然后，我们定义了`setUpTestData`方法，这个方法将负责设置每个测试将使用的数据。
- en: Here, we create two users; the first one has two orders and one of the orders
    is set to `Completed`. The second user has only one order.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个用户；第一个用户有两个订单，其中一个订单状态设置为`Completed`。第二个用户只有一个订单。
- en: Testing the cancel order function
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试取消订单功能
- en: 'The first method that we are going to test is the `cancel_orders` method. As
    the name says, it will cancel an order. There a few things we want to test in
    this method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要测试的第一个方法是`cancel_orders`方法。顾名思义，它将取消一个订单。在这个方法中，有一些我们想要测试的东西：
- en: The first test is quite straightforward; we only want to test if we can cancel
    an order, setting its status to `Cancelled`
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个测试非常直接；我们只想测试是否可以取消订单，将其状态设置为`Cancelled`。
- en: The second test is that it shouldn't be possible to cancel orders that have
    not been received; in other words, only the orders that have the current status
    set to `Received` can be canceled
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个测试是不应该取消尚未收到的订单；换句话说，只有当前状态设置为`Received`的订单才能被取消。
- en: We need to test if the correct exception is raised in case we pass an invalid
    argument to the `cancel_order` method
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要测试如果将无效参数传递给`cancel_order`方法时是否会引发正确的异常。
- en: 'With that said, let''s add our tests:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这些，让我们添加我们的测试：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first test, `test_cancel_order`, starts off by getting an order with ID
    1\. We assert that the returned value is not `None` using the `assertIsNotNone`
    function, and we also use the function `assertEqual` to make sure that the order
    has the status '`Received`'.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试`test_cancel_order`，首先获取ID为1的订单。我们使用`assertIsNotNone`函数断言返回的值不是`None`，同时使用`assertEqual`函数确保订单的状态是`Received`。
- en: Then, we call the `cancel_order` method from the order model manager passing
    the order, and lastly, we use the `assertEqual` function again to verify that
    the order's status is in fact changed to `Cancelled`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从订单模型管理器中调用`cancel_order`方法传递订单，最后，我们再次使用`assertEqual`函数来验证订单的状态是否确实更改为`Cancelled`。
- en: The second test, `test_cancel_complated_order`, starts by getting the order
    with ID equal to `2`; remember that we have set this order with the `Completed` status.
    Then, we do the same thing as the previous test; we verify that the order is not
    equal to `None`, and we verify that the status is set to `Complete`. Finally,
    we use the `assertRaises` function to test that the correct exception is raised
    if we try to cancel an order that is already cancelled; in this case, an exception
    of type `OrderCancellationError` will be raised.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试`test_cancel_complated_order`从获取ID等于`2`的订单开始；请记住，我们已将此订单设置为`Completed`状态。然后，我们做与上一个测试相同的事情；验证订单不等于`None`，并验证状态设置为`Complete`。最后，我们使用`assertRaises`函数测试，如果我们尝试取消已取消的订单，将引发正确的异常；在这种情况下，将引发`OrderCancellationError`类型的异常。
- en: Lastly, we have the `test_cancel_order_with_invalid_argument` function, which
    will test if the correct exception will be raised if we pass an invalid argument
    to the `cancel_order` function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`test_cancel_order_with_invalid_argument`函数，它将测试如果我们向`cancel_order`函数传递无效参数，是否会引发正确的异常。
- en: Testing the get all orders function
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试获取所有订单的功能
- en: 'Now, we are going to add tests to the `get_all_orders_by_customer` method.
    For this method, we need to test:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为`get_all_orders_by_customer`方法添加测试。对于这个方法，我们需要测试：
- en: If the correct number of orders is returned when given a customer ID
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当给定顾客ID时，返回正确数量的订单
- en: If the correct exception is raised when passing an invalid argument to the method
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当向方法传递无效参数时引发正确的异常
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The tests for the `get_all_orders_by_customer` method are quite simple. In the
    first test, we fetch the orders for the customer with ID `1` and test if the returned
    number of items is equal to `2`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_all_orders_by_customer`方法的测试非常简单。在第一个测试中，我们获取ID为`1`的顾客的订单，并测试返回的项目数量是否等于`2`。'
- en: In the second test, we assert if calling `get_all_orders_by_customer` with an
    invalid argument, in fact, raises an exception of type `InvalidArgumentError`.
    In this case, the test will successfully pass.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个测试中，我们断言调用`get_all_orders_by_customer`时使用无效参数，实际上会引发`InvalidArgumentError`类型的异常。在这种情况下，测试将成功通过。
- en: Getting customer's incomplete orders
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取顾客的不完整订单
- en: 'The `get_customer_incomplete_orders` method returns all the orders with the
    statuses that are different from `Completed` given a customer ID. For this test,
    we need to verify that:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_customer_incomplete_orders`方法返回给定顾客ID的状态与`Completed`不同的所有订单。对于这个测试，我们需要验证：'
- en: The method returns the correct number of items and also if the item returned
    does not have a status equal to `Completed`
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法返回正确数量的项目，以及返回的项目是否没有状态等于`Completed`
- en: We are going to test if an exception is raised when an invalid value is passed
    as an argument to this method
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将测试当向该方法传递无效值时是否引发异常
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The test `test_get_customer_incomplete_orders` starts off by calling the  `get_customer_incomplete_orders` function
    and passing as an argument a customer ID equal to `1`. Then, we verify that the
    number of returned items is correct; in this case, there's only one incomplete
    order, so it should be `1`. Lastly, we check if the item that was returned in
    fact has a status different to `Completed`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`test_get_customer_incomplete_orders`从调用`get_customer_incomplete_orders`函数开始，并将顾客ID设置为`1`作为参数传递。然后，我们验证返回的项目数量是否正确；在这种情况下，只有一个不完整的订单，所以应该是`1`。最后，我们检查返回的项目是否实际上具有与`Completed`不同的状态。
- en: The other test, exactly like the previous one testing that tested exceptions,
    just calls the method and asserts that the correct exception has been raised.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个测试与之前测试异常的测试完全相同，只是调用该方法并断言已引发了正确的异常。
- en: Getting customer's completed orders
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取顾客的已完成订单
- en: 'Next, we are going to test `get_customer_completed_order`. This method, as
    the name says, returns all the orders that have a status of `Completed` for a
    given customer. Here, we will test the same scenarios as `get_customer_incompleted_orders`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将测试`get_customer_completed_order`。这个方法，正如其名称所示，返回给定顾客的所有状态为`Completed`的订单。在这里，我们将测试与`get_customer_incompleted_orders`相同的场景：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: First, we call `get_customer_completed_orders`, passing a customer ID equal
    to `1`, and then we verify that the number of items returned is equal to `1`.
    To finish it up, we verify that the item that was returned has, in fact, a status
    set to `Completed`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`get_customer_completed_orders`，传递顾客ID等于`1`，然后验证返回的项目数量是否等于`1`。最后，我们验证返回的项目是否实际上具有状态设置为`Completed`。
- en: Getting orders by status
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按状态获取订单
- en: 'The `get_order_by_status` function returns a list of orders given a status.
    There are two scenarios we have to test here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_order_by_status`函数根据状态返回订单列表。这里有两种情况需要测试：'
- en: If the method returns the correct number of orders given a specific status
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该方法返回给定状态的正确数量的订单
- en: That the correct exception is raised when passing an invalid argument to the
    method
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当向方法传递无效参数时引发正确的异常
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Simple enough. The first test we call is `get_orders_by_status`, passing as
    an argument `Status.Received`. Then, we verify that only two orders are returned.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单。我们首先调用`get_orders_by_status`进行第一项测试，将`Status.Received`作为参数传递。然后，我们验证只有两个订单被返回。
- en: For the second test, for the `get_order_by_status` method, like the previous
    exceptions tests, run the method, passing an invalid argument and then verify
    that the exception of type `InvalidArgumentError` has been raised.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个测试，对于`get_order_by_status`方法，与之前的异常测试一样，运行该方法，传递无效参数，然后验证是否引发了`InvalidArgumentError`类型的异常。
- en: Getting orders by period
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按期获取订单
- en: 'Now, we are going to test the `get_order_by_period` method, which returns a
    list of orders given an initial and an end date. For this method, we are going
    to perform the following tests:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将测试`get_order_by_period`方法，该方法在给定初始日期和结束日期时返回订单列表。对于这个方法，我们将执行以下测试：
- en: Call the method, passing as arguments, and orders created within that period
    should be returned
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用该方法，传递参数，应返回在该期间创建的订单
- en: Call the method, passing as arguments valid dates where we know that no orders
    were created, which should return an empty result
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用方法，传递我们知道没有创建任何订单的有效日期，这应该返回一个空结果
- en: Test if an exception is raised when calling the method, passing an invalid start
    date
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试在调用方法时是否会引发异常，传递无效的开始日期
- en: Test if an exception is raised when calling the method, passing an invalid end
    date
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试在调用方法时是否会引发异常，传递无效的结束日期
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We start this method by creating `date_from`, which is the current date minus
    one day. Here, we use the `relativedelta` method of the `python-dateutil` package
    to perform date operations. Then, we define `date_to`, which is the current date
    plus two days.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建`date_from`方法来开始这个方法，它是当前日期减去一天。在这里，我们使用`python-dateutil`包的`relativedelta`方法执行日期操作。然后，我们定义`date_to`，它是当前日期加两天。
- en: Now that we have our period, we can pass these values as arguments to the `get_orders_by_period`
    method. In our case, we set up three orders, all created with the current date,
    so this method call should return exactly three orders.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的时间段，我们可以将这些值作为参数传递给`get_orders_by_period`方法。在我们的情况下，我们设置了三个订单，全部都是用当前日期创建的，因此这个方法调用应该返回确切的三个订单。
- en: Then, we define a different period where we know that there won't be any orders.
    The `date_from` function is defined with the current date plus three days, so `date_from`
    is the current date plus `1` month.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个我们知道不会有任何订单的不同时间段。`date_from`函数定义为当前日期加三天，因此`date_from`是当前日期加`1`个月。
- en: Calling the method again passing the new values of `date_from` and `date_to`
    should not return any orders.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 再次调用该方法，传递`date_from`和`date_to`的新值不应该返回任何订单。
- en: The last two tests for `get_orders_by_period` are the same as the exception
    tests that we implemented previously.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_orders_by_period`的最后两个测试与我们之前实现的异常测试相同。'
- en: Setting the order's next status
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置订单的下一个状态
- en: The next method from the `Order` model manager that we are going to create is
    the `set_next_status` method. The `set_next_status` method is just a method that
    can be used for convenience and it will set the next status of an order. If you
    remember, the `Status` enumeration that we created means that every item in the
    enumeration is set to `auto()`, which means that items in the enumeration will
    get a numeric sequential number as a value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的`Order`模型管理器的下一个方法是`set_next_status`方法。`set_next_status`方法只是一个方便使用的方法，它将设置订单的下一个状态。如果你记得，我们创建的`Status`枚举意味着枚举中的每个项目都设置为`auto()`，这意味着枚举中的项目将获得一个数字顺序号作为值。
- en: When we save an order in the database and set its status to, for example, `Status.Processing`,
    the value of the status field in the database will be `2`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将订单保存在数据库中并将其状态设置为，例如`Status.Processing`时，数据库中状态字段的值将为`2`。
- en: The function simply adds `1` to the current order's status, so it goes to the
    next status item unless the status is `Completed`; that's the last status of the
    order's lifecycle.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能只是将`1`添加到当前订单的状态，因此它转到下一个状态项目，除非状态是`Completed`；那是订单生命周期的最后状态。
- en: 'Now that we have refreshed our memories about how this method works, it is
    time to create the tests for it, and we will have to perform the following tests:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经刷新了关于这种方法如何工作的记忆，是时候为它创建测试了，我们将不得不执行以下测试：
- en: That the order gets the next status when `set_next_status` is called
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用`set_next_status`时，订单会获得下一个状态
- en: Test if an exception will be raised when calling `set_next_status` and passing
    as an argument an order with the status `Completed`
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试在调用`set_next_status`并传递状态为`Completed`的订单时是否会引发异常
- en: Test if an exception is raised when passing an invalid order as an argument
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试在传递无效订单作为参数时是否会引发异常
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first test, `test_set_next_status`, starts by getting the order with an
    ID equal to `1`. Then, it asserts that the order object is not equal to none,
    and we also assert that the value of the order's status is `Received`. Then, we
    call the `set_next_status` method, passing the `order` as an argument. Right after
    that, we assert again to make sure that the status has changed. The test will
    pass if the order's status is equals to `2`, which is `Processing` in the `Status`
    enumeration.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试`test_set_next_status`开始通过获取ID等于`1`的订单。然后，它断言订单对象不等于none，并且我们还断言订单状态的值为`Received`。然后，我们调用`set_next_status`方法，将订单作为参数传递。然后，我们再次断言以确保状态已经改变。如果订单的状态等于`2`，也就是`Status`枚举中的`Processing`，则测试将通过。
- en: The other two tests are very similar to the order test where we assert exceptions,
    but it is worth mentioning that the test `test_set_next_status_on_completed_order` asserts
    that if we try calling the `set_next_status` on an order that has a status equal
    to `Status.Completed`, then an exception of type `OrderAlreadyCompletedError`
    will be raised.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个测试与订单测试非常相似，我们断言异常，但值得一提的是测试`test_set_next_status_on_completed_order`断言，如果我们尝试在状态等于`Status.Completed`的订单上调用`set_next_status`，那么将引发`OrderAlreadyCompletedError`类型的异常。
- en: Setting the order's status
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置订单的状态
- en: 'Finally, we are going to implement the last tests of the `Order` model manager.
    We are going to create tests for the `set_status` method. The `set_status` method
    does exactly what the name implies; it will set a status for a given order. We
    need to perform the following tests:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现`Order`模型管理器的最后测试。我们将为`set_status`方法创建测试。`set_status`方法确实做了它的名字所暗示的事情；它将为给定的订单设置状态。我们需要执行以下测试：
- en: Set a status and verify that the order's status has really changed
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置状态并验证订单的状态是否真的已经改变
- en: Set the status in an order that is already completed; it should raise an exception
    of type `OrderAlreadyCompletedError`
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在已经完成的订单中设置状态；它应该引发`OrderAlreadyCompletedError`类型的异常
- en: Set the status in an order that is already canceled; it should raise an exception
    of type `OrderAlreadyCancelledError`
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在已经取消的订单中设置状态；它应该引发`OrderAlreadyCancelledError`类型的异常
- en: Call the `set_status` method using an invalid order; it should raise an exception
    of type `InvalidArgumentError`
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无效订单调用`set_status`方法；它应该引发`InvalidArgumentError`类型的异常
- en: Call the `set_status` method using an invalid status; it should raise an exception
    of type `InvalidArgumentError`
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无效状态调用`set_status`方法；它应该引发`InvalidArgumentError`类型的异常
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We are not going to go through all the tests where we are testing exceptions,
    because they are similar to the tests that we implemented previously, but it is
    worth going through the first test. On the test `test_set_status`, it will get
    the order with an ID equal to `1`, which as we defined in the `setUpTestData`,
    has a status equal to `Status.Received`. We call the `set_status` method passing
    the order and the new status as arguments, in this case, `Status.Processing`.
    After setting the new status, we just call `assertEquals` to make sure that the
    order's status in fact changed to `Status.Processing`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会遍历所有测试，因为它们测试异常的方式类似于我们之前实现的测试，但是值得浏览第一个测试。在`test_set_status`测试中，它将获取ID等于`1`的订单，正如我们在`setUpTestData`中定义的那样，其状态等于`Status.Received`。我们调用`set_status`方法，传递订单和新状态作为参数，在这种情况下是`Status.Processing`。设置新状态后，我们只需调用`assertEquals`来确保订单的状态实际上已更改为`Status.Processing`。
- en: Creating the order model serializer
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建订单模型序列化程序
- en: We now have everything we need to start creating out API endpoints. In this
    section, we are going to create endpoints for every method that we implemented
    in the `Order` manager.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一切我们需要开始创建API端点。在这一部分，我们将为`Order`管理器中实现的每个方法创建端点。
- en: For some of these endpoints, we are going to use the Django REST Framework.
    The advantage of using the Django REST Framework is that the framework includes
    a lot of out of the box features. It has different authentication methods, a really
    robust serialization of objects, and my favorite is that it will give you a web
    interface where you can browse the API, which also contains a large collection
    of base classes and mixins when you need to create class-based views.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其中一些端点，我们将使用Django REST框架。使用Django REST框架的优势在于该框架包含了许多开箱即用的功能。它具有不同的身份验证方法，对对象的序列化非常强大，我最喜欢的是它将为您提供一个Web界面，您可以在其中浏览API，还包含了大量的基类和混合类，当您需要创建基于类的视图时。
- en: So, let's dive right into it!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们马上开始吧！
- en: The first thing that we need to do at this point is to create serializer classes
    for the entities of our model, the `Order`, `OrderCustomer`, and `OrderItem`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要做的第一件事是为我们模型的实体创建序列化程序类，`Order`，`OrderCustomer`和`OrderItem`。
- en: 'Go ahead and create a file called `serializers.py` in the main `app` directory,
    and let''s start by adding a few import statements:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 继续在主`app`目录中创建一个名为`serializers.py`的文件，并让我们从添加一些导入语句开始：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We start by importing the `functools` module from the standard library; then,
    we import the serializer from the `rest_framework` module. We are going to use
    it to create our model serializers. Lastly, we will import the models that we
    are going to use to create the `serializers`, the `Order`, `OrderItems`, and `OrderCustomer`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从标准库中导入`functools`模块；然后，我们从`rest_framework`模块中导入序列化程序。我们将使用它来创建我们的模型序列化程序。最后，我们将导入我们将用来创建`序列化程序`的模型，`Order`，`OrderItems`和`OrderCustomer`。
- en: 'The first serializer that we are going to create is the `OrderCustomerSerializer`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要创建的第一个序列化程序是`OrderCustomerSerializer`：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `OrderCustomerSerializer` inherits from `ModelSerializer` and it is quite
    simple; it just defines some class metadata. We will set the model, the `OrderCustomer,`
    and also the property fields which will contain a tuple with the fields, that
    we are going to serialize.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderCustomerSerializer`继承自`ModelSerializer`，它非常简单；它只是定义了一些类元数据。我们将设置模型，`OrderCustomer`，还有将包含一个包含我们要序列化的字段的元组的属性字段。'
- en: 'Then, we create the `OrderItemSerializer`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建`OrderItemSerializer`：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `OrderItemSerializer` is pretty similar to the `OrderCustomerSerializer`.
    The class also inherits from `ModelSerializer` and defines a couple of metadata
    properties. The first one is a model, which we set to `OrderItems`, and then the
    fields with a tuple containing every model field that we want to serialize.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderItemSerializer`与`OrderCustomerSerializer`非常相似。该类也继承自`ModelSerializer`，并定义了一些元数据属性。第一个是模型，我们将其设置为`OrderItems`，然后是包含我们要序列化的每个模型字段的元组的字段。'
- en: 'The last serializer that we are going to create is the `OrderSerializer`, so
    let''s start by defining a class called `OrderSerializer`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要创建的最后一个序列化程序是`OrderSerializer`，所以让我们从定义一个名为`OrderSerializer`的类开始：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: First, we define two properties. The `items` property is set to `OrderItemSerializer`,
    which means that it will use that serializer when we need to serialize the JSON
    data that we are going to send when we want to add new orders. The `items` property
    refers to the items (the games) that an order contains. Here, we use only one
    keyword argument `(many=True)`. This will tell you that the serializer items will
    be an array.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义两个属性。`items`属性设置为`OrderItemSerializer`，这意味着当我们需要序列化JSON数据时，它将使用该序列化程序，当我们想要添加新订单时。`items`属性指的是订单包含的商品。在这里，我们只使用一个关键字参数`(many=True)`。这将告诉你，序列化程序的items将是一个数组。
- en: The status field is a little bit special; if you remember the status field in
    the `Order` model, it is defined as a `ChoiceField`. When we save an order in
    the database, that field will store the value `1` if the order has a status of `Received`,
    `2` if the status is `Processing`, and so on. When the consumers of our API call
    the endpoint to get orders, they will be interested in the name of the status
    and not the number.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 状态字段有点特殊；如果你还记得`Order`模型中的状态字段，它被定义为`ChoiceField`。当我们在数据库中保存订单时，该字段将存储值`1`，如果订单状态为`Received`，则存储值`2`，如果状态为`Processing`，依此类推。当我们的API的消费者调用端点获取订单时，他们将对状态的名称感兴趣，而不是数字。
- en: So, the solution to this problem is to define the field as `SerializeMethodField`,
    and then we are going to create a function called `get_status`, which will return
    the display name of the order's status. We are going to see what the implementation
    of the `get_status` method looks like in a short while.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，解决这个问题的方法是将字段定义为`SerializeMethodField`，然后我们将创建一个名为`get_status`的函数，它将返回订单状态的显示名称。我们很快就会看到`get_status`方法的实现是什么样子的。
- en: We also define the `order_customer` property, which is set to `OrderCustomerSerializer`,
    and that means that the framework will use the `OrderCustomerSerializer` class
    when trying to deserialize the JSON object we send when trying to add a new order.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了`order_customer`属性，它设置为`OrderCustomerSerializer`，这意味着在尝试添加新订单时，框架将使用`OrderCustomerSerializer`类来反序列化我们发送的JSON对象。
- en: 'Then, we define a `Meta` class, so that we can add some metadata information
    to the serializer class:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个`Meta`类，以便我们可以向序列化器类添加一些元数据信息：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first property, `depth`, specifies the depth of the relationships that should
    be traversed before the serialization. In this case, it is set to `1`, because
    when fetching an order object, we also want to have information about the customers
    and items. Like the other serializers, we set the model to `Order` and the fields
    property specifies which fields will be serialized and deserialized.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性`depth`指定了在序列化之前应该遍历的关系深度。在这种情况下，它设置为`1`，因为在获取订单对象时，我们还希望获取有关客户和商品的信息。与其他序列化器一样，我们将模型设置为`Order`，并且fields属性指定了哪些字段将被序列化和反序列化。
- en: 'Then, we implement the `get_status` method:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们实现`get_status`方法：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is the method that will get the display value for the `ChoiceField` status.
    This will override the default behavior and return the result of the `get_status_display()` function
    instead.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个将为`ChoiceField`状态获取显示值的方法。这将覆盖默认行为，并返回`get_status_display()`函数的结果。
- en: 'The `_created_order_item` method is just a helper method which we are going
    to use to create and prepare the order item''s objects prior to performing a bulk
    insert:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`_created_order_item`方法只是一个辅助方法，我们将使用它来创建和准备订单项对象，然后执行批量插入操作：'
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, we are going to get two arguments. The first argument will be a dictionary
    with the data about the `OrderItem` and an `order` argument with an object of
    type `Order`. First, we update the dictionary passed in the first argument, adding
    the `order` object, then we call the `OrderItem` constructor, passing the items
    as an argument in the `item` dictionary.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将获得两个参数。第一个参数将是一个包含有关`OrderItem`的数据的字典，以及一个类型为`Order`的对象的`order`参数。首先，我们更新传递给第一个参数的字典，添加`order`对象，然后我们调用`OrderItem`构造函数，将商品作为`item`字典的参数传递。
- en: 'I am going to show you what that''s used for a short while. Now that we have
    got to the core of this serializer, we are going to implement the `create` method,
    which will be a method that will be called automatically every time we call the
    serializer''s `save` method:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我马上就会向你展示它的用途。现在我们已经到了这个序列化器的核心，我们将实现`create`方法，这将是一个在每次调用序列化器的`save`方法时自动调用的方法：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'So, the create method will be called automatically when calling the `save`
    method, and it will get the `validated_data` as an argument. The `validated_date`
    is a validated, de-serialized order data. It will look similar to the following
    data:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当调用`save`方法时，`create`方法将被自动调用，并将`validated_data`作为参数。`validated_date`是经过验证的、反序列化的订单数据。它看起来类似于以下数据：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see, in this JSON, we are passing all the information at once. Here,
    we have the `order`, the `items` property, which is a list of order items, and
    the `order_customer`, which contains information about the customer who submitted
    the order.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在这个JSON中，我们一次性传递了所有信息。这里，我们有`order`，`items`属性，它是订单项的列表，以及`order_customer`，其中包含提交订单的客户的信息。
- en: Since we have to perform the creation of these objects individually, we first
    pop the `order_customer` and the `items` so we have three different objects. The
    first, `validated_customer`, will only contain data related to the person who
    made the order. The `validated_items` object will only contain data related to
    each item of the order, and finally, the `validated_data` object will only contain
    data related to the order itself.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们必须分别创建这些对象，我们首先弹出`order_customer`和`items`，所以我们有三个不同的对象。第一个`validated_customer`将只包含与下订单的人相关的数据。`validated_items`对象将只包含订单每个商品相关的数据，最后，`validated_data`对象将只包含订单本身的数据。
- en: 'After splitting the data, we can now start adding the objects. We start by
    creating an `OrderCustomer`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 拆分数据后，我们现在可以开始添加对象。我们首先创建一个`OrderCustomer`：
- en: '[PRE49]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we can create the order. The `Order` has a foreign key field called `order_customer`,
    which is the customer that is connected to that particular Order. What we need
    to do is create a new item in the `validated_data` dictionary with a key called `order_customer`,
    and set its value to the customer that we just created:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建订单。`Order`有一个外键字段叫做`order_customer`，它是与特定订单相关联的客户。我们需要在`validated_data`字典中创建一个名为`order_customer`的新项目，并将其值设置为我们刚刚创建的客户：
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Lastly, we are going to add  `OrderItems`. Now, to add the order items, we need
    to do a few things. The `validated_items` variable is a list of items that belong
    to the underlying order, and we need to first set the order to each one of these
    items, and create an `OrderItem` object for each one of the items on the list.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加`OrderItems`。现在，要添加订单项，我们需要做一些事情。`validated_items`变量是属于底层订单的商品列表，我们首先需要为每个商品设置订单，并为列表中的每个商品创建一个`OrderItem`对象。
- en: There are different ways of performing this operation. You could do it in two
    parts; for example, first loop through the item's list and set the order property,
    then loop through the list again and create the `OrderItem` objects. However,
    that wouldn't be so elegant, would it?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作的不同方式。例如，您可以分两部分进行；首先遍历项目列表并设置订单属性，然后再次遍历列表并创建`OrderItem`对象。然而，那样并不那么优雅，是吗？
- en: 'A better approach here is to take advantage of the fact that Python is a multi-paradigm
    programming language, and we can solve this problem in a more functional way:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里更好的方法是利用Python是一种多范式编程语言的事实，我们可以以更加函数式的方式解决这个问题：
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we make use of one of the built-in function maps. The `map` function will
    apply a function that I specify as the first argument to an iterable that is passed
    as the second argument, which then returns an iterable with the results.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用了内置函数map之一。`map`函数将应用我指定的作为第一个参数的函数到作为第二个参数传递的可迭代对象上，然后返回一个包含结果的可迭代对象。
- en: The function that we are going to pass as the first argument to map is a function
    called `partial`, from the `functools` module. The `partial` function is a high-order
    function, meaning that it will return another function (the one in the first argument)
    and will add the argument and keyword arguments to its signature. In the preceding
    code, it will return `self._create_order_item`, and the first argument will be
    an item of the iterable `validated_items`. The second argument is the order that
    we created previously.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将作为map的第一个参数传递的函数称为`partial`，来自`functools`模块。`partial`函数是一个高阶函数，意味着它将返回另一个函数（第一个参数中的函数），并将参数和关键字参数添加到其签名中。在前面的代码中，它将返回`self._create_order_item`，第一个参数将是可迭代的`validated_items`中的一个项目。第二个参数是我们之前创建的订单。
- en: After that, the value of `mapped_items` should contain a list of `OrderItem`
    objects, and the only thing left to do is call `bulk_create`, which will insert
    all the items on the list for us.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`mapped_items`的值应该包含一个`OrderItem`对象的列表，唯一剩下的事情就是调用`bulk_create`，它将为我们插入列表中的所有项目。
- en: Next up, we are going to create the views.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建视图。
- en: Creating the views
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建视图
- en: 'Before we create the views, we are going to create some helper classes and
    functions that will make the code in the view simpler and clean. Go ahead and
    create a file called `view_helper.py` in the main app directory, and as usual,
    let''s start by including the import statements:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建视图之前，我们将创建一些辅助类和函数，这些类和函数将使视图中的代码更简单、更清晰。继续创建一个名为`view_helper.py`的文件，在主应用程序目录中，像往常一样，让我们从包含导入语句开始：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we import some things from the Django REST Framework, the main one being
    the generic, which contains definitions for the generic view classes that we are
    going to use to create our own custom views. The status contains all the HTTP
    status codes, which are very useful when sending the response back to the client.
    Then, we import the `Response` class, which will allow us to send content to the
    client that can be rendered in different content types, for example, JSON and
    XML.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从Django REST Framework导入了一些东西，主要是通用的，其中包含了我们将用来创建自定义视图的通用视图类的定义。状态包含了所有HTTP状态码，在向客户端发送响应时非常有用。然后，我们导入了`Response`类，它将允许我们向客户端发送内容，可以以不同的内容类型呈现，例如JSON和XML。
- en: Then, we import the `HttpResponse` from Django with its equivalent of `Response`
    in the rest framework.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从Django中导入`HttpResponse`，以及在rest框架中的`Response`的等价物。
- en: We also import all the custom exceptions that we implemented previously, so
    we can handle the data properly and send useful error messages to the client when
    something goes wrong.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还导入了我们之前实现的所有自定义异常，这样我们就可以正确处理数据，并在出现问题时向客户端发送有用的错误消息。
- en: Lastly, we import the `OrderSerializer`, which we will use for serialization,
    deserialization, and the validation model.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们导入`OrderSerializer`，我们将用它来进行序列化、反序列化和验证模型。
- en: 'The first class that we are going to create is the `OrderListAPIBaseView` class,
    which will serve as a base class for all the views that will return a list of
    content to the client:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的第一个类是`OrderListAPIBaseView`类，它将作为返回内容列表给客户端的所有视图的基类：
- en: '[PRE53]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `OrderListAPIBaseView` inherits from generics. `ListAPIView` provides us
    with get and list methods, which we can override to add functionality which meets
    our requirements.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderListAPIBaseView`继承自通用的`ListAPIView`，它为我们提供了get和list方法，我们可以重写这些方法以添加满足我们要求的功能。'
- en: The class starts by defining two properties; `serializer_class`, which is set
    to `OrderSerializer`, and the `lookup_field`, which in this case we set to empty
    string. We will override this value in the child classes. Then, we define the
    `get_queryset` method, and that is also going to be overridden in the child classes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 该类首先定义了两个属性；`serializer_class`，设置为`OrderSerializer`，以及`lookup_field`，在这种情况下我们将其设置为空字符串。我们将在子类中重写这个值。然后，我们定义了`get_queryset`方法，这也将在子类中被重写。
- en: Lastly, we implement the list method, which will first run the `get_queryset`
    method to get the data that will be returned to the user. If an error occurs,
    it will return a response with status `400` (`BAD REQUEST`), otherwise, it will
    use the `OrderSerializer` to serialize the data. The `result` argument is the
    `QuerySet` result returned by the `get_queryset` method, and the `many` keyword
    argument tells the serializer that we will serialize a list of items.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了列表方法，它将首先运行`get_queryset`方法来获取将返回给用户的数据。如果发生错误，它将返回一个状态为`400`（`BAD REQUEST`）的响应，否则，它将使用`OrderSerializer`来序列化数据。`result`参数是`get_queryset`方法返回的`QuerySet`结果，`many`关键字参数告诉序列化器我们将序列化一个项目列表。
- en: When the data is serialized properly, we send a response with status `200` (OK)
    with the results of the query.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据被正确序列化时，我们将发送一个状态为`200`（OK）的响应，其中包含查询的结果。
- en: The idea of this base class is that all the children classes will only need
    to implement the `get_queryset` method, which will keep the view classes small
    and neat.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基类的想法是，所有子类只需要实现`get_queryset`方法，这将使视图类保持简洁整洁。
- en: 'Now, we are going to add a function that will help us with the methods that
    will perform a `POST` request. Let''s go ahead and add a function called `set_status_handler`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个函数，它将帮助我们执行`POST`请求的方法。让我们继续添加一个名为`set_status_handler`的函数：
- en: '[PRE54]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This function is very simple; it will just get a function as an argument. Run
    the function; if one of the exceptions occurs, it will return a `400` (`BAD REQUEST`)
    response back to the client, otherwise, it will return a `204` (`NO CONTENT`)
    response.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单；它只会将一个函数作为参数。运行该函数；如果发生异常之一，它将向客户端返回一个`400`（`BAD REQUEST`）响应，否则，它将返回一个`204`（`NO
    CONTENT`）响应。
- en: Adding views
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加视图
- en: 'Now, it is time to start adding the views! Open the `views.py` file in the
    main `app` directory, and let''s add some import statements:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候开始添加视图了！打开主`app`目录中的`views.py`文件，让我们添加一些导入语句：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: First, we will import the `HttpReponse` from the `django.http` module and `get_object_or_404`
    from the `django.shortcuts` module. The latter is just a helper function that
    will get an object, and in case it cannot find it, it will return a response with
    the status `440` (`NOT FOUND`).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从`django.http`模块导入`HttpReponse`，并从`django.shortcuts`模块导入`get_object_or_404`。后者只是一个帮助函数，它将获取一个对象，如果找不到它，将返回状态码为`440`（`NOT
    FOUND`）的响应。
- en: Then, we import generics for creating generic views and statuses, and from the `rest_framework`,
    we import the `Response` class.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们导入generics以创建通用视图和状态，并从`rest_framework`中导入`Response`类。
- en: Lastly, we import some of the models, helper methods, and functions, and the
    serializer that we are going to be using in the views.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们导入一些模型、帮助方法和函数，以及我们将在视图中使用的序列化器。
- en: 'We should be ready to start creating the views. Let''s create a view that will
    get all the orders for a given customer:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该准备开始创建视图了。让我们创建一个视图，它将获取给定客户的所有订单：
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Nice! So, we created a class that inherits from the base class `(OrderListAPIBaseView)`,
    which we created in the `view_helpers.py`, and since we have already implemented
    the list method, the only method that we needed to implement here was the `get_queryset`.
    The `get_queryset` method gets a `customer_id` as an argument and simply calls
    the `get_all_orders_by_customer` that we created in the `Order` model manager,
    passing the `customer_id`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！因此，我们创建了一个从基类（`OrderListAPIBaseView`）继承的类，我们在`view_helpers.py`中创建了这个基类，由于我们已经实现了列表方法，因此我们在这里需要实现的唯一方法是`get_queryset`。`get_queryset`方法以`customer_id`作为参数，并简单地调用我们在`Order`模型管理器中创建的`get_all_orders_by_customer`，传递`customer_id`。
- en: We also defined the value of the `lookup_field`, which will be used to get the
    value of the keyword argument that is passed on to the `kwargs` of the list method
    on the base class.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了`lookup_field`的值，它将用于获取传递给基类列表方法的`kwargs`的关键字参数的值。
- en: 'Let''s add two more views to get the incomplete and complete orders:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加两个视图来获取未完成和完成的订单：
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Pretty much the same as the first view that we implemented, we define the `lookup_field`
    and override the `get_queryset` to call the appropriated method in the `Order`
    model manager.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们实现的第一个视图基本相同，我们定义了`lookup_field`并重写了`get_queryset`以调用`Order`模型管理器中的适当方法。
- en: 'Now, we are going to add a view that will get a list of orders when given a
    specific status:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个视图，当给定特定状态时，将获取订单列表：
- en: '[PRE58]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As you can see here, we are defining the `lookup_field` as `status_id` and we
    override the `get_queryset` to call `get_orders_by_status`, passing the status
    value.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里所看到的，我们将`lookup_field`定义为`status_id`，并重写`get_queryset`以调用`get_orders_by_status`，传递状态值。
- en: Here, we use `Status`(`status_id`), so we pass the `Enum` item and not only
    the ID.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`Status`（`status_id`），因此我们传递`Enum`项而不仅仅是ID。
- en: 'All the views that we implemented so far will only accept `GET` requests and
    it will return a list of orders. Now, we are going to implement a view that supports
    `POST` requests so we are able to receive new orders:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们实现的所有视图都只接受`GET`请求，并且将返回订单列表。现在，我们将实现一个支持`POST`请求的视图，以便能够接收新订单：
- en: '[PRE59]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now, this class differs a bit from the previous ones that we created, the base
    class being generics. `CreateAPIView` provides us with a `post` method, so we
    override that method in order to add the logic that we need. First, we get the
    request's data and pass it as an argument to the `OrderSerializer` class; it will
    deserialize the data and set it to the serializer variable. Then, we call the
    method `is_valid()`, which will validate the received data. If the request's data
    is not valid, we return a `400` response (`BAD REQUEST`), otherwise, we go ahead
    and call the `save()` method. This method will internally call the `create` method
    on the serializer, and it will create the new order along with the new order's
    customer and the order's items. If everything goes well, we return a `202` response
    (`CREATED`) together with the ID of the newly created order.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个类与我们创建的前几个类有些不同，基类是通用的。`CreateAPIView`为我们提供了一个`post`方法，因此我们重写该方法以添加我们需要的逻辑。首先，我们获取请求的数据并将其作为参数传递给`OrderSerializer`类；它将对数据进行反序列化并将其设置为序列化器变量。然后，我们调用`is_valid()`方法，它将验证接收到的数据。如果请求的数据无效，我们返回一个`400`响应（`BAD
    REQUEST`），否则，我们继续调用`save()`方法。这个方法将在序列化器上内部调用`create`方法，并且它将创建新订单以及新订单的客户和订单项目。如果一切顺利，我们将返回一个`202`响应（`CREATED`），并附上新创建订单的ID。
- en: 'Now, we are going to create three functions that will handle the order canceling,
    setting the next order''s status, and lastly, setting a specific order''s status:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建三个函数，用于处理订单取消、设置下一个订单状态，以及最后，设置特定订单的状态：
- en: '[PRE60]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, we are not using the Django REST framework class-based views
    here. We are just using regular functions. The first one, the `cancel_order` function,
    gets two parameters—the request and the `order_id`. We start by using the shortcut
    function, `get_object_or_404`. The `get_object_or_404` function returns a `404`
    response (`NOT FOUND`) if it cannot find the object matching the criteria passed
    in the second argument. Otherwise, it will return the object.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们在这里没有使用Django REST框架的基于类的视图。我们只是使用常规函数。第一个函数`cancel_order`接收两个参数——请求和`order_id`。我们首先使用快捷函数`get_object_or_404`。`get_object_or_404`函数会在无法找到与第二个参数中传递的条件匹配的对象时返回`404`响应（`未找到`）。否则，它将返回该对象。
- en: Then, we use the helper function `set_status_handler` that we implemented in
    the `view_helpers.py` file. This function gets another function as an argument.
    So, we are passing a `lambda` function that will execute the method in the `Order`
    model manager that we want. In this case, when the `lambda` function is executed,
    it will execute the `cancel_order` method that we defined in the `Order` model
    manager, passing the order that we want to cancel.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用了我们在`view_helpers.py`文件中实现的辅助函数`set_status_handler`。这个函数接收另一个函数作为参数。因此，我们传递了一个将执行我们想要的`Order`模型管理器中的方法的`lambda`函数。在这种情况下，当执行`lambda`函数时，它将执行我们在`Order`模型管理器中定义的`cancel_order`方法，传递我们想要取消的订单。
- en: The `set_next_status` function is quite similar, but instead of calling the
    `cancel_order` inside of the `lambda` function, we will call `set_next_status`,
    passing the order that we want to set to the next status.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_next_status`函数非常类似，但是我们将在`lambda`函数内部调用`cancel_order`，而不是调用`set_next_status`，传递我们想要设置为下一个状态的订单。'
- en: The `set_status` function contains a bit more logic in it, but it is also quite
    simple. This function will get two arguments, the `order_id` and the `status_id`.
    First, we get the order object, then we look up the status using the `status_id`.
    If the status doesn't exist, a `ValueError` exception will be raised and then
    we return a `400` response (`BAD REQUEST`). Otherwise, we call the `set_status_handle`,
    passing a `lambda` function that will execute the `set_status` function passing
    the order and the status objects.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_status`函数包含了一些更多的逻辑，但它也很简单。这个函数将接收两个参数，`order_id`和`status_id`。首先，我们获取订单对象，然后使用`status_id`查找状态。如果状态不存在，将引发`ValueError`异常，然后我们返回`400`响应（`错误请求`）。否则，我们调用`set_status_handle`，传递一个`lambda`函数，该函数将执行`set_status`函数，传递订单和状态对象。'
- en: Setting up the service URLs
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置服务URL
- en: 'Now that we have all the views in place, it is a good time to start setting
    up the URLs that the users of our order service can call to fetch and modify orders.
    Let''s go ahead and open the `urls.py` file in the main `app` directory; first,
    we need to import all the view classes and functions that we are going to use:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有视图放在了适当的位置，是时候开始设置我们的订单服务用户可以调用以获取和修改订单的URL了。让我们继续打开主`app`目录中的`urls.py`文件；首先，我们需要导入所有要使用的视图类和函数：
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Perfect! Now, we can start adding the URLs:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在，我们可以开始添加URL：
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To add new URLs, we need to use the `path` `function` to pass the first argument,
    the `URL`. The second argument is the function that will be executed when a request
    is sent to the `URL` specified by the first argument. Every URL that we create
    has to be added to the `urlspatterns` list. Note that Django 2 simplified how
    parameters were added to the URL. Previously, you would need to some using regular
    expressions; now, you can just follow the notation `<type:param>`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新的URL，我们需要使用`path`函数来传递第一个参数，即`URL`。第二个参数是在发送请求到由第一个参数指定的`URL`时将执行的函数。我们创建的每个URL都必须添加到`urlspatterns`列表中。请注意，Django
    2简化了如何向URL添加参数。以前，您需要使用正则表达式；现在，您只需遵循`<type:param>`的表示法。
- en: Before we try this out, we have to open the `urls.py` file, but this time in
    the order directory because we need to include the URLs that we just created.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试这个之前，我们必须打开`urls.py`文件，但这次是在订单目录中，因为我们需要包括我们刚刚创建的URL。
- en: 'The `urls.py` file should look similar to this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`urls.py`文件应该类似于这样：'
- en: '[PRE63]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, we want all the URLs that we defined on the main app to be under `/api/`.
    To achieve this, the only thing we need to do is create a new route and include
    the URLs from the main app. Add the following code in the `urlpatterns` list:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望我们在主应用程序中定义的所有URL都位于`/api/`下。为了实现这一点，我们唯一需要做的就是创建一个新的路由，并包括来自主应用程序的URL。在`urlpatterns`列表中添加以下代码：
- en: '[PRE64]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And let''s not forget to import the `include` function:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 并且不要忘记导入`include`函数：
- en: '[PRE65]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The order service won't be public when we deploy it to the AWS; however as an
    extra security measure, we are going to enable token authentication for this service.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 将订单服务部署到AWS时，它不会是公共的；但是作为额外的安全措施，我们将为此服务启用令牌身份验证。
- en: 'To call the service''s APIs, we will have to send an authentication token.
    Let''s go ahead and enable it. Open the `settings.py` file in the `order` directory
    and add the following content:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用服务的API，我们必须发送身份验证令牌。让我们继续启用它。在`order`目录中打开`settings.py`文件，并添加以下内容：
- en: '[PRE66]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You can place this right after `INSTALLED_APPS`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将其放在`INSTALLED_APPS`之后。
- en: The `DEFAULT_PERMISSION_CLASSES` function defines the global permission policy.
    Here, we set it to `rest_framework.permissions.IsAuthenticated`, which means that
    it will deny access to any unauthorized user.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEFAULT_PERMISSION_CLASSES`函数定义了全局权限策略。在这里，我们将其设置为`rest_framework.permissions.IsAuthenticated`，这意味着它将拒绝任何未经授权的用户访问。'
- en: The `DEFAULT_AUTHENTICATION_CLASSES` function specifies the global authentication
    schemas. In this case, we are going to use token authentication.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEFAULT_AUTHENTICATION_CLASSES`函数指定了全局身份验证模式。在这种情况下，我们将使用令牌身份验证。'
- en: 'Then, in `INSTALLED_APPS`, we need to include the `rest_framework.authtoken`.
    Your `INSTALLED_APPS` should look like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`INSTALLED_APPS`中，我们需要包括`rest_framework.authtoken`。您的`INSTALLED_APPS`应该如下所示：
- en: '[PRE67]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Perfect! Save the file, and on the terminal, run the following command:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！保存文件，并在终端上运行以下命令：
- en: '[PRE68]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The Django REST framework has out of the box views, so the users can call and
    acquire a token. However, for simplicity, we are going to create a user who can
    have access to the APIs. Then, we can manually create an authentication token
    that can be used to do the request to the order service APIs.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST框架具有开箱即用的视图，因此用户可以调用并获取令牌。但是，为简单起见，我们将创建一个可以访问API的用户。然后，我们可以手动创建一个身份验证令牌，该令牌可用于对订单服务API进行请求。
- en: 'Let''s go ahead and create this user. Start the service with the following
    command:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建这个用户。使用以下命令启动服务：
- en: '[PRE69]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: And browse to `https://localhost:8000/admin`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 然后浏览到`https://localhost:8000/admin`。
- en: 'Under the AUTHENTICATION AND AUTHORIZATION tab, you will see the `Users` model.
    Click on Add and create a user with the username `api_user`. When the user is
    created, browse back to the admin first page and under the AUTH TOKEN**,** click
    on Add. Select the `api_user` in the drop-down menu and click SAVE. You should
    see a page like the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在身份验证和授权选项卡下，您将看到`Users`模型。单击添加并创建一个用户名为`api_user`的用户。创建用户后，返回管理首页，在`AUTH TOKEN`下，单击添加。在下拉菜单中选择`api_user`，然后单击保存。您应该会看到以下页面：
- en: '![](assets/edccbabd-f4f7-4bf9-9e8a-930fe3e07c42.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/edccbabd-f4f7-4bf9-9e8a-930fe3e07c42.png)'
- en: Copy the key and let's create a small script just to add an order so we can
    test the APIs.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 复制密钥，让我们创建一个小脚本，只需添加一个订单，以便我们可以测试API。
- en: 'Create a file called `send_order.py`; it can be placed anywhere you want as
    long as you have the virtual environment activated, since we are going to use
    the package requests to send the order to the order services. Add the following
    content to the `send_order.py` file:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`send_order.py`的文件；它可以放在任何您想要的地方，只要您已激活虚拟环境，因为我们将使用requests包将订单发送到订单服务。将以下内容添加到`send_order.py`文件中：
- en: '[PRE70]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Great! Now, we can start the development server:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，我们可以启动开发服务器：
- en: '[PRE71]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In another window, we will run the script that we just created:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个窗口中，我们将运行刚刚创建的脚本：
- en: '[PRE72]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You can see the results as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到以下结果：
- en: '![](assets/2a95e41c-4f91-4a4e-ab80-64223855e413.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2a95e41c-4f91-4a4e-ab80-64223855e413.png)'
- en: 'What? Something went wrong here, can you guess what it is? Note the log message
    that was printed in the screenshot in the terminal where I have the Django development
    server running:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？这里出了些问题，你能猜到是什么吗？请注意在我运行Django开发服务器的终端中打印的屏幕截图中的日志消息：
- en: '[PRE73]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Ok, it says here that the server has received a PUT request to `/api/order/add/`,
    and one thing to notice here is that code `401` signifies `Unauthorized`. This
    means that the settings that we have added in the `settings.py` file worked fine.
    To call the APIs, we need to be authenticated, and we are using token authentication.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这里说服务器已收到了对`/api/order/add/`的PUT请求，这里需要注意的一件事是代码`401`表示`未经授权`。这意味着我们在`settings.py`文件中添加的设置运行正常。要调用API，我们需要进行身份验证，而我们正在使用令牌身份验证。
- en: 'To create a token for a user, we need to log in in the Django administration
    UI. There, we will find the AUTH TOKEN section as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 要为用户创建一个令牌，我们需要在Django管理UI中登录。在那里，我们将找到如下所示的`AUTH TOKEN`部分：
- en: '![](assets/2d36948d-637f-4279-8ae5-2ab99d1abc0a.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2d36948d-637f-4279-8ae5-2ab99d1abc0a.png)'
- en: 'Click on that green plus sign on the right-hand side. Then, you can select
    the user you wish to create a token for and when you are ready, click save. After
    that, you will see a list of tokens that have been created:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 单击右侧的绿色加号。然后，您可以选择要为其创建令牌的用户，当您准备好时，单击保存。之后，您将看到已创建的令牌列表：
- en: '![](assets/20e4a65d-5b1a-4455-9ed6-8aad6945c683.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/20e4a65d-5b1a-4455-9ed6-8aad6945c683.png)'
- en: That key is the key you want to send in the request's **HEADER**.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 该密钥是您要在请求的**HEADER**中发送的密钥。
- en: 'Now that we have a token, we can modify the `send_order.py` script and add
    the token information to the request, so on the top of the `send_order` function,
    add the following code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个令牌，我们可以修改`send_order.py`脚本，并将令牌信息添加到请求中，因此在`send_order`函数的顶部添加以下代码：
- en: '[PRE74]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The token variable is the token that we created for the user `api_user`. To
    get the token, just log in to the Django admin UI and under AUTH TOKEN, you will
    see the tokens that have been created. Just remove the token that I added here
    and replace it with the one that was generated for the `api_user` on your application.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌变量是我们为用户`api_user`创建的令牌。要获取令牌，只需登录到Django管理UI，在`AUTH TOKEN`下，您将看到已创建的令牌。只需删除我在此处添加的令牌，并用在您的应用程序上为`api_user`生成的令牌替换它。
- en: 'Then, we need to send the headers along with the request. Change the following
    code:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在请求中发送头。更改以下代码：
- en: '[PRE75]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Replace it with this:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 将其替换为：
- en: '[PRE76]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, we can go to the terminal and run our code again. You should see an output
    similar to the output shown in the following screenshot:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以转到终端并再次运行我们的代码。您应该看到类似于以下屏幕截图中显示的输出：
- en: '![](assets/b834857f-c578-4561-bf20-7c10a898da7a.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b834857f-c578-4561-bf20-7c10a898da7a.png)'
- en: 'Note that now, we get the following log message:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在我们得到了以下日志消息：
- en: '[PRE77]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This means that the authentication works properly. Go ahead and take the time
    to explore the Django admin UI and verify that now we have one customer and one
    order with a couple of items created on our database.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着身份验证正常工作。继续花时间探索Django管理UI，并验证我们现在在数据库中创建了一个客户和一个订单以及一些商品。
- en: Let's try some of the other endpoints to see if they are working as expected.
    For example, we can get all the orders for that customer that we just created.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些其他端点，看看它们是否按预期工作。例如，我们可以获取刚刚创建的客户的所有订单。
- en: You can perform small tests to the endpoints using any tool you want. There
    are a few very handy browser plugins that you can install, or, if you are like
    me and like to do everything on the terminal, you can use cURL. Alternatively
    if you want to try to build something with Python, there is the `httpie` package
    that you can install using pip. Use the `pip install httpie --upgrade --user` command
    to install `httpie` on your local directory under `./local/bin`. So, don't forget
    to add this directory to your PATH. I like to use `httpie` instead of cURL because
    `httpie` shows a nice and formatted JSON output so I can get a better view of
    the response that I'm getting back from the endpoint.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何工具对端点进行小型测试。有一些非常方便的浏览器插件可以安装，或者如果您像我一样喜欢在终端上做所有事情，您可以使用cURL。或者，如果您想尝试使用Python构建一些东西，可以安装`httpie`包，使用pip命令`pip
    install httpie --upgrade --user`在本地目录下`./local/bin`安装`httpie`。所以，不要忘记将此目录添加到您的PATH中。我喜欢使用`httpie`而不是cURL，因为`httpie`显示了一个漂亮和格式化的JSON输出，这样我就可以更好地查看从端点返回的响应。
- en: 'So, let''s try the first `GET` endpoint that we created:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们尝试我们创建的第一个`GET`端点：
- en: '[PRE78]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And you should see the following output:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你应该看到以下输出：
- en: '[PRE79]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Perfect! Just as expected. Go ahead and try the other endpoints!
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！正如预期的那样。继续尝试其他端点！
- en: Next up, we are going back to the online video game store and send the order.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要回到在线视频游戏商店并发送订单。
- en: Integration with the game online store
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与在线游戏商店的集成
- en: 'Now that we have the service up and running, we are ready to finish the online
    video game store project from [Chapter 7](a8e0af3b-67d9-4649-986b-041d136af0e8.xhtml),
    *Online Video Game Store with Django*. We are not going to perform many changes,
    but there are two improvements that we are going to do:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的服务已经运行起来了，我们准备完成[第7章](a8e0af3b-67d9-4649-986b-041d136af0e8.xhtml)中的Django在线视频游戏商店项目。我们不打算进行太多更改，但有两个改进我们要做：
- en: At the moment, in the online video game store, it is not possible to submit
    orders. The users of our site can only add items to the cart, visualize, and edit
    the cart's items. We are going to finish that implementation and create a view
    so that we can submit the order.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，在在线视频游戏商店中，无法提交订单。我们网站的用户只能将商品添加到购物车中，查看和编辑购物车中的商品。我们将完成这个实现，并创建一个视图，以便我们可以提交订单。
- en: We are going to implement one more view where we can see the order history.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将实现另一个视图，可以在其中查看订单历史记录。
- en: So, let's get right to it!
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧！
- en: 'The first change that we are going to do is add the authentication token for
    the `api_user` that we created in the service orders. We also want to add the
    base URL to the order service, so it will be easier for us to build up the URLs
    that we need to perform the requests. Open the `settings.py` file in the `gamestore`
    directory and add these two constant variables:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一个变化是为我们在服务订单中创建的`api_user`添加身份验证令牌。我们还想要添加订单服务的基本URL，这样我们就可以更容易地构建我们需要执行请求的URL。在`gamestore`目录中的`settings.py`文件中添加这两个常量变量：
- en: '[PRE80]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: It does not matter where you place this code, but maybe it's a good idea to
    just place it at the end of the file.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码放在哪里都可以，但也许最好是放在文件的末尾。
- en: 'The next change that we are going to do is add a `namedtuple` called `OrderItem`,
    just to help us prepare the order''s data so it is compatible with the format
    that the order service is expecting. Open the `models.py` file in the `gamestore/main`
    directory and add `import`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的变化是添加一个名为`OrderItem`的`namedtuple`，只是为了帮助我们准备订单数据，使其与订单服务期望的格式兼容。在`gamestore/main`目录中的`models.py`文件中添加`import`：
- en: '[PRE81]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Another change to the models file is that we are going to add a new method
    in the `ShoppingCartManager` class called `empty`, so that when it''s called,
    it will remove all the cart''s items. Inside of the `ShoppingCartManager` class,
    add the following method:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 模型文件的另一个变化是，我们将在`ShoppingCartManager`类中添加一个名为`empty`的新方法，这样当调用它时，它将删除所有购物车中的商品。在`ShoppingCartManager`类中添加以下方法：
- en: '[PRE82]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'At the end of the file, let''s create the `namedtuple`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件末尾，让我们创建`namedtuple`：
- en: '[PRE83]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Next up, we are going to change the `cart.html` template. Locate the `send
    order` button:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要更改`cart.html`模板。找到`send order`按钮：
- en: '[PRE84]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Replace it with the following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换它：
- en: '[PRE85]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Nice! We just created a form around the button and added the Cross-Site Request
    Forgery token within the form, so that when we click the button, it will send
    a request to `cart/send`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 很好！我们刚刚在按钮周围创建了一个表单，并在表单中添加了跨站点请求伪造令牌，这样当我们点击按钮时，它将发送一个请求到`cart/send`。
- en: 'Let''s add the new URLs. Open the `urls.py` file in the main `app` directory,
    and let''s add two new URLs:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加新的URL。在主`app`目录中打开`urls.py`文件，然后添加两个新的URL：
- en: '[PRE86]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: You can place these two URL definitions right after the definition of the `/cart/` URL.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这两个URL定义放在`/cart/`URL的定义之后。
- en: 'Open the `views.py` file and add some new imports:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`views.py`文件并添加一些新的导入：
- en: '[PRE87]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Then, we add a function that will help us with the serialization of the order
    data to be sent to the order service:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加一个函数，将帮助我们将订单数据序列化为要发送到订单服务的格式：
- en: '[PRE88]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, we have two more views to add, the first being the `send_order`:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还有两个视图要添加，第一个是`send_order`：
- en: '[PRE89]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Next is the `my_orders` view, which will be the new view that returns the order
    history:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`my_orders`视图，这将是返回订单历史记录的新视图：
- en: '[PRE90]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We need to create the `my-orders.html` file, which is going to be the template
    that is rendered by the `my_orders` view. Create a new file called `my-orders.html`
    in the `main/templates/main/` directory with the following contents:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建`my-orders.html`文件，这将是由`my_orders`视图呈现的模板。在`main/templates/main/`目录中创建一个名为`my-orders.html`的新文件，内容如下：
- en: '[PRE91]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This template is very basic; it is just looping through the orders and then
    looping the items and building a HTML table with the item's information.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板非常基础；它只是循环订单，然后循环商品并构建一个包含商品信息的HTML表格。
- en: 'We need to do some changes in `site.css`, where we have the custom styling
    of the online video game store. Open the `site.css` file in the `static/styles` folder
    and let''s do some modifications. First, locate this code, which is shown as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`site.css`中做一些更改，这是在线视频游戏商店的自定义样式。打开`static/styles`文件夹中的`site.css`文件，让我们做一些修改。首先，找到以下代码，如下所示：
- en: '[PRE92]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Replace it with the following:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换它：
- en: '[PRE93]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'At the end of this file, we can add stylings that are specific to the order
    history page:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在此文件的末尾，我们可以添加特定于订单历史页面的样式：
- en: '[PRE94]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, we are going to add one more menu option that will be a link to the new
    `my orders` page. Open the `base.html` file in the `templates` directory in the
    applications `root` directory, and locate the menu option `CART`:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个菜单选项，该选项将是指向新的`my orders`页面的链接。在应用程序`root`目录中的`templates`目录中打开`base.html`文件，并找到菜单选项`CART`：
- en: '[PRE95]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Right after the closing `</li>` tag, add the following code:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在`</li>`标签结束后，添加以下代码：
- en: '[PRE96]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Finally, the last change that we are going to do is improve the layout of error
    messages that we show in the UI. Locate this code at the end of the `base.html`
    file:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们要做的最后一项更改是改进我们在UI中显示的错误消息的布局。找到`base.html`文件末尾的此代码：
- en: '[PRE97]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Replace it with the following code:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换它：
- en: '[PRE98]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Testing the integration
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试集成
- en: We have everything in place. Now, we need to start both the website and the
    services so we can verify if everything is working properly.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备就绪。现在，我们需要启动网站和服务，以便验证一切是否正常工作。
- en: One thing to keep in mind is that for testing, we will need to run the Django
    application in different ports. We can run the website (game online store) using
    the default port `800`, and for the order services, we can use port `8001`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一件事是，为了测试，我们需要在不同的端口上运行Django应用程序。我们可以使用默认端口`800`运行网站（游戏在线商店），对于订单服务，我们可以使用端口`8001`。
- en: 'Open two terminals; in one terminal, we are going to start the online video
    game store:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 打开两个终端；在一个终端中，我们将启动在线视频游戏商店：
- en: '[PRE99]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'And, on the second terminal, we are going to start the order service:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第二个终端上，我们将启动订单服务：
- en: '[PRE100]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Great! Open the browser and head to `http://localhost:8000` and log in with
    our credentials. After logging in, you will notice that a few things are different.
    Now, there is a new option in the top menu called `ORDERS`. It should be empty,
    so go ahead and add a few items to the cart. When you are done, go to the cart
    view and click on the send order button.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！打开浏览器，转到`http://localhost:8000`并使用我们的凭据登录。登录后，您会注意到一些不同之处。现在，顶部菜单中有一个名为`ORDERS`的新选项。它应该是空的，所以继续向购物车中添加一些项目。完成后，转到购物车视图并单击发送订单按钮。
- en: 'If everything went right, you should see a notification at the top of the page,
    as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该在页面顶部看到通知，如下所示：
- en: '![](assets/23172db2-3235-40a2-8e5d-7fa0e02142bd.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/23172db2-3235-40a2-8e5d-7fa0e02142bd.png)'
- en: Perfect! It worked just as expected. Notice that after sending the order to
    the order service, the shopping cart got emptied as well.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！它正如预期的那样工作。请注意，在将订单发送到订单服务后，购物车也被清空了。
- en: 'Now, click on the `ORDERS` option on the top menu, and you should see the order
    that we just submitted:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击顶部菜单上的`ORDERS`选项，您应该看到我们刚刚提交的订单：
- en: '![](assets/9a3ff13e-c15e-4cce-8cfa-7d66c14e0787.png)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9a3ff13e-c15e-4cce-8cfa-7d66c14e0787.png)'
- en: Deploying to AWS
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到AWS
- en: Now, it is time to show the world the work that we have been doing so far.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候向世界展示我们迄今为止所做的工作了。
- en: We are going to deploy the gamestore Django application and also the order service
    to EC2 instances in Amazon Web services.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Amazon Web服务的EC2实例上部署gamestore Django应用程序和订单服务。
- en: This section is not about configuring Virtual Private Cloud, Security groups,
    Routing tables, and EC2 instances. Packt has plenty of excellent books and videos
    available that talk about this topic.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 本节不涉及配置虚拟私有云、安全组、路由表和EC2实例。Packt有许多关于这个主题的优秀书籍和视频可供参考。
- en: 'Instead, we will assume that you already have your environment set up, and
    focus on:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将假设您已经设置好了环境，并专注于：
- en: Deploying the application
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: Installing all necessary dependencies
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装所有必要的依赖项
- en: Installing and using `gunicorn`
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和使用`gunicorn`
- en: Installing and configuring `nginx`
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置`nginx`
- en: 'My AWS setup is quite simple, but it definitely works for more complex setups.
    Right now, I have one VPC with one subnet and two EC2 instances on it (`gamestore`
    and order-service). See the following screenshot:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我的AWS设置非常简单，但绝对适用于更复杂的设置。现在，我有一个VPC，一个子网和两个EC2实例（`gamestore`和order-service）。请参阅以下截图：
- en: '![](assets/e36b74d3-ac74-4979-851d-878b9b9f5b7b.png)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e36b74d3-ac74-4979-851d-878b9b9f5b7b.png)'
- en: 'We can start with the `gamestore` application; connect via ssh to the EC2 instance
    that you wish to deploy the game online application on. Remember that to `ssh`
    in one of those instances, you will need to have the `.pem` file:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`gamestore`应用程序开始；通过ssh连接到您希望部署游戏在线应用程序的EC2实例。请记住，要在这些实例中的一个中进行`ssh`，您需要拥有`.pem`文件：
- en: '[PRE101]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We will start by updating any package that we have installed on that machine;
    it is not required, but it is a good practice since some of the packages may have
    security fixes and performance improvements that you probably want to have on
    your installs. Amazon Linux uses the `yum` package manager, so we run the following
    command:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先更新在该计算机上安装的任何软件包；虽然不是必需的，但这是一个很好的做法，因为其中一些软件包可能具有安全修复和性能改进，您可能希望在安装时拥有这些改进。Amazon
    Linux使用`yum`软件包管理器，因此我们运行以下命令：
- en: '[PRE102]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Just answer yes `y` to any package that needs an update.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 只需对任何需要更新的软件包回答“是”`y`。
- en: 'These EC2 instances do not have Python installed by default, so we need to
    install it as well:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这些EC2实例默认未安装Python，因此我们也需要安装它：
- en: '[PRE103]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We also need to install `nginx`:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装`nginx`：
- en: '[PRE104]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Then, we install our project dependencies:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们安装我们的项目依赖项：
- en: '[PRE105]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Perfect! Now, we can copy our application, exit this instance, and from our
    local machine, run the following command:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在，我们可以复制我们的应用程序，退出此实例，并从我们的本地机器上运行以下命令：
- en: '[PRE106]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This command will recursively copy all the files from the `gamestore` directory
    on our local machine over to our home directory in the EC2 instance.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将递归地将本地机器上`gamestore`目录中的所有文件复制到EC2实例中我们的主目录中。
- en: Modifying the settings.py file
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改settings.py文件
- en: 'There is one thing we have to change here. In the `settings.py` file, there
    is a list called `ALLOWED_HOSTS`, which was empty when we created the Django project.
    We will need to add the IP address of the EC2 that we are deploying the application
    to; in my case, it would be:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一件事情我们需要改变。在`settings.py`文件中，有一个名为`ALLOWED_HOSTS`的列表，在我们创建Django项目时为空。我们需要添加我们将部署应用程序的EC2的IP地址；在我的情况下，它将是：
- en: '[PRE107]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'We also need to change the `ORDER_SERVICE_BASEURL` that we defined at the end
    of the file. It needs to be the address of the instance that we are going to deploy
    to the order service. In my case, the IP is `35.176.194.15`, so my variable will
    look like this:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更改文件末尾定义的`ORDER_SERVICE_BASEURL`。它需要是我们将部署到订单服务的实例的地址。在我的情况下，IP是`35.176.194.15`，所以我的变量看起来像这样：
- en: '[PRE108]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We are going to create a folder to keep the application since it is not a good
    idea to keep the application running in the `ec2-user` folder. So, we are going
    to create a new folder in the `root` directory called `app` and copy the `gamestore`
    directory over to the newly created directory:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个文件夹来保存应用程序，因为将应用程序运行在`ec2-user`文件夹中不是一个好主意。因此，我们将在`root`目录中创建一个名为`app`的新文件夹，并将`gamestore`目录复制到新创建的目录中：
- en: '[PRE109]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'We need also to set the current permissions on that directory. When `nginx`
    is installed, it also creates a `nginx` user and a group. So, let''s change the
    ownership of the entire folder:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设置该目录的当前权限。当安装`nginx`时，它还会创建一个`nginx`用户和一个组。因此，让我们更改整个文件夹的所有权：
- en: '[PRE110]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Finally, we are going to set up `nginx`, edit the `/etc/nginx/nginx.conf` file,
    and under `service`, add the following configuration:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将设置`nginx`，编辑`/etc/nginx/nginx.conf`文件，在`service`下添加以下配置：
- en: '[PRE111]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'We need to restart the `nginx` service so that the service reflects the changes
    that we just made:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重新启动`nginx`服务，以便服务反映我们刚刚做的更改：
- en: '[PRE112]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Finally, we go over to the `application` folder:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们转到`application`文件夹：
- en: '[PRE113]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Start the application with `gunicorn`. We are going to start the application
    as an `nginx` user:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gunicorn`启动应用程序。我们将以`nginx`用户的身份启动应用程序：
- en: '[PRE114]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Now, we can browse to the site. You don't need to specify port `8000` since `nginx`
    will route the requests coming from port `80` to `127.0.0.1:8000`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以浏览到该网站。您不需要指定端口`8000`，因为`nginx`将把从端口`80`进来的请求路由到`127.0.0.1:8000`。
- en: Deploying the order service
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署订单服务
- en: Deploying the order service is pretty much the same as the `gamestore` project,
    the only difference is that we are going to install different Python dependencies
    and deploy the application in a different directory. So, let's get started.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 部署订单服务与`gamestore`项目基本相同，唯一的区别是我们将安装不同的Python依赖项并将应用程序部署到不同的目录。所以，让我们开始吧。
- en: You can pretty much repeat all the steps up until installing the `nginx` step.
    Also, make sure that you are using the elastic IP address of the other EC2 instance
    from now on.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 您几乎可以重复直到安装`nginx`步骤的所有步骤。还要确保您从现在开始使用另一个EC2实例的弹性IP地址。
- en: 'After you install `nginx`, we can install the order service dependencies:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`nginx`后，我们可以安装订单服务的依赖项：
- en: '[PRE115]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'We can now copy the project file. Go to the directory where you have the service''s
    directory, and run this command:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以复制项目文件。转到您拥有服务目录的目录，并运行此命令：
- en: '[PRE116]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Like `gamestore`, we also need to edit the `settings.py` file and add our EC2
    instance elastic IP:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 与`gamestore`一样，我们还需要编辑`settings.py`文件并添加我们的EC2实例弹性IP：
- en: '[PRE117]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'We will also create a folder in the `root` directory so the project is not
    laying around in the `ec2-user` home directory:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在`root`目录中创建一个文件夹，以便项目不会留在`ec2-user`的主目录中：
- en: '[PRE118]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Let''s change the owner of the entire directory as well:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也更改整个目录的所有者：
- en: '[PRE119]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Let''s edit the `/etc/nginx/nginx.conf` file, and, under `service`, add the
    following configuration:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编辑`/etc/nginx/nginx.conf`文件，在`service`下添加以下配置：
- en: '[PRE120]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: This time, we don't need to configure the static folder since the order services
    don't have anything like images, templates, JS, or CSS files.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们不需要配置静态文件夹，因为订单服务没有像图像、模板、JS或CSS文件这样的东西。
- en: 'Restart the `nginx` service:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动`nginx`服务：
- en: '[PRE121]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Go over to the service''s directory:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 转到服务的目录：
- en: '[PRE122]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'And start the application with `gunicorn`. We are going to start the application
    as an `nginx` user:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用`gunicorn`启动应用程序。我们将以`nginx`用户的身份启动应用程序：
- en: '[PRE123]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Finally, we can browse to the address where the `gamestore` is deployed, and
    you should see the site up and running.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以浏览到`gamestore`部署的地址，您应该看到网站正在运行。
- en: 'Browsing to the site, you will see the first page. All the products are loading,
    and the login and logout sections are also working properly. Here''s a screenshot
    of my system:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到该网站，您将看到第一页。所有产品都在加载，登录和注销部分也正常工作。这是我的系统的截图：
- en: '![](assets/9660d0a6-ccf9-4d45-981a-f541742d1c64.png)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9660d0a6-ccf9-4d45-981a-f541742d1c64.png)'
- en: 'If you browse to a view that makes use of the order service, for example, the
    orders section, you can verify that everything is working, and if you have placed
    any orders on the site, you should see the orders listed here, as shown in the
    following screenshot:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您浏览使用订单服务的视图，例如订单部分，您可以验证一切是否正常运行，如果您在网站上下了任何订单，您应该在这里看到订单列表，如下面的截图所示：
- en: '![](assets/b57770dd-21a8-4748-81ae-5c8326529984.png)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b57770dd-21a8-4748-81ae-5c8326529984.png)'
- en: Summary
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have covered a lot of topics in this chapter; we have built the order service
    that was responsible for receiving orders from the web application that we developed
    in the previous chapter. The order service also provides other features, such
    as the ability to update the status of orders and provide order information using
    different criteria.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了许多主题；我们已经构建了订单服务，负责接收我们在上一章开发的网络应用程序的订单。订单服务还提供其他功能，例如能够更新订单状态并使用不同的标准提供订单信息。
- en: This microservice was an extension of the web application that we developed
    in the previous chapter, and in the following chapter, we are going to extend
    it even further by adding serverless functions to notify the users of our application
    when an order is successfully received and also when the order's status has changed
    to shipped.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微服务是我们在上一章开发的网络应用程序的延伸，接下来的章节中，我们将通过添加无服务器函数来进一步扩展它，以便在成功接收订单时通知我们应用程序的用户，以及当订单状态变更为已发货时通知他们。
