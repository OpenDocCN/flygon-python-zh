# 度

**树**是一种分层的数据结构。在其他数据结构（如列表、队列和栈）中，我们已经讨论过的项目是以顺序方式存储的。然而，在树数据结构的情况下，项目之间存在*父子*关系。树数据结构的顶部称为**根节点**。这是树中所有其他节点的祖先。

树数据结构非常重要，因为它们在各种重要应用中使用。树被用于许多事情，如解析表达式、搜索、存储数据、操作数据、排序、优先队列等。某些文档类型，如 XML 和 HTML，也可以以树形式表示。我们将在本章中看一些树的用途。

在本章中，我们将涵盖以下主题：

+   树的术语和定义

+   二叉树和二叉搜索树

+   树的遍历

+   三叉搜索树

# 技术要求

本章讨论的所有源代码都在本书的 GitHub 存储库中提供，网址为[`github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-3.x-Second-Edition/tree/master/Chapter06`](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-3.x-Second-Edition/tree/master/Chapter06)。

# 术语

让我们考虑与树数据结构相关的一些术语。

要理解树，我们首先需要了解与其相关的基本概念。树是一种数据结构，其中数据以分层形式组织。以下图表包含一个典型的树，由字符节点 A 到 M 标记：

![](img/ad37d16c-654b-46f2-bc31-a4dc5536795a.png)

以下是与树相关的术语列表：

+   **节点**：在前面的图表中，每个圈起来的字母代表一个节点。节点是实际存储数据的任何数据结构。

+   **根节点**：根节点是树中所有其他节点都连接到的第一个节点。在每棵树中，始终存在一个唯一的根节点。我们示例树中的根节点是节点 A。

+   **子树**：树的子树是具有其节点作为其他树的后代的树。例如，节点 F、K 和 L 形成原始树的子树，其中包含所有节点。

+   给定节点的子节点总数称为**该节点的度**。只包含一个节点的树的度为 0。在前面的图表中，节点 A 的度为 2，节点 B 的度为 3，节点 C 的度为 3，同样，节点 G 的度为 1。

+   **叶节点**：叶节点没有任何子节点，是给定树的终端节点。叶节点的度始终为 0。在前面的图表中，节点 J、E、K、L、H、M 和 I 都是叶节点。

+   **边**：树中任意两个节点之间的连接称为**边**。给定树中边的总数将最多比树中的总节点数少一个。前面示例树结构中显示了一个边的示例。

+   **父节点**：树中具有进一步子树的节点是该子树的父节点。例如，节点 B 是节点 D、E 和 F 的父节点，节点 F 是节点 K 和 L 的父节点。

+   **子节点**：这是连接到其父节点的节点，是该节点的后代节点。例如，节点 B 和 C 是节点 A 的子节点，而节点 H、G 和 I 是节点 C 的子节点。

+   **兄弟节点**：具有相同父节点的所有节点是兄弟节点。例如，节点 B 和 C 是兄弟节点，同样，节点 D、E 和 F 也是兄弟节点。

+   **层级**：树的根节点被认为是在第 0 级。根节点的子节点被认为在第 1 级，第 1 级节点的子节点被认为在第 2 级，依此类推。例如，根节点在第 0 级，节点 B 和 C 在第 1 级，节点 D、E、F、H、G 和 I 在第 2 级。

+   树的高度：树中最长路径上的节点总数是树的高度。例如，在前面的树示例中，树的高度为 4，因为最长路径`A-B-D-J`或`A-C-G-M`或`A-B-F-K`都有 4 个节点。

+   **深度**：节点的深度是从树的根到该节点的边的数量。在前面的树示例中，节点 H 的深度为 2。

我们将通过考虑树中的节点并抽象出一个类来开始处理树。

# 树节点

在线性数据结构中，数据项按顺序依次存储，而非线性数据结构将数据项以非线性顺序存储，其中一个数据项可以连接到多个数据项。线性数据结构中的所有数据项可以在一次遍历中遍历，而在非线性数据结构中这是不可能的。树是非线性数据结构；它们以与*数组*、*列表*、*栈*和*队列*等其他线性数据结构不同的方式存储数据。

在树数据结构中，节点按照*父-子*关系排列。树中的节点之间不应该有循环。树结构有节点形成层次结构，没有节点的树称为空树。

首先，我们将讨论一种最重要和特殊的树，即*二叉树*。二叉树是节点的集合，树中的节点可以有零个、1 个或 2 个子节点。简单的二叉树最多有两个子节点，即左子节点和右子节点。例如，在下面的二叉树示例中，有一个根节点，它有两个子节点（左子节点、右子节点）：

![](img/17ebd6df-f607-4b65-8032-03d8be1cd394.png)

如果二叉树的所有节点都有零个或两个子节点，并且没有一个节点有 1 个子节点，则称树为**满二叉树**。如果二叉树完全填满，底层可能有一个例外，从左到右填充，则称为**完全二叉树**。

就像我们之前的实现一样，节点是数据的容器，并且持有对其他节点的引用。在二叉树节点中，这些引用是指左右子节点。让我们看一下下面的 Python 代码，构建一个二叉树`node`类：

```py
    class Node: 
        def __init__(self, data): 
            self.data = data 
            self.right_child = None 
            self.left_child = None 
```

为了测试这个类，我们首先要创建四个节点——`n1`、`n2`、`n3`和`n4`：

```py
    n1 = Node("root node")  
    n2 = Node("left child node") 
    n3 = Node("right child node") 
    n4 = Node("left grandchild node") 
```

接下来，我们根据二叉树的属性将节点连接起来。我们让`n1`成为根节点，`n2`和`n3`成为它的子节点。最后，我们将`n4`作为`n2`的左子节点。看一下下面的图表，看看我们如何将这些节点连接起来：

![](img/9775f219-4ae9-4ffb-a41b-391cb5ed7c2f.png)

接下来的代码片段应该按照前面的图表连接节点：

```py
    n1.left_child = n2 
    n1.right_child = n3 
    n2.left_child = n4 
```

在这里，我们设置了一个非常简单的四个节点的树结构。我们想要在树上执行的第一个重要操作是遍历。为了理解遍历，让我们遍历这棵二叉树的左子树。我们将从根节点开始，打印出节点，并向下移动到下一个左节点。我们一直这样做，直到我们到达左子树的末端，就像这样：

```py
    current = n1 
    while current: 
        print(current.data) 
        current = current.left_child 
```

遍历上述代码块的输出如下：

```py
root node 
left child node 
left grandchild node
```

# 树的遍历

访问树中所有节点的方法称为**树的遍历**。这可以通过**深度优先搜索**（**DFS**）或**广度优先搜索**（**BFS**）来完成。我们将在接下来的小节中讨论这两种方法。

# 深度优先遍历

在深度优先遍历中，我们从根开始遍历树，并尽可能深入每个子节点，然后继续遍历到下一个兄弟节点。我们使用递归方法进行树遍历。深度优先遍历有三种形式，即中序、前序和后序。

# 中序遍历和中缀表示法

中序树遍历的工作方式如下。首先，我们检查当前节点是否为空或空。如果不为空，我们遍历树。在中序树遍历中，我们按照以下步骤进行：

1.  我们开始遍历左子树，并递归调用“中序”函数

1.  接下来，我们访问根节点

1.  最后，我们遍历右子树，并递归调用“中序”函数

因此，在“中序”树遍历中，我们按照（左子树、根、右子树）的顺序访问树中的节点。

让我们考虑一个示例来理解中序树遍历：

![](img/489c693f-15f5-4762-b70c-9ca81bbe5bb8.png)

在“中序”遍历的示例二叉树中，首先，我们递归访问根节点 A 的左子树。节点 A 的左子树以节点 B 为根，所以我们再次转到节点 B 的左子树，即节点 D。我们递归地转到节点 D 的左子树，以便我们得到根节点 D 的左子树。因此，我们首先访问左子节点，即 G，然后访问根节点 D，然后访问右子节点 H。

接下来，我们访问节点 B，然后访问节点 E。这样，我们已经访问了根节点 A 的左子树。所以下一步，我们访问根节点 A。之后，我们将访问根节点 A 的右子树。在这里，我们转到根节点 C 的左子树，它是空的，所以下一步我们访问节点 C，然后访问节点 C 的右子节点，即节点 F。

因此，这个示例树的中序遍历是“G-D-H-B-E-A-C-F”。

树的递归函数的 Python 实现，以返回树中节点的“中序”列表如下：

```py
    def inorder(self, root_node): 
        current = root_node 
        if current is None: 
            return 
        self.inorder(current.left_child) 
        print(current.data) 
        self.inorder(current.right_child) 
```

我们通过打印访问的节点来访问节点。在这种情况下，我们首先递归调用“中序”函数与`current.left_child`，然后访问根节点，最后我们再次递归调用“中序”函数与`current.right_child`。

中缀表示法（也称为逆波兰表示法）是一种常用的表示算术表达式的表示法，其中操作符放置在操作数之间。通常使用这种方式来表示算术表达式，因为这是我们在学校通常学到的方式。例如，操作符被插入（插入）在操作数之间，如`3 + 4`。必要时，可以使用括号来构建更复杂的表达式，例如`(4 + 5) * (5 - 3)`。

表达式树是一种特殊的二叉树，可用于表示算术表达式。表达式树的中序遍历产生中缀表示法。例如，考虑以下表达式树：

![](img/d46a0ed5-4f9f-406d-8028-c5bf7b0c17ed.png)

前面的表达式树的中序遍历给出了中缀表示法，即`(5 + 3)`。

# 前序遍历和前缀表示法

前序树遍历的工作方式如下。首先，我们检查当前节点是否为空或空。如果不为空，我们遍历树。前序树遍历的工作方式如下：

1.  我们从根节点开始遍历

1.  接下来，我们遍历左子树，并递归调用“前序”函数与左子树

1.  接下来，我们遍历右子树，并递归调用“前序”函数与右子树

因此，要以前序方式遍历树，我们按照根节点、左子树和右子树节点的顺序访问树。

考虑以下示例树以了解前序遍历：

![](img/f20499f8-7a4a-48f8-afc8-4269b864006d.png)

在上面的二叉树示例中，首先我们访问根节点**A**。接下来，我们转到根节点**A**的左子树。节点**A**的左子树以节点**B**为根，因此我们访问这个根节点，然后转到根节点**B**的左子树，即节点**D**。然后我们访问节点**D**，并转到根节点**D**的左子树，然后我们访问左子节点**G**，它是根节点**D**的子树。接下来，我们访问根节点**D**的右子节点，即节点**H**。接着，我们访问根节点**B**的右子树的右子节点，即节点**E**。因此，以这种方式，我们已经访问了根节点**A**和以根节点**A**为根的左子树。现在，我们将访问根节点**A**的右子树。在这里，我们访问根节点**C**，然后我们转到根节点**C**的左子树，它为空，所以下一步，我们访问节点**C**的右子节点，即节点**F**。

这个示例树的前序遍历将是`A-B-D-G-H-E-C-F`。

`pre-order`树遍历的递归函数如下：

```py
    def preorder(self, root_node): 
        current = root_node 
        if current is None: 
            return 
        print(current.data) 
        self.preorder(current.left_child) 
        self.preorder(current.right_child) 
```

前缀表示法通常被称为波兰表示法。在这种表示法中，运算符位于其操作数之前。前缀表示法是 LISP 程序员熟知的。例如，要添加两个数字 3 和 4 的算术表达式将显示为`+ 3 4`。由于没有运算符优先级的歧义，因此不需要括号：`* + 4 5 - 5 3`。

让我们考虑另一个例子，即`(3 +4) * 5`。这也可以用前缀表示法表示为`* (+ 3 4) 5`。

表达式树的前序遍历将得到算术表达式的前缀表示法。例如，考虑以下表达式树：

![](img/08f7ec34-8fde-4a49-86ae-6fbcaac63487.png)

上述树的前序遍历将以前缀表示法给出表达式为`+- 8 3 3`。

# 后序遍历和后缀表示法

`post-order`树遍历的工作方式如下。首先，我们检查当前节点是否为空。如果不为空，我们遍历树。`post-order`树遍历的工作方式如下：

1.  我们开始遍历左子树并递归调用`postorder`函数

1.  接下来，我们遍历右子树并递归调用`postorder`函数

1.  最后，我们访问根节点

因此，简而言之，关于`post-order`树遍历，我们按照左子树、右子树和最后根节点的顺序访问树中的节点。

考虑以下示例树以理解后序树遍历：

![](img/690334be-b950-44af-bf9d-ce1599bdefd8.png)

在上图中，我们首先递归访问根节点**A**的左子树。我们到达最后的左子树，也就是根节点 D，然后我们访问它的左节点，即节点**G**。然后，我们访问右子节点 H，然后我们访问根节点 D。按照相同的规则，我们接下来访问节点**B**的右子节点，即节点**E**。然后，我们访问节点**B**。接着，我们遍历节点**A**的右子树。在这里，我们首先到达最后的右子树并访问节点**F**，然后我们访问节点**C**。最后，我们访问根节点**A**。

这个示例树的后序遍历将是`G-H-D-E-B-F-C-A`。

树遍历的`post-order`方法的实现如下：

```py
    def postorder(self, root_node): 
        current = root_node 
        if current is None: 
            return 
        self.postorder(current.left_child) 
        self.postorder(current.right_child) 

        print(current.data)
```

后缀或**逆波兰表示法**（**RPN**）将运算符放在其操作数之后，如`3 4 +`。与波兰表示法一样，运算符的优先级不会引起混淆，因此永远不需要括号：`4 5 + 5 3 - *`。

以下表达式树的后序遍历将给出算术表达式的后缀表示法：

![](img/d133d129-c15f-41b9-bf01-a200e247e709.png)

上述表达式树的后缀表示法是`8 3 -3 +`。

# 广度优先遍历

广度优先遍历从树的根开始，然后访问树的下一级上的每个节点。然后，我们移动到树的下一级，依此类推。这种树遍历方式是广度优先的，因为它在深入树之前通过遍历一个级别上的所有节点来扩展树。

让我们考虑以下示例树，并使用广度优先遍历方法遍历它：

![](img/8d106753-e386-4549-9027-1709e4845e18.png)

在前面的图表中，我们首先访问**level 0**的根节点，即值为**4**的节点。我们通过打印出它的值来访问这个节点。接下来，我们移动到**level 1**并访问该级别上的所有节点，即值为**2**和**8**的节点。最后，我们移动到树的下一级，即**level 3**，并访问该级别上的所有节点。该级别上的节点是**1**，**3**，**5**和**10**。

因此，该树的广度优先遍历如下：**4**，**2**，**8**，**1**，**3**，**5**和**10**。

这种遍历模式是使用队列数据结构实现的。从根节点开始，我们将其推入队列。访问队列前面的节点（出队）并打印或存储以供以后使用。左节点被添加到队列，然后是右节点。由于队列不为空，我们重复这个过程。

该算法的 Python 实现将根节点**4**入队，出队并访问该节点。接下来，节点**2**和**8**入队，因为它们分别是下一级的左节点和右节点。节点**2**出队以便访问。接下来，它的左节点和右节点，即节点**1**和**3**，入队。此时队列前面的节点是**8**。我们出队并访问节点**8**，然后将其左节点和右节点入队。这个过程一直持续到队列为空。

广度优先遍历的 Python 实现如下：

```py
    from collections import deque 
    class Tree: 
        def breadth_first_traversal(self): 
            list_of_nodes = [] 
            traversal_queue = deque([self.root_node]) 
```

我们将根节点入队，并在`list_of_nodes`列表中保留访问过的节点的列表。使用`dequeue`类来维护队列：

```py
        while len(traversal_queue) > 0: 
            node = traversal_queue.popleft() 
            list_of_nodes.append(node.data) 
               if node.left_child: 
                traversal_queue.append(node.left_child) 

            if node.right_child: 
                traversal_queue.append(node.right_child) 
        return list_of_nodes
```

如果`traversal_queue`中的元素数量大于零，则执行循环体。队列前面的节点被弹出并附加到`list_of_nodes`列表中。第一个`if`语句将左子节点入队，如果提供了左节点则存在。第二个`if`语句对右子节点执行相同的操作。

`list_of_nodes`列表在最后一个语句中返回。

# 二叉树

二叉树是每个节点最多有两个子节点的树。二叉树中的节点以左子树和右子树的形式组织。如果树有一个根 R 和两个子树，即左子树`T1`和右子树`T2`，那么它们的根分别称为左继和右继。

以下图表是一个具有五个节点的二叉树的示例：

![](img/6519f2a2-5a73-4a88-81c8-c30ca11ba492.png)

以下是我们对前面图表的观察：

+   每个节点都保存对右节点和左节点的引用，如果节点不存在

+   根节点用**5**表示

+   根节点有两个子树，左子树有一个节点，即值为**3**的节点，右子树有三个节点，值分别为**7**，**6**和**9**。

+   值为**3**的节点是左继节点，而值为**7**的节点是右继节点

常规的二叉树在树中排列元素方面没有其他规则。它只需满足每个节点最多有两个子节点的条件。

# 二叉搜索树

**二叉搜索树**（BST）是一种特殊的二叉树。它是计算机科学应用中最重要和最常用的数据结构之一。二叉搜索树是一棵结构上是二叉树的树，并且非常有效地在其节点中存储数据。它提供非常快速的搜索操作，插入和删除等操作也非常简单和方便。

如果树中任意节点的值大于其左子树中所有节点的值，并且小于或等于其右子树中所有节点的值，则称二叉树为二叉搜索树。例如，如果**K1**、**K2**和**K3**是三个节点树中的关键值（如下图所示），则应满足以下条件：

1.  *K2<=K1*的关键值

1.  关键值*K3>K1*

以下图表描述了这一点：

![](img/4ad947ef-1686-45c9-ae03-cb7620cb4aec.png)

让我们考虑另一个例子，以便更好地理解二叉搜索树。考虑以下树：

![](img/8d71ac43-cacf-4faf-91c6-338483487b3f.png)

这是 BST 的一个例子。在这棵树中，左子树中的所有节点都小于或等于该节点的值。同样，该节点的右子树中的所有节点都大于父节点的值。

测试我们的树是否具有 BST 的属性时，我们注意到根节点左子树中的所有节点的值都小于 5。同样，右子树中的所有节点的值都大于 5。这个属性适用于 BST 中的所有节点，没有例外。

考虑另一个二叉树的例子，让我们看看它是否是二叉搜索树。尽管以下图表看起来与前一个图表相似，但它并不符合 BST 的条件，因为节点**7**大于根节点**5**；然而，它位于根节点的左侧。节点**4**位于其父节点**7**的右子树中，这是不正确的。因此，以下图表不是二叉搜索树：

![](img/13e662dd-8b8f-445e-afec-59e6fc6dfad9.png)

# 二叉搜索树实现

让我们开始在 Python 中实现 BST。我们需要跟踪树的根节点，因此我们首先创建一个`Tree`类，其中包含对根节点的引用：

```py
    class Tree: 
        def __init__(self): 
            self.root_node = None 
```

这就是维护树状态所需的全部内容。让我们在下一节中研究树上的主要操作。

# 二叉搜索树操作

二叉搜索树上可以执行的操作包括`插入`、`删除`、`查找最小值`、`查找最大值`、`搜索`等。我们将在后续小节中讨论它们。

# 查找最小和最大节点

二叉搜索树的结构使得查找具有最大或最小值的节点非常容易。

要找到树中具有最小值的节点，我们从树的根开始遍历，并每次访问左节点，直到到达树的末端。类似地，我们递归遍历右子树，直到到达末端，以找到树中具有最大值的节点。

例如，考虑以下图表；我们从节点**6**向下移动到**3**，然后从节点**3**移动到**1**，以找到具有最小值的节点。类似地，要找到树中具有最大值的节点，我们从根向树的右侧移动，然后从节点**6**移动到节点**8**，然后从节点**8**移动到节点**10**以找到具有最大值的节点。以下是一个 BST 树的例子：

![](img/4b26eee0-da90-49ec-bcc6-bb7ab38cd8d1.png)

找到最小和最大节点的概念也适用于子树。因此，根节点为**8**的子树中的最小节点是节点**7**。同样，该子树中具有最大值的节点是**10**。

返回最小节点的 Python 实现如下：

```py
    def find_min(self): 
        current = self.root_node 
        while current.left_child: 
            current = current.left_child 

        return current 
```

`while`循环继续获取左节点并访问它，直到最后一个左节点指向`None`。这是一个非常简单的方法。

同样，以下是返回最大节点的方法的代码：

```py
    def find_max(self): 
        current = self.root_node 
        while current.right_child: 
            current = current.right_child 

        return current 
```

在 BST 中查找最小值或最大值的运行时间复杂度为 O(*h*)，其中`h`是树的高度。

基本上还有两个其他操作，即`insert`和`delete`，它们对 BST 非常重要。在对树应用这些操作时，确保我们保持 BST 树的属性是很重要的。

# 插入节点

在二叉搜索树上实现的最重要的操作之一是在树中插入数据项。正如我们已经讨论过的，关于二叉搜索树的属性，对于树中的每个节点，左子节点应该包含小于其自身值的数据，右子节点应该包含大于其值的数据。因此，我们必须确保每当我们在树中插入一个项目时，二叉搜索树的属性都得到满足。

例如，通过在树中插入数据项**5**、**3**、**7**和**1**来创建一个二叉搜索树。考虑以下内容：

1.  **插入 5：**我们从第一个数据项**5**开始。为此，我们将创建一个数据属性设置为**5**的节点，因为它是第一个节点。

1.  **插入 3：**现在，我们想添加值为**3**的第二个节点，以便将数据值**3**与根节点**5**的现有节点值进行比较：

由于节点值**3**小于**5**，它将被放置在节点**5**的左子树中。我们的 BST 将如下所示：

![](img/5cc8c9f2-30ef-4a54-8ccf-034a25fc7b6e.png)

树满足 BST 规则，即左子树中的所有节点都小于父节点。

1.  **插入 7：**要向树中添加值为**7**的另一个节点，我们从值为**5**的根节点开始比较：

![](img/825b1134-b2e5-4422-a074-0a9edd9500d3.png)

由于**7**大于**5**，值为**7**的节点被放置在此根节点的右侧。

1.  **插入 1：**让我们添加另一个值为**1**的节点。从树的根开始，我们比较**1**和**5**：

![](img/77b2a9ae-1353-4526-bce0-0d0071fa2db9.png)

这个比较表明**1**小于**5**，所以我们转到**5**的左节点，即值为**3**的节点：

![](img/cc62c702-3223-4bfc-817b-b4c688f3a41a.png)

当我们将**1**与**3**进行比较时，由于**1**小于**3**，我们向下移动到节点**3**的下一级并向左移动。然而，那里没有节点。因此，我们创建一个值为**1**的节点，并将其与节点**3**的左指针关联，以获得以下结构。在这里，我们有**4**个节点的最终二叉搜索树：

![](img/026ebb91-6c6b-43df-815f-0a4e2e2ff30a.png)

我们可以看到这个例子只包含整数或数字。因此，如果我们需要在二叉搜索树中存储字符串数据，在这种情况下字符串将按字母顺序进行比较。如果我们想在 BST 中存储自定义数据类型，我们必须确保我们的类支持排序。

给出了在 BST 中添加节点的`insert`方法的 Python 实现如下：

```py
def insert(self, data):
    node = Node(data) 
    if self.root_node is None: 
        self.root_node = node 
    else: 
        current = self.root_node 
        parent = None  
    while True: 
        parent = current 
        if node.data < parent.data: 
            current = current.left_child 
            if current is None: 
                    parent.left_child = node 
                    return 
            else: 
                    current = current.right_child 
                    if current is None: 
                        parent.right_child = node 
                        return
```

现在，让我们逐步理解`insert`函数的每条指令。我们将从函数声明开始：

```py
    def insert(self, data):
```

到目前为止，您已经习惯了我们将数据封装在节点中的事实。这样，我们将`node`类隐藏在客户端代码中，客户端只需要处理树：

```py
        node = Node(data) 
```

首先将进行检查，以找出是否有根节点。如果没有，新节点将成为根节点（没有根节点的树是不允许的）：

```py
        if self.root_node is None: 
            self.root_node = node 
        else: 
```

当我们沿着树向下走时，我们需要跟踪我们正在处理的当前节点以及其父节点。`current`变量总是用于此目的：

```py
        current = self.root_node 
        parent = None 
        while True: 
            parent = current 
```

在这里，我们必须进行比较。如果新节点中保存的数据小于当前节点中保存的数据，那么我们检查当前节点是否有左子节点。如果没有，这就是我们插入新节点的地方。否则，我们继续遍历：

```py
        if node.data < current.data: 
            current = current.left_child 
            if current is None: 
                parent.left_child = node 
                return 
```

现在，我们需要处理大于或等于的情况。如果当前节点没有右子节点，那么新节点将被插入为右子节点。否则，我们向下移动并继续寻找插入点：

```py
        else: 
            current = current.right_child 
            if current is None: 
                parent.right_child = node 
                return 
```

在 BST 中插入一个节点需要`O(h)`的时间，其中`h`是树的高度。

# 删除节点

BST 上的另一个重要操作是节点的`删除`或`移除`。在这个过程中，我们需要考虑三种情况。我们要删除的节点可能有以下情况：

+   **没有子节点**：如果没有叶节点，直接删除节点

+   **一个子节点**：在这种情况下，我们交换该节点的值与其子节点的值，然后删除该节点

+   **两个子节点**：在这种情况下，我们首先找到中序后继或前驱，与其交换值，然后删除该节点

第一种情况是最容易处理的。如果要删除的节点没有子节点，我们只需将其从其父节点中删除：

![](img/9a0542ba-4bd8-473e-9a43-23bfcd1b5bf2.png)

在上面的示例中，节点**A**没有子节点，所以我们将它从其父节点，即节点**Z**中删除。

另一方面，当我们要删除的节点只有一个子节点时，该节点的父节点被指向该节点的子节点。让我们看一下下面的图表，我们要删除节点**6**，它只有一个子节点，即节点**5**：

![](img/31d35eef-0bc8-40a2-981d-aea941d428a2.png)

为了删除只有一个子节点的节点**6**，我们将节点**9**的左指针指向节点**5**。在这里，我们需要确保子节点和父节点的关系遵循二叉搜索树的属性。

当我们要删除的节点有两个子节点时，会出现更复杂的情况。考虑以下示例树，我们要删除节点**9**，它有两个子节点：

![](img/038348fb-2f25-4010-96a1-1e817fa197ab.png)

我们不能简单地用节点**6**或**13**替换节点**9**。我们需要找到节点**9**的下一个最大的后代。这是节点**12**。要到达节点**12**，我们移动到节点**9**的右节点，然后向左移动以找到最左边的节点。节点**12**被称为节点**9**的中序后继。第二步类似于查找子树中的最大节点。

我们用节点**9**的值替换节点**9**的值，并删除节点**12**。删除节点**12**后，我们得到了一个更简单的节点删除形式，这是之前讨论过的。节点 12 没有子节点，所以我们相应地应用了删除没有子节点的节点的规则。

我们的`node`类没有父节点的引用。因此，我们需要使用一个辅助方法来`搜索`并返回带有其父节点的节点。这个方法类似于`搜索`方法：

```py
    def get_node_with_parent(self, data): 
        parent = None 
        current = self.root_node 
        if current is None: 
            return (parent, None) 
        while True: 
            if current.data == data: 
                return (parent, current) 
            elif current.data > data: 
                parent = current 
                current = current.left_child 
            else: 
                parent = current 
                current = current.right_child 

        return (parent, current) 
```

唯一的区别是在更新循环内的当前变量之前，我们用`parent = current`存储它的父节点。实际删除节点的方法始于这个搜索：

```py
    def remove(self, data): 
        parent, node = self.get_node_with_parent(data) 

        if parent is None and node is None: 
            return False 

        # Get children count 
        children_count = 0 

        if node.left_child and node.right_child: 
            children_count = 2 
        elif (node.left_child is None) and (node.right_child is None): 
            children_count = 0 
        else: 
            children_count = 1 
```

我们将父节点和找到的节点分别传递给`parent`和`node`，使用`parent, node = self.get_node_with_parent(data)`。了解要删除的节点有多少个子节点是很重要的，我们在`if`语句中这样做。

在我们知道要删除的节点有多少个子节点之后，我们需要处理节点可以被删除的各种情况。`if`语句的第一部分处理了节点没有子节点的情况：

```py
        if children_count == 0: 
            if parent: 
                if parent.right_child is node: 
                    parent.right_child = None 
                else: 
                    parent.left_child = None 
            else: 
                self.root_node = None
```

在要删除的节点只有一个子节点的情况下，`if`语句的`elif`部分执行以下操作：

```py
        elif children_count == 1: 
            next_node = None 
            if node.left_child: 
                next_node = node.left_child 
            else: 
                next_node = node.right_child 

            if parent: 
                if parent.left_child is node: 
                    parent.left_child = next_node 
                else: 
                    parent.right_child = next_node 
            else: 
                self.root_node = next_node 
```

`next_node`用于跟踪单个节点，该节点是要删除的节点的子节点。然后，我们将`parent.left_child`或`parent.right_child`连接到`next_node`。

最后，我们处理了要删除的节点有两个子节点的情况：

```py
        ... 
        else: 
            parent_of_leftmost_node = node 
            leftmost_node = node.right_child 
            while leftmost_node.left_child: 
                parent_of_leftmost_node = leftmost_node 
                leftmost_node = leftmost_node.left_child 

            node.data = leftmost_node.data 
```

在查找中序后继时，我们移动到右节点，使用`leftmost_node = node.right_child`。只要左节点存在，`leftmost_node.left_child`将计算为`True`，并且`while`循环将运行。当我们到达最左边的节点时，它要么是叶节点（意味着它将没有子节点），要么有一个右子节点。

我们使用`node.data = leftmost_node.data`来更新即将被删除的节点的值为中序后继的值：

```py
    if parent_of_leftmost_node.left_child == leftmost_node: 
       parent_of_leftmost_node.left_child = leftmost_node.right_child 
    else: 
       parent_of_leftmost_node.right_child = leftmost_node.right_child
```

上述语句允许我们正确地将左子树节点的父节点与任何子节点连接起来。请注意等号右侧保持不变。这是因为中序后继只能有一个右子节点作为其唯一子节点。

`remove`操作的时间复杂度为`O(*h*)`，其中`h`是树的高度。

# 搜索树

二叉搜索树是一种树形数据结构，其中所有节点都遵循这样的属性：节点的左子树中的所有节点具有较低的键值，在其右子树中具有较大的键值。因此，搜索具有给定键值的元素非常容易。让我们考虑一个示例二叉搜索树，其中的节点为**1**、**2**、**3**、**4**、**8**、**5**和**10**，如下图所示：

![](img/5c287e15-284f-4eab-99f3-7efe3b2b34c5.png)

在上述树中，如果我们想要搜索值为**5**的节点，则我们从根节点开始，并将其与根节点进行比较。由于节点**5**的值大于根节点值**4**，我们移动到右子树。在右子树中，我们有节点**8**作为根节点；我们将节点**5**与节点**8**进行比较。由于要搜索的节点的值小于节点**8**，我们移动到左子树。当我们移动到左子树时，我们将左子树节点**5**与值为**5**的所需节点进行比较。这是一个匹配，所以我们返回“找到项目”。

以下是二叉搜索树中`searching`方法的实现：

```py
  def search(self, data):
        current = self.root_node
        while True:
            if current is None:
                return None
            elif current.data is data:
                return data
            elif current.data > data:
                current = current.left_child
            else:
                current = current.right_child

```

在上述代码中，如果找到数据，我们将返回数据，如果未找到数据，则返回`None`。我们从根节点开始搜索。接下来，如果要搜索的数据项不存在于树中，则我们将返回`None`给客户端代码。我们也可能已经找到了数据，如果是这种情况，我们将返回数据。

如果我们要搜索的数据小于当前节点的数据，则我们向树的左侧移动。此外，在代码的`else`部分中，我们检查我们要查找的数据是否大于当前节点中保存的数据，这意味着我们向树的右侧移动。

最后，我们可以编写一些客户端代码来测试 BST 的工作原理。我们必须创建一棵树，并在`1`和`10`之间插入一些数字。然后，我们搜索该范围内的所有数字。存在于树中的数字将被打印出来：

```py
    tree = Tree() 
    tree.insert(5) 
    tree.insert(2) 
    tree.insert(7) 
    tree.insert(9) 
    tree.insert(1) 

    for i in range(1, 10): 
        found = tree.search(i) 
        print("{}: {}".format(i, found)) 
```

# 二叉搜索树的好处

二叉搜索树与数组和链表相比是更好的选择。对于大多数操作，如搜索、插入和删除，BST 都很快，而数组提供了快速的搜索，但在插入和删除操作上相对较慢。同样，链表在执行插入和删除操作时效率很高，但在执行搜索操作时速度较慢。在二叉搜索树中搜索元素的“最佳情况”运行时间复杂度为`O(log n)`，而“最坏情况”时间复杂度为`O(n)`，而在列表中搜索的“最佳情况”和“最坏情况”时间复杂度均为`O(n)`。

以下表格提供了数组、链表和二叉搜索树数据结构的比较：

| **属性** | **数组** | **链表** | **BST** |
| --- | --- | --- | --- |
| **数据结构** | 线性。 | 线性。 | 非线性。 |
| **易用性** | 创建和使用都很容易。搜索、插入和删除的平均情况复杂度为`O(n)`。 | 插入和删除很快，特别是使用双向链表。 | 元素访问、插入和删除都很快，平均情况复杂度为`O(log n)`。 |
| **访问复杂度** | 访问元素容易。复杂度为`O(1)`。 | 只能进行顺序访问，所以很慢。平均和最坏情况下的复杂度是`O(n)`。 | 访问很快，但当树不平衡时很慢，最坏情况下的复杂度为`O(n)`。 |
| **搜索复杂度** | 平均和最坏情况下的复杂度是`O(n)`。 | 由于顺序搜索，所以很慢。平均和最坏情况下的复杂度是`O(n)`。 | 搜索的最坏情况复杂度是`O(n)`。 |
| **插入复杂度** | 插入很慢。平均和最坏情况下的复杂度是`O(n)`。 | 平均和最坏情况下的复杂度是`O(1)`。 | 插入的最坏情况复杂度是`O(n)`。 |
| **删除复杂度** | 删除很慢。平均和最坏情况下的复杂度是`O(n)`。 | 平均和最坏情况下的复杂度是`O(1)`。 | 删除的最坏情况复杂度是`O(n)`。 |

让我们举个例子来理解何时使用二叉搜索树来存储数据是一个好选择。假设我们有以下数据节点——**5**，**3**，**7**，**1**，**4**，**6**和**9**。如果我们使用列表来存储这些数据，最坏的情况将需要我们搜索整个包含七个元素的列表来找到这个项目。因此，在这个数据节点中，需要七次比较来搜索项目**9**：

![](img/2ebb36ce-b7e3-4149-833f-fe26f1d5e61e.png)

然而，如果我们使用二叉搜索树来存储这些值，如下图所示，在最坏的情况下，我们需要三次比较来搜索项目**9**：

![](img/9232922d-cb33-4d9f-8f58-3c09482b5e0c.png)

然而，重要的是要注意搜索效率也取决于我们如何构建二叉搜索树。如果树没有被正确构建，它可能会很慢。例如，如果我们按照{**1**，**3**，**4**，**5**，**6**，**7**，**9**}的顺序将元素插入到树中，如下图所示，那么树将不会比列表更有效：

![](img/72619b66-237f-4771-a7bc-0211b8e82bee.png)

因此，选择自平衡树有助于改善`搜索`操作。在这里，我们应该注意，二叉搜索树在大多数情况下是更好的选择；然而，我们应该尝试平衡树。

# 平衡树

我们已经在前一节中看到，如果节点按顺序插入到树中，它会变得很慢，行为上更像一个列表；也就是说，每个节点恰好有一个子节点。为了提高树数据结构的性能，我们通常希望尽可能减少树的高度，通过填充树中的每一行来平衡树。这个过程称为**平衡树**。

有不同类型的自平衡树，如红黑树、AA 树和替罪羊树。这些树在修改树的每个操作期间平衡树，比如插入或删除。还有一些外部算法来平衡树。这些方法的好处是你不需要在每次操作中都平衡树，可以在需要时再进行平衡。

# 表达树

算术表达式由操作数和运算符的组合表示，其中运算符可以是一元或二元。算术表达式也可以使用**二叉树**表示，称为表达式树。这种树结构也可以用于解析算术和布尔表达式。在表达式树中，所有叶节点包含操作数，非叶节点包含运算符。我们还应该注意，表达式树的子树（右子树或左子树）在一元运算符的情况下将为空。

例如，`3 + 4`的表达式树如下所示：

![](img/8286c09a-c33a-4d43-907e-8955d357ad4b.png)

对于稍微复杂的表达式`(4 + 5) * (5-3)`，我们将得到以下结果：

![](img/cf45c4ca-4483-4c7e-81dd-cab97ec9ba5f.png)

算术表达式可以用三种符号表示（即中缀、后缀和前缀），如前一节中关于树遍历的讨论所述。因此，对于给定的算术表达式，评估表达式树变得容易。逆波兰符号提供更快的计算。我们将在以下小节中向您展示如何构建给定后缀符号的表达式树。

# 解析逆波兰表达式

现在，我们将为后缀表示法中的表达式构建树。然后，我们将计算结果。我们将使用一个简单的树实现。为了保持简单，因为我们将通过合并较小的树来增加树，我们只需要一个树节点实现：

```py
    class TreeNode: 
        def __init__(self, data=None): 
            self.data = data 
            self.right = None 
            self.left = None 
```

为了构建树，我们将使用堆栈列出项目。让我们创建一个算术表达式并设置我们的堆栈：

```py
        expr = "4 5 + 5 3 - *".split() 
        stack = Stack() 
```

由于 Python 是一种试图具有合理默认值的语言，其`split()`方法默认在空格上拆分。（如果您考虑一下，这很可能是您所期望的。）结果将是`expr`是一个包含值`4`、`5`、`+`、`5`、`3`、`-`和`*`的列表。

`expr`列表的每个元素将是运算符或操作数。如果我们得到一个操作数，那么我们将其嵌入树节点并将其推送到堆栈上。另一方面，如果我们得到一个运算符，那么我们将运算符嵌入树节点，并将其两个操作数弹出到节点的左右子节点中。在这里，我们必须确保第一个弹出进入右子节点；否则，我们将在减法和除法中出现问题。

以下是构建树的代码：

```py
    for term in expr: 
        if term in "+-*/": 
            node = TreeNode(term) 
            node.right = stack.pop() 
            node.left = stack.pop() 
        else: 
            node = TreeNode(int(term)) 
        stack.push(node) 
```

请注意，在操作数的情况下，我们执行了从`string`到`int`的转换。如果您希望支持浮点操作数，可以使用`float()`。

在此操作结束时，我们应该在堆栈中有一个单一元素，并且该元素包含完整的树。如果我们想要评估表达式，我们将构建以下小函数：

```py
    def calc(node): 
        if node.data is "+": 
            return calc(node.left) + calc(node.right) 
        elif node.data is "-": 
            return calc(node.left) - calc(node.right) 
        elif node.data is "*": 
            return calc(node.left) * calc(node.right) 
        elif node.data is "/": 
            return calc(node.left) / calc(node.right) 
        else: 
            return node.data 
```

在上述代码中，我们将一个节点传递给函数。如果节点包含操作数，那么我们只需返回该值。如果我们得到一个运算符，那么我们将在节点的两个子节点上执行运算符表示的操作。然而，由于一个或多个子节点也可能包含运算符或操作数，我们在两个子节点上递归调用`calc()`函数（要记住每个节点的所有子节点也都是节点）。

现在，我们只需要从堆栈中弹出根节点并将其传递给`calc()`函数。然后，我们应该得到计算的结果：

```py
    root = stack.pop() 
    result = calc(root) 
    print(result) 
```

运行此程序应该产生结果`18`，这是`(4 + 5) * (5 - 3)`的结果。

# 堆

堆数据结构是树的一种特殊形式，其中节点以特定方式排序。堆分为`max`堆和`min`堆。

在`max`堆中，每个父节点的值必须始终大于或等于其子节点。由此可知，根节点必须是树中最大的值。考虑以下最大堆的图表，其中所有节点的值都大于其子节点的值：

![](img/d0bd32c7-21a2-4f0b-a2a9-908d904f5933.png)

在`min`堆中，每个父节点必须小于或等于其两个子节点。因此，根节点包含最小值。考虑以下最小堆的图表，其中所有节点的值都小于其子节点的值：

![](img/5bc4330e-b3b1-4dad-bace-f5ee12e66be2.png)

堆用于许多不同的事情。首先，它们用于实现优先级队列。还有一种非常高效的排序算法，称为**堆排序**，它使用堆。我们将在后续章节中深入研究这些内容。

# 三元搜索树

三元树是一种数据结构，树的每个节点最多可以包含`3`个子节点。与二叉搜索树相比，它不同之处在于二叉树中的节点最多可以有`2`个子节点，而三元树中的节点最多可以有`3`个子节点。三元树数据结构也被认为是字典树数据结构的特殊情况。在字典树数据结构中，当我们使用字典树数据结构存储字符串时，每个节点包含 26 个指向其子节点的指针，而在三元搜索树数据结构中，我们有 3 个指向其子节点的指针。

三元搜索树可以表示如下：

+   每个节点都存储一个字符

+   它具有指向存储与当前节点相等值的节点的等指针

+   它具有指向存储小于当前节点值的节点的左指针

+   它具有指向存储大于当前节点值的节点的右指针

+   每个节点都有一个标志变量，用于跟踪该节点是否是字符串的结尾

为了更好地理解三元搜索树数据结构，我们将通过一个示例来演示，其中我们将字符串**PUT**，**CAT**，**SIT**，**SING**和**PUSH**插入到一个空的三元树中，如下图所示：

![](img/0f216d85-eb1f-46d4-b73f-6f5234881607.png)

将值插入三元搜索树与在二叉搜索树中进行的方式非常相似。在三元搜索树中，我们遵循以下步骤将字符串插入三元搜索树：

1.  由于树最初为空，我们首先创建根节点，其中包含第一个字符**P**，然后我们为字符**U**创建另一个节点，最后是字符**T**。

1.  接下来，我们希望添加单词**CAT**。首先，我们将第一个字符**C**与根节点字符**P**进行比较。由于不匹配，并且它小于根节点，我们在根节点的左侧为字符**C**创建一个新节点。此外，我们创建了字符**A**和**T**的节点。

1.  接下来，我们添加一个新单词**SIT**。首先，我们将第一个字符**S**与根节点字符**P**进行比较。由于不匹配，并且字符**S**大于字符**P**，我们在右侧为字符**S**创建一个新节点。此外，我们创建了字符**I**和**T**的节点。

1.  接下来，我们将单词**SING**插入到三叉搜索树中。我们首先将第一个字符**S**与根节点进行比较。由于不匹配，并且字符**S**大于根节点**P**，我们查看右侧的下一个字符，即**S**。这里，字符匹配，因此我们比较下一个字符**I**；这也匹配。接下来，我们将字符**N**与树中的字符**T**进行比较。这里，字符不匹配，因此我们移动到节点**T**的左侧。在这里，我们为字符**N**创建一个新节点。此外，我们为字符**G**创建另一个新节点。

1.  然后，在三叉搜索树中添加一个新节点**PUSH**。首先，我们比较单词的第一个字符，即**P**，与根节点。由于匹配，我们查看三叉树中的下一个字符。这里，字符**U**也与单词的下一个字符匹配。因此，我们查看单词的下一个字符，即**S**。它与树中的下一个字符**T**不匹配。因此，我们在节点**T**的左侧为字符**S**创建一个新节点，因为字符**S**小于**T**。接下来，我们为下一个字符**H**创建另一个节点。

请注意，三叉树中的每个节点都通过使用标志变量来跟踪哪个节点是叶节点或非叶节点。

三叉搜索树非常适用于字符串搜索相关的应用，比如当我们希望搜索所有以特定前缀开头的字符串，或者当我们希望搜索以特定数字开头的电话号码，拼写检查等等。

# 总结

在本章中，我们研究了树数据结构及其用途。特别是我们研究了二叉树，这是树的一个子类型，其中每个节点最多有两个子节点。我们还看了二叉树如何作为可搜索的数据结构与 BST 一起使用。广度优先和深度优先搜索遍历模式也通过使用队列递归在 Python 中实现。

我们还看了二叉树如何用来表示算术或布尔表达式。然后，我们构建了一个表达式树来表示算术表达式。之后，我们向您展示了如何使用栈来解析以逆波兰表示法编写的表达式，构建表达式树，并最终遍历它以获得算术表达式的结果。

最后，我们提到了堆，这是树结构的一种特殊形式。我们在本章至少尝试奠定了堆的理论基础，以便在接下来的章节中为不同的目的实现堆。

在下一章中，我们将讨论哈希表和符号表的细节。
