- en: Python Data Types and Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python数据类型和结构
- en: In this chapter, we are going to examine Python data types in more detail. We
    have already introduced two data types, the string and list, `str()` and `list()`.
    However, these data types are not sufficient, and we often need more specialized
    data objects to represent/store our data. Python has various other standard data
    types that are used to store and manage data, which we will be discussing in this
    chapter. In addition to the built-in types, there are several internal modules
    that allow us to address common issues when working with data structures. First,
    we are going to review some operations and expressions that are common to all
    data types, and we will discuss more related to data types in Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更详细地研究Python数据类型。我们已经介绍了两种数据类型，字符串和列表，`str()`和`list()`。然而，这些数据类型是不够的，我们经常需要更专门的数据对象来表示/存储我们的数据。
    Python有各种其他标准数据类型，用于存储和管理数据，我们将在本章中讨论。除了内置类型之外，还有几个内部模块，允许我们解决处理数据结构时的常见问题。首先，我们将回顾一些适用于所有数据类型的操作和表达式，并将讨论更多与Python数据类型相关的内容。
- en: 'This chapter''s objectives are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标如下：
- en: Understanding various important built-in data types supported in Python 3.7
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Python 3.7支持的各种重要内置数据类型
- en: Exploring various additional collections of high-performance alternatives to
    built-in data types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索各种高性能替代品的其他附加集合，以替代内置数据类型
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All of the code used in this chapter is given at the following GitHub link: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter02).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有代码都在以下GitHub链接中提供：[https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter02)。
- en: Built-in data types
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置数据类型
- en: 'Python data types can be divided into three categories: numeric, sequence,
    and mapping. There is also the `None` object that represents `Null`, or the absence
    of a value. It should not be forgotten that other objects such as classes, files,
    and exceptions can also properly be considered *types*; however, they will not
    be considered here.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Python数据类型可以分为三类：数字、序列和映射。还有一个表示`Null`或值的缺失的`None`对象。不应忘记其他对象，如类、文件和异常也可以被正确地视为*类型*；但是，它们在这里不会被考虑。
- en: Every value in Python has a data type. Unlike many programming languages, in Python
    you do not need to explicitly declare the type of a variable. Python keeps track
    of object types internally.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的每个值都有一个数据类型。与许多编程语言不同，在Python中，您不需要显式声明变量的类型。Python在内部跟踪对象类型。
- en: 'Python built-in data types are outlined in the following table:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python内置数据类型概述如下表所示：
- en: '| **Category** | **Name** | **Description** |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **名称** | **描述** |'
- en: '| None | `None` | It is a null object. |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| None | `None` | 它是一个空对象。 |'
- en: '| Numeric | `int` | This is an integer data type. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 数字 | `int` | 这是一种整数数据类型。 |'
- en: '|  | `float` | This data type can store a floating-point number. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  | `float` | 这种数据类型可以存储浮点数。 |'
- en: '|  | `complex` | It stores a complex number. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|  | `complex` | 它存储复数。 |'
- en: '|  | `bool` | It is Boolean type and returns `True` or `False`. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '|  | `bool` | 它是布尔类型，返回`True`或`False`。 |'
- en: '| Sequences | `str` | It is used to store a string of characters. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 序列 | `str` | 用于存储一串字符。 |'
- en: '|  | `liXst` | It can store a list of arbitrary objects. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '|  | `liXst` | 它可以存储任意对象的列表。 |'
- en: '|  | `Tuple` | It can store a group of arbitrary items. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  | `Tuple` | 它可以存储一组任意项目。 |'
- en: '|  | `range` | It is used to create a range of integers. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '|  | `range` | 用于创建一系列整数。 |'
- en: '| Mapping | `dict` | It is a dictionary data type that stores data in *key/value*
    pairs. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 映射 | `dict` | 它是一种以*键/值*对存储数据的字典数据类型。 |'
- en: '|  | `set` | It is a mutable and unordered collection of unique items. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  | `set` | 它是一个可变的无序唯一项集合。 |'
- en: '|  | `frozenset` | It is an immutable set. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|  | `frozenset` | 它是一个不可变的集合。 |'
- en: None type
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: None类型
- en: The `None` type is immutable. It is used as `None` to show the absence of a
    value; it is similar to `null` in many programming languages, such as C and C++.
    Objects return `None` when there is actually nothing to return. It is also returned
    by `False` Boolean expressions. `None` is often used as a default value in function
    arguments to detect whether a function call has passed a value or not.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`类型是不可变的。它用作`None`来表示值的缺失；它类似于许多编程语言中的`null`，如C和C++。当实际上没有要返回的内容时，对象返回`None`。当`False`布尔表达式时，也会返回`None`。`None`经常用作函数参数的默认值，以检测函数调用是否传递了值。'
- en: Numeric types
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字类型
- en: 'Number types include integers (`int`), that is, whole numbers of unlimited
    range, floating-point numbers (`float`), complex numbers (`complex`), which are
    represented by two float numbers, and Boolean (`bool`) in Python. Python provides
    the `int` data type that allows standard arithmetic operators (`+`, `-`, `*` and
    `/` ) to work on them, similar to other programming languages. A Boolean data
    type has two possible values, `True` and `False`. These values are mapped to `1`
    and `0`, respectively. Let''s consider an example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 数字类型包括整数（`int`），即无限范围的整数，浮点数（`float`），复数（`complex`），由两个浮点数表示，以及布尔值（`bool`）在Python中。
    Python提供了允许标准算术运算符（`+`，`-`，`*`和`/`）对它们进行操作的`int`数据类型，类似于其他编程语言。布尔数据类型有两个可能的值，`True`和`False`。这些值分别映射为`1`和`0`。让我们考虑一个例子：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `a` and `b` variables are of the `int` type and `c` is a floating-point
    type. The division operator (`/`) always returns a `float` type; however, if you
    wish to get the `int` type after division, you can use the floor division operator
    (`//`), which discards any fractional part and will return the largest integer
    value that is less than or equal to `x`. Consider the following example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`a`和`b`是`int`类型，`c`是浮点类型。除法运算符（`/`）始终返回`float`类型；但是，如果希望在除法后获得`int`类型，可以使用地板除法运算符（`//`），它会丢弃任何小数部分，并返回小于或等于`x`的最大整数值。考虑以下例子：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is advised that readers use the division operator carefully, as its function
    differs according to the Python version. In Python 2, the division operator returns
    only `integer`, not `float`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 建议读者谨慎使用除法运算符，因为其功能根据Python版本而异。在Python 2中，除法运算符仅返回`integer`，而不是`float`。
- en: 'The exponent operator (`**`) can be used to get the power of a number (for
    example, `x ** y`), and the modulus operator (`%`) returns the remainder of the
    division (for example, `a% b` returns the remainder of `a/b`):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 指数运算符（`**`）可用于获取数字的幂（例如，`x ** y`），模数运算符（`%`）返回除法的余数（例如，`a% b`返回`a/b`的余数）：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Complex numbers are represented by two floating-point numbers. They are assigned
    using the `j` operator to signify the imaginary part of the complex number. We
    can access the real and imaginary parts with `f.real` and `f.imag`, respectively,
    as shown in the following code snippet. Complex numbers are generally used for
    scientific computations. Python supports addition, subtraction, multiplication,
    power, conjugates, and so forth on complex numbers, as shown in the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 复数由两个浮点数表示。它们使用`j`运算符分配，以表示复数的虚部。我们可以通过`f.real`和`f.imag`访问实部和虚部，如下面的代码片段所示。复数通常用于科学计算。Python支持复数的加法，减法，乘法，幂，共轭等，如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In Python, Boolean types are represented using  truth values, that is, `True`
    and `False`; it''s similar to `0` and `1`*.* There is a `bool` class in Python,
    which returns `True` or `False`. Boolean values can be combined with logical operators
    such as `and`, `or`, and `not`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，布尔类型使用真值表示，即`True`和`False`；这类似于`0`和`1`。Python中有一个`bool`类，返回`True`或`False`。布尔值可以与逻辑运算符（如`and`，`or`和`not`）结合使用：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A Boolean operation returns either `True` or `False`. Boolean operations are
    ordered in priority, so if more than one Boolean operation occurs in an expression,
    the operation with the highest priority will occur first. The following table
    outlines the three Boolean operators in descending order of priority:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔运算返回`True`或`False`。布尔运算按优先级排序，因此如果表达式中出现多个布尔运算，则优先级最高的运算将首先发生。以下表格按优先级降序列出了三个布尔运算符：
- en: '| **Operator** | **Example** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **运算符** | **示例** |'
- en: '| `not x` | It returns `False` if `x` is `True`, and returns `True` if `x`
    is `False`. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `not x` | 如果`x`为`True`，则返回`False`，如果`x`为`False`，则返回`True`。 |'
- en: '| `x and y` | It returns `True` if `x` and `y` are both `True`; otherwise,
    it returns `False`. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `x and y` | 如果`x`和`y`都为`True`，则返回`True`；否则返回`False`。 |'
- en: '| `x or` `y` | It returns `True` if either `x` or `y` is `True`; otherwise,
    it returns `False`. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `x or` `y` | 如果`x`或`y`中有一个为`True`，则返回`True`；否则返回`False`。 |'
- en: Python is very efficient when evaluating Boolean expressions as it will only
    evaluate an operator if it needs to. For example, if `x` is `True` in an expression
    `x or y`, then there is no need to evaluate `y` since the expression is `True`
    anyway—that is why in Python the `y` is not evaluated. Similarly, in an expression `x and y`*,*
    if `x` is `False`, the interpreter will simply evaluate `x` and return `False`,
    without evaluating `y`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Python在评估布尔表达式时非常高效，因为它只在需要时评估运算符。例如，如果在表达式`x or y`中`x`为`True`，则无需评估`y`，因为表达式无论如何都是`True`，这就是为什么在Python中不会评估`y`。类似地，在表达式`x
    and y`中，如果`x`为`False`，解释器将简单地评估`x`并返回`False`，而不会评估`y`。
- en: 'The comparison operators (`<`, `<=`, `>`, `>=`, `==`, and `!=`) work with numbers,
    lists, and other collection objects and return `True` if the condition holds.
    For collection objects, comparison operators compare the number of elements and
    the equivalence operator ( `==`) returns `True` if each collection object is structurally
    equivalent, and the value of each element is identical. Let''s see an example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符（`<`，`<=`，`>`，`>=`，`==`和`!=`）适用于数字，列表和其他集合对象，并在条件成立时返回`True`。对于集合对象，比较运算符比较元素的数量，等价运算符（`==`）在每个集合对象在结构上等价且每个元素的值相同时返回`True`。让我们看一个例子：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Representation error
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示错误
- en: 'It should be noted that the native double precision representation of floating-point
    numbers leads to some unexpected results. For example, consider the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，浮点数的本机双精度表示会导致一些意外的结果。例如，考虑以下情况：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is a result of the fact that most decimal fractions are not exactly representable
    as a binary fraction, which is how most underlying hardware represents floating-point
    numbers. For algorithms or applications where this may be an issue, Python provides
    a decimal module. This module allows for the exact representation of decimal numbers
    and facilitates greater control of properties, such as rounding behavior, number
    of significant digits, and precision. It defines two objects, a `Decimal` type,
    representing decimal numbers, and a `Context` type, representing various computational
    parameters such as precision, rounding, and error handling. An example of its
    usage can be seen in the following snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为大多数十进制小数无法准确表示为二进制小数，这是大多数底层硬件表示浮点数的方式。对于可能存在此问题的算法或应用程序，Python提供了一个decimal模块。该模块允许精确表示十进制数，并便于更好地控制属性，如舍入行为，有效数字的数量和精度。它定义了两个对象，一个表示十进制数的`Decimal`类型，另一个表示各种计算参数的`Context`类型，如精度，舍入和错误处理。其用法示例如下：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we have created a global context and set the precision to `4`. The `Decimal`
    object can be treated pretty much as you would treat `int` or `float`. They are
    subject to all of the same mathematical operations and can be used as dictionary
    keys, placed in sets, and so on. In addition, `Decimal` objects also have several
    methods for mathematical operations, such as natural exponents, `x.exp()`; natural
    logarithms, `x.ln()`; and base 10 logarithms, `x.log10()`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个全局上下文，并将精度设置为`4`。`Decimal`对象可以被视为`int`或`float`一样对待。它们可以进行相同的数学运算，并且可以用作字典键，放置在集合中等等。此外，`Decimal`对象还有几种数学运算的方法，如自然指数`x.exp()`，自然对数`x.ln()`和以10为底的对数`x.log10()`。
- en: 'Python also has a `fractions` module that implements a rational number type.
    The following example shows several ways to create fractions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Python还有一个`fractions`模块，实现了有理数类型。以下示例展示了创建分数的几种方法：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is also worth mentioning here the NumPy extension. This has types for mathematical
    objects, such as arrays, vectors, and matrices, and capabilities for linear algebra,
    calculation of Fourier transforms, eigenvectors, logical operations, and much
    more.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里还值得一提的是NumPy扩展。它具有数学对象的类型，如数组、向量和矩阵，以及线性代数、傅里叶变换、特征向量、逻辑操作等功能。
- en: Membership, identity, and logical operations
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成员资格、身份和逻辑操作
- en: 'Membership operators (`in` and `not in`) test for variables in sequences, such
    as lists or strings, and do what you would expect; `x in y` returns `True` if
    an `x` variable is found in `y`. The `is` operator compares object identity. For
    example, the following snippet shows contrast equivalence with object identity:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 成员资格运算符（`in`和`not in`）用于测试序列中的变量，如列表或字符串，并执行您所期望的操作；如果在`y`中找到了`x`变量，则`x in y`返回`True`。`is`运算符比较对象标识。例如，以下代码片段展示了对比等价性和对象标识：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sequences
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列
- en: Sequences are ordered sets of objects indexed by non-negative integers. Sequences
    include `string`, `list`, `tuple`, and `range` objects. Lists and tuples are sequences
    of arbitrary objects, whereas strings are sequences of characters. However, `string`,
    `tuple`, and `range` objects are immutable, whereas, the `list` object is mutable.
    All sequence types have a number of operations in common. Note that, for the immutable
    types, any operation will only return a value rather than actually change the
    value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 序列是由非负整数索引的对象的有序集合。序列包括`string`、`list`、`tuple`和`range`对象。列表和元组是任意对象的序列，而字符串是字符的序列。然而，`string`、`tuple`和`range`对象是不可变的，而`list`对象是可变的。所有序列类型都有许多共同的操作。请注意，对于不可变类型，任何操作都只会返回一个值，而不会实际更改该值。
- en: For all sequences, the indexing and slicing operators apply as described in
    the previous chapter. The `string` and `list` data types were discussed in detail
    in [Chapter 1](2818f56c-fbcf-422f-83dc-16cbdbd8b5bf.xhtml), *Python Objects, Types,
    and Expressions*. Here, we present some of the important methods and operations
    that are common to all of the sequence types (`string`, `list`, `tuple`, and `range`
    objects).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有序列，索引和切片操作适用于前一章节中描述的方式。`string`和`list`数据类型在[第1章](2818f56c-fbcf-422f-83dc-16cbdbd8b5bf.xhtml)中有详细讨论，*Python对象、类型和表达式*。在这里，我们介绍了一些对所有序列类型（`string`、`list`、`tuple`和`range`对象）都通用的重要方法和操作。
- en: 'All sequences have the following methods:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所有序列都有以下方法：
- en: '| **Method** | **Description** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `len(s)` | Returns the number of elements in `s`. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `len(s)` | 返回`s`中元素的数量。 |'
- en: '| `min(s,[,default=obj, key=func])` | Returns the minimum value in `s` (alphabetically
    for strings). |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `min(s,[,default=obj, key=func])` | 返回`s`中的最小值（对于字符串来说是按字母顺序）。 |'
- en: '| `max(s,[,default=obj, key=func])` | Returns the maximum value in `s` (alphabetically
    for strings). |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `max(s,[,default=obj, key=func])` | 返回`s`中的最大值（对于字符串来说是按字母顺序）。 |'
- en: '| `sum(s,[,start=0])` | Returns the sum of the elements (returns `TypeError`
    if `s`is not numeric). |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `sum(s,[,start=0])` | 返回元素的和（如果`s`不是数字，则返回`TypeError`）。 |'
- en: '| `all(s)` | Returns `True` if all elements in `s` are `True` (that is, not
    `0`, `False`, or `Null`). |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `all(s)` | 如果`s`中所有元素都为`True`（即不为`0`、`False`或`Null`），则返回`True`。 |'
- en: '| `any(s)` | Checks whether any item in `s` is `True`. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `any(s)` | 检查`s`中是否有任何项为`True`。 |'
- en: 'In addition, all sequences support the following operations:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有序列都支持以下操作：
- en: '| **Operation** | **Description** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **描述** |'
- en: '| `s+r` | Concatenates two sequences of the same type. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `s+r` | 连接两个相同类型的序列。 |'
- en: '| `s*n` | Makes `n` copies of `s`, where `n` is an integer. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `s*n` | 创建`n`个`s`的副本，其中`n`是整数。 |'
- en: '| `v1,v2...,vn=s` | Unpacks `n` variables from `s` to `v1`, `v2`, and so on.
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `v1,v2...,vn=s` | 从`s`中解包`n`个变量到`v1`、`v2`等。 |'
- en: '| `s[i]` | Indexing returns the `i` element of `s`. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `s[i]` | 索引返回`s`的第`i`个元素。 |'
- en: '| `s[i:j:stride]` | Slicing returns elements between `i` and `j` with optional
    stride. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `s[i:j:stride]` | 切片返回`i`和`j`之间的元素，可选的步长。 |'
- en: '| `x in s` | Returns `True` if the `x` element is in `s`. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `x in s` | 如果`s`中存在`x`元素，则返回`True`。 |'
- en: '| `x not in s` | Returns `True` if the `x` element is not in `s`. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `x not in s` | 如果`s`中不存在`x`元素，则返回`True`。 |'
- en: 'Let''s consider an example code snippet implementing some of the preceding
    operations on the `list` data type :'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个示例代码片段，实现了对`list`数据类型的一些前述操作：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Learning about tuples
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解元组
- en: Tuples are immutable sequences of arbitrary objects. A tuple is a comma-separated
    sequence of values; however, it is common practice to enclose them in parentheses.
    Tuples are very useful when we want to set up multiple variables in one line,
    or to allow a function to return multiple values of different objects. Tuple is
    an ordered sequence of items similar to the `list` data type. The only difference
    is that tuples are immutable; hence, once created they cannot be modified, unlike
    `list`. Tuples are indexed by integers greater than zero. Tuples are **hashable**,
    which means we can sort lists of them and they can be used as keys to dictionaries.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是任意对象的不可变序列。元组是一个逗号分隔的值序列；然而，通常的做法是将它们括在括号中。当我们想要在一行中设置多个变量，或者允许函数返回不同对象的多个值时，元组非常有用。元组是一种有序的项目序列，类似于`list`数据类型。唯一的区别是元组是不可变的；因此，一旦创建，它们就不能被修改，不像`list`。元组由大于零的整数索引。元组是**可散列**的，这意味着我们可以对它们的列表进行排序，并且它们可以用作字典的键。
- en: We can also create a tuple using the built-in function: `tuple()`. With no argument,
    this creates an empty tuple. If the argument to `tuple()` is a sequence then this
    creates a tuple of elements of that sequence. It is important to remember to use
    a trailing comma when creating a tuple with one element—without the trailing comma,
    this will be interpreted as a string. An important use of tuples is to allow us
    to assign more than one variable at a time by placing a tuple on the left-hand
    side of an assignment.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用内置函数`tuple()`创建一个元组。如果没有参数，这将创建一个空元组。如果`tuple()`的参数是一个序列，那么这将创建一个由该序列元素组成的元组。在创建只有一个元素的元组时，重要的是要记住使用尾随逗号——没有尾随逗号，这将被解释为一个字符串。元组的一个重要用途是通过在赋值的左侧放置一个元组来一次性分配多个变量。
- en: 'Consider an example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Most operators, such as those for slicing and indexing, work as they do on
    lists. However, because tuples are immutable, trying to modify an element of a
    tuple will give you `TypeError`. We can compare tuples in the same way that we
    compare other sequences, using the `==`, `>` and `<` operators. Consider an example
    code snippet:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数运算符，如切片和索引运算符，都像列表一样工作。然而，由于元组是不可变的，尝试修改元组的元素会导致`TypeError`。我们可以像比较其他序列一样比较元组，使用`==`、`>`和`<`运算符。考虑一个示例代码片段：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s consider another example to better understand tuples. For example, we
    can use multiple assignments to swap values in a tuple:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子来更好地理解元组。例如，我们可以使用多个赋值来交换元组中的值：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Beginning with dictionaries
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从字典开始
- en: 'In Python, the `Dictionary` data type is one of the most popular and useful
    data types. A dictionary stores the data in a mapping of key and value pair. Dictionaries
    are mainly a collection of objects; they are indexed by numbers, strings, or any
    other immutable objects. Keys should be unique in the dictionaries; however, the
    values in the dictionary can be changed. Python dictionaries are the only built-in
    mapping type; they can be thought of as a mapping from a set of keys to a set
    of values. They are created using the `{key:value}` syntax. For example, the following
    code can be used to create a dictionary that maps words to numerals using different
    methods:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，`字典`数据类型是最受欢迎和有用的数据类型之一。字典以键和值对的映射方式存储数据。字典主要是对象的集合；它们由数字、字符串或任何其他不可变对象索引。字典中的键应该是唯一的；然而，字典中的值可以被更改。Python字典是唯一的内置映射类型；它们可以被看作是从一组键到一组值的映射。它们使用`{key:value}`的语法创建。例如，以下代码可以用来创建一个将单词映射到数字的字典，使用不同的方法：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can add keys and values. We can also update multiple values, and test for
    the membership or occurrence of a value using the `in` operator, as shown in the
    following code example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加键和值。我们还可以更新多个值，并使用`in`运算符测试值的成员资格或出现情况，如下面的代码示例所示：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `in` operator to find an element in a list takes too much time if the list
    is long. The running time required to look up an element in a list increases linearly
    with an increase in the size of the list. Whereas, the `in` operator in dictionaries
    uses a hashing function, which enables dictionaries to be very efficient, as the
    time taken in looking up an element is independent of the size of the dictionary.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表很长，使用`in`运算符在列表中查找元素会花费太多时间。在列表中查找元素所需的运行时间随着列表大小的增加而线性增加。而字典中的`in`运算符使用哈希函数，这使得字典非常高效，因为查找元素所花费的时间与字典的大小无关。
- en: 'Notice when we print out the `{key: value}` pairs of the dictionary it does
    so in no particular order. This is not a problem since we use specified keys to
    look up each dictionary value rather than an ordered sequence of integers, as
    is the case for strings and lists:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '注意当我们打印字典的`{key: value}`对时，它并没有按特定顺序进行。这不是问题，因为我们使用指定的键来查找每个字典值，而不是一个有序的整数序列，就像对字符串和列表一样：'
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following table contains all the dictionary methods and their descriptions:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含了所有字典方法及其描述：
- en: '| **Method** | **Description** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `len(d)` | Returns total number of items in the dictionary, `d`. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `len(d)` | 返回字典`d`中的项目总数。 |'
- en: '| `d.clear()` | Removes all of the items from the dictionary, `d`. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `d.clear()` | 从字典`d`中删除所有项目。 |'
- en: '| `d.copy()` | Returns a shallow copy of the dictionary, `d`. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `d.copy()` | 返回字典`d`的浅拷贝。 |'
- en: '| `d.fromkeys(s[,value])` | Returns a new dictionary with keys from the `s`
    sequence and values set to `value`. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `d.fromkeys(s[,value])` | 返回一个新字典，其键来自序列`s`，值设置为`value`。 |'
- en: '| `d.get(k[,v])` | Returns `d[k]` if it is found; otherwise, it returns `v`
    (`None` if `v` is not given). |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `d.get(k[,v])` | 如果找到，则返回`d[k]`；否则返回`v`（如果未给出`v`，则返回`None`）。 |'
- en: '| `d.items()` | Returns all of the `key:value` pairs of the dictionary, `d`.
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `d.items()` | 返回字典`d`的所有`键:值`对。 |'
- en: '| `d.keys()` | Returns all of the keys defined in the dictionary, `d`. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `d.keys()` | 返回字典`d`中定义的所有键。 |'
- en: '| `d.pop(k[,default])` | Returns `d[k]` and removes it from `d`. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `d.pop(k[,default])` | 返回`d[k]`并从`d`中删除它。 |'
- en: '| `d.popitem()` | Removes a random `key:value` pair from the dictionary, `d`,
    and returns it as a tuple. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `d.popitem()` | 从字典`d`中删除一个随机的`键:值`对，并将其作为元组返回。 |'
- en: '| `d.setdefault(k[,v])` | Returns `d[k]`. If it is not found, it returns `v`
    and sets `d[k]` to `v`. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `d.setdefault(k[,v])` | 返回`d[k]`。如果找不到，它返回`v`并将`d[k]`设置为`v`。 |'
- en: '| `d.update(b)` | Adds all of the objects from the `b` dictionary to the `d` dictionary .
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `d.update(b)` | 将`b`字典中的所有对象添加到`d`字典中。 |'
- en: '| `d.values()` | Returns all of the values in the dictionary, `d`. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `d.values()` | 返回字典`d`中的所有值。 |'
- en: Python
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python
- en: It should be noted that the `in` operator, when applied to dictionaries, works
    in a slightly different way to when it is applied to a list. When we use the `in`
    operator on a list, the relationship between the time it takes to find an element
    and the size of the list is considered linear. That is, as the size of the list
    gets bigger, the corresponding time it takes to find an element grows, at most,
    linearly. The relationship between the time an algorithm takes to run compared
    to the size of its input is often referred to as its time complexity. We will
    talk more about this important topic in the next (and subsequent) chapters.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，当将`in`运算符应用于字典时，其工作方式与应用于列表时略有不同。当我们在列表上使用`in`运算符时，查找元素所需的时间与列表的大小之间的关系被认为是线性的。也就是说，随着列表的大小变大，找到元素所需的时间最多是线性增长的。算法运行所需的时间与其输入大小之间的关系通常被称为其时间复杂度。我们将在接下来的章节中更多地讨论这个重要的主题。
- en: In contrast to the `list` object, when the `in` operator is applied to dictionaries,
    it uses a hashing algorithm, and this has the effect of an increase in each lookup
    time that is almost independent of the size of the dictionary. This makes dictionaries
    extremely useful as a way to work with large amounts of indexed data. We will
    talk more about this important topic of rates of growth hashing in [Chapter 4](234b9cb7-47a2-4910-8039-d7fed6c4af81.xhtml), *Lists
    and Pointer Structures*, and [Chapter 14](1f1d6528-c080-4c90-abab-ab41d55d721e.xhtml), *Implementations,
    Applications, and Tools*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与`list`对象相反，当`in`运算符应用于字典时，它使用哈希算法，这会导致每次查找时间的增加几乎独立于字典的大小。这使得字典作为处理大量索引数据的一种方式非常有用。我们将在[第4章](234b9cb7-47a2-4910-8039-d7fed6c4af81.xhtml)和[第14章](1f1d6528-c080-4c90-abab-ab41d55d721e.xhtml)中更多地讨论这个重要主题，即哈希的增长率。
- en: Sorting dictionaries
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对字典进行排序
- en: 'If we want to do a simple sort on either the keys or values of a dictionary,
    we can do the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想对字典的键或值进行简单的排序，我们可以这样做：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the first line in the preceding code sorts the keys alphabetically
    and the second line sorts the values in order of the integer value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面代码中的第一行按字母顺序对键进行排序，第二行按整数值的顺序对值进行排序。
- en: 'The `sorted()` method has two optional arguments that are of interest: `key`
    and `reverse`. The `key` argument has nothing to do with the dictionary keys,
    but rather is a way of passing a function to the sort algorithm to determine the
    sort order. For example, in the following code, we use the `__getitem__` special
    method to sort the dictionary keys according to the dictionary values:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()`方法有两个感兴趣的可选参数：`key`和`reverse`。`key`参数与字典键无关，而是一种传递函数给排序算法以确定排序顺序的方法。例如，在下面的代码中，我们使用`__getitem__`特殊方法根据字典的值对字典键进行排序：'
- en: '![](Images/f060180f-67e3-4a18-a2cf-de92fa784c2c.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f060180f-67e3-4a18-a2cf-de92fa784c2c.png)'
- en: 'Essentially, what the preceding code is doing is, for every key in `d`, it
    uses the corresponding value to sort. We can also sort the values according to
    the sorted order of the dictionary keys. However, since dictionaries do not have
    a method to return a key by using its value, the equivalent of the `list.index`
    method for lists, using the optional key argument to do this is a little tricky.
    An alternative approach is to use a list comprehension, as the following example
    demonstrates:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，前面的代码对`d`中的每个键使用相应的值进行排序。我们也可以根据字典键的排序顺序对值进行排序。然而，由于字典没有一种方法可以通过其值返回一个键，就像列表的`list.index`方法一样，使用可选的`key`参数来做到这一点有点棘手。另一种方法是使用列表推导式，就像下面的例子演示的那样：
- en: '![](Images/8d05572b-0a3c-4320-9d9c-b6cf38b5243e.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8d05572b-0a3c-4320-9d9c-b6cf38b5243e.png)'
- en: 'The `sorted()` method also has an optional `reverse` argument, and unsurprisingly
    this does exactly what it says—reverses the order of the sorted list, as in the
    following example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()`方法还有一个可选的`reverse`参数，毫不奇怪，它确实做到了它所说的—反转排序列表的顺序，就像下面的例子一样：'
- en: '![](Images/bf6f08ee-d55a-4c47-8424-f493cbe2fc19.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bf6f08ee-d55a-4c47-8424-f493cbe2fc19.png)'
- en: 'Now, let''s say we are given the following dictionary, with English words as
    keys and French words as values. Our task is to place the string values in the
    correct numerical order:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有以下字典，其中英语单词作为键，法语单词作为值。我们的任务是将字符串值放在正确的数字顺序中：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Of course, when we print this dictionary out, it will be unlikely to print
    in the correct order. Because all keys and values are strings, we have no context
    for numerical ordering. To place these items in correct order, we need to use
    the first dictionary we created, mapping words to numerals as a way to order our
    English to French dictionary:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当我们打印这个字典时，它可能不会按正确的顺序打印。因为所有的键和值都是字符串，我们没有数字顺序的上下文。为了将这些项目放在正确的顺序中，我们需要使用我们创建的第一个字典，将单词映射到数字作为对英语到法语字典进行排序的一种方式：
- en: '![](Images/06a4e849-5cde-45c4-893c-d2182152f278.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06a4e849-5cde-45c4-893c-d2182152f278.png)'
- en: 'Notice we are using the values of the first dictionary, `d`, to sort the keys
    of the second dictionary, `d2`. Since our keys in both dictionaries are the same,
    we can use a list comprehension to sort the values of the French to English dictionary:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在使用第一个字典`d`的值来对第二个字典`d2`的键进行排序。由于我们两个字典中的键是相同的，我们可以使用列表推导式来对法语到英语字典的值进行排序：
- en: '![](Images/25cc0171-9321-4d8f-8b78-aafc7196f837.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/25cc0171-9321-4d8f-8b78-aafc7196f837.png)'
- en: 'We can, of course, define our own custom method that we can use as the key
    argument to the sorted method. For example, here we define a function that simply
    returns the last letter of a string:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以定义自己的自定义方法，然后将其用作排序方法的关键参数。例如，在这里，我们定义一个简单地返回字符串的最后一个字母的函数：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can then use this as the key to our sorted function to sort each element
    by its last letter:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将其用作排序函数的关键，按其最后一个字母对每个元素进行排序：
- en: '![](Images/95c948bf-cd5b-4254-add5-e98835006e00.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/95c948bf-cd5b-4254-add5-e98835006e00.png)'
- en: Dictionaries for text analysis
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本分析的字典
- en: 'A common use of dictionaries is to count the occurrences of like items in a
    sequence; a typical example is counting the occurrences of words in a body of
    text. The following code creates a dictionary where each word in the text is used
    as a key and the number of occurrences as its value. This uses a very common idiom
    of nested loops. Here we are using it to traverse the lines in a file in an outer
    loop and the keys of a dictionary on the inner loop:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的常见用途是计算序列中相似项的出现次数；一个典型的例子是计算文本中单词的出现次数。以下代码创建了一个字典，其中文本中的每个单词都用作键，出现次数作为其值。这使用了一个非常常见的嵌套循环习语。在这里，我们使用它来遍历文件中的行的外部循环和字典的键的内部循环：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will return a dictionary with an element for each unique word in the text
    file. A common task is to filter items such as these into subsets we are interested
    in. You will need a text file saved in the same directory as you run the code.
    Here we have used `alice.txt`, a short excerpt from *Alice in Wonderland*. To
    obtain the same results, you can download `alice.txt` from [davejulian.net/bo5630](http://davejulian.net/bo5630) or
    use a text file of your own. In the following code, we create another dictionary,
    filtered, containing a subset of items from `count`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个字典，其中每个唯一单词在文本文件中都有一个元素。一个常见的任务是将这些项目过滤成我们感兴趣的子集。您需要在运行代码的同一目录中保存一个文本文件。在这里，我们使用了`alice.txt`，这是《爱丽丝梦游仙境》的一个简短摘录。要获得相同的结果，您可以从[davejulian.net/bo5630](http://davejulian.net/bo5630)下载`alice.txt`，或者使用您自己的文本文件。在下面的代码中，我们创建了另一个字典`filtered`，其中包含来自`count`的子集：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we print the filtered dictionary, we get the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印过滤字典时，我们得到以下结果：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note the use of the **dictionary comprehension** used to construct the filtered
    dictionary. Dictionary comprehensions work in an identical way to the list comprehensions
    we looked at in [Chapter 1](2818f56c-fbcf-422f-83dc-16cbdbd8b5bf.xhtml), *Python
    Objects, Types, and Expressions*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用**字典推导**来构建过滤字典。字典推导的工作方式与我们在[第1章](2818f56c-fbcf-422f-83dc-16cbdbd8b5bf.xhtml)中看到的列表推导相同，即*Python对象、类型和表达式*。
- en: Sets
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: Sets are unordered collections of unique items. Sets are themselves mutable—we
    can add and remove items from them; however, the items themselves must be immutable.
    An important distinction with sets is that they cannot contain duplicate items.
    Sets are typically used to perform mathematical operations such as intersection,
    union, difference, and complement.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是无序的唯一项集合。集合本身是可变的——我们可以向其中添加和删除项目；但是，项目本身必须是不可变的。集合的一个重要区别是它们不能包含重复的项目。集合通常用于执行诸如交集、并集、差集和补集等数学运算。
- en: Unlike sequence types, set types do not provide any indexing or slicing operations.
    There are two types of set objects in Python, the mutable `set` object and the
    immutable `frozenset` object. Sets are created using comma-separated values within
    curly braces. By the way, we cannot create an empty set using `a={}`, because
    this will create a dictionary. To create an empty set, we write either `a=set()`
    or `a=frozenset()`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与序列类型不同，集合类型不提供任何索引或切片操作。Python中有两种类型的集合对象，可变的`set`对象和不可变的`frozenset`对象。使用花括号内的逗号分隔的值创建集合。顺便说一句，我们不能使用`a={}`创建一个空集，因为这将创建一个字典。要创建一个空集，我们要么写`a=set()`，要么写`a=frozenset()`。
- en: 'Methods and operations of sets are described in the following table:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的方法和操作描述在下表中：
- en: '| **Method** | **Description** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `len(a)` | Provides the total number of elements in the `a` set. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '`len(a)` | 提供了`a`集合中元素的总数。'
- en: '| `a.copy()` | Provides another copy of the `a` set. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '`a.copy()` | 提供了`a`集合的另一个副本。'
- en: '| `a.difference(t)` | Provides a set of elements that are in the `a` set but
    not in `t`. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '`a.difference(t)` | 提供了`a`集合中存在但不在`t`中的元素的集合。'
- en: '| `a.intersection(t)` | Provides a set of elements that are in both sets, `a`
    and `t`. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '`a.intersection(t)` | 提供了两个集合`a`和`t`中都存在的元素的集合。'
- en: '| `a.isdisjoint(t)` | Returns `True` if no element is common in both the sets, `a`
    and `t`. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '`a.isdisjoint(t)` | 如果两个集合`a`和`t`中没有共同的元素，则返回`True`。'
- en: '| `a.issubset(t)` | Returns `True` if all of the elements of the `a` set are
    also in the `t` set. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '`a.issubset(t)` | 如果`a`集合的所有元素也在`t`集合中，则返回`True`。'
- en: '| `a.issuperset(t)` | Returns `True` if all of the elements of the `t` set
    are also in the `a` set. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '`a.issuperset(t)` | 如果`t`集合的所有元素也在`a`集合中，则返回`True`。'
- en: '| `a.symmetric_difference(t)` | Returns a set of elements that are in either
    the `a` or `t` sets, but not in both. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '`a.symmetric_difference(t)` | 返回一个既在`a`集合中又在`t`集合中的元素的集合，但不在两者中都存在。'
- en: '| `a.union(t)` | Returns a set of elements that are in either the `a` or `t` sets.
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '`a.union(t)` | 返回一个既在`a`集合中又在`t`集合中的元素的集合。'
- en: In the preceding table, the `t` parameter can be any Python object that supports
    iteration and all methods are available to both `set` and `frozenset` objects.
    It is important to be aware that the operator versions of these methods require
    their arguments to be sets, whereas the methods themselves can accept any iterable
    type. For example, `s-[1,2,3]`, for any set, `s`, will generate an unsupported
    operand type. Using the equivalent, `s.difference([1,2,3])` will return a result.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在上表中，参数`t`可以是任何支持迭代的Python对象，所有方法都适用于`set`和`frozenset`对象。重要的是要意识到这些方法的操作符版本要求它们的参数是集合，而方法本身可以接受任何可迭代类型。例如，对于任何集合`s`，`s-[1,2,3]`将生成不支持的操作数类型。使用等效的`s.difference([1,2,3])`将返回一个结果。
- en: 'Mutable `set` objects have additional methods, described in the following table:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 可变的`set`对象具有其他方法，如下表所述：
- en: '| **Method** | **Description** |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `s.add(item)` | Adds an item to `s`; nothing happens if the item is already
    added. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `s.add(item)` | 将项目添加到`s`；如果项目已经添加，则不会发生任何事情。 |'
- en: '| `s.clear()` | Removes all elements from the set, `s`. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `s.clear()` | 从集合`s`中删除所有元素。 |'
- en: '| `s.difference_update(t)` | Removes those elements from the `s` set that are
    also in the other set, `t`. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `s.difference_update(t)` | 从`s`集合中删除那些也在其他集合`t`中的元素。 |'
- en: '| `s.discard(item)` | Removes the item from the set, `s`. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `s.discard(item)` | 从集合`s`中删除项目。 |'
- en: '| `s.intersection_update(t)` | Remove the items from the set, `s`, which are
    not in the intersection of the sets, `s` and `t`. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `s.intersection_update(t)` | 从集合`s`中删除不在集合`s`和`t`的交集中的项目。 |'
- en: '| `s.pop()` | Returns an arbitrary item from the set, `s`, and it removes it
    from the `s` set. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `s.pop()` | 从集合`s`中返回一个任意项目，并从`s`集合中删除它。 |'
- en: '| `s.remove(item)` | Deletes the item from the `s` set. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `s.remove(item)` | 从`s`集合中删除项目。 |'
- en: '| `s.symetric_difference_update(t)` | Deletes all of the elements from the `s` set
    that are not in the symmetric difference of the sets, `s` and `t`. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `s.symetric_difference_update(t)` | 从集合`s`中删除不在集合`s`和`t`的对称差集中的所有元素。 |'
- en: '| `s.update(t)` | Appends all of the items in an iterable object, `t`, to the `s`
    set. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `s.update(t)` | 将可迭代对象`t`中的所有项目附加到`s`集合。 |'
- en: 'Here, consider a simple example showing addition, removal, discard, and clear
    operations:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，考虑一个简单的示例，显示了添加、删除、丢弃和清除操作：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following example demonstrates some simple set operations and their results:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了一些简单的集合操作及其结果：
- en: '![](Images/1a0c26a1-0555-49b8-8608-248609446dc5.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1a0c26a1-0555-49b8-8608-248609446dc5.png)'
- en: Notice that the `set` object does not care that its members are not all of the
    same type, as long as they are all immutable. If you try to use a mutable object
    such as a list or dictionary in a set, you will receive an unhashable type error.
    Hashable types all have a hash value that does not change throughout the lifetime
    of the instance. All built-in immutable types are hashable. All built-in mutable
    types are not hashable, so they cannot be used as elements of sets or keys to
    dictionaries.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`set`对象不在乎其成员不全是相同类型，只要它们都是不可变的。如果您尝试在集合中使用可变对象，例如列表或字典，您将收到一个不可哈希类型错误。可哈希类型都有一个哈希值，在实例的整个生命周期中不会改变。所有内置的不可变类型都是可哈希的。所有内置的可变类型都不可哈希，因此不能用作集合的元素或字典的键。
- en: Notice also in the preceding code that when we print out the union of `s1` and
    `s2`, there is only one element with the value `'ab'`. This is a natural property
    of sets in that they do not include duplicates.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意在前面的代码中，当我们打印出`s1`和`s2`的并集时，只有一个值为`'ab'`的元素。这是集合的一个自然属性，它们不包括重复项。
- en: 'In addition to these built-in methods, there are a number of other operations
    that we can perform on sets. For example, to test for membership of a set, use
    the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些内置方法之外，我们还可以对集合执行许多其他操作。例如，要测试集合的成员资格，请使用以下方法：
- en: '![](Images/5c5e5c1a-63b6-4006-afac-81716a723380.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5c5e5c1a-63b6-4006-afac-81716a723380.png)'
- en: 'We can loop through elements in a set using the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下方法循环遍历集合中的元素：
- en: '![](Images/2399773c-55a5-49a9-9a07-415c66c31853.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2399773c-55a5-49a9-9a07-415c66c31853.png)'
- en: Immutable sets
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变集合
- en: Python has an immutable set type called `frozenset`. It works pretty much exactly
    like `set`, apart from not allowing methods or operations that change values such
    as the `add()` or `clear()` methods. There are several ways that this immutability
    can be useful.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个名为`frozenset`的不可变集合类型。它的工作方式几乎与`set`完全相同，除了不允许更改值的方法或操作，例如`add()`或`clear()`方法。这种不可变性有几种有用之处。
- en: 'For example, since normal sets are mutable and therefore not hashable, they
    cannot be used as members of other sets. On the other hand `frozenset` is immutable
    and therefore able to be used as a member of a set:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，由于普通集合是可变的，因此不可哈希，它们不能用作其他集合的成员。另一方面，`frozenset`是不可变的，因此可以用作集合的成员：
- en: '![](Images/a230c9f0-720b-45ec-b2d3-42635c4e0682.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a230c9f0-720b-45ec-b2d3-42635c4e0682.png)'
- en: 'Also, the immutable property of `frozenset` means we can use it for a key to
    a dictionary, as in the following example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`frozenset`的不可变属性意味着我们可以将其用作字典的键，如下例所示：
- en: '![](Images/b92757f5-6d64-4355-866e-0cdb00e71f53.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b92757f5-6d64-4355-866e-0cdb00e71f53.png)'
- en: Modules for data structures and algorithms
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构和算法的模块
- en: In addition to the built-in types, there are several Python modules that we
    can use to extend the built-in types and functions. In many cases, these Python
    modules may offer efficiency and programming advantages that allow us to simplify
    our code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置类型之外，还有几个Python模块可以用来扩展内置类型和函数。在许多情况下，这些Python模块可能提供效率和编程优势，使我们能够简化我们的代码。
- en: So far, we have looked at the built-in datatypes of strings, lists, sets, and
    dictionaries as well as the decimal and fraction modules. They are often described
    by the term **Abstract ****Data Types** (**ADTs**). ADTs can be considered mathematical
    specifications for the set of operations that can be performed on data. They are
    defined by their behavior rather than their implementation. In addition to the
    ADTs that we have looked at, there are several Python libraries that provide extensions
    to the built-in datatypes. These will be discussed in the following section.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看了字符串、列表、集合和字典的内置数据类型，以及十进制和分数模块。它们通常被术语**抽象数据类型**（**ADT**）描述。 ADT可以被认为是可以在数据上执行的操作集的数学规范。它们由其行为而不是其实现来定义。除了我们已经查看的ADT之外，还有几个Python库提供了对内置数据类型的扩展。这将在下一节中讨论。
- en: Collections
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'The `collections` module provides more specialized, high-performance alternatives
    for the built-in data types as well as a utility function to create named tuples.
    The following table lists the datatypes and operations of the collections module
    and their descriptions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections`模块提供了更专门的、高性能的替代品，用于内置数据类型，以及一个实用函数来创建命名元组。以下表列出了`collections`模块的数据类型和操作及其描述：'
- en: '| **Datatype or operation** | **Description** |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型或操作** | **描述** |'
- en: '| `namedtuple()` | Creates tuple subclasses with named fields. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `namedtuple()` | 创建具有命名字段的元组子类。 |'
- en: '| `deque` | Lists with fast appends and pops either end. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `deque` | 具有快速追加和弹出的列表。 |'
- en: '| `ChainMap` | Dictionary-like class to create a single view of multiple mappings.
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `ChainMap` | 类似字典的类，用于创建多个映射的单个视图。 |'
- en: '| `Counter` | Dictionary subclass for counting hashable objects. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `Counter` | 用于计算可散列对象的字典子类。 |'
- en: '| `OrderedDict` | Dictionary subclass that remembers the entry order. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `OrderedDict` | 记住条目顺序的字典子类。 |'
- en: '| `defaultdict` | Dictionary subclass that calls a function to supply missing
    values. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `defaultdict` | 调用函数以提供缺失值的字典子类。 |'
- en: '| `UserDict UserList UserString` | These three data types are simply wrappers
    for their underlying base classes. Their use has largely been supplanted by the
    ability to subclass their respective base classes directly. Can be used to access
    the underlying object as an attribute. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `UserDict UserList UserString` | 这三种数据类型只是它们基础基类的简单包装器。它们的使用在很大程度上已被能够直接对其各自的基类进行子类化所取代。可以用来作为属性访问基础对象。
    |'
- en: Deques
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双端队列
- en: Double-ended queues, or deques (usually pronounced *decks*), are list-like objects
    that support thread-safe, memory-efficient appends. Deques are mutable and support
    some of the operations of lists, such as indexing. Deques can be assigned by index,
    for example, `dq[1] = z`; however, we cannot directly slice deques. For example,
    `dq[1:2]` results in `TypeError` (we will look at a way to return a slice from
    a deque as a list shortly).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 双端队列，通常发音为*decks*，是类似列表的对象，支持线程安全、内存高效的追加。双端队列是可变的，并支持列表的一些操作，如索引。双端队列可以通过索引分配，例如，`dq[1]
    = z`；但是，我们不能直接切片双端队列。例如，`dq[1:2]`会导致`TypeError`（我们将看一种从双端队列返回切片作为列表的方法）。
- en: The major advantage of deques over lists is that inserting items at the beginning
    of a deque is much faster than inserting items at the beginning of a list, although
    inserting items at the end of a deque is very slightly slower than the equivalent
    operation on a list. Deques are thread-safe and can be serialized using the `pickle`
    module.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 双端队列比列表的主要优势在于，在双端队列的开头插入项目要比在列表的开头插入项目快得多，尽管在双端队列的末尾插入项目的速度比列表上的等效操作略慢一些。双端队列是线程安全的，并且可以使用`pickle`模块进行序列化。
- en: 'A useful way of thinking about deques is in terms of populating and consuming
    items. Items in deques are usually populated and consumed sequentially from either
    end:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的思考双端队列的方式是填充和消耗项目。双端队列中的项目通常是从两端顺序填充和消耗的：
- en: '![](Images/bdd5dc25-b4ee-4f13-80dd-c2e7b82634c1.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bdd5dc25-b4ee-4f13-80dd-c2e7b82634c1.png)'
- en: 'We can use the `pop()`and `popleft()` methods for consuming items in the deque,
    as in the following example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`pop()`和`popleft()`方法来消耗双端队列中的项目，如下例所示：
- en: '![](Images/13e07836-1988-41fc-ba5a-aa3b008691b0.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13e07836-1988-41fc-ba5a-aa3b008691b0.png)'
- en: 'We can also use the `rotate(n)` method to move and rotate all items of `n`
    steps to the right for positive values of the `n` integer or negative values of
    `n` steps to the left, using positive integers as the argument, as in the following
    example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`rotate(n)`方法将所有项目向右移动和旋转`n`步，对于`n`整数的正值或`n`步的负值向左移动，使用正整数作为参数，如下例所示：
- en: '![](Images/bb9cb7b6-1956-438a-b247-b56375078185.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bb9cb7b6-1956-438a-b247-b56375078185.png)'
- en: 'Note that we can use the `rotate` and `pop` methods to delete selected elements.
    Also worth knowing is a simple way to return a slice of a deque, as a list, which
    can be done as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以使用`rotate`和`pop`方法来删除选定的元素。还值得知道的是，返回双端队列切片的简单方法，可以按以下方式完成：
- en: '![](Images/811e6dec-b990-403d-a4a2-02d5214f0f38.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/811e6dec-b990-403d-a4a2-02d5214f0f38.png)'
- en: The `itertools.islice()` method works in the same way that slice works on a
    list, except rather than taking a list for an argument, it takes an iterable and
    returns selected values, by start and stop indices, as a list.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools.islice()`方法的工作方式与列表上的切片相同，只是它不是以列表作为参数，而是以可迭代对象作为参数，并返回所选值，按起始和停止索引，作为列表。'
- en: 'A useful feature of deques is that they support a `maxlen` optional parameter
    that restricts the size of the deque. This makes it ideally suited to a data structure
    known as a **circular buffer**. This is a fixed-size structure that is effectively
    connected end to end and they are typically used for buffering data streams. The
    following is a basic example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 双端队列的一个有用特性是它们支持一个`maxlen`可选参数，用于限制双端队列的大小。这使得它非常适合一种称为**循环缓冲区**的数据结构。这是一种固定大小的结构，实际上是端对端连接的，它们通常用于缓冲数据流。以下是一个基本示例：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This prints out the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出以下内容：
- en: '![](Images/2d67615b-9051-493c-9727-6a2f6244f6f1.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2d67615b-9051-493c-9727-6a2f6244f6f1.png)'
- en: In this example, we are populating from the right and consuming from the left.
    Notice that once the buffer is full the oldest values are consumed first and values
    are replaced from the right. We will look at circular buffers again in [Chapter
    4](234b9cb7-47a2-4910-8039-d7fed6c4af81.xhtml), *Lists and Pointer Structures*,
    when implementing circular lists.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从右侧填充并从左侧消耗。请注意，一旦缓冲区已满，最旧的值将首先被消耗，然后从右侧替换值。在[第4章](234b9cb7-47a2-4910-8039-d7fed6c4af81.xhtml)中，当实现循环列表时，我们将再次看循环缓冲区。
- en: ChainMap objects
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ChainMap对象
- en: The `collections.chainmap` class was added in Python 3.2, and it provides a
    way to link a number of dictionaries, or other mappings, so that they can be treated
    as one object. In addition, there is a `maps` attribute, a `new_child()` method,
    and a `parents` property. The underlying mappings for `ChainMap` objects are stored
    in a list and are accessible using the `maps[i]` attribute to retrieve the `ith` dictionary.
    Note that, even though dictionaries themselves are unordered, `ChainMap` objects
    are ordered lists of dictionaries.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections.chainmap`类是在Python 3.2中添加的，它提供了一种将多个字典或其他映射链接在一起，以便它们可以被视为一个对象的方法。此外，还有一个`maps`属性，一个`new_child()`方法和一个`parents`属性。`ChainMap`对象的基础映射存储在列表中，并且可以使用`maps[i]`属性来检索第`i`个字典。请注意，尽管字典本身是无序的，`ChainMap`对象是有序的字典列表。'
- en: '`ChainMap` is useful in applications where we are using a number of dictionaries
    containing related data. The consuming application expects data in terms of a
    priority, where the same key in two dictionaries is given priority if it occurs
    at the beginning of the underlying list. `ChainMap` is typically used to simulate
    nested contexts such as when we have multiple overriding configuration settings.
    The following example demonstrates a possible use case for `ChainMap`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChainMap`在使用包含相关数据的多个字典的应用程序中非常有用。消费应用程序期望按优先级获取数据，如果两个字典中的相同键出现在基础列表的开头，则该键将优先考虑。`ChainMap`通常用于模拟嵌套上下文，例如当我们有多个覆盖配置设置时。以下示例演示了`ChainMap`的可能用例：'
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The advantage of using `ChainMap` objects, rather than just a dictionary, is
    that we retain previously set values. Adding a child context overrides values
    for the same key, but it does not remove it from the data structure. This can
    be useful when we may need to keep a record of changes so that we can easily roll
    back to a previous setting.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ChainMap`对象而不仅仅是字典的优势在于我们保留了先前设置的值。添加子上下文会覆盖相同键的值，但不会从数据结构中删除它。当我们需要保留更改记录以便可以轻松回滚到先前的设置时，这可能很有用。
- en: 'We can retrieve and change any value in any of the dictionaries by providing
    the `map()` method with an appropriate index. This index represents a dictionary
    in `ChainMap`. Also, we can retrieve the parent setting, that is, the default
    settings, by using the `parents()` method:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过为`map()`方法提供适当的索引来检索和更改任何字典中的任何值。此索引表示`ChainMap`中的一个字典。此外，我们可以使用`parents()`方法检索父设置，即默认设置：
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Counter objects
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数器对象
- en: '`Counter` is a subclass of a dictionary where each dictionary key is a hashable
    object and the associated value is an integer count of that object. There are
    three ways to initialize a counter. We can pass it any sequence object, a dictionary
    of `key:value` pairs, or a tuple of the format `(object=value,...)`, as in the
    following example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter`是字典的一个子类，其中每个字典键都是可散列对象，关联的值是该对象的整数计数。有三种初始化计数器的方法。我们可以将任何序列对象、`key:value`对的字典或格式为`(object=value,...)`的元组传递给它，如下例所示：'
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can also create an empty counter object and populate it by passing its `update`
    method an iterable or a dictionary. Notice how the `update` method adds the counts
    rather than replacing them with new values. Once the counter is populated, we
    can access stored values in the same way we would do for dictionaries, as in the
    following example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个空的计数器对象，并通过将其`update`方法传递给一个可迭代对象或字典来填充它。请注意，`update`方法添加计数，而不是用新值替换它们。填充计数器后，我们可以以与字典相同的方式访问存储的值，如下例所示：
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The most notable difference between counter objects and dictionaries is that
    counter objects return a zero count for missing items rather than raising a key
    error. We can create an iterator out of a `Counter` object by using its `elements()`
    method. This returns an iterator where counts below one are not included and the
    order is not guaranteed. In the following code, we perform some updates, create
    an iterator from `Counter` elements, and use `sorted()` to sort the keys alphabetically:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器对象和字典之间最显着的区别是计数器对象对于缺失的项返回零计数，而不是引发键错误。我们可以使用其`elements()`方法从`Counter`对象创建迭代器。这将返回一个迭代器，其中不包括小于一的计数，并且顺序不被保证。在下面的代码中，我们执行一些更新，从`Counter`元素创建一个迭代器，并使用`sorted()`按字母顺序对键进行排序：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Two other `Counter` methods worth mentioning are `most_common()` and `subtract()`.
    The most common method takes a positive integer argument that determines the number
    of most common elements to return. Elements are returned as a list of (key,value)
    tuples.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个值得一提的`Counter`方法是`most_common()`和`subtract()`。最常见的方法接受一个正整数参数，确定要返回的最常见元素的数量。元素作为(key,value)元组的列表返回。
- en: 'The subtract method works exactly like update except, instead of adding values,
    it subtracts them, as in the following example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 减法方法的工作方式与更新相同，只是它不是添加值，而是减去它们，如下例所示：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Ordered dictionaries
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有序字典
- en: 'The important thing about ordered dictionaries is that they remember the insertion
    order, so when we iterate over them, they return values in the order they were
    inserted. This is in contrast to a normal dictionary, where the order is arbitrary.
    When we test to see whether two dictionaries are equal, this equality is only
    based on their keys and values; however, with `OrderedDict`, the insertion order
    is also considered an equality test between two `OrderedDict` objects with the
    same keys and values, but a different insertion order will return `False`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有序字典的重要之处在于它们记住插入顺序，因此当我们对它们进行迭代时，它们会按照插入顺序返回值。这与普通字典相反，普通字典的顺序是任意的。当我们测试两个字典是否相等时，这种相等性仅基于它们的键和值；但是，对于`OrderedDict`，插入顺序也被视为两个具有相同键和值的`OrderedDict`对象之间的相等性测试，但是插入顺序不同将返回`False`：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Similarly, when we add values from a list using `update`, `OrderedDict` will
    retain the same order as the list. This is the order that is returned when we
    iterate the values, as in the following example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当我们使用`update`从列表添加值时，`OrderedDict`将保留与列表相同的顺序。这是在迭代值时返回的顺序，如下例所示：
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`OrderedDict` is often used in conjunction with the sorted method to create
    a sorted dictionary. In the following example, we use a Lambda function to sort
    the values, and here we use a numerical expression to sort the integer values:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderedDict`经常与sorted方法一起使用，以创建一个排序的字典。在下面的示例中，我们使用Lambda函数对值进行排序，并且在这里我们使用数值表达式对整数值进行排序：'
- en: '[PRE34]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: defaultdict
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: defaultdict
- en: 'The `defaultdict` object is a subclass of `dict`, and therefore they share
    methods and operations. It acts as a convenient way to initialize dictionaries.
    With `dict`, Python will throw `KeyError` when attempting to access a key that
    is not already in the dictionary. The `defaultdict` overrides one method, `missing
    (key)`, and creates a new instance variable, `default_factory`. With `defaultdict`,
    rather than throw an error, it will run the function supplied as the `default_factory`
    argument, which will generate a value. A simple use of `defaultdict` is to set
    `default_factory` to `int` and use it to quickly tally the counts of items in
    the dictionary, as in the following example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict`对象是`dict`的子类，因此它们共享方法和操作。它作为初始化字典的便捷方式。使用`dict`时，当尝试访问尚未在字典中的键时，Python会抛出`KeyError`。`defaultdict`覆盖了一个方法，`missing(key)`，并创建了一个新的实例变量，`default_factory`。使用`defaultdict`，而不是抛出错误，它将运行作为`default_factory`参数提供的函数，该函数将生成一个值。`defaultdict`的一个简单用法是将`default_factory`设置为`int`，并用它快速计算字典中项目的计数，如下例所示：'
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You will notice that if we tried to do this with an ordinary dictionary, we
    would get a key error when we tried to add the first key. The `int` we supplied
    as an argument to the `defaultdict` is really the `int()` function that simply
    returns a zero.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，如果我们尝试使用普通字典来做这件事，当我们尝试添加第一个键时，我们会得到一个键错误。我们提供给`defaultdict`的`int`实际上是`int()`函数，它只是返回零。
- en: 'We can, of course, create a function that will determine the dictionary''s
    values. For example, the following function returns `True` if the supplied argument
    is a primary color, that is `red`, `green`, or `blue`, or returns `False` otherwise:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以创建一个函数来确定字典的值。例如，以下函数在提供的参数是主要颜色（即`red`，`green`或`blue`）时返回`True`，否则返回`False`：
- en: '[PRE36]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Learning about named tuples
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解命名元组
- en: The `namedtuple` method returns a tuple-like object that has fields accessible
    with named indexes as well as the integer indexes of normal tuples. This allows
    for code that is, to a certain extent, self-documenting and more readable. It
    can be especially useful in an application where there are a large number of tuples
    and we need to easily keep track of what each tuple represents. Furthermore, `namedtuple`
    inherits methods from tuple and it is backward-compatible with tuple.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`namedtuple`方法返回一个类似元组的对象，其字段可以通过命名索引以及普通元组的整数索引进行访问。这允许在某种程度上自我记录和更易读的代码。在需要轻松跟踪每个元组代表的内容的应用程序中，这可能特别有用。此外，`namedtuple`从元组继承方法，并且与元组向后兼容。'
- en: 'The field names are passed to the `namedtuple` method as comma and/or whitespace-separated
    values. They can also be passed as a sequence of strings. Field names are single
    strings, and they can be any legal Python identifier that does not begin with
    a digit or an underscore. A typical example is shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 字段名称作为逗号和/或空格分隔的值传递给`namedtuple`方法。它们也可以作为字符串序列传递。字段名称是单个字符串，可以是任何合法的Python标识符，不能以数字或下划线开头。一个典型的例子如下所示：
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In addition to the inherited tuple methods, the named tuple also defines three
    methods of its own, `_make()`, `asdict()`, and `_replace`. These methods begin
    with an underscore to prevent potential conflicts with field names. The `_make()`
    method takes an iterable as an argument and turns it into a named tuple object,
    as in the following example:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 除了继承的元组方法之外，命名元组还定义了三种自己的方法，`_make()`，`asdict()`和`_replace`。这些方法以下划线开头，以防止与字段名称可能发生冲突。`_make()`方法将可迭代对象作为参数，并将其转换为命名元组对象，如下例所示：
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `_asdict` method returns an `OrderedDict` object with the field names mapped
    to index keys and the values mapped to the dictionary values. The `_replace` method
    returns a new instance of the tuple, replacing the specified values. In addition,
    `_fields` returns the tuple of string listing the fields names. The `_fields_defaults`
    method provides dictionary mapping field names to the default values. Consider
    the example code snippet:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`_asdict`方法返回一个`OrderedDict`对象，其中字段名称映射到索引键，值映射到字典值。`_replace`方法返回元组的新实例，替换指定的值。此外，`_fields`返回列出字段名称的字符串元组。`_fields_defaults`方法提供将字段名称映射到默认值的字典。考虑以下示例代码片段：'
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Arrays
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: The `array` module defines a data type array that is similar to the list data
    type except for the constraint that their contents must be of a single type of
    the underlying representation, as is determined by the machine architecture or
    underlying C implementation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`array`模块定义了一种类似于列表数据类型的数据类型数组，除了它们的内容必须是由机器架构或底层C实现确定的单一类型的约束。'
- en: 'The type of an array is determined at creation time and it is indicated by
    one of the following type codes:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的类型是在创建时确定的，并且由以下类型代码之一表示：
- en: '| **Code** | **C type** | **Python type** | **Minimum bytes** |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '**代码** | **C类型** | **Python类型** | **最小字节数** |'
- en: '| ''b'' | `signedchar` | int | 1 |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '''b'' | `signedchar` | int | 1 |'
- en: '| ''B'' | `unsignedchar` | int | 1 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '''B'' | `unsignedchar` | int | 1 |'
- en: '| ''u'' | `Py_UNICODE` | Unicodecharacter | 2 |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '''u'' | `Py_UNICODE` | Unicodecharacter | 2 |'
- en: '| ''h'' | `signedshort` | int | 2 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '''h'' | `signedshort` | int | 2 |'
- en: '| ''H'' | `unsignedshort` | int | 2 |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '''H'' | `unsignedshort` | int | 2 |'
- en: '| ''i'' | `signedint` | int | 2 |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '''i'' | `signedint` | int | 2 |'
- en: '| ''I'' | `unsignedint` | int | 2 |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '''I'' | `unsignedint` | int | 2 |'
- en: '| ''l'' | `signedlong` | int | 4 |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '''l'' | `signedlong` | int | 4 |'
- en: '| ''L'' | `unsignedlong` | int | 8 |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '''L'' | `unsignedlong` | int | 8 |'
- en: '| ''q'' | `signedlonglong` | int | 8 |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '''q'' | `signedlonglong` | int | 8 |'
- en: '| ''Q'' | `unsignedlonlong` | int | 8 |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '''Q'' | `unsignedlonlong` | int | 8 |'
- en: '| ''f'' | `float` | float | 4 |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '''f'' | `float` | float | 4 |'
- en: '| ''d'' | `double` | float | 8 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '''d'' | `double` | float | 8 |'
- en: 'The array objects support the attributes and methods:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 数组对象支持属性和方法：
- en: '| **Attribute or method** | **Description** |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| **属性或方法** | **描述** |'
- en: '| `a.itemsize` | The size of one array item in bytes. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `a.itemsize` | 一个数组项的大小（以字节为单位）。|'
- en: '| `a.append(x)` | Appends an `x` element at the end of the `a` array. |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `a.append(x)` | 在`a`数组的末尾添加一个`x`元素。|'
- en: '| `a.buffer_info()` | Returns a tuple containing the current memory location
    and length of the buffer used to store the array. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `a.buffer_info()` | 返回一个元组，包含用于存储数组的缓冲区的当前内存位置和长度。|'
- en: '| `a.byteswap()` | Swaps the byte order of each item in the `a` array. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `a.byteswap()` | 交换`a`数组中每个项目的字节顺序。|'
- en: '| `a.count(x)` | Returns the occurrences of `x` in the `a` array. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `a.count(x)` | 返回`a`数组中`x`的出现次数。|'
- en: '| `a.extend(b)` | Appends all the elements from iterable `b` at the end of
    the `a` array. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `a.extend(b)` | 在`a`数组的末尾添加可迭代对象`b`的所有元素。|'
- en: '| `a.frombytes(s)` | Appends elements from an `s` string, where the string
    is an array of machine values. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `a.frombytes(s)` | 从字符串`s`中附加元素，其中字符串是机器值的数组。|'
- en: '| `a.fromfile(f,n)` | Reads `n` machine values from the file and appends them
    at the end of the array. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `a.fromfile(f,n)` | 从文件中读取`n`个机器值，并将它们附加到数组的末尾。|'
- en: '| `a.fromlist(l)` | Appends all of the elements from the `l` list to the array.
    |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `a.fromlist(l)` | 将`l`列表中的所有元素附加到数组。|'
- en: '| `a.fromunicode(s)` | Extends an array of the `u` type with the Unicode string, `s`.
    |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `a.fromunicode(s)` | 用Unicode字符串`s`扩展`u`类型的数组。|'
- en: '| `index(x)` | Returns the first (smallest) index of the `x` element. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `index(x)` | 返回`x`元素的第一个（最小）索引。|'
- en: '| `a.insert(i,x)` | Inserts an item of which the value is `x`, in the array
    at `i` index position. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `a.insert(i,x)` | 在数组的`i`索引位置插入值为`x`的项目。|'
- en: '| `a.pop([i])` | Returns the item at index, `I`, and removes it from the array.
    |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `a.pop([i])` | 返回索引`i`处的项目，并从数组中删除它。|'
- en: '| `a.remove(x)` | Removes the first occurrence of the `x` item from the array.
    |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `a.remove(x)` | 从数组中删除第一个出现的`x`项。|'
- en: '| `a.reverse()` | Reverses the order of items in the `a` array. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `a.reverse()` | 颠倒`a`数组中项目的顺序。|'
- en: '| `a.tofile(f)` | Writes all the elements to the `f` file object. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `a.tofile(f)` | 将所有元素写入`f`文件对象。|'
- en: '| `a.tolist()` | Converts the array into a list. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `a.tolist()` | 将数组转换为列表。|'
- en: '| `a.tounicode()` | Converts an array of the `u` type into a Unicode string
    |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `a.tounicode()` | 将`u`类型的数组转换为Unicode字符串。|'
- en: Array objects support all of the normal sequence operations such as indexing,
    slicing, concatenation, and multiplication.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 数组对象支持所有正常的序列操作，如索引、切片、连接和乘法。
- en: 'Using arrays, as opposed to lists, is a much more efficient way of storing
    data that is of the same type. In the following example, we have created an integer
    array of the digits from `0` to one million minus `1`, and an identical list.
    Storing one million integers in an integer array requires around 90% of the memory
    of an equivalent list:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表相比，使用数组是存储相同类型数据的更有效的方法。在下面的例子中，我们创建了一个整数数组，其中包含从`0`到一百万减去`1`的数字，以及一个相同的列表。在整数数组中存储一百万个整数，大约需要相当于等效列表的90%的内存：
- en: '[PRE40]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Because we are interested in saving space, that is, we are dealing with large
    datasets and limited memory size, we usually perform in-place operations on arrays,
    and only create copies when we need to. Typically, enumerate is used to perform
    an operation on each element. In the following snippet, we perform the simple
    operation of adding one to each item in the array.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们对节省空间感兴趣，也就是说，我们处理大型数据集和有限的内存大小，通常我们对数组进行原地操作，只有在需要时才创建副本。通常，enumerate用于对每个元素执行操作。在下面的片段中，我们执行简单的操作，为数组中的每个项目添加一。
- en: It should be noted that when performing operations on arrays that create lists,
    such as list comprehensions, the memory efficiency gains of using an array in
    the first place will be negated. When we need to create a new data object, a solution
    is to use a generator expression to perform the operation.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当对创建列表的数组执行操作时，例如列表推导，使用数组的内存效率优势将被抵消。当我们需要创建一个新的数据对象时，一个解决方案是使用生成器表达式来执行操作。
- en: Arrays created with this module are unsuitable for work that requires a matrix
    of vector operations. In the next chapter, we will build our own abstract data
    type to deal with these operations. Also important for numerical work is the NumPy
    extension, available at [www.numpy.org](http://www.numpy.org/) .
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个模块创建的数组不适合需要矢量操作的矩阵工作。在下一章中，我们将构建自己的抽象数据类型来处理这些操作。对于数值工作来说，NumPy扩展也很重要，可以在[www.numpy.org](http://www.numpy.org/)上找到。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In the last two chapters, we presented the language features and data types
    of Python. We looked at the built-in data types and some internal Python modules,
    most notably the `collections` module. There are also several other Python modules
    that are relevant to the topic of this book, but rather than examining them separately,
    their use and functionality should become self-evident as we begin using them.
    There are also a number of external libraries, for example, SciPy.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两章中，我们介绍了Python的语言特性和数据类型。我们研究了内置数据类型和一些内部Python模块，尤其是`collections`模块。还有其他几个与本书主题相关的Python模块，但与其单独检查它们，不如在开始使用它们时，它们的使用和功能应该变得不言自明。还有一些外部库，例如SciPy。
- en: In the next chapter, we will introduce the basic theory and techniques of algorithm
    design.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '在下一章中，我们将介绍算法设计的基本理论和技术。 '
