- en: Robotics 101
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器人学101
- en: As soon as we say the word robot, thoughts of science fiction start to surround
    us. We may recall the cartoon serial *The Jetsons* or think of the movie *Terminator*.
    But, as a matter of fact, robots as a species do not belong to science fiction
    anymore. They are as real as they can get. Look around you and point out any object;
    it probably wouldn't have been made without a robot. The modern era has been shaped
    by robots.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一提到机器人，我们就会被科幻小说所包围。我们可能会想起动画片《杰森一家》或者电影《终结者》。但事实上，机器人已经不再属于科幻小说。它们是真实存在的。环顾四周，指出任何物体；它可能没有机器人就不会被制造出来。现代时代已经被机器人塑造了。
- en: But then, you can also take a step back and think, wait a minute, aren't the
    things he is talking about called machines and not robots? Well, yes, you are
    very correct, yet very mistaken at the same time. It is cartoons and science fiction
    that have imparted an image of a human-like robot that is called a **robot**.
    But robots are much more than that.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你也可以退一步思考，等一下，他所说的东西不是叫做机器而不是机器人吗？嗯，是的，你说得很对，但同时也错得很离谱。正是卡通和科幻小说赋予了一个被称为**机器人**的人形机器人的形象。但机器人远不止于此。
- en: Unfortunately, we do not have a concrete, universally agreed definition of robots,
    but, as I like to say, *Any machine capable of performing physical as well as
    intellectual tasks can be called a robot.*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们没有一个具体的、普遍认可的机器人定义，但是，正如我喜欢说的那样，*任何能够执行物理和智力任务的机器都可以被称为机器人*。
- en: Now, you may say that, according to my definition, even an automatic washing
    machine can be called a robot. Well, technically, yes, and why should we not call
    it a robot? Think of the things it is doing for you and what kind of automation
    has been adapted over the years. After you feed in the type of cloth it automatically
    washes, rinses, and dries as you would have done yourself in the 19th century.
    The point I am trying to make is that there is a huge variation of robots that
    we can think of, which can radically change the way we live. We need to think
    with a wider perspective—not just limit robot to look as a human adaption in form
    of humanoid robots.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会说，根据我的定义，甚至自动洗衣机都可以被称为机器人。嗯，从技术上讲，是的，为什么我们不称它为机器人呢？想想它为你做了什么，以及多年来进行了什么样的自动化。在你输入布料类型后，它会自动洗涤和烘干，就像你在19世纪自己做的那样。我想说的是，我们可以想象有各种各样的机器人，它们可以从根本上改变我们的生活方式。我们需要以更广阔的视角思考——不仅仅将机器人限制为人形机器人的形式。
- en: 'We live in the golden era of robotics and automation in which the development
    of new products is as simple as it can get. What a decade back might have taken
    a team of engineers, can now be done by a person sitting in bedroom in just a
    few minutes, thanks to the open source world. At the very same time, there is
    hardware horsepower available to you by which you can literally build a super
    computer in your own home with just a few hundred dollars. We are surrounded by
    problems, some simple and others complex, which are waiting to be solved. The
    only missing chain in the whole process is you: an innovative mind that has the
    capability to exploit these technologies to solve the world''s problems.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在机器人和自动化的黄金时代，新产品的开发就像它可以变得那么简单。十年前可能需要一个工程师团队才能完成的工作，现在可以由一个人在卧室里在几分钟内完成，这要感谢开源世界。与此同时，有硬件计算能力可供你使用，你可以用几百美元在家里建立一个超级计算机。我们周围有各种问题，有些简单，有些复杂，等待着解决。整个过程中唯一缺失的环节就是你：一个有能力利用这些技术解决世界问题的创新思维。
- en: To make your mind capable of doing so, we will be starting of by understanding
    the roots and the basics of robotics. The goal of this book is not only to make
    the projects that are mentioned in the book but to make you understand how to
    exploit the resources to build your dream projects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你的思维能够做到这一点，我们将从理解机器人学的根源和基础开始。这本书的目标不仅是制作书中提到的项目，而且是让你了解如何利用资源来建立你的梦想项目。
- en: 'Finally, I would like to congratulate you on entering this amazing and futuristic
    field at the correct time. I always tell my students a rule, which I would like
    to share with you as well:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我要祝贺你在正确的时间进入了这个令人惊叹和未来感的领域。我总是告诉我的学生一个规则，我也想和你分享：
- en: First is a scientist
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先是科学家
- en: Second is a researcher
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二是研究员
- en: Third is an engineer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三是工程师
- en: Fourth is a technician
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四是技术员
- en: Last is a mechanic
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后是技工
- en: What it means is that the earlier in the life cycle you enter any field, the
    higher in the hierarchy you can get. The later you come, the harder it is to climb
    to the top.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你越早进入任何领域的生命周期，你就越有可能在层次结构中升级。你越晚进入，就越难爬到顶部。
- en: 'Enough talking—now let''s get straight to business! We will cover the following
    topics in this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，现在让我们直奔主题！在本章中，我们将涵盖以下主题：
- en: The hardware arsenal
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件装备
- en: Setting up Raspberry Pi
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置树莓派
- en: Programming
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程
- en: Playing with voltage
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩电压
- en: The hardware arsenal
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件装备
- en: 'Talking of robots, there are a few basic tangible components that they are
    made up of, which are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到机器人，它们由一些基本的有形组件组成，包括：
- en: Computing Unit
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算单元
- en: Sensors
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器
- en: Actuators
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行器
- en: Chassis
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底盘
- en: Power source
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电源
- en: Firstly, we will be discussing the microcontroller and, during the course of
    book, we will be discussing the rest of the tangible components in detail as and
    when required.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论微控制器，并在书的过程中根据需要详细讨论其他有形组件。
- en: Whenever you have been to buy a laptop or a computer, you must have heard the
    word microprocessor. This is the primary unit that has to make all the decisions.
    I call it the *king*, but what is a king without an empire? For the king to work,
    he needs some subordinates that can do the things for him, the same way in which
    the microprocessor needs a few subordinates such as RAM, storage, I/O devices,
    and so on. Now, the problem is that when we put in all these things the overall
    unit gets expensive and bulky. But, as we know, subsequently weight and size are
    very important factors when it comes to robots, so we cannot afford to have a
    big bulky piece of system running a robot.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你去购买笔记本电脑或电脑时，你一定听过微处理器这个词。这是必须做出所有决定的主要单位。我称它为“国王”，但没有帝国的国王算什么？国王需要一些可以为他做事的下属，就像微处理器需要一些下属，比如RAM、存储、I/O设备等。问题是，当我们放入所有这些东西时，整体单元变得昂贵和笨重。但是，正如我们所知，重量和大小在机器人方面非常重要，所以我们不能承受一个庞大笨重的系统来运行机器人。
- en: Hence, we made something called a SoC. Now, this is a one man show as this small
    chip, has all the necessary systems for it to work inside that small little chipset
    itself. So, now you don't need to add RAM or storage or any other thing for it
    to work. These small microcontrollers can get really powerful but a downside is,
    once a manufacturer has made an SoC, thereafter no changes can be done to it.
    The size of storage, RAM, or the I/O cannot be changed. But we generally can live
    with these limitations as when programming the robots, you might not be using
    the entire juice of the microcontroller until the time you are running some serious
    artificial intelligence or machine-learning code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们制造了一个叫做SoC的东西。现在，这是一个独角戏，因为这个小芯片本身就具有所有必要的系统来使其工作。所以，现在你不需要添加RAM或存储或任何其他东西来使其工作。这些小型微控制器可以变得非常强大，但缺点是，一旦制造商制造了一个SoC，以后就不能对其进行任何更改。存储器的大小、RAM或I/O都不能更改。但是我们通常可以接受这些限制，因为在编程机器人时，你可能不会使用微控制器的全部功能，直到你运行一些严肃的人工智能或机器学习代码。
- en: One such great piece of hardware is Raspberry Pi. Yes, it sounds very tasty,
    but there is so much more to it. This is a super small yet extremely powerful
    microcontroller. It is often referred to as a prototyping board because of the
    fact that it is used by roboticists everywhere to bring out their ideas and to
    make them a reality in a quick time span. It is available all across the globe
    and is extremely cheap. You can literally stream HD movies, surf the internet,
    and do much more on just a $10 device. I can't think of something as ludicrous
    as this. It is fairly easy to use and you can use Python to program it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个伟大的硬件是树莓派。是的，听起来非常美味，但它还有更多的功能。这是一个超小但非常强大的微控制器。它通常被称为原型板，因为它被世界各地的机器人学家用来实现他们的想法并在短时间内使它们成为现实。它在全球范围内都可以获得，并且非常便宜。你可以在一个仅售10美元的设备上随时观看高清电影，上网等等。我想不出还有什么比这更荒谬的了。它非常容易使用，你可以使用Python来编程。
- en: So, basically, it ticks all our boxes. This will be the primary weapon we will
    be using throughout the book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上它符合我们所有的要求。这将是我们在整本书中将要使用的主要武器。
- en: 'So let me introduce you to Raspberry Pi! This is what it looks like:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我向你介绍树莓派！它看起来是这样的：
- en: '![](Images/d358e546-e8cc-4356-a34e-cca97d99b61b.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d358e546-e8cc-4356-a34e-cca97d99b61b.png)'
- en: 'There are various models of Raspberry Pi available on the market. But we will
    be using Raspberry Pi Zero W; this will cost you around $10 and it is easier to
    purchase than a Big Mac burger. Do make sure you buy the Raspberry Pi Zero with
    a W, which supposedly stands for wireless capabilities such as Wi-Fi and Bluetooth.
    There are a few more things that you will have to order or arrange for it to work.
    Here is a list of items:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有各种型号的树莓派。但我们将使用树莓派Zero W；这将花费你大约10美元，比起大麦克汉堡更容易购买。确保你购买带有W的树莓派Zero，这个W代表无线功能，比如Wi-Fi和蓝牙。还有一些其他东西，你需要订购或安排才能使其工作。以下是一些物品清单：
- en: Micro USB to standard USB adapter
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro USB到标准USB适配器
- en: Keyboard
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘
- en: Mouse
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标
- en: Micro SD memory card, 16 or 32 GB
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro SD存储卡，16或32 GB
- en: Micro SD card reader
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro SD卡读卡器
- en: Micro USB power adapter (2 amp or more)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro USB电源适配器（2安培或更高）
- en: Micro HDMI to HDMI port
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Micro HDMI到HDMI端口
- en: Breadboard
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板
- en: Bunch of jumper wires (male to male, male to female, and female to female)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一堆跳线（公对公，公对母，母对母）
- en: 3V LEDs
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3V LED
- en: '![](Images/1b804fdf-905b-4ff5-aa4b-920a4b5b6096.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1b804fdf-905b-4ff5-aa4b-920a4b5b6096.png)'
- en: As you will instantly make out from the image, there is a micro HDMI port onboard,
    over which you can hook up your HD monitor or a TV screen. Second there is a micro
    SD card slot. This will be the primary storage device for this computer. Other
    than that, you will also find two USB sockets and a camera bus. You may think
    this is it, but the best is yet to come. Raspberry Pi has something called **GPIO**,
    which stands for **general purpose input/output**. These are disguised as small
    40 through-hole ports on one corner of the Raspberry Pi; this is what makes it
    super special.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以立即从图像中看出，板载了一个微型HDMI端口，你可以通过它连接高清显示器或电视屏幕。其次是一个Micro SD卡槽。这将是这台电脑的主要存储设备。除此之外，你还会发现两个USB插座和一个摄像头总线。你可能会认为这就是全部，但最好的还在后面。树莓派有一个叫做GPIO的东西，它代表通用输入/输出。这些被伪装成树莓派的一个角落上的40个插孔，这就是它变得非常特别的原因。
- en: Now, conventionally you would attach things to your computer that are compatible
    with it. So, hooking up a mouse, keyboard or a joystick is as easy as inserting
    a USB port, but what if you need to connect your computer to your light bulbs
    or your air-conditioner? Exactly, you can't. That's where GPIO comes in to save
    the day. These are pins which are very useful when it comes to robotics, as these
    can be used to connect various components such as sensors/motors. The beauty of
    these pins is that they can be used as either input or output based on what we
    program them for. So, as we will later see, each of these pins can be defined
    in the program to be either input or output based on our needs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，传统上您会将与计算机兼容的设备连接到计算机。因此，连接鼠标、键盘或游戏手柄就像插入USB端口一样简单，但是如果您需要将计算机连接到灯泡或空调呢？确切地说，您不能。这就是GPIO发挥作用的地方。这些引脚在机器人技术方面非常有用，因为它们可以用于连接各种组件，如传感器/电机。这些引脚的美妙之处在于，根据我们为其编程的需求，它们可以用作输入或输出。因此，正如我们将在后面看到的那样，这些引脚中的每一个都可以在程序中定义为输入或输出。
- en: 'Now, out of these 40 pins, 26 are GPIO. The rest of the pins are generic power
    or ground ports. There are two more ports called **ID EEPROM** which at this point
    of time we do not require:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这40个引脚中有26个是GPIO。其余的引脚是通用电源或地线端口。还有两个称为**ID EEPROM**的端口，目前我们不需要它们。
- en: '![](Images/aae525d5-71d4-4cba-ba1a-401be68266c6.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/aae525d5-71d4-4cba-ba1a-401be68266c6.png)'
- en: 'As you can see, Raspberry Pi is capable of giving us two types of power supply:
    3.3V and 5V. These basically cater for most of our purposes.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，树莓派能够为我们提供两种类型的电源供应：3.3V和5V。这基本上可以满足我们大部分的需求。
- en: Setting up Raspberry Pi
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置树莓派
- en: We will talk about the GPIO and other things to do with Raspberry Pi in a while.
    Firstly, we will understand how to set up this board for the first time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一会儿讨论有关树莓派的GPIO和其他事项。首先，我们将了解如何首次设置此板。
- en: The first thing you need to do is to make sure that the operating system of
    Raspberry Pi is ready. I am assuming that you are using a Windows PC, but if you
    are doing it on another OS as well, then there will not be much of a difference.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是确保树莓派的操作系统已经准备就绪。我假设您正在使用Windows PC，但如果您也在其他操作系统上进行操作，那么差别不会太大。
- en: 'To install the OS, start your PC and follow these steps:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装操作系统，请启动您的PC并按照以下步骤操作：
- en: Go to [www.raspberrypi.org](http://www.raspberrypi.org) and click on DOWNLOADS
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[www.raspberrypi.org](http://www.raspberrypi.org)并单击DOWNLOADS
- en: 'Now click on RASPBIAN, you will see the following two options:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击RASPBIAN，您将看到以下两个选项：
- en: RASPBIAN STRETCH WITH DESKTOP
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RASPBIAN STRETCH WITH DESKTOP
- en: RASPBIAN STRETCH LITE
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RASPBIAN STRETCH LITE
- en: We will be downloading RASPBIAN STRETCH WITH DESKTOP; this will give us the
    GUI interface for Raspberry Pi
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将下载RASPBIAN STRETCH WITH DESKTOP；这将为我们提供树莓派的GUI界面
- en: After downloading, unzip the package into a folder
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，将包解压缩到一个文件夹中
- en: Now we need to copy it to the memory card of Raspberry Pi. The memory card over
    which you need to copy must be formatted by low level formatting. There are basically
    two types of formatting. one which simply erases the index the other one which
    we know as low level formatting is the one in which we remove all the data from
    both the index and their physical memory location. There would be a button to
    toggle a low level format. Make sure it is clicked before you format your memory
    card for this function.  I would recommend using the SD card formatter by [www.sdcard.org](http://www.sdcard.org).
    Now open the formatter and you simply have to format it using the 32 KB option.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将它复制到树莓派的存储卡上。您需要复制的存储卡必须经过低级格式化。基本上有两种格式化方式。一种只是擦除索引，另一种是我们所知道的低级格式化，即从索引和物理内存位置中删除所有数据。会有一个按钮来切换低级格式。确保在为此功能格式化存储卡之前点击它。我建议使用[www.sdcard.org](http://www.sdcard.org)的SD卡格式化器。现在打开格式化器，您只需使用32
    KB选项进行格式化。
- en: 'Find more details and more up-to-date information here: [https://www.raspberrypi.org/documentation/installation/installing-images/README.md](https://www.raspberrypi.org/documentation/installation/installing-images/README.md).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里找到更多详细信息和更多最新信息：[https://www.raspberrypi.org/documentation/installation/installing-images/README.md](https://www.raspberrypi.org/documentation/installation/installing-images/README.md)。
- en: Once done, you have to copy the image onto the SD card. The easiest way to do
    that is by using WinDisk Imager. You can download it online without any problems.
    Then simply select the image and the location on your SD card and start copying
    the image.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您必须将映像复制到SD卡上。最简单的方法是使用WinDisk Imager。您可以在线下载它而不会遇到任何问题。然后只需选择映像和SD卡上的位置，然后开始复制映像。
- en: This could take a few minutes. After it is done, your SD will be ready. Plug
    it into Raspberry Pi and we will be ready to power it up. But before you power
    it up, plug in your monitor using the Micro HDMI to HDMI wire, connect the keyboard
    and mouse to Raspberry Pi using the Micro USB, and power it up by using the Micro
    USB adapter to standard USB adapter. Now, use the other USB port on Raspberry
    Pi to power it up using the micro USB power adapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要几分钟。完成后，您的SD卡将准备就绪。将其插入树莓派，我们将准备好启动它。但在启动之前，使用Micro HDMI到HDMI线将显示器连接到树莓派，使用Micro
    USB将键盘和鼠标连接到树莓派，然后使用Micro USB适配器连接到标准USB适配器来为其供电。现在，使用树莓派上的另一个USB端口，使用Micro USB电源适配器为其供电。
- en: Once you start it up, you will see a boot-up screen and within a few seconds
    you will be able to see the desktop. So, finally, our Raspberry Pi is up and running.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，您将看到一个启动屏幕，几秒钟后您将能够看到桌面。因此，我们的树莓派终于启动并运行了。
- en: Go ahead and explore a few options, surf the internet, look at some cat videos
    on YouTube, and get yourself familiar with this mighty device.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 继续探索一些选项，上网冲浪，观看YouTube上的一些猫视频，并熟悉这个强大的设备。
- en: By now, you must already be appreciating the power of Raspberry Pi. It may be
    slightly slower than your average computer. But, come on, this thing costs just
    $10!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经开始欣赏树莓派的强大。它可能比您平常使用的计算机稍慢。但是，拜托，这个东西只要10美元！
- en: Let's program
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们编程
- en: In this chapter, we will get you familiar with Python and how you can use the
    GPIOs on this device. To do this, go ahead and click on the Raspberry icon in
    the top left-hand corner. You will see the Python console 3.0\. There could be
    an older version of Python as well. We will be using the newer version in this
    book.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将让您熟悉Python以及如何在此设备上使用GPIO。要做到这一点，请点击左上角的树莓图标。您将看到Python控制台3.0。也可能有旧版本的Python。我们将在本书中使用更新的版本。
- en: Once the window opens, you will see the playground where you would be doing
    the coding. So now we are ready to write the first code for Python Robotics. Now
    let's see how it's done.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦窗口打开，您将看到您将在其中进行编码的游乐场。所以现在我们准备为Python机器人编写第一行代码。现在让我们看看它是如何完成的。
- en: 'The first thing we will write is:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先写的是：
- en: '![](Images/3400d872-583f-4f90-b539-091d6d0a2a3b.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3400d872-583f-4f90-b539-091d6d0a2a3b.png)'
- en: Almost all of the time when we start writing a program, we will start by writing
    the preceding line. Now, before we understand what it does, we need to understand
    libraries. Often while we are writing code, we will have to write the code again
    and again in multiple places. This takes a lot of time and certainly is not cool!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的时候，当我们开始编写程序时，我们会首先写上述行。现在，在我们了解它的作用之前，我们需要了解库。通常在编写代码时，我们将不得不在多个地方一遍又一遍地编写代码。这需要很多时间，而且肯定不酷！
- en: So, to solve this problem, we created functions. A function is a miniature program
    that we might think would be used over and over again. In this miniature program
    itself, we also mention what it would be called.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了解决这个问题，我们创建了函数。函数是一个微型程序，我们可能认为它会一遍又一遍地使用。在这个微型程序中，我们还提到它将被称为什么。
- en: Let's say that there is a code in which we need to multiply two numbers again
    and again. So, what we do is we write the code once and make it a function. We
    also name this function `Multiply`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个代码，我们需要一遍又一遍地将两个数字相乘。所以，我们写一次代码并将其制作成一个函数。我们还将这个函数命名为`Multiply`。
- en: So now, whenever we need to multiply two numbers, we don't have to write its
    code again; rather, we simply have to call the function to do it for us instead
    of writing the code to multiply. The problem is, how do we tell which number has
    to be multiplied?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我们需要相乘两个数字时，我们不必再次编写它的代码；相反，我们只需调用函数来代替我们编写相乘的代码。问题是，我们如何告诉程序要相乘哪个数字呢？
- en: There is a solution to that as well. As you might see later, whenever a function
    is called we put opening and closing brackets after it, such as `multiply()`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这也有一个解决方案。正如您以后可能看到的，每当调用一个函数时，我们在其后放上开放和关闭的括号，比如`multiply()`。
- en: If the brackets are empty that means no user input has been given. If, for example,
    we have to multiply `2` and `3` we simply write `Multiply(2,3)`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果括号是空的，那意味着没有给出用户输入。例如，如果我们要相乘`2`和`3`，我们只需写`Multiply(2,3)`。
- en: We are giving the input as `2` and `3`. The position of the input in the brackets
    is also important as the position in the brackets will define where in the program
    it will go.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在输入`2`和`3`。括号中的输入位置也很重要，因为括号中的位置将定义程序中的位置。
- en: 'Now, let''s say you make functions such as:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您创建了这样的函数：
- en: Add
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法
- en: Subtract
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减法
- en: Multiply
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相乘
- en: Divide
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除法
- en: Say you stack them together. Then the pile of functions grouped together will
    be called a library. These libraries can have hundreds of functions. There are
    some functions which are already in the Python language so that the job is made
    simpler for the programmers. Others can be defined as open source or developed
    by you at your convenience.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您将它们堆叠在一起。然后，一堆函数组合在一起将被称为库。这些库可以有数百个函数。有一些函数已经在Python语言中，以便程序员更轻松地完成工作。其他可以定义为开源或根据您的方便开发。
- en: Now, getting back to the point. We are calling the library `RPi.GPIO`; this
    is a library defined by Raspberry Pi. This will have functions that will make
    your life easier when it comes to programming Raspberry Pi. So, in the program,
    once we call the library, all the functions are at your disposal and ready to
    be used.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到重点。我们正在调用`RPi.GPIO`库；这是由树莓派定义的库。这将使您在编程树莓派时更加轻松。因此，在程序中，一旦我们调用库，所有函数都可以随时使用。
- en: In the next line, we write `Import.time`. As you must have guessed, this is
    used to import a library time. What it does we will learn shortly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们写`Import.time`。正如您可能已经猜到的那样，这是用来导入时间库的。我们很快就会了解它的作用。
- en: 'The next line of code would be as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码将如下所示：
- en: '![](Images/80ddb6d9-c893-4050-81c2-80125e7734a6.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/80ddb6d9-c893-4050-81c2-80125e7734a6.png)'
- en: Before we understand what it does, let's learn a bit more about GPIOs. These
    pins are hard numbered according to their physical positions in Raspberry Pi.
    However, we can change the numbering of the pins in the software for our understanding
    and convenience. But in this code, we will not be playing around with this and
    will set it do the default set by Broadcom, which is the manufacturer of the microcontroller
    of Raspberry Pi.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解它的作用之前，让我们更多地了解一下GPIO。这些引脚根据它们在树莓派中的物理位置进行了硬编号。但是，我们可以在软件中更改引脚的编号以便我们理解和方便使用。但在这个代码中，我们不会对此进行操作，而是将其设置为由Broadcom制造的默认设置，这是树莓派微控制器的制造商。
- en: This line uses a function of the `RPi.GPIO` library called `setmode`. What this
    function does is that it sets the pin configuration of the `setmode` to (`GPIO.BCM`)—`BCM`
    is further a function of `GPIO`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行使用了`RPi.GPIO`库的一个名为`setmode`的函数。这个函数的作用是将`setmode`的引脚配置设置为（`GPIO.BCM`）—`BCM`是`GPIO`的一个进一步的函数。
- en: 'Now we can use the base pin configuration. Further to this, a specialty of
    the GPIO pins is that it can be used both as input and output. But the only condition
    is that we have to specify whether it has to be used as input or output in the
    program itself. It cannot do both functions at the same time. Here is how it is
    done:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用基本引脚配置。GPIO引脚的特点是可以同时用作输入和输出。但唯一的条件是我们必须在程序中指定它是要用作输入还是输出。它不能同时执行两个功能。下面是如何做到的：
- en: '![](Images/16401634-9aea-4fef-95cb-5a3d682a4b2f.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/16401634-9aea-4fef-95cb-5a3d682a4b2f.png)'
- en: 'The next line of code will be as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码将如下所示：
- en: '![](Images/a04545b4-eca0-4b58-af12-7b3d30e16120.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a04545b4-eca0-4b58-af12-7b3d30e16120.png)'
- en: Again, we are using a function of the library `GPIO` called `output`. What this
    does is that it sets up a specific pin of the board in a state which we want.
    So, here we have mentioned that the pin number `23` has to be set high. Just for
    the sake of clarity, high means on and low means off.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用了GPIO库的一个函数`output`。它的作用是设置板子上特定引脚的状态。所以，这里我们指定了引脚号`23`必须设置为高电平。只是为了清楚起见，高电平表示开，低电平表示关。
- en: 'The next line of code will be as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码将如下所示：
- en: '![](Images/e036fcf5-bf04-4bef-8574-1e50a5754b5e.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e036fcf5-bf04-4bef-8574-1e50a5754b5e.png)'
- en: In this line, we are using a function from the library time. The function sleep
    basically freezes the state of all the GPIO pins. So, for example, if the pin
    `23` is high then it will remain high until the `time` the function `sleep` is
    executed. In the function `sleep`, we have defined the value as `3` seconds.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行中，我们使用了来自time库的一个函数。sleep函数基本上会冻结所有GPIO引脚的状态。所以，例如，如果引脚`23`是高电平，那么它将保持高电平，直到执行`time`函数`sleep`。在`sleep`函数中，我们定义了值为`3`秒。
- en: Hence, for 3 seconds, the pin state of Raspberry Pi will remain as it was before
    this line of code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，3秒内，树莓派的引脚状态将保持在这行代码之前的状态。
- en: 'Finally, the last line of the code will be:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码的最后一行将是：
- en: '![](Images/c5ef5641-0683-4051-aafb-2a74065e036b.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c5ef5641-0683-4051-aafb-2a74065e036b.png)'
- en: This will be a common sight after every program. This function of the GPIO library
    will reset the state of every pin that has been used in the program—the state
    of all the pins will be low. Remember, it will only affect the pins that are used
    in the program and not any other pins. So, for example, we have used the pin `23`
    in the program, so it will only affect pin `23` and not any other pin in Raspberry
    Pi.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是每个程序之后的常见情景。GPIO库的这个函数将重置程序中使用的每个引脚的状态，所有引脚的状态将变为低电平。记住，它只会影响程序中使用的引脚，而不会影响树莓派上的其他引脚。所以，例如，我们在程序中使用了引脚`23`，所以它只会影响引脚`23`，而不会影响树莓派上的其他引脚。
- en: 'Finally, your program will look something like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你的程序会看起来像这样：
- en: '![](Images/e443f82d-b779-4104-98a7-378d117b0b30.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e443f82d-b779-4104-98a7-378d117b0b30.png)'
- en: Now, one thing that you must remember is that whatever code we are writing will
    be executed one line after the other. So, let's say we keep `import RPI.GPIO as
    GPIO` at the bottom, then the whole program will not work. Why? Because as soon
    as it goes to `GPIO.setmode(GPIO.BCM)` it will not understand what `GPIO` is,
    neither will it understand what `setmode` is. Hence, we always import the libraries
    as soon as we start writing the code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你必须记住的一件事是，我们写的任何代码都将按顺序执行。所以，假设我们把`import RPI.GPIO as GPIO`放在底部，那么整个程序将无法工作。为什么？因为一旦它到达`GPIO.setmode(GPIO.BCM)`，它将不理解`GPIO`是什么，也不会理解`setmode`是什么。因此，我们总是在开始编写代码时导入库。
- en: 'Now, working on the same concept, it will execute the program in the following
    way:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，基于相同的概念，它将以以下方式执行程序：
- en: '`GPIO.out(23,GPIO.High)`: It will turn pin `23` high/on'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIO.out(23,GPIO.High)`: 它会将引脚`23`设置为高电平'
- en: '`time.sleep(3)`: It will wait for 3 seconds while pin is still high'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.sleep(3)`: 它会等待3秒，而引脚仍然是高电平'
- en: '`GPIO.cleanup()`: Finally, it will set the state of the pin `23` to low'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIO.cleanup()`: 最后，它会将引脚`23`的状态设置为低电平'
- en: Now, to see whether the program is working, let's attach some hardware to check
    whether what we have written is actually happening.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了查看程序是否工作，让我们连接一些硬件来检查我们所写的是否真的发生了。
- en: I am assuming that readers are already aware of how breadboard is used. If you
    are not familiar with it, just go ahead and google it. It will take 5 minutes
    to understand. It is super easy and will come in handy.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设读者已经知道如何使用面包板。如果你不熟悉，就去搜索一下。理解起来只需要5分钟。它非常简单，会派上用场。
- en: Now go ahead and connect the LED on breadboard, then connect the ground of the
    LED to the ground pin in Raspberry Pi, and set the positive/VCC to pin number
    `23` (refer the pin diagram).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续连接LED到面包板上，然后将LED的地连接到树莓派上的地引脚，并将正极/VCC连接到引脚号`23`（参考引脚图）。
- en: 'You can also refer to the following diagram:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以参考以下图表：
- en: '![](Images/e2d58a5a-afde-40dd-b7a6-3c0c32ec2b68.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e2d58a5a-afde-40dd-b7a6-3c0c32ec2b68.png)'
- en: Once you are done, go ahead run the code and see what happens!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，运行代码看看会发生什么！
- en: 'The LED will glow for 3 seconds and then turn back off again, exactly as we
    expected it to do. Now let''s just play around with the code and do a slight modification.
    This time, we will add a few more lines marked in bold:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: LED将会发光3秒，然后再次关闭，正如我们预期的那样。现在让我们玩弄一下代码，做一点修改。这次，我们将添加一些用粗体标记的额外行：
- en: '[PRE0]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Before understanding what's inside the code, you will notice that not every
    line is aligned, they have been intended. What does this mean ?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解代码内部之前，你会注意到并不是每一行都对齐，它们已经被缩进了。这是什么意思？
- en: A line indented together with other lines of code is called a block. So for
    example if you have a statement such as
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与其他代码行一起缩进的行称为块。所以例如，如果你有一个语句如下
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now in this line lets see how the code will run.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在这行让我们看看代码将如何运行。
- en: A while true loop would run, this will run the code that is inside it i.e.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个while true循环将运行，这将运行其中的代码，即
- en: '[PRE2]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Thereafter the code `for I in range (3):` would run. It will run the code inside
    the for loop until the value of `I` is in range, Hence the code below would run.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，代码`for I in range (3):`将运行。它将运行for循环内的代码，直到`I`的值在范围内，因此下面的代码将运行。
- en: '[PRE3]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The above code can be referred to a block of code, which is inside the `for`
    loop. The block of code can be made by indenting the code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码可以称为一个代码块，它在`for`循环内。代码块可以通过缩进代码来制作。
- en: 'Now, let''s see what it does. `While True` is a loop, it will run the `for`
    loop inside it again and again until the time the condition is not false. The
    condition we are using here is:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看它的作用。`While True`是一个循环，它将一遍又一遍地运行`for`循环，直到条件不再为假。我们在这里使用的条件是：
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The maximum range is `3` and every time the statement runs it increments the
    value of the `i` by `+1`. So it basically acts as a counter. Let's see what the
    program will actually do.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最大范围是`3`，每次语句运行时，`i`的值增加`+1`。因此，它基本上充当计数器。让我们看看程序实际会做什么。
- en: It will check for the value of `i` and increment it by `1` thereafter. As the
    code progresses, it will glow the LED high for 0.5 seconds and then shut it off
    for 0.5 seconds. And then it will wait for 1 second. This will repeat until the
    while loop is false, as in the value of `i` becomes greater than `3` where it
    would get out of the program and terminate. Run the program and see if it actually
    happens.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它将检查`i`的值，并在此之后递增`1`。随着代码的进展，它将使LED在0.5秒内高亮，然后在0.5秒内关闭。然后它将等待1秒。这将重复，直到while循环为假，也就是`i`的值大于`3`，它将退出程序并终止。运行程序，看看它是否真的发生了。
- en: By now, you understand how easy the programming is in Raspberry Pi. To go a
    step further, we will make another program and make some changes to the hardware.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解了在树莓派中编程是多么容易。为了更进一步，我们将编写另一个程序并对硬件进行一些更改。
- en: We will be connecting five more LEDs from pin numbers 7 through to 12\. We will
    make them switch on and off in a pattern.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从引脚号7到12连接五个LED。我们将使它们以一定模式开关。
- en: 'Once connected, we will write the code as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 连接后，我们将编写以下代码：
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now the code is fairly simple. Let''s see what it means:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码非常简单。让我们看看它的意思：
- en: '![](Images/f4dee2f7-57b5-4988-ae7a-022c333276ab.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f4dee2f7-57b5-4988-ae7a-022c333276ab.png)'
- en: Before I tell you something more about the code, let's go ahead and run it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我告诉你更多关于代码的事情之前，让我们继续运行它。
- en: When you run it, you will understand that as per the statement it is addressing
    the pins one by one and switching them to high after every 1 second.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，你会明白，根据语句，它会逐个地址引脚，并在每隔1秒后将它们切换到高电平。
- en: Playing with voltage
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩耍电压
- en: So far so good! But did you notice one thing? We have been using Raspberry Pi
    as a switch—simply switching the various components on and off. But what if we
    need to vary the intensity of the LEDs that we have just programmed? Is it possible? The
    answer is no. But we can still get it done somehow!
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利！但你注意到了一件事吗？我们一直在使用树莓派作为开关，简单地打开和关闭各种组件。但是如果我们需要改变刚刚编程的LED的强度怎么办？这可能吗？答案是否定的。但我们仍然可以以某种方式完成！
- en: Let's see how. Computers work in binary which means that they can represent
    either `0` or `1`. This is because of the fact that the primary computing unit
    in any system is based on a transistor which can either be on or off representing
    `0` or `1`. So, if we see this technically, computers are only capable of switching
    due to the binary architecture. However, there is a trick. This trick is called
    **pulse width modulation** (**PWM**).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何。计算机以二进制工作，这意味着它们可以表示`0`或`1`。这是因为任何系统中的主要计算单元都是基于可以表示`0`或`1`的晶体管。因此，从技术上讲，计算机只能进行二进制架构的切换。然而，有一个技巧。这个技巧叫做**脉宽调制**（**PWM**）。
- en: 'Now, before I explain any of it in detail, let''s go ahead plug in an LED on
    pin number `18`, then copy this code into Raspberry Pi and run it:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我详细解释任何内容之前，让我们继续将LED插入到引脚号为`18`，然后将此代码复制到树莓派并运行：
- en: '[PRE6]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What did you notice? The LED will be blinking at once a second. Now let's tweak
    it a bit and change the `PWM(18,1)` to `PWM(18,5)`. Let's run and see what happens.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了吗？LED将以每秒一次的频率闪烁。现在让我们稍微调整一下，将`PWM(18,1)`改为`PWM(18,5)`。运行并看看会发生什么。
- en: You will have noticed that it is now blinking five times in a second. So the
    number `5` is basically representing the frequency as the LED is now flickering
    five times in a second. Now, again, rewrite the code and increase `5` to `50`.
    Once you increase it to `50`, it switches the LED on and off 50 times in a second
    or at 50 Hertz. So, it appears to you as if it is always on.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到它现在每秒闪烁五次。因此数字`5`基本上表示频率，因为LED现在每秒闪烁五次。现在，再次重写代码并将`5`增加到`50`。一旦增加到`50`，它会在一秒内开关LED
    50次，或者以50赫兹的频率。因此，对您来说，它看起来好像一直开着。
- en: Now comes the interesting part. Go over to your code and change `duty_cycle
    = 50` to `duty_cycle = 10`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分。转到您的代码，并将`duty_cycle = 50`更改为`duty_cycle = 10`。
- en: What did you notice? You must have seen that the LED is now glowing way lower
    in intensity. In fact, it will be half of what it originally was.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了什么？你一定已经注意到LED的亮度现在低得多。实际上，它将是原来的一半。
- en: 'Let''s see what is actually happening:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际发生了什么：
- en: '![](Images/e188a479-9e7a-45a9-9fec-71e78570b396.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e188a479-9e7a-45a9-9fec-71e78570b396.png)'
- en: 'As you can make out from the diagram, the function is basically creating a
    pulse, the characteristics of which we are changing. The first characteristic
    is the frequency, the pulses generated in a second. In the code line `pwm= GPIO.PWM(18,1)` ,
    we are basically telling the microcontroller to generate one pulse every second
    on pin number `1`. In the second line, duty cycle is a percent value. It determines
    for how much percent of the time the pulse will be high. For the rest of the time
    of the pulse the output of the pin will be off. So, for the following code, the
    below bulleted points would be the characteristics:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表中可以看出，该函数基本上创建一个脉冲，我们正在更改其特性。第一个特性是频率，即每秒生成的脉冲。在代码行`pwm= GPIO.PWM(18,1)`中，我们基本上告诉微控制器在引脚号`1`上每秒生成一个脉冲。在第二行中，占空比是一个百分比值。它确定脉冲高电平的时间占总脉冲时间的百分比。对于以下代码，以下项目将是其特性：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Time/width of every pulse is 1 second
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个脉冲的时间/宽度为1秒
- en: Percent of time it would on is 50%
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将打开的时间占50%
- en: Percent of time it would be off is 50%
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将关闭的时间占50%
- en: Time it would be on is 0.5 seconds
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将打开的时间为0.5秒
- en: Time it would be off is 0.5 seconds
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将关闭0.5秒
- en: When we increase the frequency more than 50 hertz then it is very hard for the
    human eye to make out if it is actually switching on or off. Theoretically, for
    50% of the time the pin will remain high, and for the rest of the time it will
    be low. So, if we take an average then we can easily say that the overall voltage
    would be half of the original. Using this method, we can modulate the voltage
    output of any pin as per our requirements.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们增加频率超过50赫兹时，人眼很难分辨它是在开还是在关。理论上，引脚将保持高电平的时间占50%，其余时间将是低电平。因此，如果我们取平均值，我们可以很容易地说整体电压将是原始电压的一半。使用这种方法，我们可以根据我们的需求调制任何引脚的电压输出。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now you must have understood how the GPIOs can be used as output and how, by
    applying conditions, we can change their behaviors.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你一定已经明白了GPIO如何被用作输出，以及通过应用条件，我们如何改变它们的行为。
- en: In the next chapter, we will understand how these pins can be used as input
    as well. So come back, and see you there!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解这些引脚如何被用作输入。所以回来吧，我们在那里见！
