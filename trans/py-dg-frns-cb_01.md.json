["```py\nfrom __future__ import print_function\nimport argparse\n\n__authors__ = [\"Chapin Bryce\", \"Preston Miller\"]\n__date__ = 20170815\n__description__ = 'A simple argparse example'\n\nparser = argparse.ArgumentParser(\n    description=__description__,\n    epilog=\"Developed by {} on {}\".format(\n        \", \".join(__authors__), __date__)\n)\n```", "```py\n# Add Positional Arguments\nparser.add_argument(\"INPUT_FILE\", help=\"Path to input file\")\nparser.add_argument(\"OUTPUT_FILE\", help=\"Path to output file\")\n```", "```py\n# Optional Arguments\nparser.add_argument(\"--hash\", help=\"Hash the files\", action=\"store_true\")\n\nparser.add_argument(\"--hash-algorithm\",\n                    help=\"Hash algorithm to use. ie md5, sha1, sha256\",\n                    choices=['md5', 'sha1', 'sha256'], default=\"sha256\"\n                    )\n\nparser.add_argument(\"-v\", \"--version\", \"--script-version\",\n                    help=\"Displays script version information\",\n                    action=\"version\", version=str(__date__)\n                    )\n\nparser.add_argument('-l', '--log', help=\"Path to log file\", required=True)\n```", "```py\n# Parsing and using the arguments\nargs = parser.parse_args()\n\ninput_file = args.INPUT_FILE\noutput_file = args.OUTPUT_FILE\n\nif args.hash:\n    ha = args.hash_algorithm\n    print(\"File hashing enabled with {} algorithm\".format(ha))\nif not args.log:\n    print(\"Log file not defined. Will write to stdout\")\n```", "```py\nSecretDocs/\n|-- key.txt\n|-- Plans\n|   |-- plans_0012b.txt\n|   |-- plans_0016.txt\n|   `-- Successful_Plans\n|       |-- plan_0001.txt\n|       |-- plan_0427.txt\n|       `-- plan_0630.txt\n|-- Spreadsheets\n|   |-- costs.csv\n|   `-- profit.csv\n`-- Team\n    |-- Contact18.vcf\n    |-- Contact1.vcf\n    `-- Contact6.vcf\n\n4 directories, 11 files\n```", "```py\nfrom __future__ import print_function\nimport argparse\nimport os\n\n__authors__ = [\"Chapin Bryce\", \"Preston Miller\"]\n__date__ = 20170815\n__description__ = \"Directory tree walker\"\n\nparser = argparse.ArgumentParser(\n    description=__description__,\n    epilog=\"Developed by {} on {}\".format(\n        \", \".join(__authors__), __date__)\n)\nparser.add_argument(\"DIR_PATH\", help=\"Path to directory\")\nargs = parser.parse_args()\npath_to_scan = args.DIR_PATH\n```", "```py\n# Iterate over the path_to_scan\nfor root, directories, files in os.walk(path_to_scan):\n```", "```py\n    # Iterate over the files in the current \"root\"\n    for file_entry in files:\n        # create the relative path to the file\n        file_path = os.path.join(root, file_entry)\n        print(file_path)\n```", "```py\nfrom __future__ import print_function\nimport argparse\nfrom datetime import datetime as dt\nimport os\nimport sys\n\n__authors__ = [\"Chapin Bryce\", \"Preston Miller\"]\n__date__ = 20170815\n__description__ = \"Gather filesystem metadata of provided file\"\n\nparser = argparse.ArgumentParser(\n    description=__description__,\n    epilog=\"Developed by {} on {}\".format(\", \".join(__authors__), __date__)\n)\nparser.add_argument(\"FILE_PATH\",\n                    help=\"Path to file to gather metadata for\")\nargs = parser.parse_args()\nfile_path = args.FILE_PATH\n```", "```py\nstat_info = os.stat(file_path)\nif \"linux\" in sys.platform or \"darwin\" in sys.platform:\n    print(\"Change time: \", dt.fromtimestamp(stat_info.st_ctime))\nelif \"win\" in sys.platform:\n    print(\"Creation time: \", dt.fromtimestamp(stat_info.st_ctime))\nelse:\n    print(\"[-] Unsupported platform {} detected. Cannot interpret \"\n          \"creation/change timestamp.\".format(sys.platform)\n          )\nprint(\"Modification time: \", dt.fromtimestamp(stat_info.st_mtime))\nprint(\"Access time: \", dt.fromtimestamp(stat_info.st_atime))\n```", "```py\nprint(\"File mode: \", stat_info.st_mode)\nprint(\"File inode: \", stat_info.st_ino)\nmajor = os.major(stat_info.st_dev)\nminor = os.minor(stat_info.st_dev)\nprint(\"Device ID: \", stat_info.st_dev)\nprint(\"\\tMajor: \", major)\nprint(\"\\tMinor: \", minor)\n```", "```py\nprint(\"Number of hard links: \", stat_info.st_nlink)\nprint(\"Owner User ID: \", stat_info.st_uid)\nprint(\"Group ID: \", stat_info.st_gid)\nprint(\"File Size: \", stat_info.st_size)\n```", "```py\n# Gather other properties\nprint(\"Is a symlink: \", os.path.islink(file_path))\nprint(\"Absolute Path: \", os.path.abspath(file_path))\nprint(\"File exists: \", os.path.exists(file_path))\nprint(\"Parent directory: \", os.path.dirname(file_path))\nprint(\"Parent directory: {} | File name: {}\".format(\n    *os.path.split(file_path)))\n```", "```py\npip install pytz==2017.2\n```", "```py\nfrom __future__ import print_function\nimport argparse\nfrom datetime import datetime as dt\nimport os\nimport pytz\nfrom pywintypes import Time\nimport shutil\nfrom win32file import SetFileTime, CreateFile, CloseHandle\nfrom win32file import GENERIC_WRITE, FILE_SHARE_WRITE\nfrom win32file import OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL\n\n__authors__ = [\"Chapin Bryce\", \"Preston Miller\"]\n__date__ = 20170815\n__description__ = \"Gather filesystem metadata of provided file\"\n\n```", "```py\nparser = argparse.ArgumentParser(\n    description=__description__,\n    epilog=\"Developed by {} on {}\".format(\n        \", \".join(__authors__), __date__)\n)\nparser.add_argument(\"source\", help=\"Source file\")\nparser.add_argument(\"dest\", help=\"Destination directory or file\")\nparser.add_argument(\"--timezone\", help=\"Timezone of the file's timestamp\",\n                    choices=['EST5EDT', 'CST6CDT', 'MST7MDT', 'PST8PDT'],\n                    required=True)\nargs = parser.parse_args()\n\nsource = os.path.abspath(args.source)\nif os.sep in args.source:\n    src_file_name = args.source.split(os.sep, 1)[1]\nelse:\n    src_file_name = args.source\n\ndest = os.path.abspath(args.dest)\ntz = pytz.timezone(args.timezone)\n```", "```py\nshutil.copy2(source, dest)\nif os.path.isdir(dest):\n    dest_file = os.path.join(dest, src_file_name)\nelse:\n    dest_file = dest\n```", "```py\ncreated = dt.fromtimestamp(os.path.getctime(source))\ncreated = Time(tz.localize(created))\nmodified = dt.fromtimestamp(os.path.getmtime(source))\nmodified = Time(tz.localize(modified))\naccessed = dt.fromtimestamp(os.path.getatime(source))\naccessed = Time(tz.localize(accessed))\n\nprint(\"Source\\n======\")\nprint(\"Created: {}\\nModified: {}\\nAccessed: {}\".format(\n    created, modified, accessed))\n```", "```py\nhandle = CreateFile(dest_file, GENERIC_WRITE, FILE_SHARE_WRITE,\n                    None, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, None)\nSetFileTime(handle, created, accessed, modified)\nCloseHandle(handle)\n```", "```py\ncreated = tz.localize(dt.fromtimestamp(os.path.getctime(dest_file)))\nmodified = tz.localize(dt.fromtimestamp(os.path.getmtime(dest_file)))\naccessed = tz.localize(dt.fromtimestamp(os.path.getatime(dest_file)))\nprint(\"\\nDestination\\n===========\")\nprint(\"Created: {}\\nModified: {}\\nAccessed: {}\".format(\n    created, modified, accessed))\n```", "```py\nfrom __future__ import print_function\nimport argparse\nimport hashlib\nimport os\n\n__authors__ = [\"Chapin Bryce\", \"Preston Miller\"]\n__date__ = 20170815\n__description__ = \"Script to hash a file's name and contents\"\n\navailable_algorithms = {\n    \"md5\": hashlib.md5,\n    \"sha1\": hashlib.sha1,\n    \"sha256\": hashlib.sha256,\n    \"sha512\": hashlib.sha512\n}\n\nparser = argparse.ArgumentParser(\n    description=__description__,\n    epilog=\"Developed by {} on {}\".format(\", \".join(__authors__), __date__)\n)\nparser.add_argument(\"FILE_NAME\", help=\"Path of file to hash\")\nparser.add_argument(\"ALGORITHM\", help=\"Hash algorithm to use\",\n                    choices=sorted(available_algorithms.keys()))\nargs = parser.parse_args()\n\ninput_file = args.FILE_NAME\nhash_alg = args.ALGORITHM\n```", "```py\nfile_name = available_algorithms[hash_alg]()\nabs_path = os.path.abspath(input_file)\nfile_name.update(abs_path.encode())\n\nprint(\"The {} of the filename is: {}\".format(\n    hash_alg, file_name.hexdigest()))\n```", "```py\nfile_content = available_algorithms[hash_alg]()\nwith open(input_file, 'rb') as open_file:\n    buff_size = 1024\n    buff = open_file.read(buff_size)\n\n    while buff:\n        file_content.update(buff)\n        buff = open_file.read(buff_size)\n\nprint(\"The {} of the content is: {}\".format(\n    hash_alg, file_content.hexdigest()))\n```", "```py\npip install tqdm==4.11.2\n```", "```py\nfrom __future__ import print_function\nfrom time import sleep\nimport tqdm\n\nfruits = [\n    \"Acai\", \"Apple\", \"Apricots\", \"Avocado\", \"Banana\", \"Blackberry\",\n    \"Blueberries\", \"Cherries\", \"Coconut\", \"Cranberry\", \"Cucumber\",\n    \"Durian\", \"Fig\", \"Grapefruit\", \"Grapes\", \"Kiwi\", \"Lemon\", \"Lime\",\n    \"Mango\", \"Melon\", \"Orange\", \"Papaya\", \"Peach\", \"Pear\", \"Pineapple\",\n    \"Pomegranate\", \"Raspberries\", \"Strawberries\", \"Watermelon\"\n]\n```", "```py\ncontains_berry = 0\nfor fruit in tqdm.tqdm(fruits):\n    if \"berr\" in fruit.lower():\n        contains_berry += 1\n    sleep(.1)\nprint(\"{} fruit names contain 'berry' or 'berries'\".format(contains_berry))\n```", "```py\ncontains_berry = 0\npbar = tqdm.tqdm(fruits, desc=\"Reviewing names\", unit=\"fruits\")\nfor fruit in pbar:\n    if \"berr\" in fruit.lower():\n        contains_berry += 1\n    pbar.set_postfix(hits=contains_berry)\n    sleep(.1)\nprint(\"{} fruit names contain 'berry' or 'berries'\".format(contains_berry))\n```", "```py\nfor i in tqdm.trange(10000000, unit_scale=True, desc=\"Trange: \"):\n    pass\n```", "```py\nfrom __future__ import print_function\nimport logging\nimport sys\n\nlogger = logging.getLogger(__file__)\nlogger.setLevel(logging.DEBUG)\n\nmsg_fmt = logging.Formatter(\"%(asctime)-15s %(funcName)-20s\"\n                            \"%(levelname)-8s %(message)s\")\n```", "```py\nstrhndl = logging.StreamHandler(sys.stdout)\nstrhndl.setFormatter(fmt=msg_fmt)\n\nfhndl = logging.FileHandler(__file__ + \".log\", mode='a')\nfhndl.setFormatter(fmt=msg_fmt)\n\nlogger.addHandler(strhndl)\nlogger.addHandler(fhndl)\n```", "```py\nlogger.info(\"information message\")\nlogger.debug(\"debug message\")\n\ndef function_one():\n    logger.warning(\"warning message\")\n\ndef function_two():\n    logger.error(\"error message\")\n\nfunction_one()\nfunction_two()\n```", "```py\nfrom __future__ import print_function\nimport logging\nimport multiprocessing as mp\nfrom random import randint\nimport sys\nimport time\n```", "```py\ndef sleepy(seconds):\n    proc_name = mp.current_process().name\n    logger.info(\"{} is sleeping for {} seconds.\".format(\n        proc_name, seconds))\n    time.sleep(seconds)\n```", "```py\nlogger = logging.getLogger(__file__)\nlogger.setLevel(logging.DEBUG)\nmsg_fmt = logging.Formatter(\"%(asctime)-15s %(funcName)-7s \"\n                            \"%(levelname)-8s %(message)s\")\nstrhndl = logging.StreamHandler(sys.stdout)\nstrhndl.setFormatter(fmt=msg_fmt)\nlogger.addHandler(strhndl)\n```", "```py\nnum_workers = 5\nworkers = []\nfor w in range(num_workers):\n    p = mp.Process(target=sleepy, args=(randint(1, 20),))\n    p.start()\n    workers.append(p)\n```", "```py\nfor worker in workers:\n    worker.join()\n    logger.info(\"Joined process {}\".format(worker.name))\n```"]