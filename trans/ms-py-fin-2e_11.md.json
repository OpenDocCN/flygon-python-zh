["```py\npip install v20 \n```", "```py\nfrom abc import abstractmethod\n\nclass Broker(object):\n    def __init__(self, host, port):\n        self.host = host\n        self.port = port\n\n        self.__price_event_handler = None\n        self.__order_event_handler = None\n        self.__position_event_handler = None\n```", "```py\n@property\ndef on_price_event(self):\n    \"\"\"\n    Listeners will receive: symbol, bid, ask\n    \"\"\"\n    return self.__price_event_handler\n\n@on_price_event.setter\ndef on_price_event(self, event_handler):\n    self.__price_event_handler = event_handler\n```", "```py\n@property\ndef on_order_event(self):\n    \"\"\"\n    Listeners will receive: transaction_id\n    \"\"\"\n    return self.__order_event_handler\n\n@on_order_event.setter\ndef on_order_event(self, event_handler):\n    self.__order_event_handler = event_handler\n```", "```py\n@property\ndef on_position_event(self):\n    \"\"\"\n    Listeners will receive:\n    symbol, is_long, units, unrealized_pnl, pnl\n    \"\"\"\n    return self.__position_event_handler\n\n@on_position_event.setter\ndef on_position_event(self, event_handler):\n    self.__position_event_handler = event_handler\n```", "```py\n@abstractmethod\ndef get_prices(self, symbols=[]):\n    \"\"\"\n    Query market prices from a broker\n    :param symbols: list of symbols recognized by your broker\n    \"\"\"\n    raise NotImplementedError('Method is required!')\n```", "```py\n@abstractmethod\ndef stream_prices(self, symbols=[]):\n    \"\"\"\"\n    Continuously stream prices from a broker.\n    :param symbols: list of symbols recognized by your broker\n    \"\"\"\n    raise NotImplementedError('Method is required!')\n```", "```py\n@abstractmethod\ndef send_market_order(self, symbol, quantity, is_buy):\n    raise NotImplementedError('Method is required!')\n```", "```py\nimport v20\n\nclass OandaBroker(Broker):\n    PRACTICE_API_HOST = 'api-fxpractice.oanda.com'\n    PRACTICE_STREAM_HOST = 'stream-fxpractice.oanda.com'\n\n    LIVE_API_HOST = 'api-fxtrade.oanda.com'\n    LIVE_STREAM_HOST = 'stream-fxtrade.oanda.com'\n\n    PORT = '443'\n\n    def __init__(self, accountid, token, is_live=False):\n        if is_live:\n            host = self.LIVE_API_HOST\n            stream_host = self.LIVE_STREAM_HOST\n        else:\n            host = self.PRACTICE_API_HOST\n            stream_host = self.PRACTICE_STREAM_HOST\n\n        super(OandaBroker, self).__init__(host, self.PORT)\n\n        self.accountid = accountid\n        self.token = token\n\n        self.api = v20.Context(host, self.port, token=token)\n        self.stream_api = v20.Context(stream_host, self.port, token=token)\n```", "```py\ndef get_prices(self, symbols=[]):\n    response = self.api.pricing.get(\n        self.accountid,\n        instruments=\",\".join(symbols),\n        snapshot=True,\n        includeUnitsAvailable=False\n    )\n    body = response.body\n    prices = body.get('prices', [])\n    for price in prices:\n        self.process_price(price)\n```", "```py\ndef process_price(self, price):\n    symbol = price.instrument\n\n    if not symbol:\n        print('Price symbol is empty!')\n        return\n\n    bids = price.bids or []\n    price_bucket_bid = bids[0] if bids and len(bids) > 0 else None\n    bid = price_bucket_bid.price if price_bucket_bid else 0\n\n    asks = price.asks or []\n    price_bucket_ask = asks[0] if asks and len(asks) > 0 else None\n    ask = price_bucket_ask.price if price_bucket_ask else 0\n\n    self.on_price_event(symbol, bid, ask)\n```", "```py\ndef stream_prices(self, symbols=[]):\n    response = self.stream_api.pricing.stream(\n        self.accountid,\n        instruments=\",\".join(symbols),\n        snapshot=True\n    )\n\n    for msg_type, msg in response.parts():\n        if msg_type == \"pricing.Heartbeat\":\n            continue\n        elif msg_type == \"pricing.ClientPrice\":\n            self.process_price(msg)\n```", "```py\ndef send_market_order(self, symbol, quantity, is_buy):\n    response = self.api.order.market(\n        self.accountid,\n        units=abs(quantity) * (1 if is_buy else -1),\n        instrument=symbol,\n        type='MARKET',\n    )\n    if response.status != 201:\n        self.on_order_event(symbol, quantity, is_buy, None, 'NOT_FILLED')\n        return\n\n    body = response.body\n    if 'orderCancelTransaction' in body:\n        self.on_order_event(symbol, quantity, is_buy, None, 'NOT_FILLED')\n        return transaction_id = body.get('lastTransactionID', None) \n    self.on_order_event(symbol, quantity, is_buy, transaction_id, 'FILLED')\n```", "```py\ndef get_positions(self):\n    response = self.api.position.list(self.accountid)\n    body = response.body\n    positions = body.get('positions', [])\n    for position in positions:\n        symbol = position.instrument\n        unrealized_pnl = position.unrealizedPL\n        pnl = position.pl\n        long = position.long\n        short = position.short\n\n        if short.units:\n            self.on_position_event(\n                symbol, False, short.units, unrealized_pnl, pnl)\n        elif long.units:\n            self.on_position_event(\n                symbol, True, long.units, unrealized_pnl, pnl)\n        else:\n            self.on_position_event(\n                symbol, None, 0, unrealized_pnl, pnl)\n```", "```py\n# Replace these 2 values with your own!\nACCOUNT_ID = '101-001-1374173-001'\nAPI_TOKEN = '6ecf6b053262c590b78bb8199b85aa2f-d99c54aecb2d5b4583a9f707636e8009'\n\nbroker = OandaBroker(ACCOUNT_ID, API_TOKEN)\n```", "```py\nSYMBOL = 'EUR_USD'\n```", "```py\nimport datetime as dt\n\ndef on_price_event(symbol, bid, ask):\n   print(\n        dt.datetime.now(), '[PRICE]',\n        symbol, 'bid:', bid, 'ask:', ask\n    )\n\nbroker.on_price_event = on_price_event\n```", "```py\nbroker.get_prices(symbols=[SYMBOL])\n```", "```py\n2018-11-19 21:29:13.214893 [PRICE] EUR_USD bid: 1.14361 ask: 1.14374\n```", "```py\ndef on_order_event(symbol, quantity, is_buy, transaction_id, status):\n    print(\n        dt.datetime.now(), '[ORDER]',\n        'transaction_id:', transaction_id,\n        'status:', status,\n        'symbol:', symbol,\n        'quantity:', quantity,\n        'is_buy:', is_buy,\n    )\n\nbroker.on_order_event = on_order_event\nbroker.send_market_order(SYMBOL, 1, True)\n```", "```py\n2018-11-19 21:29:13.484685 [ORDER] transaction_id: 754 status: FILLED symbol: EUR_USD quantity: 1 is_buy: True\n```", "```py\ndef on_position_event(symbol, is_long, units, upnl, pnl):\n    print(\n        dt.datetime.now(), '[POSITION]',\n        'symbol:', symbol,\n        'is_long:', is_long,\n        'units:', units,\n        'upnl:', upnl,\n        'pnl:', pnl\n    )\n\nbroker.on_position_event = on_position_event\nbroker.get_positions()\n```", "```py\n2018-11-19 21:29:13.752886 [POSITION] symbol: EUR_USD is_long: True units: 1.0 upnl: -0.0001 pnl: 0.0\n```", "```py\nimport time\nimport datetime as dt\nimport pandas as pd\n\nclass MeanReversionTrader(object):\n    def __init__(\n        self, broker, symbol=None, units=1,\n        resample_interval='60s', mean_periods=5\n    ):\n        \"\"\"\n        A trading platform that trades on one side\n            based on a mean-reverting algorithm.\n\n        :param broker: Broker object\n        :param symbol: A str object recognized by the broker for trading\n        :param units: Number of units to trade\n        :param resample_interval: \n            Frequency for resampling price time series\n        :param mean_periods: Number of resampled intervals\n            for calculating the average price\n        \"\"\"\n        self.broker = self.setup_broker(broker)\n\n        self.resample_interval = resample_interval\n        self.mean_periods = mean_periods\n        self.symbol = symbol\n        self.units = units\n\n        self.df_prices = pd.DataFrame(columns=[symbol])\n        self.pnl, self.upnl = 0, 0\n\n        self.mean = 0\n        self.bid_price, self.ask_price = 0, 0\n        self.position = 0\n        self.is_order_pending = False\n        self.is_next_signal_cycle = True\n```", "```py\ndef setup_broker(self, broker):\n    broker.on_price_event = self.on_price_event\n    broker.on_order_event = self.on_order_event\n    broker.on_position_event = self.on_position_event\n    return broker\n```", "```py\ndef on_price_event(self, symbol, bid, ask):\n    print(dt.datetime.now(), '[PRICE]', symbol, 'bid:', bid, 'ask:', ask)\n\n    self.bid_price = bid\n    self.ask_price = ask\n    self.df_prices.loc[pd.Timestamp.now(), symbol] = (bid + ask) / 2.\n\n    self.get_positions()\n    self.generate_signals_and_think()\n\n    self.print_state()\n```", "```py\ndef get_positions(self):\n    try:\n        self.broker.get_positions()\n    except Exception as ex:\n        print('get_positions error:', ex)\n```", "```py\ndef on_order_event(self, symbol, quantity, is_buy, transaction_id, status):\n    print(\n        dt.datetime.now(), '[ORDER]',\n        'transaction_id:', transaction_id,\n        'status:', status,\n        'symbol:', symbol,\n        'quantity:', quantity,\n        'is_buy:', is_buy,\n    )\n    if status == 'FILLED':\n        self.is_order_pending = False\n        self.is_next_signal_cycle = False\n\n        self.get_positions()  # Update positions before thinking\n        self.generate_signals_and_think()\n```", "```py\ndef on_position_event(self, symbol, is_long, units, upnl, pnl):\n    if symbol == self.symbol:\n        self.position = abs(units) * (1 if is_long else -1)\n        self.pnl = pnl\n        self.upnl = upnl\n        self.print_state()\n```", "```py\ndef print_state(self):\n    print(\n        dt.datetime.now(), self.symbol, self.position_state, \n        abs(self.position), 'upnl:', self.upnl, 'pnl:', self.pnl\n    )\n```", "```py\ndef generate_signals_and_think(self):\n    df_resampled = self.df_prices\\\n        .resample(self.resample_interval)\\\n        .ffill()\\\n        .dropna()\n    resampled_len = len(df_resampled.index)\n\n    if resampled_len < self.mean_periods:\n        print(\n            'Insufficient data size to calculate logic. Need',\n            self.mean_periods - resampled_len, 'more.'\n        )\n        return\n\n    mean = df_resampled.tail(self.mean_periods).mean()[self.symbol]\n\n    # Signal flag calculation\n    is_signal_buy = mean > self.ask_price\n    is_signal_sell = mean < self.bid_price\n\n    print(\n        'is_signal_buy:', is_signal_buy,\n        'is_signal_sell:', is_signal_sell,\n        'average_price: %.5f' % mean,\n        'bid:', self.bid_price,\n        'ask:', self.ask_price\n    )\n\n    self.think(is_signal_buy, is_signal_sell)\n```", "```py\ndef think(self, is_signal_buy, is_signal_sell):\n    if self.is_order_pending:\n        return\n\n    if self.position == 0:\n        self.think_when_flat_position(is_signal_buy, is_signal_sell)\n    elif self.position > 0:\n        self.think_when_position_long(is_signal_sell)\n    elif self.position < 0: \n        self.think_when_position_short(is_signal_buy)       \n```", "```py\ndef think_when_position_flat(self, is_signal_buy, is_signal_sell):\n    if is_signal_buy and self.is_next_signal_cycle:\n        print('Opening position, BUY', \n              self.symbol, self.units, 'units')\n        self.is_order_pending = True\n        self.send_market_order(self.symbol, self.units, True)\n        return\n\n    if is_signal_sell and self.is_next_signal_cycle:\n        print('Opening position, SELL', \n              self.symbol, self.units, 'units')\n        self.is_order_pending = True\n        self.send_market_order(self.symbol, self.units, False)\n        return\n\n    if not is_signal_buy and not is_signal_sell:\n        self.is_next_signal_cycle = True\n```", "```py\ndef think_when_position_long(self, is_signal_sell):\n    if is_signal_sell:\n        print('Closing position, SELL', \n              self.symbol, self.units, 'units')\n        self.is_order_pending = True\n        self.send_market_order(self.symbol, self.units, False)\n```", "```py\ndef think_when_position_short(self, is_signal_buy):\n    if is_signal_buy:\n        print('Closing position, BUY', \n              self.symbol, self.units, 'units')\n        self.is_order_pending = True\n        self.send_market_order(self.symbol, self.units, True)\n```", "```py\ndef send_market_order(self, symbol, quantity, is_buy):\n    self.broker.send_market_order(symbol, quantity, is_buy)\n```", "```py\ndef run(self):\n    self.get_positions()\n    self.broker.stream_prices(symbols=[self.symbol])\n```", "```py\ntrader = MeanReversionTrader(\n    broker, \n    symbol='EUR_USD', \n    units=1\n    resample_interval='60s', \n    mean_periods=5,\n)\ntrader.run()\n```", "```py\n...\n2018-11-21 15:19:34.487216 [PRICE] EUR_USD bid: 1.1393 ask: 1.13943\n2018-11-21 15:19:35.686323 EUR_USD FLAT 0 upnl: 0.0 pnl: 0.0\nInsufficient data size to calculate logic. Need 5 more.\n2018-11-21 15:19:35.694619 EUR_USD FLAT 0 upnl: 0.0 pnl: 0.0\n...\n```", "```py\n...\n2018-11-21 15:25:07.075883 EUR_USD FLAT 0 upnl: 0.0 pnl: -0.3246\nis_signal_buy: False is_signal_sell: True average_price: 1.13934 bid: 1.13936 ask: 1.13949\nOpening position, SELL EUR_USD 1 units\n2018-11-21 15:25:07.356520 [ORDER] transaction_id: 2848 status: FILLED symbol: EUR_USD quantity: 1 is_buy: False\n2018-11-21 15:25:07.688082 EUR_USD SHORT 1.0 upnl: -0.0001 pnl: 0.0\nis_signal_buy: False is_signal_sell: True average_price: 1.13934 bid: 1.13936 ask: 1.13949\n2018-11-21 15:25:07.692292 EUR_USD SHORT 1.0 upnl: -0.0001 pnl: 0.0\n\n...\n```", "```py\nclass TrendFollowingTrader(MeanReversionTrader):\n    def __init__(\n        self, *args, long_mean_periods=10,\n        buy_threshold=1.0, sell_threshold=1.0, **kwargs\n    ):\n        super(TrendFollowingTrader, self).__init__(*args, **kwargs)\n\n        self.long_mean_periods = long_mean_periods\n        self.buy_threshold = buy_threshold\n        self.sell_threshold = sell_threshold\n```", "```py\ndef generate_signals_and_think(self):\n    df_resampled = self.df_prices\\\n        .resample(self.resample_interval)\\\n        .ffill().dropna()\n    resampled_len = len(df_resampled.index)\n\n    if resampled_len < self.long_mean_periods:\n        print(\n            'Insufficient data size to calculate logic. Need',\n            self.mean_periods - resampled_len, 'more.'\n        )\n        return\n\n    mean_short = df_resampled\\\n        .tail(self.mean_periods).mean()[self.symbol]\n    mean_long = df_resampled\\\n        .tail(self.long_mean_periods).mean()[self.symbol]\n    beta = mean_short / mean_long\n\n    # Signal flag calculation\n    is_signal_buy = beta > self.buy_threshold\n    is_signal_sell = beta < self.sell_threshold\n\n    print(\n        'is_signal_buy:', is_signal_buy,\n        'is_signal_sell:', is_signal_sell,\n        'beta:', beta,\n        'bid:', self.bid_price,\n        'ask:', self.ask_price\n    )\n\n    self.think(is_signal_buy, is_signal_sell)\n```", "```py\ntrader = TrendFollowingTrader(\n    broker,\n    resample_interval='60s',\n    symbol='EUR_USD',\n    units=1,\n    mean_periods=5,\n    long_mean_periods=10,\n    buy_threshold=1.000010,\n    sell_threshold=0.99990,\n)\ntrader.run()\n```", "```py\n...\n2018-11-23 08:51:12.438684 [PRICE] EUR_USD bid: 1.14018 ask: 1.14033\n2018-11-23 08:51:13.520880 EUR_USD FLAT 0 upnl: 0.0 pnl: 0.0\nInsufficient data size to calculate logic. Need 10 more.\n2018-11-23 08:51:13.529919 EUR_USD FLAT 0 upnl: 0.0 pnl: 0.0\n... \n```", "```py\n...\nis_signal_buy: True is_signal_sell: False beta: 1.0000333228980047 bid: 1.14041 ask: 1.14058\nOpening position, BUY EUR_USD 1 units\n2018-11-23 09:01:01.579208 [ORDER] transaction_id: 2905 status: FILLED symbol: EUR_USD quantity: 1 is_buy: True\n2018-11-23 09:01:01.844743 EUR_USD LONG 1.0 upnl: -0.0002 pnl: 0.0\n...\n```", "```py\n\"\"\"\nDownload the all-time AAPL dataset\n\"\"\"\nfrom alpha_vantage.timeseries import TimeSeries\n\n# Update your Alpha Vantage API key here...\nALPHA_VANTAGE_API_KEY = 'PZ2ISG9CYY379KLI'\n\nts = TimeSeries(key=ALPHA_VANTAGE_API_KEY, output_format='pandas')\ndf, meta_data = ts.get_daily_adjusted(symbol='AAPL', outputsize='full')\n```", "```py\ndf.info()\n```", "```py\n<class 'pandas.core.frame.DataFrame'>\nIndex: 5259 entries, 1998-01-02 to 2018-11-23\nData columns (total 8 columns):\n1\\. open                 5259 non-null float64\n2\\. high                 5259 non-null float64\n3\\. low                  5259 non-null float64\n4\\. close                5259 non-null float64\n5\\. adjusted close       5259 non-null float64\n6\\. volume               5259 non-null float64\n7\\. dividend amount      5259 non-null float64\n8\\. split coefficient    5259 non-null float64\ndtypes: float64(8)\nmemory usage: 349.2+ KB\n```", "```py\nimport datetime as dt\nimport pandas as pd\n\n# Define the date range\nstart = dt.datetime(2017, 1, 1)\nend = dt.datetime(2017, 12, 31)\n\n# Cast indexes as DateTimeIndex objects\ndf.index = pd.to_datetime(df.index)\nclosing_prices = df['5\\. adjusted close']\nprices = closing_prices.loc[start:end]\n```", "```py\nfrom scipy.stats import norm\n\ndef calculate_daily_var(\n    portfolio, prob, mean, \n    stdev, days_per_year=252.\n):\n    alpha = 1-prob\n    u = mean/days_per_year\n    sigma = stdev/np.sqrt(days_per_year)\n    norminv = norm.ppf(alpha, u, sigma)\n    return portfolio - portfolio*(norminv+1)\n```", "```py\nimport numpy as np\n\nportfolio = 100000000.00\nconfidence = 0.95\n\ndaily_returns = prices.pct_change().dropna()\nmu = np.mean(daily_returns)\nsigma = np.std(daily_returns)\n```", "```py\nVaR = calculate_daily_var(\n    portfolio, confidence, mu, sigma, days_per_year=252.)\nprint('Value-at-Risk: %.2f' % VaR)\n```", "```py\nValue-at-Risk: 114248.72\n```"]