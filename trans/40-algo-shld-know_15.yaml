- en: Cryptography
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学
- en: This chapter introduces you to algorithms related to cryptography. We will start
    by presenting the background, then we will discuss symmetric encryption algorithms.
    We will then explain the **Message-Digest 5** (**MD5**) algorithm and the **Secure
    Hash Algorithm**(**SHA**) and present the limitations and weaknesses of implementing
    symmetric algorithms. Next, we will discuss asymmetric encryption algorithms and
    how they are used to create digital certificates. Finally, we will present a practical
    example that summarizes all of these techniques.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了与密码学相关的算法。我们将首先介绍背景，然后讨论对称加密算法。然后我们将解释**消息摘要5**（**MD5**）算法和**安全哈希算法**（**SHA**），并介绍实施对称算法的局限性和弱点。接下来，我们将讨论非对称加密算法以及它们用于创建数字证书的方式。最后，我们将提供一个总结所有这些技术的实际示例。
- en: By the end of this chapter, you will have a basic understanding of various issues
    related to cryptography.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，您将对与密码学相关的各种问题有一个基本的了解。
- en: 'The following topics are discussed in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论以下主题：
- en: Introduction to cryptography
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学简介
- en: Understanding the types of cryptography techniques
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解密码学技术的类型
- en: Example – security concerns when deploying a machine learning model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例-部署机器学习模型时的安全问题
- en: Let's start by looking at the basic concepts.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从基本概念开始。
- en: Introduction to Cryptography
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学简介
- en: Techniques to protect secrets have been around for centuries. The earliest attempts
    to secure and hide data from adversaries date back to ancient inscriptions discovered
    on monuments in Egypt, where a special alphabet that was known by only a few trusted
    people was used. This early form of security is called **obscurity** and is still
    used in different forms today. In order for this method to work, it is critical
    to protect the secret, which is the meaning of the alphabet. Later in time, finding
    foolproof ways of protecting important messages was important in both World War
    One and World War Two. In the late-20^(th) century, with the introduction of electronics
    and computers, sophisticated algorithms were developed to secure data, giving
    rise to a whole new field called **cryptography**. This chapter discusses the
    algorithmic aspects of cryptography. The purpose of these algorithms is to allow
    secure data exchange between two processes or users. Cryptographic algorithms
    find strategies of using mathematical functions to ensure the stated security
    goals.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 保护秘密的技术已经存在了几个世纪。最早的保护和隐藏数据免受敌人侵害的尝试可以追溯到埃及的古代铭文，那里使用了只有少数信任的人知道的特殊字母表。这种早期的安全形式被称为**模糊**，今天仍然以不同的形式使用。为了使这种方法有效，保护字母表的含义至关重要。随后，在一战和二战中，寻找保护重要消息的绝对可靠方法变得非常重要。20世纪末，随着电子和计算机的引入，开发了复杂的算法来保护数据，从而产生了一个全新的领域，称为**密码学**。本章讨论了密码学的算法方面。这些算法的目的是允许两个进程或用户之间进行安全数据交换。密码算法找到了使用数学函数来确保所述安全目标的策略。
- en: Understanding the Importance of the Weakest Link
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解最弱链接的重要性
- en: Sometimes, when architecting the security of digital infrastructure, we put
    too much emphasis on the security of individual entities and don't pay the necessary
    attention to end-to-end security. This can result in us overlooking some loopholes
    and vulnerabilities in the system, which can later be exploited by hackers to
    access sensitive data. The important point to remember is that a digital infrastructure,
    as a whole, is only as strong as its **weakest link**. For a hacker, this weakest
    link can provide backdoor access to the sensitive data in the digital infrastructure.
    Beyond a certain point, there is not much benefit in fortifying the front door
    without closing all the back doors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在构建数字基础设施的安全性时，我们过分强调个体实体的安全性，而忽视了端到端的安全性。这可能导致我们忽视系统中的一些漏洞和弱点，这些漏洞和弱点后来可能被黑客利用来获取敏感数据。要记住的重要一点是，整个数字基础设施的强度取决于它的**最弱链接**。对于黑客来说，这个最弱链接可以提供对数字基础设施中敏感数据的后门访问。在某个程度上，加固前门而不关闭所有后门并没有太多好处。
- en: As the algorithms and techniques for keeping digital infrastructure become more
    and more sophisticated, attackers keep upgrading their techniques as well. It
    is always important to remember that one of the easiest ways for attackers to
    hack digital infrastructure is by exploiting these vulnerabilities to access sensitive
    information.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数字基础设施的算法和技术变得越来越复杂，攻击者也在不断升级他们的技术。要记住的一点是，攻击者入侵数字基础设施最简单的方法之一就是利用这些漏洞来获取敏感信息。
- en: In 2014, a cyber attack on a Canadian federal research institute—the **National
    Research Council** (**NRC**)—is estimated to have cost hundreds of millions of
    dollars. The attackers were able to steal decades of research data and intellectual
    property material. They used a loophole in the Apache software that was used on
    the web servers to gain access to the sensitive data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年，对加拿大联邦研究机构——**国家研究委员会**（**NRC**）的网络进行了一次网络攻击，据估计造成了数亿美元的损失。攻击者能够窃取数十年的研究数据和知识产权材料。他们利用了网页服务器上使用的Apache软件中的一个漏洞来获取对敏感数据的访问权限。
- en: In this chapter, we will highlight the vulnerabilities of various encryption
    algorithms.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点介绍各种加密算法的漏洞。
- en: Let's first look at the basic terminology used.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先来看看使用的基本术语。
- en: The Basic Terminology
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本术语
- en: 'Let''s look at the basic terminology related to cryptography:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来看看与密码学相关的基本术语：
- en: '**Cipher**: An algorithm that performs a particular cryptographic function.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码**：执行特定加密功能的算法。'
- en: '**Plain text**: The plain data, which can be a text file, a video, a bitmap,
    or a digitized voice. In this chapter, we will represent plain text as *P*.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**明文**：可以是文本文件、视频、位图或数字化语音的原始数据。在本章中，我们将表示明文为*P*。'
- en: '**Cipher text**: The scrambled text that is obtained after applying cryptography
    to the plain text. In this chapter, we will represent this as *C*.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密文**：应用加密后得到的混乱文本。在本章中，我们将其表示为*C*。'
- en: '**Cipher suite**: A set or suite of cryptographic software components. When
    two separate nodes want to exchange messages using cryptography, they first need
    to agree on a cipher suite. This is important in ensuring that they use exactly
    the same implementation of the cryptographic functions.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码套件**：一组或套件的加密软件组件。当两个独立节点想要使用加密交换消息时，它们首先需要就密码套件达成一致。这对于确保它们使用完全相同的加密函数实现非常重要。'
- en: '**Encryption**: The process of converting plain text, *P*, into cipher text,
    *C*, is called encryption.  Mathematically, it is represented by *encrypt(P) =
    C*.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密**：将明文*P*转换为密文*C*的过程称为加密。在数学上，它表示为*encrypt(P) = C*。'
- en: '**Decryption**: The process of converting cipher text back into plain text.
    Mathematically, it is represented by *decrypt(C) = P*.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解密**：将密文转换回明文的过程。在数学上，它表示为*decrypt(C) = P*。'
- en: '**Cryptanalysis**: The methods used to analyze the strength of the cryptographic
    algorithms. The analyst tries to recover the plain text without access to the
    secret.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码分析**：用于分析加密算法强度的方法。分析人员试图在没有秘密访问的情况下恢复明文。'
- en: '**Personally Identifiable Information** (**PII**): PII is the information that
    can be used to trace an individual''s identity when used alone or with other relevant
    data. Some examples include protected information, such as a social security number,
    date of birth, or mother''s maiden name.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**个人可识别信息**（**PII**）：PII是指可以单独使用或与其他相关数据一起用于追踪个人身份的信息。一些例子包括受保护的信息，如社会安全号码、出生日期或母亲的婚前姓氏。'
- en: Understanding the Security Requirements
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解安全需求
- en: 'It is important to first understand the exact security needs of a system. Understanding
    this will help us use the correct cryptographic technique and discover the potential
    loopholes in a system. In order to do this, we first need to better understand
    the needs of the system. In order to understand the security requirements, we
    perform the following three steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先了解系统的确切安全需求是很重要的。了解这一点将帮助我们使用正确的加密技术，并发现系统中的潜在漏洞。为了做到这一点，我们首先需要更好地了解系统的需求。为了了解安全需求，我们执行以下三个步骤：
- en: Identify the entities.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别实体。
- en: Establish the security goals.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确立安全目标。
- en: Understand the sensitivity of the data.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解数据的敏感性。
- en: Let's look at these steps one by one.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一看看这些步骤。
- en: Identifying the Entities
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别实体
- en: 'One way to identify the entities is to start by answering the following four
    questions, which will help us understand the needs of the system in the context
    of security:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 识别实体的一种方法是首先回答以下四个问题，这将帮助我们了解系统在安全环境中的需求：
- en: Which applications need to be protected?
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些应用程序需要受到保护？
- en: Who are we protecting the applications from?
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们要保护应用程序免受谁的攻击？
- en: Where should we protect them?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该在哪里保护它们？
- en: Why are we protecting them?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么要保护它们？
- en: Once we better understand these requirements, we can establish the security
    goals of our digital system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们更好地了解这些要求，我们就可以确立我们数字系统的安全目标。
- en: Establishing the Security Goals
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确立安全目标
- en: 'Cryptographic algorithms are typically used to meet one or more security goals:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用加密算法来满足一个或多个安全目标：
- en: '**Authentication**:Simply put, authentication is how we prove that a user is
    who they claim to be. Through the process of authentication, we ensure that a
    user''s identity is verified. The process of authentication starts by having the
    user present their identity. This is followed by providing information that is
    only known by the user and so can only be produced by them.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：简单来说，认证是我们如何证明用户是其所声称的人的方式。通过认证的过程，我们确保用户的身份得到验证。认证的过程始于用户提供其身份。接着是提供只有用户知道的信息，因此只能由他们产生。'
- en: '**Confidentiality**:  Data that needs to be protected is called **sensitive
    data**. Confidentiality is the concept of restricting sensitive data to authorized
    users only. To protect the confidentiality of sensitive data during its transit
    or in storage, you need to render the data so that it is unreadable except by
    authorized users. This is accomplished by using encryption algorithms, which we
    will discuss later on in this chapter.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机密性**：需要受到保护的数据称为**敏感数据**。机密性是将敏感数据限制为仅授权用户的概念。为了在传输或存储过程中保护敏感数据的机密性，您需要使数据变得不可读，除了授权用户之外。这是通过使用加密算法来实现的，我们将在本章后面讨论。'
- en: '**Integrity**: Integrity is the process of establishing that data has not been
    altered in any way during its transit or storage. For example, **TCP/IP** (**Transmission
    Control Protocol/Internet Protocol**) uses checksum or **Cyclic Redundancy Check**
    (**CRC**) algorithms to verify data integrity.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：完整性是指建立数据在传输或存储过程中没有被任何方式改变的过程。例如，**TCP/IP**（传输控制协议/互联网协议）使用校验和或**循环冗余校验**（**CRC**）算法来验证数据的完整性。'
- en: '**Non-repudiation**: Non-repudiation is the concept of a sender of information
    receiving confirmation that the data was received and the recipient receiving
    confirmation of the sender''s identity. This provides irrefutable evidence that
    a message was sent or received, which can be used later to prove the receipt of
    data and the points of failures in communication.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可否认性**：不可否认性是指信息发送方收到数据已被接收的确认，接收方收到发送方身份的确认的概念。这提供了无可辩驳的证据，证明了消息的发送或接收，这可以在以后用来证明数据的接收和通信中的故障点。'
- en: Understanding the Sensitivity of the Data
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解数据的敏感性
- en: 'It is important to understand the classified nature of data. We also need to
    think about how serious the consequences are if the data is compromised. The classification
    of the data helps us choose the correct cryptographic algorithm. There is more
    than one way to classify data, based on the sensitivity of the information it
    contains. Let''s look at the typical ways of classifying data:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数据的机密性很重要。我们还需要考虑数据泄露的后果有多严重。数据的分类有助于我们选择正确的加密算法。根据信息的敏感性，有多种分类数据的方式。让我们看看数据分类的典型方式：
- en: '**Public data or unclassified data**: Anything that is available for consumption
    for the public. For example, information found on a company''s website or a government''s
    info portal.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共数据或未分类数据**：任何对公众可用的数据。例如，在公司网站或政府信息门户上找到的信息。'
- en: '**Internal data or confidential data**:Although not for public consumption,
    exposing this data to the public may not have damaging consequences. For example,
    if an employee''s emails complaining about their manager are exposed, it may be
    embarrassing for the company but this may not have damaging consequences.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部数据或机密数据**：虽然不适合公开，但将这些数据暴露给公众可能不会造成破坏性后果。例如，如果员工的投诉经理的电子邮件被曝光，这可能会让公司尴尬，但可能不会造成破坏性后果。'
- en: '**Sensitive data or secret data**:  Data that is not supposed to be for public
    consumption and exposing it to the public has damaging consequences for an individual
    or an organization. For example, leaking the details of a future iPhone may harm
    Apple''s business goals and can give an advantage to rivals, such as Samsung.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**敏感数据或机密数据**：不应该公开的数据，如果暴露给公众，对个人或组织会造成破坏性后果。例如，泄露未来iPhone的细节可能会损害苹果的业务目标，并给三星等竞争对手带来优势。'
- en: '**Highly sensitive data**: Also called **top-secret data**. This is information
    that if disclosed, would be extremely damaging to the organization. This can include
    customer social security numbers, credit card numbers, or other very sensitive
    information. Top-secret data is protected through multiple layers of security
    and requires special permission to access.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度敏感数据**：也称为**绝密数据**。这是如果泄露将对组织造成极大损害的信息。这可能包括客户社会安全号码、信用卡号码或其他非常敏感的信息。绝密数据通过多层安全保护，并需要特别许可才能访问。'
- en: In general, more sophisticated security designs are much slower than simple
    algorithms. It is important to strike the right balance between the security and
    the performance of the system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，更复杂的安全设计比简单的算法要慢得多。在安全性和系统性能之间取得正确的平衡非常重要。
- en: Understanding the Basic Design of Ciphers
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解密码的基本设计
- en: Designing ciphers is about coming up with an algorithm that can scramble sensitive
    data so that a malicious process or an unauthorized user cannot access it. Although
    over time ciphers have become more and more sophisticated, the underlying principles
    that ciphers are based on remain unchanged.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 设计密码是为了想出一种算法，可以混淆敏感数据，使恶意进程或未经授权的用户无法访问它。尽管随着时间的推移，密码变得越来越复杂，但密码基于的基本原理保持不变。
- en: Let's start by looking at some relatively simple ciphers that will help us understand
    the underlying principles that are used in the design of cryptographic algorithms.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些相对简单的密码开始，这将帮助我们理解加密算法设计中使用的基本原理。
- en: Presenting Substitution Ciphers
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 呈现替换密码
- en: Substitution ciphers have been in use for hundreds of years in various forms.
    As the name indicates, substitution ciphers are based on a simple concept—substituting
    characters in plain text with other characters in a predetermined, organized way.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 替换密码在各种形式上已经使用了数百年。顾名思义，替换密码基于一个简单的概念——以预定的有序方式用其他字符替换明文中的字符。
- en: 'Let''s look at the exact steps involved in this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其中涉及的确切步骤：
- en: First, we map each character to a substitute character.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将每个字符映射到一个替代字符。
- en: Then, encode and convert the plaintext into cipher text by replacing each character
    in the plain text with another character in the ciphertext using substitution
    mapping.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过替换映射，将明文编码并转换为密文，用密文中的另一个字符替换明文中的每个字符。
- en: To decode, bring back the plaintext by using substitution mapping.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解码时，使用替换映射将明文还原。
- en: 'Let''s look at some examples:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子：
- en: '**Caesar cipher**:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**凯撒密码**：'
- en: 'In Caesar ciphers, the substitution mapping is created by replacing each character
    with the third character to the right of it. This mapping is described in the
    following diagram:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在凯撒密码中，替换映射是通过用右边的第三个字符替换每个字符来创建的。这个映射在下图中描述：
- en: '![](assets/91bc4fec-861e-4d78-9050-7f30a9758aa1.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/91bc4fec-861e-4d78-9050-7f30a9758aa1.png)'
- en: 'Let''s see how we can implement a Caesar cipher using Python:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Python实现凯撒密码：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can see that we applied a Caesar cipher to the plaintext, `CALM`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们对明文`CALM`应用了凯撒密码。
- en: 'Let''s print the cipher text after encrypting with the Caesar cipher:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用凯撒密码加密后打印密文：
- en: '![](assets/8edd428d-94b2-436e-ac6f-a1878e094b43.png)Caesar ciphers are said
    to have been used by Julius Caesar to communicate with his advisers.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/8edd428d-94b2-436e-ac6f-a1878e094b43.png)据说凯撒密码曾被朱利叶斯·凯撒用来与他的顾问交流。'
- en: '**Rotation 13** (**ROT13**):'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转13**（**ROT13**）：'
- en: 'ROT13 is another of the substitution-based encryptions. In ROT13, the substitution
    mapping is created by replacing each character with the 13^(th) character to the
    right of it. The following diagram illustrates this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ROT13是另一种基于替换的加密。在ROT13中，替换映射是通过用右边的第13个字符替换每个字符来创建的。以下图表说明了这一点：
- en: '![](assets/a44fe40c-b91e-469b-bfcb-efef009e8856.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a44fe40c-b91e-469b-bfcb-efef009e8856.png)'
- en: 'This means that if `ROT13()` is the function that implements ROT13, then the
    following applies:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果`ROT13()`是实现ROT13的函数，那么以下内容适用：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s print the encoded value of `C`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打印`C`的编码值：
- en: '![](assets/49619d35-4c7c-45be-a774-966b96f9a104.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/49619d35-4c7c-45be-a774-966b96f9a104.png)'
- en: '**Cryptanalysis of substitution ciphers** :'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**替换密码的密码分析**：'
- en: Substitution ciphers are simple to implement and understand. Unfortunately,
    they are also easy to crack. A simple cryptanalysis of substitution ciphers shows
    that if we use the English language alphabet, then all we need to determine to
    crack the cipher is how much are we rotating by. We can try each letter of the
    English alphabet one by one until we are able to decrypt the text. This means
    that it will take around 25 attempts to reconstruct the plain text.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 替换密码很容易实现和理解。不幸的是，它们也很容易破解。替换密码的简单密码分析表明，如果我们使用英语字母表，那么我们需要确定的是破解密码的旋转量。我们可以逐个尝试英语字母表的每个字母，直到我们能够解密文本。这意味着需要大约25次尝试才能重构明文。
- en: Now, let's look at another type of simple cipher—transposition ciphers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看另一种简单密码—置换密码。
- en: Understanding Transposition Ciphers
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解置换密码
- en: 'In transposition ciphers, the characters of the plain text are transposed.
    Let''s look at the steps involved for this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在置换密码中，明文的字符被置换。让我们看一下其中涉及的步骤：
- en: Create the matrix and choose the size of the transposition matrix. It should
    be large enough to fit the plain text string.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建矩阵并选择置换矩阵的大小。它应该足够大，以适应明文字符串。
- en: Fill in the matrix by writing in all of the characters of the string horizontally.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过横向写入字符串的所有字符来填充矩阵。
- en: Read all of the characters of the string vertically in the matrix.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在矩阵中垂直读取字符串的所有字符。
- en: Let's look at an example.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。
- en: Let's take the `Ottawa Rocks` plain text (*P*).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`Ottawa Rocks`明文(*P*)为例。
- en: 'First, let''s encode *P*. For that, we will use a 3 x 4  matrix and write in
    the plaintext horizontally:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们对*P*进行编码。为此，我们将使用一个3 x 4的矩阵，横向写入明文：
- en: '| O | t | t | a |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| O | t | t | a |'
- en: '| w | a | R | o |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| w | a | R | o |'
- en: '| c | k | s |  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| c | k | s |  |'
- en: The `read` process will read the string vertically, which will generate the
    cipher text—`OwctaktRsao`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`过程将垂直读取字符串，这将生成密码文本—`OwctaktRsao`。'
- en: The Germans used a cipher named ADFGVX in the First World War, which used both
    the transposition and substitution ciphers. Years later, it was cracked by George
    Painvin.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 德国人在第一次世界大战中使用了一种名为ADFGVX的密码，它同时使用了置换和替换密码。多年后，它被George Painvin破解。
- en: So, these are some of the types of ciphers. Now, let's look at some of the cryptographic
    techniques that are currently used.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些是一些密码类型。现在，让我们看一些当前使用的密码技术。
- en: Understanding the Types of Cryptographic Techniques
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解密码技术的类型
- en: Different types of cryptographic techniques use different types of algorithms
    and are used under different sets of circumstances.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的密码技术使用不同类型的算法，并在不同的情况下使用。
- en: 'Broadly, cryptographic techniques can be divided into the following three types:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 广义上，密码技术可以分为以下三种类型：
- en: Hashing
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 散列
- en: Symmetric
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对称
- en: Asymmetric
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非对称
- en: Let's look at them one by one.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个来看。
- en: Using the Cryptographic Hash Function
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用密码哈希函数
- en: The cryptographic hash function is a mathematical algorithm that can be used
    to create unique fingerprint of a message. It creates a fixed-sized output, called
    a **hash**, from plain text.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 密码哈希函数是一种数学算法，可以用来创建消息的唯一指纹。它从明文中创建一个称为**哈希**的固定大小的输出。
- en: 'Mathematically, this looks as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上看，这看起来是这样的：
- en: '*C[1]  = hashFunction(P[1])*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*C[1]  = hashFunction(P[1])*'
- en: 'This is explained as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解释如下的：
- en: '*P[1]* is the plain text representing the input data.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*P[1]* 是表示输入数据的明文。'
- en: '*C[1]*  is a fixed-length hash that is generated by the cryptographic hash
    function.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C[1]* 是由密码哈希函数生成的固定长度哈希。'
- en: 'This is shown in the following diagram. The variable-length data is converted
    into a fixed-length hash through a one-way hash function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这在下图中显示。可变长度数据通过单向哈希函数转换为固定长度哈希：
- en: '![](assets/36a659e2-2da6-459b-969d-b8400697eb4c.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/36a659e2-2da6-459b-969d-b8400697eb4c.png)'
- en: 'The hash function has the following five characteristics:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数具有以下五个特征：
- en: It is deterministic. The same plain text generates the same hash.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是确定性的。相同的明文生成相同的哈希。
- en: Unique input strings should generate unique output hash values.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一的输入字符串应该生成唯一的输出哈希值。
- en: Regardless of the input message, it has a fixed length.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论输入消息如何，它都具有固定长度。
- en: Even small changes in the plain text generate a new hash.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明文中的微小变化会生成新的哈希。
- en: It is a one-way function, which means that plain text, *P*[*1*,]  cannot be
    generated from the cipher text, *C*[*1*.]
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个单向函数，这意味着无法从密码文本*C[1]*生成明文*P[1]*。
- en: If we have a situation where each unique message does not have a unique hash,
    we call it a **collision**. That is, if we have two texts, *P[1]*  and *P[2]*  ,
    in the case of collision, it means *hashFunction(P[1]) = hashFunction(P[2])*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到每个唯一消息没有唯一哈希的情况，我们称之为**碰撞**。也就是说，如果我们有两个文本*P[1]*和*P[2]*，在碰撞的情况下，意味着*hashFunction(P[1])
    = hashFunction(P[2])*。
- en: Regardless of the hashing algorithm used, collisions are rare. Otherwise, hashing
    wouldn't be useful. However, for some applications, collisions cannot be tolerated.
    In those cases, we need to use a hashing algorithm that is more complex but much
    less likely to generate hash values that collide.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用的哈希算法如何，碰撞都是罕见的。否则，哈希将毫无用处。然而，对于一些应用，不能容忍碰撞。在这些情况下，我们需要使用一个更复杂但生成碰撞哈希值的可能性更小的哈希算法。
- en: Implementing cryptographic hash functions
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现密码哈希函数
- en: Cryptographic hash functions can be implemented by using various algorithms.
    Let's take a deeper look at two of them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 密码哈希函数可以通过使用各种算法来实现。让我们深入了解其中的两种。
- en: Understanding MD5-tolerated
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解MD5容忍
- en: MD5 was developed by Poul-Henning Kamp in 1994 to replace MD4\. It generates
    a 128-bit hash. MD5 is a relatively simple algorithm that is vulnerable to collision.
    In applications where a collision cannot be tolerated, MD5 should not be used.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: MD5是由Poul-Henning Kamp于1994年开发的，用来替代MD4。它生成128位哈希。MD5是一个相对简单的算法，容易发生碰撞。在不能容忍碰撞的应用中，不应使用MD5。
- en: 'Let''s look at an example. In order to generate an MD5 hash in Python, we will
    use the `passlib` library, which one of the most popular open source libraries,
    implementing over 30 password-hashing algorithms. If it is not already installed
    on your device, install it by using the following code in a Jupyter notebook:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。为了在Python中生成MD5哈希，我们将使用`passlib`库，这是一个最流行的开源库之一，实现了30多种密码哈希算法。如果它还没有安装在您的设备上，请在Jupyter笔记本中使用以下代码安装它：
- en: '[PRE2]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In Python, we can generate the MD5 hash as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以按照以下方式生成MD5哈希：
- en: '![](assets/32a01072-7c27-4d65-a565-26af8195a8da.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/32a01072-7c27-4d65-a565-26af8195a8da.png)'
- en: Note that MD5 generates a hash of 128 bits.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，MD5生成128位的哈希。
- en: 'As mentioned, we can use this generated hash as a fingerprint of the original
    text, which was `myPassword`. Let''s see how we can do this in Python:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以将生成的哈希用作原始文本的指纹，原始文本是`myPassword`。让我们看看如何在Python中实现这一点：
- en: '![](assets/dd3a883a-f1b2-4fd5-bf4a-35a505809106.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dd3a883a-f1b2-4fd5-bf4a-35a505809106.png)'
- en: Note that the generated hash for the `myPassword` string  matched the original
    hash, which generated a `True` value. However, it returned `False` as soon as
    the plain text was changed to `myPassword2`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对`myPassword`字符串生成的哈希与原始哈希匹配，生成了一个`True`值。但是，一旦明文更改为`myPassword2`，它就返回了`False`。
- en: Now, let's look at another hashing algorithm—**Secure Hash Algorithm** (**SHA**).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看另一个哈希算法——**安全哈希算法**（**SHA**）。
- en: Understanding SHA
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解SHA
- en: 'SHA was developed by the **National Institute of Standards and Technology**
    (**NIST**). Let''s see how we can use Python to create a hash using the SHA algorithm:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: SHA是由**国家标准与技术研究所**（**NIST**）开发的。让我们看看如何使用Python来创建SHA算法的哈希：
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note the use of a parameter called `salt`. Salting is the procedure of adding
    random characters before hashing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用一个名为`salt`的参数。加盐是在哈希之前添加随机字符的过程。
- en: 'Running this code will give us the following result:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码将给我们带来以下结果：
- en: '![](assets/0ac664a2-c588-48d5-a4d9-934b566d653f.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0ac664a2-c588-48d5-a4d9-934b566d653f.png)'
- en: Note that when we use the SHA algorithm, the hash generated is of 512 bytes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们使用SHA算法时，生成的哈希是512字节。
- en: An Application of the Cryptographic Hash Function
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密哈希函数的应用
- en: Hash functions are used to check the integrity of a file after making a copy
    of it. To achieve this, when a file is copied from a source to a destination (for
    example, when downloaded from a web server), a corresponding hash is also copied
    with it. This original hash, *h[original]*, acts as a fingerprint of the original
    file. After copying the file, we generate the hash again from the copied version
    of the file—that is, *h[copied]*. If *h*[*original*] = *h[copied]*—that is, the
    generated hash matches the original hash—this verifies that the file has not changed
    and none of the data was lost during the download process. We can use any cryptographic
    hash function, such as MD5 or SHA, to generate a hash for this purpose.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数用于在复制文件后检查文件的完整性。为了实现这一点，当文件从源复制到目的地（例如，从Web服务器下载时），相应的哈希也会被复制。这个原始哈希，*h[original]*，充当了原始文件的指纹。复制文件后，我们再次从复制的文件版本生成哈希，即*h[copied]*。如果*h*[*original*]
    = *h[copied]*—也就是说，生成的哈希与原始哈希匹配—这验证了文件没有改变，并且在下载过程中没有丢失任何数据。我们可以使用任何加密哈希函数，比如MD5或SHA，来为此目的生成哈希。
- en: Now, let's look at symmetric encryption.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看对称加密。
- en: Using Symmetric Encryption
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对称加密
- en: 'In cryptography, a key is a combination of numbers that is used to encode plain
    text using an algorithm of our choice. In symmetric encryption, we use the same
    key for encryption and decryption. If the key used for symmetric encryption is
    *K*, then for symmetric encryption, the following equation holds:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码学中，密钥是一组数字，用于使用我们选择的算法对明文进行编码。在对称加密中，我们使用相同的密钥进行加密和解密。如果用于对称加密的密钥是*K*，那么对称加密的等式如下：
- en: '*E[K](P) = C*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*E[K](P) = C*'
- en: Here, *P* is the plain text and *C* is the cipher text.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*P*是明文，*C*是密文。
- en: 'For decryption, we use the same key, *K*, to convert it back to *P*:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于解密，我们使用相同的密钥*K*将其转换回*P*：
- en: '*D[K](C) = P*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*D[K](C) = P*'
- en: 'This process is shown in the following diagram:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程在下面的图表中显示：
- en: '![](assets/52dabfcd-01bc-4ef2-80ce-c70d455676c8.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/52dabfcd-01bc-4ef2-80ce-c70d455676c8.png)'
- en: Now, let's look at how we can use symmetric encryption with Python.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在Python中使用对称加密。
- en: Coding Symmetric Encryption
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写对称加密
- en: 'We will use Python''s `cryptography` package, in this section, to demonstrate
    symmetric encryption. It is a comprehensive package that implements many cryptographic
    algorithms, such as symmetric ciphers and different message digests. When using
    it for the first time, we first need to install it using the `pip` command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Python的`cryptography`包来演示对称加密。它是一个全面的包，实现了许多加密算法，比如对称密码和不同的消息摘要。第一次使用时，我们需要使用`pip`命令来安装它：
- en: '[PRE4]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once installed, we can now use the package to implement symmetric encryption,
    as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们现在可以使用该包来实现对称加密，如下所示：
- en: 'First, let''s import the packages we need:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们导入我们需要的包：
- en: '[PRE5]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s generate the key:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们生成密钥：
- en: '![](assets/90609769-1a16-48cf-96b8-6fefa3799ab5.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/90609769-1a16-48cf-96b8-6fefa3799ab5.png)'
- en: 'Now, let''s open the key:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们打开密钥：
- en: '[PRE6]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using the key, let''s now try to encrypt the message:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用密钥，现在让我们尝试加密消息：
- en: '[PRE7]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s decrypt the message using the same key:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用相同的密钥解密消息：
- en: '[PRE8]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s decrypt the message and assign it to a variable named `decrypt`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们解密消息并将其赋给一个名为`decrypt`的变量：
- en: '[PRE9]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s now print the `decrypt` variable to verify whether we are able to get
    the same message:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们打印`decrypt`变量，以验证我们是否能够得到相同的消息：
- en: '![](assets/556b14e4-1ddb-4956-906a-06c41f96996e.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/556b14e4-1ddb-4956-906a-06c41f96996e.png)'
- en: Let's look at some of the advantages of symmetric encryption.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些对称加密的优势。
- en: The Advantages of Symmetric Encryption
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对称加密的优势
- en: Although the performance of the symmetric encryption is dependent on the exact
    algorithm that is used, in general, it is a lot faster than asymmetric encryption.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对称加密的性能取决于所使用的确切算法，但一般来说，它比非对称加密快得多。
- en: The Problems with Symmetric Encryption
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对称加密的问题
- en: 'When two users or processes plan to use symmetric encryption to communicate,
    they need to exchange keys using a secure channel. This gives rise to the following
    two problems:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个用户或进程计划使用对称加密进行通信时，它们需要使用安全通道交换密钥。这引发了以下两个问题：
- en: '**Key protection**: How to protect the symmetric encryption key.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥保护**：如何保护对称加密密钥。'
- en: '**Key distribution**:  How to share the symmetric encryption key from the source
    to the destination.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥分发**：如何将对称加密密钥从源共享到目的地。'
- en: Now, let's look at asymmetric encryption.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下非对称加密。
- en: Asymmetric Encryption
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非对称加密
- en: In the 1970s, asymmetric encryption was devised to address some of the weaknesses
    of symmetric encryption that we discussed in the previous section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪70年代，非对称加密被设计出来以解决我们在前一节中讨论的对称加密的一些弱点。
- en: 'The first step in asymmetric encryption is to generate two different keys that
    look totally different but are algorithmically related. One of them is chosen
    as the private key, *K[pr]*, and the other one is chosen as the public key, *K[pu]*.
    Mathematically, we can represent this as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密的第一步是生成两个看起来完全不同但在算法上相关的不同密钥。其中一个被选择为私钥，*K[pr]*，另一个被选择为公钥，*K[pu]*。在数学上，我们可以表示如下：
- en: '*E[Kpr](P) = C*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*E[Kpr](P) = C*'
- en: Here, *P* is the plain text and *C* is the cipher text.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*P*是明文，*C*是密文。
- en: 'We can decrypt it as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式解密：
- en: '*D[Kpu](C) = P*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*D[Kpu](C) = P*'
- en: Public keys are supposed to be freely distributed and private keys are kept
    secret by the owner of the key pair.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥应该被自由分发，私钥由密钥对的所有者保密。
- en: The fundamental principle is that if you encrypt with one of the keys, the only
    way to decrypt it is by using the other key. For example, if we encrypt the data
    using the public key, we will need to decrypt it using the other key—that is,
    the private key. Now, let's look at one of the fundamental protocols of asymmetric
    encryption—the **Secure Sockets Layer** (**SSL**)/**Transport Layer Security**
    (**TLS**) handshake—which is responsible for establishing a connection between
    two nodes using asymmetric encryption.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 基本原则是，如果使用其中一个密钥进行加密，解密的唯一方法是使用另一个密钥。例如，如果我们使用公钥加密数据，我们将需要使用另一个密钥来解密它，即私钥。现在，让我们看一下非对称加密的一个基本协议——**安全套接字层**（**SSL**）/**传输层安全性**（**TLS**）握手，它负责使用非对称加密在两个节点之间建立连接。
- en: The SSL/TLS Handshaking Algorithm
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSL/TLS握手算法
- en: 'SSLwas originally developed to add security to HTTP. Over time, SSL was replaced
    with a more efficient and more secure protocol, called TLS. TLS handshakes are
    the basis of how HTTP creates a secure communication session. A TLS handshake
    occurs between the two participating entities—the **client** and the **server**.
    This process is shown in the following diagram:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: SSL最初是为HTTP添加安全性而开发的。随着时间的推移，SSL被更高效、更安全的协议TLS所取代。TLS握手是HTTP创建安全通信会话的基础。TLS握手发生在两个参与实体——**客户端**和**服务器**之间。此过程如下图所示：
- en: '![](assets/787e64d9-a0ed-47d9-9c9b-c7409c0926ea.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/787e64d9-a0ed-47d9-9c9b-c7409c0926ea.png)'
- en: 'A TLS handshake establishes a secure connection between the participating nodes.
    The following are the steps that are involved in this process:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: TLS握手在参与节点之间建立了安全连接。以下是涉及此过程的步骤：
- en: 'The client sends a `client hello` message to the server. The message also contains
    the following:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向服务器发送一个“客户端hello”消息。消息还包含以下内容：
- en: The version of TLS that is used
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所使用的TLS版本
- en: The list of cipher suites supported by the client
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端支持的密码套件列表
- en: A compression algorithm
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个压缩算法
- en: A random byte string, identified by `byte_client`
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个由`byte_client`标识的随机字节字符串
- en: 'The server sends a `server hello` message back to the client. The message also
    contains the following:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器向客户端发送一个“服务器hello”消息。消息还包含以下内容：
- en: A cipher suite selected by the server from the list provided by the client
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器从客户端提供的列表中选择的密码套件
- en: A session ID
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个会话ID
- en: A random byte string, identified by `byte_server`
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个由`byte_server`标识的随机字节字符串
- en: A server digital certificate, identified by `cert_server`, containing the public
    key of the server
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含服务器公钥的服务器数字证书，由`cert_server`标识
- en: 'If the server requires a digital certificate for client authentication or a
    client certificate request, the client server request also includes the following:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果服务器需要客户端身份验证的数字证书或客户端证书请求，客户端服务器请求还包括以下内容：
- en: The distinguished names of the acceptable CAs
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可接受的CA的可区分名称
- en: The types of certificates supported
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的证书类型
- en: The client verifies `cert_server`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端验证`cert_server`。
- en: The client generates a random byte string, identified by `byte_client2`, and
    encrypts it with the public key of the server provided through `cert_server`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端生成一个随机的字节字符串，由`byte_client2`标识，并使用服务器通过`cert_server`提供的公钥进行加密。
- en: The client generates a random byte string and identifies encrypts with its own
    private key.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端生成一个随机的字节字符串，并用自己的私钥进行加密。
- en: The server verifies the client certificate.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器验证客户端证书。
- en: The client sends a `finished` message to the server, which is encrypted with
    a secret key.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向服务器发送一个使用秘密密钥加密的“完成”消息。
- en: To acknowledge this from the server side, the server sends a `finished` message
    to the client, which is encrypted with a secret key.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了从服务器端确认这一点，服务器向客户端发送一个使用秘密密钥加密的“完成”消息。
- en: 'The server and client have now established a secure channel. They can now exchange
    messages that are symmetrically encrypted with the shared secret key. The entire
    methodology is shown as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器和客户端现在建立了一个安全通道。他们现在可以交换使用共享秘密密钥对称加密的消息。整个方法如下所示：
- en: '![](assets/6a90b582-3e7c-4378-9f8b-63fec0e0db16.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6a90b582-3e7c-4378-9f8b-63fec0e0db16.png)'
- en: Now, let's discuss how we can use asymmetric encryption to create **Public Key
    Infrastructure** (**PKI**), which is created to meet one or more security goals
    for an organization.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论如何使用非对称加密来创建**公钥基础设施**（**PKI**），PKI是为了满足组织的一个或多个安全目标而创建的。
- en: Public Key Infrastructure
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公钥基础设施
- en: Asymmetric encryption is used to implement PKI. PKI is one of the most popular
    and reliable ways to manage encryption keys for an organization. All the participants
    trust a central trusting authority called a CA.CAs verify the identity of individuals
    and organizations and then issue them digital certificates (a digital certificate
    contains a copy of a person or organization's public key and its identity), verifying
    that the public key associated with that individual or organization actually belongs
    to that individual or organization.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密用于实现PKI。PKI是管理组织加密密钥的最流行和可靠的方式之一。所有参与者都信任一个名为CA的中央信任机构。CA验证个人和组织的身份，然后为他们颁发数字证书（数字证书包含个人或组织的公钥副本和其身份），验证与该个人或组织相关联的公钥实际上属于该个人或组织。
- en: The way it works is that the CA asks a user to prove their identity, with different
    standards followed for individuals and organizations. This could involve simply
    verifying ownership of a domain name, or it could involve a more rigorous process
    that involves physical proof of identity, depending on the type of digital certificate
    that a user is trying to obtain. If the CA is satisfied that the user is indeed
    who they claim to be, the user then provides the CA with their public encryption
    key over a secure channel. The CA uses this information to create a digital certificate
    that contains information about the user's identity and their public key. This
    certificate is digitally signed by the CA. The user can then show their certificate
    to anyone who wants to verify their identity, without having to send it through
    a secure channel, as the certificate doesn't contain any sensitive information
    itself. The person receiving the certificate does not have to verify the user's
    identity directly. That person can simply verify that the certificate is valid
    by verifying the CA's digital signature, which validates that the public key contained
    in the certificate does, in fact, belong to the individual or organization named
    on the certificate.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式是CA要求用户证明其身份，对个人和组织遵循不同的标准。这可能涉及简单地验证域名的所有权，也可能涉及更严格的过程，包括身份的物理证明，这取决于用户试图获得的数字证书的类型。如果CA确信用户确实是他们声称的人，用户随后通过安全通道向CA提供他们的公共加密密钥。CA使用这些信息创建包含用户身份和他们的公钥信息的数字证书。该证书由CA数字签名。用户随后可以向任何想要验证其身份的人展示其证书，而无需通过安全通道发送它，因为证书本身不包含任何敏感信息。接收证书的人不必直接验证用户的身份。该人只需验证证书是否有效，验证CA的数字签名，以验证证书中包含的公钥实际上属于证书上命名的个人或组织。
- en: The private key of the CA of an organization is the weakest link in the PKI
    chain of trust. If an impersonator gets hold of Microsoft's private key, for example,
    they can install malicious software onto millions of computers around the world
    by impersonating a Windows update.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 组织的CA的私钥是PKI信任链中最薄弱的环节。例如，如果冒名顶替者获取了微软的私钥，他们可以通过冒充Windows更新在全球数百万台计算机上安装恶意软件。
- en: Example – Security Concerns When Deploying a Machine Learning Model
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-部署机器学习模型时的安全问题
- en: In [Chapter 6](ce14ecc1-8ad5-406e-88d0-7f3acb3e4569.xhtml), *Unsupervised Machine
    Learning Algorithms*, we looked at the **CRISP-DM**  (**Cross-Industry Standard
    Process for Data Mining**) life cycle, which specifies the different phases of
    training and deploying a machine learning model. Once a model is trained and evaluated,
    the final phase is deployment. If it is a critical machine learning model, then
    we want to make sure that all of its security goals are met.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ce14ecc1-8ad5-406e-88d0-7f3acb3e4569.xhtml)中，*无监督机器学习算法*，我们看了**CRISP-DM**（**跨行业标准数据挖掘过程**）生命周期，该生命周期指定了训练和部署机器学习模型的不同阶段。一旦模型被训练和评估，最后阶段是部署。如果这是一个关键的机器学习模型，那么我们希望确保它的所有安全目标都得到满足。
- en: 'Let''s analyze the common challenges faced in deploying a model such as this
    and how we can address those challenges using the concepts discussed in this chapter.
    We will discuss strategies to protect our trained model against the following
    three challenges:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析部署这样一个模型时面临的常见挑战，以及如何使用本章讨论的概念来解决这些挑战。我们将讨论保护我们训练好的模型免受以下三个挑战的策略：
- en: '**Man-in-the-Middle** (**MITM**) attacks'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间人**（**MITM**）攻击'
- en: Masquerading
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒充
- en: Data tempering
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据篡改
- en: Let's look at them one by one.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个来看。
- en: MITM attacks
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间人攻击
- en: One of the possible attacks that we would want to protect our model against
    is MITM attacks. A MITM attack occurs when an intruder tries to eavesdrop on a
    supposedly private communication to deploy a trained machine learning model.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望保护我们的模型免受的可能攻击之一是中间人攻击。中间人攻击发生在入侵者试图窃听假定为私人通信的情况下，部署训练好的机器学习模型。
- en: Let's try to understand MITM attacks sequentially using an example scenario.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用一个示例场景来顺序理解中间人攻击。
- en: 'Let''s assume that Bob and Alice want to exchange messages using PKI:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 假设鲍勃和爱丽丝想要使用PKI交换消息：
- en: Bob is using {Pr[Bob], Pu[Bob]} and Alice is using {Pr[Alice], Pu[Alice]}. Bob
    has created a message, *M[Bob]*, and Alice has created a message, *M[Alice]*.
    They want to exchange these messages with each other in a secure way.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鲍勃使用{Pr[Bob]，Pu[Bob]}，爱丽丝使用{Pr[Alice]，Pu[Alice]}。鲍勃创建了消息*M[Bob]*，爱丽丝创建了消息*M[Alice]*。他们希望以安全的方式彼此交换这些消息。
- en: Initially, they need to exchange their public keys to establish a secure connection
    with each other. This means that Bob uses *Pu[Alice]*  to encrypt *M[Bob]* before
    sending the message to Alice.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最初，他们需要交换他们的公钥以建立彼此之间的安全连接。 这意味着鲍勃在发送消息给艾丽斯之前使用*Pu[Alice]*加密*M[Bob]*。
- en: Let's assume that we have an eavesdropper, *X*, who is using {Pr[X], Pu[X]}.
    The attacker is able to intercept the public key exchanges between Bob and Alice
    and replace them with its own public certificate.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个窃听者*X*，他正在使用{Pr[X]，Pu[X]}。 攻击者能够拦截鲍勃和艾丽斯之间的公钥交换，并用自己的公共证书替换它们。
- en: Bob sends *M[Bob]*  to Alice, encrypting it with *Pu[X]*  instead of *Pu[Alice]*,
    wrongfully thinking that this is Alice's public certificate. Eavesdropper *X*
    intercepts the communication. It intercepts the *M[Bob]*  message and decrypts
    it using *Pr[Bob]*.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鲍勃将*M[Bob]*发送给艾丽斯，使用*Pu[X]*而不是*Pu[Alice]*进行加密，错误地认为这是艾丽斯的公共证书。 窃听者*X*拦截了通信。
    它拦截了*M[Bob]*消息并使用*Pr[Bob]*解密。
- en: 'This MITM attack is shown in the following diagram:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这种中间人攻击显示在以下图表中：
- en: '![](assets/1500b5c1-9b2b-4c0c-8c7c-c1ca674612eb.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1500b5c1-9b2b-4c0c-8c7c-c1ca674612eb.png)'
- en: Now, let's look at how we can prevent MITM attacks.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何防止中间人攻击。
- en: How to prevent MITM attacks
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何防止中间人攻击
- en: Let's explore how we can prevent MITM attacks by introducing a CA to the organization.
    Let's say the name of this CA is myTrustCA. The digital certificate has its public
    key, named *Pu[myTrustCA]*, embedded in it.myTrustCA is responsible for signing
    the certificates for all of the people in the organization, including Alice and
    Bob. This means that both Bob and Alice have their certificates signed by myTrustCA.
    When signing their certificates, myTrustCA verifies that they are indeed who they
    claim to be.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨如何通过引入CA来防止中间人攻击到组织中。 假设这个CA的名字是myTrustCA。 数字证书中嵌入了它的公钥，名为*Pu[myTrustCA]*。
    myTrustCA负责为组织中的所有人，包括艾丽斯和鲍勃签署证书。 这意味着鲍勃和艾丽斯的证书都由myTrustCA签署。 在签署他们的证书时，myTrustCA验证他们确实是他们声称的人。
- en: 'Now, with this new arrangement in place, let''s revisit the sequential interaction
    between Bob and Alice:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这个新的安排，让我们重新审视鲍勃和艾丽斯之间的顺序交互：
- en: Bob is using {Pr[Bob], Pu[Bob]} and Alice is using {Pr[Alice], Pu[Alice]}. Both
    of their public keys are embedded into their digital certificates, signed by myTrustCA.
    Bob has created a message, *M[Bob]*, and Alice has created a message, *M[Alice]*.
    They want to exchange these messages with each other in a secure way.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鲍勃正在使用{Pr[Bob]，Pu[Bob]}，艾丽斯正在使用{Pr[Alice]，Pu[Alice]}。 他们的公钥都嵌入到他们的数字证书中，由myTrustCA签名。
    鲍勃创建了一条消息*M[Bob]*，艾丽斯创建了一条消息*M[Alice]*。 他们希望以安全的方式互相交换这些消息。
- en: They exchange their digital certificates, which contain their public keys. They
    will only accept the public keys if they are embedded in the certificates signed
    by the CA they trust. They need to exchange their public keys to establish a secure
    connection with each other. This means that Bob will use *Pu**[Alice]*  to encrypt
    *M**[Bob]* before sending the message to Alice.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 他们交换他们的数字证书，其中包含他们的公钥。 只有在证书中嵌入的公钥由他们信任的CA签署时，他们才会接受这些公钥。 他们需要交换他们的公钥以建立彼此之间的安全连接。
    这意味着鲍勃将使用*Pu**[Alice]*来加密*M**[Bob]*，然后将消息发送给艾丽斯。
- en: Let's assume that we have an eavesdropper, *X*, who is using {Pr[X], Pu[X]}.
    The attacker is able to intercept the public key exchanges between Bob and Alice
    and replace them with its own public certificate,  *Pu[X]*.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个窃听者*X*，他正在使用{Pr[X]，Pu[X]}。 攻击者能够拦截鲍勃和艾丽斯之间的公钥交换，并用自己的公共证书*Pu[X]*替换它们。
- en: Bob rejects *X*'s attempt, as the bad guy's digital certificate is not signed
    by the CA that Bob trusts. The secure handshake is aborted, the attempted attack
    is logged with a timestamp and all details, and a security exception is raised.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鲍勃拒绝*X*的尝试，因为坏人的数字证书没有被鲍勃信任的CA签名。 安全握手被中止，尝试的攻击被记录下来，并且引发了安全异常。
- en: When deploying a trained machine learning model, instead of Alice, there is
    a deployment server. Bob only deploys the model after establishing a secure channel,
    using the previously mentioned steps.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署训练好的机器学习模型时，不是艾丽斯，而是一个部署服务器。 鲍勃只有在建立安全通道后才能部署模型，使用先前提到的步骤。
- en: Let us see how we can implement this in Python.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Python中实现这一点。
- en: First let us import the packages that are needed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们导入所需的包。
- en: '[PRE10]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now let us create a class that can verify the certirficate.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个可以验证证书的类。
- en: '[PRE11]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let us look into other vulnerabilities that our deployed model can face.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们部署的模型可能面临的其他漏洞。
- en: Avoiding Masquerading
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免伪装
- en: Attacker *X* pretends to be an authorized user, Bob, and gains access to sensitive
    data, which is the trained model, in this case. We need to protect the model against
    any unauthorized changes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者*X*假装成授权用户鲍勃，并获得对敏感数据的访问权限，这在这种情况下是训练模型。 我们需要保护模型免受任何未经授权的更改。
- en: One way of protecting our trained model against masquerading is by encrypting
    the model with an authorized user's private key. Once encrypted, anyone can read
    and utilize the model by decrypting it through the public key of the authorized
    user, which is found in their digital certificate. No one can make any unauthorized
    changes to the model.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 保护我们训练模型免受伪装的一种方法是使用授权用户的私钥对模型进行加密。 一旦加密，任何人都可以通过解密授权用户的公钥来读取和利用模型，这在他们的数字证书中找到。
    没有人可以对模型进行任何未经授权的更改。
- en: Data and Model Encrpytion
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据和模型加密
- en: Once the model is deployed, the real-time unlabeled data that is provided as
    input to the model can also be tampered with. The trained model is used for inference
    and provides a label to this data. To protect data against tampering, we need
    to protect the data at rest and in communication. To protect the data at rest,
    symmetric encryption can be used to encode it. To transfer the data, SSL/TLS-based
    secure channels can be established to provide a secure tunnel. This secure tunnel
    can be used to transfer the symmetric key and the data can be decrypted on the
    server before it is provided to the trained model.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模型部署，提供给模型作为输入的实时未标记数据也可能被篡改。训练好的模型用于推断并为这些数据提供标签。为了防止数据被篡改，我们需要保护静态数据和通信中的数据。为了保护静态数据，可以使用对称加密进行编码。可以建立基于SSL/TLS的安全通道来传输数据，以提供安全的隧道。这个安全隧道可以用来传输对称密钥，并且数据可以在提供给训练好的模型之前在服务器上解密。
- en: This is one of the more efficient and foolproof ways to protect data against
    tampering.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是保护数据免受篡改的更有效和可靠的方法之一。
- en: Symmetric encryption can also be used to encrypt a model when it has been trained,
    before deploying it to a server. This will prevent any unauthorized access to
    the model before it is deployed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在将模型部署到服务器之前，也可以使用对称加密对模型进行加密。这将防止在部署之前未经授权访问模型。
- en: 'Let''s see how we can encrypt a trained model at the source, using symmetric
    encryption with the help of the following steps, and then decrypt it at the destination
    before using it:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用以下步骤在源处使用对称加密加密训练好的模型，然后在目的地解密它，然后再使用它：
- en: 'Let''s first train a simple model using the Iris dataset:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先使用鸢尾花数据集训练一个简单的模型：
- en: '[PRE12]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s define the names of the files that will store the model:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义将存储模型的文件的名称：
- en: '[PRE13]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that  `filename_source`  is the file that will store the trained unencrypted  model
    at the source.  `filename_destination`  is the file that will store the trained
    unencrypted model at the destination, and  `filename_sec`  is the encrypted trained
    model.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`filename_source` 是将在源处存储训练好的未加密模型的文件。`filename_destination` 是将在目的地存储训练好的未加密模型的文件，`filename_sec`
    是加密的训练好的模型。
- en: 'We will use  `pickle`  to store the trained model in a file:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `pickle` 将训练好的模型存储在文件中：
- en: '[PRE14]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s define a function named  `write_key()`  that will generate a symmetric
    key and store it in a file named  `key.key`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个名为 `write_key()` 的函数，它将生成一个对称密钥并将其存储在名为 `key.key` 的文件中：
- en: '[PRE15]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s define a function named  `load_key()`  that can read the stored
    key from the  `key.key` file:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个名为 `load_key()` 的函数，它可以从 `key.key` 文件中读取存储的密钥：
- en: '[PRE16]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, let''s define an  `encrypt()`  function that can encrypt and train the
    model, and store it in a file named  `filename_sec`:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义一个 `encrypt()` 函数，它可以加密和训练模型，并将其存储在名为 `filename_sec` 的文件中：
- en: '[PRE17]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will use these functions to generate a symmetric key and store it in a file.
    Then, we will read this key and use it to store our trained model in a file named  `filename_sec`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用这些函数生成对称密钥并将其存储在文件中。然后，我们将读取此密钥并使用它将我们的训练好的模型存储在名为 `filename_sec` 的文件中：
- en: '[PRE18]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now the model is encrypted. It will be transferred to the destination where
    it will be used for prediction:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模型已经加密。它将被传输到目的地，在那里将用于预测。
- en: 'First, we will define a function named  `decrypt()`  that we can use to decrypt
    the model from  `filename_sec`  to  `filename_destination`  using the key stored
    in the  `key.key` file:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个名为 `decrypt()` 的函数，我们可以使用它来使用存储在 `key.key` 文件中的密钥将模型从 `filename_sec`
    解密到 `filename_destination`：
- en: '[PRE19]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now let''s use this function to decrypt the model and store it in a file named  `filename_destination`:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用这个函数来解密模型并将其存储在名为 `filename_destination` 的文件中：
- en: '[PRE20]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now let''s use this unencrypted file to load the model and use it for predictions:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用这个未加密的文件来加载模型并用于预测：
- en: '![](assets/62b061a9-c024-47b5-b3fa-8c4cbe41f146.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/62b061a9-c024-47b5-b3fa-8c4cbe41f146.png)'
- en: Note that we have used symmetric encryption to encode the model. The same technique
    can be used to encrypt data as well, if needed.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经使用对称加密对模型进行了编码。如果需要，可以使用相同的技术来加密数据。
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about cryptographic algorithms. We started by identifying
    the security goals of a problem. We then discussed various cryptographic techniques
    and also looked at the details of the PKI infrastructure. Finally, we looked at
    the different ways of protecting a trained machine learning model against common
    attacks. Now, you should be able to understand the fundamentals of security algorithms
    used to protect modern IT infrastructures.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了加密算法。我们首先确定了问题的安全目标。然后讨论了各种加密技术，还研究了PKI基础设施的细节。最后，我们研究了不同的方法来保护训练好的机器学习模型免受常见攻击。现在，您应该能够理解用于保护现代IT基础设施的安全算法的基本原理。
- en: In the next chapter, we will look at designing large-scale algorithms. We will
    study the challenges and trade-offs involved in designing and selecting large
    algorithms. We will also look at the use of a GPU and clusters to solve complex
    problems.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究设计大规模算法。我们将研究设计和选择大型算法涉及的挑战和权衡。我们还将研究使用GPU和集群来解决复杂问题。
