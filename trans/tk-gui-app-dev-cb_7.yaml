- en: Canvas and Graphics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 画布和图形
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Understanding the coordinate system
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解坐标系统
- en: Drawing lines and arrows
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制线条和箭头
- en: Writing text on a canvas
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在画布上写字
- en: Adding shapes to the canvas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向画布添加形状
- en: Finding items by their position
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过它们的位置查找项目
- en: Moving canvas items
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动画布项目
- en: Detecting collisions between items
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测项目之间的碰撞
- en: Deleting items from a canvas
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从画布中删除项目
- en: Binding events to canvas items
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事件绑定到画布项目
- en: Rendering a canvas into a PostScript file
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将画布渲染成PostScript文件
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the first chapter, we covered several recipes for the standard Tkinter widget.
    However, we skipped the **Canvas** widget because it offers plenty of graphical
    capabilities, and it deserves a dedicated chapter by itself to dive into its common
    use cases.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们涵盖了标准Tkinter小部件的几个配方。但是，我们跳过了**Canvas**小部件，因为它提供了丰富的图形功能，并且值得单独的章节来深入了解其常见用例。
- en: A canvas is a rectangular area where you can not only display text and geometric
    shapes, such as lines, rectangles, or ovals, but also nest other Tkinter widgets.
    These objects are called **canvas items**, and each one has a unique identifier
    that allows us to manipulate them before they are initially displayed on the canvas.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 画布是一个矩形区域，您不仅可以在其中显示文本和几何形状，如线条、矩形或椭圆，还可以嵌套其他Tkinter小部件。这些对象称为**画布项目**，每个项目都有一个唯一的标识符，允许我们在它们最初显示在画布上之前对它们进行操作。
- en: We will cover the methods of the `Canvas` class with interactive samples, which
    will help us to identify frequent patterns that could be translated to the applications
    we want to build.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Canvas`类的方法进行交互示例，这将帮助我们识别可能转换为我们想要构建的应用程序的常见模式。
- en: Understanding the coordinate system
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解坐标系统
- en: To draw graphic items on a canvas, we will need to specify their position using
    a **coordinate system**. Since a canvas is a two-dimensional space, points will
    be notated by their coordinates on the horizontal and vertical axes—commonly labeled
    *x* and *y* respectively.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要在画布上绘制图形项目，我们需要使用**坐标系统**指定它们的位置。由于画布是二维空间，点将通过它们在水平和垂直轴上的坐标来表示——通常分别标记为*x*和*y*。
- en: With a simple application, we can easily illustrate how to locate these points
    in relation to the origin of the coordinate system, placed in the upper-left corner
    of the canvas area.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个简单的应用程序，我们可以很容易地说明如何定位这些点与坐标系统原点的关系，该原点位于画布区域的左上角。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following program contains an empty canvas and a label that shows the location
    of the cursor on the canvas; you can move the cursor to see what position it is
    placed in, giving clear feedback on how the x and y coordinates increment or decrement,
    depending on the direction you move the mouse pointer:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序包含一个空画布和一个标签，显示光标在画布上的位置；您可以移动光标以查看其所处的位置，清晰地反映了鼠标指针移动的方向，x和y坐标是如何增加或减少的：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `Canvas` instance is created like any other Tkinter widget, that is, by
    first passing the parent container and the additional configuration options as
    keyword arguments:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`实例像其他Tkinter小部件一样创建，即首先通过将父容器和额外的配置选项作为关键字参数传递：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next screenshot shows a point composed of the perpendicular projections
    of each axis:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个屏幕截图显示了由每个轴的垂直投影组成的点：
- en: The x coordinate corresponds to the distance on the horizontal axis and increments
    its value when you move the cursor from left to right
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x坐标对应于水平轴上的距离，当您将光标从左向右移动时，其值会增加
- en: The y coordinate is the distance on the vertical axis and increments its value
    when you move the cursor from up to down
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: y坐标是垂直轴上的距离，当您将光标从上向下移动时，其值会增加
- en: '![](images/43cd19e1-fd63-49cd-8d6f-dbca306cb2c4.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](images/43cd19e1-fd63-49cd-8d6f-dbca306cb2c4.png)'
- en: 'As you might have noticed in the preceding screenshot, these coordinates directly
    map to the `x` and `y` attributes of the `event` instance passed to the handler:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的在前面的屏幕截图中，这些坐标直接映射到传递给处理程序的`event`实例的`x`和`y`属性：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This happens because these attributes are calculated in respect to the widget
    that the event is bound to, in this case, the `<Motion>` sequence.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为这些属性是相对于事件绑定到的小部件计算的，在这种情况下是`<Motion>`序列。
- en: There's more...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The canvas surface can also display items with negative values in their coordinates.
    Depending on the item size, they can be partially shown on the top or left borders
    of the canvas.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 画布表面还可以显示具有其坐标中的负值的项目。根据项目的大小，它们可能部分显示在画布的顶部或左边界上。
- en: In a similar way, if an item is placed at a point where any of its coordinates
    is greater than the canvas size, it may partially fall outside the bottom or right
    borders.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果项目放置在任一坐标大于画布大小的点上，它可能部分落在底部或右边界之外。
- en: Drawing lines and arrows
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制线条和箭头
- en: One of the most basic actions you can perform with a canvas is drawing segments
    from one point to another. Although it is possible to directly draw polygons using
    other methods, the `create_line` method of the `Canvas` class has enough options
    to understand the basics of displaying items.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用画布执行的最基本的操作之一是从一个点到另一个点绘制线段。虽然可以使用其他方法直接绘制多边形，但`Canvas`类的`create_line`方法具有足够的选项来理解显示项目的基础知识。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will build an application that allows us to draw lines by
    clicking on the canvas. Each line will be displayed by clicking first on the point
    that will determine the line start, and a second time to set the line end.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将构建一个应用程序，允许我们通过单击画布来绘制线条。每条线都将通过首先单击确定线条起点的点，然后第二次设置线条终点来显示。
- en: 'We will be also able to specify some appearance options, such as color and
    width:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定一些外观选项，如颜色和宽度：
- en: '![](images/917ecb33-f662-47ac-9ef6-7cb7d79595a2.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](images/917ecb33-f662-47ac-9ef6-7cb7d79595a2.png)'
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Our `App` class will be responsible for creating an empty canvas and handling
    mouse click events.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`App`类将负责创建一个空画布并处理鼠标点击事件。
- en: The information on the line options will be retrieved from the `LineForm` class.
    The approach of separating this component into a different class helps us to abstract its
    implementation details and focus on how to work with the `Canvas` widget.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 线选项的信息将从`LineForm`类中检索。将此组件分离到不同的类中的方法有助于我们抽象其实现细节，并专注于如何使用`Canvas`小部件。
- en: 'For the sake of brevity, we omit the implementation of the `LineForm` class
    in the following snippet:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们在以下片段中省略了`LineForm`类的实现：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can find the complete code sample in the `chapter7_02.py` file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`chapter7_02.py`文件中找到完整的代码示例。
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since we want to handle the mouse clicks on the canvas, we will bind the `draw()`
    method to this type of event. We will also define the `line_start` field
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要处理画布上的鼠标点击，我们将`draw()`方法绑定到这种类型的事件。我们还将定义`line_start`字段
- en: 'to keep track of the start point of each new line:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪每条新线的起点：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `draw()` method contains the main logic of our application. The first click
    on each new line serves to determine the origin and does not perform any drawing
    operation. These coordinates are retrieved from the `event` object passed to the
    handler:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()`方法包含我们应用程序的主要逻辑。每条新线的第一次点击用于确定原点，并且不执行任何绘图操作。这些坐标是从传递给处理程序的`event`对象中检索的：'
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If `line_start` already has a value, we retrieve the origin point and pass
    it with the coordinates of the current event to draw the line:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`line_start`已经有一个值，我们将检索原点，并将其与当前事件的坐标一起传递以绘制线条：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `canvas.create_line()` method takes four arguments, where the first two
    are the horizontal and vertical coordinates of the line start and the last two
    are the coordinates corresponding to the line end.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`canvas.create_line()`方法需要四个参数，前两个是线条起点的水平和垂直坐标，最后两个是与线条终点对应的坐标。'
- en: Writing text on a canvas
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画布上写文本
- en: In case we want to write some text on a canvas, we do not need to use an additional
    widget, such as a Label. The `Canvas` class includes the `create_text` method
    to display a string that can be manipulated the same as any other type of canvas
    item.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在画布上写一些文本，我们不需要使用额外的小部件，比如Label。`Canvas`类包括`create_text`方法来显示一个可以像任何其他类型的画布项一样操作的字符串。
- en: It is also possible to use the same formatting options that we can specify to
    add style to the text of regular Tkinter widgets, such as color, font family,
    and size.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用与我们可以指定的相同的格式选项来为常规Tkinter小部件的文本添加样式，例如颜色、字体系列和大小。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this example, we will connect an Entry widget with the contents of a text
    canvas item. While the input will have the standard appearance, the text on the
    canvas will have a customized style:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将连接一个Entry小部件与文本画布项的内容。虽然输入将具有标准外观，但画布上的文本将具有自定义样式：
- en: '![](images/7fcc52e1-d1b6-43fe-a9ef-042f22b3b08f.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](images/7fcc52e1-d1b6-43fe-a9ef-042f22b3b08f.png)'
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The text item will be initially displayed using the `canvas.create_text()` method,
    with some additional options to use a Consolas font and a blue color.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 文本项将首先使用`canvas.create_text()`方法显示，还有一些额外的选项来使用Consolas字体和蓝色。
- en: 'The dynamic behavior of the text item will be implemented using `StringVar`.
    By tracing this Tkinter variable, we can modify the contents of the item:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 文本项的动态行为将使用`StringVar`实现。通过跟踪这个Tkinter变量，我们可以修改项目的内容：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can try out this program by typing some arbitrary text on the entry input
    and noticing how it automatically updates the text on the canvas.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在输入框中键入任意文本并注意它如何自动更新画布上的文本来尝试此程序。
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, we initialize the `Entry` instance with its `StringVar` variable and
    the Canvas widget:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用其`StringVar`变量和Canvas小部件初始化`Entry`实例：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we place the widgets by calling the methods for the Pack geometry manager.
    Note the importance of calling `update()` on the root window, because we want
    to force Tkinter to process all the pending changes, in this case rendering the
    widgets before the `__init__` method continues its execution:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用Pack几何管理器的方法来放置小部件。请注意调用根窗口上的`update()`的重要性，因为我们希望强制Tkinter处理所有未决的更改，在这种情况下在`__init__`方法继续执行之前渲染小部件：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We did this because the next step will be to calculate the canvas dimensions,
    and until the geometry manager has displayed the widget, it will not have the
    real values of its width and height.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是因为下一步将是计算画布的尺寸，直到几何管理器显示小部件，它才会有其宽度和高度的真实值。
- en: After this, we can safely retrieve the canvas dimensions. Since we want to align
    the text item with the center of the canvas, we divide the values of width and
    height by half.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以安全地检索画布的尺寸。由于我们想要将文本项与画布的中心对齐，我们将宽度和高度的值除以二。
- en: 'These coordinates determine the position of the item, and together with the
    styling options, are passed to the `create_text()` method. The `text` keyword
    argument is a common option used here, but we will omit it because it will be
    dynamically set when `StringVar` changes its value:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些坐标确定了项目的位置，并与样式选项一起传递给`create_text()`方法。`text`关键字参数在这里是一个常用选项，但我们将省略它，因为当`StringVar`更改其值时，它将被动态设置：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The identifier returned by `create_text()` is stored in the `text_id` field.
    It will be used on the `write_text()` method to reference the item, which is invoked
    by the tracing mechanism on write operations of the `var` instance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_text()`返回的标识符存储在`text_id`字段中。它将在`write_text()`方法中用于引用该项，该方法由`var`实例的写操作的跟踪机制调用。'
- en: To update the `text` option inside the `write_text()` handler, we call the `canvas.itemconfig()`
    method with the item identifier as the first argument, and then the configuration
    options.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新`write_text()`处理程序中的`text`选项，我们使用`canvas.itemconfig()`方法调用项目标识符作为第一个参数，然后是配置选项。
- en: 'In our case, we use the `text_id` field that we stored while initializing our
    `App` instance and the contents of `StringVar` via its `get()` method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们使用了我们在初始化`App`实例时存储的`text_id`字段和通过其`get()`方法获取的`StringVar`的内容：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We defined our `write_text()` method so that it can receive a variable number
    of arguments even though we do not need them, because the `trace()` method of
    Tkinter variables passes them to the callback functions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`write_text()`方法，以便它可以接收可变数量的参数，即使我们不需要它们，因为Tkinter变量的`trace()`方法将它们传递给回调函数。
- en: There's more...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `canvas.create_text()` method has many other options to customize the created
    canvas items.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`canvas.create_text()` 方法有许多其他选项，可以自定义创建的画布项目。'
- en: Placing the text by its upper-left corner
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过其左上角放置文本
- en: The `anchor` option allow us to control where to place the item relative to
    the position passed as its first argument to `canvas.create_text()`. By default,
    this option value is `tk.CENTER`, which means that the text widget is centered
    on these coordinates.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`anchor`选项允许我们控制相对于作为其`canvas.create_text()`的第一个参数传递的位置放置项目的位置。默认情况下，此选项值为`tk.CENTER`，这意味着文本小部件居中于这些坐标上。'
- en: 'If you want to place the text on the upper-left corner of the canvas, you can
    do so by passing the `(0, 0)` position and setting the `anchor` option to `tk.NW`,
    aligning the origin to the north-west of the rectangular area the text is placed
    within:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将文本放在画布的左上角，可以通过传递`(0, 0)`位置并将`anchor`选项设置为`tk.NW`来这样做，将原点对齐到文本放置在其中的矩形区域的西北角：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code snippet will give us the following result:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将给我们以下结果：
- en: '![](images/51d7f33e-6edb-4b2d-b763-04ebf4508af2.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](images/51d7f33e-6edb-4b2d-b763-04ebf4508af2.png)'
- en: Setting line wrapping
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置换行
- en: 'By default, the contents of a text item will be displayed in a single line.
    The `width` option allows us to define a maximum line width, which wraps lines
    longer than that:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，文本项目的内容将显示在单行中。`width`选项允许我们定义最大行宽，用于换行超过该宽度的行：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, when we write `Hello, world!` on the entry, the part of the text that
    exceeds the line width will be displayed in a new line:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们在输入框中写入`Hello, world!`时，超过行宽的文本部分将显示在新行中：
- en: '![](images/689721c7-6307-4dac-b556-28b3dbb199ec.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](images/689721c7-6307-4dac-b556-28b3dbb199ec.png)'
- en: Adding shapes to the canvas
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向画布添加形状
- en: 'In this recipe, we will cover three of the standard canvas items: rectangles,
    ovals, and arcs. All of them are displayed within a bounding box, so the use of
    only two points is necessary to set their position: the upper-left corner of the
    box and the lower-right corner.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将介绍三种标准画布项目：矩形、椭圆和弧。它们都显示在一个边界框内，因此只需要两个点来设置它们的位置：框的左上角和右下角。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The following application allows users to freely draw some items on the canvas
    by selecting its type with three buttons—each one to select the corresponding
    shape.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下应用程序允许用户通过三个按钮选择其类型在画布上自由绘制一些项目-每个按钮选择相应的形状。
- en: 'Item''s positions are determined by clicking first on the canvas to set the
    upper-left corner of the box the item will be contained in, and then clicking
    to set the lower-left corner of this box and draw the item with some predefined
    options:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的位置是通过首先在画布上单击来设置项目将包含在其中的框的左上角，然后再单击来设置此框的左下角并使用一些预定义选项绘制项目来确定的：
- en: '![](images/dff4558b-fd6c-4ff5-b8c6-76e02e2dee61.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](images/dff4558b-fd6c-4ff5-b8c6-76e02e2dee61.png)'
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Our application stores the currently chosen type of item, which is selected
    with one of the three buttons placed on a frame below the canvas.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序存储当前选择的项目类型，可以使用放置在画布下方框架上的三个按钮之一选择。
- en: 'Clicking with the primary mouse button on the canvas triggers the handler that
    stores the position of the first corner of the new item, and once it is clicked
    again, it reads the value of the selected shape to conditionally draw the corresponding
    item:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主鼠标按钮单击画布会触发处理程序，该处理程序存储新项目的第一个角的位置，然后再次单击，它会读取所选形状的值以有条件地绘制相应的项目：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To dynamically select the type of item drawn by clicking on the canvas, we will
    create a button for each one of the shapes by iterating over the `shapes` tuple.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过单击画布动态选择要绘制的项目类型，我们将通过迭代`shapes`元组为每个形状创建一个按钮。
- en: 'We define each callback command using the `partial` function from the `functools`
    module. Thanks to this, we can freeze the `Button` instance and the current shape
    of the loop as arguments to the callback of each button:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`functools`模块中的`partial`函数来定义每个回调命令。由于这样，我们可以将`Button`实例和循环的当前形状作为每个按钮的回调的参数冻结：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `set_selection()` callback marks the clicked button with the `SUNKEN` relief
    and stores the selection in the `shape` field.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_selection()`回调标记了单击的按钮，并将选择存储在`shape`字段中，使用`SUNKEN` relief。'
- en: 'The other widget siblings are configured with the standard relief (`RAISED`)
    by navigating to the parent, available in the `master` field of the current widget,
    and then retrieving all the children widgets with the `winfo_children()` method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 其他小部件兄弟姐妹通过导航到父级（在当前小部件的`master`字段中可用）并使用`winfo_children()`方法检索所有子小部件来配置标准的`relief`（`RAISED`）：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `draw_item()` handler stores the coordinates of the first click of each
    pair of events to draw the item when the canvas is clicked again—exactly like
    we previously did in the *Drawing lines and arrows* recipe.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw_item()`处理程序将每对事件的第一次单击的坐标存储起来，以便在再次单击画布时绘制项目-就像我们在*绘制线条和箭头*示例中所做的那样。'
- en: 'Depending on the value of the `shape` field, one of the following methods is
    invoked to display the corresponding item type:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`shape`字段的值，调用以下方法之一来显示相应的项目类型：
- en: '`canvas.create_rectangle(x0, y0, x1, y1, **options)`: Draws a rectangle whose
    upper-left corner is placed at **(x0, y0)** and lower-right corner at **(x1, y1)**:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canvas.create_rectangle(x0, y0, x1, y1, **options)`: 绘制一个矩形，其左上角位于**(x0, y0)**，右下角位于**(x1,
    y1)**：'
- en: '![](images/9bc92787-61f1-4eed-9c2c-1f7b422cb606.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](images/9bc92787-61f1-4eed-9c2c-1f7b422cb606.png)'
- en: '`canvas.create_oval(x0, y0, x1, y1, **options)`: Draws an ellipse that fits
    into the rectangle from **(x0, y0)** to **(x1, y1)***:*'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canvas.create_oval(x0, y0, x1, y1, **options)`: 绘制一个椭圆，适合从**(x0, y0)**到**(x1,
    y1)**的矩形中：*'
- en: '![](images/f9490d06-adc3-4f5e-872c-0fb600265970.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](images/f9490d06-adc3-4f5e-872c-0fb600265970.png)'
- en: '`canvas.create_arc(x0, y0, x1, y1, **options)`: Draws a quarter of the ellipse
    that would fit into the rectangle from **(x0, y0) **to **(x1, y1)**:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`canvas.create_arc(x0, y0, x1, y1, **options)`: 绘制一个四分之一的椭圆，该椭圆适合从**(x0, y0)**到**(x1,
    y1)**的矩形中：'
- en: '![](images/3abfc301-8ed6-4ed3-bacf-e0a8df5746e9.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](images/3abfc301-8ed6-4ed3-bacf-e0a8df5746e9.png)'
- en: See also
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Drawing lines and arrows* recipe
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*绘制线条和箭头*食谱'
- en: Finding items by their position
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按其位置查找项目
- en: The `Canvas` class includes methods to retrieve item identifiers that are close
    to a canvas coordinate.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`类包括检索接近画布坐标的项目标识符的方法。'
- en: This is very useful because it saves us from storing each reference to a canvas
    item and then calculating their current position to detect which ones are within
    a specific area or closest to a certain point.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有用，因为它可以避免我们存储对画布项目的每个引用，然后计算它们的当前位置以检测哪些项目在特定区域内或最接近特定点。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'The following application creates a canvas with four rectangles, and changes
    the color of the one that is closest to the mouse pointer:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下应用程序创建了一个带有四个矩形的画布，并更改了最接近鼠标指针的矩形的颜色：
- en: '![](images/72906402-5615-46ca-8bfb-b05a0f3b46b0.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](images/72906402-5615-46ca-8bfb-b05a0f3b46b0.png)'
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: To find the closest item to the pointer, we pass the mouse event coordinates
    to the `canvas.find_closest()` method, which retrieves the identifier of the item
    that is closest to the given position.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到最接近指针的项目，我们将鼠标事件坐标传递给`canvas.find_closest()`方法，该方法检索最接近给定位置的项目的标识符。
- en: 'Once there is at least one item in the canvas, we can safely assume that this
    method will always return a valid item identifier:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦画布中至少有一个项目，我们可以安全地假定该方法将始终返回有效的项目标识符：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'During application initialization, we create the canvas and define the `current`
    field to store a reference to the current highlighted item. We also handle the
    `"<Motion>"` events on the canvas with the `mouse_motion()` method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序初始化期间，我们创建画布并定义`current`字段以存储对当前突出显示项目的引用。我们还使用`mouse_motion()`方法处理画布上的`"<Motion>"`事件：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we create four items with a specific arrangement so that we can easily
    visualize the item that is closest to the mouse pointer:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建四个具有特定排列的项目，以便我们可以轻松地可视化最接近鼠标指针的项目：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `mouse_motion()` handler sets the color of the current item back to `blue` and
    saves the item identifier of the new one, which is closer to the event coordinates.
    Finally, the `fill` color of this item is set to `yellow`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`mouse_motion()`处理程序将当前项目的颜色设置回`blue`，并保存新项目的项目标识符，该项目更接近事件坐标。最后，设置此项目的`fill`颜色为`yellow`：'
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Initially, there are no errors when `mouse_motion()` is called for the first
    time and the `current` field is still `None`, since it is also a valid input parameter
    to `itemconfig()`; it just does not perform any action on the canvas.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次调用`mouse_motion()`时，`current`字段仍为`None`时不会出现错误，因为它也是`itemconfig()`的有效输入参数；它只是不会在画布上执行任何操作。
- en: Moving canvas items
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动画布项目
- en: Once placed, canvas items can be moved to a certain offset, without having to
    specify the absolute coordinates.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦放置，画布项目就可以移动到特定的偏移量，而无需指定绝对坐标。
- en: When moving canvas items, it is usually relevant to calculate its current position,
    for instance, to determine whether they are placed inside a concrete canvas area,
    and restrict their movements so that they always stay within that area.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 移动画布项目时，通常需要计算其当前位置，例如确定它们是否放置在具体的画布区域内，并限制它们的移动，使其始终保持在该区域内。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Our example will consist of a simple canvas with a rectangle item, which can
    be moved horizontally and vertically using the arrow keys.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将包括一个简单的带有矩形项目的画布，可以使用箭头键在水平和垂直方向上移动。
- en: 'To prevent this item from moving outside of the screen, we will limit its movements
    inside the canvas dimensions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止此项目移出屏幕，我们将限制其在画布尺寸内的移动：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To handle the arrow keyboard events, we bind the `"<KeyPress>"` and `"<KeyRelease>"`
    sequences to the application instance. The currently pressed key symbols are stored
    in the `pressed_keys` dictionary:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理箭头键盘事件，我们将`"<KeyPress>"`和`"<KeyRelease>"`序列绑定到应用程序实例。当前按下的键符号存储在`pressed_keys`字典中：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This approach is preferred instead of separately binding the `"<Up>"`, `"<Down>"`,
    `"<Right>"`, and `"<Left>"` keys, because that would call each handler only when
    Tkinter processes the input keyboard events, causing the item to "jump" from one
    position to the next one rather than moving it smoothly on the horizontal and
    vertical axes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法比分别绑定`"<Up>"`、`"<Down>"`、`"<Right>"`和`"<Left>"`键更可取，因为这样会在Tkinter处理输入键盘事件时仅调用每个处理程序，导致项目从一个位置“跳转”到下一个位置，而不是在水平和垂直轴上平滑移动。
- en: The last sentence of the initialization of the `App` instance is the call to
    `process_movements()`, which starts processing the movement of the canvas item.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`实例初始化的最后一句是调用`process_movements()`，它开始处理画布项目的移动。'
- en: 'This method calculates the offset in each axis that the item should be displaced.
    Depending on the contents of the `pressed_keys` dictionary, the `speed` value
    is added or subtracted on each component of the coordinates:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法计算项目应该在每个轴上偏移的量。根据`pressed_keys`字典的内容，`speed`值将添加或减去坐标的每个分量：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After this, we retrieve the current item position by calling `canvas.coords()`
    and unpacking the couple of points that form the bounding box into four variables.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，通过调用`canvas.coords()`并解压形成边界框的一对点来检索当前项目位置到四个变量。
- en: 'The center of the item is calculated by adding the `x` and `y` components of
    the upper-left corner to half of its width and height. This result, plus the offset
    in each axis, corresponds to the final position of the item after it is moved:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将左上角的`x`和`y`分量加上其宽度和高度的一半来计算项目的中心。这个结果，再加上每个轴上的偏移量，对应于项目移动后的最终位置：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we check whether this final item position is within the canvas area.
    To do so, we take advantage of Python''s support for chaining comparison operators:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查最终项目位置是否在画布区域内。为此，我们利用Python对链接比较运算符的支持：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, this method schedules itself with a delay of 10 milliseconds by calling
    `self.after(10, self.process_movements)`. Thus, we achieve the effect of having
    a "custom mainloop" inside Tkinter's mainloop.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该方法通过调用`self.after(10, self.process_movements)`以10毫秒的延迟安排自身。因此，我们实现了在Tkinter的主循环中具有“自定义主循环”的效果。
- en: There's more...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You might wonder why we did not call `after_idle()` instead of `after()` to
    schedule the `process_movements()` method.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么我们没有调用`after_idle()`而是调用`after()`来安排`process_movements()`方法。
- en: It might look a valid approach since there are no other events to process, apart
    from redrawing our canvas and handling keyboard inputs, so there is no need to
    add a delay between calls to `process_movements()` if there are no pending GUI
    events.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是一个有效的方法，因为除了重新绘制我们的画布和处理键盘输入之外，没有其他事件需要处理，因此在`process_movements()`之间如果没有待处理的GUI事件，就不需要添加延迟。
- en: However, using `after_idle` would cause the item to move at a pace that will
    depend on the computer speed. This means that a fast system will call `process_movements()`
    more times in the same interval of time than a slower one, and this difference
    will be noticeable in the item speed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用`after_idle`会导致项目移动的速度取决于计算机的速度。这意味着快速系统将在相同的时间间隔内多次调用`process_movements()`，而较慢的系统将在项目速度上有所不同。
- en: By introducing a minimum fixed delay, we give a chance to machines with different
    capabilities to behave in a similar manner.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入最小固定延迟，我们给具有不同功能的机器一个机会，以便以类似的方式行事。
- en: See also
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Detecting collisions between items* recipe
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测项目之间的碰撞食谱
- en: Detecting collisions between items
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测项目之间的碰撞
- en: As a continuation of the preceding recipe, we can detect whether a rectangle
    item overlaps with another one. In fact, this can be achieved, assuming that we
    are working with shapes contained in rectangular boxes, using the `find_overlapping()`
    method from the `Canvas` class.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为前面食谱的延续，我们可以检测矩形项目是否与另一个项目重叠。实际上，假设我们正在使用包含在矩形框中的形状，可以使用`Canvas`类的`find_overlapping()`方法来实现这一点。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This application extends the preceding one by adding four green rectangles
    to the canvas and highlighting the one that is touched by a blue rectangle moved
    using the arrow keys:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序通过向画布添加四个绿色矩形并突出显示通过使用箭头键移动的蓝色矩形触摸的矩形，扩展了前一个应用程序：
- en: '![](images/ce47f2c4-c609-4fa0-aea3-71bf7cb0b81e.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](images/ce47f2c4-c609-4fa0-aea3-71bf7cb0b81e.png)'
- en: How to do it...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Since this script has many similarities with the preceding one, we marked the
    parts of the code that create the four rectangles and invoke the `canvas.find_overlapping()`
    method:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此脚本与前一个脚本有许多相似之处，我们标记了创建四个矩形并调用`canvas.find_overlapping()`方法的代码部分：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The modification to the `__init__` method is similar to the one in the *Finding
    items by their position* recipe, so you can review it in case you have any doubts
    and skip directly to the changes in the `process_movements()` method.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`方法的修改类似于*按位置查找项目*食谱中的修改，因此如果有任何疑问，您可以查看它并直接跳转到`process_movements()`方法中的更改。'
- en: 'Before we calculate any overlap, the fill color of all the canvas items, except
    the one that can be controlled by the user, is changed to green. These item''s
    identifiers are retrieved by the `canvas.find_all()` method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算任何重叠之前，除了用户可以控制的项目之外，所有画布项目的填充颜色都更改为绿色。这些项目的标识符由`canvas.find_all()`方法检索：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that the item colors are reset, we call `canvas.find_overlapping()` to
    get all the items that are currently colliding with the moving item. Again, the
    item controlled by the user is excluded from the loop, and the color of the rest
    of the overlapping items (if any) is changed to yellow:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目颜色已重置，我们调用`canvas.find_overlapping()`以获取当前与移动项目发生碰撞的所有项目。同样，用户控制的项目在循环中被排除，重叠项目的颜色（如果有）被更改为黄色：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The method continues its execution by moving the blue rectangle by the calculated
    offset, and scheduling `process_movements()` itself again.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法继续执行，通过计算偏移量移动蓝色矩形，并再次安排`process_movements()`自身。
- en: There's more...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you want to detect when the moving item fully overlaps another one, instead
    of partially doing it, replace the call to `canvas.find_overlapping()` to `canvas.find_enclosed()`
    with the same parameters.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要检测移动项目完全与另一个项目重叠，而不是部分重叠，可以将对`canvas.find_overlapping()`的调用替换为使用相同参数的`canvas.find_enclosed()`。
- en: Deleting items from a canvas
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从画布中删除项目
- en: Besides adding and modifying items on a canvas, it is also possible to delete
    them via the `delete()` method of the `Canvas` class. Although the usage of this
    method is very straightforward, there are a couple of useful patterns that we
    will see in the next example.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在画布上添加和修改项目，还可以通过`Canvas`类的`delete()`方法删除它们。虽然这种方法的使用非常简单，但在下一个示例中我们将看到一些有用的模式。
- en: Keep in mind that the more items displayed on a canvas, the longer it will take
    to Tkinter to redraw the widget. Therefore, it is convenient to remove unnecessary
    items if this could cause a performance issue.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在画布上显示的项目越多，Tkinter重新绘制小部件所需的时间就越长。因此，如果这可能会导致性能问题，最好删除不必要的项目。
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will build an application that randomly displays several
    circles on a canvas. Each circle removes itself once you click on it, and the
    window contains one button to clear all the items and another button to start
    over again:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，我们将构建一个应用程序，在画布上随机显示几个圆。单击圆后，每个圆都会自行删除，窗口包含一个按钮来清除所有项目和另一个按钮来重新开始：
- en: '![](images/f5f70f4c-b05c-4a20-a132-8128d59fc1b4.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](images/f5f70f4c-b05c-4a20-a132-8128d59fc1b4.png)'
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: To irregularly place the items on the canvas, we will generate the coordinates
    using the `randint` function from the `random` module. The item color will be
    randomly chosen as well by calling `choice` with a predefined list of colors.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在画布上不规则地放置项目，我们将使用`random`模块的`randint`函数生成坐标。项目颜色也将通过调用`choice`并使用预定义的颜色列表来随机选择。
- en: 'Once generated, items can be deleted either by triggering the `on_click` handler
    when clicked or by pressing the `Clear items` button, which executes the `clear_all`
    callback. These methods internally call `canvas.delete()` with the appropriate
    parameters:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成，项目可以通过单击触发`on_click`处理程序或按下`Clear items`按钮来删除，后者执行`clear_all`回调。这些方法内部使用适当的参数调用`canvas.delete()`：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `canvas.delete()` method takes one argument, which can be an item identifier
    or a tag, and removes the matching item or items, since the same tag can be used
    multiple times.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`canvas.delete()`方法接受一个参数，可以是项目标识符或标记，并删除匹配的项目，因为相同的标记可以多次使用。'
- en: 'In the `on_click()` handler, we can see an example of how to remove an item
    by its identifier:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`on_click()`处理程序中，我们可以看到如何通过其标识符删除项目的示例：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that if we click on an empty point, `canvas.find_withtag(tk.CURRENT)` will
    return `None`, but it will not raise any error when passed to `canvas.delete()`.
    This happens because the `None` parameter will not match any item identifier or
    tag and therefore, it is a valid value even though it will not perform any action.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们单击空点，`canvas.find_withtag(tk.CURRENT)`将返回`None`，但当传递给`canvas.delete()`时不会引发任何错误。这是因为`None`参数不会匹配任何项目标识符或标记，因此，即使它不执行任何操作，它也是有效的值。
- en: 'In the `clear_items()` callback, we can find another example of deleting items.
    Here, instead of passing an item identifier, we used the `ALL` tag to match all
    the items and remove them from the canvas:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`clear_items()`回调中，我们可以找到另一个删除项目的示例。在这里，我们使用`ALL`标记而不是传递项目标识符来匹配所有项目并将其从画布中删除：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you may have noticed, the `ALL` tag works out of the box and does not need
    to be added to every canvas item.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，`ALL`标记可以直接使用，无需添加到每个画布项目。
- en: Binding events to canvas items
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将事件绑定到画布项目
- en: So far, we have seen how to bind events to widgets; however, it is also possible
    to do so for canvas items. This helps us to write more specific and simpler event
    handlers, instead of binding all the types of events we want to process on the
    `Canvas` instance and then determining which action has to be applied according
    to the affected item.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何将事件绑定到小部件；但是，也可以为画布项目这样做。这有助于我们编写更具体和更简单的事件处理程序，而不是在`Canvas`实例上绑定我们想要处理的所有事件类型，然后根据受影响的项目确定要应用的操作。
- en: Getting ready
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The following application shows how to implement the drag and drop functionality
    on canvas items. This is a common functionality that serves to illustrate how
    this approach can simplify our programs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下应用程序显示了如何在画布项目上实现拖放功能。这是一个常见的功能，用于说明这种方法如何简化我们的程序。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create a couple of items that can be dragged and dropped with the mouse—a
    rectangle and an oval. The different shapes help us to note how the click events
    are correctly applied to the corresponding item, even though the items are placed
    overlapping each other:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建两个可以使用鼠标拖放的项目——一个矩形和一个椭圆。不同的形状帮助我们注意到单击事件如何正确应用于相应的项目，即使项目重叠放置：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To bind events to items, we use the `tag_bind()` method from the `Canvas` class.
    This adds the event binding to all the items that match the item specifier, in
    our example, the `"draggable"` tag.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要将事件绑定到项目，我们使用`Canvas`类的`tag_bind()`方法。这将事件绑定添加到与项目指定符匹配的所有项目上，在我们的示例中是`"draggable"`标记。
- en: 'Even the method is named `tag_bind()`; it would be also valid to pass an item
    identifier instead of a tag:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 即使方法被命名为`tag_bind()`; 传递项目标识符而不是标记也是有效的：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Keep in mind that this only affects existing tagged items, so if we add new
    items later on with the `"draggable"` tag, they will not have these bindings attached.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这仅影响现有的带标签项目，因此，如果我们稍后使用`"draggable"`标记添加新项目，它们将不具有这些绑定附加。
- en: The `button_press()` method is the handler invoked when an item is clicked.
    As usual, a common pattern to retrieve the clicked item is to call `canvas.find_withtag(tk.CURRENT)`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`button_press()`方法是在单击项目时调用的处理程序。通常，检索单击的项目的常见模式是调用`canvas.find_withtag(tk.CURRENT)`。'
- en: 'This item identifier and the `x` and `y` coordinates of the `click` event are
    stored in the `dnd_item` field. These values will be used later to move the item
    in sync with the mouse motion:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目标识符和`click`事件的`x`和`y`坐标存储在`dnd_item`字段中。稍后将使用这些值来与鼠标运动同步移动项目：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `button_motion()` method processes the mouse motion events while the primary
    button is being held.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`button_motion()`方法在按住主按钮时处理鼠标运动事件。'
- en: 'To set the distance that the item should be moved, we calculate the difference
    from the current event position to the previously stored coordinates. These values
    are passed to the `canvas.move()` method and saved again in the `dnd_item` field:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置项目应该移动的距离，我们计算当前事件位置与先前存储的坐标之间的差异。这些值传递给`canvas.move()`方法，并再次保存在`dnd_item`字段中：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There are some variations of this drag and drop functionality that also implement
    a handler for the `<ButtonRelease-1>` sequence, which unsets the currently dragged
    item.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些变体的拖放功能，还实现了`<ButtonRelease-1>`序列的处理程序，该处理程序取消当前拖动的项目。
- en: However, this is not necessary because once this type of event occurs, the `<Button1-Motion>`
    binding will not be triggered until an item is clicked again. This also saves
    us from checking whether `dnd_item` is not `None` at the beginning of the `button_motion()`
    handler.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并非必要，因为一旦发生这种类型的事件，直到再次单击项目，`<Button1-Motion>`绑定将不会触发。这也使我们免于在`button_motion()`处理程序的开头检查`dnd_item`是否不是`None`。
- en: There's more...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is possible to improve this example by adding some basic validations, such
    as verifying that users cannot drop an item outside of the canvas visible area.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过添加一些基本验证来改进此示例，例如验证用户不能将项目放在画布可见区域之外。
- en: 'To implement this, you can use the patterns we have covered in previous recipes
    to calculate the canvas width and height and verify that the final position of
    the item is inside a valid range by chaining the comparison operators. You can
    use the structure shown in the following snippet as a template:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，您可以使用我们在以前的配方中介绍的模式来计算画布的宽度和高度，并通过链接比较运算符来验证项目的最终位置是否在有效范围内。您可以使用以下代码段中显示的结构作为模板：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: See also
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Moving canvas items* recipe
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*移动画布项目*配方'
- en: Rendering a canvas into a PostScript file
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将画布渲染成PostScript文件
- en: The `Canvas` class natively supports saving its contents using the PostScript
    language via its `postscript()` method. This stores the graphical representation
    of canvas items, such as lines, rectangles, polygons, ovals, and arcs, however,
    it does not do so for embedded widgets and images.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`类通过其`postscript()`方法本地支持使用PostScript语言保存其内容。这会存储画布项目的图形表示，如线条、矩形、多边形、椭圆和弧，但不会对嵌入式小部件和图像进行存储。'
- en: We will modify a previous recipe that dynamically generates this type of simple
    items to add the functionality to save a representation of the canvas into a PostScript
    file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改一个之前的配方，动态生成这种简单项目的功能，以添加将画布的表示保存到PostScript文件的功能。
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will take the code sample from the *Drawing lines and arrows* recipe to
    add a button to print the canvas contents to a PostScript file:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从*绘制线条和箭头*配方中获取代码示例，以添加一个按钮，将画布内容打印到PostScript文件中：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The main addition to the original script is the `Render canvas` button with
    the `render_canvas()` callback.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 原始脚本的主要添加是带有`render_canvas()`回调的`Render canvas`按钮。
- en: 'It calls the `postscript()` method on the `canvas` instance with the `file`
    and `colormode` arguments. These options specify the path to the destination file
    that writes the PostScript and the output color information, which could be `"color"`
    for full color output, `"gray"` to translate to gray-scale equivalents, and `"mono"`
    to convert all colors to black or white:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 它在`canvas`实例上调用`postscript()`方法，并使用`file`和`colormode`参数。这些选项指定了写入PostScript和输出颜色信息的目标文件的路径，可以是`"color"`表示全彩输出，`"gray"`表示转换为灰度等效，`"mono"`表示将所有颜色转换为黑色或白色：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can check all the valid options that can be passed to the `postscript()`
    method on the Tk/Tcl documentation at [https://www.tcl.tk/man/tcl8.6/TkCmd/canvas.htm#M61](https://www.tcl.tk/man/tcl8.6/TkCmd/canvas.htm#M61).
    Bear in mind that PostScript is a language primarily aimed to be printed, so most
    options refer to page settings.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Tk/Tcl文档的`postscript()`方法中检查所有可以传递的有效选项，网址为[https://www.tcl.tk/man/tcl8.6/TkCmd/canvas.htm#M61](https://www.tcl.tk/man/tcl8.6/TkCmd/canvas.htm#M61)。请记住，PostScript是一种主要用于打印的语言，因此大多数选项都是指页面设置。
- en: There's more...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Since PostScript files are not as popular as other file formats, you might want
    to convert the generated file from PostScript to a more familiar format such as
    PDF.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PostScript文件不像其他文件格式那样流行，您可能希望将生成的文件从PostScript转换为更熟悉的格式，如PDF。
- en: To do so, you need a third-party software, such as **Ghostscript**, which is
    distributed under GNU's **Affero General Public License** (**AGPL**). Ghostscript's
    interpreter and renderer utilities can be invoked from your program to automatically
    convert the PostScript result to PDF.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，您需要一个第三方软件，比如**Ghostscript**，它是根据GNU的**Affero通用公共许可证**（**AGPL**）分发的。
    Ghostscript的解释器和渲染器实用程序可以从您的程序中调用，自动将PostScript结果转换为PDF。
- en: Download and install the latest version of the software from[ https://www.ghostscript.com/download/gsdnld.html](https://www.ghostscript.com/download/gsdnld.html) and
    add the `bin` and `lib` folders of the installation into your operating system
    path.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://www.ghostscript.com/download/gsdnld.html](https://www.ghostscript.com/download/gsdnld.html)下载并安装软件的最新版本，并将安装的`bin`和`lib`文件夹添加到操作系统路径中。
- en: 'Then, modify your Tkinter application to call the `ps2pdf` program as a subprocess
    and remove the `output.ps` file when it finish its execution, as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改您的Tkinter应用程序，调用`ps2pdf`程序作为子进程，并在执行完毕时删除`output.ps`文件，如下所示：
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
