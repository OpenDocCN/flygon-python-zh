- en: Flow Control - Building a Decision Maker For Your Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程控制 - 为你的游戏构建决策制造者
- en: One of the greatest blessings of Python is automation. When we talk about automation,
    there is no staggering logic; it's all about the power of conditionals and branching.
    They control sequencing when it comes to the execution of programs. Any program
    at its rudimentary stage is made with a simulation. Whenever we deploy such programs
    in a real-world environment, we are overwhelmed by various noises and unexpected
    behaviors. To preclude such behavior, conditionals play a major role. Flow controls
    decide how to execute a specific part of a program based on the Boolean logic
    that's present. We covered topics such as statements and operators in the previous
    chapter, both of which are useful when it comes to creating Boolean logic. Such
    statements are used to perform arithmetic computation. In this chapter, we will
    see how to manipulate such statements, which will result in true or false Boolean
    logic.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python最大的福祉之一是自动化。当我们谈论自动化时，没有令人震惊的逻辑；一切都取决于条件和分支的力量。它们控制程序执行时的顺序。任何程序在其基本阶段都是通过模拟制作的。每当我们在真实环境中部署这些程序时，我们都会被各种噪音和意外行为所压倒。为了防止这种行为，条件起着重要作用。流程控制根据当前的布尔逻辑决定如何执行程序的特定部分。我们在上一章中涵盖了语句和运算符等主题，这些主题在创建布尔逻辑时非常有用。这些语句用于执行算术计算。在本章中，我们将看到如何操作这些语句，这将导致真或假的布尔逻辑。
- en: Mid-way through this chapter, we will learn about looping, an important technique
    that will make us competent enough to make code shorter and more powerful. This
    chapter will be a package that's complete with core programming, conditionals,
    and recursive programming. We will refine the tic-tac-toe game we made in the
    previous chapter by incorporating Boolean logic and flow controls.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的中途，我们将学习循环，这是一种重要的技术，可以使我们足够有能力使代码更短更强大。本章将是一个完整的包，其中包括核心编程、条件和递归编程。我们将通过引入布尔逻辑和流程控制来完善上一章中制作的井字棋游戏。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Boolean logic and logical operators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔逻辑和逻辑运算符
- en: Conditionals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句
- en: Iteration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代
- en: '`for` and `while` loops'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 和 `while` 循环'
- en: Making a game controller for our tic-tac-toe game
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的井字棋游戏制作游戏控制器
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following requirements to be able to complete this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下要求才能完成本章：
- en: Python script and IDLE
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python脚本和IDLE
- en: The code assets for this chapter, which can be found at [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter03](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter03)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码资产可以在以下链接找到：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter03](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter03)
- en: 'Check out the following video to see the code in action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的运行情况：
- en: '[http://bit.ly/2pvpBas](http://bit.ly/2pvpBas)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2pvpBas](http://bit.ly/2pvpBas)'
- en: Understanding Boolean logic and logical operators
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解布尔逻辑和逻辑运算符
- en: 'There won''t be a day that goes by without us stating that a Boolean type is
    either `True` or `False`. We use these keywords to make logic that determines
    whether we are going to execute a certain portion of code. Let''s talk about the
    bool type in terms of a real-life scenario. If we are hungry, we eat something.
    If we are tired, we rest. Let''s convert these scenarios into the appropriate
    Boolean statements:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一天会过去我们不会说布尔类型要么是`True`要么是`False`。我们使用这些关键字来制定逻辑，以确定我们是否要执行某部分代码。让我们从现实生活中的角度来谈谈布尔类型。如果我们饿了，我们就吃点东西。如果我们累了，我们就休息。让我们将这些情景转化为适当的布尔语句：
- en: '`is_hungry = True`: `eat something || is_hungry = False: don''t eat`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_hungry = True`：`吃点东西 || is_hungry = False: 不吃`'
- en: '`is_tired = True`: `take rest || is_tired = False: do your work`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_tired = True`：`休息 || is_tired = False: 做你的工作`'
- en: 'You perform these quotidian tasks based on the Boolean logic at hand. Now,
    let''s relate this to programming; you can use two sets of code based on Boolean
    data types:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你根据手头的布尔逻辑执行这些日常任务。现在，让我们把它与编程联系起来；你可以使用两组基于布尔数据类型的代码：
- en: '(`True`): `Do something || (False): Do something`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '(`True`): `做某事 || (False): 做某事`'
- en: 'We use Boolean expressions to make such types of logic. We look at how to create
    expressions in the previous chapter. Combining a variable and an operator will
    give us a simple form of expression, as in this example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用布尔表达式来制作这种类型的逻辑。我们在上一章中看到了如何创建表达式。将变量和运算符结合起来将给我们一个简单的表达式形式，就像这个例子：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Boolean expressions, however, are a bit different. Instead of giving a result
    as an integer, they provide an outcome of either `True` or `False`. The simplest
    form of a Boolean expression can be made with a double equal to operator (`==`).
    Don''t confuse it with a single equal sign (`=`). This is used for assignment,
    while a double equal sign (`==`) is used to check whether they are equal, as in
    the example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，布尔表达式有点不同。它们不是给出整数结果，而是提供`True`或`False`的结果。布尔表达式的最简单形式可以使用双等号运算符(`==`)制作。不要将其与单等号(`=`)混淆。单等号用于赋值，而双等号(`==`)用于检查它们是否相等，就像这个例子：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you compare the data of two different types, the result is always `False`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您比较两种不同类型的数据，结果始终是`False`：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can always type-caste it to make your logic `True`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以始终进行类型转换以使您的逻辑为`True`：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To check the type of any Boolean variable, you can use the `type()` method
    and get the output of `<class ''bool''>`, which implies that `True` or `False`
    are values of the bool type:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查任何布尔变量的类型，可以使用`type()`方法并获得`<class 'bool'>`的输出，这意味着`True`或`False`是布尔类型的值：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Boolean logic can also be used with comparison operators. We will learn how
    to create statements using **comparison operators** in the next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔逻辑也可以与比较运算符一起使用。我们将在下一节中学习如何使用**比较运算符**创建语句。
- en: Comparison operators
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较运算符
- en: 'Any expression that results in either `True` or `False` is a Boolean expression.
    These Boolean expressions cannot be made without comparison and logical operators.
    We''ve already looked at the basic comparison operator (`==`); however, there
    are six more we need to learn about (`<`, `>`, `<=`, `>=`, `!=`, and `is`). Let''s
    take a look at them in action:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 任何结果为`True`或`False`的表达式都是布尔表达式。这些布尔表达式不能没有比较和逻辑运算符。我们已经看过基本的比较运算符（`==`）；然而，还有六个我们需要了解的（`<`、`>`、`<=`、`>=`、`!=`和`is`）。让我们看看它们的运行情况：
- en: '**5 < 10**: 5 is less than 10, which results in `True`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5 < 10**：5小于10，结果为`True`。'
- en: '**5 > 10**: 5 is greater than 10, which results in `False`.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5 > 10**：5大于10，结果为`False`。'
- en: '**10 <= 5**: 10 is less than or equal to 5, which results in `False`. 10 is
    neither less than nor equal to 5.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**10 <= 5**：10小于或等于5，结果为`False`。10既不小于也不等于5。'
- en: '**10 >= 5**: 10 is greater than or equal to 5, which results in `True`. 10
    is greater than 5.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**10 >= 5**：10大于或等于5，结果为`True`。10大于5。'
- en: '**10 != 10**: 10 is not equal to 10, which results in `False`. 10 is equal
    to 10.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**10 != 10**：10不等于10，结果为`False`。10等于10。'
- en: '**5 is 5**: 5 is the same as 5, so this results in `True`. However, `5` is
    5, and so this results in `False`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5是5：5和5相同，所以结果是`True`。然而，`5`是5，所以结果是`False`。
- en: 'You can store the preceding numbers in different variables and try the same
    Boolean expression on the IDLE to get the following results:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将前面的数字存储在不同的变量中，并在IDLE上尝试相同的布尔表达式，以获得以下结果：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In order to make logic that's applicable to the real world, we need operators
    that can combine different comparison operations at once and provide results instantly.
    These types of operators are called logical operators. In the next section, we
    will learn about the different types of logical operators and the ways we can
    use them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使适用于现实世界的逻辑，我们需要能够同时组合不同的比较操作并立即提供结果的运算符。这些类型的运算符被称为逻辑运算符。在下一节中，我们将学习不同类型的逻辑运算符以及它们的使用方式。
- en: Logical operators
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: Operators are widely categorized as arithmetic operators, comparison operators,
    and logical operators. We've already covered the arithmetic and comparison operators;
    now, it's high time to cover logical operators.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符被广泛分类为算术运算符、比较运算符和逻辑运算符。我们已经涵盖了算术和比较运算符；现在是时候涵盖逻辑运算符了。
- en: 'You can relate logical operators with a logic gate (`and`, `or`, and `not`),
    which is the basic building block of any digital circuit. They have two inputs,
    but with certain circuit computations, we only get one output. Circuit processing
    is done by `and`, `or`, and `not` gates. Similar to the digital circuits of a
    logic gate, logical operators can have many conditions passed with it, but the
    output will eventually be either `True` or `False`. Here, `conditions` refer to
    our Boolean expression, which we make using comparison operators. The working
    principles of these three elementary logical operators are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将逻辑运算符与逻辑门（`and`、`or`和`not`）联系起来，逻辑门是任何数字电路的基本构建模块。它们有两个输入，但是通过某些电路计算，我们只得到一个输出。电路处理是通过`and`、`or`和`not`门完成的。类似于逻辑门的数字电路，逻辑运算符可以有许多条件传递，但最终输出将是`True`或`False`。这里，`conditions`指的是我们使用比较运算符制作的布尔表达式。这三种基本逻辑运算符的工作原理如下：
- en: '`and`: Two conditions are attached with a single `and` operator, that is, `condition_one` and
    `condition_two`. The entire condition will be `True` when each of these conditions
    is also `True`. If either of the conditions that are attached to the `and` operator
    is `False`, the result will be `False`. Let''s take a look at an example:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`and`：两个条件用一个`and`运算符连接，即`condition_one`和`condition_two`。当这些条件中的每一个也为`True`时，整个条件将为`True`。如果与`and`运算符连接的条件中的任一条件为`False`，结果将为`False`。让我们看一个例子：'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The truth table for the `and` operator, which sets out the functional value
    as either `True` or `False` based on a combination of Boolean or logical expressions,
    is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`and`运算符的真值表，根据布尔或逻辑表达式的组合，将其功能值设置为`True`或`False`，如下所示：'
- en: '![](Images/1cbdcdec-5887-4d30-8e9a-2ef49e1d4f70.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1cbdcdec-5887-4d30-8e9a-2ef49e1d4f70.png)'
- en: '`or`: The same as the `and` operator—two conditions are attached with a single
    `or` operator. You can add more `or` operators if you want to add more conditions.
    In the case of the `or` operator, if both of the conditions that are attached
    to it are `False`, the result will be `False`; otherwise, it will be `True`. Let''s
    look at an example:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or`：与`and`运算符相同——两个条件用一个`or`运算符连接。如果要添加更多条件，可以添加更多`or`运算符。对于`or`运算符，如果连接到它的两个条件都为`False`，结果将为`False`；否则，结果将为`True`。让我们看一个例子：'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The truth table for the `or` operator, which sets out the functional value
    to either `True` or `False` based on a combination of Boolean or logical expressions,
    is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`or`运算符的真值表，根据布尔或逻辑表达式的组合，将其功能值设置为`True`或`False`，如下所示：'
- en: '![](Images/e09ac0d2-26f8-4563-ab0b-9db051f44ca0.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e09ac0d2-26f8-4563-ab0b-9db051f44ca0.png)'
- en: '`not`: This operator inverses the type of the logic. It changes `False` to
    `True` and vice versa. Hence, it is called known as a logical inverter. It only
    takes one condition with it, as follows:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not`：这个运算符颠倒逻辑的类型。它将`False`变为`True`，反之亦然。因此，它被称为逻辑反转器。它只带有一个条件，如下所示：'
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The truth table for the `not` operator, which sets out the functional value
    as either `True` or `False` based on a combination of Boolean or logical expressions,
    is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`not`运算符的真值表，根据布尔或逻辑表达式的组合，将其功能值设置为`True`或`False`，如下所示：'
- en: '![](Images/af697950-80c1-49a0-a497-4dd72f8b09d8.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/af697950-80c1-49a0-a497-4dd72f8b09d8.png)'
- en: 'You can also represent `True` and `False` with 1 and 0 in Python. Hence, we
    can conclude that any non-zero integers can be used alone to make a condition
    with logical operators, as in the example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，也可以用1和0表示`True`和`False`。因此，我们可以得出结论，任何非零整数都可以单独使用逻辑运算符来构成条件，就像这个例子：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Learning about the different types of operators was quite fun, but now we are
    going to hop over to the section, where you will learn how to use these conditions
    (made by comparison and logical operators) to make several decisions. **Conditionals** are
    highly practical in any real-world scenario. I'm excited to learn about them—are
    you?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 学习不同类型的运算符非常有趣，但现在我们将转到一个部分，在那里你将学习如何使用这些条件（由比较和逻辑运算符制作）来做出几个决定。**条件语句**在任何现实场景中都非常实用。我很兴奋地想要学习它们，你呢？
- en: Conditionals
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'So far, we''ve learned about making conditions with comparison and logical
    operators. Now, we''ll talk about how we can evaluate these conditions. Conditionals
    are tools that come in handy when we want to compute the result of those conditions
    and control the flow of the program accordingly. As we already know, the results
    of these conditions are going to be either `True` or `False`. So, based on the
    type of bool we use, the conditionals are going to execute some part of the code.
    We use `if` statements in Python to perform conditionals. After writing the `if`
    keyword, we put conditions next to it. The condition can be singular or a combination
    of many with logical operators. We end an `if` statement with a colon; subsequent
    statements are indented property. Take a look at the following example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了使用比较和逻辑运算符制作条件。现在，我们将讨论如何评估这些条件。条件语句是在我们想要计算这些条件的结果并相应地控制程序流程时非常有用的工具。正如我们已经知道的那样，这些条件的结果将是`True`或`False`。因此，根据我们使用的布尔类型，条件语句将执行代码的某部分。我们在Python中使用`if`语句来执行条件语句。在写下`if`关键字后，我们将条件放在其旁边。条件可以是单个的，也可以是许多逻辑运算符的组合。我们用冒号结束`if`语句；随后的语句应该正确缩进。看看以下例子：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following figure represents a boolean logic for implementing conditional
    statements:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了实现条件语句的布尔逻辑：
- en: '![](Images/d2d8c293-c7ed-4118-b193-d5916ac3e0aa.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d2d8c293-c7ed-4118-b193-d5916ac3e0aa.png)'
- en: 'Take note of the following while using Python:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Python时，请注意以下事项：
- en: '**Colon (`:`)**: If you want to declare scope in Python, inside where you can
    write more than one statement, you need to use a colon (*`:`)* to specify it.
    Most of the programming language uses curly braces (`{ }`) for this, but Python
    is strange when it comes to defining scope and the extent of block statements
    for features such as functions, `if` statements, classes, and loops. However,
    once you get familiar with using this, you will find it amusing and be able to
    distinguish code written in Python from any other language within a second.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冒号（`:`）**：如果你想在Python中声明作用域，在其中可以编写多个语句，你需要使用冒号（`:`）来指定。大多数编程语言使用花括号（`{}`）来实现这一点，但是Python在定义作用域和块语句的范围时有些奇怪，比如函数、`if`语句、类和循环。然而，一旦你熟悉使用这个，你会觉得很有趣，并且能够在一秒钟内区分出用Python编写的代码和其他语言的代码。'
- en: '**Indentation** (**whitespaces**): After we define the scope with a colon,
    we can enter its scope. Any subsequent statements that are written within its
    scope should start with uniform white spaces, which we call indents. You can press
    the *Tab* key to give each statement a uniform indentation. Most of the errors
    that beginners make are due to improper indentation. If you don''t provide the
    proper indentation, you will get the following warning from the Python interpreter:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩进**（**空格**）：在我们用冒号定义作用域之后，我们可以进入其作用域。在其作用域内编写的任何后续语句都应以统一的空格开始，我们称之为缩进。你可以按下*Tab*键为每个语句提供统一的缩进。大多数初学者犯的错误都是由于不正确的缩进。如果你没有提供正确的缩进，你将会收到Python解释器的以下警告：'
- en: '![](Images/81e98a1c-8db6-49eb-b492-3f99c28b1b76.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/81e98a1c-8db6-49eb-b492-3f99c28b1b76.png)'
- en: 'If statements evaluate logical statements. Whenever that statement is true,
    its indented statement will be executed; otherwise, it will be skipped. You can
    also add the `pass` keyword to tell the interpreter not to execute anything inside
    the indented block, as in this example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`If`语句评估逻辑语句。每当该语句为真时，将执行其缩进的语句；否则，将被跳过。你还可以添加`pass`关键字，告诉解释器不要执行缩进块内的任何内容，就像这个例子一样：'
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As we already know, Boolean statements will either will result in `True` or
    `False`. Indented code inside an `if` statement will be executed if the condition
    is `True`, but if the condition is `False`, the indented code inside the `else`
    part will be executed. Let''s take a look at an example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，布尔语句将产生`True`或`False`。如果条件为`True`，则`if`语句内的缩进代码将被执行，但如果条件为`False`，则`else`部分内的缩进代码将被执行。让我们看一个例子：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Following figure represents the flowchart for implementing program to check
    whether number is positive or negative using conditional statements:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了使用条件语句实现检查数字是正数还是负数的程序的流程图：
- en: '![](Images/a14660a0-236f-4200-9c72-966bfc0face3.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a14660a0-236f-4200-9c72-966bfc0face3.png)'
- en: You can see that we have created two branches of conditions for the `True` or
    `False` logic. Based on the result of the Boolean logic, flow control is transferred
    to either side of a program. Hence, conditionals are also called *branching*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们已经为`True`或`False`逻辑创建了两个条件分支。根据布尔逻辑的结果，流程控制被转移到程序的两侧。因此，条件语句也被称为*分支*。
- en: 'Although our code is able to execute the code with two branches, there is a
    little gap in our code. If the number variable contains zero, it is neither positive
    or negative. Therefore, we have to add one more condition to this conditional.
    Whenever we need more than two branches for the computation of logic, we can make
    chained conditionals. We can add as many conditions as we like with a chained
    sequence. To perform chained conditionals with any other programming language,
    we use the `else if` command. Python improvises by making different commands with
    `elif`. Let''s take a look at an example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的代码能够执行具有两个分支的代码，但我们的代码中存在一些小差距。如果数字变量包含零，则既不是正数也不是负数。因此，我们必须为此条件添加一个条件。每当我们需要计算逻辑的两个以上分支时，我们可以进行链接条件。我们可以使用链接序列添加任意数量的条件。要使用任何其他编程语言执行链接条件，我们使用`else
    if`命令。Python通过使用`elif`制作不同的命令。让我们看一个例子：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can put any number of conditionals within one conditional statement. We
    call these nested conditionals. Let''s take a look at an example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个条件语句中放置任意数量的条件。我们称这些为嵌套条件。让我们来看一个例子：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding example, the outer conditional contains two sub-branch conditions
    where, in the first branch, we check for an even number. The next default condition
    is checked for an odd number. We use a simple single statement to make a condition
    in this example, but conditions in nested conditionals can be made complex with
    logical operators, as in this example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，外部条件包含两个子分支条件，在第一个分支中，我们检查偶数。下一个默认条件是检查奇数。在这个例子中，我们使用一个简单的单一语句来制定条件，但是在嵌套条件中，条件可以通过逻辑运算符变得复杂，就像这个例子中一样：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that you know how to make decisions with several conditional statements,
    we will take a look at a highly practical topic known as **iteration**. This allows
    us to execute a sequence of instructions. This is repeated until a certain condition
    is reached.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何使用多个条件语句做出决策，我们将看一下一个非常实用的主题，称为**迭代**。这使我们能够执行一系列指令。这将重复执行，直到达到某个条件为止。
- en: Iteration
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代
- en: 'Let''s say you want to write a program where you have to print your name 100
    times. What we have learned so far dictates that the easiest way to do this is
    to use the print statement 100 times. But what if you want to print your name
    10,000 times? Writing a print statement for 2/3 pages continuously is not good
    programming. We have to use loops in such a case. Loops will help us to iterate
    over datasets until a condition is met. In each iteration, a part of the code
    is executed and we have to update the iterating variable each time. The following
    is an example of iterating over a variable:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想写一个程序，你必须打印你的名字100次。到目前为止，我们所学到的规定，最简单的方法是使用打印语句100次。但是如果你想打印你的名字10000次呢？连续写2/3页的打印语句不是好的编程。在这种情况下，我们必须使用循环。循环将帮助我们在数据集上进行迭代，直到满足条件。在每次迭代中，执行代码的一部分，并且我们必须每次更新迭代变量。以下是一个迭代变量的示例：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We update the iterating variable with an increment and decrement unit. Here,
    we update the value of `i` by adding `1` to it. This is known as incrementing.
    You can also subtract 1 from it, which is known as decrementing. Each time we
    execute code inside indented loops, we update the iteration using either increment
    or decrement statements.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用增量和减量单位更新迭代变量。在这里，我们通过将`1`加到`i`的值来更新`i`的值。这被称为增量。您也可以从中减去1，这被称为减量。每次我们在缩进循环中执行代码时，我们使用增量或减量语句更新迭代。
- en: 'Similarly, there is a comparatively easier and faster way of implementing increment
    and decrement statements. You can use the following statements to perform multiple
    operations:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，有一种相对更简单和更快的实现增量和减量语句的方法。您可以使用以下语句执行多个操作：
- en: '`+=` adds a number to the variable and changes the variables in its process.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+=`将一个数字添加到变量中，并在其过程中更改变量。'
- en: '`-=` subtracts the variable with a value and sets the new value to its resulting
    variable.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-=`将变量与一个值相减，并将新值设置为其结果变量。'
- en: '`*=` multiplies the variable by a value and changes the outcome of the variable.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*=`将变量乘以一个值，并改变变量的结果。'
- en: '`/=` divides the variable with the value and places the result on the resulting
    variable.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/=`将变量与值相除，并将结果放在结果变量上。'
- en: 'Let''s look at an example to see its effect:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子来看看它的效果：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The effectiveness of the increment and decrement operators can be seen with
    looping, where we repeat a set of operations multiple times. Let's take a look
    at looping in action with for and while loops. We will begin by learning about
    the `for` loop.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 增量和减量运算符的有效性可以通过循环看出，我们多次重复一组操作。让我们看看使用for和while循环的循环。我们将首先学习`for`循环。
- en: Th for loop
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for循环
- en: 'Whenever you want to loop within a dataset, let''s say, within a range of numbers,
    within a certain file, or within some definite word sets, we use a `for` loop.
    It is also referred to as a definite loop. Until and unless there is certain item
    left in your bucket of items, it will iterate. The `for` loop is terminated at
    the end of the bucket. Here, bucket is a metaphor for a list of items, such as
    a list of numbers, words, or sequences, as in this example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你想在数据集中循环，比如在一系列数字范围内，在某个文件中，或者在一些确定的单词集合中，我们使用`for`循环。它也被称为确定循环。除非你的项目桶中还有某个项目，否则它将迭代。`for`循环在桶的末尾终止。在这里，桶是一个代表项目列表的隐喻，比如数字列表、单词列表或序列，就像这个例子中：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, the `range()` method is used to create a list of numbers.
    `range(10)` provides a list of numbers from `0` to `9`. It is stored as `[0,1,2,3,4,5,6,7,8,9]`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`range()`方法用于创建一个数字列表。`range(10)`提供了一个从`0`到`9`的数字列表。它被存储为`[0,1,2,3,4,5,6,7,8,9]`。
- en: 'In the first iteration, the `i` value becomes `0`, it executes code within
    the block of the `for` loop, and changes the value of `i` to the next element
    of that list automatically, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迭代中，`i`的值变为`0`，它执行`for`循环块中的代码，并自动更改`i`的值为该列表的下一个元素，如下所示：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can also loop within data that contains words or text. The iterating variable
    will contain a value as a word each time we loop within that list, as in this
    example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在包含单词或文本的数据中进行循环。在我们循环列表中的每个单词时，迭代变量将包含一个单词作为值，就像这个例子中一样：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding example, the iterating variable is a `name` variable and,
    every time it iterates through that list, it fetches its value and stores it in
    `name`. Hence, we can only use the `name` variable inside the body of our `for`
    loop. No other variable can be used except the iterating variable inside the `for`
    loop. This is shown in the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，迭代变量是`name`变量，每次它在列表中迭代时，它都会获取它的值并将其存储在`name`中。因此，我们只能在`for`循环的主体中使用`name`变量。除了`for`循环中的迭代变量之外，不能使用其他变量。这在下面的代码中显示：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding example, `person_names` is a type of variable where we can
    store an array of items. This variable is called a list. We will cover lists in
    the next chapter. Here, the iterating variable is `name`, which is declared with
    a `for` loop. However, inside the body of a for loop, we didn't use the `name` variable.
    Instead, we used `person_names`, which gave us `NameError`. Hence, iterating variables
    can be only used inside the body of a `for` loop.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`person_names`是一种可以存储数组项的变量类型。这个变量被称为列表。我们将在下一章中介绍列表。这里，迭代变量是`name`，它是用`for`循环声明的。然而，在for循环的主体中，我们没有使用`name`变量。相反，我们使用了`person_names`，这导致了`NameError`。因此，迭代变量只能在`for`循环的主体中使用。
- en: The next type of loop we will cover is the `while` loop, which will perform
    operations similar to the `for` loop but with some tweaks. The `while` loop is
    known to be used in scenarios where we don't care about the terminating point
    of loops.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的下一种循环类型是`while`循环，它将执行类似于`for`循环的操作，但有一些调整。`while`循环通常用于我们不关心循环终止点的情况。
- en: While loop
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: while循环
- en: 'Another form of iteration in Python can be performed using a `while` loop.
    Let''s recall the features of a `for` loop: it''s used to iterate over a finite
    sequence of elements, either as a list of numbers, words, or files. There has
    to be a termination point if you want to use a `for` loop. We also don''t care
    about the terminating condition while using `for` loops. It''s terminated when
    it reaches to end of the items or sequences. Now, what if we want to terminate
    the loop based on custom conditions? The `while` loop is the most appropriate
    loop in such cases. We can make a custom condition where we can terminate recursion
    with the help of a `while` loop.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的另一种迭代形式可以使用`while`循环来执行。让我们回顾一下`for`循环的特点：它用于迭代有限序列的元素，无论是作为数字、单词或文件的列表。如果要使用`for`循环，必须有一个终止点。在使用`for`循环时，我们也不关心终止条件。当它达到项目或序列的末尾时，它就会终止。那么，如果我们想要根据自定义条件终止循环呢？在这种情况下，`while`循环是最合适的循环。我们可以制定一个自定义条件，在这个条件下，我们可以使用`while`循环来终止递归。
- en: 'Both the `while` and `for` loops are going to perform incessant looping. At
    each iteration, they are going to execute body of loop. The main difference between
    the `for` and `while` loop is that the `while` loop has to declare the update
    statement and terminating condition with its declaration. First of all, we have
    to make an iterating variable, and then we have to make a terminating condition
    in order to specify a stopping point for the loop. At each iteration, we have
    to update the iterating variable, like so:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`和`for`循环都将执行不断的循环。在每次迭代中，它们都将执行循环的主体。`for`和`while`循环的主要区别在于，`while`循环必须在声明中声明更新语句和终止条件。首先，我们必须创建一个迭代变量，然后我们必须创建一个终止条件，以指定循环的停止点。在每次迭代中，我们必须更新迭代变量，就像这样：'
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, we created an iterating variable, `i`, and assigned
    a value of 0 to it. After that, we made use of a `while` loop. To use this loop,
    we used the `while` keyword and followed that by its terminating condition. We
    tell the interpreter we want to run this loop until `i` is less than 10\. If `i`
    is equal to or greater than 10, we want to terminate this loop.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们创建了一个迭代变量`i`，并将其赋值为0。之后，我们使用了`while`循环。为了使用这个循环，我们使用了`while`关键字，然后跟着它的终止条件。我们告诉解释器，我们希望运行这个循环，直到`i`小于10。如果`i`等于或大于10，我们希望终止这个循环。
- en: 'After that, we put a colon to specify the scope for our loop. Then, we added
    a simple print statement to it, which will be executed each time this loop runs.
    Finally, we added an *i = i + 1* statement to specify the updating condition.
    This is going to change the value of `i` into the new one with an increment of
    one. This is important so that we don''t end up using an infinite loop. If you
    remove your updating condition, the loop is going to run an infinite amount of
    times and the Python Terminal isn''t going to be interactive to a user''s response.
    One way of creating an infinite loop is by using a condition that has no endpoint,as
    in this example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们加上一个冒号来指定我们循环的范围。然后，我们为它添加了一个简单的打印语句，每次运行这个循环时都会执行。最后，我们添加了一个*i = i + 1*语句来指定更新条件。这将改变`i`的值为新值，并增加一。这很重要，这样我们就不会陷入无限循环。如果删除更新条件，循环将无限次运行，Python终端将不会对用户的响应进行交互。创建无限循环的一种方法是使用没有终点的条件，就像这个例子中一样：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding loop is an infinite loop as there is no endpoint or termination
    point attached to the `while` keyword. If we are able to change the `True` keyword
    to `False`, only this loop is going to terminate:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的循环是一个无限循环，因为`while`关键字没有终点或终止点。如果我们能够将`True`关键字更改为`False`，那么这个循环就会终止：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the next section, we'll learn about the looping pattern so that we can find
    out about how loop works under the hood.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习循环模式，以便了解循环在底层是如何工作的。
- en: Loop pattern
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环模式
- en: There may be trade-offs between the `for` and `while` loops, but both work well
    when we want to loop around a known list of elements or the content of files.
    We can arrange or sort the elements out of the list or file using these loops.
    A `for` loop cannot be made to loop an infinite amount of times, but a `while`
    loop can do so using a condition that is never going to be. The main purpose of
    looping is to get items from particular files or lists so that we can process
    them further. We can sort these items based on smallest and largest or important
    and superfluous while scanning datasets.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`和`while`循环之间可能存在权衡，但在我们想要循环遍历已知元素列表或文件内容时，两者都能很好地工作。我们可以使用这些循环来排列或排序列表或文件中的元素。`for`循环不能无限次循环，但`while`循环可以使用永远不会发生的条件来实现。循环的主要目的是从特定文件或列表中获取项目，以便我们可以进一步处理它们。我们可以根据扫描数据集时的最小和最大值或重要和多余的值对这些项目进行排序。'
- en: 'The construct of the loop pattern contains the following three pinpoints:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 循环模式的构造包含以下三个要点：
- en: Making an iterating variable. There can be one or more. They are used to make
    the conditions that represent the loop's terminating point.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个迭代变量。可以有一个或多个。它们用于构造表示循环终止点的条件。
- en: Some computation is done inside the body of the loop so that we can manipulate
    the data items that are fetched with the loop one by one. We can also change the
    value of the iterating variable inside the loop's body, which we normally do in
    the case of a `while` loop.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环体内部进行一些计算，以便我们可以逐个操作循环获取的数据项。我们还可以在循环体内部更改迭代变量的值，这在`while`循环的情况下通常会这样做。
- en: Look for the possible base condition so that the loop can be terminated. Otherwise,
    it will result in an infinite loop. We have to observe the resulting variable
    after the loop ends.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找可能的基本条件，以便终止循环。否则，将导致无限循环。我们必须观察循环结束后的结果变量。
- en: If you want to demonstrate the construct and working paradigm of loop patterns,
    it's always a good idea to use loops with a list of items. In the following example,
    we are going to make a program where we will take a list of numbers and check
    for the smallest number in the list.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要演示循环模式的构造和工作范例，最好使用带有项目列表的循环。在下面的示例中，我们将编写一个程序，该程序将获取一个数字列表并检查列表中的最小数。
- en: 'We can do this in two ways. Python makes programming easy for both types of
    people: the naive or the professional. They have various ways of implementing
    the same logic, but the most common is to use Python''s built-in methods, such
    as `min()` and `max()`. These get the smallest and largest number from the list
    of numbers in Python, respectively:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用两种方法做到这一点。Python使得编程对于天真或专业人士都很容易。他们有各种实现相同逻辑的方法，但最常见的是使用Python的内置方法，如`min()`和`max()`。它们分别从Python的数字列表中获取最小和最大的数字。
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second way to write program is by making our own logic. We should instantly
    make a decision to use loops as there are many items in this list, which means
    we have to do some comparison repeatedly. Hence, it''s always better to use looping
    if you want to perform a task repeatedly. Now, we need to decide on what to use:
    a `for` or a `while` loop. It''s better to use a `for` loop here because for loops
    work on finite lists. Each time we iterate over an iterating variable, it will
    contain an element from the list so that we can compare them with the previous
    element repeatedly. At first, we won''t have anything to be the smallest number.
    Hence, we have to make a variable that will contain a `None` value. This means
    we won''t have any value. After the first iteration, we will assign its value
    to the first element of the list. Let''s see how it works:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 编写程序的第二种方法是制定我们自己的逻辑。由于此列表中有许多项目，因此我们应立即决定使用循环，这意味着我们必须重复进行一些比较。因此，如果要重复执行任务，最好使用循环。现在，我们需要决定使用`for`还是`while`循环。在这里最好使用`for`循环，因为`for`循环适用于有限列表。每次迭代迭代变量时，它将包含列表中的一个元素，以便我们可以重复与前一个元素进行比较。一开始，我们没有任何东西可以作为最小数。因此，我们必须创建一个变量，其中将包含`None`值。这意味着我们没有任何值。第一次迭代后，我们将其值分配给列表的第一个元素。让我们看看它是如何工作的：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s break down the preceding code into the following segments:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把前面的代码分解成以下几个部分：
- en: In the first statement, `smallest_number = None` is assigning `None` to that
    comparing variable. We assigned `None` instead of any other number so that we
    don't miss any numbers while comparing.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一条语句中，`smallest_number = None`将`None`赋值给比较变量。我们使用`None`而不是其他任何数字，以便在比较时不会漏掉任何数字。
- en: In the second statement, we made `item` an iterating variable, which is going
    to read a list of numbers. At each iteration, it is going to store elements from
    that list. In the first iteration, the value of the item is 113\. In the second
    iteration, the value of the item is 115; at the third iteration, the value is
    55; and so on.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二条语句中，我们将`item`作为迭代变量，它将读取一个数字列表。在每次迭代中，它将存储该列表中的元素。在第一次迭代中，item的值为113。在第二次迭代中，item的值为115；在第三次迭代中，值为55；依此类推。
- en: We are now inside the body of our `for` loop, where we have to build a comparison
    statement. First, we need to check whether the smallest number is `None` to make
    sure we are starting from the base. After that, we are going to check whether
    the current item from the list is smaller than `smallest_number`. The first iteration's
    second condition is False, but the first condition, that is, `smallest_number`,
    is `None`, that is, True, which means we are going inside the body of the conditionals.
    We will assign `smallest_value` to the first item of the list, that is, 113.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在在`for`循环的循环体内部，需要构建一个比较语句。首先，我们需要检查最小数是否为`None`，以确保我们从基础开始。之后，我们将检查列表中的当前项目是否小于`smallest_number`。第一次迭代的第二个条件为False，但第一个条件，即`smallest_number`为`None`，即为True，这意味着我们将进入条件体。我们将`smallest_value`赋值为列表的第一个项目，即113。
- en: In the second iteration, the item is 115\. We are going inside the `for` loop
    and checking whether 115 is smaller than the value of `smallest_numbe`, which
    is 113\. This is `False`, and so it doesn't go inside the conditional's body;
    instead, it jumps to the third iteration.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二次迭代中，项目是115。我们进入`for`循环并检查115是否小于`smallest_numbe`的值，即113。这是`False`，因此它不会进入条件的主体；相反，它跳到第三次迭代。
- en: In the third iteration, the item is 55\. We are going to check for the condition,
    which is going to check whether the value of the item, that is, 55, is less than
    that of `smallest_number`, which is 113\. The condition (55 < 113) is `True`,
    and so it changes the value of the `smallest_number` variable to 55\. The `for`
    loop is going to iterate until the last number of that list. It is going to use
    the same comparison operation at each iteration to give us the smallest value,
    that is, 55.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三次迭代中，项目是55。我们将检查条件，即检查项目的值（即55）是否小于`smallest_number`的值，即113。条件（55 <113）为`True`，因此将`smallest_number`变量的值更改为55。`for`循环将迭代直到该列表的最后一个数字。它将在每次迭代中使用相同的比较操作，以给出最小值，即55。
- en: 'With just a change in the comparison operator, we can make a program that will
    print the largest number from the list. Instead of using the `item < smallest_number` statement,
    we can use the `item > largest_number` statement to get the largest number as
    follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仅更改比较运算符，我们可以编写一个程序，该程序将打印列表中的最大数字。我们可以使用`item > largest_number`语句而不是使用`item
    < smallest_number`语句来获取最大数字，如下所示：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the next section, we'll look at how to use two different statements, **break
    and continue**, in order to change or skim the sequence of iteration.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何使用两个不同的语句**break和continue**，以改变或跳过迭代的顺序。
- en: The break and continue statements
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断和继续语句
- en: 'While writing programs, sometimes, you want to skip the execution of statements
    or stop the iteration forcefully. These operations are handled by the continue
    and break statements. They can be powerful in multiple use cases where you want
    to make a program sort the elements of a list or to break the loop when an `if`
    condition is met. The `continue` statement is used to skip the execution of the
    program. We use these statements inside the body of loops. We can sort elements
    out of lists using these statements. We can''t use both of these statements in
    a single loop, even if we use both of them together since the break is going to
    stop the loop, which will make the continue statement useless. We can use these
    statements with conditionals. Whenever a condition is met, we are going to either
    break or skip the iteration. Let''s make a program that can sort the elements
    of a list:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写程序时，有时您希望跳过语句的执行或强制停止迭代。这些操作由`continue`和`break`语句处理。它们可以在多种用例中发挥作用，例如当您希望使程序对列表的元素进行排序或在满足`if`条件时中断循环。`continue`语句用于跳过程序的执行。我们在循环的主体内使用这些语句。我们可以使用这些语句将元素从列表中排序出来。即使我们使用这两个语句，由于`break`将停止循环，使`continue`语句无效，因此我们不能在单个循环中使用这两个语句。我们可以在条件语句中使用这些语句。每当满足条件时，我们要么中断要么跳过迭代。让我们编写一个可以对列表的元素进行排序的程序：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, we are refining the elements of a list by keeping the
    integer numbers in the output list. Other data values, such as strings and Booleans
    are removed. First, we looped an entire list and at each iteration, the element
    is stored in the item variable. We check the type of data that are stored in the
    item variable with the `type()` method. If the type of the value that's stored
    in the item is not an integer, we are using the continue statement to infer that
    we won't do anything if it is not an integer. If the type of item is a Boolean
    or string, we are skipping that iteration with the continue statement. However,
    if the type of the value that's stored in an item variable is an integer, we are
    going to execute the statement that's inside the else part of the code. We are
    going to take that integer item and add it to the new output list, which is called `refined_items`.
    After each element is checked, we print the refined list, which is the ultimate
    collection of numbers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们通过在输出列表中保留整数来完善列表的元素。其他数据值，如字符串和布尔值，都被删除。首先，我们循环整个列表，并在每次迭代时将元素存储在项目变量中。我们使用`type()`方法检查存储在项目变量中的数据的类型。如果存储在项目中的值的类型不是整数，则使用`continue`语句来推断如果不是整数，则不执行任何操作。如果项目的类型是布尔值或字符串，则使用`continue`语句跳过该迭代。但是，如果存储在项目变量中的值的类型是整数，则将执行代码的else部分中的语句。我们将取该整数项目并将其添加到名为`refined_items`的新输出列表中。在检查每个元素之后，我们打印精炼的列表，这是数字的最终集合。
- en: 'If you use a `break` statement instead, things will be the same until element
    8\. But instead of printing other elements from `[89,90,11]`, our output will
    be limited to `[1,5,7,8]`. This is because the `break` statement is going to stop
    iteration after appending element 8 to the list. Hence, we can conclude that whenever
    the Python interpreter triggers a break statement, the loop is going to be terminated:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`break`语句，直到元素8之前的情况将保持不变。但是，我们的输出将受限于`[1,5,7,8]`，而不是打印其他元素`[89,90,11]`。这是因为`break`语句将在将元素8附加到列表后停止迭代。因此，我们可以得出结论，每当Python解释器触发`break`语句时，循环将终止：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We know that, while deploying programs in a real-world environment, such programs
    will be accustomed to a different scenario that our code won't be able to handle.
    In such a case, our program will terminate, which will have a negative impact
    on the user or player of the game. Hence, we have to code in such a way that our
    code can be applied to any scenario, even when it encounters unexpected errors
    or exceptions. This type of powerful technique in programming is known as **exception
    handling** and is what we will cover in the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，在实际环境中部署程序时，这些程序将习惯于我们的代码无法处理的不同情况。在这种情况下，我们的程序将终止，这对用户或游戏玩家会产生负面影响。因此，我们必须以这样的方式编写代码，使我们的代码可以适用于任何情况，即使遇到意外错误或异常。编程中的这种强大技术称为**异常处理**，这是我们将在下一节中介绍的内容。
- en: Handling exceptions using try and except
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用try和except处理异常
- en: 'In the preceding chapter, we created a simple tic-tac-toe game. We talked about
    making some modifications at the end of that chapter. One of the modifications
    was suggested due to the deficiency of the code, which was unable to handle the
    input of a user other than an integer. What if our user enters a string as input
    to the position variable of our game? The following exception will be thrown:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个简单的井字棋游戏。我们在该章节的末尾讨论了一些修改。由于代码的不足，无法处理用户输入除整数以外的情况，因此建议进行一些修改。如果我们的用户将字符串输入为游戏的位置变量，会发生什么？将抛出以下异常：
- en: '![](Images/a6598120-5b6e-40a1-a74b-b0c29d2e055b.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a6598120-5b6e-40a1-a74b-b0c29d2e055b.png)'
- en: 'In the preceding screenshot, we can see that our code was unable to handle
    a string as input by the user. Our code is going to perform well if—and only if—we
    enter an integer. If the user mistakenly enters any other data values, the program
    will crash. The aim of this topic is to handle this type of error. We have two
    types of error: syntax errors and exception errors. The following code shows examples
    of both:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，我们可以看到我们的代码无法处理用户输入的字符串。只有当我们输入整数时，我们的代码才能正常运行。如果用户错误地输入任何其他数据值，程序将崩溃。本主题的目的是处理这种类型的错误。我们有两种类型的错误：语法错误和异常错误。以下代码显示了两种类型的示例：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Whenever you type in the wrong statement, it is going to throw an error message,
    that is, a syntax error. Here, we used two more parentheses than normal to enclose
    the print statement, which is incorrect. Due to this, the Python parser throws
    a syntax error. Remove those extra two parentheses to eradicate the syntax error:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您输入错误的语句时，它都会抛出一个错误消息，即语法错误。在这里，我们使用了比正常情况多两个括号来包围打印语句，这是不正确的。因此，Python解析器会抛出语法错误。删除这两个额外的括号以消除语法错误：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, the Python parser has thrown an exception error. This type of error occurs
    even if your Python syntax is correct. This can be either a mathematical or logical
    error. In mathematics, you cannot divide any number by zero. This results in an
    infinite, which has not been defined by Python. Hence, we ran into an exception.
    There are different types of exceptions. If you want to know the name of the exception
    you ran into, check the last statement of your code after received the exception.
    In our error message, the last statement says `ZeroDivisionError`. Hence, we ran
    into a `ZeroDivisionError` exception. If you run into any of these exceptions,
    then it's likely that your code has crashed. Hence, our game tic-tac-toe has also
    crashed because it was unable to handle input data other than integers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Python解析器抛出了一个异常错误。即使您的Python语法是正确的，也会发生这种错误。这可能是数学错误或逻辑错误。在数学上，您不能将任何数字除以零。这会导致一个无限大，这在Python中没有定义。因此，我们遇到了一个异常。有不同类型的异常。如果您想知道您遇到的异常的名称，请在收到异常后检查代码的最后一条语句。在我们的错误消息中，最后一条语句说`ZeroDivisionError`。因此，我们遇到了一个`ZeroDivisionError`异常。如果您遇到这些异常中的任何一个，那么您的代码很可能已经崩溃。因此，我们的井字棋游戏也崩溃了，因为它无法处理除整数以外的输入数据。
- en: Now, our main aim is to make our code reliable so that even if our code runs
    into an exception, instead of crashing, it gives the user a friendly message.
    In the preceding example, instead of terminating the program, we can send the
    user a message saying `You cannot divide any number by zero`. This process is
    called exception handling. These are done within `try` and `except` blocks in
    Python.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的主要目标是使我们的代码可靠，即使我们的代码遇到异常，也不会崩溃，而是向用户提供友好的消息。在上面的示例中，我们可以发送用户一条消息，说`您不能将任何数字除以零`，而不是终止程序。这个过程称为异常处理。这些都是在Python中的`try`和`except`块中完成的。
- en: 'If you are unsure about the code regarding whether it gave you an error, you
    should always use `try` and `except` blocks. Your main code, which is likely to
    run into exceptions, should be kept inside a `try` block. Then, if it runs into
    an exception, the Python parser should execute the code that''s inside the `except`
    block. The following example should make this clearer to you:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对代码是否出错不确定，您应该始终使用`try`和`except`块。您的主要代码，可能会遇到异常，应该放在`try`块内。然后，如果它遇到异常，Python解析器应该执行`except`块内的代码。以下示例应该让您更清楚：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code shows how easy it is to handle these kinds of errors. You
    put your main code inside a `try` block and if it ran into an exception, the main
    code won't be executed. Instead, the code inside of the except block will be executed,
    which in this case is a user-friendly message. You can also use `pass` so that
    you terminate the program without providing the user with a message.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了处理这些错误有多么容易。您将主要代码放在`try`块内，如果遇到异常，主要代码将不会被执行。相反，将执行`except`块内的代码，这种情况下是一个用户友好的消息。您还可以使用`pass`，以便在不向用户提供消息的情况下终止程序。
- en: 'With the except keyword, you can also pass the name of an exception explicitly.
    However, make sure you know the proper exception name you are going to run into.
    In this case, we know we are going to run into `ZeroDivisionError`, and so we
    can write the exception name with an except block, like so:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 except 关键字，您还可以显式传递异常的名称。但是，请确保您知道要遇到的正确异常名称。在这种情况下，我们知道我们将遇到 `ZeroDivisionError`，因此我们可以在
    except 块中写入异常名称，如下所示：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, let's see how we can refine our tic-tac-toe game with everything we have
    learned about so far. We will use conditionals, looping, and exception handling
    to modify the code that we wrote in the previous chapter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何利用我们迄今为止学到的一切知识来完善我们的井字棋游戏。我们将使用条件、循环和异常处理来修改我们在上一章中编写的代码。
- en: Making a game controller for our tic-tac-toe game
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的井字棋游戏制作游戏控制器
- en: 'In the preceding chapter, we build a simple tic-tac-toe game. Since we have
    learned about conditionals and looping in this chapter we are now able enough
    to make some advancement on our game. We will make the following changes to our
    game:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了一个简单的井字棋游戏。由于在本章中我们已经学习了条件和循环，现在我们能够对我们的游戏进行一些改进。我们将对我们的游戏进行以下更改：
- en: We have to make the game multiplayer, which means we have to make modifications
    to the program so that two players can play our game. We can make conditions that
    can toggle who's playing when.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须使游戏成为多人游戏，这意味着我们必须对程序进行修改，以便两名玩家可以玩我们的游戏。我们可以制作可以切换玩家的条件。
- en: When we talked about exception handling, we saw that our game was unable to
    handle string data that was inputted by a user. We can use `try` and `except`
    blocks to handle that exception.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们谈到异常处理时，我们看到我们的游戏无法处理用户输入的字符串数据。我们可以使用 `try` 和 `except` 块来处理该异常。
- en: We were unable to determine the winner of our game with the code that we wrote
    in the previous chapter. Now that we have learned about `if` conditionals, we
    can come up with some logic to check whether the player is the winner.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法确定我们在上一章中编写的代码的获胜者。现在我们已经了解了 `if` 条件，我们可以想出一些逻辑来检查玩家是否获胜。
- en: We will start our game development process by brainstorming in order to gather
    some critical information about the game.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过集思广益的方式开始我们的游戏开发过程，以收集有关游戏的一些关键信息。
- en: Brainstorming and information gathering
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集思广益和信息收集
- en: One of the important features our code lacks is readability. In the game code
    from the preceding chapter, we didn't have a proper way to track the positions
    of the game board. The first thing we can do with our code is make a choices list,
    which will contain all of the choices that can be made by the player. Here, the
    choices are for the tic-tac-toe board position. In the tic-tac-toe game, the player
    can choose between 0 and 8 numbers, which are placeholders if they're not occupied
    by another player.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码缺乏的一个重要特性是可读性。在上一章的游戏代码中，我们没有一个合适的方法来跟踪游戏板的位置。我们的代码可以做的第一件事是制作一个 choices
    列表，其中包含玩家可以做出的所有选择。在这里，选择是用于井字棋板位置的。在井字棋游戏中，玩家可以在 0 到 8 之间选择数字，如果它们没有被其他玩家占据的话，这些数字就是占位符。
- en: 'The second thing we have to add in our code is a way we can toggle whose turn
    it is. Since we have only two players, we can make player 1 play first and make
    the first move of the game. Hence, making logic would be easier. We will make
    one Boolean variable and change its value from True to False so that we can make
    a condition to change the player''s turn, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中必须添加的第二件事是我们如何切换轮到谁了。由于我们只有两名玩家，我们可以让玩家1先行动并进行游戏的第一步。因此，制作逻辑会更容易。我们将制作一个布尔变量，并将其值从
    True 更改为 False，以便我们可以制作一个条件来改变玩家的回合，如下所示：
- en: '`playerOne = True` will make sure it''s player 1''s turn.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playerOne = True` 确保是玩家1的回合。'
- en: '`playerOne = False` will allow player 2 to make a move on our game board.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playerOne = False` 将允许玩家2在我们的游戏板上行动。'
- en: 'We have to go through the rules of the tic-tac-toe game to make any player
    a winner based on the positions they occupy on the game board. If a player, either
    X or O, occupies entire rows, columns, or diagonals of the tic-tac-toe board,
    that player will be considered the winner. This is depicted in the following screenshot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须遵循井字棋游戏的规则，以便根据玩家在游戏板上占据的位置来确定任何玩家是否获胜。如果玩家 X 或 O 占据了整行、整列或对角线的井字棋板，那么该玩家将被视为获胜者。这在下面的截图中有所体现：
- en: '![](Images/6a16772b-7803-464b-b4f3-631078d63310.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6a16772b-7803-464b-b4f3-631078d63310.png)'
- en: Modifying the model
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改模型
- en: 'The program we wrote in the previous chapter was only able to make one player
    play the game. Since tic-tac-toe is a multiplayer game, modifications should be
    made so that multiple players can play this game. For that, we have to do two
    things:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中编写的程序只能让一个玩家玩游戏。由于井字棋是一款多人游戏，应该对程序进行修改，以便多名玩家可以玩这个游戏。为此，我们必须做两件事：
- en: Track empty places on the board.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪棋盘上的空位。
- en: Make a condition to toggle the player's turn.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个条件来切换玩家的回合。
- en: 'For both of those modifications, we have to make one variable that can track
    every empty and occupied position on the game board:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种修改，我们必须创建一个变量，可以跟踪游戏板上的每个空位和占用位置：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you use the `>>> print(choices)` variable, this will result in a list of
    values: `[''1'', ''2'', ''3'', ''4'', ''5'', ''6'', ''7'', ''8'', ''9'']`. They
    are positions for our board game.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 `>>> print(choices)` 变量，这将导致一个值列表：`['1', '2', '3', '4', '5', '6', '7',
    '8', '9']`。它们是我们棋盘游戏的位置。
- en: 'Now, if you want to print the board''s layout, you cannot use code from the
    previous chapter. Instead of using the `game_board` variable, we are going to
    use the `choices` variable. This works in the same way it did in the previous
    example. We are going to add a single line of dashes in-between each row:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您想打印棋盘的布局，您不能使用上一章的代码。我们将使用 `choices` 变量，而不是使用 `game_board` 变量。这与上一个示例中的工作方式相同。我们将在每一行之间添加一行短划线：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The main problem in our game may arise when the user inputs something other
    than a number. For example, if the player enters a string, the game will be terminated
    with an exception—we don't want that situation to happen. As you may recall, we
    use **exception handling** to avoid such a scenario. We will add this to our game
    in the next section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中的主要问题可能出现在用户输入非数字的情况下。例如，如果玩家输入字符串，游戏将以异常终止，我们不希望发生这种情况。正如您可能记得的那样，我们使用异常处理来避免这种情况。我们将在下一节中将其添加到我们的游戏中。
- en: Handling the exceptions of the game
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理游戏的异常
- en: 'Let''s run the game that we''ve made so far and input a string into the input
    field instead of an integer value. You will get the following exception:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行到目前为止我们制作的游戏，并在输入字段中输入一个字符串而不是整数值。你将得到以下异常：
- en: '![](Images/aa708971-878e-4c70-a2a5-634070fb33d8.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/aa708971-878e-4c70-a2a5-634070fb33d8.png)'
- en: 'We don''t want our program to crash whenever the user makes a mistake while
    interacting with our game. Instead, we can send them a user-friendly message saying
    `This is not valid, press integer only`. Let''s handle this type of exception
    by using a `try` and `catch` block, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望我们的程序在用户与我们的游戏交互时出现错误时崩溃。相反，我们可以发送给他们一个用户友好的消息，说`这不是有效的，只按整数键`。让我们通过使用`try`和`catch`块来处理这种类型的异常，如下所示：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When we run our program this time, we will get the following output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的程序时，我们将得到以下输出：
- en: '![](Images/2902aef2-9493-4eb4-852d-53b8d85b2f87.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2902aef2-9493-4eb4-852d-53b8d85b2f87.png)'
- en: Here, we entered a Python string value into the input field. Instead of it crashing
    the program, we got a message saying `Please enter only valid fields from board`.
    This is a convenient way of handling exceptions using `try` and `except` blocks.
    We used the same main loop from the previous chapter, which was going to loop
    an infinite amount of times. Inside the body of the `try` block, we kept the code
    that might throw an exception. `strip()` is a string method that is going to remove
    white spaces from the user's input. We have to type-cast user input using the
    `int` method so that the input data, which will be in the form of a string, is
    converted into an integer. If we get an exception, we are going to execute the
    code that's inside the body of the `except` block. The `continue` keyword is going
    to make the main loop run again from the beginning if we run into an exception.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将Python字符串值输入到输入字段中。而不是使程序崩溃，我们得到了一条消息，说`请只输入来自棋盘的有效字段`。这是使用`try`和`except`块处理异常的一种方便的方法。我们使用了前一章的相同主循环，它将无限次循环。在`try`块的主体中，我们保留可能引发异常的代码。`strip()`是一个字符串方法，将从用户的输入中删除空格。我们必须使用`int`方法对用户输入进行类型转换，以便将以字符串形式的输入数据转换为整数。如果我们遇到异常，我们将执行`except`块中的代码。`continue`关键字将使主循环再次从头开始运行，如果我们遇到异常。
- en: The main feature that must be added to our tic-tac-toe game is multiplayer so
    that two players can play the same game turn by turn. This toggling feature will
    be added in the next section.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 必须添加到我们的井字游戏中的主要功能是多人游戏，这样两个玩家可以轮流玩同一场游戏。这个切换功能将在下一节中添加。
- en: Toggling the player's turn
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换玩家的轮次
- en: 'Writing programs to make two players play the game is easy with Python—all
    you need to do is create one Boolean variable that will denote who the current
    player is. Then, based on the two values of the Boolean, either `True` or `False`,
    we can change who''s playing the game. However, if you want to add more than two
    players, this idea isn''t going to work. We are going to use the following Booleans:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python编写程序让两个玩家玩游戏很容易，你只需要创建一个布尔变量来表示当前玩家是谁。然后，根据布尔的两个值，`True`或`False`，我们可以改变谁在玩游戏。但是，如果你想添加超过两个玩家，这个想法就行不通了。我们将使用以下布尔值：
- en: '`Is_Current_One = True`: The current player is player 1 or X.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Is_Current_One = True`：当前玩家是玩家1或X。'
- en: '`Is_Current_One = False`: The current player is player 2 or O.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Is_Current_One = False`：当前玩家是玩家2或O。'
- en: 'This is shown in the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下代码中显示：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s break the preceding code into segments so that we can understand it
    better:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面的代码分成几个部分，以便更好地理解它：
- en: We have our main loop, which is going to run an infinite amount of times until
    it triggers a `break` statement. We've already learned that the `break` keyword
    was going to terminate our loop. In the body of the main loop, we print whether
    it's player X's or O's turn to make the player aware of their turn.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个主循环，它将无限次运行，直到触发`break`语句。我们已经学会了`break`关键字将终止我们的循环。在主循环的主体中，我们打印出是玩家X还是O轮到了，以使玩家意识到轮到他们了。
- en: We have created a Boolean variable called `Is_Current_One`, which was assigned
    a value of `True`. This means that the first player to make a move will be player
    `X`. If we make this variable False, then the default player to make the first
    move will be player `O`.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`Is_Current_One`的布尔变量，它被赋予了一个值`True`。这意味着第一个移动的玩家将是玩家`X`。如果我们将这个变量设为False，那么第一个移动的默认玩家将是玩家`O`。
- en: Inside the main loop, we created a condition to check whether player `X` or
    player `O` has placed either `X` or `O` on the board layout accordingly. The `choices[]`
    variable reflects the board's position. `choice` is the user's input, which we
    subtract by 1 because our choices variable is a list type. We know that list indexes
    start from index 0, but we have entered user input from 1 to 9\. Hence, we subtract
    the `choice` input variable with 1 to accommodate this list variable.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主循环内，我们创建了一个条件来检查玩家`X`或玩家`O`是否已将`X`或`O`放置在棋盘布局上。`choices[]`变量反映了棋盘的位置。`choice`是用户的输入，我们将其减去1，因为我们的choices变量是一个列表类型。我们知道列表索引从索引0开始，但我们已经输入了用户输入从1到9。因此，我们将`choice`输入变量减去1以适应这个列表变量。
- en: The `>>> Is_Current_One = not Is_Current_One` statement is going to toggle between
    the players. As we mentioned previously, if `Is_Current_One` is `True`, the player
    is `X`, Now, we've also made a condition so that we can change True to False in
    the next iteration so that player `O` can make the next move.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>>> Is_Current_One = not Is_Current_One`语句将在玩家之间切换。正如我们之前提到的，如果`Is_Current_One`为`True`，那么玩家就是`X`，现在，我们还制定了一个条件，这样我们就可以在下一次迭代中将True改为False，这样玩家`O`就可以进行下一步。'
- en: 'Let''s see what we are up to now by running our script file. You will see the
    following result printed in the shell:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行我们的脚本文件来看看我们现在在做什么。您将在shell中看到以下结果打印出来：
- en: '![](Images/a9420bfc-fd6e-45c1-9ec6-0a6e0acc55ab.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a9420bfc-fd6e-45c1-9ec6-0a6e0acc55ab.png)'
- en: Now, we have created our game, which can take some input from a user and place
    it on the tic-tac-toe board. We've created some logic to change whose turn it
    is. We were also able to handle exceptions that might appear in our game using
    `try` and `catch` blocks.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了我们的游戏，它可以接受用户的输入，并将其放在井字游戏板上。我们已经制定了一些逻辑来改变轮到谁了。我们还能够使用`try`和`catch`块处理游戏中可能出现的异常。
- en: We have been progressing at a rapid pace, but our game is still incomplete.
    We haven't made any logic to make a player the winner if they occupy either a
    row, a column, or three diagonal cells. We will do this in the next section.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在快速进展，但我们的游戏还不完整。我们还没有制定任何逻辑，如果玩家占据一行、一列或三个对角线单元，他们就会成为赢家。我们将在下一节中完成这一点。
- en: Making a player the winner
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使玩家成为赢家
- en: '**Tic-tac-toe** is an easy game to make, but the main purpose of building this
    game is to cover almost every core programming paradigm of Python, such as variables,
    numbers, models, built-in methods, looping, branching, and exception handling.
    Now, our game is good enough to be played by two players, but a multiplayer game
    can only have one winner at the end of it. Therefore, we have to make brand new
    logic that will reward the player if they win. We need to cover three use cases,
    as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**井字游戏**是一个很容易制作的游戏，但建立这个游戏的主要目的是涵盖Python的几乎所有核心编程范式，比如变量、数字、模型、内置方法、循环、分支和异常处理。现在，我们的游戏已经足够好，可以供两个玩家玩，但多人游戏最终只能有一个赢家。因此，我们必须制定全新的逻辑，以奖励玩家如果他们赢了。我们需要涵盖三种用例，如下：'
- en: If an entire row of the tic-tac-toe board is occupied by a player, that player
    will be the winner.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果井字游戏板的整行被一个玩家占据，那个玩家将成为赢家。
- en: If an entire column of the board is occupied by a player, that player will be
    the winner.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果棋盘的整列被一个玩家占据，那个玩家将成为赢家。
- en: If an entire diagonal of the board is occupied a player, that player will be
    the winner.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果棋盘的整个对角线被一个玩家占据，那个玩家将成为赢家。
- en: 'Let''s print our game board layouts, along with their positions, so that we
    can track all of the positions of the board while making the preceding conditions:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印我们的游戏板布局，以及它们的位置，这样我们就可以在制定前述条件时跟踪棋盘的所有位置：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Since we have to loop through all of these positions from 1 to 9, we need to
    use a `for` loop. Since we have a finite list of numbers, a `for` loop is easy
    to use. We have to make two conditions to check whether a player occupies an entire
    row or column. After dealing with row and column, we will examine diagonal conditionals
    with isolation:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们必须循环遍历从1到9的所有这些位置，我们需要使用`for`循环。由于我们有一个有限的数字列表，所以使用`for`循环很容易。我们必须制定两个条件来检查玩家是否占据了整行或整列。在处理行和列之后，我们将独立检查对角线条件：
- en: '**For row**: If any user occupies [1,2,3], [4,5,6], [7,8,9], that particular
    player will be considered the winner.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于行**：如果任何用户占据[1,2,3]，[4,5,6]，[7,8,9]，那个特定的玩家将被视为赢家。'
- en: '**For column**: If any user occupies [1,4,7] , [2,5,8], [3,6,9], that particular
    player will be considered the winner.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对于列**：如果任何用户占据[1,4,7]，[2,5,8]，[3,6,9]，那个特定的玩家将被视为赢家。'
- en: However, the position inside the `choice` variable ranges from 0 to 8, that
    is, ['0','1','2','3','4','5','6','7','8'], and so index 0 references the first
    position of the board, an index of 1 indicates the second position of the board,
    and so on.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`choice`变量中的位置范围是从0到8，即['0'，'1'，'2'，'3'，'4'，'5'，'6'，'7'，'8']，因此索引0表示棋盘的第一个位置，索引1表示棋盘的第二个位置，依此类推。
- en: 'We have been using a while `True` statement for our main loop. Let''s modify
    that so that our code will run until we a player is the winner. We will run our
    main loop until `won= False`. If we get a winner of the game, we will change the
    value of the `won` variable to `True` so that the main loop will end:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用一个`while True`语句作为我们的主循环。让我们修改一下，这样我们的代码将一直运行，直到有一个玩家成为赢家。我们将运行我们的主循环，直到`won=False`。如果我们得到了游戏的赢家，我们将改变`won`变量的值为`True`，这样主循环就会结束：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding code, we made two conditions to check whether the player is
    the winner. We made the `won` variable to track whether any player has won. If
    any player occupies an entire row or column, we are making the `won` variable''s
    value True and our loop will break, which means we will end our game. However,
    we haven''t given the user a message about being the winner. Let''s write some
    code that will tell the user they''re the winner after we check for the row and
    column condition:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们制定了两个条件来检查玩家是否是赢家。我们制定了`won`变量来跟踪任何玩家是否赢了。如果任何玩家占据了整行或整列，我们将使`won`变量的值为True，我们的循环将中断，这意味着我们将结束游戏。然而，我们还没有给用户一个关于成为赢家的消息。让我们编写一些代码，在检查行和列条件之后，告诉用户他们是赢家：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The statement we've written with the `print` method may create confusion because
    of the `str(int(Is_Current_One + 1))` command. Here, `Is_Current_One` is either
    `True` or `False`. However, it also corresponds to 1 or 0, where 1 is for `True`
    and 0 is for `False`. If player `X` is the winner, then it's player 1 who won,
    but the turn will have changed over to player `O`, that is, player 2.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`print`方法编写的语句可能会引起混淆，因为`str(int(Is_Current_One + 1))`命令。这里，`Is_Current_One`要么是`True`，要么是`False`。然而，它也对应着1或0，其中1是`True`，0是`False`。如果玩家`X`是赢家，那么赢家是玩家1，但轮到了玩家`O`，也就是玩家2。
- en: 'Hence, we have to add this to 1 so that the current player is determined the
    winner, rather than the player who goes next. Since this is a two-player game,
    this makes sense. Let''s run our code to examine the result:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须将这个加到1，这样当前玩家就确定为赢家，而不是下一个玩家。由于这是一个双人游戏，这是有道理的。让我们运行我们的代码来检查结果：
- en: '![](Images/42281b71-20e0-4c0b-b4d9-4ba3b1cb5f40.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/42281b71-20e0-4c0b-b4d9-4ba3b1cb5f40.png)'
- en: 'We haven''t finished yet—we also have to add one more condition to check whether
    the diagonals are also occupied by a player. Let''s add that condition now:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成 - 我们还必须添加一个条件来检查对角线是否也被玩家占据。让我们现在添加这个条件：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If any player occupy positions [1,5,9] or [3,5,7], they will be regarded as
    the winner. However, our `choices` variable is a list that contains all of the
    positions. Its index starts from 0, which means if you want to locate the position
    for player 1, you should pass this as `choices[0]`, like so:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何玩家占据位置[1,5,9]或[3,5,7]，他们将被视为赢家。然而，我们的`choices`变量是一个包含所有位置的列表。它的索引从0开始，这意味着如果你想定位玩家1的位置，你应该传递`choices[0]`，就像这样：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let''s run our game one more time to check whether this condition works
    properly:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次运行游戏，检查这个条件是否正常工作：
- en: '![](Images/37ad5c38-36cc-4c49-9f21-154360dc2db6.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/37ad5c38-36cc-4c49-9f21-154360dc2db6.png)'
- en: Finally, we have completed our game! We were able to include many features in
    our game, such as exception handling, multiplayer mode, and logic to make a player
    a winner. However, we still have to refine this game by adding user-defined functions
    so that we can print our board layout. This will follow the DRY principle and
    will be covered in the next chapter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们完成了我们的游戏！我们能够在游戏中包含许多功能，比如异常处理、多人游戏模式和使玩家成为赢家的逻辑。然而，我们仍然需要通过添加用户定义的函数来完善这个游戏，以便我们可以打印我们的棋盘布局。这将遵循DRY原则，并将在下一章中介绍。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has given us a roller-coaster ride of all of the core topics of
    programming paradigms with Python. We have covered flow controls and how to achieve
    them using branches and loops. We learned how to make conditions and fed them
    to the conditionals. Then, based on those conditions, we were able to make a switch
    between the execution of statements. We saw how to automate things using Python
    looping and branching. We fed multiple possible conditions with the `if` keyword
    and, based on the result of the Boolean expressions, the flow of the program was
    controlled. We also learned about the different types of looping and saw how to
    use them to iterate a list of items or objects. Then, we saw how to handle exceptions
    using try and except block.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们提供了一个关于Python编程范式核心主题的过山车之旅。我们涵盖了流程控制以及如何使用分支和循环来实现它们。我们学习了如何制定条件并将其传递给条件语句。然后，基于这些条件，我们能够在语句的执行之间进行切换。我们看到了如何使用Python的循环和分支来自动化事物。我们使用`if`关键字传递了多个可能的条件，并且根据布尔表达式的结果来控制程序的流程。我们还学习了不同类型的循环，并看到了如何使用它们来迭代一个项目或对象的列表。然后，我们看到了如何使用try和except块来处理异常。
- en: Finally, we made our tic-tac-toe game more playable than ever before by incorporating
    the different paradigms we learned about in this chapter. We added `try` and `except`
    blocks so that any exception will be caught and handled properly. We also added
    features such as multiplayer mode and logic to make a player the winner. This
    makes the game highly interactive. Finally, we made a game controller using conditionals
    and looping. However, we won't stop here; more modifications will be made in the
    upcoming chapters.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过结合本章学到的不同范式，使我们的井字棋游戏比以往任何时候都更具可玩性。我们添加了`try`和`except`块，以便捕获和正确处理任何异常。我们还添加了多人游戏模式和使玩家成为赢家的逻辑等功能。这使得游戏非常互动。最后，我们使用条件和循环制作了一个游戏控制器。然而，我们不会止步于此；在接下来的章节中将进行更多的修改。
- en: The next chapter will be life-changing for us. Up until now, we have only been
    using the built-in functions of Python, such as `min()`, `max()`, and `input()`.
    In the next chapter, we will see how to make our own functions and to use them
    so that we can make our game more readable and reusable. We will cover data structures
    such as list, set and, dictionary so that we know how to manage and store more
    complex datasets. Don't be overwhelmed by all of these statements, though. You
    have come this far, and are now on the brink of becoming a proficient Python programmer.
    Before moving on to the next chapter, make sure you are comfortable with all of
    the topics that we have learned about so far.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章对我们来说将是改变生活的。到目前为止，我们只使用了Python的内置函数，比如`min()`、`max()`和`input()`。在下一章中，我们将看到如何制作我们自己的函数，并使用它们，以便我们可以使我们的游戏更易读和可重用。我们将涵盖列表、集合和字典等数据结构，以便我们知道如何管理和存储更复杂的数据集。不过，不要被所有这些陈述所压倒。你已经走了这么远，现在正处于成为熟练的Python程序员的边缘。在进入下一章之前，请确保你对我们迄今所学的所有主题都感到舒适。
