- en: Chapter 11. Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。测试
- en: 'In this chapter, we''ll look at the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看以下配方：
- en: Using docstrings for testing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文档字符串进行测试
- en: Testing functions that raise exceptions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试引发异常的函数
- en: Handling common doctest issues
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理常见的doctest问题
- en: Creating separate test modules and packages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建单独的测试模块和包
- en: Combining unittest and doctest tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合unittest和doctest测试
- en: Testing things that involve dates or times
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试涉及日期或时间的事物
- en: Testing things that involve randomness
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试涉及随机性的事物
- en: Mocking external resources
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟外部资源
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'Testing is central to creating working software. Here''s the canonical statement
    in the importance of testing:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是创建可工作软件的核心。这是关于测试重要性的经典陈述：
- en: '*Any program feature without an automated test simply doesn''t exist.*'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*任何没有自动化测试的程序功能都不存在。*'
- en: 'This is from Kent Beck''s book, *Extreme Programming Explained: Embrace Change*
    .'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是肯特·贝克的书《极限编程解释：拥抱变化》中的内容。
- en: 'We can distinguish several kinds of testing:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分几种测试：
- en: '**Unit testing** : This applies to independent *units* of software: functions,
    classes, or modules. The unit is tested in isolation to confirm that it works
    correctly.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：这适用于独立的软件*单元*：函数、类或模块。该单元被孤立测试以确认它是否正确工作。'
- en: '**Integration testing** : This combines units to be sure they integrate properly.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：这将单元组合以确保它们正确集成。'
- en: '**System testing** : This tests an entire application or a system of interrelated
    applications to be sure that the aggregated suite of software components works
    properly. This is often used for overall acceptance of software as fit for use.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统测试**：这测试整个应用程序或一组相互关联的应用程序，以确保软件组件的集合正常工作。这经常用于整体接受软件的使用。'
- en: '**Performance testing** : This assures that a unit meets performance objectives.
    In some cases, performance testing includes the study of resources such as memory,
    threads, or file descriptors. The goal is to be sure that software makes appropriate
    use of system resources.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能测试**：这确保一个单元满足性能目标。在某些情况下，性能测试包括对内存、线程或文件描述符等资源的研究。目标是确保软件适当地利用系统资源。'
- en: Python has two built-in testing frameworks. One examines the docstrings for
    examples that include the `>>>` prompt. This is the `doctest` tool. While this
    is widely used for unit testing, it can also be used for simple integration testing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两个内置的测试框架。其中一个检查文档字符串中包含`>>>`提示的示例。这就是`doctest`工具。虽然这被广泛用于单元测试，但也可以用于简单的集成测试。
- en: The other testing framework uses classes built with definitions from the `unittest`
    module. This module defines a `TestCase` class. This, too, is designed primarily
    for unit testing, but can also be applied to integration and performance testing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个测试框架使用了从`unittest`模块定义的类构建的定义。这个模块定义了一个`TestCase`类。这也主要用于单元测试，但也可以应用于集成和性能测试。
- en: Of course, we'll want to combine these tools. Both modules have features to
    allow coexistence. We'll often leverage the test loading protocol from the `unittest`
    package to merge all of our tests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们希望结合这些工具。这两个模块都有特性允许共存。我们经常利用`unittest`包的测试加载协议来合并所有测试。
- en: Additionally, we might use the tools `nose2` or `py.test` to further automate
    test discovery and add additional features such as test case coverage. These projects
    are often helpful for particularly complex applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可能会使用工具`nose2`或`py.test`来进一步自动化测试发现，并添加额外的功能，如测试用例覆盖率。这些项目通常对特别复杂的应用程序很有帮助。
- en: 'It''s sometimes helpful to summarize a test using the GIVEN-WHEN-THEN style
    of test case naming:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有时使用GIVEN-WHEN-THEN测试用例命名风格来总结一个测试是有帮助的：
- en: '**GIVEN** some initial state or context'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GIVEN**一些初始状态或上下文'
- en: '**WHEN** a behavior is requested'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WHEN**请求行为'
- en: '**THEN** the component under test has some expected result or state change'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**THEN**被测试的组件有一些预期的结果或状态变化'
- en: Using docstrings for testing
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文档字符串进行测试
- en: Good Python includes docstrings inside every module, class, function, and method.
    Many tools can create useful, informative documentation from the docstrings.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的Python包括每个模块、类、函数和方法内部的文档字符串。许多工具可以从文档字符串创建有用的、信息丰富的文档。
- en: One important element of a docstring is an example. The example becomes a kind
    of unit test case. An example often fits the GIVEN-WHEN-THEN model of testing
    because it shows a unit, a request, and a response.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串的一个重要元素是示例。示例成为一种单元测试用例。一个示例通常符合GIVEN-WHEN-THEN测试模型，因为它显示了一个单元、一个请求和一个响应。
- en: How can we turn examples into proper test cases?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将示例转化为适当的测试用例？
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We'll look at a simple function definition as well as a simple class definition.
    Each of these will include docstrings that include examples which can be used
    as formal tests.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一个简单的函数定义以及一个简单的类定义。每个都将包括包含示例的文档字符串，这些示例可以用作正式测试。
- en: 'Here''s a simple function that computes the binomial coefficient of two numbers.
    It shows the number of combinations of *n* things taken in groups of size *k*
    . For example, how many ways a 52-card deck can be dealt into 5-card hands is
    computed like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个计算两个数字的二项式系数的简单函数。它显示了*n*个事物以*k*个大小的组合的数量。例如，一副52张的牌可以被分成5张牌的方式可以这样计算：
- en: '![Getting ready](Image00054.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](Image00054.jpg)'
- en: 'This defines a small Python function that we can write like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个小的Python函数，我们可以这样写：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This function does a simple calculation and returns a value. Since it has no
    internal state, it's relatively easy to test. This will be one of the examples
    used for showing the unit testing tools available.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数进行了一个简单的计算并返回一个值。由于它没有内部状态，所以相对容易测试。这将是用于展示可用的单元测试工具的示例之一。
- en: 'We''ll also look at a simple class which has a lazy calculation of mean and
    median. It uses an internal `Counter` object which can be interrogated to determine
    the mode:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看一个简单的类，它具有均值和中位数的延迟计算。它使用一个内部的`Counter`对象，可以被询问以确定模式：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `add()` method changes the state of this object. Because of this state change,
    we'll need to provide more sophisticated examples that show how an instance of
    the `Summary` class behaves.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`add()`方法改变了这个对象的状态。由于这种状态改变，我们需要提供更复杂的示例，展示`Summary`类的实例的行为方式。'
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll show two variations in this recipe. The first is for largely stateless
    operations, such as the computation of the `binom()` function. The second is for
    stateful operations, such as the `Summary` class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个示例中展示两种变化。第一种是用于大部分无状态操作，比如计算`binom()`函数。第二种是用于有状态操作，比如`Summary`类。
- en: Put examples into the docstrings.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将示例放入文档字符串中。
- en: 'Run the doctest module as a program. This is done in one of two ways:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将doctest模块作为程序运行。有两种方法：
- en: 'At the command prompt:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令提示符下：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If all of the examples pass, there's no output. Using the `-v` option produces
    verbose output summarizing the tests.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有示例都通过，就不会有输出。使用`-v`选项会产生总结测试的详细输出。
- en: 'By including a `__name__ == ''__main__''` section. This can import the doctest
    module and execute the `testmod()` function:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过包含一个`__name__ == '__main__'`部分。这可以导入doctest模块并执行`testmod()`函数：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If all of the examples pass, there's no output. To see some output, use the
    `verbose=1` parameter for the `testmod()` function to create more verbose output.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有示例都通过，就不会有输出。要查看一些输出，可以使用`testmod()`函数的`verbose=1`参数创建更详细的输出。
- en: Writing examples for stateless functions
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为无状态函数编写示例
- en: 'Start the docstring with a summary:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用摘要开始文档字符串：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Include the parameter definitions:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括参数定义：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Include the return value definition:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括返回值定义：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Mock up an example of using the function at Python''s `>>>` prompt:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟一个在Python的`>>>`提示下使用该函数的示例：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Close the long docstring with the appropriate quotation marks:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用适当的引号关闭长文档字符串：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Writing examples for stateful objects
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为有状态对象编写示例
- en: 'Write a class-level docstring with a summary:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用摘要编写类级别的文档字符串：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We've left space to fill in examples.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们留下了填写示例的空间。
- en: 'Write the method-level docstring with a summary. Here''s the `add()` method:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用摘要编写方法级别的文档字符串。这是`add()`方法：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here''s the `mean()` method:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`mean()`方法：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A similar string is required for the `median()` method, and any others that
    are written.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`median()`方法和其他写入的方法也需要类似的字符串。'
- en: 'Extend the class-level docstring concrete examples. In this case, we''ll write
    two. The first example shows that the `add()` method has no return value, but
    changes the state of the object. The `mean()` method reveals this state:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展类级别的文档字符串具体示例。在这种情况下，我们将写两个。第一个示例显示`add()`方法没有返回值，但改变了对象的状态。`mean()`方法显示了这个状态：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We've rounded the result of the mean to avoid displaying a long floating-point
    value that might not have the exact same text representation on all platforms.
    When we run doctest, we'll generally get a silent response because the test passed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将平均值的结果四舍五入，以避免显示一个长的浮点值，在所有平台上可能没有完全相同的文本表示。当我们运行doctest时，通常会得到一个静默的响应，因为测试通过了。
- en: 'The second example shows a multiline result from the `__str__()` method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例显示了`__str__()`方法的多行结果：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'What happens when something doesn''t work? Imagine that we changed the expected
    output to have a wrong answer. When we run doctest, we''ll see output like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当某些事情不起作用时会发生什么？想象一下，我们将期望的输出更改为错误答案。当我们运行doctest时，我们将看到如下输出：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This shows where the error is. It shows an expected value from the test example,
    and the actual answer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了错误的位置。它显示了测试示例的预期值和实际答案。
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `doctest` module includes a main program—as well as several functions—that
    will scan a Python file for `>>>` examples. We can leverage the module scanning
    function, `testmod()` , to scan the current module. We can use this to scan any
    imported module.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`模块包括一个主程序，以及几个函数，它将扫描Python文件中的`>>>`示例。我们可以利用模块扫描函数`testmod()`来扫描当前模块。我们可以使用这个来扫描任何导入的模块。'
- en: The scanning operation looks for blocks of text that have a characteristic pattern
    of a `>>>` line followed by lines that show the response from the command.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描操作寻找具有`>>>`行特征模式的文本块，后面是显示命令响应的行。
- en: 'The doctest parser creates a small test case object from the prompt line and
    the block of response text. There are three common cases:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: doctest解析器从提示行和响应文本块创建一个小的测试用例对象。有三种常见情况：
- en: 'No expected response text: We saw this pattern when we defined the tests for
    the `add()` method of the `Summary` class.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有预期的响应文本：当我们为`Summary`类的`add()`方法定义测试时，我们看到了这种模式。
- en: 'Single line of response text: This was exemplified by the `binom()` function
    and the `mean()` method.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单行响应文本：这在`binom()`函数和`mean()`方法中得到了体现。
- en: 'Multiple lines of response: Responses are bounded by either the next `>>>`
    prompt or a blank line. This was exemplified by the `str()` example of the `Summary`
    class.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多行响应：响应由下一个`>>>`提示或空行限定。这在`Summary`类的`str()`示例中得到了体现。
- en: The doctest module will execute each line of code shown with a `>>>` prompt.
    It compares the actual results with the expected results. The comparison is a
    very simple text matching. Unless special annotations are used, the output must
    precisely match the expectations.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: doctest模块将执行每个带有`>>>`提示的代码行。它将实际结果与期望结果进行比较。比较是非常简单的文本匹配。除非使用特殊注释，否则输出必须精确匹配期望。
- en: The simplicity of this testing protocol imposes some software design requirements.
    Functions and classes must be designed to work from the `>>>` prompt. Because
    it can become awkward to create very complex objects as part of a docstring example,
    the design must be kept simple enough that it can be demonstrated interactively.
    Keeping software simple enough to demonstrate at the `>>>` prompt is often beneficial.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试协议的简单性对软件设计提出了一些要求。函数和类必须设计为从`>>>`提示中工作。因为在文档字符串示例中创建非常复杂的对象可能会变得尴尬，所以设计必须保持足够简单，以便可以进行交互演示。保持软件足够简单，以便在`>>>`提示处进行演示通常是有益的。
- en: The simplicity of the comparison of the results can impose some complications
    on the output that's being displayed. Note, for example, that we rounded the value
    of the mean to two decimal places. This is because the display of floating-point
    values may vary slightly from platform to platform.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的比较简单性可能会对显示的输出造成一些复杂性。例如，请注意，我们将平均值的值四舍五入到两位小数。这是因为浮点值的显示可能会因平台而异。
- en: Python 3.5.1 (on Mac OS X) shows `8.666666666666666` where Python 2.6.9 (also
    on Mac OS X) shows `8.6666666666666661` . The values are equal for 16 of the decimal
    digits. This is about 48 bits of data, which is the practical limit of floating-point
    values.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.5.1（在Mac OS X上）显示`8.666666666666666`，而Python 2.6.9（同样在Mac OS X上）显示`8.6666666666666661`。这些值在小数点后16位相等。这大约是48位数据，这是浮点值的实际限制。
- en: We'll address the exact comparison issue in detail in the *Handling common doctest
    issues* recipe.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*处理常见的doctest问题*配方中详细讨论精确比较问题。
- en: There's more...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'One of the important test considerations is edge cases. An **edge case** generally
    focuses on the limits for which a calculation is designed. There are, for example,
    two edges to the binomial function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的测试考虑因素是边界情况。**边界情况**通常关注计算设计的极限。例如，二项式函数有两个边界：
- en: '![There''s more...](Image00055.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](Image00055.jpg)'
- en: 'We can easily add these to the examples to be sure that our implementation
    is sound; this leads to a function that looks like the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地将这些添加到示例中，以确保我们的实现是正确的；这将导致一个看起来像下面这样的函数：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In some cases, we might need to test values that are outside the valid range
    of values. These cases aren't really ideal for putting into the docstring, because
    they clutter an explanation of what is supposed to happen with an explanation
    of other things that should never normally happen.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要测试超出有效值范围的值。这些情况并不适合放入文档字符串，因为它们会使本来应该发生的事情的解释变得混乱。
- en: We can include additional docstring test cases in a global variable named `__test__`
    . This variable must be a mapping. The keys to the mapping are test case names,
    and the values of the mapping are doctest examples. These will need to be triple-quoted
    strings.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个名为`__test__`的全局变量中包含额外的文档字符串测试用例。这个变量必须是一个映射。映射的键是测试用例的名称，映射的值是doctest示例。这些示例需要是三引号字符串。
- en: Because the examples are not inside the docstrings, they don't show up when
    using the built-in `help()` function. Nor do they show up when using other tools
    to create documentation from source code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些示例不在文档字符串内，所以在使用内置的`help()`函数时不会显示出来。当使用其他工具从源代码创建文档时，它们也不会显示出来。
- en: 'We might add something like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会添加类似这样的内容：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We've written the mapping with the keys with no indent. The values have been
    indented four spaces so that they stand out from the keys and are slightly easier
    to spot.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用没有缩进的键编写了映射。值已经缩进了四个空格，这样它们就会从键中脱颖而出，并且稍微容易发现。
- en: These test cases are found by the doctest program and included in the overall
    suite of tests. We can use this for tests that are important, but aren't really
    helpful as documentation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Doctest程序会找到这些测试用例，并将其包含在整体测试套件中。我们可以用这个来进行重要的测试，但并不真正有助于文档编制。
- en: See also
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In the *Testing functions that raise exceptions* and *Handling common doctest
    issues* recipes, we'll look at two additional doctest techniques. These are important
    because exceptions can often include a traceback which may include object IDs
    that can vary each time the program is run.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*测试引发异常的函数*和*处理常见的doctest问题*配方中，我们将看到另外两种doctest技术。这是重要的，因为异常通常会包括一个回溯，其中可能包括每次运行程序时都会有所不同的对象ID。
- en: Testing functions that raise exceptions
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试引发异常的函数
- en: Good Python includes docstrings inside every module, class, function, and method.
    Many tools can create useful, informative documentation from these docstrings.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的Python在每个模块、类、函数和方法内部都包含文档字符串。许多工具可以从这些文档字符串中创建有用的、信息丰富的文档。
- en: One important element of a docstring is an example. The example becomes a kind
    of unit test case. Doctest does simple, literal matching of the expected output
    against the actual output.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串的一个重要元素是示例。示例成为一种单元测试用例。Doctest对期望输出与实际输出进行简单的、字面的匹配。
- en: When an example raises an exception, though, the traceback messages from Python
    are not always identical. It may include object ID values that change or module
    line numbers which may vary slightly depending on the context in which the test
    is executed. The literal matching rules for doctest aren't appropriate when exceptions
    are involved.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当示例引发异常时，Python的回溯消息并不总是相同的。它可能包括会改变的对象ID值或模块行号，这取决于执行测试的上下文。当涉及异常时，doctest的字面匹配规则并不适用。
- en: How can we turn exception processing and the resulting traceback messages into
    proper test cases?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将异常处理和由此产生的回溯消息转化为正确的测试用例？
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We'll look at a simple function definition as well as a simple class definition.
    Each of these will include docstrings that include examples which can be used
    as formal tests.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一个简单的函数定义以及一个简单的类定义。其中每一个都将包括包含示例的文档字符串，这些示例可以用作正式测试。
- en: 'Here''s a simple function that computes the binomial coefficient of two numbers.
    It shows the number of combinations of *n* things taken in groups of *k* . For
    example, how many ways a 52-card deck can be dealt into 5-card hands:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的函数，用于计算两个数字的二项式系数。它显示了*n*个东西在*k*组中取的组合数。例如，一个52张牌的牌组可以被分成5张牌的手的方式有多少种：
- en: '![Getting ready](Image00056.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](Image00056.jpg)'
- en: 'This defines a small Python function that we can write like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个小的Python函数，我们可以这样写：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function does a simple calculation and returns a value. We'd like to include
    some additional test cases in the `__test__` variable to show what this does when
    given values outside the expected ranges.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数进行简单的计算并返回一个值。我们想在`__test__`变量中包含一些额外的测试用例，以展示在给定超出预期范围的值时会发生什么。
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a global `__test__` variable in the module:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块中创建一个全局的`__test__`变量：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've left space to insert one or more test cases.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们留下了空间来插入一个或多个测试用例。
- en: 'For each test case, provide a name and a placeholder for the example:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个测试用例，提供一个名称和一个示例的占位符：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Include the invocation with a `doctest` directive comment, `IGNORE_EXCEPTION_DETAIL`
    . This replaces the "example goes here":'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括一个带有`doctest`指令注释的调用，`IGNORE_EXCEPTION_DETAIL`。这将替换“示例在这里”：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The directive starts with `# doctest:` . Directives are enabled with `+` and
    disabled with `-` .
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令以`# doctest:`开头。指令通过`+`启用，通过`-`禁用。
- en: 'Include an actual traceback message. This is part of the *example goes here*
    ; it goes after the `>>>` statement to show the expected response:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括一个实际的回溯消息。这是*示例在这里*的一部分；它在`>>>`语句之后显示预期的响应：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The three lines that start with `File...` will be ignored. The `ValueError:`
    line will be checked to be sure that the test produces the expected exception.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`File...`开头的三行将被忽略。`ValueError:`行将被检查以确保测试产生了预期的异常。
- en: 'The overall statement looks like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 总体语句看起来像这样：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can now use a command like this to test the entire module''s features:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这样的命令来测试整个模块的功能：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The doctest parser has several directives that can be used to modify the testing
    behavior. The directives are included as special comments with the line of code
    that performs the test action.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: doctest解析器有几个指令，可以用来修改测试行为。这些指令被包含为特殊注释，与执行测试操作的代码行一起。
- en: 'We have two ways to handle tests that include an exception:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种处理包含异常的测试的方法：
- en: 'We can use `# doctest: +IGNORE_EXCEPTION_DETAIL` and provide a full traceback
    error message. The details of the traceback are ignored, and only the final exception
    line is matched against the expected value. This makes it very easy to copy an
    actual error and paste it into the documentation.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们可以使用`# doctest: +IGNORE_EXCEPTION_DETAIL`并提供完整的回溯错误消息。回溯的细节将被忽略，只有最终的异常行与预期值匹配。这使得很容易复制实际错误并将其粘贴到文档中。'
- en: 'We can use `# doctest: +ELLIPSIS` and replace parts of the traceback message
    with `...` . This, too, allows an expected output to elide details and focus on
    the last line that has the actual error.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们可以使用`# doctest: +ELLIPSIS`并用`...`替换回溯消息的部分。这也允许预期输出省略细节并专注于实际错误的最后一行。'
- en: 'For this second kind of exception example, we might include a test case like
    this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种第二种异常示例，我们可以包括一个像这样的测试用例：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The test case uses the `+ELLIPSIS` directive. The details of the error traceback
    have had irrelevant material replaced with `...` . The relevant material has been
    left intact so that the actual exception message will match the expected exception
    message precisely.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例使用了`+ELLIPSIS`指令。错误回溯的细节已被替换为`...`。相关材料已被保留完整，以便实际异常消息与预期异常消息精确匹配。
- en: 'Doctest will ignore everything between the first `Traceback...` line and the
    final `ValueError: ...` line. Generally, the final line is all that matters for
    proper execution of the test. The intermediate text depends on the context in
    which the test was run.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Doctest将忽略第一个`Traceback...`行和最后一个`ValueError:...`行之间的所有内容。通常，最后一行是测试的正确执行所关心的。中间文本取决于测试运行的上下文。
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are several more comparison directives that can be provided to individual
    tests.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 还有几个比较指令可以提供给单个测试。
- en: '`+ELLIPSIS` : This allows an expected result to be generalized by replacing
    details with `...` .'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+ELLIPSIS`：这允许预期结果通过用`...`替换细节来概括。'
- en: '`+IGNORE_EXCEPTION_DETAIL` : This allows an expected value to include a complete
    traceback message. The bulk of the traceback will be ignored, and only the final
    exception line is checked.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+IGNORE_EXCEPTION_DETAIL`：这允许预期值包括完整的回溯消息。大部分回溯将被忽略，只有最终的异常行会被检查。'
- en: '`+NORMALIZE_WHITESPACE` : In some cases, the expected value might be wrapped
    onto multiple lines to make it easier to read. Or, it might have spacing that
    varies slightly from standard Python values. Using this flag allows some flexibility
    in the whitespace for the expected value.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+NORMALIZE_WHITESPACE`：在某些情况下，预期值可能会被包裹到多行上以便于阅读。或者，它的间距可能与标准Python值略有不同。使用此标志允许预期值的空格有一定的灵活性。'
- en: '`+SKIP` : The test is skipped. This is sometimes done for tests that are designed
    for a future release. Tests may be included prior to the feature being completed.
    The test can be left in place for future development work, but skipped in order
    to release a version on time.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: +SKIP：测试被跳过。有时会为设计用于未来版本的测试而这样做。在功能完成之前可能会包括测试。测试可以保留在原位以供未来开发工作使用，但为了按时发布版本而被跳过。
- en: '`+DONT_ACCEPT_TRUE_FOR_1` : This covers a special case that was common in Python
    2\. Before `True` and `False` were added to the language, values `1` and `0` were
    used instead. The doctest algorithm for comparing expected results to actual results
    will honor this older scheme by matching `True` and `1` . This directive can be
    provided at the command line using `-o DONT_ACCEPT_TRUE_FOR_1` . This change would
    then be globally true for all tests.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+DONT_ACCEPT_TRUE_FOR_1`：这涵盖了Python 2中常见的一种特殊情况。在`True`和`False`被添加到语言之前，值`1`和`0`被用来代替。与实际结果进行比较的doctest算法将通过匹配`True`和`1`来尊重这种较旧的方案。可以在命令行上使用`-o
    DONT_ACCEPT_TRUE_FOR_1`提供此指令。然后，这个改变将对所有测试全局有效。'
- en: '`+DONT_ACCEPT_BLANKLINE` : Normally, a blank line ends an example. In the case
    where the example output includes a blank line, the expected results must use
    the special syntax `<blankline>` . Using this shows where a blank line is expected,
    and the example doesn''t end at this blank line. In very rare cases, the expected
    output will actually include the string `<blankline>` . This directive assures
    that `<blankline>` is not used to mean a blank line but stands for itself. This
    would make sense when writing tests for the doctest module itself.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+DONT_ACCEPT_BLANKLINE`：通常，空行会结束一个示例。在示例输出包括空行的情况下，预期结果必须使用特殊语法`<blankline>`。使用这个语法可以显示预期的空行位置，并且示例不会在这个空行结束。在非常罕见的情况下，预期输出实际上会包括字符串`<blankline>`。这个指令确保`<blankline>`不是用来表示空行，而是代表它自己。在为文档测试模块本身编写测试时，这是有意义的。'
- en: These can also be provided as the `optionsflags` parameter when evaluating the
    `testmod()` or `testfile()` functions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估`testmod()`或`testfile()`函数时，这些也可以作为`optionsflags`参数提供。
- en: See also
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Using docstrings for testing* recipe for the basics of doctest
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看*使用文档字符串进行测试*配方，了解文档测试的基础知识
- en: See the *Handling common doctest issues* recipe for other special cases that
    require doctest directives
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看*处理常见的文档测试问题*配方，了解其他需要文档测试指令的特殊情况
- en: Handling common doctest issues
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理常见的文档测试问题
- en: Good Python includes docstrings inside every module, class, function, and method.
    Many tools can create useful, informative documentation from minimally complete
    docstrings.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的Python包括每个模块、类、函数和方法内部的文档字符串。许多工具可以从完整的文档字符串中创建有用的、信息丰富的文档。
- en: One important element of a docstring is an example. The example becomes a kind
    of unit test case. Doctest does simple, literal matching of the expected output
    against the actual output. There are some Python objects, however, that are not
    consistent every time they're referred to.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串的一个重要元素是示例。示例成为一种单元测试用例。文档测试对预期输出进行简单、字面的匹配。然而，有一些Python对象在每次引用它们时并不一致。
- en: 'For example, all object hash values are randomized. This means that the order
    of elements in a set or the order of keys in a dictionary can vary. We have several
    choices for creating test case example output:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，所有对象哈希值都是随机的。这意味着集合中元素的顺序或字典中键的顺序可能会有所不同。我们有几种选择来创建测试用例示例输出：
- en: Write tests that can tolerate randomization. Often by converting to a sorted
    structure.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可以容忍随机化的测试。通常通过转换为排序结构。
- en: Stipulate a value for the `PYTHONHASHSEED` environment variable.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规定`PYTHONHASHSEED`环境变量的值。
- en: Require that Python be run with the `-R` option to disable hash randomization
    entirely.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要求使用`-R`选项运行Python以完全禁用哈希随机化。
- en: 'There are several other considerations beyond simple variability in the location
    of keys or items in a set. Here are some other concerns:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了集合中键或项的位置的简单变化之外，还有一些其他考虑因素。以下是一些其他问题：
- en: The `id()` and `repr()` functions may expose an internal object ID. No guarantees
    can be made about these values.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id()`和`repr()`函数可能会暴露内部对象ID。对于这些值无法做出任何保证。'
- en: Floating-point values may vary across platforms.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点值可能会因平台而异。
- en: The current date and time cannot meaningfully be used in a test case.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前日期和时间在测试用例中没有实际意义。
- en: Random numbers using the default seed are difficult to predict.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认种子的随机数很难预测。
- en: OS resources may not exist, or may not be in the proper state.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统资源可能不存在，或者可能不处于适当的状态。
- en: We'll focus on the first two issues with some doctest techniques in this recipe.
    We'll look at `datetime` and `random` in the *Testing things that involve dates
    or times* and *Testing things that involve randomness*  recipes. We'll look at
    how to work with external resources in the *Mocking external resources* recipe.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用一些文档测试技术来解决前两个问题。我们将在*涉及日期或时间的测试*和*涉及随机性的测试*配方中研究`datetime`和`random`。我们将在*模拟外部资源*配方中研究如何处理外部资源。
- en: Doctest examples require an exact match with the text. How can we write doctest
    examples that handle hash randomization or floating-point implementation details
    appropriately?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 文档测试示例需要与文本完全匹配。我们如何编写处理哈希随机化或浮点实现细节的文档测试示例？
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the *Reading delimited files with the CSV module* recipe, we looked at how
    the `csv` module will read data, creating a mapping for each row of input. In
    that recipe, we saw a `CSV` file that has some real-time data recorded from the
    log of a sailboat. This is the `waypoints.csv` file.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用CSV模块读取分隔文件*配方中，我们看到`csv`模块将读取数据，为每一行输入创建一个映射。在那个配方中，我们看到了一个`CSV`文件，其中记录了一艘帆船日志中的一些实时数据。这是`waypoints.csv`文件。
- en: 'The `DictReader` class produces rows that look like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`DictReader`类生成的行如下所示：'
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is a doctest nightmare because the hash randomization assures that the
    order of the keys in this dictionary is likely to be different.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个文档测试的噩梦，因为哈希随机化确保这个字典中键的顺序很可能是不同的。
- en: 'When we try to write doctest examples that involve a dictionary, we''ll often
    see problems like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试编写涉及字典的文档测试示例时，我们经常会遇到这样的问题：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The data in the expected and actual rows clearly matches. However, the string
    displays of the dictionary values aren't exactly identical. The keys are not shown
    in a consistent order.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 预期和实际行中的数据明显匹配。然而，字典值的字符串显示并不完全相同。键的顺序不一致。
- en: 'We''ll also look at a small real-valued function so that we can work with floating-point
    values:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将研究一个小型的实值函数，以便我们可以处理浮点值：
- en: '![Getting ready](Image00057.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](Image00057.jpg)'
- en: This function is the cumulative probability density function for standard z-scores.
    After normalizing a variable, the mean of the Z-score values for that variable
    will be zero, and the standard deviation will be one. See the *Creating a partial
    function* recipe in [Chapter 8](text00088.html#page "Chapter 8. Functional and
    Reactive Programming Features") , *Functional and Reactive Programming Features*
    , for more information on the idea of normalized scores.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是标准z分数的累积概率密度函数。对于标准化变量，该变量的Z分数值的平均值将为零，标准差将为一。有关标准化分数概念的更多信息，请参见[第8章](text00088.html#page
    "第8章.功能和响应式编程特性")中的*创建部分函数*配方，*功能和响应式编程特性*。
- en: 'This function, Φ( *n* ), tells us exactly what fraction of the population is
    below a given z-score. For example, Φ(0) = 0.5: half the population has a z-score
    below zero.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数Φ(*n*)告诉我们人口中有多少比例在给定的z分数下。例如，Φ(0) = 0.5：一半的人口的z分数低于零。
- en: This function involves some rather complex processing. The unit tests have to
    reflect the floating-point precision issues.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数涉及一些相当复杂的处理。单元测试必须反映浮点精度问题。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We'll look at mapping (and set) ordering in one recipe. We'll look at the floating
    point separately.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个配方中查看映射（和集合）排序。我们将单独查看浮点数。
- en: Writing doctest examples for mapping or set values
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为映射或集合值编写doctest示例
- en: 'Import the necessary libraries and define the function:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库并定义函数：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We've included the example heading in the document string.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在文档字符串中包含了示例标题。
- en: 'We can replace actual data files with instances of the `StringIO` class from
    the `io` package. This can be used inside the example to provide fixed sample
    data:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用`io`包中的`StringIO`类的实例替换实际数据文件。这可以在示例内部使用，以提供固定的样本数据：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Conceptually, the test case is this. This code will not work properly because
    the keys will be scrambled. However, it can be refactored easily:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从概念上讲，测试用例是这样的。这段代码将无法正常工作，因为键将被打乱。但是，可以很容易地重构它：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We''ve omitted the rest of the output, since it varies each time the test is
    run:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了其余的输出，因为每次运行测试时都会有所不同：
- en: 'The code must be written like this to force the keys into a fixed order:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 代码必须这样编写，以强制将键按固定顺序排列：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The sorted items are in a consistent order.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 排序后的项目是按一致的顺序排列的。
- en: Writing doctest examples for floating-point values
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为浮点值编写doctest示例
- en: 'Import the necessary libraries and define the function:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库并定义函数：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We've left a space for examples in the document string.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在文档字符串中留下了示例的空间。
- en: 'For each example, include an explicit use of `round()` :'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个示例，包括显式使用`round()`：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The float values are rounded so that differences in floating-point implementation
    details don't lead to seemingly incorrect results.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点值四舍五入，以便浮点实现细节的差异不会导致看似不正确的结果。
- en: How it works...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Because of hash randomization, the hash keys used for dictionaries are unpredictable.
    This is an important security feature, and defeats a subtle denial-of-service
    attack. For details, see [http://www.ocert.org/advisories/ocert-2011-003.html](http://www.ocert.org/advisories/ocert-2011-003.html)
    .
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哈希随机化，用于字典的哈希键是不可预测的。这是一个重要的安全特性，可以防止微妙的拒绝服务攻击。有关详细信息，请参见[http://www.ocert.org/advisories/ocert-2011-003.html](http://www.ocert.org/advisories/ocert-2011-003.html)。
- en: 'We have two ways to work with dictionary keys that have no defined order:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法可以处理没有定义顺序的字典键：
- en: 'We can write test cases that are specific to each key:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以编写针对每个键具体的测试用例：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can convert to a data structure with a fixed order. The value of `row.items()`
    is an iterable sequence of pairs with each key and value. The order is not set
    in advance, but we can use the following to force an order:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将其转换为一个具有固定顺序的数据结构。`row.items()`的值是一个可迭代的键值对序列。顺序不是提前设置的，但我们可以使用以下方法来强制排序：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This returns a list with the keys sorted into order. This allows us to create
    a consistent literal value that will always be the same every time the test is
    evaluated.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个按顺序排列的键列表。这使我们能够创建一个一致的文字值，每次评估测试时都将是相同的。
- en: Most floating-point implementations are reasonably consistent. However, there
    are few formal guarantees about the last few bits of any given floating-point
    number. Rather than trust that all 53 bits have exactly the right value, it's
    often much easier to round the value to a value that's a good fit with the problem
    domain.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数浮点实现都是相当一致的。然而，对于任何给定的浮点数的最后几位，很少有正式的保证。与其相信所有的53位都有完全正确的值，往往更容易将值四舍五入为与问题域相匹配的值。
- en: For most modern processors, floating-point values are often either 32 or 64-bit
    values. A 32-bit value has about seven decimal digits. Rounding the value so that
    there are no more than six digits in the value is generally the simplest approach.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数现代处理器，浮点值通常是32位或64位值。32位值大约有七位小数。将值四舍五入，使值中不超过六位数字通常是最简单的方法。
- en: Rounding to six digits does not mean using `round(x, 6)` . The `round()` function
    doesn't preserve a number of digits. This function rounds to a number of digits
    to the right of the decimal point; it doesn't account for digits to the left of
    the decimal point. Rounding a number on the order of 10^(12) to six positions
    to the right of the decimal point leads to 18 digits—too many for a 32-bit value.
    Rounding a number on the order of 10^(-7) to six positions to the right of the
    decimal place leads to zero.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字四舍五入到六位并不意味着使用`round(x, 6)`。`round()`函数不会保留数字的位数。这个函数四舍五入到小数点右边的位数；它不考虑小数点左边的位数。将一个数量级为10^(12)的数字四舍五入到小数点右边的六个位置会得到18位数字，对于32位值来说太多了。将一个数量级为10^(-7)的数字四舍五入到小数点右边的六个位置会得到零。
- en: There's more...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When working with `set` objects, we must also be careful of the order of the
    items. We can generally use `sorted()` to convert a `set` to a `list` and impose
    a specific order.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理`set`对象时，我们还必须注意项目的顺序。我们通常可以使用`sorted()`将`set`转换为`list`并强加特定的顺序。
- en: 'Python `dict` objects show up in a surprising number of places:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Python `dict`对象出现在令人惊讶的许多地方：
- en: When we write a function that uses the `**` to collect a dictionary of argument
    values. There's no guarantee for the order of the arguments.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们编写一个使用`**`来收集参数值字典的函数时。没有保证参数的顺序。
- en: When we use a function such as `vars()` to create a dictionary from local variables,
    or from the attributes of an object, the dictionary has no guaranteed order.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用诸如 `vars()` 这样的函数从局部变量或对象的属性创建字典时，字典没有保证的顺序。
- en: When we write programs that rely on introspection of a class definition, the
    methods are defined in a class-level dictionary object. We can't predict their
    order.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们编写依赖于类定义内省的程序时，方法是在类级别的字典对象中定义的。我们无法预测它们的顺序。
- en: This becomes apparent when there are unreliable test cases. A test case which
    passes or fails seemingly randomly may have a result which is based on a hash
    randomization. Extract the keys and sort them to overcome this problem.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在不可靠的测试用例时，这一点变得明显。一个似乎随机通过或失败的测试用例可能是基于哈希随机化的结果。提取键并对其进行排序以克服这个问题。
- en: 'We can run the tests using this command-line option too:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用这个命令行选项来运行测试：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will turn off hash randomization while running doctest on a specific file,
    `ch11_r03.py` .
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这将关闭哈希随机化，同时在特定文件 `ch11_r03.py` 上运行 doctest。
- en: See also
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Testing things that involve dates or times* recipe, in particular the `now()`
    method of datetime requires some care.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*涉及日期或时间的测试* 配方，特别是 datetime 的 `now()` 方法需要一些小心。'
- en: The *Testing things that involve randomness* recipe will show how to test processing
    that involves `random` .
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*涉及随机性的测试* 配方将展示如何测试涉及 `random` 处理的过程。'
- en: Creating separate test modules and packages
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建单独的测试模块和包
- en: We can do any kind of unit testing in docstring examples. There are some things,
    however, which can become extremely tedious when done this way.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在文档字符串示例中进行任何类型的单元测试。然而，有些事情如果用这种方式做会变得极其乏味。
- en: The `unittest` module allows us to step beyond simple examples. These tests
    rely on test case class definitions. A subclass of `TestCase` can be used to write
    very complex and sophisticated tests; these can be simpler than the same test
    done as doctest examples.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest` 模块允许我们超越简单的示例。这些测试依赖于测试用例类定义。`TestCase` 的子类可以用来编写非常复杂和复杂的测试；这些测试可以比作为
    doctest 示例进行的相同测试更简单。'
- en: The `unittest` module also allows us to package tests outside the docstrings.
    This can be helpful for particularly complex tests of corner cases that aren't
    as helpful when placed in the documentation. Ideally, doctest cases illustrate
    the **happy path –**  the most common use cases. It's common to use `unittest`
    for test cases which are off the happy path.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest` 模块还允许我们在文档字符串之外打包测试。这对于特别复杂的边界情况的测试非常有帮助，当放在文档中时并不那么有用。理想情况下，doctest
    用例说明了 **happy path –** 最常见的用例。通常使用 `unittest` 来进行不在 happy path 上的测试用例。'
- en: How can we create more sophisticated tests?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何创建更复杂的测试？
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'A test can often be summarized by a three-part  *Given-When-Then* story:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试通常可以用一个三部分的 *Given-When-Then* 故事来总结：
- en: '**GIVEN** : Some unit in an initial state or context'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GIVEN**：处于初始状态或上下文中的某个单元'
- en: '**WHEN** : A behavior is requested'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WHEN**：请求一种行为'
- en: '**THEN** : The component under test has some expected result or state change'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**THEN**：被测试的组件有一些预期的结果或状态变化'
- en: 'The `TestCase` class doesn''t precisely follow this three-part structure. It
    has two parts; some design choices must be made regarding where the three parts
    of a test are allocated:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestCase` 类并不完全遵循这种三部分结构。它有两部分；必须做出一些设计选择，关于测试的三个部分应该分配到哪里：'
- en: A `setUp()` method that implements the *Given* aspect of the test case. It can
    also handle the *When* aspect.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个实现测试用例的 *Given* 部分的 `setUp()` 方法。它也可以处理 *When* 部分。
- en: A `runTest()` method that must handle the *Then* aspects. This can also handle
    the *When* aspect. The *Then* conditions are confirmed by a series of assertions.
    These generally use the sophisticated assertion methods of the `TestCase` class.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个必须处理 *Then* 部分的 `runTest()` 方法。这也可以处理 *When* 部分。 *Then* 条件通过一系列断言来确认。这些通常使用
    `TestCase` 类的复杂断言方法。
- en: The choice of where to implement the *When* aspect is tied to the question of
    reuse. In most cases, there are many alternative *When* conditions, each with
    a unique *Then* to confirm correct operation. The *Given* might be common to the
    `setUp()` method, and shared by a number of `TestCase` subclasses. Each subclass
    would have a unique `runTest()` method to implement the *When* and *Then* aspects.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在哪里实现 *When* 部分的选择与重用的问题有关。在大多数情况下，有许多替代的 *When* 条件，每个条件都有一个独特的 *Then* 来确认正确的操作。*Given*
    可能是 `setUp()` 方法的共同部分，并被一些 `TestCase` 子类共享。每个子类都有一个独特的 `runTest()` 方法来实现 *When*
    和 *Then* 部分。
- en: In some cases, the *When* aspect is split into some common parts and some test-case-specific
    parts. In this case, the *When* aspect may be partly defined in the `setUp()`
    method and partly defined in `runTest()` method.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，*When* 部分被分成一些常见部分和一些特定于测试用例的部分。在这种情况下，*When* 部分可能在 `setUp()` 方法中部分定义，部分在
    `runTest()` 方法中定义。
- en: We'll create some tests for a class that is designed to compute some basic descriptive
    statistics. We'd like to provide sample data that's far larger than anything we'd
    ever enter as doctest examples. We'd like to use thousands of data points rather
    than two or three.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为一个设计用于计算一些基本描述性统计的类创建一些测试。我们希望提供的样本数据远远大于我们作为 doctest 示例输入的任何内容。我们希望使用成千上万的数据点而不是两三个。
- en: 'Here''s an outline of the class definition that we''d like to test. We''ll
    only provide the methods and some summaries. The bulk of the code was shown in
    the *Using docstrings for testing* recipe. We''ve omitted all of the implementation
    details. This is just an outline of the class, provided as a reminder of what
    the method names are:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们想要测试的类定义的概要。我们只提供了方法和一些摘要。代码的大部分在*使用文档字符串进行测试*中显示。我们省略了所有的实现细节。这只是类的概要，提醒了方法的名称是什么：
- en: '[PRE36]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Because we're not looking at the implementation details, this is a kind of black
    box testing. The code is a black box—the internals are opaque. To emphasize that,
    we omitted the implementation details from the preceding code.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有关注实现细节，这是一种黑盒测试。代码是一个黑盒——内部是不透明的。为了强调这一点，我们从前面的代码中省略了实现细节。
- en: We'd like to be sure that when we use thousands of samples, the class performs
    correctly. We'd also like to ensure that it works quickly; we'll use this as part
    of an overall performance test, as well as a unit test.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望确保当我们使用成千上万的样本时，这个类能够正确执行。我们也希望确保它能够快速工作；我们将把它作为整体性能测试的一部分，以及单元测试。
- en: How to do it...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll include the test code in the same module as the working code. This will
    follow the pattern of doctest that bundles tests and code together. We''ll use
    the `unittest` module for creating test classes:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将测试代码包含在与工作代码相同的模块中。这将遵循将测试和代码捆绑在一起的doctest模式。我们将使用`unittest`模块来创建测试类：
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We'll also be using `random` to scramble the input data.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`random`来打乱输入数据。
- en: 'Create a subclass of `unittest.TestCase` . Provide this class with a name that
    shows the intent of the test:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`unittest.TestCase`的子类。为这个类提供一个显示测试意图的名称：
- en: '[PRE38]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The *GIVEN-WHEN-THEN* names are very long. We'll rely on `unittest` to discover
    all subclasses of `TestCase` so we don't have to type this class name more than
    once.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*GIVEN-WHEN-THEN*的名称非常长。我们将依赖`unittest`来发现`TestCase`的所有子类，这样我们就不必多次输入这个类名。'
- en: 'Define a `setUp()` method in this class which handles the *Given* aspect of
    the test. This creates a context for test processing:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类中定义一个`setUp()`方法，处理测试的*Given*方面。这将为测试处理创建一个上下文：
- en: '[PRE39]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We've created a collection of `1,001` samples ranging in value from `0` to `1,000`
    . The mean is 500 exactly, so is the median. We've shuffled the data into a random
    order.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含`1,001`个样本的集合，值范围从`0`到`1,000`。平均值恰好是500，中位数也是。我们将数据随机排序。
- en: 'Define a `runTest()` method which handles the *When* aspect of the test. This
    performs the state change:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`runTest()`方法，处理测试的*When*方面。这将执行状态变化：
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add assertions to implement the *Then* aspect of the test. This confirms that
    the state changes worked properly:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加断言来实现测试的*Then*方面。这将确认状态变化是否正常工作：
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To make it very easy to run, add a main program section:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使运行变得非常容易，添加一个主程序部分：
- en: '[PRE42]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With this, the test can be run at Command Prompt. It can also be run from the
    command line.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，测试可以在命令提示符下运行。也可以从命令行运行。
- en: How it works...
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We''re using several parts of the `unittest` module:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`unittest`模块的几个部分：
- en: The `TestCase` class is used to define one test case. This can have a `setUp()`
    method to create the unit and possibly the request . This must have at least a
    `runTest()` to make the request and check the response.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestCase`类用于定义一个测试用例。这可以有一个`setUp()`方法来创建单元和可能的请求。这必须至少有一个`runTest()`来发出请求并检查响应。'
- en: We can have as many of these class definitions in a file as we need to build
    up an appropriate set of tests. For simple classes, there may be only a few test
    cases. For complex modules, there may be dozens or even hundreds of cases.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个文件中有多个这样的类定义，以便构建一个适当的测试集。对于简单的类，可能只有几个测试用例。对于复杂的模块，可能有几十甚至几百个用例。
- en: 'The `unittest.main()` function does several things:'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unittest.main()`函数做了几件事：'
- en: It creates an empty `TestSuite` that will contain all the `TestCase` objects.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建一个空的`TestSuite`，其中包含所有的`TestCase`对象。
- en: It uses a default loader to examine a module and find all of the `TestCase`
    instances. These are loaded into the `TestSuite` . This process is something that
    we might want to modify or extend.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用默认加载器来检查一个模块并找到所有的`TestCase`实例。这些被加载到`TestSuite`中。这个过程是我们可能想要修改或扩展的。
- en: It then runs the `TestSuite` and displays a summary of the results.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后运行`TestSuite`并显示结果的摘要。
- en: 'When we run this module, we''ll see output that looks like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个模块时，我们会看到以下输出：
- en: '[PRE43]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As each test is passed, a `.` is displayed. This shows that the test suite is
    making progress. After the line of `-` is a summary of the tests run, and the
    time. If there are failures, or exceptions, the counts will reflect this.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 每次通过一个测试，都会显示一个`。`。这表明测试套件正在取得进展。在`-`行之后是测试运行的摘要和时间。如果有失败或异常，计数将反映这一点。
- en: Finally, there's a summary of `OK` to show whether all tests passed or any tests
    have failed.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个`OK`的总结，显示所有测试是否都通过或者有任何测试失败。
- en: 'If we change the test slightly to be sure that it fails, we''ll see the following
    output:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们稍微改变测试以确保它失败，我们会看到以下输出：
- en: '[PRE44]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Instead of a `.` for a passing test, a failing test displays an `F` . This is
    followed by the traceback from the assertion which failed. To force the test to
    fail, we changed the expected mean to `501` , which is not the computed mean value
    of `500.0` .
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通过的测试，显示一个`.`，对于失败的测试，显示一个`F`。然后是断言失败的回溯。为了强制测试失败，我们将期望的平均值改为`501`，而不是计算出的平均值`500.0`。
- en: 'There''s a final summary of `FAILED` . This includes the reason why the suite
    as a whole is a failure: `(failures=1)` .'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后有一个`FAILED`的总结。这包括套件作为一个整体失败的原因：`(failures=1)`。
- en: There's more...
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this example, we have two *Then* conditions inside the `runTest()` method.
    If one fails, the test stops as a failure, and the other condition is not exercised.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在`runTest()`方法中有两个*Then*条件。如果一个失败，测试就会停止作为一个失败，另一个条件就不会被执行。
- en: This is a weakness in the design of this test. If the first test fails, we won't
    get all of the diagnostic information we might want. We should avoid independent
    collections of assertions in the `runTest()` method. In many cases, a test case
    may involve multiple dependent assertions; a single failure provides all the diagnostic
    information that's required. The clustering of assertions is a design trade-off
    between simplicity and diagnostic detail.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个测试设计的一个弱点。如果第一个测试失败，我们将得不到所有可能想要的诊断信息。我们应该避免在 `runTest()` 方法中独立收集断言。在许多情况下，一个测试用例可能涉及多个依赖断言；单个失败提供了所有所需的诊断信息。断言的聚类是简单性和诊断细节之间的设计权衡。
- en: 'When we want more diagnostic details, we have two general choices:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要更多的诊断细节时，我们有两个一般选择：
- en: Use multiple test methods instead of `runTest()` . Write multiple methods with
    names that start with `test_` . Remove any method named `runTest()` . The default
    test loader will execute each `test_` method separately, after rerunning the common
    `setUp()` method.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个测试方法而不是 `runTest()`。编写多个以 `test_` 开头的方法。删除任何名为 `runTest()` 的方法。默认的测试加载器将在重新运行公共的
    `setUp()` 方法后，分别执行每个 `test_` 方法。
- en: Use multiple subclasses of the `GIVEN_Summary_WHEN_1k_samples_THEN_mean` class,
    each with a separate condition. Since the `setUp()` is common, this can be inherited.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `GIVEN_Summary_WHEN_1k_samples_THEN_mean` 类的多个子类，每个子类都有一个单独的条件。由于 `setUp()`
    是公共的，这可以被继承。
- en: 'Following the first alternative, the test class would look like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 按照第一种选择，测试类将如下所示：
- en: '[PRE45]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We've refactored the `setUp()` method to include the *Given* and *When* conditions
    of the test. The two independent *Then* conditions are refactored into their own
    separate `test_mean()` and `test_median()` methods. There is no `runTest()` method.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经重构了 `setUp()` 方法，包括测试的 *Given* 和 *When* 条件。两个独立的 *Then* 条件被重构为它们自己单独的 `test_mean()`
    和 `test_median()` 方法。没有 `runTest()` 方法。
- en: Since each test is run separately, we'll see separate error reports for problems
    with computing mean or computing median.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个测试是单独运行的，我们将看到计算均值或计算中位数的问题的单独错误报告。
- en: Some other assertions
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些其他断言
- en: 'The `TestCase` class defines numerous assertions that can be used as part of
    the *Then* condition; here are a few of the most commonly used:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestCase` 类定义了许多断言，可以作为 *Then* 条件的一部分使用；以下是一些最常用的：'
- en: '`assertEqual()` and `assertNotEqual()` compare actual and expected values using
    the default `==` operator.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEqual()` 和 `assertNotEqual()` 使用默认的 `==` 运算符比较实际值和期望值。'
- en: '`assertTrue()` and `assertFalse()` require a single boolean expression.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertTrue()` 和 `assertFalse()` 需要一个布尔表达式。'
- en: '`assertIs()` and `assertIsNot()` use the `is` comparison to determine whether
    the two arguments are references to the same object.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIs()` 和 `assertIsNot()` 使用 `is` 比较来确定两个参数是否是对同一个对象的引用。'
- en: '`assertIsNone()` and `assertIsNotNone()` use `is` to compare a given value
    with `None` .'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIsNone()` 和 `assertIsNotNone()` 使用 `is` 来将给定值与 `None` 进行比较。'
- en: '`assertIsInstance()` and `assertNotIsInstance()` use the `isinstance()` function
    to determine whether a given value is a member of a given class (or tuple of classes).'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIsInstance()` 和 `assertNotIsInstance()` 使用 `isinstance()` 函数来确定给定值是否是给定类（或类元组）的成员。'
- en: '`assertAlmostEquals()` and `assertNotAlmostEquals()` round the given values
    to seven decimal places to see whether most of the digits are equal.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertAlmostEquals()` 和 `assertNotAlmostEquals()` 将给定值四舍五入到七位小数，以查看大部分数字是否相等。'
- en: '`assertRegex()` and `assertNotRegex()` compare a given string using a regular
    expression. This uses the `search()` method of the regular expression to match
    the string.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertRegex()` 和 `assertNotRegex()` 使用正则表达式比较给定的字符串。这使用正则表达式的 `search()` 方法来匹配字符串。'
- en: '`assertCountEqual()` compares two sequences to see whether they have the same
    elements, irrespective of order. This can be handy for comparing dictionary keys
    and sets too.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertCountEqual()` 比较两个序列，看它们是否具有相同的元素，不考虑顺序。这对比较字典键和集合也很方便。'
- en: There are still more assertion methods. A number of them provide ways to detect
    exceptions, warnings, and log messages. Another group provides more type-specific
    comparison capabilities.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的断言方法。其中一些提供了检测异常、警告和日志消息的方法。另一组提供了更多类型特定的比较能力。
- en: 'For example, the mode feature of the `Summary` class produces a list. We can
    use a specific `assertListEqual()` assertion to compare the results:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Summary` 类的模式特性产生一个列表。我们可以使用特定的 `assertListEqual()` 断言来比较结果：
- en: '[PRE46]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: First, we built a collection of 1,000 values. Of those, 97 are copies of the
    number 500\. The remaining 903 elements are copies of numbers between 1 and 42\.
    These numbers have a simple rule—the frequency is the value. This rule makes it
    easier to confirm the results.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们构建了一个包含 1000 个值的集合。其中，有 97 个是数字 500 的副本。剩下的 903 个元素是介于 1 和 42 之间的数字的副本。这些数字有一个简单的规则——频率就是值。这个规则使得确认结果更容易。
- en: The `setUp()` method shuffled the data into a random order. Then the `Summary`
    object is built using the `add()` method.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUp()` 方法将数据随机排序。然后使用 `add()` 方法构建 `Summary` 对象。'
- en: We've used a `test_mode()` method. This allows for expansion to include other
    *Then* conditions on this test. In this case, we examined the first three values
    from the mode to be sure it had the expected distribution of values. The `assertListEqual()`
    compares two `list` objects; if either argument is not a list, we'll get a more
    specific error message showing that the argument wasn't of the expected type.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个 `test_mode()` 方法。这允许扩展到包括这个测试的其他 *Then* 条件。在这种情况下，我们检查了模式的前三个值，以确保它具有预期的值分布。`assertListEqual()`
    比较两个 `list` 对象；如果任一参数不是列表，我们将得到一个更具体的错误消息，显示参数不是预期类型。
- en: Separate tests directory
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单独的测试目录
- en: We've shown the `TestCase` class definitions in the same module as the code
    being tested. For small classes, this can be helpful. Everything related to the
    class can be found in one module file.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在被测试的代码的同一模块中显示了 `TestCase` 类的定义。对于小类来说，这可能是有帮助的。与类相关的一切都可以在一个模块文件中找到。
- en: In larger projects, it's common practice to sequester the test files into a
    separate directory. The tests can be (and often are) extremely large. It's not
    unreasonable to have more test code than application code.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在较大的项目中，将测试文件隔离到一个单独的目录是常见做法。测试可能（而且通常）非常庞大。测试代码的数量可能比应用程序代码还要多，这并不是不合理的。
- en: When this is done, we can rely on the discovery application that's part of the
    `unittest` framework. This application can search all of the files of a given
    directory for test files. Generally, these will be files with names that match
    the pattern `test*.py` . If we use a simple, consistent name for all test modules,
    then they can be located and run with a simple command.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以依赖`unittest`框架中的发现应用程序。该应用程序可以搜索给定目录的所有文件以寻找测试文件。通常，这些文件将是名称与模式`test*.py`匹配的文件。如果我们对所有测试模块使用简单、一致的名称，那么它们可以通过简单的命令定位并运行。
- en: 'The `unittest` loader will search each module in the directory for all classes
    that are derived from the `TestCase` class. This collection of classes within
    the larger collection of modules becomes the complete `TestSuite` . We can do
    this with the `os`  command:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`加载器将在目录中搜索所有从`TestCase`类派生的类。这些类的集合在更大的模块集合中成为完整的`TestSuite`。我们可以使用`os`命令来做到这一点：'
- en: '[PRE47]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will locate all tests in the `tests` directory of a project.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在项目的`tests`目录中找到所有的测试。
- en: See also
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We'll combine `unittest` and `doctest` in the *Combining unittest and doctest
     tests*  recipe. We'll look at mocking external objects in the *Mocking external
    resources* recipe.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在*结合unittest和doctest测试*的示例中结合`unittest`和`doctest`。我们将在*模拟外部资源*的示例中查看模拟外部对象。
- en: Combining unittest and doctest tests
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合unittest和doctest测试
- en: In most cases, we'll have a combination of `unittest` and `doctest` test cases.
    For examples of doctest, see the *Using docstrings for testing* recipe. For examples
    of unittest, see the *Creating separate test modules and packages* recipe.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们将结合使用`unittest`和`doctest`测试用例。有关doctest的示例，请参阅*使用文档字符串进行测试*的示例。有关unittest的示例，请参阅*创建单独的测试模块和包*的示例。
- en: The `doctest` examples are an essential element of the documentation strings
    on modules, classes, methods, and functions. The `unittest` cases will often be
    in a separate `tests` directory in files with names that match the pattern `test_*.py`
    .
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`示例是模块、类、方法和函数的文档字符串的重要组成部分。`unittest`案例通常会在一个单独的`tests`目录中，文件的名称与模式`test_*.py`匹配。'
- en: How can we combine all of these various tests into one tidy package?
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将所有这些不同的测试组合成一个整洁的包呢？
- en: Getting ready
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll refer back to the example from the *Using docstrings for testing* recipe.
    This recipe created tests for a class, `Summary` , that does some statistical
    calculations. In that recipe, we included examples in the docstrings.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾*使用文档字符串进行测试*的示例。这个示例为一个名为`Summary`的类创建了测试，该类执行一些统计计算。在那个示例中，我们在文档字符串中包含了示例。
- en: 'The class started like this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 该类开始如下：
- en: '[PRE48]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The methods have been omitted here so that we can focus on the example provided
    in the docstring.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这里省略了方法，以便我们可以专注于文档字符串中提供的示例。
- en: 'In the *Creating separate test modules and packages* recipe, we wrote some
    `unittest.TestCase` classes to provide additional tests for this class. We created
    class definitions like this:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在*创建单独的测试模块和包*的示例中，我们编写了一些`unittest.TestCase`类来为这个类提供额外的测试。我们创建了类定义如下：
- en: '[PRE49]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This test creates a `Summary` object; this is the *Given* aspect. It then adds
    a number of values to that `Summary` object. This is the *When* aspect of the
    test. The two `test_` methods implement two *Then* aspects of this test.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试创建了一个`Summary`对象；这是*给定*方面。然后向该`Summary`对象添加了许多值。这是测试的*当*方面。这两个`test_`方法实现了这个测试的两个*然后*方面。
- en: 'It''s common to see a project folder structure that looks like this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以看到一个项目文件夹结构，看起来像这样：
- en: '[PRE50]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We have a top-level folder, `git-project-name` , that matches the project name
    in the source code repository. We've assumed that Git is being used, but other
    tools are possible.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个顶层文件夹`git-project-name`，与源代码库中的项目名称匹配。我们假设正在使用Git，但也可能使用其他工具。
- en: Within the top-level directory, we would have some overheads that are common
    to large Python projects. This would include files such as `README.rst` with a
    description of the project, `requirements.txt` , which can be used with `pip`
    to install extra packages, and perhaps `setup.py` to install the package into
    the standard library.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶层目录中，我们将有一些对大型Python项目通用的开销。这将包括文件，如包含项目描述的`README.rst`，可以与`pip`一起使用的`requirements.txt`来安装额外的包，以及可能的`setup.py`来将包安装到标准库中。
- en: The directory `statstools` contains a module file, `summary.py` . This has our
    module that provides interesting and useful features. This module has docstring
    comments scattered around the code.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 目录`statstools`包含一个模块文件`summary.py`。这是我们提供有趣和有用功能的模块。该模块在代码中散布了文档字符串注释。
- en: The directory `tests` contains another module file, `test_summary.py` . This
    has the `unittest` test cases in it. We've chosen the names tests and `test_*.py`
    so that they fit well with automated test discovery.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 目录`tests`包含另一个模块文件`test_summary.py`。其中包含了`unittest`测试用例。我们选择了名称`tests`和`test_*.py`，以便它们与自动化测试发现很好地匹配。
- en: We need to combine all of the tests into a single, comprehensive test suite.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将所有的测试组合成一个单一的、全面的测试套件。
- en: The example we'll show uses `ch11_r01` instead of some cooler name such as `summary`
    . A real project often has clever, meaningful names. The book content is quite
    large, and the names are designed to match the overall chapter and recipe outline.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示的示例使用`ch11_r01`而不是一些更酷的名称，比如`summary`。一个真实的项目通常有巧妙、有意义的名称。书籍内容非常庞大，名称设计得与整体章节和配方大纲相匹配。
- en: How to do it...
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: For this example, we'll assume that the unittest test cases are in a file separate
    from the code being tested. We'll have `ch11_r01` and `test_ch11_r01` .
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本例中，我们假设unittest测试用例在与被测试代码分开的文件中。我们将有`ch11_r01`和`test_ch11_r01`。
- en: 'To use doctest tests, import the `doctest` module. We''ll be combining doctest
    examples with `TestCase` classes to create a comprehensive test suite:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用doctest测试，导入`doctest`模块。我们将把doctest示例与`TestCase`类结合起来，创建一个全面的测试套件：
- en: '[PRE51]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We'll assume that the `unittest` `TestCase` classes are already in place and
    we're adding more tests to the test suite.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设`unittest`的`TestCase`类已经就位，我们正在向测试套件中添加更多的测试。
- en: 'Import the module which is being tested. This module will have strings with
    doctests in it:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入正在测试的模块。这个模块将包含一些doctests的字符串：
- en: '[PRE52]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To implement the `load_tests` protocol, include the following function in the
    test module:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现`load_tests`协议，请在测试模块中包含以下函数：
- en: '[PRE53]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The function must have this name to be found by the test loader.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数必须有这个名字才能被测试加载器找到。
- en: 'To incorporate doctest tests, an additional loader is required. We''ll use
    the `doctest.DocTestSuite` class to create a suite. These tests will be added
    to the suite of tests provided as the `standard_tests` parameter value:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要包含doctest测试，需要一个额外的加载器。我们将使用`doctest.DocTestSuite`类来创建一个测试套件。这些测试将被添加到作为`standard_tests`参数值提供的测试套件中：
- en: '[PRE54]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `loader` argument is the test case loader currently being used. The `standard_tests`
    value will be all of the tests loaded by default. Generally, this is the suite
    of all subclasses of `TestCase` . The pattern value was the value provided to
    the loader.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`loader`参数是当前正在使用的测试用例加载器。`standard_tests`值将是默认加载的所有测试。通常，这是所有`TestCase`的子类的测试套件。模式值是提供给加载器的值。'
- en: We can now add `TestCase` classes and the overall `unittest.main()` function
    to create a comprehensive test module that includes the unittest `TestCase` plus
    all of the doctest examples.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加`TestCase`类和整体的`unittest.main()`函数，以创建一个包括unittest `TestCase`和所有doctest示例的全面测试模块。
- en: 'This can be done by including the following code:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过包括以下代码来完成：
- en: '[PRE55]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This allows us to run the module and execute the tests.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够运行模块并执行测试。
- en: How it works...
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we evaluate `unittest.main()` inside this module, then the test loader
    process is limited to the current module. The loader will find all classes that
    extend `TestCase` . These are the standard tests that are provided to the `load_tests()`
    function.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这个模块中评估`unittest.main()`时，测试加载器的过程将被限制在当前模块中。加载器将找到所有扩展`TestCase`的类。这些是提供给`load_tests()`函数的标准测试。
- en: We will supplement the standard tests with tests created by the `doctest` module.
    Generally, we'll be able to import the module under test and use the `DocTestSuite`
    to build a test suite from the imported module.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用`doctest`模块创建的测试来补充标准测试。通常，我们将能够导入被测试的模块，并使用`DocTestSuite`从导入的模块构建一个测试套件。
- en: The `load_tests()` function is used automatically by the `unittest` module.
    This function can do a variety of things to the test suite that it's given. In
    this example, we've supplemented the test suite with additional tests.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_tests()`函数会被`unittest`模块自动使用。这个函数可以对给定的测试套件执行各种操作。在这个例子中，我们用额外的测试补充了测试套件。'
- en: There's more...
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In some cases, a module may be quite complex; this can lead to multiple test
    modules. There might be several test modules with names such as `tests/test_module_feature.py`
    or something similar to show that there are multiple tests for separate features
    of a complex module.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一个模块可能非常复杂；这可能导致多个测试模块。可能会有几个测试模块，名称类似于`tests/test_module_feature.py`，或者类似的名称，以显示对一个复杂模块的多个功能进行了多次测试。
- en: In other cases, we might have a test module which has tests for several different
    but closely related modules. A package may be decomposed into multiple modules.
    A single test module, however, may cover all of the modules in the package being
    tested.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，我们可能有一个测试模块，其中包含对几个不同但密切相关的模块的测试。一个包可能被分解成多个模块。然而，一个单独的测试模块可能涵盖了被测试包中的所有模块。
- en: 'When combining many smaller modules, there may be multiple suites built in
    the `load_tests()` function. The body might look like this:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当组合许多较小的模块时，可能会在`load_tests()`函数中构建多个测试套件。函数体可能如下所示：
- en: '[PRE56]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This will incorporate `doctests` from multiple modules.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包含来自多个模块的`doctests`。
- en: See also
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For examples of doctest, see the *Using docstrings for testing* recipe. For
    examples of unittest, see the *Creating separate test modules and packages* recipe.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关doctest的示例，请参阅*使用文档字符串进行测试*配方。有关unittest的示例，请参阅*创建单独的测试模块和包*配方。
- en: '![](image/614271.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![](image/614271.jpg)'
- en: Testing things that involve dates or times
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试涉及日期或时间的事物
- en: Many applications rely on `datetime.datetime.now()` to create a timestamp. When
    we use this with a unit test, the results are essentially impossible to predict.
    We have a dependency injection problem here, our application depends on a class
    that we would like to replace only when we're testing.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序依赖于`datetime.datetime.now()`来创建时间戳。当我们在单元测试中使用它时，结果基本上是不可能预测的。我们在这里有一个依赖注入的问题，我们的应用程序依赖于一个我们希望只在测试时替换的类。
- en: One option is to avoid `now()` and `utcnow()` . Instead of using these directly,
    we can create a factory function that emits timestamps. For test purposes, this
    function can be replaced with one that produces known results. It seems awkward
    to avoid using the `now()` method in a complex application.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是避免使用`now()`和`utcnow()`。我们可以创建一个发出时间戳的工厂函数来代替直接使用这些函数。在测试目的中，这个函数可以被替换为产生已知结果的函数。在一个复杂的应用程序中避免使用`now()`方法似乎有些尴尬。
- en: Another option is to avoid direct use of the `datetime` class entirely. This
    requires designing classes and modules that wrap the `datetime` class. A wrapper
    class that produces known values for `now()` can then be used for testing. This,
    too, seems needlessly complex.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是完全避免直接使用`datetime`类。这需要设计包装`datetime`类的类和模块。然后可以使用一个产生`now()`已知值的包装类进行测试。这也似乎是不必要的复杂。
- en: How can we work with `datetime` stamps?
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理`datetime`时间戳？
- en: Getting ready
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll work with a small function that creates a `CSV` file. This file''s name
    will include the date and time. We''ll create files with names that look like
    this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个创建`CSV`文件的小函数。这个文件的名称将包括日期和时间。我们将创建类似于这样的名称的文件：
- en: '[PRE57]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This kind of file-naming convention might be used by a long-running server application.
    The name helps match a file and related log events. It can help to trace the work
    being done by the server.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这种文件命名约定可能会被长时间运行的服务器应用程序使用。该名称有助于匹配文件和相关的日志事件。它可以帮助跟踪服务器正在执行的工作。
- en: 'We''ll use a function like this to create these files:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这样的函数来创建这些文件：
- en: '[PRE58]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This function has a use of `utcnow()` . It is technically possible to redesign
    the function and provide the timestamp as an argument. There are situations where
    this kind of redesign might be helpful. There's also a handy alternative to a
    redesign.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用了`utcnow()`。从技术上讲，可以重新设计函数并将时间戳作为参数提供。在某些情况下，这种重新设计可能会有所帮助。还有一个方便的替代重新设计的方法。
- en: We will create a mock version of the `datetime` module, and patch the test context
    to use mock version instead of the actual version. This test will contain a mock
    class definition for the `datetime` class. Within that class, we'll provide a
    mock `utcnow()` method that will provide the expected response.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建`datetime`模块的模拟版本，并修补测试上下文以使用模拟版本而不是实际版本。这个测试将包含`datetime`类的模拟类定义。在该类中，我们将提供一个模拟的`utcnow()`方法，该方法将提供预期的响应。
- en: 'Since the function being tested creates a file, we need to think about the
    OS consequences of this. What should happen when a file with the same name already
    exists? Should an exception be raised? Should a suffix be added to the file name?
    Depending on our design decision, we may need to have two additional test cases:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 由于被测试的函数创建了一个文件，我们需要考虑这个操作系统的后果。当同名文件已经存在时应该发生什么？应该引发异常吗？文件名应该添加后缀吗？根据我们的设计决定，我们可能需要有两个额外的测试用例：
- en: Given a directory empty of conflicts. In this case, a `setUp()` method to remove
    any previous test output. We may also want to create a `tearDown()` method to
    remove the file after a test.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给出一个没有冲突的目录。在这种情况下，一个`setUp()`方法来删除任何先前的测试输出。我们可能还想创建一个`tearDown()`方法来在测试后删除文件。
- en: Given a directory with a conflicting name. In this case, a `setUp()` method
    will create a conflicting file. We may also want to create a `tearDown()` method
    to remove the file after a test.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给出一个具有冲突名称的目录。在这种情况下，一个`setUp()`方法将创建一个冲突的文件。我们可能还想创建一个`tearDown()`方法来在测试后删除文件。
- en: For this recipe, we'll assume that duplicate file names don't matter. The new
    file should simply overwrite any previous file with no warning or notice. This
    is easy to implement, and often fits the real-world scenario where there's no
    reason to create multiple files less than 1 second apart in time.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将假设重复的文件名并不重要。新文件应该简单地覆盖任何先前的文件，而不会发出警告或通知。这很容易实现，并且通常适用于现实世界的情况，即在不到1秒的时间内创建多个文件没有理由。
- en: How to do it...
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this example, we''ll assume that the `unittest` test cases are the same
    module as the code being tested. Import the `unittest` and `unittest.mock` modules:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将假设`unittest`测试用例与被测试的代码是同一个模块。导入`unittest`和`unittest.mock`模块：
- en: '[PRE59]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `unittest` module is simply imported. To use the features of this module,
    we'll have to qualify the names with `unittest.` . The various names from `unittest.mock`
    were all imported so the names can be used without any qualifier. We'll use a
    number of features of the mock module, and the long qualifying name is awkward.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块只是被导入。要使用这个模块的特性，我们必须用`unittest.`来限定名称。从`unittest.mock`导入了所有名称，因此可以在没有任何限定符的情况下使用这些名称。我们将使用模拟模块的许多特性，而且长的限定名称很笨拙。'
- en: Include the code to be tested. This is shown previously.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括要测试的代码。这是之前显示的。
- en: 'Create the following skeleton for testing. We''ve provided one class definition,
    plus a main script that can be used to execute the tests:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为测试创建以下骨架。我们提供了一个类定义，以及一个可以用来执行测试的主脚本：
- en: '[PRE60]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We didn't define a `load_tests()` function because we don't have any docstring
    tests to include.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有定义`load_tests()`函数，因为我们没有任何文档字符串测试要包含。
- en: 'The `setUp()` method will have several parts:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setUp()`方法将有几个部分：'
- en: 'The sample data to be processed:'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要处理的示例数据：
- en: '[PRE61]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'A mock object for the `datetime` module. This object provides precisely the
    features used by the unit under test. The `Mock` module contains a single `Mock`
    class definition for the `datetime` class. Within that class, it provides a single
    mock method, `utcnow()` , which always provides the same response:'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`datetime`模块的模拟对象。这个对象提供了被测试单元使用的精确特性。`Mock`模块包含了`datetime`类的一个单一`Mock`类定义。在该类中，它提供了一个单一的模拟方法`utcnow()`，它总是提供相同的响应：'
- en: '[PRE62]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here''s the expected file name given the `datetime` object shown above:'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给出上面显示的`datetime`对象的预期文件名：
- en: '[PRE63]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Some additional configuration processing is required to establish the *Given*
    condition. We''ll remove any previous edition of the file to be completely sure
    that the test assertions aren''t using a file from a previous test run:'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要进行一些额外的配置处理来建立*Given*条件。我们将删除要完全确保测试断言不使用来自先前测试运行的文件的任何先前版本：
- en: '[PRE64]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `runTest()` method will have two parts:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`runTest()`方法将有两个部分：'
- en: 'The *When* processing. This will patch the current module, `__main__` , so
    that a reference to `datetime` will be replaced with the `self.mock_datetime`
    object. It will then execute the request in that patched context:'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*When*处理。这将修补当前模块`__main__`，以便将对`datetime`的引用替换为`self.mock_datetime`对象。然后在修补的上下文中执行请求：'
- en: '[PRE65]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The *Then* processing. In this case, we''ll open the expected file, load the
    content, and confirm that the result matches the source data. This finishes with
    the necessary assertion. If the file doesn''t exist, this will raise an `IOError`
    exception:'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Then*处理。在这种情况下，我们将打开预期的文件，加载内容，并确认结果与源数据匹配。这将以必要的断言结束。如果文件不存在，这将引发`IOError`异常：'
- en: '[PRE66]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `unittest.mock` module has two valuable components that we're using here—the
    `Mock` object definition and the `patch()` function.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest.mock`模块在这里有两个有价值的组件——`Mock`对象定义和`patch()`函数。'
- en: When we create an instance of the `Mock` class, we must provide the methods
    and attributes of the resulting object. When we provide a named argument value,
    this will be saved as an attribute of the resulting object. Simple values become
    attributes of the object. Values which are based on a `Mock` object become method
    functions.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`Mock`类的实例时，必须提供结果对象的方法和属性。当我们提供一个命名参数值时，这将被保存为结果对象的属性。简单的值成为对象的属性。基于`Mock`对象的值成为方法函数。
- en: 'When we create an instance of `Mock` that provides the `return_value` (or `side_effect`
    ) named argument value, we''re creating a callable object. Here''s an example
    of a mock object that behaves like a very dumb function:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个提供`return_value`（或`side_effect`）命名参数值的`Mock`实例时，我们正在创建一个可调用的对象。这是一个行为像一个非常愚蠢的函数的模拟对象的例子：
- en: '[PRE67]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We created a mock object, `dumb_function` , that will behave like a callable—a
    function—that only returns the value `12` . For unit testing, this can be very
    handy, since the results are simple and predictable.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个模拟对象`dumb_function`，它将表现得像一个可调用的函数，只返回值`12`。对于单元测试来说，这可能非常方便，因为结果是简单和可预测的。
- en: 'What''s more important is this feature of the `Mock` object:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是`Mock`对象的这个特性：
- en: '[PRE68]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `dumb_function()` tracked each call. We can then make assertions about
    these calls. For example, the `assert_called_with()` method checks the last call
    in the history:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`dumb_function()`跟踪了每次调用。然后我们可以对这些调用进行断言。例如，`assert_called_with()`方法检查历史记录中的最后一次调用：'
- en: '[PRE69]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If the last call really was `dumb_function(18)` , then this succeeds silently.
    If the last call doesn't match the assertion, then this raises an `AssertionError`
    exception that the `unittest` module will catch and register as a test failure.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最后一次调用确实是`dumb_function(18)`，那么这将悄无声息地成功。如果最后一次调用不符合断言，那么会引发一个`AssertionError`异常，`unittest`模块将捕获并注册为测试失败。
- en: 'We can see more detail like this:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样看到更多细节：
- en: '[PRE70]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This assertion checks the entire call history. It uses the `call()` function
    from the `Mock` module to describe the arguments provided in a function call.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这个断言检查整个调用历史。它使用`Mock`模块的`call()`函数来描述函数调用中提供的参数。
- en: The `patch()` function can reach into a module's context and change any reference
    in that context. In this example, we used `patch()` to tweak a definition in the
    `__main__` module—the one currently running. In many cases, we'll import another
    module, and will need to patch that imported module. It's crucial to reach out
    to the context that's in effect for the module under test and patch that reference.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`patch()`函数可以进入模块的上下文并更改该上下文中的任何引用。在这个例子中，我们使用`patch()`来调整`__main__`模块中的定义——当前正在运行的模块。在许多情况下，我们会导入另一个模块，并且需要对导入的模块进行修补。重要的是要到达对被测试模块有效的上下文并修补该引用。'
- en: There's more...
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this example, we created a mock for the `datetime` module that had a very
    narrow feature set.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为`datetime`模块创建了一个模拟，它具有非常狭窄的功能集。
- en: The module had a single element which is an instance of the `Mock` class, named
    `datetime` . For the purposes of unit testing, a mocked class generally behaves
    like a function which returns an object. In this case, the class returned a `Mock`
    object.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块只有一个元素，即`Mock`类的一个实例，名为`datetime`。对于单元测试，模拟的类通常表现得像一个返回对象的函数。在这种情况下，该类返回了一个`Mock`对象。
- en: 'The `Mock` object that stands in for the `datetime` class has a single attribute,
    `utcnow()` . We used the special `return_value` keyword when defining this attribute
    so that it would return a fixed `datetime` instance. We can extend this pattern
    and mock more than one attribute to behave like a function. Here''s an example
    that mocks both `utcnow()` and `now()` :'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 代替`datetime`类的`Mock`对象有一个属性`utcnow()`。我们在定义这个属性时使用了特殊的`return_value`关键字，以便它返回一个固定的`datetime`实例。我们可以扩展这种模式，并模拟多个属性以表现得像一个函数。这是一个模拟`utcnow()`和`now()`的例子：
- en: '[PRE71]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The two mocked methods, `utcnow()` and `now()` , each create a different `datetime`
    object. This allows us to distinguish between the values. We can more easily confirm
    the correct operation of a unit test.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 两个模拟的方法，`utcnow()`和`now()`，分别创建了不同的`datetime`对象。这使我们能够区分这些值。我们可以更容易地确认单元测试的正确操作。
- en: Note that all of this `Mock` object construction executes during the `setUp()`
    method. This is long before the patching done by the `patch()` function. During
    `setUp()` , the `datetime` class is available. In the context of the `with` statement,
    the `datetime` class is unavailable, and is replaced by the `Mock` object.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有这些`Mock`对象的构造都是在`setUp()`方法中执行的。这是在`patch()`函数进行修补之前很久。在`setUp()`期间，`datetime`类是可用的。在`with`语句的上下文中，`datetime`类不可用，并且被`Mock`对象替换。
- en: 'We can add the following assertion to confirm that the `utcnow()` function
    was used properly by the unit under test:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加以下断言来确认`utcnow()`函数被单元测试正确使用：
- en: '[PRE72]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This will examine the `self.mock_datetime` mock object. It looks inside this
    object at the `datetime` attribute, which we've defined to have a `utcnow` attribute.
    We expect that this is called exactly once with no argument values.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检查`self.mock_datetime`模拟对象。它在这个对象中查看`datetime`属性，我们已经定义了一个`utcnow`属性。我们期望这个属性被调用一次，没有参数值。
- en: 'If the `save_data()` function doesn''t make a proper call to `utcnow()` , this
    assertion will detect that failure. It''s essential to test both sides of the
    interface. This leads to two parts to a test:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`save_data()`函数没有正确调用`utcnow()`，这个断言将检测到失败。测试接口的两侧是至关重要的。这导致了测试的两个部分：
- en: The result of the mocked `datetime` was used properly by the unit being tested
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟的`datetime`的结果被被测试的单元适当地使用
- en: The unit being tested made appropriate requests to the mocked `datetime` object
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被测试的单元对模拟的`datetime`对象发出了适当的请求
- en: 'In some cases, we might need to confirm that an obsolete or deprecated method
    is never called. We might have something like this to confirm that another method
    is not used:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要确认一个已过时或不推荐使用的方法从未被调用。我们可能会有类似这样的内容来确认另一个方法没有被使用：
- en: '[PRE73]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This kind of testing is used when refactoring software. In this example, the
    previous version may have used the `now()` method. After the change, the function
    is required to use the `utcnow()` method. We've included a test to be sure that
    the `now()` method is no longer being used.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的测试在重构软件时使用。在这个例子中，之前的版本可能使用了`now()`方法。更改后，函数需要使用`utcnow()`方法。我们已经包含了一个测试，以确保不再使用`now()`方法。
- en: See also
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating separate test modules and packages* recipe has more information
    about basic use of the `unittest` module
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建单独的测试模块和包的配方中有关`unittest`模块的基本使用的更多信息
- en: Testing things that involve randomness
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试涉及随机性的事物
- en: Many applications rely on the `random` module to create random values or put
    values into random order. In many statistical tests, repeated random shuffling
    or random subset calculations are done. When we want to test one of the algorithms,
    the results are essentially impossible to predict.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序依赖于`random`模块来创建随机值或将值随机排序。在许多统计测试中，会进行重复的随机洗牌或随机子集计算。当我们想要测试其中一个算法时，结果基本上是不可能预测的。
- en: 'We have two choices for trying to make the `random` module predictable enough
    to write meaningful unit tests:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种选择来尝试使`random`模块足够可预测，以编写有意义的单元测试：
- en: Set a known seed value, this is common, and we've made heavy use of this in
    many other recipes.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个已知的种子值，这是常见的，在许多其他配方中我们已经大量使用了这个。
- en: Use `unittest.mock` to replace the `random` module with something much less
    random.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`unittest.mock`来用一些不太随机的东西替换`random`模块。
- en: How can we unit test algorithms that involve randomness?
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如何对涉及随机性的算法进行单元测试？
- en: Getting ready
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Given a sample dataset, we can compute a statistical measure such as a mean
    or median. A common next step is to determine the likely values of these statistical
    measures for some overall population. This can done by a technique called **bootstrapping**
    .
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个样本数据集，我们可以计算统计量，如均值或中位数。一个常见的下一步是确定这些统计量对于一些整体人口的可能值。这可以通过一种称为**自助法**的技术来完成。
- en: The idea is to resample the initial set of data repeatedly. Each of the resamples
    provides a different estimate of the statistical measures. This overall set of
    resample metrics shows the likely variance of the measure for the overall population.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是反复对初始数据集进行重采样。每个重采样提供了统计量的不同估计。这个整体的重采样指标集显示了整体人口的测量可能方差。
- en: In order to be sure that a resampling algorithm works, it helps to eliminate
    randomness from the processing. We can resample a carefully planned set of data
    with a non-randomized version of the `random.choice()` function. If this works
    properly, then we have reason to believe that a truly random version will also
    work.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保重采样算法有效，有助于从处理中消除随机性。我们可以使用`random.choice()`函数的非随机版本对精心策划的数据集进行重采样。如果这样可以正常工作，那么我们有理由相信真正的随机版本也会正常工作。
- en: 'Here''s our candidate resampling function. We need to validate this to be sure
    that it properly does sampling with replacement:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的候选重采样函数。我们需要验证这一点，以确保它正确地进行了带替换的抽样：
- en: '[PRE74]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We would normally apply this `resample()` function to populate a `Counter`
    object that tracks each distinct value for a particular measure such as the mean.
    The overall resampling procedure looks like this:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会应用`resample()`函数来填充一个`Counter`对象，用于跟踪特定测量值的每个不同值，例如均值。整体的重采样过程如下：
- en: '[PRE75]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This evaluates the `resample()` function `1,000` times. This will lead to a
    number of subsets, each of which may have a distinct value for the mean. These
    values are used to populate the `mean_distribution` object.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这评估了`resample()`函数`1,000`次。这将导致许多子集，每个子集可能具有不同的均值。这些值用于填充`mean_distribution`对象。
- en: The histogram for `mean_distribution` will provide a meaningful estimate for
    population variance. This estimate of the variance will help show the population's
    most likely actual mean value.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`mean_distribution`的直方图将为人口方差提供有意义的估计。这个方差的估计将有助于显示人口最可能的实际均值。'
- en: How to do it...
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Define an outline of the overall test class:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义整体测试类的大纲：
- en: '[PRE76]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We've included a main program so that we can simply run the module to test it.
    This is handy when working in tools such as IDLE; we can use the *F5* key to test
    the module after making a change.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了一个主程序，这样我们就可以简单地运行模块来测试它。在使用诸如IDLE之类的工具时，这很方便；我们可以在进行更改后使用*F5*键来测试模块。
- en: 'Define a mock version of the `random.choice()` function. We''ll provide a mock
    data set, `self.data` , and a mock response to the `choice()` function:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`random.choice()`函数的模拟版本。我们将提供一个模拟数据集`self.data`，以及对`choice()`函数的模拟响应：
- en: '[PRE77]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We've defined the `choice()` function using the `side_effect` attribute. This
    will return values one at a time from the given sequence. We've provided eight
    mock values that are distinct from the source sequence so that we readily identify
    the outputs from the `choice()` function.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`side_effect`属性定义了`choice()`函数。这将从给定序列中一次返回一个值。我们提供了八个模拟值，这些值与源序列不同，因此我们可以很容易地识别`choice()`函数的输出。
- en: 'Define the *When* and *Then* aspects of the test. In this case, we''ll patch
    the `__main__` module to replace the reference to the `random` module. The test
    can then establish that the result has the expected set of values and that the
    `choice()` function was called multiple times:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义测试的*When*和*Then*方面。在这种情况下，我们将修补`__main__`模块，以替换对`random`模块的引用。然后测试可以建立结果是否具有预期的值，并且`choice()`函数是否被多次调用：
- en: '[PRE78]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: How it works...
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When we create an instance of the `Mock` class, we must provide the methods
    and attributes of the resulting object. When the `Mock` object includes a named
    argument value, this will be saved as an attribute of the resulting object.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`Mock`类的实例时，必须提供生成对象的方法和属性。当`Mock`对象包括一个命名参数值时，这将被保存为生成对象的属性。
- en: When we create an instance of `Mock` that provides the `side_effect` named argument
    value, we're creating a callable object. The callable object will return a value
    from the `side_effect` list each time the `Mock` object is called.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个提供`side_effect`命名参数值的`Mock`实例时，我们正在创建一个可调用对象。可调用对象将从`side_effect`列表中返回一个值，每次调用`Mock`对象时。
- en: 'Here''s an example of a mock object that behaves like a very dumb function:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个行为像一个非常愚蠢的函数的模拟对象的例子：
- en: '[PRE79]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: First, we created a `Mock` object and assigned it to the name `dumb_function`
    . The `side_effect` attribute of this `Mock` object provides a short list of two
    distinct values that will be returned.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个`Mock`对象，并将其分配给名称`dumb_function`。这个`Mock`对象的`side_effect`属性提供了一个将返回的两个不同值的短列表。
- en: The example then evaluates `dumb_function()` two times with two different argument
    values. Each time, the next value is returned from the `side_effect` list. The
    third attempt raises a `StopIteration` exception that becomes a test failure.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 然后的例子使用两个不同的参数值两次评估`dumb_function()`。每次，下一个值从`side_effect`列表中返回。第三次尝试引发了一个`StopIteration`异常，导致了测试失败。
- en: This behavior allows us to write a test that detects certain kinds of improper
    uses of a function or a method. If the function is called too many times, an exception
    will be raised. Other improper uses must be detected with the various kinds of
    assertions that can be used for `Mock` objects.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为使我们能够编写一个测试，检测函数或方法的某些不当使用。如果函数被调用太多次，将引发异常。其他不当使用必须使用各种断言来检测可以用于`Mock`对象的各种类型。
- en: There's more...
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can easily replace other features of the `random` module with mock objects
    that provide appropriate behavior without actually being random. We could, for
    example, replace the `shuffle()` function with a function that provides a known
    order. We might follow the above test design pattern like this:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地用提供适当行为的模拟对象替换`random`模块的其他特性，而不实际上是随机的。例如，我们可以用一个提供已知顺序的函数替换`shuffle()`函数。我们可以像这样遵循上面的测试设计模式：
- en: '[PRE80]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This mock `shuffle()` function returns a distinct set of values that can be
    used to confirm that some process is making proper use of the `random` module.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模拟的`shuffle()`函数返回一组不同的值，可以用来确认某个过程是否正确使用了`random`模块。
- en: See also
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using set methods and operators* , *Creating dictionaries – inserting and
    updating*  recipes in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data
    Structures – list, set, dict") ,  *Built-in Data Structures – list, set, dict*
    , and the  *Using cmd for creating command-line applications* recipe in [Chapter
    5](text00063.html#page "Chapter 5. User Inputs and Outputs") , *User Inputs and
    Outputs* , show how to seed the random number generator to create a predictable
    sequence of values.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](text00048.html#page "第4章。内置数据结构-列表、集合、字典")中，*内置数据结构-列表、集合、字典*，*使用集合方法和运算符*，*创建字典-插入和更新*配方，以及[第5章](text00063.html#page
    "第5章。用户输入和输出")中的*用户输入和输出*，*使用cmd创建命令行应用程序*配方，展示了如何种子随机数生成器以创建可预测的值序列。
- en: In [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , there are several other recipes that show
    the alternative approach, for example, *Using a class to encapsulate data + processing*
    , *Designing classes with lots of processing* , *Optimizing small objects with
    __slots__* , and *Using properties for lazy attributes* .
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](text00070.html#page "第6章。类和对象的基础")中，*类和对象的基础*，还有其他几个配方展示了另一种方法，例如*使用类封装数据+处理*，*设计具有大量处理的类*，*使用__slots__优化小对象*和*使用惰性属性*。
- en: Also, in [Chapter 7](text00079.html#page "Chapter 7. More Advanced Class Design")
    , *More Advanced Class Design* , see *Choosing between inheritance and extension –
    the is-a question* , *Separating concerns via multiple inheritance* , *Leveraging
    Python's duck typing* , *Creating a class which has orderable objects* , and *Defining
    an ordered collection* recipes.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，在[第7章](text00079.html#page "第7章。更高级的类设计")中，*更高级的类设计*，请参阅*选择继承和扩展之间的选择-是一个问题*，*通过多重继承分离关注*，*利用Python的鸭子类型*，*创建一个具有可排序对象的类*和*定义一个有序集合*配方。
- en: Mocking external resources
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟外部资源
- en: The *Testing things that involve dates or times* and *Testing things that involve
    randomness* recipes show techniques for mocking relatively simple objects. In
    the case of the  *Testing things that involve dates or times* recipe, the object
    being mocked is essentially stateless, and a single return value works nicely.
    In the *Testing things that involve randomness* recipe, the object has a state
    change, but the state change does not depend on any input arguments.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '*涉及日期或时间的测试*和*涉及随机性的测试*配方展示了模拟相对简单对象的技术。在*涉及日期或时间的测试*配方中，被模拟的对象基本上是无状态的，一个返回值就可以很好地工作。在*涉及随机性的测试*配方中，对象有一个状态变化，但状态变化不依赖于任何输入参数。'
- en: In these simpler cases, a test provides a series of requests to an object. Mock
    objects can be built which are based on a known and carefully planned sequence
    of state changes. The test case follows the object's internal state changes precisely.
    This is sometimes called white box testing because the implementation details
    of the object under test are required to define the test sequence and the mock
    objects.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更简单的情况下，测试提供了一系列请求给一个对象。可以构建基于已知和精心计划的状态变化序列的模拟对象。测试用例精确地遵循对象的内部状态变化。这有时被称为白盒测试，因为需要定义测试序列和模拟对象的实现细节。
- en: In some cases, however, a test scenario may not involve a well-defined sequence
    of state changes. The unit under test may make requests in a difficult-to-predict
    order. This is sometimes a consequence of black box testing where the implementation
    details are not known.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，测试场景可能不涉及明确定义的状态更改序列。被测试的单元可能以难以预测的顺序发出请求。这有时是黑盒测试的结果，其中实现细节是未知的。
- en: How can we create more sophisticated mock objects that have internal state and
    make their own internal state changes?
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何创建更复杂的模拟对象，这些对象具有内部状态并进行自己的内部状态更改？
- en: Getting ready
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll look at mocking a stateful RESTful web services request. In this case,
    we'll be using a database API for the Elastic database. See [https://www.elastic.co/](https://www.elastic.co/)
    for more information on this database. The database has the advantage of working
    with simple RESTful web services. These can easily be mocked to simple, fast unit
    tests.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究如何模拟有状态的RESTful Web服务请求。在这种情况下，我们将使用弹性数据库的数据库API。有关此数据库的更多信息，请参见[https://www.elastic.co/](https://www.elastic.co/)。该数据库具有使用简单的RESTful
    Web服务的优势。这些可以很容易地模拟为简单、快速的单元测试。
- en: For this recipe, we'll test a function that uses the RESTful API to create records.
    **Representational State Transfer** ( **REST** ) is a technique for using   **Hypertext
    Transfer Protocol** ( **HTTP** ) to transfer a representation of an object's state
    between processes. To create a database record, for example, a client will transfer
    a representation of an object's state to the database server, using HTTP `POST`
    requests. In many cases, JSON notation is used to represent object state.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将测试一个使用RESTful API创建记录的函数。**表述性状态转移**（**REST**）是一种使用**超文本传输协议**（**HTTP**）在进程之间传输对象状态表示的技术。例如，要创建一个数据库记录，客户端将使用HTTP
    `POST`请求将对象状态的表示传输到数据库服务器。在许多情况下，JSON表示法用于表示对象状态。
- en: Testing this function will involve mocking one part of the `urllib.request`
    module. Replacing the `urlopen()` function will allow a test case to simulate
    database activity. This will allow us to test a function that depends on web services
    without actually making potentially expensive or slow external requests.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这个函数将涉及模拟`urllib.request`模块的一部分。替换`urlopen()`函数将允许测试用例模拟数据库活动。这将允许我们测试依赖于Web服务的函数，而不实际进行可能昂贵或缓慢的外部请求。
- en: 'There are two overall approaches to working with the elastic search API in
    our application software:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用软件中，有两种总体方法可以使用弹性搜索API：
- en: We can install the Elastic database on our laptop or some server to which we
    have access. The installation is a two-part process that starts by installing
    a proper **Java Developer Kit** ( **JDK** ) and then installs the ElasticSearch
    software. We won't go into details here, because we have an alternative which
    seems simpler.
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在我们的笔记本电脑或一些我们可以访问的服务器上安装弹性数据库。安装是一个两部分的过程，首先安装适当的**Java开发工具包**（**JDK**），然后安装ElasticSearch软件。我们不会在这里详细介绍，因为我们有一个似乎更简单的替代方案。
- en: 'The URLs to create and access objects on a local computer will look like this:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地计算机上创建和访问对象的URL将如下所示：
- en: '[PRE81]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The requests will use a number of data items in the body of the request. These
    requests don't require any of the HTTP headers for security or authentication
    purposes.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 请求将在请求的正文中使用多个数据项。这些请求不需要任何HTTP头部用于安全或认证目的。
- en: We can use a hosting service such as [http://orchestrate.io](http://orchestrate.io)
    . This requires signing up with the service to get an API key instead of installing
    software. An API key grants access to a defined application. Within the application,
    a number of collections can be created. Since we won't have to install additional
    software, this seems like a handy way to proceed.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用诸如[http://orchestrate.io](http://orchestrate.io)之类的托管服务。这需要注册该服务以获取API密钥，而不是安装软件。API密钥授予对定义应用程序的访问权限。在应用程序中，可以创建多个集合。由于我们不必安装额外的软件，这似乎是一个方便的方法。
- en: 'The URLs to work with objects on a remote server will look like this:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程服务器上处理对象的URL将如下所示：
- en: '[PRE82]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The requests will also use a number of HTTP headers to provide information to
    the host. Next, We'll look at details of this service.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 请求还将使用多个HTTP头部向主机提供信息。接下来，我们将详细了解这项服务。
- en: 'The data payload for the document to be created will look like this:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建的文档的数据有效载荷将如下所示：
- en: '[PRE83]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This JSON document represents a log entry. This came from the `sample.log` file
    used in earlier examples. This document can be understood as a specific instance
    of the event type that will be saved in the `eventlog` index of the database.
    The object has four attributes with string values.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JSON文档代表了一个日志条目。这是在之前的示例中使用的`sample.log`文件中提取的。这个文档可以被理解为将保存在数据库的`eventlog`索引中的事件类型的特定实例。该对象有四个属性，其值为字符串。
- en: The *Reading complex formats using regular expressions* recipe in [Chapter 9](text00099.html#page
    "Chapter 9. Input/Output, Physical Format, and Logical Layout") , *Input/Output,
    Physical Format, and Logical Layout* , shows how to parse a complex log file.
    In the *Using multiple contexts for reading and writing files* recipe, the complex
    log records were written to a `CSV` file. In this example, we'll show how the
    log records could be placed into cloud-based storage using a database such as
    Elastic.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](text00099.html#page "第9章。输入/输出、物理格式和逻辑布局")的*使用正则表达式读取复杂格式*配方中，*输入/输出、物理格式和逻辑布局*，展示了如何解析复杂的日志文件。在*使用多个上下文读写文件*的配方中，复杂的日志记录被写入了`CSV`文件。在这个例子中，我们将展示如何将日志记录放入使用弹性等数据库的基于云的存储中。
- en: Creating an entry document in the entrylog collection
  id: totrans-500
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在entrylog集合中创建一个条目文档
- en: We're going to create entry documents in an `entrylog` collection in the database.
    An HTTP `POST` request is used to create new items. The response of `201 Created`
    will indicate that the database created the new event.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在数据库的`entrylog`集合中创建条目文档。使用HTTP `POST`请求创建新项目。`201 Created`的响应将表明数据库创建了新事件。
- en: 'To use the `orchestrate.io` database service, each request has a base URL.
    We can define this with a string like this:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `orchestrate.io` 数据库服务，每个请求都有一个基本 URL。我们可以用这样的字符串来定义它：
- en: '[PRE84]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `https` scheme is used so that the **Secure Socket Layer** ( **SSL** ) is
    used to assure that the data is private between client and server. The host name
    is `api.orchestrate.io` . Each request will have a URL based on this base service
    definition.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `https` 方案是为了确保数据在客户端和服务器之间是私密的，使用 **SSL** 。主机名是 `api.orchestrate.io`。每个请求将基于这个基本服务定义的
    URL。
- en: 'The HTTP headers for each request will look like this:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求的 HTTP 头将如下所示：
- en: '[PRE85]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `Accept` header shows what kind of response is expected. The `Content-Type`
    header shows what kind of document representation is being used for the content.
    These two headers direct the database to use JSON representation for object state.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`Accept` 头显示期望的响应类型。`Content-Type` 头显示内容所使用的文档表示类型。这两个头指示数据库使用 JSON 表示对象状态。'
- en: 'The `Authorization` header is how the API key is sent. The value for this header
    is a rather complex string. It''s easiest to build the encoded API key string
    code like the following:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '`Authorization` 头是 API 密钥的发送方式。这个头的值是一个相当复杂的字符串。最容易的方法是构建编码的 API 密钥字符串代码如下：'
- en: '[PRE86]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This snippet of code will combine a username and password into a single string
    of characters, and then encode those characters into a stream of bytes using the
    `UTF-8` encoding scheme. The `base64` module creates a second stream of bytes.
    In this output stream, four bytes will contain the bits that comprise three input
    bytes. The bytes are chosen from a simplified alphabet. This value is then converted
    back into Unicode characters along with the keyword `'Basic '` . This value can
    be used with the `Authorization` header.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将把用户名和密码组合成一个字符流，然后使用 `UTF-8` 编码方案将这些字符编码为字节流。`base64` 模块创建了第二个字节流。在这个输出流中，四个字节将包含构成三个输入字节的位。这些字节是从一个简化的字母表中选择的。然后将这个值与关键字
    `'Basic '` 转换回 Unicode 字符。这个值可以与 `Authorization` 头一起使用。
- en: 'It''s easiest to work with a RESTful API by creating a `Request` object. The
    class is defined in the `urllib.request` module. The `Request` object combines
    the data, URL, and headers, and names a specific HTTP method. Here''s the code
    to create a `Request` instance:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个 `Request` 对象来使用 RESTful API 是最容易的。该类在 `urllib.request` 模块中定义。`Request`
    对象结合了数据、URL 和头，并命名了特定的 HTTP 方法。以下是创建 `Request` 实例的代码：
- en: '[PRE87]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The request object includes four elements:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 请求对象包括四个元素：
- en: The value of the `url` parameter is the base service URL plus the collection
    name, `/v0/eventlog` . The `v0` in the path is the version information which must
    be provided with each request.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url` 参数的值是基本服务 URL 加上集合名称，`/v0/eventlog`。路径中的 `v0` 是必须在每个请求中提供的版本信息。'
- en: The `headers` parameter includes the `Authorization` header which has the API
    Key which authorizes access to the application.
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`headers` 参数包括具有授权访问应用程序的 API 密钥的 `Authorization` 头。'
- en: The method of `POST` will create a new object in the database.
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` 方法将在数据库中创建一个新对象。'
- en: The `data` parameter is the document to save. We've converted a Python object
    to a string in JSON notation. Then encoded the Unicode characters into bytes using
    `UTF-8` encoding.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data` 参数是要保存的文档。我们已经将一个 Python 对象转换为 JSON 表示的字符串。然后使用 `UTF-8` 编码将 Unicode
    字符编码为字节。'
- en: Seeing a typical response
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看典型的响应
- en: 'The processing involves sending the request and receiving a response. The `urlopen()`
    function accepts the `Request` object as an argument; this builds the request
    that''s transmitted to the database server. The response from the database server
    will include three elements:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 处理涉及发送请求和接收响应。`urlopen()` 函数接受 `Request` 对象作为参数；这构建了发送到数据库服务器的请求。来自数据库服务器的响应将包括三个元素：
- en: A status. This includes both a numeric code and a reason string. When creating
    a document, the expected response code is `201` and the string is `CREATED` .
    For many other requests, the code is `200` and the string is `OK` .
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态。这包括一个数字代码和一个原因字符串。创建文档时，预期的响应代码是 `201`，字符串是 `CREATED`。对于许多其他请求，代码是 `200`，字符串是
    `OK`。
- en: 'The response will also have headers. For a creation request, these will include
    the following:'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应还将包括头信息。对于创建请求，这些将包括以下内容：
- en: '[PRE88]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The `Content-Type` header tells us that the content is encoded in JSON. The
    `Location` header provides a URL that can be used to retrieve the object which
    is created. It also provides an `ETag` header, which is a hashed summary of the
    current state of the object; this helps to support caching local copies of an
    object. Other headers may be present; we've just shown `...` in the example.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '`Content-Type` 头告诉我们内容是以 JSON 编码的。`Location` 头提供了一个 URL，可以用来检索创建的对象。它还提供了一个
    `ETag` 头，这是对象当前状态的哈希摘要；这有助于支持缓存对象的本地副本。其他头可能存在；我们在示例中只显示了 `...` 。'
- en: The response may have a body. If present, this will be a JSON-encoded document
    (or documents) retrieved from the database. The body must be read with the `read()`
    method of the response. A body can be quite large; a `Content-Length` header provides
    the exact number of bytes.
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应可能有一个主体。如果存在，这将是从数据库检索到的一个 JSON 编码的文档（或文档）。必须使用响应的 `read()` 方法来读取主体。主体可能非常大；`Content-Length`
    头提供了确切的字节数。
- en: Client class for database access
  id: totrans-525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库访问的客户端类
- en: We'll define a simple class for database access. A class can provide context
    and status information for multiple related operations. When working with the
    Elastic database, an access class can create the request headers dictionary just
    once and reuse it in multiple requests.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为数据库访问定义一个简单的类。一个类可以为多个相关操作提供上下文和状态信息。在使用 Elastic 数据库时，访问类可以只创建一次请求头字典，并在多个请求中重复使用。
- en: 'Here''s the essence of a database client class. We''ll show this in several
    sections. First, the overall class definition:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据库客户端类的本质。我们将在几个部分中展示这一点。首先是整个类的定义：
- en: '[PRE89]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This defines a class-level variable, `service` , with the scheme and hostname.
    The initialization method, `__init__()` , can build the headers that are used
    by the various database operations:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个类级别的变量`service`，带有方案和主机名。初始化方法`__init__()`可以构建各种数据库操作中使用的标头：
- en: '[PRE90]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This method takes the API key and creates a set of headers that relies on HTTP
    basic authorization. The password is not used by the orchestrate service. We've
    included it, however, because the username and password are used for the example
    unit test case.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受API密钥并创建一组依赖于HTTP基本授权的标头。密码不会被编排服务使用。但我们已经包含了它，因为用户名和密码用于示例单元测试用例。
- en: 'Here''s the method:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这是方法：
- en: '[PRE91]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This function can combine a username and a password to create the value for
    the HTTP `Authorization` header. The `orchestrate.io` API uses an assigned API
    key as the username; the password is a zero-length string, `''` . The API key
    is assigned when someone signs up for their service. The free level of service
    allows a reasonable number of transactions and a comfortably small database.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以将用户名和密码组合起来，创建HTTP`Authorization`标头的值。`orchestrate.io` API使用分配的API密钥作为用户名；密码是一个零长度的字符串`''`。当有人注册他们的服务时，API密钥就被分配了。免费级别的服务允许合理数量的交易和一个舒适小的数据库。
- en: We've included a unit test case in the form of a docstring. This provides evidence
    that the results are correct. The test case comes from the Wikipedia page on HTTP
    basic authentication.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了一个以文档字符串形式的单元测试用例。这提供了结果正确的证据。测试用例来自维基百科关于HTTP基本认证的页面。
- en: 'The final part is a method to load one data item into the `eventlog` collection
    of the database:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分是一个将一个数据项加载到数据库的`eventlog`集合中的方法：
- en: '[PRE92]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This function builds a `Request` object with the four required pieces of information—the
    full URL, the HTTP headers, the method string, and the encoded data. In this case,
    the data is encoded as a JSON string, and the JSON string encoded into bytes using
    the `UTF-8` encoding scheme.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用四个必需的信息构建一个`Request`对象——完整的URL、HTTP标头、方法字符串和编码数据。在这种情况下，数据被编码为JSON字符串，并使用`UTF-8`编码方案将JSON字符串编码为字节。
- en: Evaluating the `urlopen()` function sends the request and retrieves a response
    object. This object is used as a context manager. The `with` statement assures
    that the resources are released properly even if there is an exception raised
    during response processing.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 评估`urlopen()`函数会发送请求并检索一个响应对象。这个对象被用作上下文管理器。`with`语句确保即使在响应处理过程中引发异常，资源也会被正确释放。
- en: A `POST` method should respond with a status of `201.` Any other status is a
    problem. In this code, the status is checked with an `assert` statement. It might
    be better to provide a message such as `Expected 201 status, got {}.format(response.status)`
    .
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`方法应该以`201`状态响应。任何其他状态都是问题。在这段代码中，状态是通过`assert`语句进行检查的。最好提供一条消息，比如`Expected
    201 status, got {}.format(response.status)`。'
- en: The headers are then examined to get the `Location` header. This provides a
    URL fragment for locating the object which was created.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 然后检查标头以获取`Location`标头。这提供了一个用于定位已创建对象的URL片段。
- en: How to do it...
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create the database access module. This module will have the `ElasticClient`
    class definition. It will also have any additional definitions that this class
    needs.
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据库访问模块。这个模块将包含`ElasticClient`类定义。它还将包含这个类需要的任何其他定义。
- en: 'This recipe will use `unittest` and `doctest` to create a unified suite of
    tests. It will use the `Mock` class from `unittest.mock` , as well as `json` .
    Since this module is separate from the unit under test, it needs to import `ch11_r08_load`
    , which has the class definitions that will be tested:'
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个示例将使用`unittest`和`doctest`来创建一个统一的测试套件。它将使用`unittest.mock`中的`Mock`类，以及`json`。由于这个模块是与被测试的单元分开的，它需要导入`ch11_r08_load`，该模块包含将被测试的类定义：
- en: '[PRE93]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Here''s the overall framework for a test case. We''ll fill in the `setUp()`
    and `runTest()` methods of this test below. The name shows that we''re given an
    instance of `ElasticClient` , when we invoke `load_eventlog()` , then a proper
    RESTful API request was made:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个测试用例的整体框架。我们将在下面填写这个测试的`setUp()`和`runTest()`方法。名称显示了当我们调用`load_eventlog()`时，我们得到了一个`ElasticClient`实例，然后进行了一个正确的RESTful
    API请求：
- en: '[PRE94]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The first part of the `setUp()` method is a mock context manager that provides
    responses similar to the `urlopen()` function:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setUp()`方法的第一部分是一个模拟上下文管理器，提供类似于`urlopen()`函数的响应：'
- en: '[PRE95]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: When `urlopen()` is called, the return value is a response object which behaves
    like a context manager. The best way to mock this is to return a mock context
    manager. The mock context manager's `__enter__()` method does the real work to
    create a response object. In this case, the `side_effect` attribute identifies
    a helper function that will be called to prepare the result from calling the `__enter__()`
    method. The `self.create_response` has not been defined yet. We'll use a function,
    defined as follows.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`urlopen()`时，返回值是一个行为像上下文管理器的响应对象。模拟这个的最佳方法是返回一个模拟上下文管理器。模拟上下文管理器的`__enter__()`方法执行真正的工作来创建响应对象。在这种情况下，`side_effect`属性标识了一个辅助函数，该函数将被调用来准备从调用`__enter__()`方法的结果。`self.create_response`还没有被定义。我们将使用一个函数，定义如下。
- en: 'The second part of the `setUp()` method is some mock data to be loaded:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setUp()`方法的第二部分是一些要加载的模拟数据：'
- en: '[PRE96]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In a more complex test, we might want to simulate a large, iterable collection
    of documents.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个更复杂的测试中，我们可能想要模拟一个大型的可迭代文档集合。
- en: 'Here''s the `create_response()` helper method that builds response-like objects.
    The response objects can be complex, so we''ve defined a function to create them:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个`create_response()`辅助方法，用于构建类似响应的对象。响应对象可能很复杂，因此我们定义了一个函数来创建它们：
- en: '[PRE97]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This method uses `self.mock_urlopen.call_args` to examine the last call to this
    `Mock` object. This call's arguments are a tuple of positional argument values
    and keyword arguments. The first `[0]` index picks the positional argument value
    from the tuple. The second `[0]` index picks the first positional argument value.
    This will be the object to be loaded to the database. The value of the `hex()`
    function is a string that includes a `0x` prefix that we discard.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法使用`self.mock_urlopen.call_args`来检查对这个`Mock`对象的最后一次调用。这个调用的参数是一个包含位置参数值和关键字参数的元组。第一个`[0]`索引从元组中选择位置参数值。第二个`[0]`索引选择第一个位置参数值。这将是要加载到数据库中的对象。`hex()`函数的值是一个包含`0x`前缀的字符串，我们将其丢弃。
- en: In a more complex test, it may be necessary for this method to keep a cache
    of objects loaded into the database to make more accurate database-like responses.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的测试中，可能需要这个方法来保持一个加载到数据库中的对象的缓存，以便更准确地模拟类似数据库的响应。
- en: 'The `runTest()` method makes a patch to the module under test. It locates the
    reference from `ch11_r08_load` to `urllib.request` and to the `urlopen()` function.
    This is replaced with the `mock_urlopen` replacement:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`runTest()`方法对被测试的模块进行了补丁。它定位了从`ch11_r08_load`到`urllib.request`和`urlopen()`函数的引用。这些引用被替换为`mock_urlopen`替代品：'
- en: '[PRE98]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This test follows the `ElasticClient` requirements of first creating a client
    object. Instead of using an actual API key, this uses a username and password
    that will create a known value for the `Authorization` header. The result of the
    `load_eventlog()` is a response-like object that can be examined to see whether
    it has the proper values.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试遵循`ElasticClient`首先创建一个客户端对象的要求。它不使用实际的API密钥，而是使用用户名和密码，这将为`Authorization`头创建一个已知的值。`load_eventlog()`的结果是一个类似响应的对象，可以检查它是否具有正确的值。
- en: All of this interaction will be done through the mock objects. We can use the
    various assertions to confirm that a proper request object was created. The test
    examines four attributes of the request object and also checks to be sure that
    the context was used properly.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些交互都将通过模拟对象完成。我们可以使用各种断言来确认是否创建了一个正确的请求对象。测试检查请求对象的四个属性，并确保上下文的使用是否正确。
- en: 'We''ll also define a `load_tests()` function to combine this `unittest` suite
    with any test examples found docstrings of `ch11_r08_load` :'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将定义一个`load_tests()`函数，将这个`unittest`套件与`ch11_r08_load`的文档字符串中找到的任何测试示例结合起来：
- en: '[PRE99]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Finally, we''ll provide the overall main program to run the complete suite.
    This makes it easy to run the test module as a standalone script:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将提供一个整体的主程序来运行完整的测试套件。这样可以很容易地将测试模块作为独立的脚本运行：
- en: '[PRE100]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: How it works...
  id: totrans-566
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'This recipe combines a number of `unittest` and `doctest` features to create
    a sophisticated test case. The features include:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例结合了许多`unittest`和`doctest`特性，创建了一个复杂的测试用例。这些特性包括：
- en: Creating a context manager
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建上下文管理器
- en: Using the side-effect feature to create a dynamic, stateful test
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用side-effect功能创建动态、有状态的测试
- en: Mocking a complex object
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟复杂对象
- en: Using the load tests protocol to combine doctest and unittest cases
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用加载测试协议来结合doctest和unittest案例
- en: We'll look at each of these features separately.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别查看这些特性。
- en: Creating a context manager
  id: totrans-573
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建上下文管理器
- en: The context manager protocol wraps an object in an additional layer of indirection.
    See the *Reading and writing files with context managers* and *Using multiple
    contexts for reading and writing files* recipes for more information on this.
    The core features that must be mocked are the `__enter__()` and `__exit__()` methods.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器协议在对象外部包装了一个额外的间接层。有关此内容的更多信息，请参阅*使用上下文管理器读写文件*和*使用多个上下文读写文件*的示例。必须模拟的核心特性是`__enter__()`和`__exit__()`方法。
- en: 'The pattern for mock context managers looks like this:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟上下文管理器的模式如下：
- en: '[PRE101]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The context manager object has two attributes. The `__exit__()` will be called
    once. A return value of `True` will silence any exception. The return value of
    `None` or `False` will allow exceptions to propagate.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器对象有两个属性。`__exit__()`将被调用一次。`True`的返回值将使任何异常静音。`None`或`False`的返回值将允许异常传播。
- en: The `__enter__()` method returns the object which is assigned in the `with`
    statement. In this example, we used the `side_effect` attribute and provided a
    function so that a dynamic result can be computed.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`__enter__()`方法返回在`with`语句中分配的对象。在这个例子中，我们使用了`side_effect`属性并提供了一个函数，以便可以计算动态结果。'
- en: A common alternative for the `__enter__()` method is to use a fixed `return_value`
    attribute and provide the same manager object each time. It's also possible to
    provide a sequence with `side_effect` ; in this case, each time the method is
    called, another object from the sequence is returned.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '`__enter__()`方法的一个常见替代方法是使用固定的`return_value`属性，并每次提供相同的管理器对象。还可以使用`side_effect`提供一个序列；在这种情况下，每次调用该方法时，都会返回序列中的另一个对象。'
- en: Creating a dynamic, stateful test
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建动态、有状态的测试
- en: In many cases, the test can use a static, fixed set of objects. The mock responses
    can be defined in the `setUp()` method. In some cases, however, an object's state
    may need to change during the operations of a complex test. In this case, the
    `side_effect` attribute of a `Mock` object can be used to track a state change.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，测试可以使用静态的、固定的对象集。模拟响应可以在`setUp()`方法中定义。然而，在某些情况下，对象的状态可能需要在复杂测试的操作过程中发生变化。在这种情况下，可以使用`Mock`对象的`side_effect`属性来跟踪状态变化。
- en: In this example, the `side_effect` attribute used the `create_response()` method
    to build a dynamic response. A function referenced by `side_effect` can do anything;
    this can be used to update dynamic state information that is used to compute complex
    responses.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`side_effect`属性使用`create_response()`方法来构建动态响应。`side_effect`引用的函数可以做任何事情；这可以用来更新动态状态信息，用于计算复杂的响应。
- en: There's a fine line here. A complex test case can introduce its own bugs. It's
    generally a good idea to keep the test cases as simple as possible to avoid having
    to write `meta tests` to test the test cases.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个微妙的界限。一个复杂的测试用例可能会引入自己的错误。通常最好尽可能简单地保持测试用例，以避免不得不编写`元测试`来测试测试用例。
- en: For non-trivial tests, it's important to be sure that the test can actually
    fail. Some tests involve inadvertent tautologies. It's possible to create a contrived
    test that is as meaningful as `self.assertEqual(4, 2+2)` . To be sure the test
    actually uses the unit under test, it should fail when the code is missing or
    has a bug injected into it.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非平凡的测试，确保测试实际上可以失败很重要。有些测试涉及无意的同义反复。可能会创建一个人为的测试，其意义与`self.assertEqual(4,
    2+2)`一样。为了确保测试实际上使用了被测试的单元，当代码缺失或注入了错误时，它应该失败。
- en: Mocking a complex object
  id: totrans-585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟一个复杂对象
- en: The response object from `urlopen()` has a large number of attributes and methods.
    For our unit test, we only needed to set a few of these features.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '`urlopen()`的响应对象具有大量的属性和方法。对于我们的单元测试，我们只需要设置其中的一些特性。'
- en: 'We used the following:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了以下内容：
- en: '[PRE102]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This created a `Mock` object with two attributes:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个具有两个属性的`Mock`对象：
- en: The `status` attribute had a simple numeric value.
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`属性有一个简单的数值。'
- en: The `getheaders` attribute used a `Mock` object with the `return_value` attribute
    to create a method function. This method function returned the dynamic `response_headers`
    value.
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getheaders`属性使用了一个`Mock`对象，具有`return_value`属性来创建一个方法函数。这个方法函数返回了动态的`response_headers`值。'
- en: The value of `response_headers` is a sequence of two-tuples that has *(key,
    value)* pairs. This representation of the response headers can be transformed
    into a dictionary very easily.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '`response_headers`的值是一个包含*(key, value)*对的两元组序列。这种响应头的表示可以很容易地转换成字典。'
- en: 'The object is built like this:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是这样构建的：
- en: '[PRE103]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This sets three headers: `Location` , `ETag` , and `Content-Type` . Other headers
    may be needed, depending on the test case. It's important not to clutter the test
    case with headers that are not used. This kind of clutter can lead to bugs in
    the test itself.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了三个头：`Location`，`ETag`和`Content-Type`。根据测试用例可能需要其他头。重要的是不要在测试用例中添加未使用的头部。这种混乱可能导致测试本身的错误。
- en: 'The database id and location are based on the following calculation:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库id和位置是基于以下计算：
- en: '[PRE104]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This uses `self.mock_urlopen.call_args` to examine the arguments provided to
    the test case. The value of the `call_args` attribute is a two-tuple with the
    positional and keyword argument values. The positional arguments are a tuple too.
    This means that `call_args[0]` is the positional argument and `call_args[0][0]`
    is the first positional argument. This will be the document that's loaded to the
    database.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了`self.mock_urlopen.call_args`来检查提供给测试用例的参数。`call_args`属性的值是一个包含位置参数和关键字参数值的二元组。位置参数也是一个元组。这意味着`call_args[0]`是位置参数，`call_args[0][0]`是第一个位置参数。这将是加载到数据库的文档。
- en: Many Python objects have hash values. In this case, the object is expected to
    be a string created by the `json.dumps()` function. The hash value for this string
    is a large number. The hex value of that number will be a string with a `0x` prefix.
    We'll use the `[2:]` slice to ignore the prefix. For information on this, see
    the *Rewriting an immutable string* recipe in [Chapter 1](text00014.html#page
    "Chapter 1. Numbers, Strings, and Tuples") , *Numbers, Strings, and Tuples* .
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Python对象都有哈希值。在这种情况下，预期对象是由`json.dumps()`函数创建的字符串。这个字符串的哈希值是一个大数。该数字的十六进制值将是一个带有`0x`前缀的字符串。我们将使用`[2:]`切片来忽略前缀。有关此信息，请参见[第1章](text00014.html#page
    "第1章. 数字、字符串和元组")中的*重写不可变字符串*一节，*数字、字符串和元组*。
- en: Using the load_tests protocol
  id: totrans-600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用load_tests协议
- en: A complex module will include class and function definitions. The module as
    a whole needs a descriptive docstring. Each class and function needs a docstring.
    Each method within a class also needs a docstring. These will provide essential
    information about the module, class, function, and method.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 一个复杂的模块将包括类和函数定义。整个模块需要一个描述性的文档字符串。每个类和函数都需要一个文档字符串。类中的每个方法也需要一个文档字符串。这将提供关于模块、类、函数和方法的基本信息。
- en: In addition, each docstring can include an example. The examples can be tested
    by the `doctest` module. See the *Using docstrings for testing* recipe for examples.
    We can combine the docstring example tests without more complex unit tests. See
    the *Combining unittest and doctest tests* recipe for more information on how
    to do this.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个文档字符串都可以包含一个示例。这些示例可以通过`doctest`模块进行测试。有关示例的信息，请参见*使用文档字符串进行测试*一节。我们可以将文档字符串示例测试与更复杂的单元测试结合起来。有关如何执行此操作的更多信息，请参见*结合unittest和doctest测试*一节。
- en: There's more...
  id: totrans-603
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `unittest` module can be used to construct integration tests too. The idea
    of an integration test is to avoid mocks and actually use the real external service
    in a test mode. This can be slow or expensive; it's common to avoid integration
    testing until after all of the unit tests provide confidence that the software
    is likely to work.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块也可以用于构建集成测试。集成测试的想法是避免模拟，实际上在测试模式下使用真实的外部服务。这可能会很慢或很昂贵；通常要避免集成测试，直到所有单元测试提供了软件可能正常工作的信心。'
- en: We might, for example, create two applications with `orchestrate.io` —the real
    application and a test application. This will provide us with two API keys. The
    test key would be used so that the database can be reset to its initial state
    without creating problems for actual users of the real data.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用`orchestrate.io`创建两个应用程序——真实应用程序和测试应用程序。这将为我们提供两个API密钥。测试密钥将被用于将数据库重置为初始状态，而不会为真实数据的实际用户创建问题。
- en: We can control this using the `unittest` , `setUpModule()` , and `tearDownModule()`
    functions. The `setUpModule()` function is executed prior to all of the tests
    in a given module file. This is a handy way to set the database to a known state.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`unittest`、`setUpModule()`和`tearDownModule()`函数来控制这一切。`setUpModule()`函数在给定模块文件中的所有测试之前执行。这是设置数据库为已知状态的一种方便方式。
- en: We can also remove the database with the `tearDownModule()` function. This can
    be handy for removing unneeded resources created by the test. It's sometimes more
    helpful to leave resources around for debugging purposes. For this reason, the
    `tearDownModule()` function may not be as useful as the `setUpModule()` function.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`tearDownModule()`函数来删除数据库。这对于删除测试创建的不必要的资源非常方便。有时为了调试目的，保留资源可能更有帮助。因此，`tearDownModule()`函数可能不像`setUpModule()`函数那样有用。
- en: See also
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Testing things that involve dates or times* and *Testing things that involve
    randomness* recipes show techniques.
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*涉及日期或时间的测试*和*涉及随机性的测试*配方展示了技巧。'
- en: The *Reading complex formats using regular expressions* recipe in [Chapter 9](text00099.html#page
    "Chapter 9. Input/Output, Physical Format, and Logical Layout") , *Input/Output,
    Physical Format, and Logical Layout* , shows how to parse a complex log file.
    In the *Using multiple contexts for reading and writing files* recipe, the complex
    log records were written to a `CSV` file.
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](text00099.html#page "第9章。输入/输出、物理格式和逻辑布局")的*输入/输出、物理格式和逻辑布局*中，*使用正则表达式读取复杂格式*配方展示了如何解析复杂的日志文件。在*使用多个上下文读写文件*配方中，复杂的日志记录被写入了一个`CSV`文件。
- en: For information on chopping up strings to replace parts, see the *Rewriting
    an immutable string* recipe.
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关如何切割字符串以替换部分内容的信息，请参阅*重写不可变字符串*配方。
- en: Elements of this can be tested by the `doctest` module. See the *Using docstrings
    for testing* recipe for examples. It's also important to combine these tests with
    any doctests. See the *Combining unittest and doctest tests* recipe for more information
    on how to do this.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些内容的一部分可以通过`doctest`模块进行测试。请参阅*使用文档字符串进行测试*配方以获取示例。将这些测试与任何doctests结合起来也很重要。有关如何执行此操作的更多信息，请参阅*结合unittest和doctest测试*配方。
