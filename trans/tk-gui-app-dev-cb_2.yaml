- en: Window Layout
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口布局
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Grouping widgets with frames
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用框架对小部件进行分组
- en: Using the Pack geometry manager
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Pack几何管理器
- en: Using the Grid geometry manager
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Grid几何管理器
- en: Using the Place geometry manager
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Place几何管理器
- en: Grouping inputs with the FrameLabel widget
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FrameLabel小部件对输入进行分组
- en: Dynamically laying out widgets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态布置小部件
- en: Creating horizontal and vertical scrollbars
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建水平和垂直滚动条
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Widgets determine the actions that users can perform with our GUI application;
    however, we should pay attention to their placement and the relationships we establish
    with that arrangement. Effective layouts help users to identify the meaning and
    priority of each graphical element so that they can quickly understand how to
    interact with our program.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件确定用户可以在GUI应用程序中执行的操作；但是，我们应该注意它们的放置和我们与该安排建立的关系。有效的布局帮助用户识别每个图形元素的含义和优先级，以便他们可以快速理解如何与我们的程序交互。
- en: Layout also determines the visual appearance that users expect to find consistently
    across the whole application, such as always placing confirmation buttons at the
    bottom-right corner of the screen. Although this information might be obvious
    to us as developers, end users may feel overwhelmed if we do not guide them through
    the application by following a natural order.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 布局还确定了用户期望在整个应用程序中一致找到的视觉外观，例如始终将确认按钮放在屏幕右下角。尽管这些信息对我们作为开发人员来说可能是显而易见的，但如果我们不按照自然顺序引导他们通过应用程序，最终用户可能会感到不知所措。
- en: This chapter will dive into the different mechanisms that Tkinter offers to
    lay out and group widgets and control other attributes, such as their size or
    spacing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入探讨Tkinter提供的不同机制，用于布置和分组小部件以及控制其他属性，例如它们的大小或间距。
- en: Grouping widgets with frames
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用框架对小部件进行分组
- en: A frame represents a rectangular region of a window, typically used in complex
    layouts to contain other widgets. Since they have their own padding, border, and
    background, you can remark that the group of widgets is related logically.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 框架表示窗口的矩形区域，通常用于复杂布局以包含其他小部件。由于它们有自己的填充、边框和背景，您可以注意到小部件组在逻辑上是相关的。
- en: Another common pattern for frames is to encapsulate part of the application's
    functionality so that you can create an abstraction that hides the implementation
    details of child widgets.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的另一个常见模式是封装应用程序功能的一部分，以便您可以创建一个抽象，隐藏子部件的实现细节。
- en: We will see an example that covers both scenarios by creating a component that
    inherits from the `Frame` class and exposes certain information on the containing
    widgets.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一个示例，涵盖了从`Frame`类继承并公开包含小部件上的某些信息的组件的两种情况。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will build an application that contains two lists, where the first one has
    a list of items and the second one is initially empty. Both lists are scrollable,
    and you can move items between them with two central buttons that transfer the
    current selection:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个应用程序，其中包含两个列表，第一个列表中有一系列项目，第二个列表最初为空。两个列表都是可滚动的，并且您可以使用两个中央按钮在它们之间移动项目：
- en: '![](images/4c30ba49-f25a-48ca-85ed-5533ffb88ce7.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](images/4c30ba49-f25a-48ca-85ed-5533ffb88ce7.png)'
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will define a `Frame` subclass to represent a scrollable list, and then
    create two instances of this class. The two buttons will also be directly added
    to the main window:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个`Frame`子类来表示可滚动列表，然后创建该类的两个实例。两个按钮也将直接添加到主窗口：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works…
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Our `ListFrame` class has only two methods to interact with the inner list:
    `pop_selection()` and `insert_item()`. The first one returns and deletes the current
    selection, or none if there is no item selected, whereas the second one inserts
    a new item at the end of the list.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ListFrame`类只有两种方法与内部列表进行交互：`pop_selection()`和`insert_item()`。第一个返回并删除当前选择的项目，如果没有选择项目，则返回None，而第二个在列表末尾插入新项目。
- en: 'These methods are used in the parent class to transfer an item from one list
    to the other one:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法用于父类中将项目从一个列表转移到另一个列表：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also took advantage of the parent frame containers to correctly pack them
    with the appropriate padding:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还利用父框架容器正确地打包它们，以适当的填充：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Thanks to these frames, our calls to the geometry manager are more isolated
    and organized in our global layout.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些框架，我们对几何管理器的调用在全局布局中更加隔离和有组织。
- en: There's more…
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Another benefit of this approach is that it allows us to use different geometry
    managers in each container widget, such as using `grid()` for the widgets within
    a frame and `pack()` to lay out the frame in the main window.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的另一个好处是，它允许我们在每个容器小部件中使用不同的几何管理器，例如在框架内使用`grid()`来布置小部件，在主窗口中使用`pack()`来布置框架。
- en: However, remember that mixing these geometry managers within the same container
    is not allowed in Tkinter and will make your application crash.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请记住，在Tkinter中不允许在同一个容器中混合使用这些几何管理器，否则会使您的应用程序崩溃。
- en: See also
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using the Pack geometry manager* recipe
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Pack几何管理器*食谱'
- en: Using the Pack geometry manager
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pack几何管理器
- en: In previous recipes, we have seen that creating a widget does not automatically
    display it on the screen. We have called the `pack()` method on each widget to
    do so, which means that we used the Pack geometry manager.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的食谱中，我们已经看到创建小部件并不会自动在屏幕上显示它。我们调用了每个小部件上的`pack()`方法来实现这一点，这意味着我们使用了Pack几何管理器。
- en: This is one of the three available geometry managers in Tkinter, and it is well
    suited for simple layouts, such as when you want to place all the widgets on top
    of each other or side by side.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Tkinter中三种可用的几何管理器之一，非常适合简单的布局，例如当您想要将所有小部件放在彼此上方或并排时。
- en: Getting ready
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Let''s suppose that we want to achieve the following layout in our application:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在应用程序中实现以下布局：
- en: '![](images/fce828e9-1f75-4590-a50e-bb8adbc1d8eb.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](images/fce828e9-1f75-4590-a50e-bb8adbc1d8eb.png)'
- en: It consists of three rows, where the last one has three widgets placed side
    by side. In this scenario, the Pack geometry manager can easily add the widgets
    as expected, without the need for additional frames.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它由三行组成，最后一行有三个小部件并排放置。在这种情况下，Pack布局管理器可以轻松地按预期添加小部件，而无需额外的框架。
- en: How to do it…
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'We will use five `Label` widgets with different texts and background colors
    to help us identify each rectangular region:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用五个具有不同文本和背景颜色的`Label`小部件来帮助我们识别每个矩形区域：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also added some options with the `opts` dictionary to make the size of each
    region clear:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向`opts`字典中添加了一些选项，以便清楚地确定每个区域的大小：
- en: '![](images/1a0e72a4-090a-4af8-af83-c8574e730056.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](images/1a0e72a4-090a-4af8-af83-c8574e730056.png)'
- en: How it works…
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: To have a better understanding of the Pack geometry manager, we will explain
    step by step how it adds widgets to the parent container. Here, we pay special
    attention to the values of the `side` option, which indicates, the relative position
    of the widget with respect to the next one that will be packed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解Pack布局管理器，我们将逐步解释它如何将小部件添加到父容器中。在这里，我们特别关注`side`选项的值，它指示小部件相对于下一个将被打包的小部件的位置。
- en: 'First, we pack the two labels at the top of the screen. While the `tk.TOP`
    constant is the default value of the `side` option, we set it explicitly to clearly
    differentiate it from the calls where we used the `tk.LEFT` value:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将两个标签打包到屏幕顶部。虽然`tk.TOP`常量是`side`选项的默认值，但我们明确设置它以清楚地区分它与我们使用`tk.LEFT`值的调用。
- en: '![](images/77b7063f-2c0b-4a2b-ab75-c1704861201d.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](images/77b7063f-2c0b-4a2b-ab75-c1704861201d.jpg)'
- en: 'Then, we pack the next three labels with the `side` option set to `tk.LEFT`,
    which causes them to be placed side by side:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`side`选项设置为`tk.LEFT`来打包下面的三个标签，这会使它们并排放置：
- en: '![](images/0f54aec2-5957-4da5-9e32-d63acc06903f.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](images/0f54aec2-5957-4da5-9e32-d63acc06903f.jpg)'
- en: Specifying the side on `label_e` does not really matter, as long as it is the
    last widget we add to the container.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 指定`label_e`上的side实际上并不重要，只要它是我们添加到容器中的最后一个小部件即可。
- en: Keep in mind that this is the reason why order is so important when working
    with the Pack geometry manager. To prevent unexpected results in complex layouts,
    it is common to group widgets with frames so that when you pack all the widgets
    within a frame, you do not interfere with the arrangement of the other ones.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这就是在使用Pack布局管理器时顺序如此重要的原因。为了防止复杂布局中出现意外结果，通常将小部件与框架分组，这样当您将所有小部件打包到一个框架中时，就不会干扰其他小部件的排列。
- en: In these cases, we strongly recommend that you use the Grid geometry manager
    since it allows you to directly set the position of each widget with one call
    to the geometry manager and avoids the need for additional frames.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们强烈建议您使用网格布局管理器，因为它允许您直接调用几何管理器设置每个小部件的位置，并且避免了额外框架的需要。
- en: There's more…
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Apart from `tk.TOP` and `tk.LEFT`, you can pass the `tk.BOTTOM` and `tk.RIGHT`
    constants to the `side` option. They perform the opposite stacking, as their names
    suggest; however, it may be counterintuitive since the natural order we follow
    is from top to bottom and from left to right.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`tk.TOP`和`tk.LEFT`，您还可以将`tk.BOTTOM`和`tk.RIGHT`常量传递给`side`选项。它们执行相反的堆叠，正如它们的名称所暗示的那样；但是，这可能是反直觉的，因为我们遵循的自然顺序是从上到下，从左到右。
- en: For instance, if we replace the `tk.LEFT` value with `tk.RIGHT` in our three
    last widgets, their order from left to right would be `label_e`, `label_d`, and
    `label_c`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们在最后三个小部件中用`tk.RIGHT`替换`tk.LEFT`的值，它们从左到右的顺序将是`label_e`，`label_d`和`label_c`。
- en: See also
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using the Grid geometry manager* recipe
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用网格布局管理器*食谱'
- en: The *Using the Place geometry manager* recipe
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Place布局管理器*食谱'
- en: Using the Grid geometry manager
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网格布局管理器
- en: The Grid geometry manager is considered the more versatile of the three geometry
    managers. It directly reassembles the *grid* concept that is commonly used in
    user interface design—a two-dimensional table divided into rows and columns, where
    each cell represents the space available for a widget.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 网格布局管理器被认为是三种布局管理器中最通用的。它直接重新组合了通常用于用户界面设计的*网格*概念，即一个二维表格，分为行和列，其中每个单元格代表小部件的可用空间。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will demonstrate how to use the Grid geometry manager to achieve the following
    layout:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示如何使用网格布局管理器来实现以下布局：
- en: '![](images/2f7823b8-c9f3-4408-8b62-eccfb7ab446d.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](images/2f7823b8-c9f3-4408-8b62-eccfb7ab446d.png)'
- en: This can be represented as a 3 x 3 table, where the widgets in the second and
    third columns span two rows and the widget at the bottom row spans three columns.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以表示为一个3 x 3的表格，其中第二列和第三列的小部件跨越两行，底部行的小部件跨越三列。
- en: How to do it…
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'As we did in the preceding recipe, we will use five labels with different backgrounds
    to illustrate the distribution of the cells:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的食谱一样，我们将使用五个具有不同背景的标签来说明单元格的分布：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We also passed a dictionary of options to add some internal padding and expand
    the widgets to all the available space in the cells.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还传递了一个选项字典，以添加一些内部填充并将小部件扩展到单元格中的所有可用空间。
- en: How it works…
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The placement of `label_a` and `label_b` is almost self-explanatory: they occupy
    the first and second rows of the first column, respectively—remember that grid
    positions are zero-indexed:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`label_a`和`label_b`的放置几乎是不言自明的：它们分别占据第一列的第一行和第二行，记住网格位置是从零开始计数的：'
- en: '![](images/956d78d6-3cda-41e4-949e-45489d30fdda.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](images/956d78d6-3cda-41e4-949e-45489d30fdda.png)'
- en: To expand `label_c` and `label_d` through multiple cells, we will set the `rowspan`
    option to `2`, so they will span two cells, starting from the position indicated
    with the `row` and `column` options. Finally, we will place `label_e` with the
    `columnspan` option to set it to `3`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展`label_c`和`label_d`跨越多个单元格，我们将把`rowspan`选项设置为`2`，这样它们将跨越两个单元格，从`row`和`column`选项指示的位置开始。最后，我们将使用`columnspan`选项将`label_e`放置到`3`。
- en: It is important to remark that in contrast with the Pack geometry manager, it
    is possible to change the order of the calls to `grid()` on each widget without
    modifying the final layout.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，与Pack几何管理器相比，可以更改对每个小部件的`grid()`调用的顺序，而不修改最终布局。
- en: There's more…
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `sticky` option indicates the borders where the widget should stick, expressed
    in cardinal directions: north, south, west and east. These values are represented
    by the Tkinter constants  `tk.N`, `tk.S`, `tk.W`, and  `tk.E`, as well as the
    combined versions `tk.NW`, `tk.NE`, `tk.SW`, and `tk.SE`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`sticky`选项表示小部件应粘附的边界，用基本方向表示：北、南、西和东。这些值由Tkinter常量`tk.N`、`tk.S`、`tk.W`和`tk.E`表示，以及组合版本`tk.NW`、`tk.NE`、`tk.SW`和`tk.SE`。'
- en: For example, `sticky=tk.N` aligns the widget to the top border of the cell (north),
    whereas `sticky=tk.SE` positions the widget in the bottom-right corner of the
    cell (south-east).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`sticky=tk.N`将小部件对齐到单元格的顶部边界（北），而`sticky=tk.SE`将小部件放置在单元格的右下角（东南）。
- en: Since these constants represent their corresponding lowercase letters, we shorthanded
    the `tk.N + tk.S + tk.W + tk.E` expression with the `"nswe"` string. This means
    that the widget should expand both horizontally and vertically—similar to the
    `fill=tk.BOTH` option of the Pack geometry manager.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些常量代表它们对应的小写字母，我们用`"nswe"`字符串简写了`tk.N + tk.S + tk.W + tk.E`表达式。这意味着小部件应该在水平和垂直方向上都扩展，类似于Pack几何管理器的`fill=tk.BOTH`选项。
- en: If no value is passed to the `sticky` option, the widget is centered within
    the cell.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`sticky`选项没有传递值，则小部件将在单元格内居中。
- en: See also
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using the Pack geometry manager* recipe
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Pack几何管理器*配方'
- en: The *Using the Place geometry manager* recipe
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Place几何管理器*配方'
- en: Using the Place geometry manager
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Place几何管理器
- en: The Place geometry manager allows you to set the position and size of a widget
    in absolute terms, or in relative terms to another one.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Place几何管理器允许您以绝对或相对于另一个小部件的位置和大小。
- en: Of the three geometry managers, it is the least commonly used one. On the other
    hand, it can fit some complex scenarios where you want to freely position a widget
    or overlap a previously placed one.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在三种几何管理器中，它是最不常用的一种。另一方面，它可以适应一些复杂的情况，例如您想自由定位一个小部件或重叠一个先前放置的小部件。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To demonstrate how to work with the Place geometry manager, we will replicate
    the following layout by mixing absolute and relative positions and sizes:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用Place几何管理器，我们将通过混合绝对位置和相对位置和大小来复制以下布局：
- en: '![](images/78190289-c61d-422c-8422-84a24b8a0d78.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](images/78190289-c61d-422c-8422-84a24b8a0d78.png)'
- en: How to do it…
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The labels that we will display have different backgrounds and are defined
    in the order they are placed from left to right and top to bottom:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将显示的标签具有不同的背景，并按从左到右和从上到下的顺序定义：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you run the preceding program, you can see the overlapping between `label_c`
    and `label_d` in the center of the screen, something that we have not achieved
    with other geometry managers.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行前面的程序，您可以看到`label_c`和`label_d`在屏幕中心的重叠，这是我们使用其他几何管理器没有实现的。
- en: How it works…
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first label is placed with the `relwidth` and `relheight` options set to
    `0.25`, which means that its width and height are 25% of its parent container.
    By default, widgets are placed at the `x=0` and `y=0` positions and aligned to
    north-west, that is, the top-left corner of the screen.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个标签的`relwidth`和`relheight`选项设置为`0.25`，这意味着它的宽度和高度是其父容器的25%。默认情况下，小部件放置在`x=0`和`y=0`位置，并对齐到西北，即屏幕的左上角。
- en: The second label is placed at the absolute position—`x=100`—and aligned to the
    top border with the `anchor` option set to the `tk.N` (north) constant. Here,
    we also specified an absolute size with `width` and `height`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个标签放置在绝对位置`x=100`，并使用`anchor`选项设置为`tk.N`（北）常量与顶部边界对齐。在这里，我们还使用`width`和`height`指定了绝对大小。
- en: The third label is centered on the window using the relative positioning and
    setting the `anchor` to `tk.CENTER`. Remember that a value of `0.5` for `relx`
    and `relwidth` means half of the parent's width and a value of `0.5` for `rely`,
    and `relheight` means half of the parent's height.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个标签使用相对定位在窗口中心，并将`anchor`设置为`tk.CENTER`。请记住，`relx`和`relwidth`的值为`0.5`表示父容器宽度的一半，`rely`和`relheight`的值为`0.5`表示父容器高度的一半。
- en: The fourth label is placed on top of `label_c` by passing it as the `in_` argument
    (note that Tkinter suffixes it with an underscore because `in` is a reserved keyword).
    When using `in_`, you might notice that the alignment is not geometrically exact. In
    our example, we had to add an offset of `2` pixels in each direction to perfectly
    overlap the right-bottom corner of `label_c`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个标签通过将其作为`in_`参数放置在`label_c`上（请注意，Tkinter在其后缀中添加了下划线，因为`in`是一个保留关键字）。使用`in_`时，您可能会注意到对齐不是几何上精确的。在我们的示例中，我们必须在每个方向上添加2个像素的偏移量，以完全重叠`label_c`的右下角。
- en: Finally, the fifth label uses absolute positioning and relative size. As you
    may have already noticed, these dimensions can be easily switched since we assume
    a parent container of 200 x 200 pixels; however, only relative weights will work
    as expected if the main window is resized. You can test this behavior by resizing
    the window.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第五个标签使用绝对定位和相对大小。正如您可能已经注意到的那样，这些尺寸可以很容易地切换，因为我们假设父容器为200 x 200像素；但是，如果调整主窗口的大小，只有相对权重才能按预期工作。您可以通过调整窗口大小来测试此行为。
- en: There's more…
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Another important advantage of the Place geometry manager is that it may be
    used in conjunction with Pack or Grid.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Place几何管理器的另一个重要优势是它可以与Pack或Grid一起使用。
- en: 'For instance, imagine that you want to dynamically display a caption over a
    widget when you right-click on it. You can represent this caption with a Label
    widget, which gets placed in the relative position where you clicked on the widget:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您希望在右键单击小部件时动态显示标题。您可以使用Label小部件表示此标题，并将其放置在单击小部件的相对位置：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As general advice, we recommend that you use any of the other geometry managers
    as much as possible in your Tkinter applications and leave this only for those
    specialized cases where you need a custom positioning.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般建议，我们建议您在Tkinter应用程序中尽可能多地使用其他几何管理器，并且仅在需要自定义定位的专门情况下使用此几何管理器。
- en: See also
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using the Pack geometry manager* recipe
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Pack几何管理器的食谱
- en: The *Using the Grid geometry manager* recipe
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网格几何管理器的食谱
- en: Grouping inputs with the LabelFrame widget
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LabelFrame小部件对输入进行分组
- en: The `LabelFrame` class can be used to group multiple input widgets, indicating the
    logical entity with a label they represent. It is typically used in forms and
    is very similar to the `Frame` widget.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`LabelFrame`类可用于对多个输入小部件进行分组，指示它们表示的逻辑实体的标签。它通常用于表单，与`Frame`小部件非常相似。'
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will build a form with a couple of `LabelFrame` instances, each one with
    their corresponding child input widgets:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个带有一对`LabelFrame`实例的表单，每个实例都有其相应的子输入小部件：
- en: '![](images/e9759bcf-5dd1-41ce-9de4-bdb6de6a32e9.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](images/e9759bcf-5dd1-41ce-9de4-bdb6de6a32e9.png)'
- en: How to do it…
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Since the purpose of this example is to show the final layout, we will add
    some widgets, without keeping their references as attributes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此示例的目的是显示最终布局，我们将添加一些小部件，而不将它们的引用保留为属性：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'The `LabelFrame` widget takes the `labelwidget` option to set the widget used
    as a label. If it is not present, it displays the string passed as the `text`
    option. For instance, instead of creating an instance with `tk.LabelFrame(master,
    text="Info")`, you can replace it with the following statements:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`LabelFrame`小部件采用`labelwidget`选项来设置用作标签的小部件。如果不存在，它将显示作为`text`选项传递的字符串。例如，可以用以下语句替换`tk.LabelFrame(master,
    text="Info")`的实例：'
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This would allow you to do any kind of customization, such as adding an image.
    Note that we did not use any geometry manager for the label since it is managed
    when you place the frame.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您进行任何类型的自定义，例如添加图像。请注意，我们没有为标签使用任何几何管理器，因为当您放置框架时，它会被管理。
- en: Dynamically laying out widgets
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态布局小部件
- en: The Grid geometry manager is easy to use both in simple and advanced layouts,
    and it is also a powerful mechanism to combine with a list of widgets.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 网格几何管理器在简单和高级布局中都很容易使用，也是与小部件列表结合使用的强大机制。
- en: We will take a look at how we can reduce the number of lines and call the geometry
    manager methods with just a few lines, thanks to list comprehensions and the `zip`
    and `enumerate` built-in functions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看如何通过列表推导和`zip`和`enumerate`内置函数，可以减少行数并仅用几行调用几何管理器方法。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The application we will build contains four `Entry` widgets, each one with
    its corresponding label that indicates the meaning of the input. We will also
    add a button to print all the entries'' values:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个应用程序，其中包含四个`Entry`小部件，每个小部件都有相应的标签，指示输入的含义。我们还将添加一个按钮来打印所有条目的值：
- en: '![](images/a4586bd3-a7cf-4f0d-9ce6-a538e7114f37.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](images/a4586bd3-a7cf-4f0d-9ce6-a538e7114f37.png)'
- en: Instead of creating and assigning each widget to a separate attribute, we will
    work with lists of widgets. Since we will track the index while iterating over
    these lists, we can easily invoke the `grid()` method with the appropriate `column`
    option.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用小部件列表而不是创建和分配每个小部件到单独的属性。由于我们将在这些列表上进行迭代时跟踪索引，因此我们可以轻松地使用适当的`column`选项调用`grid()`方法。
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will aggregate the lists of labels and entries with the `zip` function.
    The button will be created and displayed individually, as it does not share any
    option with the rest of the widgets:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`zip`函数聚合标签和输入列表。按钮将单独创建和显示，因为它与其余小部件没有共享任何选项：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can enter different text on each input and click on the Print info button
    to verify that each tuple contains the corresponding label and entry.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在每个输入上输入不同的文本，并单击“打印信息”按钮以验证每个元组包含相应的标签和输入。
- en: How it works…
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Each list comprehension iterates over the strings of the fields list. While
    labels use each item as the displayed text, entries only need the reference to
    the parent container—the underscore is a common idiom that means the variable
    value is ignored.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每个列表推导式都会迭代字段列表的字符串。标签使用每个项目作为显示的文本，输入只需要父容器的引用——下划线是一个常见的习惯用法，表示变量值被忽略。
- en: 'Starting from Python 3, `zip` returns an iterator instead of a list, so we
    consume the aggregation with the list function. As a result, the `widgets` attribute
    contains a list of tuples that can be safely iterated multiple times:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3开始，`zip`返回一个迭代器而不是列表，因此我们使用列表函数消耗聚合。结果，`widgets`属性包含一个可以安全多次迭代的元组列表：
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we have to call the geometry manager on each tuple of widgets. With the
    `enumerate` function, we can track the index of each iteration and pass it as
    the *row* number:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在每个小部件元组上调用几何管理器。使用`enumerate`函数，我们可以跟踪每次迭代的索引并将其作为*行*号传递：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that we used the `for i, (label, entry) in ...` syntax because we must
    unpack the tuple generated with `enumerate`, and then unpack each tuple of the
    `widgets` attribute.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了`for i, (label, entry) in ...`语法，因为我们必须解压使用`enumerate`生成的元组，然后解压`widgets`属性的每个元组。
- en: Within the `print_info()` callback, we iterate over widgets to print each label
    text with its corresponding entry value. To retrieve the labels' `text`, we used
    the `cget()` method, which allows you to get the value of a widget option by its
    name.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`print_info()`回调中，我们迭代小部件以打印每个标签文本及其相应的输入值。要检索标签的`text`，我们使用了`cget()`方法，它允许您通过名称获取小部件选项的值。
- en: Creating horizontal and vertical scrollbars
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建水平和垂直滚动条
- en: In Tkinter, geometry managers take all the necessary space to fit all the widgets
    in their parent container. However, if the container has a fixed size or exceeds
    the screen's size, there will be a region that will not be visible to users.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tkinter中，几何管理器会占用所有必要的空间，以适应其父容器中的所有小部件。但是，如果容器具有固定大小或超出屏幕大小，将会有一部分区域对用户不可见。
- en: Scroll bar widgets are not automatically added in Tkinter, so you must create
    and lay them out as any other type of widget. Another consideration is that only
    a few widget classes have the configuration options that make it possible to connect
    them to a scrollbar.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tkinter中，滚动条小部件不会自动添加，因此您必须像其他类型的小部件一样创建和布置它们。另一个考虑因素是，只有少数小部件类具有配置选项，使其能够连接到滚动条。
- en: To work around this, you will learn to take advantage of the flexibility of
    the **Canvas** widget to make any container scrollable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，您将学习如何利用**Canvas**小部件的灵活性使任何容器可滚动。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To demonstrate the combination of the `Canvas` and `Scrollbar` classes to create
    a resizable and scrollable frame, we will build an application that dynamically
    changes its size by loading an image.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`Canvas`和`Scrollbar`类的组合，创建一个可调整大小和可滚动的框架，我们将构建一个通过加载图像动态更改大小的应用程序。
- en: 'When the Load image button is clicked, it removes itself and loads an image into
    the `Canvas` that is larger than the scrollable region—for this example, we used
    a predefined image, but you can modify this program to select any other GIF image
    with a file dialog:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当单击“加载图像”按钮时，它会将自身移除，并将一个大于可滚动区域的图像加载到`Canvas`中-例如，我们使用了一个预定义的图像，但您可以修改此程序以使用文件对话框选择任何其他GIF图像：
- en: '![](images/5ed14b60-2769-43a6-9204-75d6a42f8198.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](images/5ed14b60-2769-43a6-9204-75d6a42f8198.png)'
- en: 'This enables the horizontal and vertical scrollbars, which automatically adjust
    themselves if the main window is resized:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启用水平和垂直滚动条，如果主窗口被调整大小，它们会自动调整自己：
- en: '![](images/1c73a705-07ce-497d-a353-1cc76c01b56e.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](images/1c73a705-07ce-497d-a353-1cc76c01b56e.png)'
- en: How to do it…
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'When we will dive into the functionality of the Canvas widget in a separate
    chapter, this application will introduce its standard scroll interface and the
    `create_window()` method. Note that this script requires the file `python.gif`
    to be placed in the same directory:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将在单独的章节中深入了解Canvas小部件的功能时，本应用程序将介绍其标准滚动界面和`create_window()`方法。请注意，此脚本需要将文件`python.gif`放置在相同的目录中：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The first lines of our application create the scroll bars and connect them to
    the `Canvas` object with the `xscrollcommand` and `yscrollcommand` options, which
    take a reference to the `set()` method of `scroll_x` and `scroll_y`, respectively—this
    is the method in charge of moving the scroll bar slider.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的第一行创建了滚动条，并使用`xscrollcommand`和`yscrollcommand`选项将它们连接到`Canvas`对象，这些选项分别使用`scroll_x`和`scroll_y`的`set()`方法的引用-这是负责移动滚动条滑块的方法。
- en: 'It is also necessary to configure the `command` option of each scroll bar once
    the `Canvas` is defined:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要在定义`Canvas`后配置每个滚动条的`command`选项：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It is also possible to create the `Canvas` first and configure its options later,
    when the scroll bars are instantiated.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以先创建`Canvas`，然后在实例化滚动条时配置其选项。
- en: 'The next step is to add the frame to our scrollable `Canvas` with the `create_window()`
    method. The first argument it takes is the position to place the widget passed
    with the `window` option. Since the *x* and *y* axes of the `Canvas` widget start
    in the top-left corner, we placed the frame at the `(0, 0)` position and also
    aligned it to that corner with `anchor=tk.NW` (north-west):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用`create_window()`方法将框架添加到我们可滚动的`Canvas`中。它接受的第一个参数是使用`window`选项传递的小部件的位置。由于`Canvas`小部件的*x*和*y*轴从左上角开始，我们将框架放置在`(0,
    0)`位置，并使用`anchor=tk.NW`将其对齐到该角落（西北）：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Then, we will make the first row and column resizable with the `rowconfigure()`
    and `columnconfigure()` methods. The `weight` option indicates the relative weight
    to distribute the extra space, but in our case, there are no more rows or columns
    to resize.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用`rowconfigure()`和`columnconfigure()`方法使第一行和列可调整大小。`weight`选项指示相对权重以分配额外的空间，但在我们的情况下，没有更多的行或列需要调整大小。
- en: 'The binding to the `<Configure>` event will help us to properly reconfigure
    the `canvas` when the main window gets resized. Handling this type of event follows
    the same principles that we saw in the previous chapter to process mouse and keyboard
    events:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定到`<Configure>`事件将帮助我们在主窗口调整大小时正确重新配置`canvas`。处理这种类型的事件遵循我们在上一章中看到的相同原则，以处理鼠标和键盘事件：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, we will set the minimum size of the main window with the current width
    and height, which can be retrieved with the `winfo_width()` and `winfo_height()`
    methods.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用`winfo_width()`和`winfo_height()`方法设置主窗口的最小大小，这些方法可以检索当前的宽度和高度。
- en: 'In order to get the real size of a container, we have to force the geometry
    manager to draw all the child widgets first by calling `update_idletasks()`. This
    method is available in all widget classes, and forces Tkinter to process all pending
    idle events, such as redrawings and geometry recalculations:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得容器的真实大小，我们必须通过调用`update_idletasks()`强制几何管理器首先绘制所有子小部件。这个方法在所有小部件类中都可用，并强制Tkinter处理所有待处理的空闲事件，如重绘和几何重新计算：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `resize` method handles the window resize event and updates the `scrollregion`
    option, which defines the area of the `canvas` that can be scrolled. To easily
    recalculate it, you can use the `bbox()` method with the `ALL` constant. This
    returns the bounding box of the whole Canvas widget:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`resize`方法处理窗口调整大小事件，并更新`scrollregion`选项，该选项定义了可以滚动的`canvas`区域。为了轻松地重新计算它，您可以使用`bbox()`方法和`ALL`常量。这将返回整个Canvas小部件的边界框：'
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tkinter will automatically trigger several `<Configure>`­ events when we start
    our application, so there is no need to call `self.resize()` at the end of the
    `__init__` method.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动应用程序时，Tkinter将自动触发多个`<Configure>`事件，因此无需在`__init__`方法的末尾调用`self.resize()`。
- en: There's more…
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Only a few widget classes support the standard scroll options: `Listbox`, `Text`,
    and `Canvas` allow `xscrollcommand` and `yscrollcommand`, whereas the Entry widget
    only allows the `xscrollcommand`. We have seen how to apply this pattern to a
    `canvas` since it can be used as a generic solution, but you can follow a similar
    structure to make any of these widgets scrollable and resizable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 只有少数小部件类支持标准滚动选项：`Listbox`、`Text`和`Canvas`允许`xscrollcommand`和`yscrollcommand`，而输入小部件只允许`xscrollcommand`。我们已经看到如何将此模式应用于`canvas`，因为它可以用作通用解决方案，但您可以遵循类似的结构使这些小部件中的任何一个可滚动和可调整大小。
- en: Another detail to point out is that we did not call any geometry manager to
    draw the frame because the `create_window()` method does this for us. To better
    organize our application class, we could move all the functionalities that belong
    to the frame and its inner widgets to a dedicated `Frame` subclass.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点要指出的是，我们没有调用任何几何管理器来绘制框架，因为`create_window()`方法会为我们完成这项工作。为了更好地组织我们的应用程序类，我们可以将属于框架及其内部小部件的所有功能移动到专用的`Frame`子类中。
- en: See also
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Handling mouse and keyboard events* recipe
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理鼠标和键盘事件的方法
- en: The *Grouping widgets with frames* recipe
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用框架对小部件进行分组的方法
