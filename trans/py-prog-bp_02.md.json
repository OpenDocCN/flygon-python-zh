["```py\n$ python3 -m venv musicterminal\n```", "```py\n$ . musicterminal/bin/activate\n```", "```py\nmusicterminal\n\u251c\u2500\u2500 client\n\u251c\u2500\u2500 pytify\n\u2502   \u251c\u2500\u2500 auth\n\u2502   \u2514\u2500\u2500 core\n\u2514\u2500\u2500 templates\n```", "```py\nrequests==2.18.4\nPyYAML==3.12\n```", "```py\n$ pip install -r requirements.txt\n```", "```py\n$ sudo apt-get install libncurses5 libncurses5-dev\n```", "```py\nclient_id: '<your client ID>'\nclient_secret: '<your client secret>'\naccess_token_url: 'https://accounts.spotify.com/api/token'\nauth_url: 'http://accounts.spotify.com/authorize'\napi_version: 'v1'\napi_url: 'https://api.spotify.com'\nauth_method: 'AUTHORIZATION_CODE'\n```", "```py\nfrom enum import Enum, auto\n\nclass AuthMethod(Enum):\n    CLIENT_CREDENTIALS = auto()\n    AUTHORIZATION_CODE = auto()\n```", "```py\nfrom .auth_method import AuthMethod\n```", "```py\nimport os\nimport yaml\nfrom collections import namedtuple\n\nfrom pytify.auth import AuthMethod\n```", "```py\nConfig = namedtuple('Config', ['client_id',\n                               'client_secret',\n                               'access_token_url',\n                               'auth_url',\n                               'api_version',\n                               'api_url',\n                               'base_url',\n                               'auth_method', ])\n```", "```py\n>>> from collections import namedtuple\n>>> User = namedtuple('User', ['firstname', 'lastname', 'email'])\n>>> u = User('Daniel','Furtado', 'myemail@test.com')\nUser(firstname='Daniel', lastname='Furtado', email='myemail@test.com')\n>>>\n```", "```py\n>>> from collections import namedtuple\n>>> User = namedtuple('User', 'firstname lastname email')\n>>> u = User('Daniel', 'Furtado', 'myemail@test.com')\n>>> print(u)\nUser(firstname='Daniel', lastname='Furtado', email='myemail@test.com')\n```", "```py\n>>> from collections import namedtuple\n>>> User = namedtuple('User', 'firstname lastname email', verbose=True)\nfrom builtins import property as _property, tuple as _tuple\nfrom operator import itemgetter as _itemgetter\nfrom collections import OrderedDict\n\nclass User(tuple):\n    'User(firstname, lastname, email)'\n\n    __slots__ = ()\n\n    _fields = ('firstname', 'lastname', 'email')\n\n    def __new__(_cls, firstname, lastname, email):\n        'Create new instance of User(firstname, lastname, email)'\n        return _tuple.__new__(_cls, (firstname, lastname, email))\n\n    @classmethod\n    def _make(cls, iterable, new=tuple.__new__, len=len):\n        'Make a new User object from a sequence or iterable'\n        result = new(cls, iterable)\n        if len(result) != 3:\n            raise TypeError('Expected 3 arguments, got %d' % \n            len(result))\n        return result\n\n    def _replace(_self, **kwds):\n        'Return a new User object replacing specified fields with  \n         new values'\n        result = _self._make(map(kwds.pop, ('firstname', 'lastname',  \n                             'email'), _self))\n        if kwds:\n            raise ValueError('Got unexpected field names: %r' %  \n                              list(kwds))\n        return result\n\n    def __repr__(self):\n        'Return a nicely formatted representation string'\n        return self.__class__.__name__ + '(firstname=%r,  \n                                           lastname=%r, email=%r)' \n        % self\n\n    def _asdict(self):\n        'Return a new OrderedDict which maps field names to their  \n          values.'\n        return OrderedDict(zip(self._fields, self))\n\n    def __getnewargs__(self):\n        'Return self as a plain tuple. Used by copy and pickle.'\n        return tuple(self)\n\n    firstname = _property(_itemgetter(0), doc='Alias for field  \n                          number 0')\n\n    lastname = _property(_itemgetter(1), doc='Alias for field number  \n                         1')\n\n    email = _property(_itemgetter(2), doc='Alias for field number  \n                      2')\n```", "```py\n>>> from collections import namedtuple\n>>> User = namedtuple('User', 'firstname lastname email 23445', rename=True)\n>>> User._fields\n('firstname', 'lastname', 'email', '_3')\n```", "```py\ndef read_config():\n    current_dir = os.path.abspath(os.curdir)\n    file_path = os.path.join(current_dir, 'config.yaml')\n\n    try:\n        with open(file_path, mode='r', encoding='UTF-8') as file:\n            config = yaml.load(file)\n\n            config['base_url'] = \n f'{config[\"api_url\"]}/{config[\"api_version\"]}'    auth_method = config['auth_method']\n            config['auth_method'] = \n            AuthMethod.__members__.get(auth_method)\n\n            return Config(**config)\n\n    except IOError as e:\n        print(\"\"\" Error: couldn''t file the configuration file \n        `config.yaml`\n 'on your current directory.   Default format is:',   client_id: 'your_client_id' client_secret: 'you_client_secret' access_token_url: 'https://accounts.spotify.com/api/token' auth_url: 'http://accounts.spotify.com/authorize' api_version: 'v1' api_url: 'http//api.spotify.com' auth_method: 'authentication method'   * auth_method can be CLIENT_CREDENTIALS or  \n          AUTHORIZATION_CODE\"\"\")\n        raise   \n```", "```py\nreturn Config(\n    client_id=config['client_id'],\n    client_secret=config['client_secret'],\n    access_token_url=config['access_token_url'],\n    auth_url=config['auth_url'],\n    api_version=config['api_version'],\n    api_url=config['api_url'],\n    base_url=config['base_url'],\n    auth_method=config['auth_method'])\n```", "```py\nfrom .config import read_config\n```", "```py\nfrom collections import namedtuple\n\nAuthorization = namedtuple('Authorization', [\n    'access_token',\n    'token_type',\n    'expires_in',\n    'scope',\n    'refresh_token',\n])\n```", "```py\nfrom .authorization import Authorization\n```", "```py\nclass BadRequestError(Exception):\n    pass\n```", "```py\nfrom .exceptions import BadRequestError\n```", "```py\nimport requests\nimport base64\nimport json\n\nfrom .authorization import Authorization\nfrom pytify.core import BadRequestError\n```", "```py\ndef get_auth_key(client_id, client_secret):\n    byte_keys = bytes(f'{client_id}:{client_secret}', 'utf-8')\n    encoded_key = base64.b64encode(byte_keys)\n    return encoded_key.decode('utf-8')\n```", "```py\ndef _client_credentials(conf):\n\n    auth_key = get_auth_key(conf.client_id, conf.client_secret)\n\n    headers = {'Authorization': f'Basic {auth_key}', }\n\n    options = {\n        'grant_type': 'client_credentials',\n        'json': True,\n        }\n\n    response = requests.post(\n        'https://accounts.spotify.com/api/token',\n        headers=headers,\n        data=options\n    )\n\n    content = json.loads(response.content.decode('utf-8'))\n\n    if response.status_code == 400:\n        error_description = content.get('error_description','')\n        raise BadRequestError(error_description)\n\n    access_token = content.get('access_token', None)\n    token_type = content.get('token_type', None)\n    expires_in = content.get('expires_in', None)\n    scope = content.get('scope', None)    \n\n    return Authorization(access_token, token_type, expires_in, \n    scope, None)\n```", "```py\ndef authenticate(conf):\n    return _client_credentials(conf)\n```", "```py\nfrom .auth import authenticate\nfrom .auth import get_auth_key\n```", "```py\nPython 3.6.2 (default, Oct 15 2017, 01:15:28)\n[GCC 6.3.0 20170516] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> from pytify.core import read_config\n>>> from pytify.auth import authenticate\n>>> config = read_config()\n>>> auth = authenticate(config)\n>>> auth\nAuthorization(access_token='BQDM_DC2HcP9kq5iszgDwhgDvq7zm1TzvzXXyJQwFD7trl0Q48DqoZirCMrMHn2uUml2YnKdHOszAviSFGtE6w', token_type='Bearer', expires_in=3600, scope=None, refresh_token=None)\n>>>\n```", "```py\ndef _refresh_access_token(auth_key, refresh_token):\n\n    headers = {'Authorization': f'Basic {auth_key}', }\n\n    options = {\n        'refresh_token': refresh_token,\n        'grant_type': 'refresh_token',\n        }\n\n    response = requests.post(\n        'https://accounts.spotify.com/api/token',\n        headers=headers,\n        data=options\n    )\n\n    content = json.loads(response.content.decode('utf-8'))\n\n    if not response.ok:\n        error_description = content.get('error_description', None)\n        raise BadRequestError(error_description)\n\n    access_token = content.get('access_token', None)\n    token_type = content.get('token_type', None)\n    scope = content.get('scope', None)\n    expires_in = content.get('expires_in', None)\n\n    return Authorization(access_token, token_type, expires_in, \n    scope, None)\n```", "```py\nimport os\n```", "```py\ndef _authorization_code(conf):\n\n    current_dir = os.path.abspath(os.curdir)\n    file_path = os.path.join(current_dir, '.pytify')\n\n    auth_key = get_auth_key(conf.client_id, conf.client_secret)\n\n    try:\n        with open(file_path, mode='r', encoding='UTF-8') as file:\n            refresh_token = file.readline()\n\n            if refresh_token:\n                return _refresh_access_token(auth_key, \n                 refresh_token)\n\n    except IOError:\n        raise IOError(('It seems you have not authorize the \n                       application '\n                       'yet. The file .pytify was not found.'))\n```", "```py\ndef authenticate(conf):\n    if conf.auth_method == AuthMethod.CLIENT_CREDENTIALS:\n        return _client_credentials(conf)\n\n    return _authorization_code(conf)\n```", "```py\nfrom .auth_method import AuthMethod\n```", "```py\npip install flask\n```", "```py\n$ pip freeze | grep Flask >> requirements.txt\n```", "```py\npip install -r requirements.txt\n```", "```py\nfrom urllib.parse import urlencode\n\nimport requests\nimport json\n\nfrom flask import Flask\nfrom flask import render_template\nfrom flask import request\n\nfrom pytify.core import read_config\nfrom pytify.core import BadRequestError\nfrom pytify.auth import Authorization\nfrom pytify.auth import get_auth_key\n```", "```py\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef home():\n    config = read_config()\n\n    params = {\n        'client_id': config.client_id,\n        'response_type': 'code',\n        'redirect_uri': 'http://localhost:3000/callback',\n        'scope': 'user-read-private user-modify-playback-state',\n    }\n\n    enc_params = urlencode(params)\n    url = f'{config.auth_url}?{enc_params}'\n\n    return render_template('index.html', link=url)\n```", "```py\ndef _authorization_code_request(auth_code):\n    config = read_config()\n\n    auth_key = get_auth_key(config.client_id, config.client_secret)\n\n    headers = {'Authorization': f'Basic {auth_key}', }\n\n    options = {\n        'code': auth_code,\n        'redirect_uri': 'http://localhost:3000/callback',\n        'grant_type': 'authorization_code',\n        'json': True\n    }\n\n    response = requests.post(\n        config.access_token_url,\n        headers=headers,\n        data=options\n    )\n\n    content = json.loads(response.content.decode('utf-8'))\n\n    if response.status_code == 400:\n        error_description = content.get('error_description', '')\n        raise BadRequestError(error_description)\n\n    access_token = content.get('access_token', None)\n    token_type = content.get('token_type', None)\n    expires_in = content.get('expires_in', None)\n    scope = content.get('scope', None)\n    refresh_token = content.get('refresh_token', None)\n\n    return Authorization(access_token, token_type, expires_in, \n    scope, refresh_token)\n```", "```py\n@app.route('/callback')\ndef callback():\n    config = read_config()\n    code = request.args.get('code', '')\n    response = _authorization_code_request(config, code)\n\n    file = open('.pytify', mode='w', encoding='utf-8')\n    file.write(response.refresh_token)\n    file.close()\n\n    return 'All set! You can close the browser window and stop the \n    server.'\n```", "```py\nif __name__ == '__main__':\n    app.run(host='localhost', port=3000)\n```", "```py\n<html>\n    <head>\n    </head>\n    <body>\n       <a href={{link}}> Click here to authorize </a>\n    </body>\n</html>\n```", "```py\npython spotify_auth.py\n```", "```py\n* Running on http://localhost:3000/ (Press CTRL+C to quit)\n```", "```py\nAQB2jJxziOvuj1VW_DOBeJh-uYWUYaR03nWEJncKdRsgZC6ql2vaUsVpo21afco09yM4tjwgt6Kkb_XnVC50CR0SdjWrrbMnr01zdemN0vVVHmrcr_6iMxCQSk-JM5yTjg4\n```", "```py\nfrom enum import Enum, auto\n\nclass RequestType(Enum):\n    GET = auto()\n    PUT = auto()\n```", "```py\nimport requests\nimport json\n\nfrom .exceptions import BadRequestError\nfrom .config import read_config\nfrom .request_type import RequestType\n\ndef execute_request(\n        url_template,\n        auth,\n        params,\n        request_type=RequestType.GET,\n        payload=()):\n\n```", "```py\nconf = read_config()\n\nparams['base_url'] = conf.base_url\n\nurl = url_template.format(**params)\n\nheaders = {\n    'Authorization': f'Bearer {auth.access_token}'\n}\n```", "```py\nif request_type is RequestType.GET:\n    response = requests.get(url, headers=headers)\nelse:\n    response = requests.put(url, headers=headers, data=json.dumps(payload))\n\n    if not response.text:\n        return response.text\n\nresult = json.loads(response.text)\n```", "```py\nif not response.ok:\n    error = result['error']\n    raise BadRequestError(\n        f'{error[\"message\"]} (HTTP {error[\"status\"]})')\n\nreturn result\n```", "```py\nfrom urllib.parse import urlencode\n\ndef validate_params(params, required=None):\n\n    if required is None:\n        return\n\n    partial = {x: x in params.keys() for x in required}\n    not_supplied = [x for x in partial.keys() if not partial[x]]\n\n    if not_supplied:\n        msg = f'The parameter(s) `{\", \".join(not_supplied)}` are \n        required'\n        raise AttributeError(msg)\n\ndef prepare_params(params, required=None):\n\n    if params is None and required is not None:\n        msg = f'The parameter(s) `{\", \".join(required)}` are \n        required'\n        raise ValueErrorAttributeError(msg)\n    elif params is None and required is None:\n        return ''\n    else:\n        validate_params(params, required)\n\n    query = urlencode(\n        '&'.join([f'{key}={value}' for key, value in \n         params.items()])\n    )\n\n    return f'?{query}'\n```", "```py\nfrom enum import Enum\n\nclass SearchType(Enum):\n    ARTIST = 1\n    ALBUM = 2\n    PLAYLIST = 3\n    TRACK = 4\n```", "```py\nimport requests\nimport json\nfrom urllib.parse import urlencode\n\nfrom .search_type import SearchType\nfrom pytify.core import read_config\n\ndef _search(criteria, auth, search_type):\n\n    conf = read_config()\n\n    if not criteria:\n        raise AttributeError('Parameter `criteria` is required.')\n\n    q_type = search_type.name.lower()\n    url = urlencode(f'{conf.base_url}/search?q={criteria}&type=\n    {q_type}')\n\n    headers = {'Authorization': f'Bearer {auth.access_token}'}\n    response = requests.get(url, headers=headers)\n\n    return json.loads(response.text)\n\ndef search_artist(criteria, auth):\n    return _search(criteria, auth, SearchType.ARTIST)\n\ndef search_album(criteria, auth):\n    return _search(criteria, auth, SearchType.ALBUM)\n\ndef search_playlist(criteria, auth):\n    return _search(criteria, auth, SearchType.PLAYLIST)\n\ndef search_track(criteria, auth):\n    return _search(criteria, auth, SearchType.TRACK)\n```", "```py\nfrom .parameter import prepare_params\nfrom .request import execute_request\n\ndef get_artist_albums(artist_id, auth, params=None):\n\n    if artist_id is None or artist_id is \"\":\n        raise AttributeError(\n            'Parameter `artist_id` cannot be `None` or empty.')\n\n    url_template = '{base_url}/{area}/{artistid}/{postfix}{query}'\n    url_params = {\n        'query': prepare_params(params),\n        'area': 'artists',\n        'artistid': artist_id,\n        'postfix': 'albums',\n        }\n\n    return execute_request(url_template, auth, url_params)\n```", "```py\nfrom .parameters import prepare_params\nfrom .request import execute_request\n\ndef get_album_tracks(album_id, auth, params=None):\n\n    if album_id is None or album_id is '':\n        raise AttributeError(\n            'Parameter `album_id` cannot be `None` or empty.')\n\n    url_template = '{base_url}/{area}/{albumid}/{postfix}{query}'\n    url_params = {\n        'query': prepare_params(params),\n        'area': 'albums',\n        'albumid': album_id,\n        'postfix': 'tracks',\n        }\n\n    return execute_request(url_template, auth, url_params)\n```", "```py\nfrom .parameter import prepare_params\nfrom .request import execute_request\n\nfrom .request_type import RequestType\n\ndef play(track_uri, auth, params=None):\n\n    if track_uri is None or track_uri is '':\n        raise AttributeError(\n            'Parameter `track_uri` cannot be `None` or empty.')\n\n    url_template = '{base_url}/{area}/{postfix}'\n    url_params = {\n        'query': prepare_params(params),\n        'area': 'me',\n        'postfix': 'player/play',\n        }\n\n    payload = {\n        'uris': [track_uri],\n        'offset': {'uri': track_uri}\n    }\n\n    return execute_request(url_template,\n                           auth,\n                           url_params,\n                           request_type=RequestType.PUT,\n                           payload=payload)\n```", "```py\nfrom .search_type import SearchType\n\nfrom .search import search_album\nfrom .search import search_artist\nfrom .search import search_playlist\nfrom .search import search_track\n\nfrom .artist import get_artist_albums\nfrom .album import get_album_tracks\nfrom .player import play\n```", "```py\nPython 3.6.2 (default, Dec 22 2017, 15:38:46)\n[GCC 6.3.0 20170516] on linux\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> from pytify.core import search_artist\n>>> from pytify.core import read_config\n>>> from pytify.auth import authenticate\n>>> from pprint import pprint as pp\n>>>\n>>> config = read_config()\n>>> auth = authenticate(config)\n>>> results = search_artist('hot water music', auth)\n>>> pp(results)\n{'artists': {'href': 'https://api.spotify.com/v1/search?query=hot+water+music&type=artist&market=SE&offset=0&limit=20',\n 'items': [{'external_urls': {'spotify': 'https://open.spotify.com/artist/4dmaYARGTCpChLhHBdr3ff'},\n 'followers': {'href': None, 'total': 56497},\n 'genres': ['alternative emo',\n 'emo',\n 'emo punk', \n```", "```py\nimport curses\nimport curses.panel\nfrom uuid import uuid1\n\nclass Panel:\n\n    def __init__(self, title, dimensions):\n        height, width, y, x = dimensions\n\n        self._win = curses.newwin(height, width, y, x)\n        self._win.box()\n        self._panel = curses.panel.new_panel(self._win)\n        self.title = title\n        self._id = uuid1()\n\n        self._set_title()\n\n        self.hide()\n```", "```py\ndef hide(self):\n    self._panel.hide()\n```", "```py\ndef _set_title(self):\n    formatted_title = f' {self._title} '\n    self._win.addstr(0, 2, formatted_title, curses.A_REVERSE)\n```", "```py\ndef show(self):\n    self._win.clear()\n    self._win.box()\n    self._set_title()\n    curses.curs_set(0)\n    self._panel.show()\n```", "```py\ndef is_visible(self):\n    return not self._panel.hidden()\n```", "```py\ndef __eq__(self, other):\n    return self._id == other._id\n```", "```py\nfrom uuid import uuid1\n```", "```py\nclass MenuItem:\n    def __init__(self, label, data, selected=False):\n        self.id = str(uuid1())\n        self.data = data\n        self.label = label\n\n        def return_id():\n            return self.data['id'], self.data['uri']\n\n        self.action = return_id\n        self.selected = selected\n```", "```py\ndef __eq__(self, other):\n    return self.id == other.id\n```", "```py\ndef __len__(self):\n    return len(self.label)\n```", "```py\ndef __str__(self):\n    return self.label\n```", "```py\nfrom enum import Enum, auto\n\nclass Alignment(Enum):\n    LEFT = auto()\n    RIGHT = auto()\n```", "```py\nimport curses\nimport curses.panel\n\nfrom .alignment import Alignment\nfrom .panel import Panel\n\nclass Menu(Panel):\n\n    def __init__(self, title, dimensions, align=Alignment.LEFT, \n                 items=[]):\n        super().__init__(title, dimensions)\n        self._align = align\n        self.items = items\n```", "```py\ndef get_selected(self):\n    items = [x for x in self.items if x.selected]\n    return None if not items else items[0]\n```", "```py\ndef _select(self, expr):\n    current = self.get_selected()\n    index = self.items.index(current)\n    new_index = expr(index)\n\n    if new_index < 0:\n        return\n\n    if new_index > index and new_index >= len(self.items):\n        return\n\n    self.items[index].selected = False\n    self.items[new_index].selected = True\n```", "```py\ndef next(self):\n    self._select(lambda index: index + 1)\n\ndef previous(self):\n    self._select(lambda index: index - 1)\n```", "```py\nnew_index = expr(index)\n```", "```py\ndef _initialize_items(self):\n    longest_label_item = max(self.items, key=len)\n\n    for item in self.items:\n        if item != longest_label_item:\n            padding = (len(longest_label_item) - len(item)) * ' '\n            item.label = (f'{item}{padding}'\n                          if self._align == Alignment.LEFT\n                          else f'{padding}{item}')\n\n        if not self.get_selected():\n            self.items[0].selected = True\n```", "```py\ndef init(self):\n    self._initialize_items()\n```", "```py\nNEW_LINE = 10 CARRIAGE_RETURN = 13\n```", "```py\n    def handle_events(self, key):\n        if key == curses.KEY_UP:\n            self.previous()\n        elif key == curses.KEY_DOWN:\n            self.next()\n        elif key == curses.KEY_ENTER or key == NEW_LINE or key == \n         CARRIAGE_RETURN:\n            selected_item = self.get_selected()\n            return selected_item.action\n```", "```py\n    def __iter__(self):\n        return iter(self.items)\n```", "```py\ndef update(self):\n    pos_x = 2\n    pos_y = 2\n\n    for item in self.items:\n        self._win.addstr(\n                pos_y,\n                pos_x,\n                item.label,\n                curses.A_REVERSE if item.selected else \n                curses.A_NORMAL)\n        pos_y += 1\n\n    self._win.refresh()\n```", "```py\nclass EmptyResultsError(Exception):\n    pass\n```", "```py\nfrom .menu_item import MenuItem\n\nfrom pytify.core import search_artist\nfrom pytify.core import get_artist_albums\nfrom pytify.core import get_album_tracks\nfrom pytify.core import play\n\nfrom .empty_results_error import EmptyResultsError\n\nfrom pytify.auth import authenticate\nfrom pytify.core import read_config\n\nclass DataManager():\n\n    def __init__(self):\n        self._conf = read_config()\n        self._auth = authenticate(self._conf)\n```", "```py\ndef search_artist(self, criteria):\n    results = search_artist(criteria, self._auth)\n    items = results['artists']['items']\n\n    if not items:\n        raise EmptyResultsError(f'Could not find the artist: \n        {criteria}')\n\n    return items[0]\n```", "```py\ndef _format_artist_label(self, item):\n    return f'{item[\"name\"]} ({item[\"type\"]})'\n```", "```py\ndef _format_track_label(self, item):\n\n    time = int(item['duration_ms'])\n    minutes = int((time / 60000) % 60)\n    seconds = int((time / 1000) % 60)\n\n    track_name = item['name']\n\n    return f'{track_name} - [{minutes}:{seconds}]'\n```", "```py\ndef get_artist_albums(self, artist_id, max_items=20):\n\n     albums = get_artist_albums(artist_id, self._auth)['items']\n\n     if not albums:\n         raise EmptyResultsError(('Could not find any albums for'\n                                  f'the artist_id: {artist_id}'))\n\n     return [MenuItem(self._format_artist_label(album), album)\n             for album in albums[:max_items]]\n```", "```py\ndef get_album_tracklist(self, album_id):\n\n    results = get_album_tracks(album_id, self._auth)\n\n    if not results:\n        raise EmptyResultsError('Could not find the tracks for this \n        album')\n\n    tracks = results['items']\n\n    return [MenuItem(self._format_track_label(track), track)\n            for track in tracks]\n```", "```py\ndef play(self, track_uri):\n    play(track_uri, self._auth)\n```", "```py\nimport curses\nimport curses.panel\nfrom curses import wrapper\nfrom curses.textpad import Textbox\nfrom curses.textpad import rectangle\n\nfrom client import Menu\nfrom client import DataManager\n```", "```py\ndef show_search_screen(stdscr):\n    curses.curs_set(1)\n    stdscr.addstr(1, 2, \"Artist name: (Ctrl-G to search)\")\n\n    editwin = curses.newwin(1, 40, 3, 3)\n    rectangle(stdscr, 2, 2, 4, 44)\n    stdscr.refresh()\n\n    box = Textbox(editwin)\n    box.edit()\n\n    criteria = box.gather()\n    return criteria\n```", "```py\ndef clear_screen(stdscr):\n    stdscr.clear()\n    stdscr.refresh()\n```", "```py\ndef main(stdscr):\n\n    curses.cbreak()\n    curses.noecho()\n    stdscr.keypad(True)\n\n    _data_manager = DataManager()\n\n    criteria = show_search_screen(stdscr)\n\n    height, width = stdscr.getmaxyx()\n\n    albums_panel = Menu('List of albums for the selected artist',\n                        (height, width, 0, 0))\n\n    tracks_panel = Menu('List of tracks for the selected album',\n                        (height, width, 0, 0))\n\n    artist = _data_manager.search_artist(criteria)\n\n    albums = _data_manager.get_artist_albums(artist['id'])\n\n    clear_screen(stdscr)\n\n    albums_panel.items = albums\n    albums_panel.init()\n    albums_panel.update()\n    albums_panel.show()\n\n    current_panel = albums_panel\n\n    is_running = True\n\n    while is_running:\n        curses.doupdate()\n        curses.panel.update_panels()\n\n        key = stdscr.getch()\n\n        action = current_panel.handle_events(key)\n\n        if action is not None:\n            action_result = action()\n            if current_panel == albums_panel and action_result is \n            not None:\n                _id, uri = action_result\n                tracks = _data_manager.get_album_tracklist(_id)\n                current_panel.hide()\n                current_panel = tracks_panel\n                current_panel.items = tracks\n                current_panel.init()\n                current_panel.show()\n            elif current_panel == tracks_panel and action_result is  \n            not None:\n                _id, uri = action_result\n                _data_manager.play(uri)\n\n        if key == curses.KEY_F2:\n            current_panel.hide()\n            criteria = show_search_screen(stdscr)\n            artist = _data_manager.search_artist(criteria)\n            albums = _data_manager.get_artist_albums(artist['id'])\n\n            clear_screen(stdscr)\n            current_panel = albums_panel\n            current_panel.items = albums\n            current_panel.init()\n            current_panel.show()\n\n        if key == ord('q') or key == ord('Q'):\n            is_running = False\n\n        current_panel.update()\n\ntry:\n    wrapper(main)\nexcept KeyboardInterrupt:\n    print('Thanks for using this app, bye!')\n```", "```py\ncurses.cbreak()\ncurses.noecho()\nstdscr.keypad(True)\n```", "```py\n_data_manager = DataManager()\n```", "```py\ncriteria = show_search_screen(stdscr)\n```", "```py\nheight, width = stdscr.getmaxyx()\n\nalbums_panel = Menu('List of albums for the selected artist',\n                    (height, width, 0, 0))\n\ntracks_panel = Menu('List of tracks for the selected album',\n                    (height, width, 0, 0))\n\nartist = _data_manager.search_artist(criteria)\n\nalbums = _data_manager.get_artist_albums(artist['id'])\n\nclear_screen(stdscr)\n```", "```py\nalbums_panel.items = albums\nalbums_panel.init()\nalbums_panel.update()\nalbums_panel.show()\n\ncurrent_panel = albums_panel\n\nis_running = True\n```", "```py\nwhile is_running:\n    curses.doupdate()\n    curses.panel.update_panels()\n\n    key = stdscr.getch()\n\n    action = current_panel.handle_events(key)\n```", "```py\ndef handle_events(self, key):\n    if key == curses.KEY_UP:\n        self.previous()\n    elif key == curses.KEY_DOWN:\n        self.next()\n    elif key == curses.KEY_ENTER or key == NEW_LINE or key ==  \n    CARRIAGE_RETURN:\n    selected_item = self.get_selected()\n    return selected_item.action\n```", "```py\nif action is not None:\n    action_result = action()\n    if current_panel == albums_panel and action_result is not None:\n        _id, uri = action_result\n        tracks = _data_manager.get_album_tracklist(_id)\n        current_panel.hide()\n        current_panel = tracks_panel\n        current_panel.items = tracks\n        current_panel.init()\n        current_panel.show()\n    elif current_panel == tracks_panel and action_result is not \n    None:\n        _id, uri = action_result\n        _data_manager.play(uri)\n```", "```py\nif key == curses.KEY_F2:\n    current_panel.hide()\n    criteria = show_search_screen(stdscr)\n    artist = _data_manager.search_by_artist_name(criteria)\n    albums = _data_manager.get_artist_albums(artist['id'])\n\n    clear_screen(stdscr)\n    current_panel = albums_panel\n    current_panel.items = albums\n    current_panel.init()\n    current_panel.show()\n```", "```py\nif key == ord('q') or key == ord('Q'):\n    is_running = False\n```", "```py\ncurrent_panel.update()\n```", "```py\ntry:\n    wrapper(main)\nexcept KeyboardInterrupt:\n    print('Thanks for using this app, bye!')\n```"]