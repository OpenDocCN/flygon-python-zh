# 流程控制 - 为你的游戏构建决策制造者

Python 最大的福祉之一是自动化。当我们谈论自动化时，没有令人震惊的逻辑；一切都取决于条件和分支的力量。它们控制程序执行时的顺序。任何程序在其基本阶段都是通过模拟制作的。每当我们在真实环境中部署这些程序时，我们都会被各种噪音和意外行为所压倒。为了防止这种行为，条件起着重要作用。流程控制根据当前的布尔逻辑决定如何执行程序的特定部分。我们在上一章中涵盖了语句和运算符等主题，这些主题在创建布尔逻辑时非常有用。这些语句用于执行算术计算。在本章中，我们将看到如何操作这些语句，这将导致真或假的布尔逻辑。

在本章的中途，我们将学习循环，这是一种重要的技术，可以使我们足够有能力使代码更短更强大。本章将是一个完整的包，其中包括核心编程、条件和递归编程。我们将通过引入布尔逻辑和流程控制来完善上一章中制作的井字棋游戏。

本章将涵盖以下主题：

+   布尔逻辑和逻辑运算符

+   条件语句

+   迭代

+   `for` 和 `while` 循环

+   为我们的井字棋游戏制作游戏控制器

# 技术要求

您需要以下要求才能完成本章：

+   Python 脚本和 IDLE

+   本章的代码资产可以在以下链接找到：[`github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter03`](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter03)

查看以下视频以查看代码的运行情况：

[`bit.ly/2pvpBas`](http://bit.ly/2pvpBas)

# 理解布尔逻辑和逻辑运算符

没有一天会过去我们不会说布尔类型要么是`True`要么是`False`。我们使用这些关键字来制定逻辑，以确定我们是否要执行某部分代码。让我们从现实生活中的角度来谈谈布尔类型。如果我们饿了，我们就吃点东西。如果我们累了，我们就休息。让我们将这些情景转化为适当的布尔语句：

+   `is_hungry = True`：`吃点东西 || is_hungry = False: 不吃`

+   `is_tired = True`：`休息 || is_tired = False: 做你的工作`

你根据手头的布尔逻辑执行这些日常任务。现在，让我们把它与编程联系起来；你可以使用两组基于布尔数据类型的代码：

+   (`True`): `做某事 || (False): 做某事`

我们使用布尔表达式来制作这种类型的逻辑。我们在上一章中看到了如何创建表达式。将变量和运算符结合起来将给我们一个简单的表达式形式，就像这个例子：

```py
>>> y
>>> x = y + 6 * 7 
```

然而，布尔表达式有点不同。它们不是给出整数结果，而是提供`True`或`False`的结果。布尔表达式的最简单形式可以使用双等号运算符(`==`)制作。不要将其与单等号(`=`)混淆。单等号用于赋值，而双等号(`==`)用于检查它们是否相等，就像这个例子：

```py
>>> 5 == 5
True
>>> "Python" == "Java"
False
```

如果您比较两种不同类型的数据，结果始终是`False`：

```py
>>> "5" == 5 # String(5) not equal to int(5)
```

您可以始终进行类型转换以使您的逻辑为`True`：

```py
>>> int("5") == 5
True
>>> "5" == str(5)
True
```

要检查任何布尔变量的类型，可以使用`type()`方法并获得`<class 'bool'>`的输出，这意味着`True`或`False`是布尔类型的值：

```py
>>> logic = False
>>> type(logic)
'<class 'bool'>'
```

布尔逻辑也可以与比较运算符一起使用。我们将在下一节中学习如何使用**比较运算符**创建语句。

# 比较运算符

任何结果为`True`或`False`的表达式都是布尔表达式。这些布尔表达式不能没有比较和逻辑运算符。我们已经看过基本的比较运算符（`==`）；然而，还有六个我们需要了解的（`<`、`>`、`<=`、`>=`、`!=`和`is`）。让我们看看它们的运行情况：

+   **5 < 10**：5 小于 10，结果为`True`。

+   **5 > 10**：5 大于 10，结果为`False`。

+   **10 <= 5**：10 小于或等于 5，结果为`False`。10 既不小于也不等于 5。

+   **10 >= 5**：10 大于或等于 5，结果为`True`。10 大于 5。

+   **10 != 10**：10 不等于 10，结果为`False`。10 等于 10。

+   5 是 5：5 和 5 相同，所以结果是`True`。然而，`5`是 5，所以结果是`False`。

您可以将前面的数字存储在不同的变量中，并在 IDLE 上尝试相同的布尔表达式，以获得以下结果：

```py
>>> v1 = 5
>>> v2 = 10
>>> v1 < v2
True
>>> v1 > v2
False
>>> v2 <= v1
False
>>> v2 >= v1
True
>>> v2 != v2
False
>>> v1 is v2 
False
>>> v1 is v1
True
```

为了使适用于现实世界的逻辑，我们需要能够同时组合不同的比较操作并立即提供结果的运算符。这些类型的运算符被称为逻辑运算符。在下一节中，我们将学习不同类型的逻辑运算符以及它们的使用方式。

# 逻辑运算符

运算符被广泛分类为算术运算符、比较运算符和逻辑运算符。我们已经涵盖了算术和比较运算符；现在是时候涵盖逻辑运算符了。

您可以将逻辑运算符与逻辑门（`and`、`or`和`not`）联系起来，逻辑门是任何数字电路的基本构建模块。它们有两个输入，但是通过某些电路计算，我们只得到一个输出。电路处理是通过`and`、`or`和`not`门完成的。类似于逻辑门的数字电路，逻辑运算符可以有许多条件传递，但最终输出将是`True`或`False`。这里，`conditions`指的是我们使用比较运算符制作的布尔表达式。这三种基本逻辑运算符的工作原理如下：

+   `and`：两个条件用一个`and`运算符连接，即`condition_one`和`condition_two`。当这些条件中的每一个也为`True`时，整个条件将为`True`。如果与`and`运算符连接的条件中的任一条件为`False`，结果将为`False`。让我们看一个例子：

```py
      >>> condition_one = 5 > 2 #True
      >>> condition_two = 6 < 10 #True
      >>> condition_one and condition_two
      True
      >>> condition_two = 6 > 10
      >>> condition_one and condition_two
      False
```

`and`运算符的真值表，根据布尔或逻辑表达式的组合，将其功能值设置为`True`或`False`，如下所示：

![](img/1cbdcdec-5887-4d30-8e9a-2ef49e1d4f70.png)

+   `or`：与`and`运算符相同——两个条件用一个`or`运算符连接。如果要添加更多条件，可以添加更多`or`运算符。对于`or`运算符，如果连接到它的两个条件都为`False`，结果将为`False`；否则，结果将为`True`。让我们看一个例子：

```py
 >>> 4 < 10 or 5 == 5
 True
 >>> 4 <= 10 or 100 < 50
 True
 >>> 10 <= 4 or 100 < 50
 False
```

`or`运算符的真值表，根据布尔或逻辑表达式的组合，将其功能值设置为`True`或`False`，如下所示：

![](img/e09ac0d2-26f8-4563-ab0b-9db051f44ca0.png)

+   `not`：这个运算符颠倒逻辑的类型。它将`False`变为`True`，反之亦然。因此，它被称为逻辑反转器。它只带有一个条件，如下所示：

```py
      >>> not (5 < 4) # condition 5 < 4 is False
      True
      >>> not True
      False
```

`not`运算符的真值表，根据布尔或逻辑表达式的组合，将其功能值设置为`True`或`False`，如下所示：

![](img/af697950-80c1-49a0-a497-4dd72f8b09d8.png)

在 Python 中，也可以用 1 和 0 表示`True`和`False`。因此，我们可以得出结论，任何非零整数都可以单独使用逻辑运算符来构成条件，就像这个例子：

```py
>>> 1 and 1
1
>>> 1 and 0
0
>>> 1 or 0
1
>>> 49 or True
49
```

学习不同类型的运算符非常有趣，但现在我们将转到一个部分，在那里你将学习如何使用这些条件（由比较和逻辑运算符制作）来做出几个决定。**条件语句**在任何现实场景中都非常实用。我很兴奋地想要学习它们，你呢？

# 条件语句

到目前为止，我们已经学习了使用比较和逻辑运算符制作条件。现在，我们将讨论如何评估这些条件。条件语句是在我们想要计算这些条件的结果并相应地控制程序流程时非常有用的工具。正如我们已经知道的那样，这些条件的结果将是`True`或`False`。因此，根据我们使用的布尔类型，条件语句将执行代码的某部分。我们在 Python 中使用`if`语句来执行条件语句。在写下`if`关键字后，我们将条件放在其旁边。条件可以是单个的，也可以是许多逻辑运算符的组合。我们用冒号结束`if`语句；随后的语句应该正确缩进。看看以下例子：

```py
#filename: conditionals.py

if (True):
  #Do something
```

以下图表示了实现条件语句的布尔逻辑：

![](img/d2d8c293-c7ed-4118-b193-d5916ac3e0aa.png)

在使用 Python 时，请注意以下事项：

+   **冒号（`:`）**：如果你想在 Python 中声明作用域，在其中可以编写多个语句，你需要使用冒号（`:`）来指定。大多数编程语言使用花括号（`{}`）来实现这一点，但是 Python 在定义作用域和块语句的范围时有些奇怪，比如函数、`if`语句、类和循环。然而，一旦你熟悉使用这个，你会觉得很有趣，并且能够在一秒钟内区分出用 Python 编写的代码和其他语言的代码。

+   **缩进**（**空格**）：在我们用冒号定义作用域之后，我们可以进入其作用域。在其作用域内编写的任何后续语句都应以统一的空格开始，我们称之为缩进。你可以按下*Tab*键为每个语句提供统一的缩进。大多数初学者犯的错误都是由于不正确的缩进。如果你没有提供正确的缩进，你将会收到 Python 解释器的以下警告：

![](img/81e98a1c-8db6-49eb-b492-3f99c28b1b76.png)

`If`语句评估逻辑语句。每当该语句为真时，将执行其缩进的语句；否则，将被跳过。你还可以添加`pass`关键字，告诉解释器不要执行缩进块内的任何内容，就像这个例子一样：

```py
>>> if ( 4 == 4):
          pass
>>> #does not print anything
```

正如我们已经知道的，布尔语句将产生`True`或`False`。如果条件为`True`，则`if`语句内的缩进代码将被执行，但如果条件为`False`，则`else`部分内的缩进代码将被执行。让我们看一个例子：

```py
>>> number = 1
>>> if number > 0:
        print("Number is positive")
    else:
        print("Number is negative")
Number is positive
>>>
```

以下图表示了使用条件语句实现检查数字是正数还是负数的程序的流程图：

![](img/a14660a0-236f-4200-9c72-966bfc0face3.png)

你可以看到，我们已经为`True`或`False`逻辑创建了两个条件分支。根据布尔逻辑的结果，流程控制被转移到程序的两侧。因此，条件语句也被称为*分支*。

尽管我们的代码能够执行具有两个分支的代码，但我们的代码中存在一些小差距。如果数字变量包含零，则既不是正数也不是负数。因此，我们必须为此条件添加一个条件。每当我们需要计算逻辑的两个以上分支时，我们可以进行链接条件。我们可以使用链接序列添加任意数量的条件。要使用任何其他编程语言执行链接条件，我们使用`else if`命令。Python 通过使用`elif`制作不同的命令。让我们看一个例子：

```py
>>> number = input("Enter any number: ")
>>> number = int(number) #converting string to integer
>>> if number > 0:
        print("Number is Positive")
    elif number == 0:
        print("Number is Zero")
    else:
        print("Number is Negative")
Enter any number: 0
Number is Zero
>>>
```

我们可以在一个条件语句中放置任意数量的条件。我们称这些为嵌套条件。让我们来看一个例子：

```py
>>> number = 10
>>> if number > 0:
        if number % 2 == 0:
                print("Number is positive and even")
        else:
                print("Number is positive and odd")      
Number is positive and even 
```

在上面的例子中，外部条件包含两个子分支条件，在第一个分支中，我们检查偶数。下一个默认条件是检查奇数。在这个例子中，我们使用一个简单的单一语句来制定条件，但是在嵌套条件中，条件可以通过逻辑运算符变得复杂，就像这个例子中一样：

```py
>>> number = 4
>>> if number > 0:
        if number % 2 == 0 and number < 10:
                print("Number {} is small even & positive number".format(number))
Number 4 is small even & positive number
```

现在你知道如何使用多个条件语句做出决策，我们将看一下一个非常实用的主题，称为**迭代**。这使我们能够执行一系列指令。这将重复执行，直到达到某个条件为止。

# 迭代

假设你想写一个程序，你必须打印你的名字 100 次。到目前为止，我们所学到的规定，最简单的方法是使用打印语句 100 次。但是如果你想打印你的名字 10000 次呢？连续写 2/3 页的打印语句不是好的编程。在这种情况下，我们必须使用循环。循环将帮助我们在数据集上进行迭代，直到满足条件。在每次迭代中，执行代码的一部分，并且我们必须每次更新迭代变量。以下是一个迭代变量的示例：

```py
>>> i = 0
>>> i = i + 1
```

我们使用增量和减量单位更新迭代变量。在这里，我们通过将`1`加到`i`的值来更新`i`的值。这被称为增量。您也可以从中减去 1，这被称为减量。每次我们在缩进循环中执行代码时，我们使用增量或减量语句更新迭代。

同样，有一种相对更简单和更快的实现增量和减量语句的方法。您可以使用以下语句执行多个操作：

+   `+=`将一个数字添加到变量中，并在其过程中更改变量。

+   `-=`将变量与一个值相减，并将新值设置为其结果变量。

+   `*=`将变量乘以一个值，并改变变量的结果。

+   `/=`将变量与值相除，并将结果放在结果变量上。

让我们看一个例子来看看它的效果：

```py
>>> value = 4
>>> value += 5
>>> print(value)
9
```

增量和减量运算符的有效性可以通过循环看出，我们多次重复一组操作。让我们看看使用 for 和 while 循环的循环。我们将首先学习`for`循环。

# for 循环

每当你想在数据集中循环，比如在一系列数字范围内，在某个文件中，或者在一些确定的单词集合中，我们使用`for`循环。它也被称为确定循环。除非你的项目桶中还有某个项目，否则它将迭代。`for`循环在桶的末尾终止。在这里，桶是一个代表项目列表的隐喻，比如数字列表、单词列表或序列，就像这个例子中：

```py
>>> for i in range(10):
         print(i, " John Doe") #range(10) gives [0,1,2,3,4,5,6,7,8,9]
0  John Doe
1  John Doe
2  John Doe
3  John Doe
4  John Doe
5  John Doe
6  John Doe
7  John Doe
8  John Doe
9  John Doe
```

在上面的代码中，`range()`方法用于创建一个数字列表。`range(10)`提供了一个从`0`到`9`的数字列表。它被存储为`[0,1,2,3,4,5,6,7,8,9]`。

在第一次迭代中，`i`的值变为`0`，它执行`for`循环块中的代码，并自动更改`i`的值为该列表的下一个元素，如下所示：

```py
>>> for i in [6,7,8]:
         print(i)
6
7
8
```

您还可以在包含单词或文本的数据中进行循环。在我们循环列表中的每个单词时，迭代变量将包含一个单词作为值，就像这个例子中一样：

```py
>>> for name in ['Tom','Harry','Ricky','Matt']:
             print(name)
Tom
Harry
Ricky
Matt
```

在上面的例子中，迭代变量是`name`变量，每次它在列表中迭代时，它都会获取它的值并将其存储在`name`中。因此，我们只能在`for`循环的主体中使用`name`变量。除了`for`循环中的迭代变量之外，不能使用其他变量。这在下面的代码中显示：

```py
>>> person_names = ['Tom','Harry','Ricky','Matt']
>>> for name in person_names:
         print(person_names)
Traceback (most recent call last):
   File "<pyshell#26>", line 1, in <module>
     for name in person_name:
NameError: name 'person_name' is not defined
```

在上面的例子中，`person_names`是一种可以存储数组项的变量类型。这个变量被称为列表。我们将在下一章中介绍列表。这里，迭代变量是`name`，它是用`for`循环声明的。然而，在 for 循环的主体中，我们没有使用`name`变量。相反，我们使用了`person_names`，这导致了`NameError`。因此，迭代变量只能在`for`循环的主体中使用。

我们将要介绍的下一种循环类型是`while`循环，它将执行类似于`for`循环的操作，但有一些调整。`while`循环通常用于我们不关心循环终止点的情况。

# while 循环

Python 中的另一种迭代形式可以使用`while`循环来执行。让我们回顾一下`for`循环的特点：它用于迭代有限序列的元素，无论是作为数字、单词或文件的列表。如果要使用`for`循环，必须有一个终止点。在使用`for`循环时，我们也不关心终止条件。当它达到项目或序列的末尾时，它就会终止。那么，如果我们想要根据自定义条件终止循环呢？在这种情况下，`while`循环是最合适的循环。我们可以制定一个自定义条件，在这个条件下，我们可以使用`while`循环来终止递归。

`while`和`for`循环都将执行不断的循环。在每次迭代中，它们都将执行循环的主体。`for`和`while`循环的主要区别在于，`while`循环必须在声明中声明更新语句和终止条件。首先，我们必须创建一个迭代变量，然后我们必须创建一个终止条件，以指定循环的停止点。在每次迭代中，我们必须更新迭代变量，就像这样：

```py
>>> i = 0
>>> while (i < 10):
        print("John Doe")
        i = i + 1
John Doe
John Doe
John Doe
John Doe
John Doe
John Doe
John Doe
John Doe
John Doe
John Doe
```

在上面的例子中，我们创建了一个迭代变量`i`，并将其赋值为 0。之后，我们使用了`while`循环。为了使用这个循环，我们使用了`while`关键字，然后跟着它的终止条件。我们告诉解释器，我们希望运行这个循环，直到`i`小于 10。如果`i`等于或大于 10，我们希望终止这个循环。

之后，我们加上一个冒号来指定我们循环的范围。然后，我们为它添加了一个简单的打印语句，每次运行这个循环时都会执行。最后，我们添加了一个*i = i + 1*语句来指定更新条件。这将改变`i`的值为新值，并增加一。这很重要，这样我们就不会陷入无限循环。如果删除更新条件，循环将无限次运行，Python 终端将不会对用户的响应进行交互。创建无限循环的一种方法是使用没有终点的条件，就像这个例子中一样：

```py
>>> while True:
         print("Infinite loop")
```

上面的循环是一个无限循环，因为`while`关键字没有终点或终止点。如果我们能够将`True`关键字更改为`False`，那么这个循环就会终止：

```py
>>> condition = True
>>> while condition:
        print("This will run only one time")
        condition = False
This will run only one time
```

在下一节中，我们将学习循环模式，以便了解循环在底层是如何工作的。

# 循环模式

`for`和`while`循环之间可能存在权衡，但在我们想要循环遍历已知元素列表或文件内容时，两者都能很好地工作。我们可以使用这些循环来排列或排序列表或文件中的元素。`for`循环不能无限次循环，但`while`循环可以使用永远不会发生的条件来实现。循环的主要目的是从特定文件或列表中获取项目，以便我们可以进一步处理它们。我们可以根据扫描数据集时的最小和最大值或重要和多余的值对这些项目进行排序。

循环模式的构造包含以下三个要点：

+   制作一个迭代变量。可以有一个或多个。它们用于构造表示循环终止点的条件。

+   在循环体内部进行一些计算，以便我们可以逐个操作循环获取的数据项。我们还可以在循环体内部更改迭代变量的值，这在`while`循环的情况下通常会这样做。

+   寻找可能的基本条件，以便终止循环。否则，将导致无限循环。我们必须观察循环结束后的结果变量。

如果要演示循环模式的构造和工作范例，最好使用带有项目列表的循环。在下面的示例中，我们将编写一个程序，该程序将获取一个数字列表并检查列表中的最小数。

我们可以用两种方法做到这一点。Python 使得编程对于天真或专业人士都很容易。他们有各种实现相同逻辑的方法，但最常见的是使用 Python 的内置方法，如`min()`和`max()`。它们分别从 Python 的数字列表中获取最小和最大的数字。

```py
>>> numbers = [113,115,55,66,65,90]
>>> min(numbers)
55
>>>max(numbers)
115
```

编写程序的第二种方法是制定我们自己的逻辑。由于此列表中有许多项目，因此我们应立即决定使用循环，这意味着我们必须重复进行一些比较。因此，如果要重复执行任务，最好使用循环。现在，我们需要决定使用`for`还是`while`循环。在这里最好使用`for`循环，因为`for`循环适用于有限列表。每次迭代迭代变量时，它将包含列表中的一个元素，以便我们可以重复与前一个元素进行比较。一开始，我们没有任何东西可以作为最小数。因此，我们必须创建一个变量，其中将包含`None`值。这意味着我们没有任何值。第一次迭代后，我们将其值分配给列表的第一个元素。让我们看看它是如何工作的：

```py
>>> smallest_number = None
>>> for item in [113,115,55,66,65,90]:
            if smallest_number is None or item < smallest_number:
                     smallest_number = item
>>> print("Smallest:", smallest_number)
Smallest: 55
```

让我们把前面的代码分解成以下几个部分：

+   在第一条语句中，`smallest_number = None`将`None`赋值给比较变量。我们使用`None`而不是其他任何数字，以便在比较时不会漏掉任何数字。

+   在第二条语句中，我们将`item`作为迭代变量，它将读取一个数字列表。在每次迭代中，它将存储该列表中的元素。在第一次迭代中，item 的值为 113。在第二次迭代中，item 的值为 115；在第三次迭代中，值为 55；依此类推。

+   我们现在在`for`循环的循环体内部，需要构建一个比较语句。首先，我们需要检查最小数是否为`None`，以确保我们从基础开始。之后，我们将检查列表中的当前项目是否小于`smallest_number`。第一次迭代的第二个条件为 False，但第一个条件，即`smallest_number`为`None`，即为 True，这意味着我们将进入条件体。我们将`smallest_value`赋值为列表的第一个项目，即 113。

+   在第二次迭代中，项目是 115。我们进入`for`循环并检查 115 是否小于`smallest_numbe`的值，即 113。这是`False`，因此它不会进入条件的主体；相反，它跳到第三次迭代。

+   在第三次迭代中，项目是 55。我们将检查条件，即检查项目的值（即 55）是否小于`smallest_number`的值，即 113。条件（55 <113）为`True`，因此将`smallest_number`变量的值更改为 55。`for`循环将迭代直到该列表的最后一个数字。它将在每次迭代中使用相同的比较操作，以给出最小值，即 55。

通过仅更改比较运算符，我们可以编写一个程序，该程序将打印列表中的最大数字。我们可以使用`item > largest_number`语句而不是使用`item < smallest_number`语句来获取最大数字，如下所示：

```py
>>> largest_number = None
>>> for item in [113,115,55,66,65,90]:
            if largest_number is None or item > largest_number:
                    largest_number = item
>>> print("Largest: ",largest_number)
Largest: 115
```

在下一节中，我们将看看如何使用两个不同的语句**break 和 continue**，以改变或跳过迭代的顺序。

# 中断和继续语句

在编写程序时，有时您希望跳过语句的执行或强制停止迭代。这些操作由`continue`和`break`语句处理。它们可以在多种用例中发挥作用，例如当您希望使程序对列表的元素进行排序或在满足`if`条件时中断循环。`continue`语句用于跳过程序的执行。我们在循环的主体内使用这些语句。我们可以使用这些语句将元素从列表中排序出来。即使我们使用这两个语句，由于`break`将停止循环，使`continue`语句无效，因此我们不能在单个循环中使用这两个语句。我们可以在条件语句中使用这些语句。每当满足条件时，我们要么中断要么跳过迭代。让我们编写一个可以对列表的元素进行排序的程序：

```py
>>> items = [1,5,7,8,"Free","spam",False,89,90,11,"Python"]
>>> refined_items = []
>>> for item in items:
        if type(item) != int:
                continue
        else:
                 refined_items.append(item)
>>> print(refined_items)
[1,5,7,8,89,90,11]
```

在上述代码中，我们通过在输出列表中保留整数来完善列表的元素。其他数据值，如字符串和布尔值，都被删除。首先，我们循环整个列表，并在每次迭代时将元素存储在项目变量中。我们使用`type()`方法检查存储在项目变量中的数据的类型。如果存储在项目中的值的类型不是整数，则使用`continue`语句来推断如果不是整数，则不执行任何操作。如果项目的类型是布尔值或字符串，则使用`continue`语句跳过该迭代。但是，如果存储在项目变量中的值的类型是整数，则将执行代码的 else 部分中的语句。我们将取该整数项目并将其添加到名为`refined_items`的新输出列表中。在检查每个元素之后，我们打印精炼的列表，这是数字的最终集合。

如果使用`break`语句，直到元素 8 之前的情况将保持不变。但是，我们的输出将受限于`[1,5,7,8]`，而不是打印其他元素`[89,90,11]`。这是因为`break`语句将在将元素 8 附加到列表后停止迭代。因此，我们可以得出结论，每当 Python 解释器触发`break`语句时，循环将终止：

```py
>>> items = [1,5,7,8,"Free","spam",False,89,90,11,"Python"]
>>> refined_items = []
>>> for item in items:
        if type(item) != int:
                 break
        else:
                 refined_items.append(item)
>>> print(refined_items)
[1,5,7,8]
```

我们知道，在实际环境中部署程序时，这些程序将习惯于我们的代码无法处理的不同情况。在这种情况下，我们的程序将终止，这对用户或游戏玩家会产生负面影响。因此，我们必须以这样的方式编写代码，使我们的代码可以适用于任何情况，即使遇到意外错误或异常。编程中的这种强大技术称为**异常处理**，这是我们将在下一节中介绍的内容。

# 使用 try 和 except 处理异常

在上一章中，我们创建了一个简单的井字棋游戏。我们在该章节的末尾讨论了一些修改。由于代码的不足，无法处理用户输入除整数以外的情况，因此建议进行一些修改。如果我们的用户将字符串输入为游戏的位置变量，会发生什么？将抛出以下异常：

![](img/a6598120-5b6e-40a1-a74b-b0c29d2e055b.png)

在上述截图中，我们可以看到我们的代码无法处理用户输入的字符串。只有当我们输入整数时，我们的代码才能正常运行。如果用户错误地输入任何其他数据值，程序将崩溃。本主题的目的是处理这种类型的错误。我们有两种类型的错误：语法错误和异常错误。以下代码显示了两种类型的示例：

```py
>>> print("Hey! it's me")))
SyntaxError: invalid syntax
```

每当您输入错误的语句时，它都会抛出一个错误消息，即语法错误。在这里，我们使用了比正常情况多两个括号来包围打印语句，这是不正确的。因此，Python 解析器会抛出语法错误。删除这两个额外的括号以消除语法错误：

```py
>>> a = 34
>>> a / 0
Traceback (most recent call last):
  File "<pyshell#2>", line 1, in <module>
    a / 0
ZeroDivisionError: division by zero
```

现在，Python 解析器抛出了一个异常错误。即使您的 Python 语法是正确的，也会发生这种错误。这可能是数学错误或逻辑错误。在数学上，您不能将任何数字除以零。这会导致一个无限大，这在 Python 中没有定义。因此，我们遇到了一个异常。有不同类型的异常。如果您想知道您遇到的异常的名称，请在收到异常后检查代码的最后一条语句。在我们的错误消息中，最后一条语句说`ZeroDivisionError`。因此，我们遇到了一个`ZeroDivisionError`异常。如果您遇到这些异常中的任何一个，那么您的代码很可能已经崩溃。因此，我们的井字棋游戏也崩溃了，因为它无法处理除整数以外的输入数据。

现在，我们的主要目标是使我们的代码可靠，即使我们的代码遇到异常，也不会崩溃，而是向用户提供友好的消息。在上面的示例中，我们可以发送用户一条消息，说`您不能将任何数字除以零`，而不是终止程序。这个过程称为异常处理。这些都是在 Python 中的`try`和`except`块中完成的。

如果您对代码是否出错不确定，您应该始终使用`try`和`except`块。您的主要代码，可能会遇到异常，应该放在`try`块内。然后，如果它遇到异常，Python 解析器应该执行`except`块内的代码。以下示例应该让您更清楚：

```py
>>> a = 34
 #INSIDE TRY BLOCK: put code that can give you error or exception
>>> try:
       print(a/0) #this will give you exception
    except:
       print("You cannot divide any number by Zero. It is Illegal!") #message to user

You cannot divide any number by Zero. It is Illegal!
```

上述代码显示了处理这些错误有多么容易。您将主要代码放在`try`块内，如果遇到异常，主要代码将不会被执行。相反，将执行`except`块内的代码，这种情况下是一个用户友好的消息。您还可以使用`pass`，以便在不向用户提供消息的情况下终止程序。

使用 except 关键字，您还可以显式传递异常的名称。但是，请确保您知道要遇到的正确异常名称。在这种情况下，我们知道我们将遇到 `ZeroDivisionError`，因此我们可以在 except 块中写入异常名称，如下所示：

```py
>>> a = 34
 #INSIDE TRY BLOCK: put code that can give you error or exception
>>> try:
        print(a/0) #this will give you exception
    except ZeroDivisionError:
        pass
```

现在，让我们看看如何利用我们迄今为止学到的一切知识来完善我们的井字棋游戏。我们将使用条件、循环和异常处理来修改我们在上一章中编写的代码。

# 为我们的井字棋游戏制作游戏控制器

在上一章中，我们构建了一个简单的井字棋游戏。由于在本章中我们已经学习了条件和循环，现在我们能够对我们的游戏进行一些改进。我们将对我们的游戏进行以下更改：

+   我们必须使游戏成为多人游戏，这意味着我们必须对程序进行修改，以便两名玩家可以玩我们的游戏。我们可以制作可以切换玩家的条件。

+   当我们谈到异常处理时，我们看到我们的游戏无法处理用户输入的字符串数据。我们可以使用 `try` 和 `except` 块来处理该异常。

+   我们无法确定我们在上一章中编写的代码的获胜者。现在我们已经了解了 `if` 条件，我们可以想出一些逻辑来检查玩家是否获胜。

我们将通过集思广益的方式开始我们的游戏开发过程，以收集有关游戏的一些关键信息。

# 集思广益和信息收集

我们的代码缺乏的一个重要特性是可读性。在上一章的游戏代码中，我们没有一个合适的方法来跟踪游戏板的位置。我们的代码可以做的第一件事是制作一个 choices 列表，其中包含玩家可以做出的所有选择。在这里，选择是用于井字棋板位置的。在井字棋游戏中，玩家可以在 0 到 8 之间选择数字，如果它们没有被其他玩家占据的话，这些数字就是占位符。

我们在代码中必须添加的第二件事是我们如何切换轮到谁了。由于我们只有两名玩家，我们可以让玩家 1 先行动并进行游戏的第一步。因此，制作逻辑会更容易。我们将制作一个布尔变量，并将其值从 True 更改为 False，以便我们可以制作一个条件来改变玩家的回合，如下所示：

+   `playerOne = True` 确保是玩家 1 的回合。

+   `playerOne = False` 将允许玩家 2 在我们的游戏板上行动。

我们必须遵循井字棋游戏的规则，以便根据玩家在游戏板上占据的位置来确定任何玩家是否获胜。如果玩家 X 或 O 占据了整行、整列或对角线的井字棋板，那么该玩家将被视为获胜者。这在下面的截图中有所体现：

![](img/6a16772b-7803-464b-b4f3-631078d63310.png)

# 修改模型

我们在上一章中编写的程序只能让一个玩家玩游戏。由于井字棋是一款多人游戏，应该对程序进行修改，以便多名玩家可以玩这个游戏。为此，我们必须做两件事：

+   跟踪棋盘上的空位。

+   制作一个条件来切换玩家的回合。

对于这两种修改，我们必须创建一个变量，可以跟踪游戏板上的每个空位和占用位置：

```py
#code is written in same previous file

choices = []
for pos in range(0,9):
      choices.append(str(pos+1))
```

如果您使用 `>>> print(choices)` 变量，这将导致一个值列表：`['1', '2', '3', '4', '5', '6', '7', '8', '9']`。它们是我们棋盘游戏的位置。

现在，如果您想打印棋盘的布局，您不能使用上一章的代码。我们将使用 `choices` 变量，而不是使用 `game_board` 变量。这与上一个示例中的工作方式相同。我们将在每一行之间添加一行短划线：

```py
#board layout
print('\n')
print('|' + choices[0] + '|' + choices[1] + '|' + choices[2] + '|')
print('----------')
print('|' + choices[3] + '|' + choices[4] + '|' + choices[5] + '|')
print('----------')
print('|' + choices[6] + '|' + choices[7] + '|' + choices[8] + '|')

#output
''' 
|1|2|3|
----------
|4|5|6|
----------
|7|8|9|

'''
```

我们游戏中的主要问题可能出现在用户输入非数字的情况下。例如，如果玩家输入字符串，游戏将以异常终止，我们不希望发生这种情况。正如您可能记得的那样，我们使用异常处理来避免这种情况。我们将在下一节中将其添加到我们的游戏中。

# 处理游戏的异常

让我们运行到目前为止我们制作的游戏，并在输入字段中输入一个字符串而不是整数值。你将得到以下异常：

![](img/aa708971-878e-4c70-a2a5-634070fb33d8.png)

我们不希望我们的程序在用户与我们的游戏交互时出现错误时崩溃。相反，我们可以发送给他们一个用户友好的消息，说`这不是有效的，只按整数键`。让我们通过使用`try`和`catch`块来处理这种类型的异常，如下所示：

```py
while True:
    print('\n')
    print('|' + choices[0] + '|' + choices[1] + '|' + choices[2] + '|')
    print('----------')
    print('|' + choices[3] + '|' + choices[4] + '|' + choices[5] + '|')
    print('----------')
    print('|' + choices[6] + '|' + choices[7] + '|' + choices[8] + '|')
    #above code is to print board layouts

    try:
        choice = int(input("> ").strip())
    except:
        print("Please enter only valid fields from board (0-8)")
        continue
```

当我们运行我们的程序时，我们将得到以下输出：

![](img/2902aef2-9493-4eb4-852d-53b8d85b2f87.png)

在这里，我们将 Python 字符串值输入到输入字段中。而不是使程序崩溃，我们得到了一条消息，说`请只输入来自棋盘的有效字段`。这是使用`try`和`except`块处理异常的一种方便的方法。我们使用了前一章的相同主循环，它将无限次循环。在`try`块的主体中，我们保留可能引发异常的代码。`strip()`是一个字符串方法，将从用户的输入中删除空格。我们必须使用`int`方法对用户输入进行类型转换，以便将以字符串形式的输入数据转换为整数。如果我们遇到异常，我们将执行`except`块中的代码。`continue`关键字将使主循环再次从头开始运行，如果我们遇到异常。

必须添加到我们的井字游戏中的主要功能是多人游戏，这样两个玩家可以轮流玩同一场游戏。这个切换功能将在下一节中添加。

# 切换玩家的轮次

使用 Python 编写程序让两个玩家玩游戏很容易，你只需要创建一个布尔变量来表示当前玩家是谁。然后，根据布尔的两个值，`True`或`False`，我们可以改变谁在玩游戏。但是，如果你想添加超过两个玩家，这个想法就行不通了。我们将使用以下布尔值：

+   `Is_Current_One = True`：当前玩家是玩家 1 或 X。

+   `Is_Current_One = False`：当前玩家是玩家 2 或 O。

这在以下代码中显示：

```py
#creating Boolean variable
Is_Current_One = True #default player is player X

#first move is done by player X
while True:
    #put code of board layouts here
    if Is_Current_One:
        print("Player X")
    else:
        print("Player O")

    #put try and except block here
    #---------------------------------------------
    #code to put either X or O on position selected by user
    if Is_Current_One:
        choices[choice-1] = 'X'
    else:
        choices[choice-1] = 'O'
    #code to toggle between True and False
    Is_Current_One = not Is_Current_One
```

让我们将前面的代码分成几个部分，以便更好地理解它：

+   我们有一个主循环，它将无限次运行，直到触发`break`语句。我们已经学会了`break`关键字将终止我们的循环。在主循环的主体中，我们打印出是玩家 X 还是 O 轮到了，以使玩家意识到轮到他们了。

+   我们创建了一个名为`Is_Current_One`的布尔变量，它被赋予了一个值`True`。这意味着第一个移动的玩家将是玩家`X`。如果我们将这个变量设为 False，那么第一个移动的默认玩家将是玩家`O`。

+   在主循环内，我们创建了一个条件来检查玩家`X`或玩家`O`是否已将`X`或`O`放置在棋盘布局上。`choices[]`变量反映了棋盘的位置。`choice`是用户的输入，我们将其减去 1，因为我们的 choices 变量是一个列表类型。我们知道列表索引从索引 0 开始，但我们已经输入了用户输入从 1 到 9。因此，我们将`choice`输入变量减去 1 以适应这个列表变量。

+   `>>> Is_Current_One = not Is_Current_One`语句将在玩家之间切换。正如我们之前提到的，如果`Is_Current_One`为`True`，那么玩家就是`X`，现在，我们还制定了一个条件，这样我们就可以在下一次迭代中将 True 改为 False，这样玩家`O`就可以进行下一步。

让我们通过运行我们的脚本文件来看看我们现在在做什么。您将在 shell 中看到以下结果打印出来：

![](img/a9420bfc-fd6e-45c1-9ec6-0a6e0acc55ab.png)

现在，我们已经创建了我们的游戏，它可以接受用户的输入，并将其放在井字游戏板上。我们已经制定了一些逻辑来改变轮到谁了。我们还能够使用`try`和`catch`块处理游戏中可能出现的异常。

我们一直在快速进展，但我们的游戏还不完整。我们还没有制定任何逻辑，如果玩家占据一行、一列或三个对角线单元，他们就会成为赢家。我们将在下一节中完成这一点。

# 使玩家成为赢家

**井字游戏**是一个很容易制作的游戏，但建立这个游戏的主要目的是涵盖 Python 的几乎所有核心编程范式，比如变量、数字、模型、内置方法、循环、分支和异常处理。现在，我们的游戏已经足够好，可以供两个玩家玩，但多人游戏最终只能有一个赢家。因此，我们必须制定全新的逻辑，以奖励玩家如果他们赢了。我们需要涵盖三种用例，如下：

+   如果井字游戏板的整行被一个玩家占据，那个玩家将成为赢家。

+   如果棋盘的整列被一个玩家占据，那个玩家将成为赢家。

+   如果棋盘的整个对角线被一个玩家占据，那个玩家将成为赢家。

让我们打印我们的游戏板布局，以及它们的位置，这样我们就可以在制定前述条件时跟踪棋盘的所有位置：

```py
| 1 | 2 | 3 |
 ----------
| 4 | 5 | 6 |
 ----------
| 7 | 8 | 9 |
```

由于我们必须循环遍历从 1 到 9 的所有这些位置，我们需要使用`for`循环。由于我们有一个有限的数字列表，所以使用`for`循环很容易。我们必须制定两个条件来检查玩家是否占据了整行或整列。在处理行和列之后，我们将独立检查对角线条件：

+   **对于行**：如果任何用户占据[1,2,3]，[4,5,6]，[7,8,9]，那个特定的玩家将被视为赢家。

+   **对于列**：如果任何用户占据[1,4,7]，[2,5,8]，[3,6,9]，那个特定的玩家将被视为赢家。

然而，`choice`变量中的位置范围是从 0 到 8，即['0'，'1'，'2'，'3'，'4'，'5'，'6'，'7'，'8']，因此索引 0 表示棋盘的第一个位置，索引 1 表示棋盘的第二个位置，依此类推。

我们一直在使用一个`while True`语句作为我们的主循环。让我们修改一下，这样我们的代码将一直运行，直到有一个玩家成为赢家。我们将运行我们的主循环，直到`won=False`。如果我们得到了游戏的赢家，我们将改变`won`变量的值为`True`，这样主循环就会结束：

```py
won = False #at first we don't have any winner
while not won:
    #code from previous topics
    #logic to make any player winner:
    for pos_x in range(0,3):
        pos_y = pos_x * 3 

        #for row condition:
        if (choices[pos_y] == choices[(pos_y + 1)]) and (choices[pos_y] 
           == choices[(pos_y + 2)]):
            #code to change won to True
            won = True #main loop will break

        #column condition:
        if (choices[pos_x] == choices[(pos_x + 3)]) and (choices[pos_x] 
          == choices[(pos_x + 6)]):
            won = True #main loop will break

```

在前面的代码中，我们制定了两个条件来检查玩家是否是赢家。我们制定了`won`变量来跟踪任何玩家是否赢了。如果任何玩家占据了整行或整列，我们将使`won`变量的值为 True，我们的循环将中断，这意味着我们将结束游戏。然而，我们还没有给用户一个关于成为赢家的消息。让我们编写一些代码，在检查行和列条件之后，告诉用户他们是赢家：

```py
while not won:
    #code from previous topic
    for pos_x in range(0,3):
        pos_y = pos_x * 3

    #add condition for row and column here

#print who is winner
print("Player " + str(int(Is_Current_One + 1)) + " won, Congratulations!")    
```

我们用`print`方法编写的语句可能会引起混淆，因为`str(int(Is_Current_One + 1))`命令。这里，`Is_Current_One`要么是`True`，要么是`False`。然而，它也对应着 1 或 0，其中 1 是`True`，0 是`False`。如果玩家`X`是赢家，那么赢家是玩家 1，但轮到了玩家`O`，也就是玩家 2。

因此，我们必须将这个加到 1，这样当前玩家就确定为赢家，而不是下一个玩家。由于这是一个双人游戏，这是有道理的。让我们运行我们的代码来检查结果：

![](img/42281b71-20e0-4c0b-b4d9-4ba3b1cb5f40.png)

我们还没有完成 - 我们还必须添加一个条件来检查对角线是否也被玩家占据。让我们现在添加这个条件：

```py
| 1 | 2 | 3 |
 ----------
| 4 | 5 | 6 |
 ----------
| 7 | 8 | 9 |
```

如果任何玩家占据位置[1,5,9]或[3,5,7]，他们将被视为赢家。然而，我们的`choices`变量是一个包含所有位置的列表。它的索引从 0 开始，这意味着如果你想定位玩家 1 的位置，你应该传递`choices[0]`，就像这样：

```py
while not won:
    #code from previous topic
    for pos_x in range(0,3):
        pos_y = pos_x * 3
    #add condition for row and column here

    #diagonal condition here:
    if ((choices[0] == choices[4] and choices[0] == choices[8]) or
        (choices[2] == choices[4] and choices[4] == choices[6])):
         won = True

#print who is winner
print("Player " + str(int(Is_Current_One + 1)) + " won, Congratulations!")  
```

现在，让我们再次运行游戏，检查这个条件是否正常工作：

![](img/37ad5c38-36cc-4c49-9f21-154360dc2db6.png)

最后，我们完成了我们的游戏！我们能够在游戏中包含许多功能，比如异常处理、多人游戏模式和使玩家成为赢家的逻辑。然而，我们仍然需要通过添加用户定义的函数来完善这个游戏，以便我们可以打印我们的棋盘布局。这将遵循 DRY 原则，并将在下一章中介绍。

# 总结

本章为我们提供了一个关于 Python 编程范式核心主题的过山车之旅。我们涵盖了流程控制以及如何使用分支和循环来实现它们。我们学习了如何制定条件并将其传递给条件语句。然后，基于这些条件，我们能够在语句的执行之间进行切换。我们看到了如何使用 Python 的循环和分支来自动化事物。我们使用`if`关键字传递了多个可能的条件，并且根据布尔表达式的结果来控制程序的流程。我们还学习了不同类型的循环，并看到了如何使用它们来迭代一个项目或对象的列表。然后，我们看到了如何使用 try 和 except 块来处理异常。

最后，我们通过结合本章学到的不同范式，使我们的井字棋游戏比以往任何时候都更具可玩性。我们添加了`try`和`except`块，以便捕获和正确处理任何异常。我们还添加了多人游戏模式和使玩家成为赢家的逻辑等功能。这使得游戏非常互动。最后，我们使用条件和循环制作了一个游戏控制器。然而，我们不会止步于此；在接下来的章节中将进行更多的修改。

下一章对我们来说将是改变生活的。到目前为止，我们只使用了 Python 的内置函数，比如`min()`、`max()`和`input()`。在下一章中，我们将看到如何制作我们自己的函数，并使用它们，以便我们可以使我们的游戏更易读和可重用。我们将涵盖列表、集合和字典等数据结构，以便我们知道如何管理和存储更复杂的数据集。不过，不要被所有这些陈述所压倒。你已经走了这么远，现在正处于成为熟练的 Python 程序员的边缘。在进入下一章之前，请确保你对我们迄今所学的所有主题都感到舒适。
