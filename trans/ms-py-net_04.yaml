- en: The Python Automation Framework – Ansible Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python自动化框架- Ansible基础知识
- en: The previous two chapters incrementally introduced different ways to interact
    with network devices. In [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml),
    *Low-Level Network Device Interactions*, we discussed Pexpect and Paramiko libraries
    that manage an interactive session to control the interactions. In [Chapter 3](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml),
    *APIs and Intent-Driven Networking*, we started to think of our network in terms
    of API and intent. We looked at various APIs that contain a well-defined command
    structure and provide a structured way of getting feedback from the device. As
    we moved from [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml), *Low-Level
    Network Device Interactions*, to [Chapter 3](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml),
    *APIs and Intent-Driven Networking*, we began to think about our intent for the
    network and gradually expressed our network in terms of code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前两章逐步介绍了与网络设备交互的不同方式。在[第2章](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml)中，*低级网络设备交互*，我们讨论了管理交互会话以控制交互的Pexpect和Paramiko库。在[第3章](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml)中，*API和意图驱动的网络*，我们开始从API和意图的角度思考我们的网络。我们看了各种包含明确定义的命令结构并提供了一种结构化方式从设备获取反馈的API。当我们从[第2章](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml)
    *低级网络设备交互*转移到[第3章](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml) *API和意图驱动的网络*时，我们开始思考我们对网络的意图，并逐渐以代码的形式表达我们的网络。
- en: 'Let''s expand upon the idea of translating our intention into network requirements.
    If you have worked on network designs, chances are the most challenging part of
    the process is not the different pieces of network equipment, but rather qualifying
    and translating business requirements into the actual network design. Your network
    design needs to solve business problems. For example, you might be working within
    a larger infrastructure team that needs to accommodate a thriving online e-commerce
    site that experiences slow site response times during peak hours. How do you determine
    if the network is the problem? If the slow response on the website was indeed
    due to network congestion, which part of the network should you upgrade? Can the
    rest of the system take advantage of the bigger speed and feed? The following
    diagram is an illustration of a simple process of the steps that we might go through
    when trying to translate our business requirements into a network design:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探讨将我们的意图转化为网络需求的想法。如果你曾经从事过网络设计，那么最具挑战性的部分往往不是网络设备的不同部分，而是资格和将业务需求转化为实际网络设计。你的网络设计需要解决业务问题。例如，你可能在一个更大的基础设施团队中工作，需要适应一个繁荣的在线电子商务网站，在高峰时段经历网站响应速度缓慢。你如何确定网络是否存在问题？如果网站的响应速度确实是由于网络拥塞造成的，那么你应该升级网络的哪一部分？其他系统能否利用更大的速度和吞吐量？以下图表是一个简单的过程的示意图，当我们试图将我们的业务需求转化为网络设计时，我们可能会经历的步骤：
- en: '![](assets/864b0e75-a6f0-4e3b-9115-d969d38f5605.png)Business logic to network
    deployment'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/864b0e75-a6f0-4e3b-9115-d969d38f5605.png)业务逻辑到网络部署'
- en: In my opinion, network automation is not just about faster configuration. It
    should also be about solving business problems, and accurately and reliably translating
    our intention into device behavior. These are the goals that we should keep in
    mind as we march on the network automation journey. In this chapter, we will start
    to look at a Python-based framework called **Ansible** that allows us to declare
    our intention for the network and abstract even more from the API and CLI.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，网络自动化不仅仅是更快的配置。它还应该解决业务问题，并准确可靠地将我们的意图转化为设备行为。这些是我们在网络自动化旅程中应该牢记的目标。在本章中，我们将开始研究一个名为**Ansible**的基于Python的框架，它允许我们声明我们对网络的意图，并从API和CLI中抽象出更多。
- en: A more declarative framework
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个更具声明性的框架
- en: You woke up one morning in a cold sweat from a nightmare you had about a potential
    network security breach. You realized that your network contains valuable digital
    assets that should be protected. You have been doing your job as a network administrator,
    so it is pretty secure, but you want to put more security measures around your
    network devices just to be sure.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有一天早上，你从一个关于潜在网络安全漏洞的噩梦中惊醒。你意识到你的网络包含有价值的数字资产，应该受到保护。作为网络管理员，你一直在做好工作，所以它相当安全，但你想在网络设备周围增加更多的安全措施，以确保安全。
- en: 'To start with, you break the objective down into two actionable items:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将目标分解为两个可行的项目：
- en: 'Upgrading the devices to the latest version of the software, which requires:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级设备到最新版本的软件，这需要：
- en: Uploading the image to the device.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将镜像上传到设备。
- en: Instructing the device to boot from the new image.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指示设备从新镜像启动。
- en: Proceeding to reboot the device.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续重新启动设备。
- en: Verifying that the device is running with the new software image.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证设备是否正在运行新软件镜像。
- en: 'Configuring the appropriate access control list on the networking devices,
    which includes the following:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络设备上配置适当的访问控制列表，包括以下内容：
- en: Constructing the access list on the device.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上构建访问列表。
- en: Configuring the access list on the interface, which in most cases is under the
    interface configuration section so that it can be applied to the interfaces.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接口上配置访问列表，在大多数情况下是在接口配置部分，以便可以应用到接口上。
- en: Being an automation-focused network engineer, you want to write scripts to reliably
    configure the devices and receive feedback from the operations. You begin to research
    the necessary commands and APIs for each of the steps, validate them in the lab,
    and finally deploy them in production. Having done a fair amount of work for OS
    upgrade and ACL deployment, you hope the scripts are transferable to the next
    generation of devices. Wouldn't it be nice if there was a tool that could shorten
    this design-develop-deployment cycle?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个以自动化为重点的网络工程师，您希望编写脚本来可靠地配置设备并从操作中获得反馈。您开始研究每个步骤所需的命令和API，在实验室中验证它们，最终在生产环境中部署它们。在为OS升级和ACL部署做了大量工作之后，您希望这些脚本可以转移到下一代设备上。如果有一个工具可以缩短这个设计-开发-部署周期，那不是很好吗？
- en: In this chapter and in [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml), *The
    Python Automation Framework – Beyond Basics*, we will work with an open source
    automation tool called **Ansible**. It is a framework that can simplify the process
    of going from business logic to network commands. It can configure systems, deploy
    software, and orchestrate a combination of tasks. Ansible is written in Python
    and has emerged as one of the leading automation tools supported by network equipment
    vendors.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和第5章《Python自动化框架-超越基础》中，我们将使用一个名为Ansible的开源自动化工具。它是一个可以简化从业务逻辑到网络命令的过程的框架。它可以配置系统，部署软件，并协调一系列任务。Ansible是用Python编写的，并已成为受网络设备供应商支持的领先自动化工具之一。
- en: 'In this chapter, we will take a look at the following topics:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: A quick Ansible example
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个快速的Ansible示例
- en: The advantages of Ansible
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible的优势
- en: The Ansible architecture
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible架构
- en: Ansible Cisco modules and examples
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible Cisco模块和示例
- en: Ansible Juniper modules and examples
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible Juniper模块和示例
- en: Ansible Arista modules and examples
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible Arista模块和示例
- en: At the time of writing this book, Ansible release 2.5 is compatible with Python
    2.6 and 2.7, with Python 3 support recently coming out of the technical review.
    Just like Python, many of the useful features of Ansible come from the community-driven
    extension modules. Even with Ansible core module supportability with Python 3,
    many of the extension modules and production deployments are still in Python 2
    mode. It will take some time to bring all the extension modules up from Python
    2 to Python 3\. Due to this reason, for the rest of this book, we will use Python
    2.7 with Ansible 2.2.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Ansible 2.5版本兼容Python 2.6和2.7，最近才从技术审查中获得了对Python 3的支持。与Python一样，Ansible的许多有用功能来自社区驱动的扩展模块。即使Ansible核心模块支持Python
    3，许多扩展模块和生产部署仍处于Python 2模式。需要一些时间将所有扩展模块从Python 2升级到Python 3。因此，在本书的其余部分，我们将使用Python
    2.7和Ansible 2.2。
- en: Why Ansible 2.2? Ansible 2.5, released in March 2018, offers many new network
    module features with a new connection method, syntax, and best practices. Given
    its relatively new features, most of the production deployment is still pre-2.5
    release. However, in this chapter, you will also find sections dedicated to Ansible
    2.5 examples for those who want to take advantage of the new syntax and features.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择Ansible 2.2？Ansible 2.5于2018年3月发布，提供了许多新的网络模块功能，具有新的连接方法、语法和最佳实践。鉴于其相对较新的功能，大多数生产部署仍处于2.5版本之前。然而，在本章中，您还将找到专门用于Ansible
    2.5示例的部分，供那些想要利用新语法和功能的人使用。
- en: For the latest information on Ansible Python 3 support, check out [http://docs.ansible.com/ansible/python_3_support.html](http://docs.ansible.com/ansible/python_3_support.html).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Ansible Python 3支持的最新信息，请访问[http://docs.ansible.com/ansible/python_3_support.html](http://docs.ansible.com/ansible/python_3_support.html)。
- en: As one can tell from the previous chapters, I am a believer in learning by examples.
    Just like the underlying Python code for Ansible, the syntax for Ansible constructs
    are easy enough to understand, even if you have not worked with Ansible before.
    If you have some experience with YAML or Jinja2, you will quickly draw the correlation
    between the syntax and the intended procedure. Let's take a look at an example
    first.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的章节可以看出，我是一个学习示例的信徒。就像Ansible的底层Python代码一样，即使您以前没有使用过Ansible，Ansible构造的语法也很容易理解。如果您有一些关于YAML或Jinja2的经验，您将很快找到语法和预期过程之间的关联。让我们先看一个例子。
- en: A quick Ansible example
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个快速的Ansible示例
- en: As with other automation tools, Ansible started out by managing servers before
    expanding its ability to manage networking equipment. For the most part, the modules
    and what Ansible refers to as the playbook are similar between server modules
    and network modules with subtle differences. In this chapter, we will look at
    a server task example first and draw comparisons later on with network modules.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他自动化工具一样，Ansible最初是用来管理服务器的，然后扩展到管理网络设备的能力。在很大程度上，服务器模块和网络模块以及Ansible所称的playbook之间是相似的，只是有细微的差别。在本章中，我们将首先看一个服务器任务示例，然后再与网络模块进行比较。
- en: The control node installation
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制节点安装
- en: First, let's clarify the terminology we will use in the context of Ansible.
    We will refer to the virtual machine with Ansible installed as the control machine,
    and the machines being managed as the target machines or managed nodes. Ansible
    can be installed on most of the Unix systems, with the only dependency of Python
    2.6 or 2.7\. Currently, the Windows operating system is not officially supported
    as the control machine. Windows hosts can still be managed by Ansible, as they
    are just not supported as the control machine.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们澄清一下在Ansible环境中使用的术语。我们将把安装了Ansible的虚拟机称为控制机，被管理的机器称为目标机器或被管理节点。Ansible可以安装在大多数Unix系统上，唯一的依赖是Python
    2.6或2.7。目前，Windows操作系统并不被官方支持作为控制机。Windows主机仍然可以被Ansible管理，只是不被支持作为控制机。
- en: As Windows 10 starts to adopt the Windows Subsystem for Linux, Ansible might
    soon be ready to run on Windows as well. For more information, please check the
    Ansible documentation for Windows ([https://docs.ansible.com/ansible/2.4/intro_windows.html](https://docs.ansible.com/ansible/2.4/intro_windows.html)).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Windows 10开始采用Windows子系统，Ansible可能很快也准备好在Windows上运行。有关更多信息，请查看Windows的Ansible文档（[https://docs.ansible.com/ansible/2.4/intro_windows.html](https://docs.ansible.com/ansible/2.4/intro_windows.html)）。
- en: On the managed node requirements, you may notice some documentation mentioning
    that Python 2.4 or later is a requirement. This is true for managing target nodes
    with operating systems such as Linux, but obviously not all network equipment
    supports Python. We will see how this requirement is bypassed for networking modules
    by local execution on the control node.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在受控节点要求中，您可能会注意到一些文档提到Python 2.4或更高版本是一个要求。这对于管理诸如Linux之类的操作系统的目标节点是正确的，但显然并非所有网络设备都支持Python。我们将看到如何通过在控制节点上本地执行来绕过网络模块的此要求。
- en: For Windows, Ansible modules are implemented in PowerShell. Windows modules
    in the core and extra repository live in a Windows/subdirectory if you would like
    to take a look.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows，Ansible模块是用PowerShell实现的。如果您想查看核心和额外存储库中的Windows模块，可以在Windows/subdirectory中找到。
- en: 'We will be installing Ansible on our Ubuntu virtual machine. For instructions
    on installation on other operating systems, check out the installation documentation
    ([http://docs.ansible.com/ansible/intro_installation.html](http://docs.ansible.com/ansible/intro_installation.html)).
    In the following code block, you will see the steps for installing the software
    packages:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的Ubuntu虚拟机上安装Ansible。有关其他操作系统的安装说明，请查看安装文档（[http://docs.ansible.com/ansible/intro_installation.html](http://docs.ansible.com/ansible/intro_installation.html)）。在以下代码块中，您将看到安装软件包的步骤：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can also use `pip` to install Ansible: `pip install ansible`. My personal
    preference is to use the operating system's package management system, such as
    Apt on Ubuntu.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`pip`来安装Ansible：`pip install ansible`。我个人更喜欢使用操作系统的软件包管理系统，比如Ubuntu上的Apt。
- en: 'We can now do a quick verification as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以进行快速验证如下：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let's see how we can run different versions of Ansible on the same control
    node. This is a useful feature to adopt if you'd like to try out the latest development
    features without permanent installation. We can also use this method if we intend
    on running Ansible on a control node for which we do not have root permissions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在同一控制节点上运行不同版本的Ansible。如果您想尝试最新的开发功能而不进行永久安装，这是一个有用的功能。如果我们打算在没有根权限的控制节点上运行Ansible，我们也可以使用这种方法。
- en: As we saw from the output, at the time of writing this book, the latest release
    is 2.6.1\. Feel free to use this version, but given the relatively new release,
    we will focus on Ansible version 2.2 in this book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，写作本书时，最新版本是2.6.1。请随意使用此版本，但考虑到相对较新的发布，我们将在本书中专注于Ansible版本2.2。
- en: Running different versions of Ansible from source
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从源代码运行不同版本的Ansible
- en: 'You can run Ansible from a source code checkout (we will look at Git as a version
    control mechanism in [Chapter 11](85c09606-4a40-46f3-82b8-0b20550fd64d.xhtml),
    *Working with Git*):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从源代码检出运行Ansible（我们将在[第11章](85c09606-4a40-46f3-82b8-0b20550fd64d.xhtml)中查看Git作为版本控制机制）：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To run different versions, we can simply use `git checkout` for the different
    branch or tag and perform the environment setup again:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行不同版本，我们可以简单地使用`git checkout`切换到不同的分支或标签，并重新执行环境设置：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the Git commands seem a bit strange to you, we will cover Git in more detail
    in [Chapter 11](85c09606-4a40-46f3-82b8-0b20550fd64d.xhtml), *Working with Git*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Git命令对您来说有点奇怪，我们将在[第11章](85c09606-4a40-46f3-82b8-0b20550fd64d.xhtml)中更详细地介绍Git。
- en: 'Once we are at the version you need, such as Ansible 2.2, we can run the update
    for the core modules for that version:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们到达您需要的版本，比如Ansible 2.2，我们可以为该版本运行核心模块的更新：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's take a look at the lab topology we will use in this chapter and [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml),
    *The Python Automation Framework – Beyond Basics*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们将在本章和[第5章](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml)中使用的实验室拓扑，*Python自动化框架-超越基础知识*。
- en: Lab setup
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验室设置
- en: 'In this chapter and in [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml),
    *The Python Automation Framework – Beyond Basics*, our lab will have an Ubuntu
    16.04 control node machine with Ansible installed. This control machine will have
    reachability for the management network for our VIRL devices, which consist of
    IOSv and NX-OSv devices. We will also have a separate Ubuntu VM for our playbook
    example when the target machine is a host:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和[第5章](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml)中，我们的实验室将有一个安装了Ansible的Ubuntu
    16.04控制节点机器。这个控制机器将能够访问我们的VIRL设备的管理网络，这些设备包括IOSv和NX-OSv设备。当目标机器是主机时，我们还将有一个单独的Ubuntu虚拟机用于我们的playbook示例。
- en: '![](assets/9f1dbd4a-6866-43af-ab4c-ef765483d7c4.png)Lab topology'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/9f1dbd4a-6866-43af-ab4c-ef765483d7c4.png)实验室拓扑'
- en: Now, we are ready to see our first Ansible playbook example.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备看我们的第一个Ansible playbook示例。
- en: Your first Ansible playbook
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第一个Ansible playbook
- en: 'Our first playbook will be used between the control node and a remote Ubuntu
    host. We will take the following steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个playbook将在控制节点和远程Ubuntu主机之间使用。我们将采取以下步骤：
- en: Make sure the control node can use key-based authorization.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保控制节点可以使用基于密钥的授权。
- en: Create an inventory file.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建清单文件。
- en: Create a playbook.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个playbook。
- en: Execute and test it.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行并测试它。
- en: The public key authorization
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公钥授权
- en: 'The first thing to do is copy your SSH public key from your control machine
    to the target machine. A full public key infrastructure tutorial is outside the
    scope of this book, but here is a quick walkthrough on the control node:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是将您的SSH公钥从控制机器复制到目标机器。完整的公钥基础设施教程超出了本书的范围，但在控制节点上有一个快速演练：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can read more about PKI at [https://en.wikipedia.org/wiki/Public_key_infrastructure](https://en.wikipedia.org/wiki/Public_key_infrastructure).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://en.wikipedia.org/wiki/Public_key_infrastructure](https://en.wikipedia.org/wiki/Public_key_infrastructure)了解更多关于PKI的信息。
- en: Because we are using key-based authentication, we can turn off password-based
    authentication on the remote node and be more secure. You will now be able to
    `ssh` from the control node to the remote node using the private key without being
    prompted for a password.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用基于密钥的身份验证，我们可以在远程节点上关闭基于密码的身份验证，使其更加安全。现在，你可以使用私钥从控制节点到远程节点进行`ssh`连接，而无需输入密码。
- en: Can you automate the initial public key copying? It is possible, but is highly
    dependent on your use case, regulation, and environment. It is comparable to the
    initial console setup for network gears to establish initial IP reachability.
    Do you automate this? Why or why not?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你能自动复制初始公钥吗？这是可能的，但高度依赖于你的用例、规定和环境。这类似于网络设备的初始控制台设置以建立初始IP可达性。你会自动化这个过程吗？为什么或者为什么不？
- en: The inventory file
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库存文件
- en: We do not need Ansible if we have no remote target to manage, right? Everything
    starts with the fact that we need to perform some task on a remote host. In Ansible,
    the way we specify the potential remote target is with an inventory file. We can
    have this inventory file as the `/etc/ansible/hosts` file or use the `-i` option
    to specify the file during playbook runtime. Personally, I prefer to have this
    file in the same directory where my playbook is and use the `-i` option.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有远程目标需要管理，我们就不需要Ansible，对吧？一切都始于我们需要在远程主机上执行一些任务。在Ansible中，我们指定潜在远程目标的方式是使用一个库存文件。我们可以将这个库存文件作为`/etc/ansible/hosts`文件，或者在playbook运行时使用`-i`选项指定文件。我个人更喜欢将这个文件放在与我的playbook相同的目录中，并使用`-i`选项。
- en: Technically, this file can be named anything you like as long as it is in a
    valid format. However, the convention is to name this file `hosts`. You can potentially
    save yourself and your colleagues some headaches in the future by following this
    convention.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，只要它是有效的格式，这个文件可以被命名为任何你喜欢的名字。然而，按照惯例，将这个文件命名为`hosts`。遵循这个惯例，你可以在未来避免一些麻烦。
- en: 'The inventory file is a simple, plaintext INI-style ([https://en.wikipedia.org/wiki/INI_file](https://en.wikipedia.org/wiki/INI_file))
    file that states your target. By default, the target can either be a DNS FQDN
    or an IP address:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 库存文件是一个简单的纯文本INI风格([https://en.wikipedia.org/wiki/INI_file](https://en.wikipedia.org/wiki/INI_file))文件，用于说明你的目标。默认情况下，目标可以是DNS
    FQDN或IP地址：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can now use the command-line option to test Ansible and the `hosts` file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用命令行选项来测试Ansible和`hosts`文件：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By default, Ansible assumes that the same user executing the playbook exists
    on the remote host. For example, I am executing the playbook as `echou` locally;
    the same user also exists on my remote host. If you want to execute as a different
    user, you can use the `-u` option when executing, that is, `-u REMOTE_USER`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible假设执行playbook的用户在远程主机上存在。例如，我在本地以`echou`的身份执行playbook；相同的用户也存在于我的远程主机上。如果你想以不同的用户执行，可以在执行时使用`-u`选项，即`-u
    REMOTE_USER`。
- en: The previous line in the example reads in the host file as the inventory file
    and executes the `ping` module on the host called `192.168.199.170`. Ping ([http://docs.ansible.com/ansible/ping_module.html](http://docs.ansible.com/ansible/ping_module.html))
    is a trivial test module that connects to the remote host, verifies a usable Python
    installation, and returns the output `pong` upon success.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的上一行将主机文件读入库存文件，并在名为`192.168.199.170`的主机上执行`ping`模块。Ping ([http://docs.ansible.com/ansible/ping_module.html](http://docs.ansible.com/ansible/ping_module.html))是一个简单的测试模块，连接到远程主机，验证可用的Python安装，并在成功时返回输出`pong`。
- en: You may take a look at the ever-expanding module list ([http://docs.ansible.com/ansible/list_of_all_modules.html](http://docs.ansible.com/ansible/list_of_all_modules.html))
    if you have any questions about the use of existing modules that were shipped
    with Ansible.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对已经与Ansible一起提供的现有模块的使用有任何疑问，可以查看不断扩展的模块列表([http://docs.ansible.com/ansible/list_of_all_modules.html](http://docs.ansible.com/ansible/list_of_all_modules.html))。
- en: 'If you get a host key error, it is typically because the host key is not in
    the `known_hosts` file, and is typically under `~/.ssh/known_hosts`. You can either
    SSH to the host and answer `yes` when adding the host, or you can disable this
    by checking on `/etc/ansible/ansible.cfg` or `~/.ansible.cfg` with the following
    code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到主机密钥错误，通常是因为主机密钥不在`known_hosts`文件中，通常位于`~/.ssh/known_hosts`下。你可以通过SSH到主机并在添加主机时回答`yes`，或者通过检查`/etc/ansible/ansible.cfg`或`~/.ansible.cfg`来禁用这个功能，使用以下代码：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have validated the inventory file and Ansible package, we can make
    our first playbook.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经验证了库存文件和Ansible包，我们可以制作我们的第一个playbook。
- en: Our first playbook
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个playbook
- en: Playbooks are Ansible's blueprint to describe what you would like to do to the
    hosts using modules. This is where we will be spending the majority of our time
    as operators when working with Ansible. If you are building a tree house, the
    playbook will be your manual, the modules will be your tools, while the inventory
    will be the components that you will be working on when using the tools.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Playbooks是Ansible描述使用模块对主机执行的操作的蓝图。这是我们在使用Ansible时作为操作员将要花费大部分时间的地方。如果你正在建造一个树屋，playbook将是你的手册，模块将是你的工具，而库存将是你在使用工具时要处理的组件。
- en: The playbook is designed to be human readable, and is in YAML format. We will
    look at the common syntax used in the Ansible architecture section. For now, our
    focus is to run an example playbook to get the look and feel of Ansible.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: playbook旨在人类可读，并且采用YAML格式。我们将在Ansible架构部分看到常用的语法。现在，我们的重点是运行一个示例playbook，以了解Ansible的外观和感觉。
- en: Originally, YAML was said to mean Yet Another Markup Language, but now, [http://yaml.org/](http://yaml.org/) has
    repurposed the acronym to be YAML ain't markup language.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，YAML被说成是另一种标记语言，但现在，[http://yaml.org/](http://yaml.org/)已经重新定义这个首字母缩写为YAML不是标记语言。
- en: 'Let''s look at this simple 6-line playbook, `df_playbook.yml`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个简单的6行playbook，`df_playbook.yml`：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In a playbook, there can be one or more plays. In this case, we have one play
    (lines two to six). In any play, we can have one or more tasks. In our example
    play, we have just one task (lines four to six). The `name` field specifies the
    purpose of the task in a human readable format and the `shell` module was used.
    The module takes one argument of `df`. The `shell` module reads in the command
    in the argument and executes it on the remote host. In this case, we execute the
    `df` command to check the disk usage and copy the output to a file named `df_temp.txt`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在playbook中，可以有一个或多个plays。在这种情况下，我们有一个play（第二到第六行）。在任何play中，我们可以有一个或多个任务。在我们的示例play中，我们只有一个任务（第四到第六行）。`name`字段以人类可读的格式指定任务的目的，使用了`shell`模块。该模块接受一个`df`参数。`shell`模块读取参数中的命令并在远程主机上执行它。在这种情况下，我们执行`df`命令来检查磁盘使用情况，并将输出复制到名为`df_temp.txt`的文件中。
- en: 'We can execute the playbook via the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下代码执行playbook：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you log into the managed host (`192.168.199.170`, for me), you will see that
    the `df_temp.txt` file contains the output of the `df` command. Neat, huh?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您登录到受管主机（对我来说是`192.168.199.170`），您会看到`df_temp.txt`文件包含`df`命令的输出。很整洁，对吧？
- en: You may have noticed that there were actually two tasks executed in our output,
    even though we only specified one task in the playbook; the setup module is automatically
    added by default. It is executed by Ansible to gather information about the remote
    host, which can be used later on in the playbook. For example, one of the facts
    that the setup module gathers is the operating system. What is the purpose of
    gathering facts about the remote target? You can use this information as a conditional
    for additional tasks in the same playbook. For example, the playbook can contain
    additional tasks to install packages. It can do this specifically to use `apt`
    for Debian-based hosts and `yum` for Red Hat-based hosts, based on the operation
    system facts that were gathered in the setup module.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们的输出实际上执行了两个任务，尽管我们在playbook中只指定了一个任务；设置模块是默认自动添加的。它由Ansible执行，以收集有关远程主机的信息，这些信息可以在playbook中稍后使用。例如，设置模块收集的事实之一是操作系统。收集有关远程目标的事实的目的是什么？您可以将此信息用作同一playbook中其他任务的条件。例如，playbook可以包含额外的任务来安装软件包。它可以具体使用`apt`来为基于Debian的主机安装软件包，使用`yum`来为基于Red
    Hat的主机安装软件包，这是基于在设置模块中收集的操作系统事实。
- en: If you are curious about the output of a setup module, you can find out what
    information Ansible gathers via `$ ansible -i hosts <host> -m setup`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对设置模块的输出感到好奇，您可以通过`$ ansible -i hosts <host> -m setup`找出Ansible收集的信息。
- en: Underneath the hood, there are actually a few things that have happened for
    our simple task. The control node copies the Python module to the remote host,
    executes the module, copies the module output to a temporary file, then captures
    the output and deletes the temporary file. For now, we can probably safely ignore
    these underlying details until we need them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，我们的简单任务实际上发生了一些事情。控制节点将Python模块复制到远程主机，执行模块，将模块输出复制到临时文件，然后捕获输出并删除临时文件。目前，我们可能可以安全地忽略这些底层细节，直到我们需要它们。
- en: It is important that we fully understand the simple process that we have just
    gone through because we will be referring back to these elements later in this
    chapter. I purposely chose a server example to be presented here, because this
    will make more sense as we dive into the networking modules when we need to deviate
    from them (remember that we mentioned the Python interpreter is most likely not
    on the network gear).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们充分理解我们刚刚经历的简单过程，因为我们将在本章后面再次提到这些元素。我特意选择了一个服务器示例来呈现在这里，因为当我们需要偏离它们时（记住我们提到Python解释器很可能不在网络设备上），这将更有意义。
- en: Congratulations on executing your first Ansible playbook! We will look more
    into the Ansible architecture, but for now let's take a look at why Ansible is
    a good fit for network management. Remember that Ansible modules are written in
    Python? That is one advantage for a Pythonic network engineer, right?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您执行了您的第一个Ansible playbook！我们将更深入地了解Ansible架构，但现在让我们看看为什么Ansible非常适合网络管理。记住Ansible模块是用Python编写的吗？这对于Python网络工程师来说是一个优势，对吧？
- en: The advantages of Ansible
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible的优势
- en: There are many infrastructure automation frameworks besides Ansible—namely Chef,
    Puppet, and SaltStack. Each framework offers its own unique features and models;
    there is no one right framework that fits all the organizations. In this section,
    I would like to list some of the advantages of Ansible over other frameworks and
    why I think this is a good tool for network automation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Ansible之外，还有许多基础设施自动化框架，包括Chef、Puppet和SaltStack。每个框架都提供其独特的功能和模型；没有一个框架适合所有组织。在本节中，我想列出Ansible相对于其他框架的一些优势，以及为什么我认为这是网络自动化的好工具。
- en: I am listing the advantages of Ansible without comparing them to other frameworks.
    Other frameworks might adopt some of the same philosophy or certain aspects of
    Ansible, but rarely do they contain all of the features that I will be mentioning.
    I believe it is the combination of all the following features and philosophy that
    makes Ansible ideal for network automation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在列出Ansible的优势，而不是将它们与其他框架进行比较。其他框架可能采用与Ansible相同的某些理念或某些方面，但很少包含我将要提到的所有功能。我相信正是所有以下功能和理念的结合使得Ansible成为网络自动化的理想选择。
- en: Agentless
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无需代理
- en: Unlike some of its peers, Ansible does not require a strict master-client model.
    No software or agent needs to be installed on the client that communicates back
    to the server. Outside of the Python interpreter, which many platforms have by
    default, there is no additional software needed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些同行不同，Ansible不需要严格的主从模型。客户端不需要安装软件或代理来与服务器通信。除了许多平台默认具有的Python解释器外，不需要额外的软件。
- en: For network automation modules, instead of relying on remote host agents, Ansible
    uses SSH or API calls to push the required changes to the remote host. This further
    reduces the need for the Python interpreter. This is huge for network device management,
    as network vendors are typically reluctant to put third-party software on their
    platforms. SSH, on the other hand, already exists on the network equipment. This
    mentality has changed a bit in the last few years, but overall SSH is the common
    denominator for all network equipment while configuration management agent support
    is not. As you will remember from [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml), *Low-Level
    Network Device Interacti**ons*, newer network devices also provide an API layer,
    which can also be leveraged by Ansible.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络自动化模块，Ansible使用SSH或API调用将所需的更改推送到远程主机，而不是依赖远程主机代理。这进一步减少了对Python解释器的需求。对于网络设备管理来说，这对于网络设备管理来说是非常重要的，因为网络供应商通常不愿意在其平台上安装第三方软件。另一方面，SSH已经存在于网络设备上。这种心态在过去几年里有所改变，但总体上，SSH是所有网络设备的共同点，而配置管理代理支持则不是。正如您从第2章“低级网络设备交互”中所记得的那样，更新的网络设备还提供API层，这也可以被Ansible利用。
- en: Because there is no agent on the remote host, Ansible uses a push model to push
    the changes to the device, as opposed to the pull model where the agent pulls
    the information from the master server. The push model, in my opinion, is more
    deterministic as everything originates from the control machine. In a pull model,
    the timing of the `pull` might vary from client to client, and therefore results
    in change timing variance.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于远程主机上没有代理，Ansible使用推送模型将更改推送到设备，而不是拉模型，其中代理从主服务器拉取信息。在我看来，推送模型更具确定性，因为一切都起源于控制机器。在拉模型中，“拉”的时间可能因客户端而异，因此导致更改时间的差异。
- en: Again, the importance of being agentless cannot be stressed enough when it comes
    to working with the existing network equipment. This is usually one of the major
    reasons network operators and vendors embrace Ansible.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调与现有网络设备一起工作时无代理的重要性是不言而喻的。这通常是网络运营商和供应商接受Ansible的主要原因之一。
- en: Idempotent
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 幂等性
- en: According to Wikipedia, idempotence is the property of certain operations in
    mathematics and computer science that can be applied multiple times without changing
    the result beyond the initial application ([https://en.wikipedia.org/wiki/Idempotence](https://en.wikipedia.org/wiki/Idempotence)).
    In more common terms, it means that running the same procedure over and over again
    does not change the system after the first time. Ansible aims to be idempotent,
    which is good for network operations that require a certain order of operations.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科的定义，幂等性是数学和计算机科学中某些操作的属性，可以多次应用而不会改变初始应用后的结果（https://en.wikipedia.org/wiki/Idempotence）。更常见的说法是，这意味着反复运行相同的过程不会改变系统。Ansible旨在具有幂等性，这对于需要一定操作顺序的网络操作是有益的。
- en: The advantage of idempotence is best compared to the Pexpect and Paramiko scripts
    that we have written. Remember that these scripts were written to push out commands
    as if an engineer was sitting at the terminal. If you were to execute the script
    10 times, the script will make changes 10 times. If we write the same task via
    the Ansible playbook, the existing device configuration will be checked first,
    and the playbook will only execute if the changes do not exist. If we execute
    the playbook 10 times, the change will only be applied during the first run, with
    the next 9 runs suppressing the configuration change.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等性的优势最好与我们编写的Pexpect和Paramiko脚本进行比较。请记住，这些脚本是为了像工程师坐在终端上一样推送命令而编写的。如果您执行该脚本10次，该脚本将进行10次更改。如果我们通过Ansible
    playbook编写相同的任务，将首先检查现有设备配置，只有在更改不存在时才会执行playbook。如果我们执行playbook 10次，更改只会在第一次运行时应用，接下来的9次运行将抑制配置更改。
- en: Being idempotent means we can repeatedly execute the playbook without worrying
    that there will be unnecessary changes made. This is important as we need to automatically
    check for state consistency without any extra overhead.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等性意味着我们可以重复执行playbook，而不必担心会有不必要的更改。这很重要，因为我们需要自动检查状态的一致性，而不会有任何额外的开销。
- en: Simple and extensible
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单且可扩展
- en: Ansible is written in Python and uses YAML for the playbook language, both of
    which are considered relatively easy to learn. Remember the Cisco IOS syntax?
    This is a domain-specific language that is only applicable when you are managing
    Cisco IOS devices or other similarly structured equipment; it is not a general
    purpose language beyond its limited scope. Luckily, unlike some other automation
    tools, there is no extra domain-specific language or DSL to learn for Ansible
    because YAML and Python are both widely used as general purpose languages.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是用Python编写的，并使用YAML作为playbook语言，这两者都被认为相对容易学习。还记得Cisco IOS的语法吗？这是一种特定领域的语言，只适用于管理Cisco
    IOS设备或其他类似结构的设备；它不是一个通用的语言，超出了其有限的范围。幸运的是，与一些其他自动化工具不同，Ansible没有额外的特定领域语言或DSL需要学习，因为YAML和Python都被广泛用作通用目的语言。
- en: As you can see from the previous example, even if you have not seen YAML before,
    it is easy to accurately guess what the playbook is trying to do. Ansible also
    uses Jinja2 as a template engine, which is a common tool used by Python web frameworks
    such as Django and Flask, so the knowledge is transferable.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的例子中可以看出，即使您以前没有见过YAML，也很容易准确猜出playbook的意图。Ansible还使用Jinja2作为模板引擎，这是Python
    web框架（如Django和Flask）常用的工具，因此知识是可转移的。
- en: I cannot stress enough the extensibility of Ansible. As illustrated by the preceding
    example, Ansible starts out with automating server (primarily Linux) workloads
    in mind. It then branches out to manage Windows machines with PowerShell. As more
    and more people in the industry started to adapt Ansible, the network became a
    topic that started to get more attention. The right people and team were hired
    at Ansible, network professionals started to get involved, and customers started
    to demand vendors for support. Starting with Ansible 2.0, network automation has
    become a first-class citizen alongside server management. The ecosystem is alive
    and well, with continuous improvement in each of the releases.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法强调Ansible的可扩展性。正如前面的例子所示，Ansible最初是为了自动化服务器（主要是Linux）工作负载而设计的。然后它开始用PowerShell管理Windows机器。随着越来越多的行业人员开始采用Ansible，网络成为一个开始受到更多关注的话题。Ansible聘请了合适的人员和团队，网络专业人员开始参与，客户开始要求供应商提供支持。从Ansible
    2.0开始，网络自动化已成为与服务器管理并驾齐驱的一等公民。生态系统活跃而健康，每个版本都在不断改进。
- en: Just like the Python community, the Ansible community is friendly, and the attitude
    is inclusive of new members and ideas. I have first-hand experience of being a
    noob and trying to make sense of contribution procedures and wishing to write
    modules to be merged upstream. I can testify to the fact that I felt welcomed
    and respected for my opinions at all times.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Python社区一样，Ansible社区也很友好，对新成员和新想法持包容态度。我亲身经历过成为新手，试图理解贡献程序并希望编写模块以合并到上游的过程。我可以证明，我始终感到受到欢迎和尊重我的意见。
- en: The simplicity and extensibility really speak well for future proofing. The
    technology world is evolving fast, and we are constantly trying to adapt to it.
    Wouldn't it be great to learn a technology once and continue to use it, regardless
    of the latest trend? Obviously, nobody has a crystal ball to accurately predict
    the future, but Ansible's track record speaks well for future technology adaptation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 简单性和可扩展性确实为未来的保护做出了很好的表述。技术世界发展迅速，我们不断努力适应。学习一项技术并继续使用它，而不受最新趋势的影响，这不是很好吗？显然，没有人有水晶球能够准确预测未来，但Ansible的记录为未来技术的适应性做出了很好的表述。
- en: Network vendor support
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络供应商支持
- en: Let's face it, we don't live in a vacuum. There is a running joke in the industry
    that the OSI layer should include a layer 8 (money) and 9 (politics). Every day,
    we need to work with network equipment made by various vendors.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们面对现实，我们不是生活在真空中。行业中有一个流行的笑话，即OSI层应该包括第8层（金钱）和第9层（政治）。每天，我们需要使用各种供应商制造的网络设备。
- en: Take API integration as an example. We saw the difference between the Pexpect
    and API approach in previous chapters. API clearly has an upper hand in terms
    of network automation. However, the API interface does not come cheap. Each vendor
    needs to invest time, money, and engineering resources to make the integration
    happen. The willingness for the vendor to support a technology matters greatly
    in our world. Luckily, all the major vendors support Ansible, as clearly indicated
    by the ever increasingly available network modules ([http://docs.ansible.com/ansible/list_of_network_modules.html](http://docs.ansible.com/ansible/list_of_network_modules.html)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以API集成为例。我们在前几章中看到了Pexpect和API方法之间的差异。在网络自动化方面，API显然具有优势。然而，API接口并不便宜。每个供应商都需要投入时间、金钱和工程资源来实现集成。供应商支持技术的意愿在我们的世界中非常重要。幸运的是，所有主要供应商都支持Ansible，这清楚地表明了越来越多的网络模块可用（[http://docs.ansible.com/ansible/list_of_network_modules.html](http://docs.ansible.com/ansible/list_of_network_modules.html)）。
- en: Why do vendors support Ansible more than other automation tools? Being agentless
    certainly helps, since having SSH as the only dependency greatly lowers the bar
    of entry. Engineers who have been on the vendor side know that the feature request
    process is usually months long and many hurdles have to be jumped through. Any
    time a new feature is added, it means more time spent on regression testing, compatibility
    checking, integration reviews, and many more. Lowering the bar of entry is usually
    the first step in getting vendor support.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么供应商支持Ansible比其他自动化工具更多？无代理的特性肯定有所帮助，因为只有SSH作为唯一的依赖大大降低了进入门槛。在供应商一侧工作过的工程师知道，功能请求过程通常需要数月时间，需要克服许多障碍。每次添加新功能，都意味着需要花更多时间进行回归测试、兼容性检查、集成审查等。降低进入门槛通常是获得供应商支持的第一步。
- en: The fact that Ansible is based on Python, a language liked by many networking
    professionals, is another great propeller for vendor support. For vendors such
    as Juniper and Arista who already made investments in PyEZ and Pyeapi, they can
    easily leverage the existing Python modules and quickly integrate their features
    into Ansible. As you will see in [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml), *The
    Python Automation Framework – Beyond Basics*, we can use our existing Python knowledge
    to easily write our own modules.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible基于Python这一事实，这是许多网络专业人员喜欢的语言，也是供应商支持的另一个重要推动力。对于已经在PyEZ和Pyeapi上进行投资的Juniper和Arista等供应商，他们可以轻松利用现有的Python模块，并快速将其功能集成到Ansible中。正如我们将在第5章《Python自动化框架-超越基础知识》中看到的，我们可以利用现有的Python知识轻松编写自己的模块。
- en: Ansible already had a large number of community-driven modules before it focused
    on networking. The contribution process is somewhat baked and established, or
    as baked as an open source project can be. The core Ansible team is familiar with
    working with the community for submission and contribution.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible专注于网络之前，它已经拥有大量由社区驱动的模块。贡献过程在某种程度上已经成熟和建立，或者说已经成熟，就像一个开源项目可以成熟一样。Ansible核心团队熟悉与社区合作进行提交和贡献。
- en: Another reason for the increased network vendor support also has to do with
    Ansible's ability to give vendors the ability to express their own strength in
    the module context. We will see in the coming section that, besides SSH, the Ansible
    module can also be executed locally and communicate with these devices by using
    API. This ensures that vendors can express their latest and greatest features
    as soon as they make them available through the API. In terms of network professionals,
    this means that you can use the cutting-edge features to select the vendors when
    you are using Ansible as an automation platform.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 增加网络供应商支持的另一个原因也与Ansible能够让供应商在模块上表达自己的优势有关。我们将在接下来的部分中看到，除了SSH，Ansible模块还可以在本地执行，并通过API与这些设备通信。这确保供应商可以在他们通过API提供最新和最好的功能时立即表达出来。对于网络专业人员来说，这意味着您可以在使用Ansible作为自动化平台时，使用最前沿的功能来选择供应商。
- en: We have spent a relatively large portion of space discussing vendor support
    because I feel that this is often an overlooked part in the Ansible story. Having
    vendors willing to put their weight behind the tool means you, the network engineer,
    can sleep at night knowing that the next big thing in networking will have a high
    chance of Ansible support, and you are not locked into your current vendor as
    your network needs to grow.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了相当大的篇幅讨论供应商支持，因为我觉得这经常被忽视在Ansible故事中。有供应商愿意支持这个工具意味着您，网络工程师，可以放心地睡觉，知道下一个网络中的重大事件将有很高的机会得到Ansible的支持，您不会被锁定在当前供应商上，因为您的网络需要增长。
- en: The Ansible architecture
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible架构
- en: 'The Ansible architecture consists of playbooks, plays, and tasks. Take a look
    at `df_playbook.yml` that we used previously:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible架构由playbooks、plays和tasks组成。看一下我们之前使用的`df_playbook.yml`：
- en: '![](assets/5d5fb374-caea-4662-ad0b-27dffe364640.png)Ansible playbook'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5d5fb374-caea-4662-ad0b-27dffe364640.png)Ansible playbook'
- en: 'The whole file is called a playbook, which contains one or more plays. Each
    play can consist of one or more tasks. In our simple example, we only have one
    play, which contains a single task. In this section, we will take a look at the
    following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 整个文件称为playbook，其中包含一个或多个plays。每个play可以包含一个或多个tasks。在我们的简单示例中，我们只有一个play，其中包含一个单独的task。在本节中，我们将看一下以下内容：
- en: '**YAML**: This format is extensively used in Ansible to express playbooks and
    variables.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YAML**：这种格式在Ansible中被广泛用于表达playbooks和变量。'
- en: '**Inventory**: The inventory is where you can specify and group hosts in your
    infrastructure. You can also optionally specify host and group variables in the
    inventory file.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清单**：清单是您可以在其中指定和分组基础设施中的主机的地方。您还可以在清单文件中可选地指定主机和组变量。'
- en: '**Variables**: Each of the network devices is different. It has a different
    hostname, IP, neighbor relations, and so on. Variables allow for a standard set
    of plays while still accommodating these differences.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**：每个网络设备都不同。它有不同的主机名、IP、邻居关系等。变量允许使用标准的plays，同时还能适应这些差异。'
- en: '**Templates**: Templates are nothing new in networking. In fact, you are probably
    using one without thinking of it as a template. What do we typically do when we
    need to provision a new device or replace an RMA (return merchandise authorization)?
    We copy the old configuration over and replace the differences such as the hostname
    and the loopback IP addresses. Ansible standardizes the template formatting with
    Jinja2, which we will dive deeper into later on.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**：模板在网络中并不新鲜。事实上，您可能在不经意间使用了一个模板。当我们需要配置新设备或替换RMA（退货授权）时，我们通常会复制旧配置并替换主机名和环回IP地址等差异。Ansible使用Jinja2标准化模板格式，我们稍后将深入探讨。'
- en: In [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml), *The Python Automation
    Framework – Beyond Basics*, we will cover some more advanced topics such as conditionals,
    loops, blocks, handlers, playbook roles, and how they can be included with network
    management.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml)中，《Python自动化框架-超越基础知识》，我们将涵盖一些更高级的主题，如条件、循环、块、处理程序、playbook角色以及它们如何与网络管理一起使用。
- en: YAML
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAML
- en: 'YAML is the syntax used for Ansible playbooks and some other files. The official
    YAML documentation contains the full specifications of the syntax. Here is a compact
    version as it pertains to the most common usage for Ansible:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: YAML是Ansible playbooks和一些其他文件使用的语法。官方的YAML文档包含了语法的完整规范。以下是与Ansible最常见用法相关的简洁版本：
- en: A YAML file starts with three dashes (`---`)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAML文件以三个破折号(`---`)开头
- en: Whitespace indentation is used to denote structures when they are lined up,
    just like Python
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空格缩进用于表示结构，就像Python一样
- en: Comments begin with the hash (`#`) sign
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释以井号(`#`)开头
- en: List members are denoted by a leading hyphen (`-`), with one member per line
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表成员以前导连字符(`-`)表示，每行一个成员
- en: Lists can also be denoted via square brackets (`[]`), with elements separated
    by a comma (`,`)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表也可以用方括号(`[]`)表示，元素之间用逗号(`,`)分隔
- en: 'Dictionaries are denoted by key: value pairs, with a colon for separation'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '字典由key: value对表示，用冒号分隔'
- en: Dictionaries can be denoted by curly braces, with elements separated by a comma
    (`,`)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典可以用花括号表示，元素之间用逗号分隔
- en: Strings can be unquoted, but can also be enclosed in double or single quotes
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串可以不用引号，但也可以用双引号或单引号括起来
- en: 'As you can see, YAML maps well into JSON and Python datatypes. If I were to
    rewrite `df_playbook.yml` into `df_playbook.json`, this is what it would look
    like:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，YAML很好地映射到JSON和Python数据类型。如果我要将`df_playbook.yml`重写为`df_playbook.json`，它将如下所示：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is obviously not a valid playbook, but serves as an aid in helping to
    understand the YAML formats while using the JSON format as a comparison. Most
    of the time, comments (`#`), lists (`-`), and dictionaries (key: value) are what
    you will see in a playbook.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '这显然不是一个有效的playbook，但可以帮助理解YAML格式，同时使用JSON格式进行比较。大多数情况下，playbook中会看到注释(`#`)、列表(`-`)和字典(key:
    value)。'
- en: Inventories
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清单
- en: 'By default, Ansible looks at the `/etc/ansible/hosts` file for hosts specified
    in your playbook. As mentioned previously, I find it more expressive to specify
    the host file via the `-i` option. This is what we have been doing up to this
    point. To expand on our previous example, we can write our inventory host file
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible会查看`/etc/ansible/hosts`文件中在playbook中指定的主机。如前所述，我发现通过`-i`选项指定主机文件更具表现力。这是我们到目前为止一直在做的。为了扩展我们之前的例子，我们可以将我们的清单主机文件写成如下形式：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you may have guessed, the square bracket headings specify group names, so
    later on in the playbook we can point to this group. For example, in `cisco_1.yml`
    and `cisco_2.yml`, I can act on all of the hosts specified under the `nexus` group
    to the group name of `nexus`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到，方括号标题指定了组名，所以在playbook中我们可以指向这个组。例如，在`cisco_1.yml`和`cisco_2.yml`中，我可以对`nexus`组下指定的所有主机进行操作，将它们指向`nexus`组名：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A host can exist in more than one group. The group can also be nested as `children`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个主机可以存在于多个组中。组也可以作为`children`进行嵌套：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the previous example, the datacenter group includes both the `cisco` and
    `arista` members.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，数据中心组包括`cisco`和`arista`成员。
- en: We will discuss variables in the next section. However, you can optionally specify
    variables belonging to the host and group in the inventory file as well. In our
    first inventory file example, [`nexus:vars`] specifies variables for the whole
    nexus group. The `ansible_host` variable declares variables for each of the hosts
    on the same line.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节讨论变量。但是，您也可以选择在清单文件中指定属于主机和组的变量。在我们的第一个清单文件示例中，[`nexus:vars`]指定了整个nexus组的变量。`ansible_host`变量在同一行上为每个主机声明变量。
- en: For more information on the inventory file, check out the official documentation
    ([http://docs.ansible.com/ansible/intro_inventory.html](http://docs.ansible.com/ansible/intro_inventory.html)).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有关清单文件的更多信息，请查看官方文档（[http://docs.ansible.com/ansible/intro_inventory.html](http://docs.ansible.com/ansible/intro_inventory.html)）。
- en: Variables
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'We discussed variables a bit in the previous section. Because our managed nodes
    are not exactly alike, we need to accommodate the differences via variables. Variable
    names should be letters, numbers, and underscores, and should always start with
    a letter. Variables are commonly defined in three locations:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中稍微讨论了变量。由于我们的受管节点并不完全相同，我们需要通过变量来适应这些差异。变量名应该是字母、数字和下划线，并且应该以字母开头。变量通常在三个位置定义：
- en: The playbook
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: playbook
- en: The inventory file
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清单文件
- en: Separate files to be included in files and roles
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将要包含在文件和角色中的单独文件
- en: 'Let''s look at an example of defining variables in a playbook, `cisco_1.yml`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个在playbook中定义变量的例子，`cisco_1.yml`：
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see the `cli` variable declared under the `vars` section, which is being
    used in the task of `nxos_snmp_contact`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vars`部分下可以看到`cli`变量的声明，该变量在`nxos_snmp_contact`任务中被使用。
- en: For more information on the `nxso_snmp_contact` module, check out the online
    documentation ([http://docs.ansible.com/ansible/nxos_snmp_contact_module.html](http://docs.ansible.com/ansible/nxos_snmp_contact_module.html)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`nxso_snmp_contact`模块的更多信息，请查看在线文档（[http://docs.ansible.com/ansible/nxos_snmp_contact_module.html](http://docs.ansible.com/ansible/nxos_snmp_contact_module.html)）。
- en: To reference a variable, you can use the Jinja2 templating system convention
    of a double curly bracket. You don't need to put quotes around the curly bracket
    unless you are starting a value with it. I typically find it easier to remember
    and put a quote around the variable value regardless.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用一个变量，可以使用Jinja2模板系统的双花括号约定。除非您以它开头，否则不需要在花括号周围加引号。我通常发现更容易记住并在变量值周围加上引号。
- en: You may have also noticed the `{{ inventory_hostname }}` reference, which is
    not declared in the playbook. It is one of the default variables that Ansible
    provides for you automatically, and it is sometimes referred to as the magic variable.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了`{{ inventory_hostname }}`的引用，在playbook中没有声明。这是Ansible自动为您提供的默认变量之一，有时被称为魔术变量。
- en: There are not many magic variables, and you can find the list in the documentation
    ([http://docs.ansible.com/ansible/playbooks_variables.html#magic-variables-and-how-to-access-information-about-other-hosts](http://docs.ansible.com/ansible/playbooks_variables.html#magic-variables-and-how-to-access-information-about-other-hosts))).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 没有太多的魔术变量，你可以在文档中找到列表（[http://docs.ansible.com/ansible/playbooks_variables.html#magic-variables-and-how-to-access-information-about-other-hosts](http://docs.ansible.com/ansible/playbooks_variables.html#magic-variables-and-how-to-access-information-about-other-hosts)）。
- en: 'We have declared variables in an inventory file in the previous section:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节的清单文件中声明了变量：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To use the variables in the inventory file instead of declaring them in the
    playbook, let''s add the group variables for `[nexus_by_name]` in the host file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在清单文件中使用变量而不是在playbook中声明它们，让我们在主机文件中为`[nexus_by_name]`添加组变量：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, modify the playbook to match what we can see here in `cisco_2.yml`, to
    reference the variables:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改playbook以匹配我们在`cisco_2.yml`中看到的内容，以引用变量：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice that in this example, we are referring to the `nexus_by_name` group in
    the inventory file, the `ansible_host` host variable, and the `username` and `password`
    group variables. This is a good way of hiding the username and password in a write-protected
    file and publish the playbook without the fear of exposing your sensitive data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个例子中，我们在清单文件中引用了`nexus_by_name`组，`ansible_host`主机变量和`username`和`password`组变量。这是一个很好的方法，可以将用户名和密码隐藏在受保护的文件中，并发布playbook而不担心暴露敏感数据。
- en: To see more examples of variables, check out the Ansible documentation ([http://docs.ansible.com/ansible/playbooks_variables.html](http://docs.ansible.com/ansible/playbooks_variables.html)).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看更多变量示例，请查看Ansible文档（[http://docs.ansible.com/ansible/playbooks_variables.html](http://docs.ansible.com/ansible/playbooks_variables.html)）。
- en: 'To access complex variable data that''s provided in a nested data structure,
    you can use two different notations. Noted in the `nxos_snmp_contact` task, we
    registered the output in a variable and displayed it using the debug module. You
    will see something like the following during playbook execution:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问提供在嵌套数据结构中的复杂变量数据，您可以使用两种不同的表示法。在`nxos_snmp_contact`任务中，我们在一个变量中注册了输出，并使用debug模块显示它。在playbook执行期间，您将看到类似以下的内容：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In order to access the nested data, we can use the following notation, as specified
    in `cisco_3.yml`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问嵌套数据，我们可以使用`cisco_3.yml`中指定的以下表示法：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You will receive just the value indicated:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您将只收到指定的值：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Lastly, we mentioned variables can also be stored in a separate file. To see
    how we can use variables in a role or included file, we should get a few more
    examples under our belt, because they are a bit complicated to start with. We
    will see more examples of roles in [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml),
    *The Python Automation Framework – Beyond Basics*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提到变量也可以存储在单独的文件中。为了了解如何在角色或包含的文件中使用变量，我们应该再多举几个例子，因为它们起步有点复杂。我们将在[第5章](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml)中看到更多角色的例子，《Python自动化框架-进阶》。
- en: Templates with Jinja2
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jinja2模板
- en: In the previous section, we used variables with the Jinja2 syntax of `{{ variable
    }}`. While you can do a lot of complex things in Jinja2, luckily, we only need
    some of the basic things to get started.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们使用了Jinja2语法`{{ variable }}`的变量。虽然您可以在Jinja2中做很多复杂的事情，但幸运的是，我们只需要一些基本的东西来开始。
- en: Jinja2 ([http://jinja.pocoo.org/](http://jinja.pocoo.org/)) is a full-featured,
    powerful template engine that originated in the Python community. It is widely
    used in Python web frameworks such as Django and Flask.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2 ([http://jinja.pocoo.org/](http://jinja.pocoo.org/))是一个功能齐全、强大的模板引擎，起源于Python社区。它在Python
    web框架中广泛使用，如Django和Flask。
- en: 'For now, it is enough to just keep in mind that Ansible utilizes Jinja2 as
    the template engine. We will revisit the topics of Jinja2 filters, tests, and
    lookups as the situations call for them. You can find more information on the
    Ansible Jinja2 template here: [http://docs.ansible.com/ansible/playbooks_templating.html](http://docs.ansible.com/ansible/playbooks_templating.html).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只需记住Ansible使用Jinja2作为模板引擎即可。根据情况，我们将重新讨论Jinja2过滤器、测试和查找。您可以在这里找到有关Ansible
    Jinja2模板的更多信息：[http://docs.ansible.com/ansible/playbooks_templating.html](http://docs.ansible.com/ansible/playbooks_templating.html)。
- en: Ansible networking modules
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible网络模块
- en: 'Ansible was originally made for managing nodes with full operating systems
    such as Linux and Windows before it was extended to support network equipment.
    You may have already noticed the subtle differences in playbooks that we have
    used so far for network devices, such as the lines of `gather_facts: false` and
    `connection: local`; we will take a closer look at the differences in the following
    sections.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'Ansible最初是用于管理完整操作系统的节点，如Linux和Windows，然后扩展到支持网络设备。您可能已经注意到我们迄今为止为网络设备使用的playbook中微妙的差异，比如`gather_facts:
    false`和`connection: local`；我们将在接下来的章节中更仔细地研究这些差异。'
- en: Local connections and facts
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地连接和事实
- en: Ansible modules are Python code that's executed on the remote host by default.
    Because of the fact that most network equipment does not expose Python directly,
    or they simply do not contain Python, we are almost always executing the playbook
    locally. This means that the playbook is interpreted locally first and commands
    or configurations are pushed out later on as needed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible模块是默认在远程主机上执行的Python代码。由于大多数网络设备通常不直接暴露Python，或者它们根本不包含Python，我们几乎总是在本地执行playbook。这意味着playbook首先在本地解释，然后根据需要推送命令或配置。
- en: Recall that the remote host facts were gathered via the setup module, which
    was added by default. Since we are executing the playbook locally, the setup module
    will gather the facts on the localhost instead of the remote host. This is certainly
    not needed, therefore when the connection is set to local, we can reduce this
    unnecessary step by setting the fact gathering to false.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，远程主机的事实是通过默认添加的setup模块收集的。由于我们正在本地执行playbook，因此setup模块将在本地主机而不是远程主机上收集事实。这显然是不需要的，因此当连接设置为本地时，我们可以通过将事实收集设置为false来减少这个不必要的步骤。
- en: Because network modules are executed locally, for those modules that offer a
    backup option, the files are backed up locally on the control node as well.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因为网络模块是在本地执行的，对于那些提供备份选项的模块，文件也会在控制节点上本地备份。
- en: One of the most important changes in Ansible 2.5 was the introduction of different
    communication protocols ([https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#multiple-communication-protocols](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#multiple-communication-protocols)).
    The connection method now includes `network_cli`, `netconf`, `httpapi`, and `local`.
    If the network device uses CLI over SSH, you indicate the connection method as
    `network_cli` in one of the device variables. However, due to the fact that this
    is a relatively recent change, you might still see the connection stated as local
    in many of the existing playbooks.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 2.5中最重要的变化之一是引入了不同的通信协议（[https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#multiple-communication-protocols](https://docs.ansible.com/ansible/latest/network/getting_started/network_differences.html#multiple-communication-protocols)）。连接方法现在包括`network_cli`、`netconf`、`httpapi`和`local`。如果网络设备使用SSH的CLI，您可以在其中一个设备变量中将连接方法指定为`network_cli`。然而，由于这是一个相对较新的更改，您可能仍然会在许多现有的playbook中看到连接状态为本地。
- en: Provider arguments
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供者参数
- en: As we have seen from [Chapter 2](d1720d17-6ae3-4886-89e3-f9ded2c88706.xhtml),
    *Low-Level Network Device Interactions,* and [Chapter 3](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml),
    *APIs and Intent-Driven Networking*, network equipment can be connected via both
    SSH or API, depending on the platform and software release. All core networking
    modules implement a `provider` argument, which is a collection of arguments used
    to define how to connect to the network device. Some modules only support `cli`
    while some support other values, for example, Arista EAPI and Cisco NXAPI. This
    is where Ansible's "let the vendor shine" philosophy is demonstrated. The module
    will have documentation on which transport method they support.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从[第2章](d1720d17-6ae3-4886-89e3-f9ded2c88706.xhtml)和[第3章](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml)中所看到的，*低级网络设备交互*和*API和意图驱动的网络*，网络设备可以通过SSH或API连接，这取决于平台和软件版本。所有核心网络模块都实现了`provider`参数，这是一组用于定义如何连接到网络设备的参数。一些模块只支持`cli`，而一些支持其他值，例如Arista
    EAPI和Cisco NXAPI。这就是Ansible“让供应商发光”的理念所体现的地方。模块将有关于它们支持哪种传输方法的文档。
- en: Starting with Ansible 2.5, the recommended way to specify the transport method
    is by using the `connection` variable. You will start to see the provider parameter
    being gradually phased out from future Ansible releases. Using the `ios_command`
    module as an example, [https://docs.ansible.com/ansible/latest/modules/ios_command_module.html#ios-command-module](https://docs.ansible.com/ansible/latest/modules/ios_command_module.html#ios-command-module),
    the provider parameter still works, but is being labeled as deprecated. We will
    see an example of this later in this chapter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从Ansible 2.5开始，指定传输方法的推荐方式是使用`connection`变量。您将开始看到提供程序参数逐渐在未来的Ansible版本中被淘汰。例如，使用`ios_command`模块作为示例，[https://docs.ansible.com/ansible/latest/modules/ios_command_module.html#ios-command-module](https://docs.ansible.com/ansible/latest/modules/ios_command_module.html#ios-command-module)，提供程序参数仍然有效，但被标记为已弃用。我们将在本章后面看到一个例子。
- en: 'Some of the basic arguments supported by the `provider` transport are as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`provider`传输支持的一些基本参数如下：'
- en: '`host`: This defines the remote host'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`：定义远程主机'
- en: '`port`: This defines the port to connect to'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`：定义连接的端口'
- en: '`username`: This is the username to be authenticated'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username`：要进行身份验证的用户名'
- en: '`password`: This is the password to be authenticated'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password`：要进行身份验证的密码'
- en: '`transport`: This is the type of transport for the connection'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transport`：连接的传输类型'
- en: '`authorize`: This enables privilege escalation for devices that require it'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authorize`：这允许特权升级，适用于需要特权的设备'
- en: '`auth_pass`: This defines the privilege escalation password'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth_pass`：定义特权升级密码'
- en: As you can see, not all arguments need to be specified. For example, for our
    previous playbooks, our user is always at the admin privilege when logged in,
    therefore we do not need to specify the `authorize` or the `auth_pass` arguments.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，并非所有参数都需要指定。例如，对于我们之前的playbook，我们的用户在登录时始终处于管理员特权，因此我们不需要指定`authorize`或`auth_pass`参数。
- en: 'These arguments are just variables, so they follow the same rules for variable
    precedence. For example, if I change `cisco_3.yml` to `cisco_4.yml` and observe
    the following precedence:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数只是变量，因此它们遵循相同的变量优先规则。例如，如果我将`cisco_3.yml`更改为`cisco_4.yml`并观察以下优先顺序：
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The username and password defined on the task level will override the username
    and password at the playbook level. I will receive the following error when trying
    to connect because the user does not exist on the device:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务级别定义的用户名和密码将覆盖playbook级别的用户名和密码。当尝试连接时，如果用户在设备上不存在，我将收到以下错误：
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The Ansible Cisco example
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible Cisco示例
- en: Cisco's support in Ansible is categorized by the operating systems IOS, IOS-XR,
    and NX-OS. We have already seen a number of NX-OS examples, so in this section
    let's try to manage IOS-based devices.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible中的Cisco支持按操作系统IOS、IOS-XR和NX-OS进行分类。我们已经看到了许多NX-OS的例子，所以在这一部分让我们尝试管理基于IOS的设备。
- en: 'Our host file will consist of two hosts, `R1` and `R2`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主机文件将包括两个主机，`R1`和`R2`：
- en: '[PRE24]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Our playbook, `cisco_5.yml`, will use the `ios_command` module to execute arbitrary
    `show commands`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的playbook，`cisco_5.yml`，将使用`ios_command`模块来执行任意的`show commands`：
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The result is what we would expect as the `show version` and `show run` output:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是我们期望的`show version`和`show run`输出：
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'I wanted to point out a few things illustrated by this example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我想指出这个例子所说明的一些事情：
- en: The playbook between NXOS and IOS is largely identical
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NXOS和IOS之间的playbook基本相同
- en: The syntax `nxos_snmp_contact` and `ios_command` modules follow the same pattern,
    with the only difference being the argument for the modules
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nxos_snmp_contact`和`ios_command`模块的语法遵循相同的模式，唯一的区别是模块的参数'
- en: The IOS version of the devices are pretty old with no understanding of API,
    but the modules still have the same look and feel
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备的IOS版本非常古老，不理解API，但模块仍然具有相同的外观和感觉
- en: As you can see from the preceding example, once we have the basic syntax down
    for the playbooks, the subtle difference relies on the different modules for the
    task we would like to perform.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从前面的例子中所看到的，一旦我们掌握了playbook的基本语法，微妙的差异在于我们想要执行的任务的不同模块。
- en: Ansible 2.5 connection example
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 2.5连接示例
- en: We have briefly talked about the addition of network connection changes in Ansible
    playbooks, starting with version 2.5\. Along with the changes, Ansible also released
    a network best practices document, [https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html](https://docs.ansible.com/ansible/latest/network/user_guide/network_best_practices_2.5.html).
    Let's build an example based on the best practices guide. For our topology, we
    will reuse the topology in [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml),
    *Low-Level Network Device Interactions*, with two IOSv devices. Since there are
    multiple files involved in this example, the files are grouped into a subdirectory
    named `ansible_2-5_example`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要讨论了Ansible playbook中网络连接更改的添加，从版本2.5开始。随着这些变化，Ansible还发布了一个网络最佳实践文档。让我们根据最佳实践指南构建一个例子。对于我们的拓扑，我们将重用[第2章](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml)中的拓扑，其中有两个IOSv设备。由于这个例子涉及多个文件，这些文件被分组到一个名为`ansible_2-5_example`的子目录中。
- en: 'Our inventory file is reduced to the group and the name of the hosts:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的清单文件减少到组和主机的名称：
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We have created a `host_vars` directory with two files. Each corresponds to
    the name specified in the inventory file:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`host_vars`目录，其中包含两个文件。每个文件对应清单文件中指定的名称：
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The variable file for the hosts contains what was previously included in the
    CLI variable. The additional variable of `ansible_connection` specifies `network_cli`
    as the transport:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 主机的变量文件包含了之前包含在CLI变量中的内容。`ansible_connection`的额外变量指定了`network_cli`作为传输方式：
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Our playbook will use the `ios_config` module with the `backup` option enabled.
    Notice the use of the `when` condition in this example so that if there are other
    hosts with a different operating system, this task will not be applied:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的playbook将使用`ios_config`模块，并启用`backup`选项。请注意，在这个例子中使用了`when`条件，以便如果有其他操作系统的主机，这个任务将不会被应用：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When the playbook is run, a new backup folder will be created with the configuration
    backed up for each of the hosts:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当playbook运行时，将为每个主机创建一个新的备份文件夹，其中包含备份的配置：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This example illustrates the `network_connection` variable and the recommended
    structure based on network best practices. We will look at offloading variables
    into the `host_vars` directory and conditionals in [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml),
    *The Python Automation Framework – Beyond Basics*. This structure can also be
    used for the Juniper and Arista examples in this chapter. For the different devices,
    we will just use different values for `network_connection`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了`network_connection`变量和基于网络最佳实践的推荐结构。我们将在[第5章](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml)中将变量转移到`host_vars`目录中，并使用条件语句。这种结构也可以用于本章中的Juniper和Arista示例。对于不同的设备，我们只需为`network_connection`使用不同的值。
- en: The Ansible Juniper example
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible Juniper示例
- en: 'The Ansible Juniper module requires the Juniper PyEZ package and NETCONF. If
    you have been following the API example in [Chapter 3](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml),
    *APIs and Intent-Driven Networking*, you are good to go. If not, refer back to
    that section for installation instructions as well as some test script to make
    sure PyEZ works. The Python package called `jxmlease` is also required:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Juniper模块需要Juniper PyEZ包和NETCONF。如果你一直在关注[第3章](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml)中的API示例，你就可以开始了。如果没有，请参考该部分以获取安装说明，以及一些测试脚本来确保PyEZ正常工作。还需要Python包`jxmlease`：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the host file, we will specify the device and connection variables:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机文件中，我们将指定设备和连接变量：
- en: '[PRE33]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In our Juniper playbook, we will use the `junos_facts` module to gather basic
    facts for the device. This module is equivalent to the setup module and will come
    in handy if we need to take action depending on the returned value. Note the different
    value of transport and port in the example here:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Juniper playbook中，我们将使用`junos_facts`模块来收集设备的基本信息。这个模块相当于setup模块，如果我们需要根据返回的值采取行动，它会很方便。请注意这里的传输和端口的不同值：
- en: '[PRE34]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When executed, you will receive this output from the `Juniper` device:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，你会从`Juniper`设备收到这个输出：
- en: '[PRE35]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The Ansible Arista example
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible Arista示例
- en: The final playbook example we will look at will be the Arista command module.
    At this point, we are quite familiar with our playbook syntax and structure. The
    Arista device can be configured to use transport using `cli` or `eapi`, so, in
    this example, we will use `cli`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一下最终的playbook示例，即Arista命令模块。此时，我们对playbook的语法和结构已经非常熟悉。Arista设备可以配置为使用`cli`或`eapi`进行传输，因此在这个例子中，我们将使用`cli`。
- en: 'This is the host file:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主机文件：
- en: '[PRE36]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The playbook is also similar to what we have seen previously:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: playbook也与我们之前看到的类似：
- en: '[PRE37]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output will show the standard output as we would expect from the command
    line:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示标准输出，就像我们从命令行预期的那样：
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a grand tour of the open source automation framework
    Ansible. Unlike Pexpect-based and API-driven network automation scripts, Ansible
    provides a higher layer of abstraction called the playbook to automate our network
    devices.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对开源自动化框架Ansible进行了全面介绍。与基于Pexpect和API驱动的网络自动化脚本不同，Ansible提供了一个更高层的抽象，称为playbook，用于自动化我们的网络设备。
- en: Ansible was originally constructed to manage servers and was later extended
    to network devices; therefore we took a look at a server example. Then, we compared
    and contrasted the differences when it came to network management playbooks. Later,
    we looked at the example playbooks for Cisco IOS, Juniper JUNOS, and Arista EOS
    devices. We also looked at the best practices recommended by Ansible if you are
    using Ansible version 2.5 and later.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible最初是用来管理服务器的，后来扩展到网络设备；因此我们看了一个服务器的例子。然后，我们比较和对比了网络管理playbook的不同之处。之后，我们看了Cisco
    IOS、Juniper JUNOS和Arista EOS设备的示例playbook。我们还看了Ansible推荐的最佳实践，如果你使用的是Ansible 2.5及更高版本。
- en: In [Chapter 5](96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml), *The Python Automation
    Framework – Beyond Basics*, we will leverage the knowledge we gained in this chapter
    and start to look at some of the more advanced features of Ansible.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章]（96b9ad57-2f08-4f0d-9b94-1abec5c55770.xhtml）中，《Python自动化框架-超越基础知识》，我们将利用本章所学的知识，开始了解Ansible的一些更高级的特性。
