["```py\n@pytest.mark.slow\ndef test_long_computation():\n    ...\n```", "```py\n@pytest.mark.timeout(10, method=\"thread\")\ndef test_topology_sort():\n    ...\n```", "```py\n@pytest.mark.slow\n@pytest.mark.timeout(10, method=\"thread\")\ndef test_topology_sort():\n    ...\n```", "```py\ntimeout10 = pytest.mark.timeout(10, method=\"thread\")\n\n@timeout10\ndef test_topology_sort():\n    ...\n\n@timeout10\ndef test_remove_duplicate_points():\n    ...\n```", "```py\nfrom mylib.testing import timeout10\n\n@timeout10\ndef test_topology_sort():\n    ...\n\n@timeout10\ndef test_remove_duplicate_points():\n    ...\n```", "```py\n\u03bb pytest -m slow\n```", "```py\n\u03bb pytest -m \"slow and not serial\"\n```", "```py\n\u03bb pytest -m \"smoke\"\n...\n\u03bb pytest -m \"not smoke\"\n```", "```py\n\u03bb pytest -m \"smoke\"\n...\n\u03bb pytest -m \"unittest\"\n...\n\u03bb pytest -m \"integration\"\n...\n\u03bb pytest -m \"not smoke and not unittest and not integration\"\n```", "```py\n@pytest.mark.timeout(10)\nclass TestCore:\n\n    def test_simple_simulation(self):\n        ...\n\n    def test_compute_tracers(self):\n        ...\n```", "```py\nclass TestCore:\n\n @pytest.mark.timeout(10)\n    def test_simple_simulation(self):\n        ...\n\n    @pytest.mark.timeout(10)\n    def test_compute_tracers(self):\n        ...\n```", "```py\n@pytest.mark.slow\n@pytest.mark.timeout(10)\nclass TestCore:\n\n    def test_simple_simulation(self):\n        ...\n\n    def test_compute_tracers(self):\n        ...\n```", "```py\nimport pytest\n\npytestmark = pytest.mark.timeout(10)\n\nclass TestCore:\n\n    def test_simple_simulation(self):\n        ...\n\ndef test_compute_tracers():\n    ...\n```", "```py\nimport pytest\n\n@pytest.mark.timeout(10)\nclass TestCore:\n\n    def test_simple_simulation(self):\n        ...\n\n@pytest.mark.timeout(10)\ndef test_compute_tracers():\n    ...\n```", "```py\nimport pytest\n\npytestmark = [pytest.mark.slow, pytest.mark.timeout(10)]\n```", "```py\n\u03bb pytest -m \"smoke\"\n...\n\u03bb pytest -m \"unittest\"\n...\n\u03bb pytest -m \"integration\"\n...\n\u03bb pytest -m \"not smoke and not unittest and not integration\"\n```", "```py\n@pytest.mark.smoek\ndef test_simulation_setup():\n    ...\n```", "```py\n[pytest]\nmarkers =\n    slow\n    serial\n    smoke: quick tests that cover a good portion of the code\n    unittest: unit tests for basic functionality\n    integration: cover to cover functionality testing    \n```", "```py\n\u03bb pytest --markers\n@pytest.mark.slow:\n\n@pytest.mark.serial:\n\n@pytest.mark.smoke: quick tests that cover a good portion of the code\n\n@pytest.mark.unittest: unit tests for basic functionality\n\n@pytest.mark.integration: cover to cover functionality testing\n\n...\n```", "```py\n\u03bb pytest --strict tests\\test_wrong_mark.py\n...\ncollected 0 items / 1 errors\n\n============================== ERRORS ===============================\n_____________ ERROR collecting tests/test_wrong_mark.py _____________\ntests\\test_wrong_mark.py:4: in <module>\n @pytest.mark.smoek\n..\\..\\.env36\\lib\\site-packages\\_pytest\\mark\\structures.py:311: in __getattr__\n self._check(name)\n..\\..\\.env36\\lib\\site-packages\\_pytest\\mark\\structures.py:327: in _check\n raise AttributeError(\"%r not a registered marker\" % (name,))\nE AttributeError: 'smoek' not a registered marker\n!!!!!!!!!!!!!! Interrupted: 1 errors during collection !!!!!!!!!!!!!!\n====================== 1 error in 0.09 seconds ======================\n```", "```py\n[pytest]\naddopts = --strict\nmarkers =\n    slow\n    serial\n    smoke: quick tests that cover a good portion of the code\n    unittest: unit tests for basic functionality\n    integration: cover to cover functionality testing\n```", "```py\nimport sys\nimport pytest\n\n@pytest.mark.skipif(\n sys.platform.startswith(\"win\"),\n reason=\"fork not available on Windows\",\n)\ndef test_spawn_server_using_fork():\n    ...\n```", "```py\n tests\\test_skipif.py s                                        [100%]\n====================== short test summary info ======================\nSKIP [1] tests\\test_skipif.py:6: fork not available on Windows\n===================== 1 skipped in 0.02 seconds =====================\n```", "```py\nimport os\nimport pytest\n\n@pytest.mark.skipif(\n not hasattr(os, 'fork'), reason=\"os.fork not available\"\n)\ndef test_spawn_server_using_fork2():\n    ...\n```", "```py\n@pytest.mark.skipif(condition, *, reason=None)\n```", "```py\ndef test_shaders():\n    initialize_graphics()\n    if not supports_shaders():\n pytest.skip(\"shades not supported in this driver\") # rest of the test code ... \n```", "```py\ndef test_tracers_as_arrays_manual():\n    try:\n        import numpy\n    except ImportError:\n        pytest.skip(\"requires numpy\")\n    ...\n```", "```py\ndef test_tracers_as_arrays():\n    numpy = pytest.importorskip(\"numpy\")\n    ...\n```", "```py\ndef test_tracers_as_arrays_114():\n    numpy = pytest.importorskip(\"numpy\", minversion=\"1.14\")\n    ...\n```", "```py\n@pytest.mark.xfail\ndef test_simulation_34():\n    ...\n```", "```py\n@pytest.mark.xfail(condition=None, *, reason=None, raises=None, run=True, strict=False)\n```", "```py\n    @pytest.mark.xfail(\n     sys.platform.startswith(\"win\"), \n        reason=\"flaky on Windows #42\", strict=False\n    )\n    def test_login_dialog():\n        ...\n    ```", "```py\n    @pytest.mark.xfail(\n        sys.platform.startswith(\"win\"), \n        reason=\"flaky on Windows #42\", strict=False\n    )\n    def test_login_dialog():\n        ...\n    ```", "```py\n    @pytest.mark.xfail(raises=NotImplementedError,\n                       reason='will be implemented in #987')\n    def test_credential_check():\n        check_credentials('Hawkwood') # not implemented yet\n    ```", "```py\n    @pytest.mark.xfail(\n        run=False, reason=\"undefined particles cause a crash #625\"\n    )\n    def test_undefined_particle_collision_crash():\n        collide(Particle(), Particle())\n    ```", "```py\n[pytest]\nxfail_strict = True\n```", "```py\ndef test_particle_splitting():\n    initialize_physics()\n    import numpy\n    if numpy.__version__ < \"1.13\":\n        pytest.xfail(\"split computation fails with numpy < 1.13\")\n    ...\n```", "```py\ndef test_formula_parsing():\n    tokenizer = FormulaTokenizer()\n    formula = Formula.from_string(\"C0 * x + 10\", tokenizer)\n    assert formula.eval(x=1.0, C0=2.0) == pytest.approx(12.0)\n```", "```py\ndef test_formula_parsing():\n    tokenizer = FormulaTokenizer()\n    formula = Formula.from_string(\"C0 * x + 10\", tokenizer)\n    assert formula.eval(x=1.0, C0=2.0) == pytest.approx(12.0)\n\n    formula = Formula.from_string(\"sin(x) + 2 * cos(x)\", tokenizer)\n assert formula.eval(x=0.7) == pytest.approx(2.1739021)\n\n    formula = Formula.from_string(\"log(x) + 3\", tokenizer)\n    assert formula.eval(x=2.71828182846) == pytest.approx(4.0)\n```", "```py\ndef test_formula_linear():\n    tokenizer = FormulaTokenizer()\n    formula = Formula.from_string(\"C0 * x + 10\", tokenizer)\n    assert formula.eval(x=1.0, C0=2.0) == pytest.approx(12.0)\n\ndef test_formula_sin_cos():\n    tokenizer = FormulaTokenizer()\n    formula = Formula.from_string(\"sin(x) + 2 * cos(x)\", tokenizer)\n    assert formula.eval(x=0.7) == pytest.approx(2.1739021)\n\ndef test_formula_log():\n    tokenizer = FormulaTokenizer()\n    formula = Formula.from_string(\"log(x) + 3\", tokenizer)\n    assert formula.eval(x=2.71828182846) == pytest.approx(4.0)\n```", "```py\ndef test_formula_parsing2():\n    values = [\n (\"C0 * x + 10\", dict(x=1.0, C0=2.0), 12.0),\n (\"sin(x) + 2 * cos(x)\", dict(x=0.7), 2.1739021),\n (\"log(x) + 3\", dict(x=2.71828182846), 4.0),\n ]\n    tokenizer = FormulaTokenizer()\n    for formula, inputs, result in values:\n        formula = Formula.from_string(formula, tokenizer)\n        assert formula.eval(**inputs) == pytest.approx(result)\n```", "```py\n@pytest.mark.parametrize(\n \"formula, inputs, result\",\n [\n (\"C0 * x + 10\", dict(x=1.0, C0=2.0), 12.0),\n (\"sin(x) + 2 * cos(x)\", dict(x=0.7), 2.1739021),\n (\"log(x) + 3\", dict(x=2.71828182846), 4.0),\n ],\n)\ndef test_formula_parsing(formula, inputs, result):\n    tokenizer = FormulaTokenizer()\n    formula = Formula.from_string(formula, tokenizer)\n    assert formula.eval(**inputs) == pytest.approx(result)\n```", "```py\n======================== test session starts ========================\n...\ncollected 8 items / 5 deselected\n\ntest_formula.py::test_formula[C0 * x + 10-inputs0-12.0]\ntest_formula.py::test_formula[sin(x) + 2 * cos(x)-inputs1-2.1739021]\ntest_formula.py::test_formula[log(x) + 3-inputs2-4.0] \n============== 3 passed, 5 deselected in 0.05 seconds ===============\n```", "```py\n@pytest.mark.parametrize(\n    \"formula, inputs, result\",\n    [\n        ...\n        (\"log(x) + 3\", dict(x=2.71828182846), 4.0),\n        pytest.param(\n \"hypot(x, y)\", dict(x=3, y=4), 5.0,\n marks=pytest.mark.xfail(reason=\"not implemented: #102\"),\n ),\n    ],\n)\n```", "```py\npytest.param(*values, **kw)\n```", "```py\n@pytest.mark.parametrize(\n    \"formula, inputs, result\",\n    [\n        (\"C0 * x + 10\", dict(x=1.0, C0=2.0), 12.0),\n        (\"sin(x) + 2 * cos(x)\", dict(x=0.7), 2.1739021),\n    ]\n)\n```", "```py\n@pytest.mark.parametrize(\n    \"formula, inputs, result\",\n    [\n        pytest.param(\"C0 * x + 10\", dict(x=1.0, C0=2.0), 12.0),\n        pytest.param(\"sin(x) + 2 * cos(x)\", dict(x=0.7), 2.1739021),\n    ]\n)\n```", "```py\n@pytest.mark.parametrize(\n    \"formula, inputs, result\",\n    [\n        (\"x + 3\", dict(x=1.0), 4.0,),\n        (\"x - 1\", dict(x=6.0), 5.0,),\n    ],\n)\ndef test_formula_simple(formula, inputs, result):\n    ...\n```", "```py\n======================== test session starts ========================\n...\ntests/test_formula.py::test_formula_simple[x + 3-inputs0-4.0]\ntests/test_formula.py::test_formula_simple[x - 1-inputs1-5.0]\n```", "```py\n@pytest.mark.parametrize(\n    \"formula, inputs, result\",\n    [\n        pytest.param(\"x + 3\", dict(x=1.0), 4.0, id='add'),\n        pytest.param(\"x - 1\", dict(x=6.0), 5.0, id='sub'),\n    ],\n)\ndef test_formula_simple(formula, inputs, result):\n    ...\n```", "```py\n======================== test session starts ========================\n...\ntests/test_formula.py::test_formula_simple[add]\ntests/test_formula.py::test_formula_simple[sub]\n```", "```py\n\u03bb pytest -k \"x + 3-inputs0-4.0\"\n```", "```py\n\u03bb pytest -k \"add\"\n```", "```py\nclass JSONSerializer:\n\n    def serialize_quantity(self, quantity: Quantity) -> str:\n        ...\n\n    def deserialize_quantity(self, data: str) -> Quantity:\n        ...\n\n    def serialize_pipe(self, pipe: Pipe) -> str:\n        ...\n\n    def deserialize_pipe(self, data: str) -> Pipe:\n        ...\n```", "```py\nclass Test:\n\n    def test_quantity(self):\n        serializer = JSONSerializer()\n        quantity = Quantity(10, \"m\")\n        data = serializer.serialize(quantity)\n        new_quantity = serializer.deserialize(data)\n        assert new_quantity == quantity\n\n    def test_pipe(self):\n        serializer = JSONSerializer()\n        pipe = Pipe(\n            length=Quantity(1000, \"m\"), diameter=Quantity(35, \"cm\")\n        )\n        data = serializer.serialize(pipe)\n        new_pipe = serializer.deserialize(data)\n        assert new_pipe == pipe\n```", "```py\nclass Test:\n\n    def test_quantity(self):\n        for serializer in [\n JSONSerializer(), XMLSerializer(), YAMLSerializer()\n ]:\n            quantity = Quantity(10, \"m\")\n            data = serializer.serialize(quantity)\n            new_quantity = serializer.deserialize(data)\n            assert new_quantity == quantity\n\n    def test_pipe(self):\n        for serializer in [\n JSONSerializer(), XMLSerializer(), YAMLSerializer()\n ]:\n            pipe = Pipe(\n                length=Quantity(1000, \"m\"),\n                diameter=Quantity(35, \"cm\"),\n            )\n            data = serializer.serialize(pipe)\n            new_pipe = serializer.deserialize(data)\n            assert new_pipe == pipe\n```", "```py\n@pytest.mark.parametrize(\n \"serializer_class\",\n [JSONSerializer, XMLSerializer, YAMLSerializer],\n)\nclass Test:\n\n    def test_quantity(self, serializer_class):\n        serializer = serializer_class()\n        quantity = Quantity(10, \"m\")\n        data = serializer.serialize(quantity)\n        new_quantity = serializer.deserialize(data)\n        assert new_quantity == quantity\n\n    def test_pipe(self, serializer_class):\n        serializer = serializer_class()\n        pipe = Pipe(\n            length=Quantity(1000, \"m\"), diameter=Quantity(35, \"cm\")\n        )\n        data = serializer.serialize(pipe)\n        new_pipe = serializer.deserialize(data)\n        assert new_pipe == pipe\n```", "```py\ntest_parametrization.py::Test::test_quantity[JSONSerializer] PASSED\ntest_parametrization.py::Test::test_quantity[XMLSerializer] PASSED\ntest_parametrization.py::Test::test_quantity[YAMLSerializer] PASSED\ntest_parametrization.py::Test::test_pipe[JSONSerializer] PASSED\ntest_parametrization.py::Test::test_pipe[XMLSerializer] PASSED\ntest_parametrization.py::Test::test_pipe[YAMLSerializer] PASSED\n```"]