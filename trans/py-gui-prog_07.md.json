["```py\nThe program must:\n\n* Provide a UI for reading, updating, and appending data to the CSV file\n* ...\n```", "```py\nThe program does not need to:\n\n* Allow deletion of data.\n```", "```py\n    def get_all_records(self):\n        if not os.path.exists(self.filename):\n            return []\n```", "```py\n        with open(self.filename, 'r') as fh:\n            csvreader = csv.DictReader(fh)\n            records = list(csvreader)\n```", "```py\n        csvreader = csv.DictReader(fh)\n        missing_fields = (set(self.fields.keys()) -    \n                          set(csvreader.fieldnames))\n        if len(missing_fields) > 0:\n            raise Exception(\n                \"File is missing fields: {}\"\n                .format(', '.join(missing_fields))\n            )\n        else:\n            records = list(csvreader)\n```", "```py\n        trues = ('true', 'yes', '1')\n```", "```py\n        bool_fields = [\n            key for key, meta\n            in self.fields.items()\n            if meta['type'] == FT.boolean]\n```", "```py\n        for record in records:\n            for key in bool_fields:\n                record[key] = record[key].lower() in trues\n```", "```py\n        return records\n```", "```py\n    def get_record(self, rownum):\n        return self.get_all_records()[rownum]\n```", "```py\n    def save_record(self, data, rownum=None):\n        \"\"\"Save a dict of data to the CSV file\"\"\"\n```", "```py\n        if rownum is not None:\n            # This is an update, new code here\n        else:\n            # Old code goes here, indented one more level\n```", "```py\n            records = self.get_all_records()\n            records[rownum] = data\n            with open(self.filename, 'w') as fh:\n                csvwriter = csv.DictWriter(fh,\n                    fieldnames=self.fields.keys())\n                csvwriter.writeheader()\n                csvwriter.writerows(records)\n```", "```py\nimport tkinter as tk\nfrom tkinter import ttk\nfrom pathlib import Path\n\nroot = tk.Tk()\n# Code will go here\n\nroot.mainloop()\n```", "```py\npaths = Path('.').glob('**/*')\n```", "```py\ntv = ttk.Treeview(root, columns=['size', 'modified'], \n                  selectmode='None')\n```", "```py\ntv.heading('#0', text='Name')\ntv.heading('size', text='Size', anchor='center')\ntv.heading('modified', text='Modified', anchor='e')\n```", "```py\ntv.pack(expand=True, fill='both')\n```", "```py\ntv.column('#0', stretch=True)\ntv.column('size', width=200)\n```", "```py\nmytreeview.insert(parent, 'end', iid='item1',\n          text='My Item 1', values=['12', '42'])\n```", "```py\nfor path in paths:\n    meta = path.stat()\n    parent = str(path.parent)\n    if parent == '.':\n        parent = ''\n```", "```py\n    tv.insert(parent, 'end', iid=str(path),\n        text=str(path.name), values=[meta.st_size, meta.st_mtime])\n```", "```py\ndef sort(tv, col):\n    itemlist = list(tv.get_children(''))\n    itemlist.sort(key=lambda x: tv.set(x, col))\n    for index, iid in enumerate(itemlist):\n        tv.move(iid, tv.parent(iid), index)\n```", "```py\ntv.heading('#0', text='Name', command=lambda: sort(tv, '#0'))\ntv.heading('size', text='Size', anchor='center',\n           command=lambda: sort(tv, 'size'))\ntv.heading('modified', text='Modified', anchor='e',\n           command=lambda: sort(tv, 'modified'))\n```", "```py\nclass RecordList(tk.Frame):\n    \"\"\"Display for CSV file contents\"\"\"\n```", "```py\n    column_defs = {\n        '#0': {'label': 'Row', 'anchor': tk.W},\n        'Date': {'label': 'Date', 'width': 150, 'stretch': True},\n        'Time': {'label': 'Time'},\n        'Lab': {'label': 'Lab', 'width': 40},\n        'Plot': {'label': 'Plot', 'width': 80}\n        }\n    default_width = 100\n    default_minwidth = 10\n    default_anchor = tk.CENTER\n```", "```py\n    def __init__(self, parent, callbacks, *args, **kwargs):\n        super().__init__(parent, *args, **kwargs)\n        self.callbacks = callbacks\n```", "```py\n        self.treeview = ttk.Treeview(self,\n            columns=list(self.column_defs.keys())[1:],\n            selectmode='browse')\n```", "```py\n        self.columnconfigure(0, weight=1)\n        self.rowconfigure(0, weight=1)\n        self.treeview.grid(row=0, column=0, sticky='NSEW')\n```", "```py\n        for name, definition in self.column_defs.items():\n```", "```py\n            label = definition.get('label', '')\n            anchor = definition.get('anchor', self.default_anchor)\n            minwidth = definition.get(\n                'minwidth', self.default_minwidth)\n            width = definition.get('width', self.default_width)\n            stretch = definition.get('stretch', False)\n```", "```py\n            self.treeview.heading(name, text=label, anchor=anchor)\n            self.treeview.column(name, anchor=anchor,\n                minwidth=minwidth, width=width, stretch=stretch)\n```", "```py\n        self.scrollbar = ttk.Scrollbar(self,\n            orient=tk.VERTICAL, command=self.treeview.yview)\n```", "```py\n        self.treeview.configure(yscrollcommand=self.scrollbar.set)\n```", "```py\n        self.scrollbar.grid(row=0, column=1, sticky='NSW')\n```", "```py\n    def populate(self, rows):\n        \"\"\"Clear the treeview & write the supplied data rows to it.\"\"\"\n```", "```py\n        for row in self.treeview.get_children():\n            self.treeview.delete(row)\n```", "```py\n        valuekeys = list(self.column_defs.keys())[1:]\n        for rownum, rowdata in enumerate(rows):\n            values = [rowdata[key] for key in valuekeys]\n            self.treeview.insert('', 'end', iid=str(rownum),\n                                 text=str(rownum), values=values)\n```", "```py\n        if len(rows) > 0:\n            self.treeview.focus_set()\n            self.treeview.selection_set(0)\n            self.treeview.focus('0')\n```", "```py\n        self.treeview.bind('<<TreeviewOpen>>', self.on_open_record)\n```", "```py\n    def on_open_record(self, *args):\n        selected_id = self.treeview.selection()[0]\n        self.callbacks['on_open_record'](selected_id)\n```", "```py\n    def __init__(self, parent, fields, \n                 settings, callbacks, *args, **kwargs):\n        self.callbacks = callbacks\n```", "```py\n        self.current_record = None\n```", "```py\n        self.record_label = ttk.Label()\n        self.record_label.grid(row=0, column=0)\n```", "```py\n        self.savebutton = ttk.Button(self,\n            text=\"Save\", command=self.callbacks[\"on_save\"])\n        self.savebutton.grid(sticky=\"e\", row=5, padx=10)\n```", "```py\n    def load_record(self, rownum, data=None):\n```", "```py\n        self.current_record = rownum\n```", "```py\n        if rownum is None:\n            self.reset()\n            self.record_label.config(text='New Record')\n```", "```py\n        else:\n            self.record_label.config(text='Record #{}'.format(rownum))\n            for key, widget in self.inputs.items():\n                self.inputs[key].set(data.get(key, ''))\n                try:\n                    widget.input.trigger_focusout_validation()\n                except AttributeError:\n                    pass\n```", "```py\n        go_menu = tk.Menu(self, tearoff=False)\n        go_menu.add_command(label=\"Record List\",\n                         command=callbacks['show_recordlist'])\n        go_menu.add_command(label=\"New Record\",\n                         command=callbacks['new_record'])\n        self.add_cascade(label='Go', menu=go_menu)\n```", "```py\n        self.recordlist = v.RecordList(self, self.callbacks)\n        self.recordlist.grid(row=1, padx=10, sticky='NSEW')\n```", "```py\n        self.recordform.grid(row=1, padx=10, sticky='NSEW')\n```", "```py\n        self.filename = tk.StringVar(value=default_filename)\n        self.data_model = m.CSVModel(filename=self.filename.get())\n```", "```py\n        if filename:\n            self.filename.set(filename)\n            self.data_model = m.CSVModel(filename=self.filename.get())\n```", "```py\n    def populate_recordlist(self):\n```", "```py\n        rows = self.data_model.get_all_records()\n        self.recordlist.populate(rows)\n```", "```py\n        try:\n            rows = self.data_model.get_all_records()\n        except Exception as e:\n            messagebox.showerror(title='Error',\n                message='Problem reading file',\n                detail=str(e))\n        else:\n            self.recordlist.populate(rows)\n```", "```py\n        self.recordlist = v.RecordList(self, self.callbacks)\n        self.recordlist.grid(row=1, padx=10, sticky='NSEW')\n        self.populate_recordlist()\n```", "```py\n        if filename:\n            self.filename.set(filename)\n            self.data_model = m.CSVModel(filename=self.filename.get())\n            self.populate_recordlist()\n```", "```py\n    def show_recordlist(self):\n        \"\"\"Show the recordform\"\"\"\n        self.recordlist.tkraise()\n```", "```py\n        self.callbacks = {\n             'show_recordlist': self.show_recordlist,\n             ...\n```", "```py\n    def open_record(self, rownum=None):\n```", "```py\n        if rownum is None:\n            record = None\n```", "```py\n        else:\n            rownum = int(rownum)\n            record = self.data_model.get_record(rownum)\n```", "```py\n        try:\n            record = self.data_model.get_record(rownum)\n        except Exception as e:\n            messagebox.showerror(title='Error',\n                message='Problem reading file',\n                detail=str(e))\n            return\n```", "```py\n        self.recordform.load_record(rownum, record)\n```", "```py\n        self.recordform.tkraise()\n```", "```py\n        self.callbacks = {\n            'new_record': self.open_record,\n            'on_open_record': self.open_record,\n            ...\n```", "```py\n        self.callbacks = {\n            ...\n            'on_save': self.on_save\n        }\n```", "```py\n        data = self.recordform.get()\n        rownum = self.recordform.current_record\n        try:\n            self.data_model.save_record(data, rownum)\n```", "```py\n        except IndexError as e:\n            messagebox.showerror(title='Error',\n                message='Invalid row specified', detail=str(e))\n            self.status.set('Tried to update invalid row')\n```", "```py\n        except Exception as e:\n            messagebox.showerror(title='Error',\n                message='Problem saving record', detail=str(e))\n            self.status.set('Problem saving record')\n```", "```py\n    else:\n        self.records_saved += 1\n        self.status.set(\n            \"{} records saved this session\".format(self.records_saved)\n        )\n        self.recordform.reset()\n```", "```py\n            self.populate_recordlist()\n```", "```py\n            if self.recordform.current_record is None:\n                self.recordform.reset()\n```", "```py\n        self.savebutton = ttk.Button(self, text=\"Save\",\n                                     command=self.on_save)\n        self.savebutton.grid(sticky=\"e\", row=2, padx=10)\n```", "```py\n        self.statusbar.grid(sticky=\"we\", row=2, padx=10)\n```"]