- en: 11\. More Calculus with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.使用Python进行更多微积分
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn how to calculate the length of a curve, given
    its equation. You'll be introduced to partial derivatives in three dimensions
    and how to use them to calculate the area of a surface. Following in the footsteps
    of the mathematicians of the Middle Ages, you'll use an infinite series to calculate
    constants such as pi and determine the interval of convergence of a series. Like
    the mathematicians and machine learning engineers of the modern day, you'll learn
    how to find the minimum point on a surface using partial derivatives. By the end
    of this chapter, you will be able to use calculus to solve a variety of mathematical
    problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何根据其方程计算曲线的长度。您将学习如何在三维空间中使用偏导数来计算表面积。跟随中世纪的数学家的脚步，您将使用无限级数来计算诸如π之类的常数，并确定级数的收敛区间。像现代数学家和机器学习工程师一样，您将学习如何使用偏导数找到表面上的最小点。在本章结束时，您将能够使用微积分解决各种数学问题。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'In the previous chapter, we learned how to calculate derivatives and integrals.
    Now, we''re going to use those tools to find the lengths of curves and spirals
    and extend this reasoning to three dimensions to find the area of a complicated
    surface. We''ll also look at a common tool that''s used in calculus, the infinite
    series, which is used to calculate important constants and approximate complicated
    functions. Finally, we''ll look at an important idea in machine learning: finding
    the minimum point on a curve. When you use a neural network, you create a kind
    of "error function" and work hard to find the point on the surface that gives
    the minimum error. We''ll create our own kind of gradient descent function to
    keep traveling downward until we''re at the bottom of the surface.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何计算导数和积分。现在，我们将使用这些工具来找到曲线和螺旋线的长度，并将这种推理扩展到三维空间，以找到复杂表面的面积。我们还将研究微积分中常用的工具，即无限级数，用于计算重要常数和近似复杂函数。最后，我们将研究机器学习中的一个重要概念：找到曲线上的最小点。当您使用神经网络时，您会创建一种“误差函数”，并努力找到曲面上使误差最小的点。我们将创建自己的梯度下降函数，不断向下移动，直到到达曲面的底部。
- en: Length of a Curve
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 曲线的长度
- en: 'A major use of derivatives and integrals is finding the length of a curve.
    There''s a formula for this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 导数和积分的一个主要用途是找到曲线的长度。有一个公式：
- en: '![Figure 11.1: Formula to calculate the length of a curve'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1：计算曲线长度的公式'
- en: '](image/B15968_11_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_01.jpg)'
- en: 'Figure 11.1: Formula to calculate the length of a curve'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：计算曲线长度的公式
- en: 'The preceding formula contains an integral *and* a derivative. To find the
    length of a curve, we''ll need both our derivative and integral functions. Copy
    and paste them into your code if you don''t have them yet:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的公式包含积分和导数。要找到曲线的长度，我们需要我们的导数和积分函数。如果您还没有它们，请将它们复制并粘贴到您的代码中：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s the Python version of the formula:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是公式的Python版本：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice we simply converted the math notation into Python code. We defined the
    `g` function inside the `f` function. The `g` function is everything under the
    square root in the formula. Then, we use our `trap_integral` function to find
    the accumulated value of the `g` function between `a` and `b`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只是将数学符号转换为Python代码。我们在`f`函数内定义了`g`函数。`g`函数是公式中平方根下的所有内容。然后，我们使用我们的`trap_integral`函数来找到`a`和`b`之间`g`函数的累积值。
- en: 'Let''s check that using a curve we know the length of, such as the line *y
    = 2x*. We can calculate the distance of the curve''s line between *x = (0,0)*
    and *x = (2,4)* using the Pythagorean theorem with 2√5 or 4.47 units:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们知道长度的曲线，比如线*y = 2x*。我们可以使用勾股定理计算曲线的长度，*x = (0,0)*和*x = (2,4)*之间的距离，结果为2√5或4.47个单位：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code prints out 4.47... as the output.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码输出了4.47...作为输出。
- en: 'But when we try to check an actual curve that we know the length of, such as
    a semicircle, we run into a problem. We know the length of the curve of the following
    equation because it''s half the circumference of a circle with radius 1\. So,
    we should get π or 3.1415... as the output:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们尝试检查我们知道长度的实际曲线，比如半圆时，我们遇到了问题。我们知道以下方程的长度，因为它是半径为1的圆的一半周长。所以，我们应该得到π或3.1415...作为输出：
- en: '![Figure 11.2: Formula to calculate the length of a semicircle'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2：计算半圆长度的公式'
- en: '](image/B15968_11_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_02.jpg)'
- en: 'Figure 11.2: Formula to calculate the length of a semicircle'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：计算半圆长度的公式
- en: 'Let''s change `f(x)` to the equation for the preceding semicircle:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把`f(x)`改成前面半圆的方程：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When you execute the preceding code, you get an error. The last line of the
    error message (the first line I read) says the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行前面的代码时，会出现错误。错误消息的最后一行（我读到的第一行）说：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This happens because the derivative of the semicircle at -1 and at 1, it is
    infinite. The tangent lines at those points are vertical, as shown in the following
    graph:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为半圆在-1和1处的导数是无穷大。这些点处的切线是垂直的，如下图所示：
- en: '![Figure 11.3: Vertical tangent lines, with an infinite slope'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3：垂直切线，斜率无穷大'
- en: '](image/B15968_11_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_03.jpg)'
- en: 'Figure 11.3: Vertical tangent lines, with an infinite slope'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：垂直切线，斜率无穷大
- en: 'So, already, this method runs into a problem. Let''s see if it''ll find the
    length of a regular polynomial, such as the one shown in the following graph:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这种方法已经遇到了问题。让我们看看它是否能找到正常多项式的长度，比如下图所示的多项式：
- en: '![Figure 11.4: A complicated polynomial'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4：一个复杂的多项式'
- en: '](image/B15968_11_04.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_04.jpg)'
- en: 'Figure 11.4: A complicated polynomial'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：一个复杂的多项式
- en: 'This is a polynomial of degree 5, meaning the highest exponent of *x* is *5*.
    The equation for the curve is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个5次多项式，意味着*x*的最高指数是*5*。曲线的方程如下：
- en: '![Figure 11.5: Equation of the curve'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.5：曲线的方程'
- en: '](image/B15968_11_05.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_05.jpg)'
- en: 'Figure 11.5: Equation of the curve'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：曲线方程
- en: Complicated as it may seem, nowhere on the curve is the derivative infinite,
    as it was in *Figure 11.3*. That means we can use our curve length function on
    it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来很复杂，但在曲线上没有地方导数是无穷大的，就像*图11.3*中那样。这意味着我们可以在它上面使用我们的曲线长度函数。
- en: 'Here''s the code for the polynomial:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是多项式的代码：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And the length of the curve is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线的长度如下：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can use Wolfram Alpha to solve this by putting in *length of curve y = ...
    from –2 to 1* and checking whether it''s a good approximation. But using Python,
    there''s a more straightforward way of calculating the length of a curve that
    doesn''t run into the problem we run into with derivatives. In fact, it doesn''t
    even use derivatives or integrals. You can simply find the length of a tiny bit
    of the curve using the Pythagorean theorem and add up all those tiny bits, as
    shown in the following diagram. We know the width, and we''re interested in the
    hypotenuse of the tiny right triangle. We can calculate the height, which is the
    difference between the function at *x* and the function at *x*, plus the width:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Wolfram Alpha来解决这个问题，方法是输入*length of curve y = ... from –2 to 1*，然后检查它是否是一个很好的近似值。但是使用Python，有一种更直接的方法来计算曲线的长度，它不会遇到我们在导数中遇到的问题。事实上，它甚至不使用导数或积分。你可以简单地使用毕达哥拉斯定理找到曲线的微小部分的长度，并累加所有这些微小部分，如下图所示。我们知道宽度，我们对微小直角三角形的斜边感兴趣。我们可以计算高度，即*x*处的函数和*x*处的函数之间的差，再加上宽度：
- en: '![Figure 11.6: Finding the length of a tiny part of a curve'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.6：找到曲线的微小部分的长度'
- en: '](image/B15968_11_06.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_06.jpg)'
- en: 'Figure 11.6: Finding the length of a tiny part of a curve'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：找到曲线的微小部分的长度
- en: 'The hypotenuse of the right triangle shown in the preceding diagram is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面图表中显示的直角三角形的斜边如下：
- en: '![](image/B15968_11_07.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B15968_11_07.jpg)'
- en: 'Figure 11.7: Formula to calculate the hypotenuse of the right-angled triangle'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：计算直角三角形斜边的公式
- en: 'All we have to do is go through the interval from `a` to `b`, counting up all
    those lengths. Here''s how to do that in Python:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所要做的就是遍历从`a`到`b`的区间，计算所有这些长度。以下是如何在Python中实现的：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This should remind you of the integral program: create a running sum, then
    loop over each *slice* of the curve, adding the areas (in this case, the arc lengths)
    as you go. Finally, return the final value of the running sum.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该让你想起积分程序：创建一个运行总和，然后循环遍历曲线的每个*片段*，在此过程中添加面积（在本例中是弧长）。最后，返回运行总和的最终值。
- en: 'Here is the curve length of the interval we''re interested in:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们感兴趣的区间的曲线长度：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This gives us the length of the curve as `9.614118659973549`. This is even closer
    than the previous version, and with much less fuss. Now, it's your turn to do
    the same in the following exercise.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了曲线的长度为`9.614118659973549`。这甚至比以前的版本更接近，而且麻烦要少得多。现在轮到你在以下练习中做同样的事情了。
- en: 'Exercise 11.01: Finding the Length of a Curve'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.01：找到曲线的长度
- en: 'In this exercise, you''re provided with the following equation of a curve.
    Using this equation, determine the length of the curve between two given *x* values:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将得到以下曲线方程。使用这个方程，确定两个给定*x*值之间的曲线长度：
- en: '![Figure 11.8: Equation of the curve'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.8：曲线方程'
- en: '](image/B15968_11_08.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_08.jpg)'
- en: 'Figure 11.8: Equation of the curve'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：曲线方程
- en: These values will be from *x = -1* to *x = 1*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值将从*x = -1*到*x = 1*。
- en: 'Perform the following steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'First, we need to create a `circle` function with the preceding equation:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要使用前述方程创建一个`circle`函数：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It's the semicircle again. This time, our `curve_length2` function will have
    no problem adding up the tiny slices of the arc.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是一个半圆。这次，我们的`curve_length2`函数将毫无问题地累加弧线的微小切片。
- en: 'Now, we''ll run the `curve_length2` function (which we''ve already coded) on
    that curve to add up all the tiny segments, as we did previously:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在该曲线上运行`curve_length2`函数（我们已经编码过了），以累加所有微小段，就像以前一样：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we print the output of the function, measuring from *x = -1* to *x = 1*:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们打印函数的输出，从*x = -1*到*x = 1*进行测量：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There's no error message this time. We get a good approximation of half the
    circumference of a circle with radius 1, which we know is π.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这次没有错误消息。我们得到了一个很好的近似值，即半径为1的圆的半周长，我们知道是π。
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3gkI5Qi](https://packt.live/3gkI5Qi).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3gkI5Qi](https://packt.live/3gkI5Qi)。
- en: You can also run this example online at [https://packt.live/3eVpSbz](https://packt.live/3eVpSbz).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3eVpSbz](https://packt.live/3eVpSbz)上在线运行这个例子。
- en: 'Exercise 11.02: Finding the Length of a Sine Wave'
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.02：找到正弦波的长度
- en: 'A very important and useful function in math and science is the sine wave.
    It makes one cycle between 0 and 2π, as shown in the following graph:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 数学和科学中一个非常重要和有用的函数是正弦波。它在0和2π之间完成一个周期，如下图所示：
- en: '![Figure 11.9: One cycle of the sine wave'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.9：正弦波的一个周期'
- en: '](image/B15968_11_09.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_09.jpg)'
- en: 'Figure 11.9: One cycle of the sine wave'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9：正弦波的一个周期
- en: It's easy to measure its wavelength (2π) and its amplitude (how far up and down
    it goes, that it, 1 unit), but how long is the actual curve? In this exercise,
    we'll find the length of the sine wave from 0 to 2π.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 测量它的波长（2π）和振幅（它上下移动的距离，即1个单位）很容易，但实际曲线有多长呢？在这个练习中，我们将找到从0到2π的正弦波的长度。
- en: 'Perform the following steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'We''re going to use our `curve_length2` function again, but now we have to
    import our `sin` and `pi` functions from the `math` module:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将再次使用我们的`curve_length2`函数，但现在我们必须从`math`模块导入我们的`sin`和`pi`函数：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''ve already written our `curve_length2` function, which will add up all
    the segments of the curve. We just need to tell it the function to use, and the
    beginning and ending *x* values:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经编写了`curve_length2`函数，它将累加曲线的所有部分。我们只需要告诉它要使用的函数，以及开始和结束的*x*值：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, using the `curve_length2` function, it becomes very easy to
    calculate the length of a sine wave.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用`curve_length2`函数，计算正弦波的长度变得非常容易。
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3dUy3nk](https://packt.live/3dUy3nk).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3dUy3nk](https://packt.live/3dUy3nk)。
- en: You can also run this example online at [https://packt.live/2VFy2xd](https://packt.live/2VFy2xd).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2VFy2xd](https://packt.live/2VFy2xd)上在线运行此示例。
- en: Length of a Spiral
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 螺旋的长度
- en: 'What about spirals, which are expressed in polar coordinates, where *r*, the
    distance from the origin, is a function of the theta (θ) angle that''s made with
    the *x* axis? We can''t use our *x* and *y* functions to measure the spiral shown
    in the following diagram:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，极坐标中的螺旋怎么样，其中*r*，即与原点的距离，是与与*x*轴成角度（θ）的函数？我们不能使用我们的*x*和*y*函数来测量以下图中显示的螺旋：
- en: '![Figure 11.10: An Archimedean spiral'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.10：阿基米德螺旋'
- en: '](image/B15968_11_10.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_10.jpg)'
- en: 'Figure 11.10: An Archimedean spiral'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10：阿基米德螺旋
- en: 'What we have in the preceding diagram is a spiral that starts at (5,0) and
    makes 7.5 turns, ending at (11,π). The formula for that curve is *r(θ) = 5 + 0.12892θ*.
    The number of radians turned is 7.5 times 2π, which is 15π. We''re going to use
    the same idea as in the previous section: we''re going to find the length of the
    straight line from *r(θ)* to *r(θ+step)* for some tiny step in the central angle,
    as shown in the following diagram:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们有一个从（5,0）开始，绕中心旋转7.5圈，最终到达（11,π）的螺旋。该曲线的公式为*r(θ) = 5 + 0.12892θ*。旋转的弧度数是7.5乘以2π，即15π。我们将使用与前一节相同的思路：我们将找到从*r(θ)*到*r(θ+step)*的直线长度，step是中心角的一个小步长，如下图所示：
- en: '![Figure 11.11: Approximating the length of a tiny part of the curve'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.11：近似曲线的一小部分的长度'
- en: '](image/B15968_11_11.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_11.jpg)'
- en: 'Figure 11.11: Approximating the length of a tiny part of the curve'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11：近似曲线的一小部分的长度
- en: 'The opposite side to the central angle of the triangle shown in the preceding
    diagram is just like the slice in our integration problems or the hypotenuse of
    the triangle in our previous length of curve program. This time, it isn''t a right
    triangle, so we can''t use the hypotenuse. But for this problem, there''s a formula
    called the law of cosines. In triangle ABC, the length of the side opposite angle,
    C, is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 三角形中央角的对边就像我们积分问题中的切片或前一个曲线长度程序中三角形的斜边一样。这次，它不是直角三角形，所以我们不能使用斜边。但是对于这个问题，有一个称为余弦定律的公式。在三角形ABC中，角C的对边长度如下：
- en: '![Figure 11.12: Law of cosines'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.12：余弦定律'
- en: '](image/B15968_11_12.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_12.jpg)'
- en: 'Figure 11.12: Law of cosines'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12：余弦定律
- en: 'All we need to do is put that into a function, like this one:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要做的就是将其放入一个函数中，就像这样：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we just need to write a function that will start at the starting angle
    and take tiny steps around the curve, measuring the sides opposite each tiny angle
    until it gets to the ending angle:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需要编写一个函数，从起始角度开始，沿着曲线采取微小步骤，测量每个微小角度的对边，直到达到结束角度：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our function is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数如下：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, all we have to do is execute our spiral function on that spiral, from 0
    to 15π:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们所要做的就是在该螺旋上执行我们的螺旋函数，从0到15π：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the length of the spiral is `378.8146271783955`. In the next
    exercise, we'll look at how to find the length of a polar spiral curve.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，螺旋的长度为`378.8146271783955`。在下一个练习中，我们将看看如何找到极坐标螺旋曲线的长度。
- en: 'Exercise 11.03: Finding the Length of the Polar Spiral Curve'
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.03：找到极坐标螺旋曲线的长度
- en: In this exercise, you will find the length of the polar spiral curve, which
    starts at (3,0), makes 12 complete revolutions around the center, and ends at
    (16,0).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将找到极坐标螺旋曲线的长度，该曲线从（3,0）开始，围绕中心旋转12次，最终到达（16,0）。
- en: 'Perform the following steps to find the required length:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以找到所需的长度：
- en: 'We don''t know the formula for this spiral, but we do know that the radius
    increases 13 units (from 3 to 16) in 12 revolutions. This means that for every
    increase of 2π in the angle, θ, the radius increases 13/12 units. So, we divide
    13/12 by 2π. The increase in radius can be expressed as follows:![Figure 11.13:
    Formula to calculate the increase in radius'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不知道这个螺旋的公式，但我们知道半径在12个旋转中增加了13个单位（从3到16）。这意味着对于角度θ的每个2π增加，半径增加13/12个单位。因此，我们将13/12除以2π。半径的增加可以表示如下：![图11.13：计算半径增加的公式
- en: '](image/B15968_11_13.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_13.jpg)'
- en: 'Figure 11.13: Formula to calculate the increase in radius'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13：计算半径增加的公式
- en: 'We can express that in Python this way:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用Python这样表示：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can check to make sure *r(0) = 3* and *r(24π) = 16* this way:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以检查以确保*r(0) = 3*和*r(24π) = 16*：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we simply put that in our spiral function:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需将其放入我们的螺旋函数中：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this exercise, we easily found the length of this spiral curve, that is,
    `716.3778471288748`, just by knowing the start and end values of the curve and
    the number of revolutions it made around the center.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们仅通过知道曲线的起始值和结束值以及它围绕中心旋转的次数，就轻松找到了这个螺旋曲线的长度，即`716.3778471288748`。
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YT70EH](https://packt.live/2YT70EH).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2YT70EH](https://packt.live/2YT70EH)。
- en: You can also run this example online at [https://packt.live/2YV4wFT](https://packt.live/2YV4wFT).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2YV4wFT](https://packt.live/2YV4wFT)上在线运行此示例。
- en: 'Exercise 11.04: Finding the Length of Insulation in a Roll'
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.04：找到卷中的绝缘长度
- en: 'You have been asked to find the (approximate) length of insulation that remains
    in the roll shown in the following picture:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您被要求找到所示卷中绝缘的（近似）长度：
- en: '![Figure 11.14: Measuring rolled up materials using calculus'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.14：使用微积分测量卷起的材料'
- en: '](image/B15968_11_14.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_14.jpg)'
- en: 'Figure 11.14: Measuring rolled up materials using calculus'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14：使用微积分测量卷起的材料
- en: You measure the roll and find that the center is an empty circle whose diameter
    is 4 inches (so *r(0) = 2*). The outer diameter of the roll is 26 inches. You
    count the layers from the center to the outside and estimate that the spiral takes
    23 and a half turns, so *r(2π*23.5)= 26/2 = 13*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您测量卷起并发现中心是一个直径为4英寸的空圆（因此*r(0) = 2*）。卷的外径为26英寸。您从中心到外部计算层数，并估计螺旋需要23个半转，因此*r(2π*23.5)=
    26/2 = 13*。
- en: 'Perform the following steps to calculate the length:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤计算长度：
- en: 'Calculate the equation using the preceding data:![Figure 11.15: Formula to
    calculate radius'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面的数据计算方程：![图11.15：计算半径的公式
- en: '](image/B15968_11_15.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_15.jpg)'
- en: 'Figure 11.15: Formula to calculate radius'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15：计算半径的公式
- en: 'Here''s what the graph of the spiral looks like:![Figure 11.16: A graph of
    the roll of insulation'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是螺旋图的样子：![图11.16：绝缘卷的图表
- en: '](image/B15968_11_16.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_16.jpg)'
- en: 'Figure 11.16: A graph of the roll of insulation'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16：绝缘卷的图表
- en: 'Now, it''s not hard to change our `r` code to this spiral:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将我们的`r`代码更改为这个螺旋并不难：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we can run our spiral function on this function from *0* to *2*π*23.5*:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在这个函数上运行我们的螺旋函数，从*0*到*2*π*23.5*：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 1,107 inches is just over 92 feet of insulation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 1,107英寸只是超过92英尺的绝缘。
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2VE9YKZ](https://packt.live/2VE9YKZ).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2VE9YKZ](https://packt.live/2VE9YKZ)。
- en: You can also run this example online at [https://packt.live/31D43tG](https://packt.live/31D43tG).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/31D43tG](https://packt.live/31D43tG)上在线运行此示例。
- en: 'Exercise 11.05: Finding the Length of an Archimedean Spiral'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.05：找到阿基米德螺旋的长度
- en: 'For this exercise, you have been given the equation of an Archimedean spiral.
    Find the length of the spiral from *θ=0* to *θ=2π*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，您已经得到了阿基米德螺旋的方程。找到从*θ=0*到*θ=2π*的螺旋长度：
- en: '![Figure 11.17: Equation of an Archimedean spiral'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.17：阿基米德螺旋的方程'
- en: '](image/B15968_11_17.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_17.jpg)'
- en: 'Figure 11.17: Equation of an Archimedean spiral'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17：阿基米德螺旋的方程
- en: Note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This works on both logarithmic spirals as well as Archimedean spirals.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于对数螺旋和阿基米德螺旋。
- en: 'Perform the following steps to find the length:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤找到长度：
- en: 'We simply redefine `r` with the exponential function:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需用指数函数重新定义`r`：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then. we run the spiral function from *0* to *2π*:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从*0*到*2π*运行螺旋函数：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The length of this spiral is `41.518256747758976`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个螺旋的长度是`41.518256747758976`。
- en: Note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2VEtjfo](https://packt.live/2VEtjfo).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2VEtjfo](https://packt.live/2VEtjfo)。
- en: You can also run this example online at [https://packt.live/2VHasQN](https://packt.live/2VHasQN).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2VHasQN](https://packt.live/2VHasQN)上在线运行此示例。
- en: Area of a Surface
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表面积
- en: Let's learn how to take this from two to three dimensions and calculate the
    area of a 3D surface. In *Chapter 10*, *Foundational Calculus with Python*, we
    learned how to calculate the area of a surface of revolution, but this is a surface
    where the third dimension, *z*, is a function of the values of *x* and *y*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何将这个从二维转换为三维，并计算3D表面的面积。在*第10章*，*使用Python进行基础微积分*中，我们学习了如何计算旋转表面的面积，但这是一个第三维度*z*是*x*和*y*的值的函数的表面。
- en: The Formulas
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公式
- en: 'The traditional, algebraic way to solve this analytically is given by a double
    integral over a surface:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的传统代数方法是通过对表面进行双重积分：
- en: '![Figure 11.18: Formula to calculate area of a surface'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.18：计算表面积的公式'
- en: '](image/B15968_11_18.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_18.jpg)'
- en: 'Figure 11.18: Formula to calculate area of a surface'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18：计算表面积的公式
- en: 'Here, *z = f(x,y)* or *(x,y,f(x,y))*. Those curly d''s are deltas, meaning
    we''ll be dealing with partial derivatives. Partial derivatives are derivatives
    but only with respect to one variable, even if the function is dependent on more
    than one variable. Here''s a function that returns the partial derivative of a
    function, `f`, with respect to a variable, `u`, at a specific point (`v,w`). Depending
    on which variable we''re interested in, *x* or *y*, the function will take a tiny
    step in that direction and calculate the derivative, as we''ve done already:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*z = f(x,y)*或*(x,y,f(x,y))*。那些花括号d是增量，意味着我们将处理偏导数。偏导数是导数，但只针对一个变量，即使函数依赖于多个变量。这是一个返回函数`f`在特定点(`v,w`)处相对于变量`u`的偏导数的函数。根据我们感兴趣的变量是*x*还是*y*，函数将朝着那个方向迈出微小的一步并计算导数，就像我们已经做过的那样：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There is a `try...except` block in the code in case a `ValueError` is thrown.
    This happens if the slope gets too big, as in a vertical line. If that happens,
    it'll ignore it and keep going.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中有一个`try...except`块，以防抛出`ValueError`。如果斜率太大，就像垂直线一样，就会发生这种情况。如果发生这种情况，它将忽略它并继续进行。
- en: 'Now, we''ll need a 3D vector and a `cross` function for the cross product in
    the area formula. The cross product gives the length of the vector perpendicular
    to both the given vectors, but also the area of the parallelogram that''s formed
    by the given vectors:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个3D向量和一个`cross`函数来计算面积公式中的叉积。叉积给出垂直于给定向量的向量的长度，但也给出由给定向量形成的平行四边形的面积。
- en: '![Figure 11.19: The cross product of two vectors'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.19：两个向量的叉积'
- en: '](image/B15968_11_19.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_19.jpg)'
- en: 'Figure 11.19: The cross product of two vectors'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19：两个向量的叉积
- en: 'If you know the angle between the vectors, you can use that to find the cross
    product:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道向量之间的角度，可以使用它来找到叉积：
- en: '![Figure 11.20: Formula to calculate cross product of two vectors'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.20：计算两个向量的叉积的公式'
- en: '](image/B15968_11_20.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_20.jpg)'
- en: 'Figure 11.20: Formula to calculate cross product of two vectors'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20：计算两个向量的叉积的公式
- en: 'If you don''t, as in our case, you can use 3D vectors to express the displacement
    of the vector in each direction, *x*, *y*, and *z*. For example, let''s say we
    have two vectors, *u = 2i + 3j + 4k* and *v = 5i + 6j + 7k*. They''re defined
    by their displacement in each of the three dimensions. The *i* part is the displacement
    in the *x* direction, the *j* part is the displacement in the *y* direction, and
    the *k* part is the displacement in the *z* direction. The good news is that there
    will be a few zeroes to simplify things. To cross two vectors, we can put them
    into a matrix and operate on them as the determinant of the following matrix:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不这样做，就像我们的情况一样，可以使用3D向量来表示向量在每个方向上的位移，*x*，*y*和*z*。例如，假设我们有两个向量，*u = 2i + 3j
    + 4k*和*v = 5i + 6j + 7k*。它们由它们在三个维度中的位移定义。*i*部分是*x*方向的位移，*j*部分是*y*方向的位移，*k*部分是*z*方向的位移。好消息是，会有一些零来简化事情。要交叉两个向量，我们可以将它们放入矩阵中，并对它们进行操作，如下矩阵的行列式：
- en: '![Figure 11.21: Calculating cross product of two vectors using matrix'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.21：使用矩阵计算两个向量的叉积'
- en: '](image/B15968_11_21.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_21.jpg)'
- en: 'Figure 11.21: Calculating cross product of two vectors using matrix'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21：使用矩阵计算两个向量的叉积
- en: 'We''ll write a function to perform that operation on two 3D vectors. All we''ll
    have to put in are the coefficients of *i*, *j*, and *k*. So, if *u = ai + bj
    + ck* and *v = di + ej + fk*, we''ll get the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个函数来执行两个3D向量的操作。我们需要放入的只是*i*，*j*和*k*的系数。因此，如果*u = ai + bj + ck*和*v = di
    + ej + fk*，我们将得到以下结果：
- en: '![Figure 11.22: Performing mathematical operations on 3D vectors'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.22：对3D向量执行数学运算'
- en: '](image/B15968_11_22.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_22.jpg)'
- en: 'Figure 11.22: Performing mathematical operations on 3D vectors'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.22：对3D向量执行数学运算
- en: 'Let''s use lists for the vectors, so *u = [a,b,c]* and *u[0] = a*, *u[1] =
    b* and *u[2] = c* for the coefficients:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用列表来表示向量，所以*u = [a,b,c]*和*u[0] = a*，*u[1] = b*和*u[2] = c*为系数：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We wrote a long docstring to make it clear what the function is used for, how
    to put values in, and what we''ll get as the output. Let''s check this to make
    sure we get the right output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个长的文档字符串，以清楚地说明函数的用途，如何放入值以及我们将得到什么输出。让我们检查一下，以确保我们得到正确的输出：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output is as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'That works. Now, we need to write a function to find the magnitude of a 3D
    vector, since that''s going to give us the area of the parallelogram. It''s just
    an extension of the Pythagorean theorem into three dimensions. So, the magnitude
    of vector *u* if *u = ai + bj + ck* is ![a](image/B15968_11_22a.png):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 可以了。现在，我们需要编写一个函数来找到3D向量的大小，因为这将给我们平行四边形的面积。这只是将勾股定理扩展到三维。因此，如果*u = ai + bj
    + ck*，则向量*u*的大小是![a](image/B15968_11_22a.png)：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here''s what the semicircle is going to look like, with its surface approximated
    by parallelograms. More parallelograms should mean a more accurate approximation:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是半圆的样子，其表面由平行四边形近似。更多的平行四边形应该意味着更准确的近似：
- en: '![Figure 11.23: Using more parallelograms'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.23：使用更多的平行四边形'
- en: '](image/B15968_11_23.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_23.jpg)'
- en: 'Figure 11.23: Using more parallelograms'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.23：使用更多的平行四边形
- en: 'Our area function is going to loop through all the *x* and *y* points in the
    grid, calculate the partial derivatives at each point, and use the cross product
    to find the area of the parallelogram at that point:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的面积函数将循环遍历网格中的所有*x*和*y*点，计算每个点的偏导数，并使用叉积来找到该点处平行四边形的面积：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'First, we set the running sum of the areas to 0\. Then, we calculate *dx* and
    *dy*, the tiny changes in *x* and *y*, as we divide the surface up into equal
    slices. The `try...except` block simply ignores (`pass`) the error that will arise
    if a partial derivative is infinite, when the slope of the line tangent to the
    sphere is vertical, as we saw in *Figure 11.3*. If there''s no error, it adds
    the area of the parallelogram that has been formed at that point by the partial
    derivatives. Now, we run the area function on the hemisphere using 1,000 points
    in each direction and get a pretty accurate approximation. We know half the surface
    area of a sphere of radius 1 is 2π, or 6.28:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将面积的运行总和设置为0。然后，我们计算*dx*和*dy*，*x*和*y*的微小变化，因为我们将表面分成相等的切片。`try...except`块只是忽略(`pass`)当切线的斜率是垂直的时候，会出现无限的偏导数的错误，就像我们在*图11.3*中看到的那样。如果没有错误，它将添加在该点由偏导数形成的平行四边形的面积。现在，我们使用1,000个点在每个方向上运行半球的面积函数，并得到一个相当准确的近似值。我们知道半径为1的球体的表面积的一半是2π，或6.28：
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, let's quickly perform an exercise based on this concept.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速进行一个基于这个概念的练习。
- en: 'Exercise 11.06: Finding the Area of a 3D Surface – Part 1'
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.06：寻找3D表面的面积-第1部分
- en: 'Now, let''s find the area of a complicated surface, which would be difficult
    to find using algebraic methods. Consider the surface for the following equation:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们找到一个复杂表面的面积，这将很难使用代数方法找到。考虑以下方程的表面：
- en: '![Figure 11.24: Equation of the surface'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.24：表面的方程'
- en: '](image/B15968_11_24.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_24.jpg)'
- en: 'Figure 11.24: Equation of the surface'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.24：表面的方程
- en: 'The surface is shown in the following image:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 表面显示在以下图像中：
- en: '![Figure 11.25: A complicated 3D surface'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.25：复杂的3D表面'
- en: '](image/B15968_11_25.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_25.jpg)'
- en: 'Figure 11.25: A complicated 3D surface'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.25：复杂的3D表面
- en: 'Perform the following steps to find the area:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以找到面积：
- en: 'Let''s put the function into our area program and see what we get:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将函数放入我们的面积程序中，看看我们得到什么：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Run the program to see the output:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序以查看输出：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Looking at the preceding code, we can clearly see how easy it is to find the
    area of even complicated surfaces in just a few lines of code using Python.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以清楚地看到，使用Python几行代码就可以轻松找到甚至复杂表面的面积有多容易。
- en: Note
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3gwd6kr](https://packt.live/3gwd6kr).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3gwd6kr](https://packt.live/3gwd6kr)。
- en: You can also run this example online at [https://packt.live/2ZpgwOQ](https://packt.live/2ZpgwOQ).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2ZpgwOQ](https://packt.live/2ZpgwOQ)上在线运行此示例。
- en: 'Exercise 11.07: Finding the Area of a 3D Surface – Part 2'
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.07：找到3D曲面的面积-第2部分
- en: Find the area of the surface ![a](image/B15968_11_25a.png).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 找到曲面的面积![a](image/B15968_11_25a.png)。
- en: 'Here''s how the surface looks:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是曲面的样子：
- en: '![Figure 11.26: Another 3D surface'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.26：另一个3D曲面'
- en: '](image/B15968_11_26.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_26.jpg)'
- en: 'Figure 11.26: Another 3D surface'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.26：另一个3D曲面
- en: 'Perform the following steps to find the area:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤找到面积：
- en: 'Define our surface function to return the expression:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们的曲面函数以返回表达式：
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Run the `surface` function to get the value:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`surface`函数以获得值：
- en: '[PRE43]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output is as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The area of this 3D surface is `99.80676808568984`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个3D曲面的面积是`99.80676808568984`。
- en: Note
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2VCaObq](https://packt.live/2VCaObq).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2VCaObq](https://packt.live/2VCaObq)。
- en: You can also run this example online at [https://packt.live/2NPXvQo](https://packt.live/2NPXvQo).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2NPXvQo](https://packt.live/2NPXvQo)上在线运行此示例。
- en: 'Exercise 11.08: Finding the Area of a Surface – Part 3'
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.08：找到曲面的面积-第3部分
- en: Find the area of the surface ![b](image/B15968_11_26a.png).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 找到曲面的面积![b](image/B15968_11_26a.png)。
- en: 'Here''s how the surface looks:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是曲面的样子：
- en: '![Figure 11.27: The surface of'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.27：曲面'
- en: '](image/B15968_11_27.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_27.jpg)'
- en: 'Figure 11.27: The surface of ![a](image/B15968_11_27a.png)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.27：曲面![a](image/B15968_11_27a.png)
- en: 'Perform the following steps to find the area:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤找到面积：
- en: 'Define our surface function to return the new expression:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们的曲面函数以返回新表达式：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Run the `surface` function:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`surface`函数：
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output is as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE47]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The area of this surface is `42.80527549685105`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个曲面的面积是`42.80527549685105`。
- en: Note
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3gwdLlV](https://packt.live/3gwdLlV).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3gwdLlV](https://packt.live/3gwdLlV)。
- en: You can also run this example online at [https://packt.live/3dUNWdt](https://packt.live/3dUNWdt).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3dUNWdt](https://packt.live/3dUNWdt)上在线运行此示例。
- en: Infinite Series
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限级数
- en: Mathematicians have often run into functions that are too complicated for them
    to solve or otherwise deal with, and approximations have always been an important
    component in doing math. For mathematicians trying to take derivatives and integrals
    algebraically, many expressions have no nice neat solutions, derivatives, integrals,
    and so on. In general, no differential equations that scientists come across in
    real life have algebraic solutions, so they have to use other methods. More on
    differential equations later, but there's an important family of approximations
    that use *easy* functions to approximate *hard* ones.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 数学家经常遇到对他们来说太复杂以至于无法解决或处理的函数，近似一直是数学中的重要组成部分。对于试图代数地进行导数和积分的数学家来说，许多表达式没有漂亮的解、导数、积分等。一般来说，科学家在现实生活中遇到的微分方程没有代数解，因此他们必须使用其他方法。稍后会详细介绍微分方程，但有一类重要的近似使用*简单*函数来近似*难*函数。
- en: Polynomial Functions
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多项式函数
- en: 'It''s easy to solve, differentiate, and integrate polynomial equations—ones
    such as *y = x*2 and even the following equation:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 解决多项式方程很容易，可以求导和积分，比如*y = x*2，甚至以下方程：
- en: '![Figure 11.28: A polynomial equation'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.28：多项式方程'
- en: '](image/B15968_11_28.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_28.jpg)'
- en: 'Figure 11.28: A polynomial equation'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.28：多项式方程
- en: 'The terms are all added (or subtracted) one after the other, and there are
    no trigonometric, logarithmic, or exponential functions involved to make things
    difficult. Here''s the formula for approximating a *hard* function with an *easy*
    polynomial:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 所有项都是一个接一个地添加（或相减），没有三角、对数或指数函数参与，使事情变得困难。以下是用*简单*多项式近似*难*函数的公式：
- en: '![Figure 11.29: The Taylor series'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.29：泰勒级数'
- en: '](image/B15968_11_29.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_29.jpg)'
- en: 'Figure 11.29: The Taylor series'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.29：泰勒级数
- en: 'This formula is named Taylor series: any function (which is derivable) can
    be approximated with a certain precision in a specific point using only polynomials
    with a certain page.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个公式被称为泰勒级数：任何函数（可导）都可以使用一定精度在特定点用一定页数的多项式来近似。
- en: Series
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 级数
- en: 'Mathematicians have a notation to represent adding together a bunch of numbers
    that follow a pattern:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 数学家有一种表示将一堆遵循某种模式的数字相加的符号：
- en: '![Figure 11.30: Formula for calculating series'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.30：计算级数的公式'
- en: '](image/B15968_11_30.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_30.jpg)'
- en: 'Figure 11.30: Formula for calculating series'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.30：计算级数的公式
- en: 'The big symbol that looks like an *E* is actually the Greek letter sigma, or
    *S*, which represents the sum of the numbers. The equation below the sigma is
    where the variable starts (in this case, 1) and above the sigma is the last integer
    value for *i* (in this case, 10). To the right of the sigma is an expression for
    what to do with the variable. In this case, we''re just adding *i*, the variable,
    as it goes from 1 to 10\. This is almost exactly how you''d write a list comprehension
    in Python. Here''s how:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像一个*E*的大符号实际上是希腊字母sigma，或者*S*，表示数字的总和。sigma下面的方程是变量从哪里开始（在这种情况下是1），sigma上面是*i*的最后一个整数值（在这种情况下是10）。在sigma右边是对变量的操作的表达式。在这种情况下，我们只是将*i*，变量，从1加到10。这几乎就是您在Python中编写列表推导式的方式。如下：
- en: '[PRE48]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The first term in the list comprehension is what you see in the sigma series
    expression—in this case, *i*. For example, the series for the sum of the squares
    of the integers up to *n* would be as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式中的第一个项是在sigma级数表达式中看到的内容-在这种情况下是*i*。例如，直到*n*的整数平方和的级数如下：
- en: '![Figure 11.31: Series for sum of squares of integers from 1 to n'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.31：1到n的整数平方和的级数'
- en: '](image/B15968_11_31.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_31.jpg)'
- en: 'Figure 11.31: Series for sum of squares of integers from 1 to n'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.31：1到n的整数平方和的级数
- en: 'In Python, we''d write it like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们会这样写：
- en: '[PRE49]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'An old but useful series is the arctangent series. It calculates the angle
    (in radians) that has the given tangent; for example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一个古老但有用的级数是arctangent级数。它计算具有给定正切的角度（以弧度表示）；例如：
- en: '![Figure 11.32: Equation of an arctangent series'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.32：arctangent级数的方程'
- en: '](image/B15968_11_32.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_32.jpg)'
- en: 'Figure 11.32: Equation of an arctangent series'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.32：arctangent级数的方程
- en: 'From the preceding equation, the equation for arctan will be as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前述方程，arctan的方程如下：
- en: '![Figure 11.33: Equation of an arctan'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.33：arctan的方程'
- en: '](image/B15968_11_33.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_33.jpg)'
- en: 'Figure 11.33: Equation of an arctan'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.33：arctan的方程
- en: 'The series is calculated by this pattern:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 该系列按照以下模式计算：
- en: '![Figure 11.34: Equation for series of arctan'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.34：arctan级数的方程'
- en: '](image/B15968_11_34.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_34.jpg)'
- en: 'Figure 11.34: Equation for series of arctan'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.34：arctan级数的方程
- en: 'Here is the sigma expression:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这是sigma表达式：
- en: '![Figure 11.35: A sigma expression'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.35：一个sigma表达式'
- en: '](image/B15968_11_35.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_35.jpg)'
- en: 'Figure 11.35: A sigma expression'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.35：一个sigma表达式
- en: 'By plugging in the tangent for *x*, we can calculate a close approximation
    to the angle:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通过插入*x*的正切，我们可以计算出角度的近似值：
- en: '![Figure 11.36: Substituting the value of x in the equation'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.36：将x的值代入方程'
- en: '](image/B15968_11_36.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_36.jpg)'
- en: 'Figure 11.36: Substituting the value of x in the equation'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.36：将x的值代入方程
- en: 'That''s quite a bit of calculation for a mathematician centuries ago, but here''s
    the Python equivalent. Notice how close the first part of the list comprehension
    is to the preceding sigma expression:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 对于几个世纪前的数学家来说，这是相当多的计算，但这是Python的等效代码。请注意，列表推导式的前半部分与前述sigma表达式非常接近：
- en: '[PRE50]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'So, after 10 terms, we get the following:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，经过10个项，我们得到了以下结果：
- en: '[PRE51]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is very close to ![a](image/B15968_11_36a.png).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常接近![a](image/B15968_11_36a.png)。
- en: Convergence
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收敛
- en: 'Mathematicians wanted to simplify the arctan series to easily calculate *π*
    using the fact that:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 数学家们希望简化arctan级数，以便使用以下事实轻松计算*π*：
- en: '![Figure 11.37: Trigonometric function of a tangent'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.37：正切的三角函数'
- en: '](image/B15968_11_37.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_37.jpg)'
- en: 'Figure 11.37: Trigonometric function of a tangent'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.37：正切的三角函数
- en: 'From the preceding equation, the equation for arctan will be as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前述方程，arctan的方程如下：
- en: '![Figure 11.38: Formula to calculate arctan'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.38：计算arctan的公式'
- en: '](image/B15968_11_38.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_38.jpg)'
- en: 'Figure 11.38: Formula to calculate arctan'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.38：计算arctan的公式
- en: 'They figured replacing *x* with *1* in the arctan series would make calculating
    *π* a walk in the park. Here are the first few terms:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 他们认为将*x*替换为arctan级数中的*1*会使计算*π*变得轻而易举。以下是前几个项：
- en: '![Figure 11.39: Substituting x = 1 in the arctan series'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.39：将x = 1代入arctan级数'
- en: '](image/B15968_11_39.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_39.jpg)'
- en: 'Figure 11.39: Substituting x = 1 in the arctan series'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.39：将x = 1代入arctan级数
- en: 'This expression gives the approximation for *pi*:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式给出了*π*的近似值：
- en: '![Figure 11.40: Equation to find the approximate value of pi'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.40：寻找π的近似值的方程'
- en: '](image/B15968_11_40.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_40.jpg)'
- en: 'Figure 11.40: Equation to find the approximate value of pi'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.40：寻找π的近似值的方程
- en: 'We just write the code for the part to the right of the sigma, add code for
    the range of *n*, and sum them up:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需编写sigma右侧的代码，添加*n*的范围代码，并将它们相加：
- en: '[PRE52]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can show the progress toward approximating *pi* in the output:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在输出中显示逼近*π*的进展：
- en: '[PRE53]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is not very close to *π*. How about skipping up to higher numbers of terms?
    Let''s change code for the loop:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这与*π*不太接近。跳过更高数量的项呢？让我们改变循环的代码：
- en: '[PRE54]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This is the output:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE55]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: After 1 million terms, it only gets us five correct decimal places. This series
    *converges* to (that is, gets very close to or *tends toward*) π/4 too slowly
    for any practical use. So, for centuries, mathematicians have looked for better
    and better series to approximate π.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 经过100万项计算，我们只得到了五位正确的小数。这个级数*收敛*到（即非常接近或*趋向于*）π/4，但速度太慢，无法实际使用。因此，几个世纪以来，数学家一直在寻找更好的级数来近似π。
- en: 'Exercise 11.09: Calculating 10 Correct Digits of π'
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.09：计算π的10个正确数字
- en: 'In 1706, English mathematician and astronomer John Machine used his improved
    series to calculate 100 decimal places of *pi*. Here''s the series:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在1706年，英国数学家和天文学家约翰·马钦使用他改进的级数计算了*π*的100位小数。以下是该级数：
- en: '![Figure 11.41: An arctan function'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.41：一个arctan函数'
- en: '](image/B15968_11_41.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_41.jpg)'
- en: 'Figure 11.41: An arctan function'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.41：一个arctan函数
- en: 'Use the preceding arctan function to calculate 10 correct digits of *π*. Follow
    these steps to do this:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前述arctan函数来计算*π*的10个正确数字。按照以下步骤进行：
- en: 'Simply call our arctan function. 10 terms should be sufficient:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只需调用我们的arctan函数。10个项应该足够了：
- en: '[PRE56]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Run the preceding code to see the output:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行上述代码以查看输出：
- en: '[PRE57]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We get a pretty good approximation using 10 terms. It gives even more than 10
    correct digits.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 使用10个项可以得到一个相当不错的近似值。它甚至给出了超过10个正确的数字。
- en: Note
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3dPjVvD](https://packt.live/3dPjVvD).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3dPjVvD](https://packt.live/3dPjVvD)。
- en: You can also run this example online at [https://packt.live/3dVlTKR](https://packt.live/3dVlTKR).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3dVlTKR](https://packt.live/3dVlTKR)上在线运行此示例。
- en: 'Exercise 11.10: Calculating the Value of π Using Euler''s Expression'
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.10：使用欧拉的表达式计算π的值
- en: 'The great German mathematician Euler came up with the following expression:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 伟大的德国数学家欧拉提出了以下表达式：
- en: '![Figure 11.42: Euler''s expression'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.42：欧拉的表达式'
- en: '](image/B15968_11_42.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_42.jpg)'
- en: 'Figure 11.42: Euler''s expression'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.42：欧拉的表达式
- en: Use this expression to approximate *π*. Does it converge more quickly than the
    adjusted arctan formula?
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个表达式来近似*π*。它是否比调整后的arctan公式更快地收敛？
- en: 'Perform the following steps:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Here''s the code for approximating *π* using Euler''s series:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是使用欧拉级数近似*π*的代码：
- en: '[PRE58]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Does it converge more quickly? Run the preceding code to see the output:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它收敛得更快吗？运行前面的代码以查看输出：
- en: '[PRE59]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It doesn't seem like it converges any quicker. After 1 million terms, you'll
    still only have five correct decimal places.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来它似乎并没有更快地收敛。100万项后，您仍然只有五位正确的小数。
- en: Note
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2NRnnLD](https://packt.live/2NRnnLD).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2NRnnLD](https://packt.live/2NRnnLD)。
- en: You can also run this example online at [https://packt.live/38lHXgm](https://packt.live/38lHXgm).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/38lHXgm](https://packt.live/38lHXgm)上在线运行此示例。
- en: A 20th Century Formula
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 20世纪的公式
- en: 'Here is the brilliant Indian mathematician Ramanujan''s formula to approximate
    π:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这是卓越的印度数学家拉马努金用来近似π的公式：
- en: '![Figure 11.43: Ramanujan''s formula to approximate π'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.43：拉马努金近似π的公式'
- en: '](image/B15968_11_43.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_43.jpg)'
- en: 'Figure 11.43: Ramanujan''s formula to approximate π'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.43：拉马努金近似π的公式
- en: 'Here''s how to code that in Python:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在Python中编写该代码：
- en: '[PRE60]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output after 10 terms is as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 10个项后的输出如下：
- en: '[PRE61]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: That's very accurate!!
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常准确！！
- en: Interval of Convergence
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收敛区间
- en: 'The range of values for which a series converges (tends toward a value) is
    called the interval of convergence. Using Python, finding this interval is rather
    straightforward: you run some numbers through the series, and if they get infinitely
    large, they''re not in the interval. If they produce a number, they''re in the
    interval. For example, let''s have a look at a very common textbook question and
    solve it using Python.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 系列收敛（趋向于一个值）的值范围称为收敛区间。使用Python，找到这个区间相当简单：您通过系列运行一些数字，如果它们变得无限大，它们就不在该区间内。如果它们产生一个数字，它们就在该区间内。例如，让我们看一个非常常见的教科书问题，并使用Python解决它。
- en: 'Exercise 11.11: Determining the Interval of Convergence – Part 1'
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.11：确定收敛区间-第1部分
- en: 'Determine the interval of convergence for the following power series:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 确定以下幂级数的收敛区间：
- en: '![Figure 11.44: A power series'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.44：幂级数'
- en: '](image/B15968_11_44.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_44.jpg)'
- en: 'Figure 11.44: A power series'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.44：幂级数
- en: 'Perform the following steps:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Enter the sum into Python:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将总和输入Python：
- en: '[PRE62]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Since we can't use the number "infinity," we find the sum of all the terms from
    n = 1 to 1 million.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不能使用数字“无穷大”，我们找到了从n = 1到100万的所有项的和。
- en: 'Run all the integers from -10 to 10 to see if there is any converge to a number:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行所有从-10到10的整数，看看是否收敛到一个数字：
- en: '[PRE63]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'When you run this, you''ll get an `OverflowError`:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行此代码时，将会出现`OverflowError`：
- en: '[PRE64]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: All this means is that some of the numbers got became large, which is what we
    expected. We need to add a condition so that if we get that error, it'll simply
    return `Infinity`. This is done with a `try...except` block.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一些数字变得很大，这正是我们预期的。我们需要添加一个条件，以便如果出现错误，它将简单地返回`Infinity`。这是通过`try...except`块完成的。
- en: 'Let''s tell Python to try a line of code. If it throws a specific error (in
    this case, `OverflowError`), don''t stop the program, just do this instead:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们告诉Python尝试一行代码。如果它抛出特定错误（在本例中是`OverflowError`），不要停止程序，而是执行以下操作：
- en: '[PRE65]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, the output gives us some infinities and some actual values:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输出给我们一些无穷大和一些实际值：
- en: '[PRE66]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: It looks like our interval of convergence is -5 < x < -1\. This means we can
    use the series to get useful values if *x* is in the interval. Otherwise, we can't
    use it.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的收敛区间是-5 < x < -1。这意味着如果*x*在该区间内，我们可以使用该级数获得有用的值。否则，我们无法使用它。
- en: Note
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/38k30A2](https://packt.live/38k30A2).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/38k30A2](https://packt.live/38k30A2)。
- en: You can also run this example online at [https://packt.live/31AtmMU](https://packt.live/31AtmMU).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/31AtmMU](https://packt.live/31AtmMU)上在线运行此示例。
- en: 'Exercise 11.12: Determining the Interval of Convergence – Part 2'
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.12：确定收敛区间-第2部分
- en: 'Determine the interval of convergence for the following power series:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 确定以下幂级数的收敛区间：
- en: '![Figure 11.45: A power series'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.45：幂级数'
- en: '](image/B15968_11_45.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_45.jpg)'
- en: 'Figure 11.45: A power series'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.45：幂级数
- en: 'Perform the following steps:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Define the sum in Python:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python中定义总和：
- en: '[PRE67]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Here''s some of the output:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是一些输出：
- en: '[PRE68]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: All the output for *x* between -25 and 25 stayed small (between 0 and 600),
    no matter how many terms we used, so we'll call the interval of convergence *-25
    < x < 25*.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在*x*在-25和25之间的所有输出都保持很小（在0和600之间），无论我们使用多少项，因此我们将称之为收敛区间*-25 < x < 25*。
- en: Note
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/38pwuwC](https://packt.live/38pwuwC).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/38pwuwC](https://packt.live/38pwuwC)。
- en: You can also run this example online at [https://packt.live/2YS46jl](https://packt.live/2YS46jl).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2YS46jl](https://packt.live/2YS46jl)上在线运行此示例。
- en: 'Exercise 11.13: Finding the Constant'
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.13：找到常数
- en: 'In this exercise, we will express an infinite series in Python and find the
    sum. We will use a famous constant, which is defined as the sum of the series:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在Python中表示一个无限级数并找到总和。我们将使用一个著名的常数，它被定义为该级数的和：
- en: '![Figure 11.46: Sum of the series'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.46：级数的总和'
- en: '](image/B15968_11_46.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_46.jpg)'
- en: 'Figure 11.46: Sum of the series'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.46：级数的总和
- en: 'What is the value of this famous constant? Let''s follow these steps to determine
    this value:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这个著名常数的值是多少？让我们按照以下步骤来确定这个值：
- en: 'Import the factorial module and convert the preceding equation into Python,
    as follows:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入阶乘模块并将前述方程转换为Python，如下所示：
- en: '[PRE69]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Run the preceding code to see the output:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码以查看输出：
- en: '[PRE70]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The famous constant is *e*, the base of the natural logarithms.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 著名的常数是*e*，自然对数的底数。
- en: Note
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2AoyubH](https://packt.live/2AoyubH).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2AoyubH](https://packt.live/2AoyubH)。
- en: You can also run this example online at [https://packt.live/2BZ4aVw](https://packt.live/2BZ4aVw).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2BZ4aVw](https://packt.live/2BZ4aVw)上在线运行此示例。
- en: 'Activity 11.01: Finding the Minimum of a Surface'
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动11.01：寻找表面的最小值
- en: A major task in machine learning is minimizing a function. When you're training
    a neural network, you're changing values in a matrix or tensor to see which ones
    provide a better approximation of your test data. At every value in your network,
    you can see how much it contributes to your error. This sounds like the partial
    derivatives at different points on a surface, doesn't it?
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习中的一个重要任务是最小化函数。当您训练神经网络时，您正在改变矩阵或张量中的值，以查看哪些值提供了更好地逼近您的测试数据。在网络的每个值处，您都可以看到它对您的错误有多大贡献。这听起来像是表面上不同点的偏导数，不是吗？
- en: 'An example of this is the process of gradient descent. Let''s consider that
    we want to find the location of the minimum value of our function. Every point
    in our surface has a partial derivative, and we can use those to move a little
    bit toward a lower value. We''ll start somewhere random, calculate the partial
    derivatives at that point, and then move in the direction that lowers the value
    of *z*, that is, the up-down value. So, if the partial derivative of *z* with
    respect to *x* (which we call *dz_dx*) is negative, that means *z* is decreasing
    as *x* is increasing, and we''ll want to move in the positive *x* direction. If
    *dz_dx* is positive, that means *z* is increasing as *x* is increasing, so we''ll
    want to go in the opposite direction, so we''ll move in the negative *x* direction.
    We''ll do the same for the *y* direction. This will look as follows:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是梯度下降的过程。让我们考虑一下，我们想要找到我们函数的最小值的位置。我们表面上的每个点都有一个偏导数，我们可以使用这些偏导数向更低的值移动一点。我们将从一个随机的地方开始，计算该点的偏导数，然后沿着降低*z*值的方向移动，也就是上下值。因此，如果*z*关于*x*的偏导数（我们称为*dz_dx*）是负的，这意味着*z*随着*x*的增加而减少，我们将希望向正*x*方向移动。如果*dz_dx*是正的，这意味着*z*随着*x*的增加而增加，所以我们将希望朝相反的方向移动，因此我们将向负*x*方向移动。我们将对*y*方向做同样的事情。这将如下所示：
- en: '![Figure 11.47: The path of descent to a minimum value'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.47：下降到最小值的路径'
- en: '](image/B15968_11_47.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_47.jpg)'
- en: 'Figure 11.47: The path of descent to a minimum value'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.47：下降到最小值的路径
- en: 'The first part of this activity is to create a function that finds the minimum
    point of a surface. This function can be written by following these steps:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的第一部分是创建一个找到表面最小点的函数。可以通过以下步骤编写此函数：
- en: Write a function that will create a random (x, y) location on a surface. You
    can call the `uniform` function of the `random` module to generate these values.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，该函数将在表面上创建一个随机的(x, y)位置。您可以调用`random`模块的`uniform`函数来生成这些值。
- en: Calculate the partial derivatives of *z* with respect to *x* and *y*.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算*z*关于*x*和*y*的偏导数。
- en: Change *x* and *y* by the negative of the partial derivatives, multiplied by
    a tiny *step* amount in case the partial derivative is large.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过偏导数的负值乘以一个微小的*step*量来改变*x*和*y*，以防偏导数很大。
- en: Calculate the partial derivatives at this new location and keep looping until
    the partial derivatives are both really small (less than 0.0001) or the location
    is off the surface.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算这个新位置的偏导数，并保持循环，直到偏导数都非常小（小于0.0001），或者位置偏离表面。
- en: Run the function on a bunch of random locations, saving the minimum *z* values
    to a *mins* list.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一堆随机位置上运行函数，将最小*z*值保存到*mins*列表中。
- en: Finally, print the minimum of the mins list.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打印*mins*列表的最小值。
- en: 'Once you have written the function, test it on a function that you already
    know the value of to verify that it works as intended. You can then run it on
    a function that you don''t already know the minimum point of, in order to determine
    this unknown location. The steps for this are as follows:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 编写函数后，可以在已知值的函数上测试它，以验证它是否按预期工作。然后可以在不知道最小点的函数上运行它，以确定这个未知位置。具体步骤如下：
- en: Test your function on the surface ![6](image/B15968_11_InlineEquation6.png).
    Your function should find that the minimum value is 0, at the point (0, 0).
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表面上测试您的函数![6](image/B15968_11_InlineEquation6.png)。您的函数应该发现最小值为0，在点(0, 0)处。
- en: Once you're confident in your function, use it to determine the minimum of ![7](image/B15968_11_InlineEquation8.png)
    with *-1 < x < 5* and *-1 < y < 5*.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您对您的函数有信心，就可以使用它来确定![7](image/B15968_11_InlineEquation8.png)的最小值，其中*-1 < x
    < 5*和*-1 < y < 5*。
- en: You should find that, depending on your starting point, your function will converge
    to different minimum points—a local minimum and a global minimum.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现，根据您的起始点，您的函数将收敛到不同的最小点 - 局部最小值和全局最小值。
- en: Note
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 696.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第696页找到。
- en: Summary
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In the previous chapter, we learned the power of derivatives and integrals,
    so in this chapter, we built on those tools to solve some pretty difficult problems,
    such as the length of a spiral and the area of a 3D surface. We even extended
    derivatives and integrals to three dimensions by introducing partial derivatives.
    In a calculus class, we would be using lots of algebra in order to use these tools,
    but by using Python, we modeled the situation and tested our functions. We created
    variables that will contain our changing values and looped through the calculations
    millions of times, if necessary. To the mathematicians of previous centuries,
    this would have seemed like some kind of magic lamp.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了导数和积分的力量，因此在本章中，我们基于这些工具来解决一些非常困难的问题，比如螺旋线的长度和三维表面的面积。我们甚至通过引入偏导数将导数和积分扩展到三维空间。在微积分课上，我们需要使用大量的代数来使用这些工具，但是通过使用Python，我们对情况进行了建模并测试了我们的函数。我们创建了包含我们变化数值的变量，并在必要时循环计算数百万次。对于以前世纪的数学家来说，这似乎就像是某种魔法灯。
- en: In the next chapter, we'll deal with more changing rates and amounts and avoid
    a lot of algebra by using Python. We'll find out how much salt is in an ever-changing
    mixture, when and where a predator will catch its prey, and how long we'll have
    to invest our money to make 1 million dollars.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理更多的变化率和数量，并通过使用Python避免大量的代数。我们将找出一个不断变化的混合物中有多少盐，捕食者何时何地会捕捉到猎物，以及我们需要投资多长时间才能赚到100万美元。
- en: FAB62
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: FAB62
- en: RUC47
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: RUC47
