- en: Building an Algorithmic Trading Platform
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建算法交易平台
- en: Algorithmic trading automates the systematic trading process, where orders are
    executed at the best price possible based on a variety of factors, such as pricing,
    timing, and volume. Brokerage firms may offer an **Application Programming Interface**
    (**API**) as part of their service offering for customers who wish to deploy their
    own trading algorithms. An algorithmic trading system must be highly robust to
    handle any point of failure during the order execution. Network configuration,
    hardware, memory management, speed, and user experience are a number of factors
    to be considered when designing a system for executing orders. Designing larger
    systems inevitably adds more complexity to the framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 算法交易自动化系统交易流程，根据定价、时机和成交量等多种因素以尽可能最佳价格执行订单。经纪公司可能会为希望部署自己交易算法的客户提供**应用程序编程接口**（**API**）作为其服务提供的一部分。算法交易系统必须非常健壮，以处理订单执行过程中的任何故障点。网络配置、硬件、内存管理、速度和用户体验是设计执行订单系统时需要考虑的一些因素。设计更大的系统不可避免地会给框架增加更多复杂性。
- en: As soon as a position in a market is opened, it is subjected to various types
    of risk, such as market risk, interest rate risk, and liquidity risk. To preserve
    the trading capital as much as possible, it is important to incorporate risk management
    measures into the trading system. Perhaps the most common risk measure used in
    the financial industry is the **Value at Risk** (**VaR**) technique. We will discuss
    the beauty and flaws of VaR, and how it can be incorporated into our trading system
    that we will develop in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在市场上开立头寸，就会面临各种风险，如市场风险、利率风险和流动性风险。为了尽可能保护交易资本，将风险管理措施纳入交易系统非常重要。金融行业中最常用的风险度量可能是**风险价值**（**VaR**）技术。我们将讨论VaR的优点和缺点，以及如何将其纳入我们将在本章开发的交易系统中。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An overview of algorithmic trading
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法交易概述
- en: A list of brokers and system vendors with a public API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有公共API的经纪人和系统供应商列表
- en: Choosing a programming language for a trading system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为交易系统选择编程语言
- en: Designing an algorithmic trading platform
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计算法交易平台
- en: Setting up API access on the Oanda v20 Python module
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Oanda v20 Python模块上设置API访问
- en: Implementing a mean-reverting algorithmic trading strategy
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施均值回归算法交易策略
- en: Implementing a trend-following algorithmic trading strategy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施趋势跟踪算法交易策略
- en: Introducing VaR for risk management in our trading system
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的交易系统中引入VaR进行风险管理
- en: Performing VaR calculations in Python on AAPL
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python上对AAPL进行VaR计算
- en: Introducing algorithmic trading
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍算法交易
- en: In the 1990s, exchanges had already begun to use electronic trading systems.
    By 1997, 44 exchanges worldwide used automated systems for trading futures and
    options with more exchanges in the process of developing automated technology.
    Exchanges such as the **Chicago Board of Trade** (**CBOT**) and the **London International
    Financial Futures and Options Exchange** (**LIFFE**) used their electronic trading
    systems as an after-hours complement to the traditional open outcry trading pits,
    thus giving traders 24-hour access to the exchange's risk management tools. With
    these improvements in technology, technology-based trading became less expensive,
    fueling the growth of trading platforms that are faster and more powerful. The
    higher reliability of order execution and the lower rate of message transmission
    error has deepened the reliance on technology by financial institutions. The majority
    of asset managers, proprietary traders, and market makers have since moved from
    the trading pits to electronic trading floors.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 上世纪90年代，交易所已经开始使用电子交易系统。到1997年，全球44个交易所使用自动化系统进行期货和期权交易，更多交易所正在开发自动化技术。芝加哥期货交易所（**CBOT**）和伦敦国际金融期货和期权交易所（**LIFFE**）等交易所将他们的电子交易系统用作传统的公开喊价交易场所之外的交易补充，从而使交易者可以全天候访问交易所的风险管理工具。随着技术的改进，基于技术的交易变得更加廉价，推动了更快更强大的交易平台的增长。订单执行的可靠性更高，消息传输错误率更低，这加深了金融机构对技术的依赖。大多数资产管理人、专有交易者和做市商已经从交易场所转移到了电子交易场所。
- en: As systematic or computerized trading becomes more commonplace, speed is the
    most important factor in determining the outcome of a trade. Quants, by utilizing
    sophisticated fundamental models, are able to recompute fair values of trading
    products on the fly and execute trading decisions, enabling them to reap profits
    at the expense of those fundamental traders using traditional tools. This has
    given way to the term **high-frequency trading** (**HFT**), which relies on fast
    computers to execute the trading decisions before anyone else can. In fact, HFT
    has evolved into a billion-dollar industry.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统化或计算机化交易变得更加普遍，速度成为决定交易结果的最重要因素。通过利用复杂的基本模型，量化交易者能够动态重新计算交易产品的公平价值并执行交易决策，从而能够以牺牲使用传统工具的基本交易者的利润。这催生了**高频交易**（**HFT**）这一术语，它依赖快速计算机在其他人之前执行交易决策。事实上，高频交易已经发展成为一个价值数十亿美元的行业。
- en: Algorithmic trading refers to the automation of the systematic trading process,
    where the order execution is heavily optimized to give the best price possible.
    It is not part of the portfolio allocation process.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 算法交易是指对系统化交易流程的自动化，其中订单执行被大大优化以获得最佳价格。它不是投资组合配置过程的一部分。
- en: Banks, hedge funds, brokerage firms, clearing firms, and trading firms typically
    have their servers placed right next to the electronic exchange to receive the
    latest market prices and to perform the fastest order execution where possible.
    They bring enormous trading volumes to the exchange. Anyone who wishes to participate
    in low-latency, high-volume trading activities (such as complex event processing
    or capturing fleeting price discrepancies) by acquiring exchange connectivity
    may do so in the form of co-location, where their server hardware can be placed
    on a rack right next to the exchange for a fee.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 银行、对冲基金、经纪公司、结算公司和交易公司通常会将他们的服务器放置在电子交易所旁边，以接收最新的市场价格，并在可能的情况下执行最快的订单。他们给交易所带来了巨大的交易量。任何希望参与低延迟、高交易量活动（如复杂事件处理或捕捉瞬息的价格差异）的人，可以通过获得交易所连接的方式来进行，可以选择共同定位的形式，他们的服务器硬件可以放置在交易所旁边的机架上，需要支付一定费用。
- en: The **Financial Information Exchange** (**FIX**) protocol is the industry standard
    for electronic communications with the exchange from the private server for **direct
    market access** (**DMA**) to real-time information. C++ is the common choice of
    programming language for trading over the FIX protocol, though other languages,
    such as .NET Framework Common Language and Java can also be used. The **Representational
    State Transfer**(**REST**) API offerings are becoming more common for retail investors.
    Before creating an algorithmic trading platform, you will need to assess various
    factors, such as the speed and ease of learning before deciding on a specific
    language for the purpose.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**金融信息交换**（**FIX**）协议是与交易所进行电子通信的行业标准，从私人服务器实现**直接市场访问**（**DMA**）到实时信息。C++是在FIX协议上进行交易的常见选择，尽管其他语言，如.NET
    Framework公共语言和Java也可以使用。**表述性状态转移**（**REST**）API提供正在变得越来越普遍，供零售投资者使用。在创建算法交易平台之前，您需要评估各种因素，如学习的速度和便捷性，然后才能决定特定的语言用于此目的。'
- en: Brokerage firms will provide a trading platform of some sort for their customers
    in order for them to execute orders on selected exchanges in return for the commission
    fees. Some brokerage firms may offer an API as part of their service offering
    to technically-inclined customers who wish to run their own trading algorithms.
    In most circumstances, customers may also choose from a number of commercial trading
    platforms offered by third-party vendors. Some of these trading platforms may
    also offer API access to route orders electronically to the exchange. It is important
    to read the API documentation beforehand to understand the technical capabilities
    offered by your broker and to formulate an approach in developing an algorithmic
    trading system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 经纪公司将为他们的客户提供某种交易平台，以便他们可以在选定的交易所上执行订单，作为佣金费用的回报。一些经纪公司可能会提供API作为他们的服务提供的一部分，以满足技术倾向的客户希望运行自己的交易算法。在大多数情况下，客户也可以从第三方供应商提供的多个商业交易平台中进行选择。其中一些交易平台也可能提供API访问以将订单电子路由到交易所。在开发算法交易系统之前，重要的是事先阅读API文档，了解经纪人提供的技术能力，并制定开发算法交易系统的方法。
- en: Trading platforms with a public API
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有公共API的交易平台
- en: 'The following table lists some brokers and trading platform vendors who have
    their API documentation publicly available:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了一些经纪人和交易平台供应商，他们的API文档是公开可用的：
- en: '| **Broker/vendor** | **URL** | **Programming languages supported** |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| **经纪人/供应商** | **网址** | **支持的编程语言** |'
- en: '| --- | --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| CQG | [https://www.cqg.com](https://www.cqg.com) | REST, FIX, C#, C++, and
    VB/VBA |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| CQG | [https://www.cqg.com](https://www.cqg.com) | REST, FIX, C#, C++, and
    VB/VBA |'
- en: '| Cunningham Trading Systems | [http://www.ctsfutures.com](http://www.ctsfutures.com)
    | Microsoft .Net Framework 4.0 and FIX |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| Cunningham Trading Systems | [http://www.ctsfutures.com](http://www.ctsfutures.com)
    | Microsoft .Net Framework 4.0 and FIX |'
- en: '| E*Trade | [https://developer.etrade.com/home](https://developer.etrade.com/home)
    | Python, Java, and Node.js |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| E*Trade | [https://developer.etrade.com/home](https://developer.etrade.com/home)
    | Python, Java, and Node.js |'
- en: '| Interactive Brokers | [https://www.interactivebrokers.com/en/index.php?f=5041](https://www.interactivebrokers.com/en/index.php?f=5041)
    | Java, C++, Python, C#, C++, and DDE |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| Interactive Brokers | [https://www.interactivebrokers.com/en/index.php?f=5041](https://www.interactivebrokers.com/en/index.php?f=5041)
    | Java, C++, Python, C#, C++, and DDE |'
- en: '| IG | [https://labs.ig.com/](https://labs.ig.com/) | REST, Java, JavaScript,
    .NET, Clojure, and Node.js |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| IG | [https://labs.ig.com/](https://labs.ig.com/) | REST, Java, JavaScript,
    .NET, Clojure, and Node.js |'
- en: '| Tradier | [https://developer.tradier.com/](https://developer.tradier.com/)
    | REST |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| Tradier | [https://developer.tradier.com/](https://developer.tradier.com/)
    | REST |'
- en: '| Trading Technologies | [https://www.tradingtechnologies.com/trading/apis/](https://www.tradingtechnologies.com/trading/apis/)
    | REST, .NET, and FIX |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| Trading Technologies | [https://www.tradingtechnologies.com/trading/apis/](https://www.tradingtechnologies.com/trading/apis/)
    | REST, .NET, and FIX |'
- en: '| OANDA | [https://developer.oanda.com/](https://developer.oanda.com/) | REST,
    Java, and FIX |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| OANDA | [https://developer.oanda.com/](https://developer.oanda.com/) | REST,
    Java, and FIX |'
- en: '| FXCM | [https://www.fxcm.com/uk/algorithmic-trading/api-trading/](https://www.fxcm.com/uk/algorithmic-trading/api-trading/)
    | REST, Java, and FIX |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| FXCM | [https://www.fxcm.com/uk/algorithmic-trading/api-trading/](https://www.fxcm.com/uk/algorithmic-trading/api-trading/)
    | REST, Java, and FIX |'
- en: Choosing a programming language
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择编程语言
- en: With many options of programming languages available to interface with brokers
    or vendors, the question that comes naturally to anyone starting out in algorithmic
    trading platform development is *Which language should I use?*
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与经纪人或供应商进行接口的多种编程语言选择，对于刚开始进行算法交易平台开发的人来说，自然而然会产生一个问题：*我应该使用哪种语言？*
- en: Before answering this question, it is important to find out if your broker provides
    developer tools. RESTful APIs are becoming the most common offering alongside
    FIX protocol access. A small number of brokers support Java and C#. With RESTful
    APIs, it is easy to search for, or even write a wrapper around it in almost any
    programming language that supports the **HyperText Transfer Protocol** (**HTTP**).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答这个问题之前，重要的是要弄清楚你的经纪人是否提供开发者工具。RESTful API正变得越来越普遍，与FIX协议访问并列。少数经纪人支持Java和C#。使用RESTful
    API，几乎可以在支持**超文本传输协议**（**HTTP**）的任何编程语言中搜索或编写其包装器。
- en: Bear in mind that each tool option presents its own limitations. Your broker
    may rate-limit price and event updates. How your product will be developed, the
    performance metrics to follow, the costs involved, latency threshold, risk measures,
    and the expected user interface are pieces of the puzzle to be taken into consideration.
    The risk manager, execution engine, and portfolio optimizer are some major components
    that will affect the design of your system. Your existing trading infrastructure,
    choice of operating system, programming language compiler capability, and available
    software tools pose further constraints on the system design, development, and
    deployment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，每个工具选项都有其自身的限制。你的经纪人可能会对价格和事件更新进行速率限制。产品的开发方式、要遵循的性能指标、涉及的成本、延迟阈值、风险度量以及预期的用户界面都是需要考虑的因素。风险管理、执行引擎和投资组合优化器是会影响系统设计的一些主要组件。你现有的交易基础设施、操作系统的选择、编程语言编译器的能力以及可用的软件工具对系统设计、开发和部署提出了进一步的限制。
- en: System functionalities
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统功能
- en: It is important to define the outcomes of your trading system. An outcome could
    be a research-based system concerned with obtaining high-quality data from data
    vendors, performing computations or running models, and evaluating a strategy
    through signal generation. Part of the research component might include a data-cleaning
    module or a backtesting interface to run a strategy with theoretical parameters
    over historical data. The CPU speed, memory size, and bandwidth are factors to
    be considered while designing our system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 定义交易系统的结果非常重要。结果可能是一个基于研究的系统，涉及从数据供应商获取高质量数据，执行计算或运行模型，并通过信号生成评估策略。研究组件的一部分可能包括数据清理模块或回测界面，以在历史数据上使用理论参数运行策略。在设计我们的系统时，CPU
    速度、内存大小和带宽是需要考虑的因素。
- en: Another outcome could be an execution-based system that is more concerned with
    risk management and order handling features to ensure the timely execution of
    multiple orders. The system must be highly robust in order to handle any point
    of failure during the order execution. As such, network configuration, hardware,
    memory management and speed, and user experience are some factors to be considered
    when designing a system that executes orders.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个结果可能是一个更关注风险管理和订单处理功能以确保多个订单及时执行的执行型系统。系统必须非常健壮，以处理订单执行过程中的任何故障点。因此，在设计执行订单的系统时需要考虑网络配置、硬件、内存管理和速度以及用户体验等因素。
- en: A system may contain one or more of these functionalities. Designing larger
    systems inevitably adds complexity to the framework. It is recommended that you
    choose one or more programming languages that can address and balance the development
    speed, ease of development, scalability, and reliability of your trading system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个系统可能包含一个或多个这些功能。设计更大的系统不可避免地会给框架增加复杂性。建议选择一个或多个编程语言，可以解决和平衡交易系统的开发速度、开发便捷性、可扩展性和可靠性。
- en: Building an algorithmic trading platform
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建算法交易平台
- en: In this section, we will design and build a live algorithmic trading system
    in Python. Since developer tools and offerings vary with each broker, it is important
    to take into consideration the different programming implementation that is required
    in integrating with our very own trading system. With a good system design, we
    can build a generic service that allows configurations of different brokers to
    plug in and play together nicely with our trading system.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将使用Python设计和构建一个实时算法交易系统。由于每个经纪人的开发工具和服务都不同，因此需要考虑与我们自己的交易系统集成所需的不同编程实现。通过良好的系统设计，我们可以构建一个通用服务，允许配置不同经纪人的插件，并与我们的交易系统良好地协同工作。
- en: Designing a broker interface
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计经纪人接口
- en: 'When designing a trading platform, the following three functionalities are
    highly desirable to fulfill any given trading plan:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计交易平台时，以下三个功能对于实现任何给定的交易计划都是非常理想的：
- en: '**Getting prices**: Pricing data is the one of the most basic units of information
    available from an exchange. It represents the quotation prices that are made by
    the marketplace to buy or sell a traded product. A broker may redistribute data
    from the exchange to be delivered to you in its own format. The most basic form
    of price data available is the date and time of the quotes, the symbol of the
    traded product, and the quoted bidding and asking price of the traded product.
    More often than not, this pricing data is useful to base your trading decisions
    on.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取价格**：定价数据是交易所提供的最基本信息之一。它代表了市场为购买或出售交易产品所做的报价价格。经纪人可能会重新分发交易所的数据，以自己的格式传递给你。可用的价格数据的最基本形式是报价的日期和时间、交易产品的符号以及交易产品的报价买入和卖出价格。通常情况下，这些定价数据对基于交易的决策非常有用。'
- en: The best quoted bidding and asking prices are known as the **Level 1** quote.
    In most cases, it is possible to request for Level 2, 3, or even additional quote
    levels from your broker.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳的报价和询价价格被称为**Level 1**报价。在大多数情况下，可以向经纪人请求Level 2、3甚至更多的报价级别。
- en: '**Sending orders to the market**: When sending orders to the marketplace, it
    may or may not be executed by your broker or the exchange. If it does get executed,
    you will have opened a position in the traded product and subjected yourself to
    all forms of risk, as well as returns. The simplest form of order states the product
    to trade (usually denoted by a symbol), the quantity to trade, the position that
    you want to take (that is, whether you are buying or selling), and, for a non-market
    order, the price to trade at. Depending on your needs, there are many different
    types of orders available to help manage your trading risks.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向市场发送订单：**当向市场发送订单时，它可能会被您的经纪人或交易所执行，也可能不会。如果订单得到执行，您将在交易产品中开立一个持仓，并使自己承担各种风险以及回报。最简单的订单形式指定了要交易的产品（通常用符号表示）、要交易的数量、您想要采取的持仓（即您是买入还是卖出），以及对于非市价订单，要交易的价格。根据您的需求，有许多不同类型的订单可用于帮助管理您的交易风险。'
- en: Your broker may not support all order types. It is prudent to check with your
    broker which types of order are available and which can best manage your trading
    risks. The most common order type used by market participants are market orders,
    limit orders, and good-till-canceled orders. A **market order** is an order to
    buy or sell a product right away in the market. Because it is executed based on
    the current market prices, an execution price is not required for this type of
    order. A **limit order** is an order to buy or sell a product at a specific or
    better price. A **good-till-canceled** (**GTC**) order is an order that remains
    in the exchange queue for execution until the stated expiry time. Unless specified,
    most orders are GTC orders that expire at the end of the trading day. You can
    find more information of various order types at [https://www.investopedia.com/university/how-start-trading/how-start-trading-order-types.asp](https://www.investopedia.com/university/how-start-trading/how-start-trading-order-types.asp).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您的经纪人可能不支持所有订单类型。最好与您的经纪人核实可用的订单类型以及哪种订单类型可以最好地管理您的交易风险。市场参与者最常用的订单类型是市价订单、限价订单和长期有效订单。**市价订单**是立即在市场上买入或卖出产品的订单。由于它是根据当前市场价格执行的，因此不需要为此类型的订单指定执行价格。**限价订单**是以特定或更好的价格买入或卖出产品的订单。**长期有效**（**GTC**）订单是一种保持在交易所队列中等待执行的订单，直到规定的到期时间。除非另有规定，大多数订单都是在交易日结束时到期的长期有效订单。您可以在[https://www.investopedia.com/university/how-start-trading/how-start-trading-order-types.asp](https://www.investopedia.com/university/how-start-trading/how-start-trading-order-types.asp)找到更多有关各种订单类型的信息。
- en: '**Tracking positions:** As soon as your order is executed, you will enter into
    a position. Keeping track of your opened position will help determine how well
    (or badly!) your trading strategy is doing, as well as manage and plan your risks.
    Your gains and losses from opened positions vary according to market movements,
    and is known as **unrealized profits and losses**. After closing your position,
    you will have **realized profits and losses**, which are the final outcome of
    your trading strategy.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪持仓：**一旦您的订单执行，您将进入一个持仓。跟踪您的持仓将有助于确定您的交易策略表现如何（好坏皆有可能！），并管理和规划您的风险。您的持仓盈亏根据市场波动而变化，并被称为**未实现盈利和亏损**。关闭持仓后，您将获得**实现盈利和亏损**，这是您交易策略的最终结果。'
- en: With these three basic functionalities in mind, we can design a generic `Broker`
    class implementing these functions that can be easily extended to any broker-specific
    configurations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这三个基本功能，我们可以设计一个通用的`Broker`类，实现这些功能，并可以轻松扩展到任何特定经纪人的配置。
- en: Python library requirements
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python库要求
- en: In this chapter, we will be using the publicly-available v20 module with Oanda
    as our broker. All method implementations mentioned in this chapter uses the `v20`
    Python library as an example.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用公开可用的v20模块，Oanda作为我们的经纪人。本章中提到的所有方法实现都使用`v20` Python库作为示例。
- en: Installing v20
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装v20
- en: 'The official repository for OANDA v20 REST API is at [https://github.com/oanda/v20-python](https://github.com/oanda/v20-python).
    Install using pip with the terminal command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: OANDA v20 REST API的官方存储库位于[https://github.com/oanda/v20-python](https://github.com/oanda/v20-python)。使用终端命令使用pip进行安装。
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Detailed documentation on the use of the OANDA v20 REST API can be found at
    [http://developer.oanda.com/rest-live-v20/introduction/](http://developer.oanda.com/rest-live-v20/introduction/).
    The use of APIs varies with each broker, so make sure that you consult with your
    broker for the appropriate documentation before writing your trading system implementation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有关OANDA v20 REST API的详细文档可以在[http://developer.oanda.com/rest-live-v20/introduction/](http://developer.oanda.com/rest-live-v20/introduction/)找到。API的使用因经纪人而异，因此在编写交易系统实现之前，请务必与您的经纪人咨询适当的文档。
- en: Writing an event-driven broker class
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写基于事件驱动的经纪人类
- en: Whether we are fetching prices, sending orders, or tracking positions, an event-driven
    system design will trigger key parts of our system in a multi-threaded fashion
    without blocking the main thread.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是获取价格、发送订单还是跟踪持仓，基于事件驱动的系统设计将以多线程方式触发我们系统的关键部分，而不会阻塞主线程。
- en: 'Let''s begin writing our `Broker` class in Python, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写我们的Python`Broker`类，如下所示：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the constructor, we can provide the `host` and `port` public connection configurations
    of our broker for the inheriting child classes. Three variables are declared for
    storing the event handlers of prices, orders, and position updates, respectively.
    Here, we are designing for only one listener for each event. A more complex trading
    system might support multiple listeners on the same event handler.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们可以为继承子类提供我们的经纪人的`host`和`port`公共连接配置。分别声明了三个变量，用于存储价格、订单和持仓更新的事件处理程序。在这里，我们设计了每个事件只有一个监听器。更复杂的交易系统可能支持同一事件处理程序上的多个监听器。
- en: Storing the price event handler
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储价格事件处理程序
- en: 'Inside the `Broker` class, add the following two methods as the getter and
    setter for the price event handler, respectively:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Broker`类内部，分别添加以下两个方法作为价格事件处理程序的getter和setter：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The inheriting child classes will notify the listeners through the `on_price_event`
    method invocation of the symbol, the bid price, and the ask price. Later on, we
    will use these pieces of basic information for our trading decisions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的子类将通过`on_price_event`方法调用通知监听器有关符号、买价和卖价的信息。稍后，我们将使用这些基本信息做出我们的交易决策。
- en: Storing the order event handler
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储订单事件处理程序
- en: 'Add the following two methods as the getter and setter for the order event
    handler, respectively:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 分别添加以下两个方法作为订单事件处理程序的获取器和设置器：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After an order is routed to your broker, the inheriting child classes will notify
    the listeners through the `on_order_event` method invocation, along with the order
    transaction ID.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在订单被路由到您的经纪人之后，继承的子类将通过`on_order_event`方法调用通知监听器，同时附带订单交易ID。
- en: Storing the position event handler
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储持仓事件处理程序
- en: 'Add the following two methods as the getter and setter for the position event
    handler:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下两个方法作为持仓事件处理程序的获取器和设置器：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When a position update event is received from your broker, the inheriting child
    classes will notify the listeners through the `on_position_event` method invocation
    containing the symbol information, a flag indicating a long or short position,
    the number of units traded, the unrealized profit and loss, and the realized profit
    and loss.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当从您的经纪人接收到持仓更新事件时，继承的子类将通过`on_position_event`方法通知监听器，其中包含符号信息、表示多头或空头持仓的标志、交易单位数、未实现的盈亏和已实现的盈亏。
- en: Declaring an abstract method for getting prices
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明一个用于获取价格的抽象方法
- en: 'Since fetching prices from a data source is a main requirement of any trading
    system, create an abstract method named `get_prices()` to perform such a function.
    It expects a `symbols` parameter to contain a list of broker-defined symbols,
    that will be used for querying data from our broker. The inheriting child classes
    are expected to implement this method, otherwise a `NotImplementedError` exception
    is thrown:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从数据源获取价格是任何交易系统的主要要求，创建一个名为`get_prices()`的抽象方法来执行这样的功能。它期望一个`symbols`参数，其中包含一个经纪人定义的符号列表，将用于从我们的经纪人查询数据。继承的子类应该实现这个方法，否则会抛出`NotImplementedError`异常：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that this `get_prices()` method is expected to perform a one-time fetch
    of the current market prices. This gives us a snapshot of the market at a particular
    time. For a continuously-running trading system, we will require streaming market
    prices to feed our trading logic in real time, which we will define next.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`get_prices()`方法预计执行一次获取当前市场价格的操作。这给我们提供了特定时间点的市场快照。对于一个持续运行的交易系统，我们将需要实时流式传输市场价格来满足我们的交易逻辑，接下来我们将定义这一点。
- en: Declaring an abstract method for streaming prices
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明一个用于流式传输价格的抽象方法
- en: 'Add a `stream_prices()` abstract method that accepts a list of symbols in streaming
    prices using the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`stream_prices()`抽象方法，使用以下代码接受一个符号列表来流式传输价格：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The inheriting child classes are expected to implement this method in streaming
    prices from your broker, otherwise a `NotImplementedError` exception message will
    be thrown.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的子类应该在从您的经纪人流式传输价格时实现这个方法，否则会抛出`NotImplementedError`异常消息。
- en: Declaring an abstract method for sending orders
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明一个用于发送订单的抽象方法
- en: 'Add a `send_market_order()` abstract method for the inheriting child classes
    to implement when sending a market order to your broker:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为继承的子类添加一个`send_market_order()`抽象方法，用于在向您的经纪人发送市价订单时实现：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using the preceding methods written in our `Broker` base class, we can now write
    broker-specific classes in the next section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`Broker`基类中编写的前述方法，我们现在可以在下一节中编写特定于经纪人的类。
- en: Implementing the broker class
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现经纪人类
- en: In this section, we will implement the abstract methods of the `Broker` class
    that are specific to our broker, Oanda. This requires the use of the `v20` library.
    However, you can easily change the configuration and any implemented methods that
    are specific to a broker of your choice.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现特定于我们的经纪人Oanda的`Broker`类的抽象方法。这需要使用`v20`库。但是，您可以轻松地更改配置和任何特定于您选择的经纪人的实现方法。
- en: Initializing the broker class
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化经纪人类
- en: 'Write the following `OandaBroker` class, which is specific to our broker, extending
    the generic `Broker` class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 编写以下`OandaBroker`类，它是特定于我们经纪人的类，扩展了通用的`Broker`类：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that Oanda uses two different hosts for regular API endpoints and a streaming
    API endpoint. These endpoints are different for their practice and live trading
    environments. All endpoints are connected on the standard **Secure Socket Layer**
    (**SSL**) port 440\. In the constructor, the `is_live` Boolean flag chooses the
    appropriate endpoints for the chosen trading environment for saving in the parent
    class. A `True` value for `is_live` indicates a live trading environment. The
    constructor argument also saves the account ID and token, which are required for
    authenticating the account used for trading. This information can be obtained
    from your broker.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Oanda使用两个不同的主机用于常规API端点和流式API端点。这些端点对于他们的模拟和实盘交易环境是不同的。所有端点都连接在标准的**安全套接字层**（**SSL**）端口440上。在构造函数中，`is_live`布尔标志选择适合所选交易环境的适当端点，以保存在父类中。`is_live`的`True`值表示实盘交易环境。构造函数参数还保存了账户ID和令牌，这些信息是用于验证用于交易的账户的。这些信息可以从您的经纪人那里获取。
- en: The `api` and `stream_api` variables hold the `v20` library's `Context` objects
    that are used by calling methods to send instructions to your broker.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`api`和`stream_api`变量保存了`v20`库的`Context`对象，通过调用方法向您的经纪人发送指令时使用。'
- en: Implementing the method for getting prices
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现获取价格的方法
- en: 'The following codes implement the parent `get_prices()` method in the `OandaBroker`
    class for getting prices from your broker:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了`OandaBroker`类中的父`get_prices()`方法，用于从您的经纪人获取价格：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The body of the response contains a `prices` attribute and a list of objects.
    Each item in the list is processed by the `process_price()` method. Let''s implement
    this method in the `OandaBroker` class as well:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 响应主体包含一个 `prices` 属性和一个对象列表。列表中的每个项目都由 `process_price()` 方法处理。让我们也在 `OandaBroker`
    类中实现这个方法：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `price` object contains an `instrument` property of a string object, along
    with `list` objects in the `bids` and `asks` properties. Typically, Level 1 quotes
    are available, so we read the first item of the each list. Each item in the list
    is a `price_bucket` object, from which we extract the bid and ask price.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`price` 对象包含一个字符串对象的 `instrument` 属性，以及 `bids` 和 `asks` 属性中的 `list` 对象。通常，Level
    1 报价是可用的，所以我们读取每个列表的第一项。列表中的每个项目都是一个 `price_bucket` 对象，我们从中提取买价和卖价。'
- en: With this information extracted, we pass it to the `on_price_event()` event
    handler method. Note that, in this example, we are passing only three values.
    In more complex trading systems, you might want to consider extracting more detailed
    information, such as traded volume, last traded price, or multilevel quotes, and
    pass this to the price event listeners.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些提取的信息，我们将其传递给 `on_price_event()` 事件处理程序方法。请注意，在这个例子中，我们只传递了三个值。在更复杂的交易系统中，您可能希望考虑提取更详细的信息，比如成交量、最后成交价格或多级报价，并将其传递给价格事件监听器。
- en: Implementing the method for streaming prices
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现流动价格的方法
- en: 'Add the following `stream_prices()` method in the `OandaBroker` class to start
    streaming prices from your broker:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OandaBroker` 类中添加以下 `stream_prices()` 方法，以从经纪人那里开始流动价格：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since the host connection expects a continuous stream, the `response` object
    has a `parts()` method that listens for incoming data. The `msg` object is essentially
    a `price` object, which we can reuse with the `process_price()` method to notify
    the listeners of an incoming price event.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主机连接期望连续流，`response` 对象有一个 `parts()` 方法来监听传入的数据。`msg` 对象本质上是一个 `price` 对象，我们可以重复使用它来通知监听器有一个传入的价格事件。
- en: Implementing the method for sending market orders
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现发送市价订单的方法
- en: 'Add the following `send_market_order()` method in the `OandaBroker` class,
    which will send a market order to your broker:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OandaBroker` 类中添加以下 `send_market_order()` 方法，它将向您的经纪人发送一个市价订单：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When the `market()` method of the v20 `order` library is called, the status
    of the response is expected to be `201` to indicate a successful connection to
    the broker. A further check on the response body is recommended for signs of error
    in the execution of our orders. In the case of a successful execution, the transaction
    ID and the details of the order are passed along to the listeners by calling the
    `on_order_event()` event handler. Otherwise, the order event is triggered with
    an empty transaction ID along with a `NOT_FILLED` status, indicating that the
    order is incomplete.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 v20 `order` 库的 `market()` 方法时，预期响应的状态为 `201`，表示成功连接到经纪人。建议进一步检查响应主体，以查看我们订单执行中的错误迹象。在成功执行的情况下，交易
    ID 和订单的详细信息通过调用 `on_order_event()` 事件处理程序传递给监听器。否则，订单事件将以空的交易 ID 触发，并带有 `NOT_FILLED`
    状态，表示订单不完整。
- en: Implementing the method for fetching positions
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现获取头寸的方法
- en: 'Add the following `get_positions()` method in the `OandaBroker` class, which
    will fetch all the available position information for a given account:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `OandaBroker` 类中添加以下 `get_positions()` 方法，它将为给定账户获取所有可用的头寸信息：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the response body, the `position` property contains a list of `position`
    objects, each having attributes for the contract symbol, the unrealized and realized
    gains or losses, and the number of long and short positions. This information
    is passed along to the listeners through the `on_position_event()` event handler.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应主体中，`position` 属性包含一个 `position` 对象列表，每个对象都有合同符号、未实现和已实现的盈亏、多头和空头头寸的数量属性。这些信息通过
    `on_position_event()` 事件处理程序传递给监听器。
- en: Getting the prices
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取价格
- en: 'With the methods of `broker` now defined, we can test the connection that is
    set up between our broker by reading the current market prices. The `Broker` class
    may be instantiated using the following Python codes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在定义了来自我们经纪人的价格事件监听器的方法，我们可以通过阅读当前市场价格来测试与我们经纪人之间建立的连接。可以使用以下 Python 代码实例化 `Broker`
    类：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Replace the two constant variables, `ACCOUNT_ID` and `API_TOKEN`, with your
    own credentials given by your broker, which identifies your own trading account.
    The `broker` variable is an instance of `OandaBroker`, which we can use to perform
    various broker-specific calls.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 用您的经纪人提供的自己的凭据替换两个常量变量 `ACCOUNT_ID` 和 `API_TOKEN`，这些凭据标识了您自己的交易账户。`broker` 变量是
    `OandaBroker` 的一个实例，我们可以使用它来执行各种特定于经纪人的调用。
- en: 'Suppose that we are interested in finding out the current market price of the
    EUR/USD currency pair. Let''s define a constant variable to hold the symbol of
    this instrument that is recognized by our broker:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有兴趣了解 EUR/USD 货币对的当前市场价格。让我们定义一个常量变量来保存这个工具的符号，这个符号被我们的经纪人所认可：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, define a price event listener coming from our broker, using the following
    code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下代码定义来自我们经纪人的价格事件监听器：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `on_price_event()` function is defined as the listener for incoming price
    information and is assigned to the `broker.on_price_event` event handler. We expect
    three values from a pricing event – the contract symbol, the bid price, and the
    ask price – which we simply print to the console.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_price_event()` 函数被定义为监听器，用于接收价格信息，并分配给 `broker.on_price_event` 事件处理程序。我们期望从定价事件中获得三个值
    - 合同符号、买价和卖价 - 我们只是简单地将它们打印到控制台。'
- en: 'The `get_prices()` method is called to fetch the current market price from
    our broker:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `get_prices()` 方法来从我们的经纪人那里获取当前市场价格：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We should get a similar output on the console as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在控制台上得到类似的输出：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The output is a single line showing the bid and ask price of the EUR/USD currency
    pair as `1.14361` and `1.14374`, respectively.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一行，显示 EUR/USD 货币对的买价和卖价分别为 `1.14361` 和 `1.14374`。
- en: Sending a simple market order
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送一个简单的市价订单
- en: In the same way that we use for fetching prices, we can reuse the `broker` variable
    to send a market order to our broker.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与获取价格时一样，我们可以重用`broker`变量向我们的经纪人发送市价订单。
- en: 'Now suppose that we are interested in buying one unit of the same EUR/USD currency
    pair; the following code performs this action:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们有兴趣购买一单位相同的EUR/USD货币对；以下代码执行此操作：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `on_order_event()` function is defined as the listener for incoming order
    updates from our broker and is assigned to the `broker.on_order_event` event handler.
    For example, a limit order that is executed, or an order that is canceled, will
    be called on by this method. Finally, the `send_market_order()` method indicates
    that we are interested in buying one unit of the EUR/USD currency pair.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_order_event()`函数被定义为监听来自我们经纪人的订单更新的函数，并分配给`broker.on_order_event`事件处理程序。例如，执行的限价订单或取消的订单将通过此方法调用。最后，`send_market_order()`方法表示我们有兴趣购买一单位EUR/USD货币对。'
- en: 'If the currency markets are open when you run the preceding codes, you should
    get the following result with a different transaction ID:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行上述代码时货币市场开放，您应该会得到以下结果，交易ID不同：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output shows that the order is successfully filled to buy one unit of the
    EUR/USD currency pair with a transaction ID of `754`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示订单成功填写，购买一单位EUR/USD货币对，交易ID为`754`。
- en: Getting position updates
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取持仓更新
- en: 'With a long position opened by sending a market order to buy, we should be
    able to view our current EUR/USD position. We can do so on the `broker` object
    using the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过发送市价订单进行开仓，我们应该能够查看当前的EUR/USD头寸。我们可以在`broker`对象上使用以下代码来实现：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `on_position_event()` function is defined as the listener for incoming
    position updates from our broker and is assigned to the `broke.on_position_event`
    event handler. When the `get_positions()` method is called, the broker returns
    the position information and triggers the following output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_position_event()`函数被定义为监听来自我们经纪人的持仓更新的函数，并分配给`broker.on_position_event`事件处理程序。当调用`get_positions()`方法时，经纪人返回持仓信息并触发以下输出：'
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our position statement is currently one long unit of the EUR/USD currency pair,
    with an unrealized loss of $0.0001\. Since this is our first trade, we have not
    realized any profits or losses yet.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的头寸报告目前是EUR/USD货币对的一个多头单位，未实现损失为$0.0001。由于这是我们的第一笔交易，我们还没有实现任何利润或损失。
- en: Building a mean-reverting algorithmic trading system
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建均值回归算法交易系统
- en: With our broker now accepting orders and responding to our requests, we can
    begin to design a fully-automated trading system. In this section, we will explore
    how to design and implement a mean-reverting algorithmic trading system.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的经纪人接受订单并响应我们的请求，我们可以开始设计一个完全自动化的交易系统。在本节中，我们将探讨如何设计和实施一个均值回归算法交易系统。
- en: Designing the mean-reversion algorithm
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计均值回归算法
- en: Suppose we believe that in normal market conditions, prices fluctuate, but tend
    to revert back to some short-term level, such as the average of the most recent
    prices. In this example, we assume that the EUR/USD currency pair is exhibiting
    a mean-reversion property in the near short-term period. First, we resample the
    raw tick-level data into standard time series intervals, for example, at one-minute
    intervals. Then, taking a number of the most recent periods for calculating the
    short-term average price (for example, with five periods), we are saying that
    we believe the EUR/USD prices will revert toward the average of the prior five
    minutes' prices.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们相信在正常的市场条件下，价格会波动，但往往会回归到某个短期水平，例如最近价格的平均值。在这个例子中，我们假设EUR/USD货币对在近期短期内表现出均值回归特性。首先，我们将原始的tick级数据重新采样为标准时间序列间隔，例如一分钟间隔。然后，取最近几个周期来计算短期平均价格（例如，使用五个周期），我们认为EUR/USD价格将向前五分钟的价格平均值回归。
- en: As soon as the bidding price of the EUR/USD currency pair exceeds the short-term
    average price, with five minutes as our example, our trading system shall generate
    a sell signal, and we can choose to enter into a short position with a sell market
    order. Likewise, when the asking price of EUR/USD falls below the average price,
    a buy signal is generated and we can choose to enter into a long position with
    a buy market order.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦EUR/USD货币对的出价价格超过短期平均价格，以五分钟为例，我们的交易系统将生成一个卖出信号，我们可以选择通过卖出市价订单进入空头头寸。同样，当EUR/USD的询价价格低于平均价格时，将生成买入信号，我们可以选择通过买入市价订单进入多头头寸。
- en: The moment that a position is opened, we may use the same signals to close out
    our position. When a long position is opened, we close our position on a sell
    signal by entering an order to sell at the market. Likewise, when a short position
    is opened, we close our position on a buy signal by entering an order to buy at
    the market.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开仓，我们可以使用相同的信号来平仓。当开多头头寸时，我们在卖出信号时通过输入市价卖出订单来平仓。同样，当开空头头寸时，我们在买入信号时通过输入市价买入订单来平仓。
- en: You might observe that there are plenty of flaws in our trading strategy. Closing
    out our position does not guarantee a profit. Our belief of the market can be
    wrong; in adverse market conditions, a signal might remain in one direction for
    some time and there is a high probability of closing out our position at a huge
    loss! As a trader, you should figure out a personal trading strategy that suits
    your beliefs and risk appetite.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会观察到我们交易策略中存在许多缺陷。平仓并不保证盈利。我们对市场的看法可能是错误的；在不利的市场条件下，信号可能会在一个方向上持续一段时间，并且有很高的可能性以巨大的损失平仓！作为交易员，您应该找出适合自己信念和风险偏好的个人交易策略。
- en: Implementing the mean-reversion trader class
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施均值回归交易员类
- en: 'The resample interval and the number of periods in our calculation are two
    important parameters that are required by our trading system. First, create a
    class named `MeanReversionTrader`, which we can instantiate and run as our trading
    system:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们交易系统需要的两个重要参数是重新取样间隔和计算周期数。首先，创建一个名为`MeanReversionTrader`的类，我们可以实例化并作为我们的交易系统运行：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The five parameters in our constructor initialize the state of our trading system
    – the broker used, the symbol to trade, the number of units to trade, the resampling
    interval of our price data, and the number of periods for our mean calculation.
    These values are simply stored as class variables.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中的五个参数初始化了我们交易系统的状态 - 使用的经纪人、要交易的标的、要交易的单位数、我们价格数据的重新取样间隔，以及我们均值计算的周期数。这些值只是存储为类变量。
- en: The `setup_broker()` method call sets up our class to handle events from our
    `broker` object, which we will define shortly. As we receive price data, these
    are stored in a `pandas` DataFrame variable, `df_prices`. The latest bid and ask
    prices are stored in the `bid_price` and `ask_price` variables for calculating
    signals. The `mean` variable will store the calculated mean of the prior number
    of `mean_period` prices. The `position` variable will store the number of units
    of our current position. A negative value indicates a short position, and a positive
    value indicates a long position.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup_broker()`方法调用设置我们的类来处理我们即将定义的`broker`对象的事件。当我们接收到价格数据时，这些数据存储在一个`pandas`
    DataFrame变量`df_prices`中。最新的买入和卖出价格存储在`bid_price`和`ask_price`变量中，用于计算信号。`mean`变量将存储先前`mean_period`价格的计算均值。`position`变量将存储我们当前持仓的单位数。负值表示空头持仓，正值表示多头持仓。'
- en: 'The `is_order_pending` Boolean flag indicates whether an order is pending execution
    by our broker, and the `is_next_signal_cycle` Boolean flag indicates whether the
    current trading state cycle is open. Note that our system states can be as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_order_pending`布尔标志指示是否有订单正在等待经纪人执行，`is_next_signal_cycle`布尔标志指示当前交易状态周期是否开放。请注意，我们的系统状态可以如下：'
- en: Wait for a buy or sell signal.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待买入或卖出信号。
- en: Place an order on a buy or sell signal.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在买入或卖出信号上下订单。
- en: When a position is opened, wait for a sell or buy signal.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当持仓被打开时，等待卖出或买入信号。
- en: Place an order on a sell or buy signal.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在卖出或买入信号上下订单。
- en: When the position is closed, go to step 1.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当持仓被平仓时，转到步骤1。
- en: For every cycle of steps from 1 to 5, we will only trade one unit. These Boolean
    flags act as a lock to prevent multiple orders from entering into the system at
    any one time.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1到5的每个周期中，我们只交易一个单位。这些布尔标志作为锁，防止多个订单同时进入系统。
- en: Adding event listeners
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加事件监听器
- en: Let's hook up the price, order, and position events in our `MeanReversionTrader`
    class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`MeanReversionTrader`类中连接价格、订单和持仓事件。
- en: 'Add the `setup_broker()` method into this class, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将`setup_broker()`方法添加到这个类中，如下所示：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are simply assigning three class methods as listeners on any broker-generated
    event to listen to price, order, and position updates.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将三个类方法分配为经纪人生成的任何事件的监听器，以监听价格、订单和持仓更新。
- en: 'Add the `on_price_event()` method into this class, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将`on_price_event()`方法添加到这个类中，如下所示：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When a price event is received, we store them in our `bid_price`, `ask_price`,
    and `df_prices` class variables. As the price changes, so do our open positions
    and signal values. The `get_position()` method call retrieves up-to-date information
    on our positions, and the `generate_signals_and_think()` call recalculates our
    signals and decides whether to make the trade. The current state of the system
    is printed to the console using the `print_state()` command.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当收到价格事件时，我们将它们存储在我们的`bid_price`、`ask_price`和`df_prices`类变量中。随着价格的变化，我们的持仓和信号值也会发生变化。`get_position()`方法调用将检索我们持仓的最新信息，`generate_signals_and_think()`调用将重新计算我们的信号并决定是否进行交易。使用`print_state()`命令将系统的当前状态打印到控制台。
- en: 'Write the `get_position()` method to retrieve the position information from
    our broker, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 编写`get_position()`方法来从我们的经纪人中检索持仓信息，如下所示：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the `on_order_event()` method into our class, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将`on_order_event()`方法添加到我们的类中，如下所示：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When an order event is received, we print them out to the console. In our broker's
    `on_order_event` implementation, an order that is executed successfully will pass
    either a `status` value of `FILLED` or `UNFILLED`. Only on a successful order
    can we turn off our Boolean locks, retrieve our latest position, and perform decision-making
    for closing out our position.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到订单事件时，我们将它们打印到控制台上。在我们的经纪人的`on_order_event`实现中，成功执行的订单将传递`status`值为`FILLED`或`UNFILLED`。只有在成功的订单中，我们才能关闭我们的布尔锁，检索我们的最新持仓，并进行决策以平仓我们的持仓。
- en: 'Add the `on_position_event()` method into our class, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 将`on_position_event()`方法添加到我们的类中，如下所示：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When a position update event is received for our intended trade symbol, we store
    our position information, the realized gains, and unrealized gains. The current
    state of the system is printed to the console using the `print_state()` command.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到我们预期交易标的的持仓更新事件时，我们存储我们的持仓信息、已实现收益和未实现收益。使用`print_state()`命令将系统的当前状态打印到控制台。
- en: 'Add the `print_state()` method into our class, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将`print_state()`方法添加到我们的类中，如下所示：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As soon as there are any updates to our orders, positions, or market prices,
    we print the latest state of our system to the console.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的订单、持仓或市场价格有任何更新，我们就会将系统的最新状态打印到控制台。
- en: Writing the mean-reversion signal generators
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写均值回归信号生成器
- en: 'We want our decision-making algorithm to recalculate trading signals on every
    price or order update. Let''s create a `generate_signals_and_think()` method inside
    the `MeanReversionTrader` class to do this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的决策算法在每次价格或订单更新时重新计算交易信号。让我们在`MeanReversionTrader`类中创建一个`generate_signals_and_think()`方法来做到这一点：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since price data are stored in the `df_prices` variable as a pandas DataFrame,
    we can resample them at regular intervals, as defined by the `resample_interval` variable
    given in the constructor. The `ffill()` method forward-fills any missing data
    and the `dropna()` command removes the first missing value after resampling. There
    must be sufficient data available for calculating the mean, otherwise this method
    simply exits. The `mean_periods` variable represents the minimum length of resampled
    data that must be available.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于价格数据存储在`df_prices`变量中作为pandas DataFrame，我们可以按照构造函数中给定的`resample_interval`变量的定义，定期对其进行重新采样。`ffill()`方法向前填充任何缺失的数据，`dropna()`命令在重新采样后移除第一个缺失值。必须有足够的数据可用于计算均值，否则此方法将简单退出。`mean_periods`变量表示必须可用的重新采样数据的最小长度。
- en: The `tail(self.mean_periods)` method takes the most recent resampled intervals
    and calculates the average using the `mean()` method, resulting in another pandas
    DataFrame. The mean level is taken by index referencing the column of the DataFrame,
    which is simply the instrument symbol.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail(self.mean_periods)`方法获取最近的重新采样间隔并使用`mean()`方法计算平均值，从而得到另一个pandas DataFrame。平均水平通过引用DataFrame的列来获取，该列简单地是工具符号。'
- en: Using the average price available for the mean-reversion algorithm, we can generate
    the buy and sell signals. Here, a buy signal is generated when the average price
    exceeds the market asking price, and a sell signal is generated when the average
    price exceeds the market bidding price. Our short-term belief is that market prices
    will revert to the average price.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用均值回归算法可用的平均价格，我们可以生成买入和卖出信号。在这里，当平均价格超过市场要价时，会生成买入信号，当平均价格超过市场竞价时，会生成卖出信号。我们的短期信念是市场价格将回归到平均价格。
- en: 'After printing these calculated values to the console for better debugging,
    we can now make use of the buy and sell signals to perform actual trades in a
    separate method named `think()` inside the same class:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在将这些计算出的值打印到控制台以便更好地调试后，我们现在可以利用买入和卖出信号来执行实际交易，这在同一类中的名为`think()`的方法中完成：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If an order is still in pending state by a broker, we simply do nothing and
    exit the method. Since market conditions may change at any time, you might want
    to add your own logic to handle orders that have stayed in the pending state for
    too long and try another strategy.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果订单仍处于待处理状态，我们只需不做任何操作并退出该方法。由于市场条件可能随时发生变化，您可能希望添加自己的逻辑来处理待处理状态已经过长时间的订单，并尝试另一种策略。
- en: 'The three if-else statements handles the trading logic when our position is
    flat, long, or short, respectively. When our position is flat, the `think_when_position_flat()`
    method is called, written as the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个if-else语句分别处理了当我们的仓位是平的、多头的或空头的交易逻辑。当我们的仓位是平的时，将调用`think_when_position_flat()`方法，写成如下：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first `if` statement handles the condition that, upon a buy signal and when
    the current trading cycle is open, we enter into a long position by sending a
    market order to buy and mark that order as pending. Conversely, the second `if`
    statement handles the condition to enter into a short position upon a sell signal.
    Otherwise, since the position is flat with neither a buy nor sell signal, we simply
    set the `is_next_signal_cycle` to `True` until a signal becomes available.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`if`语句处理的是，在买入信号时，当前交易周期处于开放状态时，我们通过发送市价订单来买入并将该订单标记为待处理的条件。相反，第二个`if`语句处理的是在卖出信号时进入空头仓位的条件。否则，由于仓位是平的，既没有买入信号也没有卖出信号，我们只需将`is_next_signal_cycle`设置为`True`，直到有信号可用为止。
- en: 'When we are in a long position, the `think_when_position_long()` method is
    called, written as the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处于多头仓位时，将调用`think_when_position_long()`方法，写成如下：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: On a sell signal, we mark the order as pending and close out our long position
    immediately by sending a market order to sell.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在卖出信号时，我们将订单标记为待处理，并立即通过发送市价订单来卖出来平仓我们的多头仓位。
- en: 'Similarly, when we are in a short position, the `think_when_position_short()`
    method is called, written as the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当我们处于空头仓位时，将调用`think_when_position_short()`方法，写成如下：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: On a buy signal, we mark the order as pending and close out our short position
    immediately by sending a market order to buy.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在买入信号时，我们将订单标记为待处理，并立即通过发送市价订单来买入来平仓我们的空头仓位。
- en: 'To perform the order routing functionality, add the following `send_market_order()`class
    method to our `MeanReversionTrader` class:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行订单路由功能，将以下`send_market_order()`类方法添加到我们的`MeanReversionTrader`类中：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The order information is simply forwarded to our `Broker` class for execution.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 订单信息简单地转发给我们的`Broker`类进行执行。
- en: Running our trading system
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的交易系统
- en: 'Finally, to start running our trading system, we need an entry point. Add the
    following `run()` class method to the `MeanReversionTrader` class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了开始运行我们的交易系统，我们需要一个入口点。将以下`run()`类方法添加到`MeanReversionTrader`类中：
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: During the first run of our trading system, we read our current positions and
    use the information to initialize all position-related information. Then, we request
    our broker to start streaming prices for the given symbol and hold the connection
    until the program is terminated.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的交易系统的第一次运行期间，我们读取我们当前的仓位并使用该信息来初始化所有与仓位相关的信息。然后，我们请求我们的经纪人开始为给定的符号流式传输价格，并保持连接直到程序终止。
- en: 'With an entry point defined, all we need to do is initialize our `MeanReversionTrader`
    class and call the `run()` command using the following codes:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有了入场点的定义，我们只需要初始化我们的`MeanReversionTrader`类，并使用以下代码调用`run()`命令：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Remember that the `broker` variable contains an instance of the `OandaBroker`
    class as defined from the previous *Getting prices* section, and we can reuse
    it for this class. Our trading system will use this broker object to perform broker-related
    calls. We are interested in the EUR/USD currency pair, trading one unit at each
    time. The `resample_interval` variable with a value of `60s` states that our stored
    prices are to be resampled at one-minute intervals. The `mean_periods` variable
    with a value of `5` states that we will take the average of the most recent five
    intervals, or the average price of the past five minutes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`broker`变量包含了前面*获取价格*部分定义的`OandaBroker`类的实例，我们可以重复使用它。我们的交易系统将使用这个经纪人对象来执行与经纪人相关的调用。我们对EUR/USD货币对感兴趣，每次交易一单位。`resample_interval`变量的值为`60s`表示我们的存储价格将以一分钟的间隔重新采样。`mean_periods`变量的值为`5`表示我们将取最近五个间隔的平均值，或者过去五分钟的平均价格。
- en: 'To start our trading system, make the call to `run()`; pricing updates will
    start trickling in, enabling our system to trade on its own. You should see an
    output on the console that is similar to the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的交易系统，请调用`run()`；定价更新将开始涓涓流入，使我们的系统能够自行交易。您应该在控制台上看到类似以下的输出：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: From the output, it looks as though our position is currently flat, and there
    is insufficient pricing data for calculating our trading signals.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中看，我们的头寸目前是平的，并且没有足够的定价数据来计算我们的交易信号。
- en: 'After five minutes, when there is sufficient data for a trading signal calculation,
    we should be able to observe the following outcome:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 五分钟后，当有足够的数据进行交易信号计算时，我们应该能够观察到以下结果：
- en: '[PRE39]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The average price of the past five minutes is `1.13934`. Since the current market
    bidding price for EUR/USD is `1.13936`, more than the average price, a sell signal
    is generated. A sell market order is generated to open a short position in EUR/USD
    of one unit. This leads to an unrealized loss of $0.0001.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 过去五分钟的平均价格为`1.13934`。由于EUR/USD的当前市场竞价价格为`1.13936`，高于平均价格，生成了一个卖出信号。生成一个卖出市价订单，开设EUR/USD的一个单位的空头头寸。这导致了0.0001美元的未实现损失。
- en: Let the system run on its own for a while, and it should be able to close out
    the positions on its own. To stop trading, terminate the running process using
    *Ctrl* + *Z* or something similar. Remember to manually close out any remaining
    trading positions once the program stops running. You now have a fully functional
    and automated trading system!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让系统自行运行一段时间，它应该能够自行平仓。要停止交易，请使用*Ctrl* + *Z*或类似的方法终止运行的进程。请记住，一旦程序停止运行，手动平仓任何剩余的交易头寸。现在您拥有一个完全功能的自动交易系统了！
- en: The system design and trading parameters here are stated as an example and don't
    necessarily lead to positive outcomes! You should experiment with various trading
    parameters and improve the handling of events to figure out the optimal strategy
    for your trading plan.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的系统设计和交易参数仅作为示例，并不一定会产生积极的结果！您应该尝试不同的交易参数，并改进事件处理，以找出您交易计划的最佳策略。
- en: Building a trend-following trading platform
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建趋势跟踪交易平台
- en: In the previous section, we followed the steps for building a mean-reverting
    trading platform. The same functionality can be easily extended to incorporate
    any other trading strategies. In this section, we will take a look at reusing
    the `MeanReversionTrader` class to implement a trend-following trading system.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们按照构建均值回归交易平台的步骤进行了操作。相同的功能可以很容易地扩展到包括任何其他交易策略。在本节中，我们将看看如何重用`MeanReversionTrader`类来实现一个趋势跟踪交易系统。
- en: Designing the trend-following algorithm
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计趋势跟踪算法
- en: Suppose that this time, we believe that the current market conditions exhibit
    a trend-following pattern, perhaps due to seasonal changes, economic projections,
    or government policy. As prices fluctuate, and as the short-term average price
    level crosses the average long-term price level by a certain threshold, we generate
    a buy or sell signal.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这一次，我们相信当前的市场条件呈现出趋势跟踪的模式，可能是由于季节性变化、经济预测或政府政策。随着价格的波动，短期平均价格水平穿过平均长期价格水平的某个阈值，我们生成买入或卖出信号。
- en: First, we resample raw tick-level data into standard time series intervals,
    for example, at one-minute intervals. Second, taking a number of the most recent
    periods, for example, with five periods, we calculate the short-term average price
    for the past five minutes. Finally, taking a larger number of the most recent
    periods, for example, with ten periods, we calculate the long-term average price
    for the past ten minutes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将原始的tick级数据重新采样为标准的时间序列间隔，例如，每分钟一次。其次，我们取最近的若干个周期，例如，五个周期，计算过去五分钟的短期平均价格。最后，取最近的较大数量的周期，例如，十个周期，计算过去十分钟的长期平均价格。
- en: In a market with no movement, the average short-term price should be the same
    as the average long-term price with a ratio of one – this ratio is also known
    as the beta. When the average short-term price increases more than the average
    long-term price, the beta is more than one and the market can be viewed as on
    an uptrend. When the short-term price decreases more than the average long-term
    price, the beta is less than one and the market can be viewed as on a downtrend.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有市场波动的市场中，短期平均价格应该与长期平均价格相同，比率为一 - 这个比率也被称为贝塔。当短期平均价格增加超过长期平均价格时，贝塔大于一，市场可以被视为处于上升趋势。当短期价格下降超过长期平均价格时，贝塔小于一，市场可以被视为处于下降趋势。
- en: On an uptrend, as soon as the beta crosses above a certain price threshold level,
    our trading system shall generate a buy signal, and we can choose to enter into
    a long position with a buy market order. Likewise, on a downtrend, when the beta
    falls below a certain price threshold level, a sell signal is generated and we
    can choose to enter into a short position with a sell market order.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在上升趋势中，一旦beta穿过某个价格阈值水平，我们的交易系统将生成买入信号，我们可以选择以买入市价单进入多头头寸。同样，在下降趋势中，当beta跌破某个价格阈值水平时，将生成卖出信号，我们可以选择以卖出市价单进入空头头寸。
- en: The moment that a position is opened, the same signals may be used to close
    out our position. When a long position is opened, we close our position on a sell
    signal by entering an order to sell at the market. Likewise, when a short position
    is opened, we close out our position on a buy signal by entering an order to buy
    at the market.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开仓，相同的信号可以用来平仓。当开多头头寸时，我们在卖出信号时平仓，通过以市价卖出单进入卖出订单。同样，当开空头头寸时，我们在买入信号时平仓，通过以市价买入单进入买入订单。
- en: The mechanics mentioned are very similar to those of the mean-reversion trading
    system design. Bear in mind that this algorithm does not guarantee any profits,
    and is just a simplistic belief of the markets. You should have a different (and
    better) view than this.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 上述机制与均值回归交易系统设计非常相似。请记住，该算法不能保证任何利润，只是对市场的简单看法。您应该有一个与此不同（更好）的观点。
- en: Writing the trend-following trader class
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写趋势跟踪交易员类
- en: 'Let''s write a class for our trend-following trading system with a new class
    named `TrendFollowingTreader`, which simply extends the `MeanReversionTrader`
    class using the following Python code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的趋势跟踪交易系统编写一个新的名为`TrendFollowingTreader`的类，它简单地扩展了`MeanReversionTrader`类，使用以下Python代码：
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In our constructor, we define three additional keyword arguments, `long_mean_periods`,
    `buy_threshold`, and `sell_threshold`, saved as class variables. The `long_mean_periods` variable
    defines the number of resample intervals of our time series prices to take into
    account for calculating the long-term average price. Note that the existing `mean_periods` variable
    in the parent constructor is used for calculating the short-term average price.
    The `buy_threshold` and `sell_threshold` variables contain values that determine
    the boundaries of beta in generating a buy or sell signal.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构造函数中，我们定义了三个额外的关键字参数，`long_mean_periods`，`buy_threshold`和`sell_threshold`，保存为类变量。`long_mean_periods`变量定义了我们的时间序列价格的重新采样间隔数量，用于计算长期平均价格。请注意，父构造函数中现有的`mean_periods`变量用于计算短期平均价格。`buy_threshold`和`sell_threshold`变量包含确定生成买入或卖出信号的beta边界值。
- en: Writing the trend-following signal generators
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写趋势跟踪信号生成器
- en: 'Because only the decision-making logic needs to be modified from our parent
    `MeanReversionTrader` class, and everything else, including orders, placement,
    and streaming prices, remains the same, we simply override the `generate_signals_and_think()`
    method and implement our new trend-following signal generators using the following
    code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因为只有决策逻辑需要从我们的父类`MeanReversionTrader`类中进行修改，而其他所有内容，包括订单、下单和流动价格，都保持不变，我们只需覆盖`generate_signals_and_think()`方法，并使用以下代码实现我们的新趋势跟踪信号生成器：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As before, on every invocation of the `generate_signals_and_think()` method,
    we resample prices at fixed intervals, defined by `resample_interval`. The minimum
    intervals required for the calculation of signals is now defined by `long_mean_periods`
    instead of `mean_periods`. The `mean_short` variable refers to the short-term
    average resampled price, and the `mean_long` variable refers to the long-term
    average resampled price.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，在每次调用`generate_signals_and_think()`方法时，我们以`resample_interval`定义的固定间隔重新采样价格。现在，用于计算信号的最小间隔由`long_mean_periods`而不是`mean_periods`定义。`mean_short`变量指的是短期平均重新采样价格，`mean_long`变量指的是长期平均重新采样价格。
- en: The `beta` variable is the ratio of the short-term average price to the long-term
    average price. When the beta rises above the `buy_threshold` value, a buy signal
    is generated and the `is_signal_buy` variable is `True`. Likewise, when the beta
    falls below the `sell_threshold` value, a sell signal is generated and the `is_signal_sell` variable
    is `True`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`beta`变量是短期平均价格与长期平均价格的比率。当beta上升到`buy_threshold`值以上时，将生成买入信号，并且`is_signal_buy`变量为`True`。同样，当beta跌破`sell_threshold`值时，将生成卖出信号，并且`is_signal_sell`变量为`True`。'
- en: The trading parameters are printed to the console for debugging purposes, and
    the call to the parent `think()` class method triggers the usual logic of buying
    and selling with market orders.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 交易参数被打印到控制台以进行调试，并且对父类`think()`类方法的调用会触发使用市价订单进行买入和卖出的通常逻辑。
- en: Running the trend-following trading system
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行趋势跟踪交易系统
- en: 'Let''s start our trend-following trading system by instantiating the `TrendFollowingTrader`
    class and running it using the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实例化`TrendFollowingTrader`类并使用以下代码运行我们的趋势跟踪交易系统：
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first parameter, `broker`, is the same object created for our broker in
    the previous section. Again, we are resampling our time series prices at one-minute
    intervals, and we are interested in trading the EUR/USD currency pair, entering
    into a position of at most one unit at any given time. With a `mean_periods` value
    of `5`, we are interested in taking the most recent five resampled intervals in
    calculating the average price of the past five minutes as our short-term average
    price. With a `long_mean_period` of `10`, we are interested in taking the most
    recent 10 resampled intervals in calculating the average price of the past 10 minutes
    as our long-term average price.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`broker`与上一节中为我们的经纪人创建的对象相同。同样，我们以一分钟间隔重新取样我们的时间序列价格，并且我们对交易EUR/USD货币对感兴趣，在任何给定时间最多进入一单位的头寸。使用`mean_periods`值为`5`，我们对最近的五个重新取样间隔感兴趣，以计算过去五分钟的平均价格作为我们的短期平均价格。使用`long_mean_period`值为`10`，我们对最近的10个重新取样间隔感兴趣，以计算过去10分钟的平均价格作为我们的长期平均价格。
- en: The ratio of the short-term average price to the long-term average price is
    taken as the beta. When the beta rises above the value defined by `buy_threshold`,
    a buy signal is generated. When the beta falls below the value defined by `sell_threshold`,
    a sell signal is generated.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 短期平均价格与长期平均价格的比率被视为贝塔。当贝塔上升到超过“buy_threshold”定义的值时，将生成买入信号。当贝塔下降到低于“sell_threshold”定义的值时，将生成卖出信号。
- en: 'With our trading parameters set up, the `run()` method is called to start the
    trading system. We should see an output on the console that is similar to the
    following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好交易参数后，调用`run()`方法启动交易系统。我们应该在控制台上看到类似以下的输出：
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: At the start of trading, we obtained the current market prices, staying in a
    flat position with neither profits nor losses. There is insufficient data available
    to make any trading decisions, and we will have to wait 10 minutes before we can
    see the calculated parameters take effect.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在交易开始时，我们获得了当前市场价格，保持平仓状态，既没有盈利也没有损失。没有足够的数据可用于做出任何交易决策，我们将不得不等待10分钟，然后才能看到计算参数生效。
- en: If your trading system depends on a longer period of past data and you do not
    wish to wait for all this data to be collected, consider bootstrapping your trading
    system with historical data.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的交易系统依赖于更长时间的过去数据，并且不希望等待所有这些数据被收集，考虑使用历史数据对您的交易系统进行引导。
- en: 'After a while, you should see an output that is similar to the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 过一段时间后，您应该会看到类似以下的输出：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Let the system run on its own for awhile, and it should be able to close out
    positions on its own. To stop trading, terminate the running process with *Ctrl*
    + *Z*, or something similar. Remember to manually close out any remaining trading
    positions once the program stops running. Take steps to change your trading parameters
    and decision logic to make your trading system a profitable one!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让系统自行运行一段时间，它应该能够自行平仓。要停止交易，请使用*Ctrl* + *Z*或类似的方法终止运行进程。记得在程序停止运行后手动平仓任何剩余的交易头寸。采取措施改变您的交易参数和决策逻辑，使您的交易系统成为盈利性的！
- en: Note that the author is not responsible for any outcomes of your trading system!
    In a live trading environment, it takes more control parameters, order management,
    and position tracking to manage your risk effectively.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，作者对您的交易系统的任何结果概不负责！在实时交易环境中，需要更多的控制参数、订单管理和头寸跟踪来有效管理风险。
- en: In the next section, we will discuss a risk management strategy that we can
    apply to our trading plans.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将讨论一个可以应用于我们交易计划的风险管理策略。
- en: VaR for risk management
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VaR用于风险管理
- en: As soon as we open a position in the market, we are exposed to various types
    of risks, such as volatility risk and credit risk. To preserve our trading capital
    as much as possible, it is important to incorporate some form of risk management
    measures to our trading system.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在市场上开仓，就会面临各种风险，如波动风险和信用风险。为了尽可能保护我们的交易资本，将风险管理措施纳入我们的交易系统是非常重要的。
- en: Perhaps the most common measure of risk used in the financial industry is the
    VaR technique. It is designed to simply answer the following question: *What is
    the worst expected amount of loss, given a specific probability level, say 95%,
    over a certain period of time?* The beauty of VaR is that it can be applied to
    multiple levels, from position-specific micro-level to portfolio-based macro-level.
    For example, a VaR of $1 million with a 95% confidence level for a 1-day time
    horizon states that, on average, only 1 day out of 20 could you expect to lose
    more than $1 million due to market movements.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 也许金融行业中最常用的风险度量是VaR技术。它旨在简单回答以下问题：*在特定概率水平（例如95%）和一定时间段内，预期的最坏损失金额是多少？* VaR的美妙之处在于它可以应用于多个层次，从特定头寸的微观层面到基于组合的宏观层面。例如，对于1天的时间范围，95%的置信水平下的100万美元VaR表明，平均而言，你只有20天中的1天可能会因市场波动而损失超过100万美元。
- en: 'The following diagram illustrates a normally distributed portfolio returns
    with a mean of 0%, where VaR is the loss corresponding to the 95th percentile
    of the distribution of portfolio returns:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了一个均值为0%的正态分布组合收益率，VaR是分布中第95百分位数对应的损失：
- en: '![](Images/467de0d4-9a4e-4bb6-9de3-575a4c3515a2.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/467de0d4-9a4e-4bb6-9de3-575a4c3515a2.png)'
- en: 'Suppose that we have $100 million under management at a fund claiming to have
    the same risk as an S&P 500 index fund, with an expected return of 9% and a standard
    deviation of 20%. To calculate the daily VaR at the 5% risk level or 95% confidence
    level using the variance-covariance method, we will use the following formulas:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在一家声称具有与标普500指数基金相同风险的基金中管理了1亿美元，预期收益率为9%，标准偏差为20%。使用方差-协方差方法计算5%风险水平或95%置信水平下的每日VaR，我们将使用以下公式：
- en: '![](Images/aa4ac48a-9c35-4eb0-a1a2-9c96d4ad6015.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/aa4ac48a-9c35-4eb0-a1a2-9c96d4ad6015.png)'
- en: '![](Images/170e85cd-3453-44fd-ae6a-9f3c5eeb9f53.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/170e85cd-3453-44fd-ae6a-9f3c5eeb9f53.png)'
- en: '![](Images/d9180d47-0c28-42d6-82d3-2079ac546b80.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d9180d47-0c28-42d6-82d3-2079ac546b80.png)'
- en: Here, *P* is the value of the portfolio, and *N^(−1)(α,u,σ)* is the inverse
    normal probability distribution with a risk level of *α*, a mean of *u*, a and
    standard deviation of *σ*. The number of trading days per year is assumed to be
    252\. It turns out that the daily VaR at the 5% level is $2,036,606.50.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*P*是投资组合的价值，*N^(−1)(α,u,σ)*是具有风险水平*α*、平均值*u*和标准差*σ*的逆正态概率分布。每年的交易日数假定为252天。结果表明，5%水平的每日VaR为$2,036,606.50。
- en: However, the use of VaR is not without its flaws. It does not take into account
    the probability of the loss for extreme events happening on the far ends of the
    tails on the normal distribution curve. The magnitude of the loss beyond a certain
    VaR level is difficult to estimate as well. The VaR that we investigated uses
    historical data and an assumed constant volatility level – such measures are not
    indicative of our future performance.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，VaR的使用并非没有缺陷。它没有考虑正态分布曲线尾端发生极端事件的损失概率。超过一定VaR水平的损失规模也很难估计。我们调查的VaR使用历史数据和假定的恒定波动率水平
    - 这些指标并不代表我们未来的表现。
- en: 'Let''s take a practical approach to calculate the daily VaR of stock prices;
    we will investigate the AAPL stock prices by downloading from a data source:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们采取一种实际的方法来计算股票价格的每日VaR；我们将通过从数据源下载AAPL股票价格来调查：
- en: '[PRE45]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The dataset will be downloaded to the `df` variable as a pandas DataFrame:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集将作为pandas DataFrame下载到`df`变量中：
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This gives us the following output:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '[PRE47]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Our DataFrame contains eight columns, with prices starting from the year 1998
    to the present trading day. The column of interest is the adjusted closing prices.
    Suppose that we are interested in calculating the daily VaR of 2017; let''s obtain
    this dataset using the following code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的DataFrame包含八列，价格从1998年开始到现在的交易日。感兴趣的列是调整后的收盘价。假设我们有兴趣计算2017年的每日VaR；让我们使用以下代码获取这个数据集：
- en: '[PRE48]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `prices` variable contains our AAPL dataset for 2017.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`prices`变量包含了我们2017年的AAPL数据集。'
- en: 'Using the formulas discussed earlier, you can implement the `calculate_daily_var()`
    function using the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面讨论的公式，您可以使用以下代码实现`calculate_daily_var()`函数：
- en: '[PRE49]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Let''s assume that we are holding $100 million of AAPL stock, and we are interested
    in finding the daily VaR at the 95% confidence level. We can define the VaR parameters
    using the following code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们持有$100百万的AAPL股票，并且有兴趣找到95%置信水平下的每日VaR。我们可以使用以下代码定义VaR参数：
- en: '[PRE50]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `mu` and `sigma` variables represent the daily mean percentage returns and
    the daily standard deviation of returns respectively.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`mu`和`sigma`变量分别代表每日平均百分比收益和每日收益的标准差。'
- en: 'We can obtain the VaR by calling the `calculate_daily_var()` function, as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`calculate_daily_var()`函数获得VaR，如下所示：
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We will get the following output:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE52]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Assuming 252 trading days per year, the daily VaR of 2017 for the stock AAPL
    with 95% confidence is $114,248.72.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 假设每年有252个交易日，2017年AAPL股票的每日VaR在95%的置信水平下为$114,248.72。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we were introduced to the evolution of trading from the pits
    to the electronic trading platform, and learned how algorithmic trading came about.
    We looked at some brokers offering API access to their trading service offering.
    To help us get started on our journey of developing an algorithmic trading system,
    we used the Oanda `v20` library to implement a mean-reversion trading system.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了交易从交易场到电子交易平台的演变，并了解了算法交易的产生过程。我们看了一些经纪人提供API访问其交易服务。为了帮助我们开始开发算法交易系统，我们使用Oanda
    `v20`库来实现一个均值回归交易系统。
- en: In designing an event-driven broker interface class, we defined event handlers
    for listening to orders, prices, and position updates. Child classes inheriting
    the `Broker` class simply extend this interface class with broker-specific functions,
    while still keeping the underlying trading functions compatible with our trading
    system. We successfully tested the connection with our broker by getting market
    prices, sending a market order, and receiving position updates.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计一个事件驱动的经纪人接口类时，我们为监听订单、价格和持仓更新定义了事件处理程序。继承`Broker`类的子类只需用经纪人特定的函数扩展这个接口类，同时保持底层交易函数与我们的交易系统兼容。我们通过获取市场价格、发送市价订单和接收持仓更新成功测试了与我们经纪人的连接。
- en: We discussed the design of a simple mean-reversion trading system that generates
    buy or sell signals based the movements of historical average prices, and opening
    and closing out our positions with market orders. Since this trading system uses
    only one source of trading logic, more work will be required to build a robust,
    reliable, and profitable trading system.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了一个简单的均值回归交易系统的设计，该系统根据历史平均价格的波动以及开仓和平仓市价订单来生成买入或卖出信号。由于这个交易系统只使用了一个交易逻辑来源，因此需要更多的工作来构建一个健壮、可靠和盈利的交易系统。
- en: We also discussed the design of a trend-following trading system that generates
    buy or sell signals based on the movements of a short-term average price against
    a long-term average price. With a well-designed system, we saw how easy it was
    to make a modification to the existing trading logic by simply extending the mean-reversion
    parent class and overriding the decision-making method.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了一个趋势跟随交易系统的设计，该系统根据短期平均价格与长期平均价格的波动来生成买入或卖出信号。通过一个设计良好的系统，我们看到了通过简单地扩展均值回归父类并覆盖决策方法来修改现有交易逻辑是多么容易。
- en: One critical aspect of trading is to manage risk effectively. In the financial
    industry, VaR is the most common technique used to measure risk. Using Python,
    we took a practical approach to calculate the daily VaR of past datasets on AAPL.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 交易的一个关键方面是有效地管理风险。在金融行业，VaR是用来衡量风险的最常见的技术。使用Python，我们采取了一种实际的方法来计算AAPL过去数据集的每日VaR。
- en: Once we have built a working algorithmic trading system, we can explore the
    other ways to measure the performance of our trading strategy. One of these areas
    is backtesting; we will discuss this topic in the next chapter.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了一个有效的算法交易系统，我们可以探索其他衡量交易策略表现的方式。其中之一是回测；我们将在下一章讨论这个话题。
