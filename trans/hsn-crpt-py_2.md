# 哈希

哈希有两个主要目的：第一个是在文件上放置一个指纹，以便您可以判断它是否已被更改，第二个是隐藏密码，以便您仍然可以识别正确的密码并启用登录，但是窃取哈希的人不能轻松地从中恢复密码。

在本章中，我们将涵盖以下主题：

+   MD5和SHA哈希

+   Windows密码哈希

+   Linux密码哈希

+   挑战1 - 破解Windows哈希

+   挑战2 - 破解多轮哈希

+   挑战3 - 破解Linux哈希

# MD5和SHA哈希

在解释哈希函数是什么之后，我们将处理MD5，然后是SHA系列：SHA-1，SHA-2和SHA-3。我们还将获取一些关于破解哈希的信息。

# 哈希是什么？

如前所述，使用哈希的一个目的是在文件上放置一个指纹。您可以使用哈希算法将文件中的所有字节组合在一起，从而创建一个固定的哈希值。如果更改文件的任何部分并重新计算哈希，则会得到完全不同的值。因此，如果您有两个应该相同的文件，您可以计算每个文件的哈希值，如果两个文件的哈希值匹配，则文件相同。

一个非常常见的哈希是MD5；它已经存在了几十年。它的长度为128位，对于哈希函数来说相当短，对于大多数目的来说足够可靠。人们用它来对下载和恶意软件样本等进行指纹识别，有时也用于隐藏密码。它不是一个完美的哈希函数：已知有一些碰撞，并且有一些算法可以在一些计算时间的代价下创建碰撞，这些碰撞是哈希到相同值的文件对。因此，如果您找到两个具有匹配MD5的文件，您并不完全确定它们是相同的文件，但它们通常是。

在Python中计算它们非常容易。您只需导入哈希库，然后进行计算。您调用哈希库来创建一个新对象。第一个参数是使用的算法，即MD5。第二个参数是要进行哈希处理的数据的内容。

在这里，我们将使用`HELLO`作为示例，然后您需要在末尾使用十六进制摘要，否则它将只打印数据结构的地址，而不是显示实际值。我们将使用`HELLO`的哈希，MD5和十六进制，它有128位长。因此，这是128除以4，或32个十六进制字符，如果您向`HELLO`添加另一个字符，比如感叹号，哈希将完全改变；一个值的哈希与下一个值的哈希之间没有任何相似之处。

**安全哈希算法**（**SHA**）旨在改进MD5，直到大约一年前，SHA-1没有发生碰撞，当时一些谷歌公司的研究人员发现了如何在SHA-1中发生碰撞，因此谨慎的人们正在转向SHA-2。还有另一个由**国家标准技术研究所**批准的算法，称为**SHA-3**，几乎没有人使用，因为据所有人的预期，SHA-2将在很长一段时间内保持安全。但是，如果发生了危及SHA-2的情况，SHA-3将可供我们使用。SHA-2和SHA-3都有各种长度，但最常见的长度是256和512位。

您可以在Python中轻松计算SHA-1和SHA-2哈希，但SHA-3并不常用，它还不是这个哈希库的一部分。因此，如果您使用SHA-1算法，您将得到一个SHA-1哈希。它看起来像MD5哈希，但更长。然后有SHA-256和SHA-512，它们都是SHA-2哈希。您可以看到，尽管它们更安全，但它们更长，而且有些不太方便：

![](../images/00043.jpeg)

所以，让我们来看看。

打开终端并执行`python`命令以启动Python终端：

![](../images/00044.jpeg)

然后，您可以运行以下命令：

![](../images/00045.jpeg)

您必须导入`hashlib`。然后，您可以添加`hashlib.new`。第一个参数是算法，这种情况下是`md5`。下一个参数是要进行哈希的数据，这里是`HELLO`，然后添加`hexdigest`以查看十六进制值。所以，这是`HELLO`的哈希，如果我们在末尾添加另一个字符，使其变成`HELLOa`，那么我们会得到一个完全不同的答案。

![](../images/00046.jpeg)

如果我们想使用不同的算法，我们只需输入SHA-1：

![](../images/00047.jpeg)

现在我们得到了一个很长的哈希值，如果我们添加`sha256`作为字符，我们会得到一个更长的哈希值：

![](../images/00048.jpeg)

这些哈希对于几乎任何目的都足够了。

如果您有某物的哈希值，并且想要计算它来自哪些数据，原则上，这并没有唯一的解决方案。不过，在实践中，对于像密码这样的短对象，是有的。因此，如果有人使用`MD5`函数来隐藏密码，这是一些旧的Web应用程序所做的，那么您可以通过猜测密码来反转它，直到找到匹配项。没有数学方法可以撤消哈希函数，因此您只需制作一个库。在`MD5`哈希`HELLO`的示例中，如果您只是进行一系列猜测，您将得到正确的答案。这就是哈希破解的工作原理；这不是一个复杂的想法，只是有点不方便。

我们可以获取`HELLO`的MD5哈希并继续猜测：

![](../images/00049.jpeg)

如果我们在猜测单词，可能需要猜测数百万个单词才能得到所示的值，但是如果我们能够猜到正确的值，当哈希值匹配时，我们就知道它是正确的。这个的难度取决于您每秒可以计算多少个哈希值，而MD5和SHA系列都设计为非常快速计算，因此您实际上可以尝试数百万个密码。在下一节中，我们将讨论Windows密码哈希。

# Windows密码哈希

在本节中，我们将看到如何使用Cain获取哈希，然后了解MD4和Unicode的工作原理。然后，我们将讨论如何使用Google破解哈希和如何使用单词列表破解哈希。

# 使用Cain获取哈希

Cain是一个免费的黑客工具，可以从正在运行的操作系统中收集Windows哈希。为了测试它，我们将在Windows Server上创建三个帐户，这是Windows操作系统的最新版本。您可以使用命令提示符中的用户命令来执行此操作。您可以添加一个名为`John`的用户，密码为`P@sw0rd`，一个名为`Paul`的用户，密码为`P@sw0rd`，以及一个名为`Ringo`的用户，密码为`P@sw0rd999`：

![](../images/00050.jpeg)

如果运行Cain，它可以收集哈希。以下屏幕截图显示了三个用户及其哈希值：

![](../images/00051.jpeg)

LM Hash部分是一个已经不再被任何Windows版本使用的过时系统，因此它只包含一个没有信息的虚拟值。当您登录时Windows实际使用的哈希称为NT Hash。请注意，如果两个用户使用相同的密码，它们将具有完全相同的哈希值：`464`值。这是该系统的一个弱点。不幸的是，这是一个非常薄弱且陈旧的密码系统。

# MD4和Unicode

这是Microsoft使用的算法。它将密码编码为Unicode而不是ASCII，然后当您通过MD4运行它（这是一个非常古老的算法，甚至比MD5还要古老），它会产生NT哈希值：

![](../images/00052.jpeg)

使用Unicode的原因是因为Microsoft是一个国际操作系统，允许您使用中文和日文等语言的密码，这些语言不是每个字符使用8位编码，而是每个字符使用16位编码。

# 使用Google破解哈希

由于密码哈希没有变化，任何两个具有相同密码的用户将具有相同的哈希，过去24年来已经破解了单词列表的所有黑客都将他们的结果放在了互联网上，导致了这样一种情况：你可以直接谷歌经常使用的密码哈希：

![](../images/00053.jpeg)

如果你只是把一个哈希放到谷歌上，你经常会发现有人已经为你破解了并放在了互联网上。例如，这里有一个`P@sw0rd`，已经有一个已知的结果，所以你可以破解它。这种简单的方法适用于很多密码，但这种技术对于我们用于用户`Ringo`的密码`P@sw0rd999`不起作用。

# 使用单词列表破解哈希

因此，在密码无法破解的情况下，你需要自己计算：

![](../images/00054.jpeg)

你只需使用相同的过程。进行一系列的猜测，对它们进行哈希，然后寻找你的答案。如果你的猜测列表最终达到正确的值，你当然会在这里找到它。因此，你可以看到密码`P@sw0rd999`的`5c2c...`。

这很简单，所以让我们在Python中试一试。

在终端窗口中，我们将输入`python`命令。接下来我们将导入`hashlib`库：

![](../images/00055.jpeg)

因此，你可以看到进行编码的行。我们输入密码，编码为`utf-16le`，这是Unicode；然后，我们用MD4进行哈希，并将其表示为`hexdigest`。

这是`P@sw0rd`的数字。现在，如果我们尝试访问`Ringo`用户，我们需要有一个包含两个哈希值的列表，这些值最终需要达到正确的值：

![](../images/00056.jpeg)

如果我们只是按顺序使用`997`，`998`和`999`进行计数，我们将得到我们正在寻找的`5c2c...`值。

# Linux密码哈希

在本节中，我们将首先讨论如何从操作系统中获取哈希值，然后看看加盐和拉伸过程是如何使Linux哈希值更加安全的。然后我们将讨论现代版本的Linux使用的特定哈希算法，最后看看如何使用单词列表和Python破解哈希。

在这里，我们创建了三个用户来测试软件，方式与我们之前在Windows上做的方式类似。`John`和`Paul`有相同的密码，而`Ringo`有不同的密码：

![](../images/00057.jpeg)

你可以从`/etc/shadow`文件中获取哈希值，从中我们将打印出最后三条记录。因此，你会看到`John`，`Paul`和`Ringo`，每个用户名后面都跟着`$6`，这表明它是密码的第6种类型，这是最现代和安全的形式。然后是一长串随机字符，直到下一个美元符号，然后是一个更长的随机字符串，这就是密码哈希本身。

你可以看到的第一件事是密码哈希，它比Windows密码哈希要长得多，更复杂。接下来要观察的是，即使`John`和`Paul`有相同的密码，它们的哈希完全不同，因为在对它们进行哈希之前，它们会添加一个随机的`salt`，以掩盖这些密码是相同的事实，从而使密码更加安全。加盐是在进行哈希之前添加随机字符的过程；这里也使用了拉伸。它不仅仅使用一轮MD4，而是使用了5000轮SHA-512，这简单地使得计算哈希需要更多的CPU时间。这样做的目的是减缓试图制作密码哈希字典的攻击者的速度。

你可以在`/etc/login.defs`文件中找到该方法的详细信息，该文件显示现代版本的Linux使用`SHA512`和`5000`轮的加密方法：

![](../images/00058.jpeg)

因此，该过程要求你将`salt`与密码结合起来。你执行一个包括5000轮SHA-512哈希的算法。它实际上有超过20个步骤，涉及将两个哈希值放在一起并混合位，但它比仅仅重复相同的哈希算法要复杂一些。

我们将使用`passlive`库。在Python中使用它之前，你必须使用`pip install passlib`命令进行安装。一旦你安装好了，你就可以导入`sha512_crypt`模块。以下是你如何使用它：

![](../images/00059.jpeg)

让我们开始Python终端。然后我们可以像之前展示的那样导入`passlib`库，因为我们已经将其放入`pip install`中。

现在，我们可以计算第一个，它将使用影子文件中的`salt`值并对其进行哈希，如前面的屏幕截图所示。

正如你所看到的，我们得到了正确的结果（以`r7k`开头）。如果我们进行字典攻击，我们将得到一系列密码猜测，如下所示：

![](../images/00060.jpeg)

只需尝试它们，直到找到与之匹配的那个。

# 挑战1 – 破解Windows哈希

在对Windows哈希进行审查和进行1位数哈希的示例之后，我们将给你两个挑战——一个是2位数密码，另一个是7位数密码。以下是Python中Windows哈希的样子：

![](../images/00061.jpeg)

该算法使用`hashlib`对密码的哈希进行MD4，但在此之前，将其编码为`utf-16le`，然后计算结果的`hexdigest`以获得长数字，该数字以`464`开头，在这种情况下，这是一个Windows密码哈希。

因此，你可以编写一个程序，尝试这个字符串中的所有字符，它将由10个数字组成，然后计算每个字符的哈希。你将得到一个简单的包含10个值的字典：

![](../images/00062.jpeg)

你可以使用一个1位数密码来破解这个1位数哈希，方法如下：

![](../images/00063.jpeg)

因此，这是一个挑战。密码是00到99之间的2位数，这是哈希：

![](../images/00064.jpeg)

因此，你需要创建一个循环，尝试100个可能的值。

接下来是一个7位数密码，这是哈希：

![](../images/00065.jpeg)

因此，你将不得不尝试1000万个值。这只需要几秒钟，这就是为什么Windows密码哈希非常薄弱——你可以每秒尝试数百万个。

# 挑战2 – 破解多轮哈希

在审查了Python中MD5和SHA的工作原理之后，我们将看到多轮哈希是什么，然后你将得到两个挑战来解决。

MD5和SHA都很容易计算：

![](../images/00066.jpeg)

从`hashlib`库中，你只需要使用`hashlib.new`方法，并将算法的名称放在第一个参数中，密码放在第二个参数中，然后将十六进制摘要添加到其中，以便看到十六进制的实际结果，而不仅仅是对象的地址。要进行多轮，你只需重复该过程。

你需要将密码放入`h`，然后使用当前的`h`来计算下一个`h`，并一遍又一遍地重复这个过程。以下是一个打印多轮MD5哈希的前10轮的小脚本：

![](../images/00067.jpeg)

这种技术称为**拉伸**，它被更强大的密码哈希例程所使用，比如我们在前面部分看到的Linux密码哈希。

这是你的第一个挑战：一个3位数密码使用MD5哈希100次。从这个哈希中找到它：

![](../images/00068.jpeg)

这里还有一个挑战。在这个挑战中，你有一个未知轮数的SHA-1，但不超过5000。因此，你只需尝试所有值，并从这个哈希中找到结果的3位数密码。

# 挑战3 – 破解Linux哈希

在审查了Linux哈希之后，我们将向你展示你的挑战。

Linux哈希是经过盐处理和拉伸的，有各种版本。我们正在讨论当前版本，即版本6，也就是最安全的形式：

![](../images/00069.jpeg)

哈希是以美元符号开头的长字符串；`6`表示版本，然后是一个美元符号，后面跟着`salt`，再加一个美元符号，后面是哈希。要在Python中计算它们，您需要导入一个特殊的SHA-512 `crypt`库，就像您之前看到的格式一样。

这是您的第三个挑战：以这种格式的3位密码。`salt`值为`penguins`，`hash`是以`P`开头的一长串混乱字符。

# 摘要

在本章中，我们介绍了MD5和SHA-1哈希算法，Windows密码哈希算法和Linux密码哈希算法。在挑战中，您破解了一个Windows密码哈希以恢复明文密码，以及使用未知数量的MD5和SHA-1轮次破解了另一个密码哈希。最后，您破解了Linux密码哈希以恢复明文密码。

在[第3章](part0048.html#1DOR00-6963dc2081804897894c8854b7cc74fd)，*强加密*中，我们将介绍两种主要的强加密方法，即AES和RSA。
