- en: Creating Basic Forms with Tkinter and ttk Widgets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tkinter和ttk小部件创建基本表单
- en: Good news! Your design has been reviewed and approved by the director. Now it's
    time to start implementing it!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息！您的设计已经得到主管的审查和批准。现在是时候开始实施了！
- en: 'In this chapter, you''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将涵盖以下主题：
- en: Evaluating your technology choices in light of the design
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据设计评估您的技术选择
- en: Getting to know our selected Tkinter and `ttk` widgets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解我们选择的Tkinter和`ttk`小部件
- en: Implementing and testing the form and application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和测试表单和应用程序
- en: Let's get coding!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编码吧！
- en: Evaluating our technology choices
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估我们的技术选择
- en: Our first implementation of the design will be a very simple application that
    delivers the core functionality of the specification and little else. This is
    known as a **minimum viable product** or **MVP**. Once we've established an MVP,
    we'll have a better understanding of how to develop it into a final product.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对设计的第一次实现将是一个非常简单的应用程序，它提供了规范的核心功能和很少的其他功能。这被称为**最小可行产品**或**MVP**。一旦我们建立了MVP，我们将更好地了解如何将其发展成最终产品。
- en: Before we get to that, let's take a moment to evaluate our technology choices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们花点时间评估我们的技术选择。
- en: Choosing a technology
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择技术
- en: 'Naturally, we''re going to build this form using Python and Tkinter. However,
    it''s worth asking whether Tkinter is really a good choice of technology for the
    application. We need to take the following things into consideration when choosing
    the GUI toolkit used to implement this form:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们将使用Python和Tkinter构建这个表单。然而，值得问一下，Tkinter是否真的是应用程序的良好技术选择。在选择用于实现此表单的GUI工具包时，我们需要考虑以下几点：
- en: '**Your current expertise and knowledge**: Your expertise is in Python, but
    you have little experience in creating GUIs. For the fastest time to deliver,
    you need an option that works well with Python and isn''t complicated to learn.
    You also want something established and stable, as you won''t have time to keep
    up with new developments in the toolkit. Tkinter works here.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**您目前的专业知识和技能**：您的专业是Python，但在创建GUI方面经验不足。为了最快的交付时间，您需要一个能够很好地与Python配合使用并且不难学习的选项。您还希望选择一些已经建立并且稳定的东西，因为您没有时间跟上工具包的新发展。Tkinter在这里适用。'
- en: '**The target platforms**: You will be developing the application on a Windows
    PC, but it will need to run on Debian Linux, so the choice of GUI should be cross-platform.
    The computer it will run on is old and slow, so your program needs to be frugal
    with resources. Tkinter also works here.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标平台**：您将在Windows PC上开发应用程序，但它需要在Debian Linux上运行，因此GUI的选择应该是跨平台的。它将在一台又老又慢的计算机上运行，因此您的程序需要节约资源。Tkinter在这里也适用。'
- en: '**Application functionality**: Your application needs to be able to display
    basic form fields, validate the data entered, and write it to CSV. Tkinter can
    handle these frontend requirements, and Python can handle the CSV file easily.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用功能**：您的应用程序需要能够显示基本表单字段，验证输入的数据，并将其写入CSV。Tkinter可以处理这些前端要求，Python可以轻松处理CSV文件。'
- en: Given the options available for Python, Tkinter is a good choice. It's got a
    short learning curve, it's lightweight, it's readily available on both your development
    and target platforms, and it contains the functionality necessary for the form.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于Python的可用选项，Tkinter是一个不错的选择。它学习曲线短，轻量级，在您的开发和目标平台上都很容易获得，并且包含了表单所需的功能。
- en: Python has other options for GUI development, including **PyQT**, **Kivy**,
    and **wxPython**. These have different strengths and weaknesses compared to Tkinter,
    but if you find Tkinter doesn't fit well for a project, one of these might be
    a better option.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python还有其他用于GUI开发的选项，包括**PyQT**、**Kivy**和**wxPython**。与Tkinter相比，它们各自有不同的优势和劣势，但如果发现Tkinter不适合某个项目，其中一个可能是更好的选择。
- en: Exploring Tkinter widgets
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Tkinter小部件
- en: When we designed our application, we picked out a widget class that most closely
    matched each field we needed. These were the `Entry`, `Spinbox`, `Combobox`, `Checkbutton`,
    and `Text` widgets. We also determined that we'd need the `Button` and `LabelFrame` widgets
    to implement the application layout. Before we start writing our class, let's
    take a look at each of these widgets.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计应用程序时，我们挑选了一个小部件类，它最接近我们需要的每个字段。这些是`Entry`、`Spinbox`、`Combobox`、`Checkbutton`和`Text`小部件。我们还确定我们需要`Button`和`LabelFrame`小部件来实现应用程序布局。在我们开始编写我们的类之前，让我们来看看这些小部件。
- en: Some of our widgets are in Tkinter, others are in the `ttk` themed widget set,
    and a few are in both libraries. We prefer the `ttk` versions wherever they exist,
    since they look better across platforms. Pay careful attention to the library
    from which we import each widget.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一些小部件在Tkinter中，另一些在`ttk`主题小部件集中，还有一些在两个库中都有。我们更喜欢`ttk`版本，因为它们在各个平台上看起来更好。请注意我们从哪个库导入每个小部件。
- en: The Entry widget
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入小部件
- en: 'The `ttk.Entry` widget is a basic, one-line character entry, as shown in the
    following screenshot:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`ttk.Entry`小部件是一个基本的、单行字符输入，如下截图所示：'
- en: '![](assets/93ab1723-3880-43fe-8866-779aeb33dd64.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/93ab1723-3880-43fe-8866-779aeb33dd64.png)'
- en: 'You can create an entry by executing the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行以下代码来创建一个输入：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, the commonly used arguments to `ttk.Entry` are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`ttk.Entry`的常用参数如下：
- en: '`parent`: This argument sets the `parent` widget for the entry.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`：此参数为输入设置了`parent`小部件。'
- en: '`textvariable`: This is a Tkinter `StringVar` variable whose value will be
    bound to this `input` widget.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textvariable`：这是一个Tkinter `StringVar`变量，其值将绑定到此`input`小部件。'
- en: '`show`: This argument determines which character will be displayed when you
    type into the box. By default, it''s the character you type, but this can be replaced
    (for example, for password entry you might specify `*` or dot to be shown instead).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show`：此参数确定在您输入框中键入时将显示哪个字符。默认情况下，它是您键入的字符，但这可以被替换（例如，对于密码输入，您可以指定`*`或点来代替显示）。'
- en: '`Entry`: This widget, like all the `ttk` widgets, supports additional formatting
    and styling options.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Entry`：像所有的`ttk`小部件一样，此小部件支持额外的格式和样式选项。'
- en: Among all the preceding arguments, use of the `textvariable` argument is optional;
    without it, we can extract the value in the `Entry` widget, using its `get()`
    method. Binding a variable to our `input` widget has some advantages, however.
    First, we don't have to keep or pass around a reference to the widget itself.
    This will make it easier to reorganize our software into separate modules in later
    chapters. Also, changes to the value of the input are automatically propagated
    to the variable and vice versa.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有上述参数中，使用“textvariable”参数是可选的；没有它，我们可以使用其“get()”方法提取“Entry”小部件中的值。然而，将变量绑定到我们的“input”小部件具有一些优势。首先，我们不必保留或传递对小部件本身的引用。这将使得在后面的章节中更容易将我们的软件重新组织为单独的模块。此外，对输入值的更改会自动传播到变量，反之亦然。
- en: The Spinbox widget
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spinbox小部件
- en: The `ttk.Spinbox` widget adds increment and decrement buttons to a regular `Entry` widget,
    making it suitable for numerical data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: “ttk.Spinbox”小部件向常规“Entry”小部件添加了增量和减量按钮，使其适用于数字数据。
- en: Prior to Python 3.7, `Spinbox` was only available in Tkinter, not `ttk`. If
    you're using Python 3.6 or an older version, use the `Tkinter.Spinbox` widget
    instead. The sample code uses the Tkinter version for compatibility.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.7之前，“Spinbox”只在Tkinter中可用，而不是在`ttk`中。如果您使用的是Python 3.6或更早版本，请改用`Tkinter.Spinbox`小部件。示例代码使用了Tkinter版本以确保兼容性。
- en: 'A `Spinbox` widget is created as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建“Spinbox”小部件如下：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As seen in the preceding code, the `Spinbox` widget takes some extra constructor
    arguments to control the increment and decrement button behavior, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，“Spinbox”小部件需要一些额外的构造函数参数来控制增量和减量按钮的行为，如下所示：
- en: '**`from_`**: This argument determines the lowest value to which the arrows
    decrement. The ending underscore is needed because `from` is a Python keyword;
    in Tcl/`Tk` it''s just `from`.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`from_`**：此参数确定箭头递减到的最低值。需要添加下划线，因为“from”是Python关键字；在Tcl/`Tk`中只是“from”。'
- en: '**`to`**: This argument determines the highest value to which the arrows increment.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`to`**：此参数确定箭头递增到的最高值。'
- en: '**`increment`**: This argument represents the amount at which arrows increment
    or decrement.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`increment`**：此参数表示箭头递增或递减的数量。'
- en: '**`values`**: This argument takes a list of string or number values that can
    be incremented through.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`values`**：此参数接受一个可以通过递增的字符串或数字值列表。'
- en: Note that both `from_` and `to` are required if you use either; that is, you
    cannot just specify a lower limit, doing so will either cause an exception or
    strange behavior.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果使用了“from_”和“to”，则两者都是必需的；也就是说，您不能只指定一个下限，这样做将导致异常或奇怪的行为。
- en: 'Take a look at the `Spinbox` widget in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下截图中的“Spinbox”小部件：
- en: '![](assets/0af19ce1-0ba8-4436-9c18-41fe6f315936.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0af19ce1-0ba8-4436-9c18-41fe6f315936.png)'
- en: The `Spinbox` widget is not just for numbers, even though that's primarily how
    we'll be using it. It can also take a list of strings, which can be selected using
    the arrow buttons. Because it can be used for strings or numbers, the `textvariable`
    argument takes the `StringVar`, `IntVar`, or `DoubleVar` data types.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: “Spinbox”小部件不仅仅是用于数字，尽管这主要是我们将要使用它的方式。它也可以接受一个字符串列表，可以使用箭头按钮进行选择。因为它可以用于字符串或数字，所以“textvariable”参数接受`StringVar`、`IntVar`或`DoubleVar`数据类型。
- en: Be aware that none of these parameters actually limit what can be typed into
    a `Spinbox` widget. It's nothing more than an `Entry` widget with buttons tacked
    on, and you can type not only values outside the valid range, but letters and
    symbols as well. Doing so can cause an exception if you've bound the widget to
    a non-string variable.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些参数都不限制可以输入到“Spinbox”小部件中的内容。它只不过是一个带有按钮的“Entry”小部件，您不仅可以输入有效范围之外的值，还可以输入字母和符号。这样做可能会导致异常，如果您已将小部件绑定到非字符串变量。
- en: The Combobox widget
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Combobox小部件
- en: The `ttk.Combobox` argument is an `Entry` widget that adds a drop-down select
    menu. To populate the drop-down menu, simply pass in a `values` argument with
    a list of the strings, which the user can select.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: “ttk.Combobox”参数是一个“Entry”小部件，它添加了一个下拉选择菜单。要填充下拉菜单，只需传入一个带有用户可以选择的字符串列表的“values”参数。
- en: 'You can execute the following code to create a `Combobox` widget:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以执行以下代码来创建一个“Combobox”小部件：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code will generate the following widget:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成以下小部件：
- en: '![](assets/2b06ad94-ddbd-45f4-8a00-fa095da6b4d9.png)If you''re used to HTML
    `<SELECT>` widgets or drop-down widgets in other toolkits, the `ttk.Combobox` widget
    may seem strange to you. It''s really an `Entry` widget with a drop-down menu
    to select some preset strings. Just like the `Spinbox` widget, it doesn''t limit
    the values that can be typed in.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2b06ad94-ddbd-45f4-8a00-fa095da6b4d9.png)如果您习惯于HTML的“<SELECT>”小部件或其他工具包中的下拉小部件，“ttk.Combobox”小部件可能对您来说有些陌生。它实际上是一个带有下拉菜单以选择一些预设字符串的“Entry”小部件。就像“Spinbox”小部件一样，它不限制可以输入的值。'
- en: The Checkbutton widget
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Checkbutton小部件
- en: 'The `ttk.Checkbutton` widget is a labeled checkbox for entering boolean data.
    Unlike `Spinbox` and `Combobox`, it is not derived from the `Entry` widget and
    its arguments are different as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “ttk.Checkbutton”小部件是一个带有标签的复选框，用于输入布尔数据。与“Spinbox”和“Combobox”不同，它不是从“Entry”小部件派生的，其参数如下所示：
- en: '`text`: This argument sets the label for the widget.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`：此参数设置小部件的标签。'
- en: '`variable`: This argument is `BooleanVar`, to which the checked status is bound.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variable`：此参数是`BooleanVar`，绑定了复选框的选中状态。'
- en: '`textvariable`: Unlike the `Entry` based widgets, this argument can be used
    to bind a variable to the label text of the widget. You won''t use this often,
    but you should know it exists in case you mistakenly assign your variable to it.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textvariable`：与基于`Entry`的小部件不同，此参数可用于将变量绑定到小部件的标签文本。您不会经常使用它，但您应该知道它存在，以防您错误地将变量分配给它。'
- en: 'You can execute the following code to create a `Checkbutton` widget:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以执行以下代码来创建一个“Checkbutton”小部件：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Checkbox` widget appears as a clickable box with a label by it, as shown
    in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: “Checkbox”小部件显示为一个带有标签的可点击框，如下截图所示：
- en: '![](assets/8a97f210-253f-438e-afb5-b7f49e04fed9.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8a97f210-253f-438e-afb5-b7f49e04fed9.png)'
- en: The Text widget
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本小部件
- en: The `Text` widget is much more than just a multiline `Entry` widget. It has
    a powerful tagging system that allows you to implement multicolored text, hyperlink-style
    clickable text, and more. Unlike other widgets, it can't be bound to a Tkinter
    `StringVar`, so setting or retrieving its contents needs to be done through its
    `get()`, `insert()`, and `delete()` methods.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: “Text”小部件不仅仅是一个多行“Entry”小部件。它具有强大的标记系统，允许您实现多彩的文本，超链接样式的可点击文本等。与其他小部件不同，它不能绑定到Tkinter的“StringVar”，因此设置或检索其内容需要通过其“get()”、“insert()”和“delete()”方法来完成。
- en: 'When reading or modifying with these methods, you are required to pass in one
    or two **index** values to select the character or range of characters that you''re
    operating on. These index values are strings that can take any of the following
    formats:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这些方法进行读取或修改时，您需要传入一个或两个**索引**值来选择您要操作的字符或字符范围。这些索引值是字符串，可以采用以下任何格式：
- en: The line number and character number separated by a dot. Lines are numbered
    from 1 and characters from 0, so the first character on the first line is `1.0`,
    while the twelfth character on the fourth line would be `4.11`.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由点分隔的行号和字符号。行号从1开始，字符从0开始，因此第一行上的第一个字符是“1.0”，而第四行上的第十二个字符将是“4.11”。
- en: The `end` string or Tkinter constant `END`, indicating the end of the field.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “end”字符串或Tkinter常量“END”，表示字段的结束。
- en: A numerical index plus one of the words `linestart`, `lineend`, `wordstart`,
    and `wordend`, indicating the start or end of the line or word relative to the
    numerical index. For example, `6.2 wordstart` would be the start of the word containing
    the third character on line 6; `2.0 lineend` would be the end of line 2.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字索引加上单词“linestart”、“lineend”、“wordstart”和“wordend”中的一个，表示相对于数字索引的行或单词的开始或结束。例如，“6.2
    wordstart”将是包含第六行第三个字符的单词的开始；“2.0 lineend”将是第二行的结束。
- en: Any of the preceding, a plus or minus operator, and a number of characters or
    lines. For example, `2.5 wordend - 1 chars` would be the character before the
    end of the word containing the sixth character on line 2.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前述任何一个，加上加号或减号运算符，以及一定数量的字符或行。例如，“2.5 wordend - 1 chars”将是第二行第六个字符所在的单词结束前的字符。
- en: 'The following example shows the basics of working with a `Text` widget:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了使用“Text”小部件的基础知识：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you run the preceding code, you''ll get the following output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码，您将获得以下输出：
- en: '![](assets/52c2e54d-1453-4eee-99a0-70c08c082001.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/52c2e54d-1453-4eee-99a0-70c08c082001.png)'
- en: For the `Notes` field in this form, we just need a simple multiline `Entry`;
    so, we'll only be using the most basic functionality of the `Text` widget for
    now.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表单中的“Notes”字段中，我们只需要一个简单的多行“Entry”；所以，我们现在只会使用“Text”小部件的最基本功能。
- en: The Button widget
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按钮小部件
- en: 'The `ttk.Button` widget should also be familiar. It''s just a straightforward
    button that you click with the mouse or spacebar, as shown in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: “ttk.Button”小部件也应该很熟悉。它只是一个可以用鼠标或空格键单击的简单按钮，如下截图所示：
- en: '![](assets/83d80f01-f102-4d59-878d-c674bf8a3d54.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/83d80f01-f102-4d59-878d-c674bf8a3d54.png)'
- en: Just like the `Checkbutton` widget, this widget uses the `text` and `textvariable`
    configuration options to control the label on the button. The `Button` objects
    don't take `variable`, but they do take a `command` argument, which specifies
    a Python function to run when the button is clicked.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 就像“Checkbutton”小部件一样，此小部件使用“text”和“textvariable”配置选项来控制按钮上的标签。`Button`对象不接受`variable`，但它们确实接受`command`参数，该参数指定单击按钮时要运行的Python函数。
- en: 'The following example shows the use of a `Button` object:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了“Button”对象的使用：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The LabelFrame widget
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LabelFrame小部件
- en: We have chosen the `ttk.LabelFrame` widget to group the fields in our application.
    As the name implies, it's `Frame` with `Label` (and a box around it, usually).
    The `LabelFrame` widget takes a `text` argument in the constructor that sets the
    label, positioned in the top-left of the frame.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了“ttk.LabelFrame”小部件来对我们的应用程序中的字段进行分组。顾名思义，它是一个带有标签的`Frame`（通常带有一个框）。`LabelFrame`小部件在构造函数中接受一个`text`参数，用于设置标签，该标签位于框架的左上角。
- en: Tkinter and `ttk` contain many more widgets, some of which we'll encounter later
    in this book. Python also ships with a `widget` library called `tix`, which contains
    several dozen widgets. However, `tix` is very outdated, and we won't be covering
    it in this book. You should know that it exists, though.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter和“ttk”包含许多其他小部件，其中一些我们将在本书的后面遇到。Python还附带了一个名为“tix”的小部件库，其中包含几十个小部件。但是，“tix”已经非常过时，我们不会在本书中涵盖它。不过，您应该知道它的存在。
- en: Implementing the application
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现应用程序
- en: To start our application script, create a folder called `ABQ data entry` and
    a file inside it called `data_entry_app.py`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动我们的应用程序脚本，请创建一个名为“ABQ data entry”的文件夹，并在其中创建一个名为“data_entry_app.py”的文件。
- en: 'We''ll start with the following boilerplate code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从以下样板代码开始：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Running this script should give you a blank Tk window.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本应该会给您一个空白的Tk窗口。
- en: Saving some time with a LabelInput class
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LabelInput类节省一些时间
- en: 'Every `input` widget on our form has a label associated with it. In a small
    application, we can just create the label and input separately, then add each
    to the `parent` frame as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们表单上的每个“input”小部件都有一个与之关联的标签。在一个小应用程序中，我们可以分别创建标签和输入，然后将每个标签添加到“parent”框架中，如下所示：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That works fine and you could do it that way for your application, but it also
    creates a lot of tedious, repetitious code, and moving inputs around means changing
    twice as much code. Since the `label` and `input` widgets belong together, it
    would be smart to create a small wrapper class to contain both and establish some
    universal defaults.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做很好，你可以为你的应用程序这样做，但它也会创建大量乏味、重复的代码，并且移动输入意味着改变两倍的代码。由于`label`和`input`小部件是一起的，创建一个小的包装类来包含它们并建立一些通用默认值会很聪明。
- en: When coding, be on the lookout for sections that contain a lot of repetitive
    code. You can often abstract this code into a class, function, or loop. Doing
    so won't just save your fingers some typing, it will ensure consistency and reduce
    the total amount of code you have to maintain.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码时，要注意包含大量重复代码的部分。您通常可以将此代码抽象为类、函数或循环。这样做不仅可以节省您的输入，还可以确保一致性，并减少您需要维护的代码总量。
- en: 'Let''s take a look at the following steps:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'We''ll call this class `LabelInput` and define it at the top of our code, just
    under the `Start coding here` comment:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将这个类称为`LabelInput`，并在我们的代码顶部定义它，就在`Start coding here`注释下面：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ll base the class on `Tkinter.Frame`, just as we did with `HelloWidget`.
    Our constructor takes a number of the following arguments:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将基于`Tkinter.Frame`类，就像我们在`HelloWidget`中所做的一样。我们的构造函数接受以下参数：
- en: '`parent`: This argument is a reference to the `parent` widget; all widgets
    we create will take this as the first argument.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`：这个参数是对`parent`小部件的引用；我们创建的所有小部件都将以此作为第一个参数。'
- en: '`label`: This the text for the label part of the widget.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`：这是小部件标签部分的文本。'
- en: '`input_class`: This is the class of the widget we want to create. It should
    be an actual callable class object, not a string. If left blank, `ttk.Entry` will
    be used.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input_class`：这是我们想要创建的小部件类。它应该是一个实际的可调用类对象，而不是一个字符串。如果留空，将使用`ttk.Entry`。'
- en: '`input_var`: This is a Tkinter variable to assign to the input. It''s optional,
    since some widgets don''t use variables.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input_var`：这是一个Tkinter变量，用于分配输入。这是可选的，因为有些小部件不使用变量。'
- en: '`input_args`: This is an optional dictionary of any additional arguments for
    the `input` constructor.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input_args`：这是`input`构造函数的任何额外参数的可选字典。'
- en: '`label_args`: This is an optional dictionary of any additional arguments for
    the `label` constructor.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label_args`：这是`label`构造函数的任何额外参数的可选字典。'
- en: '`**kwargs`: Finally, we catch any additional keyword arguments in `**kwargs`.
    These will be passed to the `Frame` constructor.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**kwargs`：最后，我们在`**kwargs`中捕获任何额外的关键字参数。这些将传递给`Frame`构造函数。'
- en: The first thing we do in the constructor is call `super().__init__()` and pass
    in the `parent` and extra keyword arguments. We then make sure that both `input_args`
    and `label_args` are dictionaries, and save a reference to our input variable
    as `self.variable`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们首先调用`super().__init__()`，并传入`parent`和额外的关键字参数。然后，我们确保`input_args`和`label_args`都是字典，并将我们的输入变量保存为`self.variable`的引用。
- en: Don't be tempted to use an empty dictionary (`{}`) as a default value for a
    method's keyword arguments. If you did so, a dictionary would be created when
    the method definition is evaluated and shared by all objects in the class. This
    would have some very strange effects on your code! The accepted practice is to
    pass `None` for mutable types like dictionaries and lists, then replacing `None`
    with an empty container in the method body.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 不要诱使使用空字典（`{}`）作为方法关键字参数的默认值。如果这样做，当方法定义被评估时会创建一个字典，并被类中的所有对象共享。这会对您的代码产生一些非常奇怪的影响！接受的做法是对于可变类型如字典和列表，传递`None`，然后在方法体中用空容器替换`None`。
- en: 'We want to be able to take any kind of `input` widget and deal with it appropriately
    in our class; unfortunately, as we learned previously, there are small differences
    between the constructor arguments and behavior in different widget classes, such
    as the way `Combobox` and `Checkbutton` use their `textvariable` argument. At
    the moment, we just need to differentiate between the way button widgets like
    `Button` and `Checkbutton` handle variables and label text. To deal with this,
    we''ll add the following code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望能够使用任何类型的`input`小部件，并在我们的类中适当处理它；不幸的是，正如我们之前学到的那样，不同小部件类的构造函数参数和行为之间存在一些小差异，比如`Combobox`和`Checkbutton`使用它们的`textvariable`参数的方式。目前，我们只需要区分`Button`和`Checkbutton`等按钮小部件处理变量和标签文本的方式。为了处理这个问题，我们将添加以下代码：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For button-type widgets, we do the following tasks differently:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于按钮类型的小部件，我们以不同的方式执行以下任务：
- en: Instead of adding a label, we just set the `text` argument. All buttons use
    this argument to add a `label` to the widget.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不是添加一个标签，而是设置`text`参数。所有按钮都使用这个参数来添加一个`label`到小部件中。
- en: Instead of assigning our variable to `textvariable`, we assign it to `variable`.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将变量分配给`variable`，而不是分配给`textvariable`。
- en: In the case of other `input` classes, we set `textvariable` and create a `Label`
    widget, adding it to the first row of the `LabelInput` class.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于其他`input`类，我们设置`textvariable`并创建一个`Label`小部件，将其添加到`LabelInput`类的第一行。
- en: 'Now we need to create the `input` class, as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要创建`input`类，如下所示：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is pretty straightforward: we call the `input_class` class passed into
    the constructor with the `input_args` dictionary expanded to keyword arguments.
    Then, we add it to the grid at row `1`.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这很简单：我们用扩展为关键字参数的`input_args`字典调用传递给构造函数的`input_class`类。然后，我们将其添加到第`1`行的网格中。
- en: 'Lastly, we configure the `grid` layout to expand our lone column across the
    entire widget, as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们配置`grid`布局，将我们的单列扩展到整个小部件，如下所示：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'One nice thing we can do when creating custom widgets that will save us a lot
    of coding is to add defaults to its geometry manager methods. For example, we''re
    going to want all our `LabelInput` objects to fill the entire grid cell that they''re
    placed within. Instead of adding `sticky=(tk.W + tk.E)` to every `LabelInput.grid()`
    call, we can add it as a default value by overriding the method:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当创建自定义小部件时，我们可以做的一件好事是为其几何管理器方法添加默认值，这将节省我们大量的编码。例如，我们将希望所有的`LabelInput`对象填充它们所放置的整个网格单元。我们可以通过覆盖方法将`sticky=(tk.W
    + tk.E)`添加为默认值，而不是在每个`LabelInput.grid()`调用中添加它：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By defining it as a default parameter, we can still override it as usual. The
    `input` widgets all have a `get()` method that returns their current value. To
    save some redundant typing later, we''ll implement a `get()` method in our `LabelInput`
    class that will simply pass along the request to the input or its variable. Add
    this method next:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其定义为默认参数，我们仍然可以像往常一样覆盖它。所有`input`小部件都有一个`get()`方法，返回它们当前的值。为了节省一些重复的输入，我们将在`LabelInput`类中实现一个`get()`方法，它将简单地将请求传递给输入或其变量。接下来添加这个方法：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''re using a `try` block here, because Tkinter variables will throw an exception
    if you call `get()` under certain conditions, such as when a numeric field is
    empty (blank strings can''t convert to a numeric value). In such a case, we''ll
    simply return an empty value from the form. Also, we need to handle the `tk.Text`
    widgets differently, since they require a range to retrieve text. We''re always
    going to want all the text from this form, so we''ll just specify that here. As
    a complement to `get()`, we''ll implement a `set()` method that passes the request
    to the variable or `widget`, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`try`块，因为在某些条件下，例如当数字字段为空时（空字符串无法转换为数字值），Tkinter变量将抛出异常，如果调用`get()`。在这种情况下，我们将简单地从表单中返回一个空值。此外，我们需要以不同的方式处理`tk.Text`小部件，因为它们需要一个范围来检索文本。我们总是希望从这个表单中获取所有文本，所以我们在这里指定。作为`get()`的补充，我们将实现一个`set()`方法，将请求传递给变量或小部件，如下所示：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `.set()` method abstracts away some of the differences between how various
    Tkinter widgets set their values:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`.set()`方法抽象了各种Tkinter小部件设置其值的差异：'
- en: If we have a variable of class `BooleanVar`, cast `value` to `bool` and set
    it. `BooleanVar.set()` will only take a `bool`, not other falsy or truthy values.
    This ensures our variable only gets an actual boolean value.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有一个`BooleanVar`类的变量，将`value`转换为`bool`并设置它。`BooleanVar.set()`只接受`bool`，而不是其他假值或真值。这确保我们的变量只获得实际的布尔值。
- en: If we have any other kind of variable, just pass `value` to its `.set()` method.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有任何其他类型的变量，只需将`value`传递给其`.set()`方法。
- en: If we have no variable, and a button-style class, we use the `.select()` and `.deselect()` methods
    to select and deselect the button based on the truthy value of the variable.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们没有变量，并且是一个按钮样式的类，我们使用`.select()`和`.deselect()`方法来根据变量的真值选择和取消选择按钮。
- en: If it's a `tk.Text` class, we can use its `.delete` and `.insert` methods.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是一个`tk.Text`类，我们可以使用它的`.delete`和`.insert`方法。
- en: Otherwise, we use the `.delete` and `.insert` methods of `input`, which work
    on the `Entry`, `Spinbox`, and `Combobox` classes. We have to do this separately
    from the `tk.Text` inputs, because the indexing values work differently.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，我们使用`input`的`.delete`和`.insert`方法，这些方法适用于`Entry`、`Spinbox`和`Combobox`类。我们必须将这个与`tk.Text`输入分开，因为索引值的工作方式不同。
- en: This may not account for every possible `input` widget, but it covers the ones
    we plan to use and a few more we may need later. While building the `LabelInput`
    class took a lot of work, we'll see that defining the form is much simpler now.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能并不涵盖每种可能的`input`小部件，但它涵盖了我们计划使用的以及我们以后可能需要的一些。虽然构建`LabelInput`类需要很多工作，但我们将看到现在定义表单要简单得多。
- en: Building the form
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建表单
- en: 'Instead of building our form directly on the main application window, we''re
    going to build our form as its own object. Initially, this makes it easier to
    maintain a nice layout, and later down the road it will make it easier for us
    to expand our application. Let''s perform the following steps for building our
    form:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不直接在主应用程序窗口上构建我们的表单，而是将我们的表单构建为自己的对象。最初，这样做可以更容易地维护一个良好的布局，而在将来，这将使我们更容易扩展我们的应用程序。让我们执行以下步骤来构建我们的表单：
- en: 'Once again, we''ll subclass `Tkinter.Frame` to build this module. After the
    `LabelInput` class definition, begin a new class as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦再次子类化`Tkinter.Frame`来构建这个模块。在`LabelInput`类定义之后，开始一个新的类，如下所示：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This should be familiar by now. We subclass `Frame`, define our constructor,
    and call `super().__init__()` to initialize the underlying `Frame` object.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该现在很熟悉了。我们子类化`Frame`，定义我们的构造函数，并调用`super().__init__()`来初始化底层的`Frame`对象。
- en: 'Now we''re going to create a structure to hold references to all the form''s
    `input` widgets, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个结构来保存表单中所有`input`小部件的引用，如下所示：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we create the `input` widgets, we'll store references to them in the dictionary,
    using the field name as a key. This will make it easier later to retrieve all
    our values.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`input`小部件时，我们将在字典中存储对它们的引用，使用字段名作为键。这将使我们以后更容易检索所有的值。
- en: Adding LabelFrame and other widgets
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加LabelFrame和其他小部件
- en: 'Our form is divided into sections with a label for and a box around each section.
    For each section, we''ll create a `LabelFrame` widget and start adding our `LabelInput`
    widgets to it by performing the following steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单被分成了带有标签和框的各个部分。对于每个部分，我们将创建一个`LabelFrame`小部件，并开始向其中添加我们的`LabelInput`小部件，执行以下步骤：
- en: 'Let''s start with the record information frame by executing the following code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从执行以下代码开始记录信息框架：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember that the `text` argument to `LabelFrame` defines the text of the label.
    This widget will be passed as the `parent` widget to all the inputs in the record
    information group.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`LabelFrame`的`text`参数定义了标签的文本。这个小部件将作为记录信息组中所有输入的`parent`小部件传递。
- en: 'Now, we''ll add the first line of the `input` widgets, as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加`input`小部件的第一行，如下所示：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Date` and `Technician` inputs are simple text entries; we only need to
    pass the `parent`, `label`, and `input` variables into our `LabelInput` constructor.
    For the `Time` entry, we specify a list of possible values that will be used to
    initialize the `Combobox` widget.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Date`和`Technician`输入是简单的文本输入；我们只需要将`parent`，`label`和`input`变量传递给我们的`LabelInput`构造函数。对于`Time`输入，我们指定一个可能值的列表，这些值将用于初始化`Combobox`小部件。'
- en: 'Let''s work on line 2, as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们按照以下方式处理第2行：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we have two more `Combobox` widgets and another `Entry`. These are created
    similarly to those in line 1\. The values for `Plot` just need to be a list of
    numbers from 1 through 20; we can create that with Python''s built-in `range()`
    function. Finished with the record information, we add its `LabelFrame` to the
    form widget with a call to `grid()`. The remaining fields are defined in essentially
    the same way. For example, our environmental data will look as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们有两个`Combobox`小部件和另一个`Entry`。这些创建方式与第1行中的方式类似。`Plot`的值只需要是1到20的数字列表；我们可以使用Python内置的`range()`函数创建它。完成记录信息后，我们通过调用`grid()`将其`LabelFrame`添加到表单小部件。其余字段以基本相同的方式定义。例如，我们的环境数据将如下所示：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we've added the first of our `Spinbox` widgets, specifying the valid ranges
    and increment amount; you can add in the `Light` and `Temperature` inputs in the
    same way. Notice that our `grid()` coordinates have started over with `0, 0`;
    that's because we're starting a new parent object, so the coordinates begin all
    over again.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们添加了我们的第一个`Spinbox`小部件，指定了有效范围和增量；您可以以相同的方式添加`Light`和`Temperature`输入。请注意，我们的`grid()`坐标已经从`0,
    0`重新开始；这是因为我们正在开始一个新的父对象，所以坐标重新开始。
- en: All of these nested grids can get confusing. Remember that whenever you call
    `.grid()` on a widget, the coordinates are relative to the top-left corner of
    the widget's parent. The parent's coordinates are relative to its parent, and
    so on, back up to the root window.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些嵌套的网格可能会让人困惑。请记住，每当在小部件上调用`.grid()`时，坐标都是相对于小部件父级的左上角。父级的坐标是相对于其父级的，依此类推，直到根窗口。
- en: 'This section also contains the lone `Checkbutton` widget:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分还包括唯一的`Checkbutton`小部件：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are no real arguments to use with the `Checkbutton`, though note that
    we''re using a `BooleanVar` to store its value. Now, we move on to the plant data
    section:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`Checkbutton`，没有真正的参数可用，尽管请注意我们使用`BooleanVar`来存储其值。现在，我们继续进行植物数据部分：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that, unlike our decimal `Spinboxes`, we're not setting the increment
    for the integer fields; that's because it defaults to `1.0`, which is what we
    want for integer fields.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与我们的十进制`Spinboxes`不同，我们没有为整数字段设置增量；这是因为它默认为`1.0`，这正是我们想要的整数字段。
- en: We're also using `1000` as a maximum for `Blossoms` although it technically
    shouldn't have a maximum; our `Lab` `Technicians` assured us that it would never
    approach 1,000\. Since `Spinbox` requires both `to` and `from_`, if we use either,
    we'll go ahead and use this value.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管从技术上讲`Blossoms`没有最大值，但我们也使用`1000`作为最大值；我们的`Lab` `Technicians`向我们保证它永远不会接近1000。由于`Spinbox`需要`to`和`from_`，如果我们使用其中一个，我们将使用这个值。
- en: You can also specify the strings `infinity` or `-infinity` as values. These
    can be cast to the `float` values, which behave appropriately.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定字符串`infinity`或`-infinity`作为值。这些可以转换为`float`值，其行为是适当的。
- en: 'The `Fruit` field and three `Height` fields will be mostly identical to these.
    Go ahead and create them, making sure to follow your data dictionary for the appropriate
    `input_args` values and `input_var` types. We finish our form fields by adding
    the following notes:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Fruit`字段和三个`Height`字段将与这些基本相同。继续创建它们，确保遵循适当的`input_args`值和`input_var`类型的数据字典。通过添加以下注释完成我们的表单字段：'
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There's no need for `LabelFrame` here, so we're just adding the note's `LabelInput`
    frame directly to the form. The `Text` widget takes the `width` and `height` arguments
    to specify the size of the box. We'll give it a nice generous size for note entry.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里不需要`LabelFrame`，因此我们只需将注释的`LabelInput`框直接添加到表单中。`Text`小部件采用`width`和`height`参数来指定框的大小。我们将为注释输入提供一个非常大的尺寸。
- en: Retrieving data from our form
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从我们的表单中检索数据
- en: Now that we're finished with the form, we need a way to retrieve data from it
    so it can be processed by the application. We'll create a method that returns
    a dictionary of the form's data and, as we did with our `LabelInput` objects,
    maintain the Tkinter convention of calling it `get()`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了表单，我们需要一种方法来从中检索数据，以便应用程序对其进行处理。我们将创建一个返回表单数据字典的方法，并且与我们的`LabelInput`对象一样，遵循Tkinter的约定将其命名为`get()`。
- en: 'Add the following method to your form class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的表单类中添加以下方法：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The code is simple: we loop through our instance''s `inputs` object containing
    our `LabelInput` objects and build a new dictionary by calling `get()` on each
    variable.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单：我们遍历包含我们的`LabelInput`对象的实例的`inputs`对象，并通过对每个变量调用`get()`来构建一个新字典。
- en: This code demonstrates the power of both iterable objects and consistent naming
    schemes. If we had stored our inputs as discrete properties of the form, or neglected
    to normalize the `get()` method, our code would be a lot less elegant.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了可迭代对象和一致命名方案的强大之处。如果我们将输入存储为表单的离散属性，或者忽略了规范化`get()`方法，我们的代码将不够优雅。
- en: Resetting our form
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重置我们的表单
- en: 'We''re almost done with our form class, but there''s one more method needed.
    After each save of the form, we''re going to need to reset it to empty fields;
    so, let''s add a method to do that by performing the following steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单类几乎完成了，但还需要一个方法。在每次保存表单后，我们需要将其重置为空字段；因此，让我们通过执行以下步骤添加一个方法来实现：
- en: 'Add this method to the end of the form class:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此方法添加到表单类的末尾：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As with our `get()` method, we're iterating through the `input` dictionary and
    setting each `widget` to an empty value.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们的`get()`方法一样，我们正在遍历`input`字典并将每个`widget`设置为空值。
- en: To make sure our application behaves consistently, we should call `reset()`
    immediately after the application loads, clearing out any `Tk` defaults that we
    might not want.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保我们的应用程序行为一致，我们应该在应用程序加载后立即调用`reset()`，清除我们可能不想要的任何`Tk`默认设置。
- en: 'Back up to the last line of `__init__()` and add the following code line:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`__init__()`的最后一行，并添加以下代码行：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Building our application class
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的应用程序类
- en: 'Let''s take a look at the following steps for building our application class:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看构建我们的应用程序类的以下步骤：
- en: 'Move down under the `Application` class doc string (the line that reads `Application
    root window`) and start an `__init__()` method for `Application`, as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Application`类文档字符串（读作`Application root window`的行）下面移动，并开始为`Application`编写一个`__init__()`方法，如下所示：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once again we make the familiar call to `super().__init__()`, passing along
    any arguments or keyword arguments.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次调用`super().__init__()`，传递任何参数或关键字参数。
- en: Note that we don't pass in a `parent` widget here, since `Application` is the
    root window.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们这里没有传入`parent`小部件，因为`Application`是根窗口。
- en: We call `.title()` to set our application's title string; this isn't required,
    but it will certainly help users who are running multiple applications to find
    our application quickly in their desktop environment.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`.title()`来设置我们应用程序的标题字符串；这不是必需的，但它肯定会帮助运行多个应用程序的用户快速在他们的桌面环境中找到我们的应用程序。
- en: 'We also prohibit resizing of the window with a call to `self.resizable`. This
    also isn''t strictly necessary, but it makes it simpler for us to control our
    layout for the time being. Let''s start adding our application components as follows:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还通过调用`self.resizable`禁止窗口的调整大小。这也不是严格必要的，但它使我们暂时更容易控制我们的布局。让我们开始添加我们的应用程序组件，如下所示：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The application will start at the top with a `Label` object showing the name
    of the application in a larger than normal font. Notice that we don''t specify `column`
    here; our main application layout will only have one column, so it''s not strictly
    necessary to specify `column`, as it defaults to `0`. Next, we''ll add our `DataRecordForm` as
    follows:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序将从顶部开始，显示一个`Label`对象，以比正常字体大的字体显示应用程序的名称。请注意，我们这里没有指定`column`；我们的主应用程序布局只有一列，所以没有必要严格指定`column`，因为它默认为`0`。接下来，我们将添加我们的`DataRecordForm`如下：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We're adding 10 pixels of padding on the left and right using the `padx` argument
    to `grid`. This just adds a little whitespace around the edges of the form, making
    it a bit more readable.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`padx`参数向左和向右添加了10像素的填充。这只是在表单的边缘周围添加了一些空白，使其更易读。
- en: 'Let''s add in the save button next, as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加保存按钮，如下所示：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We've given the button a `command` value of `self.on_save`; we haven't written
    that method yet, so we'll need to do that before we can run our code.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们给按钮一个`command`值为`self.on_save`；我们还没有编写该方法，所以在运行代码之前我们需要这样做。
- en: When writing methods or functions to be callbacks for a GUI event, it's conventional
    to use the format `on_EVENTNAME`, where `EVENTNAME` is a string describing the
    event triggering it. We could also name this method `on_save_button_click()`,
    but for now `on_save()` is adequate.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写用于GUI事件的方法或函数时，惯例是使用格式`on_EVENTNAME`，其中`EVENTNAME`是描述触发它的事件的字符串。我们也可以将此方法命名为`on_save_button_click()`，但目前`on_save()`就足够了。
- en: 'Finally, let''s add in the status bar, as follows:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们添加状态栏，如下所示：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We start by creating a string variable called `self.status` and use this as `textvariable`
    for `ttk.Label`. All our application will need to do to update the status is call
    `self.status.set()` anywhere inside the class. Our GUI is completed by adding
    the status bar to the bottom of the application widget.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`self.status`的字符串变量，并将其用作`ttk.Label`的`textvariable`。我们的应用程序只需要在类内部调用`self.status.set()`来更新状态。通过将状态栏添加到应用程序小部件的底部，我们的GUI完成了。
- en: Saving to CSV
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存到CSV
- en: 'When a user clicks on save, the following chain of events needs to take place:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击保存时，需要发生以下一系列事件：
- en: A file called `abq_data_record_CURRENTDATE.csv` is opened
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个名为`abq_data_record_CURRENTDATE.csv`的文件
- en: If the file doesn't exist, it will be created, and field headers will be written
    to the first line
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件不存在，它将被创建，并且字段标题将被写入第一行
- en: The data dictionary is retrieved from `DataEntryForm`
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据字典从`DataEntryForm`中检索
- en: The data is formatted as a CSV row and appended to the file
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据被格式化为CSV行并附加到文件
- en: The form is cleared, and the user is notified that the record was saved
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表单被清除，并通知用户记录已保存
- en: 'We''re going to need a few more Python libraries to help us out with this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一些其他Python库来帮助我们完成这个任务：
- en: First, we'll need a date string for our filename. Python's `datetime` library
    can help us here.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个用于我们文件名的日期字符串。Python的`datetime`库可以帮助我们。
- en: Next, we'll need to be able to check if a file exists. Python's `os` library
    has a function for this.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要能够检查文件是否存在。Python的`os`库有一个用于此的函数。
- en: Finally, we need to be able to write to a CSV file. Python has a CSV library
    in the standard library that would be perfect here.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要能够写入CSV文件。Python在标准库中有一个CSV库，这里非常适用。
- en: 'Let''s take a look at the following steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'Back up to the top of the file and add the following imports above the Tkinter
    imports:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到文件顶部，并在Tkinter导入之前添加以下导入：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, go back to the `Application` class and start the `on_save()` method, as
    follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到`Application`类，并开始`on_save()`方法，如下所示：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first thing we do is create our date string. The `datetime.today()` method
    returns a `datetime` at midnight of the current day; we then format this using
    `strftime()` to an ISO date string in the form year-month-day (using numbers 01
    through 12 for the month). This gets plugged into the filename template from our
    specification and saved as `filename`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是创建我们的日期字符串。`datetime.today()`方法返回当前日期的午夜`datetime`；然后我们使用`strftime()`将其格式化为年-月-日的ISO日期字符串（使用数字01到12表示月份）。这将被插入到我们规范的文件名模板中，并保存为`filename`。
- en: Next, we need to determine whether the file already exists; `os.path.exists()`
    will return a boolean value indicating if the file exists; we negate this value
    and store it as `newfile`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定文件是否已经存在；`os.path.exists()`将返回一个布尔值，指示文件是否存在；我们对这个值取反，并将其存储为`newfile`。
- en: 'Now, let''s get the data from `DataEntryForm`:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们从`DataEntryForm`获取数据：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With the data acquired, we need to open our file and write the data into it.
    Add in the following code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获得数据后，我们需要打开文件并将数据写入其中。添加以下代码：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `with open(filename, 'a') as fh:` statement opens our generated filename
    in append mode and gives us a file handle called `fh`. Append mode means we can't
    read or edit any existing lines in the file, just add to the end of it, which
    is exactly what we want.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`with open(filename, ''a'') as fh:`语句以追加模式打开我们生成的文件名，并为我们提供一个名为`fh`的文件句柄。追加模式意味着我们不能读取或编辑文件中的任何现有行，只能添加到文件的末尾，这正是我们想要的。'
- en: The `with` keyword works with **context manager** objects, which our call to
    `open()` returns. Context managers are special objects that define code to run
    before and after the `with` block. By opening files using this method, they'll
    automatically be closed correctly at the end of the block.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`关键字与**上下文管理器**对象一起使用，我们调用`open()`返回的就是这样的对象。上下文管理器是特殊的对象，它定义了在`with`块之前和之后要运行的代码。通过使用这种方法打开文件，它们将在块结束时自动正确关闭。'
- en: Next, we create a `csv.DictWriter` object using the file handle. This object
    will allow us to write dictionaries of data to the CSV file, matching up the dictionary
    keys with the CSV's header row labels. This will work better for us in the long
    run than the default CSV writer object, which would require the fields in the
    correct order every time.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用文件句柄创建一个`csv.DictWriter`对象。这个对象将允许我们将数据字典写入CSV文件，将字典键与CSV的标题行标签匹配。这对我们来说比默认的CSV写入对象更好，后者每次都需要正确顺序的字段。
- en: To configure this, we have to first pass in the `fieldnames` argument to the
    `DictWriter` constructor. Our field names are the keys of the `data` dictionary
    that we get from the form. If we're working on a new file, we need to write those
    field names to the first row, which we do by calling `DictWriter.writeheader()`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要配置这一点，我们首先必须将`fieldnames`参数传递给`DictWriter`构造函数。我们的字段名称是从表单中获取的`data`字典的键。如果我们正在处理一个新文件，我们需要将这些字段名称写入第一行，我们通过调用`DictWriter.writeheader()`来实现。
- en: Finally, we write our `data` dictionary to a new row, using the `.writerow()`
    method of our `DictWriter` object. At the end of the code block, the file is automatically
    closed and saved.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`DictWriter`对象的`.writerow()`方法将我们的`data`字典写入新行。在代码块的末尾，文件会自动关闭和保存。
- en: Finishing and testing
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成和测试
- en: 'At this point, you should be able to run the application, enter data, and save
    it to the CSV file. Try it out! You should see something similar to the following
    screenshot:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该能够运行应用程序，输入数据，并将其保存到CSV文件中。试试看！您应该会看到类似以下截图的东西：
- en: '![](assets/9708ab24-6d9f-4276-935b-454f6110dc31.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9708ab24-6d9f-4276-935b-454f6110dc31.png)'
- en: Perhaps the first thing you notice is that clicking Save has no noticeable effect.
    The form stays populated, and there's no indication that anything was done. We
    should fix this.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您注意到的第一件事是，单击保存没有明显的效果。表单保持填充状态，没有任何指示已经完成了什么。我们应该修复这个问题。
- en: 'We''ll perform the following two things to help here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行以下两件事来帮助这里：
- en: 'First, put a notification in our status bar that the record was saved and how
    many records have been saved this session. For the first part, add the following
    code line to the end of the `Application` constructor, as follows:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在我们的状态栏中放置一个通知，说明记录已保存以及本次会话已保存多少条记录。对于第一部分，将以下代码行添加到`Application`构造函数的末尾，如下所示：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Second, clear the form after saving, so the next record can be started. Then
    add the following code line to the end of the `on_save()` method, as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，在保存后清除表单，以便可以开始下一个记录。然后将以下代码行添加到`on_save()`方法的末尾，如下所示：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This code sets up a counter variable that will keep track of the number of records
    we've saved since the application was started.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码设置了一个计数器变量，用于跟踪自应用程序启动以来保存的记录数。
- en: After saving the file, we increment the value, then set our status to indicate
    how many records have been saved. Users will be able to see this number increase
    and know that their button click has done something.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件后，我们增加值，然后设置我们的状态以指示已保存多少条记录。用户将能够看到这个数字增加，并知道他们的按钮点击已经做了一些事情。
- en: 'Next, we''ll reset the form after saving. Append this code to the end of `Application.on_save()`,
    as follows:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在保存后重置表单。将以下代码追加到`Application.on_save()`的末尾，如下所示：
- en: '[PRE38]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That will zero out the form and ready it for the next record to be entered.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这将清空表单，并准备好下一个记录的输入。
- en: Now, run the application again. It should clear out and give you a status indication
    on saving a record.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次运行应用程序。它应该清除并在保存记录时给出状态指示。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Well, we've come a long way in this chapter! You took your design from a specification
    and some drawings to a running application that already covers the basic functionality
    you need. You learned to work with basic Tkinter and `ttk` widgets, and create
    custom widgets to save yourself a lot of repetitive work.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们在这一章取得了长足的进步！您将您的设计从规范和一些图纸转化为一个运行的应用程序，它已经涵盖了您需要的基本功能。您学会了如何使用基本的Tkinter和`ttk`小部件，并创建自定义小部件，以节省大量重复的工作。
- en: In the next chapter, we're going to address the issues with our `input` widgets.
    We'll learn to customize the behavior of our `input` widgets, prevent erroneous
    keystrokes, and validate the data to make sure it's within the tolerances laid
    out in our specification. Along the way, we'll dig deeper into Python classes
    and learn more techniques for efficient and elegant code.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将解决`input`小部件的问题。我们将学习如何自定义`input`小部件的行为，防止错误的按键，并验证数据，以确保它在我们规范中规定的容差范围内。在此过程中，我们将深入研究Python类，并学习更多高效和优雅的代码技巧。
