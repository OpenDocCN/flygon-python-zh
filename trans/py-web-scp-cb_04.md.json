["```py\nimport const\nfrom util.urls import URLUtility\n\nutil = URLUtility(const.ApodEclipseImage())\nprint(len(util.data))\n```", "```py\nReading URL: https://apod.nasa.gov/apod/image/1709/BT5643s.jpg\nRead 171014 bytes\n171014\n```", "```py\ndef ApodEclipseImage():\n    return \"https://apod.nasa.gov/apod/image/1709/BT5643s.jpg\" \n```", "```py\ndef __init__(self, url, readNow=True):\n    \"\"\" Construct the object, parse the URL, and download now if specified\"\"\"\n  self._url = url\n    self._response = None\n  self._parsed = urlparse(url)\n    if readNow:\n        self.read()\n```", "```py\ndef read(self):\n    self._response = urllib.request.urlopen(self._url)\n    self._data = self._response.read()\n```", "```py\n@property def data(self):\n    self.ensure_response()\n    return self._data\n```", "```py\nutil = URLUtility(const.ApodEclipseImage())\nprint(util.filename_without_ext)\n```", "```py\nReading URL: https://apod.nasa.gov/apod/image/1709/BT5643s.jpg\nRead 171014 bytes\nThe filename is: BT5643s\n```", "```py\n>>> parsed = urlparse(const.ApodEclipseImage())\n>>> parsed\nParseResult(scheme='https', netloc='apod.nasa.gov', path='/apod/image/1709/BT5643s.jpg', params='', query='', fragment='')\n```", "```py\n@property def filename_without_ext(self):\n    filename = os.path.splitext(os.path.basename(self._parsed.path))[0]\n    return filename\n```", "```py\nutil = URLUtility(const.ApodEclipseImage())\nprint(\"The content type is: \" + util.contenttype)\n```", "```py\nReading URL: https://apod.nasa.gov/apod/image/1709/BT5643s.jpg\nRead 171014 bytes\nThe content type is: image/jpeg\n```", "```py\n@property def contenttype(self):\n    self.ensure_response()\n    return self._response.headers['content-type']\n```", "```py\n>>> response = urllib.request.urlopen(const.ApodEclipseImage())\n>>> for header in response.headers: print(header)\nDate\nServer\nLast-Modified\nETag\nAccept-Ranges\nContent-Length\nConnection\nContent-Type\nStrict-Transport-Security\n```", "```py\n>>> for header in response.headers: print(header + \" ==> \" + response.headers[header])\nDate ==> Tue, 26 Sep 2017 19:31:41 GMT\nServer ==> WebServer/1.0\nLast-Modified ==> Thu, 31 Aug 2017 20:26:32 GMT\nETag ==> \"547bb44-29c06-5581275ce2b86\"\nAccept-Ranges ==> bytes\nContent-Length ==> 171014\nConnection ==> close\nContent-Type ==> image/jpeg\nStrict-Transport-Security ==> max-age=31536000; includeSubDomains\n```", "```py\nutil = URLUtility(const.ApodEclipseImage())\nprint(\"Filename from content-type: \" + util.extension_from_contenttype)\nprint(\"Filename from url: \" + util.extension_from_url)\n```", "```py\nReading URL: https://apod.nasa.gov/apod/image/1709/BT5643s.jpg\nRead 171014 bytes\nFilename from content-type: .jpg\nFilename from url: .jpg\n```", "```py\n@property def extension_from_contenttype(self):\n    self.ensure_response()\n\n    map = const.ContentTypeToExtensions()\n    if self.contenttype in map:\n        return map[self.contenttype]\n    return None \n```", "```py\ndef ContentTypeToExtensions():\n    return {\n        \"image/jpeg\": \".jpg\",\n  \"image/jpg\": \".jpg\",\n  \"image/png\": \".png\"\n  }\n```", "```py\n@property def extension_from_url(self):\n    ext = os.path.splitext(os.path.basename(self._parsed.path))[1]\n    return ext\n```", "```py\n# download the image item = URLUtility(const.ApodEclipseImage())\n\n# create a file writer to write the data FileBlobWriter(expanduser(\"~\")).write(item.filename, item.data)\n```", "```py\nReading URL: https://apod.nasa.gov/apod/image/1709/BT5643s.jpg\nRead 171014 bytes\nAttempting to write 171014 bytes to BT5643s.jpg:\nThe write was successful\n```", "```py\n\"\"\" Implements the IBlobWriter interface to write the blob to a file \"\"\"   from interface import implements\nfrom core.i_blob_writer import IBlobWriter\n\nclass FileBlobWriter(implements(IBlobWriter)):\n    def __init__(self, location):\n        self._location = location\n\n    def write(self, filename, contents):\n        full_filename = self._location + \"/\" + filename\n        print (\"Attempting to write {0} bytes to {1}:\".format(len(contents), filename))\n\n        with open(full_filename, 'wb') as outfile:\n            outfile.write(contents)\n\n        print(\"The write was successful\")\n```", "```py\n\"\"\" Defines the interface for writing a blob of data to storage \"\"\"   from interface import Interface\n\nclass IBlobWriter(Interface):\n   def write(self, filename, contents):\n      pass\n```", "```py\n# download the image item = URLUtility(const.ApodEclipseImage())\n\n# store it in S3 S3BlobWriter(bucket_name=\"scraping-apod\").write(item.filename, item.data)\n```", "```py\nclass S3BlobWriter(implements(IBlobWriter)):\n    def __init__(self, bucket_name, boto_client=None):\n        self._bucket_name = bucket_name\n\n        if self._bucket_name is None:\n            self.bucket_name = \"/\"    # caller can specify a boto client (can reuse and save auth times)\n  self._boto_client = boto_client\n\n        # or create a boto client if user did not, use secrets from environment variables\n  if self._boto_client is None:\n            self._boto_client = boto3.client('s3')\n\n    def write(self, filename, contents):\n        # create bucket, and put the object\n  self._boto_client.create_bucket(Bucket=self._bucket_name, ACL='public-read')\n        self._boto_client.put_object(Bucket=self._bucket_name,\n  Key=filename,\n  Body=contents,\n  ACL=\"public-read\")\n```", "```py\npip install pillow\n```", "```py\nfrom os.path import expanduser\nimport const\nfrom core.file_blob_writer import FileBlobWriter\nfrom core.image_thumbnail_generator import ImageThumbnailGenerator\nfrom util.urls import URLUtility\n\n# download the image and get the bytes img_data = URLUtility(const.ApodEclipseImage()).data\n\n# we will store this in our home folder fw = FileBlobWriter(expanduser(\"~\"))\n\n# Create a thumbnail generator and scale the image tg = ImageThumbnailGenerator(img_data).scale(200, 200)\n\n# write the image to a file fw.write(\"eclipse_thumbnail.png\", tg.bytes)\n```", "```py\nimport io\nfrom PIL import Image\n\nclass ImageThumbnailGenerator():\n    def __init__(self, bytes):\n        # Create a pillow image with the data provided\n  self._image = Image.open(io.BytesIO(bytes))\n\n    def scale(self, width, height):\n        # call the thumbnail method to create the thumbnail\n  self._image.thumbnail((width, height))\n        return self    @property\n  def bytes(self):\n        # returns the bytes of the pillow image   # save the image to an in memory objects  bytesio = io.BytesIO()\n        self._image.save(bytesio, format=\"png\")\n\n```", "```py\n        # set the position on the stream to 0 and return the underlying data\n  bytesio.seek(0)\n        return bytesio.getvalue()\n\n```", "```py\nfrom core.website_screenshot_generator import WebsiteScreenshotGenerator\nfrom core.file_blob_writer import FileBlobWriter\nfrom os.path import expanduser\n\n# get the screenshot image_bytes = WebsiteScreenshotGenerator().capture(\"http://espn.go.com\", 500, 500).image_bytes\n\n# save it to a file FileBlobWriter(expanduser(\"~\")).write(\"website_screenshot.png\", image_bytes)\n```", "```py\nConnected to pydev debugger (build 162.1967.10)\nCapturing website screenshot of: http://espn.go.com\nGot a screenshot with the following dimensions: (500, 7416)\nCropped the image to: 500 500\nAttempting to write 217054 bytes to website_screenshot.png:\nThe write was successful\n```", "```py\nclass WebsiteScreenshotGenerator():\n    def __init__(self):\n        self._screenshot = None   def capture(self, url, width, height, crop=True):\n        print (\"Capturing website screenshot of: \" + url)\n        driver = webdriver.PhantomJS()\n\n        if width and height:\n            driver.set_window_size(width, height)\n\n        # go and get the content at the url\n  driver.get(url)\n\n        # get the screenshot and make it into a Pillow Image\n  self._screenshot = Image.open(io.BytesIO(driver.get_screenshot_as_png()))\n        print(\"Got a screenshot with the following dimensions: {0}\".format(self._screenshot.size))\n\n        if crop:\n            # crop the image\n  self._screenshot = self._screenshot.crop((0,0, width, height))\n            print(\"Cropped the image to: {0} {1}\".format(width, height))\n\n        return self    @property\n  def image(self):\n        return self._screenshot\n\n    @property\n  def image_bytes(self):\n        bytesio = io.BytesIO()\n        self._screenshot.save(bytesio, \"PNG\")\n        bytesio.seek(0)\n        return bytesio.getvalue()\n```", "```py\nfrom core.website_screenshot_with_screenshotapi import WebsiteScreenshotGenerator\nfrom core.file_blob_writer import FileBlobWriter\nfrom os.path import expanduser\n\n# get the screenshot image_bytes = WebsiteScreenshotGenerator(\"bd17a1e1-db43-4686-9f9b-b72b67a5535e\")\\\n    .capture(\"http://espn.go.com\", 500, 500).image_bytes\n\n# save it to a file FileBlobWriter(expanduser(\"~\")).write(\"website_screenshot.png\", image_bytes)\n```", "```py\nSending request: http://espn.go.com\n{\"status\":\"ready\",\"key\":\"2e9a40b86c95f50ad3f70613798828a8\",\"apiCreditsCost\":1}\nThe image key is: 2e9a40b86c95f50ad3f70613798828a8\nTrying to retrieve: https://api.screenshotapi.io/retrieve\nDownloading image: https://screenshotapi.s3.amazonaws.com/captures/2e9a40b86c95f50ad3f70613798828a8.png\nSaving screenshot to: downloaded_screenshot.png2e9a40b86c95f50ad3f70613798828a8\nCropped the image to: 500 500\nAttempting to write 209197 bytes to website_screenshot.png:\nThe write was successful\n```", "```py\nclass WebsiteScreenshotGenerator:\n    def __init__(self, apikey):\n        self._screenshot = None\n  self._apikey = apikey\n\n    def capture(self, url, width, height, crop=True):\n        key = self.beginCapture(url, \"{0}x{1}\".format(width, height), \"true\", \"firefox\", \"true\")\n\n        print(\"The image key is: \" + key)\n\n        timeout = 30\n  tCounter = 0\n  tCountIncr = 3    while True:\n            result = self.tryRetrieve(key)\n            if result[\"success\"]:\n                print(\"Saving screenshot to: downloaded_screenshot.png\" + key)\n\n                bytes=result[\"bytes\"]\n                self._screenshot = Image.open(io.BytesIO(bytes))\n\n                if crop:\n                    # crop the image\n  self._screenshot = self._screenshot.crop((0, 0, width, height))\n                    print(\"Cropped the image to: {0} {1}\".format(width, height))\n                break    tCounter += tCountIncr\n            print(\"Screenshot not yet ready.. waiting for: \" + str(tCountIncr) + \" seconds.\")\n            time.sleep(tCountIncr)\n            if tCounter > timeout:\n                print(\"Timed out while downloading: \" + key)\n                break\n return self    def beginCapture(self, url, viewport, fullpage, webdriver, javascript):\n        serverUrl = \"https://api.screenshotapi.io/capture\"\n  print('Sending request: ' + url)\n        headers = {'apikey': self._apikey}\n        params = {'url': urllib.parse.unquote(url).encode('utf8'), 'viewport': viewport, 'fullpage': fullpage,\n  'webdriver': webdriver, 'javascript': javascript}\n        result = requests.post(serverUrl, data=params, headers=headers)\n        print(result.text)\n        json_results = json.loads(result.text)\n        return json_results['key']\n\n    def tryRetrieve(self, key):\n        url = 'https://api.screenshotapi.io/retrieve'\n  headers = {'apikey': self._apikey}\n        params = {'key': key}\n        print('Trying to retrieve: ' + url)\n        result = requests.get(url, params=params, headers=headers)\n\n        json_results = json.loads(result.text)\n        if json_results[\"status\"] == \"ready\":\n            print('Downloading image: ' + json_results[\"imageUrl\"])\n            image_result = requests.get(json_results[\"imageUrl\"])\n            return {'success': True, 'bytes': image_result.content}\n        else:\n            return {'success': False}\n\n    @property\n  def image(self):\n        return self._screenshot\n\n    @property\n  def image_bytes(self):\n        bytesio = io.BytesIO()\n        self._screenshot.save(bytesio, \"PNG\")\n        bytesio.seek(0)\n        return bytesio.getvalue()\n```", "```py\npip install pytesseract\n```", "```py\nsudo apt-get tesseract-ocr\n```", "```py\nbrew install tesseract\n```", "```py\nimport pytesseract as pt\nfrom PIL import Image\n\nimg = Image.open(\"textinimage.png\")\ntext = pt.image_to_string(img)\nprint(text)\n```", "```py\nThis is an image containing text.\nAnd some numbers 123456789\n\nAnd also special characters: !@#$%\"&*(_+\n```", "```py\nimport subprocess\nvideo_file = 'BigBuckBunny.mp4' thumbnail_file = 'thumbnail.jpg' subprocess.call(['ffmpeg', '-i', video_file, '-ss', '00:01:03.000', '-vframes', '1', thumbnail_file, \"-y\"])\n```", "```py\n built with Apple LLVM version 8.1.0 (clang-802.0.42)\n configuration: --prefix=/usr/local/Cellar/ffmpeg/3.3.4 --enable-shared --enable-pthreads --enable-gpl --enable-version3 --enable-hardcoded-tables --enable-avresample --cc=clang --host-cflags= --host-ldflags= --enable-libmp3lame --enable-libx264 --enable-libxvid --enable-opencl --enable-videotoolbox --disable-lzma --enable-vda\n libavutil 55\\. 58.100 / 55\\. 58.100\n libavcodec 57\\. 89.100 / 57\\. 89.100\n libavformat 57\\. 71.100 / 57\\. 71.100\n libavdevice 57\\. 6.100 / 57\\. 6.100\n libavfilter 6\\. 82.100 / 6\\. 82.100\n libavresample 3\\. 5\\. 0 / 3\\. 5\\. 0\n libswscale 4\\. 6.100 / 4\\. 6.100\n libswresample 2\\. 7.100 / 2\\. 7.100\n libpostproc 54\\. 5.100 / 54\\. 5.100\nInput #0, mov,mp4,m4a,3gp,3g2,mj2, from 'BigBuckBunny.mp4':\n Metadata:\n major_brand : isom\n minor_version : 512\n compatible_brands: mp41\n creation_time : 1970-01-01T00:00:00.000000Z\n title : Big Buck Bunny\n artist : Blender Foundation\n composer : Blender Foundation\n date : 2008\n encoder : Lavf52.14.0\n Duration: 00:09:56.46, start: 0.000000, bitrate: 867 kb/s\n Stream #0:0(und): Video: h264 (Constrained Baseline) (avc1 / 0x31637661), yuv420p, 320x180 [SAR 1:1 DAR 16:9], 702 kb/s, 24 fps, 24 tbr, 24 tbn, 48 tbc (default)\n Metadata:\n creation_time : 1970-01-01T00:00:00.000000Z\n handler_name : VideoHandler\n Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 48000 Hz, stereo, fltp, 159 kb/s (default)\n Metadata:\n creation_time : 1970-01-01T00:00:00.000000Z\n handler_name : SoundHandler\nStream mapping:\n Stream #0:0 -> #0:0 (h264 (native) -> mjpeg (native))\nPress [q] to stop, [?] for help\n[swscaler @ 0x7fb50b103000] deprecated pixel format used, make sure you did set range correctly\nOutput #0, image2, to 'thumbnail.jpg':\n Metadata:\n major_brand : isom\n minor_version : 512\n compatible_brands: mp41\n date : 2008\n title : Big Buck Bunny\n artist : Blender Foundation\n composer : Blender Foundation\n encoder : Lavf57.71.100\n Stream #0:0(und): Video: mjpeg, yuvj420p(pc), 320x180 [SAR 1:1 DAR 16:9], q=2-31, 200 kb/s, 24 fps, 24 tbn, 24 tbc (default)\n Metadata:\n creation_time : 1970-01-01T00:00:00.000000Z\n handler_name : VideoHandler\n encoder : Lavc57.89.100 mjpeg\n Side data:\n cpb: bitrate max/min/avg: 0/0/200000 buffer size: 0 vbv_delay: -1\nframe= 1 fps=0.0 q=4.0 Lsize=N/A time=00:00:00.04 bitrate=N/A speed=0.151x \nvideo:8kB audio:0kB subtitle:0kB other streams:0kB global headers:0kB muxing overhead: unknown\n```", "```py\nffmpeg -i BigBuckBunny.mp4 -ss 00:01:03.000 -frames:v 1 thumbnail.jpg -y\n```", "```py\npip install moviepy\n```", "```py\nimport moviepy.editor as mp\nclip = mp.VideoFileClip(\"BigBuckBunny.mp4\")\nclip.audio.write_audiofile(\"movie_audio.mp3\")\n```", "```py\n[MoviePy] Writing audio in movie_audio.mp3\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 17820/17820 [00:16<00:00, 1081.67it/s]\n[MoviePy] Done.\n```", "```py\n# ls -l *.mp3 -rw-r--r--@ 1 michaelheydt  staff  12931074 Sep 27 21:44 movie_audio.mp3\n```"]