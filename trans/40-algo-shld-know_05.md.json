["```py\nimport findspark\nfindspark.init()\nfrom pyspark.sql import SparkSession\nspark = SparkSession.builder.master(\"local[*]\").getOrCreate()\nsc = spark.sparkContext\n```", "```py\nwordsList = ['python', 'java', 'ottawa', 'ottawa', 'java','news']\nwordsRDD = sc.parallelize(wordsList, 4)\n# Print out the type of wordsRDD\nprint (wordsRDD.collect())\n```", "```py\nimport random\nfrom itertools import permutations\nalltours = permutations \n\ndef distance_tour(aTour):\n    return sum(distance_points(aTour[i - 1], aTour[i]) \n               for i in range(len(aTour)))\n\naCity = complex\n\ndef distance_points(first, second): return abs(first - second)\n\ndef generate_cities (number_of_cities):\n    seed=111;width=500;height=300\n    random.seed((number_of_cities, seed))\n    return frozenset(aCity(random.randint(1, width), random.randint(1, height))\n                     for c in range(number_of_cities))\n```", "```py\ndef brute_force(cities):\n    \"Generate all possible tours of the cities and choose the shortest \n     tour.\"\n    return shortest_tour(alltours(cities))\n\ndef shortest_tour(tours): return min(tours, key=distance_tour)\n```", "```py\n%matplotlib inline\nimport matplotlib.pyplot as plt\ndef visualize_tour(tour, style='bo-'): \n    if len(tour) > 1000: plt.figure(figsize=(15, 10))\n    start = tour[0:1]\n    visualize_segment(tour + start, style)\n    visualize_segment(start, 'rD') \n\ndef visualize_segment (segment, style='bo-'):\n    plt.plot([X(c) for c in segment], [Y(c) for c in segment], style, clip_on=False)\n    plt.axis('scaled')\n    plt.axis('off')\n\ndef X(city): \"X axis\"; return city.real\ndef Y(city): \"Y axis\"; return city.imag\n```", "```py\ndef greedy_algorithm(cities, start=None):\n    C = start or first(cities)\n    tour = [C]\n    unvisited = set(cities - {C})\n    while unvisited:\n        C = nearest_neighbor(C, unvisited)\n        tour.append(C)\n        unvisited.remove(C)\n    return tour\n\ndef first(collection): return next(iter(collection))\n\ndef nearest_neighbor(A, cities):\n    return min(cities, key=lambda C: distance_points(C, A))\n```", "```py\nimport numpy as np import networkx as nx import matplotlib.pyplot as plt %matplotlib inline\n```", "```py\nmyWeb = nx.DiGraph() myPages = range(1,5)\n```", "```py\nconnections = [(1,3),(2,1),(2,3),(3,1),(3,2),(3,4),(4,5),(5,1),(5,4)] myWeb.add_nodes_from(myPages) myWeb.add_edges_from(connections)\n```", "```py\npos=nx.shell_layout(myWeb) nx.draw(myWeb, pos, arrows=True, with_labels=True) plt.show()\n```", "```py\nimport pulp\n```", "```py\n# Instantiate our problem class\nmodel = pulp.LpProblem(\"Profit maximising problem\", pulp.LpMaximize)\n```", "```py\nA = pulp.LpVariable('A', lowBound=0, cat='Integer') \nB = pulp.LpVariable('B', lowBound=0, cat='Integer')\n```", "```py\n# Objective function\nmodel += 5000 * A + 2500 * B, \"Profit\"\n\n# Constraints\nmodel += 3 * A + 2 * B <= 20 \nmodel += 4 * A + 3 * B <= 30\nmodel += 4 * A + 3 * B <= 44\n```", "```py\n# Solve our problem\nmodel.solve()\npulp.LpStatus[model.status]\n```"]