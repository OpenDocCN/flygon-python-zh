- en: File I/O and Python Utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件I/O和Python工具
- en: In this chapter, we are going to discuss file I/O, that is reading, writing
    and appending to file in detail. We are also going to discuss Python utilities
    that enable manipulating files and interacting with the operating system. Each
    topic has a different level of complexity that we will discuss using an example.
    Let's get started!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细讨论文件I/O，即读取、写入和追加文件。我们还将讨论Python工具，这些工具使得操作文件和与操作系统交互成为可能。每个主题都有不同的复杂程度，我们将通过一个例子来讨论。让我们开始吧！
- en: File I/O
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件I/O
- en: 'We are discussing file I/O for two reasons:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论文件I/O有两个原因：
- en: 'In the world of Linux operating systems, everything is a file. Interaction
    with peripherals on the Raspberry Pi is similar to reading from/writing to a file.
    For example: In [Chapter 12](80544a34-7914-4217-9baa-1d0b0b450061.xhtml) , *Communication
    Interfaces*, we discussed serial port communication. You should be able to observe
    that serial port communication is like a file read/write operation.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux操作系统的世界中，一切都是文件。与树莓派上的外围设备交互类似于读取/写入文件。例如：在[第12章](80544a34-7914-4217-9baa-1d0b0b450061.xhtml)中，*通信接口*，我们讨论了串口通信。您应该能够观察到串口通信类似于文件读写操作。
- en: 'We use file I/O in some form in every project. For example: Writing sensor
    data to a CSV file or reading pre-configured options for a web server, and so
    on.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在每个项目中以某种形式使用文件I/O。例如：将传感器数据写入CSV文件，或者读取Web服务器的预配置选项等。
- en: 'Hence, we thought it would be useful to discuss file I/O in Python as its own
    chapter (detailed documentation available from here: [https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files](https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files))
    and discuss examples where it could play a role while developing applications
    on the Raspberry Pi Zero.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们认为讨论Python中的文件I/O作为一个单独的章节会很有用（详细文档请参阅：[https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files](https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files)），并讨论它在开发树莓派Zero应用程序时可能发挥作用的示例。
- en: Reading from a file
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中读取
- en: 'Let''s create a simple text file, `read_file.txt` with the following text:
    `I am learning Python Programming using the Raspberry Pi Zero` and save it to
    the code samples directory (or any location of your choice).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的文本文件`read_file.txt`，其中包含以下文本：`我正在使用树莓派Zero学习Python编程`，并将其保存到代码示例目录（或您选择的任何位置）。
- en: 'To read from a file, we need to make use of the Python''s in-built function:
    `open` to open the file. Let''s take a quick look at a code snippet that demonstrates
    opening a text file to read its content and print it to the screen:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件中读取，我们需要使用Python的内置函数：`open`来打开文件。让我们快速看一下一个代码片段，演示如何打开一个文本文件以读取其内容并将其打印到屏幕上：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s discuss this code snippet in detail:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论这段代码片段：
- en: The first step in reading the contents of the text file is opening the file
    using the in-built function `open`. The file in question needs to be passed as
    an argument along with a flag `r` that indicates we are opening the file to read
    the contents (We will discuss other flag options as we discuss each reading/writing
    files.)
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取文本文件内容的第一步是使用内置函数`open`打开文件。需要将所需的文件作为参数传递，并且还需要一个标志`r`，表示我们打开文件以读取内容（随着我们讨论每个读取/写入文件时，我们将讨论其他标志选项）。
- en: Upon opening the file, the `open` function returns a pointer (address to the
    file object) that is stored in the `file` variable.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件时，`open`函数返回一个指针（文件对象的地址），并将其存储在`file`变量中。
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This file pointer is used to read the contents of the file and print it to
    the screen:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个文件指针用于读取文件的内容并将其打印到屏幕上：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After reading the contents of the file, the file is closed by calling the `close()` function.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取文件的内容后，通过调用`close()`函数关闭文件。
- en: 'Run the preceding code snippet (available for download along with this chapter—`read_from_file.py`)
    using IDLE3 or the command-line terminal. The contents of the text file would
    be printed to the screen as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码片段（可与本章一起下载的`read_from_file.py`）使用IDLE3或命令行终端。文本文件的内容将如下打印到屏幕上：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Reading lines
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取行
- en: 'Sometimes, it is necessary to read the contents of a file by line-by-file.
    In Python, there are two options to do this: `readline()` and `readlines()`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有必要逐行读取文件的内容。在Python中，有两种选项可以做到这一点：`readline()`和`readlines()`：
- en: '`readline()`: As the name suggests, this in-built function enables reading
    one line at a time. Let''s review this using an example:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readline()`: 正如其名称所示，这个内置函数使得逐行读取成为可能。让我们通过一个例子来复习一下：'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When the preceding code snippet is executed (available for download as `read_line_from_file.py` along
    with this chapter), the `read_line.txt` file is opened and a single line is returned
    by the `readline()` function. This line is stored in the variable data. Since
    the function is called twice in this program, the output is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码片段（可与本章一起下载，文件名为`read_line_from_file.py`）时，`read_line.txt`文件被打开，并且`readline()`函数返回一行。这一行被存储在变量data中。由于该函数在程序中被调用两次，输出如下：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A new line is returned every time the `readline` function is called and it returns
    an empty string when the end-of-file has reached.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`readline`函数时都会返回一个新行，并且当到达文件结尾时会返回一个空字符串。
- en: '`readlines()`: This function reads the entire content of a file in lines and
    stores each it to a list:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readlines()`: 这个函数逐行读取文件的全部内容，并将每一行存储到一个列表中：'
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since the lines of the files is stored as a list, it could be retrieved by
    iterating through the list:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件的行被存储为一个列表，可以通过对列表进行迭代来检索它：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code snippet is available for download along with this chapter
    as `read_lines_from_file.py`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段可与本章一起下载，文件名为`read_lines_from_file.py`。
- en: Writing to a file
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入文件
- en: 'Perform the following steps in order to write to a file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行写入文件：
- en: 'The first step in writing to a file is opening a file with the write flag:
    `w`. If the file name that was passed as an argument doesn''t exist, a new file
    is created:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入文件的第一步是使用写入标志`w`打开文件。如果作为参数传递的文件名不存在，将创建一个新文件：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the file is open, the next step is passing the string to be written as
    argument to the `write()` function:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件打开后，下一步是将要写入的字符串作为参数传递给`write()`函数：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s put the code together where we write a string to a text file, close
    it, re-open the file and print the contents of the file to the screen:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将代码放在一起，我们将一个字符串写入文本文件，关闭它，重新打开文件并将文件的内容打印到屏幕上：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code snippet is available for download along with this chapter
    (`write_to_file.py`).
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的代码片段可与本章一起下载（`write_to_file.py`）。
- en: 'When the preceding code snippet is executed, the output is shown as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行前面的代码片段时，输出如下所示：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Appending to a file
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追加到文件
- en: 'Whenever a file is opened using the write flag `w`, the contents of the file
    are deleted and opened afresh to write data. There is an alternative flag `a`
    that enables appending data to the end of the file. This flag also creates a new
    file if the file (that is passed as an argument to open) doesn''t exist. Let''s
    consider the code snippet below where we append a line to the text file `write_file.txt`
    from the previous section:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每当使用写入标志`w`打开文件时，文件的内容都会被删除，并重新打开以写入数据。还有一个叫做`a`的替代标志，它使得可以将数据追加到文件的末尾。如果打开的文件（作为打开的参数）不存在，这个标志也会创建一个新文件。让我们考虑下面的代码片段，我们将一行追加到上一节中的文本文件`write_file.txt`中：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When the preceding code snippet is executed (available for download along with
    this chapter—`append_to_file.py`), the string `This is a line appended to the
    file` is appended to the end of the text of the file. The contents of the file
    will include the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码片段（可与本章一起下载的`append_to_file.py`）时，字符串`This is a line appended to the
    file`将被追加到文件的文本末尾。文件的内容将包括以下内容：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: seek
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找
- en: 'Once a file is opened, the file pointer that is used in file I/O moves from
    the beginning to the end of the file. It is possible to move the pointer to a
    specific position and read the data from that position. This is especially useful
    when we are interested in a specific line of a file. Let''s consider the text
    file `write_file.txt` from the previous example. The contents of the file include:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被打开，文件I/O中使用的文件指针会从文件的开头移动到文件的末尾。可以将指针移动到特定位置并从该位置读取数据。当我们对文件的特定行感兴趣时，这是非常有用的。让我们考虑上一个例子中的文本文件`write_file.txt`。文件的内容包括：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s try to skip the first line and read only the second line using `seek`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试跳过第一行，只读取第二行，使用`seek`：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding example (available for download along with this chapter as
    `seek_in_file.py`), the `seek` function is used to move the pointer to byte `53`
    that is the end of first line. Then the file''s contents are read and stored into
    the variable. When this code snippet is executed, the output is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中（可与本章一起下载的`seek_in_file.py`），`seek`函数用于将指针移动到字节`53`，即第一行的末尾。然后文件的内容被读取并存储到变量中。当执行这个代码片段时，输出如下所示：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Thus, seek enables moving the file pointer to a specific position.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，seek使得移动文件指针到特定位置成为可能。
- en: Read n bytes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取n个字节
- en: The `seek` function enables moving the pointer to a specific position and reading
    a byte or `n` bytes from that position. Let's re-visit reading `write_file.txt`
    and try to read the word `excited` in the sentence `I am excited to learn Python
    using Raspberry Pi Zero`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`seek`函数使得将指针移动到特定位置并从该位置读取一个字节或`n`个字节成为可能。让我们重新阅读`write_file.txt`，并尝试读取句子`I
    am excited to learn Python using Raspberry Pi Zero`中的单词`excited`。'
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code can be explained in the following steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以通过以下步骤来解释：
- en: In the first step, the file is opened using the `read` flag and the file pointer
    is set to the fifth byte (using `seek`)—the position of the letter `e` in the
    contents of the text file.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步，使用`read`标志打开文件，并将文件指针设置为第五个字节（使用`seek`）——文本文件内容中字母`e`的位置。
- en: 'Now, we read one byte from the file by passing it as an argument to the `read`
    function. When an integer is passed as an argument, the `read` function returns
    the corresponding number of bytes from the file. When no argument is passed, it
    reads the entire file. The `read` function returns an empty string if the file
    is empty:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过将文件作为参数传递给`read`函数来从文件中读取一个字节。当整数作为参数传递时，`read`函数会从文件中返回相应数量的字节。当没有传递参数时，它会读取整个文件。如果文件为空，`read`函数会返回一个空字符串：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the second part, we try to read the word `excited` from the text file. We
    rewind the position of the pointer back to the fifth byte. Then we read seven
    bytes from the file (length of the word `excited`).
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二部分中，我们尝试从文本文件中读取单词`excited`。我们将指针的位置倒回到第五个字节。然后我们从文件中读取七个字节（单词`excited`的长度）。
- en: 'When the code snippet is executed (available for download along with this chapter
    as `seek_to_read.py`), the program should print the letter `e` and the word `excited`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行代码片段时（可与本章一起下载的`seek_to_read.py`），程序应该打印字母`e`和单词`excited`：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: r+
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: r+
- en: We discussed reading and writing to files using the `r` and `w` flags. There
    is another called `r+`. This flag enables reading and writing to a file. Let's
    review an example that enables us to understand this flag.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了使用`r`和`w`标志读取和写入文件。还有另一个叫做`r+`的标志。这个标志使得可以对文件进行读取和写入。让我们回顾一个例子，以便理解这个标志。
- en: 'Let''s review the contents of `write_file.txt` once again:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回顾`write_file.txt`的内容：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s modify the second line to read: `This is a line that was modified`.
    The code sample is available for download along with this chapter as `seek_to_write.py`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改第二行，改为：`This is a line that was modified`。代码示例可与本章一起下载（`seek_to_write.py`）。
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s review how this example works:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这个例子是如何工作的：
- en: The first step in this example is opening the file using the `r+` flag. This
    enables reading and writing to the file.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个例子的第一步是使用`r+`标志打开文件。这使得可以对文件进行读取和写入。
- en: The next step is moving to the 68th byte of the file
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是移动到文件的第68个字节
- en: The `that was modified` string is written to the file at this position. The
    spaces at the end of the string are used to overwrite the original content of
    the second sentence.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个位置将`that was modified`字符串写入文件。字符串末尾的空格用于覆盖第二句原始内容。
- en: Now, the file pointer is set to the beginning of the file and its contents are
    read.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，文件指针已设置到文件的开头，并读取其内容。
- en: 'When the preceding code snippet is executed, the modified file contents are
    printed to the screen as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行前面的代码片段时，修改后的文件内容将打印到屏幕上，如下所示：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There is another `a+` flag that enables appending data to the end of the file
    and reading at the same time. We will leave this to the reader to figure out using
    the examples discussed so far.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个`a+`标志，它可以使数据追加到文件末尾并同时进行读取。我们将留给读者使用到目前为止讨论的示例来弄清楚这一点。
- en: We have discussed different examples on reading and writing to files in Python.
    It can be overwhelming without sufficient experience in programming. We strongly
    recommend working through the different code samples provided in this chapter
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Python中读取和写入文件的不同示例。如果没有足够的编程经验，可能会感到不知所措。我们强烈建议通过本章提供的不同代码示例进行实际操作。
- en: Challenge to the reader
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读者的挑战
- en: Use the `a+` flag to open the `write_file.txt` file (discussed in different
    examples) and append a line to the file. Set the file pointer using `seek` and
    print its contents. You may open the file only once in the program.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`a+`标志打开`write_file.txt`文件（在不同的示例中讨论），并向文件追加一行。使用`seek`设置文件指针并打印其内容。您可以在程序中只打开文件一次。
- en: The with keyword
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`with`关键字
- en: So far, we discussed different flags that could be used to open files in different
    modes. The examples we discussed followed a common pattern—open the file, perform
    read/write operations and close the file. There is an elegant way of interacting
    with files using the `with` keyword.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了可以用于以不同模式打开文件的不同标志。我们讨论的示例遵循一个常见模式——打开文件，执行读/写操作，然后关闭文件。有一种优雅的方式可以使用`with`关键字与文件交互。
- en: 'If there are any errors during the execution of the code block that interacts
    with a file, the `with` keyword ensures that the file is closed and the associated
    resources are cleaned up on exiting the code block. As always, let''s review the
    `with` keyword with an example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在与文件交互的代码块执行过程中出现任何错误，`with`关键字会确保在退出代码块时关闭文件并清理相关资源。让我们通过一个示例来回顾`with`关键字：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding example (`with_keyword_example`), we skipped closing the file
    as the `with` keyword takes care of closing the file once the execution of the
    indented code block is complete. The `with` keyword also takes care of closing
    the file while leaving the code block due to an error. This ensures that the resources
    are cleaned up properly in any scenario. Going forward, we will be using the `with`
    keyword for file I/O.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例（`with_keyword_example`）中，我们跳过了关闭文件，因为`with`关键字在缩进的代码块执行完毕后会自动关闭文件。`with`关键字还会在由于错误离开代码块时关闭文件。这确保了资源在任何情况下都能得到适当的清理。接下来，我们将使用`with`关键字进行文件I/O。
- en: configparser
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: configparser
- en: Let's discuss some aspects of Python programming that is especially helpful
    while developing applications using the Raspberry Pi. One such tool is the `configparser`
    available in Python. The `configparser` module ([https://docs.python.org/3.4/library/configparser.html](https://docs.python.org/3.4/library/configparser.html))
    is used to read/write config files for applications.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些在使用树莓派开发应用程序时特别有用的Python编程方面。其中一个工具是Python中提供的`configparser`。`configparser`模块（[https://docs.python.org/3.4/library/configparser.html](https://docs.python.org/3.4/library/configparser.html)）用于读取/写入应用程序的配置文件。
- en: In software development, config files are generally used to store constants
    such as access credentials, device ID, and so on In the context of a Raspberry
    Pi, `configparser` could be used to store the list of all GPIO pins in use, addresses
    of sensors interfaced via the I²C interface, and so on. Let's discuss three examples
    where we learn making use of the `configparser` module. In the first example we
    will create a `config` file using the `configparser`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，配置文件通常用于存储常量，如访问凭据、设备ID等。在树莓派的上下文中，`configparser`可以用于存储所有使用的GPIO引脚列表，通过I²C接口接口的传感器地址等。让我们讨论三个示例，学习如何使用`configparser`模块。在第一个示例中，我们将使用`configparser`创建一个`config`文件。
- en: In the second example, we will make use of the `configparser` to read the config
    values and in the third example, we will discuss modifying config files in the
    final example.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们将使用`configparser`来读取配置值，在第三个示例中，我们将讨论修改配置文件的最终示例。
- en: '**Example 1**:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例1**：'
- en: 'In the first example, let''s create a config file that stores information including
    device ID, GPIO pins in use, sensor interface address, debug switch, and access
    credentials:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，让我们创建一个配置文件，其中包括设备ID、使用的GPIO引脚、传感器接口地址、调试开关和访问凭据等信息：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s discuss the preceding code example (available for download along with
    this chapter as `config_parser_write.py`) in detail:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论前面的代码示例（可与本章一起下载作为`config_parser_write.py`）：
- en: 'The first step is importing the `configparser` module and creating an instance
    of the `ConfigParser` class. This instance is going to be called `config_parser`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是导入`configparser`模块并创建`ConfigParser`类的实例。这个实例将被称为`config_parser`：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, we open a config file called `raspi.cfg` using the `with` keyword. Since
    the file doesn't exist, a new config file is created.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`with`关键字打开名为`raspi.cfg`的配置文件。由于文件不存在，将创建一个新的配置文件。
- en: The config file is going to consist of two sections namely `AppInfo` and `Credentials`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置文件将包括两个部分，即`AppInfo`和`Credentials`。
- en: 'The two sections could be created using the `add_section` method as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`add_section`方法创建两个部分，如下所示：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Each section is going to consist of different set of constants. Each constant
    could be added to the relevant section using the `set` method. The required arguments
    to the `set` method include the section name (under which the parameter/constant
    is going to be located), the name of the parameter/constant and its corresponding
    value. For example: The `id` parameter can be added to the `AppInfo` section and
    assigned a value of `123` as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个部分将包含不同的常量集。可以使用`set`方法将每个常量添加到相关部分。`set`方法的必需参数包括参数/常量将位于的部分名称，参数/常量的名称及其对应的值。例如：`id`参数可以添加到`AppInfo`部分，并分配值`123`如下：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The final step is saving these config values to the file. This is accomplished
    using the `config_parser` method, `write`. The file is closed once the program
    exits the indented block under the `with` keyword:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将这些配置值保存到文件中。这是使用`config_parser`方法`write`完成的。一旦程序退出`with`关键字下的缩进块，文件就会关闭：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We strongly recommend trying the code snippets yourself and use these snippets
    as a reference. You will learn a lot by making mistakes and possibly arrive with
    a better solution than the one discussed here.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议尝试自己尝试代码片段，并将这些片段用作参考。通过犯错误，您将学到很多，并可能得出比这里讨论的更好的解决方案。
- en: 'When the preceding code snippet is executed, a config file called `raspi.cfg`
    is created. The contents of the config file would include the contents shown as
    follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码片段时，将创建一个名为`raspi.cfg`的配置文件。配置文件的内容将包括以下内容所示的内容：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Example 2**:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例2**：'
- en: 'Let''s discuss an example where we read config parameters from a config file
    created in the previous example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一个示例，我们从先前示例中创建的配置文件中读取配置参数：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If the config files are created in the format shown, the `ConfigParser` class
    should be able to parse it. It is not really necessary to create config files
    using a Python program. We just wanted to show programmatic creation of config
    files as it is easier to programmatically create config files for multiple devices
    at the same time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配置文件以所示格式创建，`ConfigParser`类应该能够解析它。实际上并不一定要使用Python程序创建配置文件。我们只是想展示以编程方式同时为多个设备创建配置文件更容易。
- en: 'The preceding example is available for download along with this chapter (`config_parser_read.py`).
    Let''s discuss how this code sample works:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例可与本章一起下载（`config_parser_read.py`）。让我们讨论一下这个代码示例是如何工作的：
- en: The first step is initializing an instance of the `ConfigParser` class called
    `config_parser`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是初始化名为`config_parser`的`ConfigParser`类的实例。
- en: The second step is loading and reading the config file using the instance method
    `read`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是使用实例方法`read`加载和读取配置文件。
- en: 'Since we know the structure of the config file, let''s go ahead and read some
    constants available under the section `AppInfo`. The config file parameters can
    be read using the `get` method. The required arguments include the section under
    which the config parameter is located and the name of the parameter. For example:
    The config `id` parameter is located under the `AppInfo` section. Hence, the required
    arguments to the method include `AppInfo` and `id`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们知道配置文件的结构，让我们继续阅读位于`AppInfo`部分下可用的一些常量。可以使用`get`方法读取配置文件参数。必需的参数包括配置参数所在的部分以及参数的名称。例如：配置`id`参数位于`AppInfo`部分下。因此，该方法的必需参数包括`AppInfo`和`id`：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that the config parameters are read into variables, let''s make use of
    it in our program. For example: Let''s test if the `debug_switch` variable (a
    switch to determine if the program is in debug mode) and print the other config
    parameters that were retrieved from the file:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在配置参数已读入变量中，让我们在程序中使用它。例如：让我们测试`debug_switch`变量（用于确定程序是否处于调试模式）并打印从文件中检索到的其他配置参数：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Example 3**:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例3**：'
- en: Let's discuss an example where we would like to modify an existing config file.
    This is especially useful in situations where we need to update the firmware version
    number in the config file after performing a firmware update.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一个示例，我们想要修改现有的配置文件。这在需要在执行固件更新后更新配置文件中的固件版本号时特别有用。
- en: 'The following code snippet is available for download as `config_parser_modify.py` along
    with this chapter:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段可与本章一起下载，文件名为`config_parser_modify.py`：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s discuss how this works:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下这是如何工作的：
- en: 'As always, the first step is initializing an instance of the `ConfigParser`
    class. The config file is loaded using the method `read`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与往常一样，第一步是初始化`ConfigParser`类的实例。使用`read`方法加载配置文件：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The required parameter is updated using the `set` method (discussed in a previous
    example):'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`set`方法更新必需参数（在先前的示例中讨论）：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The updated config is saved to the config file using the `write` method:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`write`方法将更新后的配置保存到配置文件中：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Challenge to the reader
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读者的挑战
- en: Using example 3 as a reference, update the config parameter `debug_switch` to
    the value `False`. Repeat example 2 and see what happens.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用示例3作为参考，将配置参数`debug_switch`更新为值`False`。重复示例2，看看会发生什么。
- en: Reading/writing to CSV files
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取/写入CSV文件
- en: In this section, we are going to discuss reading/writing to CSV files. This
    module ([https://docs.python.org/3.4/library/csv.html](https://docs.python.org/3.4/library/csv.html))
    is useful in data logging applications. Since we will be discussing data logging
    in the next chapter, let's review reading/writing to CSV files.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论读取/写入CSV文件。这个模块（[https://docs.python.org/3.4/library/csv.html](https://docs.python.org/3.4/library/csv.html)）在数据记录应用程序中非常有用。由于我们将在下一章讨论数据记录，让我们回顾一下读取/写入CSV文件。
- en: Writing to CSV files
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入CSV文件
- en: 'Let''s consider a scenario where we are reading data from different sensors.
    This data needs to be recorded to a CSV file where each column corresponds to
    a reading from a specific sensor. We are going to discuss an example where we
    record the value `123`, `456`, and `789` in the first row of the CSV file and
    the second row is going to consist of values including `Red`, `Green`, and `Blue`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景，我们正在从不同的传感器读取数据。这些数据需要记录到一个CSV文件中，其中每一列对应于来自特定传感器的读数。我们将讨论一个例子，其中我们在CSV文件的第一行记录值`123`、`456`和`789`，第二行将包括值`Red`、`Green`和`Blue`：
- en: 'The first step in writing to a CSV file is opening a CSV file using the `with`
    keyword:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入CSV文件的第一步是使用`with`关键字打开CSV文件：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The next step is initializing an instance of the `writer` class of the CSV module:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是初始化CSV模块的`writer`类的实例：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, each row is added to the file by creating a list that contains all the
    elements that need to be added to a row. For example: The first row can be added
    to the list as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过创建一个包含需要添加到行中的所有元素的列表，将每一行添加到文件中。例如：第一行可以按如下方式添加到列表中：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Putting it altogether, we have:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有内容放在一起，我们有：
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When the above code snippet is executed (available for download as `csv_write.py`
    along with this chapter), a CSV file is created in the local directory with the
    following contents:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行上述代码片段（与本章一起提供的`csv_write.py`可下载）时，在本地目录中创建了一个CSV文件，其中包含以下内容：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Reading from CSV files
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从CSV文件中读取
- en: 'Let''s discuss an example where we read the contents of the CSV file created
    in the previous section:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一个例子，我们读取上一节中创建的CSV文件的内容：
- en: 'The first step in reading a CSV file is opening it in read mode:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取CSV文件的第一步是以读模式打开它：
- en: '[PRE42]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we initialize an instance of the `reader` class from the CSV module.
    The contents of the CSV file are loaded into the object `csv_reader`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们初始化CSV模块的`reader`类的实例。CSV文件的内容被加载到对象`csv_reader`中：
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now that the contents of the CSV file are loaded, each row of the CSV file
    could be retrieved as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在CSV文件的内容已加载，可以按如下方式检索CSV文件的每一行：
- en: '[PRE44]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Put it all together:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有内容放在一起：
- en: '[PRE45]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When the preceding code snippet is executed (available for download along with
    this chapter as `csv_read.py`), the contents of the file are printed row-by-row
    where each row is a list that contains the comma separated values:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行上述代码片段（与本章一起提供的`csv_read.py`可下载）时，文件的内容将逐行打印，其中每一行都是一个包含逗号分隔值的列表：
- en: '[PRE46]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Python utilities
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python实用程序
- en: Python comes with several utilities that enables interacting with other files
    and the operating system itself. We have identified all those Python utilities
    that we have used in our past projects. Let's discuss the different modules and
    their uses as we might use them in the final project of this book.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Python带有几个实用程序，可以与其他文件和操作系统本身进行交互。我们已经确定了我们在过去项目中使用过的所有这些Python实用程序。让我们讨论不同的模块及其用途，因为我们可能会在本书的最终项目中使用它们。
- en: The os module
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: os模块
- en: As the name suggests, this module ([https://docs.python.org/3.1/library/os.html](https://docs.python.org/3.1/library/os.html))
    enables interacting with the operating system. Let's discuss some of its applications
    with examples.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，这个模块（[https://docs.python.org/3.1/library/os.html](https://docs.python.org/3.1/library/os.html)）可以与操作系统进行交互。让我们通过示例讨论一些应用。
- en: Checking a file's existence
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查文件是否存在
- en: 'The `os` module could be used to check if a file exists in a specific directory.
    For example: We extensively made use of the `write_file.txt` file. Before opening
    this file to read or write, we could check the file''s existence:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`模块可用于检查特定目录中是否存在文件。例如：我们广泛使用了`write_file.txt`文件。在打开此文件进行读取或写入之前，我们可以检查文件是否存在：'
- en: '[PRE47]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding code snippet, we make use of the `isfile()` function, available
    with the `os.path` module. When a file''s location is passed an argument to the
    function, it returns `True` if the file exists at that location. In this example,
    since the file `write_file.txt` exists in the code examples directory, the function
    returns `True`. Hence the message, `The file exists` is printed to the screen:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们使用了`os.path`模块中提供的`isfile()`函数。当文件位置作为函数的参数传递时，如果文件存在于该位置，则返回`True`。在这个例子中，由于文件`write_file.txt`存在于代码示例目录中，该函数返回`True`。因此屏幕上打印出消息`文件存在`：
- en: '[PRE48]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Checking for a folder's existence
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查文件夹是否存在
- en: 'Similar to `os.path.isfile()`, there is another function called `os.path.isdir()`.
    It returns `True` if a folder exists at a specific location. We have been reviewing
    all code samples from a folder called `code_samples` located on the Raspberry
    Pi''s desktop. It''s existence could be confirmed as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与`os.path.isfile()`类似，还有另一个名为`os.path.isdir()`的函数。如果特定位置存在文件夹，则返回`True`。我们一直在查看位于树莓派桌面上的名为`code_samples`的文件夹中的所有代码示例。可以通过以下方式确认其存在：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Deleting files
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文件
- en: 'The `os` module also enables deleting files using the `remove()` function.
    Any file that is passed as an argument to the function is deleted. In the *File
    I/O* section, we discussed reading from files using the text file, `read_file.txt`.
    Let''s delete the file by passing it as an argument to the `remove()` function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`模块还可以使用`remove()`函数删除文件。将任何文件作为函数的参数传递即可删除该文件。在*文件I/O*部分，我们讨论了使用文本文件`read_file.txt`从文件中读取。让我们通过将其作为`remove()`函数的参数来删除该文件：'
- en: '[PRE50]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Killing a process
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止进程
- en: 'It is possible to kill an application running on the Raspberry Pi by passing
    process `pid` to the `kill()` function. In the previous chapter, we discussed
    the `light_scheduler` example that runs as a background process on the Raspberry
    Pi. To demonstrate killing a process, we are going to attempt killing that process.
    We need to determine the process `pid` of the `light_scheduler` process (you may
    pick an application that was started by you as a user and not do not touch root
    processes). The process `pid` could be retrieved from the command-line terminal
    using the following command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将进程`pid`传递给`kill()`函数来终止在树莓派上运行的应用程序。在上一章中，我们讨论了在树莓派上作为后台进程运行的`light_scheduler`示例。为了演示终止进程，我们将尝试终止该进程。我们需要确定`light_scheduler`进程的进程`pid`（您可以选择由您作为用户启动的应用程序，不要触及根进程）。可以使用以下命令从命令行终端检索进程`pid`：
- en: '[PRE51]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'It spits out the processes currently running on the Raspberry Pi (shown in
    the following figure). The process `pid` for the `light_scheduler` application
    is 1815:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它会显示当前在树莓派上运行的进程（如下图所示）。`light_scheduler`应用程序的进程`pid`为1815：
- en: '![](Images/d74763d0-d5d1-4183-bfba-b820bf9e0784.png)light_scheduler daemon''s
    PID'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/d74763d0-d5d1-4183-bfba-b820bf9e0784.png)light_scheduler守护程序的PID'
- en: 'Assuming we know the process `pid` of the application that needs to be killed,
    let''s review killing the function using `kill()`. The arguments required to kill
    the function include the process `pid` and signal (`signal.SIGKILL`) that needs
    to be sent to the process to kill the application:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们知道需要终止的应用程序的进程`pid`，让我们回顾使用`kill()`函数终止该函数。终止函数所需的参数包括进程`pid`和需要发送到进程以终止应用程序的信号（`signal.SIGKILL`）：
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `signal` module ([https://docs.python.org/3/library/signal.html)](https://docs.python.org/2/library/signal.html))
    contains the constants that represents the signals that could be used to stop
    an application. In this code snippet, we make use of the `SIGKILL` signal. Try
    running the `ps` command (`ps aux`) and you will notice that the `light_scheduler`
    application has been killed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`signal`模块（[https://docs.python.org/3/library/signal.html)](https://docs.python.org/2/library/signal.html)）包含表示可用于停止应用程序的信号的常量。在此代码片段中，我们使用了`SIGKILL`信号。尝试运行`ps`命令（`ps
    aux`），您会注意到`light_scheduler`应用程序已被终止。'
- en: Monitoring a process
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控一个进程
- en: In the previous example, we discussed killing an application using the `kill()`
    function. You might have noticed that we made use of something called the `try`/`except`
    keywords to attempt killing the application. We will discuss these keywords in
    detail in the next chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们讨论了使用`kill()`函数终止应用程序。您可能已经注意到，我们使用了称为`try`/`except`关键字来尝试终止应用程序。我们将在下一章详细讨论这些关键字。
- en: It is also possible to monitor whether an application is running using the `kill()`
    function using the `try`/`except` keywords. We will discuss monitoring processes
    using the `kill()` function after introducing the concept of trapping exceptions
    using `try`/`except` keywords.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`try`/`except`关键字使用`kill()`函数来监视应用程序是否正在运行。在介绍使用`try`/`except`关键字捕获异常的概念后，我们将讨论使用`kill()`函数监视进程。
- en: All examples discussed in the `os` module are available for download along with
    this chapter as `os_utils.py`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`模块中讨论的所有示例都可以与本章一起下载，文件名为`os_utils.py`。'
- en: The glob module
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: glob模块
- en: 'The `glob` module ([https://docs.python.org/3/library/glob.html](https://docs.python.org/3/library/glob.html))
    enables identifying files of a specific extension or files that have a specific
    pattern. For example, it is possible to list all Python files in a folder as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`glob`模块（[https://docs.python.org/3/library/glob.html](https://docs.python.org/3/library/glob.html)）使得能够识别具有特定扩展名或特定模式的文件。例如，可以列出文件夹中的所有Python文件如下：'
- en: '[PRE53]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `glob()` function returns a list of files that contains the `.py` extension.
    A `for` loop is used to iterate through the list and print each file. When the
    preceding code snippet is executed, the output contains the list of all code samples
    belonging to this chapter (output truncated for representation):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`glob()`函数返回一个包含`.py`扩展名的文件列表。使用`for`循环来遍历列表并打印每个文件。当执行前面的代码片段时，输出包含属于本章的所有代码示例的列表（输出被截断以表示）：'
- en: '[PRE54]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This module is especially helpful with listing files that have a specific pattern.
    For example: Let''s consider a scenario where you would like to upload files that
    were created from different trials of an experiment. You are only interested in
    files that are of the following format: `file1xx.txt` where `x` stands for any
    digit between `0` and `9`. Those files could be sorted and listed as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块在列出具有特定模式的文件时特别有帮助。例如：让我们考虑这样一个场景，您想要上传来自实验不同试验的文件。您只对以下格式的文件感兴趣：`file1xx.txt`，其中`x`代表`0`到`9`之间的任意数字。这些文件可以按以下方式排序和列出：
- en: '[PRE55]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding example, `[0-9]` means that the file name could contain any
    digit between `0` and `9`. Since we are looking for files of the `file1xx.txt` format,
    the search pattern that is passed an argument to the `glob()` function is `file1[0-9][0-9].txt`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`[0-9]`表示文件名可以包含`0`到`9`之间的任意数字。由于我们正在寻找`file1xx.txt`格式的文件，因此作为参数传递给`glob()`函数的搜索模式是`file1[0-9][0-9].txt`。
- en: 'When the preceding code snippet is executed, the output contains all text files
    of the specified format:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码片段时，输出包含指定格式的所有文本文件：
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We came across this article that explains the use of expressions for sorting
    files: [http://www.linuxjournal.com/content/bash-extended-globbing](http://www.linuxjournal.com/content/bash-extended-globbing).
    The same concept can be extended to searching for files using the `glob` module.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了一篇解释使用表达式对文件进行排序的文章：[http://www.linuxjournal.com/content/bash-extended-globbing](http://www.linuxjournal.com/content/bash-extended-globbing)。相同的概念可以扩展到使用`glob`模块搜索文件。
- en: Challenge to the reader
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读者的挑战
- en: 'The examples discussed with the `glob` module are available for download along
    with this chapter as `glob_example.py`. In one of the examples, we discussed listing
    files of a specific format. How would you go about listing files that are of the
    following format: `filexxxx.*`? (Here `x` represents any number between `0` and
    `9`. `*` represents any file extension.)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`glob`模块讨论的例子可以与本章一起下载，文件名为`glob_example.py`。在其中一个例子中，我们讨论了列出特定格式的文件。你将如何列出以下格式的文件：`filexxxx.*`？（这里的`x`代表`0`到`9`之间的任意数字。`*`代表任何文件扩展名。）
- en: The shutil module
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: shutil模块
- en: 'The `shutil` module ([https://docs.python.org/3/library/shutil.html](https://docs.python.org/3/library/shutil.html))
    enables moving and copying files between folders using the `move()` and `copy()`
    methods. In the previous section, we listed all text files within the folder,
    `txt_files`. Let''s move these files to the current directory (where the code
    is being executed) using `move()`, make a copy of these files once again in `txt_files`
    and finally remove the text files from the current directory:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`shutil`模块（[https://docs.python.org/3/library/shutil.html](https://docs.python.org/3/library/shutil.html)）使得可以使用`move()`和`copy()`方法在文件夹之间移动和复制文件。在上一节中，我们列出了文件夹`txt_files`中的所有文本文件。让我们使用`move()`将这些文件移动到当前目录（代码执行的位置），再次在`txt_files`中复制这些文件，最后从当前目录中删除这些文本文件：'
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding example (available for download along with this chapter as
    `shutil_example.py`), the files are being moved as well as copied from the origin
    to the destination by specifying the source and the destination as the first and
    second arguments respectively.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中（可以与本章一起下载，文件名为`shutil_example.py`），文件被移动和复制，源和目的地分别作为第一个和第二个参数指定。
- en: The files to be moved (or copied) are identified using the `glob` module. Then,
    each file is moved or copied using their corresponding methods.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`glob`模块识别要移动（或复制）的文件，然后使用它们对应的方法移动或复制每个文件。
- en: The subprocess module
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: subprocess模块
- en: 'We briefly discussed this module in the previous chapter. The `subprocess`
    module ([https://docs.python.org/3.2/library/subprocess.html](https://docs.python.org/3.2/library/subprocess.html))
    enables launching another program from within a Python program. One of the commonly
    used functions from the `subprocess` module is `Popen`.Any process that needs
    to be launched from within the program needs to be passed as a list argument to
    the `Popen` function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章简要讨论了这个模块。`subprocess`模块（[https://docs.python.org/3.2/library/subprocess.html](https://docs.python.org/3.2/library/subprocess.html)）使得可以在Python程序内部启动另一个程序。`subprocess`模块中常用的函数之一是`Popen`。需要在程序内部启动的任何进程都需要作为列表参数传递给`Popen`函数：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the preceding example, `tone.wav` (WAVE file that needs to be played) and
    the command that needs to be run are passed as a list argument to the function.
    There are several other commands from the `subprocess` module that serve a similar
    purpose. We leave it to your exploration.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`tone.wav`（需要播放的WAVE文件）和需要运行的命令作为列表参数传递给函数。`subprocess`模块中还有其他几个类似用途的命令。我们留给你去探索。
- en: The sys module
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sys模块
- en: 'The `sys` module ([https://docs.python.org/3/library/sys.html](https://docs.python.org/3/library/sys.html))
    allows interacting with the Python run-time interpreter. One of the functions
    of the `sys` module is parsing command-line arguments provided as inputs to the
    program. Let''s write a program that reads and prints the contents of the file
    that is passed as an argument to the program:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys`模块（[https://docs.python.org/3/library/sys.html](https://docs.python.org/3/library/sys.html)）允许与Python运行时解释器进行交互。`sys`模块的一个功能是解析作为程序输入提供的命令行参数。让我们编写一个程序，读取并打印作为程序参数传递的文件的内容：'
- en: '[PRE59]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Try running the preceding example as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试按以下方式运行前面的例子：
- en: '[PRE60]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The preceding example is available for download along with this chapter as `sys_example.py`.
    The list of command-line arguments passed while running the program are available
    as a `argv` list in the `sys` module. `argv[0]` is usually the name of the Python
    program and `argv[1]` is usually the first argument passed to the function.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子可以与本章一起下载，文件名为`sys_example.py`。在运行程序时传递的命令行参数列表可以在`sys`模块的`argv`列表中找到。`argv[0]`通常是Python程序的名称，`argv[1]`通常是传递给函数的第一个参数。
- en: 'When `sys_example.py` is executed with `read_lines.txt` as an argument, the
    program should print the contents of the text file:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当以`read_lines.txt`作为参数执行`sys_example.py`时，程序应该打印文本文件的内容：
- en: '[PRE61]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed file I/O – reading and writing to files, different
    flags used to read, write, and append to files. We talked about moving file pointers
    to different points in a file to retrieve specific content or overwrite the contents
    of a file at a specific location. We discussed the `ConfigParser` module in Python
    and its application in storing/retrieving config parameters for applications along
    with reading and writing to CSV files.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了文件I/O - 读取和写入文件，以及用于读取、写入和追加文件的不同标志。我们谈到了将文件指针移动到文件的不同位置以检索特定内容或在特定位置覆盖文件内容。我们讨论了Python中的`ConfigParser`模块及其在存储/检索应用程序配置参数以及读写CSV文件中的应用。
- en: Finally, we discussed different Python utilities that have a potential use in
    our project. We will be extensively making use of file I/O and the discussed Python
    utilities in our final project. We strongly recommend familiarizing yourself with
    the concepts discussed in this chapter before moving onto the final projects discussed
    in this book.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了在我们的项目中潜在使用的不同Python工具。我们将广泛使用文件I/O和在本书中讨论的Python工具。我们强烈建议在进入本书中讨论的最终项目之前，熟悉本章讨论的概念。
- en: In the upcoming chapters, we will discuss uploading sensor data stored in CSV files
    to the cloud and logging errors encountered during the execution of an application.
    See you in the next chapter!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论将存储在CSV文件中的传感器数据上传到云端，以及记录应用程序执行过程中遇到的错误。下一章见！
