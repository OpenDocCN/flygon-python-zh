["```py\nfrom pymunk.vec2d import Vec2d\nprint(Vec2d(2, 7))\n\n#add two vectors\nprint(Vec2d(2, 7) + Vec2d((3, 4)))\n\n#results\nVec2d(2, 7)\nVec2d(5, 11)\n```", "```py\nprint(Vec2d(3,4).get_distance(Vec2d(9,0)))\n7.211102550927978\n```", "```py\nimport pymunk\nspace = pymunk.Space() #creating Space instance\nbody = pymunk.Body() #creating Body instance\nobject = pymunk.Circle(body, 4)\nobject.density = 2\n#print body measurements\nprint(\"Mass : {:.0f} and Moment: {:.0f}\".format(body.mass, body.moment))\n\nspace.add(body, object)\nprint(\"Mass: {:.0f} and Moment: {:.0f}\",format(body.mass, body.moment))\n```", "```py\nMass : 0 and Moment: 0\nMass: 101 and Moment: 804\n```", "```py\npymunk.Circle(body, radius_of_circular_shape)\n```", "```py\npymunk.Poly(body, vertices, transform = None, radius = 0)\n```", "```py\npymunk.Segment(body, point1, point2, radius)\n```", "```py\nimport pymunk as p #aliasing pymunk as p\nfrom pymunk import Vec2d #for vector manipulation\n```", "```py\n\nclass RoundBird():\n    def __init__(self, distance, angle, x_pos, y_pos, space):\n        weight = 5\n  r = 12 #radius\n  value_of_inertia = p.moment_for_circle(weight, 0, r, (0, 0))\n        obj_body = p.Body(weight, value_of_inertia)\n        obj_body.position = x_pos, y_pos\n        power_value = distance * 53\n  impulse = power_value * Vec2d(1, 0)\n        angle = -angle\n        obj_body.apply_impulse_at_local_point(impulse.rotated(angle))\n        obj_shape = p.Circle(obj_body, r, (0, 0))\n        obj_shape.elasticity = 0.95 #bouncing angry bird\n  obj_shape.friction = 1 #for roughness\n  obj_shape.collision_type = 0 #for checking collisions later\n  space.add(obj_body, obj_shape)\n        #class RoundBird attribute ----\n  self.body = obj_body\n        self.shape = obj_shape\n```", "```py\n\nclass RoundPig():\n    def __init__(self, x_pos, y_pos, space):\n        self.life = 20 #life will be decreased after \n          collision of pig with bird\n  weight = 5\n  r = 14 #radius\n  value_of_inertia = p.moment_for_circle(weight, 0, r, (0, 0))\n        obj_body = p.Body(weight, value_of_inertia)   \n #creates virtual space to render shape  obj_body.position = x_pos, y_pos\n        #add circle to obj body\n  obj_shape = p.Circle(obj_body, r, (0, 0))\n        obj_shape.elasticity = 0.95\n  obj_shape.friction = 1\n  obj_shape.collision_type = 1\n  space.add(obj_body, obj_shape)\n        self.body = obj_body\n        self.shape = obj_shape\n```", "```py\nimport pymunk as pym\nfrom pymunk import Vec2d\nimport Pygame as pg\nimport math\n```", "```py\nclass Polygon():\n    def __init__(self, position, length, height, space, mass=5.0):\n        value_moment = 1000\n  body_obj = pym.Body(mass, value_moment)\n        body_obj.position = Vec2d(position)\n        shape_obj = pym.Poly.create_box(body_obj, (length, height))\n        shape_obj.color = (0, 0, 255)\n        shape_obj.friction = 0.5\n  shape_obj.collision_type = 2 #adding to check collision later\n  space.add(body_obj, shape_obj)\n        self.body = body_obj\n        self.shape = shape_obj\n       wood_photo = \n          pg.image.load(\"../res/photos/wood.png\").convert_alpha()\n wood2_photo = \n          pg.image.load(\"../res/photos/wood2.png\").convert_alpha()\n rect_wood = pg.Rect(251, 357, 86, 22)\n self.beam_image = wood_photo.subsurface(rect_wood).copy()\n rect_wood2 = pg.Rect(16, 252, 22, 84)\n self.column_image = wood2_photo.subsurface(rect_wood2).copy()\n```", "```py\ndef convert_to_pygame(self, pos):\n    \"\"\"Function that will transform pymunk coordinates to \n         Pygame coordinates\"\"\"\n  return int(pos.x), int(-pos.y+610)\n```", "```py\ndef draw_poly(self, element, screen):\n    \"\"\"Draw beams and columns\"\"\"\n  polygon = self.shape\n\n    if element == 'beams':\n        pos = polygon.body.position\n        pos = Vec2d(self.convert_to_pygame(pos))\n        angle_degrees = math.degrees(polygon.body.angle)\n        rotated_beam = pg.transform.rotate(self.beam_image,\n  angle_degrees)\n offset = Vec2d(rotated_beam.get_size()) / 2.\n  pos = pos - offset\n final_pos = pos\n screen.blit(rotated_beam, (final_pos.x, final_pos.y))\n```", "```py\nif element == 'columns':\n    pos = polygon.body.position\n    pos = Vec2d(self.convert_to_pygame(pos))\n    angle_degrees = math.degrees(polygon.body.angle) + 180\n  rotated_column = pg.transform.rotate(self.column_image,\n  angle_degrees)\n offset = Vec2d(rotated_column.get_size()) / 2.\n  pos = pos - offset\n final_pos = pos\n    screen.blit(rotated_column, (final_pos.x, final_pos.y))\n```", "```py\nimport os\nimport sys\nimport math\nimport time\nimport Pygame\nimport pymunk\nfrom characters import RoundBird #our characters.py file have Bird class\n```", "```py\nPygame.init()\nscreen = Pygame.display.set_mode((1200, 650))\nredbird = Pygame.image.load(\n \"../res/photos/red-bird3.png\").convert_alpha()\nbackground_image = Pygame.image.load(\n \"../res/photos/background3.png\").convert_alpha()\nsling_image = Pygame.image.load(\n \"../res/photos/sling-3.png\").convert_alpha()\nfull_sprite = Pygame.image.load(\n \"../res/photos/full-sprite.png\").convert_alpha()\nrect_screen = Pygame.Rect(181, 1050, 50, 50)\ncropped_image = full_sprite.subsurface(rect_screen).copy()\npig_image = Pygame.transform.scale(cropped_image, (30, 30)) \n#(30, 30) resulting height and width of pig \n```", "```py\nrunning = True  #base physics code space_obj = pymunk.Space()\nspace_obj.gravity = (0.0, -700.0)\n```", "```py\nmouse_distance = 0 #distance after stretch rope_length = 90  angle = 0 mouse_x_pos = 0 mouse_y_pos = 0   mouse_pressed = False time_of_release = 0   initial_x_sling, initial_y_sling = 135, 450 #sling position at rest (not stretched) next_x_sling, next_y_sling = 160, 450\n```", "```py\ntotal_pig = []\ntotal_birds = []\nbeams = []\ncolumns = []\n#color code WHITE = (255, 255, 255)\nRED = (255, 0, 0)\nBLACK = (0, 0, 0)\nBLUE = (0, 0, 255)\n```", "```py\n# Static floor static_floor_body = pymunk.Body(body_type=pymunk.Body.STATIC)\nstatic_lines_first = [pymunk.Segment(static_floor_body, (0.0, 060.0), (1200.0, 060.0), 0.0)]\nstatic_lines_second = [pymunk.Segment(static_floor_body, (1200.0, 060.0), (1200.0, 800.0), 0.0)]\n\n#lets add elasticity and friction to surface for eachLine in static_lines_first:\n    eachLine.elasticity = 0.95\n  eachLine.friction = 1\n  eachLine.collision_type = 3\n  for eachLine in static_lines_second:\n    eachLine.elasticity = 0.95\n  eachLine.friction = 1\n  eachLine.collision_type = 3 space_obj.add(static_lines_first)\n```", "```py\ndef convert_to_pygame(pos):\n    \"\"\" function that performs conversion of pymunk coordinates to\n        Pygame coordinates\"\"\"\n  return int(pos.x), int(-pos.y+600)\n```", "```py\ndef vector(a, b):\n    #return vector from points\n  p = b[0] - a[0]\n    q = b[1] - a[1]\n    return (p, q)\n```", "```py\ndef distance(x0, y0, x1, y1):\n    \"\"\"function to calculate the distance between two points\"\"\"\n  dx = x1 - x0\n    dy = y1 - y0\n    dist = ((dx ** 2) + (dy ** 2)) ** 0.5\n  return dist\n```", "```py\ndef unit_vector(v):\n    \"\"\" returns the unit vector of a point v = (a, b) \"\"\"\n    mag = ((v[0]**2)+(v[1]**2))**0.5\n  if mag == 0:\n        mag = 0.000000000000001\n  unit_p = v[0] / mag #formula to calculate unit vector: vector[i]/magnitude\n    unit_q = v[1] / mag\n    return (unit_p, unit_q)\n```", "```py\n\ndef sling_action():\n    \"\"\"will Set up sling action according to player input events\"\"\"\n  global mouse_distance\n    global rope_length\n    global angle\n    global mouse_x_pos\n    global mouse_y_pos\n```", "```py\n#add code inside sling_action function \"\"\" Fixing bird to the sling rope (Addressing picture 1)\"\"\" vec = vector((initial_x_sling, initial_y_sling), (mouse_x_pos, mouse_y_pos))\nunit_vec = unit_vector(vec)\nuv_1 = unit_vec[0]\nuv_2 = unit_vec[1]\n\nmouse_distance = distance(initial_x_sling, initial_y_sling, mouse_x_pos, mouse_y_pos) \n#mouse_distance is a distance between sling initials point to the point at which currrent bird is \nfix_pos = (uv_1*rope_length+initial_x_sling, uv_2*rope_length+initial_y_sling)\nhighest_length = 102 #when stretched\n```", "```py\n#to make bird stay within rope x_redbird = mouse_x_pos - 20 y_redbird = mouse_y_pos - 20 if mouse_distance > rope_length:\n    pux, puy = fix_pos\n    pux -= 20\n  puy -= 20\n  first_pos = pux, puy\n    screen.blit(redbird, first_pos)\n    second_pos = (uv_1*highest_length+initial_x_sling, uv_2*highest_length+initial_y_sling) #current position ==> second_pos\n\n Pygame.draw.line(screen, (255, 0, 0), (next_x_sling, next_y_sling), second_pos, 5) \n    #front side catapult rope\n  screen.blit(redbird, first_pos)\n    Pygame.draw.line(screen, (255, 0, 0), (initial_x_sling, initial_y_sling), second_pos, 5)  \n #ANOTHER SIDE of catapult\n```", "```py\nelse:\n    #when rope is not fully stretched\n  mouse_distance += 10\n  third_pos = (uv_1*mouse_distance+initial_x_sling, \n      uv_2*mouse_distance+initial_y_sling)\n    Pygame.draw.line(screen, (0, 0, 0), (next_x_sling, next_y_sling), \n      third_pos, 5)\n    screen.blit(redbird, (x_redbird, y_redbird))\n    Pygame.draw.line(screen, (0, 0, 0), (initial_x_sling, \n       initial_y_sling), third_pos, 5)\n```", "```py\n#this is angle of impulse (angle at which bird is projected)\nchange_in_y = mouse_y_pos - initial_y_sling\nchange_in_x = mouse_x_pos - initial_x_sling\nif change_in_x == 0: \n    #if no change in x, we make fall within the area of sling\n    dx = 0.00000000000001 angle = math.atan((float(change_in_y))/change_in_x) #tan-1(dy / dx)\n```", "```py\ndef post_solve_bird_pig(arbiter, space_obj, _):\n    \"\"\"Action to perform after collision between bird and pig\"\"\"   object1, object2 = arbiter.shapes #Arbiter class obj\n  bird_body = object1.body\n    pig_body = object2.body\n    bird_position = convert_to_pygame(bird_body.position)\n    pig_position = convert_to_pygame(pig_body.position)\n    radius = 30\n  Pygame.draw.circle(screen, (255, 0, 0), bird_position, radius, 4)  \n #screen => Pygame surface  Pygame.draw.circle(screen, RED, pig_position, radius, 4)\n    #removal of pig\n  pigs_to_remove = []\n    for pig in total_pig:\n        if pig_body == pig.body:\n            pig.life -= 20 #decrease life\n  pigs_to_remove.append(pig)\n\n    for eachPig in pigs_to_remove:\n        space_obj.remove(eachPig.shape, eachPig.shape.body)\n        total_pig.remove(eachPig)\n```", "```py\ndef post_solve_bird_wood(arbiter, space_obj, _):\n    \"\"\"Action to perform after collision between bird and wood structure\"\"\"\n  #removing polygon\n  removed_poly = []\n    if arbiter.total_impulse.length > 1100:\n        object1, object2 = arbiter.shapes\n        for Each_column in columns:\n            if object2 == Each_column.shape:\n                removed_poly.append(Each_column)\n        for Each_beam in beams:\n            if object2 == Each_beam.shape:\n                removed_poly.append(Each_beam)\n        for Each_poly in removed_poly:\n            if Each_poly in columns:\n                columns.remove(Each_poly)\n            if Each_poly in beams:\n                beams.remove(Each_poly)\n        space_obj.remove(object2, object2.body)\n        #you can also remove bird if you want\n```", "```py\ndef post_solve_pig_wood(arbiter, space_obj, _):\n    \"\"\"Action to perform after collision between pig and wood\"\"\"\n  removed_pigs = []\n    if arbiter.total_impulse.length > 700:\n        pig_shape, wood_shape = arbiter.shapes\n        for pig in total_pig:\n            if pig_shape == pig.shape:\n                pig.life -= 20    if pig.life <= 0: #when life is 0\n  removed_pigs.append(pig)\n    for Each_pig in removed_pigs:\n        space_obj.remove(Each_pig.shape, Each_pig.shape.body)\n        total_pig.remove(Each_pig)\n\n```", "```py\n# bird and pigs space.add_collision_handler(0, 1).post_solve=post_solve_bird_pig\n# bird and wood space.add_collision_handler(0, 2).post_solve=post_solve_bird_wood\n# pig and wood space.add_collision_handler(1, 2).post_solve=post_solve_pig_wood\n```", "```py\nfrom characters import RoundPig #HAVE TO ADD PIG IN STRUCTURE\nfrom polygon import Polygon #POLYGON \n```", "```py\nclass Level():\n    #each level will be construct by beam, column, pig\n    #will create wooden structure\n    def __init__(self, pigs_no, columns_no, beams_no, obj_space):\n        self.pigs = pigs_no #pig number\n        self.columns = columns_no \n        self.beams = beams_no\n        self.space = obj_space\n        self.number = 0 #to create build number\n        self.total_number_of_birds = 4 #total number of initial bird\n```", "```py\ndef build_0(self):\n\n    pig_no_1 = RoundPig(980, 100, self.space)\n    pig_no_2 = RoundPig(985, 182, self.space)\n    self.pigs.append(pig_no_1)\n    self.pigs.append(pig_no_2)\n    pos = (950, 80)\n    self.columns.append(Polygon(pos, 20, 85, self.space))\n    pos = (1010, 80)\n    self.columns.append(Polygon(pos, 20, 85, self.space))\n    pos = (980, 150)\n    self.beams.append(Polygon(pos, 85, 20, self.space))\n    pos = (950, 200)\n    self.columns.append(Polygon(pos, 20, 85, self.space))\n    pos = (1010, 200)\n    self.columns.append(Polygon(pos, 20, 85, self.space))\n    pos = (980, 240)\n    self.beams.append(Polygon(pos, 85, 20, self.space))\n    self.total_number_of_birds = 4\n```", "```py\ndef load_level(self):\n    try:\n        level_name = \"build_\"+str(self.number)\n getattr(self, level_name)()\n    except AttributeError:\n        self.number = 0\n  level_name = \"build_\"+str(self.number)\n        getattr(self, level_name)()\n```", "```py\n#write it in main.py file\nfrom level import Level\nlevel = Level(total_pig, columns, beams, space)\nlevel.number = 0 level.load_level()\n```", "```py\nwhile running:\n    # handle Input events\n  for eachEvent in Pygame.event.get():\n        if eachEvent.type == Pygame.QUIT:\n            running = False\n elif eachEvent.type == Pygame.KEYDOWN and event.key == \n          Pygame.K_ESCAPE:\n            running = False \n```", "```py\nif (Pygame.mouse.get_pressed()[0] and mouse_x_pos > 100 and\n  mouse_x_pos < 250 and mouse_y_pos > 370 and mouse_y_pos < 550):\n    mouse_pressed = True if (event.type == Pygame.MOUSEBUTTONUP and\n  event.button == 1 and mouse_pressed):\n    # Release new bird\n  mouse_pressed = False\n if level.number_of_birds > 0:\n        level.number_of_birds -= 1\n  time_of_release = time.time()*1000\n  x_initial = 154\n  y_initial = 156\n```", "```py\n#add code after x-initial and y-initial declaration\nif mouse_distance > rope_length:\n    mouse_distance = rope_length\nif mouse_x_pos < initial_x_sling+5:\n    bird = RoundBird(mouse_distance, angle, x_initial, y_initial, \n           space_obj)\n    total_birds.append(bird)\nelse:\n    bird = RoundBird(-mouse_distance, angle, x_initial, y_initial, \n           space_obj)\n    total_birds.append(bird)\nif level.number_of_birds == 0:\n    game_finish_time = time.time()\n```", "```py\nmouse_x_pos, mouse_y_pos = Pygame.mouse.get_pos()\n# Blit the background image screen.fill((130, 200, 100))\nscreen.blit(background_image, (0, -50))\n\n# Blitting the first part of sling image rect = Pygame.Rect(50, 0, 70, 220)\nscreen.blit(sling_image, (138, 420), rect)\n\n# Blit the remaining number of angry bird  if level.total_number_of_birds > 0:\n    for i in range(level.total_number_of_birds-1):\n        x = 100 - (i*35)\n        screen.blit(redbird, (x, 508))\n```", "```py\n# Draw sling action checking user input if mouse_pressed and level.total_number_of_birds > 0:\n    sling_action()\nelse: #blit bird when there is no stretch of sling\n  if time.time()*1000 - time_of_release > 300 and \n      level.number_of_birds > 0:\n        screen.blit(redbird, (130, 426))\n```", "```py\nremoved_bird_after_sling = []\nremoved_pigs_after_sling = []  # Draw total_birds for bird in total_birds:\n    if bird.shape.body.position.y < 0:\n        removed_bird_after_sling.append(bird)\n    pos = convert_to_pygame(bird.shape.body.position)\n    x_pos, y_pos = pos\n    x_pos -= 22 #Pygame compatible\n  y_pos -= 20\n  screen.blit(redbird, (x_pos, y_pos)) #blit bird\n    Pygame.draw.circle(screen, BLUE,\n  pos, int(bird.shape.radius), 2) #creates blue circle \n                                                       at the edge of bird\n```", "```py\n# Remove total_birds and total_pig for bird in removed_bird_after_sling:\n    space_obj.remove(bird.shape, bird.shape.body)\n    total_birds.remove(bird)\nfor pig in removed_pigs_after_sling:\n    space_obj.remove(pig.shape, pig.shape.body)\n    total_pig.remove(pig)\n```", "```py\n# Draw total_pig for Each_pig in total_pig:\n\n    pig = Each_pig.shape\n    if pig.body.position.y < 0: #when pig hits ground or fall to the ground\n        removed_pigs_after_sling.append(pig)\n\n    pos = convert_to_pygame(pig.body.position) #pos is a tuple\n  x_pos, y_pos = pos\n\n    angle_degrees = math.degrees(pig.body.angle)\n    pig_rotated_img = Pygame.transform.rotate(pig_image, angle_degrees) \n    #small random rotation within wooden frame\n  width,height = pig_rotated_img.get_size()\n    x_pos -= width*0.5\n  y_pos -= height*0.5\n  screen.blit(pig_rotated_img, (x_pos, y_pos))\n    Pygame.draw.circle(screen, BLUE, pos, int(pig.radius), 2)\n```", "```py\n# Draw columns and Beams\n#beam and column are object of Poly class for column in columns:\n    column.draw_poly('columns', screen)\nfor beam in beams:\n    beam.draw_poly('beams', screen)\n```", "```py\ntime_step_change = 1.0/50.0/2.\n```", "```py\n\n#time_step_change = 1.0/50.0/2. for x in range(2):\n    space_obj.step(time_step_change) # This causes two updates for frame  # Blitting second part of the sling rect_for_sling = Pygame.Rect(0, 0, 60, 200)\nscreen.blit(sling_image, (120, 420), rect_for_sling)\n\nPygame.display.flip() #updating the game objects\nclock.tick(50)\n```", "```py\ndef load_music():\n    \"\"\"Function that will load the music\"\"\"\n  song_name = '../res/sounds/angry-birds.ogg'\n  Pygame.mixer.music.load(song_name)\n    Pygame.mixer.music.play(-1)\n```", "```py\nload_music()\n```", "```py\ndef build_1(self):\n    \"\"\"Function that will render level 1\"\"\"\n obj_pig = RoundPig(1000, 100, self.space)\n    self.pigs.append(obj_pig)\n    pos = (900, 80)\n    self.columns.append(Polygon(pos, 20, 85, self.space))\n    pos = (850, 80)\n    self.columns.append(Polygon(pos, 20, 85, self.space))\n    pos = (850, 150)\n    self.columns.append(Polygon(pos, 20, 85, self.space))\n    pos = (1050, 150)\n    self.columns.append(Polygon(pos, 20, 85, self.space))\n    pos = (1105, 210)\n    self.beams.append(Polygon(pos, 85, 20, self.space))\n    self.total_number_of_birds = 4 #reduce the number to \n       make game more competitive \n```"]