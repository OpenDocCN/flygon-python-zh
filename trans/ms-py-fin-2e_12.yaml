- en: Implementing a Backtesting System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施回测系统
- en: A **backtest** is a simulation of a model-driven investment strategy's response
    to historical data. While working on designing and developing a backtest, it would
    be helpful to think in terms of the concept of creating video games.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**回测**是对模型驱动的投资策略对历史数据的响应进行模拟。在设计和开发回测时，以创建视频游戏的概念思考会很有帮助。'
- en: In this chapter, we will design and implement an event-driven backtesting system
    using an object-oriented approach. The resulting profits and losses of our trading
    model may be plotted on to a graph to help visualize the performance of our trading
    strategy. However, is this sufficient enough to determine whether it is a good
    model?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将使用面向对象的方法设计和实现一个事件驱动的回测系统。我们交易模型的结果利润和损失可以绘制成图表，以帮助可视化我们交易策略的表现。然而，这足以确定它是否是一个好模型吗？
- en: There are many concerns to be addressed in backtesting—for example, the effects
    of transaction costs, execution latency of orders, access to detailed transactions,
    and quality of historical data. Notwithstanding these factors, the primary goal
    of creating a backtesting system is to test a model as accurately as possible.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在回测中有许多问题需要解决，例如交易成本的影响、订单执行的延迟、获取详细交易信息的途径以及历史数据的质量。尽管存在这些因素，创建回测系统的主要目标是尽可能准确地测试模型。
- en: 'Backtesting involves a lot of research that merits its own literature. We will
    briefly cover some thoughts that you might want to consider when implementing
    a backtest. Typically, a number of algorithms are employed in backtesting. We
    will briefly discuss some of these: k-means clustering, k-nearest neighbors, classification
    and regression trees, 2k factorial design, and genetic algorithms.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 回测涉及大量值得研究的内容，这些内容值得有专门的文献。我们将简要讨论一些在实施回测时可能要考虑的想法。通常，回测中会使用多种算法。我们将简要讨论其中一些：k均值聚类、k最近邻、分类和回归树、2k因子设计和遗传算法。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Introducing backtesting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍回测
- en: Concerns in backtesting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回测中的关注点
- en: Concept of an event-driven backtesting system
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动回测系统的概念
- en: Designing and implementing a backtesting system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和实施回测系统
- en: Writing classes to store tick data and market data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写类来存储tick数据和市场数据
- en: Writing classes for orders and positions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写订单和持仓类
- en: Writing a mean-reverting strategy
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个均值回归策略
- en: Running the backtest engine single and multiple times
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行回测引擎单次和多次
- en: Ten considerations for a backtesting model
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回测模型的十个考虑因素
- en: Discussion of algorithms in backtesting
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回测中的算法讨论
- en: Introducing backtesting
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍回测
- en: A backtest is a simulation of a model-driven investment strategy's response
    to historical data. The purpose of performing experiments with backtests is to
    make discoveries about a process or system. By using historical data, you can
    save time in testing an investment strategy for the period forward. It helps you
    test an investment theory based on the movements of the tested period. It is also
    used to both evaluate and calibrate an investment model. Creating a model is only
    the first step. The investment strategy will typically employ the model to help
    you drive simulated trading decisions and compute various factors related to either
    risk or return. These factors are typically used together to find a combination
    that is predictive of return.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 回测是对模型驱动的投资策略对历史数据的响应进行模拟。进行回测实验的目的是发现有关过程或系统的发现。通过使用历史数据，您可以节省测试投资策略的时间。它帮助您测试基于被测试期间的运动的投资理论。它也用于评估和校准投资模型。创建模型只是第一步。投资策略通常会使用该模型来帮助您进行模拟交易决策并计算与风险或回报相关的各种因素。这些因素通常一起使用，以找到一个能够预测回报的组合。
- en: Concerns in backtesting
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回测中的关注点
- en: 'However, there are many concerns to be addressed in backtesting:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在回测中有许多问题需要解决：
- en: A backtest can never exactly replicate the performance of an investment strategy
    in an actual trading environment.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回测永远无法完全复制投资策略在实际交易环境中的表现。
- en: The quality of the historical data is questionable, since it is subjected to
    outliers by third-party data vendors.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 历史数据的质量是有问题的，因为它受第三方数据供应商的异常值影响。
- en: Look-ahead bias takes many forms. For example, listed companies may split, merge,
    or de-list, resulting in substantial changes to its stock price.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前瞻性偏差有很多形式。例如，上市公司可能会分拆、合并或退市，导致其股价发生重大变化。
- en: For strategies based on information from the order book, the market microstructure
    is extremely difficult to simulate realistically, since it represents the collective
    visible supply and demand in continuous time. This supply and demand are in turn
    affected by news events around the world.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于基于订单簿信息的策略，市场微观结构极其难以真实模拟，因为它代表了连续时间内的集体可见供需。这种供需反过来受到世界各地新闻事件的影响。
- en: Icebergs and resting orders are some hidden elements of the market that could
    affect the structure once activated
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冰山和挂单是市场的一些隐藏元素，一旦激活就可能影响结构
- en: Other factors to be considered are transaction costs, execution latency of orders,
    and access to detailed transactions from backtesting.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他需要考虑的因素包括交易成本、订单执行的延迟以及从回测中获取详细交易信息的途径。
- en: Notwithstanding these factors, the primary goal of creating a backtesting system
    is thus to test a model as accurately as possible.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些因素，创建回测系统的主要目标是尽可能准确地测试模型。
- en: Look-ahead bias is the use of available future data during the period it is
    being analyzed, resulting in inaccurate results in the simulation or study. It
    is vital to use information that would be only available during the period of
    study.In finance, iceberg orders are large orders that are broken up into several
    small orders. Only a small portion of the order is visible to the public—just
    like the *tip of the iceberg*—while the mass of the actual order is hidden. A
    **resting order** is an order whose price is away from the market and is waiting
    to be executed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前瞻性偏差是在分析期间使用可用的未来数据，导致模拟或研究结果不准确。在金融领域，冰山订单是将大订单分成几个小订单。订单的一小部分对公众可见，就像*冰山的一角*一样，而实际订单的大部分是隐藏的。**挂单**是一个价格远离市场并等待执行的订单。
- en: Concept of an event-driven backtesting system
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件驱动回测系统的概念
- en: While working on designing and developing a backtest, it would be helpful to
    think in terms of the concept of creating video games. After all, we are trying
    to create a simulated market pricing and ordering environment, very much akin
    to creating a virtual gaming world. Trading can also be regarded as a thrilling
    game of buying low and selling high.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和开发回测时，以创建视频游戏的概念来思考会很有帮助。毕竟，我们正在尝试创建一个模拟的市场定价和订单环境，非常类似于创建一个虚拟的游戏世界。交易也可以被视为一个买低卖高的刺激游戏。
- en: In a virtual trading environment, components are needed for the simulation of
    price feeds, the order-matching engine, the order-book management, as well as
    functions for account and position updates. To achieve these functionalities,
    we can explore the concept of an event-driven backtesting system.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟交易环境中，需要组件来模拟价格数据源、订单匹配引擎、订单簿管理，以及账户和持仓更新功能。为了实现这些功能，我们可以探索事件驱动回测系统的概念。
- en: Let's start by understanding the concept of an event-driven programming paradigm
    used throughout the game development process. A system typically receives events
    as its inputs. It might be a keystroke entered by a user or a mouse movement.
    Other events could be messages that are generated by another system, a process,
    or a sensor to notify the host system of an incoming event.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解贯穿游戏开发过程的事件驱动编程范式的概念。系统通常将事件作为其输入接收。它可能是用户输入的按键或鼠标移动。其他事件可能是由另一个系统、进程或传感器生成的消息，用于通知主机系统有一个传入事件。
- en: 'The following diagram illustrates the stages involved in a game engine system:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了游戏引擎系统涉及的阶段：
- en: '![](Images/463d52f9-5032-4afb-af9f-0feeba28e129.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/463d52f9-5032-4afb-af9f-0feeba28e129.png)'
- en: 'Let''s take a look at a pseudo-code implementation of a main game engine loop:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下主游戏引擎循环的伪代码实现：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The core functions within the main game engine loop may process generated system
    events, as in the case of the `handle_input_events()` function, which handles
    the keyboard events:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 主游戏引擎循环中的核心功能可能会处理生成的系统事件，就像`handle_input_events()`函数处理键盘事件一样：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using an event-driven system, such as the preceding example, helps us achieve
    code modularity and reusability by being able to swap and use similar events from
    different system components. The use of object-oriented programming is further
    enforced, where classes define objects in a game. These features are particularly
    useful for interfacing with different market data sources, multiple trading algorithms,
    and runtime environments when designing our trading platform. The simulated trading
    environment is close to being a realistic one and helps us prevent look-ahead
    bias.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件驱动系统，例如前面的例子，可以通过能够交换和使用来自不同系统组件的类似事件来实现代码模块化和可重用性。面向对象编程的使用进一步得到加强，其中类定义了游戏中的对象。这些特性在设计交易平台时特别有用，可以与不同的市场数据源、多个交易算法和运行时环境进行接口。模拟交易环境接近真实环境，有助于防止前瞻性偏差。
- en: Designing and implementing a backtesting system
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计和实施回测系统
- en: Now that we have an idea of designing a video game for creating a backtesting
    trading system, we can begin our object-oriented approach by first defining the
    required classes for the various components in our trading system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个设计视频游戏来创建回测交易系统的想法，我们可以通过首先定义交易系统中各个组件所需的类来开始我们的面向对象方法。
- en: We are interested in implementing a simple backtesting system to test a mean-reverting
    strategy. Using the daily historical prices from a data-source provider, we will
    take the closing price of each day to compute the volatility of price returns
    for a particular instrument, using the AAPL stock price as an example. We would
    like to test a theory that if the standard deviation of returns for an elapsed
    number of days is far from the mean of zero by a particular threshold, a buy or
    sell signal is generated. When such a signal is indeed generated, a market order
    is sent to the exchange to be executed at the opening price of the next trading
    day.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有兴趣实施一个简单的回测系统来测试一个均值回归策略。使用数据源提供商的每日历史价格，我们将取每天的收盘价来计算特定工具价格回报的波动率，以AAPL股价为例。我们想要测试一个理论，即如果过去一定数量的日子的回报标准差远离零的均值达到特定阈值，就会生成买入或卖出信号。当确实生成这样的信号时，市场订单将被发送到交易所，以在下一个交易日的开盘价执行。
- en: As soon as we open a position, we would like to track our unrealized and realized
    profits to date. Our open position can be closed when an opposing signal is generated.
    On completion of the backtest, we will plot our profits and losses to see how
    well our strategy holds.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开仓，我们希望追踪到目前为止的未实现利润和已实现利润。我们的持仓可以在生成相反信号时关闭。在完成回测后，我们将绘制利润和损失，以查看我们的策略表现如何。
- en: Does our theory sound like a viable trading strategy? Let's find out! The following
    sections explain the classes that go into implementing a backtesting system.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的理论听起来像是一个可行的交易策略吗？让我们来看看！以下部分解释了实施回测系统所需的类。
- en: Writing a class to store tick data
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个类来存储tick数据
- en: 'Write a class named `TickData` that represents a single unit of data received
    from a market data source with the following Python code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`TickData`的类，表示从市场数据源接收的单个数据单元的Python代码：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we are interested in storing the timestamp, symbol of the instrument,
    the opening and closing price, as well as the total volume traded. Detailed descriptions
    of a single unit of tick data, such as the highest price reached or last-traded
    volume, can be added as our system evolves.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们对存储时间戳、工具的符号、开盘价和收盘价以及总成交量感兴趣。随着系统的发展，可以添加单个tick数据的详细描述，比如最高价或最后成交量。
- en: Writing a class to store market data
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个类来存储市场数据
- en: 'An instance of the `MarketData` class is used throughout the system to store
    and retrieve prices referenced by various components. Essentially, it is a container
    for storing the last available tick data. Additional `get` helper functions are
    included to provide easy reference to the required information:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketData`类的一个实例在整个系统中用于存储和检索由各个组件引用的价格。它本质上是一个用于存储最后可用tick数据的容器。还包括额外的`get`辅助函数，以提供对所需信息的便捷引用：'
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Writing a class to generate sources of market data
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个类来生成市场数据的来源
- en: 'Write a class called `MarketDataSource` to help us fetch historical data from
    an external data provider. In this example, we will be using **Quandl** as our
    data provider. The constructor of the class is defined as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`MarketDataSource`的类，以帮助我们从外部数据提供商获取历史数据。在本例中，我们将使用**Quandl**作为我们的数据提供商。该类的构造函数定义如下：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the constructor, the `symbol` parameter contains the value recognized by
    our data provider to download our desired dataset. An object of `MarketData` is
    instantiated for storing the most recent market data available. The `tick_event_handler`
    parameter stores the method handler as we iterate through our data source. The `start`
    and `end` parameters refer to the starting and ending dates of the dataset that
    we wish to keep in the `pandas` DataFrame variable, `df`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，`symbol`参数包含了我们的数据提供商识别的值，用于下载我们需要的数据集。实例化了一个`MarketData`对象来存储最新的市场数据。`tick_event_handler`参数存储了方法处理程序，当我们迭代数据源时使用。`start`和`end`参数指的是我们希望保留在`pandas`
    DataFrame变量`df`中的数据集的开始和结束日期。
- en: 'Add the `fetch_historical_prices()` method inside the `MarketDataSource` method
    containing specific instructions for downloading from our data provider and returning
    the desired `pandas` DataFrame object, which holds our daily market prices, as
    shown in the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MarketDataSource`方法中添加`fetch_historical_prices()`方法，其中包含从数据提供商下载并返回所需的`pandas`
    DataFrame对象的具体指令，该对象保存我们的每日市场价格，如下所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As this method is specific to Quandl's API, you may rewrite this method to download
    from your own data provider accordingly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此方法特定于Quandl的API，您可以根据自己的数据提供商重新编写此方法。
- en: 'Also, add the `run()` method inside the `MarketDataSource` class to simulate
    the streaming prices from our data provider during backtesting:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`MarketDataSource`类中添加`run()`方法来模拟在回测期间从数据提供商获取流式价格：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that the first `if` statement performs a check on the presence of an
    existing market data before performing the download from our data provider. This
    allows us to run several simulations on the backtest using the cached data, avoiding
    the unnecessary download overheads and having our backtests run quicker.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一个`if`语句在执行从数据提供商下载之前对现有市场数据的存在进行检查。这使我们能够在回测中运行多个模拟，使用缓存数据，避免不必要的下载开销，并使我们的回测运行更快。
- en: The `for` loop on our `df` market data variable is used to simulate the streaming
    prices. Each tick data is transformed and formatted as an instance of `TickData` and
    added to the `market_data` object as the most recently available tick data for
    that particular symbol. This object is then passed to any tick data event handlers
    listening to a tick event.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环在我们的`df`市场数据变量上用于模拟流式价格。每个tick数据被转换和格式化为`TickData`的一个实例，并添加到`market_data`对象中作为特定符号的最新可用tick数据。然后将此对象传递给任何监听tick事件的tick数据事件处理程序。'
- en: Writing the order class
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写订单类
- en: 'The `Order` class in the following code represents a single order sent by the
    strategy to the server. Each order contains a timestamp, the symbol, quantity,
    and a flag indicating a buy or sell order. In the following examples, we will
    be using market orders only, and `is_market_order` is expected to be `True`. Other
    order types, such as limit and stop orders, may be implemented if desired. Once
    an order is filled, the order is further updated with the filled price, time,
    and quantity. Write this class as given in the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中的`Order`类表示策略发送到服务器的单个订单。每个订单包含时间戳、符号、数量和指示买入或卖出订单的标志。在以下示例中，我们将仅使用市价订单，并且预计`is_market_order`为`True`。如果需要，可以实现其他订单类型，如限价和止损订单。一旦订单被执行，订单将进一步更新为填充价格、时间和数量。按照以下代码给出的方式编写此类：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Writing a class to keep track of positions
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个类来跟踪持仓。
- en: 'The `Position` class helps us keep track of our current market position and
    account balance for a traded instrument, and is written as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Position`类帮助我们跟踪我们对交易工具的当前市场位置和账户余额，并且定义如下：'
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The number of units bought, sold, and net are declared as `buys`, `sells`, and
    `net` variables, respectively. The `rpnl` variable stores the recently realized
    profits and losses for the symbol. Note that the `position_value` variable starts
    with a value of zero. When securities are bought, the value of the securities
    is debited from this account. When securities are sold, the value of the securities
    is credited into this account.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 已声明买入、卖出和净值的单位数量分别为`buys`、`sells`和`net`变量。`rpnl`变量存储了该符号的最近实现利润和损失。请注意，`position_value`变量的初始值为零。当购买证券时，证券的价值从此账户中借记。当出售证券时，证券的价值记入此账户。
- en: 'When an order is filled, an account''s position changes. Write a method named
    `on_position_event()` inside the `Position` class to handle these position events:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当订单被填充时，账户的持仓会发生变化。在`Position`类中编写一个名为`on_position_event()`的方法来处理这些持仓事件：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: On a change in our position, we update and keep track of the number of securities
    bought and sold, as well as the current value of the securities. When the net
    position is zero, the position is closed out and we obtain the current realized
    profits and losses.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的持仓发生变化时，我们更新并跟踪买入和卖出的证券数量，以及证券的当前价值。当净头寸为零时，持仓被平仓，我们获得当前的实现利润和损失。
- en: 'Whenever a position is open, the value of our securities is influenced by market
    movements. Having a measure of unrealized profits and losses helps to keep track
    of the change in market value on every tick movement. Add the following `calculate_unrealized_pnl()`
    method inside the `Position` class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每当持仓开启时，我们的证券价值会受到市场波动的影响。有一个未实现的利润和损失的度量有助于跟踪每次tick移动中市场价值的变化。在`Position`类中添加以下`calculate_unrealized_pnl()`方法：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Calling the `calculate_unrealized_pnl()` method with the current market price
    gives us the current market value of our position for a particular security.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用当前市场价格调用`calculate_unrealized_pnl()`方法可以得到特定证券当前市场价值。
- en: Writing an abstract strategy class
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个抽象策略类
- en: 'The `Strategy` class given in the following code is the base class for all
    other strategy implementations, and is written as:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码中给出的`Strategy`类是所有其他策略实现的基类，并且被写成：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `on_tick_event()` abstract method is called when new market tick data arrives.
    Child classes would have to implement this abstract method to act upon incoming
    market prices. The `on_position_event()` abstract method is called whenever there
    are updates to our positions. Child classes would have to implement this abstract
    method to act upon incoming position updates.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的市场tick数据到达时，将调用`on_tick_event()`抽象方法。子类必须实现这个抽象方法来对传入的市场价格进行操作。每当我们的持仓有更新时，将调用`on_position_event()`抽象方法。子类必须实现这个抽象方法来对传入的持仓更新进行操作。
- en: The `send_market_order()` method is called by child strategy classes to route
    a market order to the broker. The handler for such an event is stored in the constructor,
    where the actual implementation is done by the owner of this class in the next
    section and interfaced directly with a broker API.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_market_order()`方法由子策略类调用，将市价订单路由到经纪人。这样的事件处理程序存储在构造函数中，实际的实现由本类的所有者在下一节中完成，并直接与经纪人API进行接口。'
- en: Writing a mean-reverting strategy class
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个均值回归策略类
- en: 'In this example, we are implementing a **mean-reverting trading strategy**
    on the AAPL stock price. Write the `MeanRevertingStrategy` child class that inherits
    the `Strategy` class from the previous section:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在实现一个关于AAPL股票价格的均值回归交易策略。编写一个继承上一节中`Strategy`类的`MeanRevertingStrategy`子类：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the constructor, we accept parameter values for telling our strategy the
    security symbol to trade and the number of units for each trade. The `send_order_event_handler`
    function variable is passed to the parent class to be stored. The `lookback_intervals`,
    `buy_threshold`, and `sell_threshold` variables are parameters concerned with
    generating trading signals using mean-reversion calculations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们接受参数值，告诉我们的策略要交易的证券符号和每笔交易的单位数。`send_order_event_handler`函数变量被传递给父类进行存储。`lookback_intervals`、`buy_threshold`和`sell_threshold`变量是与使用均值回归计算生成交易信号相关的参数。
- en: 'The `pandas` DataFrame `prices` variable will be used to store incoming prices,
    and the `is_long` and `is_short` Boolean variables store the current position
    of this strategy, and only one of them can be `True` at any time. These are assigned
    in the `on_position_event()` method inside the `MeanRevertingStrategy` class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`pandas` DataFrame `prices`变量将用于存储传入的价格，`is_long`和`is_short`布尔变量存储此策略的当前持仓，任何时候只有一个可以为`True`。这些变量在`MeanRevertingStrategy`类中的`on_position_event()`方法中分配：'
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `on_position_event()` method implements the parent abstract method and gets
    called on every update of our position.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_position_event()`方法实现了父抽象方法，并在我们的持仓更新时被调用。'
- en: 'In addition, implement the `on_tick_event()` abstract method inside the `MeanRevertingStrategy`
    class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`MeanRevertingStrategy`类中实现`on_tick_event()`抽象方法：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: On every tick-data event, market prices are stored in the current strategy class
    to be used for the calculation of trading signals, provided there is sufficient
    data to so. In this example, we are using daily historical prices with a look-back
    period of 20 days. In other words, we will be using the mean of the past 20 days'
    prices to determine a mean reversion. Until there is insufficient data, we simply
    skip this step.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个tick-data事件中，市场价格存储在当前策略类中，用于计算交易信号，前提是有足够的数据。在这个例子中，我们使用20天的日历史价格回溯期。换句话说，我们将使用过去20天价格的平均值来确定均值回归。在没有足够数据的情况下，我们只是跳过这一步。
- en: 'Add the `store_prices()` method inside the `MeanRevertingStrategy` class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MeanRevertingStrategy`类中添加`store_prices()`方法：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: On each tick event, the `prices` DataFrame store the daily closing price, indexed
    by a timestamp.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个tick事件上，`prices` DataFrame存储每日收盘价，由时间戳索引。
- en: 'The logic for generating trading signals is given in the `generate_signals_and_send_order()`
    method inside the `MeanRevertingStrategy` class:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 生成交易信号的逻辑在`MeanRevertingStrategy`类中的`generate_signals_and_send_order()`方法中给出：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: On each tick event, the **z-score** for the current period is calculated, which
    we will cover shortly. As soon as the z-score exceeds our buying threshold value,
    a buy signal is generated. We can either close a short position or enter into
    a long position by sending a buy market order to our broker. Conversely, when
    the z-score exceeds our selling threshold value, a sell signal is generated. We
    can either close a long position or enter into a short position by sending a sell
    market order to our broker. In our backtest system, orders are executed at the
    opening of the next day.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个tick事件上，计算当前时期的**z-score**，我们将很快介绍。一旦z-score超过我们的买入阈值值，就会生成买入信号。我们可以通过向经纪人发送买入市价订单来关闭空头头寸或进入多头头寸。相反，当z-score超过我们的卖出阈值值时，就会生成卖出信号。我们可以通过向经纪人发送卖出市价订单来关闭多头头寸或进入空头头寸。在我们的回测系统中，订单将在第二天开盘时执行。
- en: 'Add the `calculate_z_score()` method inside the `MeanRevertingStrategy` class
    for calculating z-scores on every tick event:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MeanRevertingStrategy`类中添加`calculate_z_score()`方法，用于在每个tick事件上计算z-score：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The daily percentage returns of closing prices are z-scored using this formula:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下公式对收盘价的每日百分比收益进行z-score标准化：
- en: '![](Images/c6b40be1-683a-46a7-aa23-0f5d3ffc2e25.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c6b40be1-683a-46a7-aa23-0f5d3ffc2e25.png)'
- en: Here, *x* is the most recent return, *μ* is the mean of returns, and *σ* is
    the standard deviation of returns. A z-score value of 0 indicates that the score
    is the same as the mean. Take for example a buying threshold value of -1.5\. When
    the z-score falls below -1.5, this indicates a strong buying signal, since z-scores
    for the following periods are expected to revert to the mean of zero. Similarly,
    a selling threshold value of 1.5 could indicate a strong selling signal and z-scores
    are expected to revert to the mean.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*x*是最近的收益，*μ*是收益的平均值，*σ*是收益的标准差。 z-score值为0表示该分数与平均值相同。例如，买入阈值值为-1.5。当z-score低于-1.5时，这表示强烈的买入信号，因为预计随后的时期的z-score将恢复到零的平均值。同样，卖出阈值值为1.5可能表示强烈的卖出信号，预计z-score将恢复到平均值。
- en: Therefore, the goal of this backtesting system aims to find optimal threshold
    values in maximizing our profits.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个回测系统的目标是找到最优的阈值，以最大化我们的利润。
- en: Binding our modules with a backtesting engine
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的模块与回测引擎绑定
- en: 'After defining all of our core modular components, we are now ready to implement
    the backtesting engine as the `BacktestEngine` class with the following codes:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了所有核心模块化组件之后，我们现在准备实现回测引擎，作为`BacktestEngine`类，使用以下代码：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Within the backtest engine, we store the symbol and the number of units to trade.
    An instance of `MarketDataSource` is created with the symbol, together with the
    start and end dates for defining the timeframe of our dataset. Emitted tick events
    will be handled by our local `on_tick_event()` method, which we will implement
    shortly. The `strategy` variable is intended to store an instance of our mean-reverting
    strategy class. The `unfilled_orders` variable acts as our order book that will
    store incoming market orders for execution at the next trading day. The `positions`
    variable is intended to store instances of `Position` objects, indexed by symbol.
    The `df_rpnl` variable is intended to store our realized profits and losses during
    backtesting, which we can use to plot at the end of it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在回测引擎中，我们存储标的物和交易单位数量。使用标的物创建一个`MarketDataSource`实例，同时定义数据集的开始和结束日期。发出的tick事件将由我们的本地`on_tick_event()`方法处理，我们将很快实现。`strategy`变量用于存储我们均值回归策略类的一个实例。`unfilled_orders`变量充当我们的订单簿，将存储下一个交易日执行的市场订单。`positions`变量用于存储`Position`对象的实例，由标的物索引。`df_rpnl`变量用于存储我们在回测期间的实现利润和损失，我们可以在回测结束时使用它来绘图。
- en: 'The entry point for running the backtesting engine is the `start()` method
    given as follows inside the `Backtester` class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 运行回测引擎的入口点是`Backtester`类中给出的`start()`方法。
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A single instance of `Backtester` may be run multiple times by calling the `start()`
    method. At the start of every run, we initialize the `unfilled_orders`, `positions`,
    and `df_rpl` variables. A new instance of a strategy class is instantiated with
    the symbol and number of units to trade, a method named `on_order_received()`
    for receiving orders triggered from the strategy, as well as any keyword `kwargs`
    arguments required by the strategy.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`start()`方法可以多次运行单个`Backtester`实例。在每次运行开始时，我们初始化`unfilled_orders`、`positions`和`df_rpl`变量。使用策略类的一个新实例化，传入标的物和交易单位数量，以及一个名为`on_order_received()`的方法，用于接收来自策略的订单触发，以及策略需要的任何关键字`kwargs`参数。
- en: 'Implement the `on_order_received()` method inside the `BacktestEngine` class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BacktestEngine`类中实现`on_order_received()`方法：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We are notified on the console when an order is generated and added to the order
    book.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当订单生成并添加到订单簿时，我们会在控制台上收到通知。
- en: 'Implement the `on_tick_event()` method inside the `BacktestEngine` class to
    handle tick events emitted by the market data source:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BacktestEngine`类中实现`on_tick_event()`方法，用于处理市场数据源发出的tick事件：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The market data source in this example is expected to be the daily historical
    prices. A tick event received represents a new trading day. At the start of the
    trading day, we check our order book and match any unfilled orders at the opening
    by calling the `match_order_book()` method. After which, we pass the latest market
    data represented by the `market_data` variable to the strategy's tick-event handler
    to perform trading functions. At the end of the trading day, we print out information
    on our positions to the console.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，市场数据源预计是每日的历史价格。接收到的tick事件代表一个新的交易日。在交易日开始时，我们通过调用`match_order_book()`方法来检查我们的订单簿，并匹配开盘时的任何未成交订单。之后，我们将最新的市场数据`market_data`变量传递给策略的tick事件处理程序，执行交易功能。在交易日结束时，我们将我们的持仓信息打印到控制台上。
- en: 'Implement the `match_order_book()` and `match_unfilled_orders()` methods inside
    the `BacktestEngine` class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BacktestEngine`类中实现`match_order_book()`和`match_unfilled_orders()`方法：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'On every call of the `match_order_book()` command, a list of pending orders
    stored in the `unfilled_orders` variable is checked for execution in the market
    and removed from the list when this operation is successful. The `if` statement
    in the `match_unfilled_orders()` method verifies that the order is in the correct
    state and marks the order as filled immediately at the current market-opening
    price. This would trigger a series of events on the `on_order_filled()` method. Implement
    this method inside the `BacktestEngine` class:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次调用`match_order_book()`命令时，都会检查存储在`unfilled_orders`变量中的待处理订单列表，以便在市场中执行，并在此操作成功时从列表中移除。`match_unfilled_orders()`方法中的`if`语句验证订单是否处于正确状态，并立即以当前市场开盘价标记订单为已填充。这将触发`on_order_filled()`方法上的一系列事件。在`BacktestEngine`类中实现这个方法：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As soon as an order is filled, the corresponding position of the traded symbol
    is required to be updated. The `position` variable contains the retrieved `Position`
    instance, and a call on its `on_position_event()` command updates its state. The
    realized profits and losses are calculated and saved to the `pandas` DataFrame
    `df_rpnl` along with the timestamp. The strategy is also informed of a change
    in position by calling the `on_position_event()` command. We are notified on the
    console when such an event occurs.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦订单被执行，就需要更新交易符号的相应头寸。`position`变量包含检索到的`Position`实例，并且调用其`on_position_event()`命令会更新其状态。实现的利润和损失会被计算并保存到`pandas`
    DataFrame `df_rpnl`中，并附上时间戳。通过调用`on_position_event()`命令，策略也会被通知头寸的变化。当这样的事件发生时，我们会在控制台上收到通知。
- en: 'Add the following `get_position()` method inside the `BacktestEngine` class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BacktestEngine`类中添加以下`get_position()`方法：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `get_position()` method is a helper method that simply gets the current
    `Position` object for a trading symbol. An instance is created if none is found.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_position()`方法是一个辅助方法，简单地获取一个交易符号的当前`Position`对象。如果找不到实例，则创建一个。'
- en: 'The last command call by `on_tick_event()` is `print_position_status()`. Implement
    this method inside the `BacktestEngine` class:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_tick_event()`最后一次调用的命令是`print_position_status()`。在`BacktestEngine`类中实现这个方法：'
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: On every tick event, we print any available position information on the current
    market value, realized and unrealized profits, and losses to the console.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次tick事件中，我们打印当前市场价值、实现和未实现利润和损失的任何可用头寸信息到控制台。
- en: Running our backtesting engine
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的回测引擎
- en: 'With all of the required methods defined inside the `BacktestEngine` class,
    we may now go ahead and create an instance of this class with the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BacktestEngine`类中定义了所有必需的方法后，我们现在可以使用以下代码创建这个类的一个实例：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, we are interested in trading one unit of AAPL stock each time,
    using three years of daily historical data for backtesting from the year 2015
    to 2017.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们对每次交易感兴趣，使用2015年到2017年三年的每日历史数据进行回测。
- en: 'Issue the `start()` command to run the backtesting engine:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 发出`start()`命令来运行回测引擎：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `lookback_interval` parameter argument with a value of 20 tells our strategy
    to use the most recent 20 days' of daily historical prices in calculating z-scores.
    The `buy_threshold` and `sell_threshold` parameter arguments define the boundary
    limits at which a buy or sell signal is generated. In this example, a buy threshold
    value of -1.5 indicates that a long position is desired when the z-score falls
    below -1.5\. Similarly, a sell threshold value of 1.5 indicates that a short position
    is desired when the z-score rises above 1.5.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookback_interval`参数参数值为20告诉我们的策略在计算z分数时使用最近20天的历史每日价格。`buy_threshold`和`sell_threshold`参数参数定义了生成买入或卖出信号的边界限制。在这个例子中，-1.5的买入阈值值表示当z分数低于-1.5时希望持有多头头寸。同样，1.5的卖出阈值值表示当z分数上升到1.5以上时希望持有空头头寸。'
- en: 'When the engine runs, you will see the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当引擎运行时，您将看到以下输出：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'From the output logs, a buy signal is generated on February 25, 2015 and a
    market order is added to the order book for execution at the opening of the next
    trading day on February 26 at USD 128.785\. By the end of the trading day, our
    long position would have an unrealized profit of USD 1.63:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出日志中，我们可以看到在2015年2月25日生成了一个买入信号，并且在下一个交易日2月26日开盘时以128.785美元的价格向订单簿中添加了一个市价订单以执行。到交易日结束时，我们的多头头寸将有1.63美元的未实现利润：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Scrolling further down the logs, you should see that on March 30, 2015 a sell
    signal is generated, and a sell market order is executed on the next day, March
    31, at the price of USD 126.09\. This closes our long position and leaves us with
    a realized loss of USD 2.695.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 继续向下滚动日志，您会看到在2015年3月30日生成了一个卖出信号，并且在下一天3月31日以126.09美元的价格执行了一个卖出市价订单。这关闭了我们的多头头寸，并使我们遭受了2.695美元的实现损失。
- en: 'When the backtest engine finishes, we can plot our strategies realized and
    profits on to a chart to visualize this trading strategy with the following Python
    code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当回测引擎完成时，我们可以使用以下Python代码将我们的策略实现的利润和损失绘制到图表上，以可视化这个交易策略：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This gives us the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '![](Images/1390828c-fe24-4857-81bc-cf305c4274f3.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1390828c-fe24-4857-81bc-cf305c4274f3.png)'
- en: Note that the realized profits and losses are not complete at the end of the
    backtest. We may still be holding on to a long or short position with unrealized
    profits or losses. Be sure to account for this remaining value when evaluating
    your strategy.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，回测结束时，实现的利润和损失并不完整。我们可能仍然持有未实现的利润或损失的多头或空头头寸。在评估策略时，请确保考虑到这个剩余价值。
- en: Multiple runs of the backtest engine
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回测引擎的多次运行
- en: Using **fixed strategy parameters**, we were able to have the backtest engine
    run a single time and visualize its performance. Since the goal of backtesting
    is to find the optimal strategy parameters for considering in a trading system,
    we would like our backtest engine to run multiple times on different strategy
    parameters.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**固定的策略参数**，我们能够让回测引擎运行一次并可视化其性能。由于回测的目标是找到适用于交易系统考虑的最佳策略参数，我们希望我们的回测引擎在不同的策略参数上多次运行。
- en: 'For example, define the list of threshold values that we would like to test
    in a constant variable named `THRESHOLDS`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，定义我们想要在名为`THRESHOLDS`的常量变量中测试的阈值列表：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Each item in the list constant is a tuple of buy and sell threshold values.
    We can iterate these values with a `for` loop, calling the `engine.start()` command
    and plotting on a graph on every iteration with the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个项目都是买入和卖出阈值值的元组。我们可以使用`for`循环迭代这些值，调用`engine.start()`命令，并在每次迭代时绘制图表，使用以下代码：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We get the following output:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '![](Images/5f42cfaa-70c6-41c3-b86e-42c95ef8f7d1.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5f42cfaa-70c6-41c3-b86e-42c95ef8f7d1.png)'
- en: The four plots show the outcomes of the various threshold values being used
    in our strategy. By varying the strategy parameters, we obtained different profiles
    of risk and returns. Perhaps you may find better strategy parameters in achieving
    better results than this!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 四个图显示了在我们的策略中使用各种阈值时的结果。通过改变策略参数，我们得到了不同的风险和回报概况。也许您可以找到更好的策略参数，以获得比这更好的结果！
- en: Improving your backtesting system
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进您的回测系统
- en: In this chapter, we looked at creating a simple backtesting system based on
    the daily closing prices for a mean-reverting strategy. There are several areas
    of considerations to make such a backtesting model more realistic. Are historical
    daily prices sufficient to test our model? Should intra-day limit orders be used
    instead? Our account value started from zero; how can we reflect our capital requirements
    accurately? Are we able to borrow shares for shorting?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们基于每日收盘价创建了一个简单的回测系统，用于均值回归策略。有几个方面需要考虑，以使这样一个回测模型更加现实。历史每日价格足以测试我们的模型吗？应该使用日内限价单吗？我们的账户价值从零开始；如何能够准确反映我们的资本需求？我们能够借股做空吗？
- en: Since we took an object-oriented approach in creating a backtesting system,
    how easy would it be to integrate other components in the future? A trading system
    could accept more than one source of market data. We could also create components
    that allow us to deploy our system to the production environment.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在创建回测系统时采用了面向对象的方法，将来集成其他组件会有多容易？交易系统可以接受多个市场数据源。我们还可以创建组件，使我们能够将系统部署到生产环境中。
- en: The list of concerns mentioned are not exhaustive. To guide us in implementing
    a robust backtesting model, the next section spells out ten considerations in
    the design of such a system.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上述提到的关注点列表并不详尽。为了指导我们实施健壮的回测模型，下一节详细阐述了设计这样一个系统的十个考虑因素。
- en: Ten considerations for a backtesting model
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回测模型的十个考虑因素
- en: In the previous section, we performed one replication of a backtest. Our result
    looks pretty optimistic. However, is this sufficient to deduce that this is a
    good model? The truth is that backtesting involves a lot of research that merits
    literature of its own. The following list briefly covers some thoughts that you
    might want to consider when implementing your backtests.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们进行了一次回测的复制。我们的结果看起来相当乐观。然而，这足以推断这是一个好模型吗？事实是，回测涉及大量研究，值得有自己的文献。以下列表简要涵盖了在实施回测时您可能想要考虑的一些想法。
- en: Resources restricting your model
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制模型的资源
- en: The resources that are available to your backtesting system limit how well you
    can implement your backtest. A financial model that generates signals using only
    the last closing price needs a set of historical data on the closing prices. A
    trading system that requires reading from the order book requires all levels of
    the order book data to be available on every tick. This adds up the storage complexity.
    Other resources, such as exchange data, estimation techniques, and computer resources
    pose a limitation on the nature of the model that can be used.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于您的回测系统的资源限制了您可以实施回测的程度。只使用最后收盘价生成信号的金融模型需要一组收盘价的历史数据。需要从订单簿中读取的交易系统需要在每个tick上都有订单簿数据的所有级别。这增加了存储复杂性。其他资源，如交易所数据、估计技术和计算机资源，对可以使用的模型的性质施加了限制。
- en: Criteria of evaluation of the model
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型评估标准
- en: How can we conclude that a model is good? Some factors to consider are Sharpe
    ratios, hit ratios, average rate of return, VaR statistics, as well as the minimum
    and maximum drawdown encountered. How can a combination of such factors balance
    so that a model is usable? How much can the maximum drawdown be tolerated in achieving
    a high Sharpe ratio?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何得出模型好坏的结论？一些要考虑的因素包括夏普比率、命中率、平均收益率、VaR统计数据，以及遇到的最小和最大回撤。这些因素的组合如何平衡，使模型可用？在实现高夏普比率时，最大回撤能够容忍多少？
- en: Estimating the quality of backtest parameters
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 估计回测参数的质量
- en: Using a variety of parameters on a model typically gives us varied results.
    From multiple models, we can obtain additional sets of data for each model. Can
    the parameters from the model with the best performance be trustworthy? Using
    methods such as model averaging can help us correct optimistic estimates.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型上使用各种参数通常会给我们带来不同的结果。从多个模型中，我们可以获得每个模型的额外数据集。最佳表现模型的参数可信吗？使用模型平均等方法可以帮助我们纠正乐观的估计。
- en: The model-averaging technique is the average fit for a number of models as opposed
    to using a single best model.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 模型平均技术是对多个模型的平均拟合，而不是使用单个最佳模型。
- en: Be prepared to face model risk
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好面对模型风险的准备
- en: Perhaps after extensive backtesting, you may find yourself with a good-quality
    model. How long is it going to stay that way? In **model risk**, the market structure
    or the model parameters may change with time, or a regime change may cause the
    functional form of your model to change abruptly. By then, you could even be uncertain
    that your model is correct. A solution that addresses model risk is **model averaging**.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 也许经过广泛的回测，你可能会发现自己拥有一个高质量的模型。它会保持多久？在模型风险中，市场结构或模型参数可能会随时间改变，或者制度变革可能会导致你的模型的功能形式突然改变。到那时，你甚至可能不确定你的模型是否正确。解决模型风险的方法是模型平均。
- en: Performance of a backtest with in–sample data
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用样本内数据进行回测
- en: Backtesting helps us perform extensive parameter searches that optimize the
    results of a model. This exploits the true and the idiosyncratic aspects of the
    sample data. Also, historical data can never mimic the way that the entire data
    comes from live markets. These optimized results will always produce an optimistic
    assessment of the model and the strategy used.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 回测帮助我们进行广泛的参数搜索，优化模型的结果。这利用了样本数据的真实和特异方面。此外，历史数据永远无法模仿整个数据来自实时市场的方式。这些优化的结果将始终产生对模型和使用的策略的乐观评估。
- en: Addressing common pitfalls in backtesting
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决回测中的常见陷阱
- en: The most common error made in backtesting is **look-ahead bias**, and it comes
    in many forms. For example, parameter estimates may be derived from the entire
    period of the sample data, which constitute using information from the future.
    Statistical estimates such as these and model selection should be estimated sequentially,
    which could actually be difficult to do.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 回测中最常见的错误是前瞻性偏差，它有许多形式。例如，参数估计可能来自样本数据的整个时期，这构成了使用未来信息。这些统计估计和模型选择应该按顺序估计，这实际上可能很难做到。
- en: Errors in data come in all forms, from hardware, software, and human errors
    that could occur while routed by data distribution vendors. Listed companies may
    split, merge, or de-list, resulting in substantial changes to their stock prices.
    These actions could lead to survivorship bias in our models. Failure to clean
    data properly will give undue influence to idiosyncratic aspects of data, and
    thus affect the model parameters.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 数据错误以各种形式出现，从硬件、软件和人为错误，可能在数据分发供应商路由时发生。上市公司可能会分拆、合并或退市，导致其股价发生重大变化。这些行动可能导致我们的模型中出现生存偏差。未能正确清理数据将给予数据的特异方面不当的影响，从而影响模型参数。
- en: '**Survivorship bias** is the logical error of concentrating on results that
    have survived some past selection process. For example, a stock-market index may
    report a strong performance even in bad times because poor performing stocks are
    dropped from its component weightage, resulting in an overestimation of past returns.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 生存偏差是一种逻辑错误，它集中于经历了某种过去选择过程的结果。例如，股市指数可能会报告在不好的时候也有强劲的表现，因为表现不佳的股票被从其组成权重中剔除，导致对过去收益的高估。
- en: Failure to use shrinkage estimators or model averaging could report results
    containing extreme values, making it difficult for comparison and evaluation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 未使用收缩估计量或模型平均可能会报告包含极端值的结果，使比较和评估变得困难。
- en: In statistics, a shrinkage estimator is used as an alternative to an ordinary
    least-squares estimator to produce the smallest mean-squared error. They can be
    used to shrink raw estimates from the model output toward zero or another fixed
    constant value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计学中，收缩估计量被用作普通最小二乘估计量的替代，以产生最小均方误差。它们可以用来将模型输出的原始估计值收缩到零或另一个固定的常数值。
- en: Have a common-sense idea of your model
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对模型有一个常识性的想法
- en: Often, common sense could be lacking in our models. We may attempt to explain
    a trendless variable with a trended variable or infer causation from correlation.
    Can logarithmic values be used when the context does or does not require it? Let's
    see in the further section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模型中常常缺乏常识。我们可能会尝试用趋势变量解释无趋势变量，或者从相关性推断因果关系。当上下文需要或不需要时，可以使用对数值吗？让我们在接下来的部分看看。
- en: Understanding the context for the model
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解模型的背景
- en: Having a common-sense idea of a model is barely sufficient. A good model takes
    into account the history, personnel involved, operating constraints, common peculiarities,
    and all the understanding for the rationale of the model. Are commodity prices
    following seasonal movements? How was the data gathered? Are the formulas used
    in the computation of variables reliable? These questions can help us determine
    the causes, should things go wrong.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对模型有一个常识性的想法几乎是不够的。一个好的模型考虑了历史、参与人员、运营约束、常见的特殊情况，以及对模型的理性理解。商品价格是否遵循季节性变动？数据是如何收集的？用于计算变量的公式可靠吗？这些问题可以帮助我们确定原因，如果出现问题。
- en: Make sure you have the right data
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保你有正确的数据
- en: Not many of us have access to tick-level data. Low-resolution tick data may
    miss out on detailed information. Even tick-level data may be fraught with errors.
    Using summary statistics, such as the mean, standard errors, maximums, minimums,
    and correlations, tells us a lot about the nature of the data whether we can really
    use it, or infer backtest parameter estimates.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多人都无法访问tick级别的数据。低分辨率的tick数据可能会错过详细信息。即使是tick级别的数据也可能充满错误。使用摘要统计数据，如均值、标准误差、最大值、最小值和相关性，告诉我们很多关于数据的性质，无论我们是否真的可以使用它，或者推断回测参数估计。
- en: 'When data cleaning is performed, we might ask these questions: what are things
    to look out for? Are values realistic and logical? How is the missing data coded?'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行数据清理时，我们可能会问这些问题：需要注意什么？数值是否现实和合理？缺失数据是如何编码的？
- en: Devise a system of reporting data and results. The use of graphs helps the human
    eye to visualize patterns that might come across as unexpected. Histograms might
    reveal an unexpected distribution, or residual plots might show unexpected prediction
    error patterns. Scatter plots of residualized data may show additional modeling
    opportunities.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 制定一套报告数据和结果的系统。使用图表有助于人眼可视化可能出乎意料的模式。直方图可能显示出意想不到的分布，或者残差图可能显示出意想不到的预测误差模式。残差化数据的散点图可能显示出额外的建模机会。
- en: Residualized data is the difference or *residuals* between the observed values
    and those of the model.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 残差化数据是观察值与模型值之间的差异或*残差*。
- en: Data mine your results
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挖掘你的结果
- en: From running over several iterations of backtests, the results represent a source
    of information about your model. Running your model in real-time conditions produces
    another source of results. By data mining all this wealth of information, we can
    obtain a data-driven result that can avoid tailoring the model specifications
    to the sample data. It is recommended to use shrinkage estimators or model averaging
    when reporting the results.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对多次回测进行迭代，结果代表了关于模型的信息来源。在实时条件下运行模型会产生另一个结果来源。通过数据挖掘所有这些丰富的信息，我们可以获得一个避免将模型规格定制到样本数据的数据驱动结果。建议在报告结果时使用收缩估计或模型平均。
- en: Discussion of algorithms in backtesting
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回测中的算法讨论
- en: After taking into consideration the designing of a backtesting model, one or
    more algorithms may be used to improve the model on a continuous basis. This section
    briefly covers some of the algorithmic techniques used in areas of backtesting,
    such as data mining and machine learning.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑设计回测模型时，可以使用一个或多个算法来持续改进模型。本节简要介绍了在回测领域使用的一些算法技术，如数据挖掘和机器学习。
- en: K-means clustering
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: K均值聚类
- en: The **k-means clustering** algorithm is a method of clustering analysis in data
    mining. From the backtest results of *n* observations, the k-means algorithm is
    designed to classify the data into *k* clusters based on their relative distance
    from one another. The center point of each cluster is computed. The objective
    then is to find the within-cluster sum of squares that gives us a model-averaged
    point. The model-averaged point indicates the likely average performance of the
    model, which can be used for further comparison with the performance of other
    models.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**k均值聚类**算法是数据挖掘中的一种聚类分析方法。从*n*次观察的回测结果中，k均值算法旨在根据它们相对距离将数据分类为*k*个簇。计算每个簇的中心点。目标是找到给出模型平均点的簇内平方和。模型平均点表示模型的可能平均性能，可用于与其他模型的性能进行进一步比较。'
- en: K-nearest neighbors machine learning algorithm
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: K最近邻机器学习算法
- en: The **k-nearest neighbors** (**KNN**) is a lazy learning technique that does
    not build any models.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**k最近邻**（**KNN**）是一种懒惰学习技术，不构建任何模型。'
- en: An initial set of backtest model parameters are chosen either by random or best
    guess.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的回测模型参数集是随机选择或最佳猜测。
- en: After analyzing the results of the model, a *k* number of sets of parameters
    that is closest to the original set are used for computation in the next step.
    The model will then take the set of parameters that gives the best results.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析模型结果之后，将使用与原始集最接近的*k*个参数集进行下一步计算。然后模型将选择给出最佳结果的参数集。
- en: The process continues until the terminating condition is reached, thereby always
    giving the best set of model parameters available.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程持续进行，直到达到终止条件，从而始终提供可用的最佳模型参数集。
- en: Classification and regression tree analysis
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分类和回归树分析
- en: The **Classification And Regression Tree** (**CART**) analysis contains two
    decision trees that are used in data mining. The classification tree uses classification
    rules to classify the outcomes of a model using nodes and branches in the decision
    tree. The regression tree attempts to assign a real value to the classified outcome.
    The resulting values are averaged to provide a measure of the quality of the decision.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**分类和回归树**（**CART**）分析包含两个用于数据挖掘的决策树。分类树使用分类规则通过决策树中的节点和分支对模型的结果进行分类。回归树试图为分类结果分配一个实际值。得到的值被平均以提供决策质量的度量。'
- en: The 2k factorial design
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2k阶乘设计
- en: 'When designing experiments for backtesting, we can consider the use of **2k
    factorial design**. Suppose we have two factors, A and B. Each factor behaves
    as a Boolean value, with values of either +1 or -1\. A +1 value indicates a quantitatively
    high value, while -1 indicates a low value. This gives us a combination of 2²
    = 4 outcomes. For a 3-factor model, this gives us a combination of 2³ = 8 outcomes.
    The following table illustrates an example with two factors with outcomes W, X,
    Y, and Z:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计回测实验时，可以考虑使用**2k阶乘设计**。假设有两个因素A和B。每个因素都是布尔值，取值为+1或-1。+1表示定量高值，而-1表示低值。这给我们提供了2²=4种结果的组合。对于3因素模型，这给我们提供了2³=8种结果的组合。以下表格说明了具有W、X、Y和Z结果的两个因素的示例：
- en: '|  | **A** | **B** | **Replication I** |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '|  | **A** | **B** | **复制 I** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Value | +1 | +1 | W |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 值 | +1 | +1 | W |'
- en: '| Value | +1 | -1 | X |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 值 | +1 | -1 | X |'
- en: '| Value | -1 | +1 | Y |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 值 | -1 | +1 | Y |'
- en: '| Value | -1 | -1 | Z |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 值 | -1 | -1 | Z |'
- en: Note that we are generating one replication of backtest to produce a set of
    outcomes. Performing additional replications gives us more information. From this
    data, we can perform a regression and analyze its variance. The objectives of
    these tests are to determine which factors, A or B, are more influential over
    another, and what values should be chosen so that the outcomes are either near
    some desired value, able to achieve a low variance, or minimize the effects of
    uncontrollable variables.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在生成一个回测的复制，以产生一组结果。进行额外的复制可以为我们提供更多信息。从这些数据中，我们可以进行回归分析和分析其方差。这些测试的目标是确定哪些因素A或B对另一个更有影响，并选择哪些值，使结果要么接近某个期望值，能够实现低方差，或者最小化不可控变量的影响。
- en: The genetic algorithm
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遗传算法
- en: The **Genetic Algorithm** (**GA**) is a technique where every individual evolves
    through the process of natural selection in order to optimize a problem. A population
    of candidate solutions in an optimization problem goes through an iterative process
    of selection to become parents, undergoing mutation and crossover to produce the
    next generation of offspring. Over cycles of successive generations, the population
    evolves toward an optimal solution.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法（GA）是一种技术，其中每个个体通过自然选择的过程进化，以优化问题。在优化问题中，候选解的种群经历选择的迭代过程，成为父代，经历突变和交叉以产生下一代后代。经过连续世代的循环，种群朝着最优解进化。
- en: The application of GAs can be applied to a variety of optimizing problems, including
    backtesting, and is especially useful for solving standard optimizations, discontinuous
    or non-differentiable problems, or nonlinear outcomes.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 遗传算法的应用可以应用于各种优化问题，包括回测，特别适用于解决标准优化、不连续或非可微问题或非线性结果。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: A backtest is a simulation of a model-driven investment strategy's response
    to historical data. The purpose of performing experiments with backtests is to
    make discoveries about a process or system and to compute various factors related
    to either risk or return. The factors are typically used together to find a combination
    that is predictive of the return.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 回测是模型驱动的投资策略对历史数据的响应的模拟。进行回测实验的目的是发现有关过程或系统的信息，并计算与风险或回报相关的各种因素。这些因素通常一起使用，以找到预测回报的组合。
- en: While working on designing and developing a backtest, it would be helpful to
    think in terms of the concept of creating video games. In a virtual trading environment,
    components are needed for the simulation of price feeds, the order-matching engine,
    the order book management, as well as functions for account and position updates.
    To achieve these functionalities, we can explore the concept of an event-driven
    backtesting system.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和开发回测时，以创建视频游戏的概念思考将会很有帮助。在虚拟交易环境中，需要组件来模拟价格流、订单匹配引擎、订单簿管理，以及账户和持仓更新的功能。为了实现这些功能，我们可以探索事件驱动的回测系统的概念。
- en: In this chapter, we designed and implemented a backtesting system that interacts
    with various components that handle tick data, fetching historical prices from
    a data provider, handling order and position updates, and simulating a streaming
    price feed that triggers our strategy to perform mean-reversion calculations.
    The z-score of each period is evaluated for a trading signal, which leads to the
    generation of market orders for execution at the opening of the next trading day.
    We performed a single backtest run as well as multiple runs with varying strategy
    parameters, plotting the resulting profits and losses to help us visualize the
    performance of our trading strategy.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设计并实现了一个回测系统，与处理tick数据的各种组件进行交互，从数据提供商获取历史价格，处理订单和持仓更新，并模拟触发我们策略执行均值回归计算的流动价格。每个周期的z分数被评估为交易信号，这导致生成市场订单，以在下一个交易日开盘时执行。我们进行了单次回测运行以及多次运行，参数不同的策略，绘制了结果的利润和损失，以帮助我们可视化我们交易策略的表现。
- en: 'Backtesting involves a lot of research that merits literature of its own. In
    this chapter, we explored ten considerations for designing a backtest model. To
    help improve our models on a continuous basis, a number of algorithms can be employed
    in backtesting. We briefly discussed some of these: k-means clustering, k-nearest
    neighbors, classification and regression trees, 2k factorial design, and genetic
    algorithms.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 回测涉及大量研究，值得有专门的文献。在本章中，我们探讨了设计回测模型的十个考虑因素。为了持续改进我们的模型，可以在回测中使用许多算法。我们简要讨论了其中一些：k均值聚类，k最近邻，分类和回归树，2k因子设计和遗传算法。
- en: In the next chapter, we will learn to perform predictions using machine learning.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习使用机器学习进行预测。
