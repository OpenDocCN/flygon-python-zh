["```py\nThe program must:\n...\n* have inputs that:\n  - ignore meaningless keystrokes\n  - require a value for all fields, except Notes\n  - get marked with an error if the value is invalid on focusout\n* prevent saving the record when errors are present\n\n```", "```py\ndef has_five_or_less_chars(string):\n    return len(string) <= 5\n\nwrapped_function = root.register(has_five_or_less_chars)\nvcmd = (wrapped_function, '%P')\nfive_char_input = ttk.Entry(root, validate='key', validatecommand=vcmd)\n```", "```py\nclass FiveCharEntry2(ttk.Entry):\n    \"\"\"An Entry that truncates to five characters on exit.\"\"\"\n\n    def __init__(self, parent, *args, **kwargs):\n        super().__init__(parent, *args, **kwargs)\n        self.config(\n            validate='focusout',\n            validatecommand=(self.register(self._validate), '%P'),\n            invalidcommand=(self.register(self._on_invalid),)\n        )\n\n    def _validate(self, proposed_value):\n        return len(proposed_value) <= 5\n\n    def _on_invalid(self):\n        self.delete(5, tk.END)\n```", "```py\nfrom datetime import datetime\n\nclass DateEntry(ttk.Entry):\n    \"\"\"An Entry for ISO-style dates (Year-month-day)\"\"\"\n\n    def __init__(self, parent, *args, **kwargs):\n        super().__init__(parent, *args, **kwargs)\n        self.config(\n            validate='all',\n            validatecommand=(\n                self.register(self._validate),\n                '%S', '%i', '%V', '%d'\n            ),\n        invalidcommand=(self.register(self._on_invalid), '%V')\n    )\n    self.error = tk.StringVar()\n```", "```py\ndef _toggle_error(self, error=''):\n    self.error.set(error)\n    if error:\n        self.config(foreground='red')\n    else:\n        self.config(foreground='black')\n```", "```py\n    def _validate(self, char, index, event, action):\n\n        # reset error state\n        self._toggle_error()\n        valid = True\n\n        # ISO dates, YYYY-MM-DD, only need digits and hyphens\n        if event == 'key':\n            if action == '0':  # A delete event should always validate\n                valid = True\n            elif index in ('0', '1', '2', '3',\n                           '5', '6', '8', '9'):\n                valid = char.isdigit()\n            elif index in ('4', '7'):\n                valid = char == '-'\n            else:\n                valid = False\n```", "```py\n        elif event == 'focusout':\n            try:\n                datetime.strptime(self.get(), '%Y-%m-%d')\n            except ValueError:\n                valid = False\n        return valid\n```", "```py\n    def _on_invalid(self, event):\n        if event != 'key':\n            self._toggle_error('Not a valid date')\n```", "```py\nif __name__ == '__main__':\n    root = tk.Tk()\n    entry = DateEntry(root)\n    entry.pack()\n    tk.Label(textvariable=entry.error).pack()\n\n    # add this so we can unfocus the DateEntry\n    tk.Entry(root).pack()\n    root.mainloop()\n```", "```py\nclass Displayer():\n\n    def display(self, message):\n        print(message)\n\nclass LoggerMixin():\n\n    def log(self, message, filename='logfile.txt'):\n        with open(filename, 'a') as fh:\n            fh.write(message)\n\n    def display(self, message):\n        super().display(message)\n        self.log(message)\n\nclass MySubClass(LoggerMixin, Displayer):\n\n    def log(self, message):\n        super().log(message, filename='subclasslog.txt')\n\nsubclass = MySubClass()\nsubclass.display(\"This string will be shown and logged in subclasslog.txt.\")\n```", "```py\nclass ValidatedMixin:\n    \"\"\"Adds a validation functionality to an input widget\"\"\"\n\n    def __init__(self, *args, error_var=None, **kwargs):\n        self.error = error_var or tk.StringVar()\n        super().__init__(*args, **kwargs)\n\n```", "```py\n        vcmd = self.register(self._validate)\n        invcmd = self.register(self._invalid)\n\n        self.config(\n            validate='all',\n            validatecommand=(vcmd, '%P', '%s', '%S', '%V', '%i', '%d'),\n            invalidcommand=(invcmd, '%P', '%s', '%S', '%V', '%i', '%d')\n        )\n```", "```py\n    def _toggle_error(self, on=False):\n        self.config(foreground=('red' if on else 'black'))\n```", "```py\n  def _validate(self, proposed, current, char, event, index, \n  action):\n        self._toggle_error(False)\n        self.error.set('')\n        valid = True\n        if event == 'focusout':\n            valid = self._focusout_validate(event=event)\n        elif event == 'key':\n            valid = self._key_validate(proposed=proposed,\n                current=current, char=char, event=event,\n                index=index, action=action)\n        return valid\n\n    def _focusout_validate(self, **kwargs):\n        return True\n\n    def _key_validate(self, **kwargs):\n        return True \n```", "```py\n   def _invalid(self, proposed, current, char, event, index, \n   action):\n        if event == 'focusout':\n            self._focusout_invalid(event=event)\n        elif event == 'key':\n            self._key_invalid(proposed=proposed,\n                current=current, char=char, event=event,\n                index=index, action=action)\n\n    def _focusout_invalid(self, **kwargs):\n        self._toggle_error(True)\n\n    def _key_invalid(self, **kwargs):\n        pass\n\n```", "```py\n   def trigger_focusout_validation(self):\n        valid = self._validate('', '', '', 'focusout', '', '')\n        if not valid:\n            self._focusout_invalid(event='focusout')\n        return valid\n```", "```py\nclass RequiredEntry(ValidatedMixin, ttk.Entry):\n\n    def _focusout_validate(self, event):\n        valid = True\n        if not self.get():\n            valid = False\n            self.error.set('A value is required')\n        return valid\n```", "```py\nclass DateEntry(ValidatedMixin, ttk.Entry):\n\n    def _key_validate(self, action, index, char, **kwargs):\n        valid = True\n\n        if action == '0':\n            valid = True\n        elif index in ('0', '1', '2', '3', '5', '6', '8', '9'):\n            valid = char.isdigit()\n        elif index in ('4', '7'):\n            valid = char == '-'\n        else:\n            valid = False\n        return valid\n\n    def _focusout_validate(self, event):\n        valid = True\n        if not self.get():\n            self.error.set('A value is required')\n            valid = False\n        try:\n            datetime.strptime(self.get(), '%Y-%m-%d')\n        except ValueError:\n            self.error.set('Invalid date')\n            valid = False\n        return valid\n```", "```py\nclass ValidatedCombobox(ValidatedMixin, ttk.Combobox):\n\n    def _key_validate(self, proposed, action, **kwargs):\n        valid = True\n        # if the user tries to delete, just clear the field\n        if action == '0':\n            self.set('')\n            return True\n```", "```py\n       # get our values list\n        values = self.cget('values')\n        # Do a case-insensitive match against the entered text\n        matching = [\n            x for x in values\n            if x.lower().startswith(proposed.lower())\n        ]\n        if len(matching) == 0:\n            valid = False\n        elif len(matching) == 1:\n            self.set(matching[0])\n            self.icursor(tk.END)\n            valid = False\n        return valid\n```", "```py\n    def _focusout_validate(self, **kwargs):\n        valid = True\n        if not self.get():\n            valid = False\n            self.error.set('A value is required')\n        return valid\n```", "```py\nclass ValidatedSpinbox(ValidatedMixin, tk.Spinbox):\n\n    def __init__(self, *args, min_var=None, max_var=None,\n                 focus_update_var=None, from_='-Infinity',    \n                 to='Infinity', **kwargs):\n        super().__init__(*args, from_=from_, to=to, **kwargs)\n        self.resolution = Decimal(str(kwargs.get('increment',  \n        '1.0')))\n        self.precision = (\n            self.resolution\n            .normalize()\n```", "```py\n            .as_tuple()\n            .exponent\n        )\n```", "```py\nfrom decimal import Decimal, InvalidOperation\n```", "```py\n    def _key_validate(self, char, index, current,\n                      proposed, action, **kwargs):\n        valid = True\n        min_val = self.cget('from')\n        max_val = self.cget('to')\n        no_negative = min_val >= 0\n        no_decimal = self.precision >= 0\n```", "```py\n        if action == '0':\n            return True\n```", "```py\n      # First, filter out obviously invalid keystrokes\n        if any([\n                (char not in ('-1234567890.')),\n                (char == '-' and (no_negative or index != '0')),\n                (char == '.' and (no_decimal or '.' in current))\n        ]):\n            return False\n```", "```py\n        # At this point, proposed is either '-', '.', '-.',\n        # or a valid Decimal string\n        if proposed in '-.':\n            return True\n```", "```py\n        # Proposed is a valid Decimal string\n        # convert to Decimal and check more:\n        proposed = Decimal(proposed)\n        proposed_precision = proposed.as_tuple().exponent\n\n        if any([\n            (proposed > max_val),\n            (proposed_precision < self.precision)\n        ]):\n            return False\n\n        return valid\n```", "```py\n    def _focusout_validate(self, **kwargs):\n        valid = True\n        value = self.get()\n        min_val = self.cget('from')\n\n        try:\n            value = Decimal(value)\n        except InvalidOperation:\n            self.error.set('Invalid number string: {}'.format(value))\n            return False\n\n        if value < min_val:\n            self.error.set('Value is too low (min {})'.format(min_val))\n            valid = False\n        return valid\n```", "```py\nsv = tk.StringVar()\nsv.trace('w', some_function_or_method)\n```", "```py\n    def __init__(self, *args, min_var=None, max_var=None,\n        focus_update_var=None, from_='-Infinity', to='Infinity', \n    **kwargs\n    ):\n        super().__init__(*args, from_=from_, to=to, **kwargs)\n        self.resolution = Decimal(str(kwargs.get('increment', '1.0')))\n        self.precision = (\n            self.resolution\n            .normalize()\n            .as_tuple()\n            .exponent\n        )\n        # there should always be a variable,\n        # or some of our code will fail\n        self.variable = kwargs.get('textvariable') or tk.DoubleVar()\n\n        if min_var:\n            self.min_var = min_var\n            self.min_var.trace('w', self._set_minimum)\n        if max_var:\n            self.max_var = max_var\n            self.max_var.trace('w', self._set_maximum)\n        self.focus_update_var = focus_update_var\n        self.bind('<FocusOut>', self._set_focus_update_var)\n```", "```py\ndef _set_focus_update_var(self, event):\n        value = self.get()\n        if self.focus_update_var and not self.error.get():\n            self.focus_update_var.set(value)\n```", "```py\n    def _set_minimum(self, *args):\n        current = self.get()\n        try:\n            new_min = self.min_var.get()\n            self.config(from_=new_min)\n        except (tk.TclError, ValueError):\n            pass\n        if not current:\n            self.delete(0, tk.END)\n        else:\n            self.variable.set(current)\n        self.trigger_focusout_validation()\n```", "```py\n        max_val = self.cget('to')\n        if value > max_val:\n            self.error.set('Value is too high (max {})'.format(max_val))\n```", "```py\n        self.inputs['Date'] = LabelInput(\n            recordinfo, \"Date\",\n            input_class=DateEntry,\n            input_var=tk.StringVar())\n        self.inputs['Date'].grid(row=0, column=0)\n        self.inputs['Time'] = LabelInput(\n            recordinfo, \"Time\",\n            input_class=ValidatedCombobox,\n            input_var=tk.StringVar(),\n            input_args={\"values\": [\"8:00\", \"12:00\", \"16:00\", \"20:00\"]})\n        self.inputs['Time'].grid(row=0, column=1)\n        self.inputs['Technician'] = LabelInput(\n            recordinfo, \"Technician\",\n            input_class=RequiredEntry,\n            input_var=tk.StringVar())\n        self.inputs['Technician'].grid(row=0, column=2)\n```", "```py\n        self.inputs['Lab'] = LabelInput(\n            recordinfo, \"Lab\",\n            input_class=ValidatedCombobox,\n            input_var=tk.StringVar(),\n            input_args={\"values\": [\"A\", \"B\", \"C\", \"D\", \"E\"]})\n```", "```py\n        self.inputs['Plot'] = LabelInput(\n            recordinfo, \"Plot\",\n            input_class=ValidatedCombobox,\n            input_var=tk.IntVar(),\n            input_args={\"values\": list(range(1, 21))})\n```", "```py\n       self.inputs['Plot'] = LabelInput(\n            recordinfo, \"Plot\",\n            input_class=ValidatedCombobox,\n            input_var=tk.StringVar(),\n            input_args={\"values\": [str(x) for x in range(1, 21)]})\n```", "```py\n        self.inputs['Humidity'] = LabelInput(\n            environmentinfo, \"Humidity (g/m\u00b3)\",\n            input_class=ValidatedSpinbox,\n            input_var=tk.DoubleVar(),\n            input_args={\"from_\": '0.5', \"to\": '52.0', \"increment\": \n            '.01'})\n```", "```py\n        # Height data\n        # create variables to be updated for min/max height\n        # they can be referenced for min/max variables\n        min_height_var = tk.DoubleVar(value='-infinity')\n        max_height_var = tk.DoubleVar(value='infinity')\n```", "```py\n        self.inputs['Min Height'] = LabelInput(\n            plantinfo, \"Min Height (cm)\",\n            input_class=ValidatedSpinbox,\n            input_var=tk.DoubleVar(),\n            input_args={\n                \"from_\": '0', \"to\": '1000', \"increment\": '.01',\n                \"max_var\": max_height_var, \"focus_update_var\": \n                 min_height_var})\n```", "```py\n        self.inputs['Max Height'] = LabelInput(\n            plantinfo, \"Max Height (cm)\",\n            input_class=ValidatedSpinbox,\n            input_var=tk.DoubleVar(),\n            input_args={\n                \"from_\": 0, \"to\": 1000, \"increment\": .01,\n                \"min_var\": min_height_var, \"focus_update_var\":  \n                max_height_var})\n```", "```py\n        self.inputs['Median Height'] = LabelInput(\n            plantinfo, \"Median Height (cm)\",\n            input_class=ValidatedSpinbox,\n            input_var=tk.DoubleVar(),\n            input_args={\n                \"from_\": 0, \"to\": 1000, \"increment\": .01,\n                \"min_var\": min_height_var, \"max_var\": max_height_var})\n```", "```py\n        self.error = getattr(self.input, 'error', tk.StringVar())\n        self.error_label = ttk.Label(self, textvariable=self.error)\n        self.error_label.grid(row=2, column=0, sticky=(tk.W + tk.E))\n```", "```py\n    def get_errors(self):\n        \"\"\"Get a list of field errors in the form\"\"\"\n\n        errors = {}\n        for key, widget in self.inputs.items():\n            if hasattr(widget.input, 'trigger_focusout_validation'):\n                widget.input.trigger_focusout_validation()\n            if widget.error.get():\n                errors[key] = widget.error.get()\n\n        return errors\n```", "```py\n        # Check for errors first\n\n        errors = self.recordform.get_errors()\n        if errors:\n            self.status.set(\n                \"Cannot save, error in fields: {}\"\n                .format(', '.join(errors.keys()))\n            )\n            return False\n```", "```py\n    def reset(self):\n        \"\"\"Resets the form entries\"\"\"\n\n        # clear all values\n        for widget in self.inputs.values():\n            widget.set('')\n\n        current_date = datetime.today().strftime('%Y-%m-%d')\n        self.inputs['Date'].set(current_date)\n```", "```py\n   def reset(self):\n        \"\"\"Resets the form entries\"\"\"\n\n        # gather the values to keep for each lab\n        lab = self.inputs['Lab'].get()\n        time = self.inputs['Time'].get()\n        technician = self.inputs['Technician'].get()\n        plot = self.inputs['Plot'].get()\n        plot_values = self.inputs['Plot'].input.cget('values')\n\n        # clear all values\n        for widget in self.inputs.values():\n            widget.set('')\n\n        current_date = datetime.today().strftime('%Y-%m-%d')\n        self.inputs['Date'].set(current_date)\n        self.inputs['Time'].input.focus()\n\n        # check if we need to put our values back, then do it.\n        if plot not in ('', plot_values[-1]):\n            self.inputs['Lab'].set(lab)\n            self.inputs['Time'].set(time)\n            self.inputs['Technician'].set(technician)\n            next_plot_index = plot_values.index(plot) + 1\n            self.inputs['Plot'].set(plot_values[next_plot_index])\n            self.inputs['Seed sample'].input.focus()\n```", "```py\nself.inputs['Time'].input.focus()\n```", "```py\nself.inputs['Seed sample'].input.focus()\n```"]