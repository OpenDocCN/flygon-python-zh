# 数据结构和函数

在这一章中，我们将穿越数据结构和函数的概念，这是 Python 的两个主要构建模块。普通变量是存储任何类型的单个数据单元的好方法，但对于数据数组，我们应该始终使用数据结构。Python 有大量可用的数据结构，您可以使用它们来表示和操作数据集，甚至将它们组合在一起以制作自己的数据结构。我们已经看到了内置数据类型，如整数，布尔值，浮点数，字符串和字符。它们被称为内置类型，因为它们与 Python 一起提供。现在，我们将探索内置数据结构，如列表，字典，元组和集合。这些内置数据类型的组合会独立实现数据结构。例如，如果我们将不同的整数放在一个地方，它们就是数字数组。Python 称它们为列表，这是广泛使用的数据结构。

为了成为熟练的程序员，我们首先必须了解核心编程范式，如变量，数字，模块和内置函数，然后再深入研究数据结构和算法。这本书也不例外。我们已经介绍了 Python 的基础知识；现在是时候深入研究数据结构和用于访问和操作数据的方法。在上一章中，我们使用条件和循环修改了我们的游戏。现在，让我们将对 Python 的知识扩展到包括数据结构和函数的广泛概念，以便我们可以完善我们的游戏决定最快

进一步。

本章将涵盖以下主题：

+   我们为什么需要数据结构？

+   Python 的四个结构支柱-列表，字典，集合和元组

+   函数

+   向井字棋游戏添加人工智能

+   游戏测试和可能的修改

# 技术要求

以下是您需要正确理解本章的要求：

+   Python IDLE

+   本章的代码资产可以在[`github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter04`](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter04)找到

查看以下视频以查看代码的运行情况：

[`bit.ly/2oNoxOL`](http://bit.ly/2oNoxOL)

# 我们为什么需要数据结构？

作为程序员或计算机科学家，我们总是在寻找优化代码的方法。优化是一种改进代码以提高代码效率和质量的方式。数据结构是计算机中组织数据的一种聪明方式，因此更容易检索和访问数据，从而实现代码优化。

到目前为止，我们已经学会了如何使用条件语句来制定条件，以及如何使用普通变量来进行流程控制。然而，现实世界的数据不限于一个单位。我们可能收集大量数据，这些数据可能具有最高级别的复杂性。它可能包含数千个整数，数百个布尔值，或者它们的组合。因此，将它们存储到一个单一的普通变量中是不可能的。请看以下示例：

![](img/ceef5509-9abd-4f84-bd5e-7b5f8ae1118b.png)

在上面的代码中，我们尝试将两个值分配给一个变量。这产生了语法错误。我们甚至尝试将两个字符串值放入一个变量`a`中，但它执行了连接，并将其分配为单个值。因此，在普通变量中存储多个值是不可能的。但是，我们可以轻松地将这个普通变量转换为数据结构，如下面的代码片段所示：

```py
>>> a = 8 , 9
>>> a
(8,9)
>>> type(a) 
<class 'tuple'>
```

我们已将普通变量`a`转换为元组，这是 Python 的一种内置数据结构。我们将在接下来的部分中详细介绍这一点。

这个变量只能存储单个数据单元，但如果我们进行多次赋值，前面的值将被覆盖。然而，如果你想在一个占位符中保留所有数据，数据结构是一种方法。

作为程序员，我们的主要责任是对输入数据集进行某种操作。输入可以是任何东西，比如电子邮件或密码，或者可能是进入系统或谷歌地图位置的请求，我们可以使用数据使用算法进行某种计算。此外，haversine 算法（请参考以下网址了解更多关于这个算法的信息：[`rosettacode.org/wiki/Haversine_formula`](https://rosettacode.org/wiki/Haversine_formula)）可以给出您的位置和目的地之间的精确距离。因此，输入数据可以有很广泛的范围，但主要任务是对其进行操作。我们的系统和处理器没有足够的能力一次处理数百太字节的数据操作。因此，选择适当的数据结构是程序员可以进行的主要优化。如果我们能够以任何有组织的形式将这些输入存储到更快的数据结构中，我们甚至可以轻松地执行复杂的任务。数据结构只是提供结构给这些复杂数据的地方或存储，但是像获取和操作这样的过程是使用算法来执行的。

还有疑问吗？让我们通过以图书馆为例来清楚地理解数据结构和算法。首先，想象一个没有适当管理的图书馆的情景。书籍没有被正确放置在相关的部分。现在，在特定部分搜索书籍是没有意义的，因为它不会在那里。最好的情况是你可能会在几分钟内找到你的书，但最坏的情况是你可能不得不搜索整个图书馆来找一本关于历史的书，例如。然而，如果图书馆得到了适当的组织和管理，你将能够直接去到存放历史书籍的相关部分，并且只在那个部分搜索你的书。在这里，图书馆代表了数据结构，书是你正在寻找的数据。每当你需要数据时，你去到数据结构，如果它被适当管理，你将能够轻松地检索到它。定义你将如何搜索书籍的步骤被称为算法。

理论够了，让我们动手编码，学习 Python 的四大数据结构支柱——**列表**、**字典**、**集合**和**元组**。

# Python 的四大结构支柱——列表、字典、集合和元组

在第二章中，*学习 Python 的基础知识*，我们学习了字符串，并将它们称为不可变数据类型，因为它们不允许赋值操作。这在以下代码中显示：

```py
>>> name = "Python"
>>> name[0] = 'hey'
TypeError: 'str' object does not support item assignment
```

然而，数据结构必须是灵活的，这意味着我们应该能够从任何位置存储和提取数据元素。因此，Python 的大多数内置数据结构都是可变的，这意味着它们可以通过适当的索引进行更改和操作。四种数据结构的适当类别如下：

+   **列表和元组**：可变数据结构

+   **字典**：映射数据结构

+   **集合**：可变且无序的数据结构

每个类别都因其独特性而存在，您将看到在接下来的部分中，很容易将它们区分为优越或次优。但是，请记住，它们在某些时候都是优越的；我们可以选择一个适合情况的数据结构。例如，我们说字典是数据结构之王，但我们可能会遇到元组可能是存储数据的更快方式的情况，通常在使用 SQLite 和 MySQL 等数据库制作 Python 程序时会出现这种情况。现在，让我们来看看 Python 的每个内置数据结构，从基本的可变数据结构开始，即列表。

# 列表

就像字符串是字符序列一样，列表是值序列。值可以是任何类型的组合。列表中的值称为该列表的项。列表是可变和有序的数据结构，可以使用索引提取列表的元素。与字符串一样，我们可以使用切片技术从列表中提取多个元素。列表以存储同质数据类型而臭名昭著，但它们也支持异质数据类型。我们不仅限于使用单一方法创建列表；有多种方法可以做到这一点。让我们看一些在 Python 中创建列表的基本方法：

```py
>>> first_list = []  
>>> type(first_list)
<class 'list'>
```

创建列表的最简单方法是使用方括号——`[]`。您可以在这些方括号中添加多个元素，有多种方法可以做到这一点：

+   首先，我们可以在声明列表的同时向列表中添加元素，如下例所示：

```py
      >>> numbers = [1,2,3,4,5,6,7,8,9]
```

+   您还可以使用 Python 内置方法向列表中添加元素。例如，`append`方法可用于向列表中插入元素。元素被添加到列表的最后位置，如下所示：

```py
      >>> numbers.append(10)
      >>> print(numbers)
      [1,2,3,4,5,6,7,8,9,10]
```

我们还可以创建一个包含多种类型值的列表，如下例所示：

```py
>>> [3,7,9,"odd",True]
[3,7,9,"odd",True]
```

在这里，我们创建了一个包含数字、字符串和布尔值的列表。因此，我们在一个列表中存储了异构的数据类型。我们还可以在一个列表中添加多个列表，这些被称为嵌套列表。正如术语所示，一个列表嵌套在另一个列表中，如下例所示：

```py
>>> [1,2,3,[4,5,6],7,["hey","Python"]]
```

在上一个例子中，我们创建了一个包含六个元素的单个列表。我们在主列表中有整数和两个整体列表（`[4,5,6]`和`["hey","Python"]`）。因此，这些类型的列表被称为嵌套列表。

每当您将这些列表分配给变量时，变量类型最终变为列表类型。现在，变量的类型已从内置数据类型（如`int`、`str`或`bool`）更改为内置数据结构，即列表。

创建列表的另一种方法是使用内置的 Python 方法——`list()`方法——但在前面的过程中是多余的，因为我们必须将整个列表作为这个列表方法的参数。这被称为类型转换方法。如果你想将任何其他数据结构转换为列表，我们使用`list()`方法，如下例所示：

```py
>>> list([1,2,3,4,5])
[1,2,3,4,5]
```

在`list()`方法中，我们必须以包含元素的列表形式传递参数，这些元素使用方括号括起来。到这一点，您一定已经猜到了，Python 中可用的每个内置数据结构都必须有一个内置方法来创建其数据结构。我们使用`dict()`方法创建字典，使用`set()`方法创建集合，使用`tuple()`创建元组，就像`list()`方法创建列表一样。

由于我们在本节中揭示了创建一个名为`list`的简单而强大的数据结构的不同方法，让我们看看如何访问和操作其存储的数据。

# 访问列表元素

如果你回忆一下我们访问字符串元素的方式，你也可以在列表的情况下复制这个过程。我们在列表中使用方括号来指示它的位置，这样我们就可以提取和与特定元素交互。我们称之为索引，它被添加在这个`[]`括号符号内。创建新列表时也是一样的。列表的索引从 0 开始，以单位数字递增，同时从左到右遍历。与字符串一样，列表也支持负索引：

```py
>>> winner_names = ["Chandler","Joey","Monica","Racheal","Ross"]
>>> winner_names[0] #0 is first index
'Chandler'
>>> winner_names[-1] #-1 is last element
'Ross'
```

当我们尝试给字符串赋值时，是无效的。与字符串不同，列表可以重新分配项目给列表。因此，我们可以说列表是可变的，这意味着它们是可改变和可修改的。这个特性使得列表成为所有数据结构中最简单和最灵活的。我们可以使用 append 方法来分配元素，这是我们在前面部分看到的，但这个方法只允许我们将元素添加到列表的末尾。如果你想要添加元素到任何特定位置，你可以通过索引和赋值语句明确告诉 Python 解释器来做这件事。

例如，如果你想在列表的两个元素之间添加`loves`，你可以这样做：

```py
>>> msg = ["Joey","Monica","Racheal"]
>>> msg[1] = "loves"
>>> msg
['Joey','loves','Racheal']
```

因此，我们可以看到位置一的元素`Monica`已经被`loves`替换，这表明我们可以改变元素的顺序，并重新分配任何其他元素给列表。

在处理数据结构时，观察它们是一种良好的实践。我们可以将它们视为一种映射过程，列表上的每个元素都映射到某个索引。索引是位置，每当我们通过索引回溯列表时，我们就能访问这些索引的元素。即使你有一个嵌套列表，也就是说，在单个列表内有一个或多个列表，它们也会被映射到一个索引，如下面的例子所示：

```py
>>> web_dev = [["Django","Flask"],["Laravel","Symfony"],"Nodejs","GOLang"]
>>> web_dev[0]
['Django','Flask']
>>> web_dev[1]
['Laravel','Symfony']
```

我们知道方括号用于访问列表的元素，但如果我们想要访问嵌套列表的元素，我们必须添加另一个方括号，以指定需要访问这些元素的索引级别，如下面的例子所示：

```py
>>> web_dev[0][0]
'Django'
>>> web_dev[1][1]
'Symfony'
```

我们可以使用`in`关键字来检查元素是否在列表中。语句的语法会返回一个布尔值，要么是`True`，要么是`False`：

```py
>>> names = ["John","Jack","Cody"]
>>> "Cody" in names
True
>>> "Harry" in names
False
```

访问列表的元素更容易，但有时如果在计算正确的索引时出错，可能会得到意外的结果。因此，你必须从索引 0 开始计算列表的元素。如果你在方括号中放入不映射到任何值的索引，你将遇到一个错误，称为`IndexError`，如下面的例子所示：

```py
>>> odd = [1,3,5,7,9]
>>> odd[20]
IndexError: list index out of range
```

`IndexError`消息基本上解释了我们为什么会遇到这个错误。名为 odd 的列表的索引停在 4。然而，我们传递了 20，这是没有映射到值的位置，或者简单地说，我们在这个位置没有任何元素。因此，在处理列表时，我们必须跟踪插入值的每个位置，以免遇到任何异常。然而，我们有一个解决方案来防止这种情况——只需回想一下异常处理伙伴！这就是你需要调用的，以处理这些异常，使我们的代码能够正常运行而不是崩溃。

既然我们已经学会了使用索引技术访问这些元素，那么让我们深入了解如何遍历整个列表，这是访问整个列表的一部分。首先，你必须意识到的是循环。因为我们正在处理一个包含多个数据项的列表——这意味着多次访问多个数据——我们只需要回想一下我们通常会使用的重复操作的方法。没有比循环更适合这种情况的了。因此，如果你想读取列表的所有元素，`for`循环是最合适的方法，例如：

```py
>>> for number in [1,2,3,4]:
         print(number)
1
2
3
4
```

我们也可以在`for`循环中更新和完善我们的列表。以下示例是我们迄今为止学到的最重要的示例之一；确保你从中掌握每一个细微的信息：

```py
>>> even_num, odd_num = [], []
>>> for i in range(0,10):
        if i % 2 == 0:
            even_num.append(i)
        else:
            odd_num.append(i)

>>> print(even_num)
[0,2,4,6,8]
>>> print(odd_num)
[1,3,5,7,9]
```

像往常一样，让我们将前面的代码分成几个部分。首先，我们声明了两个空列表，它们将是我们的偶数和奇数列表的输出列表。然后，我们使用循环来访问列表的元素。语句 range(0, 10)将生成一个包含 0 到 9 的数字的列表。这里，10 是排除位置。因此，我们逐个循环整个元素列表。如果你对递归编程的概念有困难，回想一下*遍历字典*部分。在每次迭代中取出列表的每个元素后，我们进入循环体并检查将确定元素是偶数还是奇数的条件。如果是偶数，我们将其追加，这意味着我们将该元素插入`even_num`列表中，在奇数的情况下我们也是这样做的。

哇，你意识到你刚刚做了什么吗？你使用了一个简单但强大的数据结构，并进行了线性搜索。虽然我们还有很多其他主题要讨论，但这是迄今为止我们所做的最好的事情。现在，准备好学习更多关于列表操作和方法的知识。

# 列表操作和方法

你还记得前一章中 Python 的类型转换方法吗？这绝对是将一种数据类型转换为另一种的最佳方法。我们已经看过字符串、它的切片技术和方法。不过，我们意识到它是不可变的。这种限制是如此强大，以至于我们无法更改该字符串的任何元素。不过，现在我们已经来到了最灵活的数据结构，它被称为`list`。那么，为什么不将字符串转换为列表，以便我们也可以使其可变呢。让我们使用以下示例来澄清这一点：

```py
>>> name = "python"
>>> type(name)
<class 'str'>
>>> name = list(name) #list() method converts any data type to list
>>> type(name)
<class 'list'>
>>> name[0] = 'c'
>>> name
['c', 'p', 'y', 't', 'h', 'o', 'n']
```

现在，我们可以随心所欲地操作前面的列表；也许使用内置方法。不过，除了赋值之外，大多数操作与字符串的操作相似。我们在字符串部分学到了很多东西，比如切片、加法和乘法操作，甚至一些字符串方法。字符串和列表的操作相当相似——它们甚至从相同的索引 0 开始。也就是说，Python 为字符串和列表提供的内置方法并不是那么相似，为什么会呢？它们是不同类型的数据或结构。

你可以对列表进行算术运算，比如加法和乘法。不过要记住，加法只能在两个列表之间进行，而乘法必须在列表和任何整数之间进行，如下面的例子所示：

```py
>>> even = [0,2,4,6,8]
>>> odd = [1,3,5,7,9]
>>> number = even + odd
>>> number
[0,1,2,3,4,5,6,7,8,9]
```

```py
>>> ["john"] * 3
['john','john','john']
```

在第一个例子中，我们使用加法运算符对列表执行了连接操作。在第二个例子中，我们将列表乘以三，乘法的效果可以在该列表的内容中观察到。在我们的例子中，`john`被乘以三，创建了三个`john`值。

Python 提供的内置方法用于操作列表的值。它们通过创建列表的对象来对列表进行操作。让我们不要在这里谈论对象，我们有一个专门的章节来讨论对象。

有许多可用的内置方法可以操作列表结构，但我们将在这里介绍最重要的方法。我发现它们很有用，因为大多数开发人员在进行大型项目时只使用其中的一些。但是，如果你想发现更多，浏览文档页面总是一个好的实践。

我们已经看到如何使用`append`方法将元素插入列表。这个方法将元素添加到列表的末尾。但是，如果你想要插入多个元素到列表中，我们可以使用`extend`方法，如下例所示：

```py
>>> list_1 = [1,2,3]
>>> list_1.append(4)
>>> list_1
[1,2,3,4]
>>> list_2 = [5,6,7]
>>> list_1.extend(list_2)
>>> list_1
[1,2,3,4,5,6,7]
```

在前面的代码中，`extend`方法将列表作为参数，并附加调用的列表的所有元素。当我们打印`list_2`时，我们会看到列表保持不变。

与添加元素到列表的方法类似，我们也有一个可以从列表中删除元素的方法。实际上，有两种方法可以用来删除元素。一种是通过将索引作为参数传递，而另一种是直接将要删除的元素作为参数传递。当我们使用`pop`方法时，我们必须传递要从列表中删除的元素的索引；但是当我们使用`remove`方法时，我们必须将元素传递给它，以指定需要删除的特定元素。看一下以下代码片段的例子：

```py
>>> fruits = ["Apple","Banana","Orange","Mango"]
>>> fruits.pop(1)
"Banana"
>>> fruits
["Apple","Orange","Mango"]
>>> fruits = ["Apple","Banana","Orange","Mango"]
>>> fruits.remove('Orange')
>>> fruits
["Apple","Banana","Mango"]
```

还有另一种删除列表中元素的方法，就是使用简单的`del`关键字。警告：如果你写`>>> del fruits`，整个列表将被删除。确保你明确指定需要删除的元素。可以以类似于使用方括号访问元素的方式获取特定元素，如下例所示：

```py
>>> fruits = ["Apple","Banana","Orange","Mango"]
>>> del fruits[-1]
>>> fruits
["Apple","Banana","Orange"]
```

Python 中有许多可用的内置函数，可以对列表执行算术和逻辑操作。使用这些函数不可避免地使代码更清晰、更可读，我们可以在一行内执行许多任务。Python 列表的一些重要内置函数如下：

```py
>>> prime = [2,3,5,7,11,13,17]
>>> sum(prime) 
58
>>> min(prime)
2
>>> max(prime)
17
>>> len(prime)
7
```

在这里，`sum`函数将给我们一个列表元素之间的加法结果。这个方法只适用于整数和浮点值。接下来，min 和 max 函数分别给出列表的最小值和最大值。另一个重要的函数是`len()`，它将给出列表的长度。这个`len`函数适用于任何对象。此外，我们可以将它与字符串一起使用，以找到列表中字符的数量。

有时，你可能只想提取列表的特定部分或切片，例如，只提取包含 1000 个项目的列表中存储的前四个项目。在这种情况下，你必须使用切片技术，这将在下一节中介绍。

# 切片列表

在学习切片列表的技巧之前，让我们回顾一下如何切片字符串的部分。我们使用方括号运算符指定切片的起始和结束点。在列表的情况下，情况相当类似，如下例所示：

```py
>>> book = "Python Games"
#lets extract Games
>>> book[7:]
'Games'
```

通过在方括号内添加起始索引和停止索引来对列表进行切片。在前面的例子中，停止索引元素被排除在结果切片之外。让我们做一个简单的例子，可以切片我们列表中的元素的部分：

```py
>>> info = ["I","Love","Python","Java","NodeJS","C"]
>>> info[:3:]
["I","Love","Python"]
```

`info[:3:]`语句中给出的第二个冒号是可选的。第一个分号将两个块分开，作为起始和结束位置，但如果您不想添加`step`，则第二个冒号是不必要的。要了解更多关于`[start:stop:step]`的信息，请查看第二章 *学习 Python 基础*中的*字符串切片技术*部分。以以下代码为例：

```py
>>> info[:3] #same result as previous
["I", "Love", "Python"]
```

在前面的代码中，`>>> info[:3:]`，我们在方括号内添加了一个冒号（`:`）分隔符来指定列表的索引。第一个冒号前的空格是切片的起始索引；这里，我们传递了空索引，这意味着它是默认的，它将从列表的开头开始切片。我们在第一个冒号后的下一个占位符中传递了索引三，以指定切片过程的结束索引。这里，索引三处的元素是`Java`，但它处于排除位置，这意味着它将从列表的开头切片直到索引为二的元素。第二个冒号后的最后一个占位符指定了切片中需要包含的步骤。它的值为空，这意味着它是默认的；因此，我们得到了一个在这些索引之间没有跳过任何元素的结果。它的工作方式与字符串切片技术相同。

现在，让我们通过检查字符串对象的缺陷来了解列表的需求。我们将在下一节中看到，列表被认为比字符串更优越和更普遍**。**

# 字符串和列表对象

到目前为止，我们已经涵盖了关于列表的多个主题；我们看到了如何为自己创建一个列表，并且我们看到了如何使用内置方法添加、删除和操作列表的元素。现在，让我们谈谈关于字符串和列表对象的另一个重要概念。每当我们创建任何字符串时，都会创建一个对象并将其存储在特定的内存引用中。对于程序中创建的任何字符串，Python 解析器都会为它们创建一个对象，如下例所示：

```py
>>> name_1 = "Python"
>>> name_2 = "Python"
>>> name_1 is name_2
True
```

在前面的例子中，`name_1`和`name_2`都指向同一个对象。因此，我们可以说它们是等价和相同的。使用相同的`Python`字符串创建了两个变量。这两个赋值操作并不会创建两个对象；相反，会创建一个单一的对象并映射到全局命名空间中。我们可以看到，这两个具有相同内容的变量创建了一个单一的对象：

![](img/9705e59f-a13d-438b-b959-b0e5818f6eb7.png)

但是在列表的情况下，即使内容相同，它们也会创建两个不同的对象，如下例所示：

```py
>>> list_1 = ['a',1,2]
>>> list_2 = ['a',1,2]
>>> list_1 is list_2
False
```

您可以清楚地看到，在前面的代码中，我们得到了`False`的结果，这意味着这两个列表是两个不同的对象。它们并不相似，尽管它们的内容是相似的。因此，每当我们创建列表变量时，我们将它们称为列表对象，其内容是该对象的值。

最后，在本节中，我们已经介绍了我们的基本和强大的`list`数据结构。虽然我们还没有发现`list`的威力，但我们从第二章 *学习 Python 基础*开始就一直在使用它。你还记得我们用`list`来表示井字棋游戏的位置吗？因此，我们可以得出结论，即使我们有更强大和复杂的数据结构，如字典、树和队列，列表仍被认为是数据结构的**女王**，因为它们在简单的结构中容纳复杂的数据类型时非常有用。现在，让我们学习一下**字典**，它被认为是数据结构的**国王**。

# 字典

对新数据结构的发现是因为先前数据结构的缺陷。让我们回顾一下列表的缺点。我们已经将元素存储在遵循某种顺序的列表结构中，并且我们必须使用索引来检索这些值。但是这些索引是虚构的。每当您想使用列表时，您都必须记住该序列的顺序，否则您将遇到`IndexError`异常。

现在，让我们了解一下 Python 中可用的更坚固的数据结构。字典，顾名思义，涉及以与牛津词典相似的方式处理数据结构。在我们的现实世界字典中，我们有键和值对。键是指您想在字典中搜索的单词，而值是指该单词的含义。与牛津词典类似，我们的字典数据结构中也有键和值对，并且我们将它们称为元素或项目。在列表的情况下，我们也有键和值对。键是虚构的，即索引，值是该列表的元素，如下例所示：

```py
>>> my_list = ["python","java"]
```

在这里，`python`字符串是值，索引零是它的键。在列表的情况下，键只能是整数。在字典的情况下，键可以是任何类型。我们需要在字典结构中明确指定键。在每个键和值对之间，我们需要放一个冒号（`:`）。让我们创建一个字典来澄清事情：

```py
>>> my_dict = {}
>>> type(my_dict)
<class 'dict'>
```

我们使用方括号`[]`来创建列表。但现在，我们将使用花括号`{}`来创建字典。我们必须使用`键:值`对向字典中添加项目。让我们创建一个简单的字典，其中包含人名作为键，年龄作为值：

```py
>>> info = {"Monica" : 32, "Joey" : 29, "Ross" : 55 }
>>> info
{'Monica': 32, 'Ross': 55, 'Joey': 29} 
```

您可以将字典想象为一组索引和一组值之间的映射器。在这里，索引可以是任何类型，而不像列表那样只能是整数。在我们的`info`字典中，我们将键设置为字符串集合，将值设置为整数。

现在，让我们观察一下在前面的代码中打印出的`info`字典。我们可以清楚地看到输出序列与输入的顺序不同。元素位置已经交换。在这种情况下，如果元素较少，这可能不是问题。但是，如果我们创建一个包含 1,000 个项目的字典，您将清楚地观察到输出字典的顺序与输入的顺序不同。在我们的示例中，我们将`Ross`键添加到字典的末尾，但在打印相同的字典时，我们得到`Ross: 55`添加到第二个位置。因此，您可能会想知道，访问该字典的元素会有什么区别吗？一点也没有！字典是无序排列的，不像列表那样。要访问字典的元素，我们必须使用键作为标识符。访问字典的元素与访问列表的元素非常相似，但是我们不是在方括号内放置索引，而是放置键。例如，如果您想获取`Monica`的年龄，我们使用以下代码：

```py
>>> info["Monica"]
32
>>> info["Joey"]
29
>>> info["Chandler"]
KeyError: 'Chandler'
```

我们将得到`KeyError`而不是`IndexError`，这指定字典中没有名为`Chandler`的键的元素。因此，访问列表可能会增加负担，因为我们必须跟踪该列表的每个可能的索引。对于长度较小的列表来说，这不是问题，但想象一下包含 10,000 个或更多元素的列表。为了克服这种开销，最好使用字典，因为它们更容易访问，而且遇到异常的几率也较小。话虽如此，字典也不是完美的数据结构，我们将在接下来的部分看到为什么大多数人更喜欢列表而不是字典。

另一种创建字典的方法是使用`dict()`方法。让我们看看它是如何使用的：

```py
>>> info = dict()
>>> info
{}
```

我们使用内置的`dict()`方法创建了一个空字典。现在，让我们看看如何向该字典添加元素：

```py
>>> info["Python"] = 1990
>>> info["C"] = 1973
>>> info["Java"] = 1970
>>> info
['Python': 1990, 'C': 1973, 'Java': 1970]
```

由于我们已经看到了如何使用两种方法创建自己的字典，让我们看看如何获取该字典的每个元素。由于我们的数据结构可能包含许多值，我们必须使用循环来迭代它。我们将在下一节中看看如何遍历字典。

# 遍历字典

由于字典包含有限数量的键和值，我们可以使用`for`循环来迭代它。`for`循环将遍历字典的键。可以使用方括号`[]`来提取特定键的值，并将键传递给它。让我们看看这是如何工作的：

```py
>>> info = {'Python': 1990, 'C': 1973, 'Java': 1970}
>>> for key in info:
        print(key,info[key])

Python 1990
C 1973
Java 1970   
```

在前面的代码中，`info[key]`将提取该键的值。`for`循环将遍历字典的键，并且在每次迭代中，`key`变量将存储字典的键。然而，如果我们想要在`for`循环内提取键和值，我们将会得到`ValueError`。让我们看看我是什么意思：

```py
>>> for key,value in info:
        print(key,value)
ValueError: too many values to unpack (expected 2)
```

我们得到了前面的错误，因为字典不是可迭代的。然而，我们可以将其转换为另一个数据结构，例如元组或列表，以便我们可以直接在`for`循环的定义中获取键和值。我们将通过将其转换为元组使这个字典可迭代，这将在即将到来的关于元组的部分中介绍。

Python 提供了一堆内置方法，以便根据您的需求操作字典。例如，如果您想要删除一个项目或向字典中插入一个项目，您不必编写自定义逻辑来实现它；相反，Python 有内置函数来实现这一点。我们将在下一节中介绍一些最重要的字典方法。

# 字典方法

向字典添加元素更容易，我们已经看到了一些例子。现在，让我们看看如何使用`pop()`方法从字典中删除一个元素。对于作为`pop()`键的参数，该方法将从字典中删除并返回一个元素。让我们看一个简单的例子：

```py
>>> info = {'Python': 1990, 'C': 1973, 'Java': 1970}
>>> info.pop('C')
1973 
>>> info
{'Python':1990, 'Java': 1970}
```

如果要检索键的特定值，可以使用`get`方法：

```py
>>> info.get('Python')
1990
```

我们可以调用`values`方法进入字典，它将返回一个对象视图，表示字典的所有值。类似于`values()`，我们可以使用`keys()`方法打印字典对象，它将表示字典的所有键：

```py
>>> info.values()
dict_values([1990, 1970])
>>> info.keys()
dict_keys(['Python', 'Java'])
```

我们还可以使用`len()`方法，它将返回存储在字典中的项目数，如下例所示：

```py
>>> len(info)
2
```

如果您想打印字典的浅拷贝，可以使用`copy()`方法，如下例所示：

```py
>>> old = { "Zero" : 0 , "One" : 1}
>>> new = old.copy()
>>> new
{'Zero': 0, 'One': 1}
```

现在，我们已经看到了一些例子，这些例子让我们知道如何创建自己的字典，并向我们展示了如何使用各种字典方法访问它们。现在，让我们探索元组——另一个不可变的数据结构。

# 元组

元组在处理方面与列表非常相似，但它们是不可变的，而列表是可变的。我们可以以类似于列表的方式在元组中存储值的序列。就像我们使用`[]`来创建列表，使用`{}`来创建字典一样，我们使用`()`来创建元组。存储在元组中的值可以是任何类型，并且这些值都通过索引进行映射，就像列表一样。元组的第一个元素的索引是零，并且从左到右递增，同时从左到右遍历。元组的一个优点是它们是可迭代的。因此，我们可以将非可迭代的数据结构，例如字典，转换为元组，以便我们可以在循环声明中提取键和值对。

让我们创建一个简单的元组：

```py
>>> numbers = (1,2,3,4,5)
>>> type(numbers)
<class 'tuple'>
```

我们还可以使用 Python 中的内置方法来创建元组。我们可以使用`tuple()`方法创建空元组：

```py
>>> numbers = tuple()
>>> numbers
()
>>> numbers = tuple('abcde')
>>> numbers
('a','b','c','d','e')
```

如果您想创建一个只有一个元素的元组，您必须在添加这个元素后加上逗号，否则 Python 会将其视为内置数据类型，比如整数或字符串，如下面的代码所示：

```py
>>> odd = (1,)
>>> type(odd)
<class 'tuple'>
>>> even = (2)
>>> type(even)
<class 'int'>
```

创建元组的另一种方法是在每个项目之间添加逗号：

```py
>>> numbers = 1,2,3,4,5,6,7
>>> type(numbers)
<class 'tuple'>
```

我们对列表执行的大多数操作在元组的情况下也适用。为了访问元组的元素，我们使用方括号运算符并将索引传递给它，如下例所示：

```py
>>> numbers[0]
1
>>> numbers[-1]
7
```

切片操作也可以像列表一样用于元组。这个操作将导致从元组中提取的一系列值。看下面的例子：

```py
>>> numbers[3:]
(4,5,6,7)
>>> numbers[::2]
(1,3,5,7)
```

元组不支持项目赋值，这使得它成为一个不可变的数据结构，如下例所示：

```py
>>> names = ("Jack","Cody","Hannah")
>>> names[0] = "Perry"
TypeError: 'tuple' object does not support item assignment
```

现在您已经了解了字典和元组，让我们看看如何将它们从一个转换为另一个。因为所有可用的数据结构都不是完美的，它们都有一些缺陷；因此，接下来的部分将是迄今为止我们所涵盖的最重要的部分之一。这是我们将在字典和元组之间执行转换的地方。

# 元组和字典

字典不是完美的可迭代对象，这意味着我们不能使用`for`循环直接从中提取键和值。我们只能从字典中提取键，但如果要提取`键:值`对，我们必须将其转换为另一个可迭代的数据结构。让我们看一个例子并观察结果，显示了从字典到列表的转换：

```py
>>> person_address = {"Carl": "London", "Montana": "Edinburgh"}
>>> list(person_address)
["Carl","Montana"]
```

将字典直接转换为列表不会保留字典的值。它会返回一个只包含字典键的对象。由于缺少值，这些信息是无用的。让我们尝试将其转换为元组并查看结果：

```py
>>> tuple(person_address)
("Carl","Montana")
```

除了使用`tuple()`方法将字典转换为元组，还有另一种有效的方法。我们可以使用`items()`方法执行相同的任务。它用于返回包含键和值存储在嵌套元组中的列表的字典对象，如下例所示：

```py
>>> person_address.items()
dict_items([('Carl', 'London'), ('Montana', 'Edinburgh')])
```

现在，我们可以使用`for`循环在这个对象中进行迭代，并在声明的同时获取键和值，如下例所示：

```py
>>> for key,value in person_address.items():
        print(key,value)
Carl London
Montana Edinburgh
```

到目前为止，我们已经涵盖了三种强大的数据结构——列表、字典和元组。接下来是**集**；一种无序的结构，被认为是可迭代和可变的，但不存储重复元素。

# 集

通过将这种数据结构与数学中的著名概念集进行简化。在数学中，集被认为是不同实体的集合，通常被认为是对象。数字 1、2 和 3 分别是对象，但当它们组合在一起时，它们形成一个大小为 3 的单一集合。它们在 Python 中也是一样的。Python 中的集是一组既不排序也不索引的对象。

可以使用两种不同的方法创建 Python 集：

+   第一种方法类似于创建字典的方式；我们将传递对象本身，而不是键和值对，如下例所示：

```py
      >>> num = {1,2,3,4,5}
      >>> type(num)
      <class 'set'>
```

+   另一种方法是使用 Python 的内置方法`set()`，您需要以列表形式传递对象序列，如下例所示：

```py
      >>> set(['a','b','c'])
      {'c','a','b'}
```

在前面的代码中，我们可以看到花括号中的元素是无序的。我们在创建集合时传递的对象顺序不会被保留。它们也不支持集合中的重复项。如果集合中同一元素多次重复，只会保留一个元素，其他所有元素都将从结构中删除，如下例所示：

```py
>>> {"laptop","mobile","mouse","laptop","mobile"}
{'mouse', 'laptop', 'mobile'}
```

与列表和元组不同，集合也是非索引的。如果要访问集合的元素，不能使用索引技术，因为这会引发`TypeError`：

```py
>>> names = {"Ariana","Smith","David"}
>>> names[0]
TypeError: 'set' object is not subscriptable
```

由于集合是可迭代的，我们只能通过循环来访问它们。适当的循环将是 for 循环，因为在使用它时我们不必担心终止点：

```py
>>> names = {"Ariana","Smith","David"}
>>> for name in names:
        print(name)

Ariana
Smith
David
```

现在我们已经看到了如何创建和访问自己的集合，让我们深入了解可用的集合基本方法，以便我们可以操纵它们的结构。

# 集合方法

集合是可变的，但一旦它们被创建，就不能更改它们的项；相反，你可以向该集合添加或删除项。它与列表非常相似，但是有序的。现在，让我们从 Python 集合的最常用方法开始这个主题：

+   我们可以向集合中添加单个和多个项，有两种方法可以做到这一点。`add()`方法每次只会向集合中插入一个单个项。另一方面，`update()`方法将同时向集合中添加多个项。元素的添加是无序的，它们可能被插入到任何位置：

```py
      >>> favorite = {"Java","C","C#"}
      >>> favorite.add("Python")
      >>> favorite
      {'Java','C#','Python','C'}

      >>> #for update method
      >>> favorite.update(["Python","JavaScript","R"])
      >>> favorite
      {'Python','Java','R','C#','C','JavaScript'}
```

+   有许多方法可以删除集合的元素。可以使用`remove()`、`discard()`和`pop()`等方法。如果要从集合中删除的项不存在，`remove()`将抛出一个名为`KeyError`的异常，但在`discard()`方法的情况下，我们的代码不会遇到任何错误，如下例所示：

```py
      >>> favorite.remove('C')
      >>> favorite
      {'Python','R',"JavaScript','Java','C#'}

      >>> favorite.remove("NodeJS")
      KeyError: 'NodeJS'

      >>> favorite.discard("NodeJS")
      >>> #no error
```

+   我们还可以使用`pop()`方法从集合中删除元素。`pop()`只会从集合中删除最后一个元素。然而，由于集合是无序的且没有索引，我们不知道哪个元素将成为集合中的最后一个元素。因此，使用`pop()`会很危险，因为我们无法知道特定项的移除。`pop()`将返回从集合中移除的项，如下例所示：

```py
      >>> favorite.pop()
      'R'
```

+   如果你想从集合中删除每个元素，可以使用两种方法，但这些操作的结果略有不同。可以使用`del`关键字加上集合的名称来删除整个集合元素以及集合结构。另一方面，`clear()`方法用于清空集合，但其结构不会被完全删除：

```py
      >>> favorite.clear()
      >>> favorite
      set()
      >>> del favorite
      >>> favorite
      NameError: name 'favorite' is not defined
```

+   我们还可以执行并集、交集等操作，就像在数学中一样。并集操作返回一个包含原始集合中所有元素和指定集合中所有元素的集合。集合会删除重复项。如果任何项存在于多个集合中，它将只在结果集中添加一次。你可以用逗号分隔每个集合来执行多个集合之间的并集：

```py
      >>> set_1 = {1,2,3}
      >>> set_2 = {3,4,5}
      >>> set_1.union(set_2)
      {1,2,3,4,5}
      >>> set_3 = {4,5,6,7}
      >>> set_1.union(set_2,set_3)
      {1,2,3,4,5,6,7}
```

+   我们有`intersection()`方法，它将导致多个集合之间共同的项目集合，如下例所示：

```py
      >>> set_1 = {'a','b','c'}
      >>> set_2 = {'b','c','d'}
      >>> set_1.intersection(set_2)
      {'b','c'}
```

在前面的部分，我们已经介绍了 Python 的基础知识。到目前为止，我们已经建立了核心编程的坚实基础，但我们还不能构建一个高级游戏。

在接下来的部分，我们将深入探讨最重要的概念，不仅适用于 Python，而且适用于编程一般，那就是**函数**。在那一部分之后，你将拥有过程式编程的能力，这将在我们从那时起构建的每个高级游戏中非常有帮助。

# 函数

首先，让我们回顾一下到目前为止我们学到的所有主题，并观察过程式编程函数以及它们为什么首先是需要的。我们学会了如何使用变量、数字、模块、条件和循环创建多行语句。然而，我们并没有止步于此；我们涵盖了 Python 的所有基本数据结构，如列表、字典、元组和集合。这种编程范式将导致代码行数的丰富，有时我们可能需要一遍又一遍地调用相同的代码。看看下面的例子：

```py
>>> 3 + 5
8
>>> 6 + 7
13
```

在前面的代码中，我们正在添加两个数字。每次进行加法运算时，我们需要写两个数字，然后是加法运算符。与其为许多加法操作做同样的任务，为什么不制作一个可以执行加法的单个语句，并将该语句放入我们可以多次调用它的范围内呢？这个范围代表函数。我们可以通过调用这些函数多次来调用这个语句的执行。让我们制作一个可以添加任意两个数字的函数：

```py
>>> def add(a,b):
        print(a + b)
```

在前面的代码中，我们用`add`定义了函数。`def`关键字和一个名称一起用于指定 Python 解析器以创建函数。在函数的范围内，我们可以添加多个语句。现在，我们不需要每次手动添加两个数字，我们可以调用这个`add`函数来执行任意两个数字之间的加法。因此，这部分代码可用于可以添加任意两个数字的操作。第一个任务是声明函数，这就是我们刚刚做的；下一个任务是调用该函数。在调用该函数之前，不会执行该函数内的任何操作。您必须使用相同的函数名称来调用该函数。现在，如果您想执行`add`操作，您需要以相同的签名`add`调用它，并将两个值作为参数传递给它。如果您传递一个数字，它将作为参数传递给该函数调用：

```py
>>> add(4,5)
9
>>> add(10,11)
21
```

在前面的结果中，括号内的每个数字都被传递给函数参数：a 和 b。在第一个操作中，`add(4,5)`，4 被作为值传递给变量 a，5 被作为值传递给变量 b。

让我们将这些函数与以下咖啡机进行比较。我们将原材料，如咖啡豆、糖和水，投放到咖啡机中，咖啡机将加工这些原材料，并为我们提供一杯咖啡。与咖啡机一样，函数也接受包含值的原始参数作为输入。这些参数将用于处理，在函数内部完成，并给我们有意义的结果。有时，函数不返回任何东西；我们称这些为`void`：

![](img/e7096471-8dcd-4b00-bf32-b201532c734e.png)

我们看了几个例子，我们通过名称调用了函数，但它们的声明是由 Python 在内部进行的。例如，以`print()`方法为例。我们使用这个函数在终端上向用户打印任何消息，但我们没有使用`def`关键字来定义它；我们只是调用它，因为它是一个内置函数。因此，如果您使用任何函数，如`print()`、`input()`或`type()`，您都是通过在其括号内传递参数来调用该函数。您可以通过参观官方 Python 文档来查看`print()`或 Python 的任何其他内置方法的实现。在调用`input()`或`print()`时，我们将一个字符串作为参数传递给它的括号内。让我们看一个函数调用的例子：

```py
>>> type('a')
<class 'str'>
```

在前面的代码中，我们使用了`type`调用函数。参数传递在函数的括号内。我们可以传递尽可能多的参数作为括号内的表达式，但是我们必须确保只传递所需的位置参数。在函数声明中，如果我们使用了两个参数来定义函数，那么在调用时，我们应该传递相同数量的参数。否则，它会抛出一个错误，就像下面的例子所示：

```py
>>> def add(a,b):
        print(a+b)
>>> add(3)
TypeError: add() missing 1 required positional argument: 'b'

>>> add(3,4,5)
TypeError: add() takes 2 positional arguments but 3 were given
```

因此，我们可以得出结论，函数接受一个参数，根据该参数执行一些语句，并返回一个结果。在我们的`add(a,b)`函数中，我们在函数内部打印了结果，但是我们使用了`return`关键字来从函数中返回一个`result`，而不是在函数的范围内打印它：

```py
>>> def add(a,b):
        c = a + b
        return c

>>> result = add(3,5)
>>> result
8
```

因此，我们有两种类型的函数。一种在函数的范围内打印结果，而不是从中返回结果，通常为空。虽然 Python 没有空函数的命名约定，其他编程语言称这些为空函数，这意味着它们不返回任何东西。另一种类型将产生函数的返回值。当调用函数时，应该捕获这些返回值，就像在代码中：`result = add(3,5)`。`result`的值是函数的返回值。

您可能会遇到一个函数必须返回多个值的情况。我们可以使用元组结构从函数中返回多个值。让我们看一个简单的例子：

```py
>>> def result(a,b):
        print("Before Swapping: ")
        print(a,b)
        print("After Swapping: ")
        return b,a
>>> result(4,5)
Before Swapping: 
4 5
After Swapping: 
(5, 4)
```

我们将在下一节学习*默认参数*的概念。学习这个概念将帮助我们构建更灵活的函数，因此这是一个重要的主题。

# 默认参数

在函数调用期间，我们通常将一个值作为位置参数传递给相应的参数。但是，如果我们犯了一个错误，传递的参数比所需的少一个或多一个，我们的程序将遇到异常。因此，总是将一些参数指定为默认值是一个很好的做法：

```py
>>> def msg(str1,str2):
        print("I love {} and hate {}".format(str1,str2))

>>> msg("Python")
TypeError: msg() missing 1 required positional argument: 'str2'
```

现在，让我们看一下默认参数的威力。在使用它们之前，您应该记住默认参数必须放在参数顺序的末尾。创建默认参数的语法是`argument_name = value`。在前面的例子中，如果您想将`str1`作为默认参数，它应该放在`str2`之后，否则您将从 Python 解释器那里得到一个语法错误，就像下面的例子所示：

```py
>>> def msg(str1 = "Python",str2):
        print("I love {} and hate {}".format(str1,str2))

SyntaxError: non-default argument follows default argument
```

正如错误消息所澄清的那样，我们不能将默认参数指定为左侧的位置参数。它们应该跟随非默认参数，就像下面的例子所示：

```py
>>> def msg(str1,str2 = "Java"):
        print("I love {} and hate {}".format(str1,str2))

>>> msg("Python")
I love Python and hate Java
```

在前面的例子中，看一下我们在其中只使用一个参数调用函数的部分。现在，该参数是一个位置参数。因为它在位置一，所以它将被传递给函数的第一个参数。因此，`Python`值将被传递给`str1`参数。在`Python`值之后，我们什么也没传递。而不是遇到`TypeError`，我们能够得到一个正确的结果。这就是默认参数的威力。但是，如果在函数调用时向该默认参数传递另一个值，那么默认参数值将被覆盖为新值：

```py
>>> msg("Python","C")
I love Python and hate C
```

到目前为止，我们能够使用一些位置参数来调用函数，比如 a 和 b。但是如果我们必须创建一个能够添加 200 个数字的函数呢？调用这样的函数`add(a,b,c,d,..)`，其中每个变量代表一个数字，是不可能的。我们也会缺少变量，因为对于 200 个数字，我们必须维护 200 个变量。因此，最有效的方法是将所有这些参数打包到一个变量中，并将其作为单个参数传递给函数。然后，函数将解包该变量并执行相关操作。我们可以使用列表数据结构作为变量来存储这些多个值。我们将在下一节中看一下如何打包和解包普通和关键字参数。

# 打包和解包参数

让我们举一个简单的例子，这将帮助我们理解为什么我们首先需要这种打包和解包方法。在这个例子中，我们将添加数字：

```py
>>> def add(a,b):
        result = a + b
        return result

>>> print(add(4,5))
9
```

我们的代码对于较少的数字可以正常工作，也许最多可以达到 10 个值。随着数字的小幅增加，需要做一些小的修改，但这没关系。但是，如果我们有 100 个数字呢？跟踪这些数字到变量中是不可能的，也不是有效的。我们的代码看起来也不专业。现在，Python 有一个名为打包参数的疯狂功能。在这里，我们谈论的是参数，即普通参数，比如列表和元组。我们可以制作一个包含多个数字的列表。让我们看看如何制作一个可以添加多个数字的函数，使用打包参数的情况：

```py
>>> def add(*args):
        result = 0
        for item in arg:
                   result = result + item
        print(result)

>>> add(1,2,3,4,9,4,2,5,5,8)
43
```

让我们观察我们在这里编写的代码。`*arg`约定用于打包参数。在这里，`args`指的是参数，这是 Python 中参数的默认命名约定，但只要遵循变量命名模式的规则和约定，你可以给它取任何名字。一个单独的星号(`*`)是必不可少的，它表示我们正在打包成一个单一的参数。我们正在将每个项目打包到`args`中；因此，`args`将被构建为一个列表。我们知道列表是可迭代的，这允许我们使用 for 循环在其中循环。现在，在调用函数时，我们不必担心任何位置参数，甚至包含值的参数。在函数调用期间传递的每个数据片段都将使用这种方法打包到列表中。现在，我们不再受限于使用分配值给指定位置参数的参数。我们可以对每种数据类型，甚至结构执行这些打包参数技术。

解包参数的工作方式与打包类似。我们使用单个星号紧挨着参数，指定我们正在使用解包技术。在这里，参数必须是一个列表、字符串或另一个表示项目集合的结构。看一下以下示例：

```py
>>> print(*"Python")
P y t h o n
```

由于参数作为字符串(`Python`)传递，我们解包它，以便每个元素都单独打印出来，中间带有一些空格。你也可以按照以下方式解包列表结构的元素：

```py
>>> numbers = [1,2,3,4]
>>> print(*numbers)
1 2 3 4
```

因此，我们可以使用单个星号打包和解包普通参数，但是为了打包和解包关键字参数，我们必须使用双星号。用于打包和解包关键字参数的语法是`**kwargs`。只需记住对于普通参数使用单个星号，对于关键字参数使用双星号。`args`代表参数，`kwargs`是关键字参数的命名约定。我们将在下一节中看一些打包和解包关键字参数的示例。

# 打包和解包关键字参数

关键字参数指的是字典。字典不能像列表或元组那样打包和解包。字典包含键和值对；因此，它们不能以正常的方式打包和解包。为了将它们与正常参数区分开，我们使用双星号。`**kwargs`用于将字典的所有元素打包成单个参数。然而，我们知道字典不可迭代，换句话说，我们不能在字典内部循环并直接获取键和值对。为了检索键和值对，我们需要使用`items()`方法将`kwargs`转换为元组。我们已经在前面的部分看到了它的实现。让我们看一个简单的例子，说明如何实现打包关键字参数：

```py
#code is written as script
pack_keyword_args.py

def about(name,age,like):
    info = "I am {}. I am {} years old and I like {}. ".format(name,age,like)
    return info

dictionary = {"name": "Ross", "age": 55, "like": "Python"}
print(about(**dictionary))

>>>
I am Ross. I am 55 years old and I like Python
```

在上面的例子中，我们做了两件事：我们制作了一个字典，将使用`**dictionary`打包成单个参数，并将每个值传递给函数的位置参数。在字典定义中，字典的键必须与制作函数时使用的参数相同，即`name`、`age`和`like`。即使是单个拼写错误也会导致`TypeError`。

现在，是时候来介绍解包关键字参数了。语法将是相似的，包含双星号，后面跟着字典名称，或`kwargs`。由于我们正在解包，所以必须将`**kwargs`作为函数的参数添加进去，因为解包必须在函数内部完成。让我们看一个简单的例子来澄清这一点：

```py
#unpacking_key_args.py
def about(**kwargs):
    for key, value in kwargs.items():
          print("{} is {}".format(key,value))

about(Python = "Easy", Java = "Hard")

>>> #output
Python is Easy
Java is Hard
```

在调用`about`函数时，我们向参数传递了一个值，就像我们在普通函数的情况下通常传递的那样。例如，`Python`是参数，它的值是字符串。现在，这个值被传递给`about`函数的参数。然而，在函数括号内没有名为`Python`或`Java`的参数。相反，有`**kwargs`，它将这些`argument_name = value`格式转换为字典。这是一种打包参数的形式。现在，在函数内部，我们必须解包它。此时，我们知道`kwargs`是一个不可迭代的字典。我们不能在不将其转换为元组或列表的情况下获取其`key:value`对。将字典转换为元组的一种简单方法是使用`items()`方法。现在，在使用`items()`方法将字典转换为元组对象后，`kwargs`看起来是这样的：

```py
>>> kwargs.items()
dict_items([('Python', 'Easy'), ('Java', 'Hard')])
```

现在，我们正在循环遍历元组对象的这些项，每个对象都包含由逗号分隔的键和值。因此，对于每次迭代，我们都会得到键和值对，并通过适当格式化打印出来。

现在，我们掌握了不仅可以帮助我们创建自己的函数，还可以根据我们的需求修改它们的知识。如果你想使你的程序更具重用性和稳健性，必须使用打包和解包参数等方法。在这个广泛的函数式编程概念之后，现在是时候探索 Python 中的三个重要函数：匿名函数、递归函数和内置函数。让我们逐个来看看它们。我们将从*匿名函数*开始。

# 匿名函数

顾名思义，这些函数没有任何名称或签名。就像我们使用`add(a,b)`函数的名称来执行两个数字之间的加法操作一样，在匿名函数的情况下，这个`add`签名是无效的。如果您回忆一下我们使用`def`关键字创建普通函数的方式，在匿名函数的情况下，我们使用`lambda`关键字。因此，匿名函数也被称为 lambda 函数。在创建任何函数时，我们需要记住两件事：参数和表达式。参数是函数的独立和特定的输入，而表达式嵌入在函数体内。在`lambda`函数的情况下，我们可以传递任意数量的参数，但只能有一个表达式。这意味着`lambda`函数只能执行一个操作。

让我们创建一个简单的`lambda`函数，以便更容易地理解这些信息：

```py
>>> square = lambda x: x**2
>>> square(8)
64
```

在这个例子中，`square`是结果的容器。由于`lambda`函数没有独特的签名或名称，我们应该使用这个容器作为值传递参数，也就是`square`。在这里，使用`lambda`函数的语法如下：

```py
lambda arguments: expression
```

注意`arguments`和`expression`的名称；我们不能在`lambda`函数内添加多个语句。如果我们尝试在`lambda`函数内执行多个语句，就会遇到以下错误：

```py
>>> result = lambda x, y: x//y, x%y
Traceback (most recent call last):
  File "<pyshell#0>", line 1, in <module>
    result = lambda x, y: x//y, x%y
NameError: name 'x' is not defined
```

我们传递了`x,y`，也就是多个参数，这是完全有效的，但两个表达式`x//y`和`x%y`不会被`lambda`执行。我们将在接下来的章节中使用这些`lambda`函数来创建游戏。由于本章有许多内容要涵盖，而且空间不够了，我想在这里结束这个话题；但是，我强烈建议您多练习这些类型的函数。您可以随时使用 Python 文档进行帮助。

让我们来看另一种类型的函数：**递归**——一种涉及使用过程、子程序、函数或算法调用自身的计算机编程技术，在一步中具有终止条件，当满足终止条件时，程序也终止。

# 递归函数

在本节中，我们将揭示另一种编程范式，称为递归编程。递归是一种编程方式，其中一个函数会多次调用自身，直到满足特定条件为止。在函数体内，我们将调用相同的函数本身，这使它成为递归。这与嵌套条件类似，其中在单个`if`条件中有另一个`if..else`的范围。

递归应该有一个基本或终止条件，以指定程序的停止标准。没有基本条件，我们的递归程序将无法正常运行。如果在程序执行时未满足基本条件，递归程序将导致无限循环。让我们来看一个简单的编程示例，观察递归的工作原理：

```py
>>> def factorial(number):
        if number == 1:
            return 1
        else:
            return number*factorial(number-1)

>>> factorial(4)
24
```

让我们来探索前面的例子，以揭示关于递归编程的有趣事实。打印任何数字的阶乘是一个简单的例子，我们可以在学习递归编程时参考。在前面的程序中，我们有一个基本或终止条件：当数字为一时，我们返回一。这不是一个随机的陈述；相反，这是找到阶乘数的数学模式。看看下面的例子：

```py
To find factorial of 5= 5! = 5*4*3*2*1! = 5*4*3*2*1 = 120
```

对于任何数字，找到阶乘的过程在遇到 1 之后结束。因此，这是一个基本条件，每当我们的程序触发它时，我们可以终止程序。在程序的`else`部分的范围内，我们再次调用阶乘函数，但使用不同的参数。您可以观察到我们找到 5 的阶乘的例子；每次我们进入下一步时，我们都会将该数字减一，并将其与当前数字相乘，这代表了这个语句：

`>>> number*factorial(number-1)`。这个条件被称为递归情况，导致了递归。

因此，有两种使用 Python 进行逻辑推理的方法：使用循环和条件语句进行基本逻辑，或者使用递归。有时，使用全新的逻辑来解决问题会很困难，在这种情况下，我们会尝试使用递归。尽管递归代码看起来更简单、更清晰，但与其他代码相比，它是一个昂贵的调用，因为在计算过程中需要大量的时间和空间。现在，让我们谈谈使用内置函数来执行操作的更快、更便宜的方法。我们已经介绍了许多内置函数，比如`max()`、`min()`和`len()`。因此，这一部分将更容易理解。

# 内置函数

Python 带有多个内置函数，可以直接在我们的程序中使用。我们不需要导入它们，也不需要额外的努力来执行它们。例如，我们有`print()`。我们之前可能不知不觉地使用了许多内置函数，但它们也是一种函数。唯一的区别是它们是由 Python 创建者制作的。它们快速，更重要的是，使用它们可以使我们的代码更简单、更清晰。只需这样想：使用我们自己的自定义方法来添加两个数字可能需要至少三行代码，但使用内置函数，我们可以在一行代码中使用`sum()`函数来完成。

您可以通过浏览 Python 官方文档来查看每一个内置函数。其次，我们还可以在 Python shell 中获取包含内置函数列表的信息。您可以输入以下命令`>>> dir(__builtins__)`来获取包含 68 个内置函数的列表。我们已经看到了其中一些最重要的函数，例如`type()`方法和类型转换技术。它们都是使用内置函数实现的。

我不会在本节中涵盖每一个内置函数，因为这不是本书的实际目的；相反，我们将直接进入下一个主题，这将是一个有趣的主题，因为我们将使用到目前为止学到的函数和数据结构来修改我们的井字棋游戏。然而，我强烈鼓励您通过自己学习一些内置函数来谨慎前进。它们现在可能还不重要，但在您的职业生涯中某个时候肯定会派上用场。

现在我们已经学习了数据结构和函数，我们将使用它们来修改之前构建的井字棋游戏，为其增加智能。我们将在下一节中介绍这个内容。

# 为我们的游戏增加智能

在本章中，我们进行了多次修改，例如添加条件语句和循环以增强代码结构和处理。然而，这还不够完美。在本节中，我们将使用本章学到的函数和数据结构来修改我们的井字棋游戏。

由于函数将通过消除代码的重复而使我们的代码长度变短，并且调试它，以后在代码中进行更改也会更容易；你可以简单地重定向到特定的函数，而不是遍历整个程序。因此，这两个特性在将游戏板打印到终端时对我们有帮助。如果你回忆一下我们在上一章中编写的代码，用于打印游戏板布局的代码被重复使用。现在，我们可以创建一个函数，将所有我们需要的代码放在里面，这样我们就可以打印出游戏板的布局，并且可以在代码中的任何时间和任何地方调用它。

我们代码的下一个实现将是为我们的井字游戏添加智能。到目前为止，如果你运行你的井字游戏，你会发现它可以由两个玩家玩。然而，两个玩家都应该使用同一台计算机，并且他们应该通过轮流来玩。现在，我们将添加计算机智能，可以作为一个玩家来玩我们的游戏。我们实际上正在制作一个玩家可以与计算机对战的游戏。

像往常一样，我们将从头脑风暴游戏的基本要素开始，收集关于游戏布局和模型的关键信息。

# 头脑风暴和信息收集

术语“人工智能”在技术世界中非常臭名昭著，但如果你深入研究，它其实是一堆模块和条件，决定了代理的流程。在这里，代理可以是任何做决定的东西，比如机器、人类和机器人。所有这些代理执行的动作都可以产生最理想的结果。在我们的井字游戏中，代理是一个计算机玩家，它应该采取行动，可以在比赛中击败我们的玩家。我们有一个专门的章节来学习人工智能及其理性代理，这将在我们完成基本游戏编程的学习后进行介绍。然而，在本节中，我们将创建一个简单的人工智能，可以决定最有利的移动，以击败人类玩家，或者大部分时间结束游戏为平局。

我们将采用过程式编程的方法来为系统添加智能。不要被过程式编程这个术语所压倒，它只是一种使用函数来实现目标的方法。你必须记住的一件事是，每个函数都应该只执行一个任务。例如，我们可以制作`print_board()`函数，每次调用它时，它只会打印游戏的布局。这个`print_board()`函数不会从用户那里获取输入，也不会让任何玩家成为赢家。因此，函数的存在应该通过执行一个模块化的任务来保留。我们还可以制作`is_winner()`函数，它将检查是否有任何玩家是赢家。

下图显示了我们的游戏如何制作一个简单的算法。在这里，我们可以看到如何检查井字游戏板上的位置，以便计算机的下一步能够产生最佳结果；接近赢得比赛，或者在最坏的情况下，使比赛成为平局，而不是计算机输掉比赛：

![](img/cb90d27c-adf9-415e-a234-7607649af642.png)

以下图表显示了我们需要完成的程序，以实现算法的第二部分，我们将跟踪人类玩家的每个占据位置，并检查他们是否可以在下一步赢得比赛。如果他们能赢，我们将阻止这些位置。我们还将占据中心和侧面位置，以便没有人类玩家可以轻松赢得比赛：

![](img/79f3c230-ef01-42dc-aac8-4fe51d2e45d6.png)

现在，我们已经形成了基本算法，这样我们就可以开始编写代码，实现我们游戏中的基本智能。我们将在下一节“智能模型的实现”中使用这些知识，以解决智能模型的问题。

# 智能模型的实现

首先，让我们使用函数来完善我们的代码；让我们创建一个名为`printBoard()`的函数。这个函数将包含一些代码行，用来打印我们井字游戏的棋盘布局：

```py
#tic_tac_toe_AI.py

def printBoard(board):
    print('   |   |')
    print(' ' + board[7] + ' | ' + board[8] + ' | ' + board[9])
    print('   |   |')
    print('---------------')
    print('   |   |')
    print(' ' + board[4] + ' | ' + board[5] + ' | ' + board[6])
    print('   |   |')
    print('---------------')
    print('   |   |')
    print(' ' + board[1] + ' | ' + board[2] + ' | ' + board[3])
    print('   |   |')
```

前面的代码将打印出棋盘的布局；如果你想执行函数内部的语句，你必须调用它。在这里，我们必须使用`board`参数来调用它，这个参数是包含了棋盘所有位置的列表，也就是十个空位置，`[' '] *10`。让我们调用这个函数并观察结果：

```py
>>> board = [' ']*10
>>> #calling the function:
>>> printBoard(board)

      |    |
      |    |
      |    |
-----------------
      |    |
      |    |
      |    | 
-----------------
      |    |
      |    |
      |    |
```

现在，是时候制作一个函数，来检查任何玩家是否是赢家了。我们在这里并没有制作全新的逻辑；相反，我们将在函数的范围内放置我们在前面章节中制作的所有语句。现在，每当任何用户在棋盘上做出动作时，我们可以调用这个函数来检查那个特定玩家是否是赢家。因此，函数可以消除代码的重复或重复。让我们使用`isWinner()`方法来检查是否有任何用户满足成为赢家的条件：

```py
#tic_tac_toe_AI.py
#after printBoard(board) function

def isWinner(board, current_player):
    return ((board[7] == current_player and board[8] == current_player and board[9] == current_player) or
    (board[4] == current_player and board[5] == current_player and board[6] == current_player) or
    (board[1] == current_player and board[2] == current_player and board[3] == current_player) or 
    (board[7] == current_player and board[4] == current_player and board[1] == current_player) or
    (board[8] == current_player and board[5] == current_player and board[2] == current_player) or
    (board[9] == current_player and board[6] == current_player and board[3] == current_player) or
    (board[7] == current_player and board[5] == current_player and board[3] == current_player) or
    (board[9] == current_player and board[5] == current_player and board[1] == current_player))
```

在前面的代码中，`isWinner`函数的参数是`board`，其中包含了棋盘布局的位置和玩家的棋子，可以是`X`或者`O`。我们正在重用在上一章中编写的相同代码，只是做了一些小修改。这个方法将返回一个`True`或者`False`的布尔类型，并且我们将在玩家在游戏中做出新动作时调用它。我们使用这个方法来检查整行、整列和对角线的棋盘布局，如果有任何用户占据了它，就会返回`True`或者`False`。

在井字游戏中，我们以位置的形式移动玩家，并将玩家的字符分配给它，可以是`X`或者`O`。我们在前一章中已经看到了它的实现。在这里，我们将制作一个单独的函数，用来给位置分配一个值。在下面的代码中，`board`代表了包含位置的游戏布局；`current_player`要么是`X`，要么是`O`，而`move`是用户的输入：

```py
def makeMove(board, current_player, move):
    board[move] = current_player
```

现在，是时候让计算机玩我们的游戏了。让我们回顾一下我们在前一节中制作的算法。我们将进行多次检查：计算机是否能在下一步赢得比赛，以及人类玩家是否能在下一步赢得比赛。如果是这样，我们将阻止获胜的位置。我们不能在真正的棋盘布局游戏中执行这些操作，因为我们不希望我们的棋盘布局被填充。因此，我们将复制一份棋盘布局，以便我们可以在新的克隆棋盘布局中执行这些检查操作。让我们制作一个函数来复制原始的棋盘布局：

```py
def boardCopy(board):
     cloneBoard = []
     for pos in board:
         cloneBoard.append(pos)

     return cloneBoard
```

在我们克隆了原始棋盘之后，我们必须检查计算机是否有空位可以移动。让我们制作一个函数来检查棋盘布局中的可用空位：

```py
def isSpaceAvailable(board, move):
     return board[move] == ' '
```

`isSpaceAvailable`返回一个布尔类型：要么是`True`，要么是`False`。如果在传递的棋盘布局上可以移动，它将返回`True`。如果位置已经被任何玩家占据，它将返回`False`。

现在，是时候进入我们话题的主要部分了：让计算机玩我们的游戏。让我们创建一个名为`makeComputerMove()`的函数，并将`board`参数和`computerPlayer`字符传递给它。这里，`board`代表了包含所有位置的棋盘布局，而`computerPlayer`是一个字符，可以是`X`或者`O`：

```py
#tic_tac_toe_AI.py

 def makeComputerMove(board, computerPlayer):
     #part 1 
     for pos in range(1,10):
         #pos is for position of board layout
         clone = boardCopy(board)
         if isSpaceAvailable(clone, pos):
             makeMove(clone, computerPlayer, pos)
             if isWinner(clone, computerPlayer):
                return pos
```

在前面的代码`#part1`中，我们检查了计算机是否能在下一步获胜。首先，我们循环遍历了整个棋盘布局的位置，并使用`boardCopy`函数克隆了棋盘。然后，我们将 1 到 10 的每个位置传递给`isWinner`函数，检查空间是否可用。我们通过使用`isWinner`函数检查该移动是否会使计算机玩家成为赢家，并在这种情况下返回特定的移动位置。这部分代码使我们的计算机玩家足够智能，可以根据其有利的预测决定下一步移动。

在为我们的计算机玩家增加智能的过程中，下一步是跟踪人类玩家的移动。这样做可以在棋盘上做出聪明的移动，使玩家不会轻易获胜。此外，如果人类玩家在棋盘的一行上占据了两个位置，我们可以移动来阻止第三个位置。让我们编写`makeComputerMove()`函数的`#part2`。为了检查人类玩家是否会获胜，我们必须以虚拟的方式扮演人类玩家来玩游戏。我们可以在不影响原始棋盘的情况下做到这一点，因为我们可以在棋盘的副本中扮演人类。现在，为了检查人类玩家是否会获胜，我们必须获得一个玩家字母，即`X`或`O`。我们可以设置条件来检查人类玩家是`X`还是`O`。获得该字母后，我们可以在棋盘游戏的副本上以虚拟的方式扮演人类，但请记住我们是为计算机玩家编写代码。

```py
def makeComputerMove(board, computerPlayer):
     if computerPlayer == 'X':
         humanPlayer = 'O'
     else:
         humanPlayer = 'X'

     #add part1 code here
     #now check if human player will win on next move or not in part2:
     #part2
     for pos in range(1,10):
         clone = boardCopy(board)
         if isSpaceAvailable(clone, pos):
             makeMove(clone, humanPlayer, pos)
             if isWinner(clone, humanPlayer):
                return pos
```

我们刚刚编写的代码将为计算机玩家增加一个智能移动。我们让计算机以虚拟的方式扮演井字棋游戏的人类玩家。我们正在检查下一步人类玩家是否会获胜。如果他们会，我们将返回该移动，以便计算机将其字母放在该位置，阻止人类获胜。

在头脑风暴和信息收集过程中，我们制作了一个流程图，以跟踪将智能嵌入我们的计算机玩家的活动。我们执行了其中的两个活动：检查获胜的最佳移动，以及阻止人类玩家的下一个最佳移动。我们还可以通过进行初始移动使计算机玩家变得更加智能，这是人类玩家通常会做的。例如，当我们玩井字棋时，我们会从中心位置开始，因为我们认为这是最好的起始位置。那么，为什么不让计算机也这样做呢？让我们编写一些代码，让计算机检查棋盘上中心位置的可用性，并相应地保留该位置。

```py
def makeComputerMove(board, computerPlayer):
     #add part1
     #add part2
     #Occupy center position if it is available
     #part3
     if isSpaceAvailable(board, 5):
         return 5   
```

我们可以通过检查角落位置的可用性使这个计算机玩家变得更加智能。棋盘上的角落位置是`[1,3,7,9]`。由于我们的棋盘上有四个角落，我们维护了一个列表来跟踪它们。现在，让我们创建一个新的`getRandomMove()`函数，它将接受棋盘和移动作为参数。移动参数将以列表的形式提供，例如角落位置。

```py
#tic_tac_toe_AI.py
 import random
 def getRandomMove(board, moves):
     availableMoves = []
     for move in moves:
         if isSpaceAvailable(board, move):
             availableMoves.append(move)

     if availableMoves.__len__() != 0:
         return random.choice(availableMoves)
     else:
         return None       
```

在前面的代码中发生了很多事情，所以让我们把事情分解成更简单的部分。首先，这个方法将接受以列表形式提供的移动，即`[1,2,3,4,5]`；我们必须使用这个函数选择其中一个元素。然而，这个列表的元素不仅仅是数字；它们是棋盘布局的移动或位置。因此，我们必须检查每个移动的空间是否可用。如果有可用空间，我们将该移动添加到一个名为`availableMoves`的新列表中。筛选完成后，我们进行条件检查，以确定是否有任何可用移动。

`>>> availableMoves.__len__() != 0`表达式与`len(availableMoves)`相同，它将返回列表的长度。我们称这些实现(`__len__()`)为数据模型，我们将在即将到来的专门章节中进行介绍。如果`availableMoves`的长度为零，我们将返回`None`。但如果不为零，我们将执行一个表达式。让我们将这个表达式分解成片段：

+   `import random`: 如果你回忆一下第二章的主题，*学习 Python 基础*，我们导入了 math 模块来执行数学计算，比如平方根和阶乘，我们使用`import math`命令导入 math 模块。现在，我们正在导入一个 random 模块，这意味着我们可以使用该模块中定义的方法。从 random 模块调用方法的语法是`random.method_name()`。

+   `random.choice()`: choice 方法将从被调用的元素列表中随机选择一个元素。例如，执行以下命令将从传递给它的值范围中随机选择一个值：

```py
      >>> import random
      >>> random.choice([1, 2, 4, 5, 6])
      5
      >>> random.choice([1, 2, 4, 5, 6])
      2
```

1.  我们将`availableMoves`传递给它，以便`choice`方法可以随机选择任意一个移动。这对我们的游戏至关重要，因为有时计算机必须随机做出决定。

现在，让我们在`makeComputerMove`函数中调用`getRandomMove`函数。如果你浏览一下`makeComputerMove`函数的代码，我们已经添加了一个语句，将帮助计算机占据中心位置。角落位置呢？它们也是井字棋游戏的重要位置。如果我们占据了棋盘的中心和角落位置，我们的计算机将有很高的获胜几率。因此，我们必须增强我们的代码，使计算机玩家占据角落位置。由于角落位置是`[1, 3, 7, 9]`，我们必须将其作为列表参数传递给我们刚刚创建的`getRandomMove`函数：

```py
#tic_tac_toe_AI.py
 def makeComputerMove(board, computerPlayer):
     #add part1
     #add part2
     #add part3
     #code to occupy corner positions
     move = getRandomMove(board, [1, 3, 7, 9])
     if move is not None:
         return move

     #moves for remaining places ==> [2, 4, 6, 8]
     return getRandomMove(board, [2, 4, 6, 8])
```

在前面的代码中，我们添加了代码，将在任何角落位置上获取随机移动。我们已经涵盖了中心位置`[5]`和角落位置`[1,3,7,9]`的玩家移动；现在，我们还剩下边缘位置`[2,4,6,8]`。我们调用了`getRandomMove`函数，它将从传递的列表中选择任意一个随机移动。

在前面的章节中，我们学到了许多东西，比如循环、条件语句等等。在下一节中，我们将编写一些代码来使用它们来控制程序流程。我们将称之为**主函数**。

# 使用主函数控制程序流程

我们编写了许多函数，比如`makeComputerMove`、`isWinner`等等，但它们还没有被调用。我们知道在调用函数之前，函数不会执行其中的代码。因此，我们将创建一个新的函数，来处理程序的流程。通常我们称之为主函数，但你可以随意命名。我们在之前的章节中编写的代码，比如主游戏循环或切换玩家回合，将嵌入到这个主函数中。唯一需要显式调用的函数就是这个主函数。让我们现在创建一个：

```py
#tic_tac_toe_AI.py
 def main():
     while True:
         board = [' '] * 10
         player, computer = 'X', 'O'
         turn = "human"
         print("The " + turn + " will start the game")
         isGameRunning = True

         while isGameRunning:
             if turn == "human":
                 printBoard(board)
                 move = ' '
                 while move not in '1 2 3 4 5 6 7 8 9'.split() or not 
                  isSpaceAvailable(board, int(move)):
                     print('What is your next move? (choose between 1-9)')
                     move = int(input())
                  makeMove(board, player, move)
                  if isWinner(board, player):
                      printBoard(board)
                      print("You won the game!")
                      isGameRunning = False
             else:
                 #computer turn       
```

我们以前多次编写了前面的代码，比如在打印棋盘、切换玩家和创建获胜者时。不同之处在于，这里我们使用了函数。我们有一个与一个函数相关的任务，比如`isWinner`，它检查玩家是否获胜，而不是编写整个代码来检查获胜者，我们只需编写一次并在主函数中使用它。您可以看到我们已经编写了一些代码来从用户那里获取输入作为棋盘游戏的移动值。我们可以制作一个函数来从用户那里获取输入。现在让我们来做，使主函数更清晰、更易读：

```py
def makePlayerMove(board):
     move = ' '
     while move not in '1 2 3 4 5 6 7 8 9'.split() or not 
      isSpaceAvailable(board, int(move)):
         print('What is your next move? (choose between 1-9)')
         move = int(input().strip())
         return move
```

现在，让我们将这个新创建的函数添加到主函数中。我们还将完成代码的`else`部分，让计算机玩我们的游戏：

```py
def main():
     while True:
         board = [' '] * 10
         player, computer = 'X', 'O'
         turn = 'human'
         print("The " + turn + " will start the game")
         isGameRunning = True

         while isGameRunning:
             if turn == 'human':
                 printBoard(board)
                 move = makePlayerMove(board)
                 makeMove(board, player, move)
                 if isWinner(board, player):
                     printBoard(board)
                     print("You won the game!")
                     isGameRunning = False
                 else:
                     printBoard(board)
                     turn = 'computer'
             else:
                 move = makeComputerMove(board, computer)
                 makeMove(board, computer, move)
                 if isWinner(board, computer):
                     printBoard(board)
                     print('You loose!')
                     isGameRunning = False
                 else:
                     turn = 'human'

 main() #calling main function
```

现在，让我们运行游戏，并与我们定制的 AI 代理对战。以下插图显示了我们游戏的输出，并显示了新的井字棋棋盘布局。这是通过对`printBoard`进行函数调用实现的：

![](img/ad344339-a730-428a-a43a-c7779866475a.png)

以下插图描述了人类玩家与计算机 AI 对战的游戏过程。您可以看到人类被计算机玩家击败了：

![](img/e6f59fb7-52ca-4a01-ab9b-bdc8a287e482.png)

现在，我们已经制作了一个足够吸引任何玩家玩游戏的布局。但是，还有一些修改可以进行，这将在下一节中介绍。

# 游戏测试和可能的修改

我们在本章中制作的游戏已经足够可以与计算机对战。在游戏中使用 AI 主要是解决游戏在与环境交互时可能面临的所有可能情况。在我们的井字棋游戏中，与国际象棋或围棋相比，我们的走法并不多，因此制作 AI 代理更容易。通过制作一个能够做出两个聪明的举动的 AI，我们能够与人类竞争，比如检查下一个最佳走法以获胜或通过模拟阻止人类获胜。如果您想知道模拟是什么，您将不得不回想一下我们刚刚实现的算法，以检查人类玩家是否会在下一步获胜。此外，计算机玩家在克隆棋盘上扮演人类玩家，并像人类一样进行虚拟游戏。这就是模拟，我们让计算机模仿系统的真实过程或行为。

通过模拟预测最佳走法后，我们的程序会为计算机玩家返回最佳的下一个可能走法。让我们进一步推广这种技术。我们在游戏中所做的是制作一个能够制作模拟环境以预测下一个最佳走法的 AI。相同的技术应用于整个范围的 AI 应用，例如自动驾驶汽车；我们在计算机内部制作了一个模拟环境，汽车是一个代理，将根据障碍物做出左转或右转的决定。井字棋在与环境交互时比较简单，因为它的走法或情况较少，但是编写自动驾驶汽车模拟需要我们认识到在道路上驾驶汽车时可能出现的一整套情况。因此，我们可以得出结论，AI 主要是关于创建一个程序，其中代理必须考虑与环境交互时可能面临的所有情况，并对每种情况做出响应。

我们的竞争对手足够聪明，使游戏对玩家来说更加困难，但人类也拥有让电脑玩家受限的终极力量。人类玩家不会让电脑轻易获胜。因此，大部分时间我们的游戏会以平局结束。然而，如果你运行游戏，你会发现我们还没有处理这些情况。现在，每当我们的游戏是平局时，而不是停止游戏，我们的游戏将不断要求用户输入。相反，我们必须给用户一个消息，告诉他们再试一次，并帮助用户再次玩我们的游戏。为了检查平局条件，我们必须检查棋盘是否已满。当棋盘位置全部被占满且没有人获胜时，我们就有了平局条件。我们可以制作另一个函数来检查棋盘是否已满：

```py
def isBoardOccupied(board):
    for pos in range(1,10):
        if isSpaceAvailable(board,pos):
            return False
    return True
```

上面的`isBoardOccupied()`函数将根据检查返回一个布尔类型，要么是`True`，要么是`False`，这将确定棋盘是否已满。如果棋盘已满，它将返回`True`，如果没有，它将返回`False`。我们正在使用我们在前一节中创建的`isSpaceAvailable()`函数，它将检查棋盘上是否有空位。现在，让我们用这个新函数来完善我们的代码：

```py
def main():
     while True:
         # add the code here from part1
         while isGameRunning:
             if turn == 'human':
                 move = makePlayerMove(board)
                 makeMove(board, player, move)
                 if isWinner(board, player):
                     printBoard(board)
                     print("You won the game!")
                     isGameRunning = False
                 else:
                     if isBoardOccupied(board):
                        print("Game is a tie")
                        break
                     else:
                        turn = 'computer'

             else:
                 move = makeComputerMove(board, computer)
                 makeMove(board, computer, move)
                 if isWinner(board, computer):
                     printBoard(board)
                     print('You loose!')
                     isGameRunning = False
                 else:
                     if isBoardOccupied(board):
                        print("Game is tie")
                        break
                     else:
                        turn = 'human'

 main() #calling main function
```

# 总结

本章内容简洁而扼要，包含了丰富的信息，从数据结构到函数。这些主题是任何复杂程序的基石，因此，我们将在接下来的每个游戏中使用它们。我们从学习数据结构的必要性开始，深入探讨了 Python 的基本数据结构，如列表、字典、元组和集合。我们讲解了如何创建这些数据结构并对其进行操作。

我们学习了创建用户定义函数、调用它们和记录它们的方法。我们还看到函数就像机器，你可以输入原始数据，然后得到有意义的输出。我们看到了使用位置参数和默认参数输入数据到函数的方法。然后，我们看到了通过打包和解包普通和关键字参数来修改我们的函数，以便从中获得最佳性能。

我们还使用函数和数据结构进一步修改了我们的游戏，并制定了可以应对不同游戏情况的简单算法。我们让我们的电脑玩家足够聪明，可以击败我们的人类玩家。然后，我们还制作了一个模拟环境，其中一个代理可以测试和训练自己，以预测下一个最佳移动。虽然我们的游戏制作起来很简单，但它给了我们许多关于需要进行的流程的想法，例如头脑风暴、设计、编码基础和分析，然后我们才真正开始编写模块化代码。

最后，我们讲解了过程式编程，指的是使用函数来构建程序。在下一章中，我们将讲解基于 curses 的过程式编程。我们将使用与终端无关的屏幕绘图和基于文本的终端来创建程序。我们将使用 curses 事件和屏幕绘图来制作一个贪吃蛇游戏，然后利用 curses 属性来制定玩贪吃蛇游戏的逻辑。

你是否对进入下一章感到兴奋？它将带你进行一次冒险之旅，学习使用 curses 模块进行游戏编程，以及如何处理用户事件和游戏控制台。在那之前，我强烈建议你参考官方 Python 文档，并浏览 Python 内置的数据结构和模块；并且在没有额外帮助的情况下进行练习。到目前为止我们所学到的知识将在本书的各章中使用，所以现在是时候复习我们迄今为止学到的主题了。
