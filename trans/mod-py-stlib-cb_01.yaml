- en: Containers and Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器和数据结构
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Counting frequencies—count occurrences of any hashable value
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数频率-计算任何可散列值的出现次数
- en: Dictionary with fallback—have a fallback value for any missing key
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有回退的字典-为任何丢失的键设置回退值
- en: Unpacking multiple—keyword arguments—how to use `**` more than once
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解包多个-关键字参数-如何多次使用`**`
- en: Ordered dictionaries—maintaining order of keys in a dictionary
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有序字典-保持字典中键的顺序
- en: MultiDict—dictionary with multiple values per key
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MultiDict-每个键具有多个值的字典
- en: Prioritizing entries—efficiently get the top of sorted entries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先处理条目-高效获取排序条目的顶部
- en: Bunch—dictionaries that behave like objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bunch-表现得像对象的字典
- en: Enumerations—handle a known set of states
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举-处理已知状态集
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Python has a very easy and flexible set of built-in containers. As a Python
    developer, there is little you can't achieve with a `dict` or a `list`. The convenience
    of Python dictionaries and lists is such that developers often forget that those
    have limits. Like any data structure, they are optimized and designed for specific
    use cases and might be inefficient in some conditions, or even unable to handle
    them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python具有一组非常简单和灵活的内置容器。作为Python开发人员，您几乎可以用`dict`或`list`实现任何功能。Python字典和列表的便利性是如此之大，以至于开发人员经常忘记它们的限制。与任何数据结构一样，它们都经过了优化，并且设计用于特定用例，可能在某些情况下效率低下，甚至无法处理它们。
- en: Ever tried to put a key in a dictionary twice? Well you can't, because Python
    dictionaries are designed as hash tables with unique keys, but the *MultiDict*
    recipe will show you how to do that. Ever tried to grab the lowest/highest values
    out of a list without traversing it whole? The list itself can't, but in the *Prioritized entries* recipe,
    we will see how to achieve that.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经试图在字典中两次放入一个键吗？好吧，你不能，因为Python字典被设计为具有唯一键的哈希表，但*MultiDict*食谱将向您展示如何做到这一点。曾经试图在不遍历整个列表的情况下从列表中获取最低/最高值吗？列表本身不能，但在*优先处理条目*食谱中，我们将看到如何实现这一点。
- en: The limits of standard Python containers are well known to Python experts. For
    that reason, the standard library has grown over the years to overcome those limits,
    and frequently there are patterns so common that their name is widely recognized,
    even though they are not formally defined.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 标准Python容器的限制对Python专家来说是众所周知的。因此，多年来，标准库已经发展出了克服这些限制的方法，经常有一些模式是如此常见，以至于它们的名称被广泛认可，即使它们没有正式定义。
- en: Counting frequencies
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计数频率
- en: A very common need in many kinds of programs is to count the occurrences of
    a value or of an event, which means counting frequency. Be it the need to count
    words in text, count likes on a blog post, or track scores for players of a video
    game, in the end counting frequency means counting how many we have of a specific
    value.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多类型的程序中，一个非常常见的需求是计算值或事件的出现次数，这意味着计数频率。无论是需要计算文本中的单词，博客文章上的点赞次数，还是跟踪视频游戏玩家的得分，最终计数频率意味着计算特定值的数量。
- en: The most obvious solution for such a need would be to keep around counters for
    the things we need to count. If there are two, three, or four, maybe we can just
    track them in some dedicated variables, but if there are hundreds, it's certainly
    not feasible to keep around such a large amount of variables and we will quickly
    end up with a solution based on a container to collect all those counters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种需求，最明显的解决方案是保留我们需要计数的计数器。如果有两个、三个或四个，也许我们可以在一些专用变量中跟踪它们，但如果有数百个，保留这么多变量显然是不可行的，我们很快就会得到一个基于容器的解决方案来收集所有这些计数器。
- en: How to do it...
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Here are the steps for this recipe:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此食谱的步骤：
- en: Suppose we want to track the frequency of words in text; the standard library
    comes to our rescue and provides us with a very good way to track counts and frequencies,
    which is through the dedicated `collections.Counter` object.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们想要跟踪文本中单词的频率；标准库来拯救我们，并为我们提供了一种非常好的跟踪计数和频率的方法，即通过专用的`collections.Counter`对象。
- en: The `collections.Counter` object not only keeps track of frequencies, but provides
    some dedicated methods to retrieve the most common entries, entries that appear
    at last once and quickly count any iterable.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`collections.Counter`对象不仅跟踪频率，还提供了一些专用方法来检索最常见的条目，至少出现一次的条目，并快速计算任何可迭代对象。'
- en: 'Any iterable you provide to the `Counter` is "counted" for its frequency of
    values:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您提供给`Counter`的任何可迭代对象都将被“计数”其值的频率：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The result would be exactly what we expect, a dictionary with the frequencies
    of the words in our phrase:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果将会正是我们所期望的，即我们短语中单词的频率字典：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we can easily query for the most frequent words:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以轻松查询最常见的单词：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Get the frequency of a specific word:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取特定单词的频率：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or, get back the total number of occurrences:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，获取总出现次数：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And we can even apply some set operations on counters, such as joining them,
    subtracting them, or checking for intersections:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们甚至可以对计数器应用一些集合操作，例如合并它们，减去它们，或检查它们的交集：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our counting code relies on the fact that `Counter` is just a special kind of
    dictionary, and that dictionaries can be built by providing an iterable. Each
    entry in the iterable will be added to the dictionary.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计数代码依赖于`Counter`只是一种特殊类型的字典，字典可以通过提供一个可迭代对象来构建。可迭代对象中的每个条目都将添加到字典中。
- en: In the case of a counter, adding an element means incrementing its count; for
    every "word" in our list, we add that word multiple times (one every time it appears
    in the list), so its value in the `Counter` continues to get incremented every
    time the word is encountered.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在计数器的情况下，添加一个元素意味着增加其计数；对于我们列表中的每个“单词”，我们会多次添加该单词（每次它在列表中出现一次），因此它在`Counter`中的值每次遇到该单词时都会继续增加。
- en: There's more...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Relying on `Counter` is actually not the only way to track frequencies; we already
    know that `Counter` is a special kind of dictionary, so reproducing the `Counter`
    behavior should be quite straightforward.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖`Counter`实际上并不是跟踪频率的唯一方法；我们已经知道`Counter`是一种特殊类型的字典，因此复制`Counter`的行为应该是非常简单的。
- en: 'Probably every one of us came up with a dictionary in this form:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每个人可能都会得到这种形式的字典：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Whenever we face a new occurrence of `hello`, `world`, `nice`, or `day`, we
    increment the associated value in the dictionary and call it a day:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们遇到`hello`、`world`、`nice`或`day`的新出现时，我们就会增加字典中关联的值，并称之为一天：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By relying on `dict.get`, we can also easily adapt it to count any word, not
    just those we could foresee:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过依赖`dict.get`，我们也可以很容易地使其适应计算任何单词，而不仅仅是我们可以预见的那些：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: But the standard library actually provides a very flexible tool that we can
    use to improve this code even further, `collections.defaultdict`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 但标准库实际上提供了一个非常灵活的工具，我们可以使用它来进一步改进这段代码，那就是`collections.defaultdict`。
- en: '`defaultdict` is a plain dictionary that won''t throw `KeyError` for any missing
    value, but will call a function we can provide to generate the missing value.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict`是一个普通的字典，对于任何缺失的值都不会抛出`KeyError`，而是调用我们可以提供的函数来生成缺失的值。'
- en: 'So, something such as `defaultdict(int)` will create a dictionary that provides
    `0` for any key that it doesn''t have, which is very convenient for our counting
    purpose:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，诸如`defaultdict(int)`这样的东西将创建一个字典，为任何它没有的键提供`0`，这对我们的计数目的非常方便：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The result will be exactly what we expect:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将会完全符合我们的期望：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As for each word, the first time we face it, we will call `int` to get the starting
    value and then add `1` to it. As `int` gives `0` when called without any argument,
    that achieves what we want.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个单词，第一次遇到它时，我们将调用`int`来获得起始值，然后加`1`。由于`int`在没有任何参数的情况下调用时会返回`0`，这就实现了我们想要的效果。
- en: While this roughly solves our problem, it's far from being a complete solution
    for counting—we track frequencies, but on everything else, we are on our own.
    What if we want to know the most frequent entry in our bag of words?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这大致解决了我们的问题，但对于计数来说远非完整解决方案——我们跟踪频率，但在其他方面，我们是自己的。如果我们想知道我们的词袋中最常见的词是什么呢？
- en: The convenience of `Counter` is based on the set of additional features specialized
    for counting that it provides; it's not just a dictionary with a default numeric
    value, it's a class specialized in keeping track of frequencies and providing
    convenient ways to access them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter`的便利性基于其提供的一组专门用于计数的附加功能；它不仅仅是一个具有默认数值的字典，它是一个专门用于跟踪频率并提供方便的访问方式的类。'
- en: Dictionary with fallback
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有回退的字典
- en: When working with configuration values, it's common to look them up in multiple
    places—maybe we load them from a configuration file—but we can override them with
    an environment variable or a command-line option, and in case the option is not
    provided, we can have a default value.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理配置值时，通常会在多个地方查找它们——也许我们从配置文件中加载它们——但我们可以用环境变量或命令行选项覆盖它们，如果没有提供选项，我们可以有一个默认值。
- en: 'This can easily lead to long chains of `if` statements like these:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易导致像这样的长链的`if`语句：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is annoying, and while for a single value it might be just annoying, it
    will tend to grow into a huge, confusing list of conditions as more options get
    added.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这很烦人，而对于单个值来说可能只是烦人，但随着添加更多选项，它将变成一个庞大、令人困惑的条件列表。
- en: Command-line options are a very frequent use case, but the problem is related
    to chained scopes resolution. Variables in Python are resolved by looking at `locals()`;
    if they are not found, the interpreter looks at `globals()`, and if they are not
    yet found, it looks for built-ins.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行选项是一个非常常见的用例，但问题与链式作用域解析有关。在Python中，变量是通过查看`locals()`来解析的；如果找不到它们，解释器会查看`globals()`，如果还找不到，它会查找内置变量。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'For this step, you need to go through the following steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一步，您需要按照以下步骤进行：
- en: The alternative for chaining default values of `dict.get`, instead of using
    multiple `if` instances, probably wouldn't improve much the code and if we want
    to add one additional scope, we would have to add it in every single place where
    we are looking up the values.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与使用多个`if`实例相比，`dict.get`的默认值链的替代方案可能并不会改进代码太多，如果我们想要添加一个额外的作用域，我们将不得不在每个查找值的地方都添加它。
- en: '`collections.ChainMap` is a very convenient solution to this problem; we can
    provide a list of mapping containers and it will look for a key through them all.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`collections.ChainMap`是这个问题的一个非常方便的解决方案；我们可以提供一个映射容器的列表，它将在它们所有中查找一个键。'
- en: 'Our previous example involving multiple different `if` instances can be converted
    to something like this:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们之前的涉及多个不同`if`实例的示例可以转换为这样的形式：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also get rid of the last `.get` call by combining `ChainMap` with `defaultdict`.
    In this case, we can use `defaultdict` to provide a default value for every key:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以通过将`ChainMap`与`defaultdict`结合来摆脱最后的`.get`调用。在这种情况下，我们可以使用`defaultdict`为每个键提供一个默认值：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Print `value` and `value2` will result in the following:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印`value`和`value2`将会得到以下结果：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`optname` will be retrieved from the `command_line_options` containing it,
    while `other-option` will end up being resolved by `defaultdict`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`optname`将从包含它的`command_line_options`中检索，而`other-option`最终将由`defaultdict`解析。'
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ChainMap` class receives multiple dictionaries as arguments; whenever a
    key is requested to `ChainMap`, it's actually going through the provided dictionaries
    one by one to check whether the key is available in any of them. Once the key
    is found, it is returned, as if it was a key owned by `ChainMap` itself.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChainMap`类接收多个字典作为参数；每当向`ChainMap`请求一个键时，它实际上会逐个查看提供的字典，以检查该键是否在其中任何一个中可用。一旦找到键，它就会返回，就好像它是`ChainMap`自己拥有的键一样。'
- en: The default value for options that are not provided is implemented by having
    `defaultdict` as the last dictionary provided to `ChainMap`. Whenever a key is
    not found in any of the previous dictionaries, it gets looked up in `defaultdict`,
    which uses the provided factory function to return a default value for all keys.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 未提供的选项的默认值是通过将`defaultdict`作为提供给`ChainMap`的最后一个字典来实现的。每当在之前的任何字典中找不到键时，它会在`defaultdict`中查找，`defaultdict`使用提供的工厂函数为所有键返回默认值。
- en: There's more...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Another great feature of `ChainMap` is that it allows updating too, but instead
    of updating the dictionary where it found the key, it always updates the first
    dictionary. The result is the same, as on next lookup of that key, we would have
    the first dictionary override any other value for that key (as it''s the first
    place where the key is checked). The advantage is that if we provide an empty
    dictionary as the first mapping provided to `ChainMap`, we can change those values
    without touching the original container:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChainMap`的另一个很棒的功能是它也允许更新，但是它总是更新第一个字典，而不是更新找到键的字典。结果是一样的，因为在下一次查找该键时，我们会发现第一个字典覆盖了该键的任何其他值（因为它是检查该键的第一个地方）。优点是，如果我们将空字典作为提供给`ChainMap`的第一个映射，我们可以更改这些值而不触及原始容器：'
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'But even though we changed the population of Japan to 128 million, the original
    population didn''t change:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使我们将日本的人口更改为1.28亿，原始人口也没有改变：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And we can even use `changes` to find out which values were changed and which
    values were not:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用`changes`来找出哪些值被更改了，哪些值没有被更改：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It''s important to know, by the way, that if the object contained in the dictionary
    is mutable and we directly mutate it, there is little `ChainMap` can do to avoid
    mutating the original object. So if, instead of numbers, we store lists in the
    dictionaries, we will be mutating the original dictionary whenever we append values
    to the dictionary:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果字典中包含的对象是可变的，并且我们直接对其进行改变，`ChainMap`无法避免改变原始对象。因此，如果我们在字典中存储的不是数字，而是列表，每当我们向字典追加值时，我们将改变原始字典：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Unpacking multiple keyword arguments
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解包多个关键字参数
- en: Frequently, you ended up in a situation where you had to provide arguments to
    a function from a dictionary. If you've ever faced that need, you probably also
    ended up in a case where you had to take the arguments from multiple dictionaries.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，你会发现自己需要从字典中向函数提供参数。如果你曾经面临过这种需求，你可能也会发现自己需要从多个字典中获取参数。
- en: Generally, Python functions accept arguments from a dictionary through unpacking
    (the `**` syntax), but so far, it hasn't been possible to use unpacking twice
    in the same call, nor was there an easy way to merge two dictionaries.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Python函数通过解包（`**`语法）从字典中接受参数，但到目前为止，在同一次调用中两次解包还不可能，也没有简单的方法来合并两个字典。
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The steps for this recipe are:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的步骤是：
- en: 'Given a function, `f`, we want to pass the arguments from two dictionaries, `d1` and
    `d2` as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个函数`f`，我们希望按以下方式从两个字典`d1`和`d2`传递参数：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`collections.ChainMap` can help us achieve what we want; it can cope with duplicated
    entries and works with any Python version:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`collections.ChainMap`可以帮助我们实现我们想要的；它可以处理重复的条目，并且适用于任何Python版本：'
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In Python 3.5 and newer versions, you can also create a new dictionary by combining
    multiple dictionaries through the literal syntax, and then pass the resulting
    dictionary as the argument of the function:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python 3.5及更新版本中，你还可以通过字面语法组合多个字典来创建一个新字典，然后将结果字典作为函数的参数传递：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this case, the duplicated entries are accepted too, but are handled in reverse
    order of priority to `ChainMap` (so right to left). Notice how `b` has a value
    of `7`, instead of the `6` it had with `ChainMap`, due to the reversed order of
    priorities.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，重复的条目也被接受，但按照`ChainMap`的优先级的相反顺序处理（从右到左）。请注意，`b`的值为`7`，而不是`ChainMap`中的`6`，这是由于优先级的反向顺序造成的。
- en: This syntax might be harder to read due to the amount of unpacking operators
    involved, and with `ChainMap` it is probably more explicit what's happening for
    a reader.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于涉及到大量的解包运算符，这种语法可能更难阅读，而使用`ChainMap`对于读者来说可能更加明确发生了什么。
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As we already know from the previous recipe, `ChainMap` looks up keys in all
    the provided dictionaries, so it's like the sum of all the dictionaries. The unpacking operator (`**`)
    works by inviting all keys to the container and then providing an argument for
    each key.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经从之前的示例中知道的那样，`ChainMap`在所有提供的字典中查找键，因此它就像所有字典的总和。解包运算符（`**`）通过将所有键放入容器，然后为每个键提供一个参数来工作。
- en: As `ChainMap` has keys resulting from the sum of all the provided dictionaries
    keys, it will provide the keys contained in all the dictionaries to the unpacking
    operator, thus allowing us to provide keyword arguments from multiple dictionaries.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ChainMap`具有所有提供的字典键的总和，它将提供包含在所有字典中的键给解包运算符，从而允许我们从多个字典中提供关键字参数。
- en: There's more...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Since Python 3.5 through PEP 448, it''s now possible to unpack multiple mappings
    to provide keyword arguments:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 自Python 3.5通过PEP 448，现在可以解包多个映射以提供关键字参数：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This solution is very convenient, but has two limits:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案非常方便，但有两个限制：
- en: It's only available in Python 3.5+
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅适用于Python 3.5+
- en: It chokes on duplicated arguments
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它无法处理重复的参数
- en: 'If you don''t know where the mappings/dictionaries you are unpacking come from,
    it''s easy to end up with the issue of duplicated arguments:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道你要解包的映射/字典来自哪里，很容易出现重复参数的问题：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the previous example, the `b` key is declared in both `d1` and `d2`, and
    that causes the function to complain that it received duplicate arguments.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`b`键在`d1`和`d2`中都有声明，这导致函数抱怨它收到了重复的参数。
- en: Ordered dictionaries
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有序字典
- en: One of the most surprising aspects of Python dictionaries for new users is that
    their order is unpredictable and can change from environment to environment. So,
    the order of keys you expected on your system might be totally different on your
    friend's computer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新用户来说，Python字典最令人惊讶的一个方面是，它们的顺序是不可预测的，而且在不同的环境中可能会发生变化。因此，您在自己的系统上期望的键的顺序可能在朋友的计算机上完全不同。
- en: This frequently causes unexpected failures during tests; if a continuous integration
    system is involved, the ordering of dictionary keys on the system running the
    tests can be different from the ordering on your system, which might lead to random
    failures.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这经常会在测试期间导致意外的失败；如果涉及到持续集成系统，则运行测试的系统上的字典键的排序可能与您的系统上的排序不同，这可能导致随机失败。
- en: 'Suppose you have a snippet of code that generates an HTML tag with some attributes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一小段代码，它生成了一个带有一些属性的HTML标签：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It might surprise you that on some systems you end up with this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 也许会让你感到惊讶的是，在某些系统上，你最终会得到这样的结果：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'While on others, the result might be this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 而在其他情况下，结果可能是这样的：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So, if you expect to be able to compare the resulting string to check whether
    your function did the right thing when generating this tag, you might be disappointed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您期望能够比较生成的字符串，以检查您的函数在生成此标签时是否做对了，您可能会感到失望。
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Keys ordering is a very convenient feature and in some cases, it's actually
    necessary, so the Python standard library comes to help and provides the `collections.OrderedDict`
    container.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 键的排序是一个非常方便的功能，在某些情况下，它实际上是必需的，因此Python标准库提供了`collections.OrderedDict`容器。
- en: 'In the case of `collections.OrderedDict`, the keys are always in the order
    they were inserted in:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`collections.OrderedDict`的情况下，键始终按插入的顺序排列：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`OrderedDict` stores both a mapping of the keys to their values and a list
    of keys that is used to preserve the order of them.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderedDict`同时存储键到值的映射和一个用于保留它们顺序的键列表。'
- en: So whenever your look for a key, the lookup goes through the mapping, but whenever
    you want to list the keys or iterate over the container, you go through the list
    of keys to ensure they are processed in the order they were inserted in.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当您查找键时，查找都会通过映射进行，但每当您想要列出键或对容器进行迭代时，您都会通过键列表来确保它们按照插入的顺序进行处理。
- en: 'The main problem when using `OrderedDict` is that Python on versions before
    3.6 didn''t guarantee any specific order of keyword arguments:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`OrderedDict`的主要问题是，Python在3.6之前的版本中没有保证关键字参数的任何特定顺序：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This would have again introduced a totally random order of keys even though
    `OrderedDict` was used. Not because `OrderedDict` didn't preserve the order of
    those keys, but because it would have received them in a random order.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用了`OrderedDict`，这将再次引入完全随机的键顺序。这不是因为`OrderedDict`没有保留这些键的顺序，而是因为它们可能以随机顺序接收到。
- en: Thanks to PEP 468, the order of arguments is now guaranteed in Python 3.6 and
    newer versions (the order of dictionaries is still not, remember; so far it's
    just by chance that they are ordered). So if you are using Python 3.6 or newer,
    our previous example would work as expected, but if you are on older versions
    of Python, you would end up with a random order.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PEP 468的原因，现在在Python 3.6和更新版本中保证了参数的顺序（字典的顺序仍然不确定；请记住，它们是有序的只是偶然的）。因此，如果您使用的是Python
    3.6或更新版本，我们之前的示例将按预期工作，但如果您使用的是较旧版本的Python，您将得到一个随机的顺序。
- en: Thankfully, this is an issue that is easily solved. Like standard dictionaries,
    `OrderedDict` supports any iterable as the source of its content. As long as the
    iterable provides a key and a value, it can be used to build `OrderedDict`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这是一个很容易解决的问题。与标准字典一样，`OrderedDict`支持任何可迭代的内容作为其内容的来源。只要可迭代对象提供了一个键和一个值，就可以用它来构建`OrderedDict`。
- en: 'So by providing the keys and values in a tuple, we can provide them at construction
    time and preserve the order in any Python version:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过在元组中提供键和值，我们可以在任何Python版本中在构建时提供它们并保留顺序：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There's more...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Python 3.6 introduced a guarantee of preserving the order of dictionary keys
    as a side effect of some changes to dictionaries, but it was considered an internal
    implementation detail and not a language guarantee. Since Python 3.7, it became
    an official feature of the language so it's actually safe to rely on dictionary
    ordering if you are using Python 3.6 or newer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.6引入了保留字典键顺序的保证，作为对字典的一些更改的副作用，但它被认为是一个内部实现细节，而不是语言保证。自Python 3.7以来，它成为语言的一个官方特性，因此如果您使用的是Python
    3.6或更新版本，可以放心地依赖于字典的顺序。
- en: MultiDict
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MultiDict
- en: If you have ever need to provide a reverse mapping, you have probably discovered
    that Python lacks a way to store more than a value for each key in a dictionary.
    This is a very common need, and most languages provide some form of multimap container.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经需要提供一个反向映射，您可能已经发现Python缺乏一种方法来为字典中的每个键存储多个值。这是一个非常常见的需求，大多数语言都提供了某种形式的多映射容器。
- en: Python tends to prefer having a single way of doing things, and as storing multiple
    values for the key means just storing a list of values for a key, it doesn't provide
    a specialized container.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Python倾向于有一种单一的做事方式，因为为键存储多个值意味着只是为键存储一个值列表，所以它不提供专门的容器。
- en: The issue with storing a list of values is that to be able to append to values
    to our dictionary, the list must already exist.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 存储值列表的问题在于，为了能够将值附加到我们的字典中，列表必须已经存在。
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Proceed with the following steps for this recipe:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行此操作：
- en: 'As we already know, `defaultdict` will create a default value by calling the
    provided callable for every missing key. We can provide the `list` constructor
    as a callable:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，`defaultdict`将通过调用提供的可调用函数为每个缺失的键创建一个默认值。我们可以将`list`构造函数作为可调用函数提供：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So, we insert keys into our multimap by using `rd[k].append(v)` instead of
    the usual `rd[k] = v`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们通过使用`rd[k].append(v)`而不是通常的`rd[k] = v`来将键插入到我们的多映射中：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`MultiDict` works by storing a list for each key. Whenever a key is accessed,
    the list containing all the values for that key is retrieved.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`MultiDict`通过为每个键存储一个列表来工作。每当访问一个键时，都会检索包含该键所有值的列表。'
- en: In the case of missing keys, an empty list will be provided so that values can
    be added for that key.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在缺少键的情况下，将提供一个空列表，以便为该键添加值。
- en: This works because every time `defaultdict` faces a missing key, it will insert
    it with a value generated by calling `list`. And calling `list` will actually
    provide an empty list. So, doing `rd[v]` will always provide a list, empty or
    not, depending on whether `v` was an already existing key or not. Once we have
    our list, adding a new value is just a matter of appending it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为每次`defaultdict`遇到缺少的键时，它将插入一个由调用`list`生成的值。调用`list`实际上会提供一个空列表。因此，执行`rd[v]`将始终提供一个列表，取决于`v`是否是已经存在的键。一旦我们有了列表，添加新值只是追加它的问题。
- en: There's more...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Dictionaries in Python are associative containers where keys are unique. A key
    can appear a single time and has exactly one value.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的字典是关联容器，其中键是唯一的。一个键只能出现一次，且只有一个值。
- en: 'If we want to support multiple values per key, we can actually solve the need
    by saving `list` as the value of our key. This list can then contain all the values
    we want to keep around for that key:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要支持每个键多个值，实际上可以通过将`list`保存为键的值来满足需求。然后，该列表可以包含我们想要保留的所有值：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we want to add a new translation to `2` (Spanish, for example), we would
    just have to append the entry:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要为`2`（例如西班牙语）添加新的翻译，我们只需追加该条目：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The problem arises when we want to introduce a new key:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要引入一个新的键时，问题就出现了：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For key `4`, no list exists, so there is nowhere we can append it. So, our
    snippet to automatically reverse the mapping can''t be easily adapted to handle
    multiple values, as it would fail with key errors the first time it tries to insert
    a value:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于键`4`，没有列表存在，因此我们无法追加它。因此，我们的自动反向映射片段无法轻松适应处理多个值，因为它在尝试插入值时会出现键错误：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Checking for every single entry, whether it's already in the dictionary or not,
    and acting accordingly is not very convenient. While we can rely on the `setdefault`
    method of dictionaries to hide that check, we can get a far more elegant solution
    by using `collections.defaultdict`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 检查每个条目是否已经在字典中，然后根据情况采取行动并不是非常方便。虽然我们可以依赖字典的`setdefault`方法来隐藏该检查，但是通过使用`collections.defaultdict`可以获得更加优雅的解决方案。
- en: Prioritizing entries
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先处理条目
- en: Picking the first/top entry of a set of values is a pretty frequent need; this
    usually means defining one value that has priority over the other and involves
    sorting.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一组值的第一个/顶部条目是一个非常频繁的需求；这通常意味着定义一个优先于其他值的值，并涉及排序。
- en: But sorting can be expensive and re-sorting every time you add an entry to your
    values is certainly not a very convenient way to pick the first entry out of a
    set of values with some kind of priority.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但是排序可能很昂贵，并且每次添加条目到您的值时重新排序肯定不是一种非常方便的方式来从一组具有某种优先级的值中选择第一个条目。
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Heaps are a perfect match for everything that has priorities, such as a priority
    queue:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是一切具有优先级的完美匹配，例如优先级队列：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, our `PriorityQueue` can be used to retrieve entries given a priority:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的`PriorityQueue`可以用于检索给定优先级的条目：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`PriorityQueue` works by storing everything in an heap. Heaps are particularly
    efficient at retrieving the top/first element of a sorted set without having to
    actually sort the whole set.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`PriorityQueue`通过在堆中存储所有内容来工作。堆在检索排序集的顶部/第一个元素时特别高效，而无需实际对整个集进行排序。'
- en: 'Our priority queue stores all the values in a three-element tuple: `priority`,
    `time.time()`, and `value`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的优先级队列将所有值存储在一个三元组中：`priority`，`time.time()`和`value`。
- en: The first entry of our tuple is `priority` (lower is better). In the example,
    we recorded `f1` with a better priority than `f2`, which ensures than when we
    use `heap.heappop` to fetch tasks to process, we get `f1` and then `f2`, so that
    we end up with the `hello world` message and not `world hello`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们元组的第一个条目是`priority`（较低的优先级更好）。在示例中，我们记录了`f1`的优先级比`f2`更好，这确保了当我们使用`heap.heappop`获取要处理的任务时，我们首先得到`f1`，然后是`f2`，这样我们最终得到的是`hello
    world`消息而不是`world hello`。
- en: The second entry, `timestamp`, is used to ensure that tasks that have the same
    priority are processed in their insertion order. The oldest task will be served
    first as it will have the smallest timestamp.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个条目`timestamp`用于确保具有相同优先级的任务按其插入顺序进行处理。最旧的任务将首先被处理，因为它将具有最小的时间戳。
- en: Then, we have the value itself, which is the function we want call for our task.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有值本身，这是我们要为任务调用的函数。
- en: There's more...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A very common approach to sorting is to keep a list of entries in a tuple, where
    the first element is `key` for which we are sorting and the second element is
    the value itself.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于排序的一个非常常见的方法是将条目列表保存在一个元组中，其中第一个元素是我们正在排序的`key`，第二个元素是值本身。
- en: 'For a scoreboard, we can keep each player''s name and how many points they
    got:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于记分牌，我们可以保留每个玩家的姓名和他们得到的分数：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Storing those values in tuples works because comparing two tuples is performed
    by comparing each element of the first tuple with the element in the same index
    position in the other tuple:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些值存储在元组中有效，因为比较两个元组是通过将第一个元组的每个元素与另一个元组中相同索引位置的元素进行比较来执行的：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It's very easy to understand what's going on if you think about strings. `'BB'
    > 'BB'` is the same as `('B', 'B') > ('B', 'A')`; in the end, a string is just
    a list of characters.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您考虑字符串，就可以很容易地理解发生了什么。`'BB' > 'BB'`与`('B', 'B') > ('B', 'A')`相同；最终，字符串只是字符列表。
- en: 'We can use this property to sort our `scores` and retrieve the winner of a
    competition:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这个属性对我们的`scores`进行排序，并检索比赛的获胜者：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The major problem with this approach is that every time we add an entry to
    our list, we have to sort it again, or our scoreboard would became meaningless:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要问题是，每次我们向列表添加条目时，我们都必须重新对其进行排序，否则我们的计分板将变得毫无意义：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is very inconvenient because it's easy to miss re-sorting somewhere if
    we have multiple places appending to the list, and sorting the whole list every
    time can be expensive.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这很不方便，因为如果我们有多个地方向列表添加元素，很容易错过重新排序的地方，而且每次对整个列表进行排序可能会很昂贵。
- en: The Python standard library offers a data structure that is a perfect match
    when we're interested in finding out the winner of a competition.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库提供了一种数据结构，当我们想要找出比赛的获胜者时，它是完美的匹配。
- en: 'In the `heapq` module, we have a fully working implementation of a heap data
    structure, a particular kind of tree where each parent is smaller than its children.
    This provides us with a tree that has a very interesting property: the root element
    is always the smallest one.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`heapq`模块中，我们有一个完全工作的堆数据结构的实现，这是一种特殊类型的树，其中每个父节点都小于其子节点。这为我们提供了一个具有非常有趣属性的树：根元素始终是最小的。
- en: 'And being implemented on top of a list, it means that `l[0]` is always the
    smallest element in a `heap`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 并且它是建立在列表之上的，这意味着`l[0]`始终是`heap`中最小的元素：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You might have noticed, by the way, that the heap finds the loser of our tournament,
    not the winner, and we were interested in finding the best player, with the highest
    value.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，您可能已经注意到，堆找到了我们比赛的失败者，而不是获胜者，而我们对找到最好的玩家，即最高价值的玩家感兴趣。
- en: 'This is a minor problem we can easily solve by storing all scores as negative
    numbers. If we store each score as `* -1`, the head of the heap will always be
    the winner:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们可以通过将所有分数存储为负数来轻松解决的小问题。如果我们将每个分数存储为`* -1`，那么堆的头部将始终是获胜者：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Bunch
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bunch
- en: Python is very good at shapeshifting objects. Each instance can have its own
    attributes and it's absolutely legal to add/remove the attributes of an object
    at runtime.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Python非常擅长变形对象。每个实例都可以有自己的属性，并且在运行时添加/删除对象的属性是完全合法的。
- en: Once in a while, our code needs to deal with data of unknown shapes. For example,
    in the case of a user-submitted data, we might not know which fields the user
    is providing; maybe some of our users have a first name, some have a surname,
    and some have one or more middle name fields.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，我们的代码需要处理未知形状的数据。例如，在用户提交的数据的情况下，我们可能不知道用户提供了哪些字段；也许我们的一些用户有名字，一些有姓氏，一些有一个或多个中间名字段。
- en: If we are not processing this data ourselves, but are just providing it to some
    other function, we really don't care about the shape of the data; as long as our
    objects have those attributes, we are fine.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不是自己处理这些数据，而只是将其提供给其他函数，我们实际上并不关心数据的形状；只要我们的对象具有这些属性，我们就没问题。
- en: A very common case is when working with protocols, if you are an HTTP server,
    you might want to provide to the application running behind you a `request` object.
    This object has a few known attributes, such as `host` and `path`, and it might
    have some optional attributes, such as a `query` string or a `content` type. But,
    it can also have any attribute the client provided, as HTTP is pretty flexible
    regarding headers, and our clients could have provided an `x-totally-custom-header`
    that we might have to expose to our code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的情况是在处理协议时，如果您是一个HTTP服务器，您可能希望向您后面运行的应用程序提供一个`request`对象。这个对象有一些已知的属性，比如`host`和`path`，还可能有一些可选的属性，比如`query`字符串或`content`类型。但是，它也可以有客户端提供的任何属性，因为HTTP在头部方面非常灵活，我们的客户端可能提供了一个`x-totally-custom-header`，我们可能需要将其暴露给我们的代码。
- en: When representing this kind of data, Python developers often tend to look at
    dictionaries. In the end, Python objects themselves are built on top of dictionaries
    and they fit the need to map arbitrary values to names.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在表示这种类型的数据时，Python开发人员通常倾向于查看字典。最终，Python对象本身是建立在字典之上的，并且它们符合将任意值映射到名称的需求。
- en: 'So, we will probably end up with something like the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可能最终会得到以下内容：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: A side effect of this approach is pretty clear once we have to pass this object
    around, especially to third-party code. Functions usually work with objects, and
    while they don't require a specific kind of object as duck-typing is the standard
    in Python, they will expect certain attributes to be there.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个副作用在于，一旦我们不得不将这个对象传递给其他代码，特别是第三方代码时，就变得非常明显。函数通常使用对象工作，虽然它们不需要特定类型的对象，因为鸭子类型是Python中的标准，但它们会期望某些属性存在。
- en: Another very common example is when writing tests, Python being a duck-typed
    language, it's absolutely reasonable to want to provide a fake object instead
    of providing a real instance of the object, especially when we need to simulate
    the values of some properties (as declared with `@property`), so we don't want
    or can't afford to create real instances of the object.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常常见的例子是在编写测试时，Python作为一种鸭子类型的语言，希望提供一个假对象而不是提供对象的真实实例是绝对合理的，特别是当我们需要模拟一些属性的值（如使用`@property`声明），因此我们不希望或无法创建对象的真实实例。
- en: In such cases, using a dictionary is not viable as it will only provide access
    to its values through the `request['path']` syntax and not through `request.path`,
    as probably expected by the functions we are providing our object to.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用字典是不可行的，因为它只能通过`request['path']`语法访问其值，而不能通过`request.path`访问，这可能是我们提供对象给函数时所期望的。
- en: Also, the more we end up accessing this value, the more it's clear that the
    syntax using dot notation conveys the feeling of an entity that collaborates to
    the intent of the code, while a dictionary conveys the feeling of plain data.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们访问这个值的次数越多，就越清楚使用点符号表示法传达了代码意图的实体协作的感觉，而字典传达了纯粹数据的感觉。
- en: 'As soon as we remember that Python objects can change shape at any time, we
    might be tempted to try creating an object instead of a dictionary. Unfortunately,
    we won''t be able to provide the attributes at initialization time:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们记住Python对象可以随时改变形状，我们可能会尝试创建一个对象而不是字典。不幸的是，我们无法在初始化时提供属性：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Things don''t improve much if we try to assign those attributes after the object
    is built:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在构建对象后分配这些属性，情况也不会有所改善：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With a little effort, we can create a class that leverages dictionaries to
    contain any attribute we want and allow access both as a dictionary and through
    properties:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一点努力，我们可以创建一个利用字典来包含我们想要的任何属性并允许通过属性和字典访问的类：
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Bunch` class inherits `dict`, mostly as a way to provide a context where
    values can be stored, then most of the work is done by `__getattribute__` and
    `__setattr__`. So, for any attribute that is retrieved or set on the object, they
    will just retrieve or set a key in `self` (remember we inherited from `dict`,
    so `self` is in fact a dictionary).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bunch`类继承自`dict`，主要是为了提供一个值可以被存储的上下文，然后大部分工作由`__getattribute__`和`__setattr__`完成。因此，对于在对象上检索或设置的任何属性，它们只会检索或设置`self`中的一个键（记住我们继承自`dict`，所以`self`实际上是一个字典）。'
- en: This allows the `Bunch` class to store and retrieve any value as an attribute
    of the object. The convenient feature is that it can behave both as an object
    and as a `dict` in most contexts.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得`Bunch`类能够将任何值存储和检索为对象的属性。方便的特性是它在大多数情况下既可以作为对象又可以作为`dict`来使用。
- en: 'For example, it is possible to find out all the values that it contains, like
    any other dictionary:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以找出它包含的所有值，就像任何其他字典一样：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'It is also able to access those as attributes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 它还能够将它们作为属性访问：
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There's more...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Our `bunch` implementation is not yet complete, as it will fail any test for
    class name (it's always named `Bunch`) and any test for inheritance, thus failing
    at faking other objects.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`bunch`实现还不完整，因为它将无法通过任何类名称测试（它总是被命名为`Bunch`），也无法通过任何继承测试，因此无法伪造其他对象。
- en: 'The first step is to make `Bunch` able to shapeshift not only its properties,
    but also its name. This can be achieved by creating a new class dynamically every
    time we create `Bunch`. The class will inherit from `Bunch` and will do nothing
    apart from providing a new name:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使`Bunch`能够改变其属性，还能改变其名称。这可以通过每次创建`Bunch`时动态创建一个新类来实现。该类将继承自`Bunch`，除了提供一个新名称外不会做任何其他事情：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `Bunch` function moved from being the class itself to being a factory that
    will create objects that all act as `Bunch`, but can have different classes. Each
    `Bunch` will be a subclass of `BunchBase`, where the `_classname` name can be
    provided when `Bunch` is created:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bunch`函数从原来的类本身变成了一个工厂，将创建所有作为`Bunch`的对象，但可以有不同的类。每个`Bunch`将是`BunchBase`的子类，其中在创建`Bunch`时可以提供`_classname`名称：'
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This will allow us to create as many kinds of `Bunch` objects as we want, and
    each will have its own custom type:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们创建任意类型的`Bunch`对象，并且每个对象都将有自己的自定义类型：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The next step is to make our `Bunch` actually look like any other type that
    it has to impersonate. That is needed for the case where we want to use `Bunch`
    in place of another object. As `Bunch` can have any kind of attribute, it can
    take the place of any kind of object, but to be able to, it has to pass type checks
    for custom types.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使我们的`Bunch`实际上看起来像它必须模仿的任何其他类型。这对于我们想要在另一个对象的位置使用`Bunch`的情况是必要的。由于`Bunch`可以具有任何类型的属性，因此它可以代替任何类型的对象，但为了能够这样做，它必须通过自定义类型的类型检查。
- en: We need to go back to our `Bunch` factory and make the `Bunch` objects not only
    have a custom class name, but also appear to be inherited from a custom parent.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要回到我们的`Bunch`工厂，并使`Bunch`对象不仅具有自定义类名，还要看起来是从自定义父类继承而来。
- en: 'To better understand what''s going on, we will declare an example `Person`
    type; this type will be the one our `Bunch` objects will try to fake:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解发生了什么，我们将声明一个示例`Person`类型；这个类型将是我们的`Bunch`对象尝试伪造的类型：
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Specifically, we are going to print `Hello Your Name` through a custom `print`
    function that only works for `Person`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将通过一个自定义的`print`函数打印`Hello Your Name`，该函数仅适用于`Person`：
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We want to change our `Bunch` factory to accept the class and create a new
    type out of it:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望改变我们的`Bunch`工厂，接受该类并创建一个新类型：
- en: '[PRE55]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, our `Bunch` objects will appear as instances of a class named what we
    wanted, and will always appear as a subclass of `_parent`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`Bunch`对象将显示为我们想要的类的实例，并且始终显示为`_parent`的子类：
- en: '[PRE56]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`Bunch` can be a very convenient pattern; in both its complete and simplified
    versions, it is widely used in many frameworks with various implementations that
    all achieve pretty much the same result.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bunch`可以是一种非常方便的模式；在其完整和简化版本中，它被广泛用于许多框架中，具有各种实现，但都可以实现几乎相同的结果。'
- en: The showcased implementation is interesting because it gives us a clear idea
    of what's going on. There are ways to implement `Bunch` that are very smart, but
    might make it hard to guess what's going on and customize it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 展示的实现很有趣，因为它让我们清楚地知道发生了什么。有一些非常聪明的方法可以实现`Bunch`，但可能会让人难以猜测发生了什么并进行自定义。
- en: 'Another possible way to implement the `Bunch` pattern is by patching the `__dict__` class,
    which contains all the attributes of the class:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`Bunch`模式的另一种可能的方法是通过修补包含类的所有属性的`__dict__`类：
- en: '[PRE57]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this form, whenever `Bunch` is created, it will populate its values as a
    `dict` (by calling `super().__init__`, which is the `dict` initialization) and
    then, once all the attributes provided are stored in `dict`, it swaps the `__dict__` object, which
    is the dictionary that contains all object attributes, with `self`. This makes
    the `dict` that was just populated with all the values also the `dict` that contains
    all the attributes of the object.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种形式下，每当创建`Bunch`时，它将以`dict`的形式填充其值（通过调用`super().__init__`，这是`dict`的初始化），然后，一旦所有提供的属性都存储在`dict`中，它就会用`self`交换`__dict__`对象，这是包含所有对象属性的字典。这使得刚刚填充了所有值的`dict`也成为了包含对象所有属性的`dict`。
- en: Our previous implementation worked by replacing the way we looked for attributes,
    while this implementation replaces the place where we look for attributes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的实现是通过替换我们查找属性的方式来工作的，而这个实现是替换我们查找属性的地方。
- en: Enumerations
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: Enumeration is a common way to store values that can only represent a few states.
    Each symbolic name is bound to a specific value, usually numeric, that represents
    the states the enumeration can have.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是存储只能表示几种状态的值的常见方式。每个符号名称都绑定到一个特定的值，通常是数字，表示枚举可以具有的状态。
- en: Enumerations are very common in other programming languages, but until recently,
    Python didn't have any explicit support for enumerations.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举在其他编程语言中非常常见，但直到最近，Python才没有对枚举提供明确的支持。
- en: How to do it...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Typically, enumerations are implemented by mapping symbolic names to numeric
    values; this is allowed in Python through `enum.IntEnum`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，枚举是通过将符号名称映射到数值来实现的；在Python中，通过`enum.IntEnum`是允许的：
- en: '[PRE58]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works...
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`IntEnum` is an integer, apart from the fact that all possible values are created
    when the class is defined. `IntEnum` inherits from `int`, so its values are real
    integers.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntEnum`是一个整数，除了在类定义时创建所有可能的值。`IntEnum`继承自`int`，因此它的值是真正的整数。'
- en: During the `RequestType` definition, all the possible values for `enum` are
    declared within the class body and the values are verified against duplicates
    by the metaclass.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RequestType`的定义过程中，所有`enum`的可能值都在类体内声明，并且这些值通过元类进行重复验证。
- en: Also, `enum` provides support for a special value, `auto`, which means *just
    put in a value, I don't care*. As you usually only care whether it's `POST` or
    `GET`, you usually don't care whether `POST` is `1` or `2`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`enum`提供了对特殊值`auto`的支持，它的意思是*只是放一个值进去，我不在乎*。通常你只关心它是`POST`还是`GET`，你通常不关心`POST`是`1`还是`2`。
- en: Last but not least, enumerations cannot be subclassed if they define at least
    one possible value.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，如果枚举定义了至少一个可能的值，那么枚举就不能被子类化。
- en: There's more...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`IntEnum` values behave like `int` in most cases, which is usually convenient,
    but they can cause problems if the developer doesn''t pay attention to the type.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntEnum`的值在大多数情况下表现得像`int`，这通常很方便，但如果开发人员不注意类型，它们可能会引起问题。'
- en: 'For example, a function might unexpectedly perform the wrong thing if another
    enumeration or an integer value is provided, instead of the proper enumeration
    value:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果提供了另一个枚举或整数值，而不是正确的枚举值，函数可能会意外执行错误的操作：
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As an example, invoking `do_request` with `RequestType.POST` or `1` will do
    exactly the same thing:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用`RequestType.POST`或`1`调用`do_request`将做完全相同的事情：
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When we want to avoid treating our enumerations as numbers, we can use `enum.Enum`,
    which provides enumerated values that are not considered plain numbers:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不想将枚举视为数字时，可以使用`enum.Enum`，它提供了不被视为普通数字的枚举值：
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: So generally, if you need a simple set of enumerated values or possible states
    that rely on `enum`, `Enum` is safer, but if you need a set of numeric values
    that rely on `enum`, `IntEnum` will ensure that they behave like numbers.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一般来说，如果你需要一个简单的枚举值集合或依赖于`enum`的可能状态，`Enum`更安全，但如果你需要依赖于`enum`的一组数值，`IntEnum`将确保它们表现得像数字。
