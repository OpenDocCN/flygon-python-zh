# Python对象、类型和表达式

数据结构和算法是一个大型复杂软件项目的核心要素之一。它们是一种系统化的方式，用于在软件中存储和组织数据，以便能够高效地使用。Python具有高效的高级数据结构和有效的面向对象编程语言。Python是许多高级数据任务的首选语言，原因很充分。它是最容易学习的高级编程语言之一。直观的结构和语义意味着对于那些不是计算机科学家，但可能是生物学家、统计学家或初创公司的负责人来说，Python是执行各种数据任务的简单方式。它不仅仅是一种脚本语言，而是一种功能齐全的面向对象的编程语言。

在Python中，有许多有用的数据结构和算法内置在语言中。此外，由于Python是一种基于对象的语言，相对容易创建自定义数据对象。在本书中，我们将研究Python的内部库和一些外部库，并学习如何从头开始构建自己的数据对象。

在本章中，我们将讨论以下主题：

+   获得对数据结构和算法的一般工作知识

+   理解核心数据类型及其功能

+   探索Python编程语言的面向对象的方面

# 技术要求

本书使用Python编程语言（版本3.7）介绍数据结构和算法。本书假设您已经了解Python。但是，如果您有点生疏，来自其他语言，或者根本不了解Python，不用担心 - 这一章应该能让您迅速掌握。

以下是GitHub链接：[https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter01](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter01)。

如果您对Python不熟悉，请访问[https://docs.python.org/3/tutorial/index.html](https://docs.python.org/3/tutorial/index.html)，您也可以在[https://www.python.org/doc/](https://www.python.org/doc/)找到文档。这些都是很好的资源，可以轻松学习这种编程语言。

# 安装Python

要安装Python，我们使用以下方法。

Python是一种解释性语言，语句是逐行执行的。程序员通常可以将一系列命令写在源代码文件中。对于Python，源代码存储在一个带有`.py`文件扩展名的文件中。

Python通常已经完全集成并安装在大多数Linux和Mac操作系统上。通常，预安装的Python版本是2.7。您可以使用以下命令检查系统上安装的版本：

```py
>>> import sys
>>> print(sys.version)
3.7.0 (v3.7.0:1bf9cc5093, Jun 27 2018, 04:06:47) [MSC v.1914 32 bit (Intel)]
```

您还可以使用以下命令在Linux上安装不同版本的Python：

1.  打开终端

1.  `sudo apt-get update`

1.  `sudo apt-get install -y python3-pip`

1.  `pip3 install <package_name>`

Python必须安装在Windows操作系统的系统上，因为它不像Linux/macOS那样预安装。可以从此链接下载Python的任何版本：[https://www.python.org/downloads/](https://www.python.org/downloads/)。您可以下载软件安装程序并运行它 - 选择为所有用户安装，然后单击下一步。您需要指定要安装软件包的位置，然后单击下一步。之后，在自定义Python对话框中选择将Python添加到环境变量的选项，然后再次单击下一步进行最终安装。安装完成后，您可以通过打开命令提示符并输入以下命令来确认安装：

```py
python -V
```

最新的稳定Python版本是Python 3.7.0。可以通过在命令行中输入以下内容来执行Python程序：

```py
python <sourcecode_filename>.py
```

# 理解数据结构和算法

算法和数据结构是计算机中最基本的概念。它们是构建复杂软件的主要构建模块。理解这些基础概念在软件设计中是非常重要的，这涉及以下三个特征：

+   算法如何操作数据结构中包含的信息

+   3. 数据在内存中的排列方式

+   1. 特定数据结构的性能特征是什么

在这本书中，我们将从几个角度来审视这个话题。首先，我们将从数据结构和算法的角度来看Python编程语言的基础知识。其次，重要的是我们要有正确的数学工具。我们需要理解计算机科学的基本概念，为此我们需要数学。通过采取一种启发式的方法，制定一些指导原则意味着，一般来说，我们不需要比高中数学更多的知识来理解这些关键思想的原则。

另一个重要方面是评估。衡量算法的性能需要理解数据规模的增加如何影响数据的操作。当我们处理大型数据集或实时应用程序时，我们的算法和结构尽可能高效是至关重要的。

最后，我们需要一个强大的实验设计策略。能够将现实世界的问题概念化为编程语言的算法和数据结构，需要能够理解问题的重要元素以及将这些元素映射到编程结构的方法。

为了更好地理解算法思维的重要性，让我们考虑一个现实世界的例子。假设我们在一个陌生的市场，我们被要求购买一些物品。我们假设市场是随机布局的，每个供应商销售一个随机子集的物品，其中一些物品可能在我们的清单上。我们的目标是尽量减少每个购买物品的价格，同时最小化在市场上花费的时间。解决这个问题的一种方法是编写以下类似的算法：

1. 供应商是否有我们清单上的物品，且成本低于该物品的预测成本？

2. 如果是，购买并从清单中删除；如果不是，继续下一个供应商。

2. 如果没有更多的供应商，结束。

3. 如果我们必须使用编程语言来实现这个简单的迭代器，我们需要数据结构来定义和存储我们想要购买的物品清单和供应商正在销售的物品清单。我们需要确定最佳的匹配物品的方式，并且我们需要一些逻辑来决定是否购买。

关于这个算法，我们可以做出几点观察。首先，由于成本计算是基于预测的，我们不知道真实成本是多少。因此，我们不会购买物品，因为我们低估了物品的成本，导致我们在市场结束时仍有剩余物品。为了处理这种情况，我们需要一种有效的方式来存储数据，以便我们可以有效地回溯到成本最低的供应商。

此外，我们需要了解比较我们购物清单上的物品与每个供应商出售的物品所花费的时间。这很重要，因为随着我们购物清单上物品的数量或每个供应商出售的物品数量的增加，搜索物品需要更多的时间。我们搜索物品的顺序和数据结构的形状可以对搜索所需的时间产生很大的影响。显然，我们希望安排我们的清单以及我们访问每个供应商的顺序，以便最小化搜索时间。

此外，考虑一下当我们将购买条件更改为以*最便宜*的价格购买，而不仅仅是低于平均预测价格时会发生什么。这会完全改变问题。我们不再是顺序地从一个供应商到另一个供应商，而是需要遍历市场一次，并且有了这个知识，我们可以根据我们想要访问的供应商对我们的购物清单进行排序。

显然，将现实世界的问题转化为编程语言这样的抽象构造涉及许多微妙之处。例如，随着我们在市场上的进展，我们对产品成本的了解会提高，因此我们预测的平均价格变量会变得更加准确，直到在最后一个摊位，我们对市场的了解是完美的。假设任何形式的回溯算法都会产生成本，我们可以看到有理由重新审视整个策略。高价格波动、数据结构的大小和形状，以及回溯的成本等条件都决定了最合适的解决方案。整个讨论清楚地表明了数据结构和算法在构建复杂解决方案中的重要性。

# Python用于数据

Python具有几种内置的数据结构，包括列表、字典和集合，我们可以用它们来构建定制对象。此外，还有一些内部库，如collections和math对象，它们允许我们创建更高级的结构，并对这些结构进行计算。最后，还有像SciPy包中发现的外部库。这些库允许我们执行一系列高级数据任务，如逻辑和线性回归、可视化和数学计算，比如矩阵和向量的操作。外部库对于开箱即用的解决方案非常有用。然而，我们也必须意识到，与从头开始构建定制对象相比，通常会有性能损失。通过学习如何自己编写这些对象，我们可以将它们针对特定任务，使它们更有效率。这并不排除外部库的作用，我们将在第12章《设计技术和策略》中讨论这一点。

首先，我们将概述一些关键的语言特性，这些特性使Python成为数据编程的绝佳选择。

# Python环境

由于其可读性和灵活性，Python是全球最受欢迎和广泛使用的编程语言之一。Python环境的一个特点是其交互式控制台，允许您将Python用作桌面可编程计算器，也可以用作编写和测试代码片段的环境。

控制台的`读取...评估...打印`循环是与更大代码库交互的非常方便的方式，比如运行函数和方法或创建类的实例。这是Python相对于编译语言（如C/C++或Java）的主要优势之一，后者的`编写...编译...测试...重新编译`循环与Python的`读取...评估...打印`循环相比，可以大大增加开发时间。能够输入表达式并立即得到响应可以大大加快数据科学任务的速度。

除了官方的CPython版本外，还有一些优秀的Python发行版。其中最受欢迎的两个可以在以下网址找到：Anaconda（https://www.continuum.io/downloads）和Canopy（https://www.enthought.com/products/canopy/）。大多数发行版都带有自己的开发环境。Canopy和Anaconda都包括用于科学、机器学习和其他数据应用的库。大多数发行版都带有编辑器。

除了CPython版本外，还有许多Python控制台的实现。其中最值得注意的是基于网络的计算环境IPython/Jupyter平台。

# 变量和表达式

要通过算法实现解决现实世界的问题，我们首先必须选择变量，然后对这些变量应用操作。变量是附加到对象的标签。变量不是对象，也不是对象的容器；它们只是作为对象的指针或引用。例如，考虑以下代码：

![](Images/745e0608-bbd2-46b2-a213-47194b782fc8.png)

在这里，我们创建了一个指向列表对象的变量`a`。我们创建另一个变量`b`，它指向相同的列表对象。当我们向这个列表对象添加一个元素时，这个变化会反映在`a`和`b`中。

在Python中，变量名在程序执行期间附加到不同的数据类型；不需要首先声明变量的数据类型。每个值都有一个类型（例如字符串或整数）；然而，指向这个值的变量名没有特定的类型。更具体地说，变量指向一个对象，可以根据分配给它们的值的类型而改变它们的类型。考虑以下例子：

![](Images/2b7de8f3-a61b-4ac6-a154-12653f2518c8.png)

在前面的代码示例中，`a`的类型从`int`变为`float`，具体取决于变量中存储的值。

# 变量作用域

函数内部变量的作用域规则很重要。每当函数执行时，都会创建一个局部环境（命名空间）。这个局部命名空间包含所有由函数分配的变量和参数名。每当调用函数时，Python解释器首先查找函数本身的局部命名空间——如果找不到匹配项，然后查找全局命名空间。如果名称仍然找不到，那么它会在内置命名空间中搜索。如果还是找不到，解释器会引发`NameError`异常。考虑以下代码：

```py
a=15;b=25
def my_function():
  global a 
  a=11;b=21

my_function() 
print(a)  #prints 11 
print(b)  #prints 25
```

在前面的代码中，我们定义了两个`global`变量。我们需要使用关键字`global`告诉解释器，在函数内部我们正在引用一个`global`变量。当我们将这个变量更改为`11`时，这些更改会反映在全局范围内。然而，我们将`b`变量设置为`21`是函数内部的局部变量，对它进行的任何更改都不会反映在全局范围内。当我们运行函数并打印`b`时，我们看到它保留了它的全局值。

此外，让我们考虑另一个有趣的例子：

```py
>>> a = 10
>>> def my_function():
...     print(a)
>>> my_function ()
10
```

代码可以正常工作，并输出`10`，但看看下面的代码：

```py
>>> a = 10 
>>> def my_function():
...     print(a)
...     a= a+1 
>>> my_function()
 UnboundLocalError: local variable 'a' referenced before assignment
```

前面的代码出错了，因为在作用域内对变量进行赋值会使该变量成为该作用域的局部变量。在前面的例子中，在`my_function()`中对变量`a`进行赋值，编译器会将`a`视为局部变量，这就是为什么之前的`print()`函数尝试打印一个未初始化的局部变量`a`，从而导致错误。可以通过声明为`global`来访问外部作用域变量来解决这个问题：

```py
>>> a = 10
>>> def my_function():
...     global a
...     print(a)
...     a = a+1
>>> my_function()
10
```

因此，在Python中，函数内部引用的变量隐式地是全局的，如果`a`变量在函数体内的任何地方被赋值，它会被假定为局部变量，除非显式声明为全局变量。

# 流程控制和迭代

Python程序由一系列语句组成。解释器按顺序执行每个语句，直到没有更多的语句为止。这对于作为主程序运行的文件以及通过`import`加载的文件都是如此。所有语句，包括变量赋值、函数定义、类定义和模块导入，都具有相同的地位。没有比其他更高优先级的特殊语句，每个语句都可以放在程序的任何位置。通常，程序中的所有指令/语句都按顺序执行。然而，控制程序执行流的主要方法有两种——条件语句和循环。

`if...else`和`elif`语句控制条件执行语句。一般格式是一系列`if`和`elif`语句，后跟最终的`else`语句：

```py
x='one' 
if x==0:
   print('False')
elif  x==1:
   print('True')
else:  print('Something else')

#prints'Something else'
```

请注意使用`==`运算符来比较两个值。如果两个值相等，则返回`True`；否则返回`False`。还要注意，将`x`设置为字符串将返回`Something else`，而不会像在静态类型的语言中那样生成类型错误。动态类型的语言，如Python，允许对具有不同类型的对象进行灵活赋值。

控制程序流的另一种方法是使用循环。Python提供了两种构建循环的方式，如`while`和`for`循环语句。`while`循环重复执行语句，直到布尔条件为真。`for`循环提供了一种通过一系列元素重复执行循环的方法。下面是一个例子：

![](Images/8bddf69a-d89b-49c0-a9a6-358dbcb2dd2e.png)

在这个例子中，`while`循环执行语句，直到条件`x < 3`为真。让我们考虑另一个使用*for*循环的例子：

```py
>>>words = ['cat', 'dog', 'elephant']
>>> for w in words:
...     print(w)
... 
cat
dog
elephant
```

在这个例子中，*for*循环执行对列表中所有项目的迭代。

# 数据类型和对象概述

Python包含各种内置数据类型。这些包括四种数值类型（`int`、`float`、`complex`、`bool`）、四种序列类型（`str`、`list`、`tuple`、`range`）、一种映射类型（`dict`）和两种集合类型。还可以创建用户定义的对象，如函数或类。我们将在本章中讨论字符串和列表数据类型，下一章中讨论其余的内置类型。

Python中的所有数据类型都是**对象**。实际上，在Python中几乎所有的东西都是对象，包括模块、类和函数，以及字面量，如字符串和整数。Python中的每个对象都有一个**类型**、一个**值**和一个**标识**。当我们写`greet= "helloworld"`时，我们创建了一个字符串对象的实例，其值为`"hello world"`，标识为`greet`。对象的标识充当指向对象在内存中位置的指针。对象的类型，也称为对象的类，描述了对象的内部表示，以及它支持的方法和操作。一旦创建了对象的实例，它的标识和类型就不能被改变。

我们可以使用内置函数`id()`来获取对象的标识。这将返回一个标识整数，在大多数系统上，这将指向其内存位置，尽管您不应该依赖于这一点在您的任何代码中。

此外，有许多比较对象的方法；例如，参见以下内容：

```py
if a==b:    # a and b have the same value

if a is b:    # if a and b are the same object

if type(a) is type(b):   #a and b are the same type
```

需要区分**可变**和**不可变**对象之间的重要区别。可变对象如列表可以改变其值。它们有`insert()`或`append()`等方法，可以改变对象的值。不可变对象如字符串不能改变其值，因此当我们运行它们的方法时，它们只是返回一个值，而不是改变底层对象的值。当然，我们可以通过将其分配给一个变量或将其用作函数中的参数来使用这个值。例如，`int`类是不可变的——一旦创建了它的实例，它的值就不能改变，但是，引用这个对象的标识符可以被重新分配另一个值。

# 字符串

字符串是不可变的序列对象，每个字符代表序列中的一个元素。与所有对象一样，我们使用方法来执行操作。字符串是不可变的，不会改变实例；每个方法只是返回一个值。这个值可以存储为另一个变量，或作为参数传递给函数或方法。

以下表格列出了一些最常用的字符串方法及其描述：

| 方法 | 描述 |
| --- | --- |
| `s.capitalize` | 返回只有第一个字符大写的字符串，其余字符保持小写。 |
| `s.count(substring,[start,end])` | 计算子字符串的出现次数。 |
| `s.expandtabs([tabsize])` | 用空格替换制表符。 |
| `s.endswith(substring,[start, end]` | 如果字符串以指定的子字符串结尾，则返回`True`。 |
| `s.find(substring,[start,end])` | 返回子字符串第一次出现的索引。 |
| `s.isalnum()` | 如果字符串`s`中所有字符都是字母数字，则返回`True`。 |
| `s.isalpha()` | 如果字符串`s`中所有字符都是字母，则返回`True`。 |
| `s.isdigit()` | 如果字符串中所有字符都是数字，则返回`True`。 |
| `s.split([separator],[maxsplit])` | 以空格或可选分隔符分割字符串。返回一个列表。 |
| `s.join(t)` | 连接序列`t`中的字符串。 |
| `s.lower()` | 将字符串转换为全小写。 |
| `s.replace(old, new[maxreplace])` | 用新的子字符串替换旧的子字符串。 |
| `s.startswith(substring, [start, end]])` | 如果字符串以指定的子字符串开头，则返回`True`。 |
| `s.swapcase()` | 返回字符串中交换大小写的副本。 |
| `s.strip([characters])` | 移除空格或可选字符。 |
| `s.lstrip([characters])` | 返回删除前导字符的字符串副本。 |

像所有序列类型一样，字符串支持索引和切片。我们可以通过使用索引`s[i]`检索字符串的任何字符。我们可以通过使用`s[i:j]`检索字符串的一个切片，其中`i`和`j`是切片的起点和终点。我们可以通过使用步长返回一个扩展的切片，如下所示—`s[i:j:stride]`。以下代码应该能说明这一点：

![](Images/3da1c070-0671-4a9b-91cb-38e3ec444994.png)

前两个例子非常直接，分别返回索引`1`处的字符和字符串的前七个字符。请注意，索引从`0`开始。在第三个例子中，我们使用了步长为`2`。这导致每隔一个字符被返回。在最后一个例子中，我们省略了结束索引，切片返回整个字符串中每隔一个字符。

只要值是整数，就可以使用任何表达式、变量或运算符作为索引：

![](Images/045aeaf6-1be2-49ba-a3ea-059b09cb361e.png)

另一个常见的操作是使用循环遍历字符串：

![](Images/55d863c4-45e2-4aa1-936e-7e41915b13a3.png)

鉴于字符串是不可变的，一个常见的问题是如何执行插入值等操作。我们需要想办法为我们需要的结果构建新的字符串对象，而不是改变一个字符串。例如，如果我们想要在问候语中插入一个单词，我们可以将一个变量赋值给以下内容：

![](Images/93ff7c53-9bb0-4339-9ad3-bdaf2bb16046.png)

正如这段代码所示，我们使用切片操作符在索引位置`5`处拆分字符串，并使用`+`进行连接。Python从不将字符串的内容解释为数字。如果我们需要对字符串执行数学运算，我们需要先将它们转换为数字类型：

![](Images/d4bd788f-9566-4712-b1ab-6b09c31cc858.png)

# 列表

列表是最常用的内置数据结构之一，因为它们可以存储任意数量的不同数据类型。它们是对象的简单表示，并且由整数索引，从零开始，如我们在*字符串*中看到的那样。

下表包含了最常用的列表方法及其描述：

| **方法** | **描述** |
| --- | --- |
| `list(s)` | 返回序列`s`的列表。 |
| `s.append(x)` | 在列表`s`的末尾添加元素`x`。 |
| `s.extend(x)` | 在列表`s`的末尾添加列表`x`。 |
| `s.count(x)` | 返回列表`s`中`x`出现的次数。 |
| `s.index(x,[start],[stop])` | 返回最小的索引`i`，其中`s[i]==x`。我们可以为查找包括可选的开始和结束索引。 |
| `s.insert(i,e)` | 在索引`i`处插入`x`。 |
| `s.pop(i)` | 返回列表`s`中的元素`i`并将其移除。 |
| `s.remove(x)` | 从列表`s`中移除元素`x`。 |
| `s.reverse()` | 颠倒列表`s`的顺序。 |
| `s.sort(key,[reverse])` | 用可选的key对列表`s`进行排序并反转。 |

在Python中，与其他语言相比，列表的实现是不同的。Python不会创建变量的多个副本。例如，当我们将一个变量的值分配给另一个变量时，两个变量都指向存储值的相同内存地址。只有在变量改变其值时才会分配一个副本。这个特性使得Python在内存上更有效，因为它只在需要时才创建多个副本。

这对于可变的复合对象（如列表）有重要的影响。考虑以下代码：

![](Images/14c189e7-ddb4-4e04-89b7-84b8635d7bb6.png)

在上述代码中，`list1`和`list2`变量都指向同一内存位置。但是，当我们通过`list2`将`y`更改为`4`时，实际上也更改了`list1`指向的相同`y`变量。

`list`的一个重要特性是它可以包含嵌套结构；也就是说，列表可以包含其他列表。例如，在以下代码中，列表`items`包含了另外三个列表：

![](Images/43641e4c-00c8-455c-bb6c-e1ee22e484b7.png)

我们可以使用方括号运算符访问列表的值，并且由于列表是可变的，它们是就地复制的。以下示例演示了我们如何使用这一点来更新元素；例如，在这里我们将面粉的价格提高了20%：

![](Images/c19d6173-458d-4901-b494-d34600607c0f.png)

我们可以使用非常常见和直观的方法，即**列表推导**，从表达式中创建一个列表。它允许我们通过一个表达式直接创建一个列表。考虑以下示例，使用这个表达式创建了一个列表`l`：

![](Images/b27ed8e2-fff4-49b6-95c4-84808f5c1f5f.png)

列表推导可以非常灵活；例如，考虑以下代码。它基本上展示了执行函数组合的两种不同方式，其中我们将一个函数（`x*4`）应用于另一个函数（`x*2`）。以下代码打印出了两个列表，分别表示`f1`和`f2`的函数组合，首先使用for循环计算，然后使用列表推导计算：

```py
def f1(x): return x*2 
def f2(x): return x*4

lst=[]
for i in range(16):
   lst.append(f1(f2(i)))

print(lst)
print([f1(x) for x in range(64) if x in [f2(j) for j in range(16)]])

```

输出的第一行是来自于for循环结构。第二行是来自于列表推导表达式：

![](Images/39930806-6c10-4d9c-afbc-8a39002c8708.png)

列表推导也可以用来复制嵌套循环的操作，以更紧凑的形式。例如，我们将`list1`中的每个元素与彼此相乘：

![](Images/79b4fd28-f816-49d9-98de-145f8aa50ff3.png)

我们还可以使用列表推导与其他对象（如字符串）一起构建更复杂的结构。例如，以下代码创建了一个单词及其字母计数的列表：

![](Images/db9ed782-f9e2-45cf-a87f-96f4001a4224.png)

正如我们将看到的，列表构成了我们将要研究的许多数据结构的基础。它们的多功能性、易于创建和使用使它们能够构建更专业化和复杂的数据结构。

# 函数作为一等对象

在Python中，不仅数据类型被视为对象。函数和类都被称为一等对象，允许它们以与内置数据类型相同的方式进行操作。根据定义，一等对象具有以下特点：

+   在运行时创建

+   分配为变量或数据结构中

+   作为函数的参数传递

+   作为函数结果返回

在Python中，术语**一等对象**有点不准确，因为它暗示了某种层次结构，而所有Python对象本质上都是一等对象。

为了看看这是如何工作的，让我们定义一个简单的函数：

```py
def greeting(language): 
   if language=='eng': 
        return 'hello world'
      if language =='fr'
        return 'Bonjour le monde'
      else: return  'language not supported'

```

由于用户定义的函数是对象，我们可以将它们包含在其他对象中，比如列表中：

![](Images/68d69688-ec25-41e1-8c34-932ae3496c25.png)

函数也可以作为其他函数的参数使用。例如，我们可以定义以下函数：

![](Images/8ae8379b-84a1-4848-b182-2edb6099f0d5.png)

在这里，`callf()`接受一个函数作为参数，将语言变量设置为`'eng'`，然后调用带有语言变量作为参数的函数。我们可以看到，如果我们想要生成一个以各种语言返回特定句子的程序，这将是有用的。在这里，我们有一个设置语言的中心位置。除了我们的问候函数，我们还可以创建返回不同句子的类似函数。通过在一个地方设置语言，程序逻辑的其余部分不必担心这一点。如果我们想要改变语言，我们只需改变语言变量，其他一切都可以保持不变。

# 高阶函数

接受其他函数作为参数或返回函数的函数称为**高阶函数**。Python 3包含两个内置的高阶函数——`filter()`和`map()`。请注意，在Python的早期版本中，这些函数返回列表；在Python 3中，它们返回一个迭代器，使它们更加高效。`map()`函数提供了一种简单的方法来将每个项目转换为可迭代对象。例如，这是一种在序列上执行操作的高效、紧凑的方法。请注意使用`lambda`匿名函数：

![](Images/7315856e-a4c1-44e6-8072-af7c4f03d3f6.png)

同样，我们可以使用内置的filter函数来过滤列表中的项目：

![](Images/7a36c976-240b-448f-bf5a-bed8d610d781.png)

请注意，map和filter执行与列表推导可以实现的相同功能。除了在使用内置函数map和filter时，与列表推导相比，性能特性没有太大的区别，除了在不使用`lambda`运算符时稍微有一点性能优势。尽管如此，大多数风格指南建议使用列表推导而不是内置函数，可能是因为它们更容易阅读。

创建我们自己的高阶函数是函数式编程风格的一个标志。高阶函数的一个实际例子是以下演示的。在这里，我们将`len`函数作为sort函数的键传递。这样，我们可以按长度对单词列表进行排序：

![](Images/0d25a0df-964c-447a-8c22-a25b83b4eb96.png)

这是另一个不区分大小写的排序示例：

![](Images/56fc79db-0fb0-404e-9f1c-a839e62eca5e.png)

请注意`list.sort()`方法和内置的sorted函数之间的区别。`list.sort()`方法是列表对象的一个方法，它对现有的列表实例进行排序而不复制它。这种方法改变了目标对象并返回`None`。在Python中，一个重要的约定是改变对象的函数或方法返回`None`，以明确表示没有创建新对象并且对象本身已经改变。

另一方面，内置的sorted函数返回一个新的列表。它实际上接受任何可迭代对象作为参数，但它总是返回一个列表。*list sort*和*sorted*都接受两个可选的关键字参数。

对更复杂的结构进行排序的一个简单方法是使用lambda运算符来使用元素的索引进行排序，例如：

![](Images/2cb6f820-9f35-4208-8dc7-9abf5407197b.png)

在这里，我们按价格对项目进行了排序。

# 递归函数

递归是计算机科学中最基本的概念之一。在执行过程中，当一个函数调用自身一次或多次时，它被称为*递归*。循环迭代和递归在*循环*通过布尔条件或一系列元素重复执行语句的意义上是不同的，而递归则重复调用一个函数。在Python中，我们可以通过在其自身函数体内调用它来实现递归函数。为了防止递归函数变成无限循环，我们需要至少一个测试终止情况的参数来结束递归。这有时被称为基本情况。应该指出，递归与迭代不同。虽然两者都涉及重复，但迭代循环通过一系列操作，而递归重复调用一个函数。从技术上讲，递归是迭代的一种特殊情况，通常总是可以将迭代函数转换为递归函数，反之亦然。递归函数的有趣之处在于它们能够用有限的语句描述一个无限的对象。

以下代码应该演示了递归和迭代之间的区别。这两个函数都简单地打印出低和高之间的数字，第一个使用迭代，第二个使用递归：

![](Images/1511f7af-2b45-439a-bcfa-ab700239a3b9.png)

请注意，对于`iterTest`，迭代示例，我们使用while语句来测试条件，然后调用打印方法，最后递增低值。递归示例测试条件，打印，然后调用自身，在其参数中递增低变量。一般来说，迭代更有效率；然而，递归函数通常更容易理解和编写。递归函数还可用于操作递归数据结构，如链表和树，我们将会看到。

# 生成器和协程

我们可以创建不仅返回一个结果而且返回整个结果序列的函数，方法是使用yield语句。这些函数被称为**生成器**。Python包含生成器函数，这是一种创建迭代器的简单方法，特别适用于替代不可行的长列表。生成器产生项目而不是构建列表。例如，以下代码显示了为什么我们可能选择使用生成器而不是创建列表：

```py
#compares the running time of a list compared to a generator 
import time
#generator function creates an iterator of odd numbers between n and m 
def oddGen(n,m):
    while n<m:
      yield n
      n+=2

#builds a list of odd numbers between n and m 
def oddLst(n,m):
     lst=[]
     while n<m:
        lst.append(n)
        n+=2
     return lst

#the time it takes to perform sum on an iterator
t1=time.time()
sum(oddGen(1,1000000))
print("Time to sum an iterator: %f" % (time.time() - t1))
#the time it takes to build and sum a list
t1=time.time()
sum(oddLst(1,1000000))
print("Time to build and sum a list: %f" % (time.time() - t1))

```

这将打印出以下内容：

![](Images/8c1bd48e-7fc3-4d72-9e55-251c14fd0573.png)

正如我们所看到的，构建一个列表来进行这种计算需要更长的时间。使用生成器的性能改进是因为值是按需生成的，而不是保存在内存中作为列表。计算可以在所有元素生成之前开始，并且只有在需要时才生成元素。

在上面的例子中，sum方法在需要进行计算时将每个数字加载到内存中。这是通过生成器对象重复调用`__next__()`特殊方法实现的。生成器永远不会返回除`None`之外的值。

通常，生成器对象用于for循环。例如，我们可以利用前面代码中创建的`oddLst`生成器函数来打印出`1`到`10`之间的奇数：

```py
for i in oddLst (1,10):print(i)
```

我们还可以创建一个**生成器表达式**，它除了用括号替换方括号外，使用与列表推导相同的语法并执行与列表推导相同的操作。然而，生成器表达式不会创建一个列表；它创建一个**生成器对象**。这个对象不会创建数据，而是根据需要创建数据。这意味着生成器对象不支持`append()`和`insert()`等序列方法。

但是，您可以使用`list()`函数将生成器转换为列表：

![](Images/b912eedf-5db9-4363-a0c1-ac65aa3b96fb.png)

# 类和对象编程

类是创建新类型对象的一种方式，它们是面向对象编程的核心。一个类定义了一组在该类的所有实例之间共享的属性。通常，类是一组函数、变量和属性。

面向对象的范式是令人信服的，因为它为我们提供了一种具体的方式来思考和表示程序的核心功能。通过围绕对象和数据而不是动作和逻辑组织我们的程序，我们有了一种强大而灵活的方式来构建复杂的应用程序。当然，动作和逻辑仍然存在，但通过将它们体现在对象中，我们有了一种封装功能的方式，允许对象以非常具体的方式改变。这使得我们的代码更少容易出错，更容易扩展和维护，并能够模拟现实世界的对象。

在Python中使用class语句创建类。这定义了与一组类实例关联的一组共享属性。一个类通常由一些方法、类变量和计算属性组成。重要的是要理解，定义一个类本身并不会创建该类的任何实例。要创建一个实例，必须将一个变量分配给一个类。类主体由一系列在类定义期间执行的语句组成。在类内部定义的函数称为**实例方法**。它们通过将该类的实例作为第一个参数传递来对类实例应用一些操作。这个参数按照惯例被称为self，但它可以是任何合法的标识符。这里是一个简单的例子：

```py
class Employee(object):
    numEmployee=0
    def init (self,name,rate):
        self.owed=0 
        self.name=name
        self.rate=rate 
      Employee.numEmployee += 1

    def del (self): 
        Employee.numEmployee-=1

    def hours(self,numHours):
         self.owed += numHours*self.rate
         return ("%.2f hours worked" % numHours)

    def pay(self):
        self.owed=0
        return("payed %s " % self.name)
```

类变量，比如`numEmployee`，在类的所有实例之间共享值。在这个例子中，`numEmployee`用于计算员工实例的数量。请注意，`Employee`类实现了`__init__`和`__del__`特殊方法，我们将在下一节讨论。

我们可以通过以下方式创建`Employee`对象的实例，运行方法，并返回类和实例变量：

![](Images/3c5ad41c-37f0-4906-925a-5d2acef07238.png)

# 特殊方法

我们可以使用`dir(object)`函数获取特定对象的属性列表。以两个下划线开始和结束的方法称为**特殊方法**。除了以下例外，特殊方法通常由Python解释器调用，而不是由程序员调用；例如，当我们使用`+`运算符时，我们实际上是在调用`to _add_()`。例如，我们可以使用`len(my_object)`而不是使用`my_object._len_()`；在字符串对象上使用`len()`实际上要快得多，因为它返回表示对象在内存中的大小的值，而不是调用对象的`_len_`方法。

作为常见做法，我们在程序中实际调用的唯一特殊方法是`_init_`方法，以调用我们自己的类定义中的超类的初始化程序。强烈建议不要使用双下划线语法来定义自己的对象，因为可能会与Python自己的特殊方法产生当前或将来的冲突。

然而，我们可能希望在自定义对象中实现特殊方法，以赋予它们一些内置类型的行为。在下面的代码中，我们创建了一个实现了`_repr_`方法的类。这个方法创建了一个对象的字符串表示，对于检查目的很有用：

```py
class my_class():
    def __init__(self,greet):
        self.greet=greet 
    def __repr__(self):
        return 'a custom object (%r) ' % (self.greet)
```

当我们创建这个对象的实例并进行检查时，我们可以看到我们得到了我们定制的字符串表示。注意使用`%r`格式占位符返回对象的标准表示。这是有用的最佳实践，因为在这种情况下，它向我们显示`greet`对象是由引号表示的字符串：

![](Images/d231a9ec-fcf0-4387-9c07-2b9f3fecddaf.png)

# 继承

继承是面向对象编程语言中最强大的功能之一。它允许我们从其他类继承功能。通过继承，可以创建一个修改现有类行为的新类。继承意味着如果通过继承另一个类创建一个类的对象，那么该对象将具有两个类的所有功能、方法和变量；即父类和新类。我们继承功能的现有类称为父类/基类，新类称为派生/子类。

继承可以用一个非常简单的例子来解释——我们创建一个`employee`类，具有员工姓名和每小时支付的费率等属性。现在我们可以创建一个新的`specialEmployee`类，继承自`employee`类的所有属性。

在Python中，继承是通过在类定义中传递继承的类作为参数来完成的。它经常用于修改现有方法的行为。

`specialEmployee`类的实例与`Employee`实例相同，只是`hours()`方法发生了变化。例如，在下面的代码中，我们创建一个新的`specialEmployee`类，它继承了`Employee`类的所有功能，并且还改变了`hours()`方法：

```py
class specialEmployee(Employee):
    def hours(self,numHours):
        self.owed += numHours*self.rate*2 
        return("%.2f hours worked" % numHours)
```

为了子类定义新的类变量，需要定义一个`__init__()`方法，如下所示：

```py
class specialEmployee(Employee):
    def __init__(self,name,rate,bonus):
        Employee.__init__(self,name,rate)    #calls the base classes                                                     
        self.bonus=bonus

    def   hours(self,numHours):
        self.owed += numHours*self.rate+self.bonus     
        return("%.2f hours worked" % numHours)

```

注意，基类的方法不会自动调用，派生类需要调用它们。我们可以使用内置的`isinstance(obj1,obj2)`函数测试类成员资格。如果`obj1`属于`obj2`的类或任何派生自`obj2`的类，则返回`True`。让我们考虑以下示例来理解这一点，其中`obj1`和`obj2`分别是`Employee`和`specialEmployee`类的对象：

```py
#Example issubclass() to check whether a class is a subclass of another class  
#Example isinstance() to check if an object belongs to a class or not 

print(issubclass(specialEmployee, Employee))
print(issubclass(Employee, specialEmployee)) 

d = specialEmployee("packt", 20, 100) 
b = Employee("packt", 20)  
print(isinstance(b, specialEmployee)) 
print(isinstance(b, Employee)) 

# the output prints  
True 
False 
False 
True
```

通常，所有方法都在类内定义的实例上操作。但这不是必需的。有两种类型的方法——**静态方法**和**类方法**。静态方法与类方法非常相似，主要绑定到类，而不是与类的对象绑定。它在类内定义，不需要类的实例来执行。它不对实例执行任何操作，并且使用`@staticmethod`类装饰器定义。静态方法无法访问实例的属性，因此它们最常见的用法是作为一种方便的方式来将实用函数组合在一起。

类方法在类本身上操作，不与实例一起工作。类方法的工作方式与类变量相关联，而不是该类的实例。类方法是使用`@classmethod`装饰器定义的，并且在类中与实例方法区分开。它作为第一个参数传递，按照惯例命名为`cls`。`exponentialB`类继承自`exponentialA`类，并将基类变量更改为`4`。我们也可以运行父类的`exp()`方法如下：

```py
class exponentialA(object):
    base=3
    @classmethod
    def exp(cls,x):
        return(cls.base**x) 

    @staticmethod   def addition(x, y):  
        return (x+y)

class exponentialB(exponentialA):
        base=4

a = exponentialA() 
b= a.exp(3) 
print("the value: 3 to the power 3 is", b) 
print('The sum is:', exponentialA.addition(15, 10)) 
print(exponentialB.exp(3))

#prints the following output
the value: 3 to the power 3 is 27 
The sum is: 25 
64
```

静态方法和类方法之间的区别在于，静态方法对类一无所知，它只处理参数，而类方法仅与类一起工作，其参数始终是类本身。

类方法可能有几个有用的原因。例如，因为子类继承了其父类的所有相同特性，所以有可能会破坏继承的方法。使用类方法是定义确切运行哪些方法的一种方式。

# 数据封装和属性

除非另有规定，所有属性和方法都可以自由访问。这也意味着从基类中定义的所有内容都可以从派生类中访问。当我们构建面向对象的应用程序时，这可能会导致问题，因为我们可能希望隐藏对象的内部实现。这可能会导致派生类中定义的对象与基类之间的命名空间冲突。为了防止这种情况，我们使用双下划线定义私有属性，例如`__privateMethod()`。这些方法名称会自动更改为`__Classname_privateMethod()`，以防止与基类中定义的方法发生命名冲突。请注意，这并不严格隐藏私有属性，而只是提供了一种防止命名冲突的机制。

建议在使用类**属性**定义可变属性时使用私有属性。属性是一种属性，它在调用时不返回存储的值，而是计算其值。例如，我们可以使用以下方式重新定义`exp()`属性：

```py
class Bexp(Aexp):
    base=3
    def exp(self):
        return(x**cls.base)
```

# 摘要

本章为我们提供了Python编程的基本基础和介绍。我们描述了Python提供的各种数据结构和算法。我们涵盖了变量的使用，列表，一些控制结构，并学习了如何使用条件语句。我们还讨论了Python中如何使用函数。我们讨论了各种类型的对象，以及Python语言面向对象的一些内容。我们创建了自己的对象并从中继承。

Python还提供了更多功能。当我们准备在后面的章节中研究一些算法的实现时，下一章将重点介绍数字、序列、映射和集合。这些也是Python中的数据类型，在为一系列操作组织数据时非常有用。

# 进一步阅读

+   *学习Python* 作者：Fabrizio Romano: [https://www.packtpub.com/application-development/learning-python](https://www.packtpub.com/application-development/learning-python)。
