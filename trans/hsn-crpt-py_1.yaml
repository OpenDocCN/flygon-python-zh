- en: Obfuscation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混淆
- en: Python is the best language to start with if you are a beginner, which is what
    makes it so popular. You can write powerful code with just a few lines, and most
    importantly, you can handle arbitrarily large integers with complete precision.
    This book covers essential cryptography concepts; classic encryption methods,
    such as the Caesar cipher and XOR; the concepts of confusion and diffusion, which
    determine how strong a crypto system is; hiding data with obfuscation; hashing
    data for integrity and passwords; and strong encryption methods and attacks against
    these methods, including the padding oracle attack. You do not need to have programming
    experience to learn any of this. You don't need any special computer; any computer
    that can run Python can do these projects. We'll not be inventing new encryption
    techniques just for learning how to use standard pre-existing ones that don't
    require anything more than very basic algebra.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python是最适合初学者的语言，这也是它如此受欢迎的原因。您可以用几行代码编写强大的代码，最重要的是，您可以完全精确地处理任意大的整数。本书涵盖了基本的密码学概念；经典的加密方法，如凯撒密码和XOR；混淆和扩散的概念，决定了加密系统的强度；使用混淆隐藏数据；对数据进行哈希以确保完整性和密码；以及强大的加密方法和对这些方法的攻击，包括填充预言攻击。您不需要有编程经验来学习这些内容。您不需要任何特殊的计算机；任何可以运行Python的计算机都可以完成这些项目。我们不会发明新的加密技术，只是学习如何使用标准的现有技术，这些技术不需要任何比基本代数更复杂的东西。
- en: We will first deal with obfuscation, the basic idea of what encryption is, and
    old-fashioned encryption techniques that hide data to make it more difficult to
    read. This latter process is one of the basic activities that encryption modules
    use in combination with other methods to make stronger, more modern encryption
    techniques.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先处理混淆，即加密的基本概念，以及隐藏数据以使其更难阅读的老式加密技术。后一种过程是加密模块与其他方法结合使用以制定更强大、更现代的加密技术的基本活动之一。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: About cryptography
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于密码学
- en: Installing and setting up Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和设置Python
- en: Caesar cipher and ROT13
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凯撒密码和ROT13
- en: base64 encoding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: base64编码
- en: XOR
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XOR
- en: About cryptography
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于密码学
- en: The term crypto has become overloaded recently with the introduction of all
    currencies, such as Bitcoin, Ethereum, and Litecoin. When we refer to crypto as
    a form of protection, we are referring to the concept of cryptography applied
    to communication links, storage devices, software, and messages used in a system.
    Cryptography has a long and important history in protecting critical systems and
    sensitive information.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，随着所有货币（如比特币、以太坊和莱特币）的引入，密码一词变得过载。当我们将密码称为一种保护形式时，我们指的是应用于系统中的通信链路、存储设备、软件和消息的密码学概念。密码学在保护关键系统和敏感信息方面具有悠久而重要的历史。
- en: During World War II, the Germans used Enigma machines to encrypt communications,
    and the Allies went to great lengths to crack the encryption. Enigma machines
    used a series of rotors that transformed plaintext to ciphertext, and by understanding
    the position of the rotors, the Allies were able to decrypt the ciphertext into
    plaintext. This was a momentous achievement but took significant manpower and
    resources. Today it is still possible to crack certain encryption techniques;
    however, it is often more feasible to attack other aspects of cryptographic systems,
    such as the protocols, the integration points, or even the libraries used to implement
    cryptography.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次世界大战期间，德国人使用Enigma机器加密通信，而盟军则竭尽全力破译这种加密。Enigma机器使用一系列转子将明文转换为密文，通过了解转子的位置，盟军能够将密文解密为明文。这是一个重大的成就，但需要大量的人力和资源。今天仍然有可能破解某些加密技术；然而，攻击加密系统的其他方面，如协议、集成点甚至用于实现加密的库，往往更为可行。
- en: Cryptography has a rich history; however, nowadays, you will come across new
    concepts, such as blockchain, that can be used as a tool to help secure the IoT.
    Blockchain is based on a set of well-known cryptographic primitives. Other new
    directions in cryptography include quantum-resistant algorithms, which hold up
    against a theorized onslaught of quantum computers and quantum key distributions.
    They use protocols such as BB84 and BB92 to leverage the concepts of quantum entanglement
    and create good-quality keys for using classical encryption algorithms.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学有着悠久的历史；然而，如今，您将遇到新概念，如区块链，可以用作帮助保护物联网的工具。区块链基于一组众所周知的密码原语。密码学的其他新方向包括抗量子算法，这些算法可以抵御理论上的量子计算机的攻击，并使用诸如BB84和BB92之类的协议来利用量子纠缠的概念，并为使用经典加密算法创建高质量的密钥。
- en: Installing and setting up Python
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和设置Python
- en: Python has never been easy to install. In order to proceed, let's make sure
    that we have set up Python on our machine. We will see how to use Python on macOS
    or Linux and how to install it on Windows.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python从来都不容易安装。为了继续，请确保我们已经在我们的机器上设置了Python。我们将看到如何在macOS或Linux上使用Python以及如何在Windows上安装它。
- en: Using Python on Mac or Linux
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Mac或Linux上使用Python
- en: 'On a macOS or Linux system, you do not need to install Python because it is
    already included. You just need to open a Terminal window and enter the `python`
    command. This will put you in an interactive mode where you can execute `python`
    commands one by one. You can close the interactive mode by executing the `exit()` command.
    So, basically, to create a script, we use the `nano` text editor followed by the
    name of the file. We then enter `python` commands and save the file. You can then
    run the script with `python` followed by the script name. So, let''s see how to
    use Python on macOS or Linux in the following steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS或Linux系统上，您无需安装Python，因为它已经包含在内。您只需要打开一个终端窗口并输入`python`命令。这将使您进入交互模式，在这里您可以逐个执行`python`命令。您可以通过执行`exit()`命令来关闭交互模式。因此，基本上，要创建一个脚本，我们使用`nano`文本编辑器，然后输入文件名。然后输入`python`命令并保存文件。然后可以使用`python`后跟脚本名称来运行脚本。因此，让我们看看如何在macOS或Linux上使用Python，以下是具体步骤：
- en: 'Open the Terminal on a macOS or Linux system and run the `python` command.
    This opens an interactive mode of Python, as shown in the following screenshot:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在macOS或Linux系统上打开终端并运行`python`命令。这将打开Python的交互模式，如下面的截图所示：
- en: '![](../images/00005.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00005.jpeg)'
- en: 'When you use the `print` command, it prints `Hello` right away:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你使用`print`命令时，它会立即打印`Hello`：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will then leave with the following command:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用以下命令离开：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As mentioned before, to use Python in interactive mode, we will enter the command as
    shown:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，要在交互模式下使用Python，我们将输入如下命令：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `hello.py` file, we can write commands like this:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`hello.py`文件中，我们可以写入如下命令：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save the file by pressing *Ctrl* + *X* followed by *Y* and *Enter* only if you've
    modified it.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl* + *X*保存文件，然后只有在你修改了文件后才按*Y*和*Enter*。
- en: 'Now, let''s type Python followed by the the script name:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们输入Python，然后输入脚本名称：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you run it, you will get the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，你会得到以下输出：
- en: '![](../images/00006.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00006.jpeg)'
- en: The preceding command runs the script and prints out `HELLO`; that's all you
    have to do if you have a macOS or Linux system.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令运行脚本并打印出`HELLO`；如果你有macOS或Linux系统，这就是你所需要做的。
- en: Installing Python on Windows
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上安装Python
- en: If you have Windows, you have to download and install Python.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Windows，你需要下载并安装Python。
- en: 'Here are the steps which you need to follow:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你需要遵循的步骤：
- en: Download Python from [https://www.python.org/downloads/](https://www.python.org/downloads/)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://www.python.org/downloads/](https://www.python.org/downloads/)下载Python
- en: Run it in a Command Prompt window
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符窗口中运行它
- en: Start interactive mode with Python
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用Python开始交互模式
- en: Close with `exit()`
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`exit()`关闭
- en: To create a script, you just use Notepad, enter the text, save the file with
    *Ctrl* + *S*, and then run it with `python` followed by the script name. Let's
    get started with the installation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个脚本，你只需使用记事本，输入文本，用*Ctrl* + *S*保存文件，然后用`python`后跟脚本名称运行它。让我们开始安装。
- en: Open the Python page using link given previously and download Python. It offers
    you various versions of Python. In this book, we will use Python 2.7.12.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前给出的链接打开Python页面并下载Python。它为您提供各种版本的Python。在本书中，我们将使用Python 2.7.12。
- en: 'Sometimes, you can''t install it right away because Windows marks it as untrusted:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你无法立即安装它，因为Windows将其标记为不受信任：
- en: You have to unblock it in the properties first so that it will run, and run
    the installer
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须先在属性中解除阻止，这样它才能运行，并运行安装程序
- en: If you go through the steps of the installer, you'll see an optional step named
    Add python.exe to path. You need to choose that selection
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你按照安装程序的步骤进行时，你会看到一个名为Add python.exe to path的可选步骤。你需要选择那个选项
- en: The purpose of that selection is to make it so Python can run from the command
    line in a Terminal window, which is called Command Prompt on Windows.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该选项的目的是使Python能够在终端窗口中从命令行运行，Windows上称为命令提示符。
- en: 'Now let''s proceed with our installation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续我们的安装：
- en: 'Open the Terminal and type the following command:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并输入以下命令：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you run it, you can see that it works. So, now we will type a command:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行它时，你会看到它有效。所以，现在我们将输入一个命令：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Refer to the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下截图：
- en: '![](../images/00007.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00007.jpeg)'
- en: We can exit using the `exit()` command as shown earlier.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用之前显示的`exit()`命令退出。
- en: 'Now, if we want to make a script, we type the following command:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们想要制作一个脚本，我们输入以下命令：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This opens up Notepad:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开记事本：
- en: '![](../images/00008.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00008.jpeg)'
- en: 'We want to create a file. In that file, we enter the following command:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要创建一个文件。在文件中，我们输入以下命令：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, save and close it. In order to run it, we need to enter the following
    command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后保存并关闭它。为了运行它，我们需要输入以下命令：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It runs and prints `HELLO`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它运行并打印`HELLO`。
- en: 'Usually, when you install Python on Windows, it fails to correct the path,
    so you have to execute the following commands to create a symbolic link; otherwise,
    Python will not start correctly from the command line:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你在Windows上安装Python时，它无法正确设置路径，所以你必须执行以下命令来创建一个符号链接；否则，Python将无法从命令行正确启动：
- en: '`**cd c: \Windows**`'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`**cd c: \Windows**`'
- en: '`**mklink /H python.exe**`'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`**mklink /H python.exe**`'
- en: '`**c: \python27\python.exe**`'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`**c: \python27\python.exe**`'
- en: In the next section, we will look at the Caesar cipher and ROT13 obfuscation
    techniques.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看凯撒密码和ROT13混淆技术。
- en: Caesar cipher and ROT13
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 凯撒密码和ROT13
- en: In this section, we will explain what a Caesar cipher is and how to implement
    it in Python. Then, we will consider other `shift` values, modular arithmetic,
    and ROT13.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释什么是凯撒密码以及如何在Python中实现它。然后，我们将考虑其他`shift`值，模运算和ROT13。
- en: 'A Caesar cipher is an ancient trick where you just move every letter forward
    three characters in the alphabet. Here is an example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码是一个古老的技巧，你只需将字母向字母表中的后三个字符移动。这是一个例子：
- en: 'Plaintext: `ABCDEFGHIJKLMNOPQRSTUVWXYZ`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明文：`ABCDEFGHIJKLMNOPQRSTUVWXYZ`
- en: 'Ciphertext: `DEFGHIJKLMNOPQRSTUVWXYZABC`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密文：`DEFGHIJKLMNOPQRSTUVWXYZABC`
- en: So, `HELLO` becomes `KHOOR`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`HELLO`变成了`KHOOR`。
- en: To implement it, we're going to use the `string.find()` method. The interactive
    mode of Python is good for testing new methods, hence it's easy to create a string. You
    can make a very simple script to implement the Caesar cipher with a string named
    `alpha` for alphabet. You can then take input from the user, which is the plaintext
    method, then set a value, `n`, which equals the length of the string, and the
    string out is equal to an empty string. We then have a loop that goes through
    `n` repetitions, finding the character from string in and then finding the location
    of that character in the `alpha` string. It then prints out those three values
    so that we can make sure that the script is working correctly, then it adds `3`
    to `loc` (location) and puts the corresponding character in string out, and again
    prints out partial values so that we can see that the script is working correctly.
    At the end, we print our final output. Adding extra print statements is a very
    good way to begin your programming because you can detect mistakes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现它，我们将使用`string.find()`方法。Python的交互模式非常适合测试新方法，因此很容易创建一个字符串。你可以制作一个非常简单的脚本来实现凯撒密码，使用一个名为`alpha`的字符串来表示字母表。然后你可以从用户那里获取输入，这就是明文方法，然后设置一个值`n`，它等于字符串的长度，字符串输出等于一个空字符串。然后我们有一个循环，它重复了`n`次，找到字符串中的字符，然后找到该字符在`alpha`字符串中的位置。然后打印出这三个值，以便我们可以确保脚本正常工作，然后它将`loc`（位置）加上`3`，并将相应的字符放入字符串输出中，然后再次打印出部分值，以便我们可以看到脚本是否正常工作。最后，我们打印出最终的输出。添加额外的打印语句是开始编程的一个很好的方法，因为你可以发现错误。
- en: Implementing the Caesar cipher in Python
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中实现凯撒密码
- en: 'Let''s go ahead and open the Terminal and follow these steps to implement Caesar
    cipher in Python:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续打开终端，并按照以下步骤在Python中实现凯撒密码：
- en: 'We will use Python in interactive mode first and then make a string that just
    has some letters in order to test this method:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在Python的交互模式下使用它，然后制作一个只包含一些字母的字符串来测试这种方法：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Because we understand how the string methods work, we''ll exit and go into
    the `nano` text editor to look at the first version of our script:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们了解了字符串方法的工作原理，我们将退出并进入`nano`文本编辑器，查看我们脚本的第一个版本：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you run the command, you will get the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行这个命令时，你会得到以下代码：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can see the alphabet and the input from the user in the script. You calculate
    the length of the string, and for each character, `C` is going to be the one character
    on processing, `loc` will be the numerical location of that character, `newloc`
    will be `loc` plus `3`, and we can then add that character to string out. Let's
    see this.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在脚本中看到字母表和用户输入。你计算字符串的长度，对于每个字符，`C`将是正在处理的一个字符，`loc`将是该字符的数字位置，`newloc`将是`loc`加上`3`，然后我们可以将该字符添加到字符串输出中。让我们看看这个。
- en: 'Leave using *Ctrl*+*X* and then enter the following command:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Ctrl*+*X*离开，然后输入以下命令：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When you run this command, you will get the following output:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行这个命令时，你会得到以下输出：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we enter `HELLO`, it prints out the correct answer of `KHOOR`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们输入`HELLO`，它会打印出`KHOOR`的正确答案：
- en: '![](../images/00009.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00009.jpeg)'
- en: When we run this script, it takes the input of `HELLO` and it breaks it up character
    by character so that it processes each character on a separate line. `H` is found
    to be the 7th character, so adding `3` gives me `10`, which results in `K`. It
    shows us character by character how it works. So, the first version of the script
    is a success.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个脚本时，它接受`HELLO`的输入，并将其逐个字符地分解开来，以便对每个字符进行处理。`H`被发现是第7个字符，所以加上`3`得到`10`，结果是`K`。它逐个字符地显示了它的工作原理。因此，脚本的第一个版本是成功的。
- en: To clean the code further, we will remove the unnecessary `print` statements
    and switch to a `shift` variable. We will create a variable `shift` variable.
    Which also comes from raw inputs, but we have to convert it to an integer because
    raw input is interpreted as `text` as you can't add `text` to an integer. This
    is the only change in the script that follows. If you give it a `shift` value
    of `3`, you get `KHOOR`; if you give it a `shift` value of `10`, you get `ROVVY`; but
    if you put in a `shift` value of `14`, it crashes, saying string index out of
    range. Here, the problem is, we've added multiple times to the `loc` variable,
    and eventually, we move past `Z`, and the variable is no longer valid. In order
    to improve that, after adding something to the variable, we'll check to see whether
    it's greater than or equal to `26`, and whether `26` can be subtracted from it.
    Once you run this, you can use a shift of `14`, which will work. We can use a
    shift of `24`, and it works too. However, if we use a shift of `44`, it's out
    of range again. This is because just subtracting `26` once when it's over `26`
    is not really enough, and the right solution here is modular arithmetic. If we
    put `% 26`, it will calculate the number modulus `26`, which will prevent it from
    ever leaving the range of `0` through `25`. It will divide it by `26` and keep
    only the remainder, as expected in this case. We're going to see the modular function
    many more times as we move forward in cryptography. You can put in any `shift` value
    of your choice, such as `300`, and it will never crash, but will turn that into
    a number between `0` and `25`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步清理代码，我们将删除不必要的`print`语句并切换到`shift`变量。我们将创建一个`shift`变量。它也来自原始输入，但我们必须将其转换为整数，因为原始输入被解释为`文本`，您不能将`文本`添加到整数。这是接下来的脚本中唯一的更改。如果您给它一个`3`的`shift`值，您会得到`KHOOR`；如果您给它一个`10`的`shift`值，您会得到`ROVVY`；但如果您输入一个`14`的`shift`值，它会崩溃，显示字符串索引超出范围。这里的问题是，我们已经多次添加到`loc`变量，最终，我们超过了`Z`，变量就不再有效了。为了改进这一点，在向变量添加内容后，我们将检查它是否大于或等于`26`，以及是否可以从中减去`26`。一旦您运行这个，您可以使用`14`的移位，这将起作用。我们可以使用`24`的移位，它也可以工作。但是，如果我们使用`44`的移位，它又超出范围了。这是因为当超过`26`时，仅仅减去`26`一次并不够，正确的解决方案是模运算。如果我们加上`％26`，它将计算数字模`26`，这将防止它离开`0`到`25`的范围。它将除以`26`并保留余数，这在这种情况下是预期的。随着我们在密码学中继续前进，我们将看到模函数更多次。您可以输入任何您选择的`shift`值，比如`300`，它永远不会崩溃，但会将其转换为`0`到`25`之间的数字。
- en: 'Let''s see how the script works with other shift values:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看脚本如何处理其他移位值：
- en: 'Take a look at the script Caesar:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看凯撒脚本：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When you run it, you will get the following:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它时，您将得到以下内容：
- en: '![](../images/00010.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00010.jpeg)'
- en: 'This is the script that allows us to vary the `shift` value but does not handle
    anything about the `shift` value getting too large. Let''s run the following command:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个允许我们改变`shift`值但不处理`shift`值变得太大的脚本。让我们运行以下命令：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you enter `HELLO` and give it a shift of `3`, it''s fine, but if we run
    it again and give it a shift of `20`, it crashes:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入`HELLO`并给它一个`3`的移位，它是好的，但如果我们再次运行它并给它一个`20`的移位，它就会崩溃：
- en: '![](../images/00011.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00011.jpeg)'
- en: So, as expected, there are some limitations in this one.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，预料之中，这个有一些限制。
- en: 'Let''s move on to `caesar3`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续看`caesar3`：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After running it, we get the following output:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行后，我们得到以下输出：
- en: '![](../images/00012.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00012.jpeg)'
- en: '`Caesar3` attempts to solve that problem by catching it if we know that the
    addition causes it to be greater than or equal to `26` and subtracting `26` from
    it.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Caesar3`试图通过捕捉它来解决这个问题，如果我们知道加法导致它大于或等于`26`，则从中减去`26`。'
- en: 'Let''s run the following command:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行以下命令：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will give it `shift` characters and a `shift` of `20`, and it will be fine:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将给它`shift`字符和`shift`为`20`，它会很好：
- en: '![](../images/00013.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00013.jpeg)'
- en: 'If we give it a shift of `40`, it does not work:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们给它一个`40`的偏移量，它就不起作用：
- en: '![](../images/00014.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00014.jpeg)'
- en: There is some improvement, but we are still not able to handle any value of
    `shift`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些改进，但我们仍然无法处理任何`shift`值。
- en: 'Let''s go up to `caesar4`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续到`caesar4`：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you run the command, you will get this:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行命令时，您将得到这个：
- en: '![](../images/00015.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00015.jpeg)'
- en: This is the one that uses modular arithmetic with the percent sign, and that's
    not going to fail.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用百分号进行模运算的脚本，这不会失败。
- en: 'Let''s run the following command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行以下命令：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you run the command, you will get this:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行命令时，您将得到这个：
- en: '![](../images/00016.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00016.jpeg)'
- en: This is the script that handles all the values of the Caesar shift.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理所有凯撒移位值的脚本。
- en: ROT13
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROT13
- en: 'ROT13 is nothing more than a Caesar cipher with a `shift` equal to `13` characters.
    In the script that follows, we will hardcode the shift to be `13`. If you run
    one cycle of ROT13, it changes `HELLO` to `URYYB`, and if you encrypt it again
    with the same process, putting in that `URYYB`, it''ll turn back into `HELLO`,
    because the first shift is just by `13` characters and shifting by another `13`
    characters takes the total shift to `26`, which wraps right around, and that is
    what makes this one useful and important:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ROT13只不过是一个`shift`等于`13`个字符的凯撒密码。在接下来的脚本中，我们将硬编码移位为`13`。如果您运行一次ROT13，它会将`HELLO`更改为`URYYB`，如果您再次使用相同的过程对其进行加密，输入`URYYB`，它将变回`HELLO`，因为第一个移位只是`13`个字符，再移位`13`个字符将总移位变为`26`，这样就可以很好地包裹，这就是这个脚本有用和重要的地方：
- en: 'Now let''s look at the ROT13 script using the following command:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看一下使用以下命令的ROT13脚本：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When you run the preceding command, you can see the script file:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行上述命令时，您可以看到脚本文件：
- en: '![](../images/00017.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00017.jpeg)'
- en: 'It''s just exactly equal to our last Caesar cipher shift, with a script with
    a shift of `13`. Run the script as shown here:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它与我们上次凯撒密码移位的脚本完全相同，移位为`13`。按照这里所示的脚本运行：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following is the output:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![](../images/00018.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00018.jpeg)'
- en: 'If we enter the message `URYYB` and run that, it turns back into `HELLO`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们输入消息`URYYB`并运行它，它会变回`HELLO`：
- en: '![](../images/00019.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00019.jpeg)'
- en: This is important because there are quite a few cryptographic functions that
    have this property; where you encrypt something once and encrypt it again, you
    reverse the process. Instead of making it more encrypted, it becomes unencrypted.
    In the next section, we will cover base64 encoding.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为有很多具有这种属性的加密函数；当你加密一次然后再次加密时，你会反转这个过程。它不会变得更加加密，而是变得未加密。在下一节中，我们将涵盖base64编码。
- en: base64 encoding
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: base64编码
- en: We will now discuss encoding ASCII data as bytes and base64 encoding these bytes.
    We will also cover base64 encoding for binary data and decoding to get back to
    the original input.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将讨论将ASCII数据编码为字节，并对这些字节进行base64编码。我们还将涵盖二进制数据的base64编码和解码，以恢复原始输入。
- en: ASCII data
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASCII数据
- en: 'In ASCII, each character turns into one byte:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASCII中，每个字符变成一个字节：
- en: '`A` is `65` in base `10`, and in binary, it is `0b01000001`. Here, you have
    `0` in the most significant bit because there''s no `128`, then you have `1` in
    the next bit for `64` and `1` in the end, so you have *64 + 1=65*.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A`在十进制中是`65`，在二进制中是`0b01000001`。这里，你在最高位没有`128`，然后在下一个位上有`64`的`1`，最后有`1`，所以你有*64
    + 1=65*。'
- en: The next is `B` with base `66` and `C` with base `67`. The binary for `B` is
    `0b01000010`, and for `C`, it is `0b01000011`.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是`B`，基数为`66`，`C`，基数为`67`。`B`的二进制是`0b01000010`，`C`的二进制是`0b01000011`。
- en: 'The three-letter string `ABC` can be interpreted as a 24-bit string that looks
    like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 三个字母的字符串`ABC`可以解释为一个24位的字符串，看起来像这样：
- en: '![](../images/00020.gif)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00020.gif)'
- en: We've added these blue lines just to show where the bytes are broken out. To
    interpret that as base64, you need to break it into groups of 6 bits. 6 bits have
    a total of 64 combinations, so you need 64 characters to encode it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了这些蓝线只是为了显示字节的分隔位置。要将其解释为base64，你需要将其分成6位一组。6位有64种组合，所以你需要64个字符来编码它。
- en: 'The characters used are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的字符如下：
- en: '![](../images/00021.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00021.jpeg)'
- en: 'We use the capital letters for the first 26, lowercase letters for another
    26, the digits for another 10, which gets you up to 62 characters. In the most
    common form of base64, you use `+` and `/` for the last two characters:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用大写字母表示前26个，小写字母表示另外26个，数字表示另外10个，总共62个字符。在最常见的base64形式中，最后两个字符使用`+`和`/`：
- en: '![](../images/00022.gif)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00022.gif)'
- en: 'If you have an ASCII string of three characters, it turns into 24 bits interpreted
    as 3 groups of 8\. If you just break them up into 4 groups of 6, you have 4 numbers
    between 0 and 63, and in this case, they turn into `Q`, `U`, `J`, and `D`. In
    Python, you just have a string followed by the command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个ASCII字符串有三个字符，它变成24位，解释为3组8位。如果你把它们分成4组6位，你有4个0到63之间的数字，在这种情况下，它们变成`Q`、`U`、`J`和`D`。在Python中，你只需要一个字符串，后面跟着命令：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will do the encoding. Then add an extra carriage return at the end, which
    neither matters nor affects the decoding.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这将进行编码。然后在最后添加一个额外的回车，这既不重要也不影响解码。
- en: What if you have something other than a group of 3 bytes?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有的不是3个字节的组合呢？
- en: The `=` sign is used to indicate padding if the input string length is not a
    multiple of 3 bytes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 等号`=`用于指示填充，如果输入字符串长度不是3个字节的倍数。
- en: If you have four bytes for the input, then the base64 encoding ends with two
    equals signs, just to indicate that it had to add two characters of padding. If
    you have five bytes, you have one equals sign, and if you have six bytes, then
    there's no equals signs, indicating that the input fit neatly into base64 with
    no need for padding. The padding is null.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入有四个字节，那么base64编码以两个等号结束，只是表示它必须添加两个填充字符。如果有五个字节，就有一个等号，如果有六个字节，那么就没有等号，表示输入完全适合base64，不需要填充。填充是空的。
- en: 'You take `ABCD` and encode it and then you take `ABCD` with explicit byte of
    zero. `x00` means a single character with eight bits of zero, and you get the
    same result with just an extra `A` and one equals, and if you fill it out all
    the way with two bytes of zero, you get capital `A` all the way. Remember: a capital
    `A` is the very first character in `base64`. It stands for six bits of zero.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你取`ABCD`进行编码，然后你取`ABCD`并加上一个显式的零字节。`x00`表示一个具有八位零的单个字符，你得到相同的结果，只是多了一个`A`和一个等号，如果你用两个零字节填满它，你会得到大写的`A`。记住：大写的`A`是`base64`中的第一个字符。它代表六位零。
- en: 'Let''s take a look at base64 encoding in Python:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Python中的base64编码：
- en: 'We will start `python` up and make a string. If you just make a string with
    quotes and press *Enter*, it will print it in immediate mode:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将启动`python`并创建一个字符串。如果你只是用引号创建一个字符串并按*Enter*，它会立即打印出来：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Python will print the result of each calculation automatically. If we encode
    that with `base64`, we will get this:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python会自动打印每次计算的结果。如果我们用`base64`对其进行编码，我们会得到这个结果：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It turns into `QUJD` with an extra courage return at the end and if we make
    it longer:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它变成`QUJD`，最后有一个额外的回车，如果我们让它更长：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This has two equals signs because we started with four bytes, and it had to
    add two more to make it a multiple of three:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里有两个等号，因为我们从四个字节开始，它必须再添加两个字节使其成为3的倍数：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With a five-byte input, we have one equals sign; and with six bytes of input,
    we have no more equal signs, instead, we have a total of eight characters with
    `base64`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有五个字节的输入，我们有一个等号；有六个字节的输入，我们没有等号，而是一共有八个字符使用`base64`。
- en: 'Let''s go back to `ABCD` with the two equals signs:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到带有两个等号的`ABCD`：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can see how the padding was done by putting it in explicitly here:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到填充是如何通过在这里明确放置它来完成的：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There's a first byte of zero, and now we get another single equals sign.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个零的第一个字节，现在我们得到另一个单个等号。
- en: 'Let''s put in a second byte of zero:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再加入一个字节的零：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have no padding here, and we see that the last characters are all `A`, indicating
    that there's been a filling of binary zeros.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有填充，我们看到最后的字符都是`A`，表明已经填充了二进制零。
- en: Binary data
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制数据
- en: 'The next issue is handling binary data. Executable files are binary and not
    ASCII. Also, images, movies, and many other files have binary data. ASCII data
    always starts with a zero as the first bit, but `base64` works fine with binary
    data. Here is a common executable file, a forensic utility; it starts with `MZê`
    and has unprintable ASCII characters:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是处理二进制数据。可执行文件是二进制的，而不是ASCII。此外，图像、电影和许多其他文件都包含二进制数据。ASCII数据始终以第一个位为零开始，但`base64`可以很好地处理二进制数据。这是一个常见的可执行文件，一个法医实用程序；它以`MZê`开头，并且有不可打印的ASCII字符：
- en: '![](../images/00023.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00023.jpeg)'
- en: As this is a hex viewer, you see the raw data in hexadecimal, and on the right,
    it attempts to print it as ASCII. Windows programs have this string at the start,
    and this program cannot be run in DOS mode, but they have a lot of unprintable
    characters, such as `FF` and `0`, which really doesn't matter for Python at all. An
    easy way to encode data like that is to read it directly from the file. You can
    use the `with` command. It will just open a file with filename and mode read binary
    with the handle `f` and then you can read it. The `with` command is here just
    to tell Python to open the file, and that if it cannot be opened due to some error,
    then just to close the handle and then decode it exactly the same way. To decode
    data you've encoded in this fashion, you just take the output string and you put
    `.decode` instead of `.encode`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个十六进制查看器，您可以看到十六进制的原始数据，在右侧，它尝试将其打印为ASCII。Windows程序在开头有这个字符串，并且这个程序不能在DOS模式下运行，但它们有很多不可打印的字符，比如`FF`和`0`，这对Python来说并不重要。像这样编码数据的简单方法是直接从文件中读取它。您可以使用`with`命令。它将使用文件名和读取二进制模式打开一个文件，并使用句柄`f`读取它。`with`命令在这里只是告诉Python打开文件，并且如果由于某些错误无法打开文件，则关闭句柄，然后以完全相同的方式解码它。要解码以这种方式编码的数据，只需取输出字符串，并将`.encode`替换为`.decode`。
- en: 'Now let''s take a look at how to handle binary data:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何处理二进制数据：
- en: 'We will first exit Python so that we can see the filesystem, and then we''ll
    look for the `Ac` file using the command shown here:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先退出Python，以便我们可以查看文件系统，然后我们将使用以下命令查找`Ac`文件：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There's the filename. Since that's kind of a long block, we are just going to
    copy and paste it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是文件名。由于这是一个比较长的块，我们只需复制并粘贴它。
- en: 'Now we start Python and `clear` the screen using the following command:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们启动Python并使用以下命令`clear`屏幕：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will start `python` again:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重新开始`python`：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Alright, so, now we use the following command:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在我们使用以下命令：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here we enter the filename first and then the mode, which is read binary. We
    will give it filename handle of `f`. We will take all the data and put it in a
    single variable data. We could just encode the data in `base64`, and it would
    automatically print it. If you have an intended block in Python, you have to press
    *Enter* twice so it knows the block is done, and then `base64` encodes it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们首先输入文件名，然后是读取二进制模式。我们将给它一个文件名句柄`f`。我们将获取所有数据并将其放入一个单一变量数据中。我们可以只对数据进行`base64`编码，它会自动打印出来。如果您在Python中有一个预期的块，您必须按*Enter*键两次，以便它知道块已完成，然后`base64`对其进行编码。
- en: 'You get a long block of `base64` that is not very readable, but this is a handy
    way to handle data like that; say, if you want to email it or put it in some other
    text format. So, to do the decoding, let''s encode something simpler so that we
    can easily see the result:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会得到一个很长的`base64`块，这不太可读，但这是处理这种数据的一种方便方式；比如，如果您想要通过电子邮件发送它或将其放入其他文本格式中。因此，为了进行解码，让我们编码一些更简单的东西，以便我们可以轻松地看到结果：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we want to play with it, put that in a `c` variable using the following
    command:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要使用它，可以使用以下命令将其放入一个`c`变量中：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we can print `c` to make sure that we have got what we expected. We have
    `QUJD`, which is what we expected. So, now we can decode it using the following
    command:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以打印`c`以确保我们得到了预期的结果。我们有`QUJD`，这是我们预期的结果。所以，现在我们可以使用以下命令对其进行解码：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`base64` is not encrypting. It is not hiding anything, but it is just another
    way to represent it. In the next section, we''ll cover XOR.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`base64`不是加密。它不隐藏任何东西，而只是另一种表示方法。在下一节中，我们将介绍XOR。'
- en: XOR
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XOR
- en: 'This section explains what XOR is on single bits with a truth table, and then
    shows how to do it on bytes. XOR undoes itself, so decryption is the same operation
    as encryption. You can use single bytes or multiple byte keys for XOR, and we
    will use looping to test keys. Here''s the XOR truth table:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了XOR在单个位上的真值表，然后展示了如何在字节上进行操作。XOR可以撤销自身，因此解密与加密是相同的操作。您可以使用单个字节或多个字节密钥进行XOR，并且我们将使用循环来测试密钥。以下是XOR的真值表：
- en: '`0 ^ 0 = 0`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0 ^ 0 = 0`'
- en: '`0 ^ 1 = 1`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0 ^ 1 = 1`'
- en: '`1 ^ 0 = 1`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1 ^ 0 = 1`'
- en: '`1 ^ 1 = 0`'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1 ^ 1 = 0`'
- en: If you feed in two bits and the two bits are the same, the answer is `0.` If
    the bits are different, the answer is `1`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您输入两个位，并且这两个位相同，则答案是`0`。如果位不同，则答案是`1`。
- en: XOR operates on one bit at a time. Python indicates XOR with the `^` operator.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: XOR一次操作一个位。Python使用`^`运算符表示XOR。
- en: The truth table shows how it works. You feed in bits that are equally likely
    to be `0` and `1` and XOR them together, then you end up with 50% ones and zeros,
    which means that XOR does not destroy any information.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 真值表显示了它的工作原理。您输入可能是`0`和`1`的位，并将它们进行异或运算，然后最终得到50%的1和0，这意味着异或不会破坏任何信息。
- en: 'Here''s the XOR for bytes:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是字节的异或：
- en: '`A 0b01000001`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A 0b01000001`'
- en: '`B 0b01000010`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`B 0b01000010`'
- en: '`XOR 0b00000011`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XOR 0b00000011`'
- en: '`A` is the number `65`, so you have `1` for `64` and `1` for `1`; `B` is `1`
    larger, and if you XOR the two of them together, all the bits match for the first
    6 bits, and they''re all `0`. The last two bits are different, and they turn into
    `1`. This is the binary value `3`, which is not a printable character, but you
    can express it as an integer.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`A`是数字`65`，所以你有`64`的`1`和`1`的`1`；`B`大1，如果你将它们进行XOR操作，所有的位匹配前6位，它们都是`0`。最后两位不同，它们变成了`1`。这是二进制值`3`，它不是一个可打印的字符，但你可以将它表示为一个整数。'
- en: 'The key can be single byte or multibyte. If the key is a single byte, such
    as `B`, then you use the same byte to encrypt every plaintext character. Just
    keep repeating the key over and over:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥可以是单字节或多字节。如果密钥是单字节，比如`B`，那么你可以使用相同的字节来加密每个明文字符。只需一直重复使用密钥：
- en: '![](../images/00024.gif)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00024.gif)'
- en: 'Repeat `B` for this byte, `B` for that byte, and so on. If the key is multibyte,
    then you repeat the pattern:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个字节重复`B`，那个字节也是`B`，依此类推。如果密钥是多字节的，那么你就重复这个模式：
- en: '![](../images/00025.gif)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00025.gif)'
- en: You use `B` for the first byte, `C` for the next byte, then again `B` for the
    next byte, `C` for the next byte, and so on.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你用`B`代表第一个字节，`C`代表下一个字节，然后再次用`B`代表下一个字节，`C`代表下一个字节，依此类推。
- en: To do this in Python, you need to loop through the bytes of a string and calculate
    an index to show which byte you're on. Then we enter some text from the user,
    calculate its length, then go through the indices from `1` up to the length of
    the string, starting at `0`. Then we take the text byte and just print it out
    here so you can see how the loop works. So, if we give it a five-character plaintext,
    such as `HELLO`, it just prints out the characters one by one.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你需要循环遍历字符串的字节并计算一个索引来显示你所在的字节。然后我们从用户那里输入一些文本，计算它的长度，然后遍历从`1`到字符串长度的索引，从`0`开始。然后我们取文本字节并在这里打印出来，这样你就可以看到循环是如何工作的。所以，如果我们给它一个五个字符的明文，比如`HELLO`，它就会一个接一个地打印出字符。
- en: To do the XOR, we'll input a plaintext and a key and then take a byte of text
    and a byte of key, XOR them together, and print out the results
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行异或操作，我们将输入一个明文和一个密钥，然后取一个文本字节和一个密钥字节，进行异或操作，然后打印出结果。
- en: Note `%len( key)`, which is what prevents you from running off the end of the
    key. It will just keep repeating the bytes in the key. So, if the key is three
    bytes long, this will be modulus three, so it will count as `0`, `1`, `2`, and
    then back to `0 1 2 0 1 2`, and so on. In this way, you can handle any length
    of plaintext.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`%len( key)`，这可以防止你超出密钥的末尾。它将一直重复密钥中的字节。因此，如果密钥是三个字节长，这将是模三，所以它将计数为`0`，`1`，`2`，然后回到`0
    1 2 0 1 2`，依此类推。这样，你可以处理任意长度的明文。
- en: If you combine uppercase and lowercase letters, you'll often find the case that
    XOR produces unprintable bytes. In the example that follows, we have used `HELLO`, `Kitty`,
    and a key of `qrs`. Note that some of these bytes are readily printable and some
    of them contain strange characters, such as *Esc* and *Tab*, which are difficult
    to print. Therefore, the best way to handle the output is not to attempt to print
    it as ASCII, but instead print it as `hex` encoded values. Instead of trying to
    print the bytes one by one, we combine them into a `cipher` variable, and in the
    end, we print out the entire plaintext, the entire key, and then the entire ciphertext
    in hex. In this way, it can correctly handle these strange values that are difficult
    to print.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你结合大写和小写字母，你经常会发现XOR产生无法打印的字节的情况。在接下来的例子中，我们使用了`HELLO`，`Kitty`和一个`qrs`的密钥。请注意，其中一些字节是可以打印的，而其中一些包含奇怪的字符，比如*Esc*和*Tab*，这些很难打印。因此，处理输出的最佳方式不是尝试将其作为ASCII打印，而是将其作为`hex`编码的值打印。我们不是一个接一个地打印字节，而是将它们组合成一个`cipher`变量，最后，我们以`hex`形式打印出整个明文，整个密钥，然后是整个密文。这样，它可以正确处理这些难以打印的奇怪值。
- en: 'Let''s try this looping in Python:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python中尝试这个循环：
- en: 'We open the Terminal and enter the following command:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打开终端并输入以下命令：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When you run it, you will get the following output:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行它时，你会得到以下输出：
- en: '![](../images/00026.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00026.jpeg)'
- en: 'This is the first one that is `xor1.py`, so we input text from the user, calculate
    it''s length, and then just print out the bytes one by one to see how the loop
    works. Let''s run it and give it `HELLO`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是第一个`xor1.py`，所以我们从用户那里输入文本，计算它的长度，然后一个接一个地打印出字节，以查看循环是如何工作的。让我们运行它并给它`HELLO`：
- en: '![](../images/00027.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00027.jpeg)'
- en: 'It just prints out the bytes one by one. Now, let''s look at the next XOR 2:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它只是一个接一个地打印出字节。现在，让我们看一下下一个XOR 2：
- en: '![](../images/00028.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00028.jpeg)'
- en: This inputs `text` and `key` the same way and goes through each byte of `text`,
    picks out the correct byte of `key` using the modular arithmetic, performs the
    XOR, and prints out the results.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里输入`text`和`key`，然后以相同的方式进行处理，遍历`text`的每个字节，使用模运算挑选出`key`的正确字节，执行异或操作，然后打印出结果。
- en: 'So if we run the same file here, we take `HELLO` and a `key` as shown:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以如果我们在这里运行相同的文件，我们取`HELLO`和一个`key`如下所示：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'So, the output is as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，输出如下：
- en: '![](../images/00029.jpeg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00029.jpeg)'
- en: It calculates the bytes one by one. Note how we get two equals signs here, which
    is the reason why you would use a multiple by `key` because the plaintext is changing
    but the key, is also changing and that pattern is not reflected in the output,
    so it's more effective obfuscation.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 它逐个计算字节。请注意，这里我们得到了两个等号，这就是为什么你会使用多字节`key`的原因，因为明文在变化，但密钥也在变化，而这种模式在输出中没有反映出来，所以它是更有效的混淆。
- en: 'Clear that and look at the third `xor2a.py` file:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除并查看第三个`xor2a.py`文件：
- en: '![](../images/00030.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00030.jpeg)'
- en: You can see that this handles the problem of unprintable bytes.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你就可以看到，这解决了无法打印的字节的问题。
- en: 'So, we create a variable named `cipher`, combine each byte of output here,
    and at the end, we encode it with `hex` instead of trying to `print` it out directly:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们创建了一个名为`cipher`的变量，在这里组合了每个输出字节，最后，我们用`hex`编码它，而不是直接尝试将其打印出来：
- en: '![](../images/00031.jpeg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00031.jpeg)'
- en: If you give it `HELLO` and then text a key of `qrs`, it will give you the plaintext
    `HELLO Kitty`, the key, and then the hexadecimal-encoded output, which can easily
    handle funny characters, such as `0 7` and `0 5`. In the next section, you'll
    see challenge 1—the Caesar cipher.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你给它`HELLO`，然后输入一个`qrs`的键，它会给你明文`HELLO Kitty`，键，然后是十六进制编码的输出，这可以轻松处理有趣的字符，比如`0
    7`和`0 5`。在下一节中，你将看到挑战1 – 凯撒密码。
- en: Challenge 1 – the Caesar cipher
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战1 – 凯撒密码
- en: After a Caesar cipher review, we'll have an example of how to solve it and then
    your challenge. Remember how the Caesar cipher works. You have an alphabet of
    available characters, you take in the message and a `shift` value, and then you
    just shift the characters forward that many steps in the alphabet, wrapping around
    if you go around the end. The script we end up with works for any `shift` value,
    including normal numbers, such as `3`, or even numbers that are larger than `26`;
    they just wrap around and can scramble any data you put it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 经过凯撒密码的复习，我们将有一个解决它的例子，然后是你的挑战。记住凯撒密码是如何工作的。你有一个可用字符的字母表，你输入消息和一个`shift`值，然后你只需将字符向前移动那么多步，如果超出字母表的末尾就回到开头。我们最终得到的脚本适用于任何`shift`值，包括正常的数字，比如`3`，甚至大于`26`的数字；它们只是循环并且可以混淆你输入的任何数据。
- en: 'Here''s an example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: For ciphertext, you can decipher it by just trying all the `shift` values from
    `0` to `25`, and one of them will just be readable. This is a simple brute-force
    attack. Let's take a look at it.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于密文，你可以尝试从`0`到`25`的所有`shift`值，其中一个将是可读的。这是一个简单的暴力攻击。让我们来看看。
- en: 'Here, in Python, go to the `caesar4` script, that we had before. It takes in
    a string and shifts it by any value you specify. If we use that script, we can
    run it as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在Python中，去`caesar4`脚本，我们之前有过。它接受一个字符串并将其按你指定的任何值进行移位。如果我们使用那个脚本，我们可以运行它如下：
- en: '![](../images/00032.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00032.jpeg)'
- en: Then, if we put in `HELLO` and shift it by `3`, it turns into `KHOOR`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果我们输入`HELLO`并将其移位`3`，它就会变成`KHOOR`。
- en: 'If we want to crack it, we can use the solution script as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要破解它，我们可以使用以下解决方案脚本：
- en: '![](../images/00033.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00033.jpeg)'
- en: 'So, if we use that script, we can run it:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，如果我们使用那个脚本，我们可以运行它：
- en: '![](../images/00034.jpeg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00034.jpeg)'
- en: 'If we put it in `KHOOR`, it''ll shift it by a variety of values, and you can
    see the one that''s readable at `23`, which is `HELLO`. So, the example we discussed
    before of longer ciphertexts and so on will become readable down at `3`, where
    you see its `DEMONSTRATION`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们输入`KHOOR`，它将以各种值进行移位，你可以看到在`23`时可读的值是`HELLO`。所以，我们之前讨论的更长的密文等等的例子，在`3`时变得可读，你会看到它是`DEMONSTRATION`：
- en: '![](../images/00035.jpeg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00035.jpeg)'
- en: 'Your challenge is to decipher this string: `MYXQBKDEVKDSYXC`.'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的挑战是解密这个字符串：`MYXQBKDEVKDSYXC`。
- en: In the next section, we'll have a challenge on `base64`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将有一个关于`base64`的挑战。
- en: Challenge 2 – base64
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战2 – base64
- en: After a `base64` review, we'll perform an example to show you how to decode
    some obfuscated text, and then we have one simple and one hard challenge for you.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 经过`base64`的复习，我们将进行一个例子，向你展示如何解码一些混淆的文本，然后我们为你准备了一个简单的和一个困难的挑战。
- en: 'Here is the `base64` review:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`base64`的复习：
- en: '![](../images/00036.jpeg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00036.jpeg)'
- en: '`base64` encoding text makes it longer. Here''s the sample text to decode:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`base64`编码文本会变得更长。这是要解码的示例文本：'
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It decodes into the string sample text. Let's take a look at that.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 它解码成示例文本字符串。让我们看看。
- en: 'Refer to the following steps:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下步骤：
- en: 'If you run `python` in immediate mode, it will do four simple jobs:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在立即模式下运行`python`，它将执行四个简单的任务：
- en: '[PRE41]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'So, if we take `ABC` and encode it with `base64`, we get this string:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，如果我们取`ABC`并用`base64`编码，我们会得到这个字符串：
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we decode that with `base64`, we get back to the original text:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们用`base64`解码它，我们会得到原始文本：
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'So, the challenge text is as follows, and if you decode it, you get the string
    sample text:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，挑战文本如下，如果你解码它，你会得到示例文本字符串：
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'So, that will do for simple case; your first challenge looks like that:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这对于简单情况足够了；你的第一个挑战看起来是这样的：
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here''s a long string to decode for your longer challenge:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个要解码的长字符串，用于你的更长的挑战：
- en: '[PRE46]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This long string is so long because it's been encoded by `base64` not just once
    but several times. So, you'll have to try decoding it until it turns into something
    readable. In the next section, we'll have *Challenge 3 – XOR*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个长字符串之所以这么长，是因为它被`base64`编码了不止一次，而是多次。所以，你需要尝试解码它，直到它变成可读的内容。在下一节中，我们将有*挑战3
    – 异或*。
- en: Challenge 3 – XOR
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战3 – 异或
- en: In this section, we will review how XOR works and then give you an example,
    and then present you with two challenges.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将复习异或的工作原理，然后给你一个例子，然后提出两个挑战。
- en: 'So, here is one of the XOR programs we discussed before:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这是我们之前讨论过的一个异或程序：
- en: '![](../images/00037.jpeg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00037.jpeg)'
- en: You input arbitrary texts and an arbitrary key, and then go through the bytes
    one by one, picking out one byte of text and one byte of key before combining
    them with XOR and printing out the results. So, if you put in `HELLO` and `qrs`,
    you'll get encrypted stuff, encrypted with XOR.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你输入任意文本和一个任意的键，然后逐个字节地遍历它们，挑选出一个文本字节和一个键字节，然后用异或结合它们并打印出结果。所以，如果你输入`HELLO`和`qrs`，你会得到用异或加密的东西。
- en: 'Here''s an example:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '![](../images/00038.jpeg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00038.jpeg)'
- en: It will scramble into `EXAMPLE`. So, this undoes encryption; remember that XOR
    undoes itself.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 它会解密成`EXAMPLE`。所以，这是解密；记住异或会解开自己。
- en: If you want to break into one of these, one simple procedure is just to try
    every key and print out the results for each one, and then read the key is readable.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想破解其中一个，一个简单的方法就是尝试每个键并打印出每个结果，然后读出可读的键。
- en: So, we try all single-digit keys from `0` to `9`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们尝试从`0`到`9`的所有单个数字键。
- en: The result is that you feed in the ciphertext, encrypt it with each of these,
    and when you hit the correct key value, it will turn into readable text.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是你输入密文，用每个值加密它，当你得到正确的键值时，它将变成可读的文本。
- en: 'Let''s take a look at that:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看：
- en: '![](../images/00039.jpeg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00039.jpeg)'
- en: 'Here''s the decryption routine, which simply inputs texts from the user and
    then tries every key in this string, `0` through `9`. For each one of those it
    combines, think the XORed text into a variable named `clear`, so it can print
    one line for each key and then the clear result. So, if we run that one and put
    in my ciphertext, it gives us 10 lines.:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解密例程，它简单地从用户输入文本，然后尝试这个字符串中的每个密钥，`0`到`9`。对于这些中的每一个，它将XOR文本组合成一个名为`clear`的变量，以便可以为每个密钥打印一行，然后清晰结果。因此，如果我们运行它并输入我的密文，它会给我们10行。
- en: '![](../images/00040.jpeg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00040.jpeg)'
- en: 'We just scanned through these lines and saw which one becomes readable, and
    you can see the correct key and the correct plaintext at `6`. The first challenge
    is here:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是浏览了这些行并看到哪一个变得可读，您可以看到正确的密钥和正确的明文在`6`处。第一个挑战就在这里：
- en: '![](../images/00041.jpeg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00041.jpeg)'
- en: 'This is similar to the one we saw earlier. The key is a single digit, and it
    will decrypt into something readable. Here''s a longer example that is in a hexadecimal
    format:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前看到的类似。密钥是一个数字，它将解密为可读的内容。这是一个以十六进制格式的更长的示例：
- en: '![](../images/00042.gif)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00042.gif)'
- en: The key is two digits of ASCII, so you'll have to try 100 choices to find a
    way to turn this into a readable string.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥是两个ASCII数字，因此您将不得不尝试100种选择来找到将其转换为可读字符串的方法。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, after setting up Python, we covered the simple substitution
    cipher, the Caesar cipher, and then `base64` encoding. We gathered data six bits
    at a time instead of eight bits at a time, and then we looked at XOR encoding,
    where bits are flipped one by one in accordance with the key. We also saw a very
    simple truth table. The challenges you performed were cracking the Caesar cipher
    without the key, cracking `base64` by reversing it to get the original bytes,
    and cracking XOR encryption without knowledge of the key with a brute-force attack
    trying all possible keys. In [Chapter 2](part0035.html#11C3M0-6963dc2081804897894c8854b7cc74fd),
    *Hashing*, we will cover different types of hashing algorithms.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，设置Python之后，我们介绍了简单的替换密码、凯撒密码，然后是`base64`编码。我们每次收集六位数据而不是八位数据，然后我们看了XOR编码，其中位根据密钥逐个翻转。我们还看到了一个非常简单的真值表。您完成的挑战是破解凯撒密码而不知道密钥，通过将`base64`反向解码以获取原始字节，并尝试所有可能的密钥进行暴力攻击来破解XOR加密。在[第2章](part0035.html#11C3M0-6963dc2081804897894c8854b7cc74fd)
    *哈希*中，我们将介绍不同类型的哈希算法。
