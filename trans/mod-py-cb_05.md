# 第五章 用户输入和输出

在本章中，我们将学习以下示例：

+   使用`print()`函数的特性

+   使用 input()和 getpass()进行用户输入

+   使用"format".format_map(vars())进行调试

+   使用 argparse 获取命令行输入

+   使用 cmd 创建命令行应用程序

+   使用 OS 环境设置

# 介绍

软件的核心价值在于产生有用的输出。一种简单的输出类型是一些有用结果的文本显示。Python 通过`print()`函数支持这一点。

`input()`函数与`print()`函数有明显的相似之处。`input()`函数从控制台读取文本，允许我们向程序提供不同的值。

还有许多其他常见的提供输入的方式。解析命令行对于许多应用程序也是有帮助的。有时我们需要使用配置文件来提供有用的输入。数据文件和网络连接是提供输入的更多方式。每种方式都是独特的，需要单独考虑。在本章中，我们将专注于`input()`和`print()`的基础知识。

# 使用`print()`函数的特性

在许多情况下，`print()`函数是我们学习的第一个函数。第一个脚本通常是以下变体：

```py
 **print("Hello world.")** 

```

我们很快就学会了`print()`函数可以显示多个值，包括有用的空格。

当我们写下这个：

```py
 **>>> count = 9973 
>>> print("Final count", count) 
Final count 9973** 

```

我们看到在两个值之间包括了一个空格。此外，在函数提供的值后打印了一个换行符，通常用`\n`字符表示。

我们能控制这种格式吗？我们能改变提供的额外字符吗？

原来我们可以用`print()`做更多的事情。

## 准备工作

我们有一个用于记录大帆船燃油消耗的电子表格。它的行看起来像这样：

| 日期 | 10/25/13 | 10/26/13 | 10/28/13 |
| --- | --- | --- | --- |
| 发动机开启 | 08:24:00 | 09:12:00 | 13:21:00 |
| 燃油高度 | 29 | 27 | 22 |
| 发动机关闭 | 13:15:00 | 18:25:00 | 06:25:00 |
| 燃油高度关闭 | 27 | 22 | 14 |

有关这些数据的更多信息，请参阅第四章中的*从集合中删除项目 - remove()、pop()和 difference*和*对列表进行切片和切块*的示例，*内置数据结构 - 列表、集合、字典*。油箱内没有液位计。燃油的深度必须通过油箱侧面的视镜读取，这就是为什么燃油的容积被陈述为深度。油箱的完整深度约为 31 英寸，容积约为 72 加仑；可以将深度转换为容积。

以下是使用 CSV 数据的示例。此函数读取文件并返回从每行构建的字段列表：

```py
 **>>> from pathlib import Path 
>>> import csv 
>>> from collections import OrderedDict 
>>> def get_fuel_use(source_path): 
...     with source_path.open() as source_file: 
...         rdr= csv.DictReader(source_file) 
...         od = (OrderedDict( 
...             [(column, row[column]) for column in rdr.fieldnames]) 
...             for row in rdr) 
...         data = list(od) 
...     return data 
>>> source_path = Path("code/fuel2.csv") 
>>> fuel_use= get_fuel_use(source_path) 
>>> fuel_use  
[OrderedDict([('date', '10/25/13'), ('engine on', '08:24:00'), 
    ('fuel height on', '29'), ('engine off', '13:15:00'), 
    ('fuel height off', '27')]), 
OrderedDict([('date', '10/26/13'), ('engine on', '09:12:00'), 
    ('fuel height on', '27'), ('engine off', '18:25:00'), 
    ('fuel height off', '22')]), 
OrderedDict([('date', '10/28/13'), ('engine on', '13:21:00'), 
    ('fuel height on', '22'), ('engine off', '06:25:00'), 
    ('fuel height off', '14')])]** 

```

我们使用了`pathlib.Path`对象来定义原始数据的位置。我们定义了一个名为`get_fuel_use()`的函数，它将打开并读取给定路径的文件。该函数从源电子表格创建了一行行的数据列表。每行数据都表示为一个`OrderedDict`对象。

该函数首先创建一个`csv.DictReader`对象来解析原始数据。读取器通常返回一个内置的`dict`对象，它不会对键强加特定的顺序。为了强制特定的键顺序，该函数使用生成器表达式为每行创建一个`OrderedDict`对象。读取器`rdr`的`fieldnames`属性用于将列强制为特定顺序。生成器表达式使用了一个嵌套的循环对：一个循环处理一行的每个字段，外部循环处理数据的每一行。

结果是一个包含`OrderedDict`对象的列表对象。这是我们可以用于打印的一致的数据源。每行都有基于第一行列名的五个字段。

## 如何做...

我们有两种方法来控制`print()`的格式：

+   设置字段间分隔符字符 `sep`，其默认值为一个空格

+   设置行尾字符 `end`，其默认值为 `\n` 字符

我们将展示几个更改 `sep` 和 `end` 的示例。每个都是一种一步到位的配方。

默认情况如下。这个例子没有改变 `sep` 或 `end`：

```py
 **>>> for leg in fuel_use: 
...    start = float(leg['fuel height on']) 
...    finish = float(leg['fuel height off']) 
...    print("On", leg['date'], 
...    'from', leg['engine on'], 
...    'to', leg['engine off'], 
...    'change', start-finish, 'in.') 
On 10/25/13 from 08:24:00 to 13:15:00 change 2.0 in. 
On 10/26/13 from 09:12:00 to 18:25:00 change 5.0 in. 
On 10/28/13 from 13:21:00 to 06:25:00 change 8.0 in.** 

```

当我们查看输出时，我们可以看到每个项目之间插入了一个空格。每个数据项集合的末尾的 `\n` 字符意味着每个 `print()` 函数产生一个单独的行。

在准备数据时，我们可能希望使用类似于逗号分隔值的格式，可能使用不是简单逗号的列分隔符。这是一个使用 `|` 的示例：

```py
 **>>> print("date", "start", "end", "depth", sep=" | ") 
date | start | end | depth 
>>> for leg in fuel_use: 
...    start = float(leg['fuel height on']) 
...    finish = float(leg['fuel height off']) 
...    print(leg['date'], leg['engine on'], 
...    leg['engine off'], start-finish, sep=" | ") 
10/25/13 | 08:24:00 | 13:15:00 | 2.0 
10/26/13 | 09:12:00 | 18:25:00 | 5.0 
10/28/13 | 13:21:00 | 06:25:00 | 8.0** 

```

在这种情况下，我们可以看到每一列都有给定的分隔符字符串。由于 `end` 设置没有更改，每个 `print()` 函数产生一个不同的输出行。

最常见的情况似乎是我们想要完全抑制分隔符。这给了我们对输出的精细控制。

这是我们如何改变默认标点以强调字段名称和值。在这种情况下，我们已经更改了 `end` 设置：

```py
 **>>> for leg in fuel_use: 
...    start = float(leg['fuel height on']) 
...    finish = float(leg['fuel height off']) 
...    print('date', leg['date'], sep='=', end=', ') 
...    print('on', leg['engine on'], sep='=', end=', ') 
...    print('off', leg['engine off'], sep='=', end=', ') 
...    print('change', start-finish, sep="=") 
date=10/25/13, on=08:24:00, off=13:15:00, change=2.0 
date=10/26/13, on=09:12:00, off=18:25:00, change=5.0 
date=10/28/13, on=13:21:00, off=06:25:00, change=8.0** 

```

由于行尾字符串被更改为`,`，每次使用 `print()` 函数都不会产生单独的行。直到最后一个 `print()` 函数，它具有 `end` 的默认值，我们才得到正确的行尾。

显然，这种技术对于比这些简单示例更复杂的任何事情都可能变得非常复杂。对于简单的事情，我们可以调整分隔符或结尾。对于更复杂的事情，我们需要使用字符串的 `format()` 方法。

## 它是如何工作的...

在一般情况下，`print()` 函数是围绕 `stdout.write()` 的一个方便的包装器。这种关系可以被改变，我们将在下面看到。

我们可以想象 `print()` 有一个类似于这样的定义：

```py
    def print(*args, *, sep=None, end=None, file=sys.stdout): 
        if sep is None: sep = ' ' 
        if end is None: end = '\n' 
        arg_iter= iter(args) 
        first = next(arg_iter) 
        sys.stdout.write(repr(first)) 
        for value in arg_iter: 
            sys.stdout.write(sep) 
            sys.stdout.write(repr(value()) 
        sys.stdout.write(end) 

```

这为我们提供了关于分隔符字符串和行尾字符串如何包含在 `print()` 函数输出中的提示。如果没有提供值，则默认值为空格和换行符。该函数通过参数值进行迭代，将第一个值视为特殊值，因为它没有分隔符。这种方法确保分隔符字符串 `sep` 出现在值之间。

行尾字符串 `end` 出现在所有值之后。它总是被写入。我们可以通过将其设置为空字符串来有效地关闭它。

## 还有更多...

`sys` 模块定义了两个始终可用的标准输出文件：`sys.stdout` 和 `sys.stderr`。

我们可以使用 `file=` 关键字参数来写入标准错误文件，除了标准输出文件：

```py
    import sys 
    print("Red Alert!", file=sys.stderr) 

```

我们已经导入了 `sys` 模块，以便我们可以访问标准错误文件。我们使用它来写入一个不会成为标准输出流的消息。

通常情况下，我们需要谨慎地在一个程序中打开太多的输出文件。操作系统的限制通常足够打开许多文件。然而，当一个程序创建大量文件时，可能会变得混乱。

通常情况下，使用操作系统文件重定向技术会很好用。程序的主要输出可以写入 `sys.stdout`；这在操作系统级别很容易重定向。用户可能输入类似这样的命令行：

```py
 **python3 myapp.py <input.dat >output.dat** 

```

这将提供 `input.dat` 文件作为 `sys.stdin` 上的输入。当 Python 程序写入 `sys.stdout` 时，操作系统将输出重定向到 `output.dat` 对象。

在某些情况下，我们需要打开额外的文件。在这种情况下，我们可能会看到这样的编程：

```py
    from pathlib import Path 
    target_path = Path("somefile.dat") 
    with target_path.open('w', encoding='utf-8') as target_file: 
        print("Some output", file=target_file) 
        print("Ordinary log") 

```

在这个例子中，我们打开了一个特定的输出路径，并使用`with`语句将打开的文件分配给`target_file`。 然后，我们可以将其用作`print()`函数中的`file=`值，以将其写入此文件。 因为文件是上下文管理器，离开`with`语句意味着文件将被正确关闭，并且所有 OS 资源将从应用程序中释放。 所有文件操作都应该包装在`with`语句上下文中，以确保资源得到正确释放。

## 另请参阅

+   请参阅*使用"format".format_map(vars())进行调试*配方

+   有关此示例中的输入数据的更多信息，请参阅第四章中的*从集合中删除项目-remove()、pop()和 difference*和*切片和切块列表*配方，*内置数据结构-列表、集合、字典*

+   有关一般文件操作的更多信息，请参阅第九章，*输入/输出、物理格式、逻辑布局*

# 使用 input()和 getpass()进行用户输入

一些 Python 脚本依赖于从用户那里收集输入。 有几种方法可以做到这一点。 一种常用的技术是使用控制台提示用户输入。

有两种相对常见的情况：

+   **普通输入**：我们使用`input()`函数。 这将提供正在输入的字符的有用回显。

+   **无回显输入**：这通常用于密码。 输入的字符不会显示，提供了一定程度的隐私。 我们使用`getpass()`模块中的`getpass()`函数。

`input()`和`getpass()`函数只是从控制台读取的两种实现选择。 结果表明，获取字符的字符串只是处理的第一步。 实际上，我们有单独的考虑层次：

1.  与控制台的初始交互。 这是编写提示和读取输入的基础。 这必须正确处理数据以及键盘事件，例如用于编辑的退格键。 这也可能意味着适当处理文件结束。

1.  验证输入以查看它是否属于预期值域。 我们可能正在寻找数字，是/否值或一周中的某一天。 在大多数情况下，验证层有两个部分：

+   我们检查输入是否适合某些一般域，例如数字。

+   我们检查输入是否适合某些更具体的子域。 例如，这可能包括检查数字是否大于或等于零。

1.  在更大的上下文中验证输入，以确保它与其他输入一致。 例如，我们可以检查用户的出生日期是否在今天之前。

除了这些技术之外，我们将在*使用 argparse 获取命令行输入*配方中看到一些其他方法。

## 准备工作

我们将看一种从人那里读取复杂结构的技术。 在这种情况下，我们将使用年，月和日作为单独的项目来创建完整的日期。

这是一个快速的例子，省略了所有验证问题：

```py
    from datetime import date 

    def get_date(): 
        year = int(input("year: ")) 
        month = int(input("month [1-12]: ")) 
        day = int(input("day [1-31]: ")) 
        result = date(year, month, day) 
        return result 

```

这说明了使用`input()`函数有多么容易。 我们经常需要将其包装在额外的处理中，以使其更有用。 日历很复杂，我们不愿意接受 2 月 32 日而不警告用户这不是一个正确的日期。

## 如何做...

1.  检查输入是否为密码或同样受到保密的内容。 如果是，则使用`getpass.getpass()`函数。 这意味着我们需要导入以下函数：

```py
            from getpass import getpass 

    ```

否则，如果不需要输入，则使用`input()`函数。

1.  确定将使用哪个提示。 这可能只是`>>>`或更复杂的东西。 在某些情况下，我们可能会提供大量的上下文信息。

在我们的示例中，我们提供了一个字段名称和关于预期数据类型的提示作为提示字符串。提示字符串是`input()`或`getpass()`函数的参数：

```py
            year = int(input("year: ")) 

    ```

1.  确定如何验证每个单独的项目。最简单的情况是一个单一值和一个涵盖所有内容的规则。在更复杂的情况下——比如这个——每个单独的元素都是一个带有范围约束的数字。在后续步骤中，我们将看看如何验证复合项目。

1.  我们可能希望重新构造我们的输入，使其看起来像这样：

```py
            month = None 
            while month is None: 
                month_text = input("month [1-12]: ") 
                try: 
                    month = int(month_text) 
                    if 1 <= month <= 12: 
                        pass 
                    else: 
                        raise ValueError("Month of range 1-12") 
                except ValueError as ex: 
                    print(ex) 
                    month = None 

    ```

它将两个验证规则应用于输入：

+   它使用`int()`函数检查月份是否是有效的整数

+   它使用`if`语句检查整数是否在[1, 12]范围内，如果不在范围内则引发`ValueError`异常

对于错误的输入引发异常通常是最简单的方法。它允许我们最大的灵活性。我们可能会使用其他异常类，包括定义自定义数据验证异常。

由于我们将为复杂对象的每个字段使用几乎相同的循环，因此我们需要重新构造此输入并将验证序列转换为一个单独的函数。我们将其称为`get_integer()`。我们将在这里看到详细信息：

1.  验证复合对象。在这种情况下，这也意味着我们的整体输入需要重新构造，以便在出现错误输入时进行重试：

```py
            input_date = None 
            while input_date is None: 
                year = get_integer("year: ", 1900, 2100) 
                month = get_integer("month [1-12]: ", 1, 12) 
                day = get_integer("day [1-31]: ", 1, 31) 
                try: 
                    result = date(year, month, day) 
                except ValueError as ex: 
                    print(ex) 
                    input_date = None 
            # assert input_date is the valid date entered by the user 

    ```

这个整体循环实现了复合日期对象的高级验证。

给定年份和月份，我们实际上可以确定一个稍微更窄的天数范围。复杂之处在于月份不仅有不同数量的天数，从 28 到 31 不等，而且二月的天数还取决于年份的类型。

1.  与其模仿规则，不如使用`datetime`模块来计算两个相邻月份的第一天，如下所示：

```py
            day_1_date = date(year, month, 1) 
            if month == 12: 
                next_year, next_month = year+1, 1 
            else: 
                next_year, next_month = year, month+1 
            day_end_date = date(next_year, next_month, 1) 

    ```

这将正确计算给定月份的最后一天。该算法通过计算给定年份和月份的第一天，然后计算下个月的第一天。它正确地更改年份，以便`year`的一月跟随`year`的十二月。

这些日期之间的天数是给定月份的天数。我们可以使用表达式`(day_end_date - day_1_date).days`从`timedelta`对象中提取天数。

## 工作原理...

我们需要将输入问题分解成几个单独但密切相关的问题。在底层是与用户的初始交互。我们确定了两种常见的处理方式：

+   `input()`：这只是提示和读取

+   `getpass.getpass()`：这会提示并读取密码，而不会回显

我们希望能够使用*退格*字符编辑当前输入行。在某些环境中，有一个更复杂的编辑器可用。它体现在 Python 的`readline`模块中。如果存在该模块，它可以在准备输入行时添加大量编辑。该模块的主要特性是操作系统级的输入历史记录——我们可以使用上箭头键来恢复任何先前的输入。

我们已将输入验证分解成几个层次，以反映确认输入是否有效所需的编程类型：

+   **通用域**验证应该使用简单的转换函数，如`int()`或`float()`。这些函数 tend to raise exceptions for invalid data.使用这些转换函数并处理异常要简单得多，而不是尝试编写匹配有效数值的正则表达式。

+   我们的**子域**验证必须使用`if`语句来确定值是否符合施加的任何其他约束，例如范围。为了保持一致性，如果数据无效，这也应该引发异常。

可能会对值施加许多潜在的约束类型。例如，我们可能只想要有效的操作系统进程 ID，称为 PID。这需要在 Nanny Linux 系统上检查`/proc/<pid>`路径。

对于基于 BSD 的系统，如 Mac OS X，`/proc`文件系统不存在。相反，需要执行类似以下的操作来确定 PID 是否有效：

```py
    import subprocess 
    status = subprocess.check_output( 
        ['ps',PID]) 

```

对于 Windows，命令如下：

```py
    status = subprocess.check_output( 
        ['tasklist', '/fi', '"PID eq {PID}"'.format(PID=PID)]) 

```

这两个函数中的任何一个都需要成为输入验证的一部分，以确保用户输入正确的 PID 值。只有在整数的主要域得到保证时才能应用这一点。

最后，我们的整体输入函数还应该对无效输入引发异常。这可能在复杂性上有很大的变化。在示例中，我们创建了一个简单的日期对象。在其他情况下，我们可能需要进行更多的处理来确定复杂输入是否有效。

## 还有更多...

我们有几种用户输入的替代方法，涉及略有不同的方法。我们将详细讨论这两个主题：

+   输入字符串解析：这将涉及对`input()`的简单使用和巧妙的解析

+   通过`cmd`模块进行交互：这涉及更复杂的类，以及更简单的解析

### 输入字符串解析

简单的日期值需要三个单独的字段。包括与 UTC 的时区偏移的更复杂的日期时间将涉及七个单独的字段。通过读取和解析字符串而不是单独的字段，用户体验可能会得到改善。

对于简单的日期输入，我们可以使用以下方法：

```py
raw_date_str = input("date [yyyy-mm-dd]: ") 
input_date = datetime.strptime(raw_date_str, '%Y-%m-%d').date() 

```

我们使用`strptime()`函数来解析给定格式的时间字符串。我们在`input()`函数中提供的提示中强调了预期的日期格式。

这种输入方式要求用户输入更复杂的字符串。由于它是一个包含日期所有细节的单个字符串，许多人发现它更容易和友好。

请注意，收集单独字段和处理复杂字符串这两种技术都依赖于底层的`input()`函数。

### 通过 cmd 模块进行交互

`cmd`模块包括`Cmd`类，可用于构建交互式界面。这对用户交互的概念采取了截然不同的方法。它不依赖于显式使用`input()`。

我们将在*使用 cmd 创建命令行应用*中仔细研究这一点。

## 另请参阅

在 SunOS 操作系统的参考资料中，现在由 Oracle 拥有，有一系列命令提示不同类型的用户输入：

[`docs.oracle.com/cd/E19683-01/816-0210/6m6nb7m5d/index.html`](https://docs.oracle.com/cd/E19683-01/816-0210/6m6nb7m5d/index.html)

具体来说，所有以`ck`开头的这些命令都是用于收集和验证用户输入的。这可以用来定义输入验证规则的模块：

+   `ckdate`：提示并验证日期

+   `ckgid`：提示并验证组 ID

+   `ckint`：显示提示，验证并返回整数值

+   `ckitem`：构建菜单，提示并返回菜单项

+   `ckkeywd`：提示并验证关键字

+   `ckpath`：显示提示，验证并返回路径名

+   `ckrange`：提示并验证整数

+   `ckstr`：显示提示，验证并返回字符串答案

+   `cktime`：显示提示，验证并返回一天中的时间

+   `ckuid`：提示并验证用户 ID

+   `ckyorn`：提示并验证是/否

# 使用"format".format_map(vars())进行调试

在 Python 中，最重要的调试和设计工具之一是`print()`函数。有一些格式选项可用；我们在*使用 print()函数的特性*中看到了这些。

如果我们想要更灵活的输出怎么办？使用`"string".format_map()`方法可以提供更多的灵活性。这还不是全部。我们可以将其与`vars()`函数结合使用，创建出令人惊叹的东西！

## 准备工作

让我们看一个涉及一些中等复杂计算的多步过程。我们将计算一些样本数据的平均值和标准差。给定这些值，我们将定位所有比平均值高一个标准差以上的项目：

```py
 **>>> import statistics 
>>> size = [2353, 2889, 2195, 3094, 
... 725, 1099, 690, 1207, 926, 
... 758, 615, 521, 1320] 
>>> mean_size = statistics.mean(size) 
>>> std_size = statistics.stdev(size) 
>>> sig1 = round(mean_size + std_size, 1) 
>>> [x for x in size if x > sig1] 
[2353, 2889, 3094]** 

```

这个计算有几个工作变量。`mean_size`，`std_size`和`sig1`变量都显示了过滤`size`列表的最终列表推导的元素。如果结果令人困惑甚至不正确，了解计算中间步骤是有帮助的。在这种情况下，因为它们是浮点值，我们经常希望四舍五入结果，使其更有意义。

## 如何做...

1.  `vars()`函数从各种来源构建一个字典结构。

1.  如果没有给出参数，默认情况下，`vars()`函数将展开所有局部变量。这将创建一个可以与模板字符串的`format_map()`方法一起使用的映射。

1.  使用映射允许我们将变量的名称插入格式模板中。它看起来像这样：

```py
     **>>> print( 
          ...     "mean={mean_size:.2f}, std={std_size:.2f}" 
          ...     .format_map(vars()) 
          ... ) 
          mean=1414.77, std=901.10** 

    ```

我们可以将任何局部变量放入格式字符串中。使用`format_map(vars())`，我们不需要更复杂的方式来选择要显示的变量。

## 它是如何工作的...

`vars()`函数从各种来源构建一个字典结构：

+   `vars()`表达式将展开所有局部变量，以创建一个可以与`format_map()`方法一起使用的映射。

+   `vars(object)`表达式将展开对象内部`__dict__`属性中的所有项目。这使我们能够公开类定义和对象的属性。当我们在第六章中查看对象时，我们将看到如何利用这一点。

`format_map()`方法期望一个参数，即映射。格式字符串使用`{name}`来引用映射中的键。我们可以使用`{name:format}`来提供格式规范。我们还可以使用`{name!conversion}`来使用`repr()`，`str()`或`ascii()`函数提供转换函数。

有关格式选项的更多背景信息，请参考第一章中的*使用"template".format()构建复杂字符串*配方，*数字、字符串和元组*。

## 还有更多...

`format_map(vars())`技术是显示变量值的一种简单方法。另一种方法是使用`format(**vars())`。这种替代方法可以给我们一些额外的灵活性。

例如，我们可以使用这种更灵活的格式来包括不仅仅是局部变量的额外计算：

```py
 **>>> print( 
...     "mean={mean_size:.2f}, std={std_size:.2f}," 
...     " limit2={sig2:.2f}" 
...     .format(sig2=mean_size+2*std_size, **vars()) 
... ) 
mean=1414.77, std=901.10, limit2=3216.97** 

```

我们计算了一个新值`sig2`，它只出现在格式化的输出中。

## 另请参阅

+   参考第一章中的*使用"template".format()构建复杂字符串*配方，*数字、字符串和元组*，了解 format()方法可以做的更多事情

+   有关其他格式选项，请参考*使用 print()函数的特性*配方

# 使用 argparse 获取命令行输入

在某些情况下，我们希望从操作系统命令行获取用户输入，而不需要太多交互。我们更希望解析命令行参数值，然后执行处理或报告错误。

例如，在操作系统级别，我们可能想要运行这样的程序：

```py
 **slott$ python3 ch05_r04.py -r KM 36.12,-86.67 33.94,-118.40** 

 **From (36.12, -86.67) to (33.94, -118.4) in KM = 2887.35** 

```

操作系统提示符是`slott$`。我们输入了一个命令`python3 ch05_r04.py`。这个命令有一个可选参数`-r KM`，和两个位置参数`36.12,-86.67`和`33.94,-118.40`。

该程序解析命令行参数并将结果写回控制台。这允许一种非常简单的用户交互方式。它使程序非常简单。它允许用户编写一个 shell 脚本来调用程序或将程序与其他 Python 程序合并以创建一个更高级的程序。

如果用户输入了不正确的内容，交互可能会像这样：

```py
 **slott$ python3 ch05_r04.py -r KM 36.12,-86.67 33.94,-118asd** 

 **usage: ch05_r04.py [-h] [-r {NM,MI,KM}] p1 p2** 

 **ch05_r04.py: error: argument p2: could not convert string to float: '-118asd'** 

```

一个无效的参数值`-118asd`导致了一个错误消息。程序以错误状态码停止。在大多数情况下，用户可以按上箭头键获取上一个命令行，进行更改，然后再次运行程序。交互被委托给操作系统命令行。

程序的名称`ch05_r04`并不是太具有信息性。也许我们可以做得更好。位置参数是两个（纬度，经度）对。输出显示了给定单位下两者之间的距离。

我们如何从命令行解析参数值？

## 准备就绪

我们需要做的第一件事是重构我们的代码，创建两个单独的函数：

+   从命令行获取参数的函数。由于`argparse`模块的工作方式，这个函数几乎总是会返回一个`argparse.Namespace`对象。

+   一个执行真正工作的函数。这个函数应该被设计成在任何情况下都不引用命令行选项。这意味着它可以在各种情境中被重复使用。

这是我们的*真正工作*函数，`display()`：

```py
    from ch03_r05 import haversine, MI, NM, KM 
    def display(lat1, lon1, lat2, lon2, r): 
        r_float = {'NM': NM, 'KM': KM, 'MI': MI}[r] 
        d = haversine( lat1, lon1, lat2, lon2, r_float ) 
        print( "From {lat1},{lon1} to {lat2},{lon2}" 
              "in {r} = {d:.2f}".format_map(vars())) 

```

我们从另一个模块导入了核心计算`haversine()`。我们为这个函数提供了参数值，并使用`format()`来显示最终的结果消息。

我们基于第三章中的*根据部分函数选择参数顺序*食谱中的示例中显示的计算，*函数定义*：

![准备就绪](img/Image00012.jpg)

基本计算产生了两点之间的中心角*c*，给定为（*lat[1]*，*lon[1]*）和（*lat[2]*，*lon[2]*）。角度以弧度表示。我们通过将其乘以地球的平均半径来将其转换为距离。如果我们将角度*c*乘以 3959 英里的半径，我们将得到以英里表示的角度距离。

请注意，我们期望距离转换因子*r*以字符串形式提供。然后，这个函数将字符串映射到实际的浮点值。

有关`format()`方法的详细信息，请注意我们正在使用“Debugging with "format".format_map(vars())”食谱的变体。

当它在 Python 中使用时，函数的样子如下：

```py
 **>>> from ch05_r04 import display 
>>> display(36.12, -86.67, 33.94, -118.4, 'NM') 
From 36.12,-86.67 to 33.94,-118.4 in NM = 1558.53** 

```

这个函数有两个重要的设计特点。第一个特点是它避免了对由参数解析创建的`argparse.Namespace`对象的特性的引用。我们的目标是拥有一个可以在许多替代上下文中重复使用的函数。我们需要保持用户界面的输入和输出元素分开。

第二个设计特点是，这个函数显示了另一个函数计算出的值。这是一个有用的特性，因为它让我们分解问题。我们已经将用户体验与基本计算分开。

## 如何做…

1.  定义整体参数解析函数：

```py
            def get_options(): 

    ```

1.  创建“解析器”对象：

```py
            parser = argparse.ArgumentParser() 

    ```

1.  向“解析器”对象添加各种类型的参数。有时这很困难，因为我们仍在完善用户体验。很难想象人们会如何使用程序以及他们可能会有的所有问题。

对于我们的示例，我们有两个强制的位置参数和一个可选参数：

+   点 1 的纬度和经度

+   点 2 的纬度和经度

+   可选距离

我们可以使用海里作为一个方便的默认值，这样水手们就可以得到他们需要的答案：

```py
            parser.add_argument('-r', action='store', 
                    choices=('NM', 'MI', 'KM'), default='NM') 
            parser.add_argument('p1', action='store', type=point_type) 
            parser.add_argument('p2', action='store', type=point_type) 

    ```

我们添加了两种类型的参数。第一个是`-r`参数，以`-`开头标记为可选。有时，一个长名称会用`--`表示。在某些情况下，我们将提供这两种选择，如下所示：

```py
            add_argument('--radius', '-r'....)
    ```

动作是存储在命令行上跟在`-r`后面的值。我们列出了三种可能的选择并提供了默认值。解析器将验证输入，如果输入不是这三个值之一，将写入适当的错误。

强制参数不带`-`前缀。我们使用了`store`的操作；这是默认操作，实际上不需要声明。作为`type`参数提供的函数用于将源字符串转换为适当的 Python 对象。这也是验证复杂输入值的理想方式。我们将在本节中查看`point_type()`验证函数。

1.  评估步骤 2 中创建的解析器对象的`parse_args()`方法：

```py
            options = parser.parse_args() 

    ```

默认情况下，这使用来自`sys.argv`的值，这些值是用户输入的命令行参数值。如果需要以某种方式修改用户提供的命令行，我们可以提供一个显式参数。

这是最终的函数：

```py
    def get_options(): 
        parser = argparse.ArgumentParser() 
        parser.add_argument('-r', action='store', 
                choices=('NM', 'MI', 'KM'), default='NM') 
        parser.add_argument('p1', action='store', type=point_type) 
        parser.add_argument('p2', action='store', type=point_type) 
        options = parser.parse_args() 
        return options 

```

这依赖于`point_type()`验证函数。这是因为默认输入类型由`str()`函数定义。这确保参数的值将是字符串对象。我们提供了`type`参数，以便我们可以注入类型转换。我们可以使用`type = int`或`type = float`进行转换为数字。

在我们的示例中，我们使用`point_type()`将字符串转换为（*纬度*，*经度*）二元组：

```py
    def point_type(string): 
        try: 
            lat_str, lon_str = string.split(',') 
            lat = float(lat_str) 
            lon = float(lon_str) 
            return lat, lon 
        except Exception as ex: 
            raise argparse.ArgumentTypeError from ex 

```

此函数解析输入值。首先，它在`,`字符处分隔两个值。它尝试对每个部分进行浮点转换。如果`float()`函数都有效，则我们有一个有效的纬度和经度，可以将其作为一对浮点值返回。

如果出现任何问题，将引发异常。从这个异常中，我们将引发一个`ArgumentTypeError`异常。这是由`argparse`模块用于向用户报告错误。

这是结合选项解析器和输出显示函数的主要脚本：

```py
    if __name__ == "__main__": 
        options = get_options() 
        lat_1, lon_1 = options.p1 
        lat_2, lon_2 = options.p2 
        r = {'NM': NM, 'KM': KM, "MI": MI}[options.r] 
        display(lat_1, lon_1, lat_2, lon_2, r) 

```

这个主要脚本做了一些事情，将用户输入连接到显示的输出：

1.  解析命令行选项。这些都存在于选项对象中。

1.  将`p1`和`p2`（*纬度*，*经度*）二元组扩展为四个单独的变量。

1.  评估`display()`函数。

## 它是如何工作的...

参数解析器分为三个阶段：

1.  通过创建`ArgumentParser`的实例作为解析器对象来定义整体上下文。我们可以提供诸如整体程序描述之类的信息。我们还可以在这里提供格式化程序和其他选项。

1.  使用`add_argument()`方法添加单个参数。这些可以包括可选参数以及必需参数。每个参数都可以具有多种功能，以提供不同种类的语法。我们将在*还有更多...*部分中查看一些替代方案。

1.  解析实际的命令行输入。解析器的`parse()`方法将自动使用`sys.argv`。我们可以提供一个显式值，而不是`sys.argv`的值。提供覆盖值的最常见原因是允许进行更完整的单元测试。

一些简单的程序将具有一些可选参数。更复杂的程序可能有许多可选参数。

通常在位置参数中有一个文件名。当程序读取一个或多个文件时，文件名将在命令行上提供，如下所示：

```py
 **python3 some_program.py *.rst** 

```

我们使用了 Linux shell 的**globbing**功能——`*.rst`字符串扩展为符合命名规则的所有文件的列表。可以使用以下参数定义的文件列表进行处理：

```py
    parser.add_argument('file', nargs='*') 

```

命令行上所有不以`-`字符开头的名称都将被收集到解析器构建的对象的`file`值中。

然后我们可以使用以下内容：

```py
    for filename in options.file: 
        process(filename) 

```

这将处理命令行中给定的每个文件。

对于 Windows 程序，shell 不进行 glob 操作，应用程序必须处理其中包含通配符模式的文件名。Python 的`glob`模块可以帮助解决这个问题。此外，`pathlib`模块可以创建包括 globbing 功能的`Path`对象。

我们可能需要进行更复杂的参数解析选项。非常复杂的应用程序可能有数十个单独的命令。例如，看看`git`版本控制程序；该应用程序使用数十个单独的命令，如`git clone`，`git commit`或`git push`。每个命令都有独特的参数解析要求。我们可以使用`argparse`来创建这些命令及其不同参数集的复杂层次结构。

## 还有更多...

我们可以处理什么样的参数？常见的使用中有很多参数样式。所有这些变化都是使用解析器的`add_argument()`方法来定义的：

+   **简单选项**：`-o`或`--option`参数通常用于启用或禁用程序的功能。这些通常使用`add_argument()`参数`action='store_true'，default=False`来实现。有时，如果应用程序使用`action='store_false'，default=True`，实现会更简单。默认值和存储值的选择可能简化编程，但不会改变用户的体验。

+   **带非平凡对象的简单选项**：用户将其视为简单的`-o`或`--option`参数。我们可能希望使用更复杂的对象来实现这一点，而不是简单的布尔常量。我们可以使用`action='store_const'，const=some_object，default=another_object`。由于模块、类和函数也是对象，因此这里可以使用大量的复杂性。

+   **带值的选项**：我们展示了`-r unit`作为接受单位名称的字符串的参数。我们使用`action='store'`来存储提供的字符串值。我们还可以使用`type=function`选项来提供验证或将输入转换为有用形式的函数。

+   **增加计数器的选项**：一种常见的技术是具有多个详细级别的调试日志。我们可以使用`action='count'，default=0`来计算给定参数出现的次数。用户可以提供`-v`以获得详细输出，`-vv`以获得非常详细的输出。参数解析器将`-vv`视为`-v`参数的两个实例，这意味着值将从初始值`0`增加到`2`。

+   **累积列表的选项**：我们可能有一个选项，用户可能希望提供多个值。例如，我们可以使用一个距离值列表。我们可以使用`action='append'，default=[]`的参数定义。这将允许用户说`-r NM -r KM`以便同时显示海里和公里。当然，这将需要对`display()`函数进行重大更改，以处理集合中的多个单位。

+   **显示帮助文本**：如果我们什么都不做，那么`-h`和`--help`将显示帮助消息并退出。这将为用户提供有用的信息。如果需要，我们可以禁用此功能或更改参数字符串。这是一个广泛使用的惯例，所以最好什么都不做，这样它就成为我们程序的一个特性。

+   **显示版本号**：通常会有`--Version`作为一个参数来显示版本号并退出。我们使用`add_argument("--Version"，action="version"，version="v 3.14")`来实现这一点。我们提供一个`version`动作和一个额外的关键字参数来设置要显示的版本。

这涵盖了大多数命令行参数处理的常见情况。通常，我们在编写自己的应用程序时会尝试利用这些常见的参数样式。如果我们努力使用简单、广泛使用的参数样式，我们的用户可能更容易理解我们的应用程序的工作方式。

还有一些 Linux 命令，其命令行语法甚至更复杂。一些 Linux 程序，如`find`或`expr`，具有`argparse`无法轻松处理的参数。对于这些边缘情况，我们需要直接使用`sys.argv`的值编写自己的解析器。

## 另请参阅

+   我们看了如何在*使用 input()和 getpass()进行用户输入*配方中获得交互式用户输入

+   我们将在*使用 OS 环境设置*配方中看到如何为此添加更多的灵活性

# 使用 cmd 创建命令行应用程序

有几种创建交互式应用程序的方法。*使用 input()和 getpass()进行用户输入*配方查看了诸如`input()`和`getpass.getpass()`之类的函数。*使用 argparse 获取命令行输入*配方展示了如何使用`argparse`创建可以从操作系统命令行与用户交互的应用程序。

我们有第三种方法来创建交互式应用程序，使用`cmd`模块。该模块将提示用户输入，然后调用我们提供的类的特定方法。

这与第七章中的内容相关，*更高级的类设计*。我们将添加功能到类定义中，以创建一个独特的子类。

交互将如下所示，我们已标记用户输入如下：“`help`”：

```py
 **Starting with 100** 

 **Roulette> **`help`**** 

 **Documented commands (type help <topic>):** 

 **========================================** 

bet  help 

Undocumented commands: 
 **======================** 

 **done  spin  stake** 

 **Roulette>** 

help bet

 **Bet <name> <amount>** 

 **Name is one of even, odd, red, black, high, or low** 

 **Roulette> **`bet black 1`**** 

 **Roulette> **`bet even 1`**** 

 **Roulette> **`spin`**** 

 **Spin ('21', {'red', 'high', 'odd'})** 

 **Lose even** 

 **Lose black** 

 **... more interaction ...** 

 **Roulette> **`done`**** 

 **Ending with 93** 

```

应用程序有一个介绍性消息。它显示玩家的起始赌注，也就是他们有多少赌注。应用程序显示一个提示，`Roulette>`。用户可以输入五个可用命令中的任何一个。

当我们输入`help`作为命令时，我们会看到可用命令的显示。只有两个有任何文档。其他三个没有更多的详细信息可用。

当我们输入`help bet`时，我们会看到`bet`命令的详细文档。描述告诉我们要从可用的六个选择中提供一个赌注名称和一个赌注金额。

我们创建了两个赌注——一个在黑色上，一个在偶数上。然后我们输入`spin`命令来旋转轮盘。这显示了结果——数字`21`——是红色的，高的，奇数的。我们的两个赌注都输了。

我们省略了一些没有赢得太多的其他交互。当我们输入`done`命令时，最终的赌注会显示出来。如果模拟更详细，它可能还会显示一些有关旋转、赢和输的汇总统计数据。

## 准备工作

`cmd.Cmd`应用程序的核心特性是**读取-求值-打印循环**（**REPL**）。当有大量单独的状态更改和大量命令来进行这些状态更改时，这种应用程序运行良好。

我们将使用*轮盘*中一部分赌注的简单模拟作为示例。想法是允许用户创建一个或多个赌注，然后旋转模拟的*轮盘*。虽然正规的赌场*轮盘*有许多可能的赌注，但我们将只关注其中的六个：

+   红，黑

+   偶数，奇数

+   高，低

*美式轮盘*有 38 个箱子。1 到 36 号是红色和黑色的。还有两个箱子，0 和 00，是绿色的。这两个额外的箱子被定义为既不是偶数也不是奇数，也不是高也不是低。在零上下注的方式很少，但在数字上下注的方式很多。

我们将使用一些辅助函数来表示*轮盘*轮，这些函数构建了一个箱子集合。每个箱子都有一个显示数字的字符串和一组赢家的赌注名称。

我们可以定义一个通用的箱子，使用一些简单的规则来确定哪些赌注属于获胜集合：

```py
    red_bins = (1, 3, 5, 7, 9, 12, 14, 16, 18, 
        21, 23, 25, 27, 28, 30, 32, 34, 36) 

    def roulette_bin(i): 
        return str(i), { 
            'even' if i%2 == 0 else 'odd', 
            'low'  if 1 <= i < 19 else 'high', 
            'red'  if i in red_bins else 'black' 
        } 

```

`roulette_bin()`函数返回一个包含箱子编号的字符串表示和一组三个获胜提议的双元组。

对于`0`和`00`，我们需要一些不同的东西：

```py
    def zero_bin(): 
        return '0', set() 

    def zerozero_bin(): 
        return '00', set() 

```

`zero_bin()`函数返回一个字符串箱子编号和一个空集。`zerozero_bin()`函数返回一个特殊字符串来显示它是`00`，加上一个空集来显示没有定义的赌注是赢家。

我们可以结合这三个函数的结果来创建一个完整的*轮盘*轮。整个轮盘将被建模为一个箱子元组的列表：

```py
    def wheel(): 
        b0 = [zero_bin()] 
        b00 = [zerozero_bin()] 
        b1_36 = [ 
            roulette_bin(i) for i in range(1,37) 
        ] 
        return b0+b00+b1_36 

```

我们建立了一个简单的列表，其中包含完整的一组轮盘号码：一个零，一个双零，以及 1 到 36 的数字。现在我们可以使用`random.choice()`函数随机选择一个轮盘号码。这将告诉我们哪些赌注赢了，哪些输了。

## 如何做...

1.  导入 cmd 模块：

```py
            import cmd 

    ```

1.  定义对`cmd.Cmd`的扩展：

```py
            class Roulette(cmd.Cmd): 

    ```

1.  在`preloop()`方法中定义所需的任何初始化：

```py
                def preloop(self): 
                    self.bets = {} 
                    self.stake = 100 
                    self.wheel = wheel() 

    ```

当处理开始时，`preloop()`方法只被评估一次。我们用它来初始化赌注和玩家的赌注的字典。我们还创建了一个轮盘集合的实例。self 参数是类内方法的要求。现在，它只是一个简单的必需语法。在第六章中，*类和对象的基础*，我们将更仔细地研究这个问题。

请注意，这是在`class`语句内缩进的。

初始化也可以在`__init__()`方法中完成。不过，这有点复杂，因为我们必须使用`super()`来确保首先完成`Cmd`类的初始化。

1.  对于每个命令，创建一个`do_command()`方法。方法的名称将是命令，前缀为`do_`。命令后用户输入的文本将作为参数值提供给方法。以下是`bet`命令和`spin`命令的两个示例：

```py
                def do_bet(self, arg_string): 
                    pass 
                def do_spin(self, arg_string): 
                    pass 

    ```

1.  解析和验证每个命令的参数。命令后用户输入的内容将作为方法的第一个位置参数的值提供。

如果参数无效，方法应该打印一条消息并返回。如果参数有效，方法可以继续通过验证步骤。

对于我们的例子，`spin`命令不需要任何输入。我们可以忽略参数字符串。为了更完整，我们可能希望在字符串非空时显示错误。

然而，`bet`命令确实有一个赌注，它必须是六个有效的赌注名称之一。我们可能想要检查重复的赌注。我们可能还想要检查缩写的赌注名称。六个赌注中的每一个都有一个独特的首字母。

作为扩展，赌注也可以有一个金额。我们在第一章中的*使用正则表达式解析字符串*一节中研究了解析字符串的方法。在这个例子中，我们将简单处理赌注的名称：

```py
                def do_spin(self, arg_string): 
                    if len(self.bets) == 0: 
                        print("No bets have been placed") 
                        return 
                    # Happy path: more goes here. 

                BET_NAMES = set(['even', 'odd', 'high', 'low', 'red', 'black']) 

                def do_bet(self, arg_string): 
                    if arg_string not in BET_NAMES: 
                        print("{0} is not a valid bet".format(arg_string)) 
                        return 
                    # Happy path: more goes here. 

    ```

1.  为每个命令编写顺利路径处理。对于我们的例子，`spin`命令将解决赌注。`bet`命令将累积另一个赌注。这是`do_bet()`的顺利路径：

```py
            self.bets[arg_string] = 1 

    ```

我们已经将用户的赌注添加到`self.bets`映射中，并标明了金额。在这个例子中，我们将所有的赌注都视为具有相同的最小金额。

1.  这是`do_spin()`的顺利路径，解决了所有的赌注：

```py
            self.spin = random.choice(self.wheel) 
            print("Spin", self.spin) 
            label, winners = self.spin 
            for b in self.bets: 
                if b in winners: 
                    self.stake += self.bets[b] 
                    print("Win", b) 
                else: 
                    self.stake -= self.bets[b] 
                    print("Lose", b) 
            self.bets= {} 

    ```

首先，我们旋转轮盘以获得一个获胜的赌注。然后，我们检查玩家的每个赌注，看看哪些与获胜的赌注匹配。如果玩家的赌注`b`在获胜的赌注集合中，我们将增加他们的赌注。否则，我们将减少他们的赌注。

在这个例子中，所有的赌注都是 1:1。如果我们想要扩展到其他类型的赌注，我们必须为各种赌注提供适当的赔率。

1.  编写主脚本。这将创建该类的一个实例并执行`cmdloop()`方法：

```py
            if __name__ == "__main__": 
                r = Roulette() 
                r.cmdloop() 

    ```

我们创建了`Cmd`子类`Roulette`的一个实例。当我们执行`cmdloop()`方法时，该类将写入任何提供的介绍性消息，写入提示符，并读取命令。

## 它是如何工作的...

`Cmd`模块包含大量内置功能，用于显示提示符，从用户那里读取输入，然后根据用户的输入找到正确的方法。

例如，当我们输入`bet black`时，`Cmd`超类的内置方法将从输入中剥离第一个单词`bet`，将其前缀为`do_`，然后评估实现该命令的方法。

如果没有 `do_bet()` 方法，命令处理器将写入错误消息。这是自动完成的，我们不需要编写任何代码。

由于我们编写了一个 `do_bet()` 方法，这将被调用。在这种情况下，命令后的文本 `black` 将作为位置参数值提供。

一些方法，如 `do_help()` ，已经是应用程序的一部分。这些方法将总结其他 `do_*` 方法。当我们的方法有文档字符串时，这可以通过内置的帮助功能显示出来。

`Cmd` 类依赖于 Python 的内省功能。类的实例可以检查方法名称，以定位所有以 `do_` 开头的方法。它们在类级别的 `__dict__` 属性中可用。内省是一个高级主题，将在第七章中涉及，*更高级的类设计*。

## 还有更多...

`Cmd` 类有许多其他地方可以添加交互功能：

+   我们可以定义 `help_*()` 方法，这些方法将成为杂项帮助主题的一部分。

+   当任何 `do_*` 方法返回一个值时，循环将结束。我们可能想要添加一个 `do_quit()` 方法，其主体为 `return True`。这将结束命令处理循环。

+   我们可能会提供一个名为 `emptyline()` 的方法来响应空行。一种选择是安静地什么也不做。另一个常见选择是当用户不输入命令时采取默认操作。

+   当用户的输入与任何 `do_*` 方法都不匹配时，将评估 `default()` 方法。这可能用于更高级的输入解析。

+   `postloop()` 方法可用于在循环结束后进行一些处理。这将是写总结的好地方。这还需要一个返回值的 `do_*` 方法——任何非 `False` 值——来结束命令循环。

此外，我们还可以设置许多属性。这些是类级别的变量，将成为方法定义的对等体：

+   `prompt` 属性是要写的提示字符串。对于我们的示例，我们可以这样做：

```py
            class Roulette(cmd.Cmd): 
                prompt="Roulette> " 

    ```

+   `intro` 属性是介绍性消息。

+   我们可以通过设置 `doc_header` 、 `undoc_header` 、 `misc_header` 和 `ruler` 属性来定制帮助输出。这些都将改变帮助输出的外观。

目标是能够创建一个处理用户交互的整洁类，这种类的方式既简单又灵活。这个类创建了一个应用程序，它与 Python 的 REPL 有许多共同特征。它还具有许多命令行程序的特点，这些程序提示用户输入。

这些交互应用程序的一个例子是 Linux 中的命令行 FTP 客户端。它有一个提示符 `ftp>` ，并解析数十个单独的 FTP 命令。输入 `help` 将显示所有属于 FTP 交互的各种内部命令。

## 另请参阅

+   我们将在第六章和第七章中查看类定义，*类和对象的基础*和*更高级的类设计*。

# 使用操作系统环境设置

有几种方法可以查看用户输入的时间跨度：

+   交互数据：这是由用户在一种*现在*时间跨度内提供的。

+   程序启动时提供的命令行参数：这些值通常跨越程序的一个完整执行。

+   在操作系统级别设置的环境变量：这些可以在命令行中设置，使它们几乎与启动应用程序的命令一样交互。

+   它们可以在 `.bashrc` 文件或 `.profile` 文件中为用户配置。这使它们比命令行更持久，稍微不那么交互。

+   在 Windows 中，有**高级设置**选项，允许某人设置长期配置。这些通常是多次执行程序的输入。

+   配置文件设置：这些因应用程序而异。其思想是编辑一个文件，并使这些选项或参数长时间可用。这些可能适用于多个用户，甚至适用于所有用户。配置文件通常具有最长的时间跨度。

在*使用 input()和 getpass()进行用户输入*和*使用 cmd 创建命令行应用程序*配方中，我们研究了与用户的交互。在*使用 argparse 获取命令行输入*配方中，我们研究了如何处理命令行参数。我们将在第十三章中研究配置文件，*应用集成*。

环境变量可通过`os`模块获得。我们如何可以基于这些操作系统级别的设置来配置应用程序？

## 准备工作

我们可能希望通过操作系统设置向程序提供各种类型的信息。这里存在一个深刻的限制：操作系统设置只能是字符串值。这意味着许多种设置将需要一些代码来解析值，并从字符串创建适当的 Python 对象。

当我们使用`argparse`解析命令行参数时，这个模块可以为我们做一些数据转换。当我们使用`os`处理环境变量时，我们将不得不自己实现转换。

在*使用 argparse 获取命令行输入*配方中，我们将`haversine()`函数包装在一个简单的应用程序中，解析命令行参数。

在操作系统级别上，我们创建了一个像这样工作的程序：

```py
 **slott$ python3 ch05_r04.py -r KM 36.12,-86.67 33.94,-118.40** 

 **From (36.12, -86.67) to (33.94, -118.4) in KM = 2887.35** 

```

使用了一段时间后，我们发现我们经常使用海里来计算从我们的船锚定的地方到达的距离。我们真的希望为输入点和`-r`参数之一设置默认值。

由于船只可以停泊在各种地方，我们需要更改默认值，而无需调整实际代码。

我们将设置一个名为`UNITS`的操作系统环境变量，其中包含距离单位。我们可以设置另一个变量`HOME_PORT`，其中包含家庭点。我们希望能够执行以下操作：

```py
 **slott$ UNITS=NM** 

 **slott$ HOME_PORT=36.842952,-76.300171** 

 **slott$ python3 ch05_r06.py 36.12,-86.67** 

 **From 36.12,-86.67 to 36.842952,-76.300171 in NM = 502.23** 

```

单位和家庭点值通过操作系统环境提供给应用程序。这可以在配置文件中设置，以便我们可以轻松进行更改。也可以手动设置，如示例所示。

## 如何做...

1.  导入`os`模块。操作系统环境可通过此模块获得：

```py
            import os 

    ```

1.  导入应用程序所需的任何其他类或对象：

```py
            from ch03_r05 import haversine, MI, NM, KM 

    ```

1.  定义一个函数，该函数将使用环境值作为可选命令行参数的默认值。要解析的默认参数集来自`sys.argv`，因此还重要的是要导入`sys`模块：

```py
            def get_options(argv=sys.argv): 

    ```

1.  从操作系统环境设置中收集默认值。这包括任何所需的验证：

```py
            default_units = os.environ.get('UNITS', 'KM') 
            if default_units not in ('KM', 'NM', 'MI'): 
                sys.exit("Invalid value for UNITS, not KM, NM, or MI") 
            default_home_port = os.environ.get('HOME_PORT') 

    ```

`sys.exit()`函数很好地处理了错误处理。它将打印消息并以非零状态代码退出。

1.  创建`parser`属性。为相关参数提供任何默认值。这取决于`argparse`模块，也必须导入：

```py
                      parser = argparse.ArgumentParser() 
            parser.add_argument('-r', action='store', 
                choices=('NM', 'MI', 'KM'), default=default_units) 
            parser.add_argument('p1', action='store', type=point_type) 
            parser.add_argument('p2', nargs='?', action='store', type=point_type, 
                default=default_home_port) 
            options = parser.parse_args(argv[1:]) 

    ```

1.  进行任何额外的验证以确保参数正确设置。在这个例子中，可能没有为`HOME_PORT`设置值，也没有为第二个命令行参数提供值。这需要一个`if`语句和对`sys.exit()`的调用：

```py
                    if options.p2 is None: 
                    sys.exit("Neither HOME_PORT nor p2 argument provided.") 

    ```

1.  返回具有一组有效参数的`options`对象：

```py
            return options 

    ```

这将允许`-r`参数和第二个点完全是可选的。如果这些参数从命令行中省略，参数解析器将使用配置信息提供默认值。

使用*使用 argparse 获取命令行输入*配方来处理`get_options()`函数创建的选项的方法。

## 它是如何工作的...

我们使用操作系统环境变量创建可以被命令行参数覆盖的默认值。如果环境变量已设置，那么该字符串将作为参数定义的默认值。如果环境变量未设置，则使用应用程序级别的默认值。

在`UNITS`变量的情况下，如果未设置操作系统环境变量，则应用程序使用公里作为默认值。

这给我们三个层次的交互：

+   我们可以在`.bashrc`文件中定义一个设置。或者，我们可以使用 Windows 的**高级设置**选项来进行持久性更改。这个值将在每次登录或创建新的命令窗口时使用。

+   我们可以在命令行上交互地设置操作系统环境。这将持续到我们的会话结束。当我们注销或关闭命令窗口时，这个值将丢失。

+   我们可以通过命令行参数每次运行程序时提供一个唯一的值。

请注意，从环境变量中检索的值没有内置或自动验证。我们需要验证这些字符串，以确保它们是有意义的。

还要注意，我们在几个地方重复列出了有效单位的列表。这违反了**不要重复自己**（**DRY**）原则。使用这个列表的全局变量是一个很好的改进。

## 还有更多...

*使用 argparse 获取命令行输入*示例展示了处理来自`sys.argv`的默认命令行参数的略有不同的方法。第一个参数是正在执行的 Python 应用程序的名称，通常与参数解析无关。

`sys.argv`的值将是以下字符串列表：

```py
    ['ch05_r06.py', '-r', 'NM', '36.12,-86.67'] 

```

我们必须在处理过程中的某个时候跳过`sys.argv[0]`中的初始值。我们有两种选择：

+   在这个示例中，我们尽可能晚地在解析过程中丢弃多余的项目。当提供`sys.argv[1：]`给解析器时，第一个项目将被跳过。

+   在前面的示例中，我们在处理过程中更早地丢弃了该值。`main()`函数使用`options = get_options(sys.argv[1:])`向解析器提供了更短的列表。

一般来说，这两种方法之间唯一相关的区别取决于单元测试的数量和复杂性。这个示例将需要一个包含初始参数字符串的单元测试，在解析过程中将被丢弃。

## 另请参阅

+   我们将看到处理配置文件的多种方法在第十三章中，*应用集成*

![](img/614271.jpg)
