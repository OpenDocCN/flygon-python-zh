- en: APIs and Intent-Driven Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API和意图驱动的网络
- en: In [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml), *Low-Level Network
    Device Interactions*, we looked at ways to interact with the network devices using
    Pexpect and Paramiko. Both of these tools use a persistent session that simulates
    a user typing in commands as if they are sitting in front of a Terminal. This
    works fine up to a point. It is easy enough to send commands over for execution
    on the device and capture the output. However, when the output becomes more than
    a few lines of characters, it becomes difficult for a computer program to interpret
    the output. The returned output from Pexpect and Paramiko is a series of characters
    meant to be read by a human being. The structure of the output consists of lines
    and spaces that are human-friendly but difficult to be understood by computer
    programs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml)中，*低级网络设备交互*，我们看了一下使用Pexpect和Paramiko与网络设备进行交互的方法。这两个工具都使用了一个模拟用户在终端前输入命令的持久会话。这在一定程度上是有效的。很容易发送命令以在设备上执行并捕获输出。然而，当输出超过几行字符时，计算机程序很难解释输出。Pexpect和Paramiko返回的输出是一系列字符，是为人类阅读而设计的。输出的结构包括了人类友好的行和空格，但对计算机程序来说很难理解。
- en: In order for our computer programs to automate many of the tasks we want to
    perform, we need to interpret the returned results and make follow-up actions
    based on the returned results. When we cannot accurately and predictably interpret
    the returned results, we cannot execute the next command with confidence.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的计算机程序自动化执行我们想要执行的许多任务，我们需要解释返回的结果，并根据返回的结果采取后续行动。当我们无法准确和可预测地解释返回的结果时，我们无法有信心执行下一个命令。
- en: Luckily, this problem was solved by the internet community. Imagine the difference
    between a computer and a human being when they are both reading a web page. The
    human sees words, pictures, and spaces interpreted by the browser; the computer
    sees raw HTML code, Unicode characters, and binary files. What happens when a
    website needs to become a web service for another computer? The same web resources
    need to accommodate both human clients and other computer programs. Doesn't this
    problem sound familiar to the one that we presented before? The answer is the **Application
    Program Interface** (**API**). It is important to note that an API is a concept
    and not a particular technology or framework, according to Wikipedia.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个问题已经被互联网社区解决了。想象一下当计算机和人类都在阅读网页时的区别。人类看到的是浏览器解释的单词、图片和空格；计算机看到的是原始的HTML代码、Unicode字符和二进制文件。当一个网站需要成为另一个计算机的网络服务时会发生什么？同样的网络资源需要同时适应人类客户和其他计算机程序。这个问题听起来是不是很熟悉？答案就是**应用程序接口**（**API**）。需要注意的是，根据维基百科的说法，API是一个概念，而不是特定的技术或框架。
- en: In computer programming, an **Application Programming Interface** (**API**)
    is a set of subroutine definitions, protocols, and tools for building application
    software. In general terms, it's a set of clearly defined methods of communication
    between various software components. A good API makes it easier to develop a computer
    program by providing all the building blocks, which are then put together by the
    programmer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程中，**应用程序编程接口**（**API**）是一组子程序定义、协议和用于构建应用软件的工具。一般来说，它是各种软件组件之间清晰定义的通信方法集。一个好的API通过提供所有构建块，使得开发计算机程序更容易，然后由程序员组合在一起。
- en: 'In our use case, the set of clearly defined methods of communication would
    be between our Python program and the destination device. The APIs from our network
    devices provide a separate interface for the computer programs. The exact API
    implementation is vendor specific. One vendor will prefer XML over JSON, some
    might provide HTTPS as the underlying transport protocol, and others might provide
    Python libraries as wrappers. Despite the differences, the idea of an API remains
    the same: it is a separate communication method optimized for other computer programs.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的用例中，清晰定义的通信方法集将在我们的Python程序和目标设备之间。我们的网络设备API提供了一个独立的接口供计算机程序使用。确切的API实现是特定于供应商的。一个供应商可能更喜欢XML而不是JSON，有些可能提供HTTPS作为底层传输协议，而其他供应商可能提供Python库作为包装器。尽管存在差异，API的概念仍然是相同的：它是一种为其他计算机程序优化的独立通信方法。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Treating infrastructure as code, intent-driven networking, and data modeling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基础设施视为代码、意图驱动的网络和数据建模
- en: Cisco NX-API and the application-centric infrastructure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思科NX-API和面向应用的基础设施
- en: Juniper NETCONF and PyEZ
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Juniper NETCONF和PyEZ
- en: Arista eAPI and PyEAPI
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arista eAPI和PyEAPI
- en: Infrastructure as code
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施即代码
- en: In a perfect world, network engineers and architects who design and manage networks
    should focus on what they want the network to achieve instead of the device-level
    interactions. In my first job as an intern for a local ISP, wide-eyed and excited,
    my first assignment was to install a router on a customer's site to turn up their
    fractional frame relay link (remember those?). How would I do that? I asked. I
    was handed a standard operating procedure for turning up frame relay links. I
    went to the customer site, blindly typed in the commands, and looked at the green
    lights flashing, then happily packed my bag and patted myself on the back for
    a job well done. As exciting as that first assignment was, I did not fully understand
    what I was doing. I was simply following instructions without thinking about the
    implication of the commands I was typing in. How would I troubleshoot something
    if the light was red instead of green? I think I would have called back to the
    office and cried for help (tears optional).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个完美的世界里，设计和管理网络的网络工程师和架构师应该关注网络应该实现的目标，而不是设备级别的交互。在我作为当地ISP的实习生的第一份工作中，我兴奋地安装了一个路由器在客户现场，打开了他们的分段帧中继链路（还记得那些吗？）。我应该怎么做？我问道。我拿到了一个打开帧中继链路的标准操作流程。我去了客户现场，盲目地输入命令，看着绿灯闪烁，然后高兴地收拾行李，为自己的工作感到自豪。尽管第一份工作很令人兴奋，但我并没有完全理解我在做什么。我只是在按照指示行事，没有考虑我输入的命令的影响。如果灯是红色而不是绿色，我该如何排除故障？我想我会打电话回办公室求助（泪水可选）。
- en: Of course, network engineering is not about typing in commands into a device,
    but it is about building a way that allows services to be delivered from one point
    to another with as little friction as possible. The commands we have to use and
    the output that we have to interpret are merely means to an end. In other words,
    we should be focused on our intent for the network. What we want our network to
    achieve is much more important than the command syntax we use to get the device
    to do what we want it to do. If we further extract that idea of describing our
    intent as lines of code, we can potentially describe our whole infrastructure
    as a particular state. The infrastructure will be described in lines of code with
    the necessary software or framework enforcing that state.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，网络工程不是关于在设备上输入命令，而是建立一种允许服务尽可能顺畅地从一点传递到另一点的方式。我们必须使用的命令和我们必须解释的输出只是达到目的的手段。换句话说，我们应该专注于网络的意图。我们想要网络实现的目标比我们用来让设备做我们想让它做的命令语法更重要。如果我们进一步提取描述我们意图的代码行的想法，我们可以潜在地将我们整个基础设施描述为特定状态。基础设施将在代码行中描述，并有必要的软件或框架强制执行该状态。
- en: Intent-Driven Networking
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于意图驱动的网络
- en: Since the publication of the first edition of this book, the term **Intent-Based
    Networking** has seen an uptick in use after major network vendors chose to use
    it to describe their next-generation devices. In my opinion, **Intent-Driven Networking**
    is the idea of defining a state that the network should be in and having software
    code to enforce that state. As an example, if my goal is to block port 80 from
    being externally accessible, that is how I should declare it as the intention
    of the network. The underlying software will be responsible for knowing the syntax
    of configuring and applying the necessary access-list on the border router to
    achieve that goal. Of course, Intent-Driven Networking is an idea with no clear
    answer on the exact implementation. But the idea is simple and clear, I would
    hereby argue that we should focus as much on the intent of the network and abstract
    ourselves from the device-level interaction.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 自从这本书第一版出版以来，“基于意图的网络”这个术语在主要网络供应商选择将其用于描述其下一代设备后得到了更多的使用。在我看来，“基于意图驱动的网络”是定义网络应该处于的状态，并有软件代码来强制执行该状态的想法。举个例子，如果我的目标是阻止端口80被外部访问，那么我应该将这个作为网络意图声明。底层软件将负责知道配置和应用必要的访问控制列表的语法在边界路由器上实现这个目标。当然，“基于意图驱动的网络”是一个没有明确实现的想法。但这个想法很简单明了，我在此要主张我们应该更多地关注网络的意图，并摆脱设备级别的交互。
- en: In using an API, it is my opinion that it gets us closer to a state of intent-driven
    networking. In short, because we abstract the layer of a specific command executed
    on our destination device, we focus on our intent instead of the specific commands.
    For example, going back to our `block port 80` access-list example, we might use
    access-list and access-group on a Cisco and filter-list on a Juniper. However,
    in using an API, our program can start asking the executor for their intent while
    masking what kind of physical device it is they are talking to. We can even use
    a higher-level declarative framework, such as Ansible, which we will cover in
    [Chapter 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml), *The Python Automation
    Framework – Ansible Basics*. But for now, let's focus on network APIs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用API时，我认为这让我们更接近基于意图驱动的网络的状态。简而言之，因为我们抽象了在目标设备上执行的特定命令的层，我们关注的是我们的意图，而不是具体的命令。例如，回到我们的“阻止端口80”的访问控制列表的例子，我们可能在思科上使用访问控制列表和访问组，而在Juniper上使用过滤列表。然而，在使用API时，我们的程序可以开始询问执行者的意图，同时掩盖他们正在与何种物理设备交流。我们甚至可以使用更高级的声明性框架，比如Ansible，我们将在第4章中介绍，即《Python自动化框架-
    Ansible基础》。但现在，让我们专注于网络API。
- en: Screen scraping versus API structured output
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕抓取与API结构化输出
- en: 'Imagine a common scenario where we need to log into the network device and
    make sure all the interfaces on the devices are in an up/up state (both the status
    and the protocol are showing as `up`). For the human network engineers getting
    into a Cisco NX-OS device, it is simple enough to issue the `show IP interface
    brief` command in the Terminal to easily tell from the output which interface
    is up:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个常见的情景，我们需要登录到网络设备，并确保设备上的所有接口都处于up/up状态（状态和协议都显示为`up`）。对于人类网络工程师来说，登录到Cisco
    NX-OS设备，通过终端发出`show IP interface brief`命令就足够简单，可以轻松地从输出中看出哪个接口是up的：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The line break, white spaces, and the first line of the column title are easily
    distinguished from the human eye. In fact, they are there to help us line up,
    say, the IP addresses of each interface from line one to line two and three. If
    we were to put ourselves in the computer''s position, all these spaces and line
    breaks only takes us away from the really important output, which is: which interfaces
    are in the up/up state? To illustrate this point, we can look at the Paramiko
    output for the same operation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 换行符、空格和列标题的第一行很容易从人眼中区分出来。事实上，它们是为了帮助我们对齐，比如说，从第一行到第二行和第三行的每个接口的IP地址。如果我们把自己放在计算机的位置上，所有这些空格和换行只会让我们远离真正重要的输出，那就是：哪些接口处于up/up状态？为了说明这一点，我们可以看一下相同操作的Paramiko输出：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we were to parse out that data, here is what I would do in a pseudo-code
    fashion (simplified representation of the code I would write):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要解析出这些数据，我会以伪代码的方式进行如下操作（简化了我将要编写的代码的表示方式）：
- en: Split each line via the line break.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过换行符分割每一行。
- en: I may or may not need the first line that contains the executed command of `show
    ip interface brief`. For now, I don't think I need it.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我可能不需要包含`show ip interface brief`执行命令的第一行。目前，我认为我不需要它。
- en: Take out everything on the second line up until the VRF, and save it in a variable
    as we want to know which VRF the output is showing.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除第二行直到VRF的所有内容，并将其保存在一个变量中，因为我们想知道输出显示的是哪个VRF。
- en: For the rest of the lines, because we do not know how many interfaces there
    are, we will use a regular expression statement to search if the line starts with
    possible interfaces, such as `lo` for loopback and `Eth` for Ethernet interfaces.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于其余的行，因为我们不知道有多少个接口，我们将使用正则表达式语句来搜索行是否以可能的接口开头，比如`lo`表示环回接口，`Eth`表示以太网接口。
- en: We will need to split this line into three sections via space, each consisting
    of the name of the interface, IP address, and then the interface status.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要通过空格将这行分成三个部分，每个部分包括接口名称、IP地址，然后是接口状态。
- en: The interface status will then be split further using the forward slash (`/`)
    to give us the protocol, link, and the admin status.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后进一步使用斜杠(`/`)分割接口状态，以获取协议、链路和管理状态。
- en: 'Whew, that is a lot of work just for something that a human being can tell
    at a glance! You might be able to optimize the code and the number of lines, but
    in general this is what we need to do when we need to screen scrap something that
    is somewhat unstructured. There are many downsides to this method, but some of
    the bigger problems that I can see are listed as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这需要大量的工作，而人类一眼就能看出来！你可能能够优化代码和行数，但总的来说，当我们需要屏幕抓取一些结构不太清晰的东西时，这就是我们需要做的。这种方法有许多缺点，但我能看到的一些更大的问题列在下面：
- en: '**Scalability**: We spent so much time on painstaking details to parse out
    the outputs from each command. It is hard to imagine how we can do this for the
    hundreds of commands that we typically run.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：我们花了很多时间来仔细解析每个命令的输出。很难想象我们如何能够对我们通常运行的数百个命令进行这样的操作。'
- en: '**Predictability**: There is really no guarantee that the output stays the
    same between different software versions. If the output is changed ever so slightly,
    it might just render our hard-earned battle of information gathering useless.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可预测性**：实际上并没有保证输出在不同软件版本之间保持不变。如果输出稍有变化，可能会使我们辛苦收集的信息变得毫无用处。'
- en: '**Vendor and software lock-in**: Perhaps the biggest problem is that once we
    spend all this time parsing the output for this particular vendor and software
    version, in this case, Cisco NX-OS, we need to repeat this process for the next
    vendor that we pick. I don''t know about you, but if I were to evaluate a new
    vendor, the new vendor is at a severe on-boarding disadvantage if I have to rewrite
    all the screen scrap code again.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应商和软件锁定**：也许最大的问题是，一旦我们花费了所有这些时间来解析特定供应商和软件版本（在本例中为Cisco NX-OS）的输出，我们需要重复这个过程来选择下一个供应商。我不知道你怎么看，但如果我要评估一个新的供应商，如果我不得不重新编写所有的屏幕抓取代码，那么新的供应商就处于严重的入门劣势。'
- en: 'Let''s compare that with an output from an NX-API call for the same `show IP
    interface brief` command. We will go over the specifics of getting this output
    from the device later in this chapter, but what is important here is to compare
    the following output to the previous screen scraping output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其与相同`show IP interface brief`命令的NX-API调用输出进行比较。我们将在本章后面详细介绍如何从设备中获取此输出，但这里重要的是将以下输出与先前的屏幕抓取输出进行比较：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: NX-API can return output in XML or JSON, and this is the JSON output that we
    are looking at. Right away, you can see the output is structured and can be mapped
    directly to the Python dictionary data structure. There is no parsing required—you
    can simply pick the key and retrieve the value associated with the key. You can
    also see from the output that there are various metadata in the output, such as
    the success or failure of the command. If the command fails, there will be a message
    telling the sender the reason for the failure. You no longer need to keep track
    of the command issued, because it is already returned to you in the `input` field.
    There is also other useful metadata in the output, such as the NX-API version.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: NX-API可以返回XML或JSON格式的输出，这是我们正在查看的JSON输出。您可以立即看到输出是结构化的，并且可以直接映射到Python字典数据结构。无需解析-您只需选择键并检索与键关联的值。您还可以从输出中看到各种元数据，例如命令的成功或失败。如果命令失败，将显示一条消息，告诉发送者失败的原因。您不再需要跟踪已发出的命令，因为它已在“输入”字段中返回给您。输出中还有其他有用的元数据，例如NX-API版本。
- en: This type of exchange makes life easier for both vendors and operators. On the
    vendor side, they can easily transfer configuration and state information. They
    can add extra fields when the need to expose additional data arises using the
    same data structure. On the operator side, they can easily ingest the information
    and build their infrastructure around it. It is generally agreed on that automation
    is much needed and a good thing. The questions are usually centered on the format
    and structure of the automation. As you will see later in this chapter, there
    are many competing technologies under the umbrella of API. On the transport side
    alone, we have REST API, NETCONF, and RESTCONF, among others. Ultimately, the
    overall market might decide about the final data format in the future. In the
    meantime, each of us can form our own opinions and help drive the industry forward.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的交换使供应商和运营商的生活更加轻松。对于供应商来说，他们可以轻松地传输配置和状态信息。当需要公开额外数据时，他们可以使用相同的数据结构添加额外字段。对于运营商来说，他们可以轻松地摄取信息并围绕它构建基础设施。一般认为自动化是非常需要的，也是一件好事。问题通常集中在自动化的格式和结构上。正如您将在本章后面看到的，API的伞下有许多竞争技术。仅在传输方面，我们有REST
    API、NETCONF和RESTCONF等。最终，整体市场可能会决定未来的最终数据格式。与此同时，我们每个人都可以形成自己的观点，并帮助推动行业向前发展。
- en: Data modeling for infrastructure as code
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施的数据建模
- en: 'According to Wikipedia ([https://en.wikipedia.org/wiki/Data_model](https://en.wikipedia.org/wiki/Data_model)),
    the definition for a data model is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科（[https://en.wikipedia.org/wiki/Data_model](https://en.wikipedia.org/wiki/Data_model)）的定义，数据模型的定义如下：
- en: A data model is an abstract model that organizes elements of data and standardizes
    how they relate to one another and to properties of the real-world entities. For
    instance, a data model may specify that the data element representing a car be
    composed of a number of other elements which, in turn, represent the color and
    size of the car and define its owner.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 数据模型是一个抽象模型，它组织数据元素并规范它们之间以及与现实世界实体属性的关系。例如，数据模型可以指定代表汽车的数据元素由许多其他元素组成，这些元素反过来代表汽车的颜色和大小，并定义其所有者。
- en: 'The data modeling process can be illustrated in the following diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 数据建模过程可以用以下图表来说明：
- en: '![](assets/2c817be7-d41c-47bd-929a-130e1a63fd87.png)Data modeling process'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2c817be7-d41c-47bd-929a-130e1a63fd87.png)数据建模过程'
- en: When applied to the network, we can apply this concept as an abstract model
    that describes our network, be it a data center, campus, or global wide area network.
    If we take a closer look at a physical data center, a layer 2 Ethernet switch
    can be thought of as a device containing a table of MAC addresses mapped to each
    port. Our switch data model describes how the MAC address should be kept in a
    table, which includes the keys, additional characteristics (think of VLAN and
    private VLAN), and more. Similarly, we can move beyond devices and map the whole
    data center in a model. We can start with the number of devices in each of the
    access, distribution, and core layers, how they are connected, and how they should
    behave in a production environment. For example, if we have a fat-tree network,
    how many links should each of the spine routers have, how many routes they should
    contain, and how many next-hops should each of the prefixes have? These characteristics
    can be mapped out in a format that can be referenced against the ideal state that
    we should always check against.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于网络时，我们可以将这个概念应用为描述我们的网络的抽象模型，无论是数据中心、校园还是全球广域网。如果我们仔细观察物理数据中心，可以将层2以太网交换机视为包含MAC地址映射到每个端口的设备。我们的交换机数据模型描述了MAC地址应该如何保存在表中，其中包括键、附加特性（考虑VLAN和私有VLAN）等。同样，我们可以超越设备，将整个数据中心映射到一个模型中。我们可以从每个接入、分发和核心层中的设备数量开始，它们是如何连接的，以及它们在生产环境中应该如何行为。例如，如果我们有一个fat-tree网络，每个脊柱路由器应该有多少链接，它们应该包含多少路由，每个前缀应该有多少下一跳？这些特性可以以一种格式映射出来，可以与我们应该始终检查的理想状态进行对比。
- en: One of the relatively new network data modeling languages that is gaining traction
    is **Yet Another Next Generation** (**YANG**) (despite common belief, some of
    the IETF workgroups do have a sense of humor). It was first published in RFC 6020
    in 2010, and has since gained traction among vendors and operators. At the time
    of writing, the support for YANG has varied greatly from vendors to platforms.
    The adaptation rate in production is therefore relatively low. However, it is
    a technology worth keeping an eye out for.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**另一种下一代**（**YANG**）是一种相对新的网络数据建模语言，正在受到关注（尽管一般的看法是，一些IETF工作组确实有幽默感）。它首次在2010年的RFC
    6020中发布，并且自那时以来在供应商和运营商中得到了广泛的应用。在撰写本文时，对YANG的支持在供应商和平台之间差异很大。因此，生产中的适应率相对较低。但是，这是一项值得关注的技术。'
- en: The Cisco API and ACI
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思科API和ACI
- en: Cisco Systems, the 800-pound gorilla in the networking space, have not missed
    out on the trend of network automation. In their push for network automation,
    they have made various in-house developments, product enhancements, partnerships,
    as well as many external acquisitions. However, with product lines spanning routers,
    switches, firewalls, servers (unified computing), wireless, the collaboration
    software and hardware, and analytic software, to name a few, it is hard to know
    where to start.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 思科系统是网络领域的800磅大猩猩，在网络自动化的趋势中没有落后。在推动网络自动化的过程中，他们进行了各种内部开发、产品增强、合作伙伴关系，以及许多外部收购。然而，由于产品线涵盖路由器、交换机、防火墙、服务器（统一计算）、无线、协作软件和硬件以及分析软件等，要知道从哪里开始是很困难的。
- en: 'Since this book focuses on Python and networking, we will scope this section
    to the main networking products. In particular, we will cover the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这本书侧重于Python和网络，我们将把这一部分范围限定在主要的网络产品上。特别是，我们将涵盖以下内容：
- en: Nexus product automation with NX-API
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NX-API的Nexus产品自动化
- en: Cisco NETCONF and YANG examples
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思科NETCONF和YANG示例
- en: The Cisco application-centric infrastructure for the data center
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据中心的思科应用中心基础设施
- en: The Cisco application-centric infrastructure for the enterprise
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业级思科应用中心基础设施
- en: For the NX-API and NETCONF examples here, we can either use the Cisco DevNet
    always-on lab devices or locally run Cisco VIRL. Since ACI is a separate product
    and is licensed with the physical switches for the following ACI examples, I would
    recommend using the DevNet labs to get an understanding of the tools. If you are
    one of the lucky engineers who has a private ACI lab that you can use, please
    feel free to use it for the relevant examples.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这里的NX-API和NETCONF示例，我们可以使用思科DevNet始终开启的实验室设备，或者在本地运行思科VIRL。由于ACI是一个独立的产品，并且在以下ACI示例中与物理交换机一起许可使用，我建议使用DevNet实验室来了解这些工具。如果你是那些有自己的私人ACI实验室可以使用的幸运工程师之一，请随意在相关示例中使用它。
- en: 'We will use the similar lab topology as we did in [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml),
    *Low-Level Network Device Interactions*, with the exception of one of the devices
    running nx-osv:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与[第2章](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml)中相同的实验拓扑，*低级网络设备交互*，只有一个设备运行nx-osv除外：
- en: '![](assets/f905b772-b032-4d3a-b935-4d5cdd6b0faf.png) Lab topology'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/f905b772-b032-4d3a-b935-4d5cdd6b0faf.png) 实验室拓扑'
- en: Let's take a look at NX-API.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看NX-API。
- en: Cisco NX-API
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思科NX-API
- en: Nexus is Cisco's primary product line of data center switches. The NX-API ([http://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus9000/sw/6-x/programmability/guide/b_Cisco_Nexus_9000_Ser](http://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus9000/sw/6-x/programmability/guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide_chapter_011.html)[ies_NX-OS_Programmability_Guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide_chapter_011.html](http://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus9000/sw/6-x/programmability/guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide_chapter_011.html))
    allows the engineer to interact with the switch outside of the device via a variety
    of transports including SSH, HTTP, and HTTPS.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Nexus是思科的主要数据中心交换机产品线。NX-API ([http://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus9000/sw/6-x/programmability/guide/b_Cisco_Nexus_9000_Ser](http://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus9000/sw/6-x/programmability/guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide_chapter_011.html)[ies_NX-OS_Programmability_Guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide_chapter_011.html](http://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus9000/sw/6-x/programmability/guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide_chapter_011.html))允许工程师通过各种传输方式与交换机进行交互，包括SSH、HTTP和HTTPS。
- en: Lab software installation and device preparation
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验室软件安装和设备准备
- en: 'Here are the Ubuntu packages that we will install. You may already have some
    of the packages such `pip` and `git`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将安装的Ubuntu软件包。你可能已经安装了一些软件包，比如`pip`和`git`：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you are using Python 2, use the following packages instead: `sudo apt-get
    install -y python-dev libxml2-dev libxslt1-dev libffi-dev libssl-dev zlib1g-dev
    python-pip git python-requests`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Python 2，使用以下软件包代替：`sudo apt-get install -y python-dev libxml2-dev libxslt1-dev
    libffi-dev libssl-dev zlib1g-dev python-pip git python-requests`。
- en: 'The `ncclient` ([https://github.com/ncclient/ncclient](https://github.com/ncclient/ncclient))
    library is a Python library for NETCONF clients. We will install this from the
    GitHub repository so that we can install the latest version:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`ncclient` ([https://github.com/ncclient/ncclient](https://github.com/ncclient/ncclient))库是一个用于NETCONF客户端的Python库。我们将从GitHub存储库中安装它，以便安装最新版本：'
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'NX-API on Nexus devices is turned off by default, so we will need to turn it
    on. We can either use the user that is already created (if you are using VIRL
    auto-config), or create a new user for the NETCONF procedures:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Nexus设备上的NX-API默认关闭，因此我们需要打开它。我们可以使用已经创建的用户（如果你使用的是VIRL自动配置），或者为NETCONF过程创建一个新用户：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For our lab, we will turn on both HTTP and the sandbox configuration, as they
    should be turned off in production:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的实验室，我们将同时打开HTTP和沙盒配置，因为它们在生产中应该关闭：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are now ready to look at our first NX-API example.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备看我们的第一个NX-API示例。
- en: NX-API examples
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NX-API示例
- en: 'NX-API sandbox is a great way to play around with various commands, data formats,
    and even copy the Python script directly from the web page. In the last step,
    we turned it on for learning purposes. It should be turned off in production.
    Let''s launch a web browser and take a look at the various message formats, requests,
    and responses based on the CLI commands that we are already familiar with:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: NX-API沙盒是一个很好的方式来玩各种命令、数据格式，甚至可以直接从网页上复制Python脚本。在最后一步，我们为了学习目的打开了它。在生产中应该关闭它。让我们打开一个网页浏览器，看看基于我们已经熟悉的CLI命令的各种消息格式、请求和响应。
- en: '![](assets/3d7aec04-66a7-4ecb-95c2-f19b17fd399a.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3d7aec04-66a7-4ecb-95c2-f19b17fd399a.png)'
- en: 'In the following example, I have selected `JSON-RPC` and the `CLI` command
    type for the `show version` command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我选择了`JSON-RPC`和`CLI`命令类型来执行`show version`命令：
- en: '![](assets/48fbd88d-cc73-4a69-aa66-fff954aaa457.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/48fbd88d-cc73-4a69-aa66-fff954aaa457.png)'
- en: The sandbox comes in handy if you are unsure about the supportability of the
    message format, or if you have questions about the response data field keys for
    the value you want to retrieve in your code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对消息格式的支持性不确定，或者对你想在代码中检索的值的响应数据字段键有疑问，沙盒会派上用场。
- en: 'In our first example, we are just going to connect to the Nexus device and
    print out the capabilities exchanged when the connection was first made:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，我们只是连接到Nexus设备，并在连接时打印出交换的能力：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The connection parameters of the host, port, username, and password are pretty
    self- explanatory. The device parameter specifies the kind of device the client
    is connecting to. We will see a different response in the Juniper NETCONF sections
    when using the ncclient library. The `hostkey_verify` bypasses the `known_host`
    requirement for SSH; if not, the host needs to be listed in the `~/.ssh/known_hosts`
    file. The `look_for_keys` option disables public-private key authentication, but
    uses a username and password for authentication.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 主机、端口、用户名和密码的连接参数都很容易理解。设备参数指定了客户端连接的设备类型。当使用ncclient库时，在Juniper NETCONF部分会看到不同的响应。`hostkey_verify`绕过了SSH的`known_host`要求；如果不绕过，主机需要列在`~/.ssh/known_hosts`文件中。`look_for_keys`选项禁用了公钥私钥认证，而是使用用户名和密码进行认证。
- en: If you run into an issue with [https://github.com/paramiko/paramiko/issues/748](https://github.com/paramiko/paramiko/issues/748) with
    Python 3 and Paramiko, please feel free to use Python 2\. Hopefully, by the time
    you read this section, the issue is already fixed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Python 3和Paramiko中遇到问题，请随时使用Python 2。希望在你阅读本节时，这个问题已经得到解决。
- en: 'The output will show the XML and NETCONF supported features by this version
    of NX-OS:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示这个版本的NX-OS支持的XML和NETCONF特性：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using ncclient and NETCONF over SSH is great because it gets us closer to the
    native implementation and syntax. We will use the same library later on in this
    book. For NX-API, it might be easier to deal with HTTPS and JSON-RPC. In the earlier
    screenshot of NX-API Developer Sandbox, if you noticed, in the Request box, there
    is a box labeled Python. If you click on it, you will be able to get an automatically
    converted Python script based on the request library.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ncclient和通过SSH的NETCONF非常好，因为它让我们更接近本地实现和语法。我们将在本书的后面使用相同的库。对于NX-API，处理HTTPS和JSON-RPC可能更容易。在NX-API开发者沙箱的早期截图中，如果你注意到，在请求框中，有一个标有Python的框。如果你点击它，你将能够获得一个基于请求库自动生成的Python脚本。
- en: The following script uses an external Python library named `requests`. `requests`
    is a very popular, self-proclaimed HTTP for the human library used by companies
    like Amazon, Google, NSA, and more. You can find more information about it on
    the official site ([http://docs.python-requests.org/en/master/](http://docs.python-requests.org/en/master/)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本使用了一个名为`requests`的外部Python库。`requests`是一个非常流行的、自称为人类的HTTP库，被亚马逊、谷歌、NSA等公司使用。你可以在官方网站上找到更多关于它的信息。
- en: 'For the `show version` example, the following Python script is automatically
    generated for you. I am pasting in the output without any modification:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`show version`的例子，以下Python脚本是自动生成的。我将输出粘贴在这里，没有进行任何修改：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `cisco_nxapi_2.py` script, you will see that I have only modified the
    URL, username, and password of the preceding file. The output was parsed to include
    only the software version. Here is the output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cisco_nxapi_2.py`脚本中，你会看到我只修改了前面文件的URL、用户名和密码。输出被解析为只包括软件版本。以下是输出：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The best part about using this method is that the same overall syntax structure
    works with both configuration commands as well as show commands. This is illustrated
    in the `cisco_nxapi_3.py` file. For multiline configuration, you can use the ID
    field to specify the order of operations. In `cisco_nxapi_4.py`, the following
    payload was listed for changing the description of the interface Ethernet 2/12
    in the interface configuration mode:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法的最好之处在于，相同的总体语法结构既适用于配置命令，也适用于显示命令。这在`cisco_nxapi_3.py`文件中有所体现。对于多行配置，你可以使用ID字段来指定操作的顺序。在`cisco_nxapi_4.py`中，列出了用于更改接口Ethernet
    2/12的描述的有效负载：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can verify the result of the previous configuration script by looking at
    the running-configuration of the Nexus device:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看Nexus设备的运行配置来验证前面配置脚本的结果：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the next section, we will look at some examples for Cisco NETCONF and the
    YANG model.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将看一些关于Cisco NETCONF和YANG模型的例子。
- en: The Cisco and YANG models
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cisco和YANG模型
- en: Earlier in this chapter, we looked at the possibility of expressing the network
    by using the data modeling language YANG. Let's look into it a little bit more
    with examples.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们探讨了使用数据建模语言YANG来表达网络的可能性。让我们通过例子再深入了解一下。
- en: 'First off, we should know that the YANG model only defines the type of data
    sent over the NETCONF protocol without dictating what the data should be. Secondly,
    it is worth pointing out that NETCONF exists as a standalone protocol, as we saw
    in the NX-API section. YANG, being relatively new, has a spotty supportability
    across vendors and product lines. For example, if we run the same capability exchange
    script that we have used before for a Cisco 1000v running IOS-XE, this is what
    we will see:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该知道YANG模型只定义了通过NETCONF协议发送的数据类型，而不规定数据应该是什么。其次，值得指出的是NETCONF存在作为一个独立的协议，正如我们在NX-API部分看到的那样。YANG作为相对较新的技术，在各个供应商和产品线之间的支持性不够稳定。例如，如果我们对运行IOS-XE的Cisco
    1000v运行相同的能力交换脚本，我们会看到这样的结果：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Compare this to the output that we saw for NX-OS. Clearly, IOS-XE supports the
    YANG model features more than NX-OS. Industry-wide, network data modeling when
    supported, is clearly something that can be used across your devices, which is
    beneficial for network automation. However, given the uneven support of vendors
    and products, it is not yet mature enough to be used exclusively for the production network,
    in my opinion. For this book, I have included a script called `cisco_yang_1.py`
    that shows how to parse out the NETCONF XML output with YANG filters called `urn:ietf:params:xml:ns:yang:ietf-interfaces`
    as a starting point to see the existing tag overlay.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将此与我们在NX-OS中看到的输出进行比较。显然，IOS-XE对YANG模型功能的支持要比NX-OS多。在整个行业范围内，当支持时，网络数据建模显然是可以跨设备使用的，这对于网络自动化是有益的。然而，鉴于供应商和产品的支持不均衡，我认为它还不够成熟，不能完全用于生产网络。对于本书，我包含了一个名为`cisco_yang_1.py`的脚本，演示了如何使用YANG过滤器`urn:ietf:params:xml:ns:yang:ietf-interfaces`来解析NETCONF
    XML输出的起点。
- en: You can check the latest vendor support on the YANG GitHub project page ([https://github.com/YangModels/yang/tree/master/vendor](https://github.com/YangModels/yang/tree/master/vendor)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在YANG GitHub项目页面上检查最新的供应商支持（[https://github.com/YangModels/yang/tree/master/vendor](https://github.com/YangModels/yang/tree/master/vendor)）。
- en: The Cisco ACI
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cisco ACI
- en: The Cisco **Application Centric Infrastructure** (**ACI**) is meant to provide
    a centralized approach to all of the network components. In the data center context,
    it means that the centralized controller is aware of and manages the spine, leaf,
    and top of rack switches, as well as all the network service functions. This can
    be done through GUI, CLI, or API. Some might argue that the ACI is Cisco's answer
    to the broader controller-based software-defined networking.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Cisco **Application Centric Infrastructure**（**ACI**）旨在为所有网络组件提供集中化的方法。在数据中心环境中，这意味着集中控制器知道并管理着脊柱、叶子和机架顶部交换机，以及所有网络服务功能。这可以通过GUI、CLI或API来实现。有人可能会认为ACI是思科对更广泛的基于控制器的软件定义网络的回应。
- en: One of the somewhat confusing points for ACI is the difference between ACI and
    APIC-EM. In short, ACI focuses on data center operations while APIC-EM focuses
    on enterprise modules. Both offer a centralized view and control of the network
    components, but each has its own focus and share of tool sets. For example, it
    is rare to see any major data center deploy a customer-facing wireless infrastructure,
    but a wireless network is a crucial part of enterprises today. Another example
    would be the different approaches to network security. While security is important
    in any network, in the data center environment, lots of security policies are
    pushed to the edge node on the server for scalability. In enterprise security,
    policies are somewhat shared between the network devices and servers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ACI而言，有点令人困惑的是ACI和APIC-EM之间的区别。简而言之，ACI专注于数据中心操作，而APIC-EM专注于企业模块。两者都提供了对网络组件的集中视图和控制，但每个都有自己的重点和工具集。例如，很少见到任何主要数据中心部署面向客户的无线基础设施，但无线网络是当今企业的重要组成部分。另一个例子是网络安全的不同方法。虽然安全在任何网络中都很重要，但在数据中心环境中，许多安全策略被推送到服务器的边缘节点以实现可伸缩性。在企业安全中，策略在网络设备和服务器之间有一定的共享。
- en: Unlike NETCONF RPC, ACI API follows the REST model to use the HTTP verb (`GET`,
    `POST`, `DELETE`) to specify the operation that's intended.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与NETCONF RPC不同，ACI API遵循REST模型，使用HTTP动词（`GET`，`POST`，`DELETE`）来指定所需的操作。
- en: We can look at the `cisco_apic_em_1.py` file, which is a modified version of
    the Cisco sample code on `lab2-1-get-network-device-list.py` ([https://github.com/CiscoDevNet/apicem-1.3-LL-sample-codes/blob/master/basic-labs/lab2-1-get-network-device-list.py](https://github.com/CiscoDevNet/apicem-1.3-LL-sample-codes/blob/master/basic-labs/lab2-1-get-network-device-list.py)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看`cisco_apic_em_1.py`文件，这是Cisco示例代码`lab2-1-get-network-device-list.py`的修改版本（[https://github.com/CiscoDevNet/apicem-1.3-LL-sample-codes/blob/master/basic-labs/lab2-1-get-network-device-list.py](https://github.com/CiscoDevNet/apicem-1.3-LL-sample-codes/blob/master/basic-labs/lab2-1-get-network-device-list.py)）。
- en: The abbreviated version without comments and spaces are listed in the following
    section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分列出了没有注释和空格的缩写版本。
- en: 'The first function named `getTicket()` uses HTTPS `POST` on the controller
    with the path of `/api/v1/ticket` with a username and password embedded in the
    header. This function will return the parsed response for a ticket that is only
    valid for a limited time:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`getTicket()`的第一个函数在控制器上使用HTTPS `POST`，路径为`/api/v1/ticket`，在标头中嵌入用户名和密码。此函数将返回仅在有限时间内有效的票证的解析响应：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The second function then calls another path called `/api/v1/network-devices`
    with the newly acquired ticket embedded in the header, then parses the results:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，第二个函数调用另一个名为`/api/v1/network-devices`的路径，并在标头中嵌入新获取的票证，然后解析结果：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is a pretty common workflow for API interactions. The client will authenticate
    itself with the server in the first request and receive a time-based token. This
    token will be used in subsequent requests and will be served as a proof of authentication.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是API交互的一个常见工作流程。客户端将在第一个请求中使用服务器进行身份验证，并接收一个基于时间的令牌。此令牌将在后续请求中使用，并将作为身份验证的证明。
- en: 'The output displays both the raw JSON response output as well as a parsed table.
    A partial output when executed against a DevNet lab controller is shown here:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了原始JSON响应输出以及解析后的表格。执行针对DevNet实验室控制器的部分输出如下所示：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we only query a single controller device, but we are able to
    get a high-level view of all the network devices that the controller is aware
    of. In our output, the Catalyst 2960-C switch, 3500 Access Points, 4400 ISR router,
    and 5500 Wireless Controller can all be explored further. The downside is, of
    course, that the ACI controller only supports Cisco devices at this time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们只查询了一个控制器设备，但我们能够高层次地查看控制器所知道的所有网络设备。在我们的输出中，Catalyst 2960-C交换机，3500接入点，4400
    ISR路由器和5500无线控制器都可以进一步探索。当然，缺点是ACI控制器目前只支持Cisco设备。
- en: The Python API for Juniper networks
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Juniper网络的Python API
- en: Juniper networks have always been a favorite among the service provider crowd.
    If we take a step back and look at the service provider vertical, it would make
    sense that automating network equipment is on the top of their list of requirements.
    Before the dawn of cloud-scale data centers, service providers were the ones with
    the most network equipment. A typical enterprise network might have a few redundant
    internet connections at the corporate headquarter with a few hub-and-spoke remote
    sites connected back to the HQ using the service provider's private MPLS network.
    To a service provider, they are the ones who need to build, provision, manage,
    and troubleshoot the connections and the underlying networks. They make their
    money by selling the bandwidth along with value-added managed services. It would
    make sense for the service providers to invest in automation to use the least
    amount of engineering hours to keep the network humming along. In their use case,
    network automation is the key to their competitive advantage.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Juniper网络一直是服务提供商群体中的最爱。如果我们退一步看看服务提供商垂直领域，自动化网络设备将是他们需求清单的首要任务。在云规模数据中心出现之前，服务提供商是拥有最多网络设备的人。一个典型的企业网络可能在公司总部有几个冗余的互联网连接，还有一些以枢纽-辐射方式连接回总部，使用服务提供商的私有MPLS网络。对于服务提供商来说，他们需要构建、配置、管理和排除连接和底层网络的问题。他们通过销售带宽以及增值的托管服务来赚钱。对于服务提供商来说，投资于自动化以使用最少的工程小时数来保持网络运行是合理的。在他们的用例中，网络自动化是他们竞争优势的关键。
- en: In my opinion, the difference between a service provider's network needs compared
    to a cloud data center is that, traditionally, service providers aggregate more
    services into a single device. A good example would be **Multiprotocol Label Switching**
    (**MPLS**) that almost all major service providers provide but rarely adapt in
    the enterprise or data center networks. Juniper, as they have been very successful,
    has identified this need and excel at fulfilling the service provider requirements
    of automating. Let's take a look at some of Juniper's automation APIs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，服务提供商网络的需求与云数据中心相比的一个区别是，传统上，服务提供商将更多的服务聚合到单个设备中。一个很好的例子是**多协议标签交换**（**MPLS**），几乎所有主要的服务提供商都提供，但在企业或数据中心网络中很少使用。正如Juniper非常成功地发现了这一需求，并且在满足服务提供商自动化需求方面表现出色。让我们来看一下Juniper的一些自动化API。
- en: Juniper and NETCONF
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Juniper和NETCONF
- en: 'The **Network Configuration Protocol** (**NETCONF**) is an IETF standard, which
    was first published in 2006 as [RFC 4741](https://tools.ietf.org/html/rfc4741)
    and later revised in [RFC 6241](https://tools.ietf.org/html/rfc6241). Juniper
    networks contributed heavily to both of the RFC standards. In fact, Juniper was
    the sole author for RFC 4741\. It makes sense that Juniper devices fully support
    NETCONF, and it serves as the underlying layer for most of its automation tools
    and frameworks. Some of the main characteristics of NETCONF include the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络配置协议**（**NETCONF**）是一个IETF标准，最早于2006年发布为[RFC 4741](https://tools.ietf.org/html/rfc4741)，后来修订为[RFC
    6241](https://tools.ietf.org/html/rfc6241)。Juniper网络对这两个RFC标准做出了重大贡献。事实上，Juniper是RFC
    4741的唯一作者。Juniper设备完全支持NETCONF是合情合理的，并且它作为大多数自动化工具和框架的基础层。NETCONF的一些主要特点包括以下内容：'
- en: It uses **Extensible Markup Language** (**XML**) for data encoding.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用**可扩展标记语言**（**XML**）进行数据编码。
- en: It uses **Remote Procedure Calls** (**RPC**), therefore in the case of HTTP(s)
    as the transport, the URL endpoint is identical while the operation intended is
    specified in the body of the request.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用**远程过程调用**（**RPC**），因此在使用HTTP(s)作为传输方式时，URL端点是相同的，而所需的操作在请求的正文中指定。
- en: 'It is conceptually based on layers from top to bottom. The layers include the
    content, operations, messages, and transport:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在概念上是基于自上而下的层。这些层包括内容、操作、消息和传输：
- en: '![](assets/46006bbf-bde4-4219-b26e-451e09a7d384.png)NETCONF model'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/46006bbf-bde4-4219-b26e-451e09a7d384.png)NETCONF模型'
- en: Juniper networks provide an extensive NETCONF XML management protocol developer
    guide ([https://www.juniper.net/techpubs/en_US/junos13.2/information-products/pathway-pages/netconf-guide/netconf.html#overview](https://www.juniper.net/techpubs/en_US/junos13.2/information-products/pathway-pages/netconf-guide/netconf.html#overview))
    in its technical library. Let's take a look at its usage.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Juniper网络在其技术库中提供了一个广泛的NETCONF XML管理协议开发者指南（[https://www.juniper.net/techpubs/en_US/junos13.2/information-products/pathway-pages/netconf-guide/netconf.html#overview](https://www.juniper.net/techpubs/en_US/junos13.2/information-products/pathway-pages/netconf-guide/netconf.html#overview)）。让我们来看一下它的用法。
- en: Device preparation
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备准备
- en: 'In order to start using NETCONF, let''s create a separate user as well as turn
    on the required services:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始使用NETCONF，让我们创建一个单独的用户，并打开所需的服务：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For the Juniper device lab, I am using an older, unsupported platform called
    **Juniper Olive**. It is solely used for lab purposes. You can use your favorite
    search engine to find out some interesting facts and history about Juniper Olive.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Juniper设备实验室，我正在使用一个名为**Juniper Olive**的较旧、不受支持的平台。它仅用于实验目的。您可以使用您喜欢的搜索引擎找出一些关于Juniper
    Olive的有趣事实和历史。
- en: 'On the Juniper device, you can always take a look at the configuration either
    in a flat file or in XML format. The `flat` file comes in handy when you need
    to specify a one-liner command to make configuration changes:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在Juniper设备上，您可以随时查看配置，无论是在一个平面文件中还是在XML格式中。当您需要指定一条命令来进行配置更改时，`flat`文件非常方便：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The XML format comes in handy at times when you need to see the XML structure
    of the configuration:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，当您需要查看配置的XML结构时，XML格式非常方便：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have installed the necessary Linux libraries and the ncclient Python library
    in the Cisco section. If you have not done so, refer back to that section and
    install the necessary packages.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Cisco部分安装了必要的Linux库和ncclient Python库。如果您还没有这样做，请参考该部分并安装必要的软件包。
- en: We are now ready to look at our first Juniper NETCONF example.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好查看我们的第一个Juniper NETCONF示例。
- en: Juniper NETCONF examples
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Juniper NETCONF示例
- en: 'We will use a pretty straightforward example to execute `show version`. We
    will name this file `junos_netconf_1.py`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个非常简单的示例来执行`show version`。我们将把这个文件命名为`junos_netconf_1.py`：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All the fields in the script should be pretty self-explanatory, with the exception
    of `device_params`. Starting with ncclient 0.4.1, the device handler was added
    to specify different vendors or platforms. For example, the name can be juniper,
    CSR, Nexus, or Huawei. We also added `hostkey_verify=False` because we are using
    a self-signed certificate from the Juniper device.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中的所有字段应该都很容易理解，除了`device_params`。从ncclient 0.4.1开始，添加了设备处理程序，用于指定不同的供应商或平台。例如，名称可以是juniper、CSR、Nexus或Huawei。我们还添加了`hostkey_verify=False`，因为我们使用的是Juniper设备的自签名证书。
- en: 'The returned output is `rpc-reply` encoded in XML with an `output` element:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的输出是用XML编码的`rpc-reply`，其中包含一个`output`元素：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can parse the XML output to just include the output text:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以解析XML输出以仅包括输出文本：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In `junos_netconf_2.py`, we will make configuration changes to the device.
    We will start with some new imports for constructing new XML elements and the
    connection manager object:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`junos_netconf_2.py`中，我们将对设备进行配置更改。我们将从一些新的导入开始，用于构建新的XML元素和连接管理器对象：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will lock the configuration and make configuration changes:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将锁定配置并进行配置更改：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Under the build configuration section, we create a new element of `system` with
    subelements of `host-namre` and `domain-name`. If you were wondering about the
    hierarchy structure, you can see from the XML display that the node structure
    with `system` is the parent of `host-name` and `domain-name`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建配置部分，我们创建一个`system`元素，其中包含`host-name`和`domain-name`子元素。如果你想知道层次结构，你可以从XML显示中看到`system`的节点结构是`host-name`和`domain-name`的父节点：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After the configuration is built, the script will push the configuration and
    commit the configuration changes. These are the normal best practice steps (lock,
    configure, unlock, commit) for Juniper configuration changes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 配置构建完成后，脚本将推送配置并提交配置更改。这些是Juniper配置更改的正常最佳实践步骤（锁定、配置、解锁、提交）：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Overall, the NETCONF steps map pretty well to what you would have done in the
    CLI steps. Please take a look at the `junos_netconf_3.py` script for a more reusable
    code. The following example combines the step-by-step example with a few Python
    functions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，NETCONF步骤与CLI步骤非常相似。请查看`junos_netconf_3.py`脚本，以获取更多可重用的代码。以下示例将步骤示例与一些Python函数结合起来：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This file can be executed by itself, or it can be imported to be used by other
    Python scripts.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件可以自行执行，也可以被导入到其他Python脚本中使用。
- en: Juniper also provides a Python library to be used with their devices called
    PyEZ. We will take a look at a few examples of using the library in the following
    section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Juniper还提供了一个名为PyEZ的Python库，可用于其设备。我们将在下一节中看一些使用该库的示例。
- en: Juniper PyEZ for developers
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发人员的Juniper PyEZ
- en: '**PyEZ** is a high-level Python implementation that integrates better with
    your existing Python code. By utilizing the Python API, you can perform common
    operation and configuration tasks without the extensive knowledge of the Junos
    CLI.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**PyEZ**是一个高级的Python实现，与现有的Python代码更好地集成。通过使用Python API，您可以执行常见的操作和配置任务，而无需对Junos
    CLI有深入的了解。'
- en: Juniper maintains a comprehensive Junos PyEZ developer guide at [https://www.juniper.net/techpubs/en_US/junos-pyez1.0/information-products/pathway-pages/junos-pyez-developer-guide.html#configuration](https://www.juniper.net/techpubs/en_US/junos-pyez1.0/information-products/pathway-pages/junos-pyez-developer-guide.html#configuration)
    on their technical library. If you are interested in using PyEZ, I would highly
    recommend at least a glance through the various topics in the guide.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Juniper在其技术库的[https://www.juniper.net/techpubs/en_US/junos-pyez1.0/information-products/pathway-pages/junos-pyez-developer-guide.html#configuration](https://www.juniper.net/techpubs/en_US/junos-pyez1.0/information-products/pathway-pages/junos-pyez-developer-guide.html#configuration)上维护了一份全面的Junos
    PyEZ开发人员指南。如果您有兴趣使用PyEZ，我强烈建议至少浏览一下指南中的各个主题。
- en: Installation and preparation
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和准备
- en: The installation instructions for each of the operating systems can be found
    on the *Installing Junos PyEZ* ([https://www.juniper.net/techpubs/en_US/junos-pyez1.0/topics/task/installation/junos-pyez-server-installing.html](https://www.juniper.net/techpubs/en_US/junos-pyez1.0/topics/task/installation/junos-pyez-server-installing.html))
    page. We will show the installation instructions for Ubuntu 16.04.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统的安装说明都可以在*安装Junos PyEZ* ([https://www.juniper.net/techpubs/en_US/junos-pyez1.0/topics/task/installation/junos-pyez-server-installing.html](https://www.juniper.net/techpubs/en_US/junos-pyez1.0/topics/task/installation/junos-pyez-server-installing.html))页面上找到。我们将展示Ubuntu
    16.04的安装说明。
- en: 'The following are some dependency packages, many of which should already be
    on the host from running previous examples:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些依赖包，其中许多应该已经在主机上运行之前的示例中了：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`PyEZ` packages can be installed via pip. Here, I have installed for both Python
    3 and Python 2:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`PyEZ`包可以通过pip安装。在这里，我已经为Python 3和Python 2都安装了：'
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'On the Juniper device, NETCONF needs to be configured as the underlying XML
    API for PyEZ:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在Juniper设备上，NETCONF需要配置为PyEZ的基础XML API：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For user authentication, we can either use password authentication or an SSH
    key pair. Creating the local user is straightforward:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户认证，我们可以使用密码认证或SSH密钥对。创建本地用户很简单：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For the `ssh` key authentication, first, generate the key pair on your host:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ssh`密钥认证，首先在主机上生成密钥对：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'By default, the public key will be called `id_rsa.pub` under `~/.ssh/`, while
    the private key will be named `id_rsa` under the same directory. Treat the private
    key like a password that you never share. The public key can be freely distributed.
    In our use case, we will move the public key to the `/tmp` directory and enable
    the Python 3 HTTP server module to create a reachable URL:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，公钥将被称为`id_rsa.pub`，位于`~/.ssh/`目录下，而私钥将被命名为`id_rsa`，位于相同的目录下。将私钥视为永远不共享的密码。公钥可以自由分发。在我们的用例中，我们将把公钥移动到`/tmp`目录，并启用Python
    3 HTTP服务器模块以创建可访问的URL：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: For Python 2, use `python -m SimpleHTTPServer` instead.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python 2，请改用`python -m SimpleHTTPServer`。
- en: 'From the Juniper device, we can create the user and associate the public key
    by downloading the public key from the Python 3 web server:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从Juniper设备中，我们可以通过从Python 3 web服务器下载公钥来创建用户并关联公钥：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, if we try to `ssh` with the private key from the management station, the
    user will be automatically authenticated:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试使用管理站的私钥进行ssh，用户将自动进行身份验证：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s make sure that both of the authentication methods work with PyEZ. Let''s
    try the username and password combination:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保两种身份验证方法都可以与PyEZ一起使用。让我们尝试用户名和密码组合：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can also try to use the SSH key authentication:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以尝试使用SSH密钥身份验证：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Great! We are now ready to look at some examples for PyEZ.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在准备好查看一些PyEZ的示例了。
- en: PyEZ examples
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyEZ示例
- en: 'In the previous interactive prompt, we already saw that when the device connects,
    the object automatically retrieves a few facts about the device. In our first
    example, `junos_pyez_1.py`, we were connecting to the device and executing an
    RPC call for `show interface em1`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的交互提示中，我们已经看到设备连接时，对象会自动检索有关设备的一些事实。在我们的第一个示例`junos_pyez_1.py`中，我们连接到设备并执行了`show
    interface em1`的RPC调用：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The device class has an `rpc` property that includes all operational commands.
    This is pretty awesome because there is no slippage between what we can do in
    CLI versus API. The catch is that we need to find out the `xml rpc` element tag.
    In our first example, how do we know `show interface em1` equates to `get_interface_information`?
    We have three ways of finding out this information:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 设备类具有一个包含所有操作命令的`rpc`属性。这非常棒，因为我们在CLI和API中可以做的事情之间没有差距。问题在于我们需要找出`xml rpc`元素标签。在我们的第一个示例中，我们如何知道`show
    interface em1`等同于`get_interface_information`？我们有三种方法可以找出这些信息：
- en: We can reference the *Junos XML API Operational Developer Reference*
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以参考*Junos XML API操作开发人员参考*
- en: We can use the CLI and display the XML RPC equivalent and replace the dash (`-`)
    between the words with an underscore (`_`)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用CLI显示XML RPC等效，并用下划线（`_`）替换单词之间的破折号（`-`）
- en: We can also do this programmatically by using the PyEZ library
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以通过使用PyEZ库来进行编程
- en: 'I typically use the second option to get the output directly:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常使用第二个选项直接获取输出：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here is an example of using PyEZ programmatically (the third option):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用PyEZ进行编程的示例（第三个选项）：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Of course, we will need to make configuration changes as well. In the `junos_pyez_2.py`
    configuration example, we will import an additional `Config()` method from PyEZ:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还需要进行配置更改。在`junos_pyez_2.py`配置示例中，我们将从PyEZ导入一个额外的`Config()`方法：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We will utilize the same block for connecting to a device:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用相同的块连接到设备：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `new Config()` method will load the XML data and make the configuration
    changes:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`new Config()`方法将加载XML数据并进行配置更改：'
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The PyEZ examples are simple by design. Hopefully, they demonstrate the ways
    you can leverage PyEZ for your Junos automation needs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: PyEZ示例设计简单。希望它们能展示您如何利用PyEZ满足Junos自动化需求的方式。
- en: The Arista Python API
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arista Python API
- en: '**Arista Networks** have always been focused on large-scale data center networks.
    In its corporate profile page ([https://www.arista.com/en/company/company-overview](https://www.arista.com/en/company/company-overview)),
    it is stated as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**Arista Networks**一直专注于大型数据中心网络。在其公司简介页面（[https://www.arista.com/en/company/company-overview](https://www.arista.com/en/company/company-overview)）中，如下所述：'
- en: '"Arista Networks was founded to pioneer and deliver software-driven cloud networking
    solutions for large data center storage and computing environments."'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: “Arista Networks成立的目的是开创并提供面向大型数据中心存储和计算环境的软件驱动云网络解决方案。”
- en: Notice that the statement specifically called out **large data centers**, which
    we already know are exploded with servers, databases, and, yes, network equipment.
    It makes sense that automation has always been one of Arista's leading features.
    In fact, they have a Linux underpin behind their operating system, allowing many
    added benefits such as Linux commands and a built-in Python interpreter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该声明特别指出了**大型数据中心**，我们已经知道这些数据中心充斥着服务器、数据库和网络设备。自动化一直是Arista的主要特点之一是有道理的。事实上，他们的操作系统背后有一个Linux支撑，允许许多附加功能，如Linux命令和内置的Python解释器。
- en: Like other vendors, you can interact with Arista devices directly via eAPI,
    or you can choose to leverage their `Python` library. We will see examples of
    both. We will also look at Arista's integration with the Ansible framework in
    later chapters.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他供应商一样，您可以直接通过eAPI与Arista设备交互，或者您可以选择利用他们的`Python`库。我们将看到两者的示例。我们还将在后面的章节中看到Arista与Ansible框架的集成。
- en: Arista eAPI management
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arista eAPI管理
- en: Arista's eAPI was first introduced in EOS 4.12 a few years ago. It transports
    a list of show or configuration commands over HTTP or HTTPS and responds back
    in JSON. An important distinction is that it is a **Remote Procedure Call** (**RPC**)
    and **JSON-RPC**, instead of a pure RESTFul API that's served over HTTP or HTTPS.
    For our intents and purposes, the difference is that we make the request to the
    same URL endpoint using the same HTTP method (`POST`). Instead of using HTTP verbs
    (`GET`, `POST`, `PUT`, `DELETE`) to express our action, we simply state our intended
    action in the body of the request. In the case of eAPI, we will specify a `method`
    key with a `runCmds` value for our intention.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，Arista的eAPI首次在EOS 4.12中引入。它通过HTTP或HTTPS传输一系列显示或配置命令，并以JSON形式回应。一个重要的区别是它是**远程过程调用**（**RPC**）和**JSON-RPC**，而不是纯粹通过HTTP或HTTPS提供的RESTFul
    API。对于我们的意图和目的，不同之处在于我们使用相同的HTTP方法（`POST`）向相同的URL端点发出请求。我们不是使用HTTP动词（`GET`，`POST`，`PUT`，`DELETE`）来表达我们的动作，而是简单地在请求的正文中说明我们的意图动作。在eAPI的情况下，我们将为我们的意图指定一个`method`键和一个`runCmds`值。
- en: For the following examples, I am using a physical Arista switch running EOS
    4.16.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我使用运行EOS 4.16的物理Arista交换机。
- en: The eAPI preparation
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: eAPI准备
- en: 'The eAPI agent on the Arista device is disabled by default, so we will need
    to enable it on the device before we can use it:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Arista设备上的eAPI代理默认处于禁用状态，因此我们需要在设备上启用它才能使用：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you can see, we have turned off the HTTP server and are using HTTPS as the
    sole transport instead. Starting from a few EOS versions ago, the management interfaces,
    by default, reside in a VRF called **management.** In my topology, I am accessing
    the device via the management interface; therefore, I have specified the VRF for
    eAPI management. You can check that API management state via the "show management
    api http-commands" command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已关闭HTTP服务器，而是仅使用HTTPS作为传输。从几个EOS版本前开始，默认情况下，管理接口位于名为**management**的VRF中。在我的拓扑中，我通过管理接口访问设备；因此，我已指定了eAPI管理的VRF。您可以通过"show
    management api http-commands"命令检查API管理状态：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After enabling the agent, you will be able to access the exploration page for
    eAPI by going to the device''s IP address. If you have changed the default port
    for access, just append it at the end. The authentication is tied into the method
    of authentication on the switch. We will use the username and password configured
    locally on the device. By default, a self-signed certificate will be used:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 启用代理后，您将能够通过访问设备的IP地址来访问eAPI的探索页面。如果您已更改访问的默认端口，只需在末尾添加即可。认证与交换机上的认证方法绑定。我们将使用设备上本地配置的用户名和密码。默认情况下，将使用自签名证书：
- en: '![](assets/3df6e19b-b674-427d-8fd8-e2b40dbfae9a.png)Arista EOS explorer'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/3df6e19b-b674-427d-8fd8-e2b40dbfae9a.png)Arista EOS explorer'
- en: 'You will be taken to an explorer page where you can type in the CLI command
    and get a nice output for the body of your request. For example, if I want to
    see how to make a request body for `show version`, this is the output I will see
    from the explorer:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您将进入一个探索页面，在那里您可以输入CLI命令并获得请求正文的良好输出。例如，如果我想查看如何为`show version`制作请求正文，这就是我将从探索器中看到的输出：
- en: '![](assets/8579af8e-eb72-4dc3-baab-1ab7d8c937be.png)Arista EOS explorer viewer'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/8579af8e-eb72-4dc3-baab-1ab7d8c937be.png)Arista EOS explorer viewer'
- en: The overview link will take you to the sample use and background information
    while the command documentation will serve as reference points for the show commands.
    Each of the command references will contain the returned value field name, type,
    and a brief description. The online reference scripts from Arista use jsonrpclib
    ([https://github.com/joshmarshall/jsonrpclib/](https://github.com/joshmarshall/jsonrpclib/)),
    which is what we will use. However, as of the time of writing this book, it has
    a dependency of Python 2.6+ and has not yet ported to Python 3; therefore, we
    will use Python 2.7 for these examples.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 概述链接将带您进入示例用途和背景信息，而命令文档将作为show命令的参考点。每个命令引用都将包含返回值字段名称、类型和简要描述。Arista的在线参考脚本使用jsonrpclib
    ([https://github.com/joshmarshall/jsonrpclib/](https://github.com/joshmarshall/jsonrpclib/))，这是我们将使用的。然而，截至撰写本书时，它依赖于Python
    2.6+，尚未移植到Python 3；因此，我们将在这些示例中使用Python 2.7。
- en: By the time you read this book, there might be an updated status. Please read
    the GitHub pull request ([https://github.com/joshmarshall/jsonrpclib/issues/38](https://github.com/joshmarshall/jsonrpclib/issues/38))
    and the GitHub README ([https://github.com/joshmarshall/jsonrpclib/](https://github.com/joshmarshall/jsonrpclib/))
    for the latest status.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在您阅读本书时，可能会有更新的状态。请阅读GitHub拉取请求 ([https://github.com/joshmarshall/jsonrpclib/issues/38](https://github.com/joshmarshall/jsonrpclib/issues/38))
    和GitHub README ([https://github.com/joshmarshall/jsonrpclib/](https://github.com/joshmarshall/jsonrpclib/))
    以获取最新状态。
- en: 'Installation is straightforward using `easy_install` or `pip`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 安装很简单，使用`easy_install`或`pip`：
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: eAPI examples
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: eAPI示例
- en: 'We can then write a simple program called `eapi_1.py` to look at the response
    text:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以编写一个名为`eapi_1.py`的简单程序来查看响应文本：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that, since this is Python 2, in the script, I used the `from __future__
    import print_function` to make future migration easier. The `ssl`-related lines
    are for Python version > 2.7.9\. For more information, please see [https://www.python.org/dev/peps/pep-0476/](https://www.python.org/dev/peps/pep-0476/).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于这是Python 2，在脚本中，我使用了`from __future__ import print_function`以便未来迁移更容易。与`ssl`相关的行适用于Python版本
    > 2.7.9。更多信息，请参阅[https://www.python.org/dev/peps/pep-0476/](https://www.python.org/dev/peps/pep-0476/)。
- en: 'This is the response I received from the previous `runCms()` method:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我从先前的`runCms()`方法收到的响应：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As you can see, the result is a list containing one dictionary item. If we
    need to grab the serial number, we can simply reference the item number and the
    key:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，结果是包含一个字典项的列表。如果我们需要获取序列号，我们可以简单地引用项目编号和键：
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output will contain only the serial number:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将仅包含序列号：
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To be more familiar with the command reference, I recommend that you click on
    the Command Documentation link on the eAPI page, and compare your output with
    the output of show version in the documentation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更熟悉命令参考，请点击eAPI页面上的命令文档链接，并将您的输出与文档中show version的输出进行比较。
- en: As noted earlier, unlike REST, the JSON-RPC client uses the same URL endpoint
    for calling the server resources. You can see from the previous example that the
    `runCmds()` method contains a list of commands. For the execution of configuration
    commands, you can follow the same framework, and configure the device via a list
    of commands.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，与REST不同，JSON-RPC客户端使用相同的URL端点来调用服务器资源。您可以从前面的示例中看到，`runCmds()`方法包含一系列命令。对于配置命令的执行，您可以遵循相同的框架，并通过一系列命令配置设备。
- en: 'Here is an example of configuration commands named `eapi_2.py`. In our example,
    we wrote a function that takes the switch object and the list of commands as attributes:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个名为`eapi_2.py`的配置命令示例。在我们的示例中，我们编写了一个函数，该函数将交换机对象和命令列表作为属性：
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here is the output of the command''s execution:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命令执行的输出：
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, do a quick check on the `switch` to verify the command''s execution:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，快速检查`switch`以验证命令的执行：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Overall, eAPI is fairly straightforward and simple to use. Most programming
    languages have libraries similar to `jsonrpclib`, which abstracts away JSON-RPC
    internals. With a few commands, you can start integrating Arista EOS automation
    into your network.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，eAPI非常简单直接，易于使用。大多数编程语言都有类似于`jsonrpclib`的库，它们抽象了JSON-RPC的内部。通过几个命令，您就可以开始将Arista
    EOS自动化集成到您的网络中。
- en: The Arista Pyeapi library
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arista Pyeapi库
- en: The Python client Pyeapi ([http://pyeapi.readthedocs.io/en/master/index.html](http://pyeapi.readthedocs.io/en/master/index.html))
    library is a native Python library wrapper around eAPI. It provides a set of bindings
    to configure Arista EOS nodes. Why do we need Pyeapi when we already have eAPI?
    Picking between Pyeapi versus eAPI is mostly a judgment call if you are in a Python
    environment.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Python客户端Pyeapi（[http://pyeapi.readthedocs.io/en/master/index.html](http://pyeapi.readthedocs.io/en/master/index.html)）库是一个原生的Python库，包装了eAPI。它提供了一组绑定来配置Arista
    EOS节点。为什么我们需要Pyeapi，当我们已经有eAPI了呢？在Python环境中选择Pyeapi还是eAPI主要是一个判断调用。
- en: However, if you are in a non-Python environment, eAPI is probably the way to
    go. From our examples, you can see that the only requirement of eAPI is a JSON-RPC
    capable client. Thus, it is compatible with most programming languages. When I
    first started out in the field, Perl was the dominant language for scripting and
    network automation. There are still many enterprises that rely on Perl scripts
    as their primary automation tool. If you're in a situation where the company has
    already invested a ton of resources and the code base is in another language than
    Python, eAPI with JSON-RPC would be a good bet.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你处于非Python环境中，eAPI可能是一个不错的选择。从我们的例子中可以看出，eAPI的唯一要求是一个支持JSON-RPC的客户端。因此，它与大多数编程语言兼容。当我刚开始进入这个领域时，Perl是脚本和网络自动化的主导语言。仍然有许多企业依赖Perl脚本作为他们的主要自动化工具。如果你处于一个公司已经投入大量资源且代码基础是另一种语言而不是Python的情况下，使用支持JSON-RPC的eAPI可能是一个不错的选择。
- en: However, for those of us who prefer to code in Python, a native `Python` library
    means a more natural feeling in writing our code. It certainly makes extending
    a Python program to support the EOS node easier. It also makes keeping up with
    the latest changes in Python easier. For example, we can use Python 3 with Pyeapi!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于那些更喜欢用Python编程的人来说，一个原生的`Python`库意味着在编写我们的代码时更自然。它确实使得扩展Python程序以支持EOS节点更容易。它也使得更容易跟上Python的最新变化。例如，我们可以使用Python
    3与Pyeapi！
- en: At the time of writing this book, Python 3 (3.4+) support is officially a work-in-progress,
    as stated in the documentation ([http://pyeapi.readthedocs.io/en/master/requirements.html](http://pyeapi.readthedocs.io/en/master/requirements.html)).
    Please check the documentation for more details.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Python 3（3.4+）支持正式是一个正在进行中的工作，如文档中所述（[http://pyeapi.readthedocs.io/en/master/requirements.html](http://pyeapi.readthedocs.io/en/master/requirements.html)）。请查看文档以获取更多详细信息。
- en: Pyeapi installation
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pyeapi安装
- en: 'Installation is straightforward with pip:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pip进行安装非常简单：
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that pip will also install the netaddr library as it is part of the stated
    requirements [(](http://pyeapi.readthedocs.io/en/master/requirements.html)[http://pyeapi.readthedocs.io/en/master/requirements.html](http://pyeapi.readthedocs.io/en/master/requirements.html)[)
    for Pyeapi.](http://pyeapi.readthedocs.io/en/master/requirements.html)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，pip还将安装netaddr库，因为它是Pyeapi的规定要求的一部分（[http://pyeapi.readthedocs.io/en/master/requirements.html](http://pyeapi.readthedocs.io/en/master/requirements.html)）。
- en: 'By default, the Pyeapi client will look for an INI style hidden (with a period
    in front) file called `eapi.conf` in your home directory. You can override this
    behavior by specifying the `eapi.conf` file path, but it is generally a good idea
    to separate your connection credential and lock it down from the script itself.
    You can check out the Arista Pyeapi documentation ([http://pyeapi.readthedocs.io/en/master/configfile.html#configfile](http://pyeapi.readthedocs.io/en/master/configfile.html#configfile))
    for the fields contained in the file. Here is the file I am using in the lab:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Pyeapi客户端将在您的主目录中查找一个INI风格的隐藏文件（前面带有一个句点）称为`eapi.conf`。您可以通过指定`eapi.conf`文件路径来覆盖这种行为，但通常最好将连接凭据与脚本本身分开。您可以查看Arista
    Pyeapi文档（[http://pyeapi.readthedocs.io/en/master/configfile.html#configfile](http://pyeapi.readthedocs.io/en/master/configfile.html#configfile)）以获取文件中包含的字段。这是我在实验室中使用的文件：
- en: '[PRE55]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The first line, `[connection:Arista1]`, contains the name that we will use
    in our Pyeapi connection; the rest of the fields should be pretty self-explanatory.
    You can lock down the file to be read-only for the user using this file:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行`[connection:Arista1]`包含了我们将在Pyeapi连接中使用的名称；其余字段应该是相当容易理解的。您可以将文件锁定为只读，供用户使用此文件：
- en: '[PRE56]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Pyeapi examples
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pyeapi示例
- en: 'Now, we are ready to take a look around the usage. Let''s start by connecting
    to the EOS node by creating an object in the interactive Python shell:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好查看用法了。让我们通过在交互式Python shell中创建一个对象来连接到EOS节点：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can execute show commands to the node and receive the output:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行show命令到节点并接收输出：
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The configuration field can be either a single command or a list of commands
    using the `config()` method:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 配置字段可以是单个命令，也可以是使用`config()`方法的命令列表：
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Note that command abbreviation (`show run` versus `show running-config`) and
    some extensions will not work:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，命令缩写（`show run`与`show running-config`）和一些扩展将不起作用：
- en: '[PRE60]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'However, you can always catch the results and get the desired value:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您总是可以捕获结果并获得所需的值：
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'So far, we have been doing what we have been doing with eAPI for show and configuration
    commands. Pyeapi offers various APIs to make life easier. In the following example,
    we will connect to the node, call the VLAN API, and start to operate on the VLAN
    parameters of the device. Let''s take a look:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用eAPI进行show和配置命令。Pyeapi提供了各种API来使生活更轻松。在下面的示例中，我们将连接到节点，调用VLAN API，并开始对设备的VLAN参数进行操作。让我们来看一下：
- en: '[PRE62]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s verify that VLAN 10 was created on the device:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证一下设备上是否创建了VLAN 10：
- en: '[PRE63]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As you can see, the Python native API on the EOS object is really where Pyeapi
    excels beyond eAPI. It abstracts the lower-level attributes into the device object
    and makes the code cleaner and easier to read.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，EOS对象上的Python本机API确实是Pyeapi在eAPI之上的优势所在。它将底层属性抽象成设备对象，使代码更清晰、更易读。
- en: For a full list of ever increasing Pyeapi APIs, check the official documentation
    ([http://pyeapi.readthedocs.io/en/master/api_modules/_list_of_modules.html](http://pyeapi.readthedocs.io/en/master/api_modules/_list_of_modules.html)).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取不断增加的Pyeapi API的完整列表，请查阅官方文档（[http://pyeapi.readthedocs.io/en/master/api_modules/_list_of_modules.html](http://pyeapi.readthedocs.io/en/master/api_modules/_list_of_modules.html)）。
- en: 'To round up this chapter, let''s assume that we repeat the previous steps enough
    times that we would like to write another Python class to save us some work. The `pyeapi_1.py` script
    is shown as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 总结本章，让我们假设我们重复了前面的步骤足够多次，以至于我们想写另一个Python类来节省一些工作。`pyeapi_1.py`脚本如下所示：
- en: '[PRE64]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As you can see from the script, we automatically connect to the node and set
    the hostname and `running_config` upon connection. We also create a method to
    the class that creates VLAN by using the `VLAN` API. Let''s try out the script
    in an interactive shell:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从脚本中可以看出，我们自动连接到节点并在连接时设置主机名和`running_config`。我们还创建了一个使用`VLAN` API创建VLAN的类方法。让我们在交互式shell中尝试运行脚本：
- en: '[PRE65]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Vendor-neutral libraries
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 供应商中立库
- en: There are several excellent efforts of vendor-neutral libraries such as Netmiko
    ([https://github.com/ktbyers/netmiko](https://github.com/ktbyers/netmiko)) and
    NAPALM ([https://github.com/napalm-automation/napalm](https://github.com/napalm-automation/napalm)).
    Because these libraries do not come natively from the device vendor, they are
    sometimes a step slower to support the latest platform or features. However, because
    the libraries are vendor-neutral, if you do not like vendor lock-in for your tools,
    then these libraries are a good choice. Another benefit of using these libraries
    is the fact that they are normally open source, so you can contribute back upstream
    for new features and bug fixes.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个优秀的供应商中立库，比如Netmiko（[https://github.com/ktbyers/netmiko](https://github.com/ktbyers/netmiko)）和NAPALM（[https://github.com/napalm-automation/napalm](https://github.com/napalm-automation/napalm)）。因为这些库并非来自设备供应商，它们有时会慢一步来支持最新的平台或功能。然而，由于这些库是供应商中立的，如果你不喜欢为你的工具绑定供应商，那么这些库是一个不错的选择。使用这些库的另一个好处是它们通常是开源的，所以你可以为新功能和错误修复做出贡献。
- en: On the other hand, because these libraries are community supported, they are
    not necessarily the ideal fit if you need to rely on somebody else to fix bugs
    or implement new features. If you have a relatively small team that still needs
    to comply with certain service-level assurances for your tools, you might be better
    off using a vendor-backed library.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，由于这些库是由社区支持的，如果你需要依赖他人来修复错误或实现新功能，它们可能并不是理想的选择。如果你有一个相对较小的团队，仍然需要遵守工具的某些服务级保证，你可能最好使用供应商支持的库。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at various ways to communicate and manage network
    devices from Cisco, Juniper, and Arista. We looked at both direct communication
    with the likes of NETCONF and REST, as well as using vendor-provided libraries
    such as PyEZ and Pyeapi. These are different layers of abstractions, meant to
    provide a way to programmatically manage your network devices without human intervention.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一些从思科、Juniper和Arista管理网络设备的各种方法。我们既看了与NETCONF和REST等直接通信，也使用了供应商提供的库，比如PyEZ和Pyeapi。这些都是不同的抽象层，旨在提供一种无需人工干预就能编程管理网络设备的方式。
- en: In [Chapter 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml), *The Python Automation
    Framework – Ansible Basics*, we will take a look at a higher level of vendor-neutral
    abstraction framework called **Ansible**. Ansible is an open source, general purpose
    automation tool written in Python. It can be used to automate servers, network
    devices, load balancers, and much more. Of course, for our purpose, we will focus
    on using this automation framework for network devices.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml)中，*Python自动化框架- Ansible基础*，我们将看一下一个更高级的供应商中立抽象框架，称为**Ansible**。Ansible是一个用Python编写的开源通用自动化工具。它可以用于自动化服务器、网络设备、负载均衡器等等。当然，对于我们的目的，我们将专注于使用这个自动化框架来管理网络设备。
