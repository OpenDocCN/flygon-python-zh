- en: Visualizing Data Using the Canvas Widget
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Canvas小部件可视化数据
- en: With months of experimental data logged in the database, it's time to begin
    the process of visualizing and interpreting it. Rather than exporting data into
    a spreadsheet to create charts and graphs, your fellow analysts have asked whether
    the program itself can create graphical data visualizations. To implement this
    feature, you're going to need to learn about Tkinter's `Canvas` widget.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中记录了数月的实验数据后，现在是开始可视化和解释数据的过程。你的同事分析师们询问程序本身是否可以创建图形数据可视化，而不是将数据导出到电子表格中创建图表和图形。为了实现这一功能，你需要了解Tkinter的`Canvas`小部件。
- en: 'In this chapter, you''ll learn the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Using the `Canvas` widget for drawing and animation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Canvas小部件进行绘图和动画
- en: Building a simple line graph using `Canvas`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Canvas构建简单的折线图
- en: Incorporating more advanced graphs and charts using Matplotlib
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Matplotlib集成更高级的图表和图表
- en: Drawing and animation with Tkinter's Canvas
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tkinter的Canvas进行绘图和动画
- en: The `Canvas` widget is undoubtedly the most powerful widget available in Tkinter.
    It can be used to build anything from custom widgets and views to complete user
    interfaces. As the name implies, `Canvas` is a blank area on which figures and
    images can be drawn.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`小部件无疑是Tkinter中最强大的小部件。它可以用于构建从自定义小部件和视图到完整用户界面的任何内容。顾名思义，`Canvas`是一个可以绘制图形和图像的空白区域。'
- en: 'A `Canvas` object can be created like any other widget:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 可以像创建其他小部件一样创建`Canvas`对象：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`Canvas` accepts the usual widget configuration arguments, as well as `width`
    and `height` for setting its size. Once created, we can start adding items to
    `canvas` using its many `create_()` methods.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`接受通常的小部件配置参数，以及用于设置其大小的`width`和`height`。创建后，我们可以使用其许多`create_()`方法开始向`canvas`添加项目。'
- en: 'For example, we can add a rectangle with this code:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用以下代码添加一个矩形：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first four arguments are the coordinates of the upper-left and lower-right
    corners, in pixels from the upper-left corner of the canvas. Each `create_()`
    method begins like this, with coordinates defining the shape. The `fill` option
    specifies the color of the inside of the object.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个参数是左上角和右下角的坐标，以像素为单位，从画布的左上角开始。每个`create_()`方法都是以定义形状的坐标开始的。`fill`选项指定了对象内部的颜色。
- en: 'Coordinates can also be specified as tuple pairs, like so:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标也可以指定为元组对，如下所示：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Although this is more characters, it improves readability considerably. Also
    note that, just like colors elsewhere in Tkinter, we can use names or hex codes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是更多的字符，但它显着提高了可读性。还要注意，就像Tkinter中的其他颜色一样，我们可以使用名称或十六进制代码。
- en: 'We can also create ovals, as shown in the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建椭圆，如下所示：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: An oval, like a rectangle, takes the coordinates of the upper-left and lower-right
    corners of its **bounding box**. A bounding box is the smallest rectangle that
    will contain an item, so in the case of this oval, you can imagine a circle inside
    a square with corners at `(350, 250)` and `(450, 350)`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆和矩形一样，需要其**边界框**的左上角和右下角的坐标。边界框是包含项目的最小矩形，因此在这个椭圆的情况下，你可以想象一个圆在一个角坐标为`(350,
    250)`和`(450, 350)`的正方形内。
- en: 'We can create lines using `create_line()`, like so:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`create_line()`创建线，如下所示：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Lines can consist of any number of points, between which Tkinter will connect
    the dots. We've specified the width of the line as well as its color (using the
    `fill` argument). Additional arguments can control the shape of corners and ends,
    the presence and style of arrows at each end of the line, whether and how the
    line is dashed, and whether the line is straight or curved.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 行可以由任意数量的点组成，Tkinter将连接这些点。我们已经指定了线的宽度以及颜色（使用`fill`参数）。额外的参数可以控制角和端点的形状，线两端箭头的存在和样式，线条是否虚线，以及线条是直线还是曲线。
- en: 'In a similar fashion, we can create polygons, like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以创建多边形，如下所示：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is just like creating a line, except that Tkinter connects the last dot
    back to the first and fills in the interior. Setting `smooth` to `True` causes
    the corners to be rounded using Bezier curves.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这与创建线条类似，只是Tkinter将最后一个点连接回第一个点，并填充内部。将`smooth`设置为`True`会使用贝塞尔曲线使角变圆。
- en: 'In addition to simple shapes, we can also place text or images on the `canvas`
    object as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的形状之外，我们还可以按照以下方式在`canvas`对象上放置文本或图像：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The return value of any `create_()` method is a string that uniquely identifies
    the item in the context of the `Canvas` object. We can use that identification
    string to do things to the item after creation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 任何`create_()`方法的返回值都是一个字符串，它在`Canvas`对象的上下文中唯一标识该项。我们可以使用该标识字符串在创建后对该项进行操作。
- en: 'For example, we can bind events like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以这样绑定事件：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we've used the `tag_bind` method to bind a left-mouse click on our image
    object to the canvas's `delete()` method, which (when given an item identifier)
    deletes the item.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`tag_bind`方法将鼠标左键单击我们的图像对象绑定到画布的`delete()`方法，该方法（给定一个项目标识符）会删除该项目。
- en: Animating Canvas objects
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Canvas对象添加动画
- en: Tkinter's `Canvas` widget doesn't have a built-in animation framework, but we
    can still create simple animations by combining its `move()` method with our understanding
    of the event queue.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter的`Canvas`小部件没有内置的动画框架，但我们仍然可以通过将其`move()`方法与对事件队列的理解相结合来创建简单的动画。
- en: To demonstrate this, we'll create a bug race simulator, in which two bugs (represented
    by colored circles) will race haphazardly toward a finish line on the other side
    of the screen. Like real bugs, they won't have any notion that they're in a race
    and will move randomly, the winner being whichever bug incidentally hits the finish
    line first.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们将创建一个虫子赛跑模拟器，其中两只虫子（用彩色圆圈表示）将杂乱地向屏幕的另一侧的终点线赛跑。就像真正的虫子一样，它们不会意识到自己在比赛，会随机移动，赢家是哪只虫子碰巧先到达终点线。
- en: 'To begin, open a new Python file and start with a basic boilerplate as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开一个新的Python文件，并从以下基本样板开始：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating our objects
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的对象
- en: 'Let''s create the objects to be used in our game:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建用于游戏的对象：
- en: 'In `App.__init__()`, we''ll simply create our `canvas` object and add it using
    `pack()`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`App.__init__()`中，我们将简单地创建我们的`canvas`对象，并使用`pack()`添加它：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we''ll create a `setup()` method as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个`setup()`方法如下：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code snippet, `setup()` begins by calculating some relative
    locations on the `canvas` object and saving them as instance properties, which
    will simplify the placement of objects on the `canvas` object. The finish line,
    which is a rectangle across the right edge of the window, uses the `stipple` argument
    to specify a bitmap that will overlay the solid color to give it some texture;
    in this case, `gray50` is a built-in bitmap that alternates black and transparent
    pixels.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，`setup()`首先通过计算`canvas`对象上的一些相对位置，并将它们保存为实例属性，这将简化在`canvas`对象上放置对象。终点线是窗口右边的一个矩形，使用`stipple`参数指定一个位图，该位图将覆盖实色以赋予其一些纹理；在这种情况下，`gray50`是一个内置的位图，交替黑色和透明像素。
- en: 'Add a call to `setup()` at the end of `__init__()` as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__init__()`的末尾添加一个对`setup()`的调用如下：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because `setup()` relies on the `width` and `height` values of the `canvas` object,
    we need to make sure it isn't called until the operating system's window manager
    has drawn and sized the window. The simplest way of doing this is to delay the
    call by a few hundred milliseconds.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`setup()`依赖于`canvas`对象的`width`和`height`值，我们需要确保在操作系统的窗口管理器绘制和调整窗口大小之前不调用它。最简单的方法是将调用延迟几百毫秒。
- en: 'Next, we need to create our players. Let''s create a class to represent them
    as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建我们的玩家。让我们创建一个类来表示他们如下：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Racer` class will be created with a reference to `canvas` and a `color`
    string, from which its color and name will be derived. We'll draw the racer initially
    at the middle-left of the screen and make it `50` pixels in size. Finally, we
    save a reference to its item ID string in `self.id`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Racer`类将使用对`canvas`的引用和一个`color`字符串创建，并从中派生其颜色和名称。我们将最初在屏幕的中间左侧绘制赛车，并使其大小为`50`像素。最后，我们将其项目ID字符串的引用保存在`self.id`中。'
- en: 'Now, back in `App.setup()`, we''ll create two racers by executing the following
    code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`App.setup()`中，我们将通过执行以下代码创建两个赛车：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At this point, all the objects in our game are set up. Run the program and you
    should see a yellow-stippled finish line on the right and a green circle on the
    left (the red circle will be hidden under the green).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们游戏中的所有对象都已设置好。运行程序，你应该能看到右侧的黄色点线终点线和左侧的绿色圆圈（红色圆圈将被隐藏在绿色下面）。
- en: Animating the racers
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画赛车
- en: To animate our racers, we're going to use the `Canvas.move()` method. `move()`
    takes an item ID, a number of `x` pixels, and a number of `y` pixels, and moves
    the item by that amount. By using `random.randint()` and some simple logic, we
    can generate a series of moves that will send each racer on a meandering path
    towards the finish line.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的赛车动画化，我们将使用`Canvas.move()`方法。`move()`接受一个项目ID，一定数量的`x`像素和一定数量的`y`像素，并将项目移动该数量。通过使用`random.randint()`和一些简单的逻辑，我们可以生成一系列移动，将每个赛车发送到一条蜿蜒的路径朝着终点线。
- en: 'A simple implementation may look like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的实现可能如下所示：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This isn't really what we want, though; the problem is that `move()` happens
    instantaneously, causing the bug to jump across the screen; we want our moves
    to take place smoothly over a period of time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是我们真正想要的；问题在于`move()`是瞬间发生的，导致错误跳跃到屏幕的另一侧；我们希望我们的移动在一段时间内平稳进行。
- en: 'To accomplish this, we''re going to take the following approach:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将采取以下方法：
- en: Calculate a series of linear moves, each with a random delta `x`, delta `y`,
    and `time`, that will reach the finish line
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算一系列线性移动，每个移动都有一个随机的增量`x`，增量`y`和`时间`，可以到达终点线
- en: Break each move into a number of steps determined by dividing the time into
    a regular interval
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个移动分解为由时间分成的一定间隔的步骤
- en: Add each step of each movement to a queue
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个移动的每一步添加到队列中
- en: At our regular interval, pull the next step from the queue and pass it to `move()`
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的常规间隔中，从队列中提取下一步并传递给`move()`
- en: 'Let''s start by defining our frame interval and creating our animation queue:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义我们的帧间隔并创建我们的动画队列：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`FRAME_RES` (short for frame resolution) defines the number of milliseconds
    between each `Canvas.move()` call. `50` milliseconds gives us 20 frames per second
    and should be sufficient for smooth movements.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`FRAME_RES`（帧分辨率的缩写）定义了每个`Canvas.move()`调用之间的毫秒数。`50`毫秒给我们20帧每秒，应该足够平滑移动。'
- en: 'Now create a method to plot the course to the finish line:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个方法来绘制到终点线的路径：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method plots a course from the left-center of `canvas` to the right-side
    by generating random `x` and `y` movements until the total `x` is greater than
    the width of the `canvas` object. The change in `x` will always be positive, keeping
    our bugs moving towards the finish line, but the change in `y` can be positive
    or negative. To keep our bugs on the screen, we constrain the total `y` movements
    by negating any change in `y` that would put the player outside the top or bottom
    bound of the canvas.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法通过生成随机的`x`和`y`移动，从`canvas`的左中心绘制一条到右侧的路径，直到总`x`大于`canvas`对象的宽度。`x`的变化总是正的，使我们的错误向着终点线移动，但`y`的变化可以是正的也可以是负的。为了保持我们的错误在屏幕上，我们通过否定任何会使玩家超出画布顶部或底部边界的`y`变化来限制总的`y`移动。
- en: In addition to `dx` and `dy`, we generate a random amount of `time` for the
    move to take, between half a second and two seconds, and send the generated values
    to a `queue_move()` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`dx`和`dy`，我们还生成了移动所需的随机`time`数量，介于半秒和两秒之间，并将生成的值发送到`queue_move()`方法。
- en: 'The `queue_move()` command will need to break the large move into individual
    frames that describe how much movement should happen in one `FRAME_RES` interval.
    To do this, we need a **partition function**: a mathematical function that will
    break an integer `n` into `k` approximately equal integers. For example, if we
    wanted to break -10 into four parts, our function should return a list like [-3,
    -3, -2, -2].'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue_move()`命令将需要将大移动分解为描述在一个`FRAME_RES`间隔中应该发生多少移动的单个帧。为此，我们需要一个**partition函数**：一个数学函数，将整数`n`分解为大致相等的整数`k`。例如，如果我们想将-10分成四部分，我们的函数应返回一个类似于[-3,
    -3, -2, -2]的列表。'
- en: 'Create `partition()` as a static method on `Racer`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将`partition()`创建为`Racer`的静态方法：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We start with the easy case: when `n` is `0`, return a list of `k` zeros.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从简单的情况开始：当`n`为`0`时，返回一个由`k`个零组成的列表。
- en: 'The rest of the code looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分如下所示：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, we create a list of length `k` that is made up of `base_step`, that is,
    the integer portion of `n` divided by `k`. We use a cast of `int()` here rather
    than floor division because it behaves more appropriately with negative numbers.
    Next, we need to distribute the remainder among the list as evenly as we can.
    To accomplish this, we add `1` or `-1` (depending on the sign of the remainder)
    to the first `n % k` items in the parts list.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个长度为`k`的列表，由`base_step`组成，即`n`除以`k`的整数部分。我们在这里使用`int()`的转换而不是地板除法，因为它在负数时表现更合适。接下来，我们需要尽可能均匀地在列表中分配余数。为了实现这一点，我们在部分列表的前`n
    % k`项中添加`1`或`-1`（取决于余数的符号）。
- en: 'Follow the math here using our example of `n = -10` and `k = 4`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的例子`n = -10`和`k = 4`，按照这里的数学：
- en: -10 / 4 = -2.5, truncated to -2.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -10 / 4 = -2.5，截断为-2。
- en: 'So we have a list: [-2, -2, -2, -2].'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所以我们有一个列表：[-2, -2, -2, -2]。
- en: -10 % 4 = 2, so we add -1 (that is, -10 / 10) to the first two items in the
    list.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -10 % 4 = 2，所以我们在列表的前两个项目中添加-1（即-10 / 10）。
- en: We arrive at an answer of [-3, -3, -2, -2]. Perfect!
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们得到了一个答案：[-3, -3, -2, -2]。完美！
- en: 'Now we can write `queue_move()`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写`queue_move()`：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We first determine the number of steps in this move by dividing the time by `FRAME_RES`
    using floor division. We create a list of `x` moves and a list of `y` moves by
    passing `dx` and `dy` each to our `partition()` method. Those two lists are combined
    with `zip` to form a single list of `(dx, dy)` pairs, which then gets added to
    the animation queue.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过使用地板除法将时间除以`FRAME_RES`来确定此移动中的步数。我们通过将`dx`和`dy`分别传递给我们的`partition()`方法来创建`x`移动列表和`y`移动列表。这两个列表与`zip`结合形成一个`(dx,
    dy)`对的单个列表，然后添加到动画队列中。
- en: 'To make the animation actually happen, we''ll write an `animate()` method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使动画真正发生，我们将编写一个`animate()`方法：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `animate()` method checks the queue for a move. If there is one, `canvas.move()`
    is called with the racer's ID and the moves that need to be made. Finally, the
    `animate()` method is scheduled to run again in `FRAME_RES` milliseconds.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`animate()`方法检查队列是否有移动。如果有，将调用`canvas.move()`，并传递赛车的ID和需要进行的移动。最后，`animate()`方法被安排在`FRAME_RES`毫秒后再次运行。'
- en: The last step in animating the racers is to call `self.plot_course()` and `self.animate()`
    at the end of `__init__()`. If you run the game now, your two dots should wander
    the screen from left to right. But nobody's winning just yet!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 动画赛车的最后一步是在`__init__()`的末尾调用`self.plot_course()`和`self.animate()`。如果现在运行游戏，你的两个点应该从左到右在屏幕上漫游。但目前还没有人获胜！
- en: Detecting and handling a win condition
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测和处理获胜条件
- en: To detect a win condition, we're going to periodically check whether a racer
    is overlapping with the finish line item. When one of them is, we'll declare it
    the winner and offer the option to play again.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测获胜条件，我们将定期检查赛车是否与终点线项目重叠。当其中一个重叠时，我们将宣布它为获胜者，并提供再玩一次的选项。
- en: Collision detection between items is slightly awkward with the Tkinter `Canvas` widget.
    We have to pass a set of bounding box coordinates to `find_overlapping()`, which
    returns a tuple of item identifiers that overlap with the bounding box.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 物品之间的碰撞检测在Tkinter的Canvas小部件中有些尴尬。我们必须将一组边界框坐标传递给`find_overlapping()`，它会返回与边界框重叠的项目标识的元组。
- en: 'Let''s create an `overlapping()` method for our `Racer` class:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的`Racer`类创建一个`overlapping()`方法：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This method retrieves the bounding box of the `Racer` item using the canvas's
    `bbox()` method. It then fetches a tuple of items overlapping this bounding box
    using `find_overlapping()`. Next, we'll filter this tuple to remove the `Racer`
    item's ID, effectively returning a list of items overlapping with the `Racer` class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法使用画布的`bbox()`方法检索`Racer`项目的边界框。然后使用`find_overlapping()`获取与此边界框重叠的项目的元组。接下来，我们将过滤此元组，以删除`Racer`项目的ID，有效地返回与`Racer`类重叠的项目列表。
- en: 'Back in our `App()` method, we''ll create a `check_for_winner()` method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`App()`方法，我们将创建一个`check_for_winner()`方法：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method iterates our list of racers and checks whether the `finish_line`
    ID is in the list returned by the racer's `overlapping()` method. If it is, `racer`
    has hit the finish line and will be declared the winner.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法迭代我们的赛车列表，并检查赛车的`overlapping()`方法返回的列表中是否有`finish_line` ID。如果有，`racer`就到达了终点线，并将被宣布为获胜者。
- en: If no player was declared the winner, we'll schedule the check to run again
    after `Racer.FRAME_RES` milliseconds.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有宣布获胜者，我们将在`Racer.FRAME_RES`毫秒后再次安排检查运行。
- en: 'We handle a win condition in the `declare_winner()` method:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`declare_winner()`方法中处理获胜条件：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this method, we've just created a `text` item declaring `racer.name` as the
    winner in the center of `canvas`. The `activefill` argument causes the color to
    appear violet when the mouse is hovered over it, indicating to the user that this
    text is clickable.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们刚刚创建了一个`text`项目，在`canvas`的中心声明`racer.name`为获胜者。`activefill`参数使颜色在鼠标悬停在其上时变为紫色，向用户指示此文本是可点击的。
- en: 'When that text is clicked, it calls the `reset()` method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击该文本时，它调用`reset()`方法：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `reset()` method needs to clear off the canvas, so it retrieves a list of
    all item identifiers using the `find_all()` method, then calls `delete()` on each
    one. Finally, we call `setup()` to reset the game.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset()`方法需要清除画布，因此它使用`find_all()`方法检索所有项目标识符的列表，然后对每个项目调用`delete()`。最后，我们调用`setup()`来重置游戏。'
- en: 'The game is now complete, as you can see in the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在下面的截图中所见，游戏现在已经完成：
- en: '![](assets/5199652b-2987-472d-b74e-4d00c79ddc46.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5199652b-2987-472d-b74e-4d00c79ddc46.png)'
- en: While not exactly simple, animation in Tkinter can provide smooth and satisfactory
    results with some careful planning and a bit of math.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是很简单，但Tkinter中的动画可以通过一些仔细的规划和一点数学来提供流畅和令人满意的结果。
- en: Enough games, though; let's get back to the lab and figure out how to use the
    Tkinter `Canvas` widget to visualize data.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，够玩游戏了；让我们回到实验室，看看如何使用Tkinter的`Canvas`小部件来可视化数据。
- en: Creating simple graphs on the canvas
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画布上创建简单的图表
- en: The first graph we want to produce is a simple line graph that shows the growth
    of our plants over time. Each lab has varying climate conditions, and we want
    to see how those conditions are affecting the growth of all plants, so the chart
    will have one line per lab showing the average of the median height measurements
    for all plots in the lab over the days of the experiment.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要生成的第一个图形是一个简单的折线图，显示我们植物随时间的生长情况。每个实验室的气候条件各不相同，我们想要看到这些条件如何影响所有植物的生长，因此图表将显示每个实验室的一条线，显示实验期间实验室中所有地块的中位高度测量的平均值。
- en: We'll start by creating a model method to return the raw data, then create a
    `Canvas`-based line-chart view, and finally create an application callback to
    pull the data and send it to the chart view.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个模型方法来返回原始数据，然后创建一个基于`Canvas`的折线图视图，最后创建一个应用程序回调来获取数据并将其发送到图表视图。
- en: Creating the model method
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型方法
- en: Suppose we have a SQL query that determines the day number of a plot check by
    subtracting its date from the oldest date in the `plot_checks` table, then pulls
    `lab_id` and the average of `median_height` for all plants in the given lab on
    the given day.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个SQL查询，通过从`plot_checks`表中的最旧日期中减去其日期来确定地块检查的天数，然后在给定实验室和给定日期上拉取`lab_id`和所有植物的`median_height`的平均值。
- en: 'We''ll run this query in a new `SQLModel` method called `get_growth_by_lab()`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个名为`get_growth_by_lab()`的新`SQLModel`方法中运行此查询：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We''ll get back a table of data that looks something like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到一个数据表，看起来像这样：
- en: '| **Day** | **Lab ID** | **Average height** |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| **Day** | **Lab ID** | **Average height** |'
- en: '| 0 | A | 7.4198750000000000 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 0 | A | 7.4198750000000000 |'
- en: '| 0 | B | 7.3320000000000000 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 0 | B | 7.3320000000000000 |'
- en: '| 0 | C | 7.5377500000000000 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 0 | C | 7.5377500000000000 |'
- en: '| 0 | D | 8.4633750000000000 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 0 | D | 8.4633750000000000 |'
- en: '| 0 | E | 7.8530000000000000 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 0 | E | 7.8530000000000000 |'
- en: '| 1 | A | 6.7266250000000000 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 1 | A | 6.7266250000000000 |'
- en: '| 1 | B | 6.8503750000000000 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 1 | B | 6.8503750000000000 | '
- en: We'll use this data to build our chart.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些数据来构建我们的图表。
- en: Creating the graph view
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图形视图
- en: 'Head over to `views.py`, where we''ll create the `LineChartView` class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`views.py`，在那里我们将创建`LineChartView`类：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`LineChartView` is a subclass of `Canvas`, so we''ll be able to draw items
    directly on it. We''ll accept a parent widget, height, and width for the chart
    portion, labels for the `x` and `y` axes as arguments, and the maximum values
    for `x` and `y` to display. We''ll save the chart dimensions and maximum values
    for later use, and set a class property of 20 pixels for the margin width.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`LineChartView`是`Canvas`的子类，因此我们将能够直接在其上绘制项目。我们将接受父小部件、图表部分的高度和宽度、`x`和`y`轴的标签作为参数，并显示`x`和`y`的最大值。我们将保存图表的尺寸和最大值以供以后使用，并将边距宽度设置为20像素的类属性。'
- en: 'Let''s start setting up this `Canvas`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设置这个`Canvas`：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We calculate the `width` and `height` values of view by adding the margin to
    both sides, then call the superclass `__init__()` with them, also setting the
    background to `lightgrey`. We'll also save the chart `width` and `height` as instance
    properties.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将边距添加到两侧来计算视图的`width`和`height`值，然后使用它们调用超类`__init__()`，同时将背景设置为`lightgrey`。我们还将保存图表的`width`和`height`作为实例属性。
- en: 'Next, let''s draw the axes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们绘制轴：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Our chart's origin will be `self.margin` pixels from the bottom-left corner,
    and we'll draw the `x` and `y` axes as simple black lines moving left and up from
    it to the edge of the chart.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图表原点将距离左下角`self.margin`像素，并且我们将绘制`x`和`y`轴，作为简单的黑色线条从原点向左和向上延伸到图表的边缘。
- en: 'Next, we''ll label the axes:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将标记轴：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we''re creating the `text` items set to the labels for the `x` and `y`
    axes. There are a few new arguments in use here: `anchor` sets which side of the
    text''s bounding box is attached to the coordinates provided, and `angle` rotates
    the text object by the given number of degrees. Note that `angle` is a Tkinter
    8.6 feature, so it could be a problem for macOS users. Also, note that we''ve
    used south as `anchor` for the rotated text; even though it''s rotated, the cardinal
    directions refer to the non-rotated sides, so south will always be the bottom
    of the text as it''s normally printed.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了设置为`x`和`y`轴标签的`text`项目。这里使用了一些新的参数：`anchor`设置文本边界框的哪一侧与提供的坐标相连，`angle`将文本对象旋转给定的角度。请注意，`angle`是Tkinter
    8.6的一个特性，因此对于macOS用户可能会有问题。另外，请注意，我们将旋转的文本的`anchor`设置为south；即使它被旋转，基本方向仍然指的是未旋转的边，因此south始终是文本的底部，就像正常打印的那样。
- en: 'Last of all, we need to create a second `Canvas` that will contain the actual
    chart:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建一个包含实际图表的第二个`Canvas`：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: While we could place widgets on `canvas` using a geometry manager like `pack()`
    or `grid()`, the `create_window()` method places a widget on `Canvas` as a `Canvas`
    item using coordinates. We're anchoring the lower-left corner of the chart to
    the origin point on our graph.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用`pack()`或`grid()`等几何管理器在`canvas`上放置小部件，但`create_window()`方法将小部件作为`Canvas`项目放置在`Canvas`上，使用坐标。我们将图表的左下角锚定到我们图表的原点。
- en: 'With the pieces in place, we''ll now create a method to draw data on the chart:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这些部分的就位，我们现在将创建一个在图表上绘制数据的方法：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In `plot_line()`, we first have to convert the raw data into coordinates that
    can be drawn. We'll need to scale our `data` points so that they range from `0`
    to the height and width of the chart object. Our method calculates the scale of
    `x` and `y` (that is, how many pixels per unit `x` or `y`) by dividing the chart
    dimensions by the maximum values of `x` and `y`. We can then transform our data
    by using a list comprehension that multiplies each data point by the scale value.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`plot_line()`中，我们首先必须将原始数据转换为可以绘制的坐标。我们需要缩放我们的`数据`点，使它们的范围从图表对象的高度和宽度为`0`。我们的方法通过将图表尺寸除以`x`和`y`的最大值来计算`x`和`y`的比例（即每个单位`x`或`y`有多少像素）。然后我们可以通过使用列表推导将每个数据点乘以比例值来转换我们的数据。
- en: Also, data is usually graphed with the origin in the bottom-left, but coordinates
    measure from the top-left, so we'll need to flip the `y` coordinates; this is
    done in our list comprehension as well by subtracting the new `y` value from the
    chart height. These coordinates can now be passed to `create_line()` along with
    a reasonable `width` and the `color` argument passed in by the caller.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数据通常是以左下角为原点绘制的，但坐标是从左上角开始测量的，因此我们需要翻转`y`坐标；这也是我们的列表推导中所做的，通过从图表高度中减去新的`y`值来完成。现在可以将这些坐标传递给`create_line()`，并与合理的`宽度`和调用者传入的`颜色`参数一起传递。
- en: One last thing we need is a **legend**, to tell the user what each color on
    the chart represents. Without legend, this chart would be meaningless.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一件事是一个**图例**，告诉用户图表上的每种颜色代表什么。没有图例，这个图表将毫无意义。
- en: 'Let''s create a `draw_legend()` method:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`draw_legend()`方法：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Our method takes a dictionary that maps labels to colors, which will be provided
    by the application. For each one, we simply draw a text item containing the `label`
    text with the associated `fill` color. Since we know our labels will be short
    (only a single character), we can get away with just putting this in the margin.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法接受一个将标签映射到颜色的字典，这将由应用程序提供。对于每一个，我们只需绘制一个包含`标签`文本和相关`填充`颜色的文本项。由于我们知道我们的标签会很短（只有一个字符），我们可以只把它放在边缘。
- en: Updating the application
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新应用程序
- en: 'In the `Application` class, create a new method for showing our chart:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Application`类中，创建一个新方法来显示我们的图表：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first order of business is to fetch data from our `get_growth_by_lab()`
    method and calculate the maximum values for the `x` and `y` axes. We've done this
    by using list comprehensions to extract values into lists and calling the built-in
    `max()` function on it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首要任务是从我们的`get_growth_by_lab()`方法中获取数据，并计算`x`和`y`轴的最大值。我们通过使用列表推导将值提取到列表中，并在其上调用内置的`max()`函数来完成这一点。
- en: 'Next, we''ll build a widget to hold our `LineChartView` object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建一个小部件来容纳我们的`LineChartView`对象：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We're using the `Toplevel` widget in this case, which creates a new window outside
    our main application window. We've then created `LineChartView` that is `600`
    by `300` pixels with the *x*-axis and *y*-axis labels and added it to `Toplevel`
    using `pack()`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`Toplevel`小部件，它在我们的主应用程序窗口之外创建一个新窗口。然后我们创建了`LineChartView`，它是`600`乘`300`像素，带有*x*轴和*y*轴标签，并将其添加到`Toplevel`中使用`pack()`。
- en: 'Next, we''ll assign colors to each lab and draw `legend`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为每个实验室分配颜色并绘制`图例`：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The last thing to do is to draw the actual lines:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的是绘制实际的线：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Remember that our data contains values for all the labs together, so we're iterating
    through the labs in `legend` and using a list comprehension to extract only the
    data for that lab. Then our `plot_line()` method does the rest.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的数据包含所有实验室的值，因此我们正在`图例`中迭代实验室，并使用列表推导来提取该实验室的数据。然后我们的`plot_line()`方法完成其余工作。
- en: With this method complete, add it to the `callbacks` dictionary and add a menu
    item to the tools menu for each platform.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此方法后，将其添加到`callbacks`字典中，并为每个平台的工具菜单添加一个菜单项。
- en: 'When you call your function, you should see something like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用您的函数时，您应该看到类似这样的东西：
- en: '![](assets/db64ecf3-2169-4ea1-ac5c-954a960ba237.png)The graph won''t look like
    much without some sample data. Unless you just like doing data entry, there is
    a script for loading sample data in the `sql` directory.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/db64ecf3-2169-4ea1-ac5c-954a960ba237.png)没有一些示例数据，图表看起来不会很好。除非您只是喜欢进行数据输入，否则在`sql`目录中有一个加载示例数据的脚本。'
- en: Advanced graphs using Matplotlib and Tkinter
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Matplotlib和Tkinter创建高级图表
- en: 'Our line graph is pretty, but it still needs considerable work to be fully
    functional: it lacks a scale, grid lines, and other features that would make it
    a completely useful chart.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的折线图很漂亮，但要使其完全功能，仍需要相当多的工作：它缺少比例、网格线和其他功能，这些功能将使它成为一个完全有用的图表。
- en: 'We could spend a lot of time making it more complete, but there''s a faster
    way to get much more satisfactory graphs and charts in our Tkinter application:
    **Matplotlib**.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以花很多时间使它更完整，但在我们的Tkinter应用程序中获得更令人满意的图表和图形的更快方法是**Matplotlib**。
- en: Matplotlib is a third-party library for generating professional-quality, interactive
    graphs of all types. It's a vast library with many add-ons, and we won't cover
    much of its actual usage, but we should look at how to integrate Matplotlib into
    a Tkinter application. To do this, we'll create a bubble chart showing the yield
    of each plot as it relates to `humidity` and `temperature`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib是一个第三方库，用于生成各种类型的专业质量、交互式图表。这是一个庞大的库，有许多附加组件，我们不会涵盖其实际用法的大部分内容，但我们应该看一下如何将Matplotlib集成到Tkinter应用程序中。为此，我们将创建一个气泡图，显示每个地块的产量与`湿度`和`温度`的关系。
- en: You should be able to install `matplotlib` using `pip` with the command `pip
    install --user matplotlib`.  For complete instructions on installing, please see
    [https://matplotlib.org/users/installing.html.](https://matplotlib.org/users/installing.html)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够使用`pip install --user matplotlib`命令使用`pip`安装`matplotlib`。有关安装的完整说明，请参阅[https://matplotlib.org/users/installing.html.](https://matplotlib.org/users/installing.html)
- en: Data model method
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据模型方法
- en: 'Before we can make a chart, we''ll need a `SQLModel` method to extract the
    data:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们制作图表之前，我们需要一个`SQLModel`方法来提取数据：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The purpose of this chart is to find the sweet spot of `temperature` and `humidity`
    for each seed sample. Therefore, we need one row per `plot` that includes the
    maximum `fruit` measurement, average humidity and temperature at the `plot` column,
    and `seed_sample`. Since we don't want any bad data, we'll filter out rows that
    have `Equipment` `Fault`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表的目的是找到每个种子样本的`温度`和`湿度`的最佳点。因此，我们需要每个`plot`的一行，其中包括最大的`fruit`测量值，`plot`列处的平均湿度和温度，以及`seed_sample`。由于我们不想要任何错误的数据，我们将过滤掉具有`Equipment`
    `Fault`的行。
- en: Creating the bubble chart view
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建气泡图表视图
- en: To integrate MatplotLib into a Tkinter application, there are several imports
    we need to make.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要将MatplotLib集成到Tkinter应用程序中，我们需要进行几次导入。
- en: 'The first is `matplotlib` itself:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`matplotlib`本身：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It may seem odd to run code in the `import` section, and your editor may even
    complain about it. But before we import anything else from `matplotlib` we need
    to tell it which backend it should use. In this case, we want the `TkAgg` backend,
    which is made to integrate into Tkinter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在“导入”部分运行代码可能看起来很奇怪，甚至您的编辑器可能会对此进行投诉。但在我们从`matplotlib`导入任何其他内容之前，我们需要告诉它应该使用哪个后端。在这种情况下，我们想要使用`TkAgg`后端，这是专为集成到Tkinter中而设计的。
- en: 'Now we can make a few more imports from `matplotlib`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从`matplotlib`中再引入一些内容：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `Figure` class represents the basic drawing area on which `matplotlib` charts
    can be drawn. The `FigureCanvasTkAgg` class is an interface between the `Figure`
    and the Tkinter `Canvas`, and `NavigationToolbar2TkAgg` allows us to place a pre-made
    toolbar for `Figure` on our graph.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Figure`类表示`matplotlib`图表可以绘制的基本绘图区域。`FigureCanvasTkAgg`类是`Figure`和Tkinter`Canvas`之间的接口，`NavigationToolbar2TkAgg`允许我们在图表上放置一个预制的`Figure`工具栏。'
- en: 'To see how these fit together, let''s start our `YieldChartView` class in `views.py`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看这些如何配合，让我们在`views.py`中启动我们的`YieldChartView`类：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: After calling `super().__init__()` to create the `Frame` object, we create a
    `Figure` object to hold our chart. Instead of a size in pixels, the `Figure` object
    takes a size in **inches** and a **dots per inch** (**dpi**) setting (in this
    case, resulting in a 600 by 400 pixel `Figure`). Next, we create a `FigureCanvasTkAgg`
    object to connect our `Figure` object with a Tkinter `Canvas`. The `FigureCanvasTkAgg` object
    is not itself a `Canvas` object or subclass, but it has a `Canvas` object we can
    place in our application.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`super().__init__()`创建`Frame`对象之后，我们创建一个`Figure`对象来保存我们的图表。`Figure`对象不是以像素为单位的大小，而是以**英寸**和**每英寸点数**（**dpi**）设置为单位（在这种情况下，得到的是一个600x400像素的`Figure`）。接下来，我们创建一个`FigureCanvasTkAgg`对象，将我们的`Figure`对象与Tkinter`Canvas`连接起来。`FigureCanvasTkAgg`对象本身不是`Canvas`对象或子类，但它有一个`Canvas`对象，我们可以将其放置在我们的应用程序中。
- en: 'Next, we''ll add the toolbar and `pack()` to our `FigureCanvasTkAgg` object:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将工具栏和`pack()`添加到我们的`FigureCanvasTkAgg`对象中：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Our toolbar is passed our `FigureCanvasTkAgg` object and the root window (`self`
    in this case),  attaching it to our figure and it's canvas. To place  the `FigureCanvasTkAgg`
    object on our `Frame` object, we need to call `get_tk_widget()` to retrieve its
    Tkinter `Canvas` widget, which we can then pack or grid as desired using `pack()`
    and `grid()`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工具栏被传递给了我们的`FigureCanvasTkAgg`对象和根窗口（在这种情况下是`self`），将其附加到我们的图表和它的画布上。要将`FigureCanvasTkAgg`对象放在我们的`Frame`对象上，我们需要调用`get_tk_widget()`来检索其Tkinter`Canvas`小部件，然后我们可以使用`pack()`和`grid()`按需要对其进行打包或网格化。
- en: 'The next step is to set up the axes:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置轴：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In Matplotlib, an `axes` object represents a single set of `x` and `y` axes
    on which data can be graphed, and is created using the `add_subplot()` method.
    The three integers passed to `add_subplot()` establish that this is the first
    set of `axes` out of one row of one column of subplots. Our figure could conceivably
    contain multiple subplots arranged in a table-like format, but we only need one.
    After it's created, we set the labels on the `axes` object.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在Matplotlib中，`axes`对象表示可以在其上绘制数据的单个`x`和`y`轴集，使用`add_subplot()`方法创建。传递给`add_subplot()`的三个整数建立了这是一个子图中一行中的第一个`axes`集。我们的图表可能包含多个以表格形式排列的子图，但我们只需要一个。创建后，我们设置`axes`对象上的标签。
- en: To create a bubble chart, we're going to use the **scatter plot** feature of
    Matplotlib, but use the size of each dot to indicate the fruit yield. We'll also
    color code the dots to indicate the seed sample.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建气泡图表，我们将使用Matplotlib的**散点图**功能，但使用每个点的大小来指示水果产量。我们还将对点进行颜色编码以指示种子样本。
- en: 'Let''s implement a method to draw our scatter plots:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个绘制散点图的方法：
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The data passed in should contain three columns per record, and we're breaking
    those out into three separate lists containing the `x`, `y`, and `size` values.
    Next, we're going amplify the differences between size values to make them more
    apparent by squaring each value then dividing it by half. This isn't strictly
    necessary, but it helps make the chart more readable when differences are relatively
    small.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 传入的数据应该包含每条记录的三列，并且我们将这些分解为包含`x`、`y`和`size`值的三个单独的列表。接下来，我们将放大大小值之间的差异，使它们更加明显，方法是将每个值平方然后除以一半。这并不是绝对必要的，但在差异相对较小时，它有助于使图表更易读。
- en: Finally, we draw the data onto the `axes` object by calling `scatter()`, also
    passing along the  `color` and `label` values for the dots, and making them semi-transparent
    with the `alpha` argument.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用`scatter()`将数据绘制到`axes`对象上，同时传递`color`和`label`值给点，并使用`alpha`参数使它们半透明。
- en: '`zip(*data)` is a Python idiom for breaking a list of n-length tuples into
    n lists of values, essentially the reverse of `zip(x, y, s)`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip(*data)`是一个Python习语，用于将n长度元组的列表分解为值的n个列表，本质上是`zip(x, y, s)`的反向操作。'
- en: 'To draw legend for our `axes` object, we need two things: a list of our `scatter`
    objects and list of their labels. To get these, we''ll have to create a couple
    of blank lists in `__init__()` and append them whenever `draw_scatter()` is called.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们的`axes`对象绘制图例，我们需要两样东西：我们的`scatter`对象的列表和它们的标签列表。为了获得这些，我们将不得不在`__init__()`中创建一些空列表，并在每次调用`draw_scatter()`时进行追加。
- en: 'In `__init__()`, add some empty lists:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__()`中，添加一些空列表：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, at the end of `draw_scatter()`, append the lists and update the `legend()`
    method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`draw_scatter()`的末尾，追加列表并更新`legend()`方法：
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We can call `legend()` repeatedly and it will simply destroy and redraw the
    legend each time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以反复调用`legend()`，它会简单地销毁并重新绘制图例。
- en: Application method
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序方法
- en: Back in `Application`, let's create the method to show our yield data.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`Application`，让我们创建一个显示产量数据的方法。
- en: 'Start by creating a `Toplevel` method and adding our chart view:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个`Toplevel`方法并添加我们的图表视图：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now let''s set up the data for our scatters:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为我们的散点图设置数据：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We've retrieved the yield `data` from the data model and created a dictionary
    that will hold the colors we want to use for each seed sample.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从数据模型中检索了产量`data`，并创建了一个将保存我们想要为每个种子样本使用的颜色的字典。
- en: 'Now we just need to iterate through the seed samples and draw the scatters:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要遍历种子样本并绘制散点图：
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Once again, we're formatting and filtering down our data using a list comprehension,
    providing average humidity for `x`, average temperature for `y`, and yield for
    `s`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用列表推导式格式化和过滤我们的数据，为`x`提供平均湿度，为`y`提供平均温度，为`s`提供产量。
- en: Add the method to the `callbacks` dictionary and create a menu item for it just
    under the growth chart option.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 将该方法添加到`callbacks`字典中，并在生长图选项下方创建一个菜单项。
- en: 'Your bubble chart should look something like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您的气泡图应该看起来像这样：
- en: '![](assets/335e2505-6f35-4708-aaa0-5a5e1948112e.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/335e2505-6f35-4708-aaa0-5a5e1948112e.png)'
- en: Take a moment to play with this chart using the navigation toolbar. Notice how
    you can zoom and pan, adjust the size of the chart, and save the image. These
    are powerful tools that Matplotlib provides automatically.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请利用导航工具栏玩一下这个图表，注意你可以缩放和平移，调整图表的大小，并保存图像。这些都是Matplotlib自动提供的强大工具。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about Tkinter's graphical capabilities. You learned
    how to draw and animate figures on the Tkinter `Canvas` widget, and how to use
    these capabilities to visualize data. You also learned how to integrate Matplotlib
    figures into your application, and we implemented two charts in our application
    by connecting SQL queries to our chart views.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了Tkinter的图形能力。您学会了如何在Tkinter的`Canvas`小部件上绘制和动画图形，以及如何利用这些能力来可视化数据。您还学会了如何将Matplotlib图形集成到您的应用程序中，并通过将SQL查询连接到我们的图表视图，在我们的应用程序中实现了两个图表。
