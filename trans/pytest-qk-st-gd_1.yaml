- en: Writing and Running Tests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写和运行测试
- en: In the previous chapter, we discussed why testing is so important and looked
    at a brief overview of the `unittest` module. We also took a cursory look at pytest's
    features, but barely got a taste of them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了为什么测试如此重要，并简要概述了`unittest`模块。我们还粗略地看了pytest的特性，但几乎没有尝试过。
- en: In this chapter, we will start our journey with pytest. We will be pragmatic,
    so this means that we will not take an exhaustive look at all of the things it's
    possible to do with pytest, but instead provide you with a quick overview of the
    basics to make you productive quickly. We will take a look at how to write tests,
    how to organize them into files and directories, and how to use pytest's command
    line effectively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用pytest。我们将实用主义，这意味着我们不会详尽地研究pytest的所有可能功能，而是为您提供快速概述基础知识，以便您能够迅速提高生产力。我们将看看如何编写测试，如何将它们组织到文件和目录中，以及如何有效地使用pytest的命令行。
- en: 'Here''s what is covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下内容：
- en: Installing pytest
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装pytest
- en: Writing and running tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写和运行测试
- en: Organizing files and packages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织文件和包
- en: Useful command-line options
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有用的命令行选项
- en: 'Configuration: `pytest.ini` file'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置：`pytest.ini`文件
- en: In the chapter, there are a lot of examples typed into the command line. They
    are marked by the λ character. To avoid clutter and to focus on the important
    parts, the pytest header (which normally displays the pytest version, the Python
    version, installed plugins, and so on) will be suppressed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，有很多示例在命令行中输入。它们由λ字符标记。为了避免混乱并专注于重要部分，将抑制pytest标题（通常显示pytest版本、Python版本、已安装插件等）。
- en: Let's jump right into how to install pytest.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入如何安装pytest。
- en: Installing pytest
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装pytest
- en: Installing pytest is really simple, but first, let's take a moment to review
    good practices for Python development.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 安装pytest非常简单，但首先让我们花点时间回顾Python开发的良好实践。
- en: All of the examples are for Python 3\. They should be easy to adapt to Python
    2 if necessary.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例都是针对Python 3的。如果需要，它们应该很容易适应Python 2。
- en: pip and virtualenv
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pip和virtualenv
- en: The recommended practice for installing dependencies is to create a `virtualenv`.
    A `virtualenv` ([https://packaging.python.org/guides/installing-using-pip-and-virtualenv/](https://packaging.python.org/guides/installing-using-pip-and-virtualenv/))
    acts like a complete separate Python installation from the one that comes with
    your operating system, making it safe to install the packages required by your
    application without risk of breaking your system Python or tools.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装依赖项的推荐做法是创建一个`virtualenv`。`virtualenv`（[https://packaging.python.org/guides/installing-using-pip-and-virtualenv/](https://packaging.python.org/guides/installing-using-pip-and-virtualenv/)）就像是一个完全独立的Python安装，不同于操作系统自带的Python，因此可以安全地安装应用程序所需的软件包，而不会破坏系统Python或工具。
- en: 'Now we will learn how to create a virtual environment and install pytest using
    pip. If you are already familiar with `virtualenv` and pip, you can skip this
    section:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将学习如何创建虚拟环境并使用pip安装pytest。如果您已经熟悉`virtualenv`和pip，可以跳过本节：
- en: 'Type this in your Command Prompt to create a `virtualenv`:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符中键入以下内容以创建`virtualenv`：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command will create a `.env` folder in the current directory, containing
    a full-blown Python installation. Before proceeding, you should `activate` the
    `virtualenv`:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此命令将在当前目录中创建一个`.env`文件夹，其中包含完整的Python安装。在继续之前，您应该`activate` `virtualenv`：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or on Windows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在Windows上：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will put the `virtualenv` Python in front of the `$PATH` environment variable,
    so Python, pip, and other tools will be executed from the `virtualenv`, not from
    your system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`virtualenv` Python放在`$PATH`环境变量的前面，因此Python、pip和其他工具将从`virtualenv`而不是系统中执行。
- en: 'Finally, to install pytest, type:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，要安装pytest，请键入：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can verify that everything went well by typing:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过键入以下内容来验证一切是否顺利进行：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we are all set up and can begin!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好可以开始了！
- en: Writing and running tests
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写和运行测试
- en: 'Using pytest, all you need to do to start writing tests is to create a new
    file named `test_*.py` and write test functions that start with `test`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pytest，您只需要创建一个名为`test_*.py`的新文件，并编写以`test`开头的测试函数：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To execute this test, simply execute `pytest`, passing the name of the file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此测试，只需执行`pytest`，并传递文件名：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you don't pass anything, pytest will look for all of the test files from
    the current directory recursively and execute them automatically.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不传递任何内容，pytest将递归查找当前目录中的所有测试文件并自动执行它们。
- en: 'You might encounter examples on the internet that use `py.test` in the command
    line instead of `pytest`. The reason for that is historical: pytest used to be
    part of the `py` package, which provided several general purpose utilities, including
    tools that followed the convention of starting with `py.<TAB>` for tab completion,
    but since then, it has been moved into its own project. The old `py.test` command
    is still available and is an alias to `pytest`, but the latter is the recommended
    modern usage.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会在互联网上遇到使用命令行中的`py.test`而不是`pytest`的示例。原因是历史性的：pytest曾经是`py`包的一部分，该包提供了几个通用工具，包括遵循以`py.<TAB>`开头的约定的工具，用于制表符补全，但自那时起，它已经被移动到自己的项目中。旧的`py.test`命令仍然可用，并且是`pytest`的别名，但后者是推荐的现代用法。
- en: 'Note that there''s no need to create classes; just simple functions and plain
    `assert` statements are enough, but if you want to use classes to group tests
    you can do so:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无需创建类；只需简单的函数和简单的`assert`语句就足够了，但如果要使用类来分组测试，也可以这样做：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Grouping tests can be useful when you want to put a number of tests under the
    same scope: you can execute tests based on the class they are in, apply markers
    to all of the tests in a class ([Chapter 3](6a37176b-78d0-4e6c-8185-460d48869d23.xhtml),
    *Markers and Parametrization*), and create fixtures bound to a class ([Chapter
    4](bf8b3438-83e6-4ce5-9df4-4da086636ef7.xhtml), *Fixtures*).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要将多个测试放在同一范围下时，分组测试可能很有用：您可以根据它们所在的类执行测试，对类中的所有测试应用标记（[第3章](6a37176b-78d0-4e6c-8185-460d48869d23.xhtml)，*标记和参数化*），并创建绑定到类的固定装置（[第4章](bf8b3438-83e6-4ce5-9df4-4da086636ef7.xhtml)，*固定装置*）。
- en: Running tests
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行测试
- en: Pytest can run your tests in a number of ways. Let's quickly get into the basics
    now and, later on in the chapter, we will move on to more advanced options.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest可以以多种方式运行您的测试。现在让我们快速了解基础知识，然后在本章后面，我们将转向更高级的选项。
- en: 'You can start by just simply executing the `pytest` command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从简单地执行`pytest`命令开始：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will find all of the `test_*.py` and `*_test.py` modules in the current
    directory and below recursively, and will run all of the tests found in those
    files:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这将递归地查找当前目录和以下所有`test_*.py`和`*_test.py`模块，并运行这些文件中找到的所有测试：
- en: 'You can reduce the search to specific directories:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将搜索范围缩小到特定目录：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also mix any number of files and directories:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以混合任意数量的文件和目录：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can execute specific tests by using the syntax `<test-file>::<test-function-name>`:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用语法“<test-file>::<test-function-name>”执行特定的测试：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can execute all of the `test` methods of a `test` class:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以执行“test”类的所有“test”方法：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can execute a specific `test` method of a `test` class using the syntax `<test-file>::<test-class>::<test-method-name>`:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用语法“<test-file>::<test-class>::<test-method-name>”执行“test”类的特定“test”方法：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The syntax used above is created internally by pytest, is unique to each test
    collected, and is called a `node id` or `item id`*. *It basically consists of
    the filename of the testing module, class, and functions joined together by the `::` characters.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上面使用的语法是pytest内部创建的，对于每个收集的测试都是唯一的，并称为“节点ID”或“项目ID”。它基本上由测试模块的文件名，类和函数通过“::”字符连接在一起。
- en: 'Pytest will show a more verbose output, which includes node IDs, with the `-v`
    flag:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: pytest将显示更详细的输出，其中包括节点ID，使用`-v`标志：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To see which tests there are without running them, use the `--collect-only` 
    flag:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看有哪些测试而不运行它们，请使用`--collect-only`标志：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`--collect-only` is especially useful if you want to execute a specific test
    but can''t remember its exact name.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要执行特定测试但无法记住其确切名称，则`--collect-only`特别有用。
- en: Powerful asserts
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强大的断言
- en: As you've probably already noticed, pytest makes use of the built-in `assert`
    statement to check assumptions during testing. Contrary to other frameworks, you
    don't need to remember various `self.assert*` or `self.expect*` functions. While this
    may not seem like a big deal at first, after spending some time using plain asserts,
    you will realize how much that makes writing tests more enjoyable and natural.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，pytest利用内置的`assert`语句来检查测试期间的假设。与其他框架相反，您不需要记住各种`self.assert*`或`self.expect*`函数。虽然一开始可能看起来不是很重要，但在使用普通断言一段时间后，您会意识到这使得编写测试更加愉快和自然。
- en: 'Again, here''s an example of a failure:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这是一个失败的示例：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Pytest shows the line of the failure, as well as the variables and expressions
    involved in the failure. By itself, this would be pretty cool already, but pytest
    goes a step further and provides specialized explanations of failures involving
    other data types.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: pytest显示了失败的行，以及涉及失败的变量和表达式。单独来看，这已经相当酷了，但pytest进一步提供了有关涉及其他数据类型的失败的专门解释。
- en: Text differences
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本差异
- en: 'When showing the explanation for short strings, pytest uses a simple difference
    method:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示短字符串的解释时，pytest使用简单的差异方法：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Longer strings show a smarter delta, using `difflib.ndiff` to quickly spot
    the differences:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 较长的字符串显示更智能的增量，使用`difflib.ndiff`快速发现差异：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Multiline strings are also treated specially:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 多行字符串也会被特殊处理：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Lists
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'Assertion failures for lists also show only differing items by default:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的断言失败也默认只显示不同的项目：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that pytest shows which index differs, and also that the `-v` flag can
    be used to show the complete difference between the lists:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，pytest显示了哪个索引不同，并且`-v`标志可用于显示列表之间的完整差异：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the difference is too big, pytest is smart enough to show only a portion
    to avoid showing too much output, displaying a message like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果差异太大，pytest足够聪明，只显示一部分以避免显示太多输出，显示以下消息：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Dictionaries and sets
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典和集合
- en: 'Dictionaries are probably one of the most used data structures in Python, so,
    unsurprisingly, pytest has specialized representation for them:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 字典可能是Python中最常用的数据结构之一，因此pytest为其提供了专门的表示：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Sets also have similar output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 集合也具有类似的输出：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As with lists, there are also `-v` and `-vv` options for displaying more detailed
    output.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表一样，还有`-v`和`-vv`选项以显示更详细的输出。
- en: How does pytest do it?
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pytest是如何做到的？
- en: By default, Python's assert statement does not provide any details when it fails,
    but as we just saw, pytest shows a lot of information about the variables and
    expressions involved in a failed assertion. So how does pytest do it?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Python的assert语句在失败时不提供任何详细信息，但正如我们刚才看到的，pytest显示了有关失败断言中涉及的变量和表达式的大量信息。那么pytest是如何做到的呢？
- en: Pytest is able to provide useful exceptions because it implements a mechanism
    called *assertion rewriting*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: pytest能够提供有用的异常，因为它实现了一种称为“断言重写”的机制。
- en: Assertion rewriting works by installing a custom import hook that intercepts
    the standard Python import mechanism. When pytest detects that a test file (or
    plugin) is about to be imported, instead of loading the module, it first compiles
    the source code into an **abstract syntax tree** (**AST**) using the built-in
    `ast` module. Then, it searches for any `assert` statements and *rewrites* them
    so that the variables used in the expression are kept so that they can be used
    to show more helpful messages if the assertion fails. Finally, it saves the rewritten
    `pyc` file to disk for caching.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 断言重写通过安装自定义导入钩子来拦截标准Python导入机制。当pytest检测到即将导入测试文件（或插件）时，它首先将源代码编译成**抽象语法树**（**AST**），使用内置的`ast`模块。然后，它搜索任何`assert`语句并*重写*它们，以便保留表达式中使用的变量，以便在断言失败时显示更有帮助的消息。最后，它将重写后的`pyc`文件保存到磁盘进行缓存。
- en: This all might seem very magical, but the process is actually simple, deterministic,
    and, best of all, completely transparent.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切可能看起来非常神奇，但实际上这个过程是简单的、确定性的，而且最重要的是完全透明的。
- en: If you want more details, refer to [http://pybites.blogspot.com.br/2011/07/behind-scenes-of-pytests-new-assertion.html](http://pybites.blogspot.com.br/2011/07/behind-scenes-of-pytests-new-assertion.html),
    written by the original developer of this feature, Benjamin Peterson. The `pytest-ast-back-to-python`
    plugin shows exactly what the AST of your test files looks like after the rewriting
    process. Refer to: [https://github.com/tomviner/pytest-ast-back-to-python](https://github.com/tomviner/pytest-ast-back-to-python).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多细节，请参考[http://pybites.blogspot.com.br/2011/07/behind-scenes-of-pytests-new-assertion.html](http://pybites.blogspot.com.br/2011/07/behind-scenes-of-pytests-new-assertion.html)，由此功能的原始开发者Benjamin
    Peterson编写。`pytest-ast-back-to-python`插件会准确显示重写过程后测试文件的AST是什么样子的。请参阅：[https://github.com/tomviner/pytest-ast-back-to-python](https://github.com/tomviner/pytest-ast-back-to-python)。
- en: 'Checking exceptions: pytest.raises'
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查异常：pytest.raises
- en: A good API documentation will clearly explain what the purpose of each function
    is, its parameters, and return values. Great API documentation also clearly explains
    which exceptions are raised and when.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的API文档将清楚地解释每个函数的目的、参数和返回值。优秀的API文档还清楚地解释了在何时引发异常。
- en: For that reason, testing that exceptions are raised in the appropriate circumstances is
    just as important as testing the main functionality of APIs. It is also important
    to make sure that exceptions contain an appropriate and clear message to help
    users understand the issue.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试异常在适当情况下引发的情况，和测试API的主要功能一样重要。还要确保异常包含适当和清晰的消息，以帮助用户理解问题。
- en: Suppose we are writing an API for a game. This API allows programmers to write
    `mods`, which are a plugin of sorts that can change several aspects of a game,
    from new textures to complete new story lines and types of characters.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在为一个游戏编写API。这个API允许程序员编写`mods`，这是一种插件，可以改变游戏的多个方面，从新的纹理到完全新的故事情节和角色类型。
- en: 'This API has a function that allows mod writers to create a new character,
    and it can raise exceptions in some situations:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API有一个函数，允许模块编写者创建一个新的角色，并且在某些情况下可能会引发异常：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Pytest makes it easy to check that your code is raising the proper exceptions
    with the `raises` statement:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest使得检查代码是否使用`raises`语句引发了适当的异常变得容易：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`pytest.raises` is a with-statement that ensures the exception class passed
    to it will be **raised** inside its execution **block**. For more details ([https://docs.python.org/3/reference/compound_stmts.html#the-with-statement](https://docs.python.org/3/reference/compound_stmts.html#the-with-statement)).
    Let''s see how `create_character` implements those checks:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest.raises`是一个with语句，它确保传递给它的异常类将在其执行块内被**触发**。更多细节请参阅（[https://docs.python.org/3/reference/compound_stmts.html#the-with-statement](https://docs.python.org/3/reference/compound_stmts.html#the-with-statement)）。让我们看看`create_character`如何实现这些检查：'
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you are paying close attention, you probably noticed that the copy-paste
    error in the preceding code should actually raise an  `InvalidClassNameError` for
    the class name check.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察，您可能会注意到前面代码中的复制粘贴错误实际上应该为类名检查引发一个`InvalidClassNameError`。
- en: 'Executing this file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此文件：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`test_empty_name` passed as expected. `test_invalid_class_name` raised `InvalidClassNameError`,
    so the exception was not captured by `pytest.raises`, which failed the test (as
    any other exception would).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_empty_name`按预期通过。`test_invalid_class_name`引发了`InvalidClassNameError`，因此异常未被`pytest.raises`捕获，这导致测试失败（就像任何其他异常一样）。'
- en: Checking exception messages
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查异常消息
- en: As stated at the start of this section, APIs should provide clear messages in
    the exceptions they raise. In the previous examples, we only verified that the
    code was raising the appropriate exception type, but not the actual message.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节开头所述，API应该在引发异常时提供清晰的消息。在前面的例子中，我们只验证了代码是否引发了适当的异常类型，但没有验证实际消息。
- en: '`pytest.raises` can receive an optional `match` argument, which is a regular
    expression string that will be matched against the exception message, as well
    as checking the exception type. For more details, go to: [https://docs.python.org/3/howto/regex.html](https://docs.python.org/3/howto/regex.html).
    We can use that to improve our tests even further:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest.raises`可以接收一个可选的`match`参数，这是一个正则表达式字符串，将与异常消息匹配，以及检查异常类型。更多细节，请访问：[https://docs.python.org/3/howto/regex.html](https://docs.python.org/3/howto/regex.html)。我们可以使用它来进一步改进我们的测试：'
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Simple!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 简单！
- en: 'Checking warnings: pytest.warns'
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查警告：pytest.warns
- en: APIs also evolve. New and better alternatives to old functions are provided,
    arguments are removed, old ways of using a certain functionality evolve into better
    ways, and so on.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: API也在不断发展。为旧功能提供新的更好的替代方案，删除参数，旧的使用某个功能的方式演变为更好的方式，等等。
- en: API writers have to strike a balance between keeping old code working to avoid
    breaking clients and providing better ways of doing things, while all the while
    keeping their own API code maintainable. For this reason, a solution often adopted
    is to start to issue `warnings` when API clients use the old behavior, in the
    hope that they update their code to the new constructs. Warning messages are shown
    in situations where the current usage is not wrong to warrant an exception, it
    just happens that there are new and better ways of doing it. Often, warning messages
    are shown during a grace period for this update to take place, and afterward the
    old way is no longer supported.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: API编写者必须在保持旧代码正常工作以避免破坏客户端和提供更好的方法之间取得平衡，同时保持自己的API代码可维护。因此，通常采用的解决方案是开始在API客户端使用旧行为时发出`warnings`，希望他们更新其代码以适应新的结构。警告消息显示在当前用法不足以引发异常的情况下，只是发生了新的更好的方法。通常，在此更新期间会显示警告消息，之后旧的方式将不再受支持。
- en: 'Python provides the standard warnings module exactly for this purpose, making
    it easy to warn developers about forthcoming changes in APIs. For more details,
    go to: [https://docs.python.org/3/library/warnings.html](https://docs.python.org/3/library/warnings.html).
    It lets you choose from a number of warning classes, for example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了标准的warnings模块，专门用于此目的，可以轻松地警告开发人员关于API中即将发生的更改。有关更多详细信息，请访问：[https://docs.python.org/3/library/warnings.html](https://docs.python.org/3/library/warnings.html)。它让您可以从多个警告类中进行选择，例如：
- en: '`UserWarning`: user warnings (`user` here means developers, not software users)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserWarning`: 用户警告（这里的“用户”指的是开发人员，而不是软件用户）'
- en: '`DeprecationWarning`: features that will be removed in the future'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeprecationWarning`: features that will be removed in the future'
- en: '`ResourcesWarning`: related to resource usage'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResourcesWarning`: 与资源使用相关'
- en: (This list is not exhaustive. Consult the warnings documentation for the full
    listing. For more details, go to: [https://docs.python.org/3/library/warnings.html](https://docs.python.org/3/library/warnings.html)[).](https://docs.python.org/3/library/warnings.html)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: （此列表不是详尽无遗的。请查阅警告文档以获取完整列表。有关更多详细信息，请访问：[https://docs.python.org/3/library/warnings.html](https://docs.python.org/3/library/warnings.html)）。
- en: Warning classes help users control which warnings should be shown and which
    ones should be suppressed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 警告类帮助用户控制应该显示哪些警告，哪些应该被抑制。
- en: 'For example, suppose an API for a computer game provides this handy function
    to obtain the starting hit points of player characters given their class name:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个电脑游戏的API提供了这个方便的函数，可以根据玩家角色的类名获取起始生命值：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Time moves forward and the developers decide to use an `enum` instead of class
    names in the next release. For more details, go to: [https://docs.python.org/3/library/enum.html](https://docs.python.org/3/library/enum.html),
    which is more adequate to represent a limited set of values:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 时间在流逝，开发人员决定在下一个版本中使用`enum`而不是类名。有关更多详细信息，请访问：[https://docs.python.org/3/library/enum.html](https://docs.python.org/3/library/enum.html)，这更适合表示有限的一组值：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'But changing this suddenly would break all clients, so they wisely decide to
    support both forms for the next release: `str` and the `PlayerClass` `enum`. They
    don''t want to keep supporting this forever, so they start showing a warning whenever
    a class is passed as a `str`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但是突然更改这一点会破坏所有客户端，因此他们明智地决定在下一个版本中支持这两种形式：`str`和`PlayerClass` `enum`。他们不想永远支持这一点，因此他们开始在将类作为`str`传递时显示警告：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the same vein as `pytest.raises` from the previous section, the `pytest.warns`
    function lets you test whether your API code is producing the warnings you expect:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节的`pytest.raises`类似，`pytest.warns`函数让您测试API代码是否产生了您期望的警告：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As with `pytest.raises`, `pytest.warns` can receive an optional `match` argument,
    which is a regular expression string. For more details, go to: [https://docs.python.org/3/howto/regex.html](https://docs.python.org/3/howto/regex.html), which
    will be matched against the exception message:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与`pytest.raises`一样，`pytest.warns`可以接收一个可选的`match`参数，这是一个正则表达式字符串。将与异常消息匹配：有关更多详细信息，请访问：[https://docs.python.org/3/howto/regex.html](https://docs.python.org/3/howto/regex.html)，
- en: '[PRE34]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Comparing floating point numbers: pytest.approx'
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较浮点数：pytest.approx
- en: 'Comparing floating point numbers can be tricky. For more details, go to: [https://docs.python.org/3/tutorial/floatingpoint.html](https://docs.python.org/3/tutorial/floatingpoint.html).
    Numbers that we consider equal in the real world are not so when represented by
    computer hardware:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 比较浮点数可能会很棘手。有关更多详细信息，请访问：[https://docs.python.org/3/tutorial/floatingpoint.html](https://docs.python.org/3/tutorial/floatingpoint.html)。在现实世界中我们认为相等的数字，在计算机硬件表示时并非如此：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When writing tests, it is very common to compare the results produced by our
    code against what we expect as floating point values. As shown above, a simple
    `==` comparison often won''t be sufficient. A common approach is to use a known
    tolerance instead and use `abs` to correctly deal with negative numbers:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试时，很常见的是将我们的代码产生的结果与我们期望的浮点值进行比较。如上所示，简单的`==`比较通常是不够的。一个常见的方法是使用已知的公差，然后使用`abs`来正确处理负数：
- en: '[PRE36]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: But besides being ugly and hard to understand, it is sometimes difficult to
    come up with a tolerance that works in most situations. The chosen tolerance of
    `0.0001` might work for the numbers above, but not for very large numbers or very
    small ones. Depending on the computation performed, you would need to find a suitable
    tolerance for every set of input numbers, which is tedious and error-prone.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，除了难看和难以理解之外，有时很难找到适用于大多数情况的公差。所选的`0.0001`的公差可能适用于上面的数字，但对于非常大的数字或非常小的数字则不适用。根据所执行的计算，您需要为每组输入数字找到一个合适的公差，这是繁琐且容易出错的。
- en: '`pytest.approx` solves this problem by automatically choosing a tolerance appropriate
    for the values involved in the expression, providing a very nice syntax to boot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest.approx`通过自动选择适用于表达式中涉及的值的公差来解决这个问题，还提供了非常好的语法：'
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can read the above as `assert that 0.1 + 0.2 equals approximately to 0.3`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将上述内容理解为`断言0.1 + 0.2大约等于0.3`。
- en: 'But the  `approx` function does not stop there; it can be used to compare:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`approx`函数并不止于此；它可以用于比较：
- en: 'Sequences of numbers:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字序列：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Dictionary `values` (not keys):'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典`values`（而不是键）：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`numpy` arrays:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numpy`数组：'
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When a test fails, `approx` provides a nice error message displaying the values
    that failed and the tolerance used:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试失败时，`approx`提供了一个很好的错误消息，显示了失败的值和使用的公差：
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Organizing files and packages
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织文件和包
- en: Pytest needs to import your code and test modules, and it is up to you how to
    organize them. Pytest supports two common test layouts, which we will discuss
    next.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest需要导入您的代码和测试模块，您可以自行决定如何组织它们。Pytest支持两种常见的测试布局，我们将在下面讨论。
- en: Tests that accompany your code
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伴随您的代码的测试
- en: 'You can place your test modules together with the code they are testing by
    creating a `tests` folder next to the modules themselves:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在模块旁边创建一个`tests`文件夹，将测试模块放在它们测试的代码旁边：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'By putting the tests near the code they test, you gain the following advantages:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将测试放在测试代码附近，您将获得以下优势：
- en: It is easier to add new tests and test modules in this hierarchy and keep them
    in sync
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种层次结构中更容易添加新的测试和测试模块，并保持它们同步
- en: Your tests are now part of your package, so they can be deployed and run in
    other environments
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的测试现在是您包的一部分，因此它们可以在其他环境中部署和运行
- en: The main disadvantage with this approach is that some folks don't like the added
    package size of the extra modules, which are now packaged together with the rest
    of the code, but this is usually minimal and of little concern.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要缺点是，有些人不喜欢额外模块增加的包大小，这些模块现在与其余代码一起打包，但这通常是微不足道的，不值一提。
- en: 'As an additional benefit, you can use the `--pyargs` option to specify tests
    using their module import path. For example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的好处，您可以使用`--pyargs`选项来指定使用模块导入路径的测试。例如：
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will execute all test modules found under `mylib.tests`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行在`mylib.tests`下找到的所有测试模块。
- en: You might consider using `_tests` for the test module names instead of `_test`.
    This makes the directory easier to find because the leading underscore usually
    makes them appear at the top of the folder hierarchy. Of course, feel free to
    use `tests` or any other name that you prefer; pytest doesn't care as long as
    the test modules themselves are named `test_*.py` or `*_test.py`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能考虑使用`_tests`而不是`_test`作为测试模块名称。这样可以更容易找到目录，因为前导下划线通常会使它们出现在文件夹层次结构的顶部。当然，随意使用`tests`或任何其他您喜欢的名称；pytest不在乎，只要测试模块本身的名称为`test_*.py`或`*_test.py`。
- en: Tests separate from your code
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试与代码分离
- en: 'An alternative to the method above is to organize your tests in a separate
    directory from the main package:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述方法的替代方法是将测试组织在与主包不同的目录中：
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Some people prefer this layout because:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人更喜欢这种布局，因为：
- en: It keeps library code and testing code separate
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将库代码和测试代码分开
- en: The testing code is not included in the source package
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码不包含在源包中
- en: 'One disadvantage of the above method is that, once you have a more complex
    hierarchy, you will probably want to keep the same hierarchy inside your tests
    directory, and that''s a little harder to maintain and keep in sync:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法的一个缺点是，一旦您有一个更复杂的层次结构，您可能希望保持测试目录内部的相同层次结构，这可能更难维护和保持同步：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So, which layout is the best? Both layouts have advantages and disadvantages.
    Pytest itself works perfectly well with either of them, so feel free to choose
    a layout that you are more comfortable with.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，哪种布局最好呢？两种布局都有优点和缺点。Pytest本身可以很好地与它们中的任何一个一起使用，所以请随意选择您更舒适的布局。
- en: Useful command-line options
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的命令行选项
- en: Now we will take a look at command-line options that will make you more productive
    in your daily work. As stated at the beginning of the chapter, this is not a complete
    list of all of the command-line features; just the ones that you will use (and
    love) the most.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一下命令行选项，这些选项将使您在日常工作中更加高效。正如本章开头所述，这不是所有命令行功能的完整列表；只是您将使用（并喜爱）最多的那些。
- en: 'Keyword expressions: -k'
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键字表达式：-k
- en: Often, you don't exactly remember the full path or name of a test that you want
    to execute. At other times, many tests in your suite follow a similar pattern
    and you want to execute all of them because you just refactored a sensitive area
    of the code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您可能不完全记得要执行的测试的完整路径或名称。在其他时候，您的套件中的许多测试遵循相似的模式，您希望执行所有这些测试，因为您刚刚重构了代码的一个敏感区域。
- en: 'By using the `-k <EXPRESSION>` flag (from *keyword expression*), you can run
    tests whose `item id` loosely matches the given expression:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`-k <EXPRESSION>`标志（来自*关键字表达式*），您可以运行`item id`与给定表达式松散匹配的测试：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will execute all tests that contain the string `parse` in their item IDs.
    You can also write simple Python expressions using Boolean operators:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行所有包含其项目ID中包含字符串`parse`的测试。您还可以使用布尔运算符编写简单的Python表达式：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will execute all tests that contain `parse` but not `num` in their item
    IDs.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行所有包含`parse`但不包含`num`的测试。
- en: 'Stop soon: -x, --maxfail'
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尽快停止：-x，--maxfail
- en: When doing large-scale refactorings, you might not know beforehand how or which
    tests are going to be affected. In those situations, you might try to guess which
    modules will be affected and start running tests for those. But, often, you end
    up breaking more tests than you initially estimated and quickly try to stop the
    test session by hitting `CTRL+C` when everything starts to fail unexpectedly.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行大规模重构时，您可能事先不知道如何或哪些测试会受到影响。在这种情况下，您可能会尝试猜测哪些模块会受到影响，并开始运行这些模块的测试。但是，通常情况下，您会发现自己破坏了比最初估计的更多的测试，并迅速尝试通过按下`CTRL+C`来停止测试会话，当一切开始意外地失败时。
- en: In those situations, you might try using the `--maxfail=N` command-line flag,
    which stops the test session automatically after `N` failures or errors, or the
    shortcut `-x`, which equals `--maxfail=1`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，您可以尝试使用`--maxfail=N`命令行标志，该标志在`N`次失败或错误后自动停止测试会话，或者快捷方式`-x`，它等于`--maxfail=1`。
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This allows you to quickly see the first failing test and deal with the failure.
    After fixing the reason for the failure, you can continue running with `-x` to
    deal with the next problem.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这使您可以快速查看第一个失败的测试并处理失败。修复失败原因后，您可以继续使用`-x`来处理下一个问题。
- en: If you find this brilliant, you don't want to skip the next section!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您觉得这很棒，您不会想跳过下一节！
- en: 'Last failed, failed first: --lf, --ff'
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上次失败，首先失败：--lf，--ff
- en: Pytest always remembers tests that failed in previous sessions, and can reuse
    that information to skip right to the tests that have failed previously. This
    is excellent news if you are incrementally fixing a test suite after a large refactoring,
    as mentioned in the previous section.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest始终记住以前会话中失败的测试，并可以重用该信息以直接跳转到以前失败的测试。如果您在大规模重构后逐步修复测试套件，这是一个好消息，如前一节所述。
- en: You can run the tests that failed before by passing the `--lf` flag (meaning last
    failed*):*
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过传递`--lf`标志（意思是*上次失败*）来运行以前失败的测试：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When used together with `-x` (`--maxfail=1`) these two flags are refactoring
    heaven:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当与`-x`（`--maxfail=1`）一起使用时，这两个标志是重构的天堂：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This lets you start executing the full suite and then pytest stops at the first
    test that fails. You fix the code, and execute the same command line again. Pytest
    starts right at the failed test, and goes on if it passes (or stops again if you
    haven't yet managed to fix the code yet). It will then stop at the next failure.
    Rinse and repeat until all tests pass again.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你就可以开始执行完整的测试套件，然后pytest在第一个失败的测试停止。你修复代码，然后再次执行相同的命令行。Pytest会直接从失败的测试开始，如果通过（或者如果你还没有成功修复代码，则再次停止）。然后它会在下一个失败处停止。反复进行，直到所有测试再次通过。
- en: Keep in mind that it doesn't matter if you execute another subset of tests in
    the middle of your refactoring; pytest always remembers which tests failed, regardless
    of the command-line executed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，无论您在重构过程中执行了另一个测试子集，pytest始终会记住哪些测试失败了，而不管执行的命令行是什么。
- en: If you have ever done a large refactoring and had to keep track of which tests
    were failing so that you didn't waste your time running the test suite over and
    over again, you will definitely appreciate this boost in your productivity.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经进行过大规模重构，并且必须跟踪哪些测试失败，以便不会浪费时间一遍又一遍地运行测试套件，那么您肯定会欣赏这种提高生产力的方式。
- en: 'Finally, the `--ff` flag is similar to `--lf`, but it will reorder your tests
    so the previous failures are run **first**, followed by the tests that passed
    or that were not run yet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`--ff`标志类似于`--lf`，但它将重新排序您的测试，以便首先运行以前失败的测试，然后是通过的测试或尚未运行的测试：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Output capturing: -s and --capture'
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出捕获：-s和--capture
- en: Sometimes, developers leave `print` statements laying around by mistake, or
    even on purpose, to be used later for debugging. Some applications also may write
    to `stdout`  or `stderr` as part of their normal operation or logging.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，开发人员会错误地留下`print`语句，甚至故意留下以供以后调试使用。有些应用程序也可能会在正常操作或日志记录的过程中写入`stdout`或`stderr`。
- en: All that output would make understanding the test suite display much harder.
    For this reason, by default, pytest captures all output written to `stdout` and
    `stderr` automatically.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些输出会使理解测试套件的显示变得更加困难。因此，默认情况下，pytest会自动捕获写入`stdout`和`stderr`的所有输出。
- en: 'Consider this function to compute a hash of some text given to it that has
    some debugging code left on it:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个函数来计算给定文本的哈希值，其中留下了一些调试代码：
- en: '[PRE52]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We have a very simple test for it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对此有一个非常简单的测试：
- en: '[PRE53]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When executing this test, by default, you won''t see the output of the `print`
    calls:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此测试时，默认情况下，您将看不到`print`调用的输出：
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: That's nice and clean.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这很干净。
- en: But those print statements are there to help you understand and debug the code,
    which is why pytest will show the captured output if the test **fails**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些打印语句是为了帮助您理解和调试代码，这就是为什么pytest会在测试**失败**时显示捕获的输出。
- en: 'Let''s change the contents of the hashed text but not the hash itself. Now,
    pytest will show the captured output in a separate section after the error traceback:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改哈希文本的内容，但不更改哈希本身。现在，pytest将在错误回溯后的单独部分显示捕获的输出：
- en: '[PRE55]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Showing the captured output on failing tests is very handy when running tests
    locally, and even more so when running tests on CI.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地运行测试时，显示失败测试的捕获输出非常方便，甚至在CI上运行测试时也是如此。
- en: Disabling capturing with -s
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用-s禁用捕获
- en: While running your tests locally, you might want to disable output capturing
    to see what messages are being printed in real-time, or whether the capturing
    is interfering with other capturing your code might be doing.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地运行测试时，您可能希望禁用输出捕获，以查看实时打印的消息，或者捕获是否干扰了代码可能正在进行的其他捕获。
- en: 'In those cases, just pass `-s` to pytest to completely disable capturing:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，只需向pytest传递`-s`以完全禁用捕获：
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Capture methods with --capture
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用--capture捕获方法
- en: 'Pytest has two methods to capture output. Which method is used can be chosen
    with the `--capture` command-line flag:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest有两种捕获输出的方法。可以使用`--capture`命令行标志选择使用哪种方法：
- en: '`--capture=fd`: captures output at the **file-descriptor level**, which means
    that all output written to the file descriptors, 1 (stdout) and 2 (stderr), is
    captured. This will capture output even from C extensions and is the default.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--capture=fd`：在**文件描述符级别**捕获输出，这意味着所有写入文件描述符1（stdout）和2（stderr）的输出都会被捕获。这将捕获来自C扩展的输出，这也是默认值。'
- en: '`--capture=sys`: captures output written directly to `sys.stdout` and `sys.stderr`
    at the Python level, without trying to capture system-level file descriptors.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--capture=sys`：捕获直接写入`sys.stdout`和`sys.stderr`的输出，而不尝试捕获系统级文件描述符。'
- en: Usually, you don't need to change this, but in a few corner cases, depending
    on what your code is doing, changing the capture method might be useful.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您不需要更改这个，但在一些特殊情况下，根据您的代码正在执行的操作，更改捕获方法可能会有用。
- en: For completeness, there's also `--capture=no`, which is the same as `-s`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，还有`--capture=no`，它与`-s`相同。
- en: 'Traceback modes and locals: --tb, --showlocals'
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回溯模式和本地变量：--tb，--showlocals
- en: 'Pytest will show a complete traceback of a failing test, as expected from a
    testing framework. However, by default, it doesn''t show the standard traceback
    that most Python programmers are used to; it shows a different traceback:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest将显示失败测试的完整回溯，这是测试框架所期望的。但是，默认情况下，它不会显示大多数Python程序员习惯的标准回溯；它显示了不同的回溯：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This traceback shows only a single line of code and file location for all frames
    in the traceback stack, except for the first and last one, where a portion of
    the code is shown as well (in bold).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这种回溯仅显示回溯堆栈中所有帧的单行代码和文件位置，除了第一个和最后一个，其中还显示了一部分代码（加粗）。
- en: While some might find it strange at first, once you get used to it you realize
    that it makes spotting the cause of the error much simpler. By looking at the
    surrounding code of the start and end of the traceback, you can usually understand
    the error better. I suggest that you try to get used to the default traceback
    provided by pytest for a few weeks; I'm sure you will love it and never look back.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始有些人可能会觉得奇怪，但一旦你习惯了，你就会意识到它使查找错误原因变得更简单。通过查看回溯的起始和结束周围的代码，通常可以更好地理解错误。我建议您尝试在几周内习惯pytest提供的默认回溯；我相信您会喜欢它，永远不会回头。
- en: If you don't like pytest's default traceback, however, there are other traceback
    modes, which are controlled by the `--tb` flag. The default is `--tb=auto` and
    was shown previously. Let's have a look at an overview of the other modes in the
    next sections.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您不喜欢pytest的默认回溯，还有其他回溯模式，由`--tb`标志控制。默认值是`--tb=auto`，如前所示。让我们在下一节概览其他模式。
- en: --tb=long
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: --tb=long
- en: 'This mode will show a **portion of the code for** **all** **frames** of failure
    tracebacks, making it quite verbose:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式将显示失败回溯的**所有帧**的**代码部分**，使其相当冗长。
- en: '[PRE58]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: --tb=short
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: --tb=short
- en: 'This mode will show a single line of code from all the frames of the failure
    traceback, providing short and concise output:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式将显示失败回溯的所有帧的代码的一行，提供简短而简洁的输出：
- en: '[PRE59]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: --tb=native
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: --tb=native
- en: 'This mode will output the exact same traceback normally used by Python to report
    exceptions and is loved by purists:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式通常会输出Python用于报告异常的完全相同的回溯，受到纯粹主义者的喜爱：
- en: '[PRE60]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: --tb=line
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: --tb=line
- en: 'This mode will output a single line per failing test, showing only the exception
    message and the file location of the error:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式将为每个失败的测试显示一行，仅显示异常消息和错误的文件位置：
- en: '[PRE61]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This mode might be useful if you are doing a massive refactoring and except
    a ton of failures anyway, planning to enter **refactoring-heaven mode** with the `--lf
    -x` flags afterwards.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在进行大规模重构并且预计会有大量失败，之后打算使用`--lf -x`标志进入**重构天堂模式**，则此模式可能会有用。
- en: --tb=no
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: --tb=no
- en: 'This does not show any traceback or failure message at all, making it also
    useful to run the suite first to get a glimpse of how many failures there are,
    so that you can start using `--lf -x` flags to fix tests step-wise:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会显示任何回溯或失败消息，因此在运行套件以获取有多少失败的概念后，也可以使用`--lf -x`标志逐步修复测试：
- en: '[PRE62]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: --showlocals (-l)
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: --showlocals（-l）
- en: Finally, while this is not a traceback mode flag specifically, `--showlocals`
    (or `-l` as shortcut) augments the traceback modes by showing a list of the **local
    variables and their values** when using `--tb=auto`, `--tb=long`, and `--tb=short`
    modes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，虽然这不是一个特定的回溯模式标志，`--showlocals`（或`-l`作为快捷方式）通过显示在使用`--tb=auto`、`--tb=long`和`--tb=short`模式时的**本地变量及其值**列表来增强回溯模式。
- en: 'For example, here''s the output of `--tb=auto` and `--showlocals`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是`--tb=auto`和`--showlocals`的输出：
- en: '[PRE63]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Notice how this makes it much easier to see where the bad data is coming from:
    the `''3rd Grid,24,null''` string that is being read from a file at the start
    of the test.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这样做会更容易看出坏数据来自哪里：在测试开始时从文件中读取的`'3rd Grid,24,null'`字符串。
- en: '`--showlocals` is extremely useful both when running your tests locally and
    in CI, being a firm favorite. Be careful, though, as this might be a security
    risk: local variables might expose passwords and other sensitive information,
    so make sure to transfer tracebacks using secure connections and be careful to
    make them public.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`--showlocals`在本地运行测试和CI时都非常有用，深受喜爱。不过要小心，因为这可能存在安全风险：本地变量可能会暴露密码和其他敏感信息，因此请确保使用安全连接传输回溯，并小心使其公开。'
- en: Slow tests with --durations
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用--durations进行缓慢测试
- en: At the start of a project,  your test suite is usually blazingly fast, running
    in a few seconds, and life is good. But as projects grow in size, so do their
    test suites, both in the number of tests and the time it takes for them to run.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目开始时，您的测试套件通常运行非常快，只需几秒钟，生活很美好。但随着项目规模的增长，测试套件的测试数量和运行时间也在增加。
- en: 'Having a slow test suite affects productivity, especially if you follow TDD
    and run tests all the time. For this reason, it is healthy to periodically take
    a look at your longest running tests and perhaps analyze whether they can be made
    faster: perhaps you are using a large dataset in a place where a much smaller
    (and faster) dataset would do, or you might be executing redundant steps that
    are not important for the actual test being done.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件运行缓慢会影响生产力，特别是如果您遵循TDD并且一直运行测试。因此，定期查看运行时间最长的测试并分析它们是否可以更快是很有益的：也许您在一个需要更小（更快）数据集的地方使用了大型数据集，或者您可能正在执行不重要的冗余步骤，这些步骤对于实际进行的测试并不重要。
- en: 'When that happens, you will love the `--durations=N` flag. This flag provides
    a summary of the `N` longest running tests, or uses zero to see a summary of all
    tests:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生这种情况时，您会喜欢`--durations=N`标志。此标志提供了`N`个运行时间最长的测试的摘要，或者使用零来查看所有测试的摘要：
- en: '[PRE64]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This output provides invaluable information when you start hunting for tests
    to speed up.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始寻找测试以加快速度时，此输出提供了宝贵的信息。
- en: Although this flag is not something that you will use daily, because it seems
    that many people don't know about it, it is worth mentioning.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个标志不是您每天都会使用的东西，因为许多人似乎不知道它，但它值得一提。
- en: 'Extra test summary: -ra'
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的测试摘要：-ra
- en: 'Pytest shows rich traceback information on failing tests. The extra information
    is great, but the actual footer is not very helpful in identifying which tests
    have actually failed:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest 在测试失败时显示丰富的回溯信息。额外的信息很棒，但实际的页脚对于识别哪些测试实际上失败了并不是很有帮助：
- en: '[PRE65]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `-ra` flag can be passed to produce a nice summary with the full name of
    all failing tests at the end of the session:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 可以传递 `-ra` 标志以生成一个漂亮的摘要，在会话结束时列出所有失败测试的完整名称：
- en: '[PRE66]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This flag is particularly useful when running the suite from the command line
    directly, because scrolling the terminal to find out which tests failed can be
    annoying.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当直接从命令行运行套件时，此标志特别有用，因为在终端上滚动以查找失败的测试可能很烦人。
- en: 'The flag is actually `-r`, which accepts a number of single-character arguments:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上标志是 `-r`，它接受一些单字符参数：
- en: '`f` (failed): `assert` failed'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f`（失败）：`assert` 失败'
- en: '`e` (error): raised an unexpected exception'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e`（错误）：引发了意外的异常'
- en: '`s` (skipped): skipped (we will get to this in the next chapter)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`（跳过）：跳过（我们将在下一章中介绍）'
- en: '`x` (xfailed): expected to fail, did fail (we will get to this in the next
    chapter)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`（预期失败）：预期失败，确实失败（我们将在下一章中介绍）'
- en: '`X` (xpassed): expected to fail, but passed (!) (we will get to this in the
    next chapter)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X`（预期通过）：预期失败，但通过了（！）（我们将在下一章中介绍）'
- en: '`p` (passed): test passed'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p`（通过）：测试通过'
- en: '`P` (passed with output): displays captured output even for passing tests (careful –
    this usually produces a lot of output)'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P`（带输出的通过）：即使是通过的测试也显示捕获的输出（小心 - 这通常会产生大量输出）'
- en: '`a`: shows all the above, except for `P`; this is the **default** and is usually
    the most useful.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`：显示上述所有内容，但不包括 `P`；这是**默认**的，并且通常是最有用的。'
- en: The flag can receive any combination of the above. So, for example, if you are
    interested in failures and errors only, you can pass `-rfe` to pytest.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 该标志可以接收上述任何组合。因此，例如，如果您只对失败和错误感兴趣，可以向 pytest 传递 `-rfe`。
- en: In general, I recommend sticking with `-ra`, without thinking too much about
    it and you will obtain the most benefits.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我建议坚持使用 `-ra`，不要想太多，您将获得最多的好处。
- en: 'Configuration: pytest.ini'
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置：pytest.ini
- en: Users can customize some pytest behavior using a configuration file called `pytest.ini`.
    This file is usually placed at the root of the repository and contains a number
    of configuration values that are applied to all test runs for that project. It
    is meant to be kept under version control and committed with the rest of the code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以使用名为 `pytest.ini` 的配置文件自定义一些 pytest 行为。该文件通常放置在存储库的根目录，并包含一些应用于该项目的所有测试运行的配置值。它旨在保持在版本控制下，并与其余代码一起提交。
- en: The format follows a simple ini-style format with all pytest-related options
    under a `[pytest]` section. For more details, go to:[https://docs.python.org/3/library/configparser.html](https://docs.python.org/3/library/configparser.html).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 格式遵循简单的 ini 样式格式，所有与 pytest 相关的选项都在`[pytest]` 部分下。有关更多详细信息，请访问：[https://docs.python.org/3/library/configparser.html](https://docs.python.org/3/library/configparser.html)。
- en: '[PRE67]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The location of this file also defines what pytest calls the **root directory**
    (`rootdir`): if present, the directory that contains the configuration file is
    considered the root directory.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件的位置还定义了 pytest 称之为**根目录**（`rootdir`）的内容：如果存在，包含配置文件的目录被视为根目录。
- en: 'The root directory is used for the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 根目录用于以下内容：
- en: To create the tests node IDs
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建测试节点 ID
- en: As a stable location to store information about the project (by pytest plugins
    and features)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为存储有关项目信息的稳定位置（由 pytest 插件和功能）
- en: Without the configuration file, the root directory will depend on which directory
    you execute pytest from and which arguments are passed (the description of the
    algorithm can be found here: [https://docs.pytest.org/en/latest/customize.html#finding-the-rootdir](https://docs.pytest.org/en/latest/customize.html#finding-the-rootdir)).
    For this reason, it is always recommended to have a `pytest.ini` file in all but
    the simplest projects, even if empty.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 没有配置文件，根目录将取决于您从哪个目录执行 pytest 以及传递了哪些参数（算法的描述可以在这里找到：[https://docs.pytest.org/en/latest/customize.html#finding-the-rootdir](https://docs.pytest.org/en/latest/customize.html#finding-the-rootdir)）。因此，即使是最简单的项目，也始终建议在其中有一个
    `pytest.ini` 文件，即使是空的。
- en: Always define a `pytest.ini` file, even if empty.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 始终定义一个 `pytest.ini` 文件，即使是空的。
- en: 'If you are using `tox`, you can put a `[pytest]` section in the traditional
    `tox.ini` file and it will work just as well. For more details, go to: [https://tox.readthedocs.io/en/latest/](https://tox.readthedocs.io/en/latest/):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 `tox`，可以在传统的 `tox.ini` 文件中放置一个 `[pytest]` 部分，它将同样有效。有关更多详细信息，请访问：[https://tox.readthedocs.io/en/latest/](https://tox.readthedocs.io/en/latest/)：
- en: '[PRE68]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is useful to avoid cluttering your repository root with too many files,
    but it is really a matter of preference.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于避免在存储库根目录中放置太多文件很有用，但这实际上是一种偏好。
- en: Now, we will take a look at more common configuration options. More options
    will be introduced in the coming chapters as we cover new features.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看一下更常见的配置选项。随着我们介绍新功能，将在接下来的章节中介绍更多选项。
- en: 'Additional command-line: addopts'
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加命令行：addopts
- en: We learned some very useful command-line options. Some of them might become
    personal favorites, but having to type them all the time would be annoying.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了一些非常有用的命令行选项。其中一些可能会成为个人喜爱，但是不得不一直输入它们会很烦人。
- en: 'The `addopts` configuration option can be used instead to always add a set
    of options to the command line:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`addopts` 配置选项可以用来始终向命令行添加一组选项：'
- en: '[PRE69]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'With that configuration, typing the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，输入以下内容：
- en: '[PRE70]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Is the same as typing:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 与输入以下内容相同：
- en: '[PRE71]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note that, despite its name, `addopts` actually inserts the options **before**
    other options typed in the command line. This makes it possible to override most
    options in `addopts` when passing them in explicitly.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管它的名字是`addopts`，但实际上它是在命令行中输入其他选项之前插入选项。这使得在`addopts`中覆盖大多数选项成为可能，当显式传递它们时。
- en: 'For example, the following code will now display **auto **tracebacks, instead
    of native ones, as configured in `pytest.ini`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码现在将显示**自动**的回溯，而不是原生的回溯，如在`pytest.ini`中配置的那样：
- en: '[PRE72]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Customizing a collection
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义收集
- en: 'By default, pytest collects tests using this heuristic:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，pytest使用以下启发式方法收集测试：
- en: Files that match `test_*.py` and `*_test.py`
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配`test_*.py`和`*_test.py`的文件
- en: Inside test modules, functions that match `test*` and classes that match `Test*`
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试模块内部，匹配`test*`的函数和匹配`Test*`的类
- en: Inside test classes, methods that match `test*`
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试类内部，匹配`test*`的方法
- en: 'This convention is simple to understand and works for most projects, but they
    can be overwritten by these configuration options:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约定很容易理解，适用于大多数项目，但可以被这些配置选项覆盖：
- en: '`python_files`: a list of patterns to use to collect test modules'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python_files`：用于收集测试模块的模式列表'
- en: '`python_functions`: a list of patterns to use to collect test functions and
    test methods'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python_functions`：用于收集测试函数和测试方法的模式列表'
- en: '`python_classes`: a list of patterns to use to collect test classes'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`python_classes`：用于收集测试类的模式列表'
- en: 'Here''s an example of a configuration file changing the defaults:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更改默认设置的配置文件示例：
- en: '[PRE73]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The recommendation is to only use these configuration options for legacy projects
    that follow a different convention, and stick with the defaults for new projects.
    Using the defaults is less work and avoids confusing other collaborators.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 建议只在遵循不同约定的传统项目中使用这些配置选项，并对新项目使用默认设置。使用默认设置更少工作，避免混淆其他合作者。
- en: 'Cache directory: cache_dir'
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存目录：cache_dir
- en: The `--lf` and `--ff` options shown previously are provided by an internal plugin
    named `cacheprovider`, which saves data on a directory on disk so it can be accessed
    in future sessions. This directory by default is located in the **root directory** under
    the name `.pytest_cache`. This directory should never be committed to version
    control.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`--lf`和`--ff`选项之前显示的是由一个名为`cacheprovider`的内部插件提供的，它将数据保存在磁盘上的一个目录中，以便在将来的会话中访问。默认情况下，该目录位于**根目录**下，名称为`.pytest_cache`。这个目录不应该提交到版本控制中。'
- en: 'If you would like to change the location of that directory, you can use the
    `cache_dir` option. This option also expands environment variables automatically:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要更改该目录的位置，可以使用`cache_dir`选项。该选项还会自动扩展环境变量：
- en: '[PRE74]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Avoid recursing into directories: norecursedirs'
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免递归进入目录：norecursedirs
- en: 'pytest by default will recurse over all subdirectories of the arguments given
    on the command line. This might make test collection take more time than desired
    when recursing into directories that never contain any tests, for example:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: pytest默认会递归遍历命令行给定的所有子目录。当递归进入从不包含任何测试的目录时，这可能会使测试收集花费比预期更多的时间，例如：
- en: virtualenvs
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟环境
- en: Build artifacts
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建产物
- en: Documentation
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档
- en: Version control directories
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制目录
- en: pytest by default tries to be smart and will not recurse inside folders with
    the patterns `.*`, `build`, `dist`, `CVS`, `_darcs`, `{arch}`, `*.egg`, `venv`.
    It also tries to detect virtualenvs automatically by looking at known locations
    for activation scripts.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: pytest默认会聪明地不会递归进入具有模式`.*`、`build`、`dist`、`CVS`、`_darcs`、`{arch}`、`*.egg`、`venv`的文件夹。它还会尝试通过查看已知位置的激活脚本来自动检测virtualenvs。
- en: 'The `norecursedirs` option can be used to override the default list of pattern
    names that pytest should never recurse into:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`norecursedirs`选项可用于覆盖pytest不应该递归进入的默认模式名称列表：'
- en: '[PRE75]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You can also use the `--collect-in-virtualenv` flag to skip the `virtualenv`
    detection.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`--collect-in-virtualenv`标志来跳过`virtualenv`检测。
- en: In general, users have little need to override the defaults, but if you find
    yourself adding the same directory over and over again in your projects, consider
    opening an issue. For more details ([https://github.com/pytest-dev/pytest/issues/new](https://github.com/pytest-dev/pytest/issues/new)).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，用户很少需要覆盖默认设置，但如果发现自己在项目中一遍又一遍地添加相同的目录，请考虑提交一个问题。更多细节（[https://github.com/pytest-dev/pytest/issues/new](https://github.com/pytest-dev/pytest/issues/new)）。
- en: 'Pick the right place by default: testpaths'
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认情况下选择正确的位置：testpaths
- en: 'As discussed previously, a common directory structure is *out-of-source layout*,
    with tests separated from the application/library code in a `tests` or similarly
    named directory. In that layout it is useful to use the `testpaths` configuration
    option:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，常见的目录结构是*源代码之外的布局*，测试与应用程序/库代码分开存放在一个名为`tests`或类似命名的目录中。在这种布局中，使用`testpaths`配置选项非常有用：
- en: '[PRE76]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This will tell pytest where to look for tests when no files, directories, or
    node ids are given in the command line, which might speed up test collection.
    Note that you can configure more than one directory, separated by spaces.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉pytest在命令行中没有给定文件、目录或节点ID时在哪里查找测试，这可能会加快测试收集的速度。请注意，您可以配置多个目录，用空格分隔。
- en: Override options with -o/--override
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用-o/--override覆盖选项
- en: 'Finally, a little known feature is that you can override any configuration
    option directly in the command-line using the `-o` /`--override` flags. This flag
    can be passed multiple times to override more than one option:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个鲜为人知的功能是，您可以使用`-o`/`--override`标志直接在命令行中覆盖任何配置选项。这个标志可以多次传递，以覆盖多个选项：
- en: '[PRE77]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered how to use `virtualenv` and `pip` to install pytest.
    After that, we jumped into how to write tests, and the different ways to run them
    so that we can execute just the tests we are interested in. We had an overview
    of how pytest can provide rich output information for failing tests for different
    built-in data types. We learned how to use `pytest.raises` and `pytest.warns`
    to check exceptions and warnings, and `pytest.approx` to avoid common pitfalls
    when comparing floating point numbers. Then, we briefly discussed how to organize
    test files and modules in your projects. We also took a look at some of the more
    useful command-line options so that we can get productive right away. Finally,
    we covered how `pytest.ini` files are used for persistent command-line options
    and other configuration.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何使用`virtualenv`和`pip`来安装pytest。之后，我们深入讨论了如何编写测试，以及运行测试的不同方式，以便只执行我们感兴趣的测试。我们概述了pytest如何为不同的内置数据类型提供丰富的输出信息，以便查看失败的测试。我们学会了如何使用`pytest.raises`和`pytest.warns`来检查异常和警告，以及使用`pytest.approx`来避免比较浮点数时的常见问题。然后，我们简要讨论了如何在项目中组织测试文件和模块。我们还看了一些更有用的命令行选项，以便我们可以立即提高工作效率。最后，我们介绍了`pytest.ini`文件如何用于持久的命令行选项和其他配置。
- en: In the next chapter, we will learn how to use marks to help us skip tests on
    certain platforms, how to let our test suite know when a bug is fixed in our code
    or in external libraries, and how to group sets of tests so that we can execute
    them selectively in the command line. After that, we will learn how to apply the
    same checks to different sets of data to avoid copying and pasting testing code.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用标记来帮助我们在特定平台上跳过测试，如何让我们的测试套件知道代码或外部库中的错误已经修复，以及如何分组测试集，以便我们可以在命令行中有选择地执行它们。之后，我们将学习如何对不同的数据集应用相同的检查，以避免复制和粘贴测试代码。
