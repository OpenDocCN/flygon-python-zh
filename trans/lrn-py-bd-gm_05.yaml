- en: Learning About Curses by Building a Snake Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过构建贪吃蛇游戏来了解curses
- en: Whenever any developer writes games or applications, it is likely that they
    need to reuse some parts of the code repeatedly. For example, when we want a player
    to move within the game console, they use the left and right arrow keys multiple
    times. Thus, we need the code that can handle such events and process them. Writing
    the same code multiple times to handle the same action does not support **don't
    repeat yourself** (**DRY**) principles, so we need to use functions that can be
    called multiple times to perform the same action time and again.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每当开发人员编写游戏或应用程序时，他们可能需要重复使用代码的某些部分。例如，当我们希望玩家在游戏控制台内移动时，他们多次使用左右箭头键。因此，我们需要能够处理此类事件并对其进行处理的代码。多次编写相同的代码来处理相同的操作不支持**不要重复自己**（**DRY**）原则，因此我们需要使用可以多次调用以多次执行相同操作的函数。
- en: To facilitate this, these functions are bundled into containers known as modules.
    As you may recall from the preceding chapter, we have used modules in most of
    our programs. For example, by using the `random` module functions, we were able
    to get a random number between the specific range; math modules, on the other
    hand, allowed us to perform different mathematical computations. In this chapter,
    we are going to cover another module, known as curses. It will provide us with
    an interface where we can handle the curses library, which contains functions
    that directly interact with the Python terminal. This means we can make a simple
    Terminal-based game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，这些函数被捆绑到称为模块的容器中。正如您可能还记得上一章所述，我们在大多数程序中使用了模块。例如，通过使用`random`模块函数，我们能够在特定范围内获得随机数；另一方面，数学模块使我们能够执行不同的数学计算。在本章中，我们将介绍另一个模块，称为curses。它将为我们提供一个接口，我们可以在其中处理curses库，该库包含直接与Python终端交互的函数。这意味着我们可以制作一个简单的基于终端的游戏。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding curses
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解curses
- en: Starting the curses application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动curses应用程序
- en: User input with curses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用curses进行用户输入
- en: Making a Snake game with curses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用curses制作贪吃蛇游戏
- en: Game testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏测试
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will require the following to get the full benefit of this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要以下内容才能充分利用本章：
- en: '**Python** **IDLE** (**integrated development kit**)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python** **IDLE**（集成开发工具包）'
- en: The code assets for this book, which can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter05](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter05)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书的代码资产，可以在本书的GitHub存储库中找到：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter05](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter05)
- en: 'Check out the following video to see the code in action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：
- en: '[http://bit.ly/2oG1CVO](http://bit.ly/2oG1CVO)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2oG1CVO](http://bit.ly/2oG1CVO)'
- en: Understanding curses
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解curses
- en: Curses is a Terminal controller library that allows us to write text-based applications.
    The word Terminal is independent to any platform, and so curses can be used on
    any operating system. With curses, developers will be able to write applications
    directly without interacting with the Terminals. The curses library is the medium
    that sends the commands in the form of control characters while determining the
    operating system or Terminal it should be executed on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Curses是一个终端控制器库，允许我们编写基于文本的应用程序。术语“终端”与任何平台无关，因此curses可以在任何操作系统上使用。使用curses，开发人员将能够直接编写应用程序，而无需与终端交互。curses库是以控制字符的形式发送命令的媒介，同时确定应该在哪个操作系统或终端上执行。
- en: In Python, we have two libraries called windows-curses and unicurses. Both of
    these libraries provide the functions that can set up the desired look for the
    output Terminal screen. They are updated using control sequences. In short, developers
    will design the appearance of the output window screen and call the functions
    to make curses do its work. Thus, in curses-based applications, we won't get output
    that's a user-friendly as we expect it to be because we will be only able to write
    text-based applications with the curses library. Thus, any game you write with
    curses will run in the Terminal, that is, the command prompt of Windows or the
    Terminal of Linux.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们有两个名为windows-curses和unicurses的库。这两个库都提供了可以为输出终端屏幕设置所需外观的函数。它们使用控制序列进行更新。简而言之，开发人员将设计输出窗口屏幕的外观，并调用函数使curses发挥作用。因此，在基于curses的应用程序中，我们不会得到像我们期望的那样用户友好的输出，因为我们只能使用curses库编写基于文本的应用程序。因此，您使用curses编写的任何游戏都将在终端中运行，即Windows的命令提示符或Linux的终端。
- en: Python's *curses* library will allow us to write text-based user interfaces
    and control the screen with user inputs. The library that we are using in this
    chapter will help us control the screen movements and handle user events or inputs.
    The programs that will be built from curses will not have features that will resemble
    modern GUI applications or Android applications, which have widgets such as text
    view, label, slider, graphs, and templates. Instead, it will provide simple widgets
    and tools such as the **command-line interface** (**CLI**), most of which are
    found in text-only applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python的*curses*库将允许我们编写基于文本的用户界面，并通过用户输入控制屏幕。在本章中使用的库将帮助我们控制屏幕移动并处理用户事件或输入。从curses构建的程序将不具有类似于现代GUI应用程序或Android应用程序的功能，这些应用程序具有诸如文本视图、标签、滑块、图表和模板等小部件。相反，它将提供简单的小部件和工具，如**命令行界面**（**CLI**），其中大部分在仅文本应用程序中找到。
- en: The curses module of Python is an adaptation of the curses of the C-programming
    language. The only difference is using Python; everything can be done without
    us having deep knowledge of low-level routines. We can call the interfaces to
    invoke functions that will, in turn, call the curses to handle user operations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Python的curses模块是C编程语言的curses的一个适应。唯一的区别是使用Python；一切都可以在不需要我们深入了解低级例程的情况下完成。我们可以调用接口来调用函数，这些函数将依次调用curses来处理用户操作。
- en: While dealing with curses, the window screen is considered a character matrix.
    Each window interface is set up by the programmers, and includes height, width,
    and border. After setting such coordinates, the programmer will invoke Python
    curses to update that screen. Working with widgets such as the text view, button,
    and label is also done in the same manner; that is, we will initialize the coordinates
    where it should be placed in the window and call curses to update it accordingly.
    To handle user input from curses, we have to import it. We can easily import actions
    such as RIGHT, LEFT, UP, and DOWN and handle their behavior according to the program's
    needs. In most games, these events are going to provide movement to the game characters.
    The game we are going to cover at the end of this chapter will be the Snake game,
    and the snake itself will be our main character. This means that actions such
    as LEFT, RIGHT, UP, and DOWN will move the snake to a new position. The Windows
    version of Python does not have an inbuilt curses module and is not available
    with the same name. However, there's are two compatible modules available that
    do the same thing. These are called unicurses and windows-curses. We are going
    to use the latter in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理curses时，窗口屏幕被视为字符矩阵。每个窗口界面由程序员设置，并包括高度、宽度和边框。设置这样的坐标后，程序员将调用Python curses来更新该屏幕。使用诸如文本视图、按钮和标签之类的小部件也是以相同的方式进行的；也就是说，我们将初始化应在窗口中放置的坐标，并调用curses相应地更新它。要处理来自curses的用户输入，我们必须导入它。我们可以轻松地导入诸如RIGHT、LEFT、UP和DOWN等操作，并根据程序的需要处理它们的行为。在大多数游戏中，这些事件将为游戏角色提供移动。我们将在本章末尾介绍的游戏是贪吃蛇游戏，而蛇本身将是我们的主要角色。这意味着LEFT、RIGHT、UP和DOWN等操作将使蛇移动到新位置。Python的Windows版本没有内置的curses模块，也不以相同的名称提供。但是，有两个兼容的模块可用，它们执行相同的功能。这些称为unicurses和windows-curses。我们将在本章中使用后者。
- en: Let's start learning about curses by making a simple application. We will make
    a simple `hello` program that's printed in the curses Terminal.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过制作一个简单的应用程序来开始学习curses。我们将制作一个简单的`hello`程序，该程序将在curses终端中打印。
- en: Starting the curses application
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动curses应用程序
- en: We are going to build the application using a module that does not come pre-packaged
    with Python. Therefore, we have to install that package manually on our machine.
    With the installation of Python, a package management system should have been
    installed automatically on your machine known as pip. This management tool is
    used to install and organize the libraries that are written with Python. Thus,
    if you want to use any third-party libraries or dependencies on your program,
    you have to install them using the pip tool. The method to install any package
    is simple. You simply have to write the `pip install` command, followed by the
    name of the library you wish to install. The name of the library is case-sensitive,
    and so no mistakes should be made while writing the name of the library. If you
    want to check the code that is written inside the library, simply search for the
    documentation of that library. You will get information about the library, as
    well as the functions that are available to be used inside your programs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python中未预打包的模块构建应用程序。因此，我们必须在我们的机器上手动安装该软件包。安装Python时，应该已经自动在您的机器上安装了一个称为pip的软件包管理系统。此管理工具用于安装和组织用Python编写的库。因此，如果您想在程序中使用任何第三方库或依赖项，您必须使用pip工具进行安装。安装任何软件包的方法很简单。您只需编写`pip
    install`命令，后跟您希望安装的库的名称。库的名称区分大小写，因此在编写库的名称时不应出现错误。如果您想检查库中编写的代码，只需搜索该库的文档。您将获得有关该库的信息，以及可在程序中使用的函数。
- en: 'We are going to use the windows-curses library to write text-based programs,
    and so we have to install that package using the `pip` command. The pip command
    should be executed in the command prompt if your machine is Windows, and in the
    Terminal of your machine if you''re using Mac OS X or Linux. The following screenshot
    shows how we need to execute the `pip` command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用windows-curses库来编写基于文本的程序，因此我们必须使用`pip`命令安装该软件包。如果您的机器是Windows，则应在命令提示符中执行pip命令；如果您使用的是Mac
    OS X或Linux，则应在您的机器的终端中执行pip命令。以下屏幕截图显示了我们需要执行`pip`命令的方式：
- en: '![](Images/16064870-3492-408d-8aae-cd282362fb42.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/16064870-3492-408d-8aae-cd282362fb42.png)'
- en: 'Similarly, to install curses in your Linux machine, you can open your Terminal
    and run the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在Linux机器上安装curses，您可以打开终端并运行以下命令：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we will be able to write programs using the curses module. At this point,
    the curses module that we have installed will be available in the same way that
    other built-in modules such as math or random and available. Similar to built-in
    modules, we can simply import the curses module and start invoking the functions
    that are defined within it. The following steps explain the roadmap for creating
    any curses applications:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将能够使用curses模块编写程序。此时，我们安装的curses模块将以与其他内置模块（如math或random）相同的方式可用。与内置模块类似，我们可以简单地导入curses模块并开始调用其中定义的函数。以下步骤解释了创建任何curses应用程序的路线图：
- en: 'Let''s start by importing curses and seeing if it was installed properly or
    not. The command we use to import any module is `import` followed by the module''s
    name. Our module name is curses. Thus, the command would be as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先导入curses并查看它是否已正确安装。我们用于导入任何模块的命令是`import`后跟模块的名称。我们的模块名称是curses。因此，命令将如下所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can conclude that it is imported successfully as the Python parser hasn''t
    thrown an error. Now, we can use this module to write programs. Let''s write a
    simple program to observe the working procedure of the curses module:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以得出结论，它已成功导入，因为Python解析器没有抛出错误。现在，我们可以使用这个模块来编写程序。让我们编写一个简单的程序来观察curses模块的工作过程：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We cannot run any curses applications directly from Python IDLE. To run it,
    you have to navigate to the folder where you have stored the Python file and double-click
    on that file to open it. You will get a blank screen with a cursor at the top,
    which will remain there for 10 seconds. After 10 seconds, the same blank window
    screen will pop out from the screen. That screen will yield the text-based application
    that can be written with curses.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能直接从Python IDLE运行任何curses应用程序。要运行它，你必须导航到存储Python文件的文件夹，并双击该文件以打开它。你会得到一个空白屏幕，顶部有一个光标，它将在那里停留10秒。10秒后，同样的空白窗口屏幕将从屏幕上弹出。该屏幕将产生可以用curses编写的基于文本的应用程序。
- en: 'Let''s look at our preceding code and uncover the interesting functions of
    curses:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们之前的代码，并揭示curses的有趣函数：
- en: 'First of all, as always, we imported the module that we wanted to use in our
    program. We imported two modules here: curses and time. The curses module has
    different functions available for us which can be used to write text-based applications,
    while the time module has different functions available that can be used to update
    our output screen behavior. In this program, we called the `sleep` method of the
    `time` module, which will hold the output of the screen for the amount of time
    that was passed within its parenthesis (10 seconds, in our case). After 10 seconds,
    our output screen will disappear.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，像往常一样，我们导入了我们想要在程序中使用的模块。我们在这里导入了两个模块：curses和time。curses模块为我们提供了不同的可用函数，可以用来编写基于文本的应用程序，而time模块为我们提供了不同的可用函数，可以用来更新我们的输出屏幕行为。在这个程序中，我们调用了`time`模块的`sleep`方法，它将保持屏幕的输出，持续的时间是括号内传递的时间（在我们的例子中是10秒）。10秒后，我们的输出屏幕将消失。
- en: Before writing any code with curses, it should be initialized. The invocation
    of the `initscr()` function is going to initialize curses. Thus, for any curses
    application, we should initialize curses at the first line of the code. This initialization
    code is going to return us a window object that represents the output screen of
    our program. Here, this initialization is captured by the window object named
    `window_screen`, which represents the screen of our output Terminal. Thus, any
    function call to the curses API should be done with `window_screen`. The first
    invocation is done with the `clear()` function.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用curses编写任何代码之前，它应该被初始化。调用`initscr()`函数将初始化curses。因此，对于任何curses应用程序，我们应该在代码的第一行初始化curses。这个初始化代码将返回一个窗口对象，代表我们程序的输出屏幕。在这里，这个初始化被窗口对象`window_screen`捕获，它代表了我们输出终端的屏幕。因此，对curses
    API的任何函数调用都应该使用`window_screen`。第一个调用是使用`clear()`函数。
- en: We successfully created a game screen and held it with a method call. However,
    the current screen is not modifiable enough. We, as programmers, may want to customize
    the screen by specifying the height and width explicitly. Fortunately, Python's
    curses module provides another method to accomplish this, that is, the `newwin`
    method. We will learn about it in the next section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们成功创建了一个游戏屏幕，并用一个方法调用来保持它。然而，当前屏幕的可修改性还不够。作为程序员，我们可能希望通过明确指定高度和宽度来定制屏幕。幸运的是，Python的curses模块提供了另一种方法来实现这一点，即`newwin`方法。我们将在下一节中学习它。
- en: New screen and window objects
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新屏幕和窗口对象
- en: The window object that's returned from the invocation of the `initscr()` function
    represents the entire screen of the output window. This window object also supports
    different methods that can display text to the window, alter it, take events from
    the user and update positions, and so on. The only demerit with this `initscr()`
    function is that we cannot a pass custom height or width of the screen to it.
    It only represents the default whole screen of the output Terminal.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从`initscr()`函数的调用返回的窗口对象代表了输出窗口的整个屏幕。这个窗口对象还支持不同的方法，可以向窗口显示文本，修改它，接受用户的事件和更新位置等。这个`initscr()`函数的唯一缺点是我们不能将屏幕的自定义高度或宽度传递给它。它只代表了输出终端的默认整个屏幕。
- en: 'Sometimes, we might want the screen of the game to be customized so that it
    has a height of 20 and a width of 60, for example. Here, height and width can
    be considered as column and row, where each unit represents a line within that
    matrix. Since we have passed a width of 60, there will be 60 horizontal lines.
    The same goes for our height of 20; there will be 20 vertical lines. You can represent
    them as pixels too. To create a new screen, which is probably what we are going
    to do while making a curses application since the `initscr()` function isn''t
    going to do this for us, we have to call the new function. This function is going
    to divide the bigger window screen into a new one based on the coordinates specified.
    The name of this function is `newwin()`, which literally means new window, and
    it takes four arguments, that is, **Height**, **Width**, **Y**, and **X.** The
    order these are passed in is **Y**, **X** which is unusual compared to other libraries.
    The **Y** value is for the column''s position while the **X** value is for the
    row''s position. Take a look at the following diagram, which explains the values
    of **Y** and **X**:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能希望游戏屏幕被定制，使其高度为20，宽度为60，例如。在这里，高度和宽度可以被视为列和行，其中每个单位代表矩阵中的一行。由于我们传递了宽度为60，将会有60条水平线。高度为20也是一样的；将会有20条垂直线。你也可以将它们表示为像素。要创建一个新的屏幕，这可能是我们在制作curses应用程序时要做的事情，因为`initscr()`函数不会为我们做这个，我们必须调用新函数。这个函数将根据指定的坐标将更大的窗口屏幕分成一个新的窗口。这个函数的名称是`newwin()`，字面意思是新窗口，它接受四个参数，即**高度**，**宽度**，**Y**和**X**。它们的传递顺序是**Y**，**X**，这与其他库相比是不寻常的。**Y**值是列的位置，而**X**值是行的位置。看一下下面的图表，它解释了**Y**和**X**的值：
- en: '![](Images/1df0dbbc-8aca-4b5e-93bc-0e9e14718431.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1df0dbbc-8aca-4b5e-93bc-0e9e14718431.png)'
- en: Thus, by increasing the value of **Y**, we are going downward, which is the
    same as the column in a matrix. Similarly, by increasing the value of **X**, we
    are toward the right-hand side of the screen, which is the same as the row in
    a matrix. As we can see, curses stores a window screen in the form of the character
    matrix. We can use those coordinates to represent the position of the game's display,
    as well as the game characters. For example, if you want to make your player move
    in the position of (5,0), as shown in the preceding diagram, you would call the
    `move(5,0)` function to achieve that. Remember the order in which the argument
    is passed. The value of **Y** is followed by **X**, which may confuse you if you
    have a background in game programming from any other library.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过增加**Y**的值，我们向下移动，这与矩阵中的列相同。同样，通过增加**X**的值，我们向屏幕的右侧移动，这与矩阵中的行相同。正如我们所看到的，curses以字符矩阵的形式存储窗口屏幕。我们可以使用这些坐标来表示游戏显示的位置，以及游戏角色。例如，如果您想让您的玩家在(5,0)的位置移动，就像前面的图表中所示的那样，您将调用`move(5,0)`函数来实现。记住参数传递的顺序。**Y**的值后面是**X**，如果您在其他库中有游戏编程的背景，这可能会让您感到困惑。
- en: 'As an example, we are going to create a program where we will make a new screen
    inside a big screen using the `newwin()` function. The four arguments inside this
    function are `height`, `width`, `y`, and `x`. Remember this order as we have to
    pass it in a similar fashion:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将创建一个程序，在其中使用`newwin()`函数在大屏幕内创建一个新屏幕。此函数内的四个参数分别是`height`、`width`、`y`和`x`。记住这个顺序，因为我们必须以类似的方式传递它：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, it''s time to write a simple program that can add some text to our curses
    application:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候编写一个简单的程序，可以向我们的curses应用程序添加一些文本了：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s observe the preceding code line by line and learn about each of the
    methods we used, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行观察前面的代码，并了解我们使用的每个方法，如下所示：
- en: 'First of all, we imported the two important modules: curses and time. After
    that, we initialized the window object with the `initscr()` function. The `noecho()` function
    will turn off the automatic echoing process in our application. This is essential
    because while the user is playing the game, we don''t want them to show us what
    they pressed; instead, we want them to perform an action based on that event.
    The next function call is `cbreak()`. This mode will help our program react instantly
    to the user''s input. For example, in the case of the `input()` method of Python,
    until and unless we are going to press *Enter* on our keyboard, this method won''t
    perform any action. However, in the case of the `cbreak()` function, it is going
    to help the application react to any input keys instantly without the need for
    pressing *Enter*. This is important because we have to make a game where the user
    will get a response without any delay. For example, if the user presses the DOWN
    key, the character of the game must move in downward instantly. This is different
    to a buffered input function, which is going to take all the input and store it
    in a buffer that''s going to react only if the user presses *Enter*.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们导入了两个重要的模块：curses和time。之后，我们使用`initscr()`函数初始化了窗口对象。`noecho()`函数将关闭应用程序中的自动回显过程。这是必要的，因为当用户玩游戏时，我们不希望他们向我们展示他们按下了什么键；相反，我们希望他们根据该事件执行操作。下一个函数调用是`cbreak()`。这种模式将帮助我们的程序立即对用户的输入做出反应。例如，在Python的`input()`方法中，除非我们在键盘上按下*Enter*，否则此方法不会执行任何操作。然而，在`cbreak()`函数的情况下，它将帮助应用程序立即对任何输入键做出反应，而无需按*Enter*。这很重要，因为我们必须制作一个用户可以立即得到响应的游戏。例如，如果用户按下DOWN键，游戏角色必须立即向下移动。这与缓冲输入函数不同，后者将接收所有输入并将其存储在一个缓冲区中，只有在用户按下*Enter*时才会做出反应。
- en: The next function call is the `keypad()` function. We have enabled keypad mode
    by passing True as an argument. Whenever we press any key in the Terminal, it
    returns data in the form of a multibyte escape sequence. For example, `Esc` sends
    `\x1b`. That is 1 byte. `Page Up` sends `\x1b[H`. That is 3 bytes. To handle such
    data that is returned by the Terminal, curses uses a special value that can be
    imported manually. For example, to handle the DOWN key being pressed on the keyboard,
    we can import it as `curses.KEY_DOWN`. This is done by enabling keypad mode.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个函数调用是`keypad()`函数。我们通过传递True作为参数启用了键盘模式。每当我们在终端中按下任何键时，它都以多字节转义序列的形式返回数据。例如，`Esc`发送`\x1b`。这是1个字节。`Page
    Up`发送`\x1b[H`。这是3个字节。为了处理终端返回的这种数据，curses使用了一个可以手动导入的特殊值。例如，要处理键盘上按下的DOWN键，我们可以将其导入为`curses.KEY_DOWN`。这是通过启用键盘模式来实现的。
- en: After that, we called the `addstr()` function. This function will add a string
    to the output screen in the position specified during its call. We passed three
    arguments to it. Remember that the first two arguments are in the order y, x.
    The last argument that's passed is a string that needs to be added to the position
    of (y,x). We have passed a value of (0,0), which means the string will be added
    to the uppermost left corner of the output window. The next method that we called
    was `refresh()`, which is going to update the character matrix of the window object
    *screen*. If you take a look at the code carefully, you will see that whenever
    we are adding or refreshing the content of the screen, we are doing it using a
    window curses object, which was initialized using the `initscr()` function. However,
    the behavior of the Terminal has been altered by the curses module. For example,
    to change the default echoing behavior of the Terminal, we made a direct call
    to the `noecho()` function from the curses module instead of from the window cursor
    object.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们调用了`addstr()`函数。这个函数将在其调用期间指定的位置将一个字符串添加到输出屏幕上。我们向它传递了三个参数。记住，前两个参数的顺序是y，x。传递的最后一个参数是需要添加到(y,x)位置的字符串。我们传递了一个值为(0,0)，这意味着字符串将被添加到输出窗口的左上角。我们调用的下一个方法是`refresh()`，它将更新窗口对象*screen*的字符矩阵。如果你仔细看代码，你会发现每当我们添加或刷新屏幕的内容时，我们都是使用一个窗口curses对象来做的，这个对象是使用`initscr()`函数初始化的。然而，终端的行为已经被curses模块改变了。例如，为了改变终端的默认回显行为，我们直接从curses模块而不是从窗口光标对象中直接调用了`noecho()`函数。
- en: 'Now, let''s run our code to observe the result. Make sure you run your application
    from your Terminal or command prompt with `filename.py`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行我们的代码来观察结果。确保你从终端或命令提示符中运行你的应用程序，使用`filename.py`：
- en: '![](Images/f76bd343-3e09-41ef-8a3e-956e4c65c004.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f76bd343-3e09-41ef-8a3e-956e4c65c004.png)'
- en: You can change the position from (0,0) to any other value, for example, (5,5),
    to observe the windows and padding format.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将位置从(0,0)改变为任何其他值，比如(5,5)，来观察窗口和填充格式。
- en: Finally, we have made our first program with curses. Now, it's time to explore
    another feature of curses, which is based on the ability to handle user input.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们用curses制作了我们的第一个程序。现在，是时候探索curses的另一个特性了，这个特性是基于处理用户输入的能力。
- en: User input with curses
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用curses处理用户输入
- en: 'In any game, user input is one of the most crucial pieces of information that
    needs to be handled properly. We cannot make any delay while handling these types
    of actions. In the case of curses, we have two ways to take input from the user.
    These two methods are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何游戏中，用户输入是需要正确处理的最关键的信息之一。在处理这些类型的操作时，我们不能有任何延迟。在curses的情况下，我们有两种方法可以从用户那里获取输入。这两种方法如下：
- en: '`getch()`: If you have any programming background of languages such as C or
    C++, this should not be new to you. The `getch()` function, just like in C, is
    used to make a listener that will listen to the user key continuously. It returns
    an integer from 0 to 255 which represents the ASCII code of the key that was pressed.
    For example, the ASCII code for `a` is `097`. Values that are greater than 255
    are special keys, for example, the *Page Up* and navigation keys, that is, UP,
    DOWN, LEFT, and RIGHT. We can compare the values of such keys with constants stored
    in curses; for example, `curses.UP`, `curses.DOWN`, `curses.LEFT`, and `curses.RIGHT`.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getch()`: 如果你有C或C++等语言的编程背景，这对你来说应该不是什么新鲜事。`getch()`函数就像在C中一样，用于创建一个持续监听用户按键的监听器。它返回一个从0到255的整数，代表被按下的键的ASCII码。例如，`a`的ASCII码是`097`。大于255的值是特殊键，例如*Page
    Up*和导航键，即UP、DOWN、LEFT和RIGHT。我们可以将这些键的值与curses中存储的常量进行比较；例如，`curses.UP`、`curses.DOWN`、`curses.LEFT`和`curses.RIGHT`。'
- en: '`getkey()`: `getch` and `getkey` do the same thing, but the `getkey` function
    converts the returned integer into a string. Normal keys such as a-z or A-Z will
    be returned as a 1 character string that can be compared with the `ord()` function.
    However, special keys or functional keys will be returned as a longer string containing
    a key and representing the type of action, such as `KEY_UP`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getkey()`: `getch`和`getkey`做的是同样的事情，但是`getkey`函数会将返回的整数转换为字符串。诸如a-z或A-Z之类的普通键将作为一个包含一个字符的字符串返回，可以与`ord()`函数进行比较。然而，特殊键或功能键将作为一个更长的字符串返回，其中包含一个键并表示动作的类型，比如`KEY_UP`。'
- en: 'Let''s write a program that can handle keyboard events:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个可以处理键盘事件的程序：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We discussed this code when we talked about using a True loop. Make sure you
    revise the preceding topics if you are confused about any of these commands. One
    strange thing you might observe in this code is that we have imported curses and
    gave it an alias of c. This is the process of renaming your module. Now, instead
    of using `curses.method_name` at every method call, we can simply call it using `c.method_name()`,
    which certainly removes the overhead of writing the same module name every time.
    Inside the loop, we used the `getch()` function to take input from the user. After
    that, the character is retrieved in the `char` variable and we compare it with
    the returned value of the `ord` function. Remember that the `getch` function was
    going to return a value in Unicode? The same is done by the `ord` function. It
    takes an argument as a character and returns the Unicode value of that character.
    We use conditionals to make a condition. So, if the user presses *q* on their
    keyboard, we will end the program, and if the user presses *p* on their keyboard,
    we will print `Hello World` to the output window at the position of (y,x). Let''s
    run our Python file, `C:\User\Desktop> python program3.py`, and take a look at
    the output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论使用True循环时，我们讨论了这段代码。如果你对任何这些命令感到困惑，请确保复习前面的主题。你可能会观察到这段代码中的一个奇怪的地方是，我们导入了curses并给它起了一个别名c。这是重命名模块的过程。现在，我们可以在每个方法调用时使用`c.method_name()`，而不是在每次调用时使用`curses.method_name`，这当然消除了每次写相同模块名的开销。在循环内，我们使用`getch()`函数从用户那里获取输入。之后，字符被存储在`char`变量中，我们将其与`ord`函数的返回值进行比较。记住，`getch`函数将返回一个Unicode值？`ord`函数也是如此。它接受一个字符作为参数，并返回该字符的Unicode值。我们使用条件语句来进行条件判断。因此，如果用户在键盘上按下*q*，我们将结束程序，如果用户在键盘上按下*p*，我们将在输出窗口的位置(y,x)打印`Hello
    World`。让我们运行我们的Python文件，`C:\User\Desktop> python program3.py`，并查看输出：
- en: '![](Images/935843ba-c5f4-4c19-96c2-0b28b7fe7a6e.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/935843ba-c5f4-4c19-96c2-0b28b7fe7a6e.png)'
- en: Press *q* on your keyboard to terminate the loop and close the application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 按下键盘上的*q*键来终止循环并关闭应用程序。
- en: Note that *q* is not the same as *Q* because the ASCII code for these characters
    isn't the same.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*q*和*Q*不同，因为这些字符的ASCII码不同。
- en: Our code is running perfectly but is becoming lengthier, even though the application
    is so simple. We are calling so many methods already, such as `noecho()`, `cbreak()`,
    `keypad()`, and `endwin()`. To remove the overhead of calling so many functions,
    we can use the wrapper function from the curses module. All of these functions,
    including the initialization of curses objects, is done automatically by the wrapper
    function. Just remember that the wrapper function as a call to the bundle that
    wraps all of these methods inside of it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码运行得很好，但变得越来越长，尽管应用程序很简单。我们已经调用了很多方法，比如`noecho()`，`cbreak()`，`keypad()`和`endwin()`。为了消除调用这么多函数的开销，我们可以使用curses模块中的包装函数。所有这些函数，包括curses对象的初始化，都是由包装函数自动完成的。只需记住，包装函数是一个包含所有这些方法的捆绑调用。
- en: 'Similarly, we can also handle mouse events using the curses module. Let''s
    make a program using the wrapper function and handle the events of the mouse buttons
    in the same program:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以使用curses模块来处理鼠标事件。让我们使用包装函数编写一个程序，并在同一个程序中处理鼠标按钮的事件：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s take a look at the preceding code in detail:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看一下前面的代码：
- en: We will start from the last line, where we called the wrapper function with
    some callable object as an argument. We've already learned about the objectives
    of `wrapper()`; it eliminates multiple function calls such as `initscr()`, `noecho()`,
    and so on. Thus, debugging is easier using the wrapper function. Not only that,
    but this function also handles exceptions internally by using try and catch blocks.
    Whenever you run into an unknown exception that you might not have caught, you
    can always trust the wrapper function to do so. This will identify the bugs of
    your program and provide you with an exception message without crashing the application.
    The argument to the wrapper function will be a callable object, which, in this
    case, is the main function. This main function has a *screen* argument, which
    is the curses window object. We didn't initialize the curses object anywhere in
    the program with the `initscr()` function because this was done internally by
    the wrapper function.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从最后一行开始，我们在那里使用了可调用对象调用了包装函数。我们已经了解了`wrapper()`的目的；它消除了多个函数调用，比如`initscr()`，`noecho()`等等。因此，使用包装函数进行调试更容易。不仅如此，这个函数还通过try和catch块在内部处理异常。每当你遇到一个未知的异常，你可能没有捕获到，你总是可以信任包装函数来处理。这将识别程序的错误并提供异常消息，而不会使应用程序崩溃。包装函数的参数将是一个可调用对象，这里是主函数。这个主函数有一个*screen*参数，它是curses窗口对象。我们没有在程序的任何地方使用`initscr()`函数初始化curses对象，因为这是由包装函数在内部完成的。
- en: 'Inside the scope of the main function, we made a call to two methods: `curs_set(0)`,
    which is going to hide the cursor in the output screen, and `mousemask(1)`, which
    is going to accept the mouse events. Here, mouse events will be special symbols
    or functional characters that will be different from normal alphabetical characters.
    Thus, curses has made constants to address those functional characters. This is
    the same for the UP keyboard key; we have the `KEY_UP` constant; in the case of
    mouse events, we have the `KEY_MOUSE` constant. These should be invoked from the
    curses module, for example, `curses.KEY_MOUSE`. After we get such mouse events,
    we are going to print `Mouse is clicked` to the output Terminal. The `getch()`
    method is going to input any events that can be either mouse-related or keyboard
    buttons. Let''s run our program to achieve the following output:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主函数的范围内，我们调用了两个方法：`curs_set(0)`，它将隐藏输出屏幕上的光标，以及`mousemask(1)`，它将接受鼠标事件。在这里，鼠标事件将是特殊符号或功能字符，与正常的字母字符不同。因此，curses已经定义了常量来表示这些功能字符。这与UP键盘键相同；我们有`KEY_UP`常量；在鼠标事件的情况下，我们有`KEY_MOUSE`常量。这些应该从curses模块中调用，例如`curses.KEY_MOUSE`。在我们获得这样的鼠标事件之后，我们将在输出终端上打印`鼠标被点击`。`getch()`方法将输入任何可能是与鼠标相关或键盘按钮的事件。让我们运行程序以获得以下输出：
- en: '![](Images/29bbc122-b640-411f-a973-606a7ff98269.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/29bbc122-b640-411f-a973-606a7ff98269.png)'
- en: Now that we have gained enough knowledge to make games using curses, let's proceed
    to the next section, which will give us an idea about how gaming logic is made
    under the hood. We will be making a simple Snake game.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了足够的知识来使用curses制作游戏，让我们继续下一部分，这将让我们了解游戏逻辑是如何在底层实现的。我们将制作一个简单的贪吃蛇游戏。
- en: Making a snake game with curses
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用curses制作贪吃蛇游戏
- en: We already know that the process of writing games is not as easy as it seems.
    We have to follow many procedures to make a game playable because, while exposing
    the game to the environment, we can be overwhelmed by many unwanted and unexpected
    exceptions. Thus, following the proper order of execution is always essential,
    even if it may take more time than usual. In this section, we are going to create
    a Sake game using curses. We will be modifying it into a more appealing game in
    the upcoming chapters. A good game does not always mean a good user interface
    because the interface provides value to the user but not the programmer. We have
    to make a habit of writing proper code along with making good interfaces, which
    requires us to follow each of the steps we will go over in this section. We are
    going to use the curses module to make the initial Snake game. Then, in the next
    chapter, we will modify it using object-oriented programming.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道编写游戏的过程并不像看起来那么容易。我们必须遵循许多程序来使游戏可玩，因为在将游戏暴露给环境时，我们可能会被许多不需要的和意外的异常所淹没。因此，遵循正确的执行顺序总是至关重要的，即使可能比平常花费更多的时间。在本节中，我们将使用curses创建一个贪吃蛇游戏。在即将到来的章节中，我们将对其进行修改，使其成为一个更具吸引力的游戏。一个好的游戏并不总是意味着一个良好的用户界面，因为界面为用户提供价值，而不是程序员。我们必须养成编写良好代码并制作良好界面的习惯，这要求我们遵循本节中将要介绍的每一步。我们将使用curses模块来制作最初的贪吃蛇游戏。然后，在下一章中，我们将使用面向对象编程对其进行修改。
- en: Before we code, we have to gather information about the model and the interface
    of the game. While modeling, we have to extract critical information, such as *how
    to render the game characters into the screen*, *how to make an event listener*,
    and *how to make logic that will allow the game characters to move*. We will cover
    all of this in the next section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码之前，我们必须收集有关游戏模型和界面的信息。在建模过程中，我们必须提取关键信息，比如*如何将游戏字符渲染到屏幕上*，*如何制作事件监听器*，以及*如何制作允许游戏角色移动的逻辑*。我们将在下一部分中涵盖所有这些内容。
- en: Brainstorming and information gathering
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 头脑风暴和信息收集
- en: 'As we have been doing up until now, the first step is to brainstorm and gather
    critical information about the game layouts and game models. In the Snake game,
    we have two characters: the snake (the player) and its food. Whenever the snake
    eats food, its length should be increased. That''s the basic idea, anyway. Now,
    let''s revise the resources that are available to us. Obviously, the resources
    that are provided by Python are more abundant, but we haven''t learned how to
    make graphical characters and use them in our game yet. All we''ve learned to
    do is make games with text-based Terminals. We can use characters such as A-Z
    to specify game objects. For example, we can make the snake `XXXXXXX`, which is
    a combination of Xs. The food can be represented by `O`. Let''s see what this
    would look like in our game console:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们一直在做的那样，第一步是头脑风暴和收集关于游戏布局和游戏模型的关键信息。在贪吃蛇游戏中，我们有两个角色：蛇（玩家）和它的食物。每当蛇吃食物时，它的长度应该增加。这是基本的想法。现在，让我们复习一下我们可以使用的资源。显然，Python提供的资源更加丰富，但我们还没有学会如何制作图形字符并在游戏中使用它们。我们只学会了如何在基于文本的终端中制作游戏。我们可以使用A-Z等字符来指定游戏对象。例如，我们可以制作蛇`XXXXXXX`，这是X的组合。食物可以用`O`表示。让我们看看这在我们的游戏控制台中会是什么样子：
- en: '![](Images/a3df7678-7e01-4124-bec7-1a9f24c72335.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a3df7678-7e01-4124-bec7-1a9f24c72335.png)'
- en: We also have to decide on the screen for the game. The `initscr()` method is
    going to create the entire screen as a curses object. We don't want that; instead,
    we want to make a game screen that can be customized by the height, width, and
    y, x positions. As you may recall, we can divide the screen into a new one, using
    the `newwin()` method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须决定游戏的屏幕。`initscr()`方法将创建整个屏幕作为curses对象。我们不希望这样；相反，我们希望制作一个可以通过高度、宽度和y、x位置自定义的游戏屏幕。正如您可能记得的那样，我们可以使用`newwin()`方法将屏幕分成一个新的屏幕。
- en: The most important thing to remember is to track the coordinates because we
    have to make a boundary for our gameplay. We can make certain rules that specify
    the boundary position of the game character and, if they touch that boundary,
    we can terminate our game.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是要记住跟踪坐标，因为我们必须为我们的游戏玩法制作一个边界。我们可以制定一些规则，指定游戏角色的边界位置，如果它们触及该边界，我们可以终止我们的游戏。
- en: 'We have to make logic for two things:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为两件事制定逻辑：
- en: Whenever the snake eats the food, we have to generate new food in a new position.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当蛇吃食物时，我们必须在新位置生成新的食物。
- en: Whenever the snake eats the food, we have to increase the speed of the snake
    to make the game more difficult. We should also track collisions between the snake's
    head and its body.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当蛇吃食物时，我们必须增加蛇的速度，使游戏变得更加困难。我们还应该跟踪蛇头和蛇身之间的碰撞。
- en: In terms of the former point, we can use the random module, which provides a
    random coordinate position of (y, x) that we can assign food to. For the latter
    point, we have to use a curses method called timeout. We have to pass the value
    of the delay as an argument to that function. According to Python's official documentation,
    the timeout function sets blocking or non-blocking read behavior for the window.
    If *delay* is negative, a blocking read is used (which will wait indefinitely
    for the input). If *delay* is zero, then a non-blocking read is used, and -1 will
    be returned by `getch()` if no input is waiting. If *delay* is positive, then
    `getch()` will block for *delay* milliseconds and return -1 if there is still
    no input at the end of that time. Thus, we can change the speed of the game based
    on the delay when it is zero or positive.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一点方面，我们可以使用random模块，它提供了一个(y, x)的随机坐标位置，我们可以将食物分配给它。对于后一点，我们必须使用一个名为timeout的curses方法。我们必须将延迟的值作为参数传递给该函数。根据Python的官方文档，timeout函数为窗口设置阻塞或非阻塞读取行为。如果*延迟*为负数，则使用阻塞读取（将无限期地等待输入）。如果*延迟*为零，则使用非阻塞读取，如果没有输入等待，`getch()`将返回-1。如果*延迟*为正数，则`getch()`将阻塞*延迟*毫秒，并且如果在该时间结束时仍然没有输入，则返回-1。因此，我们可以根据延迟改变游戏的速度，当延迟为零或正数时。
- en: So, in terms of the `curses.timeout(delay)` command, if you make delay negative,
    your snake will move at a rapid pace. However, we need to remember that we have
    some constraints here; the speed of the snake should be increased, along with
    the length of the snake. First of all, what is a snake? How it is made in our
    game? We learned about lists in the previous chapter. Let's use that to make a
    snake. We have already seen the structure of our snake, which is a bunch of X
    characters. But at the beginning of the game, we should only provide a small length
    for the snake, maybe a length of 3, that is, `XXX`. We will store each of these
    X's in the list, which represents coordinates such as [[4,10], [4,9], [4,8]].
    Here, each of these lists represents one X, that is, at the position of [4,10],
    we will have one X and another X at 4,9\. Remember that these should be y, x positions
    and that they should be next to each other because they represent the body of
    the snake.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`curses.timeout(delay)`命令方面，如果您使延迟为负数，您的蛇将以快速的速度移动。然而，我们需要记住这里有一些约束；蛇的速度应该随着蛇的长度增加。首先，蛇是什么？在我们的游戏中是如何制作的？我们在上一章学习了列表。让我们用它来制作一个蛇。我们已经看到了我们的蛇的结构，它是一堆X字符。但在游戏开始时，我们应该为蛇提供一个较小的长度，也许是3的长度，即`XXX`。我们将把这些X中的每一个存储在列表中，它表示坐标，比如[[4,10]，[4,9]，[4,8]]。在这里，这些列表中的每一个代表一个X，也就是说，在[4,10]的位置，我们将有一个X，而在4,9的位置还有一个X。请记住，这些应该是y，x位置，并且它们应该相邻，因为它们代表蛇的身体。
- en: Let's say our delay is 100 which would be constant. Thus, our command to represent
    speed will be `curses.timeout(100)`, which will be the snake's constant speed
    throughout the game. However, we can change the speed of the game by incrementing
    the length of the snake. For now, let's proceed to the next section, where we
    will make a boundary for our game.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的延迟是100，这将是恒定的。因此，我们表示速度的命令将是`curses.timeout(100)`，这将是蛇在整个游戏中的恒定速度。然而，我们可以通过增加蛇的长度来改变游戏的速度。现在，让我们继续进行下一节，我们将为我们的游戏制作一个边界。
- en: Inception
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始。
- en: 'In this section, we will start writing the code for our game. We will use the
    curses module to do this. First, we will initialize the screen for the game and
    make some game characters. Take a look at the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始编写游戏的代码。我们将使用curses模块来实现这一点。首先，我们将初始化游戏屏幕并制作一些游戏角色。看一下以下代码：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There's nothing new in the preceding code. You can also eliminate all of the
    function calls using the `wrapper()` function. We can see that we have two list
    variables, `snake` and `food`, which contain the coordinates that represent their
    positions in our game console. We also made a call to the `addch` function. It
    will work in a similar fashion to the `addstr` function. We passed the position
    of the food and added the `O` character to that position.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中没有什么新的。您还可以使用`wrapper()`函数消除所有的函数调用。我们可以看到我们有两个列表变量，`snake`和`food`，它们包含代表它们在游戏控制台中位置的坐标。我们还调用了`addch`函数。它将以类似的方式工作`addstr`函数。我们传递了食物的位置并在该位置添加了`O`字符。
- en: 'Making computer games require two steps: the first step is to make a visual
    that must be naturally attractive, while the second step is to make the player
    interact with the game. To make games interactive, we have to handle the events
    provided by the player. This is what we will do in the next section.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 制作电脑游戏需要两个步骤：第一步是制作一个必须自然吸引人的视觉效果，而第二步是让玩家与游戏互动。为了使游戏具有互动性，我们必须处理玩家提供的事件。这就是我们将在下一节中做的事情。
- en: Handling user key events
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户按键事件
- en: 'We''ve started to build the basic layout of our game. Now, let''s write some
    code that can handle user keyboard events. Snake is a simple game. We can make
    it work by handling only four keys of the keyboard, that is, UP, DOWN, LEFT, and
    RIGHT. We can use `getch()` to get user input. But remember, these are not alphabetical
    characters, they are functional characters. Thus, we have to import constants
    such as `KEY_UP`, `KEY_DOWN`, `KEY_LEFT`, and `KEY_RIGHT` to fetch those ASCII
    values. Let''s start writing the code that will handle user events:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开始构建游戏的基本布局。现在，让我们编写一些代码来处理用户键盘事件。贪吃蛇是一个简单的游戏。我们可以通过处理键盘的四个键：上、下、左、右来使其工作。我们可以使用`getch()`来获取用户输入。但请记住，这些不是字母字符，它们是功能字符。因此，我们必须导入常量，如`KEY_UP`、`KEY_DOWN`、`KEY_LEFT`和`KEY_RIGHT`来获取这些ASCII值。让我们开始编写处理用户事件的代码：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code that we have written may seem complicated, but all of these things
    have been covered already. Let''s take a look at what we''ve done:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的代码可能看起来很复杂，但所有这些事情都已经涵盖过了。让我们看看我们做了什么：
- en: In the first statement, we made the default key `KEY_RIGHT`. This is important
    because we don't want to make the snake move if the user hasn't pressed a key.
    So, our snake character will move right automatically when the game is started.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个语句中，我们将默认键设置为`KEY_RIGHT`。这很重要，因为我们不希望在用户没有按键时使蛇移动。因此，当游戏开始时，我们的蛇角色将自动向右移动。
- en: After that, we made a game loop. This loop is going to be executed until we
    press *Esc* since the ASCII value for *Esc* is 27\. Inside the loop, we made a
    call to the timeout method, which will represent the speed of our snake character.
    In the next line, we get the event of the user using the `getch()` method. Remember
    that, if you press any key event, its value is going to be -1\. Thus, we can compare
    it and put the key that was pressed by the user into the key variable. However,
    the key can be anything, such as an alphabetical character or a special symbol
    such as [!,@,#,$], and so we have to filter them with the appropriate keys, for
    example, LEFT, RIGHT, UP, and DOWN. If the key that's pressed by the user is not
    among these, we are going to make the key have a default value of `KEY_RIGHT`.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们创建了一个游戏循环。这个循环将一直执行，直到我们按下*Esc*，因为*Esc*的ASCII值是27。在循环内部，我们调用了timeout方法，它将代表我们的贪吃蛇角色的速度。在下一行，我们使用`getch()`方法获取用户的事件。请记住，如果按下任何键事件，它的值将是-1。因此，我们可以进行比较，并将用户按下的键放入键变量中。然而，键可以是任何东西，比如字母字符或特殊符号，如[!,@,#,$]，因此我们必须用适当的键进行过滤，例如LEFT、RIGHT、UP和DOWN。如果用户按下的键不在其中，我们将使键具有默认值`KEY_RIGHT`。
- en: Now, we can communicate our program with input devices such as a keyboard or
    joystick. It's time to move on to the next section, where we will create our first
    logic to update the **head position** of the snake characters when the user presses
    the LEFT, RIGHT, UP, and DOWN keys.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的程序与键盘或操纵杆等输入设备进行通信。是时候进入下一部分了，在那里我们将创建我们的第一个逻辑，当用户按下左、右、上和下键时，更新蛇字符的**头部位置**。
- en: Game logic – updating the head position of the snake
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏逻辑-更新蛇头的位置
- en: 'In the previous section, we were able to handle user events using constants
    provided by curses. Just like movement, the head of the snake can also be changed.
    We have to make brand new logic that will update the position of the snake''s
    head. Our snake is a composition of coordinates that are stored in the list. The
    first element of that nested list is the position of the snake''s head. Thus,
    we only need to update the first element of the list. Let''s see how we are going
    to do this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们能够使用curses提供的常量来处理用户事件。就像移动一样，蛇的头部也可以改变。我们必须制定全新的逻辑来更新蛇头的位置。我们的蛇是存储在列表中的坐标的组合。嵌套列表的第一个元素是蛇头的位置。因此，我们只需要更新列表的第一个元素。让我们看看我们将如何做到这一点：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This may seem like it's a little difficult to understand, so let me make this
    clear.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点难以理解，所以让我澄清一下。
- en: 'The `snake` variable is a list. Thus, we can use the `insert()` method to manipulate
    that list element. The `insert()` method will take two arguments: one will be
    the index and the other will be the element to be inserted. In the preceding code,
    index is 0, which means we want to insert an element in the first element of the
    list, which represents the head of the snake. The next argument is the element,
    which needs to be added to index 0\. We can see a comma (`,`) in-between two statements:
    `snake[0][0] + (key == KEY_DOWN and 1) + (key == KEY_UP and -1)` and `snake[0][1]
    + (key == KEY_LEFT and -1) + (key == KEY_RIGHT and 1)`. The first statement represents
    the y coordinate of the snake''s head, while the second statements represents
    the x coordinate of the snake''s head. In the y part of the snake''s head, which
    can be represented as a column, we can have two movements: either DOWN or UP.
    While going down, we have to add 1 to the current head position y element and
    while going up, we have to decrease 1 in the current y position. For the x part
    of the snake''s head, we have the LEFT and RIGHT movements.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`snake`变量是一个列表。因此，我们可以使用`insert()`方法来操作该列表元素。`insert()`方法将接受两个参数：一个是索引，另一个是要插入的元素。在前面的代码中，索引是0，这意味着我们要在列表的第一个元素中插入一个元素，它代表了蛇的头部。下一个参数是要添加到索引0的元素。我们可以在两个语句之间看到一个逗号(,)：`snake[0][0]
    + (key == KEY_DOWN and 1) + (key == KEY_UP and -1)`和`snake[0][1] + (key == KEY_LEFT
    and -1) + (key == KEY_RIGHT and 1)`。第一个语句表示蛇头的y坐标，而第二个语句表示蛇头的x坐标。在蛇头的y部分，可以表示为一列，我们可以有两种移动方式：向下或向上。向下时，我们必须在当前头部位置的y元素上加1，而向上时，我们必须在当前y位置减1。对于蛇头的x部分，我们有左和右的移动。'
- en: 'On pressing the LEFT key, we are going to decrease the coordinate of x with
    1 and on pressing the RIGHT key, we are going to add 1 to x. Still confused? Taking
    a look at the following diagram should make things clearer for you:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 按下左键时，我们将x坐标减1，按下右键时，我们将x加1。还是困惑吗？看一下下面的图表应该能让你更清楚：
- en: '![](Images/20279a9a-0c1a-41ba-a180-c0b02331e9f8.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/20279a9a-0c1a-41ba-a180-c0b02331e9f8.png)'
- en: Remember that this update has to be done in the order of (y,x). For every **UP**
    and **DOWN** key that's pressed, a decrement or increment of 1 is done in the
    coordinate of y, which is snake[0][0] for the head. For x, this is snake[0][1],
    which is the same increment and decrement that we used previously, but for when
    the user presses the **RIGHT** and **LEFT** keys.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个更新必须按照(y,x)的顺序进行。对于每次按下**UP**和**DOWN**键，y坐标都会增加或减少1，这是蛇头的snake[0][0]坐标。对于x坐标，这是snake[0][1]，这是我们之前使用的相同的增加和减少，但是当用户按下**RIGHT**和**LEFT**键时。
- en: 'Now that we have made some logic to update the position of the snake, we need
    to make the snake eat the food. The logic we are going to cover is simple: when
    the snake''s head position is the same as the food''s position, we can say that
    the snake ate the food. Let''s go over this now.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经制定了一些逻辑来更新蛇的位置，我们需要让蛇吃食物。我们要讨论的逻辑很简单：当蛇的头部位置与食物的位置相同时，我们可以说蛇吃了食物。让我们现在来讨论这个。
- en: Game logic – when the snakes eats the food
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏逻辑-当蛇吃食物时
- en: 'Let''s make the next bit of logic for our game. In this section, we are going
    to make the snake eat the food. This is quite simple to implement. Whenever the
    snake''s head touches the food, we will assume that the snake has eaten the food.
    Thus, the snake''s head coordinates and the food''s coordinates will be the same.
    We also have to make some logic that will generate food in the next location as
    soon as the snake eats the current piece of food. The location for the next piece
    of food should be random. We can use the `random` module to create such an arbitrary
    location. Let''s start writing the code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的游戏制作下一个逻辑部分。在这一部分，我们将让蛇吃食物。这很容易实现。每当蛇的头部触碰到食物时，我们就假设蛇已经吃了食物。因此，蛇的头部坐标和食物的坐标将是相同的。我们还必须制定一些逻辑，一旦蛇吃掉当前的食物，就会在下一个位置生成食物。下一个食物的位置应该是随机的。我们可以使用`random`模块来创建这样一个任意的位置。让我们开始编写代码：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is a new way of importing any function from the module. While calling
    this function, we don''t have to write something like `random.randint()`. Instead,
    we can call it directly in our program. The arguments inside the `randint()` method
    must be the range of values. For example, `randint(2,8)` returns a number between
    2 to 8, like so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从模块中导入任何函数的新方法。在调用这个函数时，我们不必写类似`random.randint()`的东西。相反，我们可以直接在我们的程序中调用它。`randint()`方法中的参数必须是值的范围。例如，`randint(2,8)`返回2到8之间的数字，就像这样：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Inside the if part of the code, we have added the logic that will put the food
    in a new position. Remember that, at the beginning of the game, we initialized
    the new window height to be 20 and the width to be 60\. Thus, we can only generate
    food within this boundary. In the else part of the code, we pop out the last element
    if the user is unable to eat the food. In the second to last line, we added the
    snake's head position with the `'X'` character.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的if部分中，我们添加了将食物放在新位置的逻辑。请记住，在游戏开始时，我们将新窗口的高度初始化为20，宽度为60。因此，我们只能在这个边界内生成食物。在代码的else部分中，如果用户无法吃到食物，我们会弹出最后一个元素。在倒数第二行，我们将蛇头的位置与`'X'`字符相加。
- en: 'Let''s run our game and see what it looks like so far:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行游戏，看看目前的样子：
- en: '![](Images/b1eacf8b-662a-45a1-883f-f68146d1edf9.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b1eacf8b-662a-45a1-883f-f68146d1edf9.png)'
- en: Now, our game is playable enough. We learned about so many things while making
    this game, such as how to make game logic while working with the methods and coordinates
    of the game console. Now, let's proceed to the next section, where we will learn
    how to test and modify our game.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的游戏已经足够可玩了。在制作这个游戏的过程中，我们学到了很多东西，比如如何在处理游戏控制台的方法和坐标时制定游戏逻辑。现在，让我们继续下一节，我们将学习如何测试和修改我们的游戏。
- en: Game testing and modification
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏测试和修改
- en: 'To uncover the deficit of any program, its always a good idea to run and test
    it. Just like our previous games, we can also make modifications to the Snake
    game. The following points explain some of the modifications we could make to
    our game:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发现任何程序的缺陷，运行和测试它总是一个好主意。就像我们之前的游戏一样，我们也可以对Snake游戏进行修改。以下几点解释了我们可以对游戏进行的一些修改：
- en: 'When you run the game, the first thing you will notice is that our game does
    not have logic to decide whether the snake has collided with itself or not. If
    it does collide with another part of its body, we have to stop the game. Let''s
    add that logic inside the while loop:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你运行游戏时，你会注意到的第一件事是，我们的游戏没有逻辑来决定蛇是否与自己的其他部分发生碰撞。如果它与身体的其他部分发生碰撞，我们必须停止游戏。让我们在while循环中添加这个逻辑：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, snake[0] represents the head of the snake while snake[1:]
    represents the body of the snake. Thus, the preceding condition means that the
    head coordinates are inside the body of the snake, which means a collision occurred.
    In this case, we use a `break` statement to get out of the loop and terminate
    the game.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的代码中，snake[0]代表蛇的头部，而snake[1:]代表蛇的身体。因此，前面的条件意味着头部坐标在蛇的身体内，这意味着发生了碰撞。在这种情况下，我们使用`break`语句来跳出循环并终止游戏。
- en: 'Let''s say we want to add the score of the player. Adding a score is simple;
    the number of food that has been eaten by the snake is equivalent to the player''s
    score. We can initialize the value of the score as 0 to start with:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们想要添加玩家的得分。添加得分很简单；蛇吃掉的食物数量等于玩家的得分。我们可以将得分的值初始化为0开始：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we have added some statements with the `addstr` method
    that will provide the score of the player at the specified position. Now, let''s
    run our game:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一些带有`addstr`方法的语句，这些语句将在指定位置提供玩家的得分。现在，让我们运行游戏：
- en: '![](Images/9358081e-0e9b-4242-ab0e-0e7a30cc3cd5.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9358081e-0e9b-4242-ab0e-0e7a30cc3cd5.png)'
- en: 'After running the game, you can see that we are able to play within the interface
    of curses. However, you will encounter an exception as soon as your snake hits
    the boundary line, and your game will be terminated automatically. We will learn
    how to handle boundary collisions in the upcoming chapters in detail (to be specific, [Chapter
    11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake Game UI
    with Pygame*), but, for now, let''s learn about the easiest method we can use
    to handle and get rid of triggering an exception. First of all, observe the dimension
    of the boundary screen and take note of the actual height and width at which the
    boundary resides. Consider looking at the `win` variable to get an idea about
    the size of the boundary screen. Now, looking at the height of 20, we might assume
    that whenever the snake touches the top boundary, that is, he head position of
    the snake at 0, the snake''s head must enter through the own boundary, which has
    a y coordinate of 19\. Remember that, in the upper and lower boundaries, only
    the y-coordinate changes. The code for this will be as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏后，您可以看到我们能够在curses的界面中进行游戏。然而，一旦您的蛇撞到边界线，您将遇到一个异常，游戏将自动终止。我们将在接下来的章节中详细学习如何处理边界碰撞（具体来说，[第11章](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml)，*使用Pygame制作Outdo
    Turtle - Snake游戏UI*），但是现在，让我们学习一下我们可以使用的最简单的方法来处理并消除触发异常。首先，观察边界屏幕的尺寸，并注意边界所在的实际高度和宽度。考虑查看`win`变量，以了解边界屏幕的大小。现在，看着高度为20，我们可能会假设每当蛇触碰顶部边界时，也就是说，蛇头位置为0时，蛇头必须通过自己的边界进入，其y坐标为19。请记住，在上下边界中，只有y坐标会改变。这个逻辑的代码如下：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Similarly, we have to address the case where the snake hits either the right
    or left boundary. Since the height remains the same for either case, we are only
    interested in the width (x-position). Since the width of the screen that''s declared
    by the win variable is 60, we can expect the snake hitting a boundary at around
    0 (for the right) and 59 (for the left) to cause the snake to be regenerated accordingly.
    You have to add the following line of code to handle collisions that occur at
    the left and right boundaries:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们必须处理蛇撞到右边界或左边界的情况。由于高度对于任何一种情况都保持不变，我们只关心宽度（x位置）。由于由win变量声明的屏幕宽度为60，我们可以预期蛇在0（右边）和59（左边）左右撞到边界时会相应地重新生成。您必须添加以下代码来处理发生在左右边界的碰撞：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we have completed the snake game. It is appealing enough to make any
    user play this game. We also learned how to create programs with our own brand
    new logic. This was the first simple module we have used to make text-based games.
    Even though it''s playable, we haven''t added any graphics to it, and so it looks
    quite bland. We will make it more scintillating by learning about a new Python
    paradigm named Object Oriented Programming. We have successfully made some modifications
    to our game. Now, it''s time to learn about the most important concept of Python:
    object-oriented programming.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经完成了Snake游戏。它足够吸引人，让任何用户都能玩这个游戏。我们还学会了如何用全新的逻辑创建程序。这是我们用来制作基于文本的游戏的第一个简单模块。尽管它是可玩的，但我们没有为它添加任何图形，所以看起来相当单调。通过学习一个名为面向对象编程的新Python范例，我们将使它更加引人入胜。我们已经成功地对我们的游戏进行了一些修改。现在，是时候学习Python最重要的概念了：面向对象编程。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we started to uncover the world of game programming with curses.
    Obviously, it wasn''t the perfect game as it had no amazing animations or a fantastic
    interface. We barely touched on these topics since curses provides applications
    that are text-based and run on a plain Terminal. Even the game characters, such
    as snake and food for the Snake game were made out of alphabetical letters. Even
    though we didn''t put extra effort in to make the game more appealing, we have
    learned about how to make the game logic. Two of the pieces of logic that we made
    in the Snake game were important: the first was the interaction of the coordinates
    of the game console with the player''s positions, and the second was making the
    characters collide. The coordinate system''s order that''s supported by curses
    was strange. In most libraries, such as pygame and pyopengl, we have a coordinate
    system represented in the order (x,y), but in curses, it''s (y,x). The collision
    between two characters is confirmed if they are in the same coordinate point (y,x).
    To do this, we have to check the collision between the snake''s head and its body.
    This logic might sound simple, but it will come in handy in the long run. For
    example, in upcoming games such as Flappy Bird or Angry Birds, we are going to
    check the collision between the characters with the same logic.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始揭开curses游戏编程的世界。显然，这并不是完美的游戏，因为它没有惊人的动画或奇妙的界面。我们几乎没有涉及这些话题，因为curses提供的应用是基于文本的，并在普通终端上运行。甚至Snake游戏的游戏角色，如蛇和食物，都是由字母组成的。尽管我们没有额外的努力使游戏更具吸引力，但我们已经学会了如何制作游戏逻辑。我们在Snake游戏中制作的逻辑中有两个重要的部分：第一个是游戏控制台的坐标与玩家位置的交互，第二个是使角色发生碰撞。curses支持的坐标系统顺序很奇怪。在大多数库中，如pygame和pyopengl，我们有一个以(x，y)顺序表示的坐标系统，但在curses中，它是(y，x)。如果两个字符在相同的坐标点(y，x)上，它们之间发生碰撞。为了做到这一点，我们必须检查蛇头和蛇身之间的碰撞。这个逻辑听起来可能很简单，但从长远来看会很有用。例如，在即将推出的游戏中，如Flappy
    Bird或Angry Birds，我们将使用相同的逻辑来检查角色之间的碰撞。
- en: The code that we've written for the Snake game is meticulous and thorough because
    the game was written with procedural programming in mind. In the next chapter,
    we will learn about the most important concept of Python, object-oriented programming,
    and modify our code accordingly, which will make our code more readable and reusable.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为Snake游戏编写的代码非常细致和彻底，因为游戏是以过程式编程为基础编写的。在下一章中，我们将学习Python最重要的概念——面向对象编程，并相应地修改我们的代码，这将使我们的代码更易读和可重用。
