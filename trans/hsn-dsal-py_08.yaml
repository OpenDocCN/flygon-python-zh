- en: Graphs and Other Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图和其他算法
- en: In this chapter, we will discuss concepts related to the graphs. The concept
    of graphs comes from a branch of mathematics called **graph theory**. Graphs are
    used to solve a number of computing problems. Graphs are a non-linear data structure.
    This structure represents data by connecting a set of nodes or vertices along
    their edges. It is quite a different data structure compared to what we have looked
    at so far, and operations on graphs (for example, traversal) may be unconventional.
    We will be discussing many concepts related to graphs in this chapter. In addition,
    we will also be discussing priority queues and heaps later in the chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论与图相关的概念。图的概念来自数学的一个分支，称为**图论**。图被用来解决许多计算问题。图是一种非线性数据结构。这种结构通过连接一组节点或顶点以及它们的边来表示数据。这与我们迄今为止所看到的数据结构非常不同，对图的操作（例如遍历）可能是非常规的。在本章中，我们将讨论与图相关的许多概念。此外，我们还将在本章后面讨论优先队列和堆。
- en: 'By the end of this chapter, you should be able to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该能够做到以下几点：
- en: Understand what graphs are
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解图是什么
- en: Know the types of graphs and their constituents
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解图的类型和它们的组成部分
- en: Know how to represent a graph and traverse it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何表示图并遍历它
- en: Get a fundamental idea of what priority queues are
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获得优先队列的基本概念
- en: Be able to implement a priority queue
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够实现优先队列
- en: Be able to determine the i^(th) smallest element in a list
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够确定列表中第i个最小的元素
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All source code discussed in this chapter is provided in the GitHub repository
    at the following link: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter08).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的所有源代码都可以在以下链接的GitHub存储库中找到：[https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter08](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter08)。
- en: Graphs
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图
- en: A graph is a set of vertices and edges that form connections between the vertices.
    In a more formal approach, a graph **G** is an ordered pair of a set *V* of vertices
    and a set **E** of edges, given as `G = (V, E)` in formal mathematical notation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图是一组顶点和边，它们之间形成连接。在更正式的方法中，图**G**是一个顶点集*V*和边集**E**的有序对，以正式的数学符号表示为`G = (V, E)`。
- en: 'An example of a graph is given here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给出了一个图的示例：
- en: '![](Images/05db308a-34cf-4ecf-90df-2798d1d0153d.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/05db308a-34cf-4ecf-90df-2798d1d0153d.png)'
- en: 'Let''s discuss some of the important definitions of a graph:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些图的重要定义：
- en: '**Node or vertex**: A point or node in a graph is called a vertex, which is
    usually represented in a graph by a dot. In the preceding diagram, the vertices or
    nodes are **A**, **B**, **C**, **D**, and **E**.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点或顶点**：图中的一个点或节点称为一个顶点，通常在图中用一个点表示。在前面的图中，顶点或节点是**A**、**B**、**C**、**D**和**E**。'
- en: '**Edge**: This is a connection between two vertices. The line connecting **A**
    and **B** is an example of an edge in the preceding graph.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边**：这是两个顶点之间的连接。连接**A**和**B**的线是前面图中边的一个例子。'
- en: '**Loop**: When an edge from a node is incident on itself, that edge forms a
    loop.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环**：当一个节点的边与自身相连时，该边形成一个循环。'
- en: '**Degree of a vertex**: The total number of edges that are incident on a given
    vertex is called the degree of that vertex. For example, the degree of the **B** vertex in
    the previous diagram is `4`.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点的度**：一个给定顶点上的边的总数被称为该顶点的度。例如，前面图中**B**顶点的度为`4`。'
- en: '**Adjacency**: This refers to the connection(s) between any two nodes; thus,
    if there is a connection between any two vertices or nodes, then they are said
    to be adjacent to each other. For example, the **C** node is adjacent to the **A **node
    because there is an edge between them.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邻接**：这指的是任意两个节点之间的连接；因此，如果两个顶点或节点之间有连接，则它们被称为相邻。例如，**C**节点与**A**节点相邻，因为它们之间有一条边。'
- en: '**Path**: A sequence of vertices and edges between any two nodes represents
    a path from the **A** vertex to the **B **vertex. For example, **CABE** represents
    a path from the **C** node to the **E** node.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径**：任意两个节点之间的顶点和边的序列表示从**A**节点到**B**节点的路径。例如，**CABE**表示从**C**节点到**E**节点的路径。'
- en: '**Leaf vertex** (also called *pendant vertex*): A vertex or node is called
    a leaf vertex or pendant vertex if it has exactly one degree.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叶节点**（也称为*挂节点*）：如果一个顶点或节点的度为1，则称为叶节点或挂节点。'
- en: Directed and undirected graphs
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有向和无向图
- en: 'Graphs are represented by the edges between the nodes. The connecting edges
    can be considered directed or undirected. If the connecting edges in a graph are
    undirected, then the graph is called an undirected graph, and if the connecting
    edges in a graph are directed, then it is called a directed graph. An undirected
    graph simply represents edges as lines between the nodes. There is no additional
    information about the relationship between the nodes, other than the fact that
    they are connected. For example, in the following diagram, we demonstrate an undirected
    graph of four nodes, **A**, **B**, **C**, and **D**, which are connected using
    edges:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图由节点之间的边表示。连接边可以被认为是有向的或无向的。如果图中的连接边是无向的，则图被称为无向图，如果图中的连接边是有向的，则它被称为有向图。无向图简单地将边表示为节点之间的线。除了它们相互连接之外，关于节点之间关系的其他信息都没有。例如，在下图中，我们展示了一个由四个节点**A**、**B**、**C**和**D**组成的无向图，它们之间通过边相连：
- en: '![](Images/3b95d068-1a3e-4396-a06e-ccb8d3212bc8.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3b95d068-1a3e-4396-a06e-ccb8d3212bc8.png)'
- en: 'In a directed graph, the edges provide the information on the direction of
    connection between any two nodes in a graph. If an edge from node **A** to **B**
    is said to be directed, then the edge (**A**, **B**) would not be equal to the
    edge (**B**, **A**). The directed edges are drawn as lines with arrows, which
    will point in whichever direction the edge connects the two nodes. For example,
    in the following diagram, we show a directed graph where many nodes are connected
    using directed edges:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在有向图中，边提供了有关图中任意两个节点之间连接方向的信息。如果从节点**A**到**B**的边是有向的，那么边（**A**，**B**）就不等于边（**B**，**A**）。有向边用带箭头的线表示，箭头指向边连接两个节点的方向。例如，在下图中，我们展示了一个有向图，其中许多节点使用有向边连接：
- en: '![](Images/2a0b4a49-1e7d-4191-9261-ec2f3631e0c8.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2a0b4a49-1e7d-4191-9261-ec2f3631e0c8.png)'
- en: 'The arrow of an edge determines the flow of direction. One can only move from
    **A** to **B**, as shown in the preceding diagram—not **B** to **A**. In a directed
    graph, each node (or vertex) has an indegree and an outdegree. Let''s have a look
    at what these are:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 边的箭头确定了方向的流动。如前图所示，只能从**A**到**B**，而不能从**B**到**A**。在有向图中，每个节点（或顶点）都有一个入度和一个出度。让我们来看看这些是什么：
- en: '**Indegree**: The total number of edges that come into a vertex in the graph
    is called the indegree of that vertex. For example, in the previous diagram, the
    **E** node has `1` indegree, due to edge **CE** coming into the **E** node.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入度**：进入图中一个顶点的边的总数称为该顶点的入度。例如，在前面的图中，**E**节点由于边**CE**进入，所以入度为`1`。'
- en: '**Outdegree**: The total number of edges that goes out from a vertex in the
    graph is called the outdegree of that vertex. For example, the **E** node in the
    previous diagram has an outdegree of `2`, as it has two edges, **EF** and **ED**, going
    out of that node.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**出度**：从图中一个顶点出去的边的总数称为该顶点的出度。例如，在前面的图中，**E**节点的出度为`2`，因为它有两条边**EF**和**ED**出去。'
- en: '**Isolated vertex**:A node or vertex is called an isolated vertex when it has
    a degree of zero.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**孤立顶点**：当一个节点或顶点的度为零时，称为孤立顶点。'
- en: '**Source vertex**: A vertex is called a source vertex if it has an indegree
    of zero. For example, in the previous diagram, the **A** node is the source vertex.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源顶点**：如果一个顶点的入度为零，则称为源顶点。例如，在前面的图中，**A**节点是源顶点。'
- en: '**Sink** **vertex**: A vertex is a sink vertex if that has an outdegree of
    zero. For example, in the previous diagram, the **F** node is the sink vertex.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汇点**：如果一个顶点的出度为零，则称为汇点。例如，在前面的图中，**F**节点是汇点。'
- en: Weighted graphs
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加权图
- en: 'A weighted graph is a graph that has a numeric weight associated with the edges
    in the graph. It can be either a directed or an undirected graph. This numerical
    value can possibly be used to indicate distance or cost, depending upon the purpose
    of the graph. Let''s consider an example. The following graph indicates different
    ways to get from the **A** node to the **D **node. You can either go straight
    from **A** to **D**, or choose to pass through **B** and **C,** considering that
    the associated weight with each edge is the amount of time, in minutes, for the
    journey to the next node:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 加权图是一个在图中的边上关联了数值权重的图。它可以是有向图，也可以是无向图。这个数值可以用来表示距离或成本，取决于图的目的。让我们来考虑一个例子。下图表示了从**A**节点到**D**节点的不同路径。你可以直接从**A**到**D**，也可以选择经过**B**和**C**，考虑到每条边的关联权重是到达下一个节点所需的时间（以分钟为单位）：
- en: '![](Images/16b1ee37-e5b6-4d4e-951c-7dfd2bcf24ba.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/16b1ee37-e5b6-4d4e-951c-7dfd2bcf24ba.png)'
- en: In this example, **AD** and **ABCD** represent two different paths. A path is
    simply a sequence of edges that you pass through between two nodes. Following
    these paths, you see that the **AD** journey takes **40** minutes, whereas the
    **ABCD** journey takes **25** minutes. If the only concern is time, then it would
    be better to travel along the **ABCD **path, even though it may be a longer route. The
    point to take away here is that edges can be directed and may hold other information
    (for example, time taken, distance to be traveled, and so on).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，**AD**和**ABCD**代表两条不同的路径。路径就是在两个节点之间通过的一系列边。跟随这些路径，你会发现**AD**需要**40**分钟，而**ABCD**只需要**25**分钟。如果唯一关心的是时间，那么沿着**ABCD**路径旅行会更好，即使它可能是一条更长的路线。这里要记住的是边可以是有方向的，并且可能包含其他信息（例如所需时间、要行驶的距离等）。
- en: We can implement our graphs in a similar manner to what we have done with other
    data structures, such as linked lists. With graphs, it makes sense to see edges
    as objects, just as nodes. Just like nodes, edges can also contain extra information
    that makes it necessary to follow a particular path. The edges in the graphs can
    be represented using the links between different nodes; if there is a directed
    edge in the graph, we can implement it with an arrow pointing from one node to
    another, which is easy to represent in the node class by using `next` or `previous`,
    `parent`, or `child`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以类似的方式实现图形，就像我们对其他数据结构（如链表）所做的那样。对于图形来说，将边看作对象和节点一样是有意义的。就像节点一样，边也可以包含额外的信息，这使得跟随特定路径成为必要。图中的边可以用不同节点之间的链接来表示；如果图中有一个有向边，我们可以用一个箭头从一个节点指向另一个节点来实现它，这在节点类中很容易用`next`或`previous`、`parent`或`child`来表示。
- en: Graph representations
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的表示
- en: 'Graphs can be represented with two main forms while implementing them in Python.
    One way is to use an adjacency list, and the other is to use an adjacency matrix.
    Let''s consider an example, shown in the following diagram, to develop both types
    of representation for graphs:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中实现图时，可以用两种主要形式来表示。一种是使用邻接表，另一种是使用邻接矩阵。让我们考虑一个例子，如下图所示，为图开发这两种表示类型：
- en: '![](Images/56cf0157-d3c0-4cbc-96f5-106bf1595186.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/56cf0157-d3c0-4cbc-96f5-106bf1595186.png)'
- en: Adjacency lists
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邻接表
- en: An adjacency list stores all the nodes, along with other nodes that are directly
    connected to them in the graph. Two nodes, `A` and `B`, in a graph `G`, are said
    to be adjacent if there is a direct connection between them. A `list` data structure
    in Python is used to represent a graph. The `indices` of the list can be used
    to represent the nodes or vertices in the graph.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接列表存储所有节点，以及与它们在图中直接连接的其他节点。在图`G`中，两个节点`A`和`B`如果之间有直接连接，则称它们是相邻的。在Python中，使用`list`数据结构表示图。列表的索引可以用来表示图中的节点或顶点。
- en: 'At each index, the adjacent nodes to that vertex are stored. For example, consider
    the following adjacency list corresponding to the sample graph shown previously:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个索引处，将该顶点的相邻节点存储起来。例如，考虑以下对应于先前显示的示例图的邻接列表：
- en: '![](Images/ef3c9ee0-ee1c-4d1b-bac9-7ac85ad81b87.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ef3c9ee0-ee1c-4d1b-bac9-7ac85ad81b87.png)'
- en: The numbers in the box represent the vertices. The `0` index represents the `A` vertex
    of the graph, with its adjacent nodes being `B` and `C`. The `1` index represents
    the `B` vertex of the graph, with its adjacent nodes of `E`, `C`, and `A`. Similarly,
    the other vertices, `C`, `E`, and `F`, of the graph are represented at the indices
    of `2`, `3`, and `4` with their adjacent nodes, as shown in the previous diagram.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 方框中的数字代表顶点。`0`索引代表图的`A`顶点，其相邻节点为`B`和`C`。`1`索引代表图的`B`顶点，其相邻节点为`E`、`C`和`A`。类似地，图的其他顶点`C`、`E`和`F`在索引`2`、`3`和`4`处表示，其相邻节点如前图所示。
- en: 'Using a `list` for the representation is quite restrictive, because we lack
    the ability to directly use the vertex labels. Therefore, a `dictionary` data
    structure is more suitable to represent the graph. To implement the same preceding
    graph using a dictionary data structure, we can use the following statements:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`list`进行表示相当受限制，因为我们缺乏直接使用顶点标签的能力。因此，使用`dictionary`数据结构更适合表示图。要使用`dictionary`数据结构实现相同的先前图，我们可以使用以下语句：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now we can easily establish that the **A** vertex has the adjacent vertices of **B**
    and **C**. The **F** vertex has the **C** vertex as its only neighbor. Similarly,
    the **B** vertex has adjacent vertices of **E**, **B**, and **A**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以很容易地确定**A**顶点的相邻顶点是**B**和**C**。**F**顶点的唯一邻居是**C**。同样，**B**顶点的相邻顶点是**E**、**B**和**A**。
- en: Adjacency matrices
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邻接矩阵
- en: 'Another approach by which a graph can be represented is by using an adjacency
    matrix. A matrix is a two-dimensional array. The idea here is to represent the
    cells with a `1` or `0`, depending on whether two vertices are connected by an
    edge or not. We demonstrate an example graph, along with its corresponding adjacency
    matrix, in the following diagram:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图可以使用邻接矩阵表示的另一种方法是使用邻接矩阵。矩阵是一个二维数组。这里的想法是用`1`或`0`表示单元格，具体取决于两个顶点是否由边连接。我们在下图中演示了一个示例图，以及其对应的邻接矩阵：
- en: '![](Images/239d325d-3579-44fc-9574-51a29681914d.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/239d325d-3579-44fc-9574-51a29681914d.png)'
- en: 'An adjacency matrix can be implemented using the given an adjacency list. To
    implement the adjacency matrix, let''s take the previous dictionary-based implementation
    of the graph. Firstly, we have to obtain the key elements of the adjacency matrix.
    It is important to note that these matrix elements are the vertices of the graph.
    We can get the key elements by sorting the keys of the graph. The code snippet
    for this is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用给定的邻接列表来实现邻接矩阵。要实现邻接矩阵，让我们使用图的先前基于字典的实现。首先，我们必须获得邻接矩阵的关键元素。重要的是要注意，这些矩阵元素是图的顶点。我们可以通过对图的键进行排序来获得关键元素。此操作的代码片段如下：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, the length of the keys of the graph is used to provide the dimensions
    of the adjacency matrix, which are stored in `cols` and `rows`, and the values
    in the `cols` and `rows` are equal. We then create an empty adjacency matrix of
    the right size for the number of `cols` by `rows`, filling it with zeros. The `edges_list` variable
    will store the tuples that form the edges in the graph. For example, an edge between
    the A and B nodes will be stored as `(A, B)`. The code snippet to initialize an
    empty adjacency matrix is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用图的键的长度来提供邻接矩阵的维度，这些维度存储在`cols`和`rows`中，`cols`和`rows`中的值相等。然后我们创建一个正确大小的空邻接矩阵，大小为`cols`乘以`rows`，并用零填充它。`edges_list`变量将存储图中形成边的元组。例如，A和B节点之间的边将存储为`(A,
    B)`。初始化空邻接矩阵的代码片段如下：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The multidimensional array is filled using a nested `for` loop:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 多维数组是使用嵌套的`for`循环填充的：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The neighbors of a vertex are obtained by `graph[key]`. The key, in combination
    with the `neighbor`, is then used to create the tuple stored in `edges_list`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点的邻居是通过`graph[key]`获得的。然后，结合`neighbor`使用`edges_list`存储创建的元组。
- en: 'The output of the preceding Python code for storing the edges of the graph
    is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 用于存储图的边的上述Python代码的输出如下：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The next step in implementing the adjacency matrix is to fill it, using `1`
    to denote the presence of an edge in the graph. This can be done with the `adjacency_matrix[index_of_first_vertex][index_of_second_vertex]
    = 1` statement. The full code snippet that marks the presence of edges of the
    graph is as follows
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 实现邻接矩阵的下一步是填充它，使用`1`表示图中存在边。这可以通过`adjacency_matrix[index_of_first_vertex][index_of_second_vertex]
    = 1`语句来完成。标记图的边存在的完整代码片段如下：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `matrix_elements` array has its `rows` and `cols`, starting from `A` to
    all other vertices with indices of `0` to `5`. The `for` loop iterates through
    our list of tuples and uses the `index` method to get the corresponding index
    where an edge is to be stored.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`matrix_elements`数组有它的`rows`和`cols`，从`A`到所有其他顶点，索引从`0`到`5`。`for`循环遍历我们的元组列表，并使用`index`方法获取要存储边的相应索引。'
- en: 'The output of the preceding code is the adjacency matrix for the sample graph
    shown previously. The adjacency matrix produced looks like the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 先前代码的输出是先前显示的示例图的邻接矩阵。生成的邻接矩阵如下所示：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At row `1` and column `1`, the `0` represents the absence of an edge between
    A and A. Similarly, at column `2` and row `3`, there is a value of `1` that denotes
    the edge between the C and B vertices in the graph.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`1`行和第`1`列，`0`表示A和A之间没有边。同样，在第`2`列和第`3`行，有一个值为`1`，表示图中C和B顶点之间的边。
- en: Graph traversals
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图遍历
- en: 'A graph traversal means to visit all the vertices of the graph, while keeping
    track of which nodes or vertices have already been visited and which ones have
    not. A graph traversal algorithm is efficient if it traverses all the nodes of
    the graph in the minimum possible time. A common strategy of graph traversal is
    to follow a path until a dead end is reached, then traverse back up until there
    is a point where we meet an alternative path. We can also iteratively move from
    one node to another in order to traverse the full graph, or part of it. Graph
    traversal algorithms are very important in answering many fundamental problems—they
    can be useful to determine how to reach from one vertex to another in a graph,
    and which path from the A to B vertices in the graph is better than other paths.
    In the next section, we will discuss two important graph traversal algorithms:
    **breadth-first search** (**BFS**) and **depth-first search** (**DFS**).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图遍历意味着访问图的所有顶点，同时跟踪已经访问和尚未访问的节点或顶点。如果图遍历算法以最短可能的时间遍历图的所有节点，则该算法是高效的。图遍历的常见策略是沿着一条路径前进，直到遇到死胡同，然后向上遍历，直到遇到另一条路径。我们还可以迭代地从一个节点移动到另一个节点，以遍历整个图或部分图。图遍历算法在回答许多基本问题时非常重要——它们可以确定如何从图中的一个顶点到达另一个顶点，以及在图中从A到B顶点的哪条路径比其他路径更好。在接下来的部分中，我们将讨论两个重要的图遍历算法：**广度优先搜索**（**BFS**）和**深度优先搜索**（**DFS**）。
- en: Breadth-first traversal
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广度优先遍历
- en: Breadth-first traversal algorithms work breadth-wise in the graph. A queue data
    structure is used to store the information of vertices that are to be visited
    in the graph. We begin with the starting node, the **A** node. Firstly, we visit
    that node, and then we look up all of its neighboring, or adjacent, vertices.
    We first visit these adjacent vertices one by one, while adding their neighbors
    to the list of vertices that are to be visited. We follow this process until we
    have visited all the vertices of the graph, ensuring that no vertex is visited
    twice.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 广度优先遍历算法以图的广度为基础工作。使用队列数据结构来存储要在图中访问的顶点的信息。我们从起始节点**A**开始。首先，我们访问该节点，然后查找它所有的相邻顶点。我们逐个访问这些相邻顶点，同时将它们的邻居添加到要访问的顶点列表中。我们一直遵循这个过程，直到访问了图的所有顶点，确保没有顶点被访问两次。
- en: 'Let''s consider an example to better understand breadth-first traversal for
    graphs, using the following diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下图示例更好地理解图的广度优先遍历：
- en: '![](Images/f707225d-efca-4c9e-be16-cd6a3bac6ff5.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f707225d-efca-4c9e-be16-cd6a3bac6ff5.png)'
- en: In the preceding diagram, we have a graph of five nodes on the left, and on
    the right, a queue data structure to store the vertices to be visited. We start
    visiting the first node, **A**, and then add all its adjacent vertices, **B**,
    **C**, and **E**, to the queue. Here, it is important to note that there are multiple
    ways of adding the adjacent nodes to the queue, since there are three nodes, **B**,
    **C**, and **E**, that can be added in the queue as either **BCE**, **CEB**, **CBE**, **BEC**,
    or **ECB**, each of which would give us different tree traversal results.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，左侧有一个五个节点的图，右侧有一个队列数据结构，用于存储要访问的顶点。我们开始访问第一个节点**A**，然后将其所有相邻的顶点**B**、**C**和**E**添加到队列中。在这里，需要注意的是，添加相邻节点到队列有多种方式，因为有三个节点**B**、**C**和**E**，可以按照**BCE**、**CEB**、**CBE**、**BEC**或**ECB**的顺序添加到队列中，每种方式都会给出不同的树遍历结果。
- en: 'All of these possible solutions to the graph traversal are correct, but in
    this example, we will add the nodes in alphabetical order. The **A** node is visited
    as shown:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图遍历的所有可能解决方案都是正确的，但在这个例子中，我们将按字母顺序添加节点。如图所示，访问了**A**节点：
- en: '![](Images/27150f8e-3c54-4124-95e2-52a1a5b48413.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/27150f8e-3c54-4124-95e2-52a1a5b48413.png)'
- en: 'Once we have visited the **A** vertex, next, we visit its first adjacent vertex,
    **B**, and add those adjacent vertices that are not already added in the queue
    or not visited. In this case, we have to add the **D** vertex to the queue:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们访问了**A**顶点，接下来，我们访问它的第一个相邻顶点**B**，并添加那些尚未添加到队列或未访问的相邻顶点。在这种情况下，我们需要将**D**顶点添加到队列中：
- en: '![](Images/3b782d49-aea9-4aa0-bccd-32be854c1741.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3b782d49-aea9-4aa0-bccd-32be854c1741.png)'
- en: 'Now, after visiting the **B** vertex , we visit the next vertex from the queue—the
    **C** vertex. And again, add those of its adjacent vertices that have not already
    been added in the queue. In this case, there are no unrecorded vertices left,
    so there is no need to do anything:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在访问**B**顶点之后，我们访问队列中的下一个顶点**C**。然后，添加那些尚未添加到队列中的相邻顶点。在这种情况下，没有未记录的顶点，因此不需要进行任何操作：
- en: '![](Images/cb98173e-c3f9-4254-ac75-cb3eefaa916e.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cb98173e-c3f9-4254-ac75-cb3eefaa916e.png)'
- en: 'After visiting the **C** vertex, we visit the next vertex from the queue, the
    **E** vertex:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问**C**顶点之后，我们访问队列中的下一个顶点**E**：
- en: '![](Images/a444bc08-d7ec-42e2-a6e7-32b1c06491c4.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a444bc08-d7ec-42e2-a6e7-32b1c06491c4.png)'
- en: 'Similarly, after visiting the **E** vertex, we visit the **D** vertex in the
    last step:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在访问**E**顶点之后，我们在最后一步访问**D**顶点：
- en: '![](Images/3e1093a8-d4a6-4d88-9140-2f5d5cb36f85.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3e1093a8-d4a6-4d88-9140-2f5d5cb36f85.png)'
- en: Therefore, the BFS algorithm for traversing the preceding graph visits the vertices
    in the order of **A-B-C-E-D**. This is one of the possible solutions to the BFS
    traversal for the preceding graph, but we can get many possible solutions, depending
    on how we add the adjacent nodes to the queue.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，用于遍历上述图的BFS算法按照**A-B-C-E-D**的顺序访问顶点。这是上述图的BFS遍历的一种可能解决方案，但根据我们如何将相邻节点添加到队列中，我们可以得到许多可能的解决方案。
- en: 'To learn the implementation of this algorithm in Python, let''s consider another
    example of an undirected graph. Consider the following diagram as a graph:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习Python中此算法的实现，让我们考虑另一个无向图的示例。考虑以下图表作为图：
- en: '![](Images/dbc67290-a5cd-4ffe-835a-3e11ea10b056.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/dbc67290-a5cd-4ffe-835a-3e11ea10b056.png)'
- en: 'The adjacency list for the graph is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图的邻接列表如下：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To traverse this graph using the breadth-first algorithm, we will employ the
    use of a queue. The algorithm creates a list to store the vertices that have been
    visited as the traversal process proceeds. We shall start our traversal from the `A` node.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用广度优先算法遍历此图，我们将使用队列。该算法创建一个列表来存储已访问的顶点，遍历过程中。我们将从A节点开始遍历。
- en: The `A` node is queued and added to the list of visited nodes. Afterward, we
    use a `while` loop to effect traversal of the graph. In the `while` loop, the
    A node is dequeued. Its unvisited adjacent nodes, B, G, and D, are sorted in alphabetical
    order and queued up. The queue will now contain the B, D, and G nodes. These nodes
    are also added to the list of visited nodes. At this point, we start another iteration
    of the `while` loop, because the queue is not empty, which also means that we
    are not really done with the traversal.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: A节点被排队并添加到已访问节点列表中。然后，我们使用`while`循环来遍历图。在`while`循环中，A节点被出队。它的未访问的相邻节点B、G和D按字母顺序排序并排队。队列现在包含B、D和G节点。这些节点也被添加到已访问节点列表中。此时，我们开始`while`循环的另一个迭代，因为队列不为空，这也意味着我们并没有真正完成遍历。
- en: The B node is dequeued. Out of its adjacent nodes, A, F, and E, node A has already
    been visited. Therefore, we only queue the E and F nodes in alphabetical order.
    The E and F nodes are then added to the list of visited nodes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: B节点被出队。在其相邻节点A、F和E中，节点A已经被访问。因此，我们只按字母顺序排队E和F节点。然后，E和F节点被添加到已访问节点列表中。
- en: Our queue now holds the following nodes at this point—D, G, E, and F. The list
    of visited nodes contains A, B, D, G, E, and F.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的队列包含以下节点：D、G、E和F。已访问节点列表包含A、B、D、G、E和F。
- en: The D node is dequeued, but all of its adjacent nodes have been visited, so
    we simply dequeue it. The next node at the front of the queue is G. We dequeue
    the G node, but we also find out that all its adjacent nodes have been visited,
    because they are in the list of visited nodes. So, the G node is also dequeued.
    We dequeue the E node too, because all of its nodes have also been visited. The
    only node in the queue now is the F node.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: D节点被出队，但它的所有相邻节点都已被访问，所以我们只需出队。队列前面的下一个节点是G。我们出队G节点，但我们也发现它的所有相邻节点都已被访问，因为它们在已访问节点列表中。因此，G节点也被出队。我们也出队E节点，因为它的所有节点也都已被访问。队列中现在只剩下F节点。
- en: The F node is dequeued, and we realize that out of its adjacent nodes, B, D,
    and C, only C has not been visited. We then enqueue the C node and add it to the
    list of visited nodes. Then, the C node is dequeued. C has the adjacent nodes
    of F and H, but F has already been visited, leaving the H node. The H node is
    enqueued and added to the list of visited nodes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: F节点被出队，我们意识到它的相邻节点B、D和C中，只有C尚未被访问。然后，我们将C节点入队并添加到已访问节点列表中。然后，C节点被出队。C有F和H两个相邻节点，但F已经被访问，只剩下H节点。H节点被入队并添加到已访问节点列表中。
- en: Finally, the last iteration of the `while` loop will lead to the H node being
    dequeued. Its only adjacent node, C, has already been visited. Once the queue
    is completely empty, the loop breaks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次`while`循环迭代将导致H节点被出队。它的唯一相邻节点C已经被访问。一旦队列完全为空，循环就会中断。
- en: The output of the traversal the graph in the diagram is A, B, D, G, E, F, C,
    and H.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中遍历的输出是A、B、D、G、E、F、C和H。
- en: 'The code for a BFS is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: BFS的代码如下：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we want to find out whether a set of nodes are in the list of visited nodes,
    we use the `remaining_elements = set(adj_nodes).difference(set(visited_vertices))` statement. This
    uses the `set` object's `difference` method to find the nodes that are in `adj_nodes`, but
    not in `visited_vertices`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要找出一组节点是否在已访问节点列表中时，我们使用`remaining_elements = set(adj_nodes).difference(set(visited_vertices))`语句。这使用`set`对象的`difference`方法来找到在`adj_nodes`中但不在`visited_vertices`中的节点。
- en: In the worst-case scenario, each vertex or node and the edge will be traversed,
    thus the time complexity of the BFS algorithm is `O(|V| + |E|)`, where `|V|` is
    the number of vertices or nodes, while `|E|` is the number of edges in the graph.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，每个顶点或节点和边都将被遍历，因此BFS算法的时间复杂度为`O(|V| + |E|)`，其中`|V|`是顶点或节点的数量，而`|E|`是图中的边的数量。
- en: Depth-first search
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度优先搜索
- en: As the name suggests, the DFS algorithm traverses the depth of any particular
    path in the graph before traversing its breadth. As such, child nodes are visited
    first before sibling nodes. The `stack` data structure is used to implement the
    DFS algorithm.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，DFS算法在遍历广度之前，会先遍历图中任何特定路径的深度。因此，首先访问子节点，然后是兄弟节点。使用栈数据结构来实现DFS算法。
- en: 'We start by visiting the A node, and then we look at the neighbors of the A
    vertex, then a neighbor of that neighbor, and so on. Let''s consider the following
    graph in the context of DFS:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从访问A节点开始，然后查看A顶点的邻居，然后是邻居的邻居，依此类推。让我们在DFS的上下文中考虑以下图：
- en: '![](Images/ed6faf7a-b221-4000-bd58-91e6cf00c945.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ed6faf7a-b221-4000-bd58-91e6cf00c945.png)'
- en: 'After visiting the **A** vertex, we visit one of its neighbors, **B**, as shown:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 访问完A顶点后，我们访问其邻居之一，B，如下所示：
- en: '![](Images/ec27341d-6a80-4b5d-a952-8fac290a5ae0.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ec27341d-6a80-4b5d-a952-8fac290a5ae0.png)'
- en: 'After visiting the **B** vertex, we look at another neighbor of **A**, that
    is, **S**, as there is no vertex connected to **B** which can be visited. Next,
    we look for the neighbors of the **S** vertex, which are the **C** and **G** vertices.
    We visit **C** as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 访问完B顶点后，我们查看A的另一个邻居S，因为没有与B相连的顶点可以访问。接下来，我们查看S顶点的邻居，即C和G顶点。我们访问C如下：
- en: '![](Images/fe9f9af7-5783-4f10-bf19-af222854d129.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fe9f9af7-5783-4f10-bf19-af222854d129.png)'
- en: 'After visiting the **C** node, we visit its neighboring vertices, **D** and
    **E**:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 访问**C**节点后，我们访问其相邻的**D**和**E**节点：
- en: '![](Images/6c2139c7-20f9-4d2f-9027-4e972e122b5c.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6c2139c7-20f9-4d2f-9027-4e972e122b5c.png)'
- en: 'Similarly, after visiting the **E** vertex, we visit the **H** and **F** vertices,
    as shown in the following graphs:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，访问**E**顶点后，我们访问**H**和**F**顶点，如下图所示：
- en: '![](Images/b063f8a5-beec-41da-bd2b-73bf9bec1cc9.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b063f8a5-beec-41da-bd2b-73bf9bec1cc9.png)'
- en: 'Finally, we visit the **F** node:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们访问**F**节点：
- en: '![](Images/bded1b28-229f-4a15-a99b-50dc72925357.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bded1b28-229f-4a15-a99b-50dc72925357.png)'
- en: The output of the DFS traversal is **A-B-S-C-D-E-H-G-F**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: DFS遍历的输出是**A-B-S-C-D-E-H-G-F**。
- en: 'To implement the DFS, we start with the adjacency list of the given graph.
    Here is the adjacency list of the preceding graph:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现DFS，我们从给定图的邻接表开始。以下是先前图的邻接表：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The implementation of the DFS algorithm begins by creating a list to store
    the visited nodes. The `graph_stack` stack variable is used to aid the traversal
    process. We are using a regular Python list as a stack. The starting node, called `root`,
    is passed with the graph''s adjacency matrix, graph. `root` is pushed onto the
    stack. `node = root` holds the first node in the stack:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: DFS算法的实现始于创建一个列表来存储已访问的节点。`graph_stack`栈变量用于辅助遍历过程。我们使用普通的Python列表作为栈。起始节点称为`root`，并与图的邻接矩阵`graph`一起传递。`root`被推入栈中。`node
    = root`保存栈中的第一个节点：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The body of the `while` loop will be executed, provided the stack is not empty.
    If `node` is not in the list of visited nodes, we add it. All adjacent nodes to `node` are
    collected by `adj_nodes = graph[node]`. If all the adjacent nodes have been visited,
    we pop that node from the stack and set `node` to `graph_stack[-1]`. `graph_stack[-1]` is
    the top node on the stack. The `continue` statement jumps back to the beginning
    of the `while` loop's test condition.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 只要栈不为空，`while`循环的主体将被执行。如果`node`不在已访问节点列表中，我们将其添加。通过`adj_nodes = graph[node]`收集`node`的所有相邻节点。如果所有相邻节点都已经被访问，我们将从栈中弹出该节点，并将`node`设置为`graph_stack[-1]`。`graph_stack[-1]`是栈顶的节点。`continue`语句跳回到`while`循环的测试条件的开始。
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If, on the other hand, not all the adjacent nodes have been visited, then the
    nodes that are yet to be visited are obtained by finding the difference between
    the `adj_nodes` and `visited_vertices` with the `remaining_elements = set(adj_nodes).difference(set(visited_vertices))` statement.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果并非所有相邻节点都已经被访问，则通过使用`remaining_elements = set(adj_nodes).difference(set(visited_vertices))`语句找到`adj_nodes`和`visited_vertices`之间的差异来获得尚未访问的节点。
- en: The first item within `sorted(remaining_elements)` is assigned to `first_adj_node`,
    and pushed onto the stack. We then point the top of the stack to this node.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted(remaining_elements)`中的第一个项目被分配给`first_adj_node`，并推入栈中。然后我们将栈的顶部指向这个节点。'
- en: When the `while` loop exists, we will return `visited_vertices`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当`while`循环结束时，我们将返回`visited_vertices`。
- en: 'We will now explain the working of the source code by relating it to the previous
    example. The **A** node is chosen as our starting node. **A** is pushed onto the
    stack and added to the `visisted_vertices` list. In doing so, we mark it as having
    been visited. The `graph_stack` stack is implemented with a simple Python list.
    Our stack now has A as its only element. We examine the **A** node''s adjacent
    nodes, **B** and **S**. To test whether all the adjacent nodes of **A** have been
    visited, we use the `if` statement:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过将其与先前的示例相关联来解释源代码的工作。**A**节点被选择为我们的起始节点。**A**被推入栈中，并添加到`visisted_vertices`列表中。这样做时，我们将其标记为已访问。`graph_stack`栈使用简单的Python列表实现。我们的栈现在只有A作为其唯一元素。我们检查**A**节点的相邻节点**B**和**S**。为了测试**A**的所有相邻节点是否都已经被访问，我们使用`if`语句：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If all the nodes have been visited, we pop the top of the stack. If the `graph_stack`
    stack is not empty, we assign the node on top of the stack to `node`, and start
    the beginning of another execution of the body of the `while` loop. The `set(adj_nodes).issubset(set(visited_vertices))`
    statement will evaluate to `True` if all the nodes in `adj_nodes` are a subset
    of `visited_vertices`. If the `if` statement fails, it means that some nodes remain
    to be visited. We obtain that list of nodes with `remaining_elements = set(adj_nodes).difference(set(visited_vertices))`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有节点都已经被访问，我们将弹出栈顶。如果`graph_stack`栈不为空，我们将栈顶的节点赋给`node`，并开始另一个`while`循环主体的执行。如果`set(adj_nodes).issubset(set(visited_vertices))`语句评估为`True`，则表示`adj_nodes`中的所有节点都是`visited_vertices`的子集。如果`if`语句失败，这意味着还有一些节点需要被访问。我们通过`remaining_elements
    = set(adj_nodes).difference(set(visited_vertices))`获得这些节点的列表。
- en: 'Referring to the diagram, the **B** and **S** nodes will be stored in `remaining_elements`.
    We will access the list in alphabetical order as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图表，**B**和**S**节点将被存储在`remaining_elements`中。我们将按照字母顺序访问列表，如下所示：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We sort `remaining_elements` and return the first node to `first_adj_node`.
    This will return **B**. We push the **B** node onto the stack by appending it
    to the `graph_stack`. We prepare the **B** node for access by assigning it to
    `node`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`remaining_elements`进行排序，并将第一个节点返回给`first_adj_node`。这将返回**B**。我们通过将其附加到`graph_stack`来将**B**节点推入栈。我们通过将其分配给`node`来准备访问**B**节点。
- en: On the next iteration of the `while` loop, we add the **B** node to the list
    of `visited nodes`. We discover that the only adjacent node to **B**, which is
    **A**, has already been visited. Because all the adjacent nodes of **B** have
    been visited, we pop it off the stack, leaving **A** as the only element on the
    stack. We return to **A** and examine whether all of its adjacent nodes have been
    visited. The **A** node now has **S** as the only unvisited node. We push **S**
    to the stack and begin the whole process again.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环的下一次迭代中，我们将**B**节点添加到`visited nodes`列表中。我们发现**B**的唯一相邻节点**A**已经被访问。因为**B**的所有相邻节点都已经被访问，我们将其从栈中弹出，只留下**A**作为栈中的唯一元素。我们返回到**A**，检查它的所有相邻节点是否都已经被访问。**A**节点现在只有**S**节点是未访问的。我们将**S**推入栈中，然后重新开始整个过程。
- en: The output of the traversal is `A-B-S-C-D-E-H-G-F`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历的输出是`A-B-S-C-D-E-H-G-F`。
- en: DFS find applications in solving maze problems, finding connected components,
    and finding the bridges of a graph, among others.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索在解决迷宫问题、查找连通分量和查找图的桥梁等方面有应用。
- en: Other useful graph methods
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他有用的图方法
- en: It is very often that we need to use graphs for finding a path between two nodes.
    Sometimes, it is necessary to find all the paths between nodes, and in some situations,
    we might need to find the shortest path between nodes. For example, in routing
    applications, we generally use various algorithms to determine the shortest path
    from the source node to the destination node. For an unweighted graph, we would
    simply determine the path with the lowest number of edges between them. If a weighted
    graph is given, we have to calculate the total weight of passing through a set
    of edges.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要使用图来找到两个节点之间的路径。有时，需要找到节点之间的所有路径，在某些情况下，我们可能需要找到节点之间的最短路径。例如，在路由应用中，我们通常使用各种算法来确定从源节点到目标节点的最短路径。对于无权图，我们只需确定它们之间边数最少的路径。如果给定了加权图，我们必须计算通过一组边的总权重。
- en: Thus, in a different situation, we may have to find the longest or shortest
    path using different algorithms.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在不同的情况下，我们可能需要使用不同的算法来找到最长或最短的路径。
- en: Priority queues and heaps
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先队列和堆
- en: A priority queue is a data structure which is similar to the queue and stack
    data structures that stores data along with the priority associated with it. In
    the priority queue, the item with the highest priority is served first. Priority
    queues are often implemented using a heap, since it is very efficient for this
    purpose; however, it can be implemented using other data structures. It is a modified
    queue that returns the items in the order of highest priority, whereas the queue
    returns the items in the order that the items were added. The priority queue is
    used in many applications, such as CPU scheduling.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列是一种类似于队列和栈数据结构的数据结构，它存储与其关联的优先级的数据。在优先队列中，具有最高优先级的项目首先被服务。优先队列通常使用堆来实现，因为对于这个目的来说它非常高效；然而，它也可以使用其他数据结构来实现。它是一个修改过的队列，以最高优先级的顺序返回项目，而队列则以添加项目的顺序返回项目。优先队列在许多应用中使用，例如CPU调度。
- en: Let's consider an example to demonstrate the importance of priority queues over
    regular queues. Assume that, in a store, customers queue in a line where service
    is rendered only at the front of the queue. Each customer will spend some time
    in the queue before getting served. If the units of time spent by four customers
    in the queue are 4, 30, 2, and 1 respectively, then the average time spent in
    the queue becomes `(4 + 34 + 36 + 37)/4`, which is `27.75`. However, if we associate
    the priority condition with the data stored in the queue, then we can give more
    priority to the customer that spends the least time. In this situation, the customers
    will be served in the order of time spent by the customers, that is, in the order
    of 1, 2, 4, then 30\. Thus, the average waiting time would be `(1 + 3 + 7 + 37)/4`,
    which now equals `12`—a better average waiting time. Clearly, there is merit to
    serving the customers by the least time spent. This method of selecting the next
    item by priority, or some other criterion, is the basis for creating priority
    queues. Priority queues are mostly implemented using heaps.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子来演示优先队列比普通队列的重要性。假设在商店里，顾客排队等候服务只能在队列的前端进行。每个顾客在得到服务之前都会在队列中花费一些时间。如果四个顾客在队列中花费的时间分别是4、30、2和1，那么队列中的平均等待时间就变成了`(4
    + 34 + 36 + 37)/4`，即`27.75`。然而，如果我们将优先条件与队列中存储的数据关联起来，那么我们可以给予花费时间最少的顾客更高的优先级。在这种情况下，顾客将按照花费时间的顺序进行服务，即按照1、2、4、30的顺序。因此，平均等待时间将变为`(1
    + 3 + 7 + 37)/4`，现在等于`12`——一个更好的平均等待时间。显然，按照花费时间最少的顾客进行服务是有益的。按照优先级或其他标准选择下一个项目的方法是创建优先队列的基础。优先队列通常使用堆来实现。
- en: A heap is a data structure that satisfies a heap property. A heap property states
    that there must be a certain relationship between a parent node and its child
    nodes. This property must apply throughout the entire heap.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是满足堆属性的数据结构。堆属性规定父节点和其子节点之间必须存在一定的关系。这个属性必须在整个堆中都适用。
- en: In a min heap, the relationship between parent and children is that the value
    at the parent must always be less than or equal to its children. As a consequence
    of this, the lowest element in the heap must be the root node.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小堆中，父节点和子节点之间的关系是父节点的值必须始终小于或等于其子节点的值。由于这个关系，堆中最小的元素必须是根节点。
- en: In a max heap, on the other hand, the parent is greater than or equal to its
    child or its children. It follows from this that the largest value makes up the
    root node.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在最大堆中，父节点大于或等于其子节点。由此可知，最大值组成了根节点。
- en: 'The heaps are binary trees, and although we are going to use a binary tree,
    we will actually use a list to represent it. The heap stores a complete binary
    tree. A complete binary tree is one in which each row must be fully filled before
    starting to fill the next row, as shown in the following diagram:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是二叉树，尽管我们将使用二叉树，但实际上我们将使用列表来表示它。堆存储完全二叉树。完全二叉树是指在开始填充下一行之前，每一行必须完全填满，如下图所示：
- en: '![](Images/1cc995f2-9454-47c1-9f92-c16a8b884182.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1cc995f2-9454-47c1-9f92-c16a8b884182.png)'
- en: 'To make the math with indexes easier, we are going to leave the first item
    in the list (index 0) empty. After that, we place the tree nodes into the list,
    from top to bottom and left to right, as shown in the following diagram:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使索引的数学运算更容易，我们将把列表中的第一项（索引0）留空。之后，我们将树节点按照从上到下、从左到右的顺序放入列表中，如下图所示：
- en: '![](Images/8ddea893-9e46-4226-9160-4fcdd911daef.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8ddea893-9e46-4226-9160-4fcdd911daef.png)'
- en: If you observe carefully, you will notice that you can retrieve the children
    of any node at the `n` index very easily. The left child is located at `2n`, and
    the right child is located at `2n + 1`. This will always hold true. For example,
    the C node would be at the `3` index, as **C** is a right child of the **A** node,
    whose index is `1`, so it becomes `2n+1 = 2*1 + 1 = 3`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会注意到你可以很容易地检索到任何节点的子节点在`n`索引。左子节点位于`2n`，右子节点位于`2n + 1`。这总是成立的。例如，C节点将位于`3`索引，因为C是A节点的右子节点，其索引为`1`，所以它变成了`2n+1
    = 2*1 + 1 = 3`。
- en: 'Let''s discuss the implementation of the min heap using Python, as implementing
    the max heap will be more straightforward once we understand the min heap. We
    start with the heap class, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论使用Python实现最小堆，因为一旦我们理解了最小堆，实现最大堆将更加直接。我们从堆类开始，如下所示：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We initialize our heap list with a zero to represent the dummy first element
    (remember that we are only doing this to make the math simpler). We also create
    a variable to hold the size of the heap. This would not be necessary as such,
    since we could check the size of the list, but we would always have to remember
    to reduce it by one. So, we choose to keep a separate variable instead.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用零初始化堆列表，以表示虚拟的第一个元素（记住我们只是为了简化数学而这样做）。我们还创建一个变量来保存堆的大小。这并不是必要的，因为我们可以检查列表的大小，但我们总是需要记住将其减少一。因此，我们选择保持一个单独的变量。
- en: Insert operation
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入操作
- en: Inserting an item to the min heap works in two steps. First, we add the new
    element to the end of the list (which we understand to be the bottom of the tree),
    and we increment the size of the heap by one. Secondly, after each insertion operation,
    we need to arrange the new element up in the heap tree, to organize all the nodes
    in such a way that it satisfies the heap property. This is to remind us that the
    lowest element in the min-heap needs to be the root element.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 向最小堆插入项目需要分两步进行。首先，我们将新元素添加到列表的末尾（我们理解为树的底部），并将堆的大小增加一。其次，在每次插入操作之后，我们需要将新元素在堆树中安排起来，以使所有节点以满足堆属性的方式组织。这是为了提醒我们，最小堆中最小的元素需要是根元素。
- en: 'We first create a helper method, called `arrange`, that takes care of arranging
    all the nodes after insertion. Let''s consider an example of adding an element
    in the min heap. We provide an example heap in the following diagram, and want
    to insert the value of `2` in it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`arrange`的辅助方法，它负责在插入后安排所有节点。让我们考虑在最小堆中添加元素的示例。我们在下图中提供了一个示例堆，并希望在其中插入值为`2`的元素：
- en: '![](Images/8bb8b3e5-192f-4127-92f1-d97d8a56fcf2.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8bb8b3e5-192f-4127-92f1-d97d8a56fcf2.png)'
- en: 'The new element has occupied the last slot in the third row or level. Its index
    value is **7**. Now we compare that value with its parent. The parent is at index
    `7/2 = 3` (integer division). That element holds **6**, so we swap the **2**, as
    follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 新元素已经占据了第三行或级别的最后一个插槽。它的索引值为7。现在我们将该值与其父节点进行比较。父节点的索引为`7/2 = 3`（整数除法）。该元素的值为6，所以我们交换2，如下所示：
- en: '![](Images/1086030c-280d-4d34-bfa6-90f390182773.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1086030c-280d-4d34-bfa6-90f390182773.png)'
- en: 'Our new element has been swapped and moved up to the **3 **index. We have not
    reached the top of the heap yet (*3/2 > 0*), so we continue. The new parent of
    our element is at index *3/2=1*. So we compare and, if necessary, swap again:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新元素已经被交换并移动到了**3**索引。我们还没有达到堆的顶部（*3/2 > 0*），所以我们继续。我们元素的新父节点位于索引*3/2=1*。所以我们再次比较，如果需要，再次交换：
- en: '![](Images/00545df1-f14c-4d8b-8d93-5120d5ab74d9.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/00545df1-f14c-4d8b-8d93-5120d5ab74d9.png)'
- en: 'After the final swap, we are left with a heap that looks as follows. Notice
    that it adheres to the definition of a heap:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最终交换后，我们得到了一个堆，如下所示。请注意，它符合堆的定义：
- en: '![](Images/53fadd7f-0c58-43a7-bdc3-f8ef93057166.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/53fadd7f-0c58-43a7-bdc3-f8ef93057166.png)'
- en: 'Here is the implementation of `arrange()` method after we insert an element
    into the min-heap:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向最小堆插入元素后，这是`arrange()`方法的实现：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We are going to loop until we have reached the root node, so that we can keep
    arranging the element up as high as it needs to go. Since we are using integer
    division, as soon as we get below `2`, the loop will break out:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将循环直到达到根节点，这样我们就可以将元素安排到需要到达的最高位置。由于我们使用整数除法，一旦小于`2`，循环就会中断：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Compare between the parent and child. If the parent is greater than the child,
    swap the two values:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 比较父节点和子节点。如果父节点大于子节点，则交换两个值：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, let''s not forget to move up the tree:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不要忘记向上移动树：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method ensures that the elements are ordered properly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法确保元素被正确排序。
- en: 'Now, we just need to call this from our `insert` method:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要从我们的`insert`方法中调用这个方法：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that the last line in `insert` calls the `arrange()` method to reorganize
    the heap as necessary.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`insert`中的最后一行调用`arrange()`方法来根据需要重新组织堆。
- en: Pop operation
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹出操作
- en: The `pop` operation removes an element from the heap. The reason for removing
    an element from the min-heap is, first, to find out the index of the item to be
    deleted, and then organize the heap so that it satisfies the heap property. However,
    it is more common to pop off the minimum value from the min-heap, and as per the
    property of the min-heap, we can get the minimum value by its root value. Therefore,
    to obtain and remove the minimum value from the min-heap, we remove the root node
    and re-organize all the nodes of the heap. We also decrement the size of the heap
    by one.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop`操作从堆中移除一个元素。从最小堆中移除元素的原因是，首先找出要删除的项目的索引，然后组织堆以满足堆属性。然而，更常见的是从最小堆中弹出最小值，并根据最小堆的属性，我们可以通过其根值获得最小值。因此，为了获取并从最小堆中删除最小值，我们移除根节点并重新组织堆的所有节点。我们还将堆的大小减少一。'
- en: However, once the root has been popped off, we need a new root node. For this,
    we just take the last item from the list and make it the new root. That is, we
    move it to the beginning of the list. However, the selected last node might not
    be the lowest element of the heap, so we have to reorganize the nodes of the heap.
    To structure all the nodes according to the min-heap property, we follow a strategy
    that is opposite to the `arrange()` method that we used while inserting an element
    into the heap. We make the last node a new root, and then we let it move down
    (or sink down) as required.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦根节点被弹出，我们就需要一个新的根节点。为此，我们只需取出列表中的最后一个项目，并将其作为新的根。也就是说，我们将它移动到列表的开头。然而，所选的最后一个节点可能不是堆中最小的元素，因此我们需要重新组织堆的节点。为了根据最小堆属性对所有节点进行结构化，我们遵循了与插入元素时使用的`arrange()`方法相反的策略。我们将最后一个节点作为新的根，然后让它根据需要向下移动（或下沉）。
- en: 'Let''s consider an example to help understand this concept in the following
    heap. First, we pop off the `root` element:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来帮助理解这个概念。首先，我们弹出`root`元素：
- en: '![](Images/ea6a7355-42dc-44ce-b906-c8a74c6c2856.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ea6a7355-42dc-44ce-b906-c8a74c6c2856.png)'
- en: 'If we choose to move up one of the children of the root, we will have to figure
    out how to rebalance the entire tree structure, which would have been more complex.
    So, instead, we do something really interesting. We move up the very last element
    in the list to fill the position of the `root` element; for example, the last
    element, **6**, is placed at the root position in the following heap example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择移动根的一个子节点，我们将不得不弄清楚如何重新平衡整个树结构，这将更加复杂。因此，我们做一些非常有趣的事情。我们将列表中的最后一个元素移动到`root`元素的位置上；例如，在下面的堆示例中，最后一个元素**6**被放置在根位置上：
- en: '![](Images/7e7ff95f-1917-4ab7-9a1f-4f2a2d53dbe6.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7e7ff95f-1917-4ab7-9a1f-4f2a2d53dbe6.png)'
- en: 'Now, this element is clearly not the lowest in the heap. So, we have to sink
    it down in the heap. Firstly, we need to determine whether to sink it down toward either the
    left or right child. We compare the two children, so that the lowest element will
    be the one to move up as the root sinks down. In the example, we compare the two
    children of the root, that is, **5** and **3**:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个元素显然不是堆中最小的。因此，我们需要将它下沉到堆中。首先，我们需要确定是向左还是向右子节点下沉。我们比较两个子节点，以便最小的元素将作为根下沉。在这个例子中，我们比较了根的两个子节点，即**5**和**3**：
- en: '![](Images/1d633f27-44e6-47c9-acfb-7ccb19717cb0.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1d633f27-44e6-47c9-acfb-7ccb19717cb0.png)'
- en: 'The right child is clearly smaller: its index is **3**, which represents *root
    index * 2 + 1*. We go ahead and compare our new root node with the value at this
    index, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 右子节点显然更小：它的索引是**3**，表示*根索引* 2 + 1*。我们继续将我们的新根节点与该索引处的值进行比较，如下所示：
- en: '![](Images/bc3c7d19-1995-4618-9569-e595be98aacc.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bc3c7d19-1995-4618-9569-e595be98aacc.png)'
- en: 'Now our node has moved down to index **3**. We need to compare it to the lesser
    of its children. However, now we only have one child, so we don''t need to worry
    about which child to compare it against (for a min heap, it is always the lesser
    child):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的节点已经下降到索引**3**。我们需要将其与较小的子节点进行比较。然而，现在我们只有一个子节点，所以我们不需要担心与哪个子节点进行比较（对于最小堆，它总是较小的子节点）：
- en: '![](Images/2dc6e0f7-7801-4991-b6f6-dd66f46dc674.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2dc6e0f7-7801-4991-b6f6-dd66f46dc674.png)'
- en: There is no need to swap here. Since there are no more rows, we don't need to
    do anything else. Notice here that, after the `sink()` operation is completed,
    the heap adheres to our definition of a heap.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不需要交换。由于没有更多的行，我们不需要做其他事情。请注意，在完成`sink()`操作后，堆符合我们对堆的定义。
- en: 'Now we can begin implementing this. But before we implement the `sink()` method,
    we need to note how we determine which of the children to compare against the
    parent node. Let''s put that selection in its own little method, just to make
    the code look a little simpler:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始实现这个了。但在我们实现`sink()`方法之前，我们需要注意如何确定要与父节点进行比较的子节点。让我们将选择放在自己的小方法中，这样代码看起来会简单一些：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We may get beyond the end of the list—if we do, then we return the index of
    the left child:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会超出列表的末尾——如果是这样，我们返回左子节点的索引：
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Otherwise, we simply return the index of the lesser of the two children:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们简单地返回两个子节点中较小的那个的索引：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we can create the `sink` function. As we did before, we are going to loop
    so that we can sink our element down as far as is needed:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建`sink`函数。就像以前一样，我们将循环，以便我们可以将我们的元素下沉到需要的位置：
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we need to know which of the left or the right children to compare against.
    This is where we make use of the `minindex()` function:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要知道是要与左子节点还是右子节点进行比较。这就是我们使用`minindex()`函数的地方：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As we did in the `arrange()` method during the insertion operation, we compare
    parent and child to see whether we need to make the swap:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在插入操作中的`arrange()`方法中所做的那样，我们比较父节点和子节点，看看我们是否需要进行交换：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And we need to make sure that we move down the tree, so that we don''t get
    stuck in a loop, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保向下移动树，这样我们就不会陷入循环中：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The only thing remaining now is to implement the main `pop()` method itself.
    This is very straightforward, as the grunt work is performed by the `sink()` method:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一剩下的就是实现主要的`pop()`方法本身。这非常简单，因为`sink()`方法执行了大部分工作：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Testing the heap
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试堆
- en: 'Now, let''s test the implementation of the heap, and discuss this with an example.
    We start with the construction of a heap by inserting 10 elements, one by one.
    Let the elements be `{4, 8, 7, 2, 9, 10, 5, 1, 3, 6}`. First, we manually create
    a heap with these elements, and then we will implement it and verify if we are
    doing it correctly or not:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试堆的实现，并通过一个例子来讨论。我们首先通过逐个插入10个元素来构建一个堆。让元素为`{4, 8, 7, 2, 9, 10, 5, 1,
    3, 6}`。首先，我们手动创建一个包含这些元素的堆，然后我们将实现它并验证我们是否做得正确：
- en: '![](Images/43b714fe-a272-4abf-8977-2404128f041b.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/43b714fe-a272-4abf-8977-2404128f041b.png)'
- en: 'We show, in the preceding diagram, a step-by-step process to insert elements
    in the heap. Here, we continue adding elements as shown:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们展示了一个逐步插入元素到堆中的过程。在这里，我们继续按照所示添加元素：
- en: '![](Images/f378b0d1-6ba0-4ad1-8c70-2fcd91194238.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f378b0d1-6ba0-4ad1-8c70-2fcd91194238.png)'
- en: 'Finally, we insert an element, **6**, to the heap:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们向堆中插入一个元素**6**：
- en: '![](Images/73e8a792-fa08-4fc2-97e3-26ae969442a8.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/73e8a792-fa08-4fc2-97e3-26ae969442a8.png)'
- en: 'Now, let''s begin by creating the heap and inserting that data, as shown in
    the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始创建堆并插入数据，如下所示的代码：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can print the heap list, just to inspect how the elements are ordered. If
    you redraw this as a tree structure, you would notice that it meets the required
    properties of a heap, similar to what we created manually:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印堆列表，只是为了检查元素的排序方式。如果你将其重新绘制为树结构，你会注意到它满足堆的所需属性，类似于我们手动创建的那样：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we will pop off the items, one at a time. Notice how the items come out
    in a sorted order, from lowest to highest. Also, notice how the heap list changes
    after each `pop`. The `sink()` method will reorganize all the items in the heap:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将一个一个地弹出项目。注意项目是如何按照从低到高的顺序排序出来的。同时，注意每次`pop`后堆列表是如何改变的。`sink()`方法将重新组织堆中的所有项目：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have discussed, in the preceding section, the concepts around using the min-heap,
    so it should be a simple task to implement a max-heap by simply reversing the
    logic.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们讨论了使用最小堆的概念，因此通过简单地颠倒逻辑，实现最大堆应该是一个简单的任务。
- en: We will use the min-heap that we discussed here again in [Chapter 10](3b546628-5e98-41b9-a0a8-066c907061c3.xhtml),
    *Sorting*, on sorting algorithms, and will rewrite the code for sorting the elements
    in the list. These algorithms are called heap sort algorithms.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第10章](3b546628-5e98-41b9-a0a8-066c907061c3.xhtml)中再次使用我们在这里讨论的最小堆，*排序*，关于排序算法，并将重写列表中元素的排序代码。这些算法被称为堆排序算法。
- en: Selection algorithms
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择算法
- en: Selection algorithms fall under a class of algorithms that seek to answer the
    problem of finding the `i^(th)`-smallest element in a list. When a list is sorted
    in ascending order, the first element in the list will be the smallest item in
    the list. The second element in the list will be the second-smallest element in
    the list. The last element in the list will be the least-smallest (or, largest)
    element in the list.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 选择算法属于一类算法，旨在解决在列表中找到第i个最小元素的问题。当列表按升序排序时，列表中的第一个元素将是列表中最小的项。列表中的第二个元素将是列表中第二小的元素。列表中的最后一个元素将是最小的（或最大的）元素。
- en: In creating the heap data structure, we have come to understand that a call
    to the `pop` method will return the smallest element in the min-heap. The first
    element to pop off a min heap is the smallest element in the list. Similarly,
    the seventh element to be popped off the min heap will be the seventh-smallest
    element in the list. Therefore, finding the `i^(th)`-smallest element in a list
    will require us to pop the heap i number of times. This is a very simple and efficient
    way of finding the `i^(th)`-smallest element in a list.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建堆数据结构时，我们已经了解到调用`pop`方法将返回最小堆中的最小元素。从最小堆中弹出的第一个元素是列表中的最小元素。同样，从最小堆中弹出的第七个元素将是列表中第七小的元素。因此，在列表中找到第i个最小元素将需要我们弹出堆i次。这是在列表中找到第i个最小元素的一种非常简单和高效的方法。
- en: However, in Chapter 11, *Selection Algorithms*, we will study more approaches
    to find the `i^(th)`-smallest element in a list.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在第11章，*选择算法*中，我们将学习更多寻找列表中第i个最小元素的方法。
- en: Selection algorithms have applications in filtering out noisy data, finding
    the median, smallest, and largest elements in a list, and can even be applied
    in computer chess programs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 选择算法在过滤嘈杂数据、查找列表中的中位数、最小和最大元素等方面有应用，并且甚至可以应用在计算机国际象棋程序中。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'Graphs and heaps have been discussed in this chapter. The subject of graphs
    is very important and useful for many real-world applications. We have looked
    at different ways to represent a graph in Python, using lists and dictionaries.
    In order to traverse the graph, we used two methods: BFS and DFS.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了图和堆。图的主题对于许多现实世界的应用非常重要和有用。我们已经看过了用列表和字典表示图的不同方法。为了遍历图，我们使用了两种方法：BFS和DFS。
- en: We then switched our attention to heaps and priority queues, in order to understand
    their implementation. The chapter ended with a discussion on using the concept
    of a heap to find the `i^(th)`-smallest element in a list.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们转向了堆和优先队列，以了解它们的实现。本章以使用堆的概念来查找列表中第i个最小元素的讨论结束。
- en: The next chapter will usher us into the arena of searching, and the various
    methods by which we can efficiently search for items in lists.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将引领我们进入搜索领域，以及我们可以有效搜索列表中项目的各种方法。
