["```py\nIn [ ]:\n    import math\n\n    r = 0.05\n    T = 2\n    t = T/2\n    u = 1.2\n    d = 0.8\n\n    q = (math.exp(r*t)-d)/(u-d)\nIn [ ]:\n    print('q is', q)\nOut[ ]:   \n    q is 0.6281777409400603\n```", "```py\nIn [ ]:\n    import math\n\n    \"\"\" \n    Stores common attributes of a stock option \n    \"\"\"\n    class StockOption(object):\n        def __init__(\n            self, S0, K, r=0.05, T=1, N=2, pu=0, pd=0, \n            div=0, sigma=0, is_put=False, is_am=False):\n            \"\"\"\n            Initialize the stock option base class.\n            Defaults to European call unless specified.\n\n            :param S0: initial stock price\n            :param K: strike price\n            :param r: risk-free interest rate\n            :param T: time to maturity\n            :param N: number of time steps\n            :param pu: probability at up state\n            :param pd: probability at down state\n            :param div: Dividend yield\n            :param is_put: True for a put option,\n                    False for a call option\n            :param is_am: True for an American option,\n                    False for a European option\n            \"\"\"\n            self.S0 = S0\n            self.K = K\n            self.r = r\n            self.T = T\n            self.N = max(1, N)\n            self.STs = [] # Declare the stock prices tree\n\n            \"\"\" Optional parameters used by derived classes \"\"\"\n            self.pu, self.pd = pu, pd\n            self.div = div\n            self.sigma = sigma\n            self.is_call = not is_put\n            self.is_european = not is_am\n\n        @property\n        def dt(self):\n            \"\"\" Single time step, in years \"\"\"\n            return self.T/float(self.N)\n\n        @property\n        def df(self):\n            \"\"\" The discount factor \"\"\"\n            return math.exp(-(self.r-self.div)*self.dt)  \n```", "```py\nIn [ ]:\n    import math\n    import numpy as np\n    from decimal import Decimal\n\n    \"\"\" \n    Price a European option by the binomial tree model \n    \"\"\"\n    class BinomialEuropeanOption(StockOption):\n\n        def setup_parameters(self):\n            # Required calculations for the model\n            self.M = self.N+1  # Number of terminal nodes of tree\n            self.u = 1+self.pu  # Expected value in the up state\n            self.d = 1-self.pd  # Expected value in the down state\n            self.qu = (math.exp(\n                (self.r-self.div)*self.dt)-self.d)/(self.u-self.d)\n            self.qd = 1-self.qu\n\n        def init_stock_price_tree(self):\n            # Initialize terminal price nodes to zeros\n            self.STs = np.zeros(self.M)\n\n            # Calculate expected stock prices for each node\n            for i in range(self.M):\n                self.STs[i] = self.S0 * \\\n                    (self.u**(self.N-i)) * (self.d**i)\n\n        def init_payoffs_tree(self):\n            \"\"\"\n            Returns the payoffs when the option \n            expires at terminal nodes\n            \"\"\" \n            if self.is_call:\n                return np.maximum(0, self.STs-self.K)\n            else:\n                return np.maximum(0, self.K-self.STs)\n\n        def traverse_tree(self, payoffs):\n            \"\"\"\n            Starting from the time the option expires, traverse\n            backwards and calculate discounted payoffs at each node\n            \"\"\"\n            for i in range(self.N):\n                payoffs = (payoffs[:-1]*self.qu + \n                           payoffs[1:]*self.qd)*self.df\n\n            return payoffs\n\n        def begin_tree_traversal(self):\n            payoffs = self.init_payoffs_tree()\n            return self.traverse_tree(payoffs)\n\n        def price(self):\n            \"\"\" Entry point of the pricing implementation \"\"\"\n            self.setup_parameters()\n            self.init_stock_price_tree()\n            payoffs = self.begin_tree_traversal()\n\n            # Option value converges to first node\n            return payoffs[0]\n```", "```py\nIn [ ]:\n    eu_option = BinomialEuropeanOption(\n        50, 52, r=0.05, T=2, N=2, pu=0.2, pd=0.2, is_put=True)\nIn [ ]:\n    print('European put option price is:', eu_option.price())\nOut[ ]:    \n    European put option price is: 4.1926542806038585\n```", "```py\ndef init_stock_price_tree(self):\n    # Initialize a 2D tree at T=0\n    self.STs = [np.array([self.S0])]\n\n    # Simulate the possible stock prices path\n    for i in range(self.N):\n        prev_branches = self.STs[-1]\n        st = np.concatenate(\n            (prev_branches*self.u, \n             [prev_branches[-1]*self.d]))\n        self.STs.append(st) # Add nodes at each time step\n```", "```py\ndef init_payoffs_tree(self):\n    if self.is_call:\n        return np.maximum(0, self.STs[self.N]-self.K)\n    else:\n        return np.maximum(0, self.K-self.STs[self.N])\n```", "```py\ndef check_early_exercise(self, payoffs, node):\n    if self.is_call:\n        return np.maximum(payoffs, self.STs[node] - self.K)\n    else:\n        return np.maximum(payoffs, self.K - self.STs[node])\n```", "```py\ndef traverse_tree(self, payoffs):\n    for i in reversed(range(self.N)):\n        # The payoffs from NOT exercising the option\n        payoffs = (payoffs[:-1]*self.qu + \n                   payoffs[1:]*self.qd)*self.df\n\n        # Payoffs from exercising, for American options\n        if not self.is_european:\n            payoffs = self.check_early_exercise(payoffs,i)\n\n    return payoffs\n```", "```py\nIn [ ]:\n    am_option = BinomialTreeOption(50, 52, \n        r=0.05, T=2, N=2, pu=0.2, pd=0.2, is_put=True, is_am=True)\nIn [ ]:\n    print('American put option price is:', am_option.price())\nOut[ ]:    \n    American put option price is: 5.089632474198373\n```", "```py\nIn [ ]:\n    import math\n\n    \"\"\" \n    Price an option by the binomial CRR model \n    \"\"\"\n    class BinomialCRROption(BinomialTreeOption):\n        def setup_parameters(self):\n            self.u = math.exp(self.sigma * math.sqrt(self.dt))\n            self.d = 1./self.u\n            self.qu = (math.exp((self.r-self.div)*self.dt) - \n                       self.d)/(self.u-self.d)\n            self.qd = 1-self.qu\n```", "```py\nIn [ ]:\n    eu_option = BinomialCRROption(\n        50, 52, r=0.05, T=2, N=2, sigma=0.3, is_put=True)\nIn [ ]:\n    print('European put:', eu_option.price())\nOut[ ]:\n    European put: 6.245708445206436\nIn [ ]:\n    am_option = BinomialCRROption(50, 52, \n        r=0.05, T=2, N=2, sigma=0.3, is_put=True, is_am=True)\nIn [ ]:\n    print('American put option price is:', am_option.price())\nOut[ ]:\n    American put option price is: 7.428401902704834\n```", "```py\nIn [ ]:\n    import math\n\n    \"\"\" \n    Price an option by the Leisen-Reimer tree\n    \"\"\"\n    class BinomialLROption(BinomialTreeOption):\n\n        def setup_parameters(self):\n            odd_N = self.N if (self.N%2 == 0) else (self.N+1)\n            d1 = (math.log(self.S0/self.K) +\n                  ((self.r-self.div) +\n                   (self.sigma**2)/2.)*self.T)/\\\n                (self.sigma*math.sqrt(self.T))\n            d2 = (math.log(self.S0/self.K) +\n                  ((self.r-self.div) -\n                   (self.sigma**2)/2.)*self.T)/\\\n                (self.sigma * math.sqrt(self.T))\n\n            pbar = self.pp_2_inversion(d1, odd_N)\n            self.p = self.pp_2_inversion(d2, odd_N)\n            self.u = 1/self.df * pbar/self.p\n            self.d = (1/self.df-self.p*self.u)/(1-self.p)\n            self.qu = self.p\n            self.qd = 1-self.p\n\n        def pp_2_inversion(self, z, n):\n            return .5 + math.copysign(1, z)*\\\n                math.sqrt(.25 - .25*\n                    math.exp(\n                        -((z/(n+1./3.+.1/(n+1)))**2.)*(n+1./6.)\n                    )\n                )\n```", "```py\nIn [ ]:\n    eu_option = BinomialLROption(\n        50, 52, r=0.05, T=2, N=4, sigma=0.3, is_put=True)\nIn [ ]:\n    print('European put:', eu_option.price())\nOut[ ]:      \n    European put: 5.878650106601964\nIn [ ]:\n    am_option = BinomialLROption(50, 52, \n        r=0.05, T=2, N=4, sigma=0.3, is_put=True, is_am=True)\nIn [ ]:\n    print('American put:', am_option.price())\nOut[ ]:\n    American put: 6.763641952939979\n```", "```py\nIn [ ]:\n    import numpy as np\n\n    \"\"\" \n    Compute option price, delta and gamma by the LR tree \n    \"\"\"\n    class BinomialLRWithGreeks(BinomialLROption):\n\n        def new_stock_price_tree(self):\n            \"\"\"\n            Creates an additional layer of nodes to our\n            original stock price tree\n            \"\"\"\n            self.STs = [np.array([self.S0*self.u/self.d,\n                                  self.S0,\n                                  self.S0*self.d/self.u])]\n\n            for i in range(self.N):\n                prev_branches = self.STs[-1]\n                st = np.concatenate((prev_branches*self.u,\n                                     [prev_branches[-1]*self.d]))\n                self.STs.append(st)\n\n        def price(self):\n            self.setup_parameters()\n            self.new_stock_price_tree()\n            payoffs = self.begin_tree_traversal()\n\n            # Option value is now in the middle node at t=0\n            option_value = payoffs[len(payoffs)//2]\n\n            payoff_up = payoffs[0]\n            payoff_down = payoffs[-1]\n            S_up = self.STs[0][0]\n            S_down = self.STs[0][-1]\n            dS_up = S_up - self.S0\n            dS_down = self.S0 - S_down\n\n            # Calculate delta value\n            dS = S_up - S_down\n            dV = payoff_up - payoff_down\n            delta = dV/dS\n\n            # calculate gamma value\n            gamma = ((payoff_up-option_value)/dS_up - \n                     (option_value-payoff_down)/dS_down) / \\\n                ((self.S0+S_up)/2\\. - (self.S0+S_down)/2.)\n\n            return option_value, delta, gamma\n\n```", "```py\nIn [ ]:\n    eu_call = BinomialLRWithGreeks(50, 52, r=0.05, T=2, N=300, sigma=0.3)\n    results = eu_call.price()\nIn [ ]:\n    print('European call values')\n    print('Price: %s\\nDelta: %s\\nGamma: %s' % results)\nOut[ ]:\n    European call values\n    Price: 9.69546807138366\n    Delta: 0.6392477816643529\n    Gamma: 0.01764795890533088\n\nIn [ ]:\n    eu_put = BinomialLRWithGreeks(\n        50, 52, r=0.05, T=2, N=300, sigma=0.3, is_put=True)\n    results = eu_put.price()\nIn [ ]:\n    print('European put values')\n    print('Price: %s\\nDelta: %s\\nGamma: %s' % results)\nOut[ ]:   \n    European put values\n    Price: 6.747013809252746\n    Delta: -0.3607522183356649\n    Gamma: 0.0176479589053312\n```", "```py\ndef setup_parameters(self):\n    \"\"\" Required calculations for the model \"\"\"\n    self.u = math.exp(self.sigma*math.sqrt(2.*self.dt))\n    self.d = 1/self.u\n    self.m = 1\n    self.qu = ((math.exp((self.r-self.div) *\n                         self.dt/2.) -\n                math.exp(-self.sigma *\n                         math.sqrt(self.dt/2.))) /\n               (math.exp(self.sigma *\n                         math.sqrt(self.dt/2.)) -\n                math.exp(-self.sigma *\n                         math.sqrt(self.dt/2.))))**2\n    self.qd = ((math.exp(self.sigma *\n                         math.sqrt(self.dt/2.)) -\n                math.exp((self.r-self.div) *\n                         self.dt/2.)) /\n               (math.exp(self.sigma *\n                         math.sqrt(self.dt/2.)) -\n                math.exp(-self.sigma *\n                         math.sqrt(self.dt/2.))))**2.\n\n    self.qm = 1 - self.qu - self.qd\n```", "```py\ndef init_stock_price_tree(self):\n    # Initialize a 2D tree at t=0\n    self.STs = [np.array([self.S0])]\n\n    for i in range(self.N):\n        prev_nodes = self.STs[-1]\n        self.ST = np.concatenate(\n            (prev_nodes*self.u, [prev_nodes[-1]*self.m,\n                                 prev_nodes[-1]*self.d]))\n        self.STs.append(self.ST)\n```", "```py\ndef traverse_tree(self, payoffs):\n    # Traverse the tree backwards \n    for i in reversed(range(self.N)):\n        payoffs = (payoffs[:-2] * self.qu +\n                   payoffs[1:-1] * self.qm +\n                   payoffs[2:] * self.qd) * self.df\n\n        if not self.is_european:\n            payoffs = self.check_early_exercise(payoffs,i)\n\n    return payoffs\n```", "```py\nIn [ ]:\n   eu_put = TrinomialTreeOption(\n        50, 52, r=0.05, T=2, N=2, sigma=0.3, is_put=True)\nIn [ ]:\n   print('European put:', eu_put.price())\nOut[ ]:\n   European put: 6.573565269142496\nIn [ ]:\n   am_option = TrinomialTreeOption(50, 52, \n        r=0.05, T=2, N=2, sigma=0.3, is_put=True, is_am=True)\nIn [ ]:\n   print('American put:', am_option.price())\nOut[ ]:\n   American put: 7.161349217272585\n```", "```py\nIn [ ]:\n    import numpy as np\n\n    class BinomialCRRLattice(BinomialCRROption):\n\n        def setup_parameters(self):\n            super(BinomialCRRLattice, self).setup_parameters()\n            self.M = 2*self.N + 1\n\n        def init_stock_price_tree(self):\n            self.STs = np.zeros(self.M)\n            self.STs[0] = self.S0 * self.u**self.N\n\n            for i in range(self.M)[1:]:\n                self.STs[i] = self.STs[i-1]*self.d\n\n        def init_payoffs_tree(self):\n            odd_nodes = self.STs[::2]  # Take odd nodes only\n            if self.is_call:\n                return np.maximum(0, odd_nodes-self.K)\n            else:\n                return np.maximum(0, self.K-odd_nodes)\n\n        def check_early_exercise(self, payoffs, node):\n            self.STs = self.STs[1:-1]  # Shorten ends of the list\n            odd_STs = self.STs[::2]  # Take odd nodes only\n            if self.is_call:\n                return np.maximum(payoffs, odd_STs-self.K)\n            else:\n                return np.maximum(payoffs, self.K-odd_STs)\n```", "```py\nIn [ ]:\n    eu_option = BinomialCRRLattice(\n        50, 52, r=0.05, T=2, N=2, sigma=0.3, is_put=True)\nIn [ ] :\n    print('European put:', eu_option.price())\nOut[ ]:  European put: 6.245708445206432\nIn [ ]:\n    am_option = BinomialCRRLattice(50, 52, \n        r=0.05, T=2, N=2, sigma=0.3, is_put=True, is_am=True)\nIn [ ] :\n    print(\"American put:\", am_option.price())\nOut[ ]:   \n    American put: 7.428401902704828\n```", "```py\nIn [ ]:\n    import numpy as np\n\n    \"\"\" \n    Price an option by the trinomial lattice \n    \"\"\"\n    class TrinomialLattice(TrinomialTreeOption):\n\n        def setup_parameters(self):\n            super(TrinomialLattice, self).setup_parameters()\n            self.M = 2*self.N + 1\n\n        def init_stock_price_tree(self):\n            self.STs = np.zeros(self.M)\n            self.STs[0] = self.S0 * self.u**self.N\n\n            for i in range(self.M)[1:]:\n                self.STs[i] = self.STs[i-1]*self.d\n\n        def init_payoffs_tree(self):\n            if self.is_call:\n                return np.maximum(0, self.STs-self.K)\n            else:\n                return np.maximum(0, self.K-self.STs)\n\n        def check_early_exercise(self, payoffs, node):\n            self.STs = self.STs[1:-1]  # Shorten ends of the list\n            if self.is_call:\n                return np.maximum(payoffs, self.STs-self.K)\n            else:\n                return np.maximum(payoffs, self.K-self.STs)\n```", "```py\nIn [ ]:\n    eu_option = TrinomialLattice(\n        50, 52, r=0.05, T=2, N=2, sigma=0.3, is_put=True)\n    print('European put:', eu_option.price())\nOut[ ]:\n    European put: 6.573565269142496\nIn [ ]:\n    am_option = TrinomialLattice(50, 52, \n        r=0.05, T=2, N=2, sigma=0.3, is_put=True, is_am=True)\n    print('American put:', am_option.price())\nOut[ ]:\n    American put: 7.161349217272585\n```", "```py\nIn [ ]:\n    from abc import ABC, abstractmethod\n    import numpy as np\n\n    \"\"\" \n    Base class for sharing \n    attributes and functions of FD \n    \"\"\"\n    class FiniteDifferences(object):\n\n        def __init__(\n            self, S0, K, r=0.05, T=1, \n            sigma=0, Smax=1, M=1, N=1, is_put=False\n        ):\n            self.S0 = S0\n            self.K = K\n            self.r = r\n            self.T = T\n            self.sigma = sigma\n            self.Smax = Smax\n            self.M, self.N = M, N\n            self.is_call = not is_put\n\n            self.i_values = np.arange(self.M)\n            self.j_values = np.arange(self.N)\n            self.grid = np.zeros(shape=(self.M+1, self.N+1))\n            self.boundary_conds = np.linspace(0, Smax, self.M+1)\n\n        @abstractmethod\n        def setup_boundary_conditions(self):\n            raise NotImplementedError('Implementation required!')\n\n        @abstractmethod\n        def setup_coefficients(self):\n            raise NotImplementedError('Implementation required!')\n\n        @abstractmethod\n        def traverse_grid(self):\n            \"\"\"  Iterate the grid backwards in time\"\"\"\n            raise NotImplementedError('Implementation required!')\n\n        @abstractmethod\n        def interpolate(self):\n            \"\"\" Use piecewise linear interpolation on the initial\n            grid column to get the closest price at S0.\n            \"\"\"\n            return np.interp(\n                self.S0, self.boundary_conds, self.grid[:,0])\n```", "```py\n@property\ndef dS(self):\n    return self.Smax/float(self.M)\n\n@property\ndef dt(self):\n    return self.T/float(self.N)\n```", "```py\ndef price(self):\n    self.setup_boundary_conditions()\n    self.setup_coefficients()\n    self.traverse_grid()\n    return self.interpolate()\n```", "```py\nIn [ ]:\n    import numpy as np\n\n    \"\"\" \n    Explicit method of Finite Differences \n    \"\"\"\n    class FDExplicitEu(FiniteDifferences):\n\n        def setup_boundary_conditions(self):\n            if self.is_call:\n                self.grid[:,-1] = np.maximum(\n                    0, self.boundary_conds - self.K)\n                self.grid[-1,:-1] = (self.Smax-self.K) * \\\n                    np.exp(-self.r*self.dt*(self.N-self.j_values))\n            else:\n                self.grid[:,-1] = np.maximum(\n                    0, self.K-self.boundary_conds)\n                self.grid[0,:-1] = (self.K-self.Smax) * \\\n                    np.exp(-self.r*self.dt*(self.N-self.j_values))\n\n        def setup_coefficients(self):\n            self.a = 0.5*self.dt*((self.sigma**2) *\n                                  (self.i_values**2) -\n                                  self.r*self.i_values)\n            self.b = 1 - self.dt*((self.sigma**2) *\n                                  (self.i_values**2) +\n                                  self.r)\n            self.c = 0.5*self.dt*((self.sigma**2) *\n                                  (self.i_values**2) +\n                                  self.r*self.i_values)\n\n        def traverse_grid(self):\n            for j in reversed(self.j_values):\n                for i in range(self.M)[2:]:\n                    self.grid[i,j] = \\\n                        self.a[i]*self.grid[i-1,j+1] +\\\n                        self.b[i]*self.grid[i,j+1] + \\\n                        self.c[i]*self.grid[i+1,j+1]\n```", "```py\nIn [ ]:\n    option = FDExplicitEu(50, 50, r=0.1, T=5./12., \n        sigma=0.4, Smax=100, M=100, N=1000, is_put=True)\n    print(option.price())\nOut[ ]:\n    4.072882278148043\n```", "```py\nIn [ ]:\n    option = FDExplicitEu(50, 50, r=0.1, T=5./12., \n        sigma=0.4, Smax=100, M=80, N=100, is_put=True)\n    print(option.price())\nOut[ ]:   \n    -8.109445694129245e+35\n```", "```py\nIn [ ]:\n    import numpy as np\n    import scipy.linalg as linalg\n\n    \"\"\" \n    Explicit method of Finite Differences \n    \"\"\"\n    class FDImplicitEu(FDExplicitEu):\n\n        def setup_coefficients(self):\n            self.a = 0.5*(self.r*self.dt*self.i_values -\n                          (self.sigma**2)*self.dt*\\\n                              (self.i_values**2))\n            self.b = 1 + \\\n                     (self.sigma**2)*self.dt*\\\n                        (self.i_values**2) + \\\n                    self.r*self.dt\n            self.c = -0.5*(self.r*self.dt*self.i_values +\n                           (self.sigma**2)*self.dt*\\\n                               (self.i_values**2))\n            self.coeffs = np.diag(self.a[2:self.M],-1) + \\\n                          np.diag(self.b[1:self.M]) + \\\n                          np.diag(self.c[1:self.M-1],1)\n\n        def traverse_grid(self):\n            \"\"\" Solve using linear systems of equations \"\"\"\n            P, L, U = linalg.lu(self.coeffs)\n            aux = np.zeros(self.M-1)\n\n            for j in reversed(range(self.N)):\n                aux[0] = np.dot(-self.a[1], self.grid[0, j])\n                x1 = linalg.solve(L, self.grid[1:self.M, j+1]+aux)\n                x2 = linalg.solve(U, x1)\n                self.grid[1:self.M, j] = x2\n```", "```py\nIn [ ]:\n    option = FDImplicitEu(50, 50, r=0.1, T=5./12., \n        sigma=0.4, Smax=100, M=100, N=1000, is_put=True)\n    print(option.price())\nOut[ ]:\n    4.071594188049893\nIn [ ]:\n    option = FDImplicitEu(50, 50, r=0.1, T=5./12., \n        sigma=0.4, Smax=100, M=80, N=100, is_put=True)\n    print(option.price())\nOut[ ]:\n    4.063684691731647\n```", "```py\nIn [ ]:\n    import numpy as np\n    import scipy.linalg as linalg\n\n    \"\"\" \n    Crank-Nicolson method of Finite Differences \n    \"\"\"\n    class FDCnEu(FDExplicitEu):\n\n        def setup_coefficients(self):\n            self.alpha = 0.25*self.dt*(\n                (self.sigma**2)*(self.i_values**2) - \\\n                self.r*self.i_values)\n            self.beta = -self.dt*0.5*(\n                (self.sigma**2)*(self.i_values**2) + self.r)\n            self.gamma = 0.25*self.dt*(\n                (self.sigma**2)*(self.i_values**2) +\n                self.r*self.i_values)\n            self.M1 = -np.diag(self.alpha[2:self.M], -1) + \\\n                      np.diag(1-self.beta[1:self.M]) - \\\n                      np.diag(self.gamma[1:self.M-1], 1)\n            self.M2 = np.diag(self.alpha[2:self.M], -1) + \\\n                      np.diag(1+self.beta[1:self.M]) + \\\n                      np.diag(self.gamma[1:self.M-1], 1)\n\n        def traverse_grid(self):\n            \"\"\" Solve using linear systems of equations \"\"\"\n            P, L, U = linalg.lu(self.M1)\n\n            for j in reversed(range(self.N)):\n                x1 = linalg.solve(\n                    L, np.dot(self.M2, self.grid[1:self.M, j+1]))\n                x2 = linalg.solve(U, x1)\n                self.grid[1:self.M, j] = x2\n```", "```py\nIn [ ]:\n    option = FDCnEu(50, 50, r=0.1, T=5./12.,\n        sigma=0.4, Smax=100, M=100, N=1000, is_put=True)\n    print(option.price())\nOut[ ]:   \n    4.072238354486825\nIn [ ]:\n    option = FDCnEu(50, 50, r=0.1, T=5./12., \n        sigma=0.4, Smax=100, M=80, N=100, is_put=True)\n    print(option.price())\nOut[ ]: \n    4.070145703042843\n```", "```py\nIn [ ]:\n    import numpy as np\n\n    \"\"\"\n    Price a down-and-out option by the Crank-Nicolson\n    method of finite differences.\n    \"\"\"\n    class FDCnDo(FDCnEu):\n\n        def __init__(\n            self, S0, K, r=0.05, T=1, sigma=0, \n            Sbarrier=0, Smax=1, M=1, N=1, is_put=False\n        ):\n            super(FDCnDo, self).__init__(\n                S0, K, r=r, T=T, sigma=sigma,\n                Smax=Smax, M=M, N=N, is_put=is_put\n            )\n            self.barrier = Sbarrier\n            self.boundary_conds = np.linspace(Sbarrier, Smax, M+1)\n            self.i_values = self.boundary_conds/self.dS\n\n        @property\n        def dS(self):\n            return (self.Smax-self.barrier)/float(self.M)\n```", "```py\nIn [ ]:\n    option = FDCnDo(50, 50, r=0.1, T=5./12., \n        sigma=0.4, Sbarrier=40, Smax=100, M=120, N=500)\n    print(option.price())\nOut[ ]:   \n    5.491560552934787\nIn [ ]:\n    option = FDCnDo(50, 50, r=0.1, T=5./12., sigma=0.4, \n        Sbarrier=40, Smax=100, M=120, N=500, is_put=True)\n    print(option.price())\nOut[ ]:\n   0.5413635028954452\n```", "```py\nIn [ ]:\n    import numpy as np\n    import sys\n\n    \"\"\" \n    Price an American option by the Crank-Nicolson method \n    \"\"\"\n    class FDCnAm(FDCnEu):\n\n        def __init__(self, S0, K, r=0.05, T=1, \n                Smax=1, M=1, N=1, omega=1, tol=0, is_put=False):\n            super(FDCnAm, self).__init__(S0, K, r=r, T=T, \n                sigma=sigma, Smax=Smax, M=M, N=N, is_put=is_put)\n            self.omega = omega\n            self.tol = tol\n            self.i_values = np.arange(self.M+1)\n            self.j_values = np.arange(self.N+1)\n\n        def setup_boundary_conditions(self):\n            if self.is_call:\n                self.payoffs = np.maximum(0, \n                    self.boundary_conds[1:self.M]-self.K)\n            else:\n                self.payoffs = np.maximum(0, \n                    self.K-self.boundary_conds[1:self.M])\n\n            self.past_values = self.payoffs\n            self.boundary_values = self.K * np.exp(\n                    -self.r*self.dt*(self.N-self.j_values))\n```", "```py\ndef traverse_grid(self):\n    \"\"\" Solve using linear systems of equations \"\"\"\n    aux = np.zeros(self.M-1)\n    new_values = np.zeros(self.M-1)\n\n    for j in reversed(range(self.N)):\n        aux[0] = self.alpha[1]*(self.boundary_values[j] +\n                                self.boundary_values[j+1])\n        rhs = np.dot(self.M2, self.past_values) + aux\n        old_values = np.copy(self.past_values)\n        error = sys.float_info.max\n\n        while self.tol < error:\n            new_values[0] = \\\n                self.calculate_payoff_start_boundary(\n                    rhs, old_values)    \n\n            for k in range(self.M-2)[1:]:\n                new_values[k] = \\\n                    self.calculate_payoff(\n                        k, rhs, old_values, new_values)                  \n\n            new_values[-1] = \\\n                self.calculate_payoff_end_boundary(\n                    rhs, old_values, new_values)\n\n            error = np.linalg.norm(new_values-old_values)\n            old_values = np.copy(new_values)\n\n        self.past_values = np.copy(new_values)\n\n    self.values = np.concatenate(\n        ([self.boundary_values[0]], new_values, [0]))\n```", "```py\n def calculate_payoff_start_boundary(self, rhs, old_values):\n    payoff = old_values[0] + \\\n        self.omega/(1-self.beta[1]) * \\\n            (rhs[0] - \\\n             (1-self.beta[1])*old_values[0] + \\\n             self.gamma[1]*old_values[1])\n\n    return max(self.payoffs[0], payoff)       \n```", "```py\n def calculate_payoff_end_boundary(self, rhs, old_values, new_values):\n    payoff = old_values[-1] + \\\n        self.omega/(1-self.beta[-2]) * \\\n            (rhs[-1] + \\\n             self.alpha[-2]*new_values[-2] - \\\n             (1-self.beta[-2])*old_values[-1])\n\n    return max(self.payoffs[-1], payoff)\n```", "```py\ndef calculate_payoff(self, k, rhs, old_values, new_values):\n    payoff = old_values[k] + \\\n        self.omega/(1-self.beta[k+1]) * \\\n            (rhs[k] + \\\n             self.alpha[k+1]*new_values[k-1] - \\\n             (1-self.beta[k+1])*old_values[k] + \\\n             self.gamma[k+1]*old_values[k+1])\n\n    return max(self.payoffs[k], payoff)\n```", "```py\ndef interpolate(self):\n    # Use linear interpolation on final values as 1D array\n    return np.interp(self.S0, self.boundary_conds, self.values)\n```", "```py\nIn [ ]:\n    option = FDCnAm(50, 50, r=0.1, T=5./12., \n        sigma=0.4, Smax=100, M=100, N=42, omega=1.2, tol=0.001)\n    print(option.price())\nOut[ ]:\n    6.108682815392217\nIn [ ]:\n    option = FDCnAm(50, 50, r=0.1, T=5./12., sigma=0.4, Smax=100, \n        M=100, N=42, omega=1.2, tol=0.001, is_put=True)\n    print(option.price())\nOut[ ]:   \n    4.277764229383736\n```", "```py\nIn [ ]:\n    \"\"\"\n    Get implied volatilities from a Leisen-Reimer binomial\n    tree using the bisection method as the numerical procedure.\n    \"\"\"\n    class ImpliedVolatilityModel(object):\n\n        def __init__(self, S0, r=0.05, T=1, div=0, \n                     N=1, is_put=False):\n            self.S0 = S0\n            self.r = r\n            self.T = T\n            self.div = div\n            self.N = N\n            self.is_put = is_put\n\n        def option_valuation(self, K, sigma):\n            \"\"\" Use the binomial Leisen-Reimer tree \"\"\"\n            lr_option = BinomialLROption(\n                self.S0, K, r=self.r, T=self.T, N=self.N, \n                sigma=sigma, div=self.div, is_put=self.is_put\n            )\n            return lr_option.price()\n\n        def get_implied_volatilities(self, Ks, opt_prices):\n            impvols = []\n            for i in range(len(strikes)):\n                # Bind f(sigma) for use by the bisection method\n                f = lambda sigma: \\\n                    self.option_valuation(Ks[i], sigma)-\\\n                    opt_prices[i]\n                impv = bisection(f, 0.01, 0.99, 0.0001, 100)[0]\n                impvols.append(impv)\n\n            return impvols\n\n```", "```py\nIn [ ]:\n    def bisection(f, a, b, tol=0.1, maxiter=10):\n        \"\"\"\n        :param f: The function to solve\n        :param a: The x-axis value where f(a)<0\n        :param b: The x-axis value where f(b)>0\n        :param tol: The precision of the solution\n        :param maxiter: Maximum number of iterations\n        :return: The x-axis value of the root,\n                    number of iterations used\n        \"\"\"\n        c = (a+b)*0.5  # Declare c as the midpoint ab\n        n = 1  # Start with 1 iteration\n        while n <= maxiter:\n            c = (a+b)*0.5\n            if f(c) == 0 or abs(a-b)*0.5 < tol:\n                # Root is found or is very close\n                return c, n\n\n            n += 1\n            if f(c) < 0:\n                a = c\n            else:\n                b = c\n\n        return c, n\n```", "```py\nIn [ ]:\n    strikes = [75, 80, 85, 90, 92.5, 95, 97.5, \n               100, 105, 110, 115, 120, 125]\n    put_prices = [0.16, 0.32, 0.6, 1.22, 1.77, 2.54, 3.55, \n                  4.8, 7.75, 11.8, 15.96, 20.75, 25.81]\nIn [ ]:\n    model = ImpliedVolatilityModel(\n        99.62, r=0.0248, T=78/365., div=0.0182, N=77, is_put=True)\n    impvols_put = model.get_implied_volatilities(strikes, put_prices)\n```", "```py\nIn [ ]:\n    %matplotlib inline\n    import matplotlib.pyplot as plt\n\n    plt.plot(strikes, impvols_put)\n    plt.xlabel('Strike Prices')\n    plt.ylabel('Implied Volatilities')\n    plt.title('AAPL Put Implied Volatilities expiring in 78 days')\n    plt.show()\n```"]