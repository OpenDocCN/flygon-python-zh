# Python的初步介绍

“授人以鱼不如授人以渔。”- 中国谚语

根据维基百科的说法，**计算机编程**是：

“...从计算问题的原始表述到可执行的计算机程序的过程。编程涉及活动，如分析，开发理解，生成算法，验证算法的要求，包括它们的正确性和资源消耗，以及在目标编程语言中实现（通常称为编码）算法。”

简而言之，编码就是用计算机能理解的语言告诉计算机做某事。

计算机是非常强大的工具，但不幸的是，它们无法自行思考。它们需要被告知一切：如何执行任务，如何评估条件以决定要遵循哪条路径，如何处理来自设备的数据，比如网络或磁盘，以及在发生意外情况时如何做出反应，比如，某物坏了或丢失了。

你可以用许多不同的风格和语言编写代码。难吗？我会说*是*和*不是*。这有点像写作。每个人都可以学会写作，你也可以。但是，如果你想成为一名诗人呢？那么仅仅写作是不够的。你必须获得一整套其他技能，这需要更长时间和更大的努力。

最终，一切都取决于你想走多远。编码不仅仅是将一些有效的指令组合在一起。它远不止如此！

良好的代码是简短、快速、优雅、易于阅读和理解、简单、易于修改和扩展、易于扩展和重构、易于测试。要能够同时具备所有这些品质的代码需要时间，但好消息是，通过阅读这本书，你正在迈出迈向这个目标的第一步。我毫无疑问你能做到。任何人都可以；事实上，我们都在不知不觉中一直在编程。

你想要一个例子吗？

假设你想泡速溶咖啡。你需要准备一个杯子，速溶咖啡罐，一把茶匙，水和水壶。即使你没有意识到，你正在评估大量的数据。你要确保水壶里有水，水壶已插好电，杯子干净，并且咖啡罐里有足够的咖啡。然后，你烧开水，也许在此期间，你把一些咖啡放进杯子里。当水准备好时，你把它倒进杯子里，然后搅拌。

那么，这就是编程吗？

好吧，我们收集了资源（水壶，咖啡，水，茶匙和杯子），并验证了一些关于它们的条件（水壶已插好电，杯子干净，并且有足够的咖啡）。然后我们开始了两个动作（烧水和把咖啡放进杯子里），当它们都完成时，我们最终通过把水倒进杯子里并搅拌来结束了这个过程。

你能看到吗？我刚刚描述了一个咖啡程序的高级功能。这并不难，因为这就是大脑整天在做的事情：评估条件，决定采取行动，执行任务，重复其中一些，并在某个时候停下来。清理物品，把它们放回去，等等。

现在你需要学会如何分解你在现实生活中自动完成的所有这些动作，以便计算机实际上能够理解它们。而且你还需要学习一种语言，来指导它。

所以这本书就是为此而写的。我会告诉你如何做，我会尝试通过许多简单但专注的例子来做到这一点（这是我最喜欢的一种）。

在这一章中，我们将涵盖以下内容：

+   Python的特点和生态系统

+   关于如何开始并运行Python和虚拟环境的指南

+   如何运行Python程序

+   如何组织Python代码和Python的执行模型

# 一个合适的介绍

我喜欢在教编码时引用现实世界；我相信这有助于人们更好地理解概念。然而，现在是时候更严谨地从技术角度看待编码是什么了。

当我们编写代码时，我们在指示计算机要做的事情。行动发生在哪里？在很多地方：计算机内存、硬盘、网络电缆、CPU等等。这是一个完整的*世界*，大部分时间是真实世界的一个子集的表示。

如果你写了一个允许人们在线购买服装的软件，你将不得不在程序的范围内代表真实的人、真实的服装、真实的品牌、尺寸等等。

为了做到这一点，你需要在你编写的程序中创建和处理对象。一个人可以是一个对象。一辆车是一个对象。一双袜子是一个对象。幸运的是，Python非常了解对象。

任何对象具有的两个主要特征是属性和方法。让我们以一个人的对象为例。在计算机程序中，你通常将人表示为顾客或员工。你存储在他们身上的属性是姓名、社会安全号码、年龄、是否有驾照、电子邮件、性别等等。在计算机程序中，你存储了所有你需要的数据，以便使用对象来服务你的目的。如果你正在编写一个销售服装的网站，你可能还想存储顾客的身高、体重以及其他尺寸，以便为他们推荐合适的服装。因此，属性是对象的特征。我们经常使用它们：*你能把那支笔递给我吗？*—*哪一支？*—*黑色的那支*。在这里，我们使用了笔的*黑色*属性来识别它（很可能是在蓝色和红色中）。

方法是对象可以做的事情。作为一个人，我有诸如*说话*、*走路*、*睡觉*、*醒来*、*吃饭*、*做梦*、*写*、*读*等方法。我能做的所有事情都可以看作是代表我的对象的方法。

现在你知道了对象是什么，它们公开了可以运行的方法和可以检查的属性，你已经准备好开始编码了。实际上，编码就是简单地管理我们在软件中再现的世界子集中的那些对象。你可以随意创建、使用、重用和删除对象。

根据官方Python文档的*数据模型*章节（[https://docs.python.org/3/reference/datamodel.html](https://docs.python.org/3/reference/datamodel.html)）：

“对象是Python对数据的抽象。Python程序中的所有数据都由对象或对象之间的关系表示。”

我们将在后面的章节中更仔细地看Python对象。目前，我们需要知道的是Python中的每个对象都有一个ID（或身份）、一个类型和一个值。

一旦创建，对象的ID就永远不会改变。这是它的唯一标识符，并且在幕后被Python用来在我们想要使用它时检索对象。

类型也永远不会改变。类型告诉对象支持哪些操作以及可以分配给它的可能值。

我们将在[第2章](c8b5469e-e120-49c2-95ec-cc3caae33027.xhtml)中看到Python最重要的数据类型，*内置数据类型*。

值可以改变，也可以不改变。如果可以改变，对象被称为**可变**，而当它不能改变时，对象被称为**不可变**。

我们如何使用一个对象？当然是给它一个名字！当你给一个对象一个名字，然后你可以使用这个名字来检索对象并使用它。

在更一般的意义上，诸如数字、字符串（文本）、集合等对象都与一个名称相关联。通常，我们说这个名称是变量的名称。你可以把变量看作是一个盒子，你可以用它来存储数据。

所以，你拥有了所有你需要的对象；现在呢？好吧，我们需要使用它们，对吧？我们可能想要通过网络连接发送它们，或者将它们存储在数据库中。也许在网页上显示它们，或者将它们写入文件。为了做到这一点，我们需要对用户填写表单、按下按钮、打开网页并执行搜索做出反应。我们通过运行我们的代码来做出反应，评估条件以选择执行哪些部分，多少次，以及在什么情况下。

为了做到所有这些，基本上我们需要一种语言。这就是Python的用途。在本书中，我们将一起使用Python来指导计算机为我们做一些事情。

现在，够了这些理论的东西；让我们开始吧。

# 进入Python

Python是Guido Van Rossum的奇迹创造，他是一位荷兰计算机科学家和数学家，决定在1989年圣诞节期间向世界赠送他正在玩耍的项目。这种语言大约在1991年左右出现在公众面前，从那时起，它已经发展成为全球范围内使用的主要编程语言之一。

我7岁开始编程，用的是Commodore VIC-20，后来换成了它的大哥Commodore 64。它的语言是BASIC。后来，我接触了Pascal、Assembly、C、C++、Java、JavaScript、Visual Basic、PHP、ASP、ASP .NET、C#，以及其他一些我甚至都记不起来的小语言，但直到我接触到Python，我才有了那种在商店里找到合适的沙发时的感觉。当你的所有身体部位都在喊着，“买这个！这个对我们来说完美！”

我大约花了一天时间适应它。它的语法与我习惯的有点不同，但在克服了最初的不适感之后（就像穿上新鞋一样），我就深深地爱上了它。让我们看看为什么。

# 关于Python

在我们深入了解细节之前，让我们了解一下为什么有人会想要使用Python（我建议你阅读维基百科上的Python页面，以获得更详细的介绍）。

在我看来，Python体现了以下特质。

# 可移植性

Python可以在任何地方运行，将程序从Linux移植到Windows或Mac通常只是修复路径和设置的问题。Python被设计用于可移植性，并且它会处理特定操作系统（OS）的怪癖，这些接口会让你免于编写针对特定平台的代码的痛苦。

# 连贯性

Python非常逻辑和连贯。你可以看出它是由一位杰出的计算机科学家设计的。大多数时候，如果你不知道一个方法的调用方式，你可以猜出来。

你现在可能没有意识到这一点有多重要，特别是如果你还处在起步阶段，但这是一个重要的特性。这意味着你的头脑中没有那么多杂乱，也不需要在编码时浏览文档，也不需要在大脑中进行映射。

# 开发者生产力

根据Mark Lutz（《学习Python，第5版》，O'Reilly Media）的说法，Python程序通常只有等效的Java或C++代码的五分之一到三分之一大小。这意味着工作可以更快地完成。更快是好的。更快意味着市场上更快的反应。更少的代码不仅意味着写的代码更少，而且意味着阅读的代码更少（专业程序员阅读的比写的要多得多），维护的代码更少，调试的代码更少，重构的代码更少。

另一个重要的方面是，Python可以在不需要冗长和耗时的编译和链接步骤的情况下运行，因此你不必等待看到你的工作成果。

# 一个广泛的库

Python拥有一个非常广泛的标准库（据说它是带有*内置电池*）。如果这还不够，全世界的Python社区维护着一系列第三方库，专门针对特定需求定制，你可以在**Python Package Index**（**PyPI**）上自由获取。当你编写Python代码时，你意识到你需要某个特定功能时，在大多数情况下，至少有一个库已经为你实现了该功能。

# 软件质量

Python非常注重可读性、连贯性和质量。语言的统一性使得它具有很高的可读性，这在当今编码更多是集体努力而不是个人努力的情况下至关重要。Python的另一个重要方面是其固有的多范式特性。你可以将其用作脚本语言，但也可以利用面向对象、命令式和函数式编程风格。它是多才多艺的。

# 软件集成

另一个重要的方面是Python可以扩展和集成许多其他语言，这意味着即使一家公司使用不同的语言作为他们的主流工具，Python也可以作为一个粘合剂在某种程度上连接需要相互通信的复杂应用程序。这是一个比较高级的话题，但在现实世界中，这个特性非常重要。

# 满意和享受

最后但并非最不重要的是，这很有趣！使用Python很有趣。我可以编写8小时的代码，离开办公室时感到快乐和满足，对于其他使用不提供同样数量精心设计的数据结构和构造的编码人员所遭受的挣扎毫不知情。毫无疑问，Python让编码变得有趣。而有趣则促进了动力和生产力。

# 有什么缺点吗？

也许，人们在Python中唯一可能找到的缺点（不是由于个人偏好）是它的*执行速度*。通常情况下，Python比它的编译兄弟慢。Python的标准实现在运行应用程序时会生成源代码的编译版本，称为字节码（扩展名为`.pyc`），然后由Python解释器运行。这种方法的优势是可移植性，但由于Python没有像其他语言那样编译到机器级别，我们需要付出减速的代价。

然而，Python的速度在今天很少是一个问题，因此它被广泛使用，尽管有这个次优特性。在现实生活中，硬件成本不再是一个问题，通常很容易通过并行化任务来提高速度。此外，许多程序花费大部分时间等待IO操作完成；因此，原始执行速度通常是整体性能的次要因素。不过，当涉及到大量计算时，人们可以切换到更快的Python实现，比如PyPy，通过实现先进的编译技术，它提供了平均五倍的加速（参考[http://pypy.org/](http://pypy.org/)）。

在进行数据科学时，你很可能会发现，你使用的Python库，如**Pandas**和**NumPy**，由于它们的实现方式，实现了本地速度。

如果这还不足以说服你，你可以考虑Python已被用于驱动Spotify和Instagram等服务的后端，其中性能是一个问题。尽管如此，Python已经完全胜任了它的工作。

# 今天谁在使用Python？

还不够说服？让我们简要看一下今天正在使用Python的公司：谷歌、YouTube、Dropbox、雅虎、Zope公司、工业光与魔法、华特迪士尼特效动画、Blender 3D、皮克斯、NASA、NSA、红帽、诺基亚、IBM、Netflix、Yelp、英特尔、思科、惠普、高通和摩根大通，仅举几例。

甚至像*战地2*、*文明4*和*QuArK*这样的游戏都是用Python实现的。

Python在许多不同的环境中使用，如系统编程、Web编程、GUI应用程序、游戏和机器人技术、快速原型设计、系统集成、数据科学、数据库应用等。一些知名的大学也已经将Python作为他们计算机科学课程的主要语言。

# 设置环境

在谈论如何在你的系统上安装Python之前，让我告诉你我在本书中将使用的Python版本。

# Python 2与Python 3

Python有两个主要版本：Python 2是过去，Python 3是现在。这两个版本虽然非常相似，但在某些方面是不兼容的。

在现实世界中，Python 2实际上离过去还相当遥远。简而言之，尽管Python 3自2008年以来就已经发布，但从版本2过渡到版本3的阶段仍然远未结束。这主要是因为Python 2在工业界被广泛使用，当然，公司并不急于仅仅为了更新而更新他们的系统，遵循“如果它没坏，就不要修理”的理念。你可以在网络上阅读关于这两个版本之间过渡的所有信息。

另一个妨碍过渡的问题是第三方库的可用性。通常，Python项目依赖于数十个外部库，当你开始一个新项目时，你需要确保已经有一个兼容Version-3的库来满足任何可能出现的业务需求。如果不是这样，那么在Python 3中启动一个全新的项目意味着引入潜在的风险，而许多公司并不愿意冒这种风险。

在撰写本文时，大多数最广泛使用的库已经移植到Python 3，并且对于大多数情况来说，在Python 3中启动项目是相当安全的。许多库已经重写，以便与两个版本兼容，主要利用了`six`库的功能（名称来源于2 x 3的乘法，因为从版本2到3的移植），它有助于根据使用的版本进行内省和行为调整。根据PEP 373（[https://legacy.python.org/dev/peps/pep-0373/](https://legacy.python.org/dev/peps/pep-0373/)），Python 2.7的**生命周期结束**（**EOL**）已经设定为2020年，不会有Python 2.8，因此对于在Python 2中运行项目的公司来说，现在是需要开始制定升级策略并在太迟之前转移到Python 3的时候了。

在我的电脑上（MacBook Pro），这是我拥有的最新Python版本：

```py
>>> import sys
>>> print(sys.version)
3.7.0a3 (default, Jan 27 2018, 00:46:45)
[Clang 9.0.0 (clang-900.0.39.2)]
```

因此，你可以看到这个版本是Python 3.7的alpha版本，将于2018年6月发布。前面的文本是我在控制台中输入的一小段Python代码。我们稍后会谈论它。

本书中的所有示例都将使用Python 3.7运行。尽管目前最终版本可能与我所拥有的略有不同，但我会确保所有的代码和示例在书籍出版时都是最新的3.7版本。

一些代码也可以在Python 2.7中运行，要么就是原样，要么稍作调整，但在这个时候，我认为最好先学习Python 3，然后再了解它与Python 2的区别，而不是反过来。

不过，不要担心这个版本的问题；实际上并不是那么大的问题。

# 安装Python

我从来没有真正理解为什么书中需要有一个*设置*部分，不管你需要设置什么。大多数情况下，作者写下指示的时间和你实际尝试它们的时间之间已经过去了几个月。如果你幸运的话。一旦版本发生变化，书中描述的方法可能就不再奏效了。幸运的是，现在我们有了网络，所以为了帮助你启动和运行，我只会给你一些指引和目标。

我知道大多数读者可能更喜欢在书中获得指导。但我怀疑这是否会让他们的生活变得更容易，因为我坚信，如果你想开始学习Python，你必须付出最初的努力，以熟悉这个生态系统。这非常重要，它将增强你面对接下来章节中的材料的信心。如果遇到困难，请记住，谷歌是你的朋友。

# 设置Python解释器

首先，让我们谈谈你的操作系统。Python已经完全集成，并且很可能已经安装在几乎每个Linux发行版中。如果你使用macOS，很可能Python也已经安装好了（但可能只有Python 2.7），而如果你使用Windows，你可能需要安装它。

获取Python和你需要的库并使其运行需要一些技巧。Linux和macOS似乎是最适合Python程序员的用户友好操作系统；而Windows则需要更大的努力。

我的当前系统是MacBook Pro，这也是我在整本书中将使用的系统，搭配Python 3.7。

你要开始的地方是官方Python网站：[https://www.python.org](https://www.python.org)。这个网站托管了官方Python文档和许多其他资源，你会发现非常有用。花点时间去探索一下。

另一个关于Python及其生态系统的优秀、富有资源的网站是[http://docs.python-guide.org](http://docs.python-guide.org)。你可以找到使用不同方法在不同操作系统上设置Python的说明。

找到下载部分，选择适合你操作系统的安装程序。如果你使用Windows，在运行安装程序时，请确保勾选“安装pip”选项（实际上，我建议进行完整安装，以确保安装程序包含的所有组件都安装了）。我们稍后会讨论`pip`。

现在Python已经安装在你的系统中，目标是能够打开控制台并通过键入`python`运行Python交互式shell。

请注意，我通常简称**Python交互式shell**为**Python控制台**。

在Windows中打开控制台，转到“开始”菜单，选择“运行”，然后键入`cmd`。如果在本书的示例中遇到类似权限问题的情况，请确保以管理员权限运行控制台。

在macOS X上，你可以通过转到“应用程序”|“实用工具”|“终端”来启动终端。

如果你使用Linux，你对控制台的了解就足够了。

我将使用术语*控制台*来交替指代Linux控制台、Windows命令提示符和Macintosh终端。我还将用Linux默认格式指示命令行提示符，就像这样：

```py
$ sudo apt-get update
```

如果你对此不熟悉，请花些时间学习控制台的基础知识。简而言之，在`$`符号后，通常会有一个你需要输入的指令。注意大小写和空格，它们非常重要。

无论你打开哪个控制台，都在提示符处键入`python`，确保Python交互式shell显示出来。键入`exit()`退出。请记住，如果你的操作系统预装了Python 2.*，可能需要指定`python3`。

这大致是你运行Python时应该看到的情况（根据版本和操作系统的不同，细节可能会有所变化）：

```py
$ python3.7
Python 3.7.0a3 (default, Jan 27 2018, 00:46:45)
[Clang 9.0.0 (clang-900.0.39.2)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>>
```

现在Python已经设置好，你可以运行它了，是时候确保你还有另一个工具，这个工具将是跟随本书示例不可或缺的：virtualenv。

# 关于virtualenv

正如你可能已经猜到的那样，**virtualenv**关乎虚拟环境。让我通过一个简单的例子来解释它们是什么，为什么我们需要它们。

你在系统上安装了Python，并开始为X客户工作。你创建了一个项目文件夹并开始编码。在此过程中，你还安装了一些库，例如Django框架。假设你为X项目安装的Django版本是1.7.1。

现在，你的网站做得很好，你又得到了另一个客户Y。她希望你为她建立另一个网站，所以你开始了Y项目，但在此过程中，你需要再次安装Django。唯一的问题是现在Django的版本是1.8，你不能在系统上安装它，因为这会替换你为X项目安装的版本。你不想冒险引入不兼容的问题，所以你有两个选择：要么你继续使用你当前机器上的版本，要么你升级它，并确保第一个项目仍然能够正确地使用新版本。

说实话，这些选项都不是很吸引人，对吧？绝对不是。所以，这里有解决方案：virtualenv！

virtualenv是一个允许你创建虚拟环境的工具。换句话说，它是一个用于创建隔离的Python环境的工具，每个环境都是一个包含所有必要可执行文件的文件夹，以便使用Python项目所需的包（暂时将包视为库）。

所以你为X项目创建一个虚拟环境，安装所有依赖项，然后为Y项目创建一个虚拟环境，安装所有依赖项，而不用担心，因为你安装的每个库最终都会在适当的虚拟环境范围内。在我们的例子中，X项目将使用Django 1.7.1，而Y项目将使用Django 1.8。

绝对不能直接在系统级别安装库非常重要。例如，Linux依赖于Python执行许多不同的任务和操作，如果你在系统安装的Python上进行操作，就会有破坏整个系统完整性的风险（猜猜这是发生在谁身上的...）。所以把这当作一条规则，就像睡前刷牙一样重要：*每次开始新项目时，一定要创建虚拟环境*。

要在系统上安装virtualenv，有几种不同的方法。例如，在基于Debian的Linux发行版上，你可以使用以下命令安装：

```py
$ sudo apt-get install python-virtualenv
```

可能最简单的方法是按照virtualenv官方网站上的说明进行操作：[https://virtualenv.pypa.io](https://virtualenv.pypa.io)。

你会发现，安装virtualenv最常见的方法之一是使用`pip`，这是一个用于安装和管理用Python编写的软件包的软件包管理系统。

从Python 3.5开始，创建虚拟环境的建议方式是使用`venv`模块。更多信息请参阅[官方文档](https://docs.python.org/3.7/library/venv.html)。然而，在撰写本文时，virtualenv仍然是创建虚拟环境最常用的工具。

# 你的第一个虚拟环境

创建虚拟环境非常容易，但根据系统配置和想要虚拟环境运行的Python版本，你需要正确运行命令。另一件你需要做的事情是激活虚拟环境。激活虚拟环境基本上是在后台进行一些路径操作，这样当你调用Python解释器时，实际上是调用激活的虚拟环境，而不是系统的。

我将在我的Macintosh控制台上展示一个完整的示例。我们将：

1.  在你的项目根目录下创建一个名为`learn.pp`的文件夹（在我的情况下是一个名为`srv`的文件夹，在我的主目录下）。请根据你在计算机上喜欢的设置调整路径。

1.  在`learn.pp`文件夹中，我们将创建一个名为`learnpp`的虚拟环境。

一些开发人员更喜欢使用相同的名称来称呼所有虚拟环境（例如，`.venv`）。这样他们就可以通过知道项目所在的名称来运行脚本。在Linux/macOS中，以点开头的名称会使文件或文件夹变得不可见。

1.  创建虚拟环境后，我们将激活它。在Linux、macOS和Windows之间的方法略有不同。

1.  然后，我们将确保我们正在运行所需的Python版本（3.7.*），通过运行Python交互式shell。

1.  最后，我们将使用`deactivate`命令来停用虚拟环境。

这五个简单的步骤将向您展示开始和使用项目所需做的一切。

以下是这些步骤可能看起来的一个示例（请注意，根据您的操作系统、Python版本等，可能会得到略有不同的结果）在macOS上（以`#`开头的命令是注释，空格是为了可读性引入的，`⇢`表示由于空间不足而换行）：

```py
fabmp:srv fab$ # step 1 - create folder
fabmp:srv fab$ mkdir learn.pp
fabmp:srv fab$ cd learn.pp

fabmp:learn.pp fab$ # step 2 - create virtual environment
fabmp:learn.pp fab$ which python3.7
/Users/fab/.pyenv/shims/python3.7
fabmp:learn.pp fab$ virtualenv -p
⇢ /Users/fab/.pyenv/shims/python3.7 learnpp
Running virtualenv with interpreter /Users/fab/.pyenv/shims/python3.7
Using base prefix '/Users/fab/.pyenv/versions/3.7.0a3'
New python executable in /Users/fab/srv/learn.pp/learnpp/bin/python3.7
Also creating executable in /Users/fab/srv/learn.pp/learnpp/bin/python
Installing setuptools, pip, wheel...done.

fabmp:learn.pp fab$ # step 3 - activate virtual environment
fabmp:learn.pp fab$ source learnpp/bin/activate

(learnpp) fabmp:learn.pp fab$ # step 4 - verify which python
(learnpp) fabmp:learn.pp fab$ which python
/Users/fab/srv/learn.pp/learnpp/bin/python

(learnpp) fabmp:learn.pp fab$ python
Python 3.7.0a3 (default, Jan 27 2018, 00:46:45)
[Clang 9.0.0 (clang-900.0.39.2)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> exit()

(learnpp) fabmp:learn.pp fab$ # step 5 - deactivate
(learnpp) fabmp:learn.pp fab$ deactivate
fabmp:learn.pp fab$
```

请注意，我不得不明确告诉virtualenv使用Python 3.7解释器，因为在我的系统上Python 2.7是默认的。如果我没有这样做，我将得到一个带有Python 2.7而不是Python 3.7的虚拟环境。

你可以将第2步的两条指令合并成一条命令，就像这样：

```py
$ virtualenv -p $( which python3.7 ) learnpp
```

在这种情况下，我选择明确详细，以帮助您理解每个步骤。

另一件需要注意的事情是，为了激活虚拟环境，我们需要运行`/bin/activate`脚本，这需要被源化。当脚本被**源化**时，意味着它在当前shell中执行，因此其效果会在执行后持续存在。这非常重要。还要注意，在我们激活虚拟环境后，提示符会发生变化，左边会显示其名称（在我们停用它时会消失）。在Linux上，步骤是相同的，所以我不会在这里重复。在Windows上，事情略有不同，但概念是相同的。请参考官方virtualenv网站获取指导。

在这一点上，您应该能够创建和激活一个虚拟环境。请尝试创建另一个虚拟环境，而无需我的指导。熟悉这个过程，因为这是您将始终在做的事情：**我们永远不会在系统范围内使用Python**，记住吗？这非常重要。

所以，一旦搭建好，我们就准备好更多地谈谈Python以及如何使用它。在我们开始之前，让我稍微谈谈控制台。

# 你的朋友，控制台

在这个GUI和触摸屏设备的时代，当一切都只是一个点击之遥时，不得不求助于控制台这样的工具似乎有点荒谬。

但事实是，每当你把右手（或者如果你是左撇子，是左手）从键盘上移开，去抓鼠标并将光标移动到你想点击的位置时，你都会浪费时间。用控制台完成任务，尽管可能有些违反直觉，但会提高生产力和速度。我知道，你必须相信我。

速度和生产力很重要，个人而言，我对鼠标没有任何意见，但还有另一个非常好的理由，你可能希望熟悉控制台：当你开发的代码最终部署到服务器上时，控制台可能是唯一可用的工具。如果你和它交朋友，我向你保证，在最重要的时候你永远不会迷失方向（通常是在网站宕机时，你需要迅速调查发生了什么）。

所以这真的取决于你。如果你还没有决定，请给我一点怀疑的好处，试一试。这比你想象的要容易，你永远不会后悔。没有什么比一个优秀的开发者因为习惯了自己定制的工具而在SSH连接到服务器中迷失更可悲的了。

现在，让我们回到Python。

# 如何运行Python程序

有几种不同的方法可以运行Python程序。

# 运行Python脚本

Python可以用作脚本语言。事实上，它总是非常有用的。脚本是文件（通常很小），通常用来执行一些任务。许多开发人员最终都会拥有自己的工具库，当他们需要执行任务时就会使用。例如，你可以有脚本来解析数据格式并将其呈现为另一种不同的格式。或者你可以使用脚本来处理文件和文件夹。你可以创建或修改配置文件，等等。从技术上讲，几乎没有什么是不能在脚本中完成的。

在服务器上定时运行脚本是非常常见的。例如，如果你的网站数据库每24小时需要清理一次（例如，存储用户会话的表，这些会话很快就会过期，但不会自动清理），你可以设置一个Cron作业，每天凌晨3点运行你的脚本。

根据维基百科，软件实用程序Cron是Unix类计算机操作系统中基于时间的作业调度程序。设置和维护软件环境的人使用Cron定期安排作业（命令或shell脚本）在固定的时间、日期或间隔运行。

# 运行Python交互式shell

另一种运行Python的方法是调用交互式shell。这是我们在控制台命令行中输入 `python` 时已经看到的东西。

所以，打开控制台，激活你的虚拟环境（现在应该已经成为你的第二天性了，对吧？），然后输入 `python`。你会看到几行文字，应该是这样的：

```py
$ python
Python 3.7.0a3 (default, Jan 27 2018, 00:46:45)
[Clang 9.0.0 (clang-900.0.39.2)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>>
```

那些 `>>>` 是shell的提示符。它们告诉你Python正在等待你输入。如果你输入一个简单的指令，一个适合一行的东西，那就是你会看到的。然而，如果你输入需要多于一行代码的东西，shell会把提示符改成 `...`，给你一个视觉线索，告诉你正在输入一个多行语句（或者任何需要多于一行代码的东西）。

来吧，试一试；让我们做一些基本的数学：

```py
>>> 2 + 4
6
>>> 10 / 4
2.5
>>> 2 ** 1024 
```

```py
179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216
```

最后的操作向你展示了一些不可思议的东西。我们将`2`的`1024`次方，Python毫无困难地处理了这个任务。试着在Java、C++或C#中做这个操作。除非你使用特殊的库来处理这样大的数字，否则是行不通的。

我每天都使用交互式shell。它非常有用，可以快速调试，例如，检查数据结构是否支持某个操作。或者检查或运行一段代码。

当你使用Django（一个Web框架）时，交互式shell与之相结合，允许你通过框架工具来检查数据库中的数据，以及其他许多事情。你会发现交互式shell很快会成为你在这段旅程中最亲密的朋友之一。

另一种解决方案，以更好的图形布局呈现，是使用**集成开发环境**（**IDLE**）。这是一个相当简单的集成开发环境，主要面向初学者。它比你在控制台中得到的裸交互式shell具有稍微更多的功能，所以你可能想要探索一下。它在Windows Python安装程序中免费提供，你也可以轻松地在任何其他系统中安装它。你可以在Python网站上找到有关它的信息。

Guido Van Rossum将Python命名为英国喜剧团体Monty Python，因此有传言称IDLE的名称是为了纪念Monty Python的创始成员之一Eric Idle而选择的。

# 将Python作为服务运行

除了作为脚本运行之外，在shell的边界内，Python还可以编码并作为应用程序运行。我们将在整本书中看到许多关于这种模式的例子。当我们谈论Python代码是如何组织和运行的时候，我们将更多地了解它。

# 将Python作为GUI应用程序运行

Python也可以作为**图形用户界面**（**GUI**）运行。有几个可用的框架，其中一些是跨平台的，另一些是特定于平台的。

在其他GUI框架中，我们发现以下是最广泛使用的：

+   PyQt

+   Tkinter

+   wxPython

+   PyGTK

详细描述它们超出了本书的范围，但您可以在Python网站上找到所有您需要的信息（[https://docs.python.org/3/faq/gui.html](https://docs.python.org/3/faq/gui.html)），在*Python存在哪些平台无关的GUI工具包？*部分。如果您正在寻找GUI，请记住根据一些原则选择您想要的。确保它们：

+   提供您可能需要开发项目的所有功能

+   在您可能需要支持的所有平台上运行

+   依靠尽可能广泛和活跃的社区

+   包装图形驱动程序/工具，您可以轻松安装/访问

# Python代码是如何组织的？

让我们谈一下Python代码是如何组织的。在本节中，我们将更深入地探讨一些技术名称和概念。

从基础知识开始，Python代码是如何组织的？当然，您将代码写入文件中。当您使用扩展名`.py`保存文件时，该文件被称为Python模块。

如果您使用的是Windows或macOS，通常会向用户隐藏文件扩展名，请确保更改配置，以便您可以看到文件的完整名称。这不是严格的要求，而是一个建议。

将所有软件所需的代码保存在一个文件中是不切实际的。这种解决方案适用于脚本，通常不超过几百行（通常比这短得多）。

一个完整的Python应用程序可能由数十万行代码组成，因此您将不得不将其分散到不同的模块中，这是更好的，但还不够好。事实证明，即使这样，使用代码仍然是不切实际的。因此，Python为您提供了另一种结构，称为**包**，它允许您将模块组合在一起。包只是一个文件夹，必须包含一个特殊文件`__init__.py`，它不需要包含任何代码，但其存在是为了告诉Python该文件夹不仅仅是一个文件夹，而实际上是一个包（请注意，从Python 3.3开始，`__init__.py`模块不再严格需要）。

像往常一样，一个例子将使所有这些更加清晰。我在我的书项目中创建了一个示例结构，当我在控制台中输入时：

```py
$ tree -v example
```

我得到了`ch1/example`文件夹内容的树形表示，其中包含本章示例的代码。这是一个真正简单应用程序结构的样子：

```py
example
├── core.py
├── run.py
└── util
 ├── __init__.py
 ├── db.py
 ├── math.py
 └── network.py
```

您可以看到，在这个例子的根目录中，我们有两个模块，`core.py`和`run.py`，以及一个包：`util`。在`core.py`中，可能有我们应用程序的核心逻辑。另一方面，在`run.py`模块中，我们可能会找到启动应用程序的逻辑。在`util`包中，我希望找到各种实用工具，实际上，我们可以猜测那里的模块是根据它们所持有的工具类型命名的：`db.py`将持有与数据库工作相关的工具，`math.py`当然将持有数学工具（也许我们的应用程序涉及财务数据），`network.py`可能将持有在网络上发送/接收数据的工具。

如前所述，`__init__.py`文件只是告诉Python`util`是一个包，而不仅仅是一个普通的文件夹。

如果这个软件只是组织在模块中，推断其结构将会更加困难。我在`ch1/files_only`文件夹下放了一个*仅模块*的例子；自己看看：

```py
$ tree -v files_only
```

这给我们展示了一个完全不同的画面：

```py
files_only/
├── core.py
├── db.py
├── math.py
├── network.py
└── run.py
```

猜测每个模块的功能可能有点困难，对吧？现在，考虑这只是一个简单的例子，所以您可以猜想如果我们无法将代码组织成包和模块，要理解一个真实应用程序会有多困难。

# 我们如何使用模块和包？

当开发人员编写应用程序时，很可能需要在不同的部分应用相同的逻辑。例如，当编写一个解析器来解析用户可以在网页上填写的表单数据时，应用程序将需要验证某个字段是否包含数字。无论这种验证逻辑如何编写，很可能会在多个地方需要使用。

例如，在一个调查应用程序中，用户被问及许多问题，很可能其中几个问题需要数字答案。例如：

+   你多大了？

+   你有多少宠物？

+   你有多少孩子？

+   你结婚多少次了？

在每个期望得到数字答案的地方复制/粘贴（或者更恰当地说：重复）验证逻辑将是非常糟糕的做法。这将违反**不要重复自己**（**DRY**）原则，该原则规定您在应用程序中不应该重复相同的代码。我感到有必要强调这个原则的重要性：*您在应用程序中不应该重复相同的代码*（有意思的双关语）。

重复相同的逻辑可能非常糟糕的原因有几个，其中最重要的原因是：

+   逻辑中可能存在错误，因此，您将不得不在应用逻辑的每个地方进行更正。

+   您可能希望修改验证的方式，然后您将不得不在应用的每个地方进行更改。

+   您可能会忘记修复/修改某个逻辑，因为在搜索所有出现的时候错过了它。这将在您的应用程序中留下错误/不一致的行为。

+   您的代码会比需要的更长，没有好的理由。

Python是一种很棒的语言，并为您提供了应用所有编码最佳实践所需的所有工具。对于这个特定的例子，我们需要能够重用一段代码。为了能够重用一段代码，我们需要有一个构造，可以为我们保存代码，以便我们可以在需要重复其中的逻辑时调用该构造。这个构造存在，它被称为**函数**。

我在这里不会深入讨论具体细节，所以请记住，函数是一块有组织的可重用代码，用于执行任务。函数可以根据它们所属的环境的不同形式和名称，但现在这并不重要。我们将在书的后面能够欣赏到它们时，再看到细节。函数是应用程序中模块化的构建块，几乎是不可或缺的。除非你在写一个非常简单的脚本，否则你会一直使用函数。我们将在[第4章](6fca8068-0037-4e99-986b-805a74d5729f.xhtml)中探讨函数，*函数，代码的构建块*。

Python自带一个非常庞大的库，就像我几页前已经说过的那样。现在，也许是定义库的好时机：**库**是提供丰富功能的函数和对象的集合，丰富了语言的能力。

例如，在Python的`math`库中，我们可以找到大量的函数，其中之一就是`factorial`函数，它当然可以计算一个数的阶乘。

在数学中，非负整数*N*的**阶乘**，表示为*N*！，被定义为小于或等于*N*的所有正整数的乘积。例如，计算5的阶乘如下：

5！= 5 * 4 * 3 * 2 * 1 = 120

0的阶乘是0！= 1，以遵守空乘积的约定。

因此，如果你想在你的代码中使用这个函数，你只需要导入它并用正确的输入值调用它。如果现在输入值和调用的概念不太清楚，不要担心，只需专注于导入部分。我们通过从中导入需要的内容来使用库，然后使用它。

在Python中，要计算数字5的阶乘，我们只需要以下代码：

```py
>>> from math import factorial
>>> factorial(5)
120
```

无论我们在shell中输入什么，只要它有可打印的表示，就会在控制台上打印出来（在这种情况下，是函数调用的结果：120）。

所以，让我们回到我们的例子，那个有`core.py`、`run.py`、`util`等的例子。

在我们的例子中，包`util`是我们的实用库。我们的自定义实用工具包，其中包含我们应用程序中需要的所有可重用工具（即函数）。其中一些将处理数据库（`db.py`），一些将处理网络（`network.py`），一些将执行数学计算（`math.py`），这些都超出了Python标准`math`库的范围，因此我们必须自己编写它们。

我们将在专门的章节详细讨论如何导入函数并在其中使用。现在让我们谈谈另一个非常重要的概念：*Python的执行模型*。

# Python的执行模型

在这一部分，我想向你介绍一些非常重要的概念，比如作用域、名称和命名空间。当然，你可以在官方语言参考中阅读关于Python执行模型的所有内容，但我认为那相当技术化和抽象，所以让我先给你一个不太正式的解释。

# 名称和命名空间

假设你正在找一本书，所以你去图书馆问有人要找的书。他们告诉你类似*二楼，X区，第三排*这样的信息。于是你上楼，找到X区，依此类推。

进入一个图书馆，所有的书都堆在一起，没有楼层，没有区域，没有排列，没有秩序，那将是非常不同的。找一本书将会非常困难。

当我们编写代码时，我们也会遇到同样的问题：我们必须尝试组织它，以便对于没有先验知识的人来说，能够轻松找到他们要找的东西。当软件结构正确时，它也促进了代码重用。另一方面，杂乱无章的软件更有可能暴露出分散的重复逻辑片段。

首先，让我们从书开始。我们通过书的标题来引用一本书，在Python术语中，那将是一个名称。Python名称是其他语言称为变量的最接近的抽象。名称基本上是指向对象的，并且是通过名称绑定操作引入的。让我们举个快速的例子（注意，跟在`#`后面的任何内容都是注释）：

```py
>>> n = 3  # integer number
>>> address = "221b Baker Street, NW1 6XE, London"  # Sherlock Holmes' address
>>> employee = {
...     'age': 45,
...     'role': 'CTO',
...     'SSN': 'AB1234567',
... }
>>> # let's print them
>>> n
3
>>> address
'221b Baker Street, NW1 6XE, London'
>>> employee
{'age': 45, 'role': 'CTO', 'SSN': 'AB1234567'}
>>> other_name
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'other_name' is not defined 
```

我们在前面的代码中定义了三个对象（你还记得每个Python对象具有的三个特征是什么吗？）：

+   一个整数`n`（类型：`int`，值：`3`）

+   一个字符串`address`（类型：`str`，值：福尔摩斯的地址）

+   一个字典`employee`（类型：`dict`，值：包含三个键/值对的字典）

别担心，我知道你不应该知道什么是字典。我们将在第2章“内置数据类型”中看到，它是Python数据结构的王者。

你有没有注意到，当我输入employee的定义时，提示从`>>>`变成了`...`？这是因为定义跨越了多行。

那么，`n`、`address`和`employee`是什么？它们是**名称**。我们可以使用这些名称在我们的代码中检索数据。它们需要被保存在某个地方，这样每当我们需要检索这些对象时，我们可以使用它们的名称来获取它们。我们需要一些空间来保存它们，因此：命名空间！

**命名空间**因此是名称到对象的映射。例如内置名称集（包含在任何Python程序中始终可访问的函数）、模块中的全局名称和函数中的局部名称。甚至对象的属性集也可以被视为命名空间。

命名空间的美妙之处在于它们允许你以清晰的方式定义和组织你的名称，而不会重叠或干扰。例如，与我们在图书馆中寻找的书相关联的命名空间可以用来导入书本本身，就像这样：

```py
from library.second_floor.section_x.row_three import book 
```

我们从`library`命名空间开始，通过点（`.`）运算符，我们进入该命名空间。在这个命名空间中，我们寻找`second_floor`，再次使用`.`运算符进入它。然后我们进入`section_x`，最后在最后一个命名空间`row_three`中找到了我们正在寻找的名称：`book`。

当我们处理真实的代码示例时，通过命名空间的遍历将更加清晰。现在，只需记住命名空间是名称与对象相关联的地方。

还有一个概念，与命名空间的概念密切相关，我想简要谈谈：**作用域**。

# 作用域

根据Python的文档：

“*作用域是Python程序的文本区域，其中命名空间是直接可访问的*。”

直接可访问意味着当你寻找一个未经修饰的名称引用时，Python会尝试在命名空间中找到它。

作用域是静态确定的，但实际上，在运行时，它们是动态使用的。这意味着通过检查源代码，你可以知道对象的作用域是什么，但这并不阻止软件在运行时改变它。Python提供了四种不同的作用域（当然，不一定同时都存在）：

+   **局部**作用域，它是最内层的作用域，包含局部名称。

+   **封闭**作用域，也就是任何封闭函数的作用域。它包含非局部名称和非全局名称。

+   **全局**作用域包含全局名称。

+   **内置**作用域包含内置名称。Python带有一组函数，你可以直接使用，比如`print`、`all`、`abs`等。它们存在于内置作用域中。

规则如下：当我们引用一个名称时，Python会从当前命名空间开始查找它。如果找不到该名称，Python会继续搜索封闭范围，直到搜索内置范围。如果在搜索内置范围后没有找到名称，则Python会引发一个`NameError`**异常**，这基本上意味着该名称尚未定义（您在前面的示例中看到了这一点）。

当查找名称时，命名空间的扫描顺序是：**本地**，**封闭**，**全局**，**内置**（**LEGB**）。

这都是非常理论的，所以让我们看一个例子。为了向您展示本地和封闭命名空间，我将不得不定义一些函数。如果您暂时不熟悉它们的语法，不要担心。我们将在[第4章](6fca8068-0037-4e99-986b-805a74d5729f.xhtml)中学习函数，*代码的构建块*。只需记住，在下面的代码中，当您看到`def`时，这意味着我正在定义一个函数：

```py
# scopes1.py
# Local versus Global

# we define a function, called local
def local():
    m = 7
    print(m)

m = 5
print(m)

# we call, or `execute` the function local
local()
```

在前面的示例中，我们在全局范围和本地范围（由`local`函数定义）中定义了相同的名称`m`。当我们使用以下命令执行此程序时（您已激活了您的虚拟环境吗？）：

```py
$ python scopes1.py
```

我们在控制台上看到两个数字打印出来：`5`和`7`。

Python解释器解析文件时，从上到下。首先找到一对注释行，然后解析函数`local`的定义。调用时，此函数执行两件事：它设置一个名称到代表数字`7`的对象，并将其打印出来。Python解释器继续前进，找到另一个名称绑定。这次绑定发生在全局范围中，值为`5`。下一行是对`print`函数的调用，它被执行（因此我们在控制台上得到了第一个打印出的值：`5`）。

在此之后，调用函数`local`。此时，Python执行该函数，因此此时发生绑定`m = 7`并打印出来。

非常重要的一点是代码的一部分属于`local`函数的定义，右侧缩进了四个空格。事实上，Python通过缩进代码来定义作用域。通过缩进进入作用域，通过取消缩进退出作用域。一些编码人员使用两个空格，其他人使用三个空格，但建议使用的空格数是四个。这是最大化可读性的一个很好的措施。我们稍后会更多地讨论编写Python代码时应该采用的所有惯例。

如果我们删除`m = 7`这一行会发生什么？记住LEGB规则。Python会开始在本地范围（函数`local`）中查找`m`，找不到，它会转到下一个封闭范围。在这种情况下，下一个是全局范围，因为没有包裹在`local`周围的封闭函数。因此，我们会在控制台上看到两个数字`5`。让我们实际看一下代码会是什么样子：

```py
# scopes2.py
# Local versus Global

def local():
    # m doesn't belong to the scope defined by the local function
    # so Python will keep looking into the next enclosing scope.
    # m is finally found in the global scope
    print(m, 'printing from the local scope')

m = 5
print(m, 'printing from the global scope')

local()
```

运行`scopes2.py`将打印出：

```py
$ python scopes2.py
5 printing from the global scope
5 printing from the local scope
```

正如预期的那样，Python首次打印`m`，然后当调用函数`local`时，`m`在其范围内找不到，因此Python按照LEGB链继续寻找，直到在全局范围中找到`m`。

让我们看一个带有额外层次的示例，封闭范围：

```py
# scopes3.py
# Local, Enclosing and Global

def enclosing_func():
    m = 13

    def local():
        # m doesn't belong to the scope defined by the local
        # function so Python will keep looking into the next
        # enclosing scope. This time m is found in the enclosing
        # scope
        print(m, 'printing from the local scope')

    # calling the function local
    local()

m = 5
print(m, 'printing from the global scope')

enclosing_func()
```

运行`scopes3.py`将在控制台上打印：

```py
$ python scopes3.py
(5, 'printing from the global scope')
(13, 'printing from the local scope')
```

正如您所看到的，函数`local`中的`print`指令与以前一样引用`m`。`m`在函数本身中仍未定义，因此Python按照LEGB顺序开始遍历范围。这次`m`在封闭范围中找到。

现在如果这还不是很清楚，不要担心。随着我们在书中的例子，你会慢慢理解的。Python教程的*Classes*部分（[https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html)）有一段有趣的关于作用域和命名空间的段落。如果你想更深入地理解这个主题，一定要在某个时候阅读一下。

在我们结束这一章之前，我想再多谈谈对象。毕竟，基本上Python中的一切都是对象，所以我认为它们值得更多的关注。

# 对象和类

当我之前在章节*A proper introduction*中介绍对象时，我说我们用它们来代表现实生活中的对象。例如，现在我们在网上销售各种商品，我们需要能够正确地处理、存储和表示它们。但对象实际上远不止于此。在Python中，你将要做的大部分事情都与操作对象有关。

因此，不要深入细节（我们将在以后的章节中做到这一点），我想给你一个关于类和对象的*简而言之*的解释。

我们已经看到对象是Python对数据的抽象。事实上，Python中的一切都是对象，包括数字，字符串（保存文本的数据结构），容器，集合，甚至函数。你可以把它们想象成至少有三个特征的盒子：一个ID（唯一），一个类型和一个值。

但它们是如何产生的？我们如何创建它们？我们如何编写我们自己的自定义对象？答案就在一个简单的词中：**类**。

事实上，对象是类的实例。Python的美妙之处在于类本身也是对象，但我们不要深入这个领域。这会导致这种语言中最高级的概念之一：**元类**。现在，你理解类和对象之间的区别最好的方法是通过一个例子。

比如一个朋友告诉你，*我买了一辆新自行车！* 你立刻明白她在说什么。你看到了这辆自行车吗？没有。你知道它是什么颜色吗？不知道。品牌？不知道。你对它了解多少？不知道。但与此同时，你知道你需要了解的一切，以理解你的朋友告诉你她买了一辆新自行车。你知道自行车有两个轮子连接到一个框架上，有一个鞍座，踏板，把手，刹车等等。换句话说，即使你没有看到自行车本身，你知道*自行车*的概念。一组抽象的特征和特性共同形成了一个叫做*自行车*的东西。

在计算机编程中，这就是所谓的**类**。就是这么简单。类用于创建对象。事实上，对象被称为**类的实例**。

换句话说，我们都知道自行车是什么；我们知道这个类。但是我有自己的自行车，它是自行车类的一个实例。我的自行车是一个具有自己特征和方法的对象。你也有自己的自行车。同样的类，但不同的实例。世界上制造的每辆自行车都是自行车类的一个实例。

让我们看一个例子。我们将编写一个定义自行车的类，然后我们将创建两辆自行车，一辆红色的，一辆蓝色的。我会保持代码非常简单，但如果你不完全理解它，不要担心；你现在需要关心的是理解类和对象（或类的实例）之间的区别：

```py
# bike.py
# let's define the class Bike
class Bike:

    def __init__(self, colour, frame_material):
        self.colour = colour
        self.frame_material = frame_material

    def brake(self):
        print("Braking!")

# let's create a couple of instances
red_bike = Bike('Red', 'Carbon fiber')
blue_bike = Bike('Blue', 'Steel')

# let's inspect the objects we have, instances of the Bike class.
print(red_bike.colour)  # prints: Red
print(red_bike.frame_material)  # prints: Carbon fiber
print(blue_bike.colour)  # prints: Blue
print(blue_bike.frame_material)  # prints: Steel

# let's brake!
red_bike.brake()  # prints: Braking!
```

我希望现在我不需要再告诉你每次都要运行文件了，对吧？文件名在代码块的第一行中指定。只需运行`$ python filename`，一切都会很好。但记得要激活你的虚拟环境！

这里有很多有趣的事情要注意。首先，类的定义是通过`class`语句完成的。无论`class`语句之后的代码是什么，并且缩进，都被称为类的主体。在我们的例子中，属于类定义的最后一行是`print("Braking!")`。

在定义了类之后，我们准备创建实例。你可以看到类主体承载了两个方法的定义。方法基本上（和简单地）是属于类的函数。

第一个方法`__init__`是一个**初始化器**。它使用一些Python魔术来使用我们在创建时传递的值设置对象。

在Python中，每个具有前导和尾随双下划线的方法都被称为**魔术方法**。魔术方法被Python用于多种不同的目的；因此，使用两个前导和尾随下划线命名自定义方法从来都不是一个好主意。这种命名约定最好留给Python。

我们定义的另一种方法`brake`只是一个额外方法的示例，如果我们想要刹车自行车，我们可以调用它。当然，它只包含一个`print`语句；这只是一个例子。

我们创建了两辆自行车。一辆是红色的，有碳纤维框架，另一辆是蓝色的，有钢框架。我们在创建时传递这些值。创建后，我们打印出红色自行车的颜色属性和框架类型，以及蓝色自行车的框架类型，这只是一个例子。我们还调用了`red_bike`的`brake`方法。

最后要注意的一件事。你还记得我告诉过你对象的属性集被认为是一个命名空间吗？我希望现在我说的更清楚了。你可以看到通过不同的命名空间（`red_bike`，`blue_bike`）获取`frame_type`属性，我们得到不同的值。没有重叠，没有混淆。

点（`.`）运算符当然是我们用来进入命名空间的手段，在对象的情况下也是如此。

# 如何编写良好代码的指南

编写良好的代码并不像看起来那么容易。正如我之前所说，良好的代码展示了一长串相当难以组合的特质。编写良好的代码在某种程度上是一种艺术。无论你愿意在哪个阶段停下来，有一件事你可以接受，那就是让你的代码立即变得更好的东西：**PEP 8**。

根据维基百科：

"Python的发展主要通过Python Enhancement Proposal (PEP) 过程进行。PEP过程是提出主要新功能、收集社区对问题的意见和记录Python设计决策的主要机制。"

PEP 8可能是所有PEP中最著名的。它提出了一套简单但有效的指南，定义了Python的美学，以便我们编写优美的Python代码。如果你从这一章中得到一个建议，请让它成为这个：使用它。拥抱它。你以后会感谢我的。

今天的编码不再是一个签入/签出的业务。相反，它更多的是一种社会努力。几个开发人员通过Git和Mercurial等工具共同协作一段代码，结果是由许多不同的手所创造的代码。

Git和Mercurial可能是今天使用最多的分布式版本控制系统。它们是设计帮助开发团队共同协作在同一软件上的基本工具。

如今，我们更需要有一种一致的编写代码的方式，以便最大限度地提高可读性。当公司的所有开发人员遵守PEP 8时，他们中的任何一个人落在一段代码上，都不会觉得他们自己写的。这实际上经常发生在我身上（我总是忘记我写的代码）。

这有一个巨大的优势：当您阅读自己可以写出的代码时，您会轻松阅读。没有约定，每个编码人员都会按照他们最喜欢的方式或者他们被教导或者习惯的方式来构建代码，这意味着必须根据别人的风格来解释每一行。这意味着要花费更多的时间来理解它。由于PEP 8，我们可以避免这种情况。我是它的忠实粉丝，如果代码不遵守它，我就不会签署代码审查。因此，请花时间学习它；这非常重要。

在本书的例子中，我会尽量尊重它。不幸的是，我没有79个字符的奢侈（这是PEP 8建议的最大行长度），我将不得不减少空行和其他东西，但我向你保证我会尽量布置我的代码，使其尽可能可读。

# Python文化

Python已经被广泛应用于所有编码行业。它被许多不同的公司用于许多不同的目的，也被用于教育（因为它有许多优点，而且易于学习，所以它是一个非常出色的语言）。

Python今天如此受欢迎的一个原因是，围绕它的社区是庞大、充满活力且充满杰出人才的。世界各地都组织了许多活动，主要是围绕Python或其主要的Web框架Django。

Python是开放的，而且通常拥抱它的人的思想也是开放的。在Python网站的社区页面上查看更多信息并参与其中！

Python还有另一个方面，围绕着“Pythonic”的概念。这与Python允许您使用一些在其他地方找不到的习语有关，至少不是以相同的形式或者不是那么容易使用（现在我在使用不是Python的语言编码时感到相当幽闭恐惧）。

无论如何，多年来，这种Pythonic的概念已经出现了，我理解的方式是*按照Python应该完成的方式来做事*。

为了帮助您更好地了解Python的文化和Pythonic，我将向您展示*Python之禅*。这是一个非常受欢迎的可爱彩蛋。打开Python控制台，键入`import this`。接下来的内容就是这行的结果：

```py
>>> import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
```

这里有两个阅读层次。一个是将其视为一组以有趣的方式提出的指导方针。另一个是牢记在心，并可能偶尔阅读一下，试图理解它是如何指涉更深层次的东西的：一些Python特性，您将不得不深入理解，以便按照它应该被编写的方式编写Python。从有趣的层次开始，然后深入挖掘。始终深入挖掘。

# 关于IDE的说明

关于IDE的一些话。要遵循本书中的示例，您不需要IDE；任何文本编辑器都可以。如果您想要更多高级功能，比如语法着色和自动完成，您就需要获取一个IDE。您可以在Python网站上找到一份全面的开源IDE列表（只需搜索Python IDEs）。我个人使用Sublime Text编辑器。它是免费试用的，成本只需几美元。我一生中尝试过许多IDE，但这是让我最有效率的一个。

两个重要的建议：

+   无论您选择使用什么IDE，都要努力学会它，以便能够充分利用它的优势，但*不要依赖它*。偶尔练习使用VIM（或任何其他文本编辑器）；学会能够在任何平台上使用任何一套工具进行工作。

+   无论您使用什么文本编辑器/IDE，写Python时，*缩进是四个空格*。不要使用制表符，也不要将它们与空格混合使用。使用四个空格，不是两个，不是三个，也不是五个。就使用四个。整个世界都是这样的，你不想因为你喜欢三个空格的布局而成为局外人。

# 总结

在这一章中，我们开始探索编程和Python的世界。我们只是初步了解了一点点，涉及到的概念将在本书的后面更详细地讨论。

我们谈到了Python的主要特性，谁在使用它以及为什么，以及我们可以用哪些不同的方式编写Python程序。

在本章的最后部分，我们简要介绍了命名空间、作用域、类和对象的基本概念。我们还看到了Python代码如何使用模块和包进行组织。

在实际操作中，我们学会了如何在系统上安装Python，如何确保我们拥有所需的工具`pip`和virtualenv，并创建并激活了我们的第一个虚拟环境。这将使我们能够在一个独立的环境中工作，而不会危及Python系统的安装。

现在你已经准备好和我一起开始这段旅程了。你所需要的只是热情、激活的虚拟环境、这本书、你的手指和一些咖啡。

尝试跟着例子走；我会让它们简单而简短。如果你能熟练掌握它们，你会比仅仅阅读更好地记住它们。

在下一章中，我们将探索Python丰富的内置数据类型。有很多内容需要涵盖和学习！
