- en: Online Video Game Store with Django
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Django创建在线视频游戏商店
- en: I was born in the late seventies, which means that I grew up during the birth
    of the video game industry. My first video game console was the Atari 2600, and
    it was because of that specific video game console that I decided that I wanted
    to be a programmer and make video games. I never got a job within the gaming industry,
    however, but I still love playing video games, and in, my spare time, I try to
    develop my own games.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我出生在70年代末，这意味着我在视频游戏产业诞生时长大。我的第一款视频游戏主机是Atari 2600，正是因为这款特定的视频游戏主机，我决定要成为一名程序员并制作视频游戏。然而，我从未在游戏行业找到工作，但我仍然喜欢玩视频游戏，在业余时间里，我尝试开发自己的游戏。
- en: To this day, I still go around the internet—especially eBay—buying old video
    games to bring back my nice childhood memories when all the family, my parents,
    and my sister, used to play Atari 2600 games together.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直到今天，我仍然在互联网上四处转悠，尤其是在eBay上，购买旧的视频游戏，以重温我美好的童年回忆，当时全家，我的父母和姐姐，都喜欢一起玩Atari 2600游戏。
- en: Because of my interest in vintage video games, we are going to develop a vintage
    video game online store; this will be a great way to develop something fun and
    also learn a lot about web development with the popular Django web framework.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我对复古视频游戏很感兴趣，我们将开发一个复古视频游戏在线商店；这将是一个很好的方式来开发有趣的东西，同时也学到很多关于流行的Django web框架的网页开发知识。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Setting up the environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境
- en: Creating a Django project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Django项目
- en: Creating Django apps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Django应用程序
- en: Exploring the Django admin interface
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Django管理界面
- en: Learning how to create an application model and perform queries with the Django
    ORM
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何创建应用程序模型并使用Django ORM执行查询
- en: Also, as an extra, we will be using the **npm** (**Node Package Manager**) to
    download the client-side dependencies. We will also cover how to create simple
    tasks using the task runner Gulp.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，作为额外的内容，我们将使用**npm**（**Node Package Manager**）来下载客户端依赖项。我们还将介绍如何使用任务运行器Gulp创建简单的任务。
- en: To make our application prettier without a lot of effort, we are going to use
    Bootstrap.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的应用程序更漂亮，我们将使用Bootstrap。
- en: So, let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧！
- en: Setting up the development environment
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置开发环境
- en: As usual, we are going to start setting up the environment for development.
    In [Chapter 4](2223dee0-d5de-417e-9ca9-6bf4a6038cb6.xhtml), *Exchange Rates and
    the Currency Conversion Tool*, you were introduced to `pipenv`, so in this and
    the following chapters, we are going to be using `pipenv` to create our virtual
    environment and manage our dependencies.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们将开始为开发设置环境。在[第4章](2223dee0-d5de-417e-9ca9-6bf4a6038cb6.xhtml)中，*汇率和货币转换工具*，你已经了解了`pipenv`，所以在本章和接下来的章节中，我们将使用`pipenv`来创建我们的虚拟环境和管理我们的依赖项。
- en: 'First, we want to create the directory where we are going to keep our project.
    In your working directory, create a directory called `django-project` as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要创建一个目录，用来存放我们的项目。在你的工作目录中，创建一个名为`django-project`的目录，如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we can run `pipenv` to create our virtual environment:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行`pipenv`来创建我们的虚拟环境：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you have Python 3 installed in another location, you can use the argument
    `--python` and specify the path where the Python executable is located. If everything
    went fine, you should see an output such as the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在其他位置安装了Python 3，你可以使用参数`--python`并指定Python可执行文件的路径。如果一切顺利，你应该会看到如下输出：
- en: '![](assets/ade4540c-d7e8-469a-ac30-b921844e9030.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ade4540c-d7e8-469a-ac30-b921844e9030.png)'
- en: 'Now we can activate our virtual environment using the `pipenv` command shell:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`pipenv`命令行激活我们的虚拟环境：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Great! The only dependency that we are going to add for now is Django.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在要添加的唯一依赖项是Django。
- en: At the time of writing this book, Django 2.0 had been released. It has really
    nice features compared to its predecessor. You can see the list of new features
    at [https://docs.djangoproject.com/en/2.0/releases/2.0/](https://docs.djangoproject.com/en/2.0/releases/2.0/).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Django 2.0已经发布。与之前相比，它有很多很好的功能。你可以在[https://docs.djangoproject.com/en/2.0/releases/2.0/](https://docs.djangoproject.com/en/2.0/releases/2.0/)上查看新功能列表。
- en: 'Let''s install Django in our virtual environment:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的虚拟环境中安装Django：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Django 2.0 has dropped support for Python 2.0, so if you are planning to develop
    an application using Python 2, you should install Django 1.11.x or lower. I strongly
    recommend that you start a new project using Python 3\. Python 2 will stop being
    maintained after a couple of years, and new packages will be created for Python
    3\. Popular packages of Python 2 will migrate to Python 3.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Django 2.0已经停止支持Python 2.0，所以如果你计划使用Python 2开发应用程序，你应该安装Django 1.11.x或更低版本。我强烈建议你使用Python
    3开始一个新项目。Python 2将在几年后停止维护，并且新的包将为Python 3创建。Python 2的流行包将迁移到Python 3。
- en: 'In my opinion, the best new feature of Django 2 is the new routing syntax,
    because now it is not necessary to write regular expressions. It is much cleaner
    and more readable to write something like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，Django 2最好的新功能是新的路由语法，因为现在不需要编写正则表达式。像下面这样写更加清晰和可读：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous syntax relied more on regular expressions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的语法更多地依赖于正则表达式：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is much simpler this way. Another feature that I really like in Django 2.0
    is that they have improved the admin UI a little bit and made it responsive; this
    is a great feature, because I have experienced that creating a new user (while
    you are on the go with no access to a desktop) on a non-responsive site on a small
    mobile phone screen can be painful.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这样会简单得多。我在Django 2.0中真正喜欢的另一个功能是他们稍微改进了管理UI，并使其响应式；这是一个很棒的功能，因为我曾经在小手机屏幕上使用非响应式网站时，创建新用户（当你在外出时无法访问桌面）会很痛苦。
- en: Installing Node.js
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Node.js
- en: When it comes to web development, it is almost impossible to stay away from
    Node.js. Node.js is a project that was released back in 2009\. It is a JavaScript
    runtime that allows us to run JavaScript on the server-side. Why do we care about
    Node.js if we are developing a website using Django and Python? The reason is
    that the Node.js ecosystem has several tools that will help us to manage the client-side
    dependencies in a simple manner. One of these tools that we are going to use is
    the npm.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发方面，几乎不可能远离Node.js。 Node.js是一个于2009年发布的项目。它是一个JavaScript运行时，允许我们在服务器端运行JavaScript。如果我们使用Django和Python开发网站，为什么要关心Node.js呢？原因是Node.js生态系统有几个工具，将帮助我们以简单的方式管理客户端依赖关系。我们将使用其中一个工具，即npm。
- en: Think about npm as the `pip` of the JavaScript world. npm, however, has many
    more features. One of the features that we are going to use is npm scripts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将npm视为JavaScript世界的`pip`。然而，npm有更多功能。我们将使用的功能之一是npm脚本。
- en: So, let's go ahead and install Node.js. Usually, developers need to go over
    to the Node.js website and download it from there, but I find it much simpler
    to use a tool called NVM, which allows us to install and switch easily between
    different versions of Node.js.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们继续安装Node.js。通常，开发人员需要转到Node.js网站并从那里下载，但我发现使用一个名为NVM的工具更简单，它允许我们轻松安装和切换不同版本的Node.js。
- en: To install NVM in our environment, you can follow the instructions at [https://github.com/creationix/nvm](https://github.com/creationix/nvm).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的环境中安装NVM，您可以按照[https://github.com/creationix/nvm](https://github.com/creationix/nvm)上的说明进行操作。
- en: We are covering installation of NVM on Unix/Linux and macOS systems. If you
    are using Windows, there's an awesome version for Windows that has been developed
    in the Go language; it can be found at [https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在介绍在Unix/Linux和macOS系统上安装NVM。如果您使用Windows，有一个使用Go语言开发的Windows版本，可以在[https://github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows)找到。
- en: 'When NVM is installed, you are ready to install the latest version of Node.js
    with the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 安装NVM后，您可以使用以下命令安装最新版本的Node.js：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can verify if the installation is correct with the command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令验证安装是否正确：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While writing this book, the latest Node.js version is v8.8.1.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本书时，最新的Node.js版本是v8.8.1。
- en: 'You can also type `npm` on the terminal, where you should see an output similar
    to the output that follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在终端上输入`npm`，您应该看到类似于以下输出的输出：
- en: '![](assets/36ec4dc3-0d99-4c0e-8604-c7a67979e542.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/36ec4dc3-0d99-4c0e-8604-c7a67979e542.png)'
- en: Creating a new Django project
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的Django项目
- en: 'To create a new Django project, run the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的Django项目，请运行以下命令：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that `django-admin` created a directory called `gamestore` that contains
    some boilerplate code for us. We will go through the files that Django created
    in a little while, but, first, we are going to create our first Django application.
    In the Django world, you have the project and the application, and according to
    the Django documentation, the project describes the web application itself, and
    the application is a Python package that provides some kind of feature; these
    applications contain their own set of routes, views, static files and can be reused
    across different Django projects.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`django-admin`创建了一个名为`gamestore`的目录，其中包含一些样板代码。我们将在稍后查看Django创建的文件，但首先，我们将创建我们的第一个Django应用程序。在Django世界中，您有项目和应用程序，根据Django文档，项目描述了Web应用程序本身，应用程序是一个提供某种功能的Python包；这些应用程序包含自己的一组路由、视图、静态文件，并且可以在不同的Django项目中重复使用。
- en: Don't worry if you don't understand it completely; you will learn more as we
    progress.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您完全不理解，不要担心；随着我们的进展，您会学到更多。
- en: 'With that said, let''s create the project''s initial application. Run `cd gamestore`,
    and once you are inside the `gamestore` directory, execute the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，让我们创建项目的初始应用程序。运行`cd gamestore`，一旦进入`gamestore`目录，执行以下命令：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you list the contents of the `gamestore` directory, you should see a new
    directory named `main`; that's the directory of the Django application that we
    are going to create.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列出`gamestore`目录的内容，您应该会看到一个名为`main`的新目录；那是我们将要创建的Django应用程序的目录。
- en: 'Without writing any code at all, you already have a totally functional web
    application. To run the application and see the results, run the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在不写任何代码的情况下，您已经拥有一个完全功能的Web应用程序。要运行应用程序并查看结果，请运行以下命令：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should see the following output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Open your favorite web browser, and go to `http://127.0.0.1:8000`, where you
    will see the following page:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您喜欢的Web浏览器，转到`http://127.0.0.1:8000`，您将看到以下页面：
- en: '![](assets/91704c14-da95-48eb-9d06-64970b558e88.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/91704c14-da95-48eb-9d06-64970b558e88.png)'
- en: 'One thing to note when we start the application for the first time is the following
    warning:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次启动应用程序时，需要注意的一点是以下警告：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This means that the apps that are registered by default on a Django project,
    `admin`, `auth`, `contenttypes`, and `sessions` have migrations (database changes)
    that haven''t been applied to this project. We can run these migrations with the
    following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Django项目默认注册的应用程序`admin`、`auth`、`contenttypes`和`sessions`有尚未应用到该项目的迁移（数据库更改）。我们可以使用以下命令运行这些迁移：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here Django created all the tables in a SQLite database, you will find the SQLite
    database file in the application's `root` directory.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Django在SQLite数据库中创建了所有表，您将在应用程序的`root`目录中找到SQLite数据库文件。
- en: The `db.sqlite3` file is the database file that contains the tables for our
    application. The choice of SQLite is just to make the application simpler for
    this chapter. Django supports a large set of databases; the most popular databases,
    such as, Postgres, Oracle, and even MSSQL are supported.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.sqlite3`文件是包含我们应用程序表的数据库文件。选择SQLite只是为了使本章的应用程序更简单。Django支持大量数据库；最受欢迎的数据库，如Postgres、Oracle，甚至MSSQL都受支持。'
- en: 'If you run the `runserver` command again, there should not be any migration
    warnings:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果再次运行`runserver`命令，就不应该有任何迁移警告了：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now there's only one thing that we need to do to wrap this section up; we need
    to create an administrator user so we can log in to the Django admin UI and administrate
    our web application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要做一件事来结束这一部分；我们需要创建一个管理员用户，这样我们就可以登录到Django管理界面并管理我们的Web应用程序。
- en: 'As with everything else in Django, this is very simple. Just run the following
    command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与Django中的其他一切一样，这非常简单。只需运行以下命令：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You will be asked to enter a username and email and to set the password, that
    is all you have to do to set an administrator account.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被要求输入用户名和电子邮件，并设置密码，这就是你设置管理员帐户所需要做的一切。
- en: In the next section, we are going to have a closer look at the files that the
    Django created for us.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将更仔细地查看Django为我们创建的文件。
- en: Exploring the Django project's structure
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Django项目的结构
- en: 'If you look at the Django website, it says *Django: The Web framework for perfectionists
    with deadlines,* and I could not agree more with this statement. So far, we haven''t
    written any lines of code, and we already have a site up and running. In just
    a few commands, we can create a new project with the same directory structure
    and boilerplate code. Let''s start with the development.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看一下Django的网站，它说*Django：完美主义者的网络框架，有截止日期*，我完全同意这个说法。到目前为止，我们还没有写任何代码，我们已经有了一个正在运行的网站。只需几个命令，我们就可以创建一个具有相同目录结构和样板代码的新项目。让我们开始开发。
- en: We can set up a new database and create a superuser, and, on the top of that,
    Django comes with a very nice and useful admin UI, where you can visualize our
    data, , and users.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置一个新的数据库并创建一个超级用户，而且，Django还带有一个非常好用和有用的管理界面，你可以在其中查看我们的数据和用户。
- en: In this section, we are going to explore the code that Django created for us
    when starting a new project so that we can get familiar with the structure. Let's
    go ahead and start adding the other components of our project.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将探索Django在启动新项目时为我们创建的代码，以便我们熟悉结构。让我们继续添加项目的其他组件。
- en: If you have a look inside of the project's root directory, you will find a file
    called `db.sqlite3`, another file called `manage.py`, and, lastly, a directory
    with the same name as the project, in our case `gamestore`. The `db.sqlite3` file,
    as the name suggests, is the database file; this file is created here on the project's
    root folder because we are working with SQLite. You can explore this file directly
    from the command line; we are going to demonstrate how to do that shortly.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看项目的根目录，你会发现一个名为`db.sqlite3`的文件，另一个名为`manage.py`的文件，最后，还有一个与项目同名的目录，在我们的例子中是`gamestore`。`db.sqlite3`文件，顾名思义，是数据库文件；这个文件是在项目的根文件夹中创建的，因为我们正在使用SQLite。你可以直接从命令行探索这个文件；我们很快会演示如何做到这一点。
- en: The second file is `manage.py`. This file is created automatically by the `django-admin`
    in every Django project. It basically does the same things as `django-admin`,
    plus two extra things; it will set the `DJANGO_SETTINGS_MODULE` to point to the
    project's setting file and also put the project's package on the `sys.path`. If
    you execute `manage.py` without any arguments, you can see the help with all the
    commands available.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件是`manage.py`。这个文件是由`django-admin`在每个Django项目中自动创建的。它基本上做的事情和`django-admin`一样，再加上两件额外的事情；它会将`DJANGO_SETTINGS_MODULE`设置为指向项目的设置文件，并将项目的包放在`sys.path`上。如果你执行`manage.py`而没有任何参数，你可以看到所有可用命令的帮助。
- en: As you can see with `manage.py`, you have many options, such as manage passwords,
    create a superuser, manage the database, create and execute database migrations,
    start new apps and projects, and a very important option in `runserver`, which,
    as the name says, will start the Django development server for you.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`manage.py`有许多选项，比如管理密码，创建超级用户，管理数据库，创建和执行数据库迁移，启动新应用和项目，以及一个非常重要的选项`runserver`，正如其名字所示，它将为你启动Django开发服务器。
- en: 'Now that we have learned about `manage.py` and how to execute its commands,
    we are going to take a step back and learn how to inspect the database that we
    just created. The command to do that is `dbshell`; let''s give it a go:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`manage.py`以及如何执行它的命令，我们将退一步，学习如何检查我们刚刚创建的数据库。做到这一点的命令是`dbshell`；让我们试一试：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Diving into the SQLite
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入SQLite
- en: 'You should get into the SQLite3 command prompt:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该进入SQLite3命令提示符：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you want to get a list of all the database''s tables, you can use the command
    `.tables`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取数据库的所有表的列表，可以使用命令`.tables`：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here you can see that we have all the tables that we created through the `migrate`
    command.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到，我们通过`migrate`命令创建的所有表。
- en: 'To look at every table structure, you can use the command `.schema`, and we
    can use the option `--indent`, so the output will be displayed in a more readable
    manner:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看每个表的结构，可以使用命令`.schema`，我们可以使用选项`--indent`，这样输出将以更可读的方式显示：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These are the commands that I use the most when working with SQLite3 databases,
    but the command-line interface offers a variety of commands. You can use the `.help` command
    to get a list of all available commands.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我在使用SQLite3数据库时最常用的命令，但命令行界面提供了各种命令。你可以使用`.help`命令获取所有可用命令的列表。
- en: SQLite3 databases are very useful when creating prototypes, creating proof of
    concept projects, or for creating really small projects. If our project does not
    fall in any of these categories, I would recommend using other SQL databases,
    such as MySQL, Postgres, and Oracle. There are also non-SQL databases, such as
    MongoDB. With Django, you can use any of these databases without any problem;
    if you are using the Django **ORM** (**Object relation model**), most of the time
    you can switch between databases, and the application will continue to work perfectly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建原型、概念验证项目或者创建非常小的项目时，SQLite3数据库非常有用。如果我们的项目不属于这些类别中的任何一种，我建议使用其他SQL数据库，比如MySQL、Postgres和Oracle。还有非SQL数据库，比如MongoDB。使用Django，你可以毫无问题地使用这些数据库；如果你使用Django的ORM（对象关系模型），大部分时间你可以在不同的数据库之间切换，应用程序仍然可以完美地工作。
- en: Looking at the project's package directory
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看项目的包目录
- en: Next, let's have a look at the project's package directory. There, you will
    find a bunch of files. The first file you will see is `settings.py`, which is
    a very important file, as it is where you are going to put all the settings of
    our application. In this settings file, you can specify which apps and database
    you will use, and you can also tell Django where to search for static files and
    templates, middlewares, and more.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看项目的包目录。在那里，你会找到一堆文件。你会看到的第一个文件是`settings.py`，这是一个非常重要的文件，因为你将在这里放置我们应用程序的所有设置。在这个设置文件中，你可以指定将使用哪些应用程序和数据库，你还可以告诉Django在哪里搜索静态文件和模板、中间件等。
- en: 'Then you have the `urls.py`; this file is where you specify the URLs that will
    be available on your application. You can setup URLs on the project level but
    also for every Django app. If you examine the contents of this `urls.py` file,
    you won''t find much detail. Basically, you will see text explaining how to add
    new URLs, but Django has defined (out of the box) a URL to the Django admin site:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你有`urls.py`；这个文件是你指定应用程序可用的URL的地方。你可以在项目级别设置URL，也可以为每个Django应用程序设置URL。如果你检查这个`urls.py`文件的内容，你不会找到太多细节。基本上，你会看到一些解释如何添加新的URL的文本，但Django已经定义了（开箱即用）一个URL到Django管理站点：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We are going to go through the process of adding new URLs to the project, but
    we can explain this file anyway; remember when I mentioned that in Django you
    can have diverse apps? So `django.contrib.admin` is also an app, and an app has
    its own set of URLs, views, templates. So what it is doing here? When we import
    the admin app and then define a list called `urlpatterns`, in this list we use
    a function path where the first argument is the URL, and the second argument here
    can be a view that is going to be executed. But in this case, it is passing the
    URLs of the `admin.site` app, which means that `admin/` will be the base URL,
    and all the URLs defined in `admin.site.urls` will be created under it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步介绍如何向项目添加新的URL，但无论如何我们都可以解释这个文件；还记得我提到过在Django中可以有不同的应用吗？所以`django.contrib.admin`也是一个应用，而一个应用有自己的一组URL、视图、模板。那么它在这里做什么？当我们导入admin应用然后定义一个名为`urlpatterns`的列表时，在这个列表中我们使用一个名为path的函数，第一个参数是URL，第二个参数可以是一个将要执行的视图。但在这种情况下，它传递了`admin.site`应用的URL，这意味着`admin/`将是基本URL，而`admin.site.urls`中定义的所有URL将在其下创建。
- en: 'For example, if in `admin.site.url`, I have defined two URLs, `users/` and
    `groups/`, when I have `path(''admin/'', admin.site.urls)`, I will be actually
    creating two URLs:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果在`admin.site.url`中，我定义了两个URL，`users/`和`groups/`，当我有`path('admin/', admin.site.urls)`时，我实际上将创建两个URL：
- en: '`admin/users/`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`admin/users/`'
- en: '`admin/groups/`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`admin/groups/`'
- en: Lastly, we have the `wsgi.py`, which is a simple WSGI configuration that Django
    creates for us when creating a new project.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`wsgi.py`，这是Django在创建新项目时为我们创建的一个简单的WSGI配置。
- en: Now that we are a bit more familiar with the Django's project structure, it
    is time to create our project's first app.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Django项目的结构有了一些了解，是时候创建我们项目的第一个应用了。
- en: Creating the project's main app
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目的主要应用
- en: In this section, we are going to create our first Django app. One Django project
    can contain multiple apps. Splitting the project into apps is a good practice
    for many reasons; the most obvious is that you can reuse the same app across different
    projects. Another reason to split the project into multiple apps is that it enforces
    separation of concerns. Your project will be more organized, easier to reason,
    and our colleagues will thank you because it will be much easier to maintain.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建我们的第一个Django应用程序。一个Django项目可以包含多个应用程序。将项目拆分为应用程序是一个很好的做法，原因有很多；最明显的是你可以在不同的项目中重用相同的应用程序。将项目拆分为多个应用程序的另一个原因是它强制实现关注点的分离。你的项目将更有组织，更容易理解，我们的同事会感谢你，因为这样维护起来会更容易。
- en: 'Let''s go ahead and run the command `startapp`, and, as shown before, you can
    either use the `django-admin` command or use `manager.py`. As we created the project
    using the `django-admin` command, it is a good opportunity to test the `manager.py`
    command. To create a new Django app, run the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续运行`startapp`命令，并且，如前所示，你可以使用`django-admin`命令或者使用`manager.py`。由于我们使用`django-admin`命令创建了项目，现在是一个很好的机会来测试`manager.py`命令。要创建一个新的Django应用程序，请运行以下命令：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we are going to create an app named `main`. Don't worry that no output
    is displayed, Django creates the project and the app silently. If you get a list
    of the directory contents now, you will see that there is a directory named `main`,
    and inside the `main` directory you will find some files; we are going to explain
    every file while we are adding changes to it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个名为`main`的应用程序。不要担心没有显示任何输出，Django会悄悄地创建项目和应用程序。如果你现在列出目录内容，你会看到一个名为`main`的目录，而在`main`目录中你会找到一些文件；我们将在添加更改时解释每个文件。
- en: 'So, the first thing we want to do is to add a landing page to our application.
    To do that, we have to do three things:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们想要做的第一件事是为我们的应用程序添加一个登陆页面。为此，我们需要做三件事：
- en: First, we add a new URL to tell Django that when a user of our site browses
    to the root, it should go the site `/` and display some content
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们添加一个新的URL，告诉Django当我们网站的用户浏览到根目录时，它应该转到站点`/`并显示一些内容
- en: The second step is to add a view that will be executed when the user browses
    to the site's root ``/``
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二步是添加一个视图，当用户浏览到站点的根目录``/``时将执行该视图
- en: The last step is to add an HTML template with the content that we want to display
    to the users
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一步是添加一个包含我们希望向用户显示的内容的HTML模板
- en: 'With that said, we need to include a new file called `urls.py` inside of the
    `main` app directory. First, we add some imports:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，我们需要在`main`应用程序目录中包含一个名为`urls.py`的新文件。首先，我们添加一些导入：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding code, we imported the function path from `django.urls`. The
    path function will return an element to be included in the `urlpatterns` list,
    and we also import the views file in the same directory; we want to import this
    view because it is there that we are going to define functions that will be executed
    when a specific route is accessed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们从`django.urls`中导入了path函数。path函数将返回一个要包含在`urlpatterns`列表中的元素，我们还在同一目录中导入了views文件；我们想要导入这个视图，因为我们将在那里定义在访问特定路由时将执行的函数：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Then we use the path function to define a new route. The first argument of the
    function path is a string that contains the URL pattern that we wish to make available
    in our application. This pattern may contain angle brackets (for example, `<int:user_id>`)
    to capture parameters passed on the URL, but, at this point, we are not going
    use it; we just want to add a URL for the application's root, so we add an empty
    string `''`. The second argument is the function that is going to be executed,
    and, optionally, you can add the keyword argument `name`, which sets the URL's
    name. We will see why this is useful in a short while.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用path函数来定义一个新的路由。函数path的第一个参数是一个包含我们希望在应用程序中提供的URL模式的字符串。这个模式可能包含尖括号（例如`<int:user_id>`）来捕获URL上传递的参数，但是在这一点上，我们不打算使用它；我们只是想为应用程序的根添加一个URL，所以我们添加一个空字符串`''`。第二个参数是将要执行的函数，可选地，您可以添加关键字参数`name`，它设置URL的名称。我们很快就会看到为什么这很有用。
- en: 'The second part is to define the function called `index` in the `views.py`
    file, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是在`views.py`文件中定义名为`index`的函数，如下所示：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As there are not too many things going on at this point, we first import the
    render function from `django.shortcuts`. Django has its own template engine that
    is built into the framework, and it is possible to change the default template
    engine to other template engines you like (such as Jinja2, which is one of the
    most popular template engines in the Python ecosystem), but, for simplicity, we
    are going to use the default engine. The `render` function gets the request object,
    the template, and a context object; the latter is an object that contains data
    to be displayed in the template.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此时没有太多事情要做，我们首先从`django.shortcuts`中导入render函数。Django有自己的模板引擎，内置在框架中，可以将默认模板引擎更改为您喜欢的其他模板引擎（例如Jinja2，这是Python生态系统中最受欢迎的模板引擎之一），但是为了简单起见，我们将使用默认引擎。`render`函数获取请求对象、模板和上下文对象；后者是一个包含要在模板中显示的数据的对象。
- en: 'The next thing we need to do is to add a template that will contain the content
    that we want to display when the user browses to our application. Now, most of
    the web application''s pages contain parts that never change, such as a top menu
    bar or a page''s footer, and these parts can be put into a separate template that
    can be reused by other templates. Luckily, the Django template engine has this
    feature. In fact, we can not only inject sub-templates inside a template, but
    also we can have a base template that will contain the HTML that will be shared
    between all of the pages. With that said, we are going to create a file called
    `base.html` inside the `gamestore/templates` directory that has the following
    contents:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的下一件事是添加一个模板，该模板将包含我们希望在用户浏览我们的应用程序时显示的内容。现在，大多数Web应用程序的页面包含永远不会改变的部分，例如顶部菜单栏或页面页脚，这些部分可以放入一个单独的模板中，可以被其他模板重用。幸运的是，Django模板引擎具有这个功能。事实上，我们不仅可以在模板中注入子模板，还可以有一个基本模板，其中包含将在所有页面之间共享的HTML。说到这一点，我们将在`gamestore/templates`目录中创建一个名为`base.html`的文件，其中包含以下内容：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We are not going to go through all the HTML parts, just the parts that are
    the specific syntax of Django''s template engine:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算逐个讨论所有HTML部分，只讨论Django模板引擎的特定语法部分：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The first thing to note here is `{% load static %}`, which will tell Django''s
    template engine that we want to load the static template tag. The static template
    tag is used to link static files. These files can be images, JavaScript, or Stylesheet
    files. How does Django find those files, you may ask, and the answer is simple:
    by magic! No, just kidding; the static template tag will look for the files in
    the directory specified in the `STATIC_ROOT` variable in the `settings.py` file;
    in our case we defined `STATIC_ROOT = ''/static/''`, so when using the tag `{%
    static ''styles/site.css'' %}` the link `/static/styles/site.css` will be returned.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的第一件事是`{% load static %}`，它将告诉Django的模板引擎我们要加载静态模板标签。静态模板标签用于链接静态文件。这些文件可以是图像、JavaScript或样式表文件。你可能会问，Django是如何找到这些文件的呢，答案很简单：通过魔法！不，开玩笑；静态模板标签将在`settings.py`文件中的`STATIC_ROOT`变量指定的目录中查找文件；在我们的情况下，我们定义了`STATIC_ROOT
    = '/static/'`，所以当使用标签`{% static 'styles/site.css' %}`时，链接`/static/styles/site.css`将被返回。
- en: You may be wondering, why not just write `/static/styles/site.css` instead of
    using the tag? The reason for this is that the tag gives us much more flexibility
    for change in case we need to update the path where we serve our static files.
    Imagine a situation where you have a large application with hundreds of templates,
    and in all of them, you hardcode `/static/` and then decide to change that path
    (and you don't have a team). You would need to change every single file to perform
    this change. If you use the static tag, you can simply move the files to a different
    location, and the tag changes the value of the `STATIC_ROOT` variable in the settings
    files.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么不只写`/static/styles/site.css`而不使用标签？这样做的原因是，标签为我们提供了更多的灵活性，以便在需要更新我们提供静态文件的路径时进行更改。想象一种情况，你有一个包含数百个模板的大型应用程序，在所有这些模板中，你都硬编码了`/static/`，然后决定更改该路径（而且你没有团队）。你需要更改每个文件来执行此更改。如果你使用静态标签，你只需将文件移动到不同的位置，标签就会更改`STATIC_ROOT`变量在设置文件中的值。
- en: 'Another tag that we are using in this template is the `block` tag:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个模板中使用的另一个标签是`block`标签：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `block` tag is very simple; it defines an area in the base template that
    can be used by children templates to inject content in that area. We are going
    to see exactly how this works when we create the next template file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`block`标签非常简单；它定义了基本模板中可以被子模板用来在该区域注入内容的区域。当我们创建下一个模板文件时，我们将看到这是如何工作的。'
- en: 'The third part is to add the template. The `index` function is going to render
    a template stored at `main/index.html`, which means that it will leave it in the
    directory `main/templates/main/`. Let''s go ahead and create the folder `main/templates`
    and then `main/templates/main`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第三部分是添加模板。`index`函数将呈现存储在`main/index.html`的模板，这意味着它将留在`main/templates/main/`目录中。让我们继续创建文件夹`main/templates`，然后`main/templates/main`：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a file called `index.html`  in the directory `main/templates/main/`,
    with the contents as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main/templates/main/`目录中创建一个名为`index.html`的文件，内容如下：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, here, we start off by extending the base template, which means
    that all the content of the `base.html` file will be used by the Django template
    engine to build the HTML that will be provided back to the browser when the user
    browses to `/`. Now, we also use the `block` tag; in this context, it means that
    the engine will search for a block tag named `'content'` in the `base.html` file,
    and, if it finds it, the engine will insert the `h1 html` tab inside the `'content'`
    block.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，我们首先扩展了基本模板，这意味着`base.html`文件的所有内容将被Django模板引擎用来构建HTML，当用户浏览到`/`时，将提供给浏览器。现在，我们还使用了`block`标签；在这种情况下，它意味着引擎将在`base.html`文件中搜索名为`'content'`的块标签，如果找到，引擎将在`'content'`块中插入`h1
    html`标签。
- en: This is all about reusability and maintainability of code, because you don't
    need to insert the menu markup and tags to load JavaScript and CSS files in every
    single template of our application; you just need to insert them in the base template
    and use the `block` tag here. The content will change. A second reason to use
    base templates is that, again, imagine a situation where you need to change something—let's
    say the top menu that we defined in the `base.html` file, as the menu is only
    defined in the `base.html` file. All you need to do to perform changes is to change
    the markup in the `base.html`, and all the other templates will inherit the changes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是关于代码的可重用性和可维护性，因为你不需要在我们应用程序的每个单个模板中插入菜单标记和加载JavaScript和CSS文件的标记；你只需要在基本模板中插入它们并在这里使用`block`标签。内容会改变。使用基本模板的第二个原因是，再次想象一种情况，你需要改变一些东西——比如我们在`base.html`文件中定义的顶部菜单，因为菜单只在`base.html`文件中定义。要执行更改，你只需要在`base.html`中更改标记，所有其他模板将继承更改。
- en: We are almost ready to run our code and see how the application is looking so
    far, but, first, we need to install some client-side dependencies.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好运行我们的代码并查看应用程序目前的外观了，但首先，我们需要安装一些客户端依赖项。
- en: Installing client-side dependencies
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装客户端依赖项
- en: 'Now that we have NodeJS installed, we can install the project''s client-side
    dependencies. As the focus of this chapter is Django and Python, we don''t want
    to spend too much time styling our application and going through huge CSS files.
    However, we do want our application to look great, and for this reason we are
    going to install two things: Bootstrap and Font Awesome.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了NodeJS，我们可以安装项目的客户端依赖项。由于本章的重点是Django和Python，我们不想花太多时间来设计我们的应用程序并浏览庞大的CSS文件。然而，我们希望我们的应用程序看起来很棒，因此我们将安装两样东西：Bootstrap和Font
    Awesome。
- en: Bootstrap is a very well-known toolkit that has been around for many years.
    It has a very nice set of components, a grid system, and plugins that will help
    us make our application look great for our users when they are browsing the application
    on a desktop, or even a mobile device.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap是一个非常著名的工具包，已经存在多年了。它有一套非常好的组件、网格系统和插件，将帮助我们使我们的应用程序在用户在桌面上浏览应用程序或者甚至移动设备上浏览应用程序时看起来很棒。
- en: Font Awesome is another project that has been around for a while, and it is
    a font and icons framework.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Font Awesome是另一个存在已久的项目，它是一个字体和图标框架。
- en: To install these dependencies, we could just run the npm's install command.
    However, we are going to do better. Similar to `pipenv`, which creates a file
    for our Python dependencies, `npm` has something similar. This file is called
    `package.json`, and it contains not only the project's dependencies but also scripts
    and meta information about the package.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这些依赖项，我们可以直接运行npm的安装命令。然而，我们要做得更好。类似于`pipenv`，它为我们的Python依赖项创建一个文件，`npm`也有类似的东西。这个文件叫做`package.json`，它不仅包含了项目的依赖项，还包含了关于包的脚本和元信息。
- en: 'So let''s go ahead and add the `package.json` file to the `gamestore/` directory,
    with the following content:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续将`package.json`文件添加到`gamestore/`目录中，内容如下：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Great! Save the file, and run this command on the terminal:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！保存文件，并在终端上运行以下命令：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If everything goes well, you should see a message saying that two packages have
    been installed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该会看到一条消息，说明已安装了两个软件包。
- en: If you list the contents of the `gamestore` directory, you will see that `npm`
    created a new directory called `node_modules`, and it is there that `npm` installed
    Bootstrap and Font Awesome.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列出`gamestore`目录的内容，您将看到`npm`创建了一个名为`node_modules`的新目录，`npm`安装了Bootstrap和Font
    Awesome。
- en: For simplicity, we are going to just copy the CSS files and fonts that we need
    to the `static` folder. However, when building an application, I would recommend
    using tools such as `webpack`, which will bundle all our client-side dependencies
    and set up a `webpack` dev server to serve the files for your Django application.
    Since we want to focus on Python and Django we can just go ahead and copy the
    files manually.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们将只复制我们需要的CSS文件和字体到`static`文件夹。 但是，在构建应用程序时，我建议使用诸如`webpack`之类的工具，它将捆绑所有我们的客户端依赖项，并设置`webpack`开发服务器来为您的Django应用程序提供文件。
    由于我们想专注于Python和Django，我们可以继续手动复制文件。
- en: 'First, we can create the directory of the CSS files as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以按以下方式创建CSS文件的目录：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then we need to copy the bootstrap files. First, the minified CSS file:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要复制bootstrap文件。 首先是最小化的CSS文件：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we need to copy the Font Awesome files, starting with the minified CSS:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要复制Font Awesome文件，从最小化的CSS开始：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And the fonts:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 和字体：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We are going to add another CSS file that will contain some custom CSS that
    we may add to the application to give a personal touch to the application. Add
    a file called `site.css` in the `gamestore/static/styles` directory with the following
    contents:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加另一个CSS文件，其中将包含我们可能添加到应用程序中的一些自定义CSS，以赋予应用程序个性化的外观。 在`gamestore/static/styles`目录中添加一个名为`site.css`的文件，内容如下：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'There are a few things we need to do to run our application for the first time;
    first, we need to add the main app that we created to the `INSTALLED_APPS` list
    in the `settings.py` file in the `gamestore/gamestore` directory. It should look
    like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做一些事情来第一次运行我们的应用程序； 首先，我们需要将我们创建的主应用程序添加到`gamestore/gamestore`目录中的`settings.py`文件的`INSTALLED_APPS`列表中。
    它应如下所示：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the same settings file you will find the list `TEMPLATES`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一设置文件中，您将找到列表`TEMPLATES`：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The value of `DIRS` is an empty list. We need to change it to:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`DIRS`的值是一个空列表。 我们需要将其更改为：'
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: That will tell Django to search for templates in the `templates` directory.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉Django在`templates`目录中搜索模板。
- en: 'Then, at the end of the `settings.py` file, add the following line:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`settings.py`文件的末尾添加以下行：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will tell Django to search for static files in the `gamestore/static` directory.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉Django在`gamestore/static`目录中搜索静态文件。
- en: 'Now we need to tell Django to register the URLs that we have defined in the
    `main` app. So, let''s go ahead and open the file `urls.py` in the `gamestore/gamestore`
    directory. We need to include  `"main.urls"` in the `urlpatterns` list. After
    the changes, the `urls.py` file should look like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要告诉Django注册我们在`main`应用程序中定义的URL。 因此，让我们继续打开`gamestore/gamestore`目录中的文件`urls.py`。
    我们需要在`urlpatterns`列表中包含`"main.urls"`。 更改后，`urls.py`文件应如下所示：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that we also need to import the `include` function of the `django.urls`
    module.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还需要导入`django.urls`模块的`include`函数。
- en: 'Great! Now we have all the client-site dependencies in place and ready to be
    used by our application, and we can start the application for the first time to
    see the changes that we have implemented so far. Open the terminal, and use the
    command `runserver` to start Django''s development server, like so:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！ 现在我们已经准备好使用我们的应用程序中的所有客户端依赖项，并且可以第一次启动应用程序以查看我们迄今为止实施的更改。 打开终端，并使用`runserver`命令启动Django的开发服务器，如下所示：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Browse to `http://localhost:8000`; you should see a page like the one shown
    in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到`http://localhost:8000`； 您应该看到一个页面，类似于以下截图所示的页面：
- en: '![](assets/b2034c76-688d-456c-9e99-41b3b0429427.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b2034c76-688d-456c-9e99-41b3b0429427.png)'
- en: Adding login and logout views
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加登录和注销视图
- en: Every online store needs some sort of user management. Our application's users
    should be able to create an account, change their account details, obviously log
    in to our application so they can place orders, and also log out from the application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 每个在线商店都需要某种用户管理。 我们应用的用户应该能够创建帐户，更改其帐户详细信息，显然登录到我们的应用程序，以便他们可以下订单，还可以从应用程序注销。
- en: We are going to start adding the login and logout functionality. The good news
    is that it is super easy to implement in Django.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始添加登录和注销功能。 好消息是，在Django中实现这一点非常容易。
- en: First, we need to add a Django form to our login page. Django has a built-in
    form of authentication; however, we want to customize it, so we are going to create
    another class that inherits from the Django built-in `AuthenticationForm` and
    add our changes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的登录页面上添加一个Django表单。 Django有一个内置的身份验证表单； 但是，我们想要自定义它，所以我们将创建另一个类，该类继承自Django内置的`AuthenticationForm`并添加我们的更改。
- en: 'Create a file called `forms.py` in `gamestore/main/` with the following content:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在`gamestore/main/`中创建一个名为`forms.py`的文件，内容如下：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This class is quite simple. First, we import `forms` from the `django` module
    and the `AuthenticationForm` from `django.contrib.auth.forms`, and then we create
    another class, also called `AuthenticationForm`, which inherits from Django''s
    `AuthenticationForm`. Then we define two properties, the username and the password.
    We define the username as an instance of `CharField` , and there are some keyword
    arguments that we pass in its constructor. They are:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类非常简单。 首先，我们从`django`模块导入`forms`和从`django.contrib.auth.forms`导入`AuthenticationForm`，然后我们创建另一个类，也称为`AuthenticationForm`，它继承自Django的`AuthenticationForm`。
    然后我们定义两个属性，用户名和密码。 我们将用户名定义为`CharField`的一个实例，并在其构造函数中传递一些关键字参数。 它们是：
- en: '`max_length`, which, as the name suggests limits the size of the string to
    `50` characters.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_length`，顾名思义，限制字符串的大小为`50`个字符。'
- en: We also use the `widget` argument, which specifies how this property will be
    rendered on the page. In this case, we want to render it as an input text element,
    so we pass an instance to `TextInput`. It is possible to pass some options to
    the `widget`; in our case, here we pass `'class'`, which is the CSS class and
    the placeholder.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还使用了`widget`参数，指定了如何在页面上呈现此属性。在这种情况下，我们希望将其呈现为输入文本元素，因此我们传递了一个`TextInput`实例。可以向`widget`传递一些选项；在我们的情况下，这里我们传递了`'class'`，这是CSS类和占位符。
- en: All these options will be used when the template engine renders this property
    on the page.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板引擎在页面上呈现此属性时，所有这些选项都将被使用。
- en: The second property that we define here is the password. We also define it as
    a `CharField`, and, instead of passing `max_length`, this time we set the label
    to `'Password'`. The `widget` we set to `PasswordInput` so the template engine
    will render the field on the page as input with a type equal to the password,
    and, lastly, we define the same settings for this field class and placeholder.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义的第二个属性是密码。我们还将其定义为`CharField`，而不是传递`max_length`，这次我们将标签设置为`'Password'`。我们将`widget`设置为`PasswordInput`，这样模板引擎将在页面上将字段呈现为类型等于密码的输入，并且最后，我们为此字段类和占位符定义了相同的设置。
- en: 'Now we can start registering the new URLs for logging in and out. Open the
    file `gamestore/main/urls.py`. To start, we are going to add some `import` statements:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始注册新的登录和注销URL。打开文件`gamestore/main/urls.py`。首先，我们将添加一些`import`语句：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'After the `import` statements, we can start registering the authentication
    URLs. At the end of the `urlpattens` list, add the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`import`语句之后，我们可以开始注册身份验证URL。在`urlpattens`列表的末尾，添加以下代码：
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So, here we are creating a new URL, `'accounts/login'`, and when requesting
    this URL the function view `login` will be executed. The third argument for the
    path function is a dictionary with some options, and the `template_name` specifies
    the template that will be rendered on the page when browsing to the underlying
    URL. We also define the `authetication_form` with the `AuthenticationForm` value
    that we just created. Lastly, we set the keyword argument `name` to `login`; naming
    the URL is very helpful when we need to create a link for this URL and also improves
    maintainability, because changes in the URL itself won't require changes in the
    templates as the templates reference the URL by its name.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里我们创建了一个新的URL，`'accounts/login'`，当请求这个URL时，视图函数`login`将被执行。路径函数的第三个参数是一个带有一些选项的字典，`template_name`指定了浏览到底层URL时将呈现在页面上的模板。我们还使用`AuthenticationForm`值定义了`authetication_form`。最后，我们将关键字参数`name`设置为`login`；为这个URL命名在需要创建此URL的链接时非常有帮助，也提高了可维护性，因为URL本身的更改不会要求模板的更改，因为模板通过名称引用URL。
- en: 'Now that the login is in place, let''s add the logout URL:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在登录已经就位，让我们添加注销URL：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Similar to the login URL, in the logout URL we use the path function passing
    first the URL itself (`accounts/logout`); we pass the function logout that we
    imported from the Django built-in authentication views, and, as an option, we
    set `next_page` to `/`. This means that when the user logs out, we redirect the
    user to the application's root page. Lastly, we also name the URL as logout.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 与登录URL类似，在注销URL中，我们使用路径函数首先传递URL本身(`accounts/logout`)；我们传递了从Django内置认证视图中导入的函数logout，并且作为一个选项，我们将`next_page`设置为`/`。这意味着当用户注销时，我们将用户重定向到应用程序的根页面。最后，我们还将URL命名为logout。
- en: 'Great. Now it is time to add the templates. The first template that we are
    going to add is the login template. Create a file named `login.html` at `gamestore/templates/` with
    the following contents:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。现在是时候添加模板了。我们要添加的第一个模板是登录模板。在`gamestore/templates/`下创建一个名为`login.html`的文件，内容如下：
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this template, we also extend the base template, and we add the content of
    the login template with the content block that has been defined in the base template.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模板中，我们还扩展了基本模板，并且我们添加了登录模板的内容，其中包含在基本模板中定义的内容块。
- en: First, we create a `form` tag and set the method to `POST`. Then, we add the
    `csrf_token` tag. The reason we add this tag is to prevent cross-site request
    attacks, where a malicious site performs a request to our site on behalf of the
    current logged in user.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`form`标签，并将方法设置为`POST`。然后，我们添加`csrf_token`标签。我们添加此标签的原因是为了防止跨站点请求攻击，其中恶意站点代表当前登录用户执行请求到我们的站点。
- en: If you want to know more about this type of attack, you can visit the site at [https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于这种类型的攻击，您可以访问网站[https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))。
- en: 'After the Cross-Site Request Forgery tag, we add the two fields we need: username
    and password.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在跨站点请求伪造标记之后，我们添加了我们需要的两个字段：用户名和密码。
- en: 'Then we have the following markup:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有以下标记：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is where we are going to display possible authentication errors. The forms
    object has a property called `non_field_error`, which contains errors that are
    not related to field validation. For example, if your user types the wrong username
    or password, then the error will be added the to `non_field_error` list.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将显示可能的身份验证错误的地方。表单对象有一个名为`non_field_error`的属性，其中包含与字段验证无关的错误。例如，如果您的用户输入了错误的用户名或密码，那么错误将被添加到`non_field_error`列表中。
- en: We create a `ul` element (unordered list) and loop through the `non_field_errors`
    list adding `li` elements (list items) with the error text.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`ul`元素（无序列表）并循环遍历`non_field_errors`列表，添加带有错误文本的`li`元素（列表项）。
- en: 'We have now the login in place, and we need to just include it to the page—more
    specifically, to the `base.html` template. But, first, we need to create a little
    partial template that will display the login and logout links on the page. Go
    ahead and add a file called `_loginpartial.html` to the `gamestore/templates`
    directory that has the following contents:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经放置了登录，并且只需要将其包含到页面中-更具体地说，是到`base.html`模板。但是，首先，我们需要创建一个小的部分模板，它将在页面上显示登录和注销链接。继续添加一个名为`_loginpartial.html`的文件到`gamestore/templates`目录，其中包含以下内容：
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This partial template will render two different contents depending on whether
    the user is authenticated or not. If the user is authenticated, it will render
    the logout form. Note that the action of the form makes use of the named URL;
    we don't set it to `/accounts/logout` but to `{% url 'logout' %}`.Django's URL
    tag will replace the URL name with the URL. Again, we need to add the `csrf_token`
    tag to prevent Cross-Site Request Forgery attacks, and, finally, we define an
    unordered list with two items; the first item will display the text `Logged as:`
    and the user's username, and the second item on the list will show the logout
    button.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分模板将根据用户是否经过身份验证而呈现两种不同的内容。如果用户已经过身份验证，它将呈现注销表单。请注意，表单的操作使用了命名URL；我们没有将其设置为`/accounts/logout`，而是设置为`{%
    url 'logout' %}`。Django的URL标记将使用URL名称替换URL。同样，我们需要添加`csrf_token`标记以防止跨站点请求伪造攻击，最后，我们定义了一个无序列表，其中有两个项目；第一项将显示文本`Logged
    as:`和用户的用户名，列表中的第二项将显示注销按钮。
- en: Note that we added an anchor tag inside of the list item element, and that the
    `href` property has some JavaScript code in it. That code is pretty simple; it
    uses the function `getElementById` to get the form and then call the form's submit
    function to submit to the server the request to `/accounts/logout`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在列表项元素中添加了一个锚标签，并且`href`属性中有一些JavaScript代码。该代码非常简单；它使用`getElementById`函数获取表单，然后调用表单的提交函数将请求提交到服务器的`/accounts/logout`。
- en: This is just a preference for implementation; you could easily have skipped
    this JavaScript code and added a submit button instead. It would have the same
    effect.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对实现的偏好；您可以轻松地跳过此JavaScript代码并添加提交按钮。它会产生相同的效果。
- en: In case the user is not authenticated, we only show the `login` link. The `login`
    link also uses the URL tag that will replace the name `login` with the URL.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户未经过身份验证，我们只显示`登录`链接。`登录`链接还使用URL标记，该标记将使用URL替换名称`login`。
- en: 'Great! Let''s add the login partial template to the base template. Open the
    file `base.html` at `gamestore/templates`, and locate the unordered list, shown
    as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！让我们将登录部分模板添加到基本模板中。打开`gamestore/templates`中的`base.html`文件，并找到无序列表，如下所示：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We are going to add the `_loginpartial.html` template using the `include` tag:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`include`标签添加`_loginpartial.html`模板：
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The include tag will inject the content of the `_loginpartial.html` template
    in this position in the markup.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: include标签将在标记中的此位置注入`_loginpartial.html`模板的内容。
- en: 'The final touch here is to add some styling, so the login page looks nice like
    the rest of the application. Open the file `site.css` in the `gamestore/static/styles` directory,
    and include the following contents:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是添加一些样式，使登录页面看起来像应用程序的其余部分一样好看。打开`gamestore/static/styles`目录中的`site.css`文件，并包含以下内容：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Testing the login/logout forms
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试登录/注销表单
- en: 'Before we try this out, let''s open the file `settings.py` in the `gamestore/gamestore`
    directory, and at the end of the file add the following setting:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试此操作之前，让我们打开`gamestore/gamestore`目录中的`settings.py`文件，并在文件末尾添加以下设置：
- en: '[PRE53]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This will tell Django that, after the login, the user will be redirected to
    "`/`".
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉Django，在登录后，用户将被重定向到“/”。
- en: 'Now we are ready to test the login and logout functionality, although you probably
    don''t have any users in the database. However, we created the superuser while
    we were setting up our Django project, so go ahead and try logging in with that
    user. Run the command `runserver` to start the Django development server again:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备测试登录和注销功能，尽管您可能在数据库中没有任何用户。但是，我们在设置Django项目时创建了超级用户，所以继续尝试使用该用户登录。运行命令`runserver`再次启动Django开发服务器：
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Browse to `http://localhost:8000` and note that you now have the login link
    in the top right corner of the page:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到`http://localhost:8000`，请注意您现在在页面的右上角有登录链接：
- en: '![](assets/6d74e76d-f481-4eec-9dc9-d8ad6b061fa5.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6d74e76d-f481-4eec-9dc9-d8ad6b061fa5.png)'
- en: 'If you click that, you will be redirected to `/accounts/login`, and the login
    page template that we created will be rendered:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击，您将被重定向到`/accounts/login`，并且将呈现我们创建的登录页面模板：
- en: '![](assets/3025a9a4-9ae4-4eed-b361-54290b3e87a9.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3025a9a4-9ae4-4eed-b361-54290b3e87a9.png)'
- en: 'First, try typing the wrong password or username so we can verify that the
    error message is being displayed correctly:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，尝试输入错误的密码或用户名，以便我们可以验证错误消息是否正确显示：
- en: '![](assets/ff28669a-804e-448a-9452-632421a24126.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ff28669a-804e-448a-9452-632421a24126.png)'
- en: Great! It works!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！它有效！
- en: 'Now log in with the superuser, and if everything works fine, you should be
    redirected to the application root''s URL. It says, Logged as with your username,
    and right after it there is a logout link. Give it a go, and click on the link
    Log off:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用超级用户登录，如果一切正常，您应该被重定向到应用程序根URL。它说，以您的用户名登录，然后就会有一个注销链接。试一试，点击注销链接：
- en: '![](assets/6490f579-a5ca-4bcb-9106-699f74da2029.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6490f579-a5ca-4bcb-9106-699f74da2029.png)'
- en: Creating new users
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新用户
- en: Now that we are able to log in and log out of our application, we need to add
    another page so the users can create accounts on our application and place orders.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够登录和注销我们的应用程序，我们需要添加另一个页面，以便用户可以在我们的应用程序上创建帐户并下订单。
- en: 'There are some rules that we want to enforce when creating a new account. The
    rules are:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新帐户时，我们希望强制执行一些规则。规则是：
- en: The username field is required, and it has to be unique to our application
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名字段是必需的，并且必须对我们的应用程序是唯一的
- en: The email field is required, and it has to be unique to our application
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮箱字段是必需的，并且必须在我们的应用程序中是唯一的
- en: The last and first name are required
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名字和姓氏都是必需的
- en: Both password fields are required, and they must match
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个密码字段都是必需的，并且它们必须匹配
- en: If any of these rules are not followed, we will not create the user account,
    and an error should be returned to the user.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些规则中有任何一个没有被遵循，我们将不会创建用户账户，并且应该向用户返回一个错误。
- en: 'With that said, let''s add a small helper function that will verify whether
    a field has a value that already exists in the database. Open the file `forms.py` in `gamestore/main`.
    First, we need to import the User model:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，让我们添加一个小的辅助函数，用于验证字段是否具有数据库中已存在的值。打开`gamestore/main`目录下的`forms.py`文件。首先，我们需要导入User模型：
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, add the `validate_unique_user` function:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加`validate_unique_user`函数：
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This function gets an error message and keyword arguments that will be used
    as a criterion to search for items matching a specific value. We create a variable
    called `existent_user`, and filter the user models passing the criteria. If the
    value of the variable `existent_user` is different to `None`, it means that we
    have found a user who matches our criterion. We then raise a `ValidationError`
    exception with the error message that we passed to the function.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数获取一个错误消息和关键字参数，这些参数将被用作搜索与特定值匹配的项目的条件。我们创建一个名为`existent_user`的变量，并通过传递条件来过滤用户模型。如果变量`existent_user`的值与`None`不同，这意味着我们找到了一个符合我们条件的用户。然后，我们使用传递给函数的错误消息引发一个`ValidationError`异常。
- en: 'Nice. Now we can start adding a form that will contain all the fields that
    we want the user to fill out when creating an account. In the same file, `forms.py` in
    the `gamestore/main` directory, add the following class:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。现在我们可以开始添加一个包含用户在创建账户时需要填写的所有字段的表单。在`gamestore/main`目录下的`forms.py`文件中，添加以下类：
- en: '[PRE57]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: So, we start by creating a class called `SignupForm` that will inherit from
    `Form`, we define a property for every field that is going to be necessary for
    creating a new account, and we add a username, a first and a last name, an email,
    and then two password fields. Note that in the password fields we set the min
    and max length for a password to `6` and `10`, respectively.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先创建一个名为`SignupForm`的类，它将继承自`Form`，我们为创建新账户所需的每个字段定义一个属性，然后添加一个用户名、名字和姓氏、一个电子邮件，然后两个密码字段。请注意，在密码字段中，我们将密码的最小和最大长度分别设置为`6`和`10`。
- en: 'Continuing in the same class, `SignupForm`, let''s add a method called `clean_username`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个类`SignupForm`中，让我们添加一个名为`clean_username`的方法：
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The prefix `clean` in the name of this method will make Django automatically
    call this method when parsing the posted data for the field; in this case, it
    will execute when parsing the field username.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的名称中的前缀`clean`将使Django在解析字段的发布数据时自动调用此方法；在这种情况下，它将在解析字段用户名时执行。
- en: So, we get the username value, and then call the method `validate_unique_user`,
    passing a default error message and a keyword argument username that will be used
    as a filter criterion.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们获取用户名的值，然后调用`validate_unique_user`方法，传递一个默认的错误消息和一个关键字参数用户名，这将被用作过滤条件。
- en: 'Another field that we need to verify for uniqueness is the email ID, so let''s
    implement the `clean_email` method, as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要验证唯一性的另一个字段是电子邮件ID，因此让我们实现`clean_email`方法，如下所示：
- en: '[PRE59]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It is basically the same as the clean username. First, we get the email from
    the request and pass it to the `validate_unique_user` function. The first argument
    is the error message, and the second argument is the email that will be used as
    the filter criteria.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与清理用户名相同。首先，我们从请求中获取电子邮件并将其传递给`validate_unique_user`函数。第一个参数是错误消息，第二个参数是将用作过滤条件的电子邮件。
- en: 'Another rule that we defined for our create account page is that the password
    and (repeat) password fields must match, otherwise an error will be displayed
    to the user. So let''s add the same and implement the clean method, but this time
    we want to validate the `repeat_password` field and not `password`. The reason
    for that is that if we implement a `clean_password` function, at that point `repeat_password`
    won''t be available in the `cleaned_data` dictionary yet, because the data is
    parsed in the same order as they were defined in the class. So, to ensure that
    we will have both values we implement `clean_repeat_password`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为创建账户页面定义的另一个规则是密码和（重复）密码字段必须匹配，否则将向用户显示错误。因此，让我们添加相同的并实现`clean`方法，但这次我们要验证`repeat_password`字段而不是`password`。这样做的原因是，如果我们实现一个`clean_password`函数，在那时`repeat_password`在`cleaned_data`字典中还不可用，因为数据的解析顺序与它们在类中定义的顺序相同。因此，为了确保我们将有两个值，我们实现`clean_repeat_password`：
- en: '[PRE60]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Great. So here we first define two variables; `password1`, which is the request
    value for the `password` field, and `password2`, the request value for the field
    `repeat_password`. After that, we just compare if the values are different; if
    they are, we raise a `ValidationError` exception with the error message to inform
    the user that the password didn't match and the account will not be created.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。所以这里我们首先定义了两个变量；`password1`，它是`password`字段的请求值，`password2`，它是`repeat_password`字段的请求值。之后，我们只是比较这些值是否不同；如果它们不同，我们引发一个`ValidationError`异常，其中包含错误消息，通知用户密码不匹配，账户将不会被创建。
- en: Creating the views of the user creation
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户创建的视图
- en: 'With the form and validation in place, we can now add the view that will handle
    the request to create a new account. Open the file `views.py` at `gamestore/main`,
    and start by adding some `import` statements:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有了表单和验证，我们现在可以添加处理创建新账户请求的视图。打开`gamestore/main`目录下的`views.py`文件，并首先添加一些`import`语句：
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As we will be receiving data from a `POST` request, it is a good idea to add
    Cross-Site Request Forgery checkings, so we need to import the `csrf_protect`
    decorator.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将收到来自`POST`请求的数据，所以最好添加跨站点请求伪造检查，因此我们需要导入`csrf_protect`装饰器。
- en: We also import the `SignupForm` that we just created so we can pass it to the
    view or use it to parse the request data. Lastly, we import the `User` model.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还导入了刚刚创建的`SignupForm`，这样我们就可以将其传递给视图或用它来解析请求数据。最后，我们导入了`User`模型。
- en: 'So, let''s create the `signup` function:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们创建`signup`函数：
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We start by decorating the `signup` function with the `csrf_protect` decorator.
    The function starts by checking whether the request's HTTP method is equal to
    `POST`; in that case, it will create an instance of the `SignupForm` passing as
    an argument the `POST` data. Then we call the function `is_valid()` on the form,
    which will return true if the form is valid; otherwise it will return  false.
    If the form is valid, we create a new user and call the `save` function, and,
    finally, we render the `create_account_success.html`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先用`csrf_protect`装饰器装饰`signup`函数。函数首先检查请求的HTTP方法是否等于`POST`；在这种情况下，它将创建一个`SignupForm`的实例，将`POST`数据作为参数传递。然后我们在表单上调用`is_valid()`函数，如果表单有效，它将返回true；否则返回false。如果表单有效，我们将创建一个新用户并调用`save`函数，最后我们渲染`create_account_success.html`。
- en: If the request `HTTP` method is a `GET`, the only thing we do is create an instance
    of a `SignupForm` without any argument. After that, we call the `render` function,
    passing as a first argument the `request` object, then the template that we are
    going to render, and, finally, the last argument is the instance of the `SignupForm`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的`HTTP`方法是`GET`，我们所做的唯一事情就是创建一个没有参数的`SignupForm`实例。之后，我们调用`render`函数，将`request`对象作为第一个参数传递，然后是我们要渲染的模板，最后一个参数是`SignupForm`的实例。
- en: 'We are going to create both templates referenced in this function in a short
    while, but, first, we need to create a new URL in the `url.py` file at `gamestore/main`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快创建这个函数中引用的两个模板，但首先，我们需要在`gamestore/main`的`url.py`文件中创建一个新的URL：
- en: '[PRE63]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This new URL can be added right at the end of the `urlpatterns` list.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的URL可以直接添加到`urlpatterns`列表的末尾。
- en: 'We also need to create the templates. We start with the `signup` template;
    create a file called `signup.html` at `gamestore/main/templates/main` with the
    following contents:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建模板。我们从`signup`模板开始；在`gamestore/main/templates/main`中创建一个名为`signup.html`的文件，内容如下：
- en: '[PRE64]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This template is again very similar to the template that we created before,
    in that it extends the base template and injects some data into the base template's
    content block. We add an `h1` tag with the header text and a form with the action
    set to `{% url 'signup' %}`, which the `url` tag will change to `/accounts/signup`,
    and we set the method to `POST`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板与我们之前创建的模板非常相似，它扩展了基本模板并向基本模板的内容块注入了一些数据。我们添加了一个带有标题文本的`h1`标签和一个动作设置为`{%
    url 'signup' %}`的表单，`url`标签将其更改为`/accounts/signup`，并将方法设置为`POST`。
- en: As is usual in forms, we use the `csrf_token` tag that will work together with
    the `@csrf_protect` decorator in the `signup` function in the `views` file to
    protect against Cross-Site Request Forgery.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 和通常一样，在表单中，我们使用`csrf_token`标签，它将与`views`文件中的`signup`函数中的`@csrf_protect`装饰器一起工作，以防止跨站请求伪造。
- en: Then we just call `{{ form }}`, which will render the entire form in this area,
    and, right after the fields, we add a button to submit the form.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们只需调用`{{ form }}`，它将在这个区域中渲染整个表单，然后在字段后面添加一个提交表单的按钮。
- en: 'Lastly, we create a template for showing that the account has been successfully
    created. Add a file called `create_account_success.html` to the `gamestore/main/templates/main`
    directory with the following contents:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个模板，用于显示账户已成功创建的信息。在`gamestore/main/templates/main`目录下添加一个名为`create_account_success.html`的文件，内容如下：
- en: '[PRE65]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Great! To make it look great, we are going to include some CSS code in the
    file `site.css` in the `gamestore/static` directory. Add the content shown as
    follows, at the end of the file:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！为了使它看起来更好，我们将在`gamestore/static`目录中的`site.css`文件中包含一些CSS代码。在文件末尾添加如下内容：
- en: '[PRE66]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'That''s all for the create a user page; let''s give it a go! Start the Django
    developer server again, and browse to `http://localhost:8000/accounts/signup`,
    where you should see the create user form, as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是创建用户页面的全部内容；让我们试试吧！再次启动Django开发服务器，并浏览到`http://localhost:8000/accounts/signup`，您应该会看到创建用户表单，如下所示：
- en: '![](assets/ca34bdb6-e35e-4b9b-9425-9652ba21ef52.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ca34bdb6-e35e-4b9b-9425-9652ba21ef52.png)'
- en: 'After you fill up all the fields, you should be redirected to a confirmation
    page, like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 填写所有字段后，您应该被重定向到一个确认页面，如下所示：
- en: '![](assets/82ffe42c-8485-4150-8cb8-ec480a29ddd4.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/82ffe42c-8485-4150-8cb8-ec480a29ddd4.png)'
- en: Perform some tests yourself! Try adding invalid passwords, just to verify that
    the validations we implemented are working properly.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 自己进行一些测试！尝试添加无效的密码，以验证我们实现的验证是否正常工作。
- en: Creating the game data model
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游戏数据模型
- en: Alright, we can log into our application, we can create new users, and we also
    added the front page template, which is currently blank, but we are going to fix
    that. We have got to the core of this chapter; we are going to start adding models
    that will represent the items that we can buy at the store.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们可以登录到我们的应用程序，我们可以创建新用户，我们还添加了前台模板，目前是空白的，但我们将解决这个问题。我们已经到了本章的核心；我们将开始添加代表商店中可以购买的物品的模型。
- en: 'The requirements for the game''s model that we are going to have on the site
    is:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在网站上拥有的游戏模型的要求是：
- en: The store is going to sell games for different gaming platforms
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店将销售不同游戏平台的游戏
- en: There will be a section on the first page that will list highlighted games
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首页将有一个列出精选游戏的部分
- en: The users of the store should be able to go to the game's details page and see
    more information about the game
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店的用户应该能够转到游戏详情页面并查看有关游戏的更多信息
- en: The games should be discoverable by different criteria, for example, developer,
    publisher, release date, and so on
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏应该可以通过不同的标准进行发现，例如开发者、发布商、发布日期等。
- en: The administrator of the store should be able to change product details using
    the Django admin UI.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店的管理员应该能够使用Django管理界面更改产品详情。
- en: The product's picture can be changed, and if not found, it should show a default
    image
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品的图片可以更改，如果找不到，应该显示默认图片
- en: 'With that said, let''s start adding our first model class. Open the file `models.py`
    in `gamestore/main/`, and add the following code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们开始添加我们的第一个模型类。在`gamestore/main/`中打开文件`models.py`，并添加以下代码：
- en: '[PRE67]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, we have added the class `GamePlatform`, and it will represent the gaming
    platforms that will be available at the store. The class is super simple; we just
    create a class inheriting from the `Model` class, and we define just one property
    called `name`. The name property is defined as a `CharField` of a maximum length
    of 100 characters. Django provides a large variety of data types; you can see
    the complete list at [https://docs.djangoproject.com/en/2.0/ref/models/fields/](https://docs.djangoproject.com/en/2.0/ref/models/fields/).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了`GamePlatform`类，它将代表商店中可用的游戏平台。这个类非常简单；我们只需创建一个从`Model`类继承的类，并且我们只定义了一个名为`name`的属性。`name`属性被定义为最大长度为100个字符的`CharField`。Django提供了各种各样的数据类型；你可以在[https://docs.djangoproject.com/en/2.0/ref/models/fields/](https://docs.djangoproject.com/en/2.0/ref/models/fields/)上看到完整的列表。
- en: Then we override the method `__str__`. This method will dictate how an instance
    of `GamePlatform` will be displayed when being printed out. The reason that I
    am overriding this method is that I want to display the name of `GamePlatform`
    in the list of `GamePlatform` in the Django admin UI.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们重写了`__str__`方法。这个方法将决定`GamePlatform`的实例在被打印出来时如何显示。我重写这个方法的原因是我想在Django管理界面的`GamePlatform`列表中显示`GamePlatform`的名称。
- en: 'The second model class that we are going to add here is the `Game` model. In
    the same file, add the following code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要添加的第二个模型类是`Game`模型。在同一个文件中，添加以下代码：
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Like the previous model class that we created, the `Game` class also inherits
    from `Model` and we define all the fields that we need according to the specifications.
    There are some things to note here that are new; the property `release_year` is
    defined as an integer field, and we set the property `null=True`, which means
    that this field will not be required.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前创建的模型类一样，`Game`类也继承自`Model`，我们根据规格定义了所有需要的字段。这里有一些新的需要注意的地方；`release_year`属性被定义为整数字段，并且我们设置了`null=True`属性，这意味着这个字段不是必需的。
- en: Another property that used a different type is the image property, which is
    defined as an `ImageField`, and that will allow us to provide the application's
    administrators the possibility of changing the game's image. This type inherits
    from `FileField`, and in the Django Administration UI the field will be rendered
    as a file picker. The `ImageFile` argument `upload_to` specifies where the image
    will be stored, and the default is the default image that will be rendered if
    the game does not have an image. The last argument that we specify here is `max_length`,
    which is the image path's maximum length.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用不同类型的属性是图片属性，它被定义为`ImageField`，这将允许我们为应用程序的管理员提供更改游戏图片的可能性。这种类型继承自`FileField`，在Django管理界面中，该字段将被呈现为文件选择器。`ImageFile`参数`upload_to`指定了图片将被存储的位置，默认是游戏没有图片时将呈现的默认图片。我们在这里指定的最后一个参数是`max_length`，这是图片路径的最大长度。
- en: Then, we define a `ForeignKey`. If you don't know what it is, a foreign key
    is basically a file that identifies a row in another table. In our case, here
    we want the game platform to be associated with multiple games. There are a few
    keyword arguments that we are passing to the definition of the primary key; first
    we pass the foreign key type, the `null` argument is set to `False`, meaning that
    the field is required, and, lastly we set the deletion rule to `CASCADE`, so if
    the application's admin deletes a gaming platform, that operation will cascade
    and delete all the games associated with that specific gaming platform.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了一个`ForeignKey`。如果你不知道它是什么，外键基本上是一个标识另一个表中行的字段。在我们的例子中，这里我们希望游戏平台与多个游戏相关联。我们传递给主键定义的一些关键字参数；首先我们传递了外键类型，`null`参数设置为`False`，这意味着这个字段是必需的，最后我们将删除规则设置为`CASCADE`，所以如果应用程序的管理员删除了一个游戏平台，该操作将级联并删除与该特定游戏平台相关联的所有游戏。
- en: The last property that we define is the `highlighted` property. Do you remember
    that one of the requirements was to be able to highlight some products and also
    have them in a more visible area so the users can find them easily? This property
    does just that. It is a property type Boolean that has the default value set to
    `False`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的最后一个属性是`highlighted`属性。你还记得我们的一个要求是能够突出一些产品，并且让它们出现在更显眼的区域，以便用户能够轻松找到它们吗？这个属性就是做这个的。它是一个布尔类型的属性，其默认值设置为`False`。
- en: 'Another detail, that I was saving for last is this: have you noticed that we
    have a class named `Meta` inside the model class? This is the way that we can
    add meta information about the model. In this example we are setting a property
    called `ordering` with the value as an array of strings, where each item represents
    a property of the `Game` model, so we have first `-highlighted` - the dash sign
    in front of the property name means descending order—and then we also have the
    name, which will appear in ascending order.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个细节，我留到最后的是：你有没有注意到我们的模型类里有一个名为`Meta`的类？这是我们可以添加关于模型的元信息的方式。在这个例子中，我们设置了一个名为`ordering`的属性，其值是一个字符串数组，其中每个项代表`Game`模型的一个属性，所以我们首先有`-highlighted`，横杠符号表示降序排列，然后我们还有名称，它将以升序排列出现。
- en: 'Let''s continue adding more code to the class:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续向类中添加更多代码：
- en: '[PRE69]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, we have two things. First, we assign an instance of a class called `GameManager`,
    which I will go into in more detail in a short while, and we also define the special
    method `__str__`, which defines that when printing an instance of the `Game` object,
    it will display the gaming platform and a symbol dash, followed by the name of
    the name itself.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两件事。首先，我们分配了一个名为`GameManager`的类的实例，我稍后会详细介绍，我们还定义了特殊方法`__str__`，它定义了当打印`Game`对象的实例时，它将显示游戏平台和一个符号破折号，后跟名称本身的名称。
- en: 'Before the definition of the `Game`class, let''s add another class called `GameManager`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Game`类的定义之前，让我们添加另一个名为`GameManager`的类：
- en: '[PRE70]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Before we get into the details of this implementation, I just want to say a
    few words about `Manager` objects in Django. The `Manager` is the interface between
    the database and the model classes in Django. By default, every model class has
    a `Manager`, and it is accessed through the property objects, so why define our
    own manager? The reason that I implemented a `Manager` for this `models` class
    is that I wanted to leave all the code concerning database operations within the
    model, as it makes the code cleaner and more testable.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解这个实现的细节之前，我只想说几句关于Django中的`Manager`对象。`Manager`是Django中数据库和模型类之间的接口。默认情况下，每个模型类都有一个`Manager`，可以通过属性对象访问，那么为什么要定义自己的manager呢？我为这个`models`类实现了一个`Manager`的原因是我想把所有关于数据库操作的代码都留在模型内部，因为这样可以使代码更清晰、更易于测试。
- en: So, here I defined another class, `GameManager`, that inherits from `Manager`,
    and so far we defined three methods—`get_highlighted`, which get all games that
    have the highlighted flag set to `True`, `get_not_highlighted`, which gets all
    games that highlighted flag is set to `False`, and `get_by_platform`, which gets
    all the games given a gaming platform.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在这里我定义了另一个类`GameManager`，它继承自`Manager`，到目前为止我们定义了三个方法——`get_highlighted`，它获取所有标记为`True`的游戏，`get_not_highlighted`，它获取所有标记为`False`的游戏，`get_by_platform`，它获取给定游戏平台的所有游戏。
- en: 'About the two first methods in this class: I could have just used the filter
    function and passed an argument where `highlighted` equals `True` or `False`,
    but, as I mentioned previously, it is much cleaner to have all these methods inside
    the manager.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个类中的前两个方法：我本可以只使用过滤函数并传递一个参数，其中`highlighted`等于`True`或`False`，但正如我之前提到的，将所有这些方法放在管理器内部会更清晰。
- en: 'Now we are ready to create the database. In the terminal, run the following
    command:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备创建数据库。在终端中运行以下命令：
- en: '[PRE71]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This command will create a migration file with the changes that we just implemented
    in the model. When the migrations are created, we can run the command `migrate` and
    then apply the changes to the database:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将创建一个包含我们刚刚在模型中实现的更改的迁移文件。当创建迁移时，我们可以运行`migrate`命令，然后将更改应用到数据库：
- en: '[PRE72]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Great! Next up, we are going to create a model to store the game's prices.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！接下来，我们将创建一个模型来存储游戏的价格。
- en: Creating the price list data model
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建价格列表数据模型
- en: 'Another feature that we want to have in our application is the ability to change
    the prices of the products as well as knowing when a price was added and, most
    importantly, when it was last updated. To achieve this, we are going to create
    another model class, called `PriceList`*, *in the `models.py` file in the `gamestore/main/`
    directory, using the following code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在我们的应用程序中拥有的另一个功能是能够更改产品的价格，以及知道价格是何时添加的，最重要的是，它是何时最近更新的。为了实现这一点，我们将在`models.py`文件中的`gamestore/main/`目录中创建另一个模型类，称为`PriceList`，使用以下代码：
- en: '[PRE73]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As you can see here, you have two datetime fields. The first one is `added_at`,
    and it has a property `auto_now_add` equals `True`. What it does is get Django
    to automatically add the current date when we add this price to the table. The
    `last_update` field is defined with another argument, the `auto_now` equals `True`;
    this tells Django to set the current date every time an update occurs.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，你有两个日期时间字段。第一个是`added_at`，它有一个属性`auto_now_add`等于`True`。它的作用是让Django在我们将这个价格添加到表中时自动添加当前日期。`last_update`字段是用另一个参数定义的，`auto_now`等于`True`；这告诉Django在每次更新发生时设置当前日期。
- en: Then, we have a field for the price called `price_per_unit`, which is defined
    as a `DecimalField` with a maximum of `9` digits and `2` decimal places. This
    field is not required, and it will always `default` to `0`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个名为`price_per_unit`的价格字段，它被定义为一个最大为`9`位数和`2`位小数的`DecimalField`。这个字段不是必需的，它将始终默认为`0`。
- en: Next, we create a `OneToOneField` to create a link between the `PriceList` and
    the `Game` object. We define that when a game is deleted, the related row in the
    `PriceList` table will also be removed, and we define this field as the primary
    key.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`OneToOneField`来创建`PriceList`和`Game`对象之间的链接。我们定义当游戏被删除时，`PriceList`表中的相关行也将被删除，并将此字段定义为主键。
- en: Finally, we override the `__str__` method so that it returns the game's name.
    This will be helpful when updating prices using the Django admin UI.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们重写`__str__`方法，使其返回游戏的名称。这在使用Django管理界面更新价格时会很有帮助。
- en: 'Now we can make the migration files again:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以再次生成迁移文件：
- en: '[PRE74]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Apply the changes with the following command:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令应用更改：
- en: '[PRE75]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Perfect! Now we are ready to start adding the views and the templates to display
    our games on the page.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们准备开始添加视图和模板，以在页面上显示我们的游戏。
- en: Creating the game list and details page
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游戏列表和详细页面
- en: After creating the model for the games and the prices, we have reached the fun
    part of this section, which is to create the views and templates that will display
    the games on the page. Let's get started!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了游戏和价格的模型之后，我们已经到达了本节的有趣部分，即创建将在页面上显示游戏的视图和模板。让我们开始吧！
- en: 'So, we have created a template called `index.html` in `main/templates/main`,
    but we are not displaying anything on it. To make that page more interesting,
    we are going to add two things:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们在`main/templates/main`中创建了一个名为`index.html`的模板，但我们没有在上面显示任何内容。为了使该页面更有趣，我们将添加两件事：
- en: A section on the top of the page that will display the games that we want to
    highlight. It could be a new game that arrived at the store, a very popular game,
    or some game that has a good price for the moment.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 页面顶部的一个部分，将显示我们想要突出显示的游戏。它可以是新到店的游戏，非常受欢迎的游戏，或者某个目前价格很好的游戏。
- en: Following the section with the highlighted games, we are going to list all the
    other games.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在突出显示游戏的部分之后，我们将列出所有其他游戏。
- en: 'The first template that we are going to add is a partial view that will be
    used to list games. This partial view will be shared to all the templates that
    we want to display a list of games. This partial view will receive two arguments:
    `gameslist` and `highlight_games`. Let''s go ahead and add a file called `games-list.html`
    at `gamestore/main/templates/main/` with the following contents:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要添加的第一个模板是一个部分视图，用于列出游戏。这个部分视图将被共享到我们想要显示游戏列表的所有模板中。这个部分视图将接收两个参数：`gameslist`
    和 `highlight_games`。让我们继续添加一个名为 `games-list.html` 的文件，放在 `gamestore/main/templates/main/`
    中，内容如下：
- en: '[PRE76]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: One thing to note here is that we added at the top of the page `{% load humanize
    %}`; this is a set of template filters that are built into the Django framework,
    which we are going to use to format the game price properly. To make use of these
    filters we need to edit the `settings.py` file in the `gamestore/gamestore` directory
    and add `django.contrib.humanize` to the `INSTALLED_APPS` setting.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，我们在页面顶部添加了 `{% load humanize %}`；这是 Django 框架内置的一组模板过滤器，我们将使用它们来正确格式化游戏价格。为了使用这些过滤器，我们需要编辑
    `gamestore/gamestore` 目录中的 `settings.py` 文件，并将 `django.contrib.humanize` 添加到 `INSTALLED_APPS`
    设置中。
- en: 'This code will create a container with some boxes containing the game image,
    details, and an add-to-cart button, similar to the following:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将创建一个容器，其中包含游戏图片、详细信息和一个添加到购物车的按钮，类似于以下内容：
- en: '![](assets/a90a8c0b-9daf-4a99-adb3-1a56365aec9d.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a90a8c0b-9daf-4a99-adb3-1a56365aec9d.png)'
- en: 'Now we want to modify the `index.html` at `gamestore/main/templates/main`.
    We can replace the whole content of the `index.html` file with the code, shown
    as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要修改 `gamestore/main/templates/main` 下的 `index.html`。我们可以用以下代码替换 `index.html`
    文件的整个内容：
- en: '[PRE77]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Great! The interesting code is:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！有趣的代码是：
- en: '[PRE78]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'As you can see, we are including the partial view and passing two parameters:
    `gameslist` and `highlight_games`. The `gameslist` is obviously a list of games
    that we want the partial view to render, while `highlight_games` will be used
    when we want to show the promoted games with a different color so they can be
    easily identified. In the index page, the `highlight_games` parameter is not used,
    but when we create a view to list all the games regardless of the fact that it
    is promoted or not, it may be interesting to change the color of the promoted
    ones.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正在包含部分视图并传递两个参数：`gameslist` 和 `highlight_games`。`gameslist` 显然是我们希望部分视图渲染的游戏列表，而
    `highlight_games` 将在我们想要以不同颜色显示推广游戏时使用，以便它们可以很容易地被识别出来。在首页，`highlight_games` 参数没有被使用，但是当我们创建一个视图来列出所有游戏，不管它是否被推广，改变推广游戏的颜色可能会很有趣。
- en: Below the promoted games section, we have a section with a list of games that
    are not promoted, which also makes use of the partial view `games-list.html`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在推广游戏部分下面，我们有一个列出未推广游戏的部分，它也使用了部分视图 `games-list.html`。
- en: 'The last touch on the frontend side is to include the related CSS code, so
    let''s edit the file `site.css` at `gamestore/static/styles/` and add the following
    code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 前端的最后一步是包含相关的 CSS 代码，所以让我们编辑 `gamestore/static/styles/` 下的 `site.css` 文件，并添加以下代码：
- en: '[PRE79]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now we need to modify the `index` view, so edit the `views.py` file at `gamestore/main/`
    and perform these changes in the `index` function:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要修改 `index` 视图，所以编辑 `gamestore/main/` 中的 `views.py` 文件，并对 `index` 函数进行以下更改：
- en: '[PRE80]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here, we first define how many items of each category of games we want to show;
    for promoted games, it will be three games, and the non-promoted category will
    show a maximum of nine games.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先定义了我们想要显示每个游戏类别的项目数量；对于推广游戏，将显示三款游戏，而非推广类别将最多显示九款游戏。
- en: Then, we fetch the promoted and non-promoted games, and we create two variables, `show_more_link_promoted`
    and `show_more_link_games`, which will be set to `True` in case there are more
    games in the database than the maximum number we defined previously.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们获取推广和非推广游戏，并创建两个变量 `show_more_link_promoted` 和 `show_more_link_games`，如果数据库中的游戏数量超过我们之前定义的最大数量，它们将被设置为
    `True`。
- en: We create a context variable that will contain all the data that we want to
    render in the template, and, lastly, we call the `render` function and pass the
    `request` to the template we want to render, along with the context.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个包含我们想要在模板中呈现的所有数据的上下文变量，最后，我们调用 `render` 函数，并将 `request` 传递给我们想要呈现的模板，以及上下文。
- en: 'Because we make use of the `Game` model, we have to import it:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们使用了 `Game` 模型，我们需要导入它：
- en: '[PRE81]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now we are ready to see the results on the page, but, first, we need to create
    some games. To do that, we first need to register the models in the admin. To
    do that, edit the `admin.py` file and include the following code:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备在页面上看到结果了，但首先，我们需要创建一些游戏。为此，我们首先需要在管理员中注册模型。要做到这一点，编辑 `admin.py` 文件，并包含以下代码：
- en: '[PRE82]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Registering the models within the Django admin site will allow us to add, edit,
    and remove games, games platforms, and items in the price list. Because we will
    be adding images to our games, we need to configure the location where Django
    should save the images that we upload through the administration site. So, let''s
    go ahead and open the file `settings.py` in the `gamestore/gamestore` directory,
    and just below the `STATIC_DIRS` setting, add this line:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Django 管理站点中注册模型将允许我们添加、编辑和删除游戏、游戏平台和价格列表中的项目。因为我们将向游戏添加图片，我们需要配置 Django 应该保存我们通过管理站点上传的图片的位置。因此，让我们继续打开
    `gamestore/gamestore` 目录中的 `settings.py` 文件，并在 `STATIC_DIRS` 设置的下面添加这一行：
- en: '[PRE83]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, start the site:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动网站：
- en: '[PRE84]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Browse to `http://localhost:8000/admin`, and log in as the superuser account
    that we created. You should see the models listed on the page:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到`http://localhost:8000/admin`，并使用我们创建的超级用户帐户登录。您应该会在页面上看到列出的模型：
- en: '![](assets/67a5e1f4-ea27-49db-baa6-d720c8b35235.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/67a5e1f4-ea27-49db-baa6-d720c8b35235.png)'
- en: 'If you click first in `Game` platforms, you will see an empty list. Click on
    the button ADD on the Game platforms row on the top right-hand side of the page,
    and the following form will be displayed:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您首先点击“游戏”平台，您将看到一个空列表。点击页面右上方的“游戏平台”行上的ADD按钮，将显示以下表单：
- en: '![](assets/dd1567e5-3c9c-4428-b68d-5fb26bd0bef2.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dd1567e5-3c9c-4428-b68d-5fb26bd0bef2.png)'
- en: Just type any name you like, and click on the SAVE button to save your changes.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 只需输入您喜欢的任何名称，然后单击“保存”按钮以保存更改。
- en: Before we add the games, we need to find a default image and place it at `gamestore/static/images/`.
    The image should be named `placeholder.png`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加游戏之前，我们需要找到一个默认图像，并将其放置在`gamestore/static/images/`。图像的名称应为`placeholder.png`。
- en: The layout that we build will work better with images that are of the size 130x180\.
    To make it simpler, when I am creating prototypes, and I don't want to spend too
    much time looking for the perfect image, I go to the site [https://placeholder.com/](https://placeholder.com/).
    Here, you can build a placeholder image of any size you want. To get the correct
    size for our application you can go directly to [http://via.placeholder.com/130x180](http://via.placeholder.com/130x180).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的布局将更适合尺寸为130x180的图像。为了简化，当我创建原型时，我不想花太多时间寻找完美的图像，我会去网站[https://placeholder.com/](https://placeholder.com/)。在这里，您可以构建任何尺寸的占位图像。为了获得我们应用程序的正确尺寸，您可以直接转到[http://via.placeholder.com/130x180](http://via.placeholder.com/130x180)。
- en: When you have the default image in place, you can start adding games the same
    way you added the game platforms and just repeat the process multiple times to
    add a few games that are set as promoted as well.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 当您放置默认图像后，您可以开始添加游戏，方法与添加游戏平台相同，只需重复该过程多次以添加一些设置为推广的游戏。
- en: 'After adding the games, and going to the site again, you should see the list
    of games on the index page, as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 添加游戏后，再次访问网站，您应该会在首页上看到游戏列表，如下所示：
- en: '![](assets/8e40b7bf-7333-4410-926c-c4b2bc5af4a3.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8e40b7bf-7333-4410-926c-c4b2bc5af4a3.png)'
- en: On my project, I added four promoted games. Notice that because we only show
    three promoted games on the first page, we render the link See more items.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的项目中，我添加了四个推广游戏。请注意，因为我们在第一页上只显示了三个推广游戏，所以我们呈现了“查看更多项目”链接。
- en: Adding list games views
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加列表游戏视图
- en: As we are not displaying all the items on the first page, we need to build pages
    that will display all the items if the user clicks on See more items link. This
    should be fairly simple, as we already have a partial view that lists the games
    for us.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有在第一页上显示所有项目，因此我们需要构建页面，如果用户点击“查看更多项目”链接，将显示所有项目。这应该相当简单，因为我们已经有一个列出游戏的部分视图。
- en: 'Let''s create two more URLs in the `url.py` file of the `main` app, and let''s
    add these two to the `urlpatterns` list:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`main`应用的`url.py`文件中创建另外两个URL，并将它们添加到`urlpatterns`列表中：
- en: '[PRE85]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Perfect! Now we need to add one template to list all the games. Create a file
    called `all_games.html` at `gamestore/main/templates/main` with the following
    contents:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在我们需要添加一个模板来列出所有游戏。在`gamestore/main/templates/main`下创建一个名为`all_games.html`的文件，内容如下：
- en: '[PRE86]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Add another file in the same folder called `highlighted.html`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件夹中再添加一个名为`highlighted.html`的文件：
- en: '[PRE87]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: There is nothing here that we haven't seen before. This template will receive
    a list of games, and it will pass it down to the `games-list.html` partial view
    that will do all the work of rendering the games for us. There is an `if` statement
    here that checks if there are games on the list. If the list is empty, it will
    display a message that there are no games available at the moment. Otherwise,
    it will render the content.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有我们以前没有见过的东西。这个模板将接收一个游戏列表，并将其传递给`games-list.html`部分视图，该视图将为我们渲染游戏。这里有一个`if`语句，检查列表中是否有游戏。如果列表为空，它将显示消息，说明目前没有可用的游戏。否则，它将呈现内容。
- en: 'The last thing now is to add the views. Open the `views.py` file at `gamestore/main/`,
    and add the following two functions:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在最后一件事是添加视图。打开`gamestore/main/`下的`views.py`文件，并添加以下两个函数：
- en: '[PRE88]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: These functions are very similar; one gets a list of all games and the other
    one gets a list of only promoted games
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能非常相似；一个获取所有游戏的列表，另一个获取仅推广游戏的列表
- en: 'Let''s open the application again. As we have more promoted items in the database,
    let''s click on the link See more items in the Highlighted games section of the
    page. You should land on the following page:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次打开应用程序。由于数据库中有更多的推广项目，让我们点击页面上突出显示游戏部分的“查看更多项目”链接。您应该会进入以下页面：
- en: '![](assets/28d8b456-325c-42cc-86eb-94cfb4fb8e20.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/28d8b456-325c-42cc-86eb-94cfb4fb8e20.png)'
- en: Perfect! It worked just as expected.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！它的工作就像预期的那样。
- en: Next up, we are going to add functionality to the buttons so we can add those
    items to the cart.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为按钮添加功能，以便将这些项目添加到购物车中。
- en: Creating the shopping cart model
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建购物车模型
- en: It seems like now we have an application up and running, we can display our
    games, but there's a big issue here. Can you guess what? Okay, this question wasn't
    so hard, I gave the answer for that in the title of the section. Anyway, our users
    cannot buy the games—we need to implement a shopping cart so we can start making
    our users happy!
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来现在我们有一个正在运行的应用程序，我们可以显示我们的游戏，但这里有一个大问题。你能猜到是什么吗？好吧，这个问题并不难，我在本节的标题中已经给出了答案。无论如何，我们的用户无法购买游戏，我们需要实现一个购物车，这样我们就可以开始让我们的用户开心了！
- en: Now, there are many ways you can implement a shopping cart on an application,
    but we are going to do it by simply saving the cart items on the database instead
    of doing an implementation based in the user session.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以以许多种方式在应用程序上实现购物车，但我们将简单地将购物车项目保存在数据库中，而不是基于用户会话进行实现。
- en: 'The requirements for the shopping cart are as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车的要求如下：
- en: The users can add as many items they wish
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以添加任意数量的商品
- en: The users should be able to change the items in the shopping cart; for example,
    they should be able to change the quantity of an item
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够更改购物车中的商品；例如，他们应该能够更改商品的数量
- en: Removal of items should be possible
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该可以删除商品
- en: There should be an option to empty the shopping cart
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个清空购物车的选项
- en: All the data should be validated
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有数据都应该经过验证
- en: If the user owning that shopping cart is removed, the shopping cart and its
    items should also be removed
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果拥有该购物车的用户被删除，购物车及其商品也应该被删除
- en: 'With that said, open the file `models.py` in the `gamestore/main` directory,
    and let''s add our first class:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，打开`gamestore/main`目录下的`models.py`文件，让我们添加我们的第一个类：
- en: '[PRE89]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The same way we created a custom `Manager` for the `Game` object, we are also
    going to create a `Manager` for the `ShoppingCart`. We are going to add three
    methods. The first one is `get_by_id`, which, as the name says, retrieves a shopping
    cart, given an ID. The second method is `get_by_user`, which receives as a parameter
    an instance of `django.contrib.auth.models.User`, and it will return the cart
    given a user instance. The last method is `create_cart`; this method will be called
    when the user creates an account
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 和我们为`Game`对象创建自定义`Manager`一样，我们也将为`ShoppingCart`创建一个`Manager`。我们将添加三个方法。第一个是`get_by_id`，顾名思义，根据ID检索购物车。第二个方法是`get_by_user`，它接收`django.contrib.auth.models.User`的实例作为参数，并将返回给定用户实例的购物车。最后一个方法是`create_cart`；当用户创建账户时将调用此方法。
- en: 'Now that we have the manager with the methods that we need, let''s add the
    `ShoppingCart` class:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了需要的方法的管理器，让我们添加`ShoppingCart`类：
- en: '[PRE90]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This class is super simple. As always, we inherit from `Model`, and we define
    one foreign key for the type `User`. This foreign key is required, and if the
    user is deleted it will also delete the shopping cart.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类非常简单。和以往一样，我们从`Model`继承，并为类型`User`定义一个外键。这个外键是必需的，如果用户被删除，购物车也会被删除。
- en: After the foreign key, we assign our custom `Manager` to the object's property,
    and we also implement the special method `__str__` so the shopping carts are displayed
    in a nicer way in the Django admin UI.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在外键之后，我们将我们自定义的`Manager`分配给对象的属性，并且我们还实现了特殊方法`__str__`，这样在Django管理界面中购物车会以更好的方式显示。
- en: 'Next, let''s add a manager class for the `ShoppingCartItem` model, as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为`ShoppingCartItem`模型添加一个管理类，如下所示：
- en: '[PRE91]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Here, we only define one method, called `get_items`, which receives a cart
    object and returns a list of items for the underlying shopping cart. After the
    `Manager` class, we can create the model:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只定义了一个方法，名为`get_items`，它接收一个购物车对象，并返回底层购物车的商品列表。在`Manager`类之后，我们可以创建模型：
- en: '[PRE92]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We start by defining two properties: quantity, which is an integer value, and
    the price per item, which is defined as a decimal value. We have `price_per_item`
    in this model as well, because when a user adds an item to the shopping cart and
    if the administrator changes the price for a product, we don''t want that change
    in the price to be reflected on the items already added to the cart. The price
    should be the same price as when the user first added the product to the cart.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了两个属性：数量，这是一个整数值，和每件商品的价格，这是一个十进制值。在这个模型中我们也有`price_per_item`，因为当用户将商品添加到购物车时，如果管理员更改了产品的价格，我们不希望已经添加到购物车的商品的价格发生变化。价格应该与用户首次将产品添加到购物车时的价格相同。
- en: In case the user removes the item entirely and re-adds them, the new price should
    be reflected. After those two properties, we define two foreign keys, one for
    the type `ShoppingCart` and another one for `Game`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户完全删除商品并重新添加，新的价格应该得到反映。在这两个属性之后，我们定义了两个外键，一个是类型`ShoppingCart`，另一个是`Game`。
- en: Lastly, we set the `ShoppingCartItemManager` to the object's property.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`ShoppingCartItemManager`设置为对象的属性。
- en: 'We also need to import the User model:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要导入User模型：
- en: '[PRE93]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Before we try to verify that everything is working, we should create and apply
    the migrations. On the terminal, run the following command:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试验证一切是否正常工作之前，我们应该创建并应用迁移。在终端上运行以下命令：
- en: '[PRE94]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'As we did before, we need to run the migrate command to apply the migrations
    to the database:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，我们需要运行迁移命令来将迁移应用到数据库：
- en: '[PRE95]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Creating the shopping cart form
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建购物车表单
- en: 'We now have the models in place. Let''s add a new form that will display the
    cart data on a page for editing. Open the `forms.py` file at `gamestore/main/`,
    and at the end of the file add the following code:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经有了模型。让我们添加一个新的表单，用于在页面上显示购物车数据进行编辑。打开`gamestore/main/`目录下的`forms.py`文件，在文件末尾添加以下代码：
- en: '[PRE96]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Here, we create an inline `formset` using the function `inlineformset_factory`.
    Inline `formset`s are suitable when we want to work with related objects via a
    foreign key. This is very convenient in the case we have here; we have a model
    `ShoppingCart` that relates to the `ShoppingCartItem`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`inlineformset_factory`函数创建一个内联`formset`。内联`formset`适用于当我们想通过外键与相关对象一起工作时。在我们这里非常方便；我们有一个与`ShoppingCartItem`相关的`ShoppingCart`模型。
- en: So, we pass a few arguments to the `inlineformset_factory` function. First is
    the parent model (`ShoppingCart`), then it's the model (`ShoppingCartItems`).
    Because in the shopping cart we just want to edit the quantities and also remove
    items from the cart, we add a tuple containing the fields from the `ShoppingCartItem`
    that we want to render on the page—in this case, the `quantity` and `price_per_unit`.
    The next argument, `extra`, specifies whether the form should render any empty
    extra rows on the form; in our case, we don't need that, as we don't want to add
    extra items in the shopping cart to the shopping cart view.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们向`inlineformset_factory`函数传递了一些参数。首先是父模型（`ShoppingCart`），然后是模型（`ShoppingCartItems`）。因为在购物车中我们只想编辑数量并从购物车中移除商品，所以我们添加了一个包含我们想要在页面上呈现的`ShoppingCartItem`字段的元组——在这种情况下是`quantity`和`price_per_unit`。下一个参数`extra`指定表单是否应在表单上呈现任何空的额外行；在我们的情况下，我们不需要这样做，因为我们不希望将额外的商品添加到购物车视图中。
- en: In the last argument, `widgets`, we can specify how the fields should be rendered
    in the form. The quantity field will be rendered as a text input, and we don't
    want `price_per_unit` to be visible, so we define it as a hidden input so it is
    sent back to the server when we submit the form to the server.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个参数`widgets`中，我们可以指定表单中字段的呈现方式。数量字段将呈现为文本输入，我们不希望`price_per_unit`可见，所以我们将其定义为隐藏输入，这样当我们将表单提交到服务器时，它会被发送回服务器。
- en: 'Lastly, in the same file, let''s add some necessary imports:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在同一个文件中，让我们添加一些必要的导入：
- en: '[PRE97]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Open the `views.py` file, and let''s add a class-based view. First, we need
    to add some import statements:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`views.py`文件，让我们添加一个基于类的视图。首先，我们需要添加一些导入语句：
- en: '[PRE98]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Then, we can create the class, as follows:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以创建如下的类：
- en: '[PRE99]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This is slightly different than the view that we created so far, as this is
    a class-based view that inherits from an `UpdateView`. In reality, views in Django
    are callable objects, and when using classes instead of functions, we can take
    advantage of inheritance and mixins. In our case, we use `UpdateView` because
    it is a view to display forms that will edit an existing object.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们迄今为止创建的视图略有不同，因为这是一个从`UpdateView`继承的基于类的视图。实际上，在Django中，视图是可调用对象，当使用类而不是函数时，我们可以利用继承和混合。在我们的情况下，我们使用`UpdateView`，因为它是一个用于显示将编辑现有对象的表单的视图。
- en: This class view starts off by defining a few properties, such as the model,
    which is the model that we are going to be editing in the form. The `form_class`
    is the form that is going to be used for editing the data. Lastly, we have the
    template that will be used to render the form.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类视图首先定义了一些属性，比如模型，这是我们将在表单中编辑的模型。`form_class`是用于编辑数据的表单。最后，我们有将用于呈现表单的模板。
- en: We override the `get_context_data` because we include some extra data in the
    form context. So, first, we call the `get_context_data` on the base class so as
    to build the context, then we get the list of items of the current cart so we
    can determine whether the cart is empty. We set this value to the context item
    called `is_cart_empty`, which can be accessed from the template.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写了`get_context_data`，因为我们在表单上下文中包含了一些额外的数据。因此，首先我们调用基类上的`get_context_data`来构建上下文，然后我们获取当前购物车的商品列表，以便确定购物车是否为空。我们将这个值设置为上下文项`is_cart_empty`，可以从模板中访问。
- en: After that, we want to calculate the total value of the items that are currently
    in the cart. To do that, we need to first calculate the total price for each item
    by doing (price * quantity), and then sum the results. In Django, it is possible
    to aggregate the values of a `QuerySet`; we have already the `QuerySet` that contains
    the list of items in a cart, so all we have to do is to use the `aggregate` function.
    In our case, we are passing two arguments to the `aggregate` function. First,
    we get the sum of the field `price_per_unit` multiplied by the quantity, and the
    results will be stored in a property called `total_order`. The second argument
    of the `aggregate` function defines the output data type, which we want to be
    a decimal value.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们想要计算当前购物车中商品的总价值。为此，我们需要首先通过（价格*数量）来计算每件商品的总价，然后对结果进行求和。在Django中，可以对`QuerySet`的值进行聚合；我们已经有了包含购物车中商品列表的`QuerySet`，所以我们只需要使用`aggregate`函数。在我们的情况下，我们向`aggregate`函数传递了两个参数。首先，我们得到字段`price_per_unit`乘以数量的总和，并将结果存储在一个名为`total_order`的属性中。`aggregate`函数的第二个参数定义了输出数据类型，我们希望它是一个十进制值。
- en: When we get the results of the aggregation, we create a new item in the context
    dictionary called `total_order` and assign the results to it. Finally, we return
    the context.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们得到聚合的结果时，我们在上下文字典中创建了一个名为`total_order`的新项，并将结果赋给它。最后，我们返回上下文。
- en: We also override the `get_object` method. In this method, we try to get the
    shopping cart for the requesting user. If the shopping cart does not exist, an
    exception `ShoppingCart.DoesNotExist` will be raised. In that case, we create
    a shopping cart for the user and return it.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还重写了`get_object`方法。在这个方法中，我们尝试获取请求用户的购物车。如果购物车不存在，将引发一个`ShoppingCart.DoesNotExist`异常。在这种情况下，我们为用户创建一个购物车并返回它。
- en: Lastly, we also implement the `form_valid` method, which only saves the form
    and redirects the user back to the cart page.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还实现了`form_valid`方法，它只保存表单并将用户重定向回购物车页面。
- en: Creating the shopping cart view
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建购物车视图
- en: Now it is time to create the shopping cart views. This view will render the
    form that we just created, and the users should be able to change the quantities
    for every item on the cart, as well as remove items. If the shopping cart is empty,
    we should show a message saying that the cart is empty.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建购物车视图了。这个视图将呈现我们刚刚创建的表单，用户应该能够更改购物车中每件商品的数量，以及移除商品。如果购物车为空，我们应该显示一条消息，说明购物车是空的。
- en: 'Before we add the view, let''s go ahead and open the `urls.py` file in `gamestore/main/`
    and add the following URL:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加视图之前，让我们继续打开`gamestore/main/`中的`urls.py`文件，并添加以下URL：
- en: '[PRE100]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Here, we define a new URL, `'cart/'`, and, when accessed, it will execute the
    class-based view `ShoppingCartEditView`. We also define a name for the URL for
    simplicity.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个新的URL，`'cart/'`，当访问时，它将执行基于类的视图`ShoppingCartEditView`。我们还为URL定义了一个名称，以简化操作。
- en: 'We are going to create a new file called `cart.html` at `gamestore/main/templates/main`,
    with the contents as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`gamestore/main/templates/main`中创建一个名为`cart.html`的新文件，内容如下：
- en: '[PRE101]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The template is quite simple; we just loop through the forms and render each
    one of them. One thing to note here in that we are loading `humanize` in the beginning
    of the template.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 模板非常简单；我们只需循环遍历表单并渲染每一个。这里需要注意的一点是我们在模板开头加载了`humanize`。
- en: '`humanize` is a set of template filters that we can use to format data in the
    template.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`humanize`是一组模板过滤器，我们可以在模板中使用它来格式化数据。'
- en: We use the `intcomma` filter from `humanize` to format the sum of all items
    in the shopping cart. The `intcomma` filter will convert an integer or float value
    to a string and add a comma every three digits.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`humanize`中的`intcomma`过滤器来格式化购物车中所有商品的总和。`intcomma`过滤器将把整数或浮点值转换为字符串，并在每三位数字后添加一个逗号。
- en: You can try it out on the new view. However, the cart will be empty and no data
    will be displayed. Next, we are going to add functionality to include items in
    the cart.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在新视图上尝试它。但是，购物车将是空的，不会显示任何数据。接下来，我们将添加包含商品的功能。
- en: Adding items to the cart
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将商品添加到购物车
- en: We are getting close to finishing up the shopping cart. Now we are going to
    implement a view that will include items in the cart.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将完成购物车。现在我们将实现一个视图，将商品包含在购物车中。
- en: 'The first thing we need to do is create a new URL. Open the file `url.py` in
    the directory `gamestore/main/`, and add this URL to the `urlpatterns` list:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个新的URL。打开`gamestore/main/`目录中的`url.py`文件，并将此URL添加到`urlpatterns`列表中：
- en: '[PRE102]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Perfect. In this URL, we can pass the game ID, and it will execute a view called
    `add_to_cart`. Let''s add this new view. Open the file `views.py` in `gamestore/main`.
    First, we add import statements, shown as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。在此URL中，我们可以传递游戏ID，并且它将执行一个名为`add_to_cart`的视图。让我们添加这个新视图。在`gamestore/main`中打开`views.py`文件。首先，我们添加导入语句，如下所示：
- en: '[PRE103]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Now, we need a way to know if a specific item has been already added to the
    cart, so we go over to the `models.py` in `gametore/main` and add a new method
    to the `ShoppingCartItemManager` class:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一种方法来知道特定商品是否已经添加到购物车中，因此我们转到`gametore/main`中的`models.py`，并向`ShoppingCartItemManager`类添加一个新方法：
- en: '[PRE104]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '`get_existing_item` searches for a `ShoppingCartItem` object using as criteria
    the `cart id` and the `game id`. If the item is not found in the cart, it returns
    `None`; otherwise, it will return the cart item.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_existing_item`使用`cart id`和`game id`作为条件搜索`ShoppingCartItem`对象。如果在购物车中找不到该商品，则返回`None`；否则，它将返回购物车商品。'
- en: 'Now we add the view to the `views.py` file:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将视图添加到`views.py`文件中：
- en: '[PRE105]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This function gets a request and the game ID, and we start by getting the game
    and the current user's shopping cart. We then pass the cart and the game to the
    `get_existing` function that we just created. If we don't have that specific item
    in the shopping cart, we create a new `ShoppingCartItem`; otherwise, we just update
    the quantity and save.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数获取请求和游戏ID，然后我们开始获取游戏和当前用户的购物车。然后我们将购物车和游戏传递给我们刚刚创建的`get_existing`函数。如果我们在购物车中没有特定的商品，我们就创建一个新的`ShoppingCartItem`；否则，我们只是更新数量并保存。
- en: We also add a message to inform the user that the item has been added to the
    shopping cart.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一条消息，通知用户该商品已添加到购物车中。
- en: Lastly, we redirect the user to the shopping cart page.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将用户重定向到购物车页面。
- en: 'As a final touch, let''s open the `site.css` file in the `gamestore/static/styles`
    and add the styling to our shopping cart''s view:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步，让我们打开`gamestore/static/styles`中的`site.css`文件，并为我们的购物车视图添加样式：
- en: '[PRE106]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Before we try this out, we need to add the link to the cart view on the top
    menu. Open the file `base.html` in `gamestore/templates`, locate where we do the
    include of the `_loginpartial.html` file, and include the following code right
    before it:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试这个之前，我们需要在顶部菜单中添加到购物车视图的链接。在`gamestore/templates`中打开`base.html`文件，找到我们包含`_loginpartial.html`文件的位置，并在其之前包含以下代码：
- en: '[PRE107]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Now we should be ready to test it out. Go to the first page, and try adding
    some games to the cart. You should be redirected to the cart page:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该准备好测试它了。转到第一页，尝试向购物车中添加一些游戏。您应该会被重定向到购物车页面：
- en: '![](assets/88194946-e679-46f9-a81a-b3b782e05424.png)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/88194946-e679-46f9-a81a-b3b782e05424.png)'
- en: Summary
  id: totrans-466
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: It has been a long journey, and we have covered a lot of ground in this chapter.
    In this chapter, you have seen how easy it is to build an application with Django.
    The framework really honors the phrase *Framework for perfectionists with deadlines*.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个漫长的旅程，在本章中我们涵盖了很多内容。在本章中，您已经看到使用Django构建应用是多么容易。这个框架真的很符合“完美主义者的截止日期”这句话。
- en: You have learned how to create a new Django project and applications, with a
    short walkthrough of the boilerplate code that Django generates for us when we
    start a new project. We learned how to create models and use migrations to apply
    changes to the database.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了如何创建一个新的Django项目和应用程序，并简要介绍了Django在我们启动新项目时为我们生成的样板代码。我们学会了如何创建模型并使用迁移来对数据库应用更改。
- en: Django forms was also a subject that we covered a lot in this chapter, and you
    should be able to create complex forms for your projects.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: Django表单也是本章我们涵盖的一个主题，您应该能够为您的项目创建复杂的表单。
- en: As a bonus, we learned how to install and use **NodeJS Version Manager** (**NVM**)
    to install Node.js, so as to install project dependencies using the npm.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 作为奖励，我们学会了如何安装和使用**NodeJS版本管理器**（**NVM**）来安装Node.js，以便使用npm安装项目依赖项。
- en: In [Chapter 5](332eca24-e97d-470d-a00f-882dbf2092aa.xhtml), *Building a Web
    Messenger with Microservices*, we are going to extend this application and create
    services that will handle the store inventory.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](332eca24-e97d-470d-a00f-882dbf2092aa.xhtml)中，*使用微服务构建Web Messenger*，我们将扩展此应用程序，并创建将处理商店库存的服务。
