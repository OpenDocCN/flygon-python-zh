["```py\nimport hashlib\n\ndef md5Checksum(filePath):\n    fh = open(filePath, 'rb')\n    m = hashlib.md5()\n    while True:\n        data = fh.read(8192)\n        if not data:\n            break\n        m.update(data)\n    return m.hexdigest()\n\nprint('The MD5 checksum is', md5Checksum('md5.py'))\n```", "```py\nfrom Crypto.Hash import MD5\n\ndef md5Checksum(filePath):\n    fh = open(filePath, 'rb')\n    m = MD5.new()\n    while True:\n        data = fh.read(8192)\n        if not data:\n            break\n        m.update(data)\n    return m.hexdigest()\n\nprint('The MD5 checksum is' + md5Checksum('hash.py'))\n```", "```py\nencrypt ('clear text')\ndecrypt ('encrypted text')\n```", "```py\nfrom Crypto.Cipher import DES\n\n# How we use DES, the blocks are 8 characters\n# Fill with spaces the user until 8 characters\nuser =  \"user    \"\npassword = \"password\"\n\n# we create the cipher with DES\ncipher = DES.new('mycipher')\n\n# encrypt username and password\ncipher_user = cipher.encrypt(user)\ncipher_password = cipher.encrypt(password)\n\n# we send credentials\nprint(\"User: \" + cipher_user)\nprint(\"Password: \" + cipher_password)\n# We simulate the server where the messages arrive encrypted.\n\n# we decode messages and remove spaces with strip()\ncipher = DES.new('mycipher')\ndecipher_user = cipher.decrypt(cipher_user).strip()\ndecipher_password = cipher.decrypt(cipher_password)\nprint(\"SERVER decipher:\")\nprint(\"User: \" + decipher_user)\nprint(\"Password: \" + decipher_password)\n```", "```py\n# AES pycrypto package\nfrom Crypto.Cipher import AES\n\n# key has to be 16, 24 or 32 bytes long\nencrypt_AES = AES.new('secret-key-12345', AES.MODE_CBC, 'This is an IV-12')\n\n# Fill with spaces the user until 32 characters\nmessage = \"This is the secret message      \"\n\nciphertext = encrypt_AES.encrypt(message)\nprint(\"Cipher text: \" , ciphertext)\n\n# key must be identical\ndecrypt_AES = AES.new('secret-key-12345', AES.MODE_CBC, 'This is an IV-12')\nmessage_decrypted = decrypt_AES.decrypt(ciphertext)\n\nprint(\"Decrypted text: \", message_decrypted.strip())\n```", "```py\nfrom Crypto.Cipher import AES\nfrom Crypto.Hash import SHA256\nimport os, random, struct\n\ndef encrypt_file(key, filename):\n    chunk_size = 64*1024\n    output_filename = filename + '.encrypted'\n\n    # Initialization vector\n    iv = ''.join(chr(random.randint(0, 0xFF)) for i in range(16))\n\n    #create the encryption cipher\n    encryptor = AES.new(key, AES.MODE_CBC, iv)\n\n    #Determine the size of the file\n    filesize = os.path.getsize(filename)\n\n    #Open the output file and write the size of the file. \n    #We use the struct package for the purpose.\n    with open(filename, 'rb') as inputfile:\n        with open(output_filename, 'wb') as outputfile:\n            outputfile.write(struct.pack('<Q', filesize))\n            outputfile.write(iv)\n\n            while True:\n                chunk = inputfile.read(chunk_size)\n                if len(chunk) == 0:\n                    break\n                elif len(chunk) % 16 != 0:\n                    chunk += ' ' * (16 - len(chunk) % 16)\n                outputfile.write(encryptor.encrypt(chunk))\n\npassword = \"password\"\n\ndef getKey(password):\n    hasher = SHA256.new(password)\n    return hasher.digest()\n\nencrypt_file(getKey(password), 'file.txt');\n```", "```py\nfrom Crypto.Cipher import AES\nimport os, random, struct\ndef encrypt_file(key, filename, chunk_size=64*1024):\noutput_filename = filename + '.encrypted'\n```", "```py\n# Initialization vector\niv = ''.join(chr(random.randint(0, 0xFF)) for i in range(16))\n```", "```py\nencryptor = AES.new(key, AES.MODE_CBC, iv)\nfilesize = os.path.getsize(filename)\n```", "```py\nfrom Crypto.Cipher import AES\nfrom Crypto.Hash import SHA256\nimport os, random, struct\n\ndef decrypt_file(key, filename):\n    chunk_size = 64*1024\n    output_filename = os.path.splitext(filename)[0]\n\n    #open the encrypted file and read the file size and the initialization vector. \n    #The IV is required for creating the cipher.\n    with open(filename, 'rb') as infile:\n        origsize = struct.unpack('<Q', infile.read(struct.calcsize('Q')))[0]\n        iv = infile.read(16)\n\n        #create the cipher using the key and the IV.\n        decryptor = AES.new(key, AES.MODE_CBC, iv)\n\n        #We also write the decrypted data to a verification file, \n        #so we can check the results of the encryption \n        #and decryption by comparing with the original file.\n        with open(output_filename, 'wb') as outfile:\n            while True:\n                chunk = infile.read(chunk_size)\n                if len(chunk) == 0:\n                    break\n                outfile.write(decryptor.decrypt(chunk))\n            outfile.truncate(origsize)\n\npassword = \"password\"\n\ndef getKey(password):\n    hasher = SHA256.new(password)\n    return hasher.digest()\n\ndecrypt_file(getKey(password), 'file.txt.encrypted');\n```", "```py\nfrom cryptography.fernet import Fernet\n\nkey = Fernet.generate_key()\ncipher_suite = Fernet(key)\n\nprint(\"Key \"+str(cipher_suite))\nmessage = \"Secret message\"\n\ncipher_text = cipher_suite.encrypt(message)\nplain_text = cipher_suite.decrypt(cipher_text)\n\nprint(\"\\n\\nCipher text: \"+cipher_text)\n\nprint(\"\\n\\nPlain text: \"+plain_text)\n```", "```py\nimport base64\nimport os\nfrom cryptography.fernet import Fernet\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n\npassword = \"password\"\nsalt = os.urandom(16)\nkdf = PBKDF2HMAC(algorithm=hashes.SHA256(),length=32,salt=salt,iterations=100000,backend=default_backend())\n\nkey = kdf.derive(password)\n\nkdf = PBKDF2HMAC(algorithm=hashes.SHA256(),length=32,salt=salt,iterations=100000,backend=default_backend())\n\n#verify() method checks whether deriving a new key from \n#the supplied key generates the same key as the expected_key, \n#and raises an exception if they do not match.\nkdf.verify(password, key)\n\nkey = base64.urlsafe_b64encode(key)\nfernet = Fernet(key)\ntoken = fernet.encrypt(\"Secret message\")\n\nprint(\"Token: \"+token)\nprint(\"Message: \"+fernet.decrypt(token))\n```", "```py\nimport os\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.backends import default_backend\n\nbackend = default_backend()\nkey = os.urandom(32)\niv = os.urandom(16)\ncipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend=backend)\n\nencryptor = cipher.encryptor()\nprint(encryptor)\n\nmessage_encrypted = encryptor.update(\"a secret message\")\n\nprint(\"\\n\\nCipher text: \"+message_encrypted)\nct = message_encrypted + encryptor.finalize()\n\ndecryptor = cipher.decryptor()\n\nprint(\"\\n\\nPlain text: \"+decryptor.update(ct))\n```", "```py\n#!/usr/bin/env python\n\n#Hide data in lsbs of an image\n#python 3.x compatible\n\nfrom PIL import Image\n\ndef get_pixel_pairs(iterable):\n    a = iter(iterable)\n    return zip(a, a)\n\ndef set_LSB(value, bit):\n    if bit == '0':\n        value = value & 254\n    else:\n        value = value | 1\n    return value\n\ndef get_LSB(value):\n    if value & 1 == 0:\n        return '0'\n    else:\n        return '1'\n\ndef extract_message(image):\n    c_image = Image.open(image)\n    pixel_list = list(c_image.getdata())\n    message = \"\"\n    for pix1, pix2 in get_pixel_pairs(pixel_list):\n        message_byte = \"0b\"\n        for p in pix1:\n            message_byte += get_LSB(p)\n        for p in pix2:\n            message_byte += get_LSB(p)\n        if message_byte == \"0b00000000\":\n            break\n        message += chr(int(message_byte,2))\n    return message\n\n```", "```py\ndef hide_message(image, message, outfile):\n    message += chr(0)\n    c_image = Image.open(image)\n    c_image = c_image.convert('RGBA')\n    out = Image.new(c_image.mode, c_image.size)\n    width, height = c_image.size\n    pixList = list(c_image.getdata())\n    newArray = []\n    for i in range(len(message)):\n        charInt = ord(message[i])\n        cb = str(bin(charInt))[2:].zfill(8)\n        pix1 = pixList[i*2]\n        pix2 = pixList[(i*2)+1]\n        newpix1 = []\n        newpix2 = []\n\n        for j in range(0,4):\n            newpix1.append(set_LSB(pix1[j], cb[j]))\n            newpix2.append(set_LSB(pix2[j], cb[j+4]))\n\n        newArray.append(tuple(newpix1))\n        newArray.append(tuple(newpix2))\n\n    newArray.extend(pixList[len(message)*2:])\n    out.putdata(newArray)\n    out.save(outfile)\n    return outfile\n\nif __name__ == \"__main__\":\n\n print(\"Testing hide message in python_secrets.png with LSB ...\")\n print(hide_message('python.png', 'Hidden message', 'python_secrets.png'))\n print(\"Hide test passed, testing message extraction ...\")\n print(extract_message('python_secrets.png'))\n```", "```py\n# stepic - Python image steganography\n'''Python image steganography\nStepic hides arbitrary data inside PIL images.\nStepic uses the Python Image Library\n(apt: python-imaging, web: <http://www.pythonware.com/products/pil/>).\n'''\nfrom PIL import Image\n\ndef _validate_image(image):\n    if image.mode not in ('RGB', 'RGBA', 'CMYK'):\n        raise ValueError('Unsupported pixel format: ''image must be RGB, RGBA, or CMYK')\n    if image.format == 'JPEG':\n        raise ValueError('JPEG format incompatible with steganography')\n\n```", "```py\ndef encode_imdata(imdata, data):\n    '''given a sequence of pixels, returns an iterator of pixels with encoded data'''\n\n    datalen = len(data)\n    if datalen == 0:\n        raise ValueError('data is empty')\n    if datalen * 3 > len(imdata):\n        raise ValueError('data is too large for image')\n\n    imdata = iter(imdata)\n    for i in xrange(datalen):\n        pixels = [value & ~1 for value in\n            imdata.next()[:3] + imdata.next()[:3] + imdata.next()[:3]]\n        byte = ord(data[i])\n        for j in xrange(7, -1, -1):\n            pixels[j] |= byte & 1\n            byte >>= 1\n        if i == datalen - 1:\n            pixels[-1] |= 1\n            pixels = tuple(pixels)\n            yield pixels[0:3]\n            yield pixels[3:6]\n            yield pixels[6:9]\n\ndef encode_inplace(image, data):\n    '''hides data in an image'''\n    _validate_image(image)\n    w = image.size[0]\n    (x, y) = (0, 0)\n    for pixel in encode_imdata(image.getdata(), data):\n        image.putpixel((x, y), pixel)\n        if x == w - 1:\n            x = 0\n            y += 1\n        else:\n            x += 1\n\ndef encode(image, data):\n    '''generates an image with hidden data, starting with an existing\n       image and arbitrary data'''\n\n    image = image.copy()\n    encode_inplace(image, data)\n    return image\n```", "```py\ndef decode_imdata(imdata):\n    '''Given a sequence of pixels, returns an iterator of characters\n    encoded in the image'''\n\n    imdata = iter(imdata)\n    while True:\n        pixels = list(imdata.next()[:3] + imdata.next()[:3] + imdata.next()[:3])\n        byte = 0\n        for c in xrange(7):\n            byte |= pixels[c] & 1\n            byte <<= 1\n        byte |= pixels[7] & 1\n        yield chr(byte)\n        if pixels[-1] & 1:\n            break\n\ndef decode(image):\n    '''extracts data from an image'''\n    _validate_image(image)\n    return ''.join(decode_imdata(image.getdata()))\n```", "```py\ndecode_imdata(imdata)\n```", "```py\nfrom PIL import Image\nimport stepic\n\n#Open an image file in which you want to hide data\nimage = Image.open(\"python.png\")\n\n#Encode some text into the source image. \n#This returns another Image instance, which can save to a new file\n\nimage2 = stepic.encode(image, 'This is the hidden text')\nimage2.save('python_secrets.png','PNG')\n\n#Use the decode() function to extract data from an image:\n\nimage2 = Image.open('python_secrets.png')\ns = stepic.decode(image2) \ndata = s.decode()\nprint(\"Decoded data: \" + data)\n```"]