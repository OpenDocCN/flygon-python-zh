- en: PyQt Raspberry Pi
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyQt树莓派
- en: The Raspberry Pi is one of the most successful and exciting computers of the
    past decade. Introduced in 2012 by a British nonprofit organization as a way to
    teach children about computer science, the tiny **Advanced RISC Machine** (**ARM**)-based
    computer has become a ubiquitous tool for hobbyists, tinkerers, developers, and
    IT professionals of all kinds. With Python and PyQt readily available and well
    supported on its default OS, the Raspberry Pi is a great tool for PyQt developers
    as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派是过去十年中最成功和令人兴奋的计算机之一。这款由英国非营利组织于2012年推出的微型**高级RISC机器**（**ARM**）计算机，旨在教育孩子们计算机科学知识，已成为业余爱好者、改装者、开发人员和各类IT专业人士的普遍工具。由于Python和PyQt在其默认操作系统上得到了很好的支持，树莓派也是PyQt开发人员的绝佳工具。
- en: 'In this chapter, we''ll look at developing with PyQt5 on the Raspberry Pi in
    the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在以下部分中查看在树莓派上使用PyQt5开发：
- en: Running PyQt5 on the Raspberry Pi
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在树莓派上运行PyQt5
- en: Controlling **General Purpose Input/Output** (**GPIO**) devices with PyQt
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PyQt控制**通用输入/输出**（**GPIO**）设备
- en: Controlling PyQt with GPIO devices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GPIO设备控制PyQt
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to follow along with the examples in this chapter, you''ll need these
    items:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章的示例，您需要以下物品：
- en: A Raspberry Pi—preferably 3 Model B+ or newer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台树莓派——最好是3型B+或更新的型号
- en: A power supply, keyboard, mouse, monitor, and network connection for the Pi
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派的电源供应、键盘、鼠标、显示器和网络连接
- en: A micro SD card with Raspbian 10 or later installed; you can refer to the official
    documentation at [https://www.raspberrypi.org/documentation/installation/](https://www.raspberrypi.org/documentation/installation/)
    for instructions on how to install Raspbian
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了Raspbian 10或更高版本的微型SD卡；您可以参考官方文档[https://www.raspberrypi.org/documentation/installation/](https://www.raspberrypi.org/documentation/installation/)上的说明来安装Raspbian
- en: At the time of writing, Raspbian 10 has not yet been released, though it is
    possible to upgrade Raspbian 9 to the testing version. You can refer to [Appendix
    B](18a932ab-b74e-42b2-b793-4e39a5208cc0.xhtml), *Upgrading Raspbian 9 to Raspbian
    10,* of this book for instructions on how to upgrade if Raspbian 10 is not available.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Raspbian 10尚未发布，尽管可以将Raspbian 9升级到测试版本。如果Raspbian 10不可用，您可以参考本书的附录B，*将Raspbian
    9升级到Raspbian 10*，了解升级的说明。
- en: To program our GPIO-based projects, you'll also need some electronic components
    to interface with. These parts are commonly available in electronics starter kits or
    from your local electronics supply store.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写基于GPIO的项目，您还需要一些电子元件来进行接口。这些零件通常可以在电子入门套件中找到，也可以从当地的电子供应商那里购买。
- en: 'The first project will require the following items:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个项目将需要以下物品：
- en: A breadboard
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个面包板
- en: Three identical resistors (between 220 and 1,000 ohms)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个相同的电阻（阻值在220到1000欧姆之间）
- en: One tri-color LED
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个三色LED
- en: Four female-to-male jumper wires
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四根母对公跳线
- en: 'The second project will require the following items:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个项目将需要以下物品：
- en: A breadboard
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个面包板
- en: One DHT11 or DHT22 temperature/humidity sensor
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个DHT11或DHT22温湿度传感器
- en: One push button switch
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个按钮开关
- en: One resistor (the value isn't important)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个电阻（值不重要）
- en: Three female-to-male jumper wires
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三根母对公跳线
- en: 'The Adafruit DHT sensor library, which is available from PyPI using the following
    command:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adafruit DHT传感器库，可使用以下命令从PyPI获取：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can refer to the GitHub repository at [https://github.com/adafruit/Adafruit_Python_DHT](https://github.com/adafruit/Adafruit_Python_DHT)
    for more information.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考GitHub存储库[https://github.com/adafruit/Adafruit_Python_DHT](https://github.com/adafruit/Adafruit_Python_DHT)获取更多信息。
- en: You may also want to download the example code from [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter15](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter15).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想从[https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter15](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter15)下载示例代码。
- en: Check out the following video to see the code in action: [http://bit.ly/2M5xDSx](http://bit.ly/2M5xDSx)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码运行情况：[http://bit.ly/2M5xDSx](http://bit.ly/2M5xDSx)
- en: Running PyQt5 on the Pi
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在树莓派上运行PyQt5
- en: The Raspberry Pi is capable of running many different operating systems, so
    installing Python and PyQt is entirely dependent on which operating system you
    choose. In this book, we're going to focus on **Raspbian**—the official (and most
    commonly used) operating system for the Pi.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派能够运行许多不同的操作系统，因此安装Python和PyQt完全取决于您选择的操作系统。在本书中，我们将专注于树莓派的官方（也是最常用的）操作系统**Raspbian**。
- en: Raspbian is based on the stable release of Debian GNU/Linux, which, at the time
    of publication, is Debian 9 (Stretch). Unfortunately, the versions of Python and
    PyQt5 available for this release of Debian are too old for the code in this book.
    If, as you read this book, Raspbian 10 has not yet been released, please consult
    [Appendix B](18a932ab-b74e-42b2-b793-4e39a5208cc0.xhtml), *Upgrading Raspbian
    9 to Raspbian 10*, for instructions on how to upgrade Raspbian 9 to Raspbian 10.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Raspbian基于Debian GNU/Linux的稳定版本，目前是Debian 9（Stretch）。不幸的是，本书中的代码所需的Python和PyQt5版本对于这个Debian版本来说太旧了。如果在阅读本书时，Raspbian
    10尚未发布，请参考附录B，*将Raspbian 9升级到Raspbian 10*，了解如何将Raspbian 9升级到Raspbian 10的说明。
- en: Raspbian 10 comes with Python 3.7 preinstalled, but we'll need to install PyQt5
    ourselves. Note that you cannot use `pip` to install PyQt5 on the Raspberry Pi,
    as the required Qt binary files are not available from PyPI for the ARM platform
    (on which the Pi is based). However, a version of PyQt5 is available from the
    Raspbian software repositories. This will *not* be the latest version of PyQt5,
    but a version that was chosen during the Debian development process to be the
    most stable and compatible with the release. For Debian/Raspbian 10, this version
    is PyQt 5.11.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Raspbian 10预装了Python 3.7，但我们需要自己安装PyQt5。请注意，您不能使用`pip`在树莓派上安装PyQt5，因为所需的Qt二进制文件在PyPI上不适用于ARM平台（树莓派所基于的平台）。但是，PyQt5的一个版本可以从Raspbian软件存储库中获取。这将*不*是PyQt5的最新版本，而是在Debian开发过程中选择的最稳定和兼容发布的版本。对于Debian/Raspbian
    10，这个版本是PyQt 5.11。
- en: 'To install it, first make sure that your device is connected to the internet.
    Then, open a command-line Terminal and enter the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它，首先确保您的设备连接到互联网。然后，打开命令行终端并输入以下命令：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The **Advanced Packaging Tool** (**APT**) utility will download and install
    PyQt5 and all of the necessary dependencies. Note that this command only installs
    the main modules of PyQt5 for Python 3\. Certain modules, such as `QtSQL`, `QtMultimedia`,
    `QtChart`, and `QtWebEngineWidgets`, are packaged separately and will need to
    be installed using an additional command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级打包工具**（**APT**）实用程序将下载并安装PyQt5及所有必要的依赖项。请注意，此命令仅为Python 3安装PyQt5的主要模块。某些模块，如`QtSQL`、`QtMultimedia`、`QtChart`和`QtWebEngineWidgets`，是单独打包的，需要使用额外的命令进行安装：'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are many more optional libraries packaged for PyQt5\. To obtain a complete
    list, you can use the `apt search` command, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多为PyQt5打包的可选库。要获取完整列表，可以使用`apt search`命令，如下所示：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: APT is the primary way in which software is installed, removed, and updated
    on Raspbian, Debian, and many other Linux distributions. While similar to `pip`,
    APT is used for the whole operating system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: APT是在Raspbian、Debian和许多其他Linux发行版上安装、删除和更新软件的主要方式。虽然类似于`pip`，APT用于整个操作系统。
- en: Editing Python on the Pi
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在树莓派上编辑Python
- en: 'Although you can edit Python on your own computer and copy it to the Raspberry
    Pi for execution, you will likely find it more convenient to edit your code directly
    on the device. If your favorite code editor or **Integrated Development Environment**
    (**IDE**) is not available for Linux or ARM, never fear; Raspbian offers several
    alternatives:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以在自己的计算机上编辑Python并将其复制到树莓派上执行，但您可能会发现直接在设备上编辑代码更加方便。如果您喜欢的代码编辑器或**集成开发环境**（**IDE**）在Linux或ARM上不可用，不要担心；Raspbian提供了几种替代方案：
- en: The **Thonny** Python IDE comes preloaded with the default Raspbian image and
    is perfectly suitable for the examples in this chapter
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Thonny** Python IDE预装了默认的Raspbian镜像，并且非常适合本章的示例'
- en: '**IDLE**, Python''s default programming environment is also preinstalled'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IDLE**，Python的默认编程环境也是预装的'
- en: '**Geany**, a generic programming text editor suitable for many languages, is
    also preinstalled'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Geany**，一个适用于许多语言的通用编程文本编辑器，也是预装的'
- en: Traditional code editors such as **Vim** and **Emacs** and Python IDEs, such
    as **Spyder**, **Ninja IDE**, and **Eric**, can be installed from the package
    repository using the Add/Remove Software tool (found under Preferences in the
    Programs menu) or using the `apt` command
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的代码编辑器，如**Vim**和**Emacs**，以及Python IDE，如**Spyder**、**Ninja IDE**和**Eric**，可以使用添加/删除软件工具（在程序菜单的首选项下找到）或使用`apt`命令从软件包存储库安装
- en: Whatever application or approach you choose, make sure that you back up your
    files to another device, as Raspberry Pi's SD card storage is not the most robust.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择哪种应用程序或方法，请确保将文件备份到另一台设备，因为树莓派的SD卡存储并不是最稳健的。
- en: Running PyQt5 applications on the Pi
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在树莓派上运行PyQt5应用程序
- en: Once Python and PyQt5 are installed on your Raspberry Pi, you should be able
    to run any of the applications we've written so far in this book. Essentially,
    the Pi is a computer running GNU/Linux, with which all of the code in this book
    is compatible. With this in mind, you *could* simply use it as a small, energy-efficient
    computer for running your PyQt applications.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Python和PyQt5安装在您的树莓派上，您应该能够运行本书中到目前为止我们编写的任何应用程序。基本上，树莓派是一台运行GNU/Linux的计算机，本书中的所有代码都与之兼容。考虑到这一点，您*可以*简单地将其用作运行PyQt应用程序的小型、节能计算机。
- en: However, the Raspberry Pi has some distinctive features of its own, most notably,
    its GPIO pins. These pins enable the Pi to communicate with external digital circuits
    in a very simple and accessible way. Raspbian comes with software libraries preinstalled,
    which allows us to control these pins using Python.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，树莓派有一些独特的特性，最显著的是其GPIO引脚。这些引脚使树莓派能够以一种非常简单和易于访问的方式与外部数字电路进行通信。Raspbian预装了软件库，允许我们使用Python控制这些引脚。
- en: To take full advantage of the unique platform that this feature offers us, we're
    going to spend the rest of this chapter focused on using PyQt5 in combination
    with the GPIO features of the Raspberry Pi to create GUI applications that interact
    with real-world circuitry in a way that only a device like the Pi can.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用这一特性提供给我们的独特平台，我们将在本章的其余部分中专注于使用PyQt5与树莓派的GPIO功能结合，创建GUI应用程序，以与现实世界的电路进行交互，这只有像树莓派这样的设备才能做到。
- en: Controlling GPIO devices with PyQt
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PyQt控制GPIO设备
- en: For our first project, we're going to learn how we can control an external circuit
    from a PyQt application. You'll be wiring up a multicolor LED and controlling
    its color using `QColorDialog`. Gather the components listed in the *Technical
    requirements* section for the first project and let's get started.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个项目，我们将学习如何可以从PyQt应用程序控制外部电路。您将连接一个多色LED，并使用`QColorDialog`来控制其颜色。收集第一个项目中列出的组件，并让我们开始吧。
- en: Connecting the LED circuit
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接LED电路
- en: Let's begin this project by connecting the components of our circuit on the
    breadboard. Power off the Pi and disconnect the power, and then place it near
    your breadboard.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在面包板上连接电路的组件来开始这个项目。关闭树莓派并断开电源，然后将其放在面包板附近。
- en: It's always a good idea to shut down your Raspberry Pi and disconnect the power
    before connecting circuits to the GPIO pins. This will reduce the risk of destroying
    your Raspberry Pi in the event that you connect something incorrectly, or if you
    accidentally touch the component leads.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接电路到GPIO引脚之前，关闭树莓派并断开电源总是一个好主意。这将减少在连接错误的情况下破坏树莓派的风险，或者如果您意外触摸到组件引脚。
- en: 'The main component in this circuit is the tri-color LED. Although these vary
    slightly, the most common pinout for this component is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个电路中的主要组件是三色LED。尽管它们略有不同，但这个元件的最常见引脚布局如下：
- en: '![](assets/1d1018be-3dc8-4a65-ad28-831c18015ade.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1d1018be-3dc8-4a65-ad28-831c18015ade.png)'
- en: Essentially, a tri-color LED is a red LED, a green LED, and a blue LED combined
    into one package. It provides separate input leads to send current into each color
    separately and a fourth lead for the common ground. By feeding different voltages
    into each pin, we can mix red, green, and blue light to create a wide variety
    of colors, just as we mix these three elements to create RGB colors in our applications.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，三色LED是将红色LED、绿色LED和蓝色LED组合成一个包。它提供单独的输入引脚，以便分别向每种颜色发送电流，并提供一个共同的地引脚。通过向每个引脚输入不同的电压，我们可以混合红色、绿色和蓝色光，从而创建各种各样的颜色，就像我们在应用程序中混合这三种元素来创建RGB颜色一样。
- en: 'Add the LED to your breadboard so that each pin is on a separate row in the
    board. Then, connect the remaining components as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 将LED添加到面包板上，使得每个引脚都在面包板的不同行上。然后，连接其余的组件如下：
- en: '![](assets/37d2d5a0-2e88-4956-8fbb-04b724336b0b.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/37d2d5a0-2e88-4956-8fbb-04b724336b0b.png)'
- en: 'As you can see in the preceding diagram, we''re making the following connections:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们正在进行以下连接：
- en: The ground pin on the LED is connected directly to the third outside pin from
    the left on the Raspberry Pi
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED上的地针直接连接到树莓派左侧第三个外部引脚。
- en: The red pin on the LED is connected to one of the resistors, which is then connected
    to the next pin to the right (that is, pin 8)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED上的红色引脚连接到一个电阻，然后连接到右侧的下一个引脚（即引脚8）
- en: The green pin on the LED is connected to another resistor, which is then connected
    to the next free pin to the right (that is, pin 10)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED上的绿色引脚连接到另一个电阻，然后连接到右侧的下一个空闲引脚（即引脚10）
- en: The blue pin on the LED is connected to the last resistor, which is connected
    to the next free pin to the right on the Pi (pin 12)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED上的蓝色引脚连接到最后一个电阻，然后连接到Pi上右侧的下一个空闲引脚（引脚12）
- en: 'It is important to double-check your circuit and make sure that you''ve connected
    the wires to the correct pins on the Raspberry Pi. Not all GPIO pins on the Raspberry
    Pi are the same; some of them are programmable, while others have a hardcoded
    purpose. You can view a listing of the pins on your Pi by running the `pinout`
    command in the Terminal; you should see the following output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要仔细检查您的电路，并确保您已将电线连接到树莓派上的正确引脚。树莓派上并非所有的GPIO引脚都相同；其中一些是可编程的，而其他一些具有硬编码目的。您可以通过在终端中运行`pinout`命令来查看Pi上的引脚列表；您应该看到以下输出：
- en: '![](assets/5f9f8eee-267d-4935-ab36-6c1c18bd542d.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5f9f8eee-267d-4935-ab36-6c1c18bd542d.png)'
- en: The preceding screenshot shows the layout of the pins as if you were holding
    the Pi in front of you with the USB ports down. Note that several of the pins
    are marked **GND**; these are always the ground pins so you can connect the ground
    of your circuit to any of those pins. Other pins are labeled **5V** or **3V3**;
    these are always 5 volts or 3.3 volts, respectively. The remaining pins with the
    GPIO labels are programmable pins. Your wires should be connected to pins **8** (**GPIO14**),
    **10** (**GPIO15**), and **12** (**GPIO18**).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示了引脚的布局，就好像您正面对着树莓派，USB端口朝下。请注意，其中有几个引脚标有**GND**；这些始终是地引脚，因此您可以将电路的地连接到其中任何一个引脚。其他引脚标有**5V**或**3V3**；这些始终是5伏或3.3伏。其余带有GPIO标签的引脚是可编程引脚。您的电线应连接到引脚**8**（**GPIO14**）、**10**（**GPIO15**）和**12**（**GPIO18**）。
- en: Double-check your circuit connections, and then boot the Raspberry Pi. It's
    time to start coding!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查您的电路连接，然后启动树莓派。是时候开始编码了！
- en: Writing a driver library
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写驱动程序库
- en: Now that our circuit is connected, we need to write some code to control it.
    To do this, we're going to make use of the `GPIO` library on the Pi. Create a
    copy of your PyQt application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow,* and call it `three_color_led_gui.py`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的电路已连接好，我们需要编写一些代码来控制它。为此，我们将在树莓派上使用`GPIO`库。从[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)中创建一个PyQt应用程序模板的副本，*使用QMainWindow构建应用程序*，并将其命名为`three_color_led_gui.py`。
- en: 'We''ll start by importing the `GPIO` library:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从导入`GPIO`库开始：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What we want to do first is to create a Python class that will serve as an
    API for our circuit. We''ll call it `ThreeColorLed`, and then start it as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是创建一个Python类，作为我们电路的API。我们将称之为`ThreeColorLed`，然后开始如下：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our `__init__()` method takes five arguments: the first three arguments are
    the pin numbers for the red, green, and blue LED connections; the fourth argument
    is the **pin mode** used to interpret the pin numbers; and the fifth argument
    is a frequency, which we''ll discuss later. First, let''s talk about the pin mode.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`__init__()`方法接受五个参数：前三个参数是红色、绿色和蓝色LED连接的引脚号；第四个参数是用于解释引脚号的引脚模式；第五个参数是频率，我们稍后会讨论。首先，让我们谈谈引脚模式。
- en: If you look at the output from the `pinout` command, you'll notice that there
    are two ways to describe a pin on the Pi using integers. The first is by its position
    on the board, from 1 to 40\. The second is by its GPIO number (that is, the number
    following GPIO in the pin description). The `GPIO` library allows you to specify
    pins using either number, but you have to tell it which method you're going to
    use by passing one of two constants to the `GPIO.setmode()` function. `GPIO.BOARD`
    specifies that you're using the positional numbers (such as 1 to 40), while `GPIO.BCM`
    means you want to use the GPIO names. As you can see, we default here to using
    `BOARD`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`pinout`命令的输出，你会注意到在树莓派上用整数描述引脚有两种方法。第一种是根据板子上的位置，从1到40。第二种是根据它的GPIO编号（即在引脚描述中跟在GPIO后面的数字）。`GPIO`库允许你使用任一种数字来指定引脚，但你必须通过向`GPIO.setmode()`函数传递两个常量中的一个来告诉它你要使用哪种方法。`GPIO.BOARD`指定你使用位置编号（如1到40），而`GPIO.BCM`表示你要使用GPIO名称。正如你所看到的，我们默认在这里使用`BOARD`。
- en: Whenever you write a class that takes GPIO pin numbers as arguments, be sure
    to allow the user to specify the pin mode as well. The numbers themselves are
    meaningless without the context of the pin mode.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你编写一个以GPIO引脚号作为参数的类时，一定要允许用户指定引脚模式。这些数字本身没有引脚模式的上下文是没有意义的。
- en: 'Next, our `__init__()` method needs to set up the output pins:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的`__init__()`方法需要设置输出引脚：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A GPIO pin can be set to the `IN` or `OUT` mode, depending on whether you want
    to read from the pin's state or write to it. In this project, we're going to be
    sending information from the software to the circuit, so we need all of the pins
    in the `OUT` mode. After storing our pin numbers in a `dict` object, we have iterated
    through them and set them to the appropriate mode using the `GPIO.setup()` function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO引脚可以设置为`IN`或`OUT`模式，取决于你是想从引脚状态读取还是向其写入。在这个项目中，我们将从软件发送信息到电路，所以我们需要将所有引脚设置为`OUT`模式。在将引脚号存储在`dict`对象中后，我们已经通过使用`GPIO.setup()`函数迭代它们并将它们设置为适当的模式。
- en: 'Once set up, we can tell an individual pin to go high or low using the `GPIO.output()`
    function, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好后，我们可以使用`GPIO.output()`函数告诉单个引脚是高电平还是低电平，如下所示：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code simply turns each pin on and immediately off again (probably faster
    than you can see). We could use this approach to set the LED to a few simple colors;
    for example, we could make it red by setting the red pin `HIGH` and the others
    `LOW`, or cyan by setting the blue and green pins `HIGH` and the red `LOW`. Of
    course, we want to produce a much wider variety of colors, but we can't do that
    by simply turning the pins fully on or off. We need some way to vary the voltage
    of each pin between the minimum (0 volts) and the maximum (5 volts) smoothly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码简单地打开每个引脚，然后立即关闭（可能比你看到的更快）。我们可以使用这种方法来设置LED为几种简单的颜色；例如，我们可以通过将红色引脚设置为`HIGH`，其他引脚设置为`LOW`来使其变为红色，或者通过将蓝色和绿色引脚设置为`HIGH`，红色引脚设置为`LOW`来使其变为青色。当然，我们希望产生更多种颜色，但我们不能简单地通过完全打开或关闭引脚来做到这一点。我们需要一种方法来在每个引脚的电压之间平稳地变化，从最小值（0伏）到最大值（5伏）。
- en: Unfortunately, the Raspberry Pi cannot do this. The outputs are digital, not
    analog, so they can only be fully on or fully off. However, we can *simulate* varying
    voltage by using a technique called **Pulse Width Modulation** (**PWM**).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，树莓派无法做到这一点。输出是数字的，而不是模拟的，因此它们只能完全开启或完全关闭。然而，我们可以通过使用一种称为**脉宽调制**（**PWM**）的技术来*模拟*变化的电压。
- en: PWM
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PWM
- en: Find a light switch in your house with reasonably responsive bulbs (LED bulbs
    work best). Then, try turning them on and off once per second. Now flick the switch
    faster and faster until the light in the room appears almost constant. You should
    notice that it seems dimmer in the room than when you had the light on all of
    the time, even though the bulb is only ever completely on or completely off.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在你家里找一个有相对灵敏灯泡的开关（LED灯泡效果最好）。然后，尝试每秒钟打开和关闭一次。现在越来越快地按开关，直到房间里的灯几乎看起来是恒定的。你会注意到房间里的光似乎比你一直开着灯时要暗，即使灯泡只是完全开启或完全关闭。
- en: PWM works in the same way, except that, with the Pi, we can turn the voltage
    on and off so quickly (and quietly, of course) that the toggling between on and
    off appears seamless. Additionally, by varying the ratio of how long the pin is
    on to how long it is off in each cycle, we can simulate varying voltages between
    zero voltage and the maximum voltage. This ratio is known as the **duty cycle**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: PWM的工作方式相同，只是在树莓派上，我们可以如此快速（当然是无声地）地打开和关闭电压，以至于在打开和关闭之间的切换看起来是无缝的。此外，通过在每个周期中调整引脚打开时间和关闭时间的比例，我们可以模拟在零电压和最大电压之间的变化电压。这个比例被称为**占空比**。
- en: More information about the concept and use of pulse width modulation can be
    found at [https://en.wikipedia.org/wiki/Pulse-width_modulation](https://en.wikipedia.org/wiki/Pulse-width_modulation).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于脉宽调制的概念和用法的更多信息可以在[https://en.wikipedia.org/wiki/Pulse-width_modulation](https://en.wikipedia.org/wiki/Pulse-width_modulation)找到。
- en: 'To use PWM on our pins, we have to set them up first by creating a `GPIO.PWM`
    object on each pin:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的引脚上使用PWM，我们首先要通过在每个引脚上创建一个`GPIO.PWM`对象来设置它们：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, we're using a list comprehension to produce another `dict` that
    will contain the name of each pin along with a `PWM` object. The `PWM` object
    is created by passing in a pin number and a frequency value. This frequency will
    be the rate at which the pin is toggled on and off.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用列表推导来生成另一个包含每个引脚名称和`PWM`对象的`dict`。通过传入引脚号和频率值来创建`PWM`对象。这个频率将是引脚切换开和关的速率。
- en: 'Once we''ve created our `PWM` objects, we need to start them up:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了我们的`PWM`对象，我们需要启动它们：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `PWM.start()` method begins the flicking of the pin from on to off. The
    argument passed to `start()` indicates the duty cycle as a percentage; here, `0`
    means that the pin will be on 0% of the time (so, basically, it's off). A value
    of 100 will keep the pin completely on all of the time, and values in between
    indicate the amount of on time the pin receives per cycle.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`PWM.start()`方法开始引脚的闪烁。传递给`start()`的参数表示占空比的百分比；这里，`0`表示引脚将在0%的时间内打开（基本上是关闭）。值为100将使引脚始终完全打开，而介于两者之间的值表示引脚在每个周期内接收的打开时间的量。'
- en: Setting a color
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置颜色
- en: Now that our pins are configured for PWM, we need to create a method that will
    allow us to set the LED to a specific color by passing in red, green, and blue
    values. Most software RGB color implementations (including `QColor`) specify these
    values as 8-bit integers (0 to 255). Our PWM values, however, represent a duty
    cycle, which is expressed as a percentage (0 to 100).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的引脚已经配置为PWM，我们需要创建一个方法，通过传入红色、绿色和蓝色值，使LED显示特定的颜色。大多数软件RGB颜色实现（包括`QColor`）将这些值指定为8位整数（0到255）。然而，我们的PWM值表示占空比，它表示为百分比（0到100）。
- en: 'Therefore, since we''re going to need to convert numbers from the 0 to 255
    range into the 0 to 100 range several times, let''s start with a static method
    that will do such a conversion:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于我们需要多次将0到255范围内的数字转换为0到100范围内的数字，让我们从一个静态方法开始，该方法将执行这样的转换：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This method ensures that we''ll get a valid duty cycle regardless of the input
    by using simple arithmetic:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法确保我们将获得有效的占空比，而不管输入如何，都使用简单的算术运算：
- en: First, we use the absolute value of the number to prevent passing any negative
    values.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们使用数字的绝对值来防止传递任何负值。
- en: Second, we divide the value by 2.55 to find the percentage of 255 that it represents.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们将值除以2.55，以找到它代表的255的百分比。
- en: Finally, we get the modulus of 101 for the number, so that percentages higher
    than 100 will cycle around and remain in range.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们对数字取101的模，这样百分比高于100的数字将循环并保持在范围内。
- en: 'Now, let''s write our `set_color()` method, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写我们的`set_color()`方法，如下所示：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `PWM.ChangeDutyCycle()` method takes a value from 0 to 100 and adjusts the
    duty cycle of the pin accordingly. In this method, we're simply converting our
    input RGB values into the proper scale and passing them into the corresponding
    PWM objects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`PWM.ChangeDutyCycle()`方法接受0到100的值，并相应地调整引脚的占空比。在这个方法中，我们只是将我们的输入RGB值转换为适当的比例，并将它们传递给相应的PWM对象。'
- en: Cleaning up
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: The last method we need to add to our class is a clean-up method. The GPIO pins
    on the Raspberry Pi can be thought of as a state machine, in which each pin has
    a state of high or a state of low (that is, on or off). When we set these pins
    in our program, the state of those pins will remain set after our program exits.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加到我们的类中的最后一个方法是清理方法。树莓派上的GPIO引脚可以被视为一个状态机，其中每个引脚都有高状态或低状态（即打开或关闭）。当我们在程序中设置这些引脚时，这些引脚的状态将在程序退出后保持设置。
- en: Note that this could cause a problem if we're connecting a different circuit
    to our Pi; having a pin set to `HIGH` at the wrong moment while connecting a circuit
    could fry some of our components. For that reason, we want to leave everything
    off when we exit the program.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们连接了不同的电路到我们的Pi，这可能会导致问题；在连接电路时，如果在错误的时刻将引脚设置为`HIGH`，可能会烧坏一些组件。因此，我们希望在退出程序时将所有东西关闭。
- en: 'This can be done using the `GPIO.cleanup()` function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以使用`GPIO.cleanup()`函数完成：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By adding this method to our LED driver class, we can easily clean up the state
    of the Pi after each use.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这个方法添加到我们的LED驱动程序类中，我们可以在每次使用后轻松清理Pi的状态。
- en: Creating the PyQt GUI
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建PyQt GUI
- en: 'Now that we''ve taken care of the GPIO side, let''s create our PyQt GUI. In
    `MainWindow.__init__()`, add in the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了GPIO方面，让我们创建我们的PyQt GUI。在`MainWindow.__init__()`中，添加以下代码：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we're creating a `ThreeColorLed` instance using the pin numbers that we
    connected to our breadboard. Remember that the class uses the `BOARD` numbers
    by default, so `8`, `10`, and `12` are the correct values here. If you want to
    use the `BCM` numbers, be sure to specify this in the constructor arguments.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用连接到面包板的引脚号创建了一个`ThreeColorLed`实例。请记住，默认情况下，该类使用`BOARD`号码，因此这里的正确值是`8`、`10`和`12`。如果要使用`BCM`号码，请确保在构造函数参数中指定这一点。
- en: 'Now let''s add a color picker dialog:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一个颜色选择对话框：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Typically, we invoke a color dialog by calling `QColorDialog.getColor()`, but
    in this case, we want to use the dialog as if it were a widget. So, we're instantiating
    one directly and setting the `NoButtons` and `DontUseNativeDialog` options. By
    taking away the buttons and using the Qt version of the dialog, we can prevent
    the user from canceling or submitting the dialog. This allows us to treat it as
    a regular widget and assign it as the main window's central widget.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们通过调用`QColorDialog.getColor()`来调用颜色对话框，但在这种情况下，我们希望将对话框用作小部件。因此，我们直接实例化一个对话框，并设置`NoButtons`和`DontUseNativeDialog`选项。通过去掉按钮并使用对话框的Qt版本，我们可以防止用户取消或提交对话框。这允许我们将其视为常规小部件并将其分配为主窗口的中央小部件。
- en: 'We''ve connected the `currentColorChanged` signal (which is emitted whenever
    the user selects a color) to a `MainWindow` method called `set_color()`. We''ll
    add this next, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`currentColorChanged`信号（每当用户选择颜色时发出）连接到一个名为`set_color()`的`MainWindow`方法。我们将在接下来添加这个方法，如下所示：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `currentColorChanged` signal includes a `QColor` object representing the
    color selected, so we can simply dissect that into red, green, and blue values
    using the `QColor` property accessors, and then pass that information to our `ThreeColorLed`
    object's `set_color()` method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`currentColorChanged`信号包括表示所选颜色的`QColor`对象，因此我们可以简单地使用`QColor`属性访问器将其分解为红色、绿色和蓝色值，然后将该信息传递给我们的`ThreeColorLed`对象的`set_color()`方法。'
- en: Now the script is complete. You should be able to run it and light up your LED—give
    it a try!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在脚本已经完成。您应该能够运行它并点亮LED-试试看！
- en: Note that the color you pick won't exactly match the color output for the LED
    due to differences in the relative brightness of different colored LEDs. However,
    they should be reasonably close.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您选择的颜色可能不会完全匹配LED的颜色输出，因为不同颜色LED的相对亮度不同。但它们应该是相当接近的。
- en: Controlling PyQt with GPIO devices
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GPIO设备控制PyQt
- en: Controlling circuits from Python using GPIO pins is fairly straightforward.
    It's simply a matter of calling the `GPIO.output()` function with the appropriate
    pin number and high or low value. Now, however, we're going to look at the opposite
    situation, that is, controlling or updating a PyQt GUI from GPIO input.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GPIO引脚从Python控制电路非常简单。只需调用`GPIO.output()`函数，并使用适当的引脚编号和高或低值。然而，现在我们要看相反的情况，即从GPIO输入控制或更新PyQt
    GUI。
- en: To demonstrate this, we're going to build a temperature and humidity readout.
    Just as before, we'll start by connecting the circuit.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们将构建一个温度和湿度读数。就像以前一样，我们将从连接电路开始。
- en: Connecting the sensor circuit
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接传感器电路
- en: The DHT 11 and DHT 22 sensors are both temperature and humidity sensors that
    can easily work with the Raspberry Pi. Both are packaged as four-pin components,
    but only three of the pins are actually used. Some component kits even mount the
    DHT 11/22 on a small PCB with only the active three pins for output.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: DHT 11和DHT 22传感器都是温度和湿度传感器，可以很容易地与树莓派一起使用。两者都打包为四针元件，但实际上只使用了三根引脚。一些元件套件甚至将DHT
    11/22安装在一个小PCB上，只有三根活动引脚用于输出。
- en: 'In either case, if you''re looking at the DHT''s front (that is, the grill
    side), then the pins from left to right are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，如果您正在查看DHT的正面（即，格栅一侧），则从左到右的引脚如下：
- en: The input voltage—either 5 or 3 volts
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入电压——5或3伏特
- en: The sensor output
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器输出
- en: The dead pin (on a 4-pin configuration)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 死引脚（在4针配置中）
- en: Ground
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地线
- en: Either the DHT 11 or the DHT 22 will work equally well for this project. The
    11 is smaller and cheaper, but slower and less accurate than the 22\. Otherwise,
    they are functionally the same.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: DHT 11或DHT 22对于这个项目都同样适用。11更小更便宜，但比22慢且不太准确。否则，它们在功能上是一样的。
- en: 'Plug your sensor into the breadboard so that each pin is in its own row. Then,
    connect it to the Raspberry Pi using jumper wires, as demonstrated in the following
    screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将传感器插入面包板中，使每个引脚都在自己的行中。然后，使用跳线线将其连接到树莓派，如下面的屏幕截图所示：
- en: '![](assets/a29672ae-3bab-464d-891e-54cde52127fe.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a29672ae-3bab-464d-891e-54cde52127fe.png)'
- en: The sensor's voltage input pin can be connected to either of the 5V pins, and
    the ground can be connected to any of the GND pins. Additionally, the data pin
    can be connected to any GPIO pin on the Pi, but in this case, we'll use pin 7
    (once again, going by the `BOARD` numbers).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器的电压输入引脚可以连接到任何一个5V引脚，地线可以连接到任何一个GND引脚。此外，数据引脚可以连接到树莓派上的任何GPIO引脚，但在这种情况下，我们将使用引脚7（再次，按照`BOARD`编号）。
- en: Double-check your connections to make sure everything is correct, then power
    on the Raspberry Pi, and we'll start coding.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查您的连接，确保一切正确，然后打开树莓派的电源，我们将开始编码。
- en: Creating the sensor interface
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建传感器接口
- en: To begin our sensor interface software, first, create another copy of your Qt
    application template and call it `temp_humid_display.py`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始我们的传感器接口软件，首先创建另一个Qt应用程序模板的副本，并将其命名为`temp_humid_display.py`。
- en: 'The first thing we''ll do is import the necessary libraries, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先导入必要的库，如下所示：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`Adafruit_DHT` will encapsulate all of the complicated bits required to talk
    to the DHT unit so that we only need to work with high-level functions to control
    and read data from the device.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Adafruit_DHT`将封装与DHT单元通信所需的所有复杂部分，因此我们只需要使用高级功能来控制和读取设备的数据。'
- en: 'Underneath the imports, let''s set up a global constant:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入下面，让我们设置一个全局常量：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We're setting up a global constant indicating which model of DHT we're working
    with; if you have the DHT 22, then set this value to 22\. We're also setting up
    the Pi's pin mode. But this time, we're going to use the `BCM` mode to specify
    our pin numbers. The Adafruit library only takes `BCM` numbers, so it makes sense
    to be consistent across all of our classes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在设置一个全局常量，指示我们正在使用哪个型号的DHT；如果您有DHT 22，则将此值设置为22。我们还设置了树莓派的引脚模式。但这次，我们将使用`BCM`模式来指定我们的引脚编号。Adafruit库只接受`BCM`编号，因此在我们所有的类中保持一致是有意义的。
- en: 'Now, let''s start our sensor interface class for the DHT:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始为DHT创建传感器接口类：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This time, we're going to base our class on `QObject` so that we can emit signals
    when the values are read from the sensor and run the object in its own thread.
    The DHT units are a bit slow and can take a full second or more to respond when
    we request a reading. For that reason, we'll want to run its interface in a separate
    thread of execution. As you may remember from [Chapter 10](06a74416-66c5-4538-9dc5-c540a3a44da9.xhtml),
    *Multithreading with QTimer and QThread,* this is easily done when we can interact
    with the object using signals and slots.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将基于`QObject`类来创建我们的类，以便在从传感器读取值时发出信号，并在其自己的线程中运行对象。DHT单元有点慢，当我们请求读数时可能需要一秒或更长时间来响应。因此，我们希望在单独的执行线程中运行其接口。正如您可能记得的来自[第10章](06a74416-66c5-4538-9dc5-c540a3a44da9.xhtml)
    *使用QTimer和QThread进行多线程处理*，当我们可以使用信号和插槽与对象交互时，这很容易实现。
- en: 'Now, let''s add the `__init__()` method, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加`__init__()`方法，如下所示：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The constructor will take three arguments: the pin connected to the data line,
    the model number (11 or 22), and a Boolean indicating whether we want to use the
    Fahrenheit or Celsius scale. We''ll simply save all of these arguments to instance
    variables for the time being.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数将接受三个参数：连接到数据线的引脚，型号（11或22），以及一个布尔值，指示我们是否要使用华氏或摄氏温标。我们暂时将所有这些参数保存到实例变量中。
- en: 'Now we want to create a method to tell the sensor to take a reading:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要创建一个方法来告诉传感器进行读数：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the `Adafruit_DHT` library takes all of the complications out
    of reading this sensor. We simply have to call `read_entry()` with the model and
    pin numbers of our sensor and it returns a tuple containing the humidity and temperature
    values. The temperature is returned in degrees Celsius, so for American users,
    we're doing a calculation to convert this into Fahrenheit if the object is configured
    to do so. Then, we emit our three signals—one each for temperature, humidity,
    and the current time.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`Adafruit_DHT`库消除了读取传感器的所有复杂性。我们只需使用传感器的型号和引脚号调用`read_entry()`，它就会返回一个包含湿度和温度值的元组。温度以摄氏度返回，因此对于美国用户，如果对象配置为这样做，我们将进行计算将其转换为华氏度。然后，我们发出三个信号——分别是温度、湿度和当前时间。
- en: Note that we have wrapped this function using the `pyqtSlot` decorator. Again,
    recall from [Chapter 10](06a74416-66c5-4538-9dc5-c540a3a44da9.xhtml), *Multithreading
    with QTimer and QThread,* that this will remove some of the complications of moving
    this class to its own thread.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`pyqtSlot`装饰器包装了这个函数。再次回想一下[第10章](06a74416-66c5-4538-9dc5-c540a3a44da9.xhtml)中的内容，*使用QTimer和QThread进行多线程处理*，这将消除将这个类移动到自己的线程中的一些复杂性。
- en: This takes care of our sensor driver class, so now, let's build the GUI.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了我们的传感器驱动程序类，现在让我们构建GUI。
- en: Displaying the readings
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示读数
- en: By this point in this book, creating a PyQt GUI to display a couple of numbers
    should be a walk in the park. Just to make things interesting and to create a
    stylish look, we're going to use a widget that we haven't talked about yet—`QLCDNumber`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，创建一个PyQt GUI来显示一些数字应该是轻而易举的。为了增加趣味性并创建时尚的外观，我们将使用一个我们还没有讨论过的小部件——`QLCDNumber`。
- en: 'First, create a base widget in `MainWindow.__init__()`, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`MainWindow.__init__()`中创建一个基本小部件，如下所示：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s apply some of the styling skills that we learned in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml),
    *Styling Qt Applications*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们应用一些我们在[第6章](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml)中学到的样式技巧，*Qt应用程序样式*：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we're creating a custom `QPalette` object for this widget and its children,
    giving it a color scheme that is reminiscent of a blue-backlit LCD screen.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为这个小部件及其子级创建了一个自定义的`QPalette`对象，给它一个类似于蓝色背光LCD屏幕的颜色方案。
- en: 'Next, let''s create widgets to display our readings:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建用于显示我们的读数的小部件：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `QLCDNumber` widget is a widget for displaying numbers. It resembles an
    eight-segment LCD display, such as you might find on an instrument panel or digital
    clock. Its `segmentStyle` property switches between a couple of different visual
    styles; in this case, we're using `Flat`, which draws the segments filled in with
    the foreground color.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`QLCDNumber`小部件是用于显示数字的小部件。它类似于一个八段数码管显示，例如您可能在仪表板或数字时钟上找到的。它的`segmentStyle`属性在几种不同的视觉样式之间切换；在这种情况下，我们使用`Flat`，它用前景颜色填充了段。'
- en: 'With the layout now configured, let''s create a sensor object:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在布局已经配置好了，让我们创建一个传感器对象：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we've created a sensor connected to pin GPIO4 (that is, pin 7), which
    passes in the `SENSOR_MODEL` constant that we defined earlier and sets Fahrenheit
    to `True` (feel free to set it to `False` if you prefer Celsius). After that,
    we create a `QThread` object and move the `SensorInterface` object to it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个连接到GPIO4引脚（即7号引脚）的传感器，传入我们之前定义的`SENSOR_MODEL`常量，并将华氏度设置为`True`（如果您喜欢摄氏度，可以随时将其设置为`False`）。之后，我们创建了一个`QThread`对象，并将`SensorInterface`对象移动到其中。
- en: 'Next, let''s connect our signals and slots, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们连接我们的信号和插槽，如下所示：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `QLCDNumber.display()` slot can be connected to any signal that emits a
    number, so we connect our temperature and humidity signals directly. The `QTime`
    object sent with the `read_time` signal will need some parsing, however, so we'll
    connect it to a `MainWindow` method called `show_time()`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`QLCDNumber.display()`插槽可以连接到发出数字的任何信号，因此我们直接连接我们的温度和湿度信号。然而，发送到`read_time`信号的`QTime`对象将需要一些解析，因此我们将其连接到一个名为`show_time()`的`MainWindow`方法。'
- en: 'That method looks like the following code block:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法看起来像以下代码块：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This method will take advantage of the `MainWindow` object's convenient `statusBar()`
    method to show the time of the last temperature reading in the status area.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将利用`MainWindow`对象方便的`statusBar()`方法，在状态区域显示最后一次温度读数的时间。
- en: 'So, that takes care of our GUI output display; we now need a way to trigger
    the sensor to take readings. One approach we could take is to create a timer to
    do it periodically:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这解决了我们的GUI输出显示；现在我们需要一种方法来触发传感器定期进行读数。我们可以采取的一种方法是创建一个定时器来定期执行它：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this case, this timer will call `sensor.take_reading()` every minute, ensuring
    that our readings are regularly updated.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这个定时器将每分钟调用`sensor.take_reading()`，确保我们的读数定期更新。
- en: 'We can also add `QPushButton` to the interface so that the user can get fresh
    readings on demand:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在界面中添加`QPushButton`，以便用户可以随时获取新的读数：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is fairly trivial, as we just need to connect the button's `clicked` signal
    to the sensor's `take_reading` slot. But what about a hardware control? How might
    we implement something external to trigger a temperature reading? We'll explore
    that in the next section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，因为我们只需要将按钮的`clicked`信号连接到传感器的`take_reading`插槽。但是硬件控制呢？我们如何实现外部触发温度读数？我们将在下一节中探讨这个问题。
- en: Adding a hardware button
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加硬件按钮
- en: Reading values from a sensor can be useful, but what would be even more useful
    is being able to respond to events that happen in a circuit and take action as
    a result. To demonstrate this process, we'll add a hardware button to our circuit
    and monitor its state so that we can take temperature and humidity readings at
    the push of a button.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从传感器读取值可能是有用的，但更有用的是能够响应电路中发生的事件并作出相应的行动。为了演示这个过程，我们将在电路中添加一个硬件按钮，并监视它的状态，以便我们可以在按下按钮时进行温度和湿度读数。
- en: Expanding the circuit
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展电路
- en: 'To begin, power off the Raspberry Pi and let''s add some components to the
    circuit, as shown in the following diagram:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，关闭树莓派的电源，让我们向电路中添加一些组件，如下图所示：
- en: '![](assets/b493a2fa-96bd-4435-9ba8-d2ae3ee2fe9c.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b493a2fa-96bd-4435-9ba8-d2ae3ee2fe9c.png)'
- en: Here, we've essentially added a button and a resistor. The button needs to be
    connected to pin 8 on the Pi on one side, and the resistor, which is connected
    to ground, on the other. To keep the wiring clean, we've also taken advantage
    of the common ground and common voltage rails on the side of the breadboard, although
    this is optional (you can just connect things directly to the appropriate GND
    and 5V pins on the Pi, if you prefer).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们基本上添加了一个按钮和一个电阻。按钮需要连接到树莓派上的引脚8的一侧，而电阻连接到地面的另一侧。为了保持布线整洁，我们还利用了面包板侧面的公共地和公共电压导轨，尽管这是可选的（如果您愿意，您可以直接将东西连接到树莓派上的适当GND和5V引脚）。
- en: The push buttons that are often found in starter kits have four connectors—two
    for each side of the switch. Make sure that your connections are not connected
    until the button is pushed. If you find that they are always connected even without
    the button being pushed, then you probably need to rotate your button by 90 degrees
    in the circuit.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在入门套件中经常找到的按钮有四个连接器，每侧两个开关。确保您的连接在按钮被按下之前不连接。如果您发现即使没有按下按钮，它们也总是连接在一起，那么您可能需要将按钮在电路中旋转90度。
- en: The button in this circuit will simply connect our GPIO pin to ground when pushed,
    which will allow us to detect a button push. We'll see how that works in more
    detail when we write the software.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个电路中，按钮在被按下时将简单地将我们的GPIO引脚连接到地面，这将允许我们检测按钮按下。当我们编写软件时，我们将更详细地了解它是如何工作的。
- en: Implementing the button driver
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现按钮驱动程序
- en: 'Start a new class at the top of your script to be the driver for our push button:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的顶部开始一个新的类，作为我们按钮的驱动程序：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once again, we're using `QObject` so that we can emit Qt signals, which we'll
    do when we detect that the button has been pushed down.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用`QObject`，以便我们可以发出Qt信号，当我们检测到按钮被按下时，我们将这样做。
- en: 'Now, let''s write the constructor, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写构造函数，如下所示：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The first thing our `__init__()` method does after calling `super().__init__()`
    is configure our button's GPIO pin to be an input pin by passing the `GPIO.IN`
    constant to the `setup()` function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`super().__init__()`之后，我们的`__init__()`方法的第一件事是通过将`GPIO.IN`常量传递给`setup()`函数来将我们的按钮的GPIO引脚配置为输入引脚。
- en: The `pull_up_down` value we've passed here is very important. Because of the
    way we've connected this circuit, the pin will be connected to the ground whenever
    the button is pushed. But what happens when the button is not pushed? Well, in
    that case, it's in a state called **float**, in which the input will be unpredictable.
    In order to keep the pin in a predictable state when the button is not pushed,
    the `pull_up_down` argument will cause it to be pulled either `HIGH` or `LOW`
    when it is not otherwise connected. In our case, we want it pulled `HIGH` because
    our button will be pulling it `LOW`; passing in the `GPIO.PUD_UP` constant will
    do this.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里传递的`pull_up_down`值非常重要。由于我们连接电路的方式，当按钮被按下时，引脚将连接到地面。但是当按钮没有被按下时会发生什么？嗯，在这种情况下，它处于**浮动**状态，其中输入将是不可预测的。为了在按钮没有被按下时保持引脚处于可预测的状态，`pull_up_down`参数将导致在没有其他连接时将其拉到`HIGH`或`LOW`。在我们的情况下，我们希望它被拉到`HIGH`，因为我们的按钮将把它拉到`LOW`；传递`GPIO.PUD_UP`常量将实现这一点。
- en: This could work in a reverse fashion as well; for example, we could have connected
    the other side of the button to 5V, and then set `pull_up_down` to `GPIO.PUD_DOWN`
    in the `setup()` function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以以相反的方式工作；例如，我们可以将按钮的另一侧连接到5V，然后在`setup()`函数中将`pull_up_down`设置为`GPIO.PUD_DOWN`。
- en: Now, we need to figure out how to detect when the button is being pressed so
    that we can emit our signal.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要弄清楚如何检测按钮何时被按下，以便我们可以发出信号。
- en: One simple approach to this task is **polling**. Polling simply means that we're
    going to check the button at a regular interval and emit a signal if something
    changes from the last check.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这项任务的一个简单方法是**轮询**。轮询简单地意味着我们将定期检查按钮，并在上次检查时发生变化时发出信号。
- en: 'To do this, we first need to create an instance variable to save the last known
    state of the button:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们首先需要创建一个实例变量来保存按钮的上一个已知状态：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can check the current state of the button by calling the `GPIO.input()` function
    with the pin number. This function will return either `HIGH` or `LOW`, indicating
    whether the pin is at 5V or ground. If the pin is `LOW`, then that means the button
    is pressed down. We'll save that result to `self.pressed`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用`GPIO.input()`函数并传递引脚号来检查按钮的当前状态。此函数将返回`HIGH`或`LOW`，指示引脚是否为5V或地面。如果引脚为`LOW`，那么意味着按钮被按下。我们将将结果保存到`self.pressed`。
- en: 'Next, we''ll write a method to check the state of the button for changes:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个方法来检查按钮状态的变化：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This check method will take the following steps:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个检查方法将采取以下步骤：
- en: First, it compares the output of `input()` to the `LOW` constant to see whether
    the button is pressed
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它将比较`input()`的输出与`LOW`常量，以查看按钮是否被按下
- en: Then, we compare the current state of the button to the saved state to see whether
    the button's state has changed
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们比较按钮的当前状态与保存的状态，以查看按钮的状态是否发生了变化
- en: If it has, we then need to check whether the change of state is a press or a
    release
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有，我们需要检查状态的变化是按下还是释放
- en: If it is a press (`pressed` is `True`), then we emit the signal
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是按下（`pressed`为`True`），那么我们发出信号
- en: In either case, we update `self.pressed` with the new state
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论哪种情况，我们都会使用新状态更新`self.pressed`
- en: 'Now, all that remains is to call this method on a regular basis to poll for
    changes; back in `__init__()`, we can do this with a timer, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的就是定期调用这个方法来轮询变化；在`__init__()`中，我们可以使用定时器来做到这一点，如下所示：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we've created a timer that times out every 50 milliseconds, calling `self.check()`
    when it does so. This should be often enough to catch even the fastest button
    push that a human being can execute.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个定时器，每50毫秒超时一次，当这样做时调用`self.check()`。这应该足够频繁，以至于可以捕捉到人类可以执行的最快的按钮按下。
- en: 'Polling works well, but there is a cleaner way to do this by using the `GPIO`
    library''s `add_event_detect()` function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询效果很好，但使用`GPIO`库的`add_event_detect()`函数有一种更干净的方法来做到这一点：
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `add_event_detect()` function will start monitoring the pin in another thread
    for either a `RISING` event or a `FALLING` event, and call the configured `callback`
    method when such an event is detected.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_event_detect()`函数将在另一个线程中开始监视引脚，以侦听`RISING`事件或`FALLING`事件，并在检测到此类事件时调用配置的`callback`方法。'
- en: 'In this case, we just call the following instance method:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只需调用以下实例方法：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We could pass our `emit()` method directly as a callback, but `add_event_detect()`
    will call the callback function with the pin number as an argument, which `emit()`
    will not accept.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接将我们的`emit()`方法作为回调传递，但是`add_event_detect()`将使用引脚号调用回调函数作为参数，而`emit()`将不接受。
- en: The downside of using `add_event_detect()` is that it introduces another thread,
    using the Python `threading` library, which can lead to subtle problems with the
    PyQt event loop. Polling is a perfectly workable alternative that allows you to
    avoid this complication.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`add_event_detect()`的缺点是它引入了另一个线程，使用Python的`threading`库，这可能会导致与PyQt事件循环的微妙问题。轮询是一个完全可行的替代方案，可以避免这种复杂性。
- en: 'Either approach will work for our simple script, so let''s head back to `MainWindow.__init__()`
    to add support for our button:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都适用于我们的简单脚本，所以让我们回到`MainWindow.__init__()`来为我们的按钮添加支持：
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: All we need to do is create an instance of our `HWButton` class with the right
    pin number and connect its `button_press` signal to the sensor's `take_reading()`
    slot.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要做的就是创建一个`HWButton`类的实例，使用正确的引脚号，并将其`button_press`信号连接到传感器的`take_reading()`插槽。
- en: Now, if you fire everything up on the Pi, you should be able to see an update
    when you push the button.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您在树莓派上启动所有内容，当您按下按钮时，您应该能够看到更新。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The Raspberry Pi is an exciting technology, not only because of its small size,
    low cost, and low resource usage, but because it makes connecting the world of
    programming to real-world circuitry simple and accessible in a way that nothing
    had before. In this chapter, you learned how to configure the Raspberry Pi to
    run PyQt applications. You also learned how to control circuits using PyQt and
    Python, and how circuits could control actions in your software.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派是一项令人兴奋的技术，不仅因为其小巧、低成本和低资源使用率，而且因为它使得将编程世界与真实电路的连接变得简单和易于访问，这是以前没有的。在本章中，您学会了如何配置树莓派来运行PyQt应用程序。您还学会了如何使用PyQt和Python控制电路，以及电路如何控制软件中的操作。
- en: In the next chapter, we're going to bring the World Wide Web into our PyQt applications
    using `QtWebEngineWidgets`, a full Chromium-based browser inside a Qt Widget.
    We'll build a functional browser, and we'll learn about the ins and outs of the
    web engine library.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用`QtWebEngineWidgets`将全球网络引入我们的PyQt应用程序，这是一个完整的基于Chromium的浏览器，内置在Qt
    Widget中。我们将构建一个功能齐全的浏览器，并了解网络引擎库的各个方面。
- en: Questions
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try answering the following questions to test your knowledge from this chapter:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试回答以下问题，以测试您从本章中获得的知识：
- en: You have just bought a Raspberry Pi with Raspbian preinstalled to run your PyQt5
    application. When you try to run your application, you get an error trying to
    import `QtNetworkAuth`, which your application depends on. What is likely to be
    the problem?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您刚刚购买了一个预装了Raspbian的树莓派来运行您的PyQt5应用程序。当您尝试运行您的应用程序时，您遇到了一个错误，试图导入`QtNetworkAuth`，这是您的应用程序所依赖的。问题可能是什么？
- en: You have written a PyQt frontend for a legacy scanner device. Your code talks
    to the scanner through a proprietary driver utility called `scanutil.exe`. It
    is currently running on a Windows 10 PC, but your employer wants to save money
    by moving it to a Raspberry Pi. Is this a good idea?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已经为传统扫描仪设备编写了一个PyQt前端。您的代码通过一个名为`scanutil.exe`的专有驱动程序实用程序与扫描仪通信。它目前正在运行在Windows
    10 PC上，但您的雇主希望通过将其移动到树莓派来节省成本。这是一个好主意吗？
- en: You've acquired a new sensor and want to try it out with the Raspberry Pi. It
    has three connections, labeled Vcc, GND, and Data. How would you connect this
    to the Raspberry Pi? Is there more information you need?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已经获得了一个新的传感器，并希望尝试将其与树莓派一起使用。它有三个连接，标有Vcc、GND和Data。您将如何将其连接到树莓派？您还需要更多信息吗？
- en: You're trying to light an LED connected to the fourth GPIO pin from the left
    on the outside. What is wrong with this code?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您正在点亮连接到最左边的第四个GPIO引脚的LED。这段代码有什么问题？
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You are trying to dim an LED connected to GPIO pin 12\. Does the following code
    work?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您正在调暗连接到GPIO引脚12的LED。以下代码有效吗？
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You have a motion sensor with a data pin that goes `HIGH` when motion is detected.
    It''s connected to pin `8`. The following is your driver code:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您有一个运动传感器，当检测到运动时，数据引脚会变为`HIGH`。它连接到引脚`8`。以下是您的驱动代码：
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Your main window class creates a `MotionSensor` object and connects its `detection`
    signal to a callback method. However, nothing is being detected. What is missing?
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您的主窗口类创建了一个`MotionSensor`对象，并将其`detection`信号连接到回调方法。然而，没有检测到任何东西。缺少了什么？
- en: Combine the two circuits in this chapter in a creative way; for example, you
    might create a light that changes color depending on humidity and temperature.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以创造性的方式将本章中的两个电路结合起来；例如，您可以创建一个根据湿度和温度变化颜色的灯。
- en: Further reading
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For further information, please refer to the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅以下内容：
- en: More documentation for the Raspberry Pi's `GPIO` library can be found at [https://sourceforge.net/p/raspberry-gpio-python/wiki/Home/](https://sourceforge.net/p/raspberry-gpio-python/wiki/Home/)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关树莓派的`GPIO`库的更多文档可以在[https://sourceforge.net/p/raspberry-gpio-python/wiki/Home/](https://sourceforge.net/p/raspberry-gpio-python/wiki/Home/)找到
- en: Packt offers many books covering the Raspberry Pi in detail; you can find more
    information at [https://www.packtpub.com/books/content/raspberry-pi](https://www.packtpub.com/books/content/raspberry-pi)
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Packt提供了许多详细介绍树莓派的书籍；您可以在[https://www.packtpub.com/books/content/raspberry-pi](https://www.packtpub.com/books/content/raspberry-pi)找到更多信息。
