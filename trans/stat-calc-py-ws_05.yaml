- en: 5\. More Mathematics with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 用Python进行更多数学
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to grasp the basic concepts of
    sequences and series and write Python functions that implement these concepts.
    You will understand the relationships between basic trigonometric functions and
    their applications, such as the famous Pythagorean theorem. You will practice
    vector calculus and know where it is applicable by performing vector algebra in
    Python. Finally, you will feel happy knowing that complex numbers are not any
    less a type of number; they are intimately connected to trigonometry and are useful
    for real-world applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够掌握序列和级数的基本概念，并编写实现这些概念的Python函数。你将了解基本三角函数及其应用之间的关系，比如著名的毕达哥拉斯定理。你将练习向量微积分，并通过在Python中进行向量代数来了解它的适用性。最后，你会感到高兴，因为复数并不比其他类型的数字差；它们与三角学密切相关，并且对现实世界的应用很有用。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we covered functions and algebra with Python, starting
    with basic functions before working through transformations and solving equations.
    In this chapter, we'll introduce sequences and series, which have many applications
    in the real world, such as finance, and also form the basis for an understanding
    of calculus. Additionally, we will explore trigonometry, vectors, and complex
    numbers to give us a better understanding of the mathematical world.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们用Python介绍了函数和代数，从基本函数开始，然后进行变换和解方程。在本章中，我们将介绍序列和级数，在现实世界中有许多应用，比如金融，也是理解微积分的基础。此外，我们还将探讨三角学、向量和复数，以便更好地理解数学世界。
- en: The core skills of any exceptional Python programmer include a solid understanding
    of the background mathematics and an effective application of them. Think of vectors
    and complex numbers as valuable extensions to our *mathematical toolbox* that,
    later on, will contribute to efficiently describing, quantifying, and tackling
    real-world problems from the finance, science, or business and social domains.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 任何出色的Python程序员的核心技能包括对背景数学的深刻理解以及有效地应用它们。把向量和复数看作是我们*数学工具箱*的有价值扩展，它们将有助于有效地描述、量化和解决来自金融、科学、商业和社会领域的现实问题。
- en: Sequences and series, among others, appear in situations where profits, losses,
    dividends, or other payments occur on a regular basis. Trigonometry and trigonometric
    functions are necessary to solve geospatial problems, while vectors are applied
    widely in physics and engineering, machine learning, and more, where several different
    values are grouped together and the notion of direction is pivotal. Complex numbers
    are some of the most fundamental concepts that enjoy wide applications in electromagnetism,
    optics, quantum mechanics, and computer science.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 序列和级数等在利润、损失、股利或其他支付定期发生的情况中出现。三角学和三角函数对解决地理空间问题至关重要，而向量在物理学和工程学、机器学习等领域得到广泛应用，其中多个不同的值被分组在一起，方向的概念至关重要。复数是一些最基本的概念，在电磁学、光学、量子力学和计算机科学等领域有广泛的应用。
- en: Sequences and Series
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列和级数
- en: 'If you were to participate in a TV show where the $10,000 question was *"Given
    the numbers 2, 4, 8, 16, and 32, what comes next in the sequence?"*, what would
    your best guess be? If your response is 64, then congratulations—you just came
    closer to understanding one of the key concepts in mathematical abstraction: that
    of a sequence. A **sequence** is, pretty much like in the ordinary sense of the
    word, a particular order in which things follow each other. Here, *things* are
    (in most cases) integers or real numbers that are related. The order of the elements
    matters. The elements are also called the members or terms of the sequence.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你参加一个电视节目，其中1万美元的问题是“给定数字2、4、8、16和32，序列中接下来是什么？”，你最好的猜测是什么？如果你的回答是64，那么恭喜你——你刚刚更接近理解数学抽象中的一个关键概念：序列。**序列**就像普通意义上的顺序一样，是一种事物相互跟随的特定顺序。在这里，*事物*（在大多数情况下）是相关的整数或实数。元素的顺序很重要。元素也被称为序列的成员或术语。
- en: For example, in the preceding sequence of the TV show you participated in, every
    term stems from the number prior being multiplied by 2; there is no end in this
    sequence as there is no end in the number of terms (integer numbers) you can come
    up with. In other instances, elements in a sequence can appear more than once.
    Think of the number of days in the months of a year, or just the sequence of the
    outcomes of a random event, say, the toss of a coin. A well-known sequence that
    has been known since the ancient Indian times is the Fibonacci sequence—1, 1,
    2, 3, 5, 8, 13…. This is the sequence where each *new* term is the sum of the
    two previous terms.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在你参与的电视节目的前述序列中，每个术语都是前一个数字乘以2得到的；这个序列没有结束，因为可以无限产生整数数字。在其他情况下，序列中的元素可以出现多次。想想一年中每个月的天数，或者随机事件的结果序列，比如抛硬币的结果。自古印度以来就已知的一个著名序列是斐波那契数列——1、1、2、3、5、8、13……这个序列中，每个*新*术语都是前两个术语的和。
- en: That is, we need to know at least two terms before we can derive any other.
    In other words, we need to read the two first numbers (in the preceding sequence,
    1 and 1, but generally any two numbers) before we are capable of deriving and
    predicting the third number. We know that some sequences, such as the Fibonacci
    sequence, include some logic inside them; a basic rule that we can follow and
    derive any term of the sequence.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们需要知道至少两个术语才能推导出其他任何术语。换句话说，我们需要读取前两个数字（在前述序列中是1和1，但通常是任意两个数字）才能推导和预测第三个数字。我们知道一些序列，比如斐波那契数列，其中包含一些内在的逻辑；我们可以遵循一个基本规则，并推导出序列的任何术语。
- en: 'In this chapter, we will be focusing on basic sequences, also known as **progressions**,
    that are repeatedly found across many fields in applied mathematics and programming
    that fall in either of the three basic categories: arithmetic, geometric, and
    recursive. These are not the only possibilities; they are, nonetheless, the most
    popular families of sequences and illustrate the logic that they entail.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注基本序列，也称为**级数**，这些序列在应用数学和编程的许多领域中反复出现，属于三种基本类别之一：等差、等比和递归。这些不是唯一的可能性；然而，它们是最受欢迎的序列家族，并且说明了它们所蕴含的逻辑。
- en: A **sequence** of numbers {αn} = {α1, α2, α3, ..., αΝ, ...} is an ordered collection
    of terms (elements or members) for which there is a rule that associates each
    natural number n = 1, 2, 3, ..., N with just one of the terms in the sequence.
    The length of the sequence (that is, the number of its terms) can be finite or
    infinite, and the sequence is hence called finite or infinite, accordingly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列数字{αn} = {α1, α2, α3, ..., αΝ, ...}是一个有序的术语（元素或成员）的集合，对于这个集合有一个规则，将每个自然数n
    = 1, 2, 3, ..., N与序列中的一个术语关联起来。序列的长度（即其术语的数量）可以是有限的或无限的，因此相应地称为有限或无限序列。
- en: 'A **series** is a mathematical sequence that is summed as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**级数**是一个按照以下方式求和的数学序列：
- en: '![Figure 5.1: Equation of series'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.1: 级数方程'
- en: '](image/B15968_05_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_01.jpg)'
- en: 'Figure 5.1: Equation of series'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：级数方程
- en: 'This can also be summed using the summation sign, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以使用求和符号进行求和，如下所示：
- en: '![Figure 5.2: Equation of an infinite series'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2：无限级数的方程'
- en: '](image/B15968_05_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_02.jpg)'
- en: 'Figure 5.2: Equation of an infinite series'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：无限级数的方程
- en: In the preceding case, our series is infinite (that is, it is the sum of all
    the terms of an infinite sequence). However, a series, such as a sequence, can
    also be finite. Why would a sum have infinite terms? Because it turns out that,
    in many cases, the summation is carried out computationally more efficiently by
    applying known formulas. Moreover, the summation can converge to a number (not
    infinite) or some function, even when the sequence is infinite. Due to this, series
    can be considered the *building blocks* of known functions, and their terms can
    be used to represent functions of increasing complexity, thus making the study
    of their properties intuitive. Series and sequences are ubiquitous in mathematics,
    physics, engineering, finance, and beyond and have been known since ancient times.
    They appear and are particularly useful as infinite sums in the definition of
    derivates and other functions as well.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情况下，我们的级数是无限的（即，它是无限序列的所有项的和）。然而，一个级数，就像一个序列一样，也可以是有限的。为什么一个总和会有无限个项？因为事实证明，在许多情况下，通过应用已知的公式进行计算更有效。此外，即使序列是无限的，求和也可以收敛到一个数字（不是无穷大）或某个函数。由于这个原因，级数可以被认为是已知函数的*构建块*，它们的术语可以用来表示越来越复杂的函数，从而使得对它们的性质的研究变得直观。级数和序列在数学、物理、工程、金融等领域中无处不在，并且自古以来就为人所知。它们出现并且作为无限和的定义在导数和其他函数中特别有用。
- en: Arithmetic Sequences
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等差数列
- en: 'Like most mathematical concepts, sequences can be found everywhere in our daily
    lives. You might not have thought about it before, but every time you ride a cab,
    a sequence is *running* in the background to calculate the total cost of your
    ride. There is an initial charge that increments, by a fixed amount, for every
    kilometer (or mile) you ride. So, at any given moment, there''s a real, corresponding
    number (the price of the ride so far). The ordered set of all these subtotals
    forms a sequence. Similarly, your body height as you grow up is a sequence of
    real numbers (your height expressed in centimeters or inches) in time (days or
    months). Both these examples constitute sequences that are non-decreasing in time—in
    other words, every term is either larger than or equal to any previous term, but
    never smaller. However, there is a subtle difference between the two examples:
    while the rate at which we gain height as we grow differs (growth is fast for
    kids, slow for teenagers, and zero for adults), the rate at which the taxi fare
    increases is constant. This leads us to need to introduce a special class of sequences—arithmetic
    sequences—which are defined as follows.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数数学概念一样，序列无处不在我们的日常生活中。你可能以前没有想过，但每次你乘坐出租车时，后台都会运行一个序列来计算你的乘车总费用。有一个初始费用，每公里（或英里）增加一个固定金额。因此，在任何给定时刻，都有一个实际的对应数字（到目前为止的乘车费用）。所有这些小计的有序集合形成一个序列。同样，随着你的成长，你的身高是一个随时间（天或月）变化的实数序列（以厘米或英寸表示的身高）。这两个例子都构成了随时间非递减的序列——换句话说，每个术语要么大于等于任何先前的术语，但从不小于。然而，这两个例子之间存在微妙的差异：随着我们的成长，我们增加身高的速度不同（儿童增长速度快，青少年增长速度慢，成年人增长速度为零），而出租车费用增加的速度是恒定的。这导致我们需要引入一种特殊类别的序列——等差数列，其定义如下。
- en: 'Sequences where the difference between any two consecutive terms is constant
    are called **arithmetic**. Hence, the formula for arithmetic sequences is as follows:
    *α*n+1*- α*n *= d*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 任意两个连续项之间的差是恒定的序列称为**等差**。因此，等差数列的公式如下：*α*n+1*- α*n *= d*
- en: 'Here, *d* is constant and must hold for all *n*. Of course, it becomes clear
    that, if you know the parameter *d* and some (any) term *α*n, then the term *α*n+1
    can be found by a straightforward application of the preceding relation. By repetition,
    all the terms, *α*n+2, *α*n+3 ..., as well as the terms *α*n-1, *α*n-2 can be
    found. In other words, all of the terms of our sequence are known (that is, uniquely
    determined) if you know the parameter *d*, and the first term of the sequence
    *α*1. The general formula that gives us the *n*th term of the sequence becomes
    the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*d*是常数，必须对所有*n*成立。当然，很明显，如果你知道参数*d*和一些（任何）项*α*n*，那么项*α*n+1可以通过前面的关系直接找到。通过重复，所有项*α*n+2，*α*n+3
    ...，以及项*α*n-1，*α*n-2都可以找到。换句话说，如果你知道参数*d*和序列的第一项*α*1，那么所有项（即唯一确定的）的序列都是已知的。给出我们序列的第*n*项的一般公式如下：
- en: '*α*n *= α*1 *+ (n – 1)d*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*α*n *= α*1 *+ (n – 1)d*'
- en: Here, *d* is known as the common difference.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*d*被称为公差。
- en: 'Inversely, to test whether a generic sequence is an arithmetic one, it suffices
    to check all of the pairwise differences, *α*n+1 – *α*n, of its terms and see
    whether these are the same constant number. In the corresponding arithmetic series,
    the sum of the preceding sequence becomes the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，要测试一个通用序列是否是等差数列，只需检查其项的所有成对差异*α*n+1 – *α*n，并查看这些是否是相同的常数。在相应的等差数列中，前面序列的和变成了下面的形式：
- en: '*Σ*nj *α*j *= Σ*nj *[ α*1 *+ (j – 1)d ] = n(α*1 *+ α*n*)/2*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*Σ*nj *α*j *= Σ*nj *[ α*1 *+ (j – 1)d ] = n(α*1 *+ α*n*)/2*'
- en: This means that by knowing the length, *n*, the first, and the last term of
    the sequence, we can determine the sum of all terms from *α*1 to *α*n. Note that
    the sum (*α*1 + *α*n) gives twice the arithmetic mean of the whole sequence, so
    the series is nothing more than *n* times the arithmetic mean.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着通过知道长度*n*，序列的第一个和最后一个项，我们可以确定从*α*1到*α*n的所有项的和。请注意，和（*α*1 + *α*n）给出整个序列的算术平均数的两倍，因此该序列不过是算术平均数的*n*倍。
- en: 'Now, we know what the main logic and constituents of the arithmetic sequence
    are. Now, let''s look at some concrete examples. For now, we do not need to import
    any particular libraries in Python as we will be creating our own functions. Let''s
    remind ourselves that these always need to begin with `def`, followed by a space,
    the function name (anything that we like), and a list of arguments that the function
    takes inside brackets, followed by a semi-colon. The following lines are indented
    (four places to the right) and are where the logic, that is, the algorithm or
    method of the function, is written. For instance, consider the following example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道算术序列的主要逻辑和组成部分。现在，让我们看一些具体的例子。目前，我们不需要在Python中导入任何特定的库，因为我们将创建自己的函数。让我们提醒自己，这些函数总是需要以`def`开头，后面跟着一个空格，函数名（任何我们喜欢的东西），以及函数在括号内接受的参数列表，后面跟着一个分号。接下来的行是缩进的（向右缩进四个空格），并且是函数的逻辑，也就是函数的算法或方法。例如，考虑以下例子：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What follows the final statement, `result`, is what is being returned from
    the function. So, for instance, if we are programming the preceding `my_function`
    definition, which receives two input numbers, `arg1` and `arg2`, then we can pass
    it to a new variable, say, the following one:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终语句`result`之后，返回的是函数的返回值。因此，例如，如果我们正在编写前面的`my_function`定义，该定义接收两个输入数字`arg1`和`arg2`，那么我们可以将它传递给一个新变量，比如以下变量：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output will be as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `summed` is a new variable that is exactly what is being returned (produced)
    by `my_function`. Note that if the `return` statement within the definition of
    a function is missing, then the syntax is still correct and the function can still
    be called. However, the `summed` variable will be equal to `None`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`summed`是一个新变量，它正是由`my_function`返回（生成）的。请注意，如果在函数定义中缺少`return`语句，则语法仍然正确，函数仍然可以被调用。但是，`summed`变量将等于`None`。
- en: 'Now, if we want to create a (any) sequence of numbers, we should include an
    iteration inside our function. This is achieved in Python with either a `for`
    or a `while` loop. Let''s look at an example, where a function gives a sequence
    of `n` sums as the output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想创建一个（任何）数字序列，我们应该在我们的函数内包含一个迭代。在Python中，可以通过`for`或`while`循环来实现这一点。让我们看一个例子，一个函数输出一个`n`个和的序列：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we initiate the variable result (to zero) and then iteratively add to
    it the sum, `arg1 + arg2`. This iteration happens `n` times, where `n` is also
    an argument of our new function, `my_sequence`. Every time the loop (what follows
    the `for` statement) is executed, the `result` increases by `arg1 + arg2` and
    is then printed on-screen. We have omitted the `return` statement here for simplicity.
    Here, we used Python''s built-in `range()` method, which generates a sequence
    of integer numbers that starts at 0 and ends at one number before the given stop
    integer (the number that we provide as input). Let''s call our function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们初始化变量result（为零），然后迭代地将`arg1 + arg2`加到它上面。这个迭代发生了`n`次，其中`n`也是我们新函数`my_sequence`的一个参数。每次循环（跟在`for`语句后面的）执行时，`result`增加了`arg1
    + arg2`，然后打印在屏幕上。为简单起见，我们在这里省略了`return`语句。在这里，我们使用了Python内置的`range()`方法，它生成一个整数序列，从0开始，以给定的停止整数之前的一个数结束（我们提供的数字）。让我们调用我们的函数：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will obtain the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得以下输出：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Had we used a `while` loop, we would have arrived at the same result:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用了`while`循环，我们将得到相同的结果：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we were to call the `my_sequence` function, we would obtain the same output
    that we received previously for the same input.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`my_sequence`函数，我们将得到与先前相同输入的相同输出。
- en: Generators
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器
- en: 'One more interesting option for sequential operations in Python is the use
    of generators. **Generators** are objects, similar to functions, that return an
    iterable set of items, one value at a time. Simply speaking, if a function contains
    at least one `yield` statement, it becomes a generator function. The benefit of
    using generators as opposed to functions is that we can call the generator as
    many times as desired (here, an infinite amount) without cramming our system''s
    memory. In some situations, they can be invaluable tools. To obtain one term of
    a sequence of terms, we use the `next()` method. First, let''s define our function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中进行顺序操作的另一个有趣选项是使用生成器。**生成器**是类似于函数的对象，返回一组可迭代的项目，一次一个值。简单地说，如果一个函数包含至少一个`yield`语句，它就成为一个生成器函数。使用生成器而不是函数的好处是，我们可以根据需要（这里是无限次数）调用生成器，而不会使系统的内存过载。在某些情况下，它们可以是无价的工具。要获取一系列项的一个项，我们使用`next()`方法。首先，让我们定义我们的函数：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s call the `next()` method multiple times:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们多次调用`next()`方法：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Call the method for the second time:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用该方法：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Call it for the third time:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第三次调用它：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is the output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Call the method for the fourth time:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第四次调用该方法：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following is the output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So, we obtained the same results as in the previous example, but one at a time.
    If we call the `next()` method repetitively, we will get an error message since
    we have *exhausted* our generator:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到了与上一个示例相同的结果，但是一次一个。如果我们重复调用`next()`方法，我们将收到错误消息，因为我们已经*耗尽*了我们的生成器：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we are ready to implement the relations of sequences we learned in Python
    code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备在Python代码中实现我们学到的序列关系。
- en: 'Exercise 5.01: Determining the nth Term of an Arithmetic Sequence and Arithmetic
    Series'
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.01：确定算术序列和算术级数的第n项
- en: 'In this exercise, we will create a finite and infinite arithmetic sequence
    using a simple Python function. As inputs, we want to provide the first term of
    the sequence, `a1`, the common difference, `d`, and the length of the sequence,
    `n`. Our goal is to obtain the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用一个简单的Python函数创建有限和无限的算术序列。作为输入，我们希望提供序列的第一项`a1`，公差`d`和序列的长度`n`。我们的目标是获得以下内容：
- en: Just one term (the *n*th term) of the sequence.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列的一个项（第*n*项）。
- en: The full sequence of numbers.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的数字序列。
- en: The sum of *n* terms of the arithmetic sequence, in order to compare it to our
    result of the arithmetic series given previously.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术序列的*n*项的和，以便将其与先前给出的算术级数的结果进行比较。
- en: 'To calculate the preceding goals, we need to provide the first term of the
    sequence, `a1`, the common difference, `d`, and the length of the sequence, `n`,
    as inputs. Let''s implement this exercise:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算前面的目标，我们需要提供序列的第一项`a1`，公差`d`和序列的长度`n`作为输入。让我们实现这个练习：
- en: 'First, we want to write a function that returns just the *n*th term, according
    to the general formula *α*n *= α*1 *+ (n – 1)d*:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们想要编写一个函数，根据通用公式*α*n *= α*1 *+ (n – 1)d* 返回第*n*项：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'By doing this, we obtain the *n*th term of the sequence without needing to
    know any other preceding terms. For example, let''s call our function with arguments
    `(4, 3, 10)`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们获得了序列的第*n*项，而无需知道任何其他前面的项。例如，让我们用参数`(4, 3, 10)`调用我们的函数：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will get the following output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s write a function that increments the initial term, `a1`, by `d`,
    `n` times and stores all terms in a list:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个函数，它将初始项`a1`递增`d`，`n`次，并将所有项存储在列表中：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To check the resulting list, add the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查结果列表，请添加以下代码：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output will be as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we obtained the arithmetic sequence, which has a length of 10, starts
    at `4`, and increases by 3.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们得到了一个长度为10的算术序列，从`4`开始，增加3。
- en: 'Now, let''s generate the infinite sequence. We can achieve this using Python
    generators, which we introduced earlier:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们生成无限序列。我们可以使用之前介绍的Python生成器来实现这一点：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you run the preceding code, you will notice that we have to abort the execution
    manually; otherwise, the `for` loop will print out the elements of the sequence
    eternally. An alternative way of using Python generators is, as explained previously,
    to call the `next()` method directly on the generator object (here, this is `infinite_a_sequence()`).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行上述代码，您会注意到我们必须手动中止执行；否则，`for`循环将永远打印出序列的元素。使用Python生成器的另一种方法是，如前所述，直接在生成器对象（这里是`infinite_a_sequence()`）上调用`next()`方法。
- en: 'Let''s calculate the sum of the terms of our sequence by calling the `sum()`
    Python method:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过调用`sum()` Python方法来计算我们序列的项的和：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output will be as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, implement the *α*n *= α*1 *+ (n – 1)d* formula, which gives us the
    arithmetic series so that we can compare it with our result for the sum:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现*α*n *= α*1 *+ (n – 1)d* 公式，这给我们算术级数，以便我们可以将其与我们的求和结果进行比较：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the function, as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行函数，如下：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2D2S52c.](https://packt.live/2D2S52c
    )
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2D2S52c.](https://packt.live/2D2S52c )
- en: You can also run this example online at [https://packt.live/31DjRfO.](https://packt.live/31DjRfO
    )
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/31DjRfO.](https://packt.live/31DjRfO )上在线运行此示例
- en: With that, we have arrived at the same result for the summation of elements
    of an arithmetic sequence by using either a sequence or series. The ability to
    cross-validate a given result with two independent mathematical methods is extremely
    useful for programmers at all levels and lies at the heart of scientific validation.
    Moreover, knowing different methods (here, the two methods that we used to arrive
    at the series result) that can solve the same problem, and the advantages (as
    well as the disadvantages) of each method can be vital for writing code at an
    advanced level.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们通过使用序列或级数得到了相同的结果，得到了算术序列元素的总和。能够用两种独立的数学方法交叉验证给定结果的能力对于所有级别的程序员来说都是非常有用的，并且是科学验证的核心。此外，了解不同的方法（在这里，我们用来得到级数结果的两种方法），以及每种方法的优势（以及劣势）对于在高级水平上编写代码至关重要。
- en: 'We will study a different, but also fundamental, category of sequences: geometric
    ones.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习另一种不同但同样基本的序列类别：几何序列。
- en: Geometric Sequences
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几何序列
- en: An infectious disease spreads from one person to another or more, depending
    on the density of the population in a given community. In a situation such as
    a pandemic, for a moderately contagious disease, it is realistic that, on average,
    each person who has the disease infects two people per day. So, if on day 1 there
    is just one person that's infected, on day 2 there will be two newly infected,
    and on day 3, another two people will have contracted the disease for each of
    the two previously infected people, bringing the number of the newly infected
    to four. Similarly, on day 4, eight new cases appear, and so on. We can see that
    the rate that a disease expands at is not constant since the number of new cases
    depends on the number of existing cases at a given moment—and this explains how
    pandemics arise and spread exponentially.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 传染病从一个人传播到另一个或更多人，取决于给定社区的人口密度。在像大流行这样的情况下，对于一种中等传染性的疾病，平均每个患病者每天感染两个人是现实的。因此，如果在第1天只有一个感染者，第2天将有两个新感染者，第3天，对于每个先前感染的两个人，另外两个人将感染疾病，使新感染者的数量增加到四个。同样，在第4天，会出现八个新病例，依此类推。我们可以看到疾病扩展的速度并不是恒定的，因为新病例的数量取决于给定时刻现有病例的数量，这解释了大流行是如何呈指数增长和传播的。
- en: 'The preceding numbers (1, 2, 4, 8...) form a sequence. Note that now, the requirement
    of the arithmetic sequence hasn''t been met: the difference between two successive
    terms is not constant. The ratio, nonetheless, is constant. This exemplifies the
    preceding sequence as a special type of sequence, known as **geometric**, and
    is defined as a sequence or a collection of ordered numbers where the ratio of
    any two successive terms is constant.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数字（1, 2, 4, 8...）形成一个序列。请注意，现在，算术序列的要求没有得到满足：两个连续项之间的差异不是恒定的。然而，比率是恒定的。这说明了前面的序列是一种特殊类型的序列，称为**几何**，并且被定义为一个序列或一组有序数字，其中任意两个连续项的比率是恒定的。
- en: In the compact language of mathematics, we can write the preceding behavior
    as *α*n+1 *= r α*n.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学的简洁语言中，我们可以将前面的行为写成*α*n+1 *= r α*n。
- en: Here, *α*n is the number of *cases* on day *n*, *α*n+1 is the number of new
    cases on day *n+1*, and *r>0* is a coefficient that defines how fast (or slow)
    the increase happens. This is known as the common ratio. The preceding formula
    is universal, meaning that it holds for all members, *n*. So, if it holds true
    for *n*, it does so for *n-1*, *n-2*, and so on. By working with the preceding
    relationship recursively, we can easily arrive at *α*n *= r*n-1*α* equation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*α*n是第*n*天的*病例*数量，*α*n+1是第*n+1*天的新病例数量，*r>0*是定义增长速度（或减速速度）的系数。这被称为公比。前面的公式是通用的，这意味着它适用于所有成员*n*。因此，如果它对*n*成立，那么它对*n-1*，*n-2*等也成立。通过递归地处理前面的关系，我们可以轻松地得到*α*n
    *= r*n-1*α*方程。
- en: Here, we give the *n*th term of the geometric sequence once the first term,
    *α=α*1, and the common ratio, *r*, have been given. The term *α* is known as the
    **scale factor**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们给出了几何序列的第*n*项，一旦给出了第一项*α=α*1和公比*r*。术语*α*被称为**比例因子**。
- en: 'Note that *r* can have any non-zero value. If *r>1*, every generation, *α*n+1,
    is larger than the one prior and so the sequence is ever-increasing, while the
    opposite is true if *r<1: α*n+1 tends towards zero as *n* increases. So, in the
    initial example of an infectious disease, *r>1* means that the transmission is
    increasing, while *r<1* yields a decreasing transmission.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*r*可以有任何非零值。如果*r>1*，每一代，*α*n+1都比前一代大，因此序列是不断增加的，而如果*r<1*，则相反：随着*n*的增加，*α*n+1趋于零。因此，在传染病的初始例子中，*r>1*意味着传播是增加的，而*r<1*则导致传播减少。
- en: 'Let''s write a Python function that calculates the *n*th term of a geometric
    function, based on the *α*n *= r*n-1*α* formula:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个Python函数，根据*α*n *= r*n-1*α*的公式计算几何函数的第*n*项：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The inputs in that function are `r`, the common ratio, `a`, the scale factor,
    and `n`, the *n*th term that we want to find. Let''s call this function with some
    arguments, `(2, 3, 10)`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数中的输入是`r`，公比，`a`，比例因子，和`n`，我们想要找到的第*n*项。让我们用一些参数调用这个函数，`(2, 3, 10)`：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Similarly, for the case of the arithmetic sequence, we define a geometric series
    as the sum of the terms of the sequence of length *n*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于算术序列的情况，我们将几何级数定义为序列长度*n*的项的总和：
- en: '![Figure 5.3: A geometric sequence'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3：几何序列'
- en: '](image/B15968_05_03.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_03.jpg)'
- en: 'Figure 5.3: A geometric sequence'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：几何序列
- en: 'Alternatively, we can express this as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以这样表达：
- en: '![Figure 5.4: Alternative expression for a geometric sequence'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4：几何序列的另一种表达'
- en: '](image/B15968_05_04.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_04.jpg)'
- en: 'Figure 5.4: Alternative expression for a geometric sequence'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：几何序列的另一种表达
- en: 'To get a better understanding of the geometric series, let''s check out how
    it works in Python and visualize it. We need to define a function that admits
    `r`, `a`, and `n` (as we did previously) as input and calculate the second formula,
    that is, the series up to term *n*:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解几何级数，让我们看看它在Python中是如何工作并进行可视化的。我们需要定义一个函数，接受`r`、`a`和`n`（就像之前一样）作为输入，并计算第二个公式，即到第*n*项的级数：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, call the function for arguments `(2, 3, 10)`, as we did previously:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，像之前一样，为参数`(2, 3, 10)`调用函数：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Have a look at the following example plot of geometric sequences, where the
    value increases for *r>1*:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下几何序列的以下示例图，其中值对*r>1*递增：
- en: '![Figure 5.5: Geometric sequences increasing for r>1'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5：几何序列r>1递增'
- en: '](image/B15968_05_05.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_05.jpg)'
- en: 'Figure 5.5: Geometric sequences increasing for r>1'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：几何序列r>1递增
- en: 'Have a look at the following example plot of geometric sequences, where the
    value decreases for *r<1*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下几何序列的以下示例图，其中值对*r<1*递减：
- en: '![Figure 5.6: Geometric sequences decreasing for r<1'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6：几何序列r<1递减'
- en: '](image/B15968_05_06.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_06.jpg)'
- en: 'Figure 5.6: Geometric sequences decreasing for r<1'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：几何序列r<1递减
- en: In this section, we have seen how a geometric sequence progresses and how we
    can easily find the terms of it in Python, as well as the geometric series. We
    are now ready to implement what we've learned in an exercise in order to obtain
    a better understanding of sequences and their applications.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经看到了几何序列的进展以及如何在Python中轻松找到它的项，以及几何级数。我们现在准备在练习中实现我们所学到的内容，以便更好地理解序列及其应用。
- en: 'Exercise 5.02: Writing a Function to Find the Next Term of the Sequence'
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.02：编写一个函数来找到序列的下一个项
- en: 'The number of bacteria in a Petri dish increases as a geometric sequence. Given
    the population (number) of bacteria per day, across a number of days, *n*, write
    a function that calculates the population on day *n+1*. Follow these steps to
    complete this exercise:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 培养皿中细菌数量以几何序列增加。给定每天的细菌数量，跨越一定天数*n*，编写一个函数，计算第*n+1*天的细菌数量。按照以下步骤完成这个练习：
- en: 'Write a function that admits a variable number of arguments (`*args`) and calculates
    the ratio between any element and its preceding element (starting from the second
    element). Then, check whether all the ratios found are identical and return their
    unique value. Otherwise, the function returns `-1` (the sequence does not possess
    a unique common ratio):'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，接受可变数量的参数（`*args`）并计算任何元素与其前一个元素之间的比率（从第二个元素开始）。然后，检查找到的所有比率是否相同，并返回它们的唯一值。否则，函数返回`-1`（序列没有唯一的公共比率）：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, check the `find_ratio` function for two distinct cases. First, let''s
    use the following sequence:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查`find_ratio`函数的两种不同情况。首先，让我们使用以下序列：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s use the following sequence:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下序列：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As shown in the preceding outputs, the `find_ratio` function prints out the
    ratio, if it exists, or prints `-1` if the sequence is not geometric.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出所示，`find_ratio`函数打印出比率，如果存在的话，或者如果序列不是几何序列，则打印`-1`。
- en: 'Now, write a second function that reads in a sequence and prints out what the
    next term will be. To do so, read in a (comma-separated) list of numbers, find
    their ratio, and from that, predict the next term:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写第二个函数，读取一个序列并打印出下一个项将是什么。为此，读取一个（逗号分隔的）数字列表，找到它们的比率，然后预测下一个项：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that we want to check whether the sequence possesses a common ratio by
    calling the `find_ratio()` function we wrote previously. If it doesn't, raise
    an error; if it does, find the next term and return it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们要通过调用我们之前编写的`find_ratio()`函数来检查序列是否具有公共比率。如果没有，就引发一个错误；如果有，就找到下一个项并返回它。
- en: 'Check if it works by using the following sequence:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用以下序列来检查它是否有效：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following is the output of the preceding code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, try this with a different sequence:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试使用不同的序列：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It does work. In the first case, the obvious result, `8.0`, was printed. In
    the second case, the less obvious result of the decreasing geometric sequence
    was found and printed out. To summarize, we are able to write a function that
    detects a geometric sequence, finds its ratio, and uses that to predict the next-in-sequence
    term. This is extremely useful in real-life scenarios, such as in cases where
    the compound interest rate needs to be verified.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效。在第一种情况下，明显的结果`8.0`被打印出来。在第二种情况下，找到并打印出了递减的几何序列的不太明显的结果。总之，我们能够编写一个函数，检测几何序列，找到它的比率，并用它来预测下一个序列项。这在现实生活中非常有用，比如需要验证复利利率的情况。
- en: Note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2NUyT8N.](https://packt.live/2NUyT8N
    )
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2NUyT8N](https://packt.live/2NUyT8N)。
- en: You can also run this example online at [https://packt.live/3dRMwQV.](https://packt.live/3dRMwQV
    )
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3dRMwQV](https://packt.live/3dRMwQV)上在线运行此示例。
- en: In the previous sections, we saw that sequences, either arithmetic or geometric,
    can be defined in two equivalent ways. We saw that the *n*th term of the sequence
    is determined by knowing a given term of the sequence (commonly the first, but
    not necessarily) and the common difference, or common ratio. More interestingly,
    we saw that the *n*th term of a sequence can be found by knowing the *(n-1)*th
    term, which, in turn, can be found by knowing the *(n-2)*th term, and so on. So,
    there is an interesting pattern here that dictates both sequence types that we
    studied and which, in fact, extends beyond them. It turns out that we can generalize
    this behavior and define sequences in a purely recursive manner that isn't necessarily
    arithmetic or geometric. Now, let's move on to the next section, where we will
    understand recursive sequences.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到序列，无论是等差还是等比，都可以用两种等价的方式来定义。我们看到序列的第*n*项是通过知道序列的给定项（通常是第一项，但不一定）和公差或公比来确定的。更有趣的是，我们看到序列的第*n*项可以通过知道第*(n-1)*项来找到，而第*(n-1)*项又可以通过知道第*(n-2)*项来找到，依此类推。因此，这里有一个有趣的模式，决定了我们研究的两种序列类型，实际上超出了它们。事实证明，我们可以概括这种行为，并以纯粹递归的方式定义序列，而不一定是等差或等比的。现在，让我们继续下一节，我们将了解递归序列。
- en: Recursive Sequences
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归序列
- en: A **recursive sequence** is a sequence of elements, *υ*n, that are produced
    via a recursive relation, that is, each element uniquely stems from the preceding
    ones.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归序列**是一个元素序列，*υ*n，通过递归关系产生，也就是说，每个元素都是唯一地从前面的元素产生出来的。'
- en: '*υ*n can depend on one or more elements preceding it. For example, the Fibonacci
    series that we saw earlier in this chapter is a recursive sequence where knowledge
    of the *n*th term requires knowing both the *(n-1)*th and *(n-2)*th terms. On
    the other hand, the factorial only needs the element that precedes it. Specifically,
    it is defined by the recurrence relation, *n! = n(n-1)! , n > 0*, and the initial
    condition, *0! = 1*.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*υ*n可以依赖于一个或多个在它之前的元素。例如，我们在本章前面看到的斐波那契数列是一个递归序列，其中知道第*n*项需要知道第*(n-1)*项和第*(n-2)*项。另一方面，阶乘只需要前面的元素。具体来说，它由递归关系定义，*n!
    = n(n-1)! , n > 0*，和初始条件，*0! = 1*。'
- en: 'Let''s convert the preceding formulas into Python code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面的公式转换成Python代码：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding code is a recursive implementation of the factorial function:
    to calculate the result for *n*, we call the function for *n-1*, which, in turn,
    calls the function for *n-2* and so on until *n=2* is reached.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是阶乘函数的递归实现：为了计算*n*的结果，我们调用*n-1*的函数，然后*n-1*调用*n-2*的函数，依此类推，直到*n=2*。
- en: 'If we execute the preceding function for the case *n=11*, we obtain the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对*n=11*的情况执行前面的函数，我们得到以下结果：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that while the first two categories of sequences that we've seen so far
    (arithmetic and geometric) are mutually exclusive, the recursive family of sequences
    is not, meaning that sequences can be both recursive and arithmetic or recursive
    and geometric. Conventionally, we use the term *recursive* for these types of
    sequences that, unlike geometric and arithmetic, cannot be expressed in a non-recursive
    manner.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，到目前为止我们看到的前两类序列（等差和等比）是互斥的，但是递归序列不是，也就是说，序列既可以是递归的，也可以是等差的或等比的。按照惯例，我们用术语*递归*来表示这些类型的序列，与等比和等差不同，它们不能以非递归的方式表示。
- en: Now that we have explored the basic concepts of recursive sequences, we can
    implement this in Python and write code that calculates any number of elements
    of any sequence that is recursively defined.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了递归序列的基本概念，我们可以在Python中实现这一点，并编写计算递归定义的任何序列的任意数量的元素的代码。
- en: 'Exercise 5.03: Creating a Custom Recursive Sequence'
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.03：创建自定义递归序列
- en: 'In this exercise, we will create a custom recursive sequence using the concepts
    we explained in the previous section. Given the first three elements of the sequence,
    *P*n, that is, *P*1*=1*, *P*2*=7*, and *P*3*=2*, find the next seven terms of
    the sequence that is recursively defined via the relation: *P*n+3*= (3*P*n+1 *-
    P*n+2*)/(P*n *– 1)*. Follow these steps to complete this exercise:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用我们在前一节中解释的概念创建一个自定义的递归序列。给定序列的前三个元素，*P*n，也就是*P*1*=1*，*P*2*=7*，和*P*3*=2*，找出递归定义的序列的接下来七个项，关系为*P*n+3*=
    (3*P*n+1 *- P*n+2*)/(P*n *– 1)*。按照以下步骤完成这个练习：
- en: 'Define a Python function that is recursive and implements the relation given
    previously for the *n*th element of the sequence:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个Python函数，它是递归的，并实现了前面给出的序列的第*n*个元素的关系：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we started by defining the base cases, that is, the known result as given
    in the brief: if *n=1*, then *P=1*, if *n=2*, then *P=7*, and if *n=3*, then *P=2*.
    We also included the case where *n<1*. This is invalid input and, as is customary,
    our function returns the value `-1`. This makes our function *bounded* and protected
    from entering infinite loops and invalid input. Once these cases have been taken
    care of, then we have defined the recursive relation.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先定义了基本情况，也就是在简介中给出的已知结果：如果*n=1*，那么*P=1*，如果*n=2*，那么*P=7*，如果*n=3*，那么*P=2*。我们还包括了*n<1*的情况。这是无效的输入，惯例上，我们的函数返回值为`-1`。这使得我们的函数*有界*，并且受到保护，不会进入无限循环和无效输入。一旦处理了这些情况，我们就定义了递归关系。
- en: 'Now, let''s test our function and print out the first 10 values of the sequence
    (three that correspond to the base cases and seven of them that are for our task):'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们测试我们的函数，并打印出序列的前10个值（三个对应于基本情况，另外七个是我们要找的）：
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see from the preceding output, our function works and gives back
    both the known values (*P*1 *= 1*, *P*2 *= 7*, and *P*3 *= 2*) of the sequence
    and the next terms (*P_1* to *P_10*) that we were looking for.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看出，我们的函数有效，并返回了序列的已知值（*P*1 *= 1*，*P*2 *= 7*，和*P*3 *= 2*）以及我们正在寻找的下一个项（*P_1*到*P_10*）。
- en: 'As a bonus, let''s plot our findings by using the `matplotlib` module. We will
    create a list that holds the first nine values of the sequence and then plot it
    with `pyplot`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为奖励，让我们使用`matplotlib`模块绘制我们的发现。我们将创建一个包含序列前九个值的列表，然后用`pyplot`绘制它：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 5.7: Plot created using the matplotlib library'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7：使用matplotlib库创建的图表'
- en: '](image/B15968_05_07.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_07.jpg)'
- en: 'Figure 5.7: Plot created using the matplotlib library'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：使用matplotlib库创建的图表
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2D3vlPF.](https://packt.live/2D3vlPF
    )
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的源代码，请参阅[https://packt.live/2D3vlPF](https://packt.live/2D3vlPF)。
- en: You can also run this example online at [https://packt.live/3eY05Q4.](https://packt.live/3eY05Q4
    )
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3eY05Q4](https://packt.live/3eY05Q4)上在线运行此示例。
- en: We can see that a simple and well-defined recursive relation can lead to apparently
    random or chaotic results. Indeed, if you continue plotting the terms of the preceding
    sequence, you will soon notice that there is no apparent regularity in the pattern
    of the terms as they widely and asymmetrically oscillate around 0\. This prompts
    us to arrive at the conclusion that even though defining a recursive sequence
    and predicting its *n*th term is straightforward, the opposite is not always true.
    As we saw, given a sequence (a list of numbers), it is quite simple to check whether
    it forms an arithmetic sequence, a geometric sequence, or neither. However, to
    answer whether a given sequence has been derived by a recursive relation—let alone
    what this recursion is—is a non-trivial task that, in most cases, cannot be answered.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，一个简单而明确定义的递归关系可以导致明显随机或混沌的结果。实际上，如果您继续绘制前述序列的项，很快就会注意到在项的模式中没有明显的规律，它们在0周围广泛且不对称地振荡。这促使我们得出结论，即使定义了一个递归序列并预测了它的第n项是直接的，相反的情况并不总是成立。正如我们所看到的，鉴于一个序列（一系列数字），检查它是否形成等差数列、等比数列或两者都不是，是非常简单的。然而，要回答一个给定的序列是否由递归关系导出——更不用说这个递归是什么——是一个非平凡的任务，在大多数情况下都无法回答。
- en: 'In this section, we have presented what sequences are, why they are important,
    and how they are connected to another important concept in mathematics: series.
    We studied three general types of sequences, namely arithmetic, geometric, and
    recursive, and saw how they can be implemented in Python in a few simple steps.
    In the next section, we''ll delve into trigonometry and learn how trigonometric
    problems can be easily solved using Python.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了序列是什么，为什么它们很重要，以及它们与数学中另一个重要概念的联系：级数。我们研究了三种一般类型的序列，即等差、等比和递归，并看到它们如何可以在Python中通过几个简单的步骤实现。在下一节中，我们将深入研究三角学，并学习如何使用Python轻松解决三角学问题。
- en: Trigonometry
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三角学
- en: Trigonometry is about studying triangles and, in particular, the relation of
    their angles to their edges. The ratio of two of the three edges (sides) of a
    triangle gives information about a particular angle, and to such a pair of sides,
    we give it a certain name and call it a function. The beauty of trigonometry and
    mathematics in general is that these functions, which are born inside a triangle,
    make (abstract) sense in any other situation where triangles are not present and
    operate as independent mathematical objects. Hence, functions such as the tangent,
    cosine, and sine are found across most fields of mathematics, physics, and engineering
    without any reference to the triangle.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 三角学是研究三角形，特别是它们的角与边的关系。三角形的三条边（边）中的两条的比值提供了关于特定角的信息，并且对于这样一对边，我们给它一个特定的名称，并称之为函数。三角学和数学的美妙之处在于这些函数，它们诞生于三角形内部，在三角形不存在的任何其他情况下都有（抽象的）意义，并且作为独立的数学对象运行。因此，诸如正切、余弦和正弦之类的函数在大多数数学、物理和工程领域都可以找到，而无需参考三角形。
- en: Let's look at the most fundamental trigonometric functions and their usage.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看最基本的三角函数及其用法。
- en: Basic Trigonometric Functions
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本三角函数
- en: 'We will start by defining a right-angled triangle (or simply a right triangle),
    triangle ABC. One of its angles (the angle BCA in the following diagram) is a
    **right angle**, that is, a 90-degree angle. The side opposite the right angle
    is called the **hypotenuse** (side *h* in the following diagram), while the other
    sides (*a* and *b*) are known as legs. They are also referred to as *opposite*
    and *adjacent* to the respective angle. For instance, side *b* is adjacent to
    the lower right angle in the following diagram (angle CAB or *θ*), while it is
    opposite when we refer to the top angle (angle CBA):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从定义一个直角三角形（或简称直角三角形）开始，三角形ABC。它的一个角（下图中的角BCA）是一个**直角**，即90度角。直角的对边称为**斜边**（下图中的边*h*），而其他两边（*a*和*b*）称为腿。它们也被称为相对于各自角的*对边*和*邻边*。例如，边*b*是相邻于下图中的右下角的（角CAB或*θ*），而当我们提到顶角（角CBA）时，它是对边：
- en: '![Figure 5.8: A right-angled triangle'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8：直角三角形'
- en: '](image/B15968_05_08.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_08.jpg)'
- en: 'Figure 5.8: A right-angled triangle'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8：直角三角形
- en: 'The most common trigonometric functions are defined with the help of the preceding
    diagram and are defined as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的三角函数是通过前面的图表定义的，并且定义如下：
- en: '![Figure 5.9: Trigonometric functions'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.9：三角函数'
- en: '](image/B15968_05_09.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_09.jpg)'
- en: 'Figure 5.9: Trigonometric functions'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：三角函数
- en: For the tangent function, it also holds that *tanθ = sinθ/cosθ*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于正切函数，也成立 *tanθ = sinθ/cosθ*。
- en: 'Also, for any angle, θ, the following identity always holds true: *sinθ*2 *+
    cosθ*2 *= 1*.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于任何角度θ，以下恒等式始终成立：*sinθ*2 *+ cosθ*2 *= 1*。
- en: By construction, the trigonometric functions are periodic. This means that,
    regardless of the sizes of the edges of a triangle, the preceding functions take
    on values that repeat themselves every 2π. This will become apparent in the next
    exercise, where we will be plotting them. The range of the sine and cosine functions
    is the interval [-1,1]. This means that the smallest value they can obtain is
    -1, and the largest is 1, no matter what the input θ is.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 根据构造，三角函数是周期性的。这意味着，无论三角形的边的大小如何，前述函数都会在每2π重复一次。这将在下一个练习中变得明显，我们将在其中绘制它们。正弦和余弦函数的范围是区间[-1,1]。这意味着它们可以获得的最小值是-1，最大值是1，无论输入θ是什么。
- en: 'Last but not least, the edges of the right-angled triangle are connected via
    the famous Pythagorean theorem: *h*2 *= a*2 *+ b*2'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的，直角三角形的边是通过著名的毕达哥拉斯定理连接的：*h*2 *= a*2 *+ b*2
- en: 'In Python code, a simple implementation of the Pythagorean theorem would be
    to write a function that calculates *h*, given *a* and *b*, with the help of the
    square root (`sqrt`) method of the `math` module; for instance:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python代码中，毕达哥拉斯定理的一个简单实现是编写一个函数，利用`math`模块的平方根（`sqrt`）方法，计算*h*，给定*a*和*b*；例如：
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Calling this function for *a=3* and *b=4* gives us the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对*a=3*和*b=4*调用此函数会给我们以下结果：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, let's look at some concrete examples so that we can grasp these ideas.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一些具体的例子，以便我们能够掌握这些想法。
- en: 'Exercise 5.04: Plotting a Right-Angled Triangle'
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.04：绘制直角三角形
- en: 'In this exercise, we will write Python functions that will plot a right triangle
    for the given points, *p*1 and *p*2. The right-angled triangle will correspond
    to the endpoints of the legs of the triangle. We will also calculate the three
    trigonometric functions for either of the non-right angles. Let''s plot the basic
    trigonometry functions:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写Python函数，用于绘制给定点*p*1和*p*2*的直角三角形。直角三角形将对应于三角形腿的端点。我们还将计算非直角的三角函数。让我们绘制基本的三角函数：
- en: 'Import the `numpy` and `pyplot` libraries:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`numpy`和`pyplot`库：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, write a function that returns the hypotenuse by using the Pythagorean
    theorem when given the two sides, *p*1 and *p*2, as inputs:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编写一个函数，当给定两边*p*1和*p*2时，使用毕达哥拉斯定理返回斜边：
- en: '[PRE56]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let''s write another function that implements the relations for the `sin`,
    `cos`, and `tan` functions. The inputs are the lengths of the adjacent, opposite,
    and hypotenuse of a given angle, and the result is a tuple of the trigonometric
    values:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写另一个函数，实现`sin`、`cos`和`tan`函数的关系。输入是给定角的邻边、对边和斜边的长度，结果是三角函数值的元组：
- en: '[PRE57]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, write the function that plots the triangle. For simplicity, place the
    right angle at the origin of the axes at (0,0), the first input point along the
    *x* axis at (p1, 0), and the second input point along the *y* axis at (0, p2):'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写绘制三角形的函数。为简单起见，将直角放在坐标轴的原点（0,0），第一个输入点沿*x*轴放在（p1,0），第二个输入点沿*y*轴放在（0,p2）：
- en: '[PRE58]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, we created the lists, `x` and `y`, that hold the points and one more list,
    `n`, for the labels. Then, we created a `pyplot` object that plots the points
    first, and then the edges. The last two lines are used to annotate our plot; that
    is, add the labels (from the list, `n`) next to our points.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了包含点的列表`x`和`y`，还有一个标签列表`n`。然后，我们创建了一个`pyplot`对象，首先绘制点，然后绘制边。最后两行用于注释我们的绘图；即，在我们的点旁边添加标签（从列表`n`中）。
- en: 'We need to choose two points in order to define a triangle. Then, we need to
    call our functions to display the plot:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要选择两个点来定义一个三角形。然后，我们需要调用我们的函数来显示绘图：
- en: '[PRE59]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The first line prints the values of the three trigonometric functions, `sin`,
    `cos`, and `tan`, respectively. Then, we plot our triangle, which in this case
    is isosceles since it has two sides that are of equal length.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行打印三角函数`sin`、`cos`和`tan`的值。然后，我们绘制我们的三角形，在这种情况下是等腰三角形，因为它有两条相等长度的边。
- en: 'The output will be as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 5.10: Plotting the isosceles triangle'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.10：绘制等腰三角形'
- en: '](image/B15968_05_10.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_10.jpg)'
- en: 'Figure 5.10: Plotting the isosceles triangle'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10：绘制等腰三角形
- en: The results are expected and correct—upon rounding the error—since the geometry
    of this particular shape is simple (an isosceles orthogonal triangle that has
    two angles equal to π/4). Then, we checked the result (note that in NumPy, the
    value of pi can be directly called `np.pi`).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是预期的和正确的——在四舍五入误差后——因为这种特定形状的几何形状很简单（一个等腰直角三角形，两个角相等于π/4）。然后，我们检查了结果（请注意，在NumPy中，π的值可以直接调用`np.pi`）。
- en: 'Finally, to get a general overview of the `sin` and `cos` trigonometric functions,
    let''s plot them:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了对“sin”和“cos”三角函数有一个总体概述，让我们绘制它们：
- en: '[PRE60]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output will be as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 5.11: Plot of the sin and cos trigonometric functions'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.11：正弦和余弦三角函数的绘图'
- en: '](image/B15968_05_11.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_11.jpg)'
- en: 'Figure 5.11: Plot of the sin and cos trigonometric functions'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11：正弦和余弦三角函数的绘图
- en: In this exercise, we kick-started our explorations of the sphere of trigonometry
    and saw how to arrive at useful visualizations in Python.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们启动了对三角学领域的探索，并看到如何在Python中得到有用的可视化。
- en: Note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2Zz0TnU.](https://packt.live/2Zz0TnU
    )
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2Zz0TnU](https://packt.live/2Zz0TnU)
- en: You can also run this example online at [https://packt.live/2AoxS63.](https://packt.live/2AoxS63
    )
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2AoxS63](https://packt.live/2AoxS63)上在线运行此示例
- en: 'With that, we have established the main trigonometric functions and saw how
    these provide an operation between an angle and an associated trigonometric value,
    given by either the sin, cos, or tan function. Moreover, we saw that these three
    functions are periodic, that is, repeated every 2π, while the first two are bounded,
    that is, the values they can take never exceed the interval, [-1,1]. These values
    are directly found in Python or in a scientific pocket calculator. In many situations,
    however, the inverse process is desired: can I find the angle if I give the value
    of sin, cos, or tan to some function? Does such a function exist? We''ll answer
    these questions in the next section.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经建立了主要的三角函数，并看到它们如何在角度和相关的三角函数值之间提供操作，由sin、cos或tan函数给出。此外，我们看到这三个函数是周期性的，即每2π重复一次，而前两个是有界的，即它们可以取的值永远不会超出区间[-1,1]。这些值可以直接在Python或科学口袋计算器中找到。然而，在许多情况下，需要进行反向过程：如果我给出sin、cos或tan的值，我能找到角度吗？这样的函数存在吗？我们将在下一节中回答这些问题。
- en: Inverse Trigonometric Functions
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反三角函数
- en: 'Inverse trigonometric functions are the inverse functions of the trigonometric
    functions and are just as useful as their counterparts. An inverse function is
    a function that *reverses* the operation or result of the original function. Recall
    that trigonometric functions admit angles as input values and output pure numbers
    (ratios). Inverse trigonometric functions do the opposite: they admit a pure number
    as input and give an angle as output. So, if, for instance, a point, π, is mapped
    to point -1 (as the cos function does), then its inverse needs to do exactly the
    opposite. This mapping needs to hold for every point where the inverse function
    is defined.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 反三角函数是三角函数的反函数，与它们的对应函数一样有用。反函数是一个*反转*原始函数操作或结果的函数。请记住，三角函数接受角度作为输入值，并输出纯数（比值）。反三角函数则相反：它们接受纯数作为输入，并给出角度作为输出。因此，例如，如果一个点π被映射到点-1（如cos函数所做的那样），那么它的反函数需要完全相反。这种映射需要对反函数定义的每个点都成立。
- en: 'The inverse function of the *sin(x)* function is called *arcsin(x)*: if *y=sin(x)*,
    then *x=arcsin(y)*. Recall that *sin* is a periodic function, so many different
    *x*''s are mapped to the same *y*. So, the inverse function would map one point
    to several different ones. This cannot be allowed since it clashes with the very
    definition of a function. To avoid this drawback, we need to restrict our domain
    of *arcsin* (and similarly for *arccos*) to the interval [-1,1], while the images,
    *y=arcsin(x)* and *y=arccos(x)*, are restricted to the ranges [-π/2,π/2] and [0,
    π] respectively.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*sin(x)*函数的反函数称为*arcsin(x)*：如果*y=sin(x)*，那么*x=arcsin(y)*。请记住*sin*是一个周期函数，因此许多不同的*x*被映射到相同的*y*。因此，反函数会将一个点映射到几个不同的点。这是不允许的，因为它与函数的定义相冲突。为了避免这个缺点，我们需要限制我们的*arcsin*（以及类似地*arccos*）的定义域为区间[-1,1]，而映射*y=arcsin(x)*和*y=arccos(x)*则限制在范围[-π/2,π/2]和[0,
    π]。'
- en: 'We can define the three basic inverse trigonometric functions as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义三个基本的反三角函数如下：
- en: '*arcsin(x) = y such that arcsin(sin(x)) = x*'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*arcsin(x) = y，使得arcsin(sin(x)) = x*'
- en: '*arccos(x) = y such that arccos(cos(x)) = x*'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*arccos(x) = y，使得arccos(cos(x)) = x*'
- en: '*arctan(x) = y such that arctan(tan(x)) = x*'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*arctan(x) = y，使得arctan(tan(x)) = x*'
- en: In Python, these functions can be called either from the `math` module or from
    within the `numpy` library. Since most Python implementations of trigonometric
    inverse functions return radians, we may want to convert the outcome into degrees.
    We can do this by multiplying the radians by 180 and then dividing by π.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，这些函数可以从`math`模块或`numpy`库中调用。由于大多数Python实现的三角反函数返回弧度，我们可能希望将结果转换为度数。我们可以通过将弧度乘以180然后除以π来实现这一点。
- en: 'Let''s see how this can be written in code. Note that the input, `x`, is expressed
    as a pure number between -1 and 1, while the output is expressed in radians. Let''s
    import the required libraries and declare the value of `x`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这如何在代码中编写。请注意，输入`x`表示为-1和1之间的纯数，而输出表示为弧度。让我们导入所需的库并声明`x`的值：
- en: '[PRE61]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, to print the inverse of cosine, add the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要打印余弦的反函数，添加以下代码：
- en: '[PRE62]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output is as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE63]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To print the inverse of sine, add the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印正弦的反函数，添加以下代码：
- en: '[PRE64]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The output is as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE65]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To print the inverse of tan, add the following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印正切的反函数，添加以下代码：
- en: '[PRE66]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output is as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE67]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s try adding an input to the `acos` function that''s outside the range
    [-1,1]:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试为`acos`函数添加一个超出范围[-1,1]的输入：
- en: '[PRE68]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We will get an error, as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会得到一个错误，如下所示：
- en: '[PRE69]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Something similar will happen for `asin`. This is to be expected since no angle,
    *φ*, exists that can return `-1.2` as cos (or sin). However, this input is permitted
    in the `atan` function:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`asin`也会发生类似的情况。这是可以预料到的，因为不存在任何角度*φ*可以返回`-1.2`作为cos（或sin）。然而，这个输入在`atan`函数中是允许的：'
- en: '[PRE70]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The output is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE71]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Last, let''s check what the inverse of the inverse `arccos(cos(x))` function
    gives us:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看反函数`arccos(cos(x))`的反函数给我们带来了什么：
- en: '[PRE72]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE73]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As expected, we retrieve the value of the input of the `cos` function.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们检索到`cos`函数的输入值。
- en: 'The inverse trigonometric functions have a variety of applications across mathematics,
    physics, and engineering. For example, calculating integrals can be done by using
    inverse trigonometric functions. The indefinite integrals are as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 反三角函数在数学、物理和工程学中有各种应用。例如，可以使用反三角函数来计算积分。不定积分如下：
- en: '![Figure 5.12: Inverse trigonometric functions'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.12：反三角函数'
- en: '](image/B15968_05_12.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_12.jpg)'
- en: 'Figure 5.12: Inverse trigonometric functions'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12：反三角函数
- en: Here, *a* is a parameter and *C* is a constant, and the integrals become immediately
    solvable with the help of inverse trigonometric functions.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*a*是一个参数，*C*是一个常数，积分立即可以通过反三角函数得到解决。
- en: 'Exercise 5.05: Finding the Shortest Way to the Treasure Using Inverse Trigonometric
    Functions'
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.05：使用反三角函数找到通往宝藏的最短路径
- en: 'In this exercise, you will be given a secret map that points to **B**, where
    some precious treasure has been lying for centuries. You are at point **A** and
    the instructions are clear: you have to navigate 20 km south then 33 km west so
    that you arrive at the treasure. However, the straight-line segment, **AB**, is
    the shortest. You need to find the angle **θ** on the map so that your navigation
    is correctly oriented:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将获得一张指向**B**的秘密地图，几个世纪以来一些宝贵的宝藏一直在那里。您在点**A**，指令很明确：您必须向南导航20公里，然后向西导航33公里，以便到达宝藏。然而，直线段**AB**是最短的。您需要找到地图上的角度**θ**，以便您的导航正确定位：
- en: '![Figure 5.13: Graphical representation of the points A, B, and C'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.13：点A、B和C的图形表示'
- en: '](image/B15968_05_13.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_13.jpg)'
- en: 'Figure 5.13: Graphical representation of the points A, B, and C'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13：点A、B和C的图形表示
- en: 'We need to find the angle **θ**, which is the angle between the segments **AB**
    and **AC**. Follow these steps:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到角**θ**，即线段**AB**和**AC**之间的角度。按照以下步骤进行：
- en: 'Import the `atan` (arctan or inverse tangent) function:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`atan`（arctan或反正切）函数：
- en: '[PRE74]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Find the tangent of *θ* using `BC` and `AC`:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`BC`和`AC`找到*θ*的正切：
- en: '[PRE75]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The output is as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE76]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, find the angle by taking the inverse tangent function. Its argument is
    the tangent of *θ*:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过取反正切函数来找到角度。其参数是*θ*的正切：
- en: '[PRE77]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Convert that into degrees and print the value:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其转换为度并打印出值：
- en: '[PRE78]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The output is as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE79]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: So, the answer is that we need to turn 31.22 degrees in order to navigate correctly.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，答案是我们需要转动31.22度才能正确导航。
- en: 'As a bonus point, calculate the distance that we will travel along the path
    `AB`. This is simply given by the Pythagorean theorem as follows:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为奖励分，计算我们将沿着路径`AB`行进的距离。这只是由勾股定理给出的：
- en: '*AB*2 *= AC*2 *+ BC*2'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '*AB*2 *= AC*2 *+ BC*2'
- en: 'In Python, use the following code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，使用以下代码：
- en: '[PRE80]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The output is as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE81]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The course will be 38.59 km.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 课程将是38.59公里。
- en: It is straightforward to calculate this in Python by calling the `find_hypotenuse()`
    function. As expected, this is much shorter than the path *AC + BC = 53* km.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中通过调用`find_hypotenuse()`函数很容易计算。正如预期的那样，这比路径*AC + BC = 53*公里要短得多。
- en: Note
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/31CF4qr.](https://packt.live/31CF4qr
    )
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/31CF4qr。](https://packt.live/31CF4qr )
- en: You can also run this example online at [https://packt.live/38jfVlI.](https://packt.live/38jfVlI
    )
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/38jfVlI](https://packt.live/38jfVlI )上在线运行此示例。
- en: 'Exercise 5.06: Finding the Optimal Distance from an Object'
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.06：找到与对象的最佳距离
- en: 'You are visiting your local arena to watch your favorite show, and you are
    standing in the middle of the arena. Besides the main stage, there is also a viewing
    screen so that people can watch and not miss the details of the show. The bottom
    of the screen stands 3 m above your eye level, and the screen itself is 7 m high.
    The angle of vision is formed by looking at both the bottom and top of the screen.
    Find the optimal distance, *x*, between yourself and the screen so that the angle
    of vision is maximized:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在参观当地的竞技场观看您最喜欢的节目，您站在竞技场的中间。除了主舞台外，还有一个观看屏幕，这样人们就可以观看并不会错过节目的细节。屏幕底部距离您的眼睛高3米，屏幕本身高7米。视野角是通过观看屏幕的底部和顶部形成的。找到最佳距离*x*，使视野角最大化：
- en: '![Figure 5.14: Angle of vision formed between the eyes and the screen'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.14：眼睛和屏幕之间形成的视野角'
- en: '](image/B15968_05_14.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_14.jpg)'
- en: 'Figure 5.14: Angle of vision formed between the eyes and the screen'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14：眼睛和屏幕之间形成的视野角
- en: 'This is a slightly involved problem that requires a bit of algebra, but we
    will break it down into simple steps and explain the logic. First, note how much
    the plot of the problem guides us and helps us arrive at a solution. This apparently
    complex real-world problem translates into a much more abstract and simple geometric
    picture. Follow these steps to complete this exercise:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个稍微复杂的问题，需要一些代数，但我们将把它分解成简单的步骤并解释逻辑。首先注意问题的情节如何引导我们并帮助我们找到解决方案。这个明显复杂的现实世界问题转化为一个更抽象和简单的几何图像。按照以下步骤完成此练习：
- en: 'Calculate *x*. This is the lower side of the triangle and also the adjacent
    side to the angle, *θ*1 (and also *θ=θ*1*+θ*2). The answer, *x*, will be given
    by the condition that the viewing angle, *θ*2 or equivalently, *tan(θ*2*)*), is
    maximized. From the preceding plot of the *screen*, we can immediately draw the
    following relations for the three angles: *θ*1 (the inner angle), *θ*2 (the outer
    angle), and *θ=θ*1*+θ*2:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算*x*。这是三角形的底边，也是角*θ*1（也是*θ=θ*1*+θ*2）的邻边。答案*x*将由观看角*θ*2或等效地，*tan(θ*2*)*最大化的条件给出。从*屏幕*的前述图中，我们可以立即得出三个角度的以下关系：*θ*1（内角）、*θ*2（外角）和*θ=θ*1*+θ*2：
- en: '*tan(θ*1*) = opposite/adjacent = 3/x*'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*tan(θ*1*) = 对边/邻边 = 3/x*'
- en: '*tan(θ) = tan(θ*1*+θ*2*) = opposite/adjacent = (7+3)/x .*'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '*tan(θ) = tan(θ*1*+θ*2*) = 对边/邻边 = (7+3)/x .*'
- en: Now, use algebra to work around these two relations and obtain a condition for
    *θ*2.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用代数来处理这两个关系，并得到*θ*2的条件。
- en: 'A known identity for the tangent of a sum of two angles is as follows:![Figure
    5.15: Formula for tangent of a sum of two angles'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个角的正切和的已知身份如下：![图5.15：两个角的正切的公式
- en: '](image/B15968_05_15.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_15.jpg)'
- en: 'Figure 5.15: Formula for tangent of a sum of two angles'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15：两个角的正切的公式
- en: 'By substituting what we have found for *tan(θ)* and *tan(θ*1*)* in the latter
    relation and after working out the algebra, we arrive at the following:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在后一个关系中代入我们找到的*tan(θ)*和*tan(θ*1*)*，并经过代数运算，我们得到以下结果：
- en: '*tan(θ*2*) = 7x/(30+x*2*) or*'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '*tan(θ*2*) = 7x/(30+x*2*) 或*'
- en: '*θ*2 *= arctan(7x/(30+x*2*)).*'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '*θ*2 *= arctan(7x/(30+x*2*)).*'
- en: In other words, we have combined the elements of the problem and found that
    the angle, *θ*1, ought to change with the distance, *x*, as a function of *x*,
    which was given in the preceding line.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们已经结合了问题的要素，并发现角度*θ*1应该随着距离*x*的变化而变化，这是前一行给出的函数*x*的函数。
- en: 'Let''s plot this function to see how it changes. First, load the necessary
    libraries:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们绘制这个函数，看看它是如何变化的。首先，加载必要的库：
- en: '[PRE82]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Then, plot the function by defining the domain, `x`, and the values, `y`, by
    using the `arctan` method of `numpy`. These are easily plotted with the `plot()`
    method of `pyplot`, as follows:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过使用`numpy`的`arctan`方法，通过定义域`x`和值`y`来绘制函数。这些可以使用`pyplot`的`plot()`方法轻松绘制，如下所示：
- en: '[PRE83]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The output will be as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 5.16: Plot of the function using the arctan method'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.16：使用arctan方法绘制函数的图形'
- en: '](image/B15968_05_16.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_16.jpg)'
- en: 'Figure 5.16: Plot of the function using the arctan method'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.16：使用arctan方法绘制函数的图形
- en: From the preceding graph, we can see that the functions obtain a maximum.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中，我们可以看到函数获得了最大值。
- en: 'Determine the function''s maximum value, `y`, and the position, `x`, where
    this occurs:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定函数的最大值`y`和位置`x`，以及发生这种情况的位置：
- en: '[PRE84]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output is as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE85]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Lastly, convert the found angle into degrees:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将找到的角度转换为度数：
- en: '[PRE86]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The output is as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE87]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: So, the viewing angle, *θ*2, is at its maximum at 32.58 degrees and occurs when
    we stand 5.47 m away from the screen. We used the trigonometric and inverse trigonometric
    functions, implemented them in Python, and found the answer to a problem that
    arises from a *geometric* setup in a real-life situation. This sheds more light
    on how concepts from geometry and trigonometry can be usefully and easily coded
    to provide the expected results.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，观察角度*θ*2在32.58度时达到最大值，并且当我们站在距屏幕5.47米的地方时发生。我们使用三角函数和反三角函数，在Python中实现它们，并找到了一个来自现实生活中*几何*设置的问题的答案。这更加清楚地说明了几何和三角学概念如何被有用地和轻松地编码以提供预期的结果。
- en: Note
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2VB3Oez.](https://packt.live/2VB3Oez
    )
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2VB3Oez](https://packt.live/2VB3Oez)
- en: You can also run this example online at [https://packt.live/2VG9x2T.](https://packt.live/2VG9x2T
    )
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2VG9x2T](https://packt.live/2VG9x2T)上在线运行此示例。
- en: 'Now, we will move on and study another central concept in mathematics with
    a wide range of applications in algebra, physics, computer science, and applied
    data science: vectors.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续研究数学中的另一个核心概念，它在代数、物理学、计算机科学和应用数据科学中有着广泛的应用：向量。
- en: Vectors
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量
- en: '**Vectors** are abstract mathematical objects with a magnitude (size) and direction
    (orientation). A vector is represented by an arrow that has a base (tail) and
    a head. The head shows the direction of the vector, while the length of the arrow''s
    body shows its magnitude.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**向量**是具有大小（大小）和方向（方向）的抽象数学对象。向量由一个箭头表示，它有一个基（尾部）和一个头。箭头的头部显示向量的方向，而箭头的长度显示它的大小。'
- en: A **scalar**, in contrast to a vector, is a sole number. It's a non-vector,
    that is, a pure integer, real or complex (as we shall see later), that has no
    elements and hence no direction.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**标量**与向量相反，是一个单独的数字。它是一个非向量，即一个纯整数、实数或复数（我们稍后会看到），它没有元素，因此没有方向。'
- en: Vectors are symbolized by either a bold-faced letter **A**, a letter with an
    arrow on top, or simply by a regular letter, if there is no ambiguity regarding
    the notation in the discussion. The magnitude of the vector, **A**, is stylized
    as *|A|* or simply *A*. Now, let's have a look at the various vector operations.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 向量通常用粗体字母**A**、带箭头的字母或普通字母表示，如果在讨论中关于符号的表示没有歧义。向量**A**的大小被写成*|A|*或简单地写成*A*。现在，让我们来看看各种向量运算。
- en: Vector Operations
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向量运算
- en: Simply put, a vector is a collection (think of a list or array) of two, three,
    or more numbers that form a mathematical object. This object lives in a particular
    geometrical space called a vector space that has some properties, such as metric
    properties, and dimensionality. A vector space can be two-dimensional (think of
    the plane of a sheet of your book), three-dimensional (the ordinary Euclidean
    space around us), or higher, in many abstract situations in mathematics and physics.
    The elements or numbers that are needed to identify a vector equals the dimensionality
    of the space. Now that we have defined a vector space—the playground for vectors—we
    can equip it with a system of axes (the usual *x*, *y*, and *z* axes) that mark
    the origin and measure the space. In such a well-defined space, we need to determine
    a set of numbers (two, three, or more) in order to uniquely define a vector, since
    vectors are assumed to begin at the origin of axes. The elements of a vector can
    be integers, rational, real, or (rarely) complex numbers. In Python, they are,
    most commonly, represented by lists or NumPy arrays.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，向量是由两个、三个或更多个数字组成的集合（可以想象成列表或数组），形成一个数学对象。这个对象存在于一个特定的几何空间中，称为向量空间，具有一些属性，如度量属性和维度。向量空间可以是二维的（想象一下你的书页上的平面），三维的（我们周围的普通欧几里德空间），或者在数学和物理学中的许多抽象情况下更高维度的。用于识别向量的元素或数字等于空间的维度。现在我们已经定义了一个向量空间——向量的游乐场——我们可以用一组坐标轴（通常的*x*、*y*和*z*轴）来装备它，标记原点并测量空间。在这样一个明确定义的空间中，我们需要确定一组数字（两个、三个或更多）来唯一定义一个向量，因为向量被假定从坐标轴的原点开始。向量的元素可以是整数、有理数、实数或（很少）复数。在Python中，它们通常由列表或NumPy数组表示。
- en: 'Similar to real numbers, a set of linear operations is defined on vectors.
    Between two vectors, A = (a1, a2, a3) and B = (b1, b2, b3), we can define the
    following:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 与实数类似，向量上定义了一组线性运算。在两个向量A = (a1, a2, a3)和B = (b1, b2, b3)之间，我们可以定义以下内容：
- en: '![Figure 5.17: Points A, B, and C and their relations while performing vector
    operations'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.17：点A、B和C及它们在执行向量运算时的关系'
- en: '](image/B15968_05_17.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_17.jpg)'
- en: 'Figure 5.17: Points A, B, and C and their relations while performing vector
    operations'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.17：执行向量操作时点A、B和C及其关系
- en: 'Now let us see the various operations that can be performed on these vectors:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看可以对这些向量执行的各种操作：
- en: '**Addition** as the operation that results in vector *C = A + B = (a*1 *+ b*1*,
    a*2 *+ b*2*, a*3 *+ b*3*)*.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加法**作为导致向量*C = A + B = (a*1 *+ b*1*, a*2 *+ b*2*, a*3 *+ b*3*)*的操作。'
- en: '**Subtraction** as the operation that results in vector *C = A - B = (a*1 *-
    b*1*, a*2 *- b*2*, a*3 *- b*3*)*.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减法**作为导致向量*C = A - B = (a*1 *- b*1*, a*2 *- b*2*, a*3 *- b*3*)*的操作。'
- en: '**Dot** (or inner or scalar) *product* of the *scalar* *C = b. b = a*1 *b*1
    *+ a*2 *b*2 *+ a*3 *b*3.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*点积*（或内积或标量）*C = b. b = a*1 *b*1 *+ a*2 *b*2 *+ a*3 *b*3。'
- en: '**Cross** (or exterior) *product* of the vector *C = A x B*, which is perpendicular
    to the plane define by *A* and *B* and has elements (*a*2*b*3 *- a*3*b*2*, a*3*b*1
    *- a*1*b*3*, a*1*b*2 *– a*2*b*1).'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量*C = A x B*的**叉积**（或外积），它垂直于由*A*和*B*定义的平面，并具有元素（*a*2*b*3 *- a*3*b*2*, a*3*b*1
    *- a*1*b*3*, a*1*b*2 *– a*2*b*1）。
- en: '**Element-wise** or Hadamard *product* of two vectors, *A* and *B*, is the
    vector, *C*, whose elements are the pairwise product of elements of *A* and *B*;
    that is, *C = (a*1 *b*1*, a*2 *b*2*, a*3 *b*3).'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量*A*和*B*的**逐元素**或Hadamard *乘积*是向量*C*，其元素是*A*和*B*的元素的成对乘积；即*C = (a*1 *b*1*,
    a*2 *b*2*, a*3 *b*3)*。
- en: 'We can define and use the preceding formulas in Python code as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Python代码中定义并使用前述公式如下：
- en: '[PRE88]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Then, to find the sum of `A` and `B`, enter the following code:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要找到`A`和`B`的和，输入以下代码：
- en: '[PRE89]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The output is as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE90]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'To calculate the difference, enter the following code:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算差异，输入以下代码：
- en: '[PRE91]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output is as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE92]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'To find the element-wise product, enter the following code:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到逐元素乘积，输入以下代码：
- en: '[PRE93]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The output is as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE94]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'To find the dot product, use the following code:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到点积，使用以下代码：
- en: '[PRE95]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The output is as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE96]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Finally, the cross product can be calculated as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，叉积可以计算如下：
- en: '[PRE97]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The output is as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE98]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note that vector addition, subtraction, and the dot product are associative
    and commutative operations, whereas the cross product is associative but not commutative.
    In other words, a x b does not equal b x a, but rather b x a, which is why it
    is called **anticommutative**.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，向量加法、减法和点积是可结合和可交换的操作，而叉积是可结合但不可交换的。换句话说，a x b不等于b x a，而是b x a，这就是为什么它被称为**反交换**。
- en: 'Also, a vector, *A*, can be multiplied by a scalar, *λ*. In that case, you
    simply have to multiply each vector element by the same number, that is, the scalar:
    *λ A = λ (a*1*, a*2*, a*3*) = (λ a*1*, λ a*2*, λ a*3)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，向量*A*可以乘以标量*λ*。在这种情况下，您只需将每个向量元素乘以相同的数字，即标量：*λ A = λ (a*1*, a*2*, a*3*) =
    (λ a*1*, λ a*2*, λ a*3)
- en: Another important operation between vectors is the dot product, since it is
    arguably the most common operation to appear in mathematics, computer science,
    and its applications. The dot product is a funny type of operation that has no
    analog in the realm of real numbers. Indeed, it needs two vectors as input to
    produce a single scalar as output. This means that the result of the operation
    (scalar) is of a different type than its ingredients (vectors), and thus an inverse
    operation (a *dot division*) cannot generally exist.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 向量之间的另一个重要操作是点积，因为它可以说是数学、计算机科学及其应用中最常见的操作。点积是一种有趣的操作，它在实数领域中没有类似物。实际上，它需要两个向量作为输入，以产生单个标量作为输出。这意味着操作的结果（标量）与其成分（向量）的类型不同，因此通常不存在逆操作（*点除法*）。
- en: 'By definition, it is given as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，它如下所示：
- en: '![Figure 5.18: Graphical representation of the θ angle'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.18：θ角的图形表示*'
- en: '](image/B15968_05_18.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_18.jpg)'
- en: 'Figure 5.18: Graphical representation of the θ angle'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.18：θ角的图形表示
- en: 'This can be represented by the following equation:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用以下方程表示：
- en: '*A.B = |A| |B| cos(θ)*'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '*A.B = |A| |B| cos(θ)*'
- en: Here, *θ* is the angle between *A* and *B*.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*θ*是向量*A*和*B*之间的角度。
- en: 'Let''s have a look at some typical cases:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些典型的情况：
- en: 'If *A* and *B* are orthogonal, then the dot product vanishes:'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*A*和*B*是正交的，则点积消失：
- en: '*A.B = 0* if and only if *θ = angle(A,B) = π/2*, since *|A|* and *|B|* are
    not zero.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果且仅当*θ = angle(A,B) = π/2*时，*A.B = 0*，因为*|A|*和*|B|*不为零。
- en: If *A* and *B* are co-linear and co-directional, then *θ = 0*, *cos(θ)=1* and
    *A.B = |A| |B|*. If they are co-linear and have opposite directions, then *θ =
    π*, *cos(θ)=-1*, and *A.B = -|A| |B|*.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*A*和*B*共线且共方向，则*θ = 0*，*cos(θ)=1*和*A.B = |A| |B|*。如果它们共线且方向相反，则*θ = π*，*cos(θ)=-1*，*A.B
    = -|A| |B|*。
- en: 'It follows on from the definition for the dot product of a vector with itself:
    *A.A = |A| |A| or |A| = √(A.A)*'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遵循对向量与自身的点积的定义：*A.A = |A| |A|或|A| = √(A.A)*
- en: 'It follows directly from *A.B = |A| |B| cos(θ)*, where the angle between the
    two vectors is given as follows: *θ = arccos(A.B / |A| |B|)*'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它直接遵循*A.B = |A| |B| cos(θ)*，其中两个向量之间的角度如下给出：*θ = arccos(A.B / |A| |B|)*
- en: Here, *arccos* is the inverse *cos* function that we saw in the previous section.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*arccos*是我们在前一节中看到的反余弦函数。
- en: 'For example, we can write a Python program that calculates the angle between
    any two given vectors with the help of `numpy` and the preceding relation that
    gives us the angle, *θ*:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以编写一个Python程序，利用`numpy`和前面给出的关系计算任意两个给定向量之间的角度*θ*：
- en: '[PRE99]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'To find the norm (magnitude) of each vector, we can use the following code:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到每个向量的范数（大小），我们可以使用以下代码：
- en: '[PRE100]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'As an alternative, you can also use the following code:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，您还可以使用以下代码：
- en: '[PRE101]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Print their values:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 打印它们的值：
- en: '[PRE102]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'You will get the following output:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下输出：
- en: '[PRE103]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Both alternatives lead to the same result, which you can immediately check by
    printing `Amagn` and `Bmagn` once more.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种替代方案都会导致相同的结果，您可以通过再次打印`Amagn`和`Bmagn`来立即检查。
- en: 'Finally, we can find the angle, *θ*, as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以按如下方式找到角度*θ*：
- en: '[PRE104]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The output is as follows:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE105]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Now, let's have a look at exercise where will perform the various vector operations
    that we just learned about.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个练习，我们将执行刚学到的各种向量运算。
- en: 'Exercise 5.07: Visualizing Vectors'
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.07：可视化向量
- en: In this exercise, we will write a function that plots two vectors in a 2D space.
    We'll have to find their sum and the angle between them.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个在二维空间中绘制两个向量的函数。我们将不得不找到它们的和以及它们之间的角度。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成这个练习：
- en: 'Import the necessary libraries, that is, `numpy` and `matplotlib`:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库，即`numpy`和`matplotlib`：
- en: '[PRE106]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Create a function that admits two vectors as inputs, each as a list, plots
    them, and, optionally, plots their sum vector:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，接受两个向量作为输入，每个向量作为一个列表，绘制它们，并可选择绘制它们的和向量：
- en: '[PRE107]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The `vec1` and `vec2` lists hold two real numbers each. Each pair denotes the
    endpoint (head) coordinates of the corresponding vector, while the origin is set
    at (0,0). The labels are set to `"A"`, `"B"`, and `"A+B"`, but you could change
    them or even set them as variables of the `plot_vectors` function with (or without)
    default values. The Boolean variable, `isSum`, is, by default, set to `False`
    and the sum, `vec1+vec2`, will not be plotted unless it's explicitly set to `True`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`vec1`和`vec2`列表中分别包含两个实数。每对数字表示相应向量的端点（头部）坐标，而原点设置为（0,0）。标签设置为`"A"`、`"B"`和`"A+B"`，但您可以更改它们，甚至将它们设置为`plot_vectors`函数的变量（或不带）默认值。布尔变量`isSum`默认设置为`False`，和`vec1+vec2`将不会被绘制，除非显式设置为`True`。'
- en: 'Next, we put the coordinates on a `matplotlib.pyplot` object:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将坐标放在一个`matplotlib.pyplot`对象上：
- en: '[PRE108]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Here, we used the annotate method to add labels to our vectors, as well as the
    arrow method, in order to create our vectors. The star operator, `*`, is used
    to unpack the arguments within the list's `orig` and `vec1`, `vec2` so that they
    are read correctly from the `arrow()` method. `plt.grid()` creates a grid on the
    plot's background to guide the eye and is optional. The `e` parameter is added
    so that the plot limits are wide enough and the plot is readable.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用annotate方法向我们的向量添加标签，以及arrow方法来创建我们的向量。星号运算符`*`用于解包列表`orig`和`vec1`、`vec2`中的参数，以便它们可以从`arrow()`方法中正确读取。`plt.grid()`在绘图的背景上创建一个网格，以引导眼睛，这是可选的。添加`e`参数是为了使绘图限制足够宽，绘图可读。
- en: 'Next, we give our graph a title and plot it:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，给我们的图表加上标题并绘制它：
- en: '[PRE109]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now, we will write a function that calculates the angle between the two input
    vectors, as explained previously, with the help of the dot (inner) product:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个函数，计算两个输入向量之间的角度，如前所述，借助点（内）积：
- en: '[PRE110]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: First, we map our input lists to `numpy` arrays so that we can use the methods
    of this module. We calculate the dot product (named `product12`) and then divide
    that by the product of the magnitude of `vec1` with the magnitude of `vec2`. Recall
    that the magnitude of a vector is given by the square root (or `**0.5`) of the
    dot product with itself. As given by the definition of the dot product, we know
    that this quantity is the cos of the angle theta between the two vectors. Lastly,
    after rounding cos to avoid input errors in the next line, calculate theta by
    making use of the `arccos` method of `numpy`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将我们的输入列表映射到`numpy`数组，以便我们可以使用这个模块的方法。我们计算点积（命名为`product12`），然后将其除以`vec1`的大小与`vec2`的大小的乘积。回想一下，向量的大小由其与自身的点积的平方根（或`**0.5`）给出。根据点积的定义，我们知道这个数量是两个向量之间角度的余弦。最后，在四舍五入余弦以避免输入错误后，利用`numpy`的`arccos`方法计算角度。
- en: 'We want to combine the two functions that we wrote—`find_angle` and `plot_vectors`—and
    call the former inside the latter. We also want to give the user the option to
    print the result for the angle either in radians (`isRadians=True`) or degrees
    (`isRadians=False`). We are now ready to try our function. First, let''s try this
    with two perpendicular vectors:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望将我们编写的两个函数`find_angle`和`plot_vectors`结合起来，并在后者内部调用前者。我们还希望给用户选择以弧度（`isRadians=True`）或度数（`isRadians=False`）打印角度结果的选项。现在我们准备尝试我们的函数。首先，让我们尝试使用两个垂直向量：
- en: '[PRE111]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The output is as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 5.19: Plot of two perpendicular vectors'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.19：两个垂直向量的绘图'
- en: '](image/B15968_05_19.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_19.jpg)'
- en: 'Figure 5.19: Plot of two perpendicular vectors'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.19：两个垂直向量的绘图
- en: The plot looks good and the result is 90 degrees, as expected.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图看起来不错，结果是90度，如预期。
- en: 'Now, let''s try using the same function to create two co-linear vectors:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用相同的函数创建两个共线向量：
- en: '[PRE112]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The output is as follows:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 5.20: Plot of two co-linear vectors'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.20：两个共线向量的绘图'
- en: '](image/B15968_05_20.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_20.jpg)'
- en: 'Figure 5.20: Plot of two co-linear vectors'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.20：两个共线向量的绘图
- en: The output is 0 degrees, as expected.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 输出为0度，如预期。
- en: 'Lastly, again, using the same function, let''s create two generic vectors:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，再次使用相同的函数，让我们创建两个通用向量：
- en: '[PRE113]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The output is as follows:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 5.21: Plot of two generic vectors'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.21：两个通用向量的绘图'
- en: '](image/B15968_05_21.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_21.jpg)'
- en: 'Figure 5.21: Plot of two generic vectors'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.21：两个通用向量的绘图
- en: In summary, we have studied vectors as mathematical objects that live in a vector
    space. We have learned how to construct and represent vectors in Python and how
    to visualize them. Vectors follow some simple rules, and performing operations
    with them is possible. Addition and subtraction follow exactly the same logic
    when dealing with real numbers. Multiplication is somewhat more involved and different
    types of products are defined. The most common product is the inner or dot product,
    which enjoys wide *popularity* in the mathematical and physics communities due
    to its simple geometric representation. We learned how to calculate the dot product
    of any two vectors in Python and, moreover, found the angle between the duet by
    using our knowledge (and some NumPy methods) of the dot product. In simple terms,
    a vector, in two dimensions, is a pair of numbers that form a geometric object
    with interesting properties.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们已经学习了向量作为生活在向量空间中的数学对象。我们学会了如何在Python中构造和表示向量以及如何可视化它们。向量遵循一些简单的规则，并且可以进行操作。在处理实数时，加法和减法遵循完全相同的逻辑。乘法有些更复杂，并且定义了不同类型的乘积。最常见的乘积是内积或点积，由于其简单的几何表示，在数学和物理界广受欢迎。我们学会了如何在Python中计算任意两个向量的点积，并且利用我们对点积的知识（以及一些NumPy方法）找到了这对向量之间的角度。简而言之，在二维空间中，向量是一对形成有趣属性的数字。
- en: Note
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2Zxu7n5.](https://packt.live/2Zxu7n5
    )
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2Zxu7n5.](https://packt.live/2Zxu7n5 )
- en: You can also run this example online at [https://packt.live/2YPntJQ.](https://packt.live/2YPntJQ
    )
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2YPntJQ.](https://packt.live/2YPntJQ )上在线运行此示例
- en: Next, we will learn how a pair of two numbers can be combined into an even more
    exciting object, that of a complex number.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何将一对两个数字组合成一个更令人兴奋的对象，即复数。
- en: Complex Numbers
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复数
- en: Mathematical ideas have been evolving regarding numbers and their relationships
    since ancient numerical systems. Historically, mathematical ideas have evolved
    from concrete to abstract ones. For instance, a set of natural numbers was created
    so that all physical objects in the world around us directly correspond to some
    number within this set. Since arithmetic and algebra have developed, it has become
    clear that numbers beyond the naturals or integers are necessary, so decimal and
    rational numbers were introduced. Similarly, around the times of Pythagoras, it
    was found that rational numbers cannot solve all numerical problems that we could
    construct with the geometry that was known at that time. This happened when irrational
    numbers—numbers that result from taking the square root of other numbers and that
    have no representation as ratios—were introduced.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 自古代数字系统以来，数学思想一直在发展，关于数字及其关系的数学思想也在历史上从具体到抽象不断演变。例如，自然数集合的概念是为了让我们周围世界中的所有物体直接对应于该集合中的某个数字。随着算术和代数的发展，人们意识到除了自然数或整数之外，还需要小数和有理数，因此引入了小数和有理数。同样，在毕达哥拉斯时代，人们发现有理数无法解决我们当时所知的几何构造的所有数学问题。这是因为引入了无理数——从其他数字的平方根得出并且没有比率表示的数字。
- en: Complex numbers are an extension of real numbers and include some special numbers
    that can provide a solution to some equations that real numbers cannot.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 复数是实数的扩展，并包括一些特殊的数字，可以解决一些实数无法解决的方程。
- en: Such a number does, in fact, exist and has the symbol *i*. It is called an imaginary
    number or imaginary unit, even though there is nothing imaginary about it; it
    is as real as all the other numbers that we have seen and has, as we shall see,
    some very beautiful properties.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的数字实际上是存在的，并且有符号*i*。它被称为虚数或虚数单位，尽管它并不虚构；它和我们见过的所有其他数字一样真实，并且正如我们将看到的那样，具有一些非常美丽的性质。
- en: Basic Definitions of Complex Numbers
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复数的基本定义
- en: 'We define the imaginary number *i* as follows:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将虚数*i*定义如下：
- en: '*i*2 *= -1*'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '*i*2 *= -1*'
- en: 'Any number that consists of a real and an imaginary number (part) is called
    a **complex number**. For example, consider the following numbers:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 任何由实数和虚数（部分）组成的数字都称为**复数**。例如，考虑以下数字：
- en: '*z = 3 – i*'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '*z = 3 – i*'
- en: '*z = 14/11 + i 3*'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '*z = 14/11 + i 3*'
- en: '*z = -√5 – i 2.1*'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '*z = -√5 – i 2.1*'
- en: 'All the preceding numbers are all complex numbers. Their real part is symbolized
    as *Re(z)* and their imaginary part is symbolized as *Im(z)*. For the preceding
    examples, we get the following:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述的数字都是复数。它们的实部表示为*Re(z)*，虚部表示为*Im(z)*。对于前述的例子，我们得到以下结果：
- en: '*Re(z) = 3 , Im(z) = -1*'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '*Re(z) = 3 , Im(z) = -1*'
- en: '*Re(z) = 14/11 , Im(z) = 3*'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '*Re(z) = 14/11 , Im(z) = 3*'
- en: '*Re(z) = -√5 , Im(z) = -2.1*'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '*Re(z) = -√5 , Im(z) = -2.1*'
- en: 'Let''s look at some examples using code. In Python, the imaginary unit is symbolized
    with the letter *j* and a complex number is written as follows:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些使用代码的例子。在Python中，虚数单位用字母*j*表示，复数写成如下形式：
- en: '[PRE114]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Here, `<real>` and `<imag>` are real numbers. Equivalently, a complex number
    can be defined as follows:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<real>`和`<imag>`都是实数。同样，复数可以定义如下：
- en: '[PRE115]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'In code, it becomes as follows:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，它变成了如下形式：
- en: '[PRE116]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The output is as follows:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE117]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'We can also use the `real` and `imag` functions to separate the real and imaginary
    parts of any complex number, `z`. First, let''s use the `real` function:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`real`和`imag`函数来分离任何复数`z`的实部和虚部。首先，让我们使用`real`函数：
- en: '[PRE118]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The output is as follows:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE119]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Now, use the `imag` function:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`imag`函数：
- en: '[PRE120]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The output is as follows:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE121]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: In other words, any complex number can be decomposed and written as *z=Re(z)
    + i Im(z)*. As such, a complex number is a pair of two real numbers and can be
    visualized as a vector that lives in two dimensions. Hence, the geometry and algebra
    of vectors, as discussed in the previous section, can be applied here as well.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，任何复数都可以被分解并写成*z=Re(z) + i Im(z)*。因此，一个复数是两个实数的一对，并且可以被视为生活在二维空间中的向量。因此，向量的几何和代数，如前一节所讨论的，也可以在这里应用。
- en: Methods and functions that admit complex numbers as inputs are found in the
    `cmath` module. This module contains mathematical functions for complex numbers.
    The functions there accept integers, floating-point numbers, or complex numbers
    as input arguments.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 接受复数作为输入的方法和函数可以在`cmath`模块中找到。该模块包含复数的数学函数。那里的函数接受整数、浮点数或复数作为输入参数。
- en: 'A *complex conjugate* is defined as the complex number, *z** (also *z̄*), that
    has the same real part as the complex number, *z*, and the opposite imaginary
    part; that is, if *z = x+iy*, then *z* = x -iy*. Note that the product, *zz**,
    is the real number, *x*2*+y*2, which gives us the square of the *modulus* of *z*:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '*复共轭*被定义为与复数*z*具有相同实部和相反虚部的复数*z**（也*z̄*）；也就是说，如果*z = x+iy*，那么*z* = x -iy*。注意，乘积*zz**是实数*x*2*+y*2，这给出了*z*的模的平方：'
- en: '*zz* = z*z = |z|*2'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '*zz* = z*z = |z|*2'
- en: 'A complex number is plotted, similar to a vector, on the complex plane (as
    shown in the following diagram). This is the plane that''s formed by the real
    part on the *x* axis and the imaginary part on the *y* axis. The complex conjugate
    is simply a reflection of the vector with respect to the real axis:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 复数被绘制在复平面上，类似于向量（如下图所示）。这是由实部在*x*轴上和虚部在*y*轴上形成的平面。复共轭只是相对于实轴的向量的反射：
- en: '![Figure 5.22: A plot of a complex number'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.22：复数的绘图'
- en: '](image/B15968_05_22.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_22.jpg)'
- en: 'Figure 5.22: A plot of a complex number'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.22：复数的绘图
- en: A complex number, *z*, can be visualized as a vector with coordinates (x, y).
    Alternatively, we can write it as a vector with polar coordinates (r, φ). The
    complex conjugate, *z** or *z̄*, is a vector the same as *z* but reflected with
    respect to the *x* axis.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 复数*z*可以被视为具有坐标(x, y)的向量。或者，我们可以将其写成具有极坐标(r, φ)的向量。复共轭*z**或*z̄*是一个与*z*相同的向量，但相对于*x*轴反射。
- en: 'A complex number is zero if both its real and complex parts are zero. The following
    operations can be performed on two complex numbers, *z = x+iy* and *w = u+iv*:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个复数的实部和虚部都是零，那么这个复数就是零。可以对两个复数*z = x+iy*和*w = u+iv*执行以下操作：
- en: '**Addition**: *z+w = (x+u) + i(y+v)*'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加法**：*z+w = (x+u) + i(y+v)*'
- en: '**Subtraction**: *z-w = (x-u) + i(y-v)*'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减法**：*z-w = (x-u) + i(y-v)*'
- en: '**Multiplication**: *z w = (x+iy)(u+iv) = (xu-yv) + i(xv + yu)*'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乘法**：*z w = (x+iy)(u+iv) = (xu-yv) + i(xv + yu)*'
- en: '**Division**: *z/w = (x+iy)/(u+iv) = (ux+vy)+i(uy-xv) / (u2+v2)*'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**除法**：*z/w = (x+iy)/(u+iv) = (ux+vy)+i(uy-xv) / (u2+v2)*'
- en: Polar Representation and Euler's Formula
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 极坐标表示和欧拉公式
- en: 'A complex number is easily visualized as a vector on the complex plane. As
    such, it has a magnitude, which is determined by the vector''s size, and an orientation,
    which is determined by the angle, *φ*, that is formed with the *x* (real) axis.
    To determine these two numbers, we need to find the absolute value (or modulus),
    *r*, of *z=x+iy*:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 复数很容易被视为复平面上的向量。因此，它有一个大小，由向量的大小确定，以及一个方向，由与*x*（实）轴形成的角度*φ*确定。要确定这两个数，我们需要找到*z=x+iy*的绝对值（或模），*r*：
- en: '*r = |z| = √x*2*+y*2'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '*r = |z| = √x*2*+y*2'
- en: 'Its angle (also, called the argument, *arg*, or *phase*), *φ*, is as follows:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 它的角度（也称为参数*arg*或*相位*），*φ*，如下：
- en: '*φ = arg(z) = arctan(x+iy) = arctan(y/x)*'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '*φ = arg(z) = arctan(x+iy) = arctan(y/x)*'
- en: Both of these relations stem from the geometry of the complex vector. The first
    relation is simply the application of the Pythagorean theorem, while the second
    comes from applying the tangent relation to the angle, *φ*.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个关系都源自复向量的几何关系。第一个关系简单地是勾股定理的应用，而第二个来自对角度*φ*应用正切关系。
- en: 'By examining the graphical representation of the vector (see the preceding
    diagram), we can see the following:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查向量的图形表示（见前面的图），我们可以看到以下内容：
- en: '*cos(φ) = x/r and*'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '*cos(φ) = x/r 和*'
- en: '*sin(φ) = y/r*'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '*sin(φ) = y/r*'
- en: Or
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '*x = r cos(φ) and*'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '*x = r cos(φ) 和*'
- en: '*y = r sin(φ)*'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '*y = r sin(φ)*'
- en: 'By substituting these with *z = x+iy*, we get the following:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用*z = x+iy*替换这些，我们得到以下结果：
- en: '*z = r (cos(φ) + i sin(φ))*'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '*z = r (cos(φ) + i sin(φ))*'
- en: 'We can write some code in Python to find (*r*, *φ*) (the polar coordinates)
    once (*x*, *y*) (the cartesian coordinates) are given and vice versa:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Python中编写一些代码，一旦给定了(*x*, *y*)(笛卡尔坐标)，就可以找到(*r*, *φ*)(极坐标)，反之亦然：
- en: '[PRE122]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The output is as follows:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE123]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Equivalently, we can use the `polar` method from the `cmath` module:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`cmath`模块中的`polar`方法：
- en: '[PRE124]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The output is as follows:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE125]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Note
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The input (0,0) is not allowed since it leads to division by zero.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许输入(0,0)，因为这会导致除以零。
- en: 'Therefore, a complex number can be represented by its modulus, *r*, and phase,
    *φ*, instead of its abscissa (*x*, the real part) and ordinate (*y*, the imaginary
    part). The modulus, *r*, is a real, non-negative number and the phase, *φ*, lies
    in the interval [-π,π]: it is *0* and *π* for purely real numbers and *π/2* or
    *-π/2* for purely imaginary numbers. The latter representation is called polar,
    while the former is known as rectangular or Cartesian; they are equivalent. The
    following representation is also possible:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，复数可以用它的模，*r*，和相位，*φ*，来表示，而不是用它的横坐标（*x*，实部）和纵坐标（*y*，虚部）。模，*r*，是一个实数，非负数，相位，*φ*，在区间[-π,π]内：对于纯实数，它是*0*和*π*，对于纯虚数，它是*π/2*或*-π/2*。后者的表示被称为极坐标，而前者被称为矩形或笛卡尔；它们是等价的。也可以用以下表示：
- en: '*z = r e*iφ *= r (cos(φ) + i sin(φ))*'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '*z = r e*iφ *= r (cos(φ) + i sin(φ))*'
- en: 'Here is the base of the natural logarithm. This is known as Euler''s formula.
    The special case, *φ=π*, gives us the following:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 这是自然对数的底。这被称为欧拉公式。特殊情况*φ=π*给出了以下结果：
- en: '*e*iπ *+ 1 = 0*'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '*e*iπ *+ 1 = 0*'
- en: This is known as Euler's identity.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是欧拉恒等式。
- en: 'The benefit of using Euler''s formula is that complex number multiplication
    and division obtain a simple geometric representation. To multiply (divide) two
    complex numbers, *z*1 and *z*2, we simply multiply (divide) their respective moduli
    and add (subtract) their arguments:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 使用欧拉公式的好处在于，复数乘法和除法获得了简单的几何表示。要乘（除）两个复数*z*1和*z*2，我们只需将它们各自的模相乘（除）并加上（减去）它们的幅角：
- en: '*z*1 ** z*2 *= r e*iφ *= r*1 ** r*2 *e*i(φ1+φ2)'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '*z*1 ** z*2 *= r e*iφ *= r*1 ** r*2 *e*i(φ1+φ2)'
- en: 'Now, let''s implement some mathematical operations with complex numbers in
    Python. We will code the addition, subtraction, multiplication, and division of
    two complex numbers:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在Python中使用一些复数进行数学运算。我们将编写两个复数的加法、减法、乘法和除法：
- en: '[PRE126]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Now, let''s try these functions for a generic pair of complex numbers, *c1=10+2j/3*
    and *c2=2.9+1j/3*:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试这些函数对一对通用的复数*c1=10+2j/3*和*c2=2.9+1j/3*：
- en: '[PRE127]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The output is as follows:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE128]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'We can do the same for a purely real number with a purely imaginary number:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对纯实数和纯虚数做同样的操作：
- en: '[PRE129]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The output is as follows:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE130]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'From the last line, we can easily see that *1/i = -i*, which is consistent
    with the definition of the imaginary unit. The `cmath` library also provides useful
    functions for complex numbers, such as `phase` and `polar`, as well as trigonometric
    functions for complex arguments:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 从最后一行，我们很容易看出*1/i = -i*，这与虚数单位的定义一致。`cmath`库还为复数提供了有用的函数，如`phase`和`polar`，以及带有复数参数的三角函数：
- en: '[PRE131]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The output is as follows:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE132]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Hence, calculating the modulus, phase, or conjugate of a given complex number
    becomes extremely simple. Note that the last line gives us back the rectangular
    (or Cartesian) form of a complex number, given its modulus and phase.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，计算给定复数的模、相位或共轭变得非常简单。请注意，最后一行给出了复数的直角（或笛卡尔）形式，给定其模和相位。
- en: Now that we learned how the arithmetic and representation of complex numbers
    work, let's move on and look at an exercise that involves logic and combines what
    we have used and learned about in the previous sections.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了复数的算术和表示方式，让我们继续看一个涉及逻辑的练习，并结合我们在前几节中使用和学习的内容。
- en: 'Exercise 5.08: Conditional Multiplication of Complex Numbers'
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.08：复数的条件乘法
- en: 'In this exercise, you will write a function that reads a complex number, `c`,
    and multiplies it by itself if the argument of the complex number is larger than
    zero, takes the square root of `c` if its argument is less than zero, and does
    nothing if the argument equals zero. Plot and discuss your findings:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将编写一个函数，该函数读取一个复数`c`，如果复数的幅角大于零，则将其乘以自身，如果幅角小于零，则取`c`的平方根，如果幅角等于零，则不执行任何操作。绘制并讨论您的发现：
- en: 'Import the necessary libraries and, optionally, suppress any warnings (this
    isn''t necessary but is helpful if you wish to keep the output tidy from warnings
    that depend on the versions of the libraries you''re using):'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库，并且可以选择地抑制任何警告（这不是必需的，但如果您希望保持输出整洁，这是有帮助的，因为警告取决于您使用的库的版本）：
- en: '[PRE133]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Now, define a function that uses Matplotlib''s `pyplot` function to plot the
    vector of the input complex number, `c`:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个函数，该函数使用Matplotlib的`pyplot`函数来绘制输入复数`c`的向量：
- en: '[PRE134]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Now, create a function that reads the input complex number, `c`, plots it by
    calling the function defined previously, and then investigates the different cases,
    depending on the phase of the input. Plot the phases before and after the operation,
    as well as the result, in order to compare the resulting vector with the input
    vector:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个函数，读取输入复数`c`，通过调用之前定义的函数绘制它，然后根据输入的相位研究不同的情况。绘制操作前后的相位以及结果，以便将结果向量与输入向量进行比较：
- en: '[PRE135]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Note that for negative phases, we take the square root of `c` (using the `math.sqrt()`
    method), whereas for positive phases, we take the square of `c`.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于负相位，我们取`c`的平方根（使用`math.sqrt()`方法），而对于正相位，我们取`c`的平方。
- en: 'Now, transform a number that lies on the upper half of the complex plane:'
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转换一个位于复平面上半部的数字：
- en: '[PRE136]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The output is as follows:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 5.23: The plot of a number that lies on the upper half of the complex
    plane'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.23：位于复平面上半部的数字的绘图'
- en: '](image/B15968_05_23.jpg)'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_23.jpg)'
- en: 'Figure 5.23: The plot of a number that lies on the upper half of the complex
    plane'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.23：位于复平面上半部的数字的绘图
- en: 'Here, a complex number with a positive argument, *φ* (blue vector), is being
    transformed (or mapped) to a new complex number (red vector) with a larger modulus
    and a new argument that is twice the previous value. This is expected: remember
    Euler''s formula for the polar representation of *c=r e*iφ? It becomes obvious
    that the square, *c*2, is a number with double the original argument, *φ*, and
    modulus, *r*2.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，一个具有正幅角*φ*（蓝色向量）的复数正在被转换（或映射）为一个具有更大模的新复数（红色向量），并且新的幅角是先前值的两倍。这是预期的：记住欧拉公式*c=r
    e*iφ的极坐标表示？很明显，平方*c*2是一个具有原始幅角*φ*和模*r*2两倍的数字。
- en: 'Next, transform a number that lies on the lower half of the complex plane:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，转换一个位于复平面下半部的数字：
- en: '[PRE137]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The output is as follows:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 5.24: Plot of a number that lies on the lower half of the complex
    plane'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.24：位于复平面下半部的数字的绘图'
- en: '](image/B15968_05_24.jpg)'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_24.jpg)'
- en: 'Figure 5.24: Plot of a number that lies on the lower half of the complex plane'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.24：位于复平面下半部的数字的绘图
- en: In this case, the square root is calculated. Similar to the first example, the
    newly transformed vector has a modulus that is the square root of the modulus
    of the original vector and an argument that is half of the original one.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，计算了平方根。与第一个例子类似，新转换的向量的模是原始向量的模的平方根，幅角是原始幅角的一半。
- en: Note
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Fun fact: In both cases, the vector has been rotated anti-clockwise.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的事实：在两种情况下，向量都是逆时针旋转的。
- en: 'Write a `while` iteration that calls the `mult_complex()` function *n* times
    to check what happens if we keep the vectors rotating:'
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`while`迭代，调用`mult_complex()`函数*n*次，以检查如果我们保持向量旋转会发生什么：
- en: '[PRE138]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The output is as follows:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 5.25: Plot of rotating vectors'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.25：旋转向量的绘图'
- en: '](image/B15968_05_25.jpg)'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_25.jpg)'
- en: 'Figure 5.25: Plot of rotating vectors'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.25：旋转向量的绘图
- en: With that, we've seen how vectors and vector algebra can be used to visualize
    geometric operations. In particular, dividing and multiplying complex numbers
    results in acquiring a geometric representation that can be helpful when dealing
    with large sets of data and visualizations.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们看到了向量和向量代数如何用于可视化几何运算。特别是，除法和乘法复数的结果是获得几何表示，这在处理大量数据和可视化时非常有用。
- en: Note
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/31yU8W1.](https://packt.live/31yU8W1
    )
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/31yU8W1](https://packt.live/31yU8W1)。
- en: You can also run this example online at [https://packt.live/2BXWJOw.](https://packt.live/2BXWJOw
    )
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2BXWJOw](https://packt.live/2BXWJOw)上在线运行此示例。
- en: 'Activity 5.01: Calculating Your Retirement Plan Using Series'
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动5.01：使用级数计算您的退休计划
- en: In many countries, a retirement plan (also known as 401(k)) is offered by some
    employers. Such plans allow you to contribute directly from your paycheck, so
    they are an easy and effective way to save and invest for retirement. You have
    been tasked with writing some code that calculates and plots your monthly return
    based on the amount and duration of contributions.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多国家，一些雇主提供退休计划（也称为401(k)）。这些计划允许您直接从工资中捐款，因此是一种轻松有效的储蓄和投资退休的方式。您的任务是编写一些代码，根据捐款金额和持续时间计算和绘制您的月度回报。
- en: 'A retirement plan accumulates in time, exactly like a geometric series does.
    It is an investment: you save money on a monthly basis in order to collect it
    later, on a monthly basis, with added value or interest. The main *ingredients*
    to calculate the retirement return are your current balance, a monthly contribution,
    the employer match (employer''s contribution), the retirement age, the rate of
    return (the average annual return you expect from your 401(k) investment), life
    expectancy, and any other fees. In a realistic case, *caps* are introduced: the
    employer match (typically between 50% and 100%) cannot be raised by more than
    6% of your annual salary. Similarly, the employee''s contribution cannot be larger
    than a given amount in a year (typically, this is 18 K), regardless of how high
    the salary is.'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 退休计划会像等比数列一样随时间累积。这是一种投资：您每月存钱，以便以后每月收取，带有附加值或利息。计算退休回报的主要*要素*是您当前的余额，每月的捐款，雇主匹配（雇主的捐款），退休年龄，回报率（您从401(k)投资中预期的平均年回报），预期寿命和任何其他费用。在现实情况下，会引入*上限*：雇主匹配（通常在50%至100%之间）不能超过您年薪的6%。同样，员工的捐款在一年内不能超过一定金额（通常为18K），无论工资有多高。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动：
- en: Identify the variables of our problem. These will be the variables of our functions.
    Make sure you read through the activity description carefully and *internalize*
    what is known and what is to be calculated.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定我们问题的变量。这些将是我们函数的变量。确保仔细阅读活动描述，并*内化*已知和要计算的内容。
- en: Identify the sequence and write one function that calculates the value of the
    retirement plan at some year, *n*. The function should admit the current balance,
    annual salary, year, *n*, and more as inputs and return a tuple of contribution,
    employer's match, and total retirement value at year *n*.
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别序列并编写一个函数，计算某一年*n*的退休计划价值。该函数应接受当前余额、年薪、年份*n*等输入，并返回每年的捐款、雇主匹配和退休总价值的元组。
- en: Identify the series and write one function that calculates the accumulated value
    of the retirement plan *after n* years. The present function should read the input,
    call the previous function that calculates the value of the plan at each year,
    and sum all the (per year) savings. For visualization purposes, the contributions
    (per year), employer match (per year), and total value (per year) should be returned
    as lists in a tuple.
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别级数并编写一个函数，计算*n*年后退休计划的累积价值。当前函数应读取输入，调用前一个函数计算每年计划的价值，并对所有（每年）储蓄进行求和。为了可视化目的，应将捐款（每年）、雇主匹配（每年）和总价值（每年）作为列表返回到一个元组中。
- en: Run the function for a variety of chosen values and ensure it runs properly.
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对各种选择的值运行函数，并确保其正常运行。
- en: Plot the results with Matplotlib.
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Matplotlib绘制结果。
- en: Note
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 672.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第672页找到。
- en: Summary
  id: totrans-616
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have been provided with a general and helpful exposition
    of the most central mathematical concepts in sequences, series, trigonometry,
    vectors, and complex numbers and, more importantly, their implementation in Python
    using concrete and short examples. As a real-life example, we examined a retirement
    plan and the progression of our savings in time. However, numerous other situations
    can be modeled after sequences or series and be studied by applying vectors or
    complex numbers. These concepts and methods are widely used in physics, engineering,
    data science, and more. Linear algebra, that is, the study of vectors, matrices,
    and tensors, heavily relies on understanding the concept of geometry and vectors
    and appears almost everywhere in data science and when studying neural networks.
    Geometry and trigonometry, on the other hand, are explicitly used to model physical
    motion (in video games, for instance) and more advanced concepts in geospatial
    applications. However, having background knowledge of these concepts makes using
    and applying data science methods more concrete and understandable.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经得到了关于序列、级数、三角学、向量和复数等最核心数学概念的一般性和有益的阐述，更重要的是，我们使用具体而简短的例子在Python中实现了它们。作为一个现实生活的例子，我们研究了一个退休计划以及我们储蓄随时间的变化。然而，许多其他情况可以模拟成序列或级数，并通过应用向量或复数进行研究。这些概念和方法在物理学、工程学、数据科学等领域被广泛应用。线性代数，即对向量、矩阵和张量的研究，严重依赖于对几何和向量概念的理解，并几乎无处不在地出现在数据科学和神经网络的研究中。另一方面，几何和三角学明确地用于模拟物理运动（例如在视频游戏中）以及地理空间应用中的更高级概念。然而，对这些概念有背景知识使得使用和应用数据科学方法更加具体和可理解。
- en: In the next chapter, we will discuss matrices and how to apply them to solve
    real-world problems. We'll also examine Markov chains, which are used to tie concepts
    regarding probability, matrices, and limits together.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论矩阵以及如何将它们应用于解决现实世界的问题。我们还将研究马尔可夫链，它们用于将与概率、矩阵和极限相关的概念联系在一起。
- en: NDN74
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: NDN74
- en: ETB65
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: ETB65
