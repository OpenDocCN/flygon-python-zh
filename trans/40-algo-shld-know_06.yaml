- en: Graph Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图算法
- en: There is a class of computational problems that can be best represented in terms
    of graphs. Such problems can be solved using a class of algorithms called **graph
    algorithms**. For example, graph algorithms can be used to efficiently search
    a value in a graphical representation of data. To work efficiently, these algorithms
    will first need to  discover the structure of the graph. They also need to find
    the right strategy for following the edges of the graph to read the data stored
    in the vertices. As graph algorithms need to search values in order to work, efficient
    searching strategies lie at the center of designing efficient graph algorithms.
    Using graph algorithms is one of the most efficient ways of searching for information
    in complex, interconnected data structures that are linked through meaningful
    relationships. In today's era of big data, social media, and distributed data,
    such techniques are becoming increasingly important and useful.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有一类计算问题最好以图的术语来表示。这类问题可以使用一类称为**图算法**的算法来解决。例如，图算法可以用于在数据的图形表示中高效搜索值。为了高效工作，这些算法首先需要发现图的结构。它们还需要找到正确的策略来跟随图的边以读取顶点中存储的数据。由于图算法需要搜索值才能工作，因此高效的搜索策略是设计高效图算法的核心。使用图算法是在复杂的相互关联的数据结构中搜索信息的最有效方式之一。在当今的大数据、社交媒体和分布式数据时代，这些技术变得越来越重要和有用。
- en: In this chapter, we will start by presenting the basic concepts behind graph
    algorithms. Then, we will present the basics of network analysis theory. Next,
    we will look at the various techniques that can be used to traverse graphs. Finally,
    we will look at a case study showing how graph algorithms can be used for fraud
    detection.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先介绍图算法背后的基本概念。然后，我们将介绍网络分析理论的基础知识。接下来，我们将看看可以用来遍历图的各种技术。最后，我们将看一个案例研究，展示图算法如何用于欺诈检测。
- en: 'In this chapter, we will go through the following concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下概念：
- en: Different ways of representing graphs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示图的不同方式
- en: Introducing network theory analysis
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入网络理论分析
- en: Understanding graph traversals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解图的遍历
- en: 'Case study: fraud analytics'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究：欺诈分析
- en: Techniques for establishing a neighborhood in our problem space
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的问题空间中建立邻域的技术
- en: By the end of this chapter, you will have a good understanding of what graphs
    are and how to work with them to represent interconnected data structures and
    mine information from entities that are related by direct or indirect relationships,
    as well as use them to solve some complex real-world problems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将对图是什么以及如何使用它们来表示相互关联的数据结构并从直接或间接关系的实体中挖掘信息有很好的理解，以及如何使用它们来解决一些复杂的现实世界问题。
- en: Representations of graphs
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的表示
- en: A graph is a structure that represents data in terms of vertices and edges.
    A graph is represented as `aGraph` = (𝓥,  𝓔), where 𝓥  represents a set of vertices
    and 𝓔  represents a set of edges. Note that `aGraph` has |𝓥| vertices and |𝓔|
    edges.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图是一种以顶点和边的形式表示数据的结构。图表示为`aGraph` = (𝓥,  𝓔)，其中𝓥表示一组顶点，𝓔表示一组边。注意`aGraph`有|𝓥|个顶点和|𝓔|条边。
- en: 'A vertex, 𝓋 ∈ 𝓥, represents a real-world object, such as a person, a computer,
    or an activity. An edge, 𝓋 ∈ 𝓔, connects two vertices in a network:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个顶点，𝓋 ∈ 𝓥，表示现实世界的对象，如人、计算机或活动。一条边，𝓋 ∈ 𝓔，连接网络中的两个顶点：
- en: e(𝓋[1],  𝓋[2])  |  e  ∈  𝓔  &  𝓋[i]  ∈  𝓥
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: e(𝓋[1],  𝓋[2])  |  e  ∈  𝓔  &  𝓋[i]  ∈  𝓥
- en: The preceding equation indicates that in a graph, all edges belong to a set,
    𝓔, and all vertices belong to a set, 𝓥.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方程表明，在图中，所有边属于一个集合𝓔，所有顶点属于一个集合𝓥。
- en: 'An edge connects two vertices and so represents a relationship between them.
    For example, it can represent the following relationships:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一条边连接两个顶点，因此代表它们之间的关系。例如，它可以代表以下关系：
- en: Friendships between people
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人与人之间的友谊
- en: A person connected to a friend on LinkedIn
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个人在LinkedIn上连接了一个朋友
- en: A physical connection of two nodes in a cluster
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个集群中两个节点的物理连接
- en: A person attending a research conference
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个人参加研究会议
- en: 'In this chapter, we will be using the `networkx` Python package to represent
    graphs. Let''s try to create a simple graph using the `networtx` package in Python.
    To begin with, let''s try to create an empty graph, `aGraph`, with no vertex or
    node:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`networkx` Python包来表示图。让我们尝试使用Python中的`networtx`包创建一个简单的图。首先，让我们尝试创建一个空图`aGraph`，没有顶点或节点：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s add a single vertex:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个单个顶点：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also add a bunch of vertices using a list:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用列表添加一堆顶点：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can also add one edge between the existing vertices, as shown:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在现有的顶点之间添加一条边，如下所示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s now print the edges and vertices:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们打印边和顶点：
- en: '![](assets/f8489957-6725-46c0-854c-83e6a549647e.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f8489957-6725-46c0-854c-83e6a549647e.png)'
- en: 'Please note that if we are adding an edge, this also leads to adding the associated
    vertices, if they do not already exist, as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们添加一条边，这也会导致添加相关的顶点，如果它们尚不存在，如下所示：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we print the list of nodes, the following is the output that we observe:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们打印节点列表，我们将看到以下输出： '
- en: '![](assets/372a343b-993e-4a4d-a363-7d0d8e249060.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/372a343b-993e-4a4d-a363-7d0d8e249060.png)'
- en: Note that the request to add a vertex that already exists is silently ignored.
    The request is ignored or entertained based on the type of graph we have created.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对已经存在的顶点进行添加的请求会被静默忽略。请求的忽略或接受取决于我们创建的图的类型。
- en: Types of graphs
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的类型
- en: 'Graphs can be classified into four kinds, namely the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图可以分为四种类型，即以下四种：
- en: Undirected graphs
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无向图
- en: Directed graphs
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有向图
- en: Undirected multigraphs
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无向多重图
- en: Directed multigraphs
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有向多重图
- en: Let's now look through each one in detail.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们逐个详细查看每一个。
- en: Undirected graphs
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无向图
- en: 'In most cases, the relationships that the constituent nodes of a graph represent
    can be thought of as undirectional. Such relationships do not impose any order
    on the relationship. Such edges are called **undirected edges** and the resultant
    graph is called an **undirected graph**. An undirected graph is shown here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，图的组成节点之间表示的关系可以被认为是无方向的。这种关系不对关系施加任何顺序。这样的边被称为**无向边**，结果图被称为**无向图**。以下是一个无向图的示例：
- en: '![](assets/cf68002d-cedd-4a86-a4b9-bf6e5e2b8d8c.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cf68002d-cedd-4a86-a4b9-bf6e5e2b8d8c.png)'
- en: 'Some examples of undirectional relationships are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一些无向关系的例子如下：
- en: Mike and Amine (Mike and Amine know each other).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迈克和阿敏（迈克和阿敏互相认识）。
- en: Node A and Node B are connected (this is a peer-to-peer connection).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点A和节点B相连（这是一种点对点的连接）。
- en: Directed graphs
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有向图
- en: 'A graph where the relationship between the nodes in the graph has some sense
    of direction is called a **directed graph**. A directed graph is shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图中节点之间的关系具有某种方向感的图被称为**有向图**。以下是一个有向图的示例：
- en: '![](assets/ce695903-85c9-4cd3-910f-840172509719.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ce695903-85c9-4cd3-910f-840172509719.png)'
- en: 'Some examples of directed relationships are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有向关系的例子如下：
- en: Mike and his house (Mike lives in a house, but his house does not live in Mike).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迈克和他的房子（迈克住在一所房子里，但他的房子不住在迈克里）。
- en: John manages Paul (John is the manager of Paul).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约翰管理保罗（约翰是保罗的经理）。
- en: Undirected multigraphs
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无向多重图
- en: Sometimes, nodes have more than one type of relationship between them. In that
    case, there can be more than one edge connecting the same two nodes. These kinds
    of graphs, where multiples parallel edges are allowed on the same nodes, are called
    **multigraphs**. We have to explicitly indicate whether a particular graph is
    a multigraph or not. Parallel edges may represent different types of relationships
    between the nodes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，节点之间有多种关系。在这种情况下，可以有多条边连接相同的两个节点。这种图称为**多重图**，在同一节点上允许多条平行边。我们必须明确指出一个特定的图是否是多重图。平行边可以表示节点之间的不同类型的关系。
- en: 'A multigraph is shown in the following figure:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了一个多重图：
- en: '![](assets/164e1e18-bf72-4a5a-a265-5a27aff76abd.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/164e1e18-bf72-4a5a-a265-5a27aff76abd.png)'
- en: An example of a multidirectional relationship is if Mike and John are classmates
    are well as co-workers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 多向关系的一个例子是迈克和约翰既是同学又是同事。
- en: Directed multigraphs
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有向多重图
- en: 'If there is a directional relationship between nodes in a multigraph, we call
    it a **directed multigraph**:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多重图中的节点之间存在方向关系，则称为**有向多重图**：
- en: '![](assets/0958225c-d78c-45a7-9dc1-b04bcbbf08fb.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0958225c-d78c-45a7-9dc1-b04bcbbf08fb.png)'
- en: An example of a directed multigraph is that Mike reports to John in the office,
    and John teaches Mike the Python programming language.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有向多重图的一个例子是迈克在办公室向约翰汇报，并且约翰教迈克Python编程语言。
- en: Special types of edges
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊类型的边
- en: 'Edges connect various vertices of a graph together and represent the relationship
    between themselves. In addition to simple edges, they can be of the following
    special types:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 边将图的各个顶点连接在一起，并表示它们之间的关系。除了简单的边，它们还可以是以下特殊类型：
- en: '**Self-edge**: Sometimes, a particular vertex can have a relationship with
    itself. For example, John transfers money from his business account to his personal
    account. Such a special relationship can be represented by a self-directed edge.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自边**：有时，特定的顶点可以与自己有关系。例如，约翰把钱从他的商业账户转到他的个人账户。这种特殊关系可以用自导向边来表示。'
- en: '**Hyperedge**: Sometimes, more than one vertex is connected by the same edge.
    An edge that connects more than one vertex to represent such a relationship is
    called a hyperedge. For example, suppose all three of Mike, John, and Sarah are
    working on one specific project.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超边**：有时，多个顶点由同一条边连接。连接多个顶点以表示这种关系的边被称为超边。例如，假设迈克、约翰和莎拉三人一起参与一个特定项目。'
- en: A graph that has one or more hyperedges is called a **hypergraph**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 具有一个或多个超边的图被称为**超图**。
- en: 'A diagram of a self-edge and hyperedge graph is shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了自边和超边图的图示：
- en: '![](assets/8540dc18-6deb-49af-af6a-b7a8d78faf8d.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8540dc18-6deb-49af-af6a-b7a8d78faf8d.png)'
- en: Note that one particular graph can have more than one special type of edge node.
    This means that one particular graph can have both self-edges and hyper edges
    at the same time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一个特定的图可以有多种特殊类型的边节点。这意味着一个特定的图可以同时具有自边和超边。
- en: Ego-centered networks
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我中心网络
- en: The direct neighborhood of a particular vertex, *m*, may have enough important
    information to conduct a conclusive analysis for the node. The ego-center, or
    egonet, is based on this idea. An egonet of a particular vertex, *m*, consists
    of all the vertices directly connected to *m* plus node *m* itself. The node *m*
    is called the **ego** and the one-hop neighbors it is connected to are called
    **alters**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 特定顶点*m*的直接邻域可能包含足够重要的信息，以进行对节点的决定性分析。自我中心，或者称为egonet，就是基于这个想法的。特定顶点*m*的egonet包括所有直接连接到*m*的顶点以及节点*m*本身。节点*m*被称为**自我**，与之连接的一跳邻居被称为**替代者**。
- en: 'The ego network of a particular node, 3, is shown in the following graph:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 特定节点3的自我网络在以下图中显示：
- en: '![](assets/6c26bd31-bf63-43dd-bb0a-a18d704a4f7b.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6c26bd31-bf63-43dd-bb0a-a18d704a4f7b.png)'
- en: Note that the egonet represents one degree neighborhood. This concept can be
    extended to n-degree neighborhoods, which consist of all the vertices n-hop away
    from the vertex of interest.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，egonet代表一度邻域。这个概念可以扩展到n度邻域，包括所有n跳离感兴趣的顶点的顶点。
- en: Social network analysis
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社交网络分析
- en: '**Social network analysis** (**SNA**) is one of the important applications
    of graph theory. A network graph analysis is considered social network analysis
    if the following apply:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**社交网络分析**（**SNA**）是图论的重要应用之一。如果满足以下条件，网络图分析被认为是社交网络分析：'
- en: The vertices of the graph represent people.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的顶点代表人。
- en: The edges between them represent social relationships between them, such as
    a friendship, a common hobby, kinship, a sexual relationship, dislikes, and so
    on.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们之间的边代表着它们之间的社会关系，如友谊、共同爱好、血缘关系、性关系、厌恶等等。
- en: The business question that we are trying to answer through graph analysis has
    some strong social aspect to it.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过图分析试图回答的商业问题具有很强的社会方面。
- en: Human behavior is reflected in SNA and should always be kept in mind while working
    on SNA. By mapping human relationships in a graph, SNA gives good insights into
    human interactions, which can help us understand their actions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 人类行为在SNA中得到反映，并且在进行SNA时应始终牢记。通过在图中绘制人际关系，SNA可以深入了解人际互动，这有助于我们理解他们的行为。
- en: By creating a neighborhood around each individual and analyzing the actions
    of an individual based on its social relationship, you can produce interesting,
    and sometimes surprising, insights. The alternative approaches to analyzing individuals
    in isolation, based on their individual job functions, can only provide limited
    insights.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在每个个体周围创建邻域，并根据其社会关系分析个体的行为，您可以产生有趣的，有时令人惊讶的见解。基于个体的个人工作职能对个体进行分析的替代方法只能提供有限的见解。
- en: 'So, SNA can be used for the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，SNA可以用于以下方面：
- en: Understanding a users's actions on social media platforms, such as Facebook,
    Twitter, or LinkedIn
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解用户在社交媒体平台上的行为，如Facebook、Twitter或LinkedIn
- en: Understanding fraud
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解欺诈
- en: Understanding society's criminal behavior
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解社会的犯罪行为
- en: LinkedIn has contributed a lot to the research and development of new techniques
    related to SNA. In fact, LinkedIn can be thought of as a pioneer of many algorithms
    in this area.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: LinkedIn在SNA相关的新技术的研究和开发方面做出了很大贡献。事实上，LinkedIn可以被认为是该领域许多算法的先驱。
- en: Thus, SNA—due to its inherent distributed and interconnected architecture of
    social networks—is one of the most powerful use cases for graph theory. Another
    way to abstract a graph is by considering it as a network and applying an algorithm
    designed for networks. This whole area is called **network analysis theory**,
    which we will discuss next.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于社交网络的固有分布和相互连接的架构，SNA是图论最强大的用例之一。另一种抽象图的方法是将其视为网络，并应用设计用于网络的算法。这整个领域被称为**网络分析理论**，我们将在下面讨论。
- en: Introducing network analysis theory
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍网络分析理论
- en: We know that interconnected data can be represented as a network. In network
    analysis theory, we study the details of the methodologies developed to explore
    and analyze data represented as a network . Let's look at some important aspects
    of network analysis theory in this section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，互连的数据可以表示为网络。在网络分析理论中，我们研究了开发用于探索和分析表示为网络的数据的方法的细节。让我们在本节中看一些网络分析理论的重要方面。
- en: First, note that a vertex in a network acts as the basic unit. A network is
    an interconnected web of vertices where each connection represents the relationship
    between various entities under investigation. It is important to quantify the
    usefulness and importance of a vertex in a network in the context of the problem
    we are trying to solve. There are various techniques that can help us quantify
    the importance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意网络中的一个顶点充当基本单元。网络是一个由顶点相互连接而成的网络，其中每个连接代表着调查对象之间的关系。在解决问题的背景下，量化网络中顶点的有用性和重要性是很重要的。有各种技术可以帮助我们量化重要性。
- en: Let's look at some of the important concepts used in network analysis theory.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些网络分析理论中使用的重要概念。
- en: Understanding the shortest path
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解最短路径
- en: A path is a sequence of nodes between a start node and an end node, where no
    node appears twice on the path. A path represents a route between the chosen start
    and end vertex. It will be set of vertices, *p*, connecting the start vertex with
    the end vertex. No vertex is repeated in *p*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 路径是起始节点和结束节点之间的节点序列，路径上没有节点出现两次。路径代表了所选起始和结束顶点之间的路线。它将是一组连接起始顶点和结束顶点的顶点*p*。在*p*中没有重复的顶点。
- en: The length of a path is calculated by counting the constituent edges. Out of
    all the options, the path with the smallest length is called the **shortest path**.
    Calculation of the shortest path is used extensively in graph theory algorithms
    but is not always straightforward to calculate. There are different algorithms
    that can be used to find the shortest path between a start node and an end node.
    One of the most popular algorithms that can be used to find the shortest distance
    between the start node and the end node is **Dijkstra's algorithm**, published
    in the late 1950s. It calculates the shortest path in a graph. It can be used
    by **Global Positioning System** (**GPS**) devices to calculate the minimum distance
    between a source and destination. Dijkstra's algorithm is also used in network
    routing algorithms.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 路径的长度是通过计算组成边来计算的。在所有选项中，具有最小长度的路径称为**最短路径**。最短路径的计算在图论算法中被广泛使用，但并不总是直接计算。有不同的算法可以用来找到起始节点和结束节点之间的最短路径。其中一个最流行的算法是**Dijkstra算法**，它在20世纪50年代末出版。它可以计算图中的最短路径。它可以被**全球定位系统**（**GPS**）设备用来计算源和目的地之间的最小距离。Dijkstra算法也用于网络路由算法。
- en: There is a battle between Google and Apple to design the best shortest-distance
    algorithm for Google Maps and Apple Maps. The challenge they face is making the
    algorithm fast enough to calculate the shortest path within seconds.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌和苹果之间存在一场争夺，他们要设计出最佳的谷歌地图和苹果地图的最短距离算法。他们面临的挑战是使算法足够快，可以在几秒内计算出最短路径。
- en: Later in this chapter, we will discuss the **breadth-first search** (**BFS**)
    **algorithm**, which can be modified to be converted into Dijkstra's algorithm.
    BFS assumes the same cost of traversing each path in a given graph. For Dijkstra's
    algorithm, the cost of traversing a graph can be different and it needs to be
    incorporated to modify BFS into Dijkstra's algorithm.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们将讨论**广度优先搜索**（**BFS**）**算法**，它可以修改为迪杰斯特拉算法。BFS假设在给定图中遍历每条路径的成本相同。对于迪杰斯特拉算法，遍历图的成本可能不同，需要将其纳入修改BFS为迪杰斯特拉算法。
- en: As indicated, Dijkstra's algorithm is a single sourced algorithm that calculates
    the shortest path. If we want to solve all pairs of shortest paths, then the **Floyd-Warshall
    algorithm** can be used.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所示，迪杰斯特拉算法是一种计算最短路径的单源算法。如果我们想解决所有最短路径对，那么可以使用**弗洛伊德-沃舍尔算法**。
- en: Creating a neighborhood
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建邻域
- en: Finding strategies to create a neighborhood around nodes of interest is pivotal
    for graph algorithms. Methodologies to create neighborhoods are based on selecting
    direct associates with the vertex of interest. One way of creating a neighborhood
    is by choosing a k-order strategy that selects the vertices that are *k* hops
    away from the vertex of interest.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了图算法的关键节点周围创建邻域的策略至关重要。创建邻域的方法基于选择与感兴趣的顶点直接关联的方法。创建邻域的一种方法是选择一个*k*阶策略，该策略选择与感兴趣的顶点相距*k*跳的顶点。
- en: Let's look at the various criteria for creating neighborhoods.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建邻域的各种标准。
- en: Triangles
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三角形
- en: In graph theory, finding vertices that are well-connected to each other is important
    for the purpose of analysis. One technique is to try to identify triangles, which
    are a subgraph that consists of three nodes directly connected to each other,
    in the network.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在图论中，找到彼此连接良好的顶点对于分析很重要。一种技术是尝试识别三角形，在网络中，三角形是由三个直接相连的节点组成的子图。
- en: Let's look at the use case of fraud detection, which we have also used as a
    case study towards the end of this chapter. If an egonet of a node, *m*, consists
    of three vertices, including vertex *m*, then this egonet is a triangle. Vertex
    *m* will be the ego and the two connected vertices will be alters, say vertex
    *A* and vertex *B*. If both alters are known fraudulent cases, we can safely declare
    vertex *m* as fraudulent as well. If one of the alters is involved in fraud, we
    cannot come up with conclusive evidence, but we will need to conduct a further
    search into the evidence of fraud.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看欺诈检测的用例，我们在本章末尾也将其用作案例研究。如果节点*m*的egonet包括三个顶点，包括顶点*m*，那么这个egonet就是一个三角形。顶点*m*将是ego，而两个连接的顶点将是alter，比如顶点*A*和顶点*B*。如果两个alter都是已知的欺诈案例，我们可以安全地宣布顶点*m*也是欺诈的。如果其中一个alter涉及欺诈，我们无法得出结论性证据，但我们需要进一步调查欺诈证据。
- en: Density
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密度
- en: Let's first define a fully connected network. We call a graph where every vertex
    is directly connected to every other vertex a **fully connected network**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义一个完全连接的网络。我们称每个顶点直接连接到每个其他顶点的图为**完全连接的网络**。
- en: 'If we have a fully connected network, *N*, then the number of edges in the
    network can be represented by the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个完全连接的网络*N*，那么网络中的边数可以表示如下：
- en: '![](assets/bb1ed3b4-fa12-4cf7-97ab-000e1df20edd.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bb1ed3b4-fa12-4cf7-97ab-000e1df20edd.png)'
- en: 'Now, this is where density comes into play. Density measures the number of
    observed edges to the maximum number of edges, if **Edges****[Observed]**  is
    the number of edges we want to observe. It can be framed as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这就是密度发挥作用的地方。密度测量观察到的边的数量与最大边数的比值，如果**Edges****[Observed]**是我们想要观察的边的数量。它可以表述如下：
- en: '![](assets/5578cdd3-f96d-4876-9858-b341f9de7e5b.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5578cdd3-f96d-4876-9858-b341f9de7e5b.png)'
- en: Note that for a triangle, the density of the network is `1` and this represents
    the highest possible connected network.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于三角形，网络的密度为`1`，这代表了最高可能的连接网络。
- en: Understanding centrality measures
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解中心性度量
- en: There are different measures for understanding the centrality of a particular
    vertex in a graph or subgraph. For example, they can quantify the importance of
    a person in a social network or the importance of a building in a city.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的度量方法来理解图或子图中特定顶点的中心性。例如，它们可以量化社交网络中一个人的重要性，或者城市中建筑物的重要性。
- en: 'The following centrality measures are widely used in graph analysis:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下中心性度量在图分析中被广泛使用：
- en: Degree
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 度
- en: Betweenness
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介数
- en: Closeness
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紧密度
- en: Eigenvector
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征向量
- en: Let's discuss them in detail.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论它们。
- en: Degree
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 度
- en: The number of edges connected to a particular vertex is called its **degree**.
    It can indicate how well connected a particular vertex is and its ability to quickly
    spread a message across a network.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点连接的边的数量称为其**度**。它可以指示特定顶点的连接情况以及其在网络中快速传播消息的能力。
- en: 'Let''s consider `aGraph` = (𝓥, 𝓔), where 𝓥  represents a set of vertices and
    𝓔 represents a set of edges. Recall that `aGraph` has |𝓥| vertices and |𝓔| edges.
    If we divide the degree of a node by (|𝓥| -1), it is called **degree centrality**:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑`aGraph` = (𝓥, 𝓔)，其中𝓥表示顶点集合，𝓔表示边集合。回想一下，`aGraph`有|𝓥|个顶点和|𝓔|条边。如果我们将节点的度除以(|𝓥|-1)，则称为**度中心性**：
- en: '![](assets/914f6329-800b-4437-81ea-0eb2db9e916f.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/914f6329-800b-4437-81ea-0eb2db9e916f.png)'
- en: 'Now, let''s look at a specific example. Consider the following graph:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个具体的例子。考虑以下图：
- en: '![](assets/ada779e9-dd48-477a-b295-c844ff01a7bb.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ada779e9-dd48-477a-b295-c844ff01a7bb.png)'
- en: 'Now, in the preceding graph, vertex C has a degree of 4. Its degree centrality
    can be calculated as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在上述图中，顶点C的度为4。其度中心性可以计算如下：
- en: '![](assets/cb9a9f2c-b42d-4c45-8ff9-e225b9b68bdd.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cb9a9f2c-b42d-4c45-8ff9-e225b9b68bdd.png)'
- en: Betweenness
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介数
- en: Betweenness is the measure of centrality in a graph. In the context of social
    media, it will quantify the probability that a person is part of the communication
    in a subgroup. For a computer network, betweenness will quantify the negative
    effect on communication between the graph nodes, in the event of vertex failure.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 介数是图中的中心性度量。在社交媒体的背景下，它将量化一个人在子群中参与通信的概率。对于计算机网络，介数将量化在顶点故障的情况下对图节点之间通信的负面影响。
- en: 'To calculate the betweenness of vertex *a* in a certain `aGraph` = (𝓥,  𝓔),
    follow these steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算`aGraph`中顶点*a*的介数，按照以下步骤进行：
- en: Compute the shortest paths between each pair of vertices in `aGraph`. Let's
    represent this with ![](assets/b27f093d-110b-44a6-b83a-d0319c29f6b0.png).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算`aGraph`中每对顶点之间的最短路径。让我们用![](assets/b27f093d-110b-44a6-b83a-d0319c29f6b0.png)来表示这一点。
- en: From ![](assets/7c93ea9a-f562-4a1e-9638-ce41ea2ab0c7.png), count the number
    of shortest paths that pass through vertex *a*. Let's represent this with  ![](assets/e682e160-f38a-4908-9231-1a56061ce210.png).
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从![](assets/7c93ea9a-f562-4a1e-9638-ce41ea2ab0c7.png)，计算通过顶点*a*的最短路径数量。让我们用![](assets/e682e160-f38a-4908-9231-1a56061ce210.png)来表示这一点。
- en: Calculate the betweenness with ![](assets/22ac572a-c56d-4287-9f79-0a7643903726.png).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用![](assets/22ac572a-c56d-4287-9f79-0a7643903726.png)来计算介数。
- en: Fairness and closeness
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公平和亲近
- en: Let's take a graph, *g*. The fairness of vertex *a* in graph *g* is defined
    as the sum of vertex *a*'s distance from other vertices. Note that the centrality
    of a particular vertex quantifies its total distance from all the other vertices.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿一个图*g*。图*g*中顶点*a*的公平性被定义为顶点*a*到其他顶点的距离之和。请注意，特定顶点的中心性量化了它与所有其他顶点的总距离。
- en: The opposite of fairness is closeness.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 公平性的对立面是亲近度。
- en: Eigenvector centrality
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特征向量中心性
- en: Eigenvector centrality gives scores to all vertices in a graph that measure
    their importance in the network. The score will be an indicator of the connectivity
    of a particular node to other important nodes in the whole network. When Google
    created the **PageRank algorithm**, which assigns a score to each web page on
    the internet (in order to express its importance), the idea was derived from the
    eigenvector centrality measure.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 特征向量中心性给出了图中所有顶点的分数，衡量它们在网络中的重要性。该分数将是特定节点与整个网络中其他重要节点的连接性的指标。当谷歌创建了**PageRank算法**时，该算法为互联网上的每个网页分配一个分数（以表达其重要性），这个想法就是源自特征向量中心性度量。
- en: Calculating centrality metrics using Python
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python计算中心性度量
- en: 'Let''s create a network and then try to calculate its centrality metrics. The
    following code block illustrates this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个网络，然后尝试计算其中心性度量。以下代码块说明了这一点：
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The graph produced by this code is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成的图如下所示：
- en: '![](assets/e42a81ee-f9ee-40e9-b281-3808485e9c29.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e42a81ee-f9ee-40e9-b281-3808485e9c29.png)'
- en: 'So far, we have studied different measures of centrality. Let''s calculate
    them for the preceding example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经研究了不同的中心性度量。让我们为前面的例子计算这些度量：
- en: '![](assets/ab3b6b13-947c-4606-84e3-889fc6109e3e.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ab3b6b13-947c-4606-84e3-889fc6109e3e.png)'
- en: Note that the metrics of centrality are expected to give the centrality measure
    of a particular vertex in a graph or subgraph. Looking at the graph, the vertex
    labeled 7 seems to have the most central location. Vertex 7 has the highest values
    in all four metrics of centrality, thus reflecting its importance in this context.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，中心性的度量应该给出图或子图中特定顶点的中心性度量。从图中看，标记为7的顶点似乎具有最中心的位置。顶点7在中心性的四个度量中具有最高值，因此反映了它在这个上下文中的重要性。
- en: Now let's look into how we can retrieve information from the graphs. Graphs
    are complex data structures with lots of information stored both in vertices and
    edges. Let's look at some strategies that can be used to navigate through graphs
    efficiently in order to gather information from them to answer queries.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何从图中检索信息。图是复杂的数据结构，存储了大量的信息，既在顶点中又在边中。让我们看一些可以用来有效地遍历图以从中收集信息以回答查询的策略。
- en: Understanding graph traversals
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解图遍历
- en: To make use of graphs, information needs to be mined from them. Graph traversal
    is defined as the strategy used to make sure that every vertex and edge is visited
    in an orderly manner. An effort is made to make sure that each vertex and edge
    is visited exactly once; no more and no less. Broadly, there can be two different
    ways of traveling a graph to search the data in it. Going by breadth is called
    **breadth-first search** (**BFS**) and going by depth is called **depth-first
    search** (**DFS**). Let's look at them one by one.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用图，需要从中挖掘信息。图遍历被定义为用于确保以有序方式访问每个顶点和边的策略。努力确保每个顶点和边都被访问一次，不多不少。广义上讲，可以有两种不同的遍历图的方式来搜索其中的数据。按广度进行称为**广度优先搜索**（**BFS**），按深度进行称为**深度优先搜索**（**DFS**）。让我们依次看一下它们。
- en: Breadth-first search
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广度优先搜索
- en: BFS works best when there is a concept of layers or levels of neighborhoods
    in the `aGraph` we are dealing with. For example, when the connections of a person
    in LinkedIn are expressed as a graph, there are first-level connections and then
    there are second-level connections, which directly translate to the layers.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理`aGraph`时，如果存在层次或邻域级别的概念，BFS效果最好。例如，当LinkedIn中一个人的联系被表示为图时，有一级联系，然后有二级联系，这直接对应于层次。
- en: The BFS algorithm starts from a root vertex and explores the vertices in the
    neighborhood vertices. It then moves to the next neighborhood level and repeats
    the process.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: BFS算法从根顶点开始，探索邻居顶点，然后移动到下一个邻居级别并重复这个过程。
- en: 'Let''s look at a BFS algorithm. For that, let''s first consider the following
    undirected graph:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个BFS算法。为此，让我们首先考虑以下无向图：
- en: '![](assets/6dcee5c9-ab3c-4e2a-b4c8-3263c2e84e65.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6dcee5c9-ab3c-4e2a-b4c8-3263c2e84e65.png)'
- en: 'Let''s start by calculating the immediate neighborhood of each vertex and store
    that in a list, called an **adjacency list**. In Python, we can use the dictionary
    data structure to store it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从计算每个顶点的直接邻居开始，并将其存储在一个称为**邻接表**的列表中。在Python中，我们可以使用字典数据结构来存储它：
- en: '[PRE6]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To implement it in Python, we proceed as follows.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python中实现它，我们按照以下步骤进行。
- en: We will first explain the initialization and then the main loop.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先解释初始化，然后是主循环。
- en: Initialization
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化
- en: 'We will use two data structures:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两种数据结构：
- en: '`visited`: This contains all the vertices that have been visited. Initially,
    it will be empty.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visited`：包含所有已经被访问的顶点。最初，它将是空的。'
- en: '`queue`: This contains all the vertices that we have want to visit in next
    iterations.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queue`：包含我们希望在下一次迭代中访问的所有顶点。'
- en: The main loop
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主循环
- en: Next, we will implement the main loop. It will keep on looping until there isn't
    even a single element in the queue. For each node in the queue, if it has already
    been visited, then it visits its neighbor.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现主循环。它将一直循环，直到队列中没有一个元素。对于队列中的每个节点，如果它已经被访问过，那么它就会访问它的邻居。
- en: 'We can implement this main loop in Python as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Python中实现这个主循环，如下所示：
- en: First, we pop the first node from the queue and choose that as current node
    of this iteration.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从队列中弹出第一个节点，并将其选择为此次迭代的当前节点。
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Then, we check that the node is not in the visited list. If it is not, we add
    it to the list of visited nodes and use neighbors to represent its directly connected
    nodes
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查节点是否不在已访问列表中。如果不在，我们将其添加到已访问节点的列表中，并使用邻居来表示其直接连接的节点
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we will add neighbours of nodes to the queue:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将节点的邻居添加到队列中：
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once the main loop is complete, the `visited` data structure is returned, which
    contains all the nodes traversed.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主循环完成后，将返回包含所有遍历节点的`visited`数据结构。
- en: 'The complete code, with both initialization and the main loop, will be as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整的代码，包括初始化和主循环，如下所示：
- en: '![](assets/9d040f20-0317-421b-a3a4-4006b3876f23.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9d040f20-0317-421b-a3a4-4006b3876f23.png)'
- en: 'Let''s look at the exhaustive search traversal pattern for the graph that we
    defined using BFS. To visit all the nodes, the traversal pattern is shown in the
    following figure. It can be observed that while executing, it always maintains
    two data structures:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看使用BFS定义的图的详尽搜索遍历模式。为了访问所有节点，遍历模式如下图所示。可以观察到，在执行过程中，它始终保持两种数据结构：
- en: '**Visited**: Contains all the nodes that have been visited'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已访问**：包含所有已经被访问的节点'
- en: '**Queue**: Contains nodes yet to be visited'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**队列**：包含尚未被访问的节点'
- en: 'Here''s how the algorithm works:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的工作原理如下：
- en: It starts from the first node, which is the only node, Amin, on level one.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从第一个节点开始，也就是第一级上唯一的节点Amin。
- en: Then, it moves to level two and visits all three nodes Wasim, Nick, and Mike
    one by one.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它移动到第二级，并依次访问所有三个节点Wasim、Nick和Mike。
- en: After that, it moves to level three and level four, which have only one node
    each, Imran and Faras.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它移动到第三级和第四级，每个级别只有一个节点，Imran和Faras。
- en: 'Once all the nodes have been visited, they are added to the Visited data structure
    and the iterations stop:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有节点都被访问，它们将被添加到已访问的数据结构中，迭代就会停止：
- en: '![](assets/893b3679-9fec-485a-9aca-0fd0ce2a31fe.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/893b3679-9fec-485a-9aca-0fd0ce2a31fe.png)'
- en: 'Now, let''s try to find a specific person from this graph using BFS. Let''s
    specify the data that we are searching for and observe the results:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用BFS从这个图中找到特定的人。让我们指定我们正在搜索的数据，并观察结果：
- en: '![](assets/34839db3-7779-44ae-83b1-9b59b4dbb427.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/34839db3-7779-44ae-83b1-9b59b4dbb427.png)'
- en: Now let's look into the depth-first search algorithm.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看深度优先搜索算法。
- en: Depth-first search
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度优先搜索
- en: DFS is the alternative to BFS, used to search data from a graph. The factor
    that differentiates DFS from BFS is that after starting from the root vertex,
    the algorithm goes down as far as possible in each of the unique single paths
    one by one. For each path, once it has successfully reached the ultimate depth,
    it flags all the vertices associated with that path as visited. After completing
    the path, the algorithm backtracks. If it can find another path from the root
    node that has yet to be visited, the algorithm repeats the previous process. The
    algorithm keeps on moving in the new branch until all the branches have been visited.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: DFS是BFS的替代方法，用于从图中搜索数据。将DFS与BFS区分开的因素是，在从根顶点开始后，算法会逐个沿着每条唯一的路径尽可能深入。对于每条路径，一旦成功到达最终深度，它就会标记所有与该路径相关的顶点为已访问。完成路径后，算法会回溯。如果它能找到另一条从根节点开始但尚未被访问的路径，算法会重复之前的过程。算法会在新分支中不断移动，直到所有分支都被访问。
- en: Note that a graph may have a cyclic method. As mentioned, we use a Boolean flag
    to keep track of the vertices that have been processed to avoid iterating in cycles.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，图可能具有循环方法。如前所述，我们使用布尔标志来跟踪已处理的顶点，以避免在循环中迭代。
- en: To implement DFS, we will use a stack data structure, which was discussed in
    detail in [Chapter 2](04672393-683c-406b-8dd1-4dab5b5d9c4f.xhtml), *Data Structures
    Used in Algorithms*. Remember that stack is based on the **Last In, First Out**
    (**LIFO**) principle. This contrasts with a queue, which was used for BFS, which
    works on the **First In, First Out** (**FIFO**) principal.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现DFS，我们将使用一个栈数据结构，这在[第2章](04672393-683c-406b-8dd1-4dab5b5d9c4f.xhtml)中已经详细讨论过，*算法中使用的数据结构*。请记住，栈是基于**后进先出**（**LIFO**）原则的。这与队列相反，队列用于BFS，它基于**先进先出**（**FIFO**）原则。
- en: 'The following code is used for DFS:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于DFS：
- en: '[PRE10]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s again use the following code to test the `dfs` function defined previously:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用以下代码来测试先前定义的`dfs`函数：
- en: '[PRE11]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we run this algorithm, the output will look like the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个算法，输出将如下所示：
- en: '![](assets/1b3b2daa-64c0-4336-aa9b-fddeed85cc08.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1b3b2daa-64c0-4336-aa9b-fddeed85cc08.png)'
- en: 'Let''s look at the exhaustive traversal pattern of this graph using the DFS
    methodology:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用DFS方法来查看这个图的详尽遍历模式：
- en: The iteration starts from the top node, Amin.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代从顶部节点Amin开始。
- en: Then, it moves to level two, Wasim. From there, it moves toward the lower levels
    until it reaches the end, which is the Imran and Fares nodes.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它移动到第二级，Wasim。从那里，它向下一级移动，直到达到末端，即Imran和Fares节点。
- en: After completing the first full branch, it backtracks and then goes to level
    two to visit Nick and Mike.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成第一个完整分支后，它回溯然后到达第二级访问Nick和Mike。
- en: 'The traversal pattern is shown in the following figure:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历模式如下图所示：
- en: '![](assets/59e2f789-6a1c-490e-9f89-eaf09155d5a7.png)Note that DFS can be used
    in trees as well.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/59e2f789-6a1c-490e-9f89-eaf09155d5a7.png)请注意，DFS也可以用于树。'
- en: Let's now look at a case study, which explains how the concepts we have discussed
    so far in this chapter can be used to solve a real-world problem.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个案例研究，解释了本章迄今为止讨论的概念如何用于解决现实世界的问题。
- en: Case study – fraud analytics
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究 - 欺诈分析
- en: Let's look at how we can use SNA to detect fraud. With humans being social animals,
    human behavior is said to be affected by the people that you are surrounded by.
    The word **homophily** has been coined to represent the effect their social network
    has on a person. Extending this concept, a **homophilic network** is a group of
    people who are likely to be associated with each other due to some common factor;
    for example, having the same origin or hobbies, being part of the same gang or
    the same university, or some combination of other factors.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用SNA来检测欺诈。人类是社会动物，人的行为据说受到周围的人的影响。**同质性**一词被创造出来代表他们的社交网络对一个人的影响。扩展这个概念，**同质网络**是一群人，他们由于某些共同因素而可能与彼此关联；例如，具有相同的起源或爱好，是同一个团伙或同一个大学的一部分，或其他因素的组合。
- en: If we want to analyze fraud in a homophilic network, we can take advantage of
    the relationships between the person under investigation and other people in the
    network, whose risk of involvement in fraud has already been carefully calculated.
    Flagging a person due to their company is sometimes also called **guilt by association**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在同质网络中分析欺诈，我们可以利用调查对象与网络中其他人之间的关系，这些人已经仔细计算了他们参与欺诈的风险。有时因为某人的公司而标记一个人也被称为**因陋就寡**。
- en: In an effort to understand the process, let's first look at a simple case. For
    that, let's use a network with nine vertices and eight edges. In this network,
    four of the vertices are known fraud cases and are classified as **fraud** (**F**).
    Five of the remaining people have no fraud-related history and are classified
    as **non-fraud** (**NF**).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个过程，让我们首先看一个简单的案例。为此，让我们使用一个具有九个顶点和八条边的网络。在这个网络中，有四个顶点是已知的欺诈案例，并被分类为**fraud**
    (**F**)。剩下的五个人中有五个没有欺诈相关历史，被分类为**non-fraud** (**NF**)。
- en: 'We will write a code with the following steps to generate this graph:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写以下步骤的代码来生成这个图表：
- en: 'Let''s import the packages that we need:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们导入我们需要的包：
- en: '[PRE12]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Define the data structures of `vertices` and `edges`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`vertices`和`edges`的数据结构：
- en: '[PRE13]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s first instantiate the graph:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先实例化图表：
- en: '[PRE14]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s draw the graph:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们绘制图表：
- en: '[PRE15]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s define the NF nodes:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义NF节点：
- en: '[PRE16]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s create the nodes that are known to be involved in fraud:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建已知涉及欺诈的节点：
- en: '[PRE17]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s create labels for the nodes:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为节点创建标签：
- en: '[PRE18]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once the preceding code runs, it will show us a graph like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦前面的代码运行，它将显示出一个这样的图：
- en: '![](assets/55d197c0-472b-4400-92b0-b8167092bbaf.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/55d197c0-472b-4400-92b0-b8167092bbaf.png)'
- en: 'Note that we have already conducted detailed analysis to classify each node
    as a graph or non-graph. Let''s assume that we add another vertex, named *q*,
    to the network, as shown in the following figure. We have no prior information
    about this person and whether this person is involved in fraud or not. We want
    to classify this person as **NF** or **F** based on their links to the existing
    members of the social network:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经进行了详细的分析，将每个节点分类为图或非图。假设我们在网络中添加另一个名为*q*的顶点，如下图所示。我们对这个人没有先前的信息，也不知道这个人是否涉及欺诈。我们希望根据他们与社交网络中现有成员的联系来将这个人分类为**NF**或**F**：
- en: '![](assets/f2576c00-932c-4b05-8d36-905dca88d809.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f2576c00-932c-4b05-8d36-905dca88d809.png)'
- en: 'We have devised two ways to classify this new person, represented by node *q*,
    as **F** or **NF**:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设计了两种方法来对代表节点*q*的新人进行分类，分为**F**或**NF**：
- en: Using a simple method that does not use centrality metrics and additional information
    about the type of fraud
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一种不使用中心性指标和有关欺诈类型的附加信息的简单方法
- en: Using a watchtower methodology, which is an advanced technique that uses the
    centrality metrics of the existing nodes, as well as additional information about
    the type of fraud
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用了一个名为“瞭望塔”的方法，这是一种先进的技术，利用了现有节点的中心性指标，以及有关欺诈类型的其他信息
- en: We will discuss each method in detail.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细讨论每种方法。
- en: Conducting simple fraud analytics
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行简单的欺诈分析
- en: The simple technique of fraud analytics is based on the assumption that in a
    network, the behaviour of a person is affected by the people they are connected
    to. In a network, two vertices are more likely to have similar behaviour if they
    are associated with each other.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 欺诈分析的简单技术是基于这样一个假设：在一个网络中，一个人的行为受到他们所连接的人的影响。在一个网络中，如果两个顶点与彼此相关联，那么它们更有可能具有相似的行为。
- en: 'Based on this assumption, we devise a simple technique. If we want to find
    the probability that a certain node, *a*, belongs to *F*, the probability is represented
    by *P(F/q)* and is calculated as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一假设，我们设计了一种简单的技术。如果我们想找到某个节点*a*属于*F*的概率，概率表示为*P(F/q)*，计算如下：
- en: '![](assets/3512cfbb-df1e-45a6-bd57-f2ae7510a22f.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3512cfbb-df1e-45a6-bd57-f2ae7510a22f.png)'
- en: 'Let''s apply this to the preceding figure, where *Neighborhood[n]* represents
    the neighborhood of vertex *n* and *w(n, nj)* represents the weight of the connection
    between *n* and *n**j*. Also, *degree[q]*  is the degree of node *q*. Then, the
    probability is calculated as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这应用到前面的图中，其中*Neighborhood[n]*代表顶点*n*的邻域，*w(n, nj)*代表*n*和*n**j*之间连接的权重。此外，*degree[q]*是节点*q*的度。然后，概率计算如下：
- en: '![](assets/24479db6-04d6-4f69-a4b1-6bad70aa647c.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/24479db6-04d6-4f69-a4b1-6bad70aa647c.png)'
- en: Based on this analysis, the likelihood of this person being involved in fraud
    is 67%. We need to set a threshold. If the threshold is 30%, then this person
    is above the threshold value and we can safely flag them as F.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个分析，这个人涉及欺诈的可能性为67%。我们需要设定一个阈值。如果阈值为30%，那么这个人就高于阈值，我们可以安全地标记他们为F。
- en: Note that this process needs to be repeated for each of the new nodes in the
    network.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个过程需要针对网络中的每个新节点重复进行。
- en: Now, let's look at an advanced way of conducting fraud analytics.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一种进行欺诈分析的高级方法。
- en: Presenting the watchtower fraud analytics methodology
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍了瞭望塔欺诈分析方法
- en: 'The previous, simple fraud analytics technique has the following two limitations:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的简单欺诈分析技术有以下两个限制：
- en: It does not evaluate the importance of each vertex in the social network. A
    connection to a hub that is involved in fraud may have different implications
    than a relationship with a remote, isolated person.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不评估社交网络中每个顶点的重要性。与涉及欺诈的中心的联系可能与与一个远离的孤立个人的关系有不同的含义。
- en: When labeling someone as a known case of fraud in an existing network, we do
    not consider the severity of the crime.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在现有网络中将某人标记为已知的欺诈案例时，我们不考虑犯罪的严重程度。
- en: The watchtower fraud analytics methodology addresses these two limitations.
    First, let's look at a couple of concepts.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 瞭望塔欺诈分析方法解决了这两个限制。首先，让我们看一些概念。
- en: Scoring negative outcomes
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评分负面结果
- en: If a person is known to be involved in fraud, we say that there is a negative
    outcome associated with this individual. Not every negative outcome is of the
    same severity or seriousness. A person known to be impersonating another person
    will have a more serious type of negative outcome associated with them, compared
    to someone who is just trying to use an expired $20 gift card, in an innovative
    way to make it valid.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个人已知涉及欺诈，我们说与这个人相关联的是一个负面结果。并非每个负面结果的严重程度或严肃程度都相同。一个已知冒充另一个人的人将会有一个更严重类型的负面结果与他们相关联，而不仅仅是试图以创新的方式使用过期的20美元礼品卡使其有效的人。
- en: 'From a score of 1 to 10, we rate various negative outcomes as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 从1到10的评分中，我们对各种负面结果进行如下评分：
- en: '| **Negative outcome** | **Negative outcome score** |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| **负面结果** | **负面结果分数** |'
- en: '| Impersonation | 10 |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 冒充 | 10 |'
- en: '| Involvement in credit card theft | 8 |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: 涉及信用卡盗窃 | 8 |
- en: '| Fake check submission | 7 |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 假支票提交 | 7 |'
- en: '| Criminal record | 6 |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 犯罪记录 | 6 |'
- en: '| No record | 0 |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: 无记录 | 0 |
- en: Note that these scores will be based on our analysis of fraud cases and their
    impact from historical data.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些分数将基于我们对欺诈案例及其在历史数据中的影响的分析。
- en: Degree of suspicion
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 怀疑程度
- en: The **degree of suspicion** (**DOS**) quantifies our level of suspicion that
    a person may be involved in fraud. A DOS value of 0 means that this is a low-risk
    person and a DOS value of 9 means that this is a high-risk person.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**怀疑程度**（DOS）量化了我们对一个人可能涉及欺诈的程度。DOS值为0意味着这是一个低风险的人，DOS值为9意味着这是一个高风险的人。'
- en: Analysis of historical data shows that professional fraudsters have important
    positions in their social networks. To incorporate this, first we calculate all
    of the four centrality metrics of each vertex in our network. We then take the
    average of these vertices. This translates to the importance of that particular
    person in the network.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对历史数据的分析显示，专业的欺诈者在他们的社交网络中拥有重要的地位。为了纳入这一点，首先我们计算网络中每个顶点的四个中心度指标。然后我们取这些顶点的平均值。这反映了该特定人在网络中的重要性。
- en: If a person associated with a vertex is involved in fraud, we illustrate this
    negative outcome by scoring the person using the pre-determined values shown in
    the preceding table. This is done so that the severity of the crime is reflected
    in the value of each individual DOS.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与一个顶点相关联的人涉及欺诈，我们将使用前面表格中显示的预先确定的值对这个人进行评分，以反映犯罪的严重程度。
- en: Finally, we multiply the average of the centrality metrics and the negative
    outcome score to get the value of the DOS. We normalize the DOS by dividing it
    by the maximum value of the DOS in the network.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将中心度指标的平均值和负面结果分数相乘，得到DOS的值。我们通过将其除以网络中DOS的最大值来标准化DOS。
- en: 'Let''s calculate the DOS for each of the nine nodes in the previous network:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们计算前一个网络中每个九个节点的DOS：
- en: '|  | **Node 1** | **Node 2** | **Node 3** | **Node 4** | **Node 5** | **Node
    6** | **Node 7** | **Node 8** | **Node 9** |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '|  | **节点1** | **节点2** | **节点3** | **节点4** | **节点5** | **节点6** | **节点7** |
    **节点8** | **节点9** |'
- en: '| Degree of centrality | 0.25 | 0.5 | 0.25 | 0.25 | 0.25 | 0.13 | 0.63 | 0.13
    | 0.13 |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 中心度度 | 0.25 | 0.5 | 0.25 | 0.25 | 0.25 | 0.13 | 0.63 | 0.13 | 0.13 |'
- en: '| Betweenness | 0.25 | 0.47 | 0 | 0 | 0 | 0 | 0.71 | 0 | 0 |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 中介中心度 | 0.25 | 0.47 | 0 | 0 | 0 | 0 | 0.71 | 0 | 0 |'
- en: '| Closeness | 0.5 | 0.61 | 0.53 | 0.47 | 0.47 | 0.34 | 0.72 | 0.4 | 0.4 |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 接近中心度 | 0.5 | 0.61 | 0.53 | 0.47 | 0.47 | 0.34 | 0.72 | 0.4 | 0.4 |'
- en: '| Eigenvector | 0.24 | 0.45 | 0.36 | 0.32 | 0.32 | 0.08 | 0.59 | 0.16 | 0.16
    |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 特征向量 | 0.24 | 0.45 | 0.36 | 0.32 | 0.32 | 0.08 | 0.59 | 0.16 | 0.16 |'
- en: '| Average of centrality Metrics | 0.31 | 0.51 | 0.29 | 0.26 | 0.26 | 0.14 |
    0.66 | 0.17 | 0.17 |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 中心度指标的平均值 | 0.31 | 0.51 | 0.29 | 0.26 | 0.26 | 0.14 | 0.66 | 0.17 | 0.17
    |'
- en: '| Negative outcome score | 0 | 6 | 0 | 0 | 7 | 8 | 10 | 0 | 0 |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 负面结果分数 | 0 | 6 | 0 | 0 | 7 | 8 | 10 | 0 | 0 |'
- en: '| DOS | 0 | 3 | 0 | 0 | 1.82 | 1.1 | 6.625 | 0 | 0 |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| DOS | 0 | 3 | 0 | 0 | 1.82 | 1.1 | 6.625 | 0 | 0 |'
- en: '| Normalized DOS | 0 | 0.47 | 0 | 0 | 0.27 | 0.17 | 1 | 0 | 0 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 标准化DOS | 0 | 0.47 | 0 | 0 | 0.27 | 0.17 | 1 | 0 | 0 |'
- en: 'Each of the nodes and their normalized DOS is shown in the following figure:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了每个节点及其标准化DOS：
- en: '![](assets/30b77bac-79b9-4ef2-9bea-a627c4982bea.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/30b77bac-79b9-4ef2-9bea-a627c4982bea.png)'
- en: 'In order to calculate the DOS of the new node that has been added, we will
    use the following formula:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算已添加的新节点的DOS，我们将使用以下公式：
- en: '![](assets/b49b7849-b828-4aea-9d55-63519ba02edb.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b49b7849-b828-4aea-9d55-63519ba02edb.png)'
- en: 'Using the relevant values, we will calculate the DOS as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相关数值，我们将按如下计算DOS：
- en: '![](assets/14d3681c-ee75-4ca6-8cd5-fb10141e3038.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/14d3681c-ee75-4ca6-8cd5-fb10141e3038.png)'
- en: 'This will indicate the risk of fraud associated with this new node added to
    the system. It means that on a scale of 0 to 1, this person has a DOS value of
    0.42\. We can create different risk bins for the DOS, as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示与系统中添加的新节点相关的欺诈风险。这意味着在0到1的范围内，这个人的DOS值为0.42。我们可以为DOS创建不同的风险区间，如下所示：
- en: '| **Value of the DOS** | **Risk classification** |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| **DOS的值** | **风险分类** |'
- en: '| DOS = 0 | No risk |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: DOS = 0 | 无风险
- en: '| 0<DOS<=0.10 | Low risk |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 0<DOS<=0.10 | 低风险 |'
- en: '| 0.10<DOS<=0.3 | Medium risk |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 0.10<DOS<=0.3 | 中等风险 |'
- en: '| DOS>0.3 | High risk |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| DOS>0.3 | 高风险 |'
- en: Based on these criteria, it can be seen that the new individual is a high-risk
    person and should be flagged.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些标准，可以看出新个体是高风险人员，应该被标记。
- en: Usually, a time dimension is not involved when conducting such an analysis.
    But now, there are some advanced techniques that look at the growth of a graph
    as time progresses. This allows researchers to look at the relationship between
    vertices as the network evolves. Although such time-series analysis on graphs
    will increase the complexity of the problem by many times, it may give additional
    insight into the evidence of fraud that was not possible otherwise.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在进行这种分析时不涉及时间维度。但现在，有一些先进的技术可以在图的增长随时间推移时进行分析。这使研究人员能够观察网络演化时顶点之间的关系。尽管图的时间序列分析会使问题的复杂性增加许多倍，但它可能会提供对欺诈证据的额外见解，否则是不可能的。
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about graph-based algorithms. After going through
    this chapter, I expect that we should be able to use different techniques of representing,
    searching, and processing data represented as graphs. We also developed skills
    to be able to calculate the shortest distance between two vertices and we built
    neighborhoods in our problem space. This knowledge should help us use graph theory
    to address problems such as fraud detection.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了基于图的算法。经过本章的学习，我希望我们能够使用不同的技术来表示、搜索和处理以图形表示的数据。我们还开发了能够计算两个顶点之间的最短距离并在问题空间中构建邻域的技能。这些知识应该帮助我们使用图论来解决诸如欺诈检测之类的问题。
- en: In the next chapter, we will focus on different unsupervised machine learning
    algorithms. Many of the use-case techniques discussed in this chapter complement
    unsupervised learning algorithms, which will be discussed in detail in the next
    chapter. Finding evidence of fraud in a dataset is an example of such use cases.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于不同的无监督机器学习算法。本章讨论的许多用例技术与无监督学习算法相辅相成，这将在下一章中详细讨论。在数据集中找到欺诈证据就是这样的用例示例。
