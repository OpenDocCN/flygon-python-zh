- en: Fixtures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fixtures
- en: In the previous chapter, we learned how to use marks and parametrization effectively
    to skip tests, mark them as expected to fail, and parameterize them, to avoid
    repetition.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何有效地使用标记和参数化来跳过测试，将其标记为预期失败，并对其进行参数化，以避免重复。
- en: 'Tests in the real world often need to create resources or data to work on:
    a temporary directory to output some files to, a database connection to test the
    I/O layer of an application, a web server for integration testing. Those are all
    examples of resources that are required in more complex testing scenarios. More
    complex resources often need to be cleaned up at the end of the test session:
    removing a temporary directory, cleaning up and disconnecting from a database,
    shutting down a web server. Also, these resources should be easily shared across
    tests, because during testing we often need to reuse a resource for different
    test scenarios. Some resources are costly to create, but because they are immutable
    or can be restored to a pristine state, they should be created only once and shared
    with all the tests that require it, only being destroyed when the last test that
    needs them finishes.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界中的测试通常需要创建资源或数据来进行操作：一个临时目录来输出一些文件，一个数据库连接来测试应用程序的I/O层，一个用于集成测试的Web服务器。这些都是更复杂的测试场景中所需的资源的例子。更复杂的资源通常需要在测试会话结束时进行清理：删除临时目录，清理并断开与数据库的连接，关闭Web服务器。此外，这些资源应该很容易地在测试之间共享，因为在测试过程中我们经常需要为不同的测试场景重用资源。一些资源创建成本很高，但因为它们是不可变的或者可以恢复到原始状态，所以应该只创建一次，并与需要它的所有测试共享，在最后一个需要它们的测试完成时销毁。
- en: All of the previous requirements and more are covered by one of the most important
    of pytest's features: **fixtures**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: pytest最重要的功能之一是覆盖所有先前的要求和更多内容。
- en: 'Here''s what we will cover in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下内容：
- en: Introducing fixtures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入fixtures
- en: Sharing fixtures with `conftest.py` files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`conftest.py`文件共享fixtures
- en: Scopes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域
- en: Autouse
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动使用
- en: Parametrization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化
- en: Using marks from fixtures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fixtures中的标记
- en: An overview of built-in fixtures
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置fixtures概述
- en: Tips/discussion
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示/讨论
- en: Introducing fixtures
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入fixtures
- en: 'Most tests need some kind of data or resource to operate on:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数测试需要某种数据或资源来操作：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we have a list of (`series name`, `year`, `rating`) tuples that we use
    to test the `highest_rated` function. Inlining data into the test code as we do
    here works well for isolated tests, but often you have a dataset that can be used
    by multiple tests. One solution would be to copy over the dataset to each test:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个(`series name`, `year`, `rating`)元组的列表，我们用它来测试`highest_rated`函数。在这里将数据内联到测试代码中对于孤立的测试效果很好，但通常你会有一个可以被多个测试使用的数据集。一种解决方法是将数据集复制到每个测试中：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: But this gets old quickly—plus, copying  and pasting things around will hurt
    maintainability in the long run, for example, if the data layout changes (adding
    a new item to the tuple or the cast size, for example).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但这很快就会变得老套—此外，复制和粘贴东西会在长期内影响可维护性，例如，如果数据布局发生变化（例如，添加一个新项目到元组或演员阵容大小）。
- en: Enter fixtures
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入fixtures
- en: Pytest's solution to this problem is fixtures. Fixtures are used to provide
    resources that test the functions and methods we need to execute.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: pytest对这个问题的解决方案是fixtures。fixtures用于提供测试所需的函数和方法。
- en: 'They are created using normal Python functions and the `@pytest.fixture` decorator:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是使用普通的Python函数和`@pytest.fixture`装饰器创建的：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are creating a fixture named `comedy_series`, which returns the same
    list we were using in the previous section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`comedy_series`的fixture，它返回我们在上一节中使用的相同列表。
- en: 'Tests can access fixtures by declaring the fixture name in their parameter
    list. The test function then receives the return value of the fixture function
    as a parameter. Here is the `comedy_series` fixture in action:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以通过在其参数列表中声明fixture名称来访问fixtures。然后测试函数会接收fixture函数的返回值作为参数。这里是`comedy_series`
    fixture的使用：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here''s how things work:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 事情是这样的：
- en: 'Pytest looks at the test function parameters before calling it. Here, we have
    one parameter: `comedy_series`.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pytest在调用测试函数之前查看测试函数的参数。这里，我们有一个参数：`comedy_series`。
- en: For each parameter, pytest gets the fixture function of same name and executes
    it.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个参数，pytest获取相同名称的fixture函数并执行它。
- en: The return value of each fixture function becomes a named parameter, and the
    test function is called.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个fixture函数的返回值成为一个命名参数，并调用测试函数。
- en: Note that `test_highest_rated` and `test_oldest` each get their own copy of
    the comedy series list, so they don't risk interfering with each other if they
    change the list inside the test.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`test_highest_rated`和`test_oldest`各自获得喜剧系列列表的副本，因此如果它们在测试中更改列表，它们不会相互干扰。
- en: 'It is also possible to create fixtures in classes using methods:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用方法在类中创建fixtures：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Fixtures defined in test classes are only accessible by test methods of the
    class or subclasses:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试类中定义的fixtures只能被类或子类的测试方法访问：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that test classes might have other non-test methods, like any other class.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，测试类可能有其他非测试方法，就像任何其他类一样。
- en: Setup/teardown
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置/拆卸
- en: As we've seen in the introduction, it is very common for resources that are
    used in testing to require some sort of clean up after a test is done with them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍中看到的，测试中使用的资源通常需要在测试完成后进行某种清理。
- en: In our previous example, we had a very small dataset, so inlining it in the
    fixture was fine. Suppose however that we have a much larger dataset (say, 1,000
    entries), so writing it in the code would hurt readability. Often, the dataset
    is in an external file, for example, in CSV format, so porting it into the Python
    code is a pain.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们有一个非常小的数据集，所以在fixture中内联它是可以的。然而，假设我们有一个更大的数据集（比如，1000个条目），那么在代码中写入它会影响可读性。通常，数据集在外部文件中，例如CSV格式，因此将其移植到Python代码中是一件痛苦的事情。
- en: A solution to that would be to commit the CSV file containing the series dataset
    into the repository and read it inside the test, using the built-in `csv` module;
    for more details go to [https://docs.python.org/3/library/csv.html](https://docs.python.org/3/library/csv.html).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是将包含系列数据集的CSV文件提交到存储库中，并在测试中使用内置的`csv`模块进行读取；有关更多详细信息，请访问[https://docs.python.org/3/library/csv.html](https://docs.python.org/3/library/csv.html)。
- en: 'We can change the `comedy_series` fixture to do just that:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更改`comedy_series` fixture来实现这一点：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This works, but we, being diligent developers, want to be able to close that
    file properly. How can we do that with fixtures?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是有效的，但是我们作为认真的开发人员，希望能够正确关闭该文件。我们如何使用fixtures做到这一点呢？
- en: 'Fixture clean up is often referred to as **teardown**, and it is easily supported
    using the `yield` statement:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Fixture清理通常被称为**teardown**，并且可以使用`yield`语句轻松支持：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By using  `yield` instead of `return`, this is what happens:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`yield`而不是`return`，会发生以下情况：
- en: The fixture function is called
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fixture函数被调用
- en: It executes until the yield statement, where it pauses and yields the fixture
    value
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它执行直到yield语句，其中暂停并产生fixture值
- en: The test executes, receiving the fixture value as parameter
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试执行，接收fixture值作为参数
- en: Regardless of whether the test passes or fails, the function is resumed so it
    can perform its teardown actions
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论测试是否通过，函数都会恢复执行，以执行其清理操作
- en: For those familiar with it, this is very similar to a **context manager** ([https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager](https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager)),
    except that you don't need to surround the yield statement with a try/except clause
    to ensure the block after yield is executed, even if an exception occurs.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉它的人来说，这与**上下文管理器**（[https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager](https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager)）非常相似，只是您不需要用try/except子句将yield语句包围起来，以确保在发生异常时仍执行yield后的代码块。
- en: 'Let''s return to our example; we can now use  `yield` instead of `return` and
    close the file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的例子；现在我们可以使用`yield`而不是`return`并关闭文件：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is good, but notice that because `yield` works well with the `with` statement
    of the file object, we can write this instead:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但请注意，因为`yield`与文件对象的`with`语句配合得很好，我们可以这样写：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The file will be closed automatically by the `with` statement after the test
    completes, which is shorter and considered more Pythonic.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完成后，`with`语句会自动关闭文件，这更短，被认为更符合Python风格。
- en: Awesome.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。
- en: Composability
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可组合性
- en: Suppose we receive a new series.csv file that now contains a much larger number
    of TV series, including the comedy series we had before and many other genres
    as well. We want to use this new data for some other tests, but we would like
    to keep existing tests working as they did previously.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们收到一个新的series.csv文件，其中包含更多的电视系列，包括以前的喜剧系列和许多其他类型。我们希望为一些其他测试使用这些新数据，但我们希望保持现有的测试与以前一样工作。
- en: 'Fixtures in pytest can easily depend on other fixtures just by declaring them
    as parameters. Using this property, we are able to create a new series fixture
    that reads all the data from `series.csv` (which now contains more genres), and
    change our `comedy_series` fixture to filter out only comedy series:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在pytest中，fixture可以通过声明它们为参数轻松依赖于其他fixtures。利用这一特性，我们能够创建一个新的series fixture，从`series.csv`中读取所有数据（现在包含更多类型），并将我们的`comedy_series`
    fixture更改为仅过滤出喜剧系列：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The tests which use `comedy_series` are unchanged:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`comedy_series`的测试保持不变：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that, because of those characteristics, fixtures are a prime example of
    dependency injection, which is a technique where a function or an object declares
    its dependencies, but otherwise doesn't know or care how those dependencies will
    be created, or by who. This makes them extremely modular and reusable.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于这些特性，fixtures是依赖注入的一个典型例子，这是一种技术，其中函数或对象声明其依赖关系，但否则不知道或不关心这些依赖关系将如何创建，或者由谁创建。这使它们非常模块化和可重用。
- en: Sharing fixtures with conftest.py files
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用conftest.py文件共享fixtures
- en: Suppose we need to use our `comedy_series` fixture from the previous section
    in other test modules. In pytest, sharing fixtures is easily done by just moving
    the fixture code to a `conftest.py` file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要在其他测试模块中使用前一节中的`comedy_series` fixture。在pytest中，通过将fixture代码移动到`conftest.py`文件中，可以轻松共享fixtures。
- en: 'A `conftest.py` file is a normal Python module, except that it is loaded automatically
    by pytest, and any fixtures defined in it are available to test modules in the
    same directory and below automatically. Consider this test module hierarchy:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`conftest.py`文件是一个普通的Python模块，只是它会被pytest自动加载，并且其中定义的任何fixtures都会自动对同一目录及以下的测试模块可用。考虑一下这个测试模块的层次结构：'
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `tests/conftest.py` file is at the root of the hierarchy, so any fixtures
    defined on it are automatically available to all other test modules in this project.
    Fixtures in `tests/io/conftest.py` will be available only to modules at and below
    `tests/io`, so only to `test_formats.py` for now.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests/conftest.py`文件位于层次结构的根目录，因此在该项目中，任何在其中定义的fixtures都会自动对所有其他测试模块可用。在`tests/io/conftest.py`中定义的fixtures将仅对`tests/io`及以下模块可用，因此目前仅对`test_formats.py`可用。'
- en: 'This might not look like a big deal, but it makes sharing fixtures a breeze:
    it is very liberating to be able to start small with just a few fixtures when
    writing a test module, knowing that if those fixtures are useful to other tests
    in the future, it will be just a small matter of moving the fixtures to a `conftest.py` to
    reuse them. This avoids the temptation to copy and paste test data around, or
    to spend too much time thinking about how to organize test-supporting code from
    the start, to avoid  having to do a lot of refactoring later.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不像什么大不了的事，但它使共享fixtures变得轻而易举：当编写测试模块时，能够从小处开始使用一些fixtures，知道如果将来这些fixtures对其他测试有用，只需将fixtures移动到`conftest.py`中即可。这避免了复制和粘贴测试数据的诱惑，或者花费太多时间考虑如何从一开始组织测试支持代码，以避免以后进行大量重构。
- en: Scopes
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: Fixtures are always created when a test function requests them, by declaring
    them on the parameter list, as we've seen already. By default, each fixture is
    destroyed when each test finishes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 夹具总是在测试函数请求它们时创建的，通过在参数列表上声明它们，就像我们已经看到的那样。默认情况下，每个夹具在每个测试完成时都会被销毁。
- en: 'As mentioned at the beginning of this chapter, some fixtures can be costly
    to create or set up, and it would be helpful to be able to create as few instances
    of it as possible, to save time. Here are some examples:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头提到的，一些夹具可能很昂贵，需要创建或设置，因此尽可能少地创建实例将非常有帮助，以节省时间。以下是一些示例：
- en: Initializing database tables
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化数据库表
- en: Reading cached data from a disk, for example, large CSV data
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，从磁盘读取缓存数据，大型CSV数据
- en: Starting up external services
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动外部服务
- en: To help solve this issue, fixtures in pytest can have different **scopes**.
    The scope of a fixture defines when the fixture should be cleaned up. While the
    fixture is not cleaned up, tests requesting the fixture will receive the same
    fixture value.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，pytest中的夹具可以具有不同的**范围**。夹具的范围定义了夹具应该在何时清理。在夹具没有清理的情况下，请求夹具的测试将收到相同的夹具值。
- en: 'The scope parameter of the @pytest.fixture decorator is used to set the fixture''s
    scope:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`@pytest.fixture`装饰器的范围参数用于设置夹具的范围：'
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following scopes are available:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下范围可用：
- en: '`scope="session"`: fixture is teardown when all tests finish.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scope="session"`：当所有测试完成时，夹具被拆除。'
- en: '`scope="module"`: fixture is teardown when the last test function of a module
    finishes.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scope="module"`：当模块的最后一个测试函数完成时，夹具被拆除。'
- en: '`scope="class"`: fixture is teardown when the last test method of a class finishes.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scope="class"`：当类的最后一个测试方法完成时，夹具被拆除。'
- en: '`scope="function"`: fixture is teardown when the test function requesting it
    finishes. This is the default.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scope="function"`：当请求它的测试函数完成时，夹具被拆除。这是默认值。'
- en: It is important to emphasize that, regardless of scope, each fixture will be
    created only when a test function requires it. For example, session-scoped fixtures
    are not necessarily created at the start of the session, but only when the first
    test that requests it is about to be called. This makes sense when you consider
    that not all tests might need a session-scoped fixture, and there are various
    forms to run only a subset of tests, as we have seen in previous chapters.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要强调，无论范围如何，每个夹具都只会在测试函数需要它时才会被创建。例如，会话范围的夹具不一定会在会话开始时创建，而是只有在第一个请求它的测试即将被调用时才会创建。当考虑到并非所有测试都可能需要会话范围的夹具，并且有各种形式只运行一部分测试时，这是有意义的，正如我们在前几章中所看到的。
- en: Scopes in action
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围的作用
- en: To show scopes in action, let's take a look at a common pattern that's used
    when your tests involve some form of database. In the upcoming example, don't
    focus on the database API (which is made up anyway), but on the concepts and design
    of the fixtures involved.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示作用域，让我们看一下在测试涉及某种数据库时使用的常见模式。在即将到来的示例中，不要关注数据库API（无论如何都是虚构的），而是关注涉及的夹具的概念和设计。
- en: Usually, the connection to a database and table creation are slow. If the database
    supports transactions, which is the ability to perform a set of changes that can
    be applied or discarded atomically, then the following pattern can be used.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，连接到数据库和表的创建都很慢。如果数据库支持事务，即执行可以原子地应用或丢弃的一组更改的能力，那么可以使用以下模式。
- en: 'For starters, we can use a session-scoped fixture to connect and initialize
    the database with the tables we need:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以使用会话范围的夹具连接和初始化我们需要的表的数据库：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that we prune the test database and disconnect from it at the end of the
    fixture, which will happen at the end of the session.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们会在夹具结束时修剪测试数据库并断开与其的连接，这将在会话结束时发生。
- en: 'With the `db` fixture, we can share the same database across all our tests.
    This is great, because it saves time. But it also has the downside that now tests
    can change the database and affect other tests. To solve that problem, we create
    a transaction fixture that starts a new transaction before a test starts and rolls
    the transaction back when the test finishes, ensuring the database returns to
    its previous state:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`db`夹具，我们可以在所有测试中共享相同的数据库。这很棒，因为它节省了时间。但它也有一个缺点，现在测试可以更改数据库并影响其他测试。为了解决这个问题，我们创建了一个事务夹具，在测试开始之前启动一个新的事务，并在测试完成时回滚事务，确保数据库返回到其先前的状态：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Note that our transaction fixture depends on `db`. Tests now can use the transaction
    fixture to read and write to the database at will, without worrying about cleaning
    it up for other tests:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的事务夹具依赖于`db`。现在测试可以使用事务夹具随意读写数据库，而不必担心为其他测试清理它：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With just these two fixtures, we have a very solid foundation to write our
    database tests with: the first test that requires the transaction fixture will
    automatically initialize the database through the `db` fixture, and each test
    from now on that needs to perform transactions will do so from a pristine database.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个夹具，我们就有了一个非常坚实的基础来编写我们的数据库测试：需要事务夹具的第一个测试将通过`db`夹具自动初始化数据库，并且从现在开始，每个需要执行事务的测试都将从一个原始的数据库中执行。
- en: This composability between fixtures of different scopes is very powerful and
    enables all sorts of clever designs in real-world test suites.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 不同范围夹具之间的可组合性非常强大，并且使得在现实世界的测试套件中可以实现各种巧妙的设计。
- en: Autouse
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动使用
- en: It is possible to apply a fixture to all of the tests in a hierarchy, even if
    the tests don't explicitly request a fixture, by passing `autouse=True` to the
    `@pytest.fixture` decorator. This is useful when we need to apply a side-effect
    before and/or after each test unconditionally.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将`autouse=True`传递给`@pytest.fixture`装饰器，将夹具应用于层次结构中的所有测试，即使测试没有明确请求夹具。当我们需要在每个测试之前和/或之后无条件地应用副作用时，这是有用的。
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'An autouse fixture is applied to all tests which the fixture is available for
    use with:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 自动使用的夹具适用于夹具可供使用的所有测试：
- en: Same module as the fixture
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与夹具相同的模块
- en: Same class as the fixture, in the case of a fixture defined by a method
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在方法定义的情况下，与装置相同的类。
- en: Tests in the same directory or below, if the fixture is defined in a `conftest.py`
    file
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果装置在`conftest.py`文件中定义，那么在相同目录或以下目录中的测试
- en: In other words, if a test can access an autouse fixture by declaring it in the
    parameter list, the autouse fixture will be automatically used by that test. Note
    that it is possible for a test function to add the autouse fixture to its parameter
    list if it is interested in the return value of the fixture, as normal.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果一个测试可以通过在参数列表中声明它来访问一个`autouse`装置，那么该测试将自动使用`autouse`装置。请注意，如果测试函数对装置的返回值感兴趣，它可能会将`autouse`装置添加到其参数列表中，就像正常情况一样。
- en: '@pytest.mark.usefixtures'
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@pytest.mark.usefixtures'
- en: The `@pytest.mark.usefixtures` mark can be used to apply one or more fixtures
    to tests, as if they have the fixture name declared in their parameter list. This
    can be an alternative in situations where you want all tests in a group to always
    use a fixture that is not `autouse`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`@pytest.mark.usefixtures`标记可用于将一个或多个装置应用于测试，就好像它们在参数列表中声明了装置名称一样。在您希望所有组中的测试始终使用不是`autouse`的装置的情况下，这可能是一种替代方法。'
- en: 'For example, the code below will ensure all tests methods in the `TestVirtualEnv` class
    execute in a brand new virtual environment:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的代码将确保`TestVirtualEnv`类中的所有测试方法在一个全新的虚拟环境中执行：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As the name indicates, you can pass multiple fixtures names to the decorator:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，您可以将多个装置名称传递给装饰器：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Parametrizing fixtures
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化装置
- en: Fixtures can also be parametrized directly. When a fixture is parametrized,
    all tests that use the fixture will now run multiple times, once for each parameter.
    This is an excellent tool to use when we have variants of a fixture and each test
    that uses the fixture should also run with all variants.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 装置也可以直接进行参数化。当一个装置被参数化时，所有使用该装置的测试现在将多次运行，每个参数运行一次。当我们有装置的变体，并且每个使用该装置的测试也应该与所有变体一起运行时，这是一个很好的工具。
- en: 'In the previous chapter, we saw an example of parametrization using multiple
    implementations of a serializer:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了使用序列化器的多个实现进行参数化的示例：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can update the example to parametrize on a fixture instead:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更新示例以在装置上进行参数化：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下内容：
- en: We pass a `params` parameter to the fixture definition.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们向装置定义传递了一个`params`参数。
- en: We access the parameter inside the fixture, using the `param` attribute of the
    special `request` object. This built-in fixture provides access to the requesting
    test function and the parameter when the fixture is parametrized. We will see
    more about the `request` fixture later in this chapter.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`request`对象的特殊`param`属性在装置内部访问参数。当装置被参数化时，这个内置装置提供了对请求测试函数和参数的访问。我们将在本章后面更多地了解`request`装置。
- en: In this case, we instantiate the serializer inside the fixture, instead of explicitly
    in each test.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在装置内部实例化序列化器，而不是在每个测试中显式实例化。
- en: 'As can be seen, parametrizing a fixture is very similar to parametrizing a
    test, but there is one key difference: by parametrizing a fixture we make all
    tests that use that fixture run against all the parametrized instances, making
    them an excellent solution for fixtures shared in `conftest.py` files.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，参数化装置与参数化测试非常相似，但有一个关键的区别：通过参数化装置，我们使所有使用该装置的测试针对所有参数化的实例运行，使它们成为`conftest.py`文件中共享的装置的绝佳解决方案。
- en: It is very rewarding to see a lot of new tests being automatically executed
    when you add a new parameter to an existing fixture.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向现有装置添加新参数时，看到自动执行了许多新测试是非常有益的。
- en: Using marks from fixtures
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用装置标记
- en: We can use the `request` fixture to access marks that are applied to test functions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`request`装置来访问应用于测试函数的标记。
- en: 'Suppose we have an `autouse` fixture that always initializes the current locale
    to English:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`autouse`装置，它总是将当前区域初始化为英语：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: But what if we want to use a different locale for just a few tests?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们只想为一些测试使用不同的区域设置呢？
- en: 'One way to do that is to use a custom mark, and access the `mark` object from
    within our fixture:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用自定义标记，并在我们的装置内部访问`mark`对象：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Marks can be used that way to pass information to fixtures. Because it is somewhat
    implicit though, I recommend using it sparingly, because it might lead to hard-to-understand
    code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 标记可以用来将信息传递给装置。因为它有点隐式，所以我建议节俭使用，因为它可能导致难以理解的代码。
- en: An overview of built-in fixtures
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置装置概述
- en: Let's take a look at some built-in pytest fixtures.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些内置的pytest装置。
- en: tmpdir
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: tmpdir
- en: 'The `tmpdir` fixture provides an empty directory that is removed automatically
    at the end of each test:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmpdir`装置提供了一个在每次测试结束时自动删除的空目录：'
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Being a `function`-scoped fixture, each test gets its own directory so they
    don't have to worry about clean up or generating unique directories.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`function`-scoped装置，每个测试都有自己的目录，因此它们不必担心清理或生成唯一的目录。
- en: 'The fixture provides a `py.local` object ([http://py.readthedocs.io/en/latest/path.html](http://py.readthedocs.io/en/latest/path.html)),
    from the `py` library ([http://py.readthedocs.io](http://py.readthedocs.io)),
    which provides convenient methods to deal with file paths, such as joining, reading,
    writing, getting the extension, and so on; it is similar in philosophy to the `pathlib.Path` object
    ([https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html))
    from the standard library:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 装置提供了一个`py.local`对象（[http://py.readthedocs.io/en/latest/path.html](http://py.readthedocs.io/en/latest/path.html)），来自`py`库（[http://py.readthedocs.io](http://py.readthedocs.io)），它提供了方便的方法来处理文件路径，比如连接，读取，写入，获取扩展名等等；它在哲学上类似于标准库中的`pathlib.Path`对象（[https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)）：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Why pytest use `py.local` instead of `pathlib.Path`?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么pytest使用`py.local`而不是`pathlib.Path`？
- en: Pytest had been around for years before `pathlib.Path` came along and was incorporated
    into the standard library, and the `py` library  was one the best solutions for
    path-like objects at the time. Core pytest developers are looking into how to
    adapt pytest to the now-standard `pathlib.Path` API.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pathlib.Path`出现并被合并到标准库之前，Pytest已经存在多年了，而`py`库是当时路径类对象的最佳解决方案之一。核心pytest开发人员正在研究如何使pytest适应现在标准的`pathlib.Path`API。
- en: tmpdir_factory
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: tmpdir_factory
- en: 'The `tmpdir` fixture is very handy, but it is only `function`*-*scoped: this
    has the downside that it can only be used by other `function`-scoped fixtures.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmpdir`装置非常方便，但它只有`function`*-*scoped：这样做的缺点是它只能被其他`function`-scoped装置使用。'
- en: The `tmpdir_factory` fixture is a *session-scoped* fixture that allows creating
    empty and unique directories at any scope. This can be useful when we need to
    store data on to a disk in fixtures of other scopes, for example a `session`-scoped
    cache or a database file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmpdir_factory`装置是一个*session-scoped*装置，允许在任何范围内创建空的唯一目录。当我们需要在其他范围的装置中存储数据时，例如`session`-scoped缓存或数据库文件时，这可能很有用。'
- en: 'To show it in action, the `images_dir` fixture shown next uses `tmpdir_factory` to
    create a unique directory for the entire test session containing a series of sample
    image files:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示它的作用，接下来显示的`images_dir`装置使用`tmpdir_factory`创建一个唯一的目录，整个测试会话中包含一系列示例图像文件：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Because this will be executed only once per session, it will save us considerable
    time when running the tests.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这将每个会话只执行一次，所以在运行测试时会节省我们相当多的时间。
- en: 'Tests can then use the `images_dir` fixture tests to easily access the sample
    image files:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后测试可以使用`images_dir`装置轻松访问示例图像文件：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Keep in mind however that a directory created by this fixture is shared and
    will only be deleted at the end of the test session. This means that tests should
    not modify the contents of the directory; otherwise, they risk affecting other
    tests.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，此装置创建的目录是共享的，并且只会在测试会话结束时被删除。这意味着测试不应修改目录的内容；否则，它们可能会影响其他测试。
- en: monkeypatch
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 猴子补丁
- en: 'In some situations, tests need features that are complex or hard to set up
    in a testing environment, for example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，测试需要复杂或难以在测试环境中设置的功能，例如：
- en: Clients to an external resource (for example GitHub's API), where access during
    testing might be impractical or too expensive
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对外部资源的客户端（例如GitHub的API）需要在测试期间访问可能不切实际或成本太高
- en: Forcing a piece of code to behave as if on another platform, such as error handling
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制代码表现得好像在另一个平台上，比如错误处理
- en: Complex conditions or environments that are hard to reproduce locally or in
    the CI
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的条件或难以在本地或CI中重现的环境
- en: 'The `monkeypatch` fixture allows you to cleanly overwrite functions, objects,
    and dictionary entries of the system being tested with other objects and functions,
    undoing all changes during test teardown. For example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`monkeypatch`装置允许您使用其他对象和函数干净地覆盖正在测试的系统的函数、对象和字典条目，并在测试拆卸期间撤消所有更改。例如：'
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this code, `user_login` uses the `getpass.getpass()` function ([https://docs.python.org/3/library/getpass.html](https://docs.python.org/3/library/getpass.html))
    from the standard library to prompt for the user's password in the most secure
    manner available in the system. It is hard to simulate the actual entering of
    the password during testing because `getpass` tries to read directly from the
    terminal (as opposed to from `sys.stdin`) when possible.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`user_login`使用标准库中的`getpass.getpass()`函数（[https://docs.python.org/3/library/getpass.html](https://docs.python.org/3/library/getpass.html)）以系统中最安全的方式提示用户输入密码。在测试期间很难模拟实际输入密码，因为`getpass`尝试直接从终端读取（而不是从`sys.stdin`）。
- en: 'We can use the `monkeypatch` fixture to bypass the call to `getpass` in the
    tests, transparently and without changing the application code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`monkeypatch`装置来在测试中绕过对`getpass`的调用，透明地而不改变应用程序代码：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the tests, we use `monkeypatch.setattr` to replace the real `getpass()` function
    of the `getpass` module with a dummy `lambda`, which returns a hard-coded password.
    In `test_login_success`, we return a known, good password to ensure the user can
    authenticate successfully, while in `test_login_wrong_password`, we use a bad
    password to ensure the authentication error is handled correctly. As mentioned
    before, the original `getpass()` function is restored automatically at the end
    of the test, ensuring we don't leak that change to other tests in the system.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们使用`monkeypatch.setattr`来用一个虚拟的`lambda`替换`getpass`模块的真实`getpass()`函数，它返回一个硬编码的密码。在`test_login_success`中，我们返回一个已知的好密码，以确保用户可以成功进行身份验证，而在`test_login_wrong_password`中，我们使用一个错误的密码来确保正确处理身份验证错误。如前所述，原始的`getpass()`函数会在测试结束时自动恢复，确保我们不会将该更改泄漏到系统中的其他测试中。
- en: How and where to patch
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何和在哪里修补
- en: The `monkeypatch` fixture works by replacing an attribute of an object by another
    object (often called a *mock*), restoring the original object at the end of the
    test. A common problem when using this fixture is patching the wrong object, which
    causes the original function/object to be called instead of the mock one.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`monkeypatch`装置通过用另一个对象（通常称为*模拟*）替换对象的属性来工作，在测试结束时恢复原始对象。使用此装置的常见问题是修补错误的对象，这会导致调用原始函数/对象而不是模拟函数/对象。'
- en: To understand the problem, we need to understand how `import` and `import from` work
    in Python.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解问题，我们需要了解Python中`import`和`import from`的工作原理。
- en: 'Consider a module called `services.py`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个名为`services.py`的模块：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this code, we are importing the `subprocess` module and bringing the `subprocess`
    module object into the `services.py` namespace. That''s why we call `subprocess.run`:
    we are accessing the `run` function of the `subprocess` object in the `services.py` namespace.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们导入`subprocess`模块并将`subprocess`模块对象引入`services.py`命名空间。这就是为什么我们调用`subprocess.run`：我们正在访问`services.py`命名空间中`subprocess`对象的`run`函数。
- en: 'Now consider the previous code written slightly differently:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑稍微不同的以前的代码写法：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we are importing the `subprocess` module but bringing the `run` function
    object into the `service.py` namespace. That's why `run` can be called directly
    in `start_service`, and the `subprocess` name is not even available (if you try
    to call `subprocess.run`, you will get a `NameError` exception).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入了`subprocess`模块，但将`run`函数对象带入了`service.py`命名空间。这就是为什么`run`可以直接在`start_service`中调用，而`subprocess`名称甚至不可用（如果尝试调用`subprocess.run`，将会得到`NameError`异常）。
- en: We need to be aware of this difference, to properly `monkeypatch` the usage
    of `subprocess.run` in `services.py`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要意识到这种差异，以便正确地`monkeypatch`在`services.py`中使用`subprocess.run`。
- en: 'In the first case, we need to replace the `run` function of the `subprocess` module,
    because that''s how `start_service` uses it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们需要替换`subprocess`模块的`run`函数，因为`start_service`就是这样使用它的：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this code, both `services.py` and `test_services.py` have the reference to
    the same `subprocess` module object.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`services.py`和`test_services.py`都引用了相同的`subprocess`模块对象。
- en: 'In the second case, however, `services.py` has a reference to the original `run` function
    in its own namespace. For this reason, the correct approach for the second case
    is to replace the `run` function in `services.py` ''s namespace:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在第二种情况下，`services.py`在自己的命名空间中引用了原始的`run`函数。因此，第二种情况的正确方法是替换`services.py`命名空间中的`run`函数：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How the code being tested imports code that needs to be monkeypatched is the
    reason why people are tripped by this so often, so make sure you take a look at
    the code first.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 被测试代码导入需要进行monkeypatch的代码是人们经常被绊倒的原因，所以确保您首先查看代码。
- en: capsys/capfd
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: capsys/capfd
- en: The `capsys` fixture captures all text written to `sys.stdout` and `sys.stderr` and
    makes it available during testing.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`capsys` fixture捕获了写入`sys.stdout`和`sys.stderr`的所有文本，并在测试期间使其可用。'
- en: 'Suppose we have a small command-line script and want to check the usage instructions
    are correct when the script is invoked without arguments:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个小的命令行脚本，并且希望在调用脚本时没有参数时检查使用说明是否正确：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'During testing, we can access the captured output, using the `capsys` fixture.
    This fixture has a `capsys.readouterr()` method that returns a `namedtuple` ([https://docs.python.org/3/library/collections.html#collections.namedtuple](https://docs.python.org/3/library/collections.html#collections.namedtuple)) with `out` and `err` attributes,
    containing the captured text from `sys.stdout` and `sys.stderr` respectively:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试期间，我们可以使用`capsys` fixture访问捕获的输出。这个fixture有一个`capsys.readouterr()`方法，返回一个`namedtuple`([https://docs.python.org/3/library/collections.html#collections.namedtuple](https://docs.python.org/3/library/collections.html#collections.namedtuple))，其中包含从`sys.stdout`和`sys.stderr`捕获的文本。
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There's also the `capfd` fixture that works similarly to `capsys`, except that
    it also captures the output of file descriptors `1` and `2`. This makes it possible
    to capture the standard output and standard errors, even for extension modules.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`capfd` fixture，它的工作方式类似于`capsys`，只是它还捕获文件描述符`1`和`2`的输出。这使得可以捕获标准输出和标准错误，即使是对于扩展模块。
- en: Binary mode
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制模式
- en: '`capsysbinary` and `capfdbinary` are fixtures identical to `capsys` and `capfd`, except
    that they capture output in binary mode, and their `readouterr()` methods return
    raw bytes instead of text. It might be useful in specialized situations, for example,
    when running an external process that produces binary output, such as `tar`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`capsysbinary`和`capfdbinary`是与`capsys`和`capfd`相同的fixtures，不同之处在于它们以二进制模式捕获输出，并且它们的`readouterr()`方法返回原始字节而不是文本。在特殊情况下可能会有用，例如运行生成二进制输出的外部进程时，如`tar`。'
- en: request
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: request
- en: 'The `request` fixture is an internal pytest fixture that provides useful information
    about the requesting test. It can be declared in test functions and fixtures,
    and provides attributes such as the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`request` fixture是一个内部pytest fixture，提供有关请求测试的有用信息。它可以在测试函数和fixtures中声明，并提供以下属性：'
- en: '`function`: the Python `test` function object, available for `function`-scoped
    fixtures.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`：Python `test`函数对象，可用于`function`-scoped fixtures。'
- en: '`cls`/`instance`: the Python class/instance of a `test` method object, available
    for function- and `class`-scoped fixtures. It can be `None` if the fixture is
    being requested from a `test` function, as opposed to a test method.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cls`/`instance`：Python类/实例的`test`方法对象，可用于`function`和`class`-scoped fixtures。如果fixture是从`test`函数请求的，而不是测试方法，则可以为`None`。'
- en: '`module`: the Python module object of the requesting test method, available
    for `module`-, `function`-, and `class`-scoped fixtures.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module`：请求测试方法的Python模块对象，可用于`module`，`function`和`class`-scoped fixtures。'
- en: '`session`: pytest''s internal `Session` object, which is a singleton for the
    test session and represents the root of the collection tree. It is available to
    fixtures of all scopes.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session`：pytest的内部`Session`对象，它是测试会话的单例，代表集合树的根。它可用于所有范围的fixtures。'
- en: '`node`: the pytest collection node, which wraps one of the Python objects discussed
    that matches the fixture scope.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node`：pytest集合节点，它包装了与fixture范围匹配的Python对象之一。'
- en: '`addfinalizer(func)`: adds a `new finalizer` function that will be called at
    the end of the test. The finalizer function is called without arguments. `addfinalizer` was
    the original way to execute teardown in fixtures, but has since then been superseded
    by the `yield` statement, remaining in use mostly for backward compatibility.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addfinalizer(func)`: 添加一个将在测试结束时调用的`new finalizer`函数。finalizer函数将在不带参数的情况下调用。`addfinalizer`是在fixtures中执行拆卸的原始方法，但后来已被`yield`语句取代，主要用于向后兼容。'
- en: 'Fixtures can use those attributes to customize their own behavior based on
    the test being executed. For example, we can create a fixture that provides a
    temporary directory using the current test name as the prefix of the temporary
    directory, somewhat similar to the built-in `tmpdir` fixture:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: fixtures可以使用这些属性根据正在执行的测试自定义自己的行为。例如，我们可以创建一个fixture，使用当前测试名称作为临时目录的前缀，类似于内置的`tmpdir`
    fixture：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This code created the following directory when executed on my system:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统上执行此代码时创建了以下目录：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `request` fixture can be used whenever you want to customize a fixture based
    on the attributes of the test being executed, or to access the marks applied to
    the test function, as we have seen in the previous sections.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`request` fixture 可以在您想要根据正在执行的测试的属性自定义 fixture，或者访问应用于测试函数的标记时使用，正如我们在前面的部分中所看到的。'
- en: Tips/discussion
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示/讨论
- en: The following are some short topics and tips that did not fit into the previous
    sections, but that I think are worth mentioning.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些未适应前面部分的短话题和提示，但我认为值得一提。
- en: When to use fixtures, as opposed to simple functions
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用 fixture，而不是简单函数
- en: 'Sometimes, all you need is to construct a simple object for your tests, and
    arguably this can be done in a plain function, not necessarily needing to be implemented
    as a fixture. Suppose we have a `WindowManager` class, that does not receive any
    parameters:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您只需要为测试构造一个简单的对象，可以说这可以通过一个普通函数来完成，不一定需要实现为 fixture。假设我们有一个不接收任何参数的 `WindowManager`
    类：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'One way to use it in our tests would be to write a fixture:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中使用它的一种方法是编写一个 fixture：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Alternatively, you could argue that a fixture for such simple usage is overkill,
    and use a plain function instead:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以主张为这样简单的用法编写一个 fixture 是过度的，并且使用一个普通函数代替：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Or you could even create the manager explicitly on each test:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您甚至可以在每个测试中显式创建管理器：
- en: '[PRE41]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is perfectly fine, especially if this is used in a few tests in a single
    module.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完全可以的，特别是如果在单个模块中的少数测试中使用。
- en: Keep in mind, however, that fixtures **abstract away details about the construction
    and teardown process of objects**. This is crucial to remember when deciding to
    forego fixtures in favor of normal functions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，fixture **抽象了对象的构建和拆卸过程的细节**。在决定放弃 fixture 而选择普通函数时，这一点至关重要。
- en: 'Suppose that our `WindowManager` now needs to be closed explicitly, or that
    it needs a local directory for logging purposes:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的 `WindowManager` 现在需要显式关闭，或者它需要一个本地目录用于记录目的：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we have been using a fixture such as the one given in the first example,
    we just update the fixture function and **no tests need to change at all**:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们一直在使用像第一个例子中给出的 fixture，我们只需更新 fixture 函数，**测试根本不需要改变**：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'But if we opted to use a plain function, now we **have to update all places
    that call our function**: we need to pass a logging directory and guarantee that
    `.close()` is called at the end of the test:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们选择使用一个普通函数，现在我们**必须更新调用我们函数的所有地方**：我们需要传递一个记录目录，并确保在测试结束时调用 `.close()`：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Depending on how many times this function has been used in our tests, this can
    be quite a refactoring.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个函数在我们的测试中被使用的次数，这可能是一个相当大的重构。
- en: 'The message is: it is fine to use plain functions when the underlying object
    is simple and unlikely to change, but keep in mind that fixtures abstract the
    details of the creation/destruction of objects, and they might need to change
    in the future. On the other hand, using fixtures creates another level of indirection,
    which slightly increases code complexity. In the end, it is a balance that should
    be weighted by you.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个信息是：当底层对象简单且不太可能改变时，使用普通函数是可以的，但请记住，fixture 抽象了对象的创建/销毁的细节，它们可能在将来需要更改。另一方面，使用
    fixture 创建了另一个间接层，稍微增加了代码复杂性。最终，这是一个需要您权衡的平衡。
- en: Renaming fixtures
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重命名 fixture
- en: 'The `@pytest.fixture` decorator accepts a `name` parameter that can be used
    to specify a name for the fixture, different from the fixture function:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`@pytest.fixture` 装饰器接受一个 `name` 参数，该参数可用于指定 fixture 的名称，与 fixture 函数不同：'
- en: '[PRE45]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This is useful, because there are some annoyances that might affect users when
    using fixtures declared in the same module as the test functions that use them:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有用的，因为有一些烦恼可能会影响用户在使用在相同模块中声明的 fixture 时：
- en: If users forget to declare the fixture in the parameter list of a test function,
    they will get a `NameError` instead of the fixture function object (because they
    are in the same module).
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户忘记在测试函数的参数列表中声明 fixture，他们将得到一个 `NameError`，而不是 fixture 函数对象（因为它们在同一个模块中）。
- en: Some linters complain that the test function parameter is shadowing the fixture
    function.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些 linters 抱怨测试函数参数遮蔽了 fixture 函数。
- en: You might adopt this as a good practice in your team if the previous annoyances
    are frequent. Keep in mind that these problems only happen with fixtures defined
    in test modules, not in `conftest.py` files.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前的烦恼经常发生，您可能会将这视为团队中的一个良好实践。请记住，这些问题只会发生在测试模块中定义的 fixture 中，而不会发生在 `conftest.py`
    文件中。
- en: Prefer local imports in conftest files
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 conftest 文件中优先使用本地导入
- en: '`conftest.py` files are imported during collection, so they directly affect
    your experience when running tests from the command line. For this reason, I suggest
    using local imports in `conftest.py` files as often as possible, to keep import
    times low.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`conftest.py` 文件在收集期间被导入，因此它们直接影响您从命令行运行测试时的体验。因此，我建议在 `conftest.py` 文件中尽可能使用本地导入，以保持导入时间较短。'
- en: 'So, don''t use this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不要使用这个：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Prefer local imports:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 优先使用本地导入：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This practice has a noticeable impact on test startup in large test suites.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法对大型测试套件的启动有明显影响。
- en: Fixtures as test-supporting code
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fixture 作为测试支持代码
- en: You should think of fixtures not only as a means of providing resources, but
    also of providing supporting code for your tests. By supporting code, I mean classes
    that provide high-level functionality for testing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该将 fixture 视为不仅提供资源的手段，还提供测试的支持代码。通过支持代码，我指的是为测试提供高级功能的类。
- en: 'For example, a bot framework might provide a fixture that can be used to test
    your bot as a black box:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个机器人框架可能会提供一个 fixture，用于测试您的机器人作为黑盒：
- en: '[PRE48]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `bot` fixture allows the developer to talk to the bot, verify responses,
    and check the contents of the internal store that is handled by the framework,
    among other things. It provides a high-level interface that makes tests easier
    to write and understand, even for those who do not understand the internals of
    the framework.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`bot` fixture允许开发人员与机器人交谈，验证响应，并检查框架处理的内部存储的内容，等等。它提供了一个高级接口，使得测试更容易编写和理解，即使对于那些不了解框架内部的人也是如此。'
- en: This technique is useful for applications, because it will make it easy and
    enjoyable for developers to add new tests. It is also useful for libraries, because
    they will provide high-level testing support for users of your library.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术对应用程序很有用，因为它将使开发人员轻松愉快地添加新的测试。对于库来说也很有用，因为它们将为库的用户提供高级测试支持。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we delved into one of pytest''s most famous features: fixtures.
    We have seen how they can be used to provide resources and test functionality,
    and how to concisely express setup/teardown code. We learned how to share fixtures,
    using `conftest.py` files; to use fixture scopes, to avoid creating expensive
    resources for every test; and to autouse fixtures that are executed for all tests
    in the same module or hierarchy. Then, we learned how to parametrize fixtures and
    use marks from them. We took an overview of various built-in fixtures, and closed
    the chapter with some short discussions about fixtures in general. I hope you
    enjoyed the ride!'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入了解了pytest最著名的功能之一：fixtures。我们看到了它们如何被用来提供资源和测试功能，以及如何简洁地表达设置/拆卸代码。我们学会了如何共享fixtures，使用`conftest.py`文件；如何使用fixture
    scopes，避免为每个测试创建昂贵的资源；以及如何自动使用fixtures，这些fixtures会在同一模块或层次结构中的所有测试中执行。然后，我们学会了如何对fixtures进行参数化，并从中使用标记。我们对各种内置fixtures进行了概述，并在最后对fixtures进行了一些简短的讨论。希望您喜欢这一过程！
- en: In the next chapter, we will explore a little of the vast pytest plugin ecosystem
    that is at your disposal.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索一下广阔的pytest插件生态系统，这些插件都可以供您使用。
