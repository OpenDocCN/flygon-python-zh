- en: Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Searching, sorting, filtering—high-performance searching in sorted containers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索、排序、过滤-在排序的容器中进行高性能搜索
- en: Getting the n^(th) element of any iterable—grabbing the *n^(th)* element of
    any iterable, generators too
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取任何可迭代对象的第n个元素-抓取任何可迭代对象的第n个元素，包括生成器
- en: Grouping similar items—splitting an iterable into groups of similar items
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组相似项目-将可迭代对象分成相似项目的组
- en: Zipping—merging together data from multiple iterables into a single iterable
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并-将来自多个可迭代对象的数据合并成单个可迭代对象
- en: Flattening a list of lists—converting a list of lists into a flat list
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展平列表的列表-将列表的列表转换为平面列表
- en: Producing permutations and—computing all possible permutations of a set of elements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成排列和-计算一组元素的所有可能排列
- en: Accumulating and reducing—applying binary functions to iterables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 累积和减少-将二进制函数应用于可迭代对象
- en: Memoizing—speeding up computation by caching functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆-通过缓存函数加速计算
- en: Operators to functions—how to keep references to callables for a Python operator
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从运算符到函数-如何保留对Python运算符的可调用引用
- en: Partials—reducing the number of arguments of a function by preapplying some
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分-通过预应用一些函数来减少函数的参数数量
- en: Generic functions—functions that are able to change behavior according to the
    provided argument type
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用函数-能够根据提供的参数类型改变行为的函数
- en: Proper decoration—properly decorating a function to avoid missing its signature
    and docstring
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当的装饰-适当地装饰函数以避免丢失其签名和文档字符串
- en: Context managers—automatically running code whenever you enter and exit a block
    of code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文管理器-在进入和退出代码块时自动运行代码
- en: Applying variable context managers—how a variable number of context managers
    can be applied
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用可变上下文管理器-如何应用可变数量的上下文管理器
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: When writing software, there are a whole bunch of things that you will find
    yourself doing over and over independently from the type of application you are
    writing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写软件时，有很多事情你会发现自己一遍又一遍地做，与你正在编写的应用程序类型无关。
- en: Apart from whole features that you might have to reuse across different applications
    (such as login, logging, and authorization), there are a bunch of little building
    blocks that you can reuse across any kind of software.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了您可能需要在不同应用程序中重用的整个功能（例如登录、日志记录和授权）之外，还有一堆可以在任何类型的软件中重用的小构建块。
- en: This chapter will try to gather a bunch of recipes that can be used as reusable
    snippets to achieve very common operations that you might have to perform independently
    from your software's purpose.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将尝试收集一堆可以用作可重用片段的配方，以实现您可能需要独立于软件目的执行的非常常见的操作。
- en: Searching, sorting, filtering
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索、排序、过滤
- en: Searching for an element is a very common need in programming. Looking up an
    item in a container is basically the most frequent operation that your code will
    probably do, so it's very important that it's quick and reliable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中查找元素是一个非常常见的需求。在容器中查找项目基本上是您的代码可能会执行的最频繁的操作，因此它非常重要，它既快速又可靠。
- en: Sorting is frequently connected to searching, as it's often possible to involve
    smarter lookup solutions when you know your set is sorted, and sorting means continuously
    searching and moving items until they are in sorted order. So they frequently
    go together.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 排序经常与搜索相关联，因为当你知道你的集合是排序的时，往往可以使用更智能的查找解决方案，并且排序意味着不断搜索和移动项目，直到它们按排序顺序排列。所以它们经常一起出现。
- en: Python has built-in functions to sort containers of any type and look up items
    in them, even with functions that are able to leverage the sorted sequence.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Python具有内置函数，可以对任何类型的容器进行排序并在其中查找项目，甚至可以利用排序序列的函数。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, the following steps are to be performed:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，需要执行以下步骤：
- en: 'Take the following set of elements:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取以下一组元素：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Looking up an element in the sequence can be done through the `in` operator:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`in`运算符可以在序列中查找元素：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Sorting can be done through the `sorted` function:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 排序可以通过`sorted`函数完成：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once we have a sorted container, we can actually use the `bisect` module to
    find contained entries faster:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了一个排序的容器，我们实际上可以使用`bisect`模块更快地找到包含的条目：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`bisect_search` can be used to know whether an entry is in the list, much like
    the `in` operator did:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bisect_search`可以用来知道一个条目是否在列表中，就像`in`运算符一样：'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But, the advantage is that it can be a lot faster for many sorted entries:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是，优点是对于许多排序的条目来说可能会更快：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, the `bisect_search` function is 17 times faster than a plain lookup in our
    example.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的示例中，`bisect_search`函数比普通查找快17倍。
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `bisect` module uses dichotomic searching to look for the point of insertion
    of an element in a sorted container.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`bisect`模块使用二分搜索来查找已排序容器中元素的插入点。'
- en: 'If an element exists in the array, its insertion position is exactly where
    the element is (as it should go exactly where it is):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素存在于数组中，它的插入位置正是元素所在的位置（因为它应该正好在它所在的位置）：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If the element is missing, it will return the position of the next, immediately
    bigger element:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素缺失，它将返回下一个立即更大的元素的位置：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This means we will get a position even for elements that do not exist in our
    container. That's why we compare the element at the returned position with the
    element that we were looking for. If the two are different, it means that the
    nearest element was returned and so the element itself was not found.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们将获得一个位置，即使对于不存在于我们的容器中的元素。这就是为什么我们将返回的位置处的元素与我们正在寻找的元素进行比较。如果两者不同，这意味着返回了最近的元素，因此元素本身没有找到。
- en: For the same reason, if the element is not found and it's bigger than the biggest
    value contained in the container, the length of the container itself is returned
    (as the element should go at the end), so we need to also ensure that we `index
    < len(container)` to check for elements that were not in the container.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 出于同样的原因，如果未找到元素并且它大于容器中包含的最大值，则返回容器本身的长度（因为元素应该放在最后），因此我们还需要确保`index < len(container)`来检查不在容器中的元素。
- en: There's more...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: So far, we've only sorted and looked up the entries themselves, but in many
    cases you will have complex objects where you are interested in sorting and searching
    for a specific property of an object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只对条目本身进行了排序和查找，但在许多情况下，您将拥有复杂的对象，您有兴趣对对象的特定属性进行排序和搜索。
- en: 'For example, you might have a list of people and you want to sort by their
    names:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可能有一个人员列表，您想按其姓名排序：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Sorting those people by name can be done by relying on the `key` argument of
    the `sorted` function, which specifies a callable that should return the value
    for which the entry should be sorted:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过依赖`sorted`函数的`key`参数，可以对这些人按姓名进行排序，该参数指定应返回应对条目进行排序的值的可调用对象：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sorting through a `key` function is much faster than sorting through a comparison
    function. Because the `key` function only needs to be called once per item (then
    the result is preserved), while the `comparison` function needs to be called over
    and over every time that there are two items that need to be compared. So, if
    computing the value for which we should sort is expensive, the `key` function
    approach can achieve significant performance improvements.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`key`函数进行排序比通过比较函数进行排序要快得多。因为`key`函数只需要对每个项目调用一次（然后结果被保留），而`comparison`函数需要在每次需要比较两个项目时一遍又一遍地调用。因此，如果计算我们应该排序的值很昂贵，`key`函数方法可以实现显着的性能改进。
- en: 'Now the problem is that `bisect` doesn''t allow us to provide a key, so to
    be able to use `bisect` on the people list, we would have to first build a `keys`
    list where we can apply the `bisect`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，`bisect`不允许我们提供一个键，因此为了能够在people列表上使用`bisect`，我们首先需要构建一个`keys`列表，然后我们可以应用`bisect`：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This requires one more pass through the list to build the `keys` list, so it's
    only convenient if you have to look up multiple entries (or the same entry multiple
    times), otherwise a linear search across the list will be faster.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要通过列表进行一次额外的传递来构建`keys`列表，因此只有在您必须查找多个条目（或多次查找相同的条目）时才方便，否则在列表上进行线性搜索将更快。
- en: Note that you would have to build the `keys` list even to be able to use the
    `in` operator. So, if you want to search for a property without building an ad
    hoc list, you will have to rely on filtering as `filter` or list comprehensions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使要使用`in`运算符，您也必须构建`keys`列表。因此，如果要搜索一个属性而不构建一个特定的列表，您将不得不依赖于`filter`或列表推导。
- en: Getting the nth element of any iterable
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取任何可迭代对象的第n个元素
- en: Randomly accessing to containers is something we are used to doing frequently
    and without too many issues. For most container types, it's even a very cheap
    operation. When working with generic iterables and generators on the other side,
    it's not as easy as we would expect and it often ends up with us converting them
    to lists or ugly `for` loops.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 随机访问容器是我们经常做的事情，而且没有太多问题。对于大多数容器类型来说，这甚至是一个非常便宜的操作。另一方面，当使用通用可迭代对象和生成器时，情况并不像我们期望的那样简单，通常最终会导致我们将它们转换为列表或丑陋的`for`循环。
- en: The Python standard library actually has ways to make this very straightforward.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库实际上有办法使这变得非常简单。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `itertools` module is a treasure of valuable functions when working with
    iterables, and with minor effort it''s possible to get the *n^(th)* item of any
    iterable:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools`模块是一个宝库，当处理可迭代对象时具有非常有价值的功能，并且只需很少的努力就可以获得任何可迭代对象的第n个项目：'
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Given a random iterable, we can use it to grab the element we want:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个随机的可迭代对象，我们可以使用它来获取我们想要的元素：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `itertools.islice` function is able to take a slice of any iterable. In
    our specific case, we want the slice that goes from the element we are looking
    for to the next one.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools.islice`函数能够获取任何可迭代对象的切片。在我们的特定情况下，我们需要的是从我们要查找的元素到下一个元素的切片。'
- en: Once we have the slice containing the element we were looking for, we need to
    extract that item from the slice itself.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了包含我们要查找的元素的切片，我们就需要从切片本身中提取该项。
- en: As `islice` acts on iterables, it returns an iterable itself. This means we
    can use `next` to consume it, and as the item we were looking for is actually
    the first of the slice, using `next` will properly return the item we were looking
    for.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`islice`作用于可迭代对象，它本身返回一个可迭代对象。这意味着我们可以使用`next`来消耗它，由于我们要查找的项实际上是切片的第一个项，因此使用`next`将正确返回我们要查找的项。
- en: In case the item is out of bounds (for example, we look for the fourth item
    out of just three), a `StopIteration` error is raised and we can trap it like
    we would for `IndexError` in normal lists.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元素超出范围（例如，我们在仅有三个元素的情况下寻找第四个元素），则会引发`StopIteration`错误，我们可以像在普通列表中一样捕获它，就像对`IndexError`一样。
- en: Grouping similar items
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组相似的项目
- en: Sometimes you might face a list of entries that has multiple, repeated entries
    and you might want to group the similar ones based on some kind of property.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能会面对一个具有多个重复条目的条目列表，并且您可能希望根据某种属性对相似的条目进行分组。
- en: 'For example, here is a list of names:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个名字列表：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We might want to build a group of all people whose names start with the same
    character, so we can keep our phone book in alphabetical order instead of having
    names randomly scattered here and there.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望构建一个所有名字以相同字符开头的人的组，这样我们就可以按字母顺序保留我们的电话簿，而不是让名字随机散落在这里和那里。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `itertools` module is again a very powerful tool that provides us with
    the foundations we need to handle iterables:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools`模块再次是一个非常强大的工具，它为我们提供了处理可迭代对象所需的基础：'
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Given our list of names, we can apply a key function that grabs the first character
    of the name so that all entries will be grouped by it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 给定我们的姓名列表，我们可以应用一个键函数，该函数获取名称的第一个字符，以便所有条目都将按其分组：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The core of the function here is provided by `itertools.groupby`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的函数核心由`itertools.groupby`提供。
- en: This function moves the iterator forward, grabs the item, and adds it to the
    current group. When an item with a different key is faced, a new group is created.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将迭代器向前移动，抓取项目，并将其添加到当前组中。当面对具有不同键的项目时，将创建一个新组。
- en: 'So, in fact, it will only group nearby entries that share the same key:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实际上，它只会将共享相同键的附近条目分组：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, there are three groups instead of the expected two, because
    the first group of `1` is immediately interrupted by number `2`, and so we end
    up with two different groups of `1`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这里有三个组，而不是预期的两个，因为数字`1`的第一组立即被数字`2`中断，因此我们最终得到了两个不同的`1`组。
- en: 'We sort the elements before grouping them, the reason being that sorting ensures
    that equal elements are all near to one another:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在对它们进行分组之前对元素进行排序，原因是排序可以确保相等的元素都靠在一起：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At that point, the grouping function will create the correct amount of groups
    because there is a single chunk for each equivalent element:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在那一点上，分组函数将创建正确数量的组，因为每个等效元素都有一个单独的块：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We frequently work with complex objects in real life, so the `group_by_key`
    function also accepts a `key` function. That will state for which key the elements
    should be grouped.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在现实生活中经常使用复杂的对象，因此`group_by_key`函数还接受`key`函数。这将说明应该根据哪个键对元素进行分组。
- en: As sorted accepts a key function when sorting, we know that all our elements
    will be sorted for that key before grouping and so we will return the right number
    of groups.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于排序在排序时接受一个键函数，因此我们知道在分组之前所有元素都将根据该键进行排序，因此我们将返回正确数量的组。
- en: Finally, as `groupby` returns an iterator or iterators (each group within the
    top iterable is an iterator too), we cast each group to a list and build a dictionary
    out of the groups so that they can be easily accessed by `key`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于`groupby`返回一个迭代器或迭代器（顶级可迭代对象中的每个组也是一个迭代器），我们将每个组转换为列表，并构建一个字典，以便可以通过`key`轻松访问这些组。
- en: Zipping
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压缩
- en: Zipping means attaching two different iterables to create a new one that contains
    values from both.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Zipping意味着附加两个不同的可迭代对象，以创建一个包含两者值的新对象。
- en: 'This is very convenient when you have multiple tracks of values that should
    proceed concurrently. Imagine you had names and surnames and you want to just
    get a list of people:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有多个值轨道应该同时进行时，这是非常方便的。想象一下，您有名字和姓氏，您只想得到一个人的列表：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We want to zip together names and surnames:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要将名称和姓氏一起压缩：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Zip will make a new iterable where each item in the newly-created iterable is
    a collection that is made by picking one item for each one of the provided iterables.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Zip将创建一个新的可迭代对象，其中新创建的可迭代对象中的每个项目都是通过从所提供的可迭代对象中选择一个项目而生成的集合。
- en: So, `result[0] = (i[0], j[0])`, and `result[1] = (i[1], j[1])`, and so on. If
    `i` and `j` have different lengths, it will stop as soon as one of the two is
    exhausted.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`result[0] = (i[0], j[0])`，`result[1] = (i[1], j[1])`，依此类推。如果`i`和`j`的长度不同，它将在两者之一耗尽时立即停止。
- en: If you want to proceed until you exhaust the longest one of the provided iterables
    instead of stopping on the shortest one, you can rely on `itertools.zip_longest`.
    Values from the iterables that were already exhausted will be filled with a default
    value.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要继续直到耗尽所提供的可迭代对象中最长的一个，而不是在最短的一个上停止，可以依靠`itertools.zip_longest`。已经耗尽的可迭代对象的值将填充默认值。
- en: Flattening a list of lists
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展平列表的列表
- en: When you have multiple nested lists, you often need to just iterate over all
    the items contained in the lists without much interest in the depth at which they
    are actually stored.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有多个嵌套列表时，通常需要遍历所有列表中包含的项目，而不太关心它们实际存储的深度。
- en: 'Say you have this list:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有这个列表：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you just want to grab all the items within it, you really don't want to iterate
    over the lists within the list and then on the items of each one of them. We just
    want the leaf items and we don't care at all that they are in a list within a
    list.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想抓取其中的所有项目，那么您真的不想遍历列表中的列表，然后再遍历其中每一个项目。我们只想要叶子项目，我们根本不在乎它们在列表中的列表中。
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'What we want to do is just join all the lists into a single iterable that will
    yield the items themselves, as we are talking about iterators, the `itertools`
    module has the right function that will allow us to chain all the lists as if
    they were a single one:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的就是将所有列表连接成一个可迭代对象，该对象将产生项目本身，因为我们正在谈论迭代器，`itertools`模块具有正确的函数，可以让我们像单个迭代器一样链接所有列表：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The resulting `chained` iterator will yield the underlying items, one by one,
    when consumed:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`chained`迭代器将在消耗时逐个产生底层项目：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `itertools.chain` function is a very convenient one when you have to consume
    multiple iterables one after the other.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools.chain`函数在您需要依次消耗多个可迭代对象时非常方便。'
- en: 'By default, it accepts those iterables as arguments, so we would have to do:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它接受这些可迭代对象作为参数，因此我们将不得不执行：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: But, for convenience, `itertools.chain.from_iterable` will chain the entries
    contained in the provided argument instead of having to pass them explicitly one
    by one.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为了方便起见，`itertools.chain.from_iterable`将链接提供的参数中包含的条目，而不必逐个显式传递它们。
- en: There's more...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you know how many items the original lists contained and they have the same
    size, it's easy to apply the reverse operation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道原始列表包含多少项，并且它们的大小相同，那么很容易应用反向操作。
- en: 'We already know it''s possible to merge entries from multiple sources using
    `zip`, so what we actually want to do is zip together the elements that were part
    of the same original list, so that we can go back from being `chained` to the
    original list of lists:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道可以使用`zip`从多个来源合并条目，所以我们实际上想要做的是将原始列表的元素一起压缩，这样我们就可以从“chained”返回到原始的列表列表：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this case, we had three items lists, so we had to provide `chained` three
    times.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有三个项目列表，所以我们必须提供`chained`三次。
- en: This works because `zip` will sequentially consume one entry from each provided
    argument. So, as we are providing the same argument three times, we are in fact
    consuming the first three entries, then the next three, and then the last three.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`zip`将顺序地从每个提供的参数中消耗一个条目。 因此，由于我们提供了相同的参数三次，实际上我们正在消耗前三个条目，然后是接下来的三个，然后是最后的三个。
- en: 'If `chained` was a list instead of an iterator, we would have to create an
    iterator out of the list:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`chained`是一个列表而不是一个迭代器，我们将不得不从列表中创建一个迭代器：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we didn''t use `ichained` but instead we used the original `chained`, the
    result would be pretty far from what we wanted:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有使用`ichained`而是使用原始的`chained`，结果将与我们想要的相去甚远：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Producing permutations and combinations
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成排列和组合
- en: Given a set of elements, if you ever felt the need to do something for each
    possible permutation of those elements, you might have wondered what the best
    way to generate all those permutations was.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一组元素，如果您曾经感到有必要对这些元素的每个可能的排列执行某些操作，您可能会想知道生成所有这些排列的最佳方法是什么。
- en: Python has various functions in the `itertools` module that will help with permutations
    and combinations, the differences between those are not always easy to grasp,
    but once you investigate what they do, they will become clear.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Python在`itertools`模块中有各种函数，可帮助进行排列和组合，这些之间的区别并不总是容易理解，但一旦您调查它们的功能，它们就会变得清晰。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The Cartesian product is usually what people think of when talking about combinations
    and permutations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 笛卡尔积通常是在谈论组合和排列时人们所考虑的。
- en: 'Given a set of elements, `A`, `B`, and `C`, we want to extract all possible
    couples of two elements, `AA`, `AB`, `AC`, and so on:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一组元素`A`，`B`和`C`，我们想要提取所有可能的两个元素的组合，`AA`，`AB`，`AC`等等：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In case you want to omit the duplicated entries (`AA`, `BB`, `CC`), you can
    just use permutations:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想要省略重复的条目（`AA`，`BB`，`CC`），您可以只使用排列：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You might even want to ensure that the same couple doesn''t happen twice (such
    as `AB` versus `BA`), in such a case, `itertools.combinations` might be what you
    are looking for:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您甚至可能希望确保相同的夫妇不会发生两次（例如`AB`与`BA`），在这种情况下，`itertools.combinations`可能是您要寻找的。
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So most needs of combining values from a set can be easily solved through the
    function provided by the `itertools` module.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，大多数需要组合值的需求都可以通过`itertools`模块提供的函数轻松解决。
- en: Accumulating and reducing
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 累积和减少
- en: List comprehensions and `map` are very convenient tools when you need to apply
    a function to all elements of an iterable and get back the resulting values. But
    those are mostly meant to apply unary functions and keep a collection of the transformed
    values (such as add `1` to all numbers), but if you want to apply functions that
    should receive more than one element at the time, they don't fit very well.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导和`map`是非常方便的工具，当您需要将函数应用于可迭代对象的所有元素并返回结果值时。 但这些工具大多用于应用一元函数并保留转换值的集合（例如将所有数字加`1`），但是如果您想要应用应该一次接收多个元素的函数，它们就不太合适。
- en: The reduction and accumulation functions instead are meant to receive multiple
    values from the iterable and return a single value (in the case of reduction)
    or multiple values (in the case of accumulation).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 减少和累积函数实际上是为了从可迭代对象中接收多个值并返回单个值（在减少的情况下）或多个值（在累积的情况下）。
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The steps for this recipe are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的步骤如下：
- en: 'The most simple example of reduction is summing all items in an iterable:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减少的最简单的例子是对可迭代对象中的所有项目求和：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is something that can easily be done by `sum`, but for the sake of this
    example, we will use `reduce`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是可以通过`sum`轻松完成的事情，但是为了这个例子，我们将使用`reduce`：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If instead of having a single final result, you want to keep the results of
    the intermediate steps, you can use `accumulate`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您不是要获得单个最终结果，而是要保留中间步骤的结果，您可以使用`accumulate`：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There's more...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`accumulate` and `reduce` are not limited to mathematical uses. While those
    are the most obvious examples, they are very flexible functions and their purpose
    changes depending uniquely on the function they are going to apply.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`accumulate`和`reduce`不仅限于数学用途。 虽然这些是最明显的例子，但它们是非常灵活的函数，它们的目的取决于它们将应用的函数。'
- en: 'For example, if you have multiple lines of text, you can also use `reduce`
    to compute the total sum of all text:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有多行文本，您也可以使用`reduce`来计算所有文本的总和：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Or, if you have multiple dictionaries you need to collapse:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您有多个需要折叠的字典：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It''s even a very convenient way to access deeply nested dictionaries:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这甚至是访问深度嵌套的字典的一种非常方便的方法：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Memoizing
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆化
- en: When running a function over and over, avoiding the cost to call that function
    can greatly speed up the resulting code.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一遍又一遍地运行函数，避免调用该函数的成本可以大大加快生成的代码。
- en: Think of a `for` loop or a recursive function that maybe has to call that function
    dozens of times. If instead of calling it, it could preserve the known results
    of a previous call to the function, it could make code much faster.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下`for`循环或递归函数，也许必须调用该函数数十次。 如果它能够保留对函数的先前调用的已知结果，而不是调用它，那么它可以大大加快代码。
- en: The most common example for is the Fibonacci sequence. The sequence is computed
    by adding the first two numbers, then the second number is added to the result,
    and so on.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的例子是斐波那契数列。 该序列是通过添加前两个数字来计算的，然后将第二个数字添加到结果中，依此类推。
- en: This means that in the sequence `1`, `1`, `2`, `3`, `5`, computing `5` required
    us to compute `3 + 2`, which required us to compute `2 + 1`, which required us
    to compute `1 + 1`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在序列`1`，`1`，`2`，`3`，`5`中，计算`5`需要我们计算`3 + 2`，这又需要我们计算`2 + 1`，这又需要我们计算`1 +
    1`。
- en: Doing the Fibonacci sequence in a recursive manner is the most obvious approach
    as it leads to `5 = fib(n3) + fib(n2)`, which was made of `3 = fib(n2) + fib(n1)`,
    so you can easily see that we had to compute `fib(n2)` twice. Memoizing the result
    of `fib(n2)` would allow us to perform such computation only once and then reuse
    the result on the next call.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以递归方式进行斐波那契数列是最明显的方法，因为它导致`5 = fib(n3) + fib(n2)`，其中`3 = fib(n2) + fib(n1)`，所以你可以很容易地看到我们必须计算`fib(n2)`两次。记忆`fib(n2)`的结果将允许我们只执行这样的计算一次，然后在下一次调用时重用结果。
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps for this recipe:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个食谱的步骤：
- en: 'Python provides an LRU cache built-in, which we can use for memoization:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python提供了内置的LRU缓存，我们可以用它来进行记忆化：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can then use the function to compute the full sequence:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以使用该函数来计算整个序列：
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The result will be a list with all the Fibonacci numbers up to the 100^(th):'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结果将是一个包含所有斐波那契数的列表，直到第100个：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The difference in performance is huge. If we use the `timeit` module to time
    our function, we can easily see how much memoizing helped with performance.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 性能上的差异是巨大的。如果我们使用`timeit`模块来计时我们的函数，我们可以很容易地看到记忆化对性能有多大帮助。
- en: 'When the memoized version of the `fibonacci` function is used, the computation
    ends in less than a millisecond:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用`fibonacci`函数的记忆化版本时，计算在不到一毫秒内结束：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then if we remove `@functools.lru_cache()`, which implemented the memoization,
    the timing changes radically:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，如果我们移除`@functools.lru_cache()`，实现记忆化的时间会发生根本性的变化：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So it's easy to see how memoization changed the performance to fractions of
    a second from 89 seconds.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所以很容易看出记忆化如何将性能从89秒提高到几分之一秒。
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Whenever the function is invoked, `functools.lru_cache` saves the returned value
    together with the provided arguments.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用函数时，`functools.lru_cache`都会保存返回的值以及提供的参数。
- en: The next time the function will be called, the arguments are searched in the
    saved arguments and, if they are found, the previously returned value is provided
    instead of calling the function.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 下一次调用函数时，参数将在保存的参数中搜索，如果找到，将提供先前返回的值，而不是调用函数。
- en: This, in fact, changes the cost of calling our function to being just the cost
    of a lookup in a dictionary.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这改变了调用我们的函数的成本，只是在字典中查找的成本。
- en: So the first time we call `fibonacci(5)`, it gets computed, then next time it
    will be called, it will do nothing and the value previously stored for `5` will
    be returned. As `fibonacci(6)` has to call `fibonacci(5)` to be able to compute,
    it's easy to see how we provided a major performance benefit for any `fibonacci(n)`
    where `n>5`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 所以第一次调用`fibonacci(5)`时，它被计算，然后下一次调用时它将什么都不做，之前存储的`5`的值将被返回。由于`fibonacci(6)`必须调用`fibonacci(5)`才能计算，很容易看出我们为任何`fibonacci(n)`提供了主要的性能优势，其中`n>5`。
- en: Also as we wanted the whole sequence, the saving is not just for a single call,
    but for each call in the list comprehension following the first one that needs
    a memoized value.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，由于我们想要整个序列，所以节省不仅仅是单个调用，而是在第一个需要记忆值的列表推导式之后的每次调用。
- en: The `lru_cache` function was born as a **least recently used** (**LRU**) cache,
    so by default, it will keep around only the `128` most recent, but by passing
    `maxsize=None`, we can use it as a standard cache and discard the LRU part of
    it. All calls will be cached forever without a limit.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`lru_cache`函数诞生于**最近最少使用**（**LRU**）缓存，因此默认情况下，它只保留最近的`128`个，但通过传递`maxsize=None`，我们可以将其用作标准缓存，并丢弃其中的LRU部分。所有调用将永远被缓存，没有限制。'
- en: Purely for the Fibonacci case, you will notice that setting `maxsize` to any
    value greater than `3` changes nothing, as each Fibonacci number only requires
    the previous two calls to be able to compute.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹针对斐波那契情况，你会注意到将`maxsize`设置为大于`3`的任何值都不会改变，因为每个斐波那契数只需要前两个调用就能计算。
- en: Operators to functions
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数到运算符
- en: Suppose you want to create a simple calculator. The first step is parsing the
    formula the user is going to write to be able to perform it. The basic formula
    is made of an operator and two operands, so you have, in practice, a function
    and its arguments.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想创建一个简单的计算器。第一步是解析用户将要写的公式以便执行它。基本公式由一个运算符和两个操作数组成，所以你实际上有一个函数和它的参数。
- en: But given `+`, `-`, and so on, how can we have our parser return the associated
    functions? Usually to sum two numbers, we just write `n1 + n2`, but we can't pass
    around `+` itself to be called with any `n1` and `n2`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，考虑到`+`，`-`等等，我们的解析器如何返回相关的函数呢？通常，为了对两个数字求和，我们只需写`n1 + n2`，但我们不能传递`+`本身来调用任何`n1`和`n2`。
- en: This is because `+` is an operator and not a function, but underlying that it's
    still just a function in CPython that gets executed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`+`是一个运算符而不是一个函数，但在CPython中它仍然只是一个函数被执行。
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We can use the `operator` module to get a callable that represents any Python
    operator that we can store or pass around:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`operator`模块来获取一个可调用的对象，表示我们可以存储或传递的任何Python运算符：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Our `calculate` function acts as a very basic calculator (without operators
    precedence, real numbers, negative numbers, and so on):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`calculate`函数充当一个非常基本的计算器（没有运算符优先级，实数，负数等）：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: So, we were able to store functions for the four mathematical operators in the
    `operators` dictionary and look them up based on the text that was encountered
    in the expression.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们能够在`operators`字典中存储四个数学运算符的函数，并根据表达式中遇到的文本查找它们。
- en: In `calculate`, the expression is split by space, so `5 + 3` becomes `['5',
    '+', '3']`. Once we have the three elements of the expression (the two operands
    and the operator), we can just iterate over the parts and when we encounter the
    `+`, look it up in the `operators` dictionary to get back the associated function
    that should be called, which is `operator.add`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在`calculate`中，表达式被空格分隔，因此`5 + 3`变成了`['5'，'+'，'3']`。一旦我们有了表达式的三个元素（两个操作数和运算符），我们只需遍历部分，当我们遇到`+`时，在`operators`字典中查找以获取应该调用的关联函数，即`operator.add`。
- en: The `operator` module contains functions for the most common Python operators,
    from comparisons (`operator.gt`) to dot-based attribute access (`operator.attrgetter`).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator`模块包含了最常见的Python运算符的函数，从比较（`operator.gt`）到基于点的属性访问（`operator.attrgetter`）。'
- en: Most of the provided functions are meant to be paired with `map`, `sorted`,
    `filter`, and so on.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数提供的函数都是为了与`map`、`sorted`、`filter`等配对使用。
- en: Partials
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分
- en: We already know that we can apply unary functions to multiple elements using `map`,
    and apply binary functions using `reduce`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道可以使用`map`将一元函数应用于多个元素，并使用`reduce`将二元函数应用于多个元素。
- en: There is a whole set of functions that accepts a callable in Python and applies
    it to a set of items.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有一整套函数接受Python中的可调用函数，并将其应用于一组项目。
- en: The major problem is that frequently the callable we want to apply might have
    a slightly different signature, and while we can solve the issue by wrapping the
    callable into another callable that adapts the signature, this is not very convenient
    if you just want to apply a function to a set of items.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 主要问题是，我们想要应用的可调用函数可能具有稍有不同的签名，虽然我们可以通过将可调用函数包装到另一个适应签名的可调用函数中来解决问题，但如果你只想将函数应用到一组项目中，这并不是很方便。
- en: For example, if you want to multiply all numbers in a list by 3, there is no
    function that multiplies a given argument by 3.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想将列表中的所有数字乘以3，没有一个函数可以将给定的参数乘以3。
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We can easily adapt `operator.mul` to be a unary function and then pass it
    to `map` to apply it to the whole list:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地将`operator.mul`调整为一元函数，然后将其传递给`map`以将其应用于整个列表：
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, `operator.mul` was called with `3` and the item as its arguments,
    and thus returned `item*3`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`operator.mul`被调用时带有`3`和项目作为其参数，因此返回`item*3`。
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created a new `mul3` callable through `functools.partial`. This callable
    just calls `operator.mul`, passing `3` as the first argument and then passing
    any argument provided to the callable to `operator.mul` as the second, third,
    and so on arguments.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`functools.partial`创建了一个新的`mul3`可调用函数。这个可调用函数只是调用`operator.mul`，将`3`作为第一个参数传递，然后将提供给可调用函数的任何参数作为第二、第三等参数传递给`operator.mul`。
- en: So, in the end, doing `mul3(5)` means `operator.mul(3, 5)`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终执行`mul3(5)`意味着`operator.mul(3, 5)`。
- en: This is because `functools.partial` creates a new function out of a provided
    function hardwiring the provided arguments.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`functools.partial`通过提供的函数硬编码提供的参数创建一个新函数。
- en: It is, of course, also possible to pass keyword arguments, so that instead of
    hardwiring the first argument, we can set any argument.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以传递关键字参数，这样我们就可以设置任何参数，而不是硬编码第一个参数。
- en: The resulting function is then applied to all numbers through `map`, which leads
    to creating a new list with all the numbers from 0 to 10 multiplied by 3.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将生成的函数应用于所有数字通过`map`，这将导致创建一个新列表，其中包含所有从0到10的数字乘以3。
- en: Generic functions
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用函数
- en: Generic functions are one of my favorite features of the standard library. Python
    is a very dynamic language and through duck-typing, you will frequently be able
    to write code that works in many different conditions (it doesn't matter if you
    receive a list or a tuple), but in some cases, you will really need to have two
    totally different code bases depending on the received input.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通用函数是标准库中我最喜欢的功能之一。Python是一种非常动态的语言，通过鸭子类型，你经常能够编写适用于许多不同条件的代码（无论你收到的是列表还是元组），但在某些情况下，你确实需要根据接收到的输入有两个完全不同的代码库。
- en: For example, we might want to have a function that prints content of the provided
    dictionary in a human-readable format, but we want it also to work properly on
    lists of tuples and report errors for unsupported types.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能希望有一个函数，以人类可读的格式打印所提供的字典内容，但我们也希望它在元组列表上正常工作，并报告不支持的类型的错误。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `functools.singledispatch` decorator allows us to implement a generic dispatch
    based on argument type:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`functools.singledispatch`装饰器允许我们基于参数类型实现通用分派：'
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Calling the three functions will properly dispatch the request to the right
    function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这三个函数将正确地将请求分派到正确的函数：
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works...
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The function decorated with `@singledispatch` actually gets replaced by a check
    for the argument type.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@singledispatch`装饰的函数实际上被一个对参数类型的检查所取代。
- en: 'Each call to `human_readable.register` will record into a registry which callable
    should be used for each argument type:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`human_readable.register`都会记录到一个注册表中，指定每种参数类型应该使用哪个可调用函数：
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Whenever the decorated function gets called, it will instead look up the type
    of the argument in the registry and will forward the call to the associated function
    for execution.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用装饰的函数时，它将在注册表中查找参数的类型，并将调用转发到关联的函数以执行。
- en: The function decorated with `@singledispatch` should always be the generic implementation,
    the one that should be used in case the argument is not explicitly supported.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@singledispatch`装饰的函数应该始终是通用实现，即在参数没有明确支持时应该使用的实现。
- en: In our example, this just throws an error, but frequently it will instead try
    to provide an implementation that works in most cases.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，这只是抛出一个错误，但通常情况下，它将尝试提供在大多数情况下有效的实现。
- en: Then the specific implementations can be registered with `@function.register`
    to cover the cases that the primary function couldn't cover or to actually implement
    the behavior if the primary function just throws an error.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用 `@function.register` 注册特定的实现，以覆盖主要函数无法覆盖的情况，或者实际实现行为，如果主要函数只是抛出错误。
- en: Proper decoration
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适当的装饰
- en: Decorators are usually not straightforward for anyone who faces them for the
    first time, but once you get used to them, they become a very convenient tool
    to extend a function's behavior or implement a lightweight form of aspect-oriented
    programming.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次面对装饰器的任何人来说，装饰器通常并不直接，但一旦你习惯了它们，它们就成为扩展函数行为或实现轻量级面向方面的编程的非常方便的工具。
- en: But even once decorators become natural and part of everyday development, they
    have subtleties that are not obvious until you face them for the first time.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使装饰器变得自然并成为日常开发的一部分，它们也有细微之处，直到您第一次面对它们时才会变得不明显。
- en: 'It might not be immediately obvious when you are applying a `decorator`, but
    by using them, you are changing the signature of the `decorated` function, up
    to the point that the name of the function itself and its documentation are lost:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当您应用 `decorator` 时，可能并不立即明显，但通过使用它们，您正在改变 `decorated` 函数的签名，直到函数本身的名称和文档都丢失：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `sumtwo` function was decorated with `decorator`, but now, if we try to
    access the function documentation or name, they won''t be accessible anymore:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`sumtwo` 函数被 `decorator` 装饰，但现在，如果我们尝试访问函数文档或名称，它们将不再可访问：'
- en: '[PRE49]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Even though we provided a docstring for `sumtwo` and we know for sure that it
    was named `sumtwo`, we need to ensure that our decorations are properly applied
    and preserve properties of the original functions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们为 `sumtwo` 提供了文档字符串，并且我们确切知道它的名称是 `sumtwo`，我们仍需要确保我们的装饰被正确应用并保留原始函数的属性。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps for this recipe:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，需要执行以下步骤：
- en: 'The Python standard library provides a `functools.wraps` decorator that can
    be applied to decorators to have them preserve the properties of the decorated
    functions:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 标准库提供了一个 `functools.wraps` 装饰器，可以应用于装饰器，以使它们保留装饰函数的属性：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here we apply the decorator to a function:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将装饰器应用于一个函数：
- en: '[PRE51]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you can see, it will properly retain the name and docstring of the function:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所看到的，它将正确保留函数的名称和文档字符串：
- en: '[PRE52]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If the decorated function had custom attributes, those will be copied to the
    new function too.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果装饰的函数有自定义属性，这些属性也将被复制到新函数中。
- en: There's more...
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`functools.wraps` is a very convenient tool and does its best to ensure that
    the decorated function looks exactly like the original one.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`functools.wraps` 是一个非常方便的工具，尽最大努力确保装饰函数看起来与原始函数完全一样。'
- en: But while the properties of the function can easily be copied, the signature
    of the function itself is not as easy to copy.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，虽然函数的属性可以很容易地被复制，但函数本身的签名并不容易复制。
- en: 'So inspecting our decorated function arguments won''t return the original arguments:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，检查我们装饰的函数参数不会返回原始参数：
- en: '[PRE53]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'So the reported arguments are just `*args` and `**kwargs` instead of `a` and
    `b`. To access the real arguments, we must dive into the underlying functions
    through the `__wrapped__` attribute:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，报告的参数只是 `*args` 和 `**kwargs` 而不是 `a` 和 `b`。要访问真正的参数，我们必须通过 `__wrapped__`
    属性深入到底层函数中：
- en: '[PRE54]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Luckily, the standard library provides an `inspect.signature` function that
    does this for us:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，标准库为我们提供了一个 `inspect.signature` 函数来做到这一点：
- en: '[PRE55]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: So, it's better to rely on `inspect.signature` whenever we want to check arguments
    of a function to be able to support both decorated and undecorated functions.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好在想要检查函数的参数时依赖于 `inspect.signature`，以便支持装饰和未装饰的函数。
- en: 'Applying decorations can also collide with other decorators. The most common
    example is `classmethod`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 应用装饰也可能与其他装饰器冲突。最常见的例子是 `classmethod`：
- en: '[PRE56]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Trying to decorate `classmethod` won''t usually work:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试装饰 `classmethod` 通常不起作用：
- en: '[PRE57]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You need to make sure that `@classmethod` is always the last applied decorator,
    to ensure it will work as expected:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保 `@classmethod` 始终是最后应用的装饰器，以确保它将按预期工作：
- en: '[PRE58]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'At that point, the `classmethod` will work as expected:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在那时，`classmethod` 将按预期工作：
- en: '[PRE59]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: There are so many decorator-related quirks that the Python environment has libraries
    that try to implement decoration properly for everyday usage. If you don't want
    to think about how to handle them, you might want to try the `wrapt` library,
    which will take care of most decoration oddities for you.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Python 环境中有许多与装饰器相关的怪癖，因此有一些库试图为日常使用正确实现装饰。如果您不想考虑如何处理它们，您可能想尝试 `wrapt` 库，它将为您处理大多数装饰怪癖。
- en: Context managers
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文管理器
- en: Decorators can be used to ensure that something is executed when you enter and
    exit a function, but in some cases, you might want to ensure that something is
    always executed at the beginning and end of a block of code without having to
    move it to its own function or without rewriting those parts that should be executed
    every time.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器可用于确保在进入和退出函数时执行某些操作，但在某些情况下，您可能希望确保在代码块的开头和结尾始终执行某些操作，而无需将其移动到自己的函数中或重写应该每次执行的部分。
- en: Context managers exist to solve this need, factoring out code that you would
    have to rewrite over and over in place of `try:except:finally:` clauses.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器存在是为了解决这个需求，将您必须一遍又一遍地重写的代码因 `try:except:finally:` 子句而被分解出来。
- en: The most common usage of context managers is probably the closing context manager,
    which ensures that files get closed once the developer is done working with them,
    but the standard library makes it easy to write new ones.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器最常见的用法可能是关闭上下文管理器，它确保文件在开发人员完成使用它们后关闭，但标准库使编写新的上下文管理器变得很容易。
- en: How to do it...
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, the following steps are to be performed:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，需要执行以下步骤：
- en: '`contextlib` provides features related to context managers, `contextlib.contextmanager`
    can make it very easy to write context managers:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`contextlib`提供了与上下文管理器相关的功能，`contextlib.contextmanager`可以使编写上下文管理器变得非常容易：'
- en: '[PRE60]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then the context manager created can be used like any other context manager:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建的上下文管理器可以像任何其他上下文管理器一样使用：
- en: '[PRE61]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Exceptions raised within the wrapped block will be propagated to the context
    manager, so it''s possible to handle them with a standard `try:except:finally:`
    clause and do any proper cleanup:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包装块内引发的异常将传播到上下文管理器，因此可以使用标准的`try:except:finally:`子句来处理它们并进行适当的清理：
- en: '[PRE62]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The changed context manager will be able to log exceptions without interfering
    with the exception propagation:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改后的上下文管理器将能够记录异常，而不会干扰异常的传播。
- en: '[PRE63]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Applying variable context managers
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用可变上下文管理器
- en: 'When using context managers, you must rely on the `with` statement to apply
    them. While it''s possible to apply more than one context manager per statement
    by separating them with commas, it''s not as easy to apply a variable number of
    them:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用上下文管理器时，必须依赖`with`语句来应用它们。虽然可以通过用逗号分隔它们来在一个语句中应用多个上下文管理器，但是要应用可变数量的上下文管理器并不那么容易：
- en: '[PRE64]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The context managers that we want to apply must be known when writing the code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时必须知道要应用的上下文管理器：
- en: '[PRE65]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: But what if sometimes we only want to apply the `first` context manager, and
    sometimes we want to apply both?
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果有时我们只想应用`first`上下文管理器，有时又想同时应用两个呢？
- en: How to do it...
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: '`contextlib.ExitStack` serves various purposes, one of which is to allow us
    to apply a variable number of context managers to a block.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`contextlib.ExitStack`有各种用途，其中之一是允许我们对一个块应用可变数量的上下文管理器。'
- en: 'For example, we might want to apply both context managers only when we are
    printing an even number in a loop:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能只想在循环中打印偶数时同时应用两个上下文管理器：
- en: '[PRE66]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The result will be that the `second` is only added to the context, and thus
    invoked for even numbers:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是`second`只被添加到上下文中，因此仅对偶数调用：
- en: '[PRE67]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, for `1` and `3`, only `First` is printed.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，对于`1`和`3`，只有`First`被打印出来。
- en: Of course, when exiting the context declared through the `ExitStack` context
    manager, all the context managers registered within the `ExitStack` will be exited
    too.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过`ExitStack`上下文管理器声明的上下文退出时，`ExitStack`中注册的所有上下文管理器也将被退出。
