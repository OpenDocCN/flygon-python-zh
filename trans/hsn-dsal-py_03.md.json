["```py\npython3 -mpip install matplotlib\n```", "```py\nsudo apt-get install python3-matplotlib \n```", "```py\ndef MatrixChain(mat, i, j):   \n    if i == j:   \n        return 0   \n    minimum_computations = sys.maxsize  \n    for k in range(i, j): \n        count = (MatrixChain(mat, i, k) + MatrixChain(mat, k+1, j)+ mat[i-1] * mat[k] * mat[j])   \n        if count < minimum_computations:  \n              minimum_computations= count;    \n        return minimum_computations;  \n\nmatrix_sizes = [20, 30, 45, 50];  \nprint(\"Minimum multiplications are\", MatrixChain(matrix_sizes , 1, len(matrix_sizes)-1));\n\n#prints 72000\n```", "```py\ndef factorial(n): \n    # test for a base case      \n    if  n==0: \n        return 1 \n        #make a calculation and a recursive call\n    else: \n        f= n*factorial(n-1) \n    print(f) \n    return(f) \n\nfactorial(4)\n```", "```py\ndef bitStr(n,s):\n if n==1: return s \n return [digit + bits for digit in bitStr(1,s) for bits in bitStr(n-1,s)] \n\nprint(bitStr(3,'abc'))\n```", "```py\nfrom math import log10 \ndef karatsuba(x,y): \n\n    #The base case for recursion \n    if x<10 or y<10:\n        return x*y \n\n    #sets n, the number of digits in the highest input number\n    n=max(int(log10(x)+1), int(log10(y)+1)) \n\n    #rounds up n/2  \n    n_2 = int(math.ceil(n/2.0)) \n    #adds 1 if n is uneven  \n    n = n if n%2 == 0  else n+1 \n    #splits the input numbers \n    a, b = divmod(x, 10**n_2) \n    c, d = divmod(y,10**n_2) \n    #applies the three recursive steps \n    ac = karatsuba(a,c) \n    bd = karatsuba(b,d)  \n    ad_bc = karatsuba((a+b),(c+d))-ac-bd \n\n    #performs the multiplication \n    return (((10**n)*ac)+bd+((10**n_2)*(ad_bc)))\n\nt= karatsuba(1234,3456)\nprint(t)\n\n# outputs - 4264704\n```", "```py\ndef mergeSort(A): \n#base case if the input array is one or zero just return. \nif len(A) > 1: \n    # splitting input array \n    print('splitting ', A ) \n    mid=len(A)//2   \n    left=A[:mid]   \n    right=A[mid:] \n    #recursive calls to mergeSort for left and right subarrays \n    mergeSort(left)   \n    mergeSort(right) \n    #initalizes pointers for left(i) right(j) and output array (k)\n\n    #3 initalization operations \n    i = j = k = 0 \n    #Traverse and merges the sorted arrays \n    while i < len(left) and j < len(right):  \n    #if left < right comparison operation \n        if left[i] < right[j]:  \n        #if left < right Assignment operation  \n            A[k] = left[i]  \n            i=i+1 \n        else:   \n            #if right <= left assignment \n            A[k]=right[j] \n            j=j+1   \n            k=k+1   \n\n    while i< len(left):   \n    #Assignment operation \n        A[k] = left[i] \n        i=i+1   \n        k=k+1   \n\n    while j< len(right):   \n    # Assignment operation    \n        A[k] = right[j] \n        j=j+1 \n        k=k+1 \n\nprint('merging',A) \nreturn(A)\n```", "```py\nimport matplotlib.pyplotasplt \nimport math   \nx = list(range(1,100))   \nl=[]; l2=[]; a=1   \nplt.plot(x, [y*y for y in x])  \nplt.plot(x, [(7*y)*math.log(y,2) for y in x]) \nplt.show()\n```", "```py\nplt.plot(x, [(6*y)* math.log(y, 2) for y in x])\n```", "```py\n# Linear search program to search an element, return the index position of the #array\ndef searching(search_arr, x):     \n    for i in range(len(search_arr)):         \n        if search_arr [i] == x:             \n                return i     \n    return -1\n\nsearch_ar= [3, 4, 1, 6, 14]\nx=4\n\nsearching(search_ar, x)\nprint(\"Index position for the element x is :\",searching(search_ar, x))\n\n#outputs index position of the element x that is - 1\n```", "```py\nfor i in range(n): \n        f(...)\n```", "```py\nfor i in range(0,n): \n    for j in range(0,n)  \n            #statements\n```", "```py\nn=500  #c0 \n#executes n times  \nfor i in range(0,n):  \n    print(i)    #c1\n   #executes n times   \nfor i in range(0,n):  \n#executes n times  \n    for j in range(0,n):  \n            print(j)  #c2\n```", "```py\ni=1   \nwhile i<=n: \n    i=i*2 \n    print(i)   \n```", "```py\ndef nest(n):   \nfor i in range(n):   \n     for j in range(n):  \n            i+j\n```", "```py\nimport timeit \ndef test2(n): \n    ls=[]   \n    for n in range(n):\n        t=timeit.timeit(\"nest(\" + str(n) + \")\", setup=\"from _main_ import nest\", number=1)  \n        ls.append(t) \n    return ls\n```", "```py\nimport matplotlib.pyplot as plt \nn=1000 \nplt.plot(test2(n)) \nplt.plot([x*x/10000000 for x in range(n)])\n```"]