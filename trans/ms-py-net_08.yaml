- en: Network Monitoring with Python – Part 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行网络监控-第2部分
- en: In [Chapter 7](bfb06aa0-1deb-4432-80ae-f15e3644fa54.xhtml), *Network Monitoring
    with Python – Part 1*, we used SNMP to query information from network devices.
    We did this by using an SNMP manager to query the SNMP agent residing on the network
    device. The SNMP information is structured in a hierarchy format with a specific
    object ID as the way to represent the value of the object. Most of the time, the
    value we care about is a number, such as CPU load, memory usage, or interface
    traffic. It's something we can graph against time to give us a sense of how the
    value has changed over time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](bfb06aa0-1deb-4432-80ae-f15e3644fa54.xhtml)中，*使用Python进行网络监控-第1部分*，我们使用SNMP从网络设备查询信息。我们通过使用SNMP管理器查询驻留在网络设备上的SNMP代理来实现这一点。SNMP信息以层次结构格式化，具有特定的对象ID来表示对象的值。大多数时候，我们关心的值是一个数字，比如CPU负载、内存使用率或接口流量。这是我们可以根据时间绘制图表，以便让我们了解值随时间的变化。
- en: We can typically classify the SNMP approach as a `pull` method as we are constantly
    asking the device for a particular answer. This particular method adds burden
    to the device because it needs to spend a CPU cycle on the control plane to find
    answers from the subsystem, package the answer in an SNMP packet, and transport
    the answer back to the poller. If you have ever been to a family reunion where
    you have that one family member who keeps asking you the same questions over and
    over again, that would be analogous to the SNMP manager polling the managed node.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常可以将SNMP方法归类为“拉”方法，因为我们不断地向设备请求特定的答案。这种方法会给设备增加负担，因为它需要在控制平面上花费CPU周期从子系统中找到答案，将答案打包成一个SNMP数据包，并将答案传输回轮询器。如果你曾经参加过家庭聚会，有一个家庭成员一遍又一遍地问你同样的问题，那就相当于SNMP管理器不断轮询受管节点。
- en: Over time, if we have multiple SNMP pollers querying the same device every 30
    seconds (you would be surprised how often this happens), the management overhead
    would become substantial. In the same family reunion example we have given, instead
    of one family member, imagine there are many other people interrupting you every
    30 seconds to ask you a question. I don't know about you, but I know I would be
    very annoyed even if it was a simple question (or worse if all of them are asking
    the same question).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，如果我们有多个SNMP轮询器每30秒查询同一个设备（你会惊讶地发现这种情况经常发生），管理开销将变得相当大。在我们给出的家庭聚会的例子中，想象一下不是一个家庭成员，而是许多其他人每30秒打断你问你一个问题。我不知道你怎么想，但我知道即使是一个简单的问题（或者更糟糕的是，如果所有人都问同样的问题），我也会感到非常恼火。
- en: Another way we can provide more efficient network monitoring is to reverse the
    relationship between the management station from a pull to a push model. In other
    words, the information can be pushed from the device toward the management station
    in an agreed-upon format. This concept is what flow-based monitoring is based
    on. In a flow-based model, the network device streams the traffic information,
    called flow, to the management station. The format can be the Cisco proprietary
    NetFlow (version 5 or version 9), the industry standard IPFIX, or the open source
    sFlow format. In this chapter, we will spend some time looking into NetFlow, IPFIX,
    and sFlow with Python.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提供更有效的网络监控的另一种方法是将管理站与设备之间的关系从拉模型转变为推模型。换句话说，信息可以以约定的格式从设备推送到管理站。这个概念是基于基于流的监控。在基于流的模型中，网络设备将流量信息流向管理站。格式可以是思科专有的NetFlow（版本5或版本9），行业标准IPFIX，或开源sFlow格式。在本章中，我们将花一些时间用Python来研究NetFlow、IPFIX和sFlow。
- en: Not all monitoring comes in the form of time series data. You can represent
    information such as network topology and Syslog in a time series format if you
    really want to, but, this is not ideal. We can use Python to check network topology
    information and see if the topology has changed over time. We can use tools, such
    as Graphviz, with a Python wrapper, to illustrate the topology. As already seen
    in [Chapter 6](30262891-a82e-4bef-aae2-2e8fe530a16f.xhtml), *Network Security
    with Python*, Syslog contains security information. In this chapter, we will look
    at using the ELK stack (Elasticsearch, Logstash, Kibana) as an efficient way to
    collect and index network log information.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的监控都以时间序列数据的形式出现。如果你真的愿意，你可以将网络拓扑和Syslog等信息表示为时间序列格式，但这并不理想。我们可以使用Python来检查网络拓扑信息，并查看拓扑是否随时间发生了变化。我们可以使用Graphviz等工具与Python包装器来说明拓扑。正如在[第6章](30262891-a82e-4bef-aae2-2e8fe530a16f.xhtml)中已经看到的，*使用Python进行网络安全*，Syslog包含安全信息。在本章中，我们将研究使用ELK堆栈（Elasticsearch、Logstash、Kibana）作为收集和索引网络日志信息的有效方法。
- en: 'Specifically, in this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，我们将涵盖以下主题：
- en: Graphviz, which is an open source graph visualization software that can help
    us quickly and efficiently graph our network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Graphviz，这是一个开源的图形可视化软件，可以帮助我们快速高效地绘制网络图
- en: Flow-based monitoring, such as NetFlow, IPFIX, and sFlow
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于流的监控，如NetFlow、IPFIX和sFlow
- en: Using ntop to visualize the flow information
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ntop来可视化流量信息
- en: Using Elasticsearch to index and analyze our collected data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Elasticsearch来索引和分析我们收集的数据
- en: Let's start by looking at how to use Graphviz as a tool to monitor network topology
    changes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看如何使用Graphviz作为监控网络拓扑变化的工具。
- en: Graphviz
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Graphviz
- en: 'Graphviz is an open source graph visualization software. Imagine if we have
    to describe our network topology to a colleague without the benefit of a picture.
    We might say, our network consists of three layers: core, distribution, and access.
    The core layer comprises two routers for redundancy, and both of the routers are
    full-meshed toward the four distribution routers; the distribution routers are
    also full-meshed toward the access routers. The internal routing protocol is OSPF,
    and externally, we use BGP for peering with our service provider. While this description
    lacks some details, it is probably enough for your colleague to paint a pretty
    good high-level picture of your network.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Graphviz是一种开源的图形可视化软件。想象一下，如果我们不用图片的好处来描述我们的网络拓扑给同事。我们可能会说，我们的网络由三层组成：核心、分发和接入。核心层包括两台路由器用于冗余，并且这两台路由器都对四台分发路由器进行全网状连接；分发路由器也对接入路由器进行全网状连接。内部路由协议是OSPF，外部使用BGP与服务提供商进行对等连接。虽然这个描述缺少一些细节，但对于您的同事来说，这可能足够绘制出您网络的一个相当不错的高层图像。
- en: Graphviz works similarly to the process by describing the graph in the text
    format that Graphviz can understand, then we can feed the file to the Graphviz
    program to construct the graph for us. Here, the graph is described in a text
    format called DOT ([https://en.wikipedia.org/wiki/DOT_(graph_description_language)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)))
    and Graphviz renders the graph based on the description. Of course, because the
    computer lacks human imagination, the language has to be very precise and detailed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Graphviz的工作方式类似于通过描述Graphviz可以理解的文本格式来描述图形，然后我们可以将文件提供给Graphviz程序来为我们构建图形。在这里，图形是用一种称为DOT的文本格式描述的（[https://en.wikipedia.org/wiki/DOT_(graph_description_language)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)）），Graphviz根据描述渲染图形。当然，因为计算机缺乏人类的想象力，语言必须非常精确和详细。
- en: For Graphviz-specific DOT grammar definitions, take a look at [http://www.graphviz.org/doc/info/lang.html](http://www.graphviz.org/doc/info/lang.html).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Graphviz特定的DOT语法定义，请查看[http://www.graphviz.org/doc/info/lang.html](http://www.graphviz.org/doc/info/lang.html)。
- en: In this section, we will use the **Link Layer Discovery Protocol** (**LLDP**)
    to query the device neighbors and create a network topology graph via Graphviz.
    Upon completing this extensive example, we will see how we can take something
    new, such as Graphviz, and combine it with things we have already learned to solve
    interesting problems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用**链路层发现协议**（**LLDP**）来查询设备邻居，并通过Graphviz创建网络拓扑图。完成这个广泛的示例后，我们将看到如何将新的东西，比如Graphviz，与我们已经学到的东西结合起来解决有趣的问题。
- en: Let's start by constructing the lab we will be using.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建我们将要使用的实验室。
- en: Lab setup
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验室设置
- en: 'We will use VIRL to construct our lab. As in the previous chapters, we will
    put together a lab with multiple routers, a server, and a client. We will use
    five IOSv network nodes along with two server hosts:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用VIRL来构建我们的实验室。与前几章一样，我们将组建一个包括多个路由器、一个服务器和一个客户端的实验室。我们将使用五个IOSv网络节点以及两个服务器主机：
- en: '![](assets/3166a522-47db-4a53-bd7f-0e15ad415b04.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3166a522-47db-4a53-bd7f-0e15ad415b04.png)'
- en: 'If you are wondering about our choice of IOSv as opposed to NX-OS or IOS-XR
    and the number of devices, here are a few points for you to consider when you
    build your own lab:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道我们选择IOSv而不是NX-OS或IOS-XR以及设备数量的原因，在构建自己的实验室时，请考虑以下几点：
- en: Nodes virtualized by NX-OS and IOS-XR are much more memory-intensive than IOS
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由NX-OS和IOS-XR虚拟化的节点比IOS更占用内存
- en: The VIRL virtual manager I am using has 8 GB of RAM, which seems enough to sustain
    nine nodes but could be a bit unstable (nodes changing from reachable to unreachable
    at random)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我使用的VIRL虚拟管理器有8GB的RAM，似乎足够支持九个节点，但可能会有点不稳定（节点随机从可达到不可达）
- en: If you wish to use NX-OS, consider using NX-API or other API calls that would
    return structured data
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您希望使用NX-OS，请考虑使用NX-API或其他API调用来返回结构化数据
- en: 'For our example, we are going to use LLDP as the protocol for link layer neighbor
    discovery because it is vendor-neutral. Note that VIRL provides an option to automatically
    enable CDP, which can save you some time and is similar to LLDP in functionality;
    however, it is a Cisco proprietary technology so we will disable it for our lab:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将使用LLDP作为链路层邻居发现的协议，因为它是与厂商无关的。请注意，VIRL提供了自动启用CDP的选项，这可以节省一些时间，并且在功能上类似于LLDP；但是，它是一种思科专有技术，因此我们将在我们的实验室中禁用它：
- en: '![](assets/7ffca5b5-9a64-4fdd-b214-e5af0d08b772.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7ffca5b5-9a64-4fdd-b214-e5af0d08b772.png)'
- en: Once the lab is up and running, proceed to installing the necessary software
    packages.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实验室建立完成后，继续安装必要的软件包。
- en: Installation
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'Graphviz can be obtained via `apt`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`apt`获取Graphviz：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After the installation is complete, note that verification is performed by
    using the `dot` command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，请注意使用`dot`命令进行验证：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will use the Python wrapper for Graphviz, so let''s install it now while
    we are at it:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Graphviz的Python包装器，所以让我们现在安装它：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's take a look at how we can use the software.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用这个软件。
- en: Graphviz examples
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Graphviz示例
- en: Like most popular open source projects, the documentation of Graphviz ([http://www.graphviz.org/Documentation.php](http://www.graphviz.org/Documentation.php))
    is extensive. The challenge for someone new to the software is often where to
    start. For our purpose, we will focus on the dot graph, which draws directed graphs
    as hierarchies (not to be confused with the DOT language, which is a graph description
    language).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数流行的开源项目一样，Graphviz的文档（[http://www.graphviz.org/Documentation.php](http://www.graphviz.org/Documentation.php)）是非常广泛的。对于新手来说，挑战通常在于从何处开始。对于我们的目的，我们将专注于绘制有向图的dot图，这是一种层次结构（不要与DOT语言混淆，DOT语言是一种图描述语言）。
- en: 'Let''s start with some of the basic concepts:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些基本概念开始：
- en: Nodes represent our network entities, such as routers, switches, and servers
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点代表我们的网络实体，如路由器、交换机和服务器
- en: The edge represents the link between the network entities
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘代表网络实体之间的链接
- en: The graph, nodes, and edges each have attributes ([https://www.graphviz.org/doc/info/attrs.html](https://www.graphviz.org/doc/info/attrs.html))
    that can be tweaked
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图表、节点和边都有可以调整的属性([https://www.graphviz.org/doc/info/attrs.html](https://www.graphviz.org/doc/info/attrs.html))
- en: After describing the network, we can output the network graph ([https://www.graphviz.org/doc/info/output.html](https://www.graphviz.org/doc/info/output.html))
    in either PNG, JPEG, or PDF format
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述网络后，我们可以将网络图([https://www.graphviz.org/doc/info/output.html](https://www.graphviz.org/doc/info/output.html))输出为PNG、JPEG或PDF格式
- en: 'Our first example is an undirected dot graph consisting of four nodes (`core`,
    `distribution`, `access1`, and `access2`). The edges, represented by the dash `-` sign,
    join the core node to the distribution node, as well as the distribution node
    to both of the access nodes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子是一个无向点图，由四个节点(`core`、`distribution`、`access1`和`access2`)组成。边由破折号`-`符号表示，将核心节点连接到分布节点，以及将分布节点连接到两个访问节点：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The graph can be output in the `dot -T<format> source -o <output file>` command
    line:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图表可以在命令行中输出为`dot -T<format> source -o <output file>`：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The resultant graph can be viewed from the following output folder:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表可以从以下输出文件夹中查看：
- en: '![](assets/89a0f1b3-4b29-4dd0-a5f8-58ee33fbd5c5.png)Just like [Chapter 7](bfb06aa0-1deb-4432-80ae-f15e3644fa54.xhtml),
    *Network Monitoring with Python – Part 1*, it might be easier to work in the Linux
    desktop window while working with these graphs so you can see the graphs right
    away.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 就像[第7章](bfb06aa0-1deb-4432-80ae-f15e3644fa54.xhtml)中的*使用Python进行网络监控-第1部分*一样，当处理这些图表时，可能更容易在Linux桌面窗口中工作，这样你就可以立即看到图表。
- en: 'Note that we can use a directional graph by specifying the graph as a digraph
    as well as using the arrow (`->`) sign to represent the edges. There are several
    attributes we can modify in the case of nodes and edges, such as the node shape,
    edge labels, and so on. The same graph can be modified as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以通过将图表指定为有向图，并使用箭头(`->`)符号来表示边来使用有向图。在节点和边的情况下，有几个属性可以修改，例如节点形状、边标签等。同一个图表可以修改如下：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will output the file in PDF this time:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将文件输出为PDF：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Take a look at the directional arrows in the new graph:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下新图表中的方向箭头：
- en: '![](assets/9856fec1-2710-4661-8be9-99f9a65151de.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9856fec1-2710-4661-8be9-99f9a65151de.png)'
- en: Now let's take a look at the Python wrapper around Graphviz.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下围绕Graphviz的Python包装器。
- en: Python with Graphviz examples
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python与Graphviz示例
- en: 'We can reproduce the same topology graph as before using the Python Graphviz
    package which we have installed:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们安装的Python Graphviz包再次生成与之前相同的拓扑图：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code basically produces what you would normally write in the DOT language
    but in a more Pythonic way. You can view the source of the graph before the graph
    generation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码基本上产生了您通常会用DOT语言编写的内容，但以更Pythonic的方式。您可以在生成图表之前查看图表的源代码：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The graph can be rendered by the `render()` method; by default, the output
    format is PDF:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图表可以通过`render()`方法呈现；默认情况下，输出格式为PDF：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Python package wrapper closely mimics all the API options of Graphviz. You
    can find documentation about the options on the Graphviz Read the Docs website
    ([http://graphviz.readthedocs.io/en/latest/index.html](http://graphviz.readthedocs.io/en/latest/index.html)).
    You can also refer to the source code on GitHub for more information ([https://github.com/xflr6/graphviz](https://github.com/xflr6/graphviz)).
    We are now ready to use the tool to map out our network.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Python包装器紧密模仿了Graphviz的所有API选项。您可以在Graphviz Read the Docs网站([http://graphviz.readthedocs.io/en/latest/index.html](http://graphviz.readthedocs.io/en/latest/index.html))上找到有关选项的文档。您还可以在GitHub上查看源代码以获取更多信息([https://github.com/xflr6/graphviz](https://github.com/xflr6/graphviz))。我们现在准备使用这个工具来绘制我们的网络。
- en: LLDP neighbor graphing
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LLDP邻居图
- en: 'In this section, we will use the example of mapping out LLDP neighbors to illustrate
    a problem-solving pattern that has helped me over the years:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用映射LLDP邻居的示例来说明多年来帮助我的问题解决模式：
- en: Modularize each task into smaller pieces, if possible. In our example, we can
    combine a few steps, but if we break them into smaller pieces, we will be able
    to reuse and improve them more easily.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可能的话，将每个任务模块化为更小的部分。在我们的例子中，我们可以合并几个步骤，但如果我们将它们分解成更小的部分，我们将能够更容易地重用和改进它们。
- en: Use an automation tool to interact with the network devices, but keep the more
    complex logic aside at the management station. For example, the router has provided
    an LLDP neighbor output that is a bit messy. In this case, we will stick with
    the working command and the output and use a Python script at the management station
    to parse out the output we need.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自动化工具与网络设备交互，但将更复杂的逻辑保留在管理站。例如，路由器提供了一个有点混乱的LLDP邻居输出。在这种情况下，我们将坚持使用可行的命令和输出，并在管理站使用Python脚本来解析我们需要的输出。
- en: When presented with choices for the same task, pick the one that can be reused.
    In our example, we can use low-level Pexpect, Paramiko, or Ansible playbooks to
    query the routers. In my opinion, Ansible is a more reusable option, so that is
    what I have picked.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在面对相同任务的选择时，选择可以重复使用的选项。在我们的例子中，我们可以使用低级别的Pexpect、Paramiko或Ansible playbooks来查询路由器。在我看来，Ansible是一个更可重用的选项，所以我选择了它。
- en: 'To get started, since LLDP is not enabled on the routers by default, we will
    need to configure them on the devices first. By now, we know we have a number
    of options to choose from; in this case, I chose the Ansible playbook with the
    `ios_config` module for the task. The `hosts` file consists of five routers:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，因为路由器默认情况下未启用LLDP，我们需要首先在设备上配置它们。到目前为止，我们知道我们有许多选择；在这种情况下，我选择了使用`ios_config`模块的Ansible
    playbook来完成任务。`hosts`文件包括五台路由器：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `cisco_config_lldp.yml` playbook consists of one play with variables embedded
    in the playbook to configure LLDP:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`cisco_config_lldp.yml` playbook包括一个play，其中嵌入了用于配置LLDP的变量：'
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After a few seconds, to allow LLDP exchange, we can verify that LLDP is indeed
    active on the routers:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，为了允许LLDP交换，我们可以验证LLDP确实在路由器上处于活动状态：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the output, you will see that `G0/0` is configured as the MGMT interface;
    therefore, you will see LLDP peers as if they are on a flat management network.
    What we really care about is the `G0/1` and `G0/2` interfaces connected to other
    peers. This knowledge will come in handy as we prepare to parse the output and
    construct our topology graph.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，您将看到`G0/0`配置为MGMT接口；因此，您将看到LLDP对等方，就好像它们在一个平坦的管理网络上一样。我们真正关心的是连接到其他对等方的`G0/1`和`G0/2`接口。当我们准备解析输出并构建我们的拓扑图时，这些知识将派上用场。
- en: Information retrieval
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息检索
- en: 'We can now use another Ansible playbook, namely `cisco_discover_lldp.yml`,
    to execute the LLDP command on the device and copy the output of each device to
    a `tmp` directory:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用另一个Ansible playbook，即`cisco_discover_lldp.yml`，在设备上执行LLDP命令，并将每个设备的输出复制到`tmp`目录中：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `./tmp` directory now consists of all the routers'' output (showing LLDP
    neighbors) in its own file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ./tmp目录现在包含所有路由器的输出（显示LLDP邻居）的文件：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `r1_lldp_output.txt` content is the `output.stdout_lines` variable from
    our Ansible playbook:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`r1_lldp_output.txt`的内容是我们Ansible playbook中的`output.stdout_lines`变量：'
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Python parser script
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python解析脚本
- en: We can now use a Python script to parse the LLDP neighbor output from each device
    and construct a network topology graph from the results. The purpose is to automatically
    check the device to see whether any of the LLDP neighbors have disappeared due
    to link failure or other issues. Let's take a look at the `cisco_graph_lldp.py`
    file and see how that is done.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用Python脚本解析每个设备的LLDP邻居输出，并从结果构建网络拓扑图。目的是自动检查设备，看看LLDP邻居是否由于链路故障或其他问题而消失。让我们看看`cisco_graph_lldp.py`文件，看看是如何做到的。
- en: 'We start with the necessary imports of the packages: an empty list that we
    will populate with tuples of node relationships. We also know that `Gi0/0` on
    the devices are connected to the management network; therefore, we are only searching
    for `Gi0/[1234]` as our regular expression pattern in the `show LLDP neighbors`
    output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从包的必要导入开始：一个空列表，我们将用节点关系的元组填充它。我们也知道设备上的`Gi0/0`连接到管理网络；因此，我们只在`show LLDP neighbors`输出中搜索`Gi0/[1234]`作为我们的正则表达式模式：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will use the `glob.glob()` method to traverse the `./tmp` directory of all
    the files, parse out the device name, and find the neighbors that the device is
    connected to. There are some embedded print statements in the script that we can
    comment out for the final version; if the statements were uncommented, we can
    see the parsed result:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`glob.glob()`方法遍历`./tmp`目录中的所有文件，解析出设备名称，并找到设备连接的邻居。脚本中有一些嵌入的打印语句，我们可以在最终版本中注释掉；如果取消注释，我们可以看到解析的结果：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The fully populated edge list contains tuples that consist of the device and
    its neighbors:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 完全填充的边列表包含了由设备及其邻居组成的元组：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can now construct the network topology graph using the Graphviz package.
    The most important part is the unpacking of the tuples that represent the edge
    relationship:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用Graphviz包构建网络拓扑图。最重要的部分是解压代表边关系的元组：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we were to print out the resulting source dot file, it would be an accurate
    representation of our network:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印出结果的源dot文件，它将是我们网络的准确表示：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Sometimes, it is confusing to see the same link twice; for example, the `r2`
    to `r5-tor` link appeared twice in the previous diagram for each of the directions
    of the link. As network engineers, we understand that sometimes a fault in the
    physical link will result in a unidirectional link, which we want to see.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，看到相同的链接两次会让人困惑；例如，`r2`到`r5-tor`的链接在上一个图表中每个方向都出现了两次。作为网络工程师，我们知道有时物理链接故障会导致单向链接，我们希望看到这种情况。
- en: 'If we were to graph the diagram as is, the placement of the nodes would be
    a bit funky. The placement of the nodes is auto-rendered. The following diagram
    illustrates the rendering in a default layout as well as the `neato` layout, namely
    a digraph (`My_Network`, `engine=''neato''`):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按原样绘制图表，节点的放置会有点奇怪。节点的放置是自动渲染的。以下图表说明了默认布局以及`neato`布局的渲染，即有向图（`My_Network`，`engine='neato'`）：
- en: '![](assets/dde9bc1b-9f98-4da2-ac4e-4bea01181aa1.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dde9bc1b-9f98-4da2-ac4e-4bea01181aa1.png)'
- en: 'The `neato` layout represents an attempt to draw undirected graphs with even
    less hierarchy:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`neato`布局表示尝试绘制更少层次结构的无向图：'
- en: '![](assets/54d47a85-be7a-4294-acf5-056fae7ad784.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/54d47a85-be7a-4294-acf5-056fae7ad784.png)'
- en: 'Sometimes, the default layout presented by the tool is just fine, especially
    if your goal is to detect faults as opposed to making it visually appealing. However,
    in this case, let''s see how we can insert raw DOT language knobs into the source
    file. From research, we know that we can use the `rank` command to specify the
    level where some nodes can stay on the same level. However, there is no option
    presented in the Graphviz Python API. Luckily, the dot source file is just a string,
    which we can insert as raw dot comments using the `replace()` method with the
    following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，工具提供的默认布局就很好，特别是如果你的目标是检测故障而不是使其视觉上吸引人。然而，在这种情况下，让我们看看如何将原始DOT语言旋钮插入源文件。通过研究，我们知道可以使用`rank`命令指定一些节点可以保持在同一级别。然而，在Graphviz
    Python API中没有提供这个选项。幸运的是，dot源文件只是一个字符串，我们可以使用`replace()`方法插入原始dot注释，如下所示：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The end result is a new source that we can render the final topology graph
    from:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是一个新的源文件，我们可以从中渲染最终的拓扑图：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The graph is now good to go:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图现在可以使用了：
- en: '![](assets/b0444bef-47f9-44c4-a33c-e9b8aca1caee.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b0444bef-47f9-44c4-a33c-e9b8aca1caee.png)'
- en: Final playbook
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终playbook
- en: 'We are now ready to incorporate this new parser script back into our playbook.
    We can now add the additional task of rendering the output with graph generation
    in `cisco_discover_lldp.yml`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备将这个新的解析脚本重新整合到我们的playbook中。我们现在可以添加渲染输出和图形生成的额外任务到`cisco_discover_lldp.yml`中：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This playbook will now include four tasks, covering the end-to-end process of
    executing the `show lldp` command on the Cisco devices, displaying the output
    on the screen, copying the output to a separate file, and then rendering the output
    via a Python script.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这本playbook现在将包括四个任务，涵盖了在Cisco设备上执行`show lldp`命令的端到端过程，将输出显示在屏幕上，将输出复制到单独的文件，然后通过Python脚本呈现输出。
- en: The playbook can now be scheduled to run regularly via `cron` or other means.
    It will automatically query the devices for LLDP neighbors and construct the graph,
    and the graph will represent the current topology as known by the routers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: playbook现在可以通过`cron`或其他方式定期运行。它将自动查询设备的LLDP邻居并构建图表，该图表将代表路由器所知的当前拓扑结构。
- en: 'We can test this by shutting down the `Gi0/1` and `Go0/2` interfaces on `r6-edge`.
    When the LLDP neighbor passes the hold timer, they will disappear from the LLDP
    table on `r6-edge`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过关闭`r6-edge`上的`Gi0/1`和`Go0/2`接口来测试这一点。当LLDP邻居超时时，它们将从`r6-edge`的LLDP表中消失。
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we execute the playbook, the graph will automatically show that `r6-edge`
    only connects to `r3` and we can start to troubleshoot why that is the case:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行这个playbook，图表将自动显示`r6-edge`只连接到`r3`，我们可以开始排查为什么会这样。
- en: '![](assets/061f359c-1354-4204-a779-51bf15a11c9c.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/061f359c-1354-4204-a779-51bf15a11c9c.png)'
- en: This is a relatively long example. We used the tools we have learned so far
    in the book—Ansible and Python—to modularize and break tasks into reusable pieces.
    We then used a new tool, namely Graphviz, to help monitor the network for non-time
    series data, such as network topology relationships.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对较长的例子。我们使用了书中学到的工具——Ansible和Python——来模块化和将任务分解为可重用的部分。然后我们使用了一个新工具，即Graphviz，来帮助监视网络的非时间序列数据，如网络拓扑关系。
- en: Flow-based monitoring
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于流的监控
- en: As mentioned in the chapter introduction, besides polling technology, such as
    SNMP, we can also use a push strategy, which allows the device to push network
    information toward the management station. NetFlow and its closely associated
    cousins, IPFIX and sFlow, are examples of such information pushed from the direction
    of the network device toward the management station. We can make the argument
    that the `push` method is more sustainable since the network device is inherently
    in charge of allocating the necessary resources to push the information. If the
    device CPU is busy, for example, it can choose to skip the flow export process
    in favor of routing packets, which is what we want.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如章节介绍中提到的，除了轮询技术（如SNMP）之外，我们还可以使用推送策略，允许设备将网络信息推送到管理站点。NetFlow及其密切相关的IPFIX和sFlow就是从网络设备向管理站点推送的信息的例子。我们可以认为`推送`方法更具可持续性，因为网络设备本身负责分配必要的资源来推送信息。例如，如果设备的CPU繁忙，它可以选择跳过流导出过程，而优先路由数据包，这正是我们想要的。
- en: A flow, as defined by IETF ([https://www.ietf.org/proceedings/39/slides/int/ip1394-background/tsld004.htm](https://www.ietf.org/proceedings/39/slides/int/ip1394-background/tsld004.htm)),
    is a sequence of packets moving from an application sending something to the application
    receiving it. If we refer back to the OSI model, a flow is what constitutes a
    single unit of communication between two applications. Each flow comprises a number
    of packets; some flows have more packets (such as a video stream), while some
    have just a few (such as an HTTP request). If you think about flows for a minute,
    you'll notice that routers and switches might care about packets and frames, but
    the application and user usually care more about the network flows.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 根据IETF的定义，流是从发送应用程序到接收应用程序的一系列数据包。如果我们回顾OSI模型，流就是构成两个应用程序之间通信的单个单位。每个流包括多个数据包；有些流有更多的数据包（如视频流），而有些只有几个（如HTTP请求）。如果你思考一下流，你会注意到路由器和交换机可能关心数据包和帧，但应用程序和用户通常更关心网络流。
- en: 'Flow-based monitoring usually refers to NetFlow, IPFIX, and sFlow:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 基于流的监控通常指的是NetFlow、IPFIX和sFlow：
- en: '**NetFlow**: NetFlow v5 is a technology where the network device caches flow
    entries and aggregate packets by matching the set of tuples (source interface,
    source IP/port, destination IP/port, and so on). Here, once a flow is completed,
    the network device exports the flow characteristics, including total bytes and
    packet counts in the flow, to the management station.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NetFlow**：NetFlow v5是一种技术，网络设备会缓存流条目，并通过匹配元组集（源接口、源IP/端口、目的IP/端口等）来聚合数据包。一旦流完成，网络设备会导出流特征，包括流中的总字节数和数据包计数，到管理站点。'
- en: '**IPFIX**: IPFIX is the proposed standard for structured streaming and is similar
    to NetFlow v9, also known as Flexible NetFlow. Essentially, it is a definable
    flow export, which allows the user to export nearly anything that the network
    device knows about. The flexibility often comes at the expense of simplicity compared
    to NetFlow v5\. The configuration of IPFIX is more complex than the traditional
    NetFlow v5\. Additional complexity makes it less ideal for introductory learning.
    However, once you are familiar with NetFlow v5, you will be able to parse IPFIX
    as long as you match the template definition.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IPFIX**：IPFIX是结构化流的提议标准，类似于NetFlow v9，也被称为灵活NetFlow。基本上，它是一个可定义的流导出，允许用户导出网络设备了解的几乎任何内容。灵活性往往是以简单性为代价的，与NetFlow
    v5相比，IPFIX的配置更加复杂。额外的复杂性使其不太适合初学者学习。但是，一旦你熟悉了NetFlow v5，你就能够解析IPFIX，只要你匹配模板定义。'
- en: '**sFlow**: sFlow actually has no notion of a flow or packet aggregation by
    itself. It performs two types of sampling of packets. It randomly samples one
    out of *n* packets/applications and has a time-based sampling counter. It sends
    the information to the management station, and the station derives the network
    flow information by referring to the type of packet sample received along with
    the counters. As it doesn''t perform any aggregation on the network device, you
    can argue that sFlow is more scalable than NetFlow and IPFIX.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sFlow：sFlow实际上没有流或数据包聚合的概念。它对数据包进行两种类型的抽样。它随机抽样*n*个数据包/应用程序，并具有基于时间的抽样计数器。它将信息发送到管理站，管理站通过参考接收到的数据包样本类型和计数器来推导网络流信息。由于它不在网络设备上执行任何聚合，可以说sFlow比NetFlow和IPFIX更具可扩展性。
- en: The best way to learn about each one of these is probably to dive right into
    examples.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 了解每个模块的最佳方法可能是直接进入示例。
- en: NetFlow parsing with Python
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python解析NetFlow
- en: We can use Python to parse the NetFlow datagram being transported on the wire.
    This gives us a way to look at the NetFlow packet in detail as well as troubleshoot
    any NetFlow issues when it is not working as expected.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Python解析在线上传输的NetFlow数据报。这为我们提供了一种详细查看NetFlow数据包以及在其工作不如预期时排除任何NetFlow问题的方法。
- en: 'First, let''s generate some traffic between the client and server across the
    VIRL network. We can use the built-in HTTP server module from Python to quickly
    launch a simple HTTP server on the VIRL host acting as the server:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在VIRL网络的客户端和服务器之间生成一些流量。我们可以使用Python的内置HTTP服务器模块快速在充当服务器的VIRL主机上启动一个简单的HTTP服务器：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For Python 2, the module is named `SimpleHTTPServer`; for example, `python2
    -m SimpleHTTPServer`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python 2，该模块的名称为`SimpleHTTPServer`；例如，`python2 -m SimpleHTTPServer`。
- en: 'We can create a short `while` loop in a Python script to continuously send
    `HTTP GET` to the web server on the client:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Python脚本中创建一个简短的`while`循环，不断向客户端的Web服务器发送`HTTP GET`：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The client should get a very plain HTML page:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应该得到一个非常简单的HTML页面：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We should also see the requests continuously coming in from the client every
    five seconds:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该看到客户端每五秒不断发出请求：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can export NetFlow from any of the devices, but since `r6-edge` is the first
    hop for the client host, we will have this router export NetFlow to the management
    host at port `9995`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从任何设备导出NetFlow，但由于`r6-edge`是客户端主机的第一跳，我们将使此路由器将NetFlow导出到端口`9995`的管理主机。
- en: In this example, we use only one device for demonstration; therefore, we manually
    configure it with the necessary commands. In the next section, when we enable
    NetFlow on all the devices, we will use an Ansible playbook to configure all the
    routers at once.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们仅使用一个设备进行演示；因此，我们手动配置它所需的命令。在下一节中，当我们在所有设备上启用NetFlow时，我们将使用Ansible playbook一次性配置所有路由器。
- en: 'The following configurations are necessary for exporting NetFlow on the Cisco
    IOS devices:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cisco IOS设备上导出NetFlow需要以下配置：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, let's take a look at the Python parser script.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下Python解析器脚本。
- en: Python socket and struct
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python socket和struct
- en: The script, `netFlow_v5_parser.py`, was modified from Brian Rak's blog post
    at [http://blog.devicenull.org/2013/09/04/python-netflow-v5-parser.html](http://blog.devicenull.org/2013/09/04/python-netflow-v5-parser.html).
    The modification was mainly for Python 3 compatibility as well as parsing additional
    NetFlow version 5 fields. The reason we choose NetFlow v5 instead of NetFlow v9
    is that v9 is more complex and uses templates to map out the fields, making it
    more difficult to learn in an introductory session. However, since NetFlow version
    9 is an extended format of the original NetFlow version 5, all the concepts we
    introduced in this section are applicable to it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本`netFlow_v5_parser.py`是从Brian Rak的博客文章[http://blog.devicenull.org/2013/09/04/python-netflow-v5-parser.html](http://blog.devicenull.org/2013/09/04/python-netflow-v5-parser.html)修改而来。修改主要是为了Python
    3兼容性以及解析额外的NetFlow版本5字段。我们选择NetFlow v5而不是NetFlow v9的原因是v9更复杂，使用模板来映射字段，使得在入门会话中更难学习。但是，由于NetFlow版本9是原始NetFlow版本5的扩展格式，本节介绍的所有概念都适用于它。
- en: Because NetFlow packets are represented in bytes over the wire, we will use
    the Python struct module included in the standard library to convert bytes into
    native Python data types.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因为NetFlow数据包在线上传输时以字节表示，我们将使用标准库中包含的Python struct模块将字节转换为本机Python数据类型。
- en: You'll find more information about the two modules at [https://docs.python.org/3.5/library/socket.html](https://docs.python.org/3.5/library/socket.html)
    and [https://docs.python.org/3.5/library/struct.html](https://docs.python.org/3.5/library/struct.html).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.python.org/3.5/library/socket.html](https://docs.python.org/3.5/library/socket.html)和[https://docs.python.org/3.5/library/struct.html](https://docs.python.org/3.5/library/struct.html)找到有关这两个模块的更多信息。
- en: 'We will start by using the socket module to bind and listen for the UDP datagrams.
    With `socket.AF_INET`, we intend on listing for the IPv4 address sockets; with
    `socket.SOCK_DGRAM`, we specify that we''ll see the UDP datagram:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用socket模块绑定和监听UDP数据报。使用`socket.AF_INET`，我们打算监听IPv4地址套接字；使用`socket.SOCK_DGRAM`，我们指定将查看UDP数据报：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will start a loop and retrieve information off the wire 1,500 bytes at a
    time:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动一个循环，并每次从线上检索1,500字节的信息：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following line is where we begin to deconstruct or unpack the packet. The
    first argument of `!HH` specifies the network''s big-endian byte order with the
    exclamation sign (big-endian) as well as the format of the C type (`H = 2` byte
    unsigned short integer):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行是我们开始解构或解包数据包的地方。`!HH`的第一个参数指定了网络的大端字节顺序，感叹号表示大端字节顺序，以及C类型的格式（`H = 2`字节无符号短整数）：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first four bytes include the version and the number of flows exported in
    this packet. If you do not remember the NetFlow version 5 header off the top of
    your head (that was a joke, by the way; I only read the header when I want to
    fall asleep quickly), here is a quick glance:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个字节包括版本和此数据包中导出的流数。如果您没有记住NetFlow版本5标头（顺便说一句，这是一个玩笑；我只是在想要快速入睡时才会读标头），这里有一个快速浏览：
- en: '![](assets/1cb08f1a-95f9-4402-a1b2-ee4753fc54b8.png)NetFlow v5 header (source:  http://www.cisco.com/c/en/us/td/docs/net_mgmt/netflow_collection_engine/3-6/user/guide/format.html#wp1006108)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1cb08f1a-95f9-4402-a1b2-ee4753fc54b8.png)NetFlow v5标头（来源：http://www.cisco.com/c/en/us/td/docs/net_mgmt/netflow_collection_engine/3-6/user/guide/format.html#wp1006108）'
- en: 'The rest of the header can be parsed accordingly, depending on the byte location
    and data type:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的标头可以根据字节位置和数据类型进行相应的解析：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `while` loop that follows will fill the `nfdata` dictionary with the flow
    record that unpacks the source address and port, destination address and port,
    packet count, and byte count, and print the information out on the screen:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的`while`循环将使用流记录填充`nfdata`字典，解包源地址和端口、目的地址和端口、数据包计数和字节计数，并在屏幕上打印出信息：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output of the script allows you to visualize the header as well as the
    flow content at a glance:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的输出允许您一目了然地查看标头以及流内容：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that, in NetFlow version 5, the size of the record is fixed at 48 bytes;
    therefore, the loop and script are relatively straightforward. However, in the
    case of NetFlow version 9 or IPFIX, after the header, there is a template FlowSet
    ([http://www.cisco.com/en/US/technologies/tk648/tk362/technologies_white_paper09186a00800a3db9.html](http://www.cisco.com/en/US/technologies/tk648/tk362/technologies_white_paper09186a00800a3db9.html))
    that specifies the field count, field type, and field length. This allows the
    collector to parse the data without knowing the data format in advance.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在NetFlow版本5中，记录的大小固定为48字节；因此，循环和脚本相对简单。但是，在NetFlow版本9或IPFIX的情况下，在标头之后，有一个模板FlowSet（[http://www.cisco.com/en/US/technologies/tk648/tk362/technologies_white_paper09186a00800a3db9.html](http://www.cisco.com/en/US/technologies/tk648/tk362/technologies_white_paper09186a00800a3db9.html)），它指定了字段计数、字段类型和字段长度。这使得收集器可以在不事先知道数据格式的情况下解析数据。
- en: By parsing the NetFlow data in a script, we gained a solid understanding of
    the fields, but this is very tedious and hard to scale. As you may have guessed,
    there are other tools that save us the problem of parsing NetFlow records one
    by one. Let's look at one such tool, called **ntop**, in the coming section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在脚本中解析NetFlow数据，我们对字段有了很好的理解，但这非常繁琐且难以扩展。正如您可能已经猜到的那样，还有其他工具可以帮助我们避免逐个解析NetFlow记录的问题。让我们在接下来的部分看看这样的一个工具，名为**ntop**。
- en: ntop traffic monitoring
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ntop流量监控
- en: Just like the PySNMP script in [Chapter 7](bfb06aa0-1deb-4432-80ae-f15e3644fa54.xhtml),
    *Network Monitoring with Python – Part 1*, and the NetFlow parser script in this
    chapter, we can use Python scripts to handle low-level tasks on the wire. However,
    there are tools such as Cacti, which is an all-in-one open source package, that
    include data collection (poller), data storage (RRD), and a web frontend for visualization.
    These tools can save you a lot of work by packing the frequently used features
    and software in one package.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 就像[第7章](bfb06aa0-1deb-4432-80ae-f15e3644fa54.xhtml)中的PySNMP脚本，以及本章中的NetFlow解析器脚本一样，我们可以使用Python脚本来处理线路上的低级任务。但是，也有一些工具，比如Cacti，它是一个包含数据收集（轮询器）、数据存储（RRD）和用于可视化的web前端的一体化开源软件包。这些工具可以通过将经常使用的功能和软件打包到一个软件包中来节省大量工作。
- en: In the case of NetFlow, there are a number of open source and commercial NetFlow
    collectors you can choose from. If you do a quick search for top N open source
    NetFlow analyzers, you will see a number of comparison studies for different tools.
    Each one of them has its own strong and weak points; which one to use is really
    a matter of preference, platform, and your appetite for customization. I would
    recommend choosing a tool that would support both v5 and v9, and potentially sFlow
    as well. A secondary consideration would be if the tool is written in a language
    that you can understand; I imagine having Python extensibility would be a nice
    thing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在NetFlow的情况下，有许多开源和商业NetFlow收集器可供选择。如果您快速搜索前N个开源NetFlow分析器，您将看到许多不同工具的比较研究。它们每个都有自己的优势和劣势；使用哪一个实际上是一种偏好、平台和您对定制的兴趣。我建议选择一个既支持v5又支持v9，可能还支持sFlow的工具。其次要考虑的是工具是否是用您能理解的语言编写的；我想拥有Python可扩展性会是一件好事。
- en: Two of the open source NetFlow tools that I like and have used before are NfSen
    (with NFDUMP as the backend collector) and `ntop` (or `ntopng`). Between the two
    of them, `ntop` is the better-known traffic analyzer; it runs on both Windows
    and Linux platforms and integrates well with Python. Therefore, let's use `ntop`
    as an example in this section.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢并以前使用过的两个开源NetFlow工具是NfSen（后端收集器为NFDUMP）和`ntop`（或`ntopng`）。在这两者中，`ntop`是更为知名的流量分析器；它可以在Windows和Linux平台上运行，并且与Python集成良好。因此，在本节中，让我们以`ntop`为例。
- en: 'The installation of our Ubuntu host is straightforward:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Ubuntu主机的安装很简单：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The installation process will prompt for the necessary interface for listening
    and setting the administrator password. By default, the `ntop` web interface listens
    on port `3000`, while the probe listens on UDP port `5556`. On the network device,
    we need to specify the location of the NetFlow exporter:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程将提示输入必要的接口以进行监听，并设置管理员密码。默认情况下，`ntop` web界面监听端口为`3000`，而探针监听UDP端口为`5556`。在网络设备上，我们需要指定NetFlow导出器的位置：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: By default, IOSv creates a VRF called `Mgmt-intf` and places `Gi0/0` under VRF.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，IOSv创建一个名为`Mgmt-intf`的VRF，并将`Gi0/0`放在VRF下。
- en: 'We will also need to specify the direction of traffic exports, such as ingress
    or egress, under the interface configuration:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在接口配置下指定流量导出的方向，比如入口或出口：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For your reference, I have included the Ansible playbook, `cisco_config_netflow.yml`,
    to configure the lab device for the NetFlow export.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 供您参考，我已经包含了Ansible playbook，“cisco_config_netflow.yml”，用于配置实验设备进行NetFlow导出。
- en: The `r5-tor` and `r6-edge` have two interfaces more than `r1`, `r2`, and `r3` do.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`r5-tor`和`r6-edge`比`r1`、`r2`和`r3`多两个接口。'
- en: 'Execute the playbook and make sure the changes were applied properly on the
    devices:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 执行playbook并确保设备上的更改已正确应用：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once everything is set up, you can check the ntop web interface for local IP
    traffic:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都设置好后，您可以检查ntop web界面以查看本地IP流量：
- en: '![](assets/e414a37d-aacc-43ef-a619-d95d026509cf.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e414a37d-aacc-43ef-a619-d95d026509cf.png)'
- en: 'One of the most often used features of ntop is using it to look at the top
    talker graph:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ntop最常用的功能之一是使用它来查看最活跃的对话者图表：
- en: '![](assets/b5516589-b8af-4feb-b605-e603552db5bd.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b5516589-b8af-4feb-b605-e603552db5bd.png)'
- en: The ntop reporting engine is written in C; it is fast and efficient, but the
    need to have adequate knowledge of C in order to do something as simple as change
    the web frontend does not fit the modern agile development mindset.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ntop报告引擎是用C编写的；它快速高效，但是需要对C有足够的了解才能做一些像改变web前端这样简单的事情，这并不符合现代敏捷开发的思维方式。
- en: After a few false starts with Perl in the mid-2000s, the good folks at ntop
    finally settled on embedding Python as an extensible scripting engine. Let's take
    a look.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在2000年代中期，ntop的人们在Perl上尝试了几次，最终决定将Python嵌入为可扩展的脚本引擎。让我们来看看。
- en: Python extension for ntop
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ntop的Python扩展
- en: 'We can use Python to extend ntop through the ntop web server. The ntop web
    server can execute Python scripts. At a high level, the scripts will perform the
    following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Python通过ntop web服务器来扩展ntop。ntop web服务器可以执行Python脚本。在高层次上，脚本将执行以下操作：
- en: Methods to access the state of ntop
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问ntop状态的方法
- en: The Python CGI module to process forms and URL parameters
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python CGI模块处理表单和URL参数
- en: Making templates that generate dynamic HTML pages
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作生成动态HTML页面的模板
- en: Each Python script can read from `stdin` and print out `stdout/stderr`
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个Python脚本都可以从`stdin`读取并打印出`stdout/stderr`
- en: The `stdout` script is the returned HTTP page
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdout`脚本是返回的HTTP页面'
- en: 'There are several resources that come in handy with the Python integration.
    Under the web interface, you can click on About|Show Configuration to see the
    Python interpreter version as well as the directory for your Python script:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个资源对于Python集成非常有用。在Web界面下，您可以单击关于|显示配置，以查看Python解释器版本以及Python脚本的目录：
- en: '![](assets/df42b61f-c658-4b7b-b622-3d0a1e38244d.png)Python version'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/df42b61f-c658-4b7b-b622-3d0a1e38244d.png)Python版本'
- en: 'You can also check the various directories where the Python script should reside:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以检查Python脚本应该驻留的各个目录：
- en: '![](assets/f76bf24a-6008-4e58-90a9-cd40ddd4b3e4.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f76bf24a-6008-4e58-90a9-cd40ddd4b3e4.png)'
- en: Plugin directories
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 插件目录
- en: 'Under About | Online Documentation | Python ntop Engine, there are links for
    the Python API as well as the tutorial:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于|在线文档|Python ntop引擎下，有Python API和教程的链接：
- en: '![](assets/bb5f4a60-be4f-443f-b572-5b0cab30ba76.png)Python ntop documentation'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/bb5f4a60-be4f-443f-b572-5b0cab30ba76.png)Python ntop文档'
- en: 'As mentioned, the `ntop` web server directly executes the Python script placed
    under the designated directory:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，ntop web服务器直接执行放置在指定目录下的Python脚本：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will place our first script, namely `chapter8_ntop_1.py`, in the directory.
    The Python `CGI` module processes forms and parses URL parameters:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的第一个脚本，即`chapter8_ntop_1.py`，放在目录中。Python `CGI`模块处理表单并解析URL参数：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`ntop` implements three Python modules; each one of them has a specific purpose:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`ntop`实现了三个Python模块；每个模块都有特定的目的：'
- en: '`ntop`: This module interacts with the `ntop` engine'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ntop`：此模块与`ntop`引擎交互'
- en: '**Host**: This module is used to drill down into a specific host''s information'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机**：此模块用于深入了解特定主机的信息'
- en: '**Interfaces**: This module represents the information about the localhost
    interfaces'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**：此模块表示有关本地主机接口的信息'
- en: 'In our script, we will use the `ntop` module to retrieve the `ntop` engine
    information as well as use the `sendString()` method to send the HTML body text:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本中，我们将使用`ntop`模块来检索`ntop`引擎信息，并使用`sendString()`方法发送HTML正文文本：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We will execute the Python script using `http://<ip>:3000/python/<script name>`.
    Here is the result of our `chapter8_ntop_1.py` script:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`http://<ip>:3000/python/<script name>`来执行Python脚本。这是我们的`chapter8_ntop_1.py`脚本的结果：
- en: '![](assets/869976ca-1508-4a7b-a9ba-4bdd8c66b83e.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/869976ca-1508-4a7b-a9ba-4bdd8c66b83e.png)'
- en: 'We can look at another example that interacts with the interface module, `chapter8_ntop_2.py`.
    We will use the API to iterate through the interfaces:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看另一个与接口模块交互的示例，`chapter8_ntop_2.py`。我们将使用API来遍历接口：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The resulting page will display the ntop interfaces:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的页面将显示ntop接口：
- en: '![](assets/6140fbbb-7e30-4897-ad3f-fabcd4ce6fa6.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6140fbbb-7e30-4897-ad3f-fabcd4ce6fa6.png)'
- en: Besides the community version, ntop also offers a few commercial products that
    you can choose from. With the active open source community, commercial backing,
    and Python extensibility, ntop is a good choice for your NetFlow monitoring needs.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 除了社区版本外，ntop还提供了一些商业产品供您选择。凭借活跃的开源社区、商业支持和Python可扩展性，ntop是您NetFlow监控需求的不错选择。
- en: 'Next, let''s take a look at NetFlow''s cousin: sFlow.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看看NetFlow的表兄弟：sFlow。
- en: sFlow
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sFlow
- en: sFlow, which stands for sampled flow, was originally developed by InMon ([http://www.inmon.com](http://www.inmon.com))
    and later standardized by way of RFC. The current version is v5\. Many in the
    industry believe the primary advantage of sFlow is its scalability. sFlow uses
    random one in `n` packets flow samples along with the polling interval of counter
    samples to derive an estimate of the traffic; this is less CPU-intensive than
    NetFlow for the network devices. sFlow's statistical sampling is integrated with
    the hardware and provides real-time, raw exports.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: sFlow最初由InMon（[http://www.inmon.com](http://www.inmon.com)）开发，后来通过RFC进行了标准化。当前版本是v5。行业内许多人认为sFlow的主要优势是其可扩展性。sFlow使用随机的一种`n`数据包流样本以及计数器样本的轮询间隔来推导出流量的估计；这比网络设备的NetFlow更节省CPU。sFlow的统计采样与硬件集成，并提供实时的原始导出。
- en: For scalability and competitive reasons, sFlow is generally preferred over NetFlow
    for newer vendors, such as Arista Networks, Vyatta, and A10 Networks. While Cisco
    supports sFlow on its Nexus line of products, sFlow is generally *not* supported
    on Cisco platforms.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 出于可扩展性和竞争原因，sFlow通常比NetFlow更受新供应商的青睐，例如Arista Networks、Vyatta和A10 Networks。虽然思科在其Nexus产品线上支持sFlow，但通常*不*支持在思科平台上使用sFlow。
- en: SFlowtool and sFlow-RT with Python
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SFlowtool和sFlow-RT与Python
- en: Unfortunately, at this point, sFlow is something that our VIRL lab devices do
    not support (not even with the NX-OSv virtual switches). You can either use a
    Cisco Nexus 3000 switch or other vendor switches, such as Arista, that support
    sFlow. Another good option for the lab is to use an Arista vEOS virtual instance.
    I happen to have access to a Cisco Nexus 3048 switch running 7.0 (3), which I
    will be using for this section as the sFlow exporter.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，到目前为止，sFlow是我们的VIRL实验室设备不支持的东西（即使是NX-OSv虚拟交换机也不支持）。您可以使用思科Nexus 3000交换机或其他支持sFlow的供应商交换机，例如Arista。实验室的另一个好选择是使用Arista
    vEOS虚拟实例。我碰巧可以访问运行7.0（3）的思科Nexus 3048交换机，我将在本节中使用它作为sFlow导出器。
- en: 'The configuration of Cisco Nexus 3000 for sFlow is straightforward:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 思科Nexus 3000的sFlow配置非常简单：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The easiest way to ingest sFlow is to use `sflowtool`. For installation instructions,
    refer to the document at [http://blog.sflow.com/2011/12/sflowtool.html](http://blog.sflow.com/2011/12/sflowtool.html):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 摄取sFlow的最简单方法是使用`sflowtool`。有关安装说明，请参阅[http://blog.sflow.com/2011/12/sflowtool.html](http://blog.sflow.com/2011/12/sflowtool.html)上的文档：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After the installation, you can launch `sflowtool` and look at the datagram
    Nexus 3048 is sending on the standard output:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以启动`sflowtool`并查看Nexus 3048发送到标准输出的数据报：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'There are a number of good usage examples on the `sflowtool` GitHub repository
    ([https://github.com/sflow/sflowtool](https://github.com/sflow/sflowtool)); one
    of them is to use a script to receive the `sflowtool` input and parse the output.
    We can use a Python script for this purpose. In the `chapter8_sflowtool_1.py`
    example, we will use `sys.stdin.readline` to receive the input and use a regular
    expression search to print out only the lines containing the word `agent` when
    we see the sFlow packets:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`sflowtool` GitHub存储库（[https://github.com/sflow/sflowtool](https://github.com/sflow/sflowtool)）上有许多很好的用法示例；其中之一是使用脚本接收`sflowtool`输入并解析输出。我们可以使用Python脚本来实现这个目的。在`chapter8_sflowtool_1.py`示例中，我们将使用`sys.stdin.readline`接收输入，并使用正则表达式搜索仅打印包含单词`agent`的行当我们看到sFlow数据包时：'
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The script can be piped to `sflowtool`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本可以通过管道传输到`sflowtool`：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: There are a number of other useful output examples, such as `tcpdump`, output
    as NetFlow version 5 records, and a compact line-by-line output. This makes `sflowtool`
    very flexible to suit your monitoring environment.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他有用的输出示例，例如`tcpdump`，以NetFlow版本5记录输出，以及紧凑的逐行输出。这使得`sflowtool`非常灵活，以适应您的监控环境。
- en: 'ntop supports sFlow, which means you can directly export your sFlow to the
    ntop collector. If your collector is only NetFlow-aware, you can use the `-c`
    option for the `sflowtool` output in the NetFlow version 5 format:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ntop支持sFlow，这意味着您可以直接将您的sFlow导出到ntop收集器。如果您的收集器只支持NetFlow，您可以在NetFlow版本5格式中使用`sflowtool`输出的`-c`选项：
- en: '[PRE49]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Alternatively, you can also use InMon's sFlow-RT ([http://www.sflow-rt.com/index.php](http://www.sflow-rt.com/index.php))
    as your sFlow analytics engine. What sets sFlow-RT apart from an operator perspective
    is its vast REST API that can be customized to support your use cases. You can
    also easily retrieve the metrics from the API. You can take a look at its extensive
    API reference at [http://www.sflow-rt.com/reference.php](http://www.sflow-rt.com/reference.php).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以使用InMon的sFlow-RT（[http://www.sflow-rt.com/index.php](http://www.sflow-rt.com/index.php)）作为您的sFlow分析引擎。sFlow-RT从操作员的角度来看，其主要优势在于其庞大的REST
    API，可以定制以支持您的用例。您还可以轻松地从API中检索指标。您可以在[http://www.sflow-rt.com/reference.php](http://www.sflow-rt.com/reference.php)上查看其广泛的API参考。
- en: 'Note that sFlow-RT requires Java to run the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，sFlow-RT需要Java才能运行以下内容：
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Once installed, downloading and running sFlow-RT is straightforward ([https://sflow-rt.com/download.php](https://sflow-rt.com/download.php)):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，下载和运行sFlow-RT非常简单（[https://sflow-rt.com/download.php](https://sflow-rt.com/download.php)）：
- en: '[PRE51]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can point the web browser to HTTP port `8008` and verify the installation:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将Web浏览器指向HTTP端口`8008`并验证安装：
- en: '![](assets/ac593583-04c5-4b0b-8ade-4a925b583726.png)sFlow-RT about'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/ac593583-04c5-4b0b-8ade-4a925b583726.png)sFlow-RT about'
- en: 'As soon as sFlow-RT receives any sFlow packets, the agents and other metrics
    will appear:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦sFlow-RT接收到任何sFlow数据包，代理和其他指标将出现：
- en: '![](assets/1a438b4c-45c7-459a-953f-54991e570b6e.png)sFlow-RT agents'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/1a438b4c-45c7-459a-953f-54991e570b6e.png)sFlow-RT agents'
- en: 'Here are two examples of using Python requests to retrieve information from
    sFlow-RT''s REST API:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Python请求从sFlow-RT的REST API中检索信息的两个示例：
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Consult the reference documentation for additional REST endpoints available
    for your needs. Next, we will take a look at another tool called **Elasticsearch**,
    which is becoming pretty popular for both Syslog index and general network monitoring.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 咨询参考文档，了解可用于您需求的其他REST端点。接下来，我们将看看另一个工具，称为**Elasticsearch**，它正在成为Syslog索引和一般网络监控的相当流行的工具。
- en: Elasticsearch (ELK stack)
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elasticsearch（ELK堆栈）
- en: As we have seen so far in this chapter, using just the Python tools as we have
    done would adequately monitor your network with enough scalability for all types
    of networks, large and small alike. However, I would like to introduce one additional
    open source, general-purpose, distributed search and analytics engine called **Elasticsearch**
    ([https://www.elastic.co/](https://www.elastic.co/)). It is often referred to
    as just **Elastic** or **ELK stack** for combining **Elastic** with the frontend
    and input packages **Logstash**, and **Kibana**, respectively.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章中所看到的，仅使用我们已经使用的Python工具就足以监控您的网络，并具有足够的可扩展性，适用于各种规模的网络，无论大小。然而，我想介绍一个名为**Elasticsearch**（[https://www.elastic.co/](https://www.elastic.co/)）的额外的开源、通用分布式搜索和分析引擎。它通常被称为**Elastic**或**ELK堆栈**，用于将**Elastic**与前端和输入包**Logstash**和**Kibana**结合在一起。
- en: If you look at network monitoring in general, it is really about analyzing network
    data and making sense out of it. The ELK stack contains Elasticsearch, Logstash,
    and Kibana as a full stack to ingest information with Logstash, index and analyze
    data with Elasticsearch, and present the graphics output via Kibana. It is really
    three projects in one. It also has the flexibility to substitute Logstash with
    another input, such as **Beats**. Alternatively, you can use other tools, such
    as **Grafana**, instead of Kibana for visualization. The ELK stack by Elastic
    Co*.* also provides many add-on tools, referred to as **X-Pack**, for additional
    security, alerting, monitoring, and so on.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您总体上看网络监控，实际上是分析网络数据并理解其中的意义。ELK堆栈包含Elasticsearch、Logstash和Kibana作为完整的堆栈，使用Logstash摄取信息，使用Elasticsearch索引和分析数据，并通过Kibana呈现图形输出。它实际上是三个项目合而为一。它还具有灵活性，可以用其他输入替换Logstash，比如**Beats**。或者，您可以使用其他工具，比如**Grafana**，而不是Kibana进行可视化。Elastic
    Co*.*的ELK堆栈还提供许多附加工具，称为**X-Pack**，用于额外的安全性、警报、监控等。
- en: As you can probably tell by the description, ELK (or even Elasticsearch alone)
    is a deep topic to cover, and there are many books written on the subject. Even
    covering the basic usage would take up more space than we can spare in this book.
    I have considered leaving the subject out of the book simply because of its depth.
    However, ELK has become a very important tool for many of the projects that I
    am working on, including network monitoring. I feel leaving it out would be a
    huge disservice to you.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能从描述中可以看出，ELK（甚至仅是Elasticsearch）是一个深入的主题，有许多关于这个主题的书籍。即使只涵盖基本用法，也会占用比我们在这本书中可以空出的更多空间。我曾考虑过将这个主题从书中删除，仅仅是因为它的深度。然而，ELK已经成为我正在进行的许多项目中非常重要的工具，包括网络监控。我觉得不把它放在书中会对你造成很大的伤害。
- en: 'Therefore, I am going to take a few pages to briefly introduce the tool and
    a few use cases along with information for you to dig deeper if desired. We will
    go through the following topics:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我将花几页时间简要介绍这个工具以及一些用例，以及一些信息，让您有兴趣深入了解。我们将讨论以下主题：
- en: Setting up a hosted ELK service
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立托管的ELK服务
- en: The Logstash format
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Logstash格式
- en: Python's helper script for Logstash formatting
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Logstash格式的Python辅助脚本
- en: Setting up a hosted ELK service
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立托管的ELK服务
- en: The entire ELK stack can be installed as a standalone server or distributed
    across multiple servers. The installation steps are available at [https://www.elastic.co/guide/en/elastic-stack/current/installing-elastic-stack.html](https://www.elastic.co/guide/en/elastic-stack/current/installing-elastic-stack.html).
    In my experience, even with a minimal amount of data, a single VM running the
    ELK stack often stretches the resources. My first attempt at running ELK as a
    single VM lasted no more than a few days with barely two or three network devices
    sending log information toward it. After a few more unsuccessful attempts at running
    my own cluster as a beginner, I eventually settled on running the ELK stack as
    a hosted service, and this is what I would recommend you to start with.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 整个ELK堆栈可以安装为独立服务器或分布在多台服务器上。安装步骤可在[https://www.elastic.co/guide/en/elastic-stack/current/installing-elastic-stack.html](https://www.elastic.co/guide/en/elastic-stack/current/installing-elastic-stack.html)上找到。根据我的经验，即使只有少量数据，运行ELK堆栈的单个虚拟机通常也会耗尽资源。我第一次尝试将ELK作为单个虚拟机运行，仅持续了几天，几乎只有两三个网络设备向其发送日志信息。在作为初学者运行自己的集群的几次不成功尝试之后，我最终决定将ELK堆栈作为托管服务运行，这也是我建议您开始使用的方式。
- en: 'As a hosted service, there are two providers that you can consider:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 作为托管服务，有两个提供商可以考虑：
- en: '**Amazon Elasticsearch Service** ([https://aws.amazon.com/elasticsearch-service/](https://aws.amazon.com/elasticsearch-service/))'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon Elasticsearch Service**（[https://aws.amazon.com/elasticsearch-service/](https://aws.amazon.com/elasticsearch-service/)）'
- en: '**Elastic Cloud** ([https://cloud.elastic.co/](https://cloud.elastic.co/))'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Elastic Cloud**（[https://cloud.elastic.co/](https://cloud.elastic.co/)）'
- en: Currently, AWS offers a free tier which is easy to get started with and is tightly
    integrated with the current suite of AWS tools, such as identity services ([https://aws.amazon.com/iam/](https://aws.amazon.com/iam/))
    and lambda functions ([https://aws.amazon.com/lambda/](https://aws.amazon.com/lambda/)).
    However, AWS's Elasticsearch Service does not have the latest features as compared
    to Elastic Cloud, nor does it have extended x-pack integration. However, because
    AWS offers a free tier, my recommendation would be that you start with the AWS
    Elasticsearch Service. If you find out later that you need more features than
    AWS can provide, you can always move to Elastic Cloud.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，AWS提供了一个免费的套餐，很容易开始使用，并且与当前的AWS工具套件紧密集成，例如身份服务（[https://aws.amazon.com/iam/](https://aws.amazon.com/iam/)）和lambda函数（[https://aws.amazon.com/lambda/](https://aws.amazon.com/lambda/)）。然而，与Elastic
    Cloud相比，AWS的Elasticsearch服务没有最新的功能，也没有扩展的x-pack集成。然而，由于AWS提供了免费套餐，我的建议是您从AWS Elasticsearch服务开始。如果您后来发现需要比AWS提供的更多功能，您总是可以转移到Elastic
    Cloud。
- en: 'Setting up the service is straightforward; we just need to choose our region
    and give a name for our first domain. After setting it up, we can use the access
    policy to restrict input via an IP address; make sure this is the IP that AWS
    will see as the source IP (specify your corporate public IP if your host''s IP
    address is translated behind the NAT firewall):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 设置服务很简单；我们只需要选择我们的区域并为我们的第一个域名命名。设置完成后，我们可以使用访问策略来通过IP地址限制输入；确保这是AWS将看到的源IP地址（如果您的主机IP地址在NAT防火墙后面被转换，请指定您的公司公共IP）：
- en: '![](assets/75b38547-2d30-40f8-a951-7af6777231e8.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/75b38547-2d30-40f8-a951-7af6777231e8.png)'
- en: The Logstash format
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Logstash格式
- en: 'Logstash can be installed on the server where you are comfortable sending your
    network log to. The installation steps are available at [https://www.elastic.co/guide/en/logstash/current/installing-logstash.html](https://www.elastic.co/guide/en/logstash/current/installing-logstash.html).
    By default, you can put the Logstash configuration file under `/etc/logstash/conf.d/`.
    The file is in the `input-filter-output` format ([https://www.elastic.co/guide/en/logstash/current/advanced-pipeline.html](https://www.elastic.co/guide/en/logstash/current/advanced-pipeline.html)).
    In the following example, we specified the input as a `network log file`, with
    a placeholder for filtering the input, and the output as both printing out messages
    to the console as well as having the output exported toward our AWS Elasticsearch
    Service instance:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Logstash可以安装在您习惯发送网络日志的服务器上。安装步骤可在[https://www.elastic.co/guide/en/logstash/current/installing-logstash.html](https://www.elastic.co/guide/en/logstash/current/installing-logstash.html)找到。默认情况下，您可以将Logstash配置文件放在`/etc/logstash/conf.d/`下。该文件采用`input-filter-output`格式（[https://www.elastic.co/guide/en/logstash/current/advanced-pipeline.html](https://www.elastic.co/guide/en/logstash/current/advanced-pipeline.html)）。在下面的示例中，我们将输入指定为`网络日志文件`，并使用占位符过滤输入，输出为将消息打印到控制台以及将输出导出到我们的AWS
    Elasticsearch服务实例：
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now let's look at other things we can do with Python and Logstash.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看我们可以用Python和Logstash做的其他事情。
- en: Python helper script for Logstash formatting
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于Logstash格式的Python辅助脚本
- en: 'The preceding Logstash configuration will allow us to ingest network logs and
    create the index on Elasticsearch. What would happen if the text format we intend
    on putting into ELK is not a standard log format? This is where Python can help.
    In the next example, we will perform the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的Logstash配置将允许我们摄取网络日志并在Elasticsearch上创建索引。如果我们打算放入ELK的文本格式不是标准的日志格式，会发生什么？这就是Python可以帮助的地方。在下一个示例中，我们将执行以下操作：
- en: Use the Python script to retrieve a list of IPs that the Spamhaus project considers
    to be a drop list ([https://www.spamhaus.org/drop/drop.txt](https://www.spamhaus.org/drop/drop.txt))
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python脚本检索Spamhaus项目认为是拒收列表的IP地址列表（[https://www.spamhaus.org/drop/drop.txt](https://www.spamhaus.org/drop/drop.txt)）
- en: Use the Python logging module to format the information in such a way that Logstash
    can ingest it
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python日志模块以Logstash可以摄取的方式格式化信息
- en: Modify the Logstash configuration file so any new input could be sent to the
    AWS Elasticsearch Service
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改Logstash配置文件，以便任何新输入都可以发送到AWS Elasticsearch服务
- en: 'The `chapter8_logstash_1.py` script contains the code we will use. Besides
    the module imports, we will define the basic logging configuration. This section
    directly configures what the output would be and should be matched closely to
    the Logstash format:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`chapter8_logstash_1.py`脚本包含我们将使用的代码。除了模块导入之外，我们将定义基本的日志配置。该部分直接配置输出，并且应该与Logstash格式匹配：'
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We will define a few more variables and save the list of IP addresses from
    the requests in a variable:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一些更多的变量，并将请求中的IP地址列表保存在一个变量中：
- en: '[PRE55]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The final section of the script is a loop meant for parsing the output and
    writing it to the new log file:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的最后一部分是一个循环，用于解析输出并将其写入新的日志文件：
- en: '[PRE56]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here''s a sample of the log file entry:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是日志文件条目的示例：
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can then modify the Logstash configuration file accordingly to our new log
    format, starting with adding the input file location:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以相应地修改Logstash配置文件以适应我们的新日志格式，首先是添加输入文件位置：
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can add more filter configurations using `grok`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`grok`添加更多的过滤配置：
- en: '[PRE59]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We can leave the output section unchanged, as the additional entries will be
    stored in the same index. We can now use the ELK stack to query, store, and view
    the network log as well as the Spamhaus IP information.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将输出部分保持不变，因为额外的条目将存储在同一索引中。现在我们可以使用ELK堆栈来查询、存储和查看网络日志以及Spamhaus IP信息。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at additional ways in which we can utilize Python
    to enhance our network monitoring effort. We began by using Python's Graphviz
    package to create network topology graphs with real-time LLDP information reported
    by the network devices. This allows us to effortlessly show the current network
    topology as well as easily notice any link failures.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一些额外的方法，可以利用Python来增强我们的网络监控工作。我们首先使用Python的Graphviz包来创建实时LLDP信息报告的网络拓扑图。这使我们能够轻松地显示当前的网络拓扑，以及轻松地注意到任何链路故障。
- en: Next, we used Python to parse NetFlow version 5 packets to enhance our understanding
    and troubleshooting of NetFlow. We also looked at how to use ntop and Python to
    extend ntop for NetFlow monitoring. sFlow is an alternative packet sampling technology
    that we looked at where we use `sflowtool` and sFlow-RT to interpret the results.
    We ended the chapter with a general-purpose data analyzing tool, namely Elasticsearch,
    or the ELK stack.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用Python来解析NetFlow版本5数据包，以增强我们对NetFlow的理解和故障排除能力。我们还研究了如何使用ntop和Python来扩展ntop以进行NetFlow监控。sFlow是一种替代的数据包抽样技术，我们使用`sflowtool`和sFlow-RT来解释结果。我们在本章结束时介绍了一个通用的数据分析工具，即Elasticsearch，或者ELK堆栈。
- en: In [Chapter 9](3f5f47a9-8e88-40e9-a7f5-53113862d966.xhtml), *Building Network
    Web Services with Python*, we will explore how to use the Python web framework
    Flask to build network web services.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](3f5f47a9-8e88-40e9-a7f5-53113862d966.xhtml)中，*使用Python构建网络Web服务*，我们将探讨如何使用Python
    Web框架Flask来构建网络Web服务。
