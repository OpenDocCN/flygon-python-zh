["```py\nstring =  \"this is data structures book by packt publisher\"; suffix =  \"publisher\"; prefix = \"this\"; print(string.endswith(suffix))  #Check if string contains given suffix.\nprint(string.startswith(prefix)) #Check if string starts with given prefix.\n\n#Outputs\n>>True\n>>True\n```", "```py\ndef brute_force(text, pattern):\n    l1 = len(text)      # The length of the text string\n    l2 = len(pattern)   # The length of the pattern \n    i = 0\n    j = 0               # looping variables are set to 0\n    flag = False        # If the pattern doesn't appear at all, then set this to false and execute the last if statement\n\n    while i < l1:         # iterating from the 0th index of text\n        j = 0\n        count = 0    \n        # Count stores the length upto which the pattern and the text have matched\n\n        while j < l2:\n            if i+j < l1 and text[i+j] == pattern[j]:  \n        # statement to check if a match has occoured or not\n        count += 1     # Count is incremented if a character is matched \n            j += 1\n        if count == l2:   # it shows a matching of pattern in the text \n                print(\"\\nPattern occours at index\", i) \n                  # print the starting index of the successful match\n                flag = True \n     # flag is True as we wish to continue looking for more matching of  \n      pattern in the text. \n            i += 1\n    if not flag: \n        # If the pattern doesn't occours at all, means no match of  \n         pattern in the text string\n        print('\\nPattern is not at all present in the array')\n\nbrute_force('acbcabccababcaacbcac','acbcac')         # function call\n\n#outputs\n#Pattern occours at index 14\n```", "```py\nif i+j<l1 and text[i+j] == pattern[j]:\n```", "```py\ndef generate_hash(text, pattern):\n      ord_text = [ord(i) for i in text]   \n                       # stores unicode value of each character in text \n      ord_pattern = [ord(j) for j in pattern] \n                   # stores unicode value of each character in pattern\n      len_text = len(text)           # stores length of the text \n      len_pattern = len(pattern)     # stores length of the pattern\n      hash_pattern = sum(ord_pattern)\n      len_hash_array = len_text - len_pattern + 1    \n       #stores the length of new array that will contain the hash \n       values of text\n      hash_text = [0]*(len_hash_array) \n                         # Initialize all the values in the array to 0.\n      for i in range(0, len_hash_array): \n           if i == 0:  \n                hash_text[i] = sum(ord_text[:len_pattern]) \n                                      # initial value of hash function\n           else:\n                hash_text[i] = ((hash_text[i-1] - ord_text[i-1]) + \n                ord_text[i+len_pattern-1]) \n                    # calculating next hash value using previous value\n\n      return [hash_text, hash_pattern]         # return the hash values\n```", "```py\ndef Rabin_Karp_Matcher(text, pattern):\n    text = str(text)                 # convert text into string format\n    pattern = str(pattern)           # convert pattern into string format\n    hash_text, hash_pattern = generate_hash(text, pattern) \n                    # generate hash values using generate_hash function\n    len_text = len(text)              # length of text\n    len_pattern = len(pattern)        # length of pattern\n    flag = False # checks if pattern is present atleast once or not at all\n    for i in range(len(hash_text)): \n        if hash_text[i] == hash_pattern:     # if the hash value matches\n            count = 0 \n            for j in range(len_pattern): \n                if pattern[j] == text[i+j]: \n                        # comparing patten and substring character by character\n                    count += 1  \n                else:\n                    break\n                if count == len_pattern:       # Pattern is found in the text\n                    flag = True                # update flag accordingly\n                    print(\"Pattern occours at index\", i)\n                if not flag:                # Pattern doesn't match even once.\n                    print(\"Pattern is not at all present in the text\")\n```", "```py\ndef pfun(pattern): # function to generate prefix function for the given pattern\n    n = len(pattern) # length of the pattern\n    prefix_fun = [0]*(n) # initialize all elements of the list to 0\n    k = 0\n    for q in range(2,n):\n         while k>0 and pattern[k+1] != pattern[q]:\n            k = prefix_fun[k]\n         if pattern[k+1] == pattern[q]: # If the kth element of the pattern is equal to the qth element\n            k += 1            # update k accordingly\n         prefix_fun[q] = k\n    return prefix_fun         # return the prefix function \n```", "```py\n\ndef KMP_Matcher(text,pattern): \n    m = len(text)\n    n = len(pattern)\n    flag = False\n    text = '-' + text       # append dummy character to make it 1-based indexing\n    pattern = '-' + pattern       # append dummy character to the pattern also\n    prefix_fun = pfun(pattern) # generate prefix function for the pattern\n    q = 0\n    for i in range(1,m+1):\n        while q>0 and pattern[q+1] != text[i]: \n        # while pattern and text are not equal, decrement the value of q if it is > 0\n            q = prefix_fun[q]\n        if pattern[q+1] == text[i]: # if pattern and text are equal, update value of q\n            q += 1\n        if q == n: # if q is equal to the length of the pattern, it means that the pattern has been found.\n            print(\"Pattern occours with shift\",i-n) # print the index,\n```", "```py\nwhere first match occours.\n            flag = True\n            q = prefix_fun[q]\n    if not flag:\n            print('\\nNo match found')\n\nKMP_Matcher('aabaacaadaabaaba','abaac')         #function call\n```", "```py\n text[i+j+k:i+len(pattern)] not in pattern[0:len(pattern)-1]\n```", "```py\ntext= \"acbaacacababacacac\"\npattern = \"acacac\"\n\nmatched_indexes = []\ni=0\nflag = True\nwhile i<=len(text)-len(pattern):\n    for j in range(len(pattern)-1, -1, -1): #reverse searching\n        if pattern[j] != text[i+j]:\n            flag = False #indicates there is a mismatch\n            if j == len(pattern)-1: #if good-suffix is not present, we test bad character \n                if text[i+j] in pattern[0:j]:\n                    i=i+j-pattern[0:j].rfind(text[i+j]) #i+j is index of bad character, this line is used for jumping pattern to match bad character of text with same character in pattern\n                else:\n                    i=i+j+1 #if bad character is not present, jump pattern next to it\n            else:\n                k=1\n                while text[i+j+k:i+len(pattern)] not in pattern[0:len(pattern)-1]: #used for finding sub part of a good-suffix\n                    k=k+1\n                if len(text[i+j+k:i+len(pattern)]) != 1: #good-suffix should not be of one character\n                    gsshift=i+j+k-pattern[0:len(pattern)-1].rfind(text[i+j+k:i+len(pattern)]) #jumps pattern to a position where good-suffix of pattern matches with good-suffix of text\n                else:\n                    #gsshift=i+len(pattern)\n                    gsshift=0 #when good-suffix heuristic is not applicable, we prefer bad character heuristic\n                if text[i+j] in pattern[0:j]:\n                    bcshift=i+j-pattern[0:j].rfind(text[i+j]) #i+j is index of bad character, this line is used for jumping pattern to match bad character of text with same character in pattern\n                else:\n                    bcshift=i+j+1\n                i=max((bcshift, gsshift))\n            break\n    if flag: #if pattern is found then normal iteration\n        matched_indexes.append(i)\n        i = i+1\n    else: #again set flag to True so new string in text can be examined\n        flag = True\n\nprint (\"Pattern found at\", matched_indexes)\n\n```"]