- en: Expecting the Unexpected
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预料之外的情况
- en: Programs are very fragile. It would be ideal if code always returned a valid
    result, but sometimes a valid result can't be calculated. For example, it's not
    possible to divide by zero, or to access the eighth item in a five-item list.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 程序非常脆弱。如果代码总是返回有效的结果，那将是理想的，但有时无法计算出有效的结果。例如，不能除以零，或者访问五项列表中的第八项。
- en: In the old days, the only way around this was to rigorously check the inputs
    for every function to make sure they made sense. Typically, functions had special
    return values to indicate an error condition; for example, they could return a
    negative number to indicate that a positive value couldn't be calculated. Different
    numbers might mean different errors occurred. Any code that called this function
    would have to explicitly check for an error condition and act accordingly. A lot
    of developers didn't bother to do this, and programs simply crashed. However,
    in the object-oriented world, this is not the case.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，唯一的解决方法是严格检查每个函数的输入，以确保它们是有意义的。通常，函数有特殊的返回值来指示错误条件；例如，它们可以返回一个负数来表示无法计算出正值。不同的数字可能表示不同的错误。调用这个函数的任何代码都必须明确检查错误条件并相应地采取行动。许多开发人员不愿意这样做，程序就会崩溃。然而，在面向对象的世界中，情况并非如此。
- en: 'In this chapter, we will study **exceptions**, special error objects that only
    need to be handled when it makes sense to handle them. In particular, we will
    cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习**异常**，这是特殊的错误对象，只有在有意义处理它们时才需要处理。特别是，我们将涵盖以下内容：
- en: How to cause an exception to occur
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何引发异常
- en: How to recover when an exception has occurred
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在异常发生时如何恢复
- en: How to handle different exception types in different ways
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以不同的方式处理不同类型的异常
- en: Cleaning up when an exception has occurred
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在异常发生时进行清理
- en: Creating new types of exception
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新类型的异常
- en: Using the exception syntax for flow control
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用异常语法进行流程控制
- en: Raising exceptions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引发异常
- en: In principle, an exception is just an object. There are many different exception
    classes available, and we can easily define more of our own. The one thing they
    all have in common is that they inherit from a built-in class called `BaseException`.
    These exception objects become special when they are handled inside the program's
    flow of control. When an exception occurs, everything that was supposed to happen
    doesn't happen, unless it was supposed to happen when an exception occurred. Make
    sense? Don't worry, it will!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，异常只是一个对象。有许多不同的异常类可用，我们也可以很容易地定义更多我们自己的异常。它们所有的共同之处是它们都继承自一个名为`BaseException`的内置类。当这些异常对象在程序的控制流中被处理时，它们就变得特殊起来。当异常发生时，除非在异常发生时应该发生，否则一切都不会发生。明白了吗？别担心，你会明白的！
- en: 'The easiest way to cause an exception to occur is to do something silly. Chances
    are you''ve done this already and seen the exception output. For example, any
    time Python encounters a line in your program that it can''t understand, it bails
    with `SyntaxError`, which is a type of exception. Here''s a common one:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 引发异常的最简单方法是做一些愚蠢的事情。很有可能你已经这样做过，并看到了异常输出。例如，每当Python遇到无法理解的程序行时，它就会以`SyntaxError`退出，这是一种异常。这是一个常见的例子：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This `print` statement was a valid command way back in the Python 2 and earlier
    days, but in Python 3, because `print` is a function, we have to enclose the arguments
    in parentheses. So, if we type the preceding command into a Python 3 interpreter,
    we get `SyntaxError`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`print`语句在Python 2和更早的版本中是一个有效的命令，但在Python 3中，因为`print`是一个函数，我们必须用括号括起参数。因此，如果我们将前面的命令输入Python
    3解释器，我们会得到`SyntaxError`。
- en: 'In addition to `SyntaxError`, some other common exceptions are shown in the
    following example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`SyntaxError`，以下示例中还显示了一些其他常见的异常：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Sometimes, these exceptions are indicators of something wrong in our program
    (in which case, we would go to the indicated line number and fix it), but they
    also occur in legitimate situations. A `ZeroDivisionError` error doesn't always
    mean we received an invalid input. It could also mean we have received a different
    input. The user may have entered a zero by mistake, or on purpose, or it may represent
    a legitimate value, such as an empty bank account or the age of a newborn child.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这些异常是我们程序中出现问题的指示器（在这种情况下，我们会去到指示的行号并进行修复），但它们也会在合法的情况下发生。`ZeroDivisionError`错误并不总是意味着我们收到了无效的输入。它也可能意味着我们收到了不同的输入。用户可能误输入了零，或者故意输入了零，或者它可能代表一个合法的值，比如一个空的银行账户或者一个新生儿的年龄。
- en: You may have noticed all the preceding built-in exceptions end with the name
    `Error`. In Python, the words `error` and `Exception` are used almost interchangeably.
    Errors are sometimes considered more dire than exceptions, but they are dealt
    with in exactly the same way. Indeed, all the error classes in the preceding example
    have `Exception` (which extends `BaseException`) as their superclass.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到所有前面的内置异常都以`Error`结尾。在Python中，`error`和`Exception`这两个词几乎可以互换使用。错误有时被认为比异常更严重，但它们的处理方式完全相同。事实上，前面示例中的所有错误类都有`Exception`（它继承自`BaseException`）作为它们的超类。
- en: Raising an exception
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引发异常
- en: 'We''ll get to responding to such exceptions in a minute, but first, let''s
    discover what we should do if we''re writing a program that needs to inform the
    user or a calling function that the inputs are invalid. We can use the exact same
    mechanism that Python uses. Here''s a simple class that adds items to a list only
    if they are even numbered integers:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一分钟内开始回应这些异常，但首先，让我们发现如果我们正在编写一个需要通知用户或调用函数输入无效的程序应该做什么。我们可以使用Python使用的完全相同的机制。这里有一个简单的类，只有当它们是偶数的整数时才向列表添加项目：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This class extends the `list` built-in, as we discussed in [Chapter 16](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml),
    *Objects in Python*, and overrides the `append` method to check two conditions
    that ensure the item is an even integer. We first check whether the input is an
    instance of the `int` type, and then use the modulus operator to ensure it is
    divisible by two. If either of the two conditions is not met, the `raise` keyword
    causes an exception to occur. The `raise` keyword is followed by the object being
    raised as an exception. In the preceding example, two objects are constructed
    from the built-in `TypeError` and `ValueError` classes. The raised object could
    just as easily be an instance of a new `Exception` class we create ourselves (we'll
    see how shortly), an exception that was defined elsewhere, or even an `Exception`
    object that has been previously raised and handled.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展了内置的`list`，就像我们在[第16章](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml)中讨论的那样，*Python中的对象*，并覆盖了`append`方法以检查两个条件，以确保项目是偶数。我们首先检查输入是否是`int`类型的实例，然后使用模运算符确保它可以被2整除。如果两个条件中的任何一个不满足，`raise`关键字会引发异常。`raise`关键字后面跟着作为异常引发的对象。在前面的例子中，从内置的`TypeError`和`ValueError`类构造了两个对象。引发的对象也可以很容易地是我们自己创建的新`Exception`类的实例（我们很快就会看到），在其他地方定义的异常，甚至是先前引发和处理的`Exception`对象。
- en: 'If we test this class in the Python interpreter, we can see that it is outputting
    useful error information when exceptions occur, just as before:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Python解释器中测试这个类，我们可以看到在异常发生时输出了有用的错误信息，就像以前一样：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While this class is effective for demonstrating exceptions in action, it isn't
    very good at its job. It is still possible to get other values into the list using
    index notation or slice notation. This can all be avoided by overriding other
    appropriate methods, some of which are magic double-underscore methods.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个类对于演示异常的作用是有效的，但它并不擅长其工作。仍然可以使用索引表示法或切片表示法将其他值添加到列表中。通过覆盖其他适当的方法，一些是魔术双下划线方法，所有这些都可以避免。
- en: The effects of an exception
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常的影响
- en: 'When an exception is raised, it appears to stop program execution immediately.
    Any lines that were supposed to run after the exception is raised are not executed,
    and unless the exception is dealt with, the program will exit with an error message.
    Take a look at this basic function:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当引发异常时，似乎会立即停止程序执行。在引发异常之后应该运行的任何行都不会被执行，除非处理异常，否则程序将以错误消息退出。看一下这个基本函数：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we execute this function, we see that the first `print` call is executed
    and then the exception is raised. The second `print` function call is never executed,
    nor is the `return` statement:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行这个函数，我们会看到第一个`print`调用被执行，然后引发异常。第二个`print`函数调用不会被执行，`return`语句也不会被执行：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Furthermore, if we have a function that calls another function that raises
    an exception, nothing is executed in the first function after the point where
    the second function was called. Raising an exception stops all execution right
    up through the function call stack until it is either handled or forces the interpreter
    to exit. To demonstrate, let''s add a second function that calls the earlier one:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们有一个调用另一个引发异常的函数的函数，那么在调用第二个函数的地方之后，第一个函数中的任何内容都不会被执行。引发异常会立即停止所有执行，直到函数调用堆栈，直到它被处理或强制解释器退出。为了演示，让我们添加一个调用先前函数的第二个函数：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we call this function, we see that the first `print` statement executes,
    as well as the first line in the `no_return` function. But once the exception
    is raised, nothing else executes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用这个函数时，我们会看到第一个`print`语句被执行，以及`no_return`函数中的第一行。但一旦引发异常，就不会执行其他任何内容：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We'll soon see that when the interpreter is not actually taking a shortcut and
    exiting immediately, we can react to and deal with the exception inside either
    method. Indeed, exceptions can be handled at any level after they are initially
    raised.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会看到，当解释器实际上没有采取捷径并立即退出时，我们可以在任一方法内部对异常做出反应并处理。事实上，异常可以在最初引发后的任何级别进行处理。
- en: Look at the exception's output (called a traceback) from bottom to top, and
    notice how both methods are listed. Inside `no_return`, the exception is initially
    raised. Then, just above that, we see that inside `call_exceptor`, that pesky
    `no_return` function was called and the exception *bubbled up* to the calling
    method. From there, it went up one more level to the main interpreter, which,
    not knowing what else to do with it, gave up and printed a traceback.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从下到上查看异常的输出（称为回溯），注意两种方法都被列出。在`no_return`内部，异常最初被引发。然后，在其上方，我们看到在`call_exceptor`内部，那个讨厌的`no_return`函数被调用，异常*冒泡*到调用方法。从那里，它再上升一级到主解释器，由于不知道该如何处理它，放弃并打印了一个回溯。
- en: Handling exceptions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: 'Now let''s look at the tail side of the exception coin. If we encounter an
    exception situation, how should our code react to or recover from it? We handle
    exceptions by wrapping any code that might throw one (whether it is exception
    code itself, or a call to any function or method that may have an exception raised
    inside it) inside a `try...except` clause. The most basic syntax looks like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下异常硬币的反面。如果我们遇到异常情况，我们的代码应该如何对其做出反应或恢复？我们通过在`try...except`子句中包装可能引发异常的任何代码（无论是异常代码本身，还是调用可能在其中引发异常的任何函数或方法）来处理异常。最基本的语法如下：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we run this simple script using our existing `no_return` function—which,
    as we know very well, always throws an exception—we get this output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用现有的`no_return`函数运行这个简单的脚本——正如我们非常清楚的那样，它总是会引发异常——我们会得到这个输出：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `no_return` function happily informs us that it is about to raise an exception,
    but we fooled it and caught the exception. Once caught, we were able to clean
    up after ourselves (in this case, by outputting that we were handling the situation),
    and continue on our way, with no interference from that offensive function. The
    remainder of the code in the `no_return` function still went unexecuted, but the
    code that called the function was able to recover and continue.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`no_return`函数愉快地通知我们它即将引发异常，但我们欺骗了它并捕获了异常。一旦捕获，我们就能够清理自己（在这种情况下，通过输出我们正在处理的情况），并继续前进，而不受那个冒犯性的函数的干扰。`no_return`函数中剩余的代码仍未执行，但调用函数的代码能够恢复并继续。'
- en: Note the indentation around `try` and `except`. The `try` clause wraps any code
    that might throw an exception. The `except` clause is then back on the same indentation
    level as the `try` line. Any code to handle the exception is indented after the
    `except` clause. Then normal code resumes at the original indentation level.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`try`和`except`周围的缩进。`try`子句包装可能引发异常的任何代码。然后`except`子句回到与`try`行相同的缩进级别。处理异常的任何代码都在`except`子句之后缩进。然后正常代码在原始缩进级别上恢复。
- en: The problem with the preceding code is that it will catch any type of exception.
    What if we were writing some code that could raise both `TypeError` and `ZeroDivisionError`?
    We might want to catch `ZeroDivisionError`, but let `TypeError` propagate to the
    console. Can you guess the syntax?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的问题在于它会捕获任何类型的异常。如果我们编写的代码可能引发`TypeError`和`ZeroDivisionError`，我们可能希望捕获`ZeroDivisionError`，但让`TypeError`传播到控制台。你能猜到语法是什么吗？
- en: 'Here''s a rather silly function that does just that:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当愚蠢的函数，它就是这样做的：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The function is tested with the `print` statements that show it behaving as
    expected:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`print`语句测试该函数，显示它的行为符合预期：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first line of output shows that if we enter `0`, we get properly mocked.
    If we call with a valid number (note that it's not an integer, but it's still
    a valid divisor), it operates correctly. Yet if we enter a string (you were wondering
    how to get a `TypeError`, weren't you?), it fails with an exception. If we had
    used an empty `except` clause that didn't specify a `ZeroDivisionError`, it would
    have accused us of dividing by zero when we sent it a string, which is not a proper
    behavior at all.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行显示，如果我们输入`0`，我们会得到适当的模拟。如果使用有效的数字（请注意，它不是整数，但仍然是有效的除数），它会正确运行。但是，如果我们输入一个字符串（你一定想知道如何得到`TypeError`，不是吗？），它会出现异常。如果我们使用了一个未指定`ZeroDivisionError`的空`except`子句，当我们发送一个字符串时，它会指责我们除以零，这根本不是正确的行为。
- en: The *bare except* syntax is generally frowned upon, even if you really do want
    to catch all instances of an exception. Use the `except Exception:` syntax to
    explicitly catch all exception types. This tell the reader that you meant to catch
    exception objects and all subclasses of `Exception`. The bare except syntax is
    actually the same as using `except BaseException:`, which actually catches system-level
    exceptions that are very rare to intentionally want to catch, as we'll see in
    the next section. If you really do want to catch them, explicitly use `except
    BaseException:` so that anyone who reads your code knows that you didn't just
    forget to specify what kind of exception you wanted.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*裸except*语法通常不受欢迎，即使你真的想捕获所有异常实例。使用`except Exception:`语法显式捕获所有异常类型。这告诉读者你的意思是捕获异常对象和所有`Exception`的子类。裸except语法实际上与使用`except
    BaseException:`相同，它实际上捕获了非常罕见的系统级异常，这些异常很少有意想要捕获，正如我们将在下一节中看到的。如果你真的想捕获它们，明确使用`except
    BaseException:`，这样任何阅读你的代码的人都知道你不只是忘记指定想要的异常类型。'
- en: 'We can even catch two or more different exceptions and handle them with the
    same code. Here''s an example that raises three different types of exception.
    It handles `TypeError` and `ZeroDivisionError` with the same exception handler,
    but it may also raise a `ValueError` error if you supply the number `13`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以捕获两个或更多不同的异常，并用相同的代码处理它们。以下是一个引发三种不同类型异常的示例。它使用相同的异常处理程序处理`TypeError`和`ZeroDivisionError`，但如果您提供数字`13`，它也可能引发`ValueError`错误：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `for` loop at the bottom loops over several test inputs and prints the
    results. If you''re wondering about that `end` argument in the `print` statement,
    it just turns the default trailing newline into a space so that it''s joined with
    the output from the next line. Here''s a run of the program:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的`for`循环循环遍历几个测试输入并打印结果。如果你对`print`语句中的`end`参数感到疑惑，它只是将默认的尾随换行符转换为空格，以便与下一行的输出连接在一起。以下是程序的运行：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The number `0` and the string are both caught by the `except` clause, and a
    suitable error message is printed. The exception from the number `13` is not caught
    because it is a `ValueError`, which was not included in the types of exceptions
    being handled. This is all well and good, but what if we want to catch different
    exceptions and do different things with them? Or maybe we want to do something
    with an exception and then allow it to continue to bubble up to the parent function,
    as if it had never been caught?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 数字`0`和字符串都被`except`子句捕获，并打印出合适的错误消息。数字`13`的异常没有被捕获，因为它是一个`ValueError`，它没有包括在正在处理的异常类型中。这一切都很好，但如果我们想捕获不同的异常并对它们采取不同的措施怎么办？或者也许我们想对异常做一些处理，然后允许它继续冒泡到父函数，就好像它从未被捕获过？
- en: 'We don''t need any new syntax to deal with these cases. It''s possible to stack
    the `except` clauses, and only the first match will be executed. For the second
    question, the `raise` keyword, with no arguments, will re-raise the last exception
    if we''re already inside an exception handler. Observe the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要任何新的语法来处理这些情况。可以堆叠`except`子句，只有第一个匹配项将被执行。对于第二个问题，`raise`关键字，没有参数，将重新引发最后一个异常，如果我们已经在异常处理程序中。观察以下代码：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The last line re-raises the `ValueError` error, so after outputting `No, No,
    not 13!`, it will raise the exception again; we'll still get the original stack
    trace on the console.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行重新引发了`ValueError`错误，因此在输出`No, No, not 13!`之后，它将再次引发异常；我们仍然会在控制台上得到原始的堆栈跟踪。
- en: If we stack exception clauses like we did in the preceding example, only the
    first matching clause will be run, even if more than one of them fits. How can
    more than one clause match? Remember that exceptions are objects, and can therefore
    be subclassed. As we'll see in the next section, most exceptions extend the `Exception`
    class (which is itself derived from `BaseException`). If we catch `Exception`
    before we catch `TypeError`, then only the `Exception` handler will be executed,
    because `TypeError` is an `Exception` by inheritance.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像前面的例子中那样堆叠异常子句，只有第一个匹配的子句将被执行，即使有多个子句符合条件。为什么会有多个子句匹配？请记住，异常是对象，因此可以被子类化。正如我们将在下一节中看到的，大多数异常都扩展了`Exception`类（它本身是从`BaseException`派生的）。如果我们在捕获`TypeError`之前捕获`Exception`，那么只有`Exception`处理程序将被执行，因为`TypeError`是通过继承的`Exception`。
- en: This can come in handy in cases where we want to handle some exceptions specifically,
    and then handle all remaining exceptions as a more general case. We can simply
    catch `Exception` after catching all the specific exceptions and handle the general
    case there.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这在一些情况下非常有用，比如我们想要专门处理一些异常，然后将所有剩余的异常作为更一般的情况处理。在捕获所有特定异常后，我们可以简单地捕获`Exception`并在那里处理一般情况。
- en: 'Often, when we catch an exception, we need a reference to the `Exception` object
    itself. This most often happens when we define our own exceptions with custom
    arguments, but can also be relevant with standard exceptions. Most exception classes
    accept a set of arguments in their constructor, and we might want to access those
    attributes in the exception handler. If we define our own `Exception` class, we
    can even call custom methods on it when we catch it. The syntax for capturing
    an exception as a variable uses the `as` keyword:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们捕获异常时，我们需要引用`Exception`对象本身。这最常发生在我们使用自定义参数定义自己的异常时，但也可能与标准异常相关。大多数异常类在其构造函数中接受一组参数，我们可能希望在异常处理程序中访问这些属性。如果我们定义自己的`Exception`类，甚至可以在捕获时调用自定义方法。捕获异常作为变量的语法使用`as`关键字：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we run this simple snippet, it prints out the string argument that we passed
    into `ValueError` upon initialization.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个简单的片段，它会打印出我们传递给`ValueError`初始化的字符串参数。
- en: 'We''ve seen several variations on the syntax for handling exceptions, but we
    still don''t know how to execute code regardless of whether or not an exception
    has occurred. We also can''t specify code that should be executed **only** if
    an exception does **not** occur. Two more keywords, `finally` and `else`, can
    provide the missing pieces. Neither one takes any extra arguments. The following
    example randomly picks an exception to throw and raises it. Then some not-so-complicated
    exception handling code runs that illustrates the newly introduced syntax:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了处理异常的语法的几种变体，但我们仍然不知道如何执行代码，无论是否发生异常。我们也无法指定仅在**不**发生异常时执行的代码。另外两个关键字，`finally`和`else`，可以提供缺失的部分。它们都不需要额外的参数。以下示例随机选择一个要抛出的异常并引发它。然后运行一些不那么复杂的异常处理代码，演示了新引入的语法：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we run this example—which illustrates almost every conceivable exception
    handling scenario—a few times, we''ll get different output each time, depending
    on which exception `random` chooses. Here are some example runs:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个例子——它几乎涵盖了每种可能的异常处理场景——几次，每次都会得到不同的输出，这取决于`random`选择的异常。以下是一些示例运行：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note how the `print` statement in the `finally` clause is executed no matter
    what happens. This is extremely useful when we need to perform certain tasks after
    our code has finished running (even if an exception has occurred). Some common
    examples include the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`finally`子句中的`print`语句无论发生什么都会被执行。当我们需要在我们的代码运行结束后执行某些任务时（即使发生异常），这是非常有用的。一些常见的例子包括以下情况：
- en: Cleaning up an open database connection
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理打开的数据库连接
- en: Closing an open file
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭打开的文件
- en: Sending a closing handshake over the network
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过网络发送关闭握手
- en: The `finally` clause is also very important when we execute a `return` statement
    from inside a `try` clause. The `finally` handler will still be executed before
    the value is returned without executing any code following the `try...finally`
    clause.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`子句在我们从`try`子句内部执行`return`语句时也非常重要。在返回值之前，`finally`处理程序将仍然被执行，而不会执行`try...finally`子句后面的任何代码。'
- en: 'Also, pay attention to the output when no exception is raised: both the `else`
    and the `finally` clauses are executed. The `else` clause may seem redundant,
    as the code that should be executed only when no exception is raised could just
    be placed after the entire `try...except` block. The difference is that the `else`
    block will not be executed if an exception is caught and handled. We''ll see more
    on this when we discuss using exceptions as flow control later.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当没有引发异常时，请注意输出：`else`和`finally`子句都会被执行。`else`子句可能看起来多余，因为应该在没有引发异常时执行的代码可以直接放在整个`try...except`块之后。不同之处在于，如果捕获并处理了异常，`else`块将不会被执行。当我们讨论后续使用异常作为流程控制时，我们将会更多地了解这一点。
- en: Any of the `except`, `else`, and `finally` clauses can be omitted after a `try`
    block (although `else` by itself is invalid). If you include more than one, the
    `except` clauses must come first, then the `else` clause, with the `finally` clause
    at the end. The order of the `except` clauses normally goes from most specific
    to most generic.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`try`块之后可以省略任何`except`、`else`和`finally`子句（尽管单独的`else`是无效的）。如果包含多个子句，则必须先是`except`子句，然后是`else`子句，最后是`finally`子句。`except`子句的顺序通常从最具体到最一般。
- en: The exception hierarchy
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常层次结构
- en: We've already seen several of the most common built-in exceptions, and you'll
    probably encounter the rest over the course of your regular Python development.
    As we noticed earlier, most exceptions are subclasses of the `Exception` class.
    But this is not true of all exceptions. `Exception` itself actually inherits from
    a class called `BaseException`. In fact, all exceptions must extend the `BaseException`
    class or one of its subclasses.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了几个最常见的内置异常，你可能会在你的常规Python开发过程中遇到其余的异常。正如我们之前注意到的，大多数异常都是`Exception`类的子类。但并非所有异常都是如此。`Exception`本身实际上是继承自一个叫做`BaseException`的类。事实上，所有异常都必须扩展`BaseException`类或其子类之一。
- en: There are two key built-in the exception classes, `SystemExit` and `KeyboardInterrupt`,
    that derive directly from `BaseException` instead of `Exception`. The `SystemExit`
    exception is raised whenever the program exits naturally, typically because we
    called the `sys.exit` function somewhere in our code (for example, when the user
    selected an exit menu item, clicked the *Close* button on a window, or entered
    a command to shut down a server). The exception is designed to allow us to clean
    up code before the program ultimately exits. However, we generally don't need
    to handle it explicitly because cleanup code can happen inside a `finally` clause.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个关键的内置异常类，`SystemExit`和`KeyboardInterrupt`，它们直接从`BaseException`而不是`Exception`派生。`SystemExit`异常是在程序自然退出时引发的，通常是因为我们在代码中的某个地方调用了`sys.exit`函数（例如，当用户选择退出菜单项，单击窗口上的*关闭*按钮，或输入命令关闭服务器时）。该异常旨在允许我们在程序最终退出之前清理代码。但是，我们通常不需要显式处理它，因为清理代码可以发生在`finally`子句中。
- en: If we do handle it, we would normally re-raise the exception, since catching
    it would stop the program from exiting. There are, of course, situations where
    we might want to stop the program exiting; for example, if there are unsaved changes
    and we want to prompt the user if they really want to exit. Usually, if we handle
    `SystemExit` at all, it's because we want to do something special with it, or
    are anticipating it directly. We especially don't want it to be accidentally caught
    in generic clauses that catch all normal exceptions. This is why it derives directly
    from `BaseException`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理它，我们通常会重新引发异常，因为捕获它会阻止程序退出。当然，也有一些情况下，我们可能希望阻止程序退出；例如，如果有未保存的更改，我们希望提示用户是否真的要退出。通常，如果我们处理`SystemExit`，那是因为我们想对其进行特殊处理，或者直接预期它。我们尤其不希望它在捕获所有正常异常的通用子句中被意外捕获。这就是它直接从`BaseException`派生的原因。
- en: The `KeyboardInterrupt` exception is common in command-line programs. It is
    thrown when the user explicitly interrupts program execution with an OS-dependent
    key combination (normally, *Ctrl* + *C*). This is a standard way for the user
    to deliberately interrupt a running program, and like `SystemExit`, it should
    almost always respond by terminating the program. Also, like `SystemExit`, it
    should handle any cleanup tasks inside the `finally` blocks.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyboardInterrupt`异常在命令行程序中很常见。当用户使用与操作系统相关的组合键（通常是*Ctrl* + *C*）明确中断程序执行时，就会抛出该异常。这是用户有意中断运行中程序的标准方式，与`SystemExit`一样，它几乎总是应该通过终止程序来响应。同样，像`SystemExit`一样，它应该在`finally`块中处理任何清理任务。'
- en: 'Here is a class diagram that fully illustrates the hierarchy:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全说明了层次结构的类图：
- en: '![](assets/0003cd2e-9b19-4c3c-8280-9c4664984093.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0003cd2e-9b19-4c3c-8280-9c4664984093.png)'
- en: When we use the `except:` clause without specifying any type of exception, it
    will catch all subclasses of `BaseException`; which is to say, it will catch all
    exceptions, including the two special ones. Since we almost always want these
    to get special treatment, it is unwise to use the `except:` statement without
    arguments. If you want to catch all exceptions other than `SystemExit` and `KeyboardInterrupt`,
    explicitly catch `Exception`. Most Python developers assume that `except:` without
    a type is an error and will flag it in code review. If you really do want to catch
    everything, just explicitly use `except BaseException:`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`except:`子句而没有指定任何异常类型时，它将捕获`BaseException`的所有子类；也就是说，它将捕获所有异常，包括这两个特殊的异常。由于我们几乎总是希望这些得到特殊处理，因此不明智地使用`except:`语句而不带参数。如果你想捕获除`SystemExit`和`KeyboardInterrupt`之外的所有异常，明确地捕获`Exception`。大多数Python开发人员认为没有指定类型的`except:`是一个错误，并会在代码审查中标记它。如果你真的想捕获所有异常，只需明确使用`except
    BaseException:`。
- en: Defining our own exceptions
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义我们自己的异常
- en: Occasionally, when we want to raise an exception, we find that none of the built-in
    exceptions are suitable. Luckily, it's trivial to define new exceptions of our
    own. The name of the class is usually designed to communicate what went wrong,
    and we can provide arbitrary arguments in the initializer to include additional
    information.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，当我们想要引发一个异常时，我们发现没有一个内置的异常适合。幸运的是，定义我们自己的新异常是微不足道的。类的名称通常设计为传达出了什么问题，我们可以在初始化程序中提供任意参数以包含额外的信息。
- en: All we have to do is inherit from the `Exception` class. We don't even have
    to add any content to the class! We can, of course, extend `BaseException` directly,
    but I have never encountered a use case where this would make sense.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所要做的就是继承`Exception`类。我们甚至不必向类中添加任何内容！当然，我们可以直接扩展`BaseException`，但我从未遇到过这种情况。
- en: 'Here''s a simple exception we might use in a banking application:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在银行应用程序中可能使用的一个简单的异常：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The last line illustrates how to raise the newly defined exception. We are able
    to pass an arbitrary number of arguments into the exception. Often a string message
    is used, but any object that might be useful in a later exception handler can
    be stored. The `Exception.__init__` method is designed to accept any arguments
    and store them as a tuple in an attribute named `args`. This makes exceptions
    easier to define without needing to override `__init__`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行说明了如何引发新定义的异常。我们能够将任意数量的参数传递给异常。通常使用字符串消息，但可以存储任何在以后的异常处理程序中可能有用的对象。`Exception.__init__`方法设计为接受任何参数并将它们存储为名为`args`的属性中的元组。这使得异常更容易定义，而无需覆盖`__init__`。
- en: 'Of course, if we do want to customize the initializer, we are free to do so.
    Here''s an exception whose initializer accepts the current balance and the amount
    the user wanted to withdraw. In addition, it adds a method to calculate how overdrawn
    the request was:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们确实想要自定义初始化程序，我们是可以自由这样做的。这里有一个异常，它的初始化程序接受当前余额和用户想要提取的金额。此外，它添加了一个方法来计算请求透支了多少。
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `raise` statement at the end illustrates how to construct this exception.
    As you can see, we can do anything with an exception that we would do with other
    objects.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 结尾的`raise`语句说明了如何构造这个异常。正如你所看到的，我们可以对异常做任何其他对象可以做的事情。
- en: 'Here''s how we would handle an `InvalidWithdrawal` exception if one was raised:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何处理`InvalidWithdrawal`异常的方法，如果有异常被引发：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we see a valid use of the `as` keyword. By convention, most Python coders
    name the exception `e` or the `ex` variable, although, as usual, you are free
    to call it  `exception`, or `aunt_sally` if you prefer.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了`as`关键字的有效使用。按照惯例，大多数Python程序员将异常命名为`e`或`ex`变量，尽管通常情况下，你可以自由地将其命名为`exception`，或者如果你愿意的话，可以称之为`aunt_sally`。
- en: There are many reasons for defining our own exceptions. It is often useful to
    add information to the exception or log it in some way. But the utility of custom
    exceptions truly comes to light when creating a framework, library, or API that
    is intended for access by other programmers. In that case, be careful to ensure
    your code is raising exceptions that make sense to the client programmer. They
    should be easy to handle and clearly describe what went on. The client programmer
    should easily see how to fix the error (if it reflects a bug in their code) or
    handle the exception (if it's a situation they need to be made aware of).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 定义自己的异常有很多原因。通常，向异常中添加信息或以某种方式记录异常是很有用的。但是，自定义异常的实用性在创建面向其他程序员访问的框架、库或API时才真正显现出来。在这种情况下，要小心确保代码引发的异常对客户程序员有意义。它们应该易于处理，并清楚地描述发生了什么。客户程序员应该很容易看到如何修复错误（如果它反映了他们代码中的错误）或处理异常（如果这是他们需要知道的情况）。
- en: 'Exceptions aren''t exceptional. Novice programmers tend to think of exceptions
    as only useful for exceptional circumstances. However, the definition of exceptional
    circumstances can be vague and subject to interpretation. Consider the following
    two functions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 异常并不是异常的。新手程序员倾向于认为异常只对异常情况有用。然而，异常情况的定义可能模糊不清，而且可能会有不同的解释。考虑以下两个函数：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These two functions behave identically. If `divisor` is zero, an error message
    is printed; otherwise, a message printing the result of division is displayed.
    We could avoid `ZeroDivisionError` ever being thrown by testing for it with an
    `if` statement. Similarly, we can avoid `IndexError` by explicitly checking whether
    or not the parameter is within the confines of the list, and `KeyError` by checking
    whether the key is in a dictionary.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数的行为是相同的。如果`divisor`为零，则打印错误消息；否则，显示除法结果的消息。我们可以通过使用`if`语句来避免抛出`ZeroDivisionError`。同样，我们可以通过明确检查参数是否在列表范围内来避免`IndexError`，并通过检查键是否在字典中来避免`KeyError`。
- en: But we shouldn't do this. For one thing, we might write an `if` statement that
    checks whether or not the index is lower than the parameters of the list, but
    forget to check negative values.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不应该这样做。首先，我们可能会编写一个`if`语句，检查索引是否低于列表的参数，但忘记检查负值。
- en: Remember, Python lists support negative indexing; `-1` refers to the last element
    in the list.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Python列表支持负索引；`-1`指的是列表中的最后一个元素。
- en: Eventually, we would discover this and have to find all the places where we
    were checking code. But if we had simply caught `IndexError` and handled it, our
    code would just work.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们会发现这一点，并不得不找到我们检查代码的所有地方。但如果我们简单地捕获`IndexError`并处理它，我们的代码就可以正常工作。
- en: Python programmers tend to follow a model of *ask forgiveness rather than permission*,
    which is to say, they execute code and then deal with anything that goes wrong.
    The alternative, to *look before you leap*, is generally less popular. There are
    a few reasons for this, but the main one is that it shouldn't be necessary to
    burn CPU cycles looking for an unusual situation that is not going to arise in
    the normal path through the code. Therefore, it is wise to use exceptions for
    exceptional circumstances, even if those circumstances are only a little bit exceptional.
    Taking this argument further, we can actually see that the exception syntax is
    also effective for flow control. Like an `if` statement, exceptions can be used
    for decision making, branching, and message passing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序员倾向于遵循“宁可请求原谅，而不是事先征得许可”的模式，也就是说，他们执行代码，然后处理任何出现的问题。相反，先“三思而后行”的做法通常不太受欢迎。这样做的原因有几个，但主要原因是不应该需要消耗CPU周期来寻找在正常代码路径中不会出现的异常情况。因此，明智的做法是将异常用于异常情况，即使这些情况只是稍微异常。进一步地，我们实际上可以看到异常语法对于流程控制也是有效的。与`if`语句一样，异常可以用于决策、分支和消息传递。
- en: Imagine an inventory application for a company that sells widgets and gadgets.
    When a customer makes a purchase, the item can either be available, in which case
    the item is removed from inventory and the number of items left is returned, or
    it might be out of stock. Now, being out of stock is a perfectly normal thing
    to happen in an inventory application. It is certainly not an exceptional circumstance.
    But what do we return if it's out of stock? A string saying out of stock? A negative
    number? In both cases, the calling method would have to check whether the return
    value is a positive integer or something else, to determine if it is out of stock.
    That seems a bit messy, especially if we forget to do it somewhere in our code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一家销售小部件和小工具的公司的库存应用程序。当客户购买商品时，商品可以是有库存的，这种情况下商品会从库存中移除并返回剩余商品数量，或者可能是缺货的。现在，缺货在库存应用程序中是一件完全正常的事情。这绝对不是一个异常情况。但如果缺货了，我们应该返回什么呢？一个显示缺货的字符串？一个负数？在这两种情况下，调用方法都必须检查返回值是正整数还是其他值，以确定是否缺货。这似乎有点混乱，特别是如果我们在代码中忘记做这个检查。
- en: 'Instead, we can raise `OutOfStock` and use the `try` statement to direct program
    flow control. Make sense? In addition, we want to make sure we don''t sell the
    same item to two different customers, or sell an item that isn''t in stock yet.
    One way to facilitate this is to lock each type of item to ensure only one person
    can update it at a time. The user must lock the item, manipulate the item (purchase,
    add stock, count items left...), and then unlock the item. Here''s an incomplete
    `Inventory` example with docstrings that describes what some of the methods should
    do:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以引发`OutOfStock`并使用`try`语句来控制程序流程。有道理吗？此外，我们还要确保不会将同一商品卖给两个不同的客户，或者出售还未备货的商品。促进这一点的一种方法是锁定每种商品，以确保一次只有一个人可以更新它。用户必须锁定商品，操作商品（购买、补充库存、计算剩余商品数量...），然后解锁商品。以下是一个带有描述部分方法应该做什么的文档字符串的不完整的`Inventory`示例：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We could hand this object prototype to a developer and have them implement
    the methods to do exactly as they say while we work on the code that needs to
    make a purchase. We''ll use Python''s robust exception handling to consider different
    branches, depending on how the purchase was made:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个对象原型交给开发人员，并让他们实现方法，确保它们按照我们说的那样工作，而我们则可以继续编写需要进行购买的代码。我们将使用Python强大的异常处理来考虑不同的分支，具体取决于购买是如何进行的。
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Pay attention to how all the possible exception handling clauses are used to
    ensure the correct actions happen at the correct time. Even though `OutOfStock`
    is not a terribly exceptional circumstance, we are able to use an exception to
    handle it suitably. This same code could be written with an `if...elif...else`
    structure, but it wouldn't be as easy to read or maintain.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意所有可能的异常处理子句是如何用来确保在正确的时间发生正确的操作。尽管`OutOfStock`并不是一个非常异常的情况，但我们能够使用异常来适当地处理它。这段代码也可以用`if...elif...else`结构来编写，但这样不容易阅读和维护。
- en: We can also use exceptions to pass messages between different methods. For example,
    if we wanted to inform the customer as to what date the item is expected to be
    in stock again, we could ensure our `OutOfStock` object requires a `back_in_stock`
    parameter when it is constructed. Then, when we handle the exception, we can check
    that value and provide additional information to the customer. The information
    attached to the object can be easily passed between two different parts of the
    program. The exception could even provide a method that instructs the inventory
    object to reorder or backorder an item.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用异常来在不同的方法之间传递消息。例如，如果我们想要告知客户商品预计何时会再次有货，我们可以确保我们的`OutOfStock`对象在构造时需要一个`back_in_stock`参数。然后，当我们处理异常时，我们可以检查该值并向客户提供额外的信息。附加到对象的信息可以很容易地在程序的两个不同部分之间传递。异常甚至可以提供一个方法，指示库存对象重新订购或预订商品。
- en: Using exceptions for flow control can make for some handy program designs. The
    important thing to take from this discussion is that exceptions are not a bad
    thing that we should try to avoid. Having an exception occur does not mean that
    you should have prevented this exceptional circumstance from happening. Rather,
    it is just a powerful way to communicate information between two sections of code
    that may not be directly calling each other.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用异常来进行流程控制可以设计出一些方便的程序。从这次讨论中要记住的重要事情是异常并不是我们应该尽量避免的坏事。发生异常并不意味着你应该阻止这种异常情况的发生。相反，这只是一种在两个可能不直接调用彼此的代码部分之间传递信息的强大方式。
- en: Case study
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: We've been looking at the use and handling of exceptions at a fairly low level
    of detail—syntax and definitions. This case study will help tie it all in with
    our previous chapters so we can see how exceptions are used in the larger context
    of objects, inheritance, and modules.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在比较低级的细节层面上看异常的使用和处理——语法和定义。这个案例研究将帮助我们将这一切与之前的章节联系起来，这样我们就能看到异常在对象、继承和模块的更大背景下是如何使用的。
- en: Today, we'll be designing a simple central authentication and authorization
    system. The entire system will be placed in one module, and other code will be
    able to query that module object for authentication and authorization purposes.
    We should admit, from the start, that we aren't security experts, and that the
    system we are designing may be full of security holes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们将设计一个简单的中央认证和授权系统。整个系统将放置在一个模块中，其他代码将能够查询该模块对象以进行认证和授权。我们应该承认，从一开始，我们并不是安全专家，我们设计的系统可能存在许多安全漏洞。
- en: Our purpose is to study exceptions, not to secure a system. It will be sufficient,
    however, for a basic login and permission system that other code can interact
    with. Later, if that other code needs to be made more secure, we can have a security
    or cryptography expert review or rewrite our module, preferably without changing
    the API.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是研究异常，而不是保护系统。然而，对于其他代码可以与之交互的基本登录和权限系统来说，这是足够的。以后，如果其他代码需要更安全，我们可以请安全或密码专家审查或重写我们的模块，最好不要改变API。
- en: Authentication is the process of ensuring a user is really the person they say
    they are. We'll follow the lead of common web systems today, which use a username
    and private password combination. Other methods of authentication include voice
    recognition, fingerprint or retinal scanners, and identification cards.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 认证是确保用户确实是他们所说的人的过程。我们将遵循当今常见的网络系统的做法，使用用户名和私人密码组合。其他的认证方法包括语音识别、指纹或视网膜扫描仪以及身份证。
- en: Authorization, on the other hand, is all about determining whether a given (authenticated)
    user is permitted to perform a specific action. We'll create a basic permission
    list system that stores a list of the specific people allowed to perform each
    action.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 授权，另一方面，完全取决于确定特定（经过身份验证的）用户是否被允许执行特定操作。我们将创建一个基本的权限列表系统，该系统存储了允许执行每个操作的特定人员的列表。
- en: In addition, we'll add some administrative features to allow new users to be
    added to the system. For brevity, we'll leave out editing of passwords or changing
    of permissions once they've been added, but these (highly necessary) features
    can certainly be added in the future.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将添加一些管理功能，以允许新用户加入系统。为简洁起见，我们将省略密码编辑或一旦添加后更改权限，但是这些（非常必要的）功能当然可以在将来添加。
- en: There's a simple analysis; now let's proceed with design. We're obviously going
    to need a `User` class that stores the username and an encrypted password. This
    class will also allow a user to log in by checking whether a supplied password
    is valid. We probably won't need a `Permission` class, as those can just be strings
    mapped to a list of users using a dictionary. We should have a central `Authenticator`
    class that handles user management and logging in or out. The last piece of the
    puzzle is an `Authorizor` class that deals with permissions and checking whether
    a user can perform an activity. We'll provide a single instance of each of these
    classes in the `auth` module so that other modules can use this central mechanism
    for all their authentication and authorization needs. Of course, if they want
    to instantiate private instances of these classes, for non-central authorization
    activities, they are free to do so.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的分析；现在让我们继续设计。显然，我们需要一个存储用户名和加密密码的`User`类。这个类还将允许用户通过检查提供的密码是否有效来登录。我们可能不需要一个`Permission`类，因为可以将这些类别映射到使用字典的用户列表。我们应该有一个中央的`Authenticator`类，负责用户管理和登录或注销。拼图的最后一块是一个`Authorizor`类，处理权限和检查用户是否能执行某项活动。我们将在`auth`模块中提供这些类的单个实例，以便其他模块可以使用这个中央机制来满足其所有的身份验证和授权需求。当然，如果它们想要实例化这些类的私有实例，用于非中央授权活动，它们是可以自由这样做的。
- en: We'll also be defining several exceptions as we go along. We'll start with a
    special `AuthException` base class that accepts a `username` and optional `user`
    object as parameters; most of our self-defined exceptions will inherit from this
    one.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的进行，我们还将定义几个异常。我们将从一个特殊的`AuthException`基类开始，它接受`username`和可选的`user`对象作为参数；我们自定义的大多数异常将继承自这个类。
- en: 'Let''s build the `User` class first; it seems simple enough. A new user can
    be initialized with a username and password. The password will be stored encrypted
    to reduce the chances of its being stolen. We''ll also need a `check_password`
    method to test whether a supplied password is the correct one. Here is the class
    in full:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先构建`User`类；这似乎足够简单。可以使用用户名和密码初始化一个新用户。密码将被加密存储，以减少被盗的可能性。我们还需要一个`check_password`方法来测试提供的密码是否正确。以下是完整的类：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Since the code for encrypting a password is required in both `__init__` and
    `check_password`, we pull it out to its own method. This way, it only needs to
    be changed in one place if someone realizes it is insecure and needs improvement.
    This class could easily be extended to include mandatory or optional personal
    details, such as names, contact information, and birth dates.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在`__init__`和`check_password`中需要加密密码的代码，我们将其提取到自己的方法中。这样，如果有人意识到它不安全并需要改进，它只需要在一个地方进行更改。这个类可以很容易地扩展到包括强制或可选的个人详细信息，比如姓名、联系信息和出生日期。
- en: Before we write code to add users (which will happen in the as-yet undefined
    `Authenticator` class), we should examine some use cases. If all goes well, we
    can add a user with a username and password; the `User` object is created and
    inserted into a dictionary. But in what ways can all not go well? Well, clearly
    we don't want to add a user with a username that already exists in the dictionary.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码添加用户之前（这将在尚未定义的`Authenticator`类中进行），我们应该检查一些用例。如果一切顺利，我们可以添加一个带有用户名和密码的用户；`User`对象被创建并插入到字典中。但是，有哪些情况可能不顺利呢？显然，我们不希望添加一个已经存在于字典中的用户名的用户。
- en: 'If we did so, we''d overwrite an existing user''s data and the new user might
    have access to that user''s privileges. So, we''ll need a `UsernameAlreadyExists`
    exception. Also, for security''s sake, we should probably raise an exception if
    the password is too short. Both of these exceptions will extend `AuthException`,
    which we mentioned earlier. So, before writing the `Authenticator` class, let''s
    define these three exception classes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样做，我们将覆盖现有用户的数据，新用户可能会访问该用户的权限。因此，我们需要一个`UsernameAlreadyExists`异常。另外，出于安全考虑，如果密码太短，我们可能应该引发一个异常。这两个异常都将扩展`AuthException`，我们之前提到过。因此，在编写`Authenticator`类之前，让我们定义这三个异常类：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `AuthException` requires a username and has an optional user parameter.
    This second parameter should be an instance of the `User` class associated with
    that username. The two specific exceptions we're defining simply need to inform
    the calling class of an exceptional circumstance, so we don't need to add any
    extra methods to them.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthException`需要用户名，并且有一个可选的用户参数。第二个参数应该是与该用户名关联的`User`类的实例。我们正在定义的两个具体异常只需要通知调用类发生了异常情况，因此我们不需要为它们添加任何额外的方法。'
- en: 'Now let''s start on the `Authenticator` class. It can simply be a mapping of
    usernames to user objects, so we''ll start with a dictionary in the initialization
    function. The method for adding a user needs to check the two conditions (password
    length and previously existing users) before creating a new `User` instance and
    adding it to the dictionary:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始`Authenticator`类。它可以简单地是用户名到用户对象的映射，因此我们将从初始化函数中的字典开始。添加用户的方法需要在将新的`User`实例添加到字典之前检查两个条件（密码长度和先前存在的用户）：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We could, of course, extend the password validation to raise exceptions for
    passwords that are too easy to crack in other ways, if we desired. Now let''s
    prepare the `login` method. If we weren''t thinking about exceptions just now,
    we might just want the method to return `True` or `False`, depending on whether
    the login was successful or not. But we are thinking about exceptions, and this
    could be a good place to use them for a not-so-exceptional circumstance. We could
    raise different exceptions, for example, if the username does not exist or the
    password does not match. This will allow anyone trying to log a user in to elegantly
    handle the situation using a `try`/`except`/`else` clause. So, first we add these
    new exceptions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果需要，我们可以扩展密码验证以引发其他方式太容易破解的密码的异常。现在让我们准备`login`方法。如果我们现在不考虑异常，我们可能只希望该方法根据登录是否成功返回`True`或`False`。但我们正在考虑异常，这可能是一个不那么异常的情况使用它们的好地方。我们可以引发不同的异常，例如，如果用户名不存在或密码不匹配。这将允许尝试登录用户的任何人使用`try`/`except`/`else`子句优雅地处理情况。因此，首先我们添加这些新的异常：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then we can define a simple `login` method to our `Authenticator` class that
    raises these exceptions if necessary. If not, it flags the `user` as logged in
    and returns the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以为我们的`Authenticator`类定义一个简单的`login`方法，如果必要的话引发这些异常。如果不是，它会标记`user`已登录并返回以下内容：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice how `KeyError` is handled. This could have been handled using `if username
    not in self.users:` instead, but we chose to handle the exception directly. We
    end up eating up this first exception and raising a brand new one of our own that
    better suits the user-facing API.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`KeyError`的处理方式。这可以使用`if username not in self.users:`来处理，但我们选择直接处理异常。我们最终吞掉了这个第一个异常，并引发了一个更适合用户界面API的全新异常。
- en: We can also add a method to check whether a particular username is logged in.
    Deciding whether to use an exception here is trickier. Should we raise an exception
    if the username does not exist? Should we raise an exception if the user is not
    logged in?
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加一个方法来检查特定用户名是否已登录。在这里决定是否使用异常更加棘手。如果用户名不存在，我们应该引发异常吗？如果用户未登录，我们应该引发异常吗？
- en: 'To answer these questions, we need to think about how the method would be accessed.
    Most often, this method will be used to answer the yes/no question, *should I
    allow them access to <something>?* The answer will either be, y*es, the username
    is valid and they are logged in*, or *no, the username is not valid or they are
    not logged in*. Therefore, a Boolean return value is sufficient. There is no need
    to use exceptions here, just for the sake of using an exception:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这些问题，我们需要考虑该方法如何被访问。大多数情况下，这种方法将用于回答是/否的问题，*我应该允许他们访问<something>吗？*答案要么是，*是的，用户名有效且他们已登录*，要么是，*不，用户名无效或他们未登录*。因此，布尔返回值就足够了。这里没有必要使用异常，只是为了使用异常：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we can add a default authenticator instance to our module so that
    the client code can access it easily using `auth.authenticator`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以向我们的模块添加一个默认的认证实例，以便客户端代码可以使用`auth.authenticator`轻松访问它：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This line goes at the module level, outside any class definition, so the `authenticator`
    variable can be accessed as `auth.authenticator`. Now we can start on the `Authorizor`
    class, which maps permissions to users. The `Authorizor` class should not permit
    user access to a permission if they are not logged in, so they''ll need a reference
    to a specific authenticator. We''ll also need to set up the permission dictionary
    upon initialization:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行放在模块级别，不在任何类定义之外，因此可以通过`auth.authenticator`访问`authenticator`变量。现在我们可以开始`Authorizor`类，它将权限映射到用户。`Authorizor`类不应允许用户访问权限，如果他们未登录，因此它们将需要引用特定的认证实例。我们还需要在初始化时设置权限字典：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we can write methods to add new permissions and to set up which users are
    associated with each permission:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写方法来添加新的权限，并设置哪些用户与每个权限相关联：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first method allows us to create a new permission, unless it already exists,
    in which case an exception is raised. The second allows us to add a username to
    a permission, unless either the permission or the username doesn't yet exist.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法允许我们创建一个新的权限，除非它已经存在，否则会引发异常。第二个方法允许我们将用户名添加到权限中，除非权限或用户名尚不存在。
- en: We use `set` instead of `list` for usernames, so that even if you grant a user
    permission more than once, the nature of sets means the user is only in the set
    once.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`set`而不是`list`来存储用户名，这样即使您多次授予用户权限，集合的性质意味着用户只会在集合中出现一次。
- en: 'A `PermissionError` error is raised in both methods. This new error doesn''t
    require a username, so we''ll make it extend `Exception` directly, instead of
    our custom `AuthException`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都引发了`PermissionError`错误。这个新错误不需要用户名，所以我们将它直接扩展为`Exception`，而不是我们自定义的`AuthException`：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we can add a method to check whether a user has a specific `permission`
    or not. In order for them to be granted access, they have to be both logged into
    the authenticator and in the set of people who have been granted access to that
    privilege. If either of these conditions is unsatisfied, an exception is raised:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加一个方法来检查用户是否具有特定的`permission`。为了让他们获得访问权限，他们必须同时登录到认证器并在被授予该特权访问的人员集合中。如果这两个条件中有一个不满足，就会引发异常：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There are two new exceptions in here; they both take usernames, so we''ll define
    them as subclasses of `AuthException`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个新的异常；它们都使用用户名，所以我们将它们定义为`AuthException`的子类：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we can add a default `authorizor` to go with our default authenticator:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以添加一个默认的`authorizor`来与我们的默认认证器配对：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'That completes a basic authentication/authorization system. We can test the
    system at the Python prompt, checking to see whether a user, `joe`, is permitted
    to do tasks in the paint department:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了一个基本的身份验证/授权系统。我们可以在Python提示符下测试系统，检查用户`joe`是否被允许在油漆部门执行任务：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'While verbose, the preceding output shows all of our code and most of our exceptions
    in action, but to really understand the API we''ve defined, we should write some
    exception handling code that actually uses it. Here''s a basic menu interface
    that allows certain users to change or test a program:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然冗长，前面的输出显示了我们所有的代码和大部分异常的运行情况，但要真正理解我们定义的API，我们应该编写一些实际使用它的异常处理代码。这里有一个基本的菜单界面，允许特定用户更改或测试程序：
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This rather long example is conceptually very simple. The `is_permitted` method
    is probably the most interesting; this is a mostly internal method that is called
    by both `test` and `change` to ensure the user is permitted access before continuing.
    Of course, those two methods are stubs, but we aren't writing an editor here;
    we're illustrating the use of exceptions and exception handlers by testing an
    authentication and authorization framework.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相当长的例子在概念上非常简单。 `is_permitted` 方法可能是最有趣的；这是一个主要是内部方法，被`test`和`change`调用，以确保用户在继续之前被允许访问。当然，这两种方法都是存根，但我们这里不是在写编辑器；我们是通过测试身份验证和授权框架来说明异常和异常处理的使用。
- en: Exercises
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: If you've never dealt with exceptions before, the first thing you need to do
    is look at any old Python code you've written and notice if there are places you
    should have been handling exceptions. How would you handle them? Do you need to
    handle them at all? Sometimes, letting the exception propagate to the console
    is the best way to communicate to the user, especially if the user is also the
    script's coder. Sometimes, you can recover from the error and allow the program
    to continue. Sometimes, you can only reformat the error into something the user
    can understand and display it to them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未处理过异常，你需要做的第一件事是查看你写过的任何旧的Python代码，并注意是否有应该处理异常的地方。你会如何处理它们？你需要完全处理它们吗？有时，让异常传播到控制台是与用户沟通的最佳方式，特别是如果用户也是脚本的编码者。有时，你可以从错误中恢复并允许程序继续。有时，你只能将错误重新格式化为用户可以理解的内容并显示给他们。
- en: Some common places to look are file I/O (is it possible your code will try to
    read a file that doesn't exist?), mathematical expressions (is it possible that
    a value you are dividing by is zero?), list indices (is the list empty?), and
    dictionaries (does the key exist?). Ask yourself whether you should ignore the
    problem, handle it by checking values first, or handle it with an exception. Pay
    special attention to areas where you might have used `finally` and `else` to ensure
    the correct code is executed under all conditions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的查找地方是文件I/O（你的代码是否可能尝试读取一个不存在的文件？），数学表达式（你要除以的值是否可能为零？），列表索引（列表是否为空？）和字典（键是否存在？）。问问自己是否应该忽略问题，通过先检查值来处理它，还是通过异常来处理它。特别注意可能使用`finally`和`else`来确保在所有条件下执行正确代码的地方。
- en: Now write some new code. Think of a program that requires authentication and
    authorization, and try writing some code that uses the `auth` module we built
    in the case study. Feel free to modify the module if it's not flexible enough.
    Try to handle
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在写一些新代码。想想一个需要身份验证和授权的程序，并尝试编写一些使用我们在案例研究中构建的`auth`模块的代码。如果模块不够灵活，可以随意修改模块。尝试处理
- en: all the exceptions in a sensible way. If you're having trouble coming up with
    something that requires authentication, try adding authorization to the Notepad
    example from [Chapter 16](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml), *Objects
    in Python*, or add authorization to the `auth` module itself—it's not a terribly
    useful module if just anybody can start adding permissions! Maybe require an administrator
    username and password before allowing privileges to be added or changed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以明智的方式处理所有异常。如果你在想出需要身份验证的东西时遇到麻烦，可以尝试在[第16章](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml)的记事本示例中添加授权，*Python中的对象*，或者在`auth`模块本身添加授权——如果任何人都可以开始添加权限，这个模块就不是一个非常有用的模块！也许在允许添加或更改权限之前需要管理员用户名和密码。
- en: Finally, try to think of places in your code where you can raise exceptions.
    It can be in code you've written or are working on; or you can write a new project
    as an exercise. You'll probably have the best luck for designing a small framework
    or API that is meant to be used by other people; exceptions are a terrific communication
    tool between your code and someone else's. Remember to design and document any
    self-raised exceptions as part of the API, or they won't know whether or how to
    handle them!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，试着想想你的代码中可以引发异常的地方。可以是你写过或正在处理的代码；或者你可以编写一个新的项目作为练习。你可能最容易设计一个小型框架或API，供其他人使用；异常是你的代码和别人之间的绝妙沟通工具。记得设计和记录任何自引发的异常作为API的一部分，否则他们将不知道是否以及如何处理它们！
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went into the gritty details of raising, handling, defining,
    and manipulating exceptions. Exceptions are a powerful way to communicate unusual
    circumstances or error conditions without requiring a calling function to explicitly
    check return values. There are many built-in exceptions and raising them is trivially
    easy. There are several different syntaxes for handling different exception events.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们深入讨论了引发、处理、定义和操纵异常的细节。异常是一种强大的方式，可以在不要求调用函数显式检查返回值的情况下，传达异常情况或错误条件。有许多内置的异常，引发它们非常容易。处理不同异常事件有几种不同的语法。
- en: In the next chapter, everything we've studied so far will come together as we
    discuss how object-oriented programming principles and structures should best
    be applied in Python applications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论到目前为止所学的一切如何结合在一起，讨论面向对象编程原则和结构在Python应用程序中应该如何最好地应用。
