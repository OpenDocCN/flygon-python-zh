- en: Calculus and Differential Equations
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分和微分方程
- en: In this chapter, we will discuss various topics related to calculus. Calculus
    is the branch of mathematics that concerns the processes of differentiation and
    integration. Geometrically, the derivative of a function represents the gradient
    of the curve of the function, and the integral of a function represents the area
    below the curve of the function. Of course, these characterizations only hold
    in certain circumstances, but they provide a reasonable foundation for this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论与微积分相关的各种主题。微积分是涉及微分和积分过程的数学分支。从几何上讲，函数的导数代表函数曲线的梯度，函数的积分代表函数曲线下方的面积。当然，这些特征只在某些情况下成立，但它们为本章提供了一个合理的基础。
- en: 'We start by looking at calculus for a simple class of functions: the polynomials.
    In the first recipe, we create a class that represents a polynomial and define
    methods that differentiate and integrate the polynomial. Polynomials are convenient
    because the derivative or integral of a polynomial is again a polynomial. Then,
    we use the SymPy package to perform symbolic differentiation and integration on
    more general functions. After that, we see methods for solving equations using
    the SciPy package. Next, we turn our attention to numerical integration (quadrature)
    and solving differential equations. We use the SciPy package to solve ordinary
    differential equations and systems of ordinary differential equations, and then
    use a finite difference scheme to solve a simple partial differential equation.
    Finally, we use the fast Fourier transform to process a noisy signal and filter
    out the noise.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看一下简单函数类的微积分：多项式。在第一个示例中，我们创建一个表示多项式的类，并定义不同iate和积分多项式的方法。多项式很方便，因为多项式的导数或积分再次是多项式。然后，我们使用SymPy包对更一般的函数进行符号微分和积分。之后，我们看到使用SciPy包解方程的方法。接下来，我们将注意力转向数值积分（求积）和解微分方程。我们使用SciPy包来解常微分方程和常微分方程组，然后使用有限差分方案来解简单的偏微分方程。最后，我们使用快速傅里叶变换来处理嘈杂的信号并滤除噪音。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下示例：
- en: Working with polynomials and calculus
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多项式和微积分
- en: Differentiating and integrating symbolically using SymPy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SymPy进行符号微分和积分
- en: Solving equations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解方程
- en: Integrating functions numerically using SciPy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SciPy进行数值积分
- en: Solving simple differential equations numerically
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数值方法解简单的微分方程
- en: Solving systems of differential equations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解微分方程组
- en: Solving partial differential equations numerically
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数值方法解偏微分方程
- en: Using discrete Fourier transforms for signal processing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用离散傅里叶变换进行信号处理
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In addition to the scientific Python packages NumPy and SciPy, we also need
    the SymPy package. This can be installed using your favorite package manager,
    such as `pip`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了科学Python包NumPy和SciPy之外，我们还需要SymPy包。可以使用您喜欢的软件包管理器（如`pip`）来安装它：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code for this chapter can be found in the`Chapter 03` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2003](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2003).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub存储库的`Chapter 03`文件夹中找到，网址为[https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2003](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2003)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/32HuH4X](https://bit.ly/32HuH4X).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[https://bit.ly/32HuH4X](https://bit.ly/32HuH4X)。
- en: Working with polynomials and calculus
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多项式和微积分
- en: 'Polynomials are among the simplest functions in mathematics and are defined
    as a sum:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式是数学中最简单的函数之一，定义为一个求和：
- en: '![](assets/21d2a94c-cfae-48b2-92cd-b345dd6fe425.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/21d2a94c-cfae-48b2-92cd-b345dd6fe425.png)'
- en: '*x* represents a placeholder to be substituted, and *a[i]* is a number. Since
    polynomials are simple, they provide an excellent means for a brief introduction
    to calculus. Calculus concerns the *differentiation* and *integration* of functions.
    Integration is, roughly speaking, *anti-differentiation*, in the sense that first
    integrating and then differentiating yields the original function.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*代表要替换的占位符，*a[i]*是一个数字。由于多项式很简单，它们提供了一个很好的方式来简要介绍微积分。微积分涉及函数的*微分*和*积分*。积分大致上是*反微分*，因为先积分然后微分会得到原始函数。'
- en: In this recipe, we will define a simple class that represents a polynomial and
    write methods for this class to perform differentiation and integration.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将定义一个表示多项式的简单类，并为该类编写方法以执行微分和积分。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Geometrically, the *derivative*, obtained by *differentiating*, of a function
    is its *gradient*, and the *integral*, obtained by *integrating*, of a function
    is the area that lies between the curve of the function and the *x* axis, accounting
    for whether the curve lies above or below the axis. In practice, differentiating
    and integrating are done symbolically, using a set of rules and standard results
    that are particularly simple for polynomials.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从几何上讲，通过*微分*得到的*导数*是函数的*梯度*，通过*积分*得到的*积分*是函数曲线与*x*轴之间的面积，考虑到曲线是在轴的上方还是下方。在实践中，微分和积分是通过一组规则和特别适用于多项式的标准结果来进行符号化处理。
- en: There are no additional packages required for this recipe.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例不需要额外的软件包。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps describe how to create a class representing a polynomial
    and implement differentiation and integration methods for this class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何创建表示多项式的类，并为该类实现微分和积分方法：
- en: 'Let''s start by defining a simple class to represent a polynomial:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先定义一个简单的类来表示多项式：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have defined a basic class for a polynomial, we can move on to
    implement the differentiation and integration operations for this `Polynomial`
    class to illustrate how these operations change polynomials. We start with differentiation.
    We generate new coefficients by multiplying each element in the current list of
    coefficients without the first element. We use this new list of coefficients to
    create a new `Polynomial` instance that is returned:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经为多项式定义了一个基本类，我们可以继续实现这个`Polynomial`类的微分和积分操作，以说明这些操作如何改变多项式。我们从微分开始。我们通过将当前系数列表中的每个元素（不包括第一个元素）相乘来生成新的系数。我们使用这个新的系数列表来创建一个新的`Polynomial`实例，然后返回：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To implement the integration method, we need to create a new list of coefficients
    containing the new constant (converted to a float for consistency) given by the
    argument. We then add to this list of coefficients the old coefficients divided
    by their new position in the list:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现积分方法，我们需要创建一个包含由参数给出的新常数（转换为浮点数以保持一致性）的新系数列表。然后我们将旧系数除以它们在列表中的新位置，加到这个系数列表中：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, to make sure these methods work as expected, we should test these
    two methods with a simple case. We can check this using a very simple polynomial,
    such as *x² - 2x + 1*:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了确保这些方法按预期工作，我们应该用一个简单的案例测试这两种方法。我们可以使用一个非常简单的多项式来检查，比如*x² - 2x + 1*：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Polynomials offer an easy introduction to the basic operations of calculus,
    but it isn't so easy to construct Python classes for other general classes of
    functions. That being said, polynomials are extremely useful because they are
    well understood and, perhaps more importantly, calculus for polynomials is very
    easy. For powers of a variable *x*, the rule for differentiation is to multiply
    by the power and reduce the power by 1, so that *x^n* becomes *nx^(n-1)*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式为我们提供了一个对微积分基本操作的简单介绍，但对于其他一般类的函数来说，构建Python类并不那么容易。也就是说，多项式非常有用，因为它们被很好地理解，也许更重要的是，对于多项式的微积分非常容易。对于变量*x*的幂，微分的规则是乘以幂并减少1，因此*x^n*变为*nx^(n-1)*。
- en: Integration is more complex, since the integral of a function is not unique.
    We can add any constant to an integral and obtain a second integral. For powers
    of a variable *x*, the rule for integration is to increase the power by 1 and
    divide by the new power, so that *x^n* becomes *x^(n+1)/*(*n+1*), so to integrate
    a polynomial, we increase each power of *x* by 1 and divide the corresponding
    coefficient by the new power.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 积分更复杂，因为函数的积分不是唯一的。我们可以给积分加上任意常数并得到第二个积分。对于变量*x*的幂，积分的规则是将幂增加1并除以新的幂，因此*x^n*变为*x^(n+1)/*(*n+1*)，所以要对多项式进行积分，我们将每个*x*的幂增加1，并将相应的系数除以新的幂。
- en: The `Polynomial` class that we defined in the recipe is rather simplistic, but
    represents the core idea. A polynomial is uniquely determined by its coefficients,
    which we can store as a list of numerical values. Differentiation and integration
    are operations that we can perform on this list of coefficients. We include a
    simple `__repr__` method to help with the display of `Polynomial` objects, and
    a `__call__` method to facilitate evaluation at specific numerical values. This
    is mostly to demonstrate the way that a polynomial is evaluated.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个食谱中定义的`Polynomial`类相当简单，但代表了核心思想。多项式由其系数唯一确定，我们可以将其存储为一组数值值的列表。微分和积分是我们可以对这个系数列表执行的操作。我们包括一个简单的`__repr__`方法来帮助显示`Polynomial`对象，以及一个`__call__`方法来促进在特定数值上的评估。这主要是为了演示多项式的评估方式。
- en: Polynomials are useful for solving certain problems that involve evaluating
    a computationally expensive function. For such problems, we can sometimes use
    some kind of polynomial interpolation, where we "fit" a polynomial to another
    function, and then use the properties of polynomials to help solve the original
    problem. Evaluating a polynomial is much "cheaper" than the original function,
    so this can lead to dramatic improvements in speed. This usually comes at the
    cost of some accuracy. For example, Simpson's rule for approximating the area
    under a curve approximates the curve by quadratic polynomials over intervals defined
    by three consecutive mesh points. The area below each quadratic polynomial can
    be calculated easily by integration.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式对于解决涉及评估计算昂贵函数的某些问题非常有用。对于这样的问题，我们有时可以使用某种多项式插值，其中我们将一个多项式“拟合”到另一个函数，然后利用多项式的性质来帮助解决原始问题。评估多项式比原始函数要“便宜”得多，因此这可能会大大提高速度。这通常是以一些精度为代价的。例如，辛普森法则用二次多项式逼近曲线下的面积，这些多项式是由三个连续网格点定义的间隔内的。每个二次多项式下面的面积可以通过积分轻松计算。
- en: There's more...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Polynomials have many more important roles in computational programming than
    simply demonstrating the effect of differentiation and integration. For this reason,
    a much richer `Polynomial` class is provided in the NumPy package, `numpy.polynomial`.
    The NumPy `Polynomial` class, and the various derived subclasses, are useful in
    all kinds of numerical problems, and support arithmetic operations as well as
    other methods. In particular, there are methods for fitting polynomials to collections
    of data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式在计算编程中扮演的角色远不止是展示微分和积分的效果。因此，NumPy包中提供了一个更丰富的`Polynomial`类，`numpy.polynomial`。NumPy的`Polynomial`类和各种派生子类在各种数值问题中都很有用，并支持算术运算以及其他方法。特别是，有用于将多项式拟合到数据集合的方法。
- en: NumPy also provides classes, derived from `Polynomial`, that represent various
    special kinds of polynomials. For example, the `Legendre` class represents a specific
    system of polynomials called the **Legendre** polynomials. The Legendre polynomials
    are defined for *x* satisfying *-1 ≤ x ≤ 1* and form an orthogonal system, which
    is important for applications such as numerical integration and the **finite element
    method** for solving partial differential equations. The Legendre polynomials
    are defined using a recursive relation. We define
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy还提供了从`Polynomial`派生的类，表示各种特殊类型的多项式。例如，`Legendre`类表示一种特定的多项式系统，称为**Legendre**多项式。Legendre多项式是为满足*-1
    ≤ x ≤ 1*的*x*定义的，并且形成一个正交系统，这对于诸如数值积分和**有限元方法**解决偏微分方程等应用非常重要。Legendre多项式使用递归关系定义。我们定义
- en: '![](assets/52bf688b-c298-4854-8933-fe2424d18981.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/52bf688b-c298-4854-8933-fe2424d18981.png)'
- en: and for each *n ≥ 2*, we define the *n*th Legendre polynomial to satisfy the
    recurrence relation,
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个*n ≥ 2*，我们定义第*n*个Legendre多项式满足递推关系，
- en: '![](assets/70211164-f54e-4915-8a81-c7e8dfb8c69b.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/70211164-f54e-4915-8a81-c7e8dfb8c69b.png)'
- en: There are several other so called *orthogonal (systems of) polynomials*, including
    *Laguerre**polynomials*, *Chebyshev polynomials*, and *Hermite polynomials*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些所谓的*正交（系统的）多项式*，包括*Laguerre*多项式*，*Chebyshev多项式*和*Hermite多项式*。
- en: See also
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Calculus is certainly well documented in mathematical texts, and there are many
    textbooks that cover from the basic methods all the way to the deep theory. Orthogonal
    systems of polynomials are also well documented among numerical analysis texts.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分在数学文本中有很好的文档记录，有许多教科书涵盖了从基本方法到深层理论的内容。正交多项式系统在数值分析文本中也有很好的文档记录。
- en: Differentiating and integrating symbolically using SymPy
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SymPy进行符号微分和积分
- en: At some point, you may have to differentiate a function that is not a simple
    polynomial, and you may need to do this in some kind of automated fashion, for
    example, if you are writing software for education. The Python scientific stack
    includes a package called SymPy, which allows us to create and manipulate symbolic
    mathematical expressions within Python. In particular, SymPy can perform differentiation
    and integration of symbolic functions, just like a mathematician.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些时候，您可能需要区分一个不是简单多项式的函数，并且可能需要以某种自动化的方式来做这件事，例如，如果您正在编写教育软件。Python科学堆栈包括一个名为SymPy的软件包，它允许我们在Python中创建和操作符号数学表达式。特别是，SymPy可以执行符号函数的微分和积分，就像数学家一样。
- en: In this recipe, we will create a symbolic function, and then differentiate and
    integrate this function using the SymPy library.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个符号函数，然后使用SymPy库对这个函数进行微分和积分。
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Unlike some of the other scientific Python packages, there does not seem to
    be a standard alias under which SymPy is imported in the literature. Instead the
    documentation uses a star import at several points, which is not in line with
    the PEP8 style guide. This is possibly to make the mathematical expressions more
    natural. We will simply import the module under its name `sympy`, to avoid any
    confusion with the `scipy` package''s standard abbreviation, `sp` (which is the
    natural choice for `sympy` too):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些科学Python软件包不同，文献中似乎没有一个标准的别名来导入SymPy。相反，文档在几个地方使用了星号导入，这与PEP8风格指南不一致。这可能是为了使数学表达更自然。我们将简单地按照其名称`sympy`导入模块，以避免与`scipy`软件包的标准缩写`sp`混淆（这也是`sympy`的自然选择）：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this recipe, we will define a symbolic expression that represents the function
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将定义一个表示函数的符号表达式
- en: '![](assets/d45795ee-95b9-4f79-85b3-b118aafc7d48.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d45795ee-95b9-4f79-85b3-b118aafc7d48.png)'
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Differentiating and integrating symbolically (as you would do by hand) is very
    easy using the SymPy package. Follow these steps to see how it is done:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SymPy软件包进行符号微分和积分（就像您手工操作一样）非常容易。按照以下步骤来看看它是如何完成的：
- en: 'Once SymPy is imported, we define the symbols that will appear in our expressions.
    This is a Python object that has no particular value, just like a mathematical
    variable, but can be used in formulas and expressions to represent many different
    values simultaneously. For this recipe, we need only define a symbol for *x*,
    since we will only require constant (literal) symbols and functions in addition
    to this. We use the `symbols` routine from `sympy` to define a new symbol. To
    keep the notation simple, we will name this new symbol `x`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦导入了SymPy，我们就定义将出现在我们的表达式中的符号。这是一个没有特定值的Python对象，就像数学变量一样，但可以在公式和表达式中表示许多不同的值。对于这个示例，我们只需要定义一个符号用于*x*，因为除此之外我们只需要常数（文字）符号和函数。我们使用`sympy`中的`symbols`例程来定义一个新符号。为了保持符号简单，我们将这个新符号命名为`x`：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The symbols defined using the `symbols` function support all of the arithmetic
    operations, so we can construct the expression directly using the symbol `x` we
    just defined:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`symbols`函数定义的符号支持所有算术运算，因此我们可以直接使用我们刚刚定义的符号`x`构造表达式：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can use the symbolic calculus capabilities of SymPy to compute the derivative
    of `f`, that is, differentiate `f`. We do this using the `diff` routine in `sympy`,
    which differentiates a symbolic expression with respect to a specified symbol,
    and returns an expression for the derivative. This is often not expressed in its
    simplest form, so we use the `sympy.simplify` routine to simplify the result:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用SymPy的符号微积分能力来计算`f`的导数，即对`f`进行微分。我们使用`sympy`中的`diff`例程来完成这个操作，它对指定的符号进行符号表达式微分，并返回导数的表达式。这通常不是以最简形式表达的，因此我们使用`sympy.simplify`例程来简化结果：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can check whether the result of the symbolic differentiation using SymPy
    is correct, compared to the derivative computed by hand, defined as a SymPy expression,
    as follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式检查使用SymPy进行符号微分的结果是否正确，与手工计算的导数相比，定义为SymPy表达式：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'SymPy equality tests whether two expressions are equal, but not whether they
    are symbolically equivalent. Therefore, we must first simplify the difference
    of the two statements we wish to test and test for equality to `0`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SymPy相等性测试两个表达式是否相等，但不测试它们是否在符号上等价。因此，我们必须首先简化我们希望测试的两个语句的差异，并测试是否等于`0`：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can integrate the function `f`using SymPy by using the `integrate`function.
    It is a good idea to also provide the symbol with which the integration is to
    be performed by providing it as the second optional argument:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用SymPy通过`integrate`函数对函数`f`进行积分。还可以通过将其作为第二个可选参数提供来提供要执行积分的符号：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: SymPy defines various classes to represent certain kinds of expressions. For
    example, symbols, represented by the `Symbol` class, are examples of *atomic expressions*.
    Expressions are built up in a similar way to how Python builds an abstract syntax
    tree from source code. These expression objects can then be manipulated using
    methods and the standard arithmetic operations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy定义了表示某些类型表达式的各种类。例如，由`Symbol`类表示的符号是*原子表达式*的例子。表达式是以与Python从源代码构建抽象语法树的方式构建起来的。然后可以使用方法和标准算术运算来操作这些表达式对象。
- en: SymPy also defines standard mathematical functions that can operate on the `Symbol`
    objects to create symbolic expressions. The most important feature is the ability
    to perform symbolic calculus – rather than the numerical calculus that we explore
    in the remainder of this chapter – and give exact (sometimes called *analytic*)
    solutions to calculus problems.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy还定义了可以在`Symbol`对象上操作以创建符号表达式的标准数学函数。最重要的特性是能够执行符号微积分 - 而不是我们在本章剩余部分中探索的数值微积分
    - 并给出对微积分问题的精确（有时称为*解析*）解决方案。
- en: The `diff` routine from the SymPy package performs differentiation on these
    symbolic expressions. The result of this routine is usually not in its simplest
    form, which is why we used the `simplify` routine to simplify the derivative in
    the recipe. The `integrate` routine symbolically integrates a `scipy` expression
    with respect to a given symbol. (The `diff` routine also accepts a symbol argument
    that specifies the symbol for differentiating against.) This returns an expression
    whose derivative is the original expression. This routine does not add a constant
    of integration, which is good practice when doing integrals by hand.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy软件包中的`diff`例程对这些符号表达式进行微分。这个例程的结果通常不是最简形式，这就是为什么我们在配方中使用`简化`例程来简化导数的原因。`integrate`例程用给定的符号对`scipy`表达式进行符号积分。（`diff`例程还接受一个符号参数，用于指定微分的符号。）这将返回一个其导数为原始表达式的表达式。这个例程不会添加积分常数，这在手工积分时是一个好的做法。
- en: There's more...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: SymPy can do much more than simple algebra and calculus. There are submodules
    for various areas of mathematics, such as number theory, geometry, and other discrete
    mathematics (such as combinatorics).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy可以做的远不止简单的代数和微积分。它有各种数学领域的子模块，如数论、几何和其他离散数学（如组合数学）。
- en: 'SymPy expressions (and functions) can be built into Python functions that can
    be applied to NumPy arrays. This is done using the `lambdify` routine from the
    `sympy.utilities` module. This converts a SymPy expression to a numerical expression
    that uses the NumPy equivalents of the SymPy standard functions to evaluate the
    expressions numerically. The result is similar to defining a Python Lambda, hence
    the name. For example, we could convert the function and derivative from this
    recipe into Python functions using this routine:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy表达式（和函数）可以构建成Python函数，可以应用于NumPy数组。这是使用`sympy.utilities`模块中的`lambdify`例程完成的。这将SymPy表达式转换为使用SymPy标准函数的NumPy等价函数来数值评估表达式。结果类似于定义Python
    Lambda，因此得名。例如，我们可以使用这个例程将这个配方中的函数和导数转换为Python函数：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `lambdify` routine takes two arguments. The first is the variables to be
    provided, `x` in the previous code block, and the second is the expression to
    be evaluated when this function is called. For example, we can evaluate the lambdified
    SymPy expressions defined previously as if they were ordinary Python functions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambdify`例程接受两个参数。第一个是要提供的变量，上一个代码块中的`x`，第二个是在调用此函数时要评估的表达式。例如，我们可以评估之前定义的lambdified
    SymPy表达式，就好像它们是普通的Python函数一样：'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can even evaluate these lambdified expressions on NumPy arrays:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以在NumPy数组上评估这些lambdified表达式：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `lambdify` routine uses the Python `exec` routine to execute the code, so
    it should not be used with unsanitized input.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambdify`例程使用Python的`exec`例程来执行代码，因此不应该与未经过消毒的输入一起使用。'
- en: Solving equations
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解方程
- en: Many mathematical problems eventually reduce to solving an equation of the form*f(x*)
    = 0, where *f* is a function of a single variable. Here, we try to find a value
    of *x* for which the equation holds. The values of *x* for which the equation
    holds are sometimes called *roots* of the equation. There are numerous algorithms
    for finding solutions to equations of this form. In this recipe, we will use the
    Newton-Raphson and secant methods to solve an equation of the form *f(x*) = 0.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数学问题最终归结为解形式为*f(x*) = 0的方程，其中*f*是单变量函数。在这里，我们试图找到一个使方程成立的*x*的值。使方程成立的*x*的值有时被称为方程的*根*。有许多算法可以找到这种形式的方程的解。在这个配方中，我们将使用牛顿-拉弗森和弦截法来解决形式为*f(x*)
    = 0的方程。
- en: The Newton-Raphson method (Newton's method) and the secant method are good,
    standard root finding algorithms that can be applied in almost any situation.
    These are*iterative methods* that start with an approximation of the root and
    iteratively improve this approximation until it lies within a given tolerance.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿-拉弗森方法（牛顿法）和弦截法是良好的标准根查找算法，几乎可以应用于任何情况。这些是*迭代方法*，从一个根的近似值开始，并迭代改进这个近似值，直到它在给定的容差范围内。
- en: To demonstrate these techniques, we will use the function from the *Symbolic
    calculus using SymPy* recipe defined by
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这些技术，我们将使用*使用SymPy进行符号计算*配方中定义的函数
- en: '![](assets/c13a1277-2b71-46bc-9151-3a68073ce5b6.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c13a1277-2b71-46bc-9151-3a68073ce5b6.png)'
- en: which is defined for all real values of *x* and has exactly two roots, one at*x*
    = 0 and one at*x*= 2.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它对所有实数*x*都有定义，并且恰好有两个根，一个在*x*=0，另一个在*x*=2。
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The SciPy package contains routines for solving equations (among many other
    things). The root finding routines can be found in the `optimize`module from the
    `scipy` package.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy包含用于解方程的例程（以及许多其他内容）。根查找例程可以在`scipy`包的`optimize`模块中找到。
- en: If your equation is not in the form *f*(*x*) = *0*, then you will need to rearrange
    it so that this is the case. This is usually not too difficult, and simply requires
    moving any terms on the right-hand side over to the left-hand side. For example,
    if you wish to find the fixed points of a function, that is, when*g*(*x*)*= x*,
    then we would apply the method to the related function given by *f*(*x*) =*g*(*x*)*-
    x.*
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的方程不是形式上的*f*(*x*) = *0*，那么你需要重新排列它，使其成为这种情况。这通常不太困难，只需要将右侧的任何项移到左侧即可。例如，如果你希望找到函数的不动点，也就是当*g*(*x*)*=
    x*时，我们会将方法应用于由*f*(*x*) =*g*(*x*)*- x.*给出的相关函数。
- en: How to do it...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The `optimize` package provides routines for numerical root finding. The following
    instructions describe how to use the `newton` routine from this module:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`optimize`包提供了用于数值根查找的例程。以下说明描述了如何使用该模块中的`newton`例程：'
- en: 'The `optimize`module is not listed in the `scipy`namespace, so you must import
    it separately:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`optimize`模块没有列在`scipy`命名空间中，所以你必须单独导入它：'
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we must define this function and its derivative in Python:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们必须在Python中定义这个函数及其导数：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The derivative of this function was computed in the previous recipe:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数的导数在前一个配方中被计算出来：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For both the Newton-Raphson and secant methods, we use the `newton` routine
    from `optimize`. Both the secant method and the Newton-Raphson method require
    the function and the first argument and the first approximation,`x0`, as the second
    argument. To use the Newton-Raphson method, we must provide thederivative of*f*,
    using the `fprime`keyword argument:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于牛顿-拉弗森和割线法，我们使用`optimize`中的`newton`例程。割线法和牛顿-拉弗森法都需要函数和第一个参数以及第一个近似值`x0`作为第二个参数。要使用牛顿-拉弗森法，我们必须提供*f*的导数，使用`fprime`关键字参数：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To use the secant method, only the function is needed, but we must provide
    the first two approximations for the root; the second is provided as the `x1`keyword
    argument:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用割线法时，只需要函数，但是我们必须提供根的前两个近似值；第二个作为`x1`关键字参数提供：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Neither the Newton-Raphson nor the secant method are guaranteed to converge
    to a root. It is perfectly possible that the iterates of the method will simply
    cycle through a number of points (periodicity) or fluctuate wildly (chaos).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿-拉弗森法和割线法都不能保证收敛到根。完全有可能方法的迭代只是在一些点之间循环（周期性）或者波动剧烈（混沌）。
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The Newton-Raphson method for a function*f*(*x*) with derivative*f'*(*x*) and
    initial approximation *x[0]*is defined iteratively using the formula
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有导数*f'*(*x*)和初始近似值*x[0]*的函数*f*(*x*)，牛顿-拉弗森方法使用以下公式进行迭代定义
- en: '![](assets/f3f99361-b4f0-4dde-8420-e7e76aa123a3.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f3f99361-b4f0-4dde-8420-e7e76aa123a3.png)'
- en: for each integer*i* ≥*0*. Geometrically, this formula arises by considering
    the direction in which the gradient is negative (so the function is decreasing)
    if*f(x[i])*>*0* or positive (so the function is increasing) if*f*(*x[i]*) <*o*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个整数*i* ≥*0*。从几何上讲，这个公式是通过考虑梯度的负方向（所以函数是递减的）如果*f(x[i])*>*0*或正方向（所以函数是递增的）如果*f*(*x[i]*)
    <*o*。
- en: The secant method is based on the Newton-Raphson method, but replaces the first
    derivative by the approximation
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 割线法基于牛顿-拉弗森法，但是用近似值替换了一阶导数
- en: '![](assets/f2412966-ce93-4807-8fb9-cadb324252e5.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f2412966-ce93-4807-8fb9-cadb324252e5.png)'
- en: when*x[i]*-*x[i-1]* is sufficiently small, which occurs if the method is converging,
    then this is a good approximation. The price paid for not requiring the derivative
    of the function*f* is that we require an additional initial guess to start the
    method. The formula for the method is given by
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当*x[i]*-*x[i-1]*足够小时，这意味着方法正在收敛，这是一个很好的近似值。不需要函数*f*的导数的代价是我们需要一个额外的初始猜测来启动方法。该方法的公式如下
- en: '![](assets/85704de4-933f-4fd1-86a4-792565350241.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/85704de4-933f-4fd1-86a4-792565350241.png)'
- en: Generally speaking, if either method is given an initial guess (guesses for
    the secant method) that is sufficiently close to a root, then the method will
    converge to that root. The Newton-Raphson method can also fail if the derivative
    is zero at one of the iterations, in which case the formula is not well defined.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果任一方法得到一个足够接近根的初始猜测（割线法的猜测），那么该方法将收敛于该根。牛顿-拉弗森法在迭代中导数为零时也可能失败，此时公式未被很好地定义。
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The methods mentioned in this recipe are general purpose methods, but there
    are others that may be faster or more accurate in some circumstances. Broadly
    speaking, root finding algorithms fall into two categories: algorithms that use
    information about the function''s gradient at each iterate (Newton-Raphson, secant,
    Halley) and algorithms that require bounds on the location of a root (bisection
    method, regula-falsi, Brent). The algorithms discussed so far are of the first
    kind, and while generally quite fast, they may fail to converge.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方中提到的方法是通用方法，但在某些情况下可能有更快或更准确的方法。广义上讲，根查找算法分为两类：在每次迭代中使用函数梯度信息的算法（牛顿-拉弗森、割线、Halley）和需要根位置的界限的算法（二分法、regula-falsi、Brent）。到目前为止讨论的算法属于第一类，虽然通常相当快，但可能无法收敛。
- en: 'The second kind of algorithms are those for which a root is known to exist
    within a specified interval*a ≤**x* ≤*b*. We can check whether a root lies within
    such an interval by checking that*f*(*a*) and*f*(*b*) have different signs, that
    is, one of *f*(*a*) <*0*<*f*(*b*) or*f*(*b*) <*0*<*f*(*a*) is true. (Provided,
    of course, that the function is*continuous,* which tends to be the case in practice.)
    The most basic algorithm of this kind is the bisection algorithm, which repeatedly
    bisects the interval until a sufficiently good approximation to the root is found.
    The basic premise is to split the interval between*a*and *b*at the mid-point and
    select the interval in which the function changes sign. The algorithm repeats
    until the interval is very small. The following is a rudimentary implementation
    of this algorithm in Python:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种算法是已知根存在于指定区间内的算法*a ≤**x* ≤*b*。我们可以通过检查*f*(*a*)和*f*(*b*)是否有不同的符号来检查根是否在这样的区间内，也就是说，*f*(*a*)
    <*0*<*f*(*b*)或*f*(*b*) <*0*<*f*(*a*)其中一个为真。（当然，前提是函数是*连续*的，在实践中往往是这样。）这种类型的最基本算法是二分法算法，它重复地将区间二分，直到找到根的足够好的近似值。基本前提是在*a*和*b*之间分割区间，并选择函数改变符号的区间。该算法重复，直到区间非常小。以下是Python中此算法的基本实现：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This method is guaranteed to converge, since at each step the distance*b-a*
    is halved. However, it is possible that the method will require more iterations
    than Newton-Raphson or the secant method. A version of the bisection method can
    also be found in`optimize`. This version is implemented in C and is considerably
    more efficient that the version presented here, but the bisection method is not
    the fastest method in most cases.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法保证收敛，因为在每一步中，距离*b-a*减半。但是，可能需要比牛顿-拉弗森或割线法更多的迭代次数。`optimize`中也可以找到二分法的版本。这个版本是用C实现的，比这里呈现的版本要高效得多，但是在大多数情况下，二分法不是最快的方法。
- en: 'Brent''s method is an improvement on the bisection method, and is available
    in the`optimize` module as`brentq`. It uses a combination of bisection and interpolation
    to quickly find the root of an equation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Brent的方法是对二分法的改进，在`optimize`模块中作为`brentq`可用。它使用二分和插值的组合来快速找到方程的根：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is important to note that the techniques that involve bracketing (bisection,
    regula-falsi, Brent) cannot be used to find the root functions of a complex variable,
    whereas those techniques that do not use bracketing (Newton, secant, Halley) can.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，涉及括号（二分法、regula-falsi、Brent）的技术不能用于找到复变量的根函数，而不使用括号（Newton、割线、Halley）的技术可以。
- en: Integrating functions numerically using SciPy
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SciPy进行数值积分
- en: Integration can be interpreted as the area that lies between a curve and the
    *x*axis, signed according to whether this area is above or below the axis. Some
    integrals cannot be computed directly, using symbolic means, and instead have
    to be approximated numerically. One classic example of this is the Gaussian error
    function, which was mentioned in the *Basic mathematical functions* section in
    [Chapter1](6bc3b1d7-d916-4560-b4a3-8f4001bee082.xhtml), *Basic Packages, Functions,
    and Concepts*. This is defined by the formula
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 积分可以解释为曲线与*x*轴之间的区域，根据这个区域是在轴的上方还是下方进行标记。有些积分无法直接使用符号方法计算，而必须进行数值近似。其中一个经典例子是高斯误差函数，在[第1章](6bc3b1d7-d916-4560-b4a3-8f4001bee082.xhtml)的*基本数学函数*部分中提到。这是由以下公式定义的
- en: '![](assets/97d08d9b-2e67-4e07-88c0-f52be50f2ae1.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/97d08d9b-2e67-4e07-88c0-f52be50f2ae1.png)'
- en: and the integral that appears here cannot be evaluated symbolically.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这里出现的积分也无法通过符号方法计算。
- en: In this recipe, we will see how to use the numerical integration routines in
    the SciPy package to compute the integral of a function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将看到如何使用SciPy包中的数值积分例程来计算函数的积分。
- en: Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We use the `scipy.integrate`module, which contains several routines for computing
    numerical integrals. We import this module as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`scipy.integrate`模块，其中包含几个用于计算数值积分的例程。我们将此模块导入如下：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'The following steps describe how to numerically integrate a function using
    SciPy:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了如何使用SciPy进行数值积分：
- en: 'We evaluate the integral that appears in the definition of the error function
    at the value *x = 1*. For this, we need to define the integrand (the function
    that appears inside the integral) in Python:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们评估出现在误差函数定义中的积分在*x = 1*处的值。为此，我们需要在Python中定义被积函数（出现在积分内部）：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are two main routines in `scipy.integrate`for performing numerical integration
    (quadrature) that can be used. The first is the `quad`function, which uses QUADPACK
    to perform the integration, and the second is `quadrature`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipy.integrate`中有两个主要例程用于执行数值积分（求积），可以使用。第一个是`quad`函数，它使用QUADPACK执行积分，第二个是`quadrature`。'
- en: 'The `quad`routine is a general-purpose integration tool. It expects three arguments,
    which are the function to be integrated (`erf_integrand`), the lower limit (`-1.0`),
    and the upper limit (`1.0`):'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`quad`例程是一个通用的积分工具。它期望三个参数，即要积分的函数（`erf_integrand`），下限（`-1.0`）和上限（`1.0`）：'
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first returned value is the value of the integral and the second is an estimate
    for the error.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个返回值是积分的值，第二个是误差的估计。
- en: 'Repeating the computation with the `quadrature`routine, we get the following.
    The arguments are the same as for the `quad` routine:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`quadrature`例程重复计算，我们得到以下结果。参数与`quad`例程相同：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The output is the same format as the code, with the value of the integral and
    then an estimate of the error. Notice that the error is larger for the `quadrature`routine.
    This is a result of the method terminating once the estimated error falls below
    a given tolerance, which can be modified when the routine is called.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与代码的格式相同，先是积分的值，然后是误差的估计。请注意，`quadrature`例程的误差更大。这是因为一旦估计的误差低于给定的容差，方法就会终止，当调用例程时可以修改这个容差。
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Most numerical integration techniques follow the same basic procedure. First,
    we choose points *x[i]*for *i = 1, 2,…, n* in the region of integration, and then
    use these values and the values *f*(*x[i]*) to approximate the integral. For example,
    with the trapezium rule, we approximate the integral by
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数值积分技术都遵循相同的基本过程。首先，我们选择积分区域中的点*x[i]*，对于*i = 1, 2,…, n*，然后使用这些值和值*f*(*x[i]*)来近似积分。例如，使用梯形法则，我们通过以下方式近似积分
- en: '![](assets/ae1f28f9-d69a-446b-a943-b34ce41e4bcb.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ae1f28f9-d69a-446b-a943-b34ce41e4bcb.png)'
- en: 'where *a < x[1]< x[2]< … < x[n-1]< b* and *h*is the (common) difference between
    adjacent *x[i]*values, including the end points *a*and *b*. This can be implemented
    in Python as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*a < x[1]< x[2]< … < x[n-1]< b*，*h*是相邻*x[i]*值之间的（公共）差异，包括端点*a*和*b*。这可以在Python中实现如下：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The algorithms used by `quad`and `quadrature`are far more sophisticated than
    this. Using this function to approximate the integral of `erf_integrand`using
    `trapezium`yields a result of 1.4936463036001209, which agrees with the approximations
    from the `quad` and `quadrature` routines to 5 decimal places.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`quad`和`quadrature`使用的算法比这复杂得多。使用这个函数来近似使用`trapezium`积分`erf_integrand`的积分得到的结果是1.4936463036001209，这与`quad`和`quadrature`例程的近似结果在5位小数的情况下是一致的。'
- en: The `quadrature`routine uses a fixed tolerance Gaussian quadrature, whereas
    the `quad`routine uses an adaptive algorithm implemented in the Fortran library
    QUADPACK routines. Timing both routines, we find that the `quad` routine is approximately
    5 times faster than the `quadrature` routine for the problem described in the
    recipe. The `quad` routine executes in approximately 27 µs, averaged over 1 million
    executions, while the `quadrature` routine executes in approximately 134 µs. (Your
    results may differ depending on your system.)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`quadrature`例程使用固定容差的高斯积分，而`quad`例程使用Fortran库QUADPACK例程中实现的自适应算法。对两个例程进行计时，我们发现对于配方中描述的问题，`quad`例程大约比`quadrature`例程快5倍。`quad`例程在大约27微秒内执行，平均执行1百万次，而`quadrature`例程在大约134微秒内执行。（您的结果可能会因系统而异。）'
- en: There's more...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The routines mentioned in this section require the integrand function to be
    known, which is not always the case. Instead, it might be the case that we know
    a number of pairs (*x*,y) with *y = f*(*x*), but we don't know the function *f*to
    evaluate at additional points. In this case, we can use one of the sampling quadrature
    techniques from `scipy.integrate`. If the number of known points is very large
    and all points are equally spaced, we can use Romberg integration for a good approximation
    of the integral. For this, we use the `romb`routine. Otherwise, we can use a variant
    of the trapezium rule (as above) using the `trapz`routine, or Simpson's rule using
    the `simps` routine.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提到的例程需要知道被积函数，但情况并非总是如此。相反，可能是我们知道一些(*x*,y)对，其中*y = f*(*x*)，但我们不知道要在额外点上评估的函数*f*。在这种情况下，我们可以使用`scipy.integrate`中的采样积分技术之一。如果已知点的数量非常大，并且所有点都是等间距的，我们可以使用Romberg积分来很好地近似积分。为此，我们使用`romb`例程。否则，我们可以使用梯形法则的变体（如上所述）使用`trapz`例程，或者使用`simps`例程使用辛普森法则。
- en: Solving simple differential equations numerically
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值解简单微分方程
- en: Differential equations arise in situations where a quantity evolves, usually
    over time, according to a given relationship. They are extremely common in engineering
    and physics, and appear quite naturally. One of the classic examples of a (very
    simple) differential equation is the law of cooling devised by Newton. The temperature
    of a body cools at a rate proportional to the current temperature. Mathematically,
    this means that we can write the derivative of the temperature *T* of the body
    at time *t > 0* using the differential equation
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 微分方程出现在一个数量根据给定关系演变的情况中，通常是随着时间的推移。它们在工程和物理学中非常常见，并且自然地出现。一个经典的（非常简单）微分方程的例子是牛顿提出的冷却定律。物体的温度以与当前温度成比例的速率冷却。从数学上讲，这意味着我们可以写出物体在时间*t
    > 0*时的温度*T*的导数，使用微分方程
- en: '![](assets/81295a45-5fdf-4837-86ac-96caf899fa75.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/81295a45-5fdf-4837-86ac-96caf899fa75.png)'
- en: where *k* is a positive constant that determines the rate of cooling. This differential
    equation can be solved *analytically* by first "separating the variables" and
    then integrating and rearranging. After performing this procedure, we obtain the
    general solution
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 常数*k*是一个确定冷却速率的正常数。这个微分方程可以通过首先“分离变量”，然后积分和重新排列来解析地解决。执行完这个过程后，我们得到了一般解
- en: '![](assets/ddae7c6c-e2c7-43aa-b764-484f7b27b095.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ddae7c6c-e2c7-43aa-b764-484f7b27b095.png)'
- en: where *T[0]* is the initial temperature.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*T[0]*是初始温度。
- en: In this recipe, we will solve a simple ordinary differential equation numerically
    using the `solve_ivp` routine from SciPy.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用SciPy的`solve_ivp`例程数值地解决一个简单的常微分方程。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will demonstrate the technique for solving a differential equation numerically
    in Python using the cooling equation described previously since we can compute
    the true solution in this case. We take the initial temperature to be *T[0]= 50*
    and *k = 0.2*. Let's also find the solution for *t* values between 0 and 5.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示在Python中使用先前描述的冷却方程数值地解决微分方程的技术，因为在这种情况下我们可以计算真实解。我们将初始温度取为*T[0]= 50*和*k
    = 0.2*。让我们也找出*t*值在0到5之间的解。
- en: A general (first order) differential equation has the form
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一般（一阶）微分方程的形式为
- en: '![](assets/4df58dda-2ef5-4b6e-a9c6-b14742a31fcb.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4df58dda-2ef5-4b6e-a9c6-b14742a31fcb.png)'
- en: where *f* is some function of *t* (the independent variable) and *y* (the dependent
    variable). In this formula, *T* is the dependent variable and *f(t, T) = -kt*.
    The routines for solving differential equations in the SciPy package require the
    function *f* and an initial value *y[0]*[and the range of *t* values where we
    need to compute the solution. To get started, we need to define our function *f*
    in Python and create the variables *y[0]*[and *t* range ready to be supplied to
    the SciPy routine:]]
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*f*是*t*（自变量）和*y*（因变量）的某个函数。在这个公式中，*T*是因变量，*f(t, T) = -kt*。SciPy包中用于解决微分方程的例程需要函数*f*和初始值*y[0]*[以及我们需要计算解的*t*值范围。要开始，我们需要在Python中定义我们的函数*f*并创建变量*y[0]*[和*t*范围，准备提供给SciPy例程：]]
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we need to define the initial condition from which the solution should
    be found. For technical reasons, the initial *y* values must be specified as a
    one-dimensional NumPy array:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义应从中找到解的初始条件。出于技术原因，初始*y*值必须指定为一维NumPy数组：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since, in this case, we already know the true solution, we can also define
    this in Python ready to compare to the numerical solution that we will compute:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在这种情况下，我们已经知道真实解，我们也可以在Python中定义这个解，以便与我们将计算的数值解进行比较：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Follow these steps to solve a differential equation numerically and plot the
    solution along with the error:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤数值求解微分方程并绘制解以及误差：
- en: 'We use the`solve_ivp` routine from the `integrate` module in SciPy to solve
    the differential equation numerically. We add a parameter for the maximum step
    size, with a value of `0.1`, so the solution is computed at a reasonable number
    of points:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用SciPy中的`integrate`模块中的`solve_ivp`例程来数值求解微分方程。我们添加了一个最大步长的参数，值为`0.1`，这样解就可以在合理数量的点上计算出来：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we extract the solution values from the `sol`object returned from the
    `solve_ivp`method:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从`solve_ivp`方法返回的`sol`对象中提取解的值：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we plot the solution on a set of axes as follows. Since we are also going
    to plot the approximation error on the same figure, we create two subplots using
    the `subplots` routine:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们按如下方式在一组坐标轴上绘制解。由于我们还将在同一图中绘制近似误差，我们使用`subplots`例程创建两个子图：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This plots the solution on a set of axes displayed in the left-hand side of
    *Figure 3.1*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这在*图3.1*的左侧显示了解决方案的图。
- en: 'To do this, we need to compute the true solution at the points that we obtained
    from the `solve_ivp` routine, and then calculate the absolute value of the difference
    between the true and approximated solutions:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，我们需要计算从`solve_ivp`例程中获得的点处的真实解，然后计算真实解和近似解之间的差的绝对值：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, on the right-hand side of *Figure 3.1*, we plot the error in the approximation
    with a logarithmic scale on the *y* axis. We can then plot this on the right-hand
    side with a logarithmic scale *y* axis using the `semilogy` plot command as we
    saw in [Chapter 2](0f1d7ff9-fbe0-4b22-bee0-a5139e8d363d.xhtml), *Mathematical
    Plotting with Matplotlib*:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在*图3.1*的右侧，我们使用*y*轴上的对数刻度绘制近似误差。然后，我们可以使用`semilogy`绘图命令在右侧使用对数刻度*y*轴，就像我们在[第2章](0f1d7ff9-fbe0-4b22-bee0-a5139e8d363d.xhtml)中看到的那样，*使用Matplotlib进行数学绘图*：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The left-hand plot in *Figure 3.1* shows decreasing temperature over time,
    while the right-hand plot shows that the error increases as we move away from
    the known value given by the initial condition:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.1*中的左侧图显示随时间降低的温度，而右侧图显示随着我们远离初始条件给出的已知值，误差增加：'
- en: '![](assets/4c0a6446-02e4-49ec-9940-00d778538fbe.png)Figure 3.1: Plot of the
    numerical solution to the cooling equation obtained using the solve_ivp routine
    with default settings'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/4c0a6446-02e4-49ec-9940-00d778538fbe.png)图3.1：使用默认设置使用solve_ivp例程获得冷却方程的数值解的绘图'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Most methods for solving differential equations are "time-stepping" methods.
    The pairs (*t[i], y[i]*) are generated by taking small *t* steps and approximating
    the value of the function *y.* This is perhaps best illustrated by Euler's method,
    which is the most basic time-stepping method. Fixing a small step size *h > 0*,
    we form the approximation at the *i*th step using the formula
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 解决微分方程的大多数方法都是“时间步进”方法。(*t[i], y[i]*)对是通过采取小的*t*步骤并逼近函数*y*的值来生成的。这可能最好地通过欧拉方法来说明，这是最基本的时间步进方法。固定一个小的步长*h
    > 0*，我们使用以下公式在第*i*步形成近似值
- en: '![](assets/62d74fc6-de22-40c3-a06b-eca3c00eaf85.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/62d74fc6-de22-40c3-a06b-eca3c00eaf85.png)'
- en: 'starting from the known initial value *y[0].* We can easily write a Python
    routine that performs Euler''s method as follows (there are, of course, many different
    ways to implement Euler''s method; this is a very simple example):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从已知的初始值*y[0]*开始。我们可以轻松地编写一个执行欧拉方法的Python例程如下（当然，实现欧拉方法有许多不同的方法；这是一个非常简单的例子）：
- en: 'First, we set up the method by creating lists that will store the *t* values
    and *y* values that we will return:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过创建将存储我们将返回的*t*值和*y*值的列表来设置方法：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Euler''s method continues until we hit the end of the *t* range. Here, we use
    a `while` loop to accomplish this. The body of the loop is very simple; we first
    increment a counter `i`, and then append the new *t* and *y* values to their respective
    lists:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 欧拉方法一直持续到我们达到*t*范围的末尾。在这里，我们使用`while`循环来实现这一点。循环的主体非常简单；我们首先递增计数器`i`，然后将新的*t*和*y*值附加到它们各自的列表中。
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The method used by the `solve_ivp` routine, by default, is the Runge-Kutta-Fehlberg
    method (RK45), which has the ability to adapt the step size to ensure that the
    error in the approximation stays within a given tolerance. This routine expects
    three positional arguments: the function *f,* the *t* range on which the solution
    should be found, and the initial *y* value (*T[0]*in our example). Optional arguments
    can be provided to change the solver, the number of points to compute, and several
    other settings.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`solve_ivp`例程默认使用龙格-库塔-费尔伯格（RK45）方法，该方法能够自适应步长，以确保近似误差保持在给定的容差范围内。这个例程期望提供三个位置参数：函数*f*，应找到解的*t*范围，以及初始*y*值（在我们的例子中为*T[0]*）。可以提供可选参数来更改求解器、要计算的点数以及其他几个设置。'
- en: The function passed to the `solve_ivp` routine must have two arguments as in
    the general differential equation described in *Getting ready* section. The function
    can have additional arguments, which can be provided using the `args` keyword
    for the `solve_ivp` routine, but these must be positioned after the two necessary
    arguments. Comparing the `euler` routine we defined earlier to the `solve_ivp`
    routine, both with a step size of 0.1, we find that the maximum true error between
    the `solve_ivp` solution is in the order of 10^(-6), whereas the `euler` solution
    only manages an error of 31\. The `euler` routine is working, but the step size
    is much too large to overcome the accumulating error.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`solve_ivp`例程的函数必须有两个参数，就像*准备就绪*部分中描述的一般微分方程一样。函数可以有额外的参数，可以使用`args`关键字为`solve_ivp`例程提供这些参数，但这些参数必须位于两个必要参数之后。将我们之前定义的`euler`例程与步长为0.1的`solve_ivp`例程进行比较，我们发现`solve_ivp`解的最大真实误差在10^(-6)数量级，而`euler`解只能达到31的误差。`euler`例程是有效的，但步长太大，无法克服累积误差。
- en: The `solve_ivp` routine returns a solution object that stores information about
    the solution that has been computed. Most important here are the `t` and `y` attributes,
    which contain the *t* values on which the solution *y* is computed and the solution
    *y* itself. We used these values to plot the solution we computed. The *y*values
    are stored in a NumPy array of shape `(n, N)`, where `n`is the number of components
    of the equation (here, 1), and `N`is the number of points computed. The *y*values
    held in `sol`are stored in a two-dimensional array, which in this case has 1 row
    and many columns. We use the slice `y[0, :]`to extract this first row as a one-dimensional
    array that can be used to plot the solution in *step 4*.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`solve_ivp`例程返回一个存储已计算解的信息的解对象。这里最重要的是`t`和`y`属性，它们包含计算解的*t*值和解*y*本身。我们使用这些值来绘制我们计算的解。*y*值存储在形状为`(n,
    N)`的NumPy数组中，其中`n`是方程的分量数（这里是1），`N`是计算的点数。`sol`中的*y*值存储在一个二维数组中，在这种情况下有1行和许多列。我们使用切片`y[0,
    :]`来提取这个第一行作为一维数组，可以用来在*步骤4*中绘制解。'
- en: We use a logarithmically scaled *y* axis to plot the error because what is interesting
    there is the order of magnitude. Plotting it on a non-scaled *y* axis would give
    a line that is very close to the *x* axis, which doesn't show the increase in
    the error as we move through the *t* values. The logarithmically scaled *y* axis
    shows this increase clearly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用对数缩放的*y*轴来绘制误差，因为有趣的是数量级。在非缩放的*y*轴上绘制它会得到一条非常靠近*x*轴的线，这不会显示出随着*t*值的变化误差的增加。对数缩放的*y*轴清楚地显示了这种增加。
- en: There's more...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `solve_ivp` routine is a convenient interface for a number of solvers for
    differential equations, the default being the Runge-Kutta-Fehlberg (RK45) method.
    The different solvers have different strengths, but the RK45 method is a good
    general-purpose solver.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`solve_ivp`例程是微分方程的多个求解器的便捷接口，默认为龙格-库塔-费尔伯格（RK45）方法。不同的求解器有不同的优势，但RK45方法是一个很好的通用求解器。'
- en: See also
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more detailed instructions on how to add subplots to a figure in Matplotlib,
    see the*Adding subplots* recipe from [Chapter 2](0f1d7ff9-fbe0-4b22-bee0-a5139e8d363d.xhtml),
    *Mathematical Plotting with Matplotlib*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何在Matplotlib中的图中添加子图的更详细说明，请参阅[第2章](0f1d7ff9-fbe0-4b22-bee0-a5139e8d363d.xhtml)中的*添加子图*示例，*使用Matplotlib进行数学绘图*。
- en: Solving systems of differential equations
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决微分方程系统
- en: Differential equations sometimes occur in systems consisting of two or more
    interlinked differential equations. A classical example is a simple model of the
    populations of competing species. This is a simple model of competing species
    labeled *P* (the prey)*and *W* (the predators) given by the following equations:*
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 微分方程有时出现在由两个或更多相互关联的微分方程组成的系统中。一个经典的例子是竞争物种的简单模型。这是一个由以下方程给出的竞争物种的简单模型，标记为*P*（猎物）和*W*（捕食者）：*
- en: '*![](assets/e6e64a45-d031-4ff3-9d17-bac1ea19c5ec.png)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](assets/e6e64a45-d031-4ff3-9d17-bac1ea19c5ec.png)'
- en: The first equation dictates the growth of the prey species *P*, which, without
    any predators, would be exponential growth. The second equation dictates the growth
    of the predator species *W*, which, without any prey, would be exponential decay.
    Of course, these two equations are *coupled*; each population change depends on
    both populations. The predators consume the prey at a rate proportional to the
    product of their two populations, and the predators grow at a rate proportional
    to the relative abundance of prey (again the product of the two populations).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方程规定了猎物物种*P*的增长，如果没有任何捕食者，它将是指数增长。第二个方程规定了捕食者物种*W*的增长，如果没有任何猎物，它将是指数衰减。当然，这两个方程是*耦合*的；每种群体的变化都取决于两种群体。捕食者以与两种群体的乘积成比例的速率消耗猎物，并且捕食者以与猎物相对丰富度成比例的速率增长（再次是两种群体的乘积）。
- en: In this recipe, we will will analyze a simple system of differential equations
    and use the SciPy `integrate` module to obtain approximate solutions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将分析一个简单的微分方程系统，并使用SciPy的`integrate`模块来获得近似解。
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The tools for solving a system of differential equations using Python are the
    same as those for solving a single equation. We again use the `solve_ivp` routine
    from the `integrate` module in SciPy. However, this will only give us a predicted
    evolution over time with given starting populations. For this reason, we will
    also employ some plotting tools from Matplotlib to better understand the evolution.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python解决常微分方程组的工具与解决单个方程的工具相同。我们再次使用SciPy中的`integrate`模块中的`solve_ivp`例程。然而，这只会给我们一个在给定起始种群下随时间预测的演变。因此，我们还将使用Matplotlib中的一些绘图工具来更好地理解这种演变。
- en: How to do it...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The following steps walk through how to analyze a simple system of differential
    equations:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤介绍了如何分析一个简单的常微分方程组：
- en: 'Our first task is to define a function that holds the system of equations.
    This function needs to take two arguments as for a single equation, except the
    dependent variable *y* (in the notation from the *Solving simple differential
    equations numerically* recipe) will now be an array with as many elements as there
    are equations. Here, there will be two elements. The function we need for the
    example system in this recipe is as follows:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一个任务是定义一个包含方程组的函数。这个函数需要接受两个参数，就像单个方程一样，除了依赖变量*y*（在*Solving simple differential
    equations numerically*配方中的符号）现在将是一个包含与方程数量相同的元素的数组。在这里，将有两个元素。在这个配方中，我们需要的函数如下：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we have defined the system in Python, we can use the `quiver` routine from
    Matplotlib to produce a plot that will describe how the populations will evolve—given
    by the equations—at numerous starting populations. We first set up a grid of points
    on which we will plot this evolution. It is a good idea to choose a relatively
    small number of points for the `quiver` routine, otherwise it becomes difficult
    to see details in the plot. For this example, we plot the population values between
    0 and 100:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经在Python中定义了系统，我们可以使用Matplotlib中的`quiver`例程来生成一个图表，描述种群将如何演变——由方程给出——在许多起始种群中。我们首先设置一个网格点，我们将在这些点上绘制这种演变。选择相对较少的点数作为`quiver`例程的一个好主意，否则在图表中很难看到细节。对于这个例子，我们绘制种群值在0到100之间：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we compute the values of the system at each of these pairs. Notice that
    neither equation in the system is time-dependent (they are autonomous); the time
    variable *t* is unimportant in the calculation. We supply the value `0` for the
    *t* argument:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们计算每对这些点的系统值。请注意，系统中的任何一个方程都不是时间相关的（它们是自治的）；时间变量*t*在计算中并不重要。我们为*t*参数提供值`0`：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The variables `dp` and `dw` now hold the "direction" in which the population
    of *P* and *W* will evolve, respectively, if we started at each point in our grid.
    We can plot these directions together using the `quiver` routine from `matplotlib.pyplot`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在变量`dp`和`dw`分别保存了种群*P*和*W*在我们的网格中每个点开始时将如何演变的“方向”。我们可以使用`matplotlib.pyplot`中的`quiver`例程一起绘制这些方向：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Plotting the result of these commands now gives us *Figure 3.2*, which gives
    a "global" picture of how solutions evolve:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在绘制这些命令的结果给出了*图3.2*，它给出了解决方案演变的“全局”图像：
- en: '![](assets/3e756b45-1557-4de1-99a4-980dfa5dbb69.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3e756b45-1557-4de1-99a4-980dfa5dbb69.png)'
- en: 'Figure 3.2: A quiver plot showing the population dynamics of two competing
    species modeled by a system of differential equations'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：显示由常微分方程组模拟的两个竞争物种的种群动态的quiver图
- en: To understand a solution more specifically, we need some initial conditions
    so we can use the `solve_ivp` routine described in the previous recipe.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更具体地理解解决方案，我们需要一些初始条件，这样我们就可以使用前面配方中描述的`solve_ivp`例程。
- en: 'Since we have two equations, our initial conditions will have two values. (Recall
    in the *Solving simple differential equations numerically* recipe, we saw that
    the initial condition provided to `solve_ivp` needs to be a NumPy array.) Let''s
    consider the the initial values *P(0) = 85* and *W(0) = 40*. We define these in
    a NumPy array, being careful to place them in the correct order:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们有两个方程，我们的初始条件将有两个值。（回想一下，在*Solving simple differential equations numerically*配方中，我们看到提供给`solve_ivp`的初始条件需要是一个NumPy数组。）让我们考虑初始值*P(0)
    = 85*和*W(0) = 40*。我们在一个NumPy数组中定义这些值，小心地按正确的顺序放置它们：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we can use `solve_ivp` from the `scipy.integrate` module. We need to provide
    the `max_step` keyword argument to make sure that we have enough points in the
    solution to give a smooth solution curve:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`scipy.integrate`模块中的`solve_ivp`。我们需要提供`max_step`关键字参数，以确保我们在解决方案中有足够的点来得到平滑的解曲线：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s plot this solution on our existing figure to show how this specific
    solution relates to the direction plot we have already produced. We also plot
    the initial condition at the same time:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在现有的图上绘制这个解，以展示这个特定解与我们已经生成的方向图之间的关系。我们同时也绘制初始条件：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The result of this is shown in *Figure 3.3*:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果显示在*图3.3*中：
- en: '![](assets/23767cc7-85e5-4168-93d3-7ab550febf33.png)Figure 3.3: Solution trajectory
    plotted over a quiver plot showing the general behavior'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/23767cc7-85e5-4168-93d3-7ab550febf33.png)图3.3：在显示一般行为的quiver图上绘制的解轨迹'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The method used for a system of ordinary differential equations is exactly the
    same as for a single ordinary differential equation. We start by writing the system
    of equations as a single vector differential equation,
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 用于一组常微分方程的方法与单个常微分方程完全相同。我们首先将方程组写成一个单一的向量微分方程，
- en: '![](assets/949a688b-96e9-4194-80e5-6c1537087601.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/949a688b-96e9-4194-80e5-6c1537087601.png)'
- en: that can then be solved using a time-stepping method as though **y** were a
    simple scalar value.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用时间步进方法来解决，就好像**y**是一个简单的标量值一样。
- en: The technique of plotting the directional arrows on a plane using the `quiver`
    routine is a quick and easy way of learning how a system might evolve from a given
    state. The derivative of a function represents the gradient of the curve (*x*,
    *u*(*x*)), and so a differential equation describes the gradient of the solution
    function at position *y* and time *t*. A system of equations describes the gradient
    of separate solution functions at a given position **y** and time *t.* Of course,
    the position is now a two-dimensional point, so when we plot the gradient at a
    point, we represent this as an arrow that starts at the point, in the direction
    of the gradient. The length of the arrow represents the size of the gradient;
    the longer the arrow, the "faster" the solution curve will move in that direction.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`quiver`例程在平面上绘制方向箭头的技术是学习系统如何从给定状态演变的一种快速简单的方法。函数的导数代表曲线的梯度（*x*，*u*（*x*）），因此微分方程描述了解决方案函数在位置*y*和时间*t*的梯度。一组方程描述了在给定位置**y**和时间*t*的单独解决方案函数的梯度。当然，位置现在是一个二维点，所以当我们在一个点上绘制梯度时，我们将其表示为从该点开始的箭头，指向梯度的方向。箭头的长度表示梯度的大小；箭头越长，解决方案曲线在该方向上移动得越“快”。
- en: 'When we plot the solution trajectory on top of this direction field, we can
    see that the curve (starting at the point) follows the direction indicated by
    the arrows. The behavior shown by the solution trajectory is a *limit cycle*,
    where the solution for each variable is periodic as the two species populations
    grow or decline. This description of the behavior is perhaps more clear if we
    plot each population against time, as seen in *Figure 3.4*. What is not immediately
    obvious from *Figure 3.3* is that the solution trajectory loops around several
    times, but this is clearly shown in *Figure 3.4*:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在这个方向场上绘制解的轨迹时，我们可以看到曲线（从该点开始）遵循箭头指示的方向。解的轨迹所显示的行为是一个*极限环*，其中每个变量的解都是周期性的，因为两种物种的人口增长或下降。如果我们将每个人口随时间的变化绘制成图，从*图3.4*中可以看出，这种行为描述可能更清晰。从*图3.3*中并不立即明显的是解的轨迹循环几次，但这在*图3.4*中清楚地显示出来：
- en: '![](assets/c2de769a-db1c-4ac4-b755-a8f69457b59d.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c2de769a-db1c-4ac4-b755-a8f69457b59d.png)'
- en: 'Figure 3.4: Plots of populations *P* and *W* against time. Both populations
    exhibit periodic behavior'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：人口*P*和*W*随时间的变化图。两种人口都表现出周期性行为。
- en: There's more...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The technique of analyzing a system of ordinary differential equations by plotting
    the variables against one another, starting at various initial conditions, is
    called *phase space (plane) analysis.* In this recipe, we used the `quiver` plotting
    routine to quickly generate an approximation of the phase plane for the system
    of differential equations. By analyzing the phase plane of a system of differential
    equations, we can identify different local and global characteristics of the solution,
    such as limit cycles.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在变量之间绘制相空间（平面）分析系统的普通微分方程组的技术称为*相空间（平面）分析*。在这个示例中，我们使用`quiver`绘图例程快速生成了微分方程系统的相平面的近似值。通过分析微分方程系统的相平面，我们可以识别解的不同局部和全局特征，如极限环。
- en: Solving partial differential equations numerically
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值求解偏微分方程
- en: Partial differential equations are differential equations that involve *partial
    derivatives* of functions in two or more variables, as opposed to *ordinary derivatives*
    in only a single variable. Partial differential equations is a vast topic, and
    could easily fill a series of books. A typical example of a partial differential
    equation is the (one-dimensional) *heat equation*
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 偏微分方程是涉及函数在两个或多个变量中的*偏导数*的微分方程，而不是仅涉及单个变量的*普通导数*。偏微分方程是一个广泛的主题，可以轻松填满一系列书籍。偏微分方程的典型例子是（一维）*热方程*。
- en: '![](assets/6184866a-5a48-48db-9c1f-a991e60c83b6.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6184866a-5a48-48db-9c1f-a991e60c83b6.png)'
- en: where α is a positive constant and *f*(*t*, *x*) is a function. The solution
    to this partial differential equation is a function *u*(*t*, *x*), which represents
    the temperature of a rod, occupying the *x* range 0 ≤ *x ≤* *L*, at a given time
    *t* > 0\. To keep things simple, we will take *f*(*t*, *x*) = 0, which amounts
    to saying that no heating/cooling is applied to the system, α = 1, and *L = 2*.
    In practice, we can rescale the problem to fix the constant α, so this is not
    a restrictive problem. In this example, we will use the boundary conditions
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 其中α是一个正常数，*f*（*t*，*x*）是一个函数。这个偏微分方程的解是一个函数*u*（*t*，*x*），它表示了在给定时间*t*>0时，占据*x*范围0≤*x*≤*L*的杆的温度。为了简单起见，我们将取*f*（*t*，*x*）=0，这相当于说系统没有加热/冷却，α=1，*L=2*。在实践中，我们可以重新调整问题来修复常数α，所以这不是一个限制性的问题。在这个例子中，我们将使用边界条件
- en: '![](assets/245337ee-7e9f-441a-8425-7bbebaec6f5d.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/245337ee-7e9f-441a-8425-7bbebaec6f5d.png)'
- en: which are equivalent to saying that the ends of the rod are held at the constant
    temperature 0\. We will also use the initial temperature profile
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于说杆的两端保持在恒定温度0。我们还将使用初始温度剖面
- en: '![](assets/9723b438-e560-4a28-a6de-ca9930ec343a.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9723b438-e560-4a28-a6de-ca9930ec343a.png)'
- en: This initial temperature profile describes a smooth curve between the values
    of 0 and 2, that peaks at a value of 3, which might be the result of heating the
    rod at the center to a temperature of 3.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始温度剖面描述了0和2之间的值之间的平滑曲线，峰值为3，这可能是将杆在中心加热到3度的结果。
- en: We're going to use a method called *finite differences*, where we divide the
    rod into a number of equal segments and the time range into a number of discrete
    steps. We then compute approximations for the solution at each of the segments
    and each time step.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一种称为*有限差分*的方法，将杆分成若干相等的段，并将时间范围分成若干离散步骤。然后我们计算每个段和每个时间步长的解的近似值。
- en: In this recipe, we will use finite differences to solve a simple partial differential
    equation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用有限差分来解一个简单的偏微分方程。
- en: Getting ready
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the NumPy package and Matplotlib package, imported
    as `np` and `plt` as usual. We also need to import the `mplot3d` module from `mpl_toolkits`
    since we will be producing a 3D plot:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将需要NumPy包和Matplotlib包，通常导入为`np`和`plt`。我们还需要从`mpl_toolkits`导入`mplot3d`模块，因为我们将生成一个3D图：
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We will also need some modules from the SciPy package.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些来自SciPy包的模块。
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the following steps, we work through solving the heat equation using finite
    differences:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将通过有限差分来解决热方程：
- en: 'Let''s first create variables that represent the physical constraints of the
    system: the extent of the bar and the value of α:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建代表系统物理约束的变量：杆的范围和α的值：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We first divide the *x*range into *N* equal*intervals—we take *N = 10*for this
    example—using *N+1*points. We can use the `linspace`routine from NumPy to generate
    these points. We also need the common length of each interval *h:**
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将*x*范围分成*N*个相等的*间隔—我们在这个例子中取*N = 10*—使用*N+1*个点。我们可以使用NumPy中的`linspace`例程生成这些点。我们还需要每个间隔的公共长度*h:**
- en: '*[PRE46]'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE46]'
- en: 'Next, we need to set up the steps in the time direction. We take a slightly
    different approach here; we set the time step size *k* and the number of steps
    (implicitly making the assumption that we start at time 0):'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置时间方向上的步长。我们在这里采取了稍微不同的方法；我们设置时间步长*k*和步数（隐含地假设我们从时间0开始）：
- en: '[PRE47]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In order for the method to behave properly, we must have
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使方法正常运行，我们必须满足：
- en: '![](assets/bda8c9e8-45ba-4021-99ba-9cfaa5b43f1a.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bda8c9e8-45ba-4021-99ba-9cfaa5b43f1a.png)'
- en: 'otherwise the system can become unstable. We store the left-hand side of this
    in a variable for use in *Step 4*, and use an assertion to check that this inequality
    holds:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 否则系统可能变得不稳定。我们将左侧存储在一个变量中，以便在*步骤4*中使用，并使用断言来检查这个不等式是否成立：
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we can construct a matrix that holds the coefficients from the finite difference
    scheme. To do this, we use the `diags`routine from the `scipy.sparse`module to
    create a sparse, tridiagonal matrix:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以构建一个矩阵，其中包含来自有限差分方案的系数。为此，我们使用`scipy.sparse`模块中的`diags`例程创建一个稀疏的三对角矩阵：
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we create a blank matrix that will hold the solution:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个空白矩阵来保存解决方案：
- en: '[PRE50]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We need to add the initial profile to the first row. The best way to do this
    is to create a function that holds the initial profile and store the result of
    evaluating this function on the `x` array in the matrix `u` that we just created:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将初始配置添加到第一行。这样做的最佳方法是创建一个保存初始配置的函数，并将在刚刚创建的矩阵`u`上的`x`数组上评估这个函数的结果：
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we can simply loop through each step, computing the next row of the matrix
    `u` by multiplying `A` and the previous row:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以简单地循环每一步，通过将`A`和前一行相乘来计算矩阵`u`的下一行：
- en: '[PRE52]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, to visualize the solution we have just computed, we can plot the solution
    as a surface using Matplotlib:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了可视化我们刚刚计算的解，我们可以使用Matplotlib将解作为曲面绘制出来：
- en: '[PRE53]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The result of this is the surface plot shown in *Figure 3.5*:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了*图3.5*中显示的曲面图：
- en: '![](assets/7aca3573-b5b9-40e9-a959-4908ff776868.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7aca3573-b5b9-40e9-a959-4908ff776868.png)'
- en: 'Figure 3.5: Surface plot of the solution of the heat equation over the range
    0 ≤ *x* ≤ 2 computed using the finite difference method with 10 mesh points'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：使用有限差分方法计算的热方程解在范围0 ≤ *x* ≤ 2上的曲面图，使用了10个网格点
- en: How it works...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The finite difference method works by replacing each of the derivatives with
    a simple fraction that involves only the value of the function, which we can estimate.
    To implement this method, we first break down the spatial range and time range
    into a number of discrete intervals, separated by mesh points. This process is
    called *discretization*. Then we use the differential equation and the initial
    conditions and boundary conditions to form successive approximations, in a manner
    very similar to the time-stepping methods used by the `solve_ivp` routine in the
    *Solving differential equations numerically* recipe.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 有限差分方法通过用仅涉及函数值的简单分数替换每个导数来工作，我们可以估计这些分数。要实现这种方法，我们首先将空间范围和时间范围分解为若干离散间隔，由网格点分隔。这个过程称为*离散化*。然后我们使用微分方程和初始条件以及边界条件来形成连续的近似，这与`solve_ivp`例程在*Solving
    differential equations numerically*示例中使用的时间步进方法非常相似。
- en: In order to solve a partial differential equation such as the heat equation,
    we need at least three pieces of information. Usually, for the heat equation,
    this will come in the form of*boundary conditions* for the spatial dimension,
    which tell us what the behavior is at either end of the rod, and *initial conditions*for
    the time dimension, which is the initial temperature profile over the rod.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决热方程这样的偏微分方程，我们至少需要三个信息。通常，对于热方程，这将以空间维度的*边界条件*的形式出现，告诉我们在杆的两端行为如何，以及时间维度的*初始条件*，即杆上的初始温度分布。
- en: The finite difference scheme described previously is usually referred to as
    the **forward time central spatial** (**FTCS**) scheme, since we use the *forward
    finite difference* to estimate the time derivative and the *central finite difference*
    to estimate the (second order) spatial derivative. The formulas for these finite
    differences are given by
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 前面描述的有限差分方案通常被称为**前向时间中心空间**（**FTCS**）方案，因为我们使用*前向有限差分*来估计时间导数，使用*中心有限差分*来估计（二阶）空间导数。这些有限差分的公式如下：
- en: '![](assets/1d60f63d-ee29-4640-ab39-515bf356bad2.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1d60f63d-ee29-4640-ab39-515bf356bad2.png)'
- en: and
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '![](assets/ea3d52cb-c07d-4a36-a313-713d29ff4f74.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ea3d52cb-c07d-4a36-a313-713d29ff4f74.png)'
- en: Substituting these approximations into the heat equation, and using the approximation
    *u*[*i*]^(*j*)for the value of *u*(*t[j]*, x[i]) after *j*time steps at the *i*spatial
    point, we get
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些近似代入热方程，并使用近似值*u*[*i*]^(*j*)来表示在*i*空间点上经过*j*时间步后*u*(*t[j]*, x[i])的值，我们得到
- en: '![](assets/c3c59b14-5e8f-4dcb-9122-65f09009fd65.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c3c59b14-5e8f-4dcb-9122-65f09009fd65.png)'
- en: which can be rearranged to obtain the formula
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 可以重新排列以获得公式
- en: '![](assets/58222441-072c-406c-a4c3-07fe3033a114.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/58222441-072c-406c-a4c3-07fe3033a114.png)'
- en: Roughly speaking, this equation says that the next temperature at a given point
    depends on the surrounding temperatures at the previous time. This also shows
    why the condition on the `r` value is necessary; if the condition does not hold,
    the middle term on the right-hand side will be negative.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地说，这个方程表示给定点的下一个温度取决于以前时间的周围温度。这也显示了为什么`r`值的条件是必要的；如果条件不成立，右侧的中间项将是负的。
- en: We can write this system of equations in matrix form,
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个方程组写成矩阵形式，
- en: '![](assets/37370a20-7786-4985-9625-53e11fbdbe08.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/37370a20-7786-4985-9625-53e11fbdbe08.png)'
- en: where **u***^j* is a vector containing the approximation *u[i]^j*and matrix
    *A*, which was defined in *step 4*. This matrix is tridiagonal, which means the
    non-zero entries appear on, or adjacent to, the leading diagonal. We use the `diag`
    routine from the SciPy `sparse` module, which is a utility for defining these
    kinds of matrices. This is very similar to the process described in the *Solving
    equations* recipe of this chapter. The first and last row of this matrix have
    zeros, except in the topleft and bottom right, respectively, that represent the
    (non-changing) boundary conditions. The other rows have coefficients that are
    given by the finite difference approximations for the derivatives on either side
    of differential equation. We first create the diagonal entries and the entries
    above and below the diagonal, and then we use the `diags` routine to create the
    sparse matrix. The matrix should have *N+1* rows and columns, to match the number
    of mesh points, and we set the data type as double-precision floats and CSR format.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 其中**u***^j*是包含近似*u[i]^j*和矩阵*A*的向量，矩阵*A*在*步骤4*中定义。这个矩阵是三对角的，这意味着非零条目出现在或邻近主对角线上。我们使用SciPy
    `sparse`模块中的`diag`例程，这是一种定义这种矩阵的实用程序。这与本章中*解方程*配方中描述的过程非常相似。这个矩阵的第一行和最后一行都是零，除了在左上角和右下角，分别代表（不变的）边界条件。其他行的系数由微分方程两侧的有限差分近似给出。我们首先创建对角线条目和对角线上下方的条目，然后我们使用`diags`例程创建稀疏矩阵。矩阵应该有*N+1*行和列，以匹配网格点的数量，并且我们将数据类型设置为双精度浮点数和CSR格式。
- en: The initial profile gives us the vector **u**⁰, and from this first point, we
    can compute each subsequent time step by simply performing a matrix multiplication,
    as we saw in *step 7*.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 初始配置给我们向量**u**⁰，从这一点开始，我们可以通过简单地执行矩阵乘法来计算每个后续时间步骤，就像我们在*步骤7*中看到的那样。
- en: There's more...
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The method we describe here is rather crude since the approximation can become
    unstable, as we mentioned, if the relative sizes of time steps and spatial steps
    are not carefully controlled. This method is *explicit* since each time step is
    computed explicitly using only information from the previous time step. There
    are also *implicit* methods, which give a system of equations that can be solved
    to obtain the next time step. Different schemes have different characteristics
    in terms of the stability of the solution.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里描述的方法相当粗糙，因为近似可能变得不稳定，正如我们提到的，如果时间步长和空间步长的相对大小没有得到仔细控制。这种方法是*显式*的，因为每个时间步骤都是显式地使用来自上一个时间步骤的信息来计算的。还有*隐式*方法，它给出了一个可以求解以获得下一个时间步骤的方程组。不同的方案在解的稳定性方面具有不同的特性。
- en: When the function *f*(*t*, *x*) is not 0, we can easily accommodate this change
    by instead using the assignment
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数*f*(*t*, *x*)不为0时，我们可以通过使用赋值来轻松适应这种变化
- en: '![](assets/34ccf6b9-a549-469c-a194-2d67678204d2.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/34ccf6b9-a549-469c-a194-2d67678204d2.png)'
- en: 'where the function is suitably vectorized to make this formula valid. In terms
    of the code used to solve the problem, we need only include the definition of
    the function and then change the loop of the solution as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 其中函数被适当地向量化以使这个公式有效。在解决问题的代码方面，我们只需要包括函数的定义，然后将解决方案的循环更改如下：
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Physically, this function represents an external heat source (or sink) at each
    point along the rod. This may change over time, which is why, in general, the
    function should have both *t* and *x* as arguments (though they need not both
    be used).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 从物理上讲，这个函数代表了杆上每个点的外部热源（或者热池）。这可能随时间变化，这就是为什么一般来说，这个函数应该有*t*和*x*作为参数（尽管它们不一定都被使用）。
- en: The boundary conditions we gave in this example represent the ends of the rod
    being kept at a constant temperature of 0\. These kinds of boundary conditions
    are sometimes called *Dirichlet* boundary conditions. There are also *Neumann*
    boundary conditions, where the derivative of the function *u* is given at the
    boundary. For example, we might have been given the boundary conditions
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个例子中给出的边界条件代表了杆的两端保持在恒定温度为0。这种边界条件有时被称为*Dirichlet*边界条件。还有*Neumann*边界条件，其中函数*u*的导数在边界处给定。例如，我们可能已经给出了边界条件
- en: '![](assets/20efdf73-2579-492b-ad91-657fd131d376.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/20efdf73-2579-492b-ad91-657fd131d376.png)'
- en: which could be interpreted physically as the ends of the rod being insulated
    so that heat cannot escape through the end points. For such boundary conditions
    we need to modify the matrix *A* slightly, but otherwise the method remains the
    same. Indeed, inserting an imaginary *x* value to the left of the boundary and
    using the backward finite difference at the left-hand boundary (*x = 0*), we obtain
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这在物理上可以被解释为杆的两端被绝缘，因此热量不能通过端点逃逸。对于这种边界条件，我们需要稍微修改矩阵*A*，但方法本质上保持不变。实际上，在边界的左侧插入一个虚拟的*x*值，并在左边界（*x
    = 0*）使用向后有限差分，我们得到
- en: '![](assets/3df7eb78-60b0-45a4-8ac8-a3d354f85c02.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3df7eb78-60b0-45a4-8ac8-a3d354f85c02.png)'
- en: Using this in the second order finite difference approximation, we get
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个二阶有限差分近似，我们得到
- en: '![](assets/a8b3a28a-812c-4e04-bfc3-e40be3cb4481.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a8b3a28a-812c-4e04-bfc3-e40be3cb4481.png)'
- en: which means that the first row of our matrix should contain *1-r*,*then *r*,
    followed by 0\. Using a similar computation for the right-hand limit gives a similar
    final row of the matrix:*
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们矩阵的第一行应包含*1-r*，然后是*r*，然后是0。对右手极限进行类似的计算得到矩阵的最后一行。
- en: '*[PRE55]'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE55]'
- en: For more complex problems involving partial differential equations, it is probably
    more appropriate to use a *finite elements* solver. Finite element methods use
    a more sophisticated approach for computing solutions than partial differential
    equations, which are generally more flexible than the finite difference method
    we saw in this recipe. However, this comes at the cost of requiring more setup
    that relies on more advanced mathematical theory. On the other hand, there is
    a Python package for solving partial differential equations using finite element
    methods such as FEniCS ([fenicsproject.org](https://fenicsproject.org)). The advantage
    of using a package such as FEniCS is that they are usually tuned for performance,
    which is important when solving with complex problems to high accuracy.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及偏微分方程的更复杂问题，可能更适合使用*有限元*求解器。有限元方法使用比我们在本篇中看到的有限差分方法更复杂的方法来计算解决方案，通常比偏微分方程更灵活。然而，这需要更多依赖更高级数学理论的设置。另一方面，有一个用于使用有限元方法解决偏微分方程的Python包，如FEniCS
    ([fenicsproject.org](https://fenicsproject.org))。使用FEniCS等包的优势在于它们通常针对性能进行了调整，这在解决复杂问题时对高精度至关重要。
- en: See also
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The FEniCS documentation gives a good introduction to the finite element method
    and a number of examples of using the package to solve various classic partial
    differential equations. A more comprehensive introduction to the method and the
    theory is given in the following book:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: FEniCS文档介绍了有限元方法以及使用该包解决各种经典偏微分方程的示例。有关该方法和理论的更全面介绍可在以下书籍中找到：
- en: '*Johnson, C. (2009).Numerical solution of partial differential equations by
    the finite element method. Mineola, N.Y.: Dover Publications.*'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Johnson, C. (2009).Numerical solution of partial differential equations by
    the finite element method. Mineola, N.Y.: Dover Publications.*'
- en: For more details on how to produce three-dimensional surface plots using Matplotlib,
    see the *Surface and contour plots* recipe from [Chapter 2](0f1d7ff9-fbe0-4b22-bee0-a5139e8d363d.xhtml),
    *Mathematical Plotting with Matplotlib*.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何使用Matplotlib生成三维曲面图的更多详细信息，请参阅[第2章](0f1d7ff9-fbe0-4b22-bee0-a5139e8d363d.xhtml)中的*曲面和等高线图*食谱。
- en: Using discrete Fourier transforms for signal processing
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用离散傅立叶变换进行信号处理
- en: One of the most useful tools coming from calculus is the *Fourier transfor**m*.
    Roughly speaking, the Fourier transform changes the representation, in a reversible
    way, of certain functions. This change of representation is particularly useful
    in dealing with signals represented as a function of time. In this instance, the
    Fourier transform takes the signal and represents it as a function of frequency;
    we might describe this as transforming from signal space to frequency space. This
    can be used to identify the frequencies present in a signal for identification
    and other processing. In practice, we will usually have a discrete sample of a
    signal, so we have to use the *discrete Fourier transform* to perform this kind
    of analysis. Fortunately, there is a computationally efficient algorithm, called
    the **fast Fourier transform***(**FFT**), for applying the discrete Fourier transform
    to a sample.*
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 来自微积分中最有用的工具之一是*傅立叶变换*。粗略地说，傅立叶变换以可逆的方式改变了某些函数的表示。这种表示的改变在处理作为时间函数的信号时特别有用。在这种情况下，傅立叶变换将信号表示为频率函数；我们可以将其描述为从信号空间到频率空间的转换。这可以用于识别信号中存在的频率以进行识别和其他处理。在实践中，我们通常会有信号的离散样本，因此我们必须使用*离散傅立叶变换*来执行这种分析。幸运的是，有一种计算效率高的算法，称为**快速傅立叶变换**（**FFT**），用于对样本应用离散傅立叶变换。
- en: '*We will follow a common process for filtering a noisy signal using FFT. The
    first step is to apply the FFT and use the data to compute the power spectral
    density of the signal. Then we identify the peaks and filter out the frequencies
    that do no contribute a sufficiently large amount to the signal. Then we apply
    the inverse FFT to obtain the filtered signal.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将遵循使用FFT处理嘈杂信号的常见过程。第一步是应用FFT并使用数据计算信号的功率谱密度。然后我们识别峰值并滤除对信号贡献不足够大的频率。然后我们应用逆FFT来获得滤波后的信号。'
- en: In this recipe, we use the FFT to analyze a sample of a signal and identify
    the frequencies present and clean the noise from the signal.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本篇中，我们使用FFT来分析信号的样本，并识别存在的频率并清除信号中的噪音。
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will only need the NumPy and Matplotlib packages imported
    as `np` and `plt`, as usual.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本篇，我们只需要导入NumPy和Matplotlib包，如往常一样命名为`np`和`plt`。
- en: How to do it...
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these instructions to use the FFT to process a noisy signal:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明使用FFT处理嘈杂信号：
- en: 'We define a function that will generate our underlying signal:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个函数来生成我们的基础信号：
- en: '[PRE56]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we create our sample signal by adding some Gaussian noise to the underlying
    signal. We also create an array that holds the true signal at the sample *t* values
    for convenience later:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过向基础信号添加一些高斯噪声来创建我们的样本信号。我们还创建一个数组，以便在以后方便时保存样本*t*值处的真实信号：
- en: '[PRE57]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We use the `fft`module from NumPy to compute discrete Fourier transforms. We
    import this from NumPy before we start our analysis:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用NumPy的`fft`模块来计算离散傅立叶变换。在开始分析之前，我们从NumPy中导入这个模块：
- en: '[PRE58]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To see what the noisy signal looks like, we can plot the sample signal points
    with the true signal superimposed:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看嘈杂信号的样子，我们可以绘制样本信号点并叠加真实信号：
- en: '[PRE59]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The plot created here is shown in *Figure 3.6*. As we can see, the noisy signal
    does not bear much resemblance to the true signal (shown with the dashed line):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 此处创建的图表显示在*图3.6*中。正如我们所看到的，嘈杂信号与真实信号几乎没有相似之处（用虚线表示）：
- en: '![](assets/d0bf476c-f0fd-4b59-b167-0db423f6cc22.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d0bf476c-f0fd-4b59-b167-0db423f6cc22.png)'
- en: 'Figure 3.6: Noisy signal sample with true signal superimposed'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：带真实信号的噪声信号样本
- en: 'Now, we will use the discrete Fourier transform to extract the frequencies
    that are present in the sample signal. The `fft` routine in the `fft` module performs
    the FFT (discrete Fourier transform):'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用离散傅立叶变换来提取样本信号中存在的频率。`fft`模块中的`fft`例程执行FFT（离散傅立叶变换）：
- en: '[PRE60]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `fft` module provides a routine for constructing the appropriate frequency
    values called `fftfreq`. For convenience, we also generate an array containing
    the integers at which the positive frequencies occur:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fft`模块提供了一个用于构建适当频率值的例程，称为`fftfreq`。为了方便起见，我们还生成一个包含正频率出现的整数的数组：'
- en: '[PRE61]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, compute the **power spectral density** (**PSD**) of the signal as follows:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，计算信号的**功率谱密度**（**PSD**）如下：
- en: '[PRE62]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, we can plot the PSD of the signal for the positive frequencies and use
    this plot to identify the frequencies:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以绘制信号的正频率的PSD，并使用这个图来识别频率：
- en: '[PRE63]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The result can be seen in *Figure 3.7*. We can see in this diagram that there
    are spikes at roughly 4 and 7, which are the frequencies of the signal that we
    defined earlier:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以在*图3.7*中看到。我们可以在这个图表中看到大约在4和7左右有尖峰，这些是我们之前定义的信号的频率：
- en: '![](assets/dbf2eebf-e200-4bc8-8319-4a6d67561fc7.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dbf2eebf-e200-4bc8-8319-4a6d67561fc7.png)'
- en: 'Figure 3.7: Power spectral density of a signal generated using the FFT'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：使用FFT生成的信号的功率谱密度
- en: 'We can identify these two frequencies to try and reconstruct the true signal
    from the noisy sample. All of the minor peaks that appear are not larger than
    10,000, so we can use this as a cut-off value for the filter. Let''s now extract
    from the list of all positive frequency indices the (hopefully 2) indices that
    correspond to the peaks above 10,000 in the PSD:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以识别这两个频率，尝试从噪声样本中重建真实信号。所有出现的次要峰值都不大于10,000，所以我们可以将其作为滤波器的截止值。现在，我们从所有正频率索引的列表中提取（希望是2个）对应于PSD中大于10,000的峰值的索引：
- en: '[PRE64]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we create a new, clean spectrum that contains only the frequencies that
    we have extracted from the noisy signal. We do this by creating an array that
    contains only 0, and then copying the value of `spectrum` from those indices that
    correspond to the filtered frequencies and the negatives thereof:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的干净频谱，其中只包含我们从噪声信号中提取的频率。我们通过创建一个只包含0的数组，然后将`spectrum`的值从对应于滤波频率及其负值的索引复制过来来实现这一点：
- en: '[PRE65]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, we use the inverse FFT (using the `ifft` routine) to transform this clean
    spectrum back to the time domain of the original sample. We take the real part
    using the `real` routine from NumPy to eliminate the erroneous imaginary parts:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用逆FFT（使用`ifft`例程）将这个干净的频谱转换回原始样本的时间域。我们使用NumPy的`real`例程取实部以消除错误的虚部：
- en: '[PRE66]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, we plot this filtered signal over the true signal and compare the
    results:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们绘制这个滤波信号和真实信号进行比较：
- en: '[PRE67]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The result of *step 12* is shown in *Figure 3.8*. We can see that the filtered
    signal closely matches the true signal, except for some small discrepancies:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤12*的结果显示在*图3.8*中。我们可以看到，滤波信号与真实信号非常接近，除了一些小的差异：'
- en: '![](assets/c00691ae-14b1-4470-bda0-b8b048536c69.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c00691ae-14b1-4470-bda0-b8b048536c69.png)'
- en: 'Figure 3.8: Plot comparing the filtered signal generated using FFTs and filtering
    to the true signal'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：比较使用FFT和滤波生成的滤波信号与真实信号的图
- en: How it works...
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The *Fourier transform* of a function *f*(*t*) is given by the integral
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 函数*f*(*t*)的*傅立叶变换*由积分给出
- en: '![](assets/4eb1fffb-6aa9-4f17-875a-51c90d9c3040.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4eb1fffb-6aa9-4f17-875a-51c90d9c3040.png)'
- en: and the discrete Fourier transform is given by
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 离散傅立叶变换如下：
- en: '![](assets/87485bb8-515f-4654-9621-e8930510e1c5.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/87485bb8-515f-4654-9621-e8930510e1c5.png)'
- en: Here, the *f[k]*values are the sample values as complex numbers. The discrete
    Fourier transform can be computed using the preceding formula, but in practice
    this is not efficient. Computing using this formula is *O*(*N*²). The FFT algorithm
    improves the complexity to *O*(*N* log *N*), which is significantly better. The
    book *Numerical Recipes* (full bibliographic details given in the *Further reading*
    section) gives a very good description of the FFT algorithm and the discrete Fourier
    transform.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*f[k]*值是复数形式的样本值。可以使用前面的公式计算离散傅立叶变换，但实际上这并不高效。使用这个公式计算的复杂度是*O*(*N*²)。FFT算法将复杂度提高到*O*(*N*
    log *N*)，这显然更好。书籍*Numerical Recipes*（在*进一步阅读*部分给出完整的参考文献细节）对FFT算法和离散傅立叶变换有很好的描述。
- en: We will apply the discrete Fourier transform to a sample generated from a known
    signal (with known frequency modes) so we can see the connection between the results
    we obtain and the original signal. To keep this signal simple, we created a signal
    that has only two frequency components with values 4 and 7\. From this signal,
    we generated the sample that we analyzed. Because of the way the FFT works, it
    is best if the sample has a size that is a power of 2; if this isn't the case,
    we can pad the sample with zero elements to make this the case. We add some Gaussian
    noise to the sample signal, which takes the form of a normally distributed random
    number.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对从已知信号（具有已知频率模式）生成的样本应用离散傅立叶变换，以便我们可以看到我们获得的结果与原始信号之间的联系。为了保持这个信号简单，我们创建了一个只有两个频率分量（值为4和7）的信号。从这个信号，我们生成了我们分析的样本。由于FFT的工作方式，最好是样本的大小是2的幂；如果不是这种情况，我们可以用零元素填充样本使其成为这种情况。我们向样本信号添加了一些高斯噪声，这是一个正态分布的随机数。
- en: The array returned by the `fft` routine contains *N+1*elements, where *N*is
    the sample size. The element that index 0 corresponds to is the 0 frequency, or
    DC shift. The next *N/2* elements are the values corresponding to the positive
    frequencies, and the final *N/2*elements are the values corresponding to the negative
    frequencies. The actual values of the frequencies are determined by the number
    of sampled points *N*and the sample spacing, which, in this example, is stored
    in `sample_d`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`fft`例程返回的数组包含*N+1*个元素，其中*N*是样本大小。索引为0的元素对应于0频率，或者直流偏移。接下来的*N/2*个元素是对应于正频率的值，最后的*N/2*个元素是对应于负频率的值。频率的实际值由采样点数*N*和采样间距确定，在这个例子中，采样间距存储在`sample_d`中。'
- en: The power spectral density at the frequency *ω* is given by the formula
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 频率*ω*处的功率谱密度由以下公式给出
- en: '![](assets/6c55d8f3-b759-4931-a310-85478b2e65c6.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6c55d8f3-b759-4931-a310-85478b2e65c6.png)'
- en: where *H*(*ω*) represents the Fourier transformof the signal at frequency *ω*.
    The power spectral density measures the contribution of each frequency to the
    overall signal, which is why we see peaks at approximately 4 and 7\. Since Python
    indexing allows us to use negative indices for elements starting from the end
    of the sequence, we can use the positive index array to get both the positive
    and negative frequency elements from `spectrum`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*H*(*ω*)代表信号在频率*ω*处的傅里叶变换。功率谱密度测量了每个频率对整体信号的贡献，这就是为什么我们在大约4和7处看到峰值。由于Python索引允许我们对从序列末尾开始的元素使用负索引，我们可以使用正索引数组从`spectrum`中获取正频率和负频率元素。
- en: In *step 9,* we extracted the indices of the two frequencies that peak above
    10,000 on the plot. The frequencies that correspond to these indices are 3.984375
    and 6.97265625, which are not exactly equal to 4 and 7, but are very close. The
    reason for this discrepancy is the fact that we have sampled a continuous signal
    using a finite number of points. (Using more points will, of course, yield better
    approximations.)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤9*中，我们提取了在图表上峰值超过10,000的两个频率的索引。对应于这些索引的频率分别是3.984375和6.97265625，它们并不完全等于4和7，但非常接近。这种差异的原因是我们使用有限数量的点对连续信号进行了采样。（使用更多点当然会得到更好的近似。）
- en: In *step 11*, we took the real part of the data returned from the inverse FFT.
    This is because, technically speaking, the FFT works with complex data. Since
    our data contained only real data, we expect that this new signal should also
    contain only real data. However, there will be some small errors made, meaning
    that the results are not totally real. We can remedy this by taking the real part
    of the inverse FFT. This is appropriate because we can see that the imaginary
    parts are very small.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤11*中，我们提取了从逆FFT返回的数据的实部。这是因为从技术上讲，FFT处理复杂数据。由于我们的数据只包含实数据，我们期望这个新信号也只包含实数据。然而，会有一些小错误产生，这意味着结果并非完全是实数。我们可以通过取逆FFT的实部来纠正这一点。这是合适的，因为我们可以看到虚部非常小。
- en: We can see in *Figure 3.8* that the filtered signal very closely matches the
    true signal, but not exactly. This is because, as mentioned previously, we are
    approximating a continuous signal with a relatively small sample.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图3.8*中看到，滤波信号非常接近真实信号，但并非完全相同。这是因为，如前所述，我们正在用相对较小的样本来逼近连续信号。
- en: There's more...
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Signal processing in a production setting would probably make use of a specialized
    package, such as the `signal` module from `scipy`, or some lower-level code or
    hardware to perform filtering or cleaning of a signal. This recipe should be taken
    as more of a demonstration of the use of FFT as a tool for working with data sampled
    from some kind of underlying periodic structure (the signal). FFTs are useful
    for solving partial differential equations, such as the heat equation seen in
    the *Solving partial differential equations numerically* recipe.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中的信号处理可能会使用专门的软件包，比如`scipy`中的`signal`模块，或者一些更低级的代码或硬件来执行信号的滤波或清理。这个示例更多地应该被看作是FFT作为处理从某种基础周期结构（信号）采样的数据的工具的演示。FFT对于解决偏微分方程非常有用，比如在*数值解偏微分方程*食谱中看到的热方程。
- en: See also
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: More information about random numbers and the normal distribution (Gaussian)
    can be found in [Chapter 4](5da67d86-40e0-4cc5-9dd1-26b6d52369af.xhtml), *Working
    with Randomness and Probability*.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 有关随机数和正态分布（高斯）的更多信息可以在[第4章](5da67d86-40e0-4cc5-9dd1-26b6d52369af.xhtml)中找到，*处理随机性和概率*。
- en: Further reading
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Calculus is a very important part of every undergraduate mathematics course.
    There are a number of excellent textbooks on calculus, including the classic textbook
    by Spivak and the more comprehensive course by Adams and Essex:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分是每门本科数学课程中非常重要的一部分。有许多关于微积分的优秀教科书，包括Spivak的经典教科书和Adams和Essex的更全面的课程：
- en: '*Spivak, M. (2006). Calculus. 3rd ed. Cambridge: Cambridge University Press*'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spivak, M. (2006). Calculus. 3rd ed. Cambridge: Cambridge University Press*'
- en: '*Adams, R. and Essex, C. (2018). Calculus: A Complete Course. 9th ed. Don Mills,
    Ont: Pearson.Guassian*'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Adams, R. and Essex, C. (2018). Calculus: A Complete Course. 9th ed. Don Mills,
    Ont: Pearson.Guassian*'
- en: 'A good source for numerical differentiation and integration is the classic
    *Numerical Recipes* book, which gives a comprehensive description of how to solve
    many computational problems in C++, including a summary of the theory:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数值微分和积分的良好来源是经典的*数值方法*书，其中详细描述了如何在C++中解决许多计算问题的理论概述：
- en: '*Press, W., Teukolsky, S., Vetterling, W. and Flannery, B. (2007). Numerical
    recipes:* *The Art of Scientific Computing. 3rd ed. Cambridge: Cambridge University
    Press*****'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Press, W., Teukolsky, S., Vetterling, W. and Flannery, B. (2007). Numerical
    recipes:* *The Art of Scientific Computing. 3rd ed. Cambridge: Cambridge University
    Press*****'
