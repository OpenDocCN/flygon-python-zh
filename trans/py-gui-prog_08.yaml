- en: Improving the Look with Styles and Themes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用样式和主题改进外观
- en: While programs can be perfectly functional with plain text in shades of black,
    white, and gray, the subtle use of colors, fonts, and images can enhance the visual
    appeal and usability of even the most utilitarian applications. Your data entry
    application is no exception. Your boss and your users have brought several issues
    to your attention, which seem to require the use of Tkinter's styling capabilities.
    Your boss has informed you that corporate HQ requires all in-house software to
    prominently display the company logo, while the data entry staff have mentioned
    a variety of issues with the readability and overall look of the application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然程序可以完全使用黑色、白色和灰色的纯文本进行功能性操作，但是对颜色、字体和图像的微妙使用可以增强视觉吸引力和可用性，即使是最实用的应用程序也是如此。您的数据输入应用程序也不例外。您的老板和用户已经向您提出了几个问题，似乎需要使用Tkinter的样式功能。您的老板已经告诉您，总部要求所有内部软件突出显示公司标志，而数据输入人员已经提到了应用程序的可读性和整体外观的各种问题。
- en: 'In this chapter, we''re going to learn about some features of Tkinter that
    will help us to solve these issues:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习一些Tkinter的功能，这些功能将帮助我们解决这些问题：
- en: We'll learn how to add images to our Tkinter GUI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将学习如何向我们的Tkinter GUI添加图像
- en: We'll learn how to adjust the fonts and colors in our Tkinter widgets, both
    directly and with tags
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将学习如何调整Tkinter小部件的字体和颜色，直接和使用标签
- en: We'll learn how to adjust the look of Ttk widgets using styles and themes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将学习如何使用样式和主题调整Ttk小部件的外观
- en: Working with images in Tkinter
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Tkinter中使用图像
- en: The first requirement we're going to handle is adding the company logo. As a
    result of corporate policy, your application is supposed to have the company logo
    embedded in it, and you've been asked to make your application comply if possible.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理的第一个要求是添加公司标志。由于公司政策的结果，您的应用程序应该嵌入公司标志，并且如果可能的话，您已被要求使您的应用程序符合要求。
- en: To add this image to our application, you'll need to learn about Tkinter's `PhotoImage`
    class.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此图像添加到我们的应用程序中，您需要了解Tkinter的`PhotoImage`类。
- en: Tkinter PhotoImage
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter PhotoImage
- en: Several Tkinter widgets, including `Label` and `Button`, can take an `image`
    argument, which allows them to display an image. We can't simply put a path to
    an image file in those cases; instead, we have to create a `PhotoImage` object.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 包括`Label`和`Button`在内的几个Tkinter小部件可以接受`image`参数，从而允许它们显示图像。在这些情况下，我们不能简单地将图像文件的路径放入其中；相反，我们必须创建一个`PhotoImage`对象。
- en: 'Making a `PhotoImage` object is fairly simple:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`PhotoImage`对象相当简单：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`PhotoImage` is typically called with the keyword argument `file`, which is
    pointed to a file path. Alternatively, you can use the `data` argument to point
    to a `bytes` object containing image data.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用关键字参数`file`调用`PhotoImage`，该参数指向文件路径。或者，您可以使用`data`参数指向包含图像数据的`bytes`对象。
- en: 'A `PhotoImage` can be used wherever an `image` argument is accepted, such as
    a `Label`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`PhotoImage`可以在接受`image`参数的任何地方使用，例如`Label`：'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It's critical to note that your application must retain a reference to the `PhotoImage`
    object that will stay in scope for as long as the image is shown; otherwise, the
    image will not appear.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意的是，您的应用程序必须保留对`PhotoImage`对象的引用，该引用将在图像显示期间保持在范围内；否则，图像将不会显示。
- en: 'Consider the following example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you run this example, you'll notice that no image gets displayed. That's
    because the `smile` variable is destroyed as soon as `__init__()` exits; with
    no reference to the `PhotoImage` object, the image vanishes, even though we've
    packed it into the layout. To fix this, you would need to store the `image` object
    in an instance variable such as `self.smile`, which will continue to exist after
    the method returns.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此示例，您会注意到没有显示任何图像。这是因为`smile`变量在`__init__()`退出时立即被销毁；由于没有对`PhotoImage`对象的引用，图像消失了，即使我们已经将其打包到布局中。要解决此问题，您需要将`image`对象存储在实例变量中，例如`self.smile`，这样在方法返回后它将继续存在。
- en: Image support in Tkinter is limited to GIF, PGM, PPM, and (as of version 8.6)
    PNG files. To use other file formats, such as JPEG or BMP, you'll need to use
    an image manipulation library such as Pillow to convert them into a format that
    Tkinter understands.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter中的图像支持仅限于GIF、PGM、PPM和（从版本8.6开始）PNG文件。要使用其他文件格式，如JPEG或BMP，您需要使用图像处理库（如Pillow）将它们转换为Tkinter可以理解的格式。
- en: At the time of writing, Python 3 for macOS ships with Tkinter 8.5\. To use PNG
    on macOS, you'll need to upgrade to Tkinter 8.6 or later, or use Pillow. Please
    see [https://www.python.org/download/mac/tcltk/](https://www.python.org/download/mac/tcltk/)
    for more information about Tcl/Tk and macOS. Pillow is not in the Python standard
    library. To install it, follow the instructions at [http://python-pillow.org](http://python-pillow.org).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，macOS的Python 3附带Tkinter 8.5。要在macOS上使用PNG，您需要升级到Tkinter 8.6或更高版本，或者使用Pillow。有关Tcl/Tk和macOS的更多信息，请参见[https://www.python.org/download/mac/tcltk/](https://www.python.org/download/mac/tcltk/)。Pillow不在Python标准库中。要安装它，请按照[http://python-pillow.org](http://python-pillow.org)上的说明操作。
- en: Adding the company logo
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加公司标志
- en: With our knowledge of `PhotoImage`, adding the company logo to our program should
    be simple; however, we have to solve the problem of how to determine the image
    file's path. The path can be either absolute or relative to the working directory,
    but we don't know what those will be on another system. Fortunately, there's a
    way to figure it out.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借我们对`PhotoImage`的了解，将公司标志添加到我们的程序应该很简单；但是，我们必须解决如何确定图像文件的路径的问题。路径可以是绝对路径，也可以是相对于工作目录的路径，但我们不知道另一个系统上的路径是什么。幸运的是，有一种方法可以找出来。
- en: Under the `abq_data_entry` directory, create a new directory called `images`,
    and within it place an appropriately-sized PNG file that we can use in our application
    (the image has an 8x5 aspect ratio, so in this case, we're using `32x20`). To
    get an absolute path to the image, we're going to rely on a built-in variable
    in Python called `__file__`. In any Python script, the `__file__` variable will
    contain the absolute path to the current script file, which we can use to locate
    our image files.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在`abq_data_entry`目录下，创建一个名为`images`的新目录，在其中放置一个适当大小的PNG文件，我们可以在我们的应用程序中使用（图像具有8x5的宽高比，所以在这种情况下，我们使用`32x20`）。要获取图像的绝对路径，我们将依赖Python中一个名为`__file__`的内置变量。在任何Python脚本中，`__file__`变量将包含当前脚本文件的绝对路径，我们可以使用它来定位我们的图像文件。
- en: 'For example, from our `application.py` file, we could find our image using
    this code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从我们的`application.py`文件中，我们可以使用这段代码找到我们的图像：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we first find the directory that contains the `application.py`
    file by calling `path.dirname(__file__)`. This gives us an absolute path to `abq_data_entry`,
    from which we know the relative path to the image. We can join these two paths
    and have an absolute path to the image, no matter where the program is installed
    on the filesystem.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先通过调用`path.dirname(__file__)`找到包含`application.py`文件的目录。这给了我们`abq_data_entry`的绝对路径，从中我们知道图像的相对路径。我们可以连接这两个路径，并获得图像的绝对路径，无论程序安装在文件系统的何处。
- en: This approach works fine, but consider that we may want to access images from
    a variety of modules in our application, and having to import `path` and repeat
    this logic in multiple files is less than optimal. A cleaner approach is to treat
    our `images` folder like a Python package and create constants in it that point
    to image paths.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以正常工作，但考虑到我们可能希望从应用程序的各种模块中访问图像，并且不得不在多个文件中导入`path`并重复这个逻辑，这不是最佳的。一个更干净的方法是将我们的`images`文件夹视为Python包，并在其中创建指向图像路径的常量。
- en: 'Start by creating an `__init__.py` file inside the `images` folder and add
    the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`images`文件夹内创建一个`__init__.py`文件，并添加以下代码：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, our `application.py` module can simply do this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`application.py`模块可以简单地这样做：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Application.__init__()` can then create a `PhotoImage` object using the path
    in  `ABQ_LOGO_32`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application.__init__()`然后可以使用`ABQ_LOGO_32`中的路径创建一个`PhotoImage`对象：'
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After creating the `PhotoImage` object, we display it using a `Label`. If you
    run the application, you should see the logo show up at the top.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`PhotoImage`对象后，我们使用`Label`显示它。如果你运行应用程序，你应该会看到标志出现在顶部。
- en: Setting our Window icon
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的窗口图标
- en: We can also add the logo as our Window icon, which makes more sense than leaving
    the default Tkinter logo. This way, the logo will show up in both the window decorations
    and in the operating system's taskbar.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将标志添加为我们的窗口图标，这比保留默认的Tkinter标志更有意义。这样，标志将显示在窗口装饰和操作系统的任务栏中。
- en: As a subclass of Tk, our `Application` object has a method called `iconbitmap`
    which should, given a path to an icon file, set the icon appropriately. Unfortunately,
    this method is fairly finicky about the type of file it's given and does not work
    well across platforms. We can work around this using `PhotoImage` and the special
    Tk `call()` method.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Tk的子类，我们的`Application`对象有一个名为`iconbitmap`的方法，应该可以根据图标文件的路径设置图标。不幸的是，这个方法对于给定的文件类型非常挑剔，并且在各个平台上工作效果不佳。我们可以使用`PhotoImage`和特殊的Tk
    `call()`方法来解决这个问题。
- en: The `call` method allows us to directly call Tcl/Tk commands, and can be useful
    to access Tk capabilities that Tkinter wraps poorly or not at all.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`call`方法允许我们直接调用Tcl/Tk命令，并且可以用于访问Tkinter包装不好或根本不包装的Tk功能。'
- en: 'The code looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first line creates another `PhotoImage` object, referencing a larger version
    of the logo. Next, we execute `self.call()`, passing in the individual tokens
    of the Tcl/Tk command. In this case, we're calling the `wm iconphoto` command.
    `self._w` returns the Tcl/Tk name for our `Application` object; and, last of all,
    we pass in the `PhotoImage` object we created.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了另一个`PhotoImage`对象，引用了一个更大的标志的版本。接下来，我们执行`self.call()`，传入Tcl/Tk命令的各个标记。在这种情况下，我们调用`wm
    iconphoto`命令。`self._w`返回我们的`Application`对象的Tcl/Tk名称；最后，我们传入我们创建的`PhotoImage`对象。
- en: Hopefully, you won't need to use `call` often, but if you do, you can find documentation
    about Tcl/Tk commands at: [https://www.tcl.tk/doc/](https://www.tcl.tk/doc/) .
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你不需要经常使用`call`，但如果你需要，你可以在这里找到有关Tcl/Tk命令的文档：[https://www.tcl.tk/doc/](https://www.tcl.tk/doc/)
    。
- en: Run your application and notice how the icon has changed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的应用程序，注意图标已经改变了。
- en: Styling Tkinter widgets
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式化Tkinter小部件
- en: 'Tkinter has essentially two styling systems: the old Tkinter widgets system,
    and the newer Ttk system. Since we still need to work with both Tkinter and Ttk
    widgets, we''ll have to look at both systems. Let''s take a look first at the
    older Tkinter system and apply some styling to the Tkinter widgets in our application.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter基本上有两种样式系统：旧的Tkinter小部件系统和更新的Ttk系统。由于我们仍然需要使用Tkinter和Ttk小部件，我们将不得不查看这两个系统。让我们首先看一下旧的Tkinter系统，并对我们应用程序中的Tkinter小部件应用一些样式。
- en: Widget color properties
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小部件颜色属性
- en: 'Basic Tkinter widgets allow you to change two colors: **foreground**, meaning
    mainly the text and borders, and **background**, meaning the rest of the widget.
    These can be set using the `foreground` and `background` arguments, or their aliases
    `fg` and `bg`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的Tkinter小部件允许你更改两种颜色：**前景**，主要是文本和边框，和**背景**，指其余的小部件。这些可以使用`foreground`和`background`参数，或它们的别名`fg`和`bg`来设置。
- en: 'This example shows the use of colors on a `Label`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了在`Label`上使用颜色：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The values for the colors can be color name strings or CSS-style RGB hex strings.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色的值可以是颜色名称字符串或CSS样式的RGB十六进制字符串。
- en: 'For example, this code produces the same effect:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这段代码产生了相同的效果：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are over 700 named colors recognized by Tkinter, roughly corresponding
    to those recognized by the X11 display server used on Linux and Unix, or the CSS
    named colors used by web designers. For a complete list, see [https://www.tcl.tk/man/tcl8.6/TkCmd/colors.htm](https://www.tcl.tk/man/tcl8.6/TkCmd/colors.htm).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter识别了700多种命名颜色，大致对应于Linux和Unix上使用的X11显示服务器或Web设计师使用的CSS命名颜色。有关完整列表，请参见[https://www.tcl.tk/man/tcl8.6/TkCmd/colors.htm](https://www.tcl.tk/man/tcl8.6/TkCmd/colors.htm)。
- en: Using widget properties on our form
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的表单上使用小部件属性
- en: One request you received from the data entry staff is to increase the visual
    separation between the sections on the data entry form. Our `LabelFrame` widgets
    are simple Tkinter widgets (not Ttk), so we can accomplish this fairly simply
    by giving the sections colored backgrounds.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 数据输入人员收到的一个请求是增加数据输入表单上各个部分之间的视觉分隔。我们的`LabelFrame`小部件是简单的Tkinter小部件（不是Ttk），因此我们可以通过给各个部分设置有色的背景来相对简单地实现这一点。
- en: 'After some thought and discussion, you decide to color-code the sections as
    follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一番思考和讨论，您决定按以下方式对各个部分进行颜色编码：
- en: Record information will use `khaki`, suggesting the classic manila folders used
    for paper records
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录信息将使用`khaki`，表明用于纸质记录的经典马尼拉文件夹
- en: Environment information will use `lightblue`, symbolic of water and air
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境信息将使用`lightblue`，象征着水和空气
- en: Plant information will have a `lightgreen` background, symbolic of plants
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 植物信息将具有`lightgreen`背景，象征着植物
- en: '`Notes` are distinctive enough, so it will remain the same'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Notes`已经足够与众不同，因此它将保持不变'
- en: 'Open up `views.py` and edit the `LabelFrame` calls in `DataRecordForm.__init__()`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`views.py`并编辑`DataRecordForm.__init__()`中的`LabelFrame`调用：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that we've added a bit of padding here as well, to make the color more
    visible around the widgets and to also create more separation in the form.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里添加了一些填充，以使小部件周围的颜色更加明显，并在表单中创建更多的分隔。
- en: 'We should add similar padding around the `Notes` widget:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在`Notes`小部件周围添加类似的填充：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, we add the padding to the `grid` call, so that the entire `LabelInput`
    gets shifted over.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在`grid`调用中添加了填充，以便整个`LabelInput`被移动。
- en: 'The result, at least on Debian Linux, looks something like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 至少在Debian Linux上，结果看起来像这样：
- en: '![](assets/6133ca48-cf64-43e2-bcb9-19fa095453eb.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6133ca48-cf64-43e2-bcb9-19fa095453eb.png)'
- en: Hardly a visual masterpiece yet, but we have some separation and color coding
    between form sections.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管还不是一个视觉杰作，但我们在表单各个部分之间有了一些分隔和颜色编码。
- en: Using tags
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标签
- en: Foreground and background are sufficient for simple widgets such as buttons,
    but more complex Tkinter widgets like the `Text` widget or the Ttk `Treeview`
    rely on a system of **tags**. A tag in Tkinter is a named region of a widget's
    content to which color and font settings can be applied. To see how this works,
    let's build a crude, but pretty, Python shell.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前景和背景对于按钮等简单小部件已经足够了，但是像`Text`小部件或Ttk `Treeview`这样的更复杂的Tkinter小部件依赖于一种**标签**系统。在Tkinter中，标签是可以应用颜色和字体设置的小部件内容的命名区域。为了看看这是如何工作的，让我们构建一个粗糙但漂亮的Python
    shell。
- en: 'We''ll start by creating a `Text` widget:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个`Text`小部件：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we've used the `fg` and `bg` arguments to set up a green-on-black theme,
    popular with programmers. Rather than have only green text, though, let's configure
    different colors for our prompt and our interpreter output.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`fg`和`bg`参数设置了一个程序员喜欢的黑底绿字的主题。但是，我们不仅仅要绿色的文本，让我们为我们的提示和解释器输出配置不同的颜色。
- en: 'To do this, we''ll define some tags:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将定义一些标签：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `tag_configure` method allows us to create and configure tags on the `Text`
    widget. We've created one called `'prompt'` for our shell prompt, and another
    called `'output'` for the Python output.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag_configure`方法允许我们在`Text`小部件上创建和配置标签。我们为我们的shell提示创建了一个名为`''prompt''`的标签，另一个名为`''output''`的标签。'
- en: 'To `insert` text with a given tag applied, we do the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用给定标签插入文本，我们需要执行以下操作：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you may remember, the `Text.insert` method takes an index and string as
    its first two arguments. Notice the third argument: this is a tuple of the tags
    with which we want to mark the inserted text. This value must be a tuple, even
    if you''re only using one tag.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能记得的那样，`Text.insert`方法将索引和字符串作为其前两个参数。请注意第三个参数：这是我们想要标记插入的文本的标签的元组。这个值必须是一个元组，即使您只使用一个标签。
- en: If you add `text.mainloop()` to the end of the code and run it, you'll see that
    we have a black text entry window with a magenta prompt, but if you type your
    text, it will show up in green. So far so good; now, let's make it execute some
    Python.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将`text.mainloop()`添加到代码的末尾并运行它，您会看到我们有一个黑色的文本输入窗口，带有品红色的提示，但如果您输入文本，它将显示为绿色。到目前为止一切顺利；现在，让我们让它执行一些Python。
- en: 'Create a function just before the `mainloop()` call:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mainloop()`调用之前创建一个函数：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When retrieving text from a `Text` widget, we're required to supply start and
    end indices for the text we want to retrieve. Notice that we've used our tag name
    in the index. `prompt.last` tells Tkinter to fetch the text starting after the
    end of the region tagged `prompt`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当从`Text`小部件中检索文本时，我们需要为我们想要检索的文本提供起始和结束索引。请注意，我们在索引中使用了我们的标签名称。`prompt.last`告诉Tkinter从标记为`prompt`的区域的结束之后开始获取文本。
- en: 'Next, let''s execute `cmd`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们执行`cmd`：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If our `cmd` actually contains anything, we'll try to execute it with `eval`,
    then store a string of the response value as `output`. If it throws an exception,
    we'll get our exception as a string and set that as the `output`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的`cmd`实际上包含任何内容，我们将尝试使用`eval`执行它，然后将响应值的字符串存储为`output`。如果它抛出异常，我们将获得我们的异常作为字符串，并将其设置为`output`。
- en: 'Then, we''ll just show our `output`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需显示我们的`output`：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We insert our `output` text, prepended with a newline and tagged as `output`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们插入我们的`output`文本，前面加上一个换行符，并标记为`output`。
- en: 'We''ll finish off the function by giving the user back a `prompt`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过给用户返回一个`prompt`来完成该函数：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We also return the string `break` here to tell Tkinter to ignore the original
    event that triggered the callback. Since we're going to trigger this from a `Return`/`Enter`
    keystroke, we want to ignore that keystroke after we're finished. If we don't,
    the keystroke will be executed after our function returns and the user will be
    on the line under the prompt.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在这里返回字符串`break`，告诉Tkinter忽略触发回调的原始事件。因为我们将从`Return`/`Enter`按键触发这个操作，所以我们希望在完成后忽略该按键。如果不这样做，按键将在我们的函数返回后执行，用户将在提示下的下一行。
- en: 'Finally, we need to bind our function to the `Return` key:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将我们的函数绑定到`Return`键：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that the event for the `Enter`/`Return` key is always `<Return>`, even
    on non-Apple hardware (where the key is more commonly labeled `Enter`).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Enter`/`Return`键的事件始终是`<Return>`，即使在非苹果硬件上（该按键更常被标记为`Enter`）也是如此。
- en: 'Your application should look something like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序应该看起来像这样：
- en: '![](assets/db7df434-b620-4c9e-b45c-b34a34475830.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/db7df434-b620-4c9e-b45c-b34a34475830.png)'
- en: While this shell won't be supplanting IDLE any time soon, it does look rather
    nice, don't you think?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个shell不会很快取代IDLE，但它看起来确实很好看，你觉得呢？
- en: Styling our record list with tags
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标签样式化我们的记录列表
- en: 'Although `Treeview` is a Ttk widget, it uses tags to control the styling of
    individual rows. We can use this to answer another of the requests you''ve gotten
    from the data entry staff: they''d like the record list to highlight records updated
    and inserted during the current session.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Treeview`是一个Ttk小部件，但它使用标签来控制单独行的样式。我们可以利用这一点来回答数据输入人员提出的另一个要求：他们希望记录列表突出显示在当前会话期间更新和插入的记录。
- en: The first thing we'll need to do is have our `Application` object keep track
    of which rows have been updated or inserted during the session.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要做的是让我们的“Application”对象在会话期间跟踪哪些行已被更新或插入。
- en: 'In `Application.__init__()`, we''ll create the following instance variables:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Application.__init__()`中，我们将创建以下实例变量：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When a record is saved, we'll need to update one or the other of these lists
    with its row number. We'll do this in `Application.on_save()`, after the record
    is saved, but before we repopulate the record list.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当记录保存时，我们需要更新这些列表中的一个或另一个与其行号。我们将在`Application.on_save()`中完成这个操作，在记录保存后但在重新填充记录列表之前。
- en: 'First, we''ll check for an updated record:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将检查更新的记录：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Updates have `rownum` which do not have a `None` value, so if this is the case,
    we'll append it to the list. If a record is continually updated, there will be
    duplicates in our list, but that's not really of any consequence in the scale
    at which we're operating.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 更新有`rownum`，没有`None`值，所以如果是这种情况，我们将把它追加到列表中。如果记录不断更新，我们的列表中会有重复，但在我们操作的规模上，这实际上并不重要。
- en: 'Now, we need to deal with inserts:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要处理插入：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Inserted records are a little more troublesome in that we don't have a row number
    readily available to record. We do know that inserts are always appended to the
    end of the file, though, so it should be one less than the number of rows in the
    file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 插入的记录会更麻烦一些，因为我们没有一个行号可以记录。不过，我们知道插入总是添加到文件的末尾，所以它应该比文件中的行数少一个。
- en: Our inserted and updated records will be kept until the end of the program session
    (when the user exits the program), but we need to manually delete them in the
    case where a user selects a new file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的插入和更新记录将保留到程序会话结束（用户退出程序）时，但在用户选择新文件的情况下，我们需要手动删除它们。
- en: 'We can handle that by clearing the lists in `on_file_select()`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`on_file_select()`中清除列表来处理这个问题：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, our controller knows about inserted and updated records. Our record list
    does not, however; we need to fix that.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的控制器知道插入和更新的记录。不过，我们的记录列表并不知道；我们需要解决这个问题。
- en: 'Find the `RecordList` call in `Application.__init__()` and add the variables
    to its arguments:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Application.__init__()`中找到`RecordList`调用，并将这些变量添加到其参数中：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, we'll need to go back into `views.py` and tell the `RecordList` what to
    do with this information.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要回到`views.py`，告诉`RecordList`如何处理这些信息。
- en: 'We''ll start by updating its argument list and saving the lists to instance
    variables:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先更新其参数列表并将列表保存到实例变量中：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, we'll need to configure tags with appropriate colors. Our data entry staff
    feels that `lightgreen` would be a sensible color for inserted records, and `lightblue`
    for updated.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置适当颜色的标签。我们的数据输入人员认为`lightgreen`是插入记录的合理颜色，`lightblue`是更新记录的颜色。
- en: 'Add this code in `__init__()` after the `self.treeview` configuration:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__()`中添加以下代码，放在`self.treeview`配置之后：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Just as we did with the `Text` widget earlier, we call `tag_configure` to connect
    background color settings with our tag names. Note that you aren't restricted
    to just one configuration setting here; we could conceivably add `foreground`,
    `font`, or other configuration settings to the same call.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前对`Text`小部件所做的那样，我们调用`tag_configure`来将背景颜色设置与我们的标签名称连接起来。请注意，这里不仅限于一个配置设置；我们可以在同一个调用中添加`foreground`、`font`或其他配置设置。
- en: To add the tags to our `TreeView` rows, we'll need to update the `populate`
    method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要将标签添加到我们的`TreeView`行中，我们需要更新`populate`方法。
- en: 'Inside the `for` loop, just before inserting the row, we''ll add this code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中，在插入行之前，我们将添加这段代码：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We want `tag` to equal `'inserted'` if the `inserted` list exists and our `rownum`
    is in it; we want it to be `'updated'` if the `updated` list exists and our `rownum`
    is in it. Otherwise, we leave it blank.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`inserted`列表存在且我们的`rownum`在其中，我们希望`tag`等于`'inserted'`；如果`updated`列表存在且我们的`rownum`在其中，我们希望它等于`'updated'`。否则，我们将其留空。
- en: 'Now, our `treeview.insert` call just needs to be amended with this `tag` value:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`treeview.insert`调用只需要用这个`tag`值来修改：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Run the application and try inserting and updating some records.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并尝试插入和更新一些记录。
- en: 'You should get something like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似这样的东西：
- en: '![](assets/b8fb6912-02db-4fc5-a202-10d600d31c28.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b8fb6912-02db-4fc5-a202-10d600d31c28.png)'
- en: Tkinter fonts
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter字体
- en: There are three ways of specifying a widget's font in Tkinter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tkinter中，有三种指定小部件字体的方法。
- en: 'The simplest way is to just use a string format:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法就是使用字符串格式：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The string takes the format `Font-family` `size` `styles`, where `styles` can
    be any valid combination of text style keywords.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串采用`Font-family` `size` `styles`的格式，其中`styles`可以是任何有效的文本样式关键字的组合。
- en: 'Those words include:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单词包括：
- en: '`bold` for boldface text, or `normal` for normal weight'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bold` 用于粗体文本，或 `normal` 用于正常字重'
- en: '`italic` for italized text, or `roman` for regular slant'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`italic` 用于斜体文本，或 `roman` 用于常规倾斜'
- en: '`underline` for underlined text'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`underline` 用于下划线文本'
- en: '`overstrike` for struck-out text'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`overstrike` 用于删除线文本'
- en: Everything but the font family is optional, though you need to specify a `size`
    if you want to specify any of the styling keywords. The ordering of style keywords
    doesn't matter, but the weight and slant keywords are mutually exclusive (that
    is, you can't have `bold` `normal` or `italic roman`).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字体系列之外，其他都是可选的，尽管如果要指定任何样式关键字，您需要指定一个`size`。样式关键字的顺序无关紧要，但是重量和斜体关键字是互斥的（也就是说，您不能同时拥有`bold`
    `normal`或`italic roman`）。
- en: One shortcoming of the string approach is that it cannot handle fonts with spaces
    in the name.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串方法的一个缺点是它无法处理名称中带有空格的字体。
- en: 'To handle these, you can use the tuple format for fonts:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理这些，您可以使用字体的元组格式：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This format is exactly like the string format except that the different components
    are written as items in a tuple. The `size` component can be an integer or a string
    containing digits, which provides some flexibility depending on where the value
    comes from.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式与字符串格式完全相同，只是不同的组件被写成元组中的项目。`size`组件可以是整数或包含数字的字符串，这取决于值来自何处。
- en: This approach works fine for setting up a handful of font changes at launch
    time, but for situations that need to dynamically manipulate font settings, Tkinter
    has a feature called **named fonts.** This approach uses a `Font` class that can
    be assigned to widgets and then dynamically changed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于在启动时设置少量字体更改的情况，但是对于需要动态操作字体设置的情况，Tkinter具有一种称为**命名字体**的功能。这种方法使用一个可以分配给小部件然后动态更改的`Font`类。
- en: 'To use `Font`, it must be imported from the `tkinter.font` module:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`Font`，必须从`tkinter.font`模块中导入它：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we can create a custom `Font` object and assign it to widgets:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个自定义的`Font`对象并将其分配给小部件：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, the `Font` constructor arguments correlate the keywords used
    in string and tuple font specifications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`Font`构造函数参数与字符串和元组字体规范中使用的关键字相关。
- en: 'Once this font is assigned, we can dynamically alter aspects of it at runtime:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分配了这个字体，我们就可以在运行时动态地改变它的各个方面：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, we're providing a `Button` that will toggle the `overstrike`
    attribute on and off.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们提供了一个`Button`，它将切换`overstrike`属性的开和关。
- en: Tk comes with several named fonts already configured; we can create Python `Font`
    objects from them using the `nametofont` function from the `tkinter.font` module.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Tk已经配置了几个命名字体；我们可以使用`tkinter.font`模块的`nametofont`函数从中创建Python `Font`对象。
- en: 'This table shows some of the named fonts included in Tkinter:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格显示了Tkinter中包含的一些命名字体：
- en: '| **Font name** | **Defaults to** | **Used for** |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **字体名称** | **默认为** | **用于** |'
- en: '| `TkCaptionFont` | System title font | Window and dialog caption bars |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '`TkCaptionFont` | 系统标题字体 | 窗口和对话框标题栏 |'
- en: '| `TkDefaultFont` | System default font | Items not otherwise specified |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '`TkDefaultFont` | 系统默认字体 | 未另行指定的项目 |'
- en: '| `TkFixedFont` | System fixed-width font | Nothing |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '`TkFixedFont` | 系统等宽字体 | 无 |'
- en: '| `TkHeadingFont` | System heading font | Column headings in lists and tables
    |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '`TkHeadingFont` | 系统标题字体 | 列表和表格中的列标题 |'
- en: '| `TkIconFont` | System icon font | Icon captions |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '`TkIconFont` | 系统图标字体 | 图标标题 |'
- en: '| `TkMenuFont` | System menu font | Menu labels |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '`TkMenuFont` | 系统菜单字体 | 菜单标签 |'
- en: '| `TkSmallCaptionFont` | System title | Subwindows, tool dialogs |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '`TkSmallCaptionFont` | 系统标题 | 子窗口，工具对话框 |'
- en: '| `TkTextFont` | System input font | Input widgets: Entry, Spinbox, and so
    on |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '`TkTextFont` | 系统输入字体 | 输入小部件：Entry，Spinbox等 |'
- en: '| `TkTooltipFont` | System tooltip font | Tooltips |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '`TkTooltipFont` | 系统工具提示字体 | 工具提示 |'
- en: If you're curious as to what fonts Tkinter is using on your operating system,
    you can use the `tkinter.font.names()` function to retrieve a list of them.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道Tkinter在您的操作系统上使用的字体，可以使用`tkinter.font.names()`函数检索它们的列表。
- en: To change the overall look of the application, we can override these named fonts
    and the changes will get applied across all widgets that don't otherwise have
    a font set.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变应用程序的整体外观，我们可以覆盖这些命名字体，更改将应用于所有未另行设置字体的小部件。
- en: 'For example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, we use the `nametofont` function to retrieve an object for
    `TkDefaultFont`, the default named font class for Tkinter applications. After
    retrieving it, we can set its font `family` and `size`, changing those values
    for all widgets using `TkDefaultFont`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`nametofont`函数检索`TkDefaultFont`的对象，Tkinter应用程序的默认命名字体类。检索后，我们可以设置它的字体`family`和`size`，为使用`TkDefaultFont`的所有小部件更改这些值。
- en: 'The `Label` then shows the result of this adjustment:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Label`然后显示这个调整的结果：'
- en: '![](assets/12b670be-7fa5-4774-acb0-5cae16efab46.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/12b670be-7fa5-4774-acb0-5cae16efab46.png)'
- en: Giving users font options
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给用户提供字体选项
- en: Some of our data entry users have complained that the font of the application
    is just a little too small to read easily, but others dislike the idea of you
    increasing it because it makes the application too big for the screen. To accommodate
    all the users, we can add a configuration option that allows them to set a preferred
    font size.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一些数据输入用户抱怨应用程序的字体有点太小，不容易阅读，但其他人不喜欢您增加它，因为这样会使应用程序对屏幕来说太大。为了满足所有用户，我们可以添加一个配置选项，允许他们设置首选字体大小。
- en: We need to begin by adding a `'font size'` option to our settings model.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先向我们的设置模型添加一个`'font size'`选项。
- en: 'Open `models.py` and append the `SettingsModel.variables` dictionary as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`models.py`并将`SettingsModel.variables`字典追加如下：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Next, we'll add a set of radio buttons to our options menu so that the user
    can set the value.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在选项菜单中添加一组单选按钮，以便用户可以设置值。
- en: 'Open `views.py` and let''s start creating a menu just before the options menu
    gets added to the main menu:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`views.py`，让我们在将选项菜单添加到主菜单之前开始创建一个菜单：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This should look familiar, since we created a nearly identical font size menu
    when learning about the Tkinter `Menu` widget. We're allowing fonts from `6` to
    `16`, which should provide plenty of range for our users.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该看起来很熟悉，因为我们在学习Tkinter `Menu`小部件时创建了一个几乎相同的字体大小菜单。我们允许字体大小从`6`到`16`，这应该为我们的用户提供足够的范围。
- en: 'In the `Application` class, let''s create a method that will apply the font
    setting to our application''s fonts:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Application`类中，让我们创建一个方法，将应用程序的字体设置应用到我们的应用程序字体中：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We include `*args` because `set_font` will be called as a `trace` callback,
    so we need to capture any arguments being sent in, even though we won't use them.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括`*args`，因为`set_font`将作为`trace`回调调用，所以我们需要捕获发送的任何参数，尽管我们不会使用它们。
- en: 'Next, we''ll get the current `''font size''` value:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将获取当前的`'font size'`值：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There are several named fonts we're going to need to change, not just `TkDefaultFont`.
    For our application, `TkDefaultFont`, `TkTextFont`, and `TkMenuFont` should be
    sufficient.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改几个命名字体，不仅仅是`TkDefaultFont`。对于我们的应用程序，`TkDefaultFont`、`TkTextFont`和`TkMenuFont`应该足够了。
- en: 'We''ll just loop through these, retrieving the classes and setting the size
    on each one:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需循环遍历这些，检索类并在每个类上设置大小：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The last thing we need to do is to make sure this callback gets called.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是确保调用此回调。
- en: 'Just after the `load_settings()` call in `Application.__init__()`, add this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Application.__init__()`中的`load_settings()`调用之后，添加以下内容：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We call `set_font()` once to activate any saved `font size` settings and then
    set a `trace` to run it whenever the value is changed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`set_font()`一次以激活任何保存的`字体大小`设置，然后设置一个`trace`，以便在更改值时运行它。
- en: 'Run the application and try out the font menu. It should look something like
    this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并尝试使用字体菜单。它应该看起来像这样：
- en: '![](assets/8fb2114c-d0ab-4d97-96b0-4523e44ddb24.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8fb2114c-d0ab-4d97-96b0-4523e44ddb24.png)'
- en: Styling Ttk widgets
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ttk小部件的样式
- en: 'Ttk widgets represent a major improvement over standard Tkinter widgets in
    terms of the power and flexibility with which they can be styled. This flexibility
    is what gives Ttk widgets the ability to mimic native UI controls across platforms,
    but it comes at a cost: Ttk styling is confusing, poorly documented, and occasionally
    inconsistent.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Ttk小部件在功能上代表了对标准Tkinter小部件的重大改进。这种灵活性使得Ttk小部件能够在各个平台上模仿本机UI控件，但代价是：Ttk样式令人困惑，文档不完善，有时不一致。
- en: 'To understand Ttk styling, let''s start with some vocabulary, from the most
    basic elements to the most complex:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解Ttk样式，让我们从最基本的元素到最复杂的元素开始使用一些词汇：
- en: Ttk starts with **elements**. An element is one piece of a widget, such as a
    border, an arrow, or a field where text can be typed.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ttk从**元素**开始。元素是小部件的一部分，例如边框、箭头或可以输入文本的字段。
- en: Elements are composed using **layouts** into a complete widget (a `Combobox`
    or `Treeview`, for example).
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素使用**布局**组成一个完整的小部件（例如`Combobox`或`Treeview`）。
- en: '**Styles** are collections of properties that define color and font settings:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**样式**是定义颜色和字体设置的属性集合：'
- en: Each style has a name, usually T, plus the name of the widget, such as `TButton`
    or `TEntry`. There are some exceptions to this.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个样式都有一个名称，通常是T，加上小部件的名称，例如`TButton`或`TEntry`。也有一些例外。
- en: Each element in a layout references one or more style properties to define its
    appearance.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局中的每个元素都引用一个或多个样式属性来定义其外观。
- en: 'Widgets have a number of **states**, which are flags that can be turned on
    or off:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件有许多**状态**，这些状态是可以打开或关闭的标志：
- en: Styles can be configured with a **map** that connects property values to states
    or combinations of states
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式可以通过**映射**进行配置，将属性值连接到状态或状态的组合
- en: 'A collection of styles is called a **theme**. Tkinter ships with different
    themes on different platforms.:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组样式称为**主题**。Tkinter在不同平台上提供了不同的主题。：
- en: A theme might define not only different styles, but different layouts as well.
    For example, a `ttk.Button` on the default macOS theme may contain a different
    set of elements, applying style settings differently compared to a `ttk.Button`
    using the default theme in Windows.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个主题可能不仅定义不同的样式，还定义不同的布局。例如，默认macOS主题上的`ttk.Button`可能包含不同的元素集，与在Windows中使用默认主题的`ttk.Button`相比，应用样式设置的方式也不同。
- en: If you're confused at this point, that's okay. Let's take a deep dive into the
    anatomy of a `ttk.Combobox` to get a better feel for these ideas.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在感到困惑，没关系。让我们深入了解`ttk.Combobox`的解剖，以更好地了解这些概念。
- en: Exploring a Ttk widget
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Ttk小部件
- en: 'To get a better picture of how a Ttk widget is built, open a shell in IDLE
    and import `tkinter`, `ttk`, and `pprint`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解Ttk小部件是如何构建的，请在IDLE中打开一个shell并导入`tkinter`、`ttk`和`pprint`：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, create a root window, `Combobox`, and `Style` object:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个根窗口、`Combobox`和`Style`对象：
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `Style` object is, perhaps, slightly misnamed; it doesn't point to a single
    style, but rather gives us a handle to examine and alter the styles, layouts,
    and maps for the current theme.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`Style`对象可能命名有点不准确；它并不指向单个样式，而是给了我们一个处理当前主题的样式、布局和映射的句柄。'
- en: 'In order to examine our `Combobox`, we''ll first get its `stylename` using
    the `winfo_class()` method:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查我们的`Combobox`，我们首先使用`winfo_class()`方法获取它的`stylename`：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can then inspect the layout of the `Combobox` using the `Style.layout()`
    method:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`Style.layout()`方法检查`Combobox`的布局：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: By passing the style name (in this case, `TCombobox`) to the `style.layout()`
    method, we get back a layout specification that shows the hierarchy of elements
    used to construct this widget.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将样式名称（在本例中为`TCombobox`）传递给`style.layout()`方法，我们得到一个布局规范，显示用于构建此小部件的元素的层次结构。
- en: The elements, in this case, are `"Combobox.field"`, `"Combobox.downarrow"`,
    `"Combobox.padding"`, and `"Combobox.textarea"`. As you can see, each element
    has associated positioning properties similar to what you'd pass into `pack()`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，元素是`"Combobox.field"`、`"Combobox.downarrow"`、`"Combobox.padding"`和`"Combobox.textarea"`。正如您所看到的，每个元素都有与`pack()`中传递的定位属性类似的关联定位属性。
- en: The `layout` method can also be used to replace a style's layout by passing
    in a new layout specification. Unfortunately, this requires replacing the entire
    layout specification—you can't just adjust or replace a single element in place.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`layout`方法也可以用于通过传入新的布局规范来替换样式的布局。不幸的是，这需要替换整个布局规范，您不能只是在原地调整或替换单个元素。'
- en: To see how the style connects to the elements, we can use the `style.element_options()`
    method. This method takes an element name and returns a list of options that can
    be used to alter it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看样式如何连接到元素，我们可以使用`style.element_options()`方法。该方法接受一个元素名称，并返回一个可以用于更改它的选项列表。
- en: 'For example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This tells us that the `downarrow` element of the `Combobox` uses these style
    properties to determine its appearance. To change these properties, we'll have
    to use the `style.configure()` method.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们`Combobox`的`downarrow`元素使用这些样式属性来确定其外观。要更改这些属性，我们将需要使用`style.configure()`方法。
- en: 'Let''s change the color of the arrow to `red`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将箭头的颜色更改为`red`：
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You should see that the `arrowcolor` has changed to `red`. This is all we need
    to know to configure widgets for static changes, but what about dynamic changes?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到`arrowcolor`已更改为`red`。这就是我们需要了解的配置小部件进行静态更改的全部内容，但是动态更改呢？
- en: To make dynamic changes, we'll need to understand our widget's state.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行动态更改，我们需要了解小部件的状态。
- en: 'We can inspect or alter the state of our `Combobox` using the `state` method:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`state`方法检查或更改我们的`Combobox`的状态：
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`Combobox.state()` with no arguments will return a tuple with the currently
    set state flags; when used with an argument (which must be a sequence of strings),
    it will set the corresponding state flags.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`Combobox.state()`没有参数时将返回一个包含当前设置的状态标志的元组；当与参数一起使用时（参数必须是字符串序列），它将设置相应的状态标志。'
- en: 'To turn off a state flag, prepend a `!` to the flag name:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭状态标志，需要在标志名称前加上`!`：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When you call `state()` with an argument to change the value, the return value
    is a tuple containing a set of states that would, if applied, undo the state change
    you just set. This might be useful in a situation where you want to temporarily
    set a widget's state, then return it to its previous (unknown) state.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用`state()`并带有参数来更改值时，返回值是一个元组，其中包含一组状态，如果应用，则会撤消您刚刚设置的状态更改。这在您想要临时设置小部件的状态，然后将其返回到先前（未知）状态的情况下可能会有用。
- en: 'You can''t just use any strings for `state()`; they must be one of the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能只是使用任何字符串来调用`state()`；它们必须是以下之一：
- en: '`active`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active`'
- en: '`disabled`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disabled`'
- en: '`focus`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`focus`'
- en: '`pressed`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pressed`'
- en: '`selected`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selected`'
- en: '`background`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`background`'
- en: '`readonly`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readonly`'
- en: '`alternate`'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alternate`'
- en: '`invalid`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invalid`'
- en: Exactly how different widgets use each of these states depends on the widget;
    not every `state()` is configured to have an effect by default.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 每个小部件如何使用这些状态取决于小部件；并非每个`state()`默认情况下都配置为具有效果。
- en: Widget states interact with the widget style through the use of a map. We use
    the `style.map()` method to inspect or set the map for each style.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件状态通过映射与小部件样式进行交互。我们使用`style.map()`方法来检查或设置每个样式的映射。
- en: 'Take a look at the default map for `TCombobox`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`TCombobox`的默认映射：
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, `TCombobox` has a style map for the `arrowcolor` and `fieldbackground`
    properties by default. Each style map is a list of tuples, and each tuple is one
    or more state flags followed by a value for the setting. When all of the state
    flags match the current state of the widget, the value takes effect.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`TCombobox`默认情况下具有`arrowcolor`和`fieldbackground`属性的样式映射。每个样式映射都是一个元组列表，每个元组都是一个或多个状态标志，后跟一个设置的值。当所有状态标志与小部件的当前状态匹配时，该值生效。
- en: The default map turns the arrow color to a light gray color when the `disabled`
    flag is set, and turns the field background to a different light gray color when
    either the `disabled` or `readonly` flags are set.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 默认映射在设置`disabled`标志时将箭头颜色更改为浅灰色，并在设置`disabled`或`readonly`标志时将字段背景更改为不同的浅灰色。
- en: 'We can set our own style mapping using the same method:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的方法设置自己的样式映射：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we've configured the `arrowcolor` property to be `blue` when the `invalid`
    flag is not set, and `red` when both the `invalid` and `focus` flags are set.
    Notice that while our call to `map` completely overwrote the `arrowcolor` style
    map, the `fieldbackground` map was unaffected. This means you can replace style
    mappings individually, but you can't simply append to the existing map for a given
    property.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经配置了`arrowcolor`属性，当`invalid`标志未设置时，它为`blue`，当`invalid`和`focus`标志都设置时，它为`red`。请注意，虽然我们对`map`的调用完全覆盖了`arrowcolor`样式映射，但`fieldbackground`映射未受影响。这意味着您可以单独替换样式映射，但不能简单地追加到给定属性的现有映射中。
- en: So far, we've been operating on the `TCombobox` style, which is the default
    style for all `Combobox` widgets. Any changes we made would impact every `Combobox`
    in the application. We can also create custom styles derived from the existing
    style by prepending a name and a dot to an existing style name.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在操作`TCombobox`样式，这是所有`Combobox`小部件的默认样式。我们所做的任何更改都会影响应用程序中的每个`Combobox`。我们还可以通过在现有样式名称前加上名称和点来创建从现有样式派生的自定义样式。
- en: 'For example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`Blue.TCombobox` inherits all of the properties of `TCombobox` (including the
    `blue` `downarrow` we previously configured), but can add or override them with
    settings of its own that don''t affect `TCombobox`. This allows you to create
    custom styles for some widgets without affecting other widgets of the same type.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`Blue.TCombobox`继承了`TCombobox`的所有属性（包括我们之前配置的`blue` `downarrow`），但可以添加或覆盖自己的设置，而不会影响`TCombobox`。这使您可以为某些小部件创建自定义样式，而不会影响相同类型的其他小部件。'
- en: We can alter the look of all the Ttk widgets at once by changing the theme.
    Remember that a theme is a collection of styles, so by changing the theme, we'll
    be replacing all the built-in styles and layouts.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更改主题来一次性改变所有Ttk小部件的外观。请记住，主题是一组样式，因此通过更改主题，我们将替换所有内置样式和布局。
- en: 'Different themes are shipped on different platforms; to see the themes available
    on your platform, use the `theme_names()` method:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的主题在不同的平台上发行；要查看您平台上可用的主题，使用`theme_names()`方法：
- en: '[PRE52]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: (These are the themes available on Debian Linux; yours may differ.)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: （这些是Debian Linux上可用的主题；您的可能不同。）
- en: 'To query the current theme, or to set a new theme, use the `theme_use()` method:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询当前主题，或设置新主题，使用`theme_use()`方法：
- en: '[PRE53]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice how the previous styling is gone when you change the theme. If you switch
    back to the default, however, you'll see that your changes were retained.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当您更改主题时，之前的样式已经消失。但是，如果您切换回默认主题，您会发现您的更改已被保留。
- en: Styling our form labels
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的表单标签设置样式
- en: The first thing we can tackle with our knowledge of styling is our form widgets.
    Our colorization of the form is rather ugly and incomplete due to the `LabelInput`
    widgets retaining their default, drab color. We'll need to style each of those
    widgets to match the color of its `LabelInput`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用我们对样式的知识来解决的第一件事是我们的表单小部件。由于`LabelInput`小部件保留其默认的沉闷颜色，我们的表单的着色相当丑陋和不完整。我们需要为每个小部件设置样式，以匹配其`LabelInput`的颜色。
- en: 'In the `views.py` file, add this near the start of the `DataRecordForm.__init__()`
    method:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在`views.py`文件中，在`DataRecordForm.__init__()`方法的开头添加此内容：
- en: '[PRE54]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We're creating our `Style` object so that we can start working with our Ttk
    styles. What styles do we need?
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建我们的`Style`对象，以便我们可以开始使用我们的Ttk样式。我们需要哪些样式？
- en: We need a style for Ttk `Label` widgets for each section, since we'll need different
    colors for the widgets in `RecordInfo`, `EnvironmentInfo`, and `Plant Info`.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要为每个部分的Ttk`Label`小部件设置样式，因为我们需要为`RecordInfo`、`EnvironmentInfo`和`Plant Info`中的小部件设置不同的颜色。
- en: We'll need to style our Ttk `Checkbutton`, since it uses its own built-in label
    rather than a separate label widget. Since there's only one right now, we only
    need one style for it.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要为我们的Ttk`Checkbutton`设置样式，因为它使用自己内置的标签而不是单独的标签小部件。由于现在只有一个，我们只需要一个样式。
- en: 'Let''s create those styles:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建这些样式：
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As you can see, we're creating a custom style based on `TLabel`, but this is
    prefixed for each individual section. For each style, we're just setting the `background`
    color appropriately.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们正在基于`TLabel`创建自定义样式，但这是为每个单独的部分添加前缀。对于每种样式，我们只需适当设置`background`颜色。
- en: 'Now comes the tedious task of adding this style to each widget:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是将此样式添加到每个小部件的繁琐任务：
- en: '[PRE56]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In each `LabelInput` call, you'll need to add a `label_args` argument that sets
    the `style` to the appropriate `TLabel` style for the section. Go through and
    do this for all the widgets.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个`LabelInput`调用中，您需要添加一个`label_args`参数，将`style`设置为相应部分的`TLabel`样式。为所有小部件执行此操作。
- en: 'For the `Checkbutton`, you''ll need to do it differently:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Checkbutton`，您需要以不同的方式进行操作：
- en: '[PRE57]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we've set `input_args`, since the style applies to the `Checkbutton` rather
    than the label (leave `label_args`; we'll need that in a minute).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了`input_args`，因为该样式适用于`Checkbutton`而不是标签（保留`label_args`；我们一会儿会用到）。
- en: If you run the program at this point, you'll see a marked improvement, but it's
    not quite there yet; the error labels are still the old, default color.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你此时运行程序，你会看到明显的改进，但还不够完美；错误标签仍然是旧的默认颜色。
- en: To fix this, we just need to edit our `LabelInput` widget to use the `label_args`
    for the error label as well.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，我们只需要编辑我们的`LabelInput`小部件，以便错误标签也使用`label_args`。
- en: 'Open `widgets.py` and fix the `self.error_label` assignment in `LabelInput.__init__()`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在`widgets.py`中，修复`LabelInput.__init__()`中的`self.error_label`赋值：
- en: '[PRE58]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, your application should have consistent colors and look a lot more attractive:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的应用程序应该具有一致的颜色，并且看起来更加吸引人：
- en: '![](assets/eabe2216-6517-4675-b812-375b762689ae.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/eabe2216-6517-4675-b812-375b762689ae.png)'
- en: Styling input widgets on error
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在错误时为输入小部件设置样式
- en: Our data entry staff has complained that the error-styling in our fields is
    not terribly noticeable. Currently, we're just setting the `foreground` color
    to `red`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据输入人员抱怨说，我们字段中的错误样式并不是非常显眼。目前，我们只是将`foreground`颜色设置为`红色`。
- en: 'This has a couple of problems:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这有几个问题：
- en: For empty fields, there's nothing to actually color `red`
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于空字段，实际上没有什么可以涂成`红色`
- en: Our color blind user has trouble distinguishing the `red` from the normal text
    color
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的色盲用户很难区分`红色`和普通文本颜色
- en: We'll use our styling knowledge to improve the error styling and make invalid
    fields more noticeable.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用我们的样式知识来改进错误样式，并使无效字段更加显眼。
- en: Before we can do that, though, you may have to fix a minor issue with one of
    our widgets.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在这之前，您可能需要修复一个小部件的小问题。
- en: Making our Spinbox a Ttk widget
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使我们的Spinbox成为Ttk小部件
- en: If you're using Python 3.6 or earlier, the `Spinbox` widget is only available
    in `tkinter`, and not `ttk`.  We'll need to fix this so that our error-styling
    can be consistent.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Python 3.6或更早版本，则`Spinbox`小部件仅在`tkinter`中可用，而不在`ttk`中。我们需要修复这个问题，以便我们的错误样式可以保持一致。
- en: At the time of writing this book, the author has submitted a patch to Python
    3.7 to include the Ttk `Spinbox`. If you're using Python 3.7 or later, you can
    just use `ttk::spinbox` and skip this section.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，作者已经提交了一个补丁到Python 3.7中，以包括Ttk`Spinbox`。如果您使用的是Python 3.7或更高版本，您可以直接使用`ttk::spinbox`并跳过此部分。
- en: Since `Spinbox` is already in the Tcl/Tk Ttk library, creating a Python class
    for it is surprisingly easy.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Spinbox`已经在Tcl/Tk Ttk库中，为其创建一个Python类非常容易。
- en: 'Add this code near the top of `widgets.py`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在`widgets.py`的顶部附近添加此代码：
- en: '[PRE59]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is all that's needed to create a Ttk `Spinbox` for this application. We're
    simply subclassing `ttk.Entry`, but changing the Ttk widget being used in the
    `__init__` statement. If we needed any `Spinbox` methods that `Entry` lacks, we'd
    need to provide those; for this application, we don't need anything else.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为这个应用程序创建Ttk `Spinbox`所需的全部内容。我们只是对`ttk.Entry`进行子类化，但在`__init__`语句中更改了使用的Ttk小部件。如果我们需要`Entry`缺少的任何`Spinbox`方法，我们需要提供这些方法；对于这个应用程序，我们不需要其他任何东西。
- en: 'Now, we only need to update our `ValidatedSpinbox` class to inherit `TtkSpinbox`
    rather than `tk.Spinbox`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要更新我们的`ValidatedSpinbox`类，使其继承`TtkSpinbox`而不是`tk.Spinbox`：
- en: '[PRE60]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Updating ValidatedMixin
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新ValidatedMixin
- en: Now that we're working with all Ttk widgets, we can update our `ValidatedMixin`
    class with some dynamic styling.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在使用所有的Ttk小部件，我们可以通过一些动态样式来更新我们的`ValidatedMixin`类。
- en: 'We''ll begin in the `__init__()` method by creating a `Style` object:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`__init__()`方法开始，创建一个`Style`对象：
- en: '[PRE61]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Since this is a mixin class, we don't know the original style name of the widget
    we're mixing with, so we'll have to fetch that.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个混合类，我们不知道我们正在混合的小部件的原始样式名称，因此我们将不得不获取它。
- en: 'Remember that we can do this with `winfo_class()`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们可以用`winfo_class()`来实现这一点：
- en: '[PRE62]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: After getting the widget class, we're creating a derivative style by prepending
    `ValidatedInput` to it. In order to toggle our input appearance between error
    and non-error appearances, we'll create a style map that switches with the state
    of the `invalid` state flag.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取小部件类之后，我们通过在其前面添加`ValidatedInput`来创建一个派生样式。为了在错误和非错误外观之间切换我们的输入外观，我们将创建一个样式映射，根据`invalid`状态标志的状态进行切换。
- en: 'You can do this with a call to `style.map()`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用`style.map()`来实现这一点：
- en: '[PRE63]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We're still using red, since it's an established "error color", but this time
    we're inverting the field from dark-on-light to light-on-dark. This should help
    our colorblind user to distinguish errors, even though they are red.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然使用红色，因为它是一个已建立的“错误颜色”，但这次我们将字段从浅色背景变为深色背景。这应该帮助我们的色盲用户区分错误，即使它们是红色的。
- en: 'Finally, we need to update our call to `self.config` to include setting the
    widget''s style to our new validated style:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新对`self.config`的调用，以包括将小部件的样式设置为我们的新验证样式：
- en: '[PRE64]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Ttk widgets automatically set their `invalid` flags as part of the built-in
    validation system. Currently, we have a method called `_toggle_error()`, which
    is called whenever validation begins or fails and sets the error state on and
    off. We can remove that method completely, and all references to it.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Ttk小部件会自动设置它们的`invalid`标志作为内置验证系统的一部分。目前，我们有一个名为`_toggle_error()`的方法，每当验证开始或失败时都会调用它，并设置错误状态。我们可以完全删除该方法，以及所有对它的引用。
- en: 'If you try the application now, you''ll see that fields with errors now turn
    a dark red color with white text:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在尝试应用程序，您会看到带有错误的字段现在会变成深红色，并带有白色文本：
- en: '![](assets/aa35c553-7642-47b8-b442-8d30c3a69249.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aa35c553-7642-47b8-b442-8d30c3a69249.png)'
- en: Setting themes
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置主题
- en: Generally speaking, the default Ttk theme on any given platform is probably
    the best one to use on that platform, but looks are subjective and sometimes we
    might feel that Tkinter gets it wrong. Having a way to adjust the theme might
    help to smooth out some rough edges and make some users feel more comfortable
    with the look of the application.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，任何给定平台上的默认Ttk主题可能是最好的选择，但外观是主观的，有时我们可能觉得Tkinter做错了。有一种方法可以调整主题可能有助于消除一些粗糙的边缘，并使一些用户更舒适地看待应用程序的外观。
- en: As we've already seen, querying available themes and setting a new theme is
    fairly simple. Let's create a configuration option to change the theme of our
    application.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，查询可用主题并设置新主题是相当简单的。让我们创建一个配置选项来更改我们应用程序的主题。
- en: Building a theme selector
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建主题选择器
- en: Themes aren't something users are going to need to change often, and as we've
    seen, changing the theme can undo style changes we've made to our widgets. In
    light of this, we'll play it safe by designing our theme changer in such a way
    that it requires a restart of the program to make the actual change.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 主题不是用户经常需要更改的东西，正如我们所见，更改主题可能会撤消我们对小部件的样式更改。鉴于此，我们将通过设计我们的主题更改器的方式来确保需要重新启动程序才能实际更改。
- en: 'We''ll start by adding a theme option to our `SettingsModel`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在我们的`SettingsModel`中添加一个主题选项：
- en: '[PRE65]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Every platform has a `theme` aliased to `default`, so this is a safe and sensible
    default value.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 每个平台都有一个`theme`别名为`default`，因此这是一个安全和合理的默认值。
- en: Next, our `Application.__init__()` method will need to check this value and
    set the `theme` accordingly.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的`Application.__init__()`方法将需要检查这个值，并相应地设置`theme`。
- en: 'Add this code just after the call to `load_settings()`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`load_settings()`之后添加此代码：
- en: '[PRE66]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We create a `Style` object, query our settings for the theme name, then (assuming
    the saved `theme` is in the available themes) set the `theme` accordingly.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`Style`对象，查询主题名称的设置，然后（假设保存的`theme`在可用主题中）相应地设置`theme`。
- en: What remains now is to create the UI.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是创建UI。
- en: 'In the `views.py` file, we''ll create a new submenu for the `options_menu`:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在`views.py`文件中，我们将为`options_menu`创建一个新的子菜单：
- en: '[PRE67]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, we simply loop through the available themes and add a `Radiobutton` for
    each theme, tying it to our `settings['theme']` variable.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是循环遍历可用的主题，并为每个主题添加一个`Radiobutton`，将其绑定到我们的`settings['theme']`变量。
- en: It may not be obvious to users that changing the theme requires a restart, so
    let's make sure to let them know.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户来说，可能不明显更改主题需要重新启动，因此让我们确保让他们知道。
- en: 'We''ll add a `trace` to the variable:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为变量添加一个`trace`：
- en: '[PRE68]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `on_theme_change` method will just display a warning dialog informing the
    user that a restart will be needed to realize the change.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`on_theme_change`方法将显示一个警告对话框，通知用户需要重新启动才能实现更改。'
- en: 'Add it to the end of the `MainMenu` class:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 将其添加到`MainMenu`类的末尾：
- en: '[PRE69]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, you can run the application and try changing the `theme`. Which theme looks
    best on your platform?
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以运行应用程序并尝试更改`theme`。哪个主题在您的平台上看起来最好？
- en: You might find that some themes on your platform break the widget styling in
    the form. Remember that themes don't just change default colors and fonts, they
    change the layout and contents of the widget elements themselves. Sometimes, a
    style setting doesn't carry across different themes due to this change of property
    names.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现，平台上的一些主题会破坏表单中的小部件样式。请记住，主题不仅仅改变默认颜色和字体，它们还改变小部件元素本身的布局和内容。有时，由于属性名称的更改，样式设置在不同主题之间无法传递。
- en: Summary
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we overhauled the look and feel of our application for both
    aesthetic and usability improvements. You learned how to work with color and font
    settings for Tkinter widget, and the intricate world of Ttk styles.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为了美观和可用性改进彻底改变了应用程序的外观和感觉。您学会了如何处理Tkinter小部件的颜色和字体设置，以及Ttk样式的复杂世界。
