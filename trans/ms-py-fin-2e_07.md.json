["```py\nIn [ ]:\n    def zero_coupon_bond(par, y, t):\n        \"\"\"\n        Price a zero coupon bond.\n\n        :param par: face value of the bond.\n        :param y: annual yield or rate of the bond.\n        :param t: time to maturity, in years.\n        \"\"\"\n        return par/(1+y)**t\n```", "```py\nIn [ ]:\n    print(zero_coupon_bond(100, 0.05, 5))\nOut[ ]:\n    78.35261664684589\n\n```", "```py\nimport math\n\nclass BootstrapYieldCurve(object):    \n\n    def __init__(self):\n        self.zero_rates = dict()\n        self.instruments = dict()\n```", "```py\ndef add_instrument(self, par, T, coup, price, compounding_freq=2):\n    self.instruments[T] = (par, coup, price, compounding_freq)\n```", "```py\ndef get_maturities(self):\n    \"\"\" \n    :return: a list of maturities of added instruments \n    \"\"\"\n    return sorted(self.instruments.keys())\n```", "```py\ndef get_zero_rates(self):\n    \"\"\" \n    Returns a list of spot rates on the yield curve.\n    \"\"\"\n    self.bootstrap_zero_coupons()    \n    self.get_bond_spot_rates()\n    return [self.zero_rates[T] for T in self.get_maturities()]\n```", "```py\ndef bootstrap_zero_coupons(self):\n    \"\"\" \n    Bootstrap the yield curve with zero coupon instruments first.\n    \"\"\"\n    for (T, instrument) in self.instruments.items():\n        (par, coup, price, freq) = instrument\n        if coup == 0:\n            spot_rate = self.zero_coupon_spot_rate(par, price, T)\n            self.zero_rates[T] = spot_rate  \n```", "```py\ndef zero_coupon_spot_rate(self, par, price, T):\n    \"\"\" \n    :return: the zero coupon spot rate with continuous compounding.\n    \"\"\"\n    spot_rate = math.log(par/price)/T\n    return spot_rate\n```", "```py\ndef get_bond_spot_rates(self):\n    \"\"\" \n    Get spot rates implied by bonds, using short-term instruments.\n    \"\"\"\n    for T in self.get_maturities():\n        instrument = self.instruments[T]\n        (par, coup, price, freq) = instrument\n        if coup != 0:\n            spot_rate = self.calculate_bond_spot_rate(T, instrument)\n            self.zero_rates[T] = spot_rate\n```", "```py\ndef calculate_bond_spot_rate(self, T, instrument):\n    try:\n        (par, coup, price, freq) = instrument\n        periods = T*freq\n        value = price\n        per_coupon = coup/freq\n        for i in range(int(periods)-1):\n            t = (i+1)/float(freq)\n            spot_rate = self.zero_rates[t]\n            discounted_coupon = per_coupon*math.exp(-spot_rate*t)\n            value -= discounted_coupon\n\n        last_period = int(periods)/float(freq)        \n        spot_rate = -math.log(value/(par+per_coupon))/last_period\n        return spot_rate\n    except:\n        print(\"Error: spot rate not found for T=\", t)\n```", "```py\nIn [ ]:\n    yield_curve = BootstrapYieldCurve()\n    yield_curve.add_instrument(100, 0.25, 0., 97.5)\n    yield_curve.add_instrument(100, 0.5, 0., 94.9)\n    yield_curve.add_instrument(100, 1.0, 0., 90.)\n    yield_curve.add_instrument(100, 1.5, 8, 96., 2)\n    yield_curve.add_instrument(100, 2., 12, 101.6, 2)\nIn [ ]:\n    y = yield_curve.get_zero_rates()\n    x = yield_curve.get_maturities()\n```", "```py\nIn [ ]:\n    %pylab inline\n\n    fig = plt.figure(figsize=(12, 8))\n    plot(x, y)\n    title(\"Zero Curve\") \n    ylabel(\"Zero Rate (%)\")\n    xlabel(\"Maturity in Years\");\n```", "```py\nclass ForwardRates(object):\n\n    def __init__(self):\n        self.forward_rates = []\n        self.spot_rates = dict()\n\n    def add_spot_rate(self, T, spot_rate):\n        self.spot_rates[T] = spot_rate\n\n    def get_forward_rates(self):\n        \"\"\"\n        Returns a list of forward rates\n        starting from the second time period.\n        \"\"\"\n        periods = sorted(self.spot_rates.keys())\n        for T2, T1 in zip(periods, periods[1:]):\n            forward_rate = self.calculate_forward_rate(T1, T2)\n            self.forward_rates.append(forward_rate)\n\n        return self.forward_rates\n\n    def calculate_forward_rate(self, T1, T2):\n        R1 = self.spot_rates[T1]\n        R2 = self.spot_rates[T2]\n        forward_rate = (R2*T2-R1*T1)/(T2-T1)\n        return forward_rate        \n```", "```py\nIn [ ]:\n    fr = ForwardRates()\n    fr.add_spot_rate(0.25, 10.127)\n    fr.add_spot_rate(0.50, 10.469)\n    fr.add_spot_rate(1.00, 10.536)\n    fr.add_spot_rate(1.50, 10.681)\n    fr.add_spot_rate(2.00, 10.808)\nIn [ ]:\n    print(fr.get_forward_rates())\nOut[ ]:\n    [10.810999999999998, 10.603, 10.971, 11.189]\n```", "```py\nimport scipy.optimize as optimize\n\ndef bond_ytm(price, par, T, coup, freq=2, guess=0.05):\n    freq = float(freq)\n    periods = T*2\n    coupon = coup/100.*par\n    dt = [(i+1)/freq for i in range(int(periods))]\n    ytm_func = lambda y: \\\n        sum([coupon/freq/(1+y/freq)**(freq*t) for t in dt]) +\\\n        par/(1+y/freq)**(freq*T) - price\n\n    return optimize.newton(ytm_func, guess)\n```", "```py\nIn [ ] :\n    ytm = bond_ytm(95.0428, 100, 1.5, 5.75, 2)\nIn [ ]:\n    print(ytm)\nOut[ ]:\n    0.09369155345239522\n```", "```py\nIn [ ]:\n    def bond_price(par, T, ytm, coup, freq=2):\n        freq = float(freq)\n        periods = T*2\n        coupon = coup/100.*par\n        dt = [(i+1)/freq for i in range(int(periods))]\n        price = sum([coupon/freq/(1+ytm/freq)**(freq*t) for t in dt]) + \\\n            par/(1+ytm/freq)**(freq*T)\n        return price\n```", "```py\nIn [ ]:\n    price = bond_price(100, 1.5, ytm, 5.75, 2)\n    print(price)\nOut[ ]:   \n    95.04279999999997\n```", "```py\nIn [ ]:\n    def bond_mod_duration(price, par, T, coup, freq, dy=0.01):\n        ytm = bond_ytm(price, par, T, coup, freq)\n\n        ytm_minus = ytm - dy    \n        price_minus = bond_price(par, T, ytm_minus, coup, freq)\n\n        ytm_plus = ytm + dy\n        price_plus = bond_price(par, T, ytm_plus, coup, freq)\n\n        mduration = (price_minus-price_plus)/(2*price*dy)\n        return mduration\n```", "```py\nIn [ ]:\n    mod_duration = bond_mod_duration(95.0428, 100, 1.5, 5.75, 2)\nIn [ ]:\n    print(mod_duration)\nOut[ ]:\n    1.3921935426561034\n```", "```py\nIn [ ]:\n    def bond_convexity(price, par, T, coup, freq, dy=0.01):\n        ytm = bond_ytm(price, par, T, coup, freq)\n\n        ytm_minus = ytm - dy    \n        price_minus = bond_price(par, T, ytm_minus, coup, freq)\n\n        ytm_plus = ytm + dy\n        price_plus = bond_price(par, T, ytm_plus, coup, freq)\n\n        convexity = (price_minus + price_plus - 2*price)/(price*dy**2)\n        return convexity\n```", "```py\nIn [ ]:\n    convexity = bond_convexity(95.0428, 100, 1.5, 5.75, 2)\nIn [ ]:\n    print(convexity)\nOut[ ] :    \n    2.633959390331875\n```", "```py\nIn [ ]:\n    import math\n    import numpy as np\n\n    def vasicek(r0, K, theta, sigma, T=1., N=10, seed=777):    \n        np.random.seed(seed)\n        dt = T/float(N)    \n        rates = [r0]\n        for i in range(N):\n            dr = K*(theta-rates[-1])*dt + \\\n                sigma*math.sqrt(dt)*np.random.normal()\n            rates.append(rates[-1]+dr)\n\n        return range(N+1), rates\n```", "```py\nIn [ ]:\n    %pylab inline\n\n    fig = plt.figure(figsize=(12, 8))\n\n    for K in [0.002, 0.02, 0.2]:\n        x, y = vasicek(0.005, K, 0.15, 0.05, T=10, N=200)\n        plot(x,y, label='K=%s'%K)\n        pylab.legend(loc='upper left');\n\n    pylab.legend(loc='upper left')\n    pylab.xlabel('Vasicek model');\n```", "```py\nIn [ ]:\n    import math\n    import numpy as np\n\n    def CIR(r0, K, theta, sigma, T=1.,N=10,seed=777):        \n        np.random.seed(seed)\n        dt = T/float(N)    \n        rates = [r0]\n        for i in range(N):\n            dr = K*(theta-rates[-1])*dt + \\\n                sigma*math.sqrt(rates[-1])*\\\n                math.sqrt(dt)*np.random.normal()\n            rates.append(rates[-1] + dr)\n\n        return range(N+1), rates\n\n```", "```py\nIn [ ] :\n    %pylab inline\n\n    fig = plt.figure(figsize=(12, 8))\n\n    for K in [0.002, 0.02, 0.2]:\n        x, y = CIR(0.005, K, 0.15, 0.05, T=10, N=200)\n        plot(x,y, label='K=%s'%K)\n\n    pylab.legend(loc='upper left')\n    pylab.xlabel('CRR model');\n```", "```py\nIn [ ]:\n    import math\n    import numpy as np\n\n    def rendleman_bartter(r0, theta, sigma, T=1.,N=10,seed=777):        \n        np.random.seed(seed)\n        dt = T/float(N)    \n        rates = [r0]\n        for i in range(N):\n            dr = theta*rates[-1]*dt + \\\n                sigma*rates[-1]*math.sqrt(dt)*np.random.normal()\n            rates.append(rates[-1] + dr)\n\n        return range(N+1), rates\n```", "```py\nIn [ ]:\n    %pylab inline\n\n    fig = plt.figure(figsize=(12, 8))\n\n    for theta in [0.01, 0.05, 0.1]:\n        x, y = rendleman_bartter(0.005, theta, 0.05, T=10, N=200)\n        plot(x,y, label='theta=%s'%theta)\n\n    pylab.legend(loc='upper left')\n    pylab.xlabel('Rendleman and Bartter model');\n```", "```py\nIn [ ]:\n    import math\n    import numpy as np\n\n    def brennan_schwartz(r0, K, theta, sigma, T=1., N=10, seed=777):    \n        np.random.seed(seed)\n        dt = T/float(N)    \n        rates = [r0]\n        for i in range(N):\n            dr = K*(theta-rates[-1])*dt + \\\n                sigma*rates[-1]*math.sqrt(dt)*np.random.normal()\n            rates.append(rates[-1] + dr)\n\n        return range(N+1), rates\n```", "```py\nIn [ ]:\n    %pylab inline\n\n    fig = plt.figure(figsize=(12, 8))\n\n    for K in [0.2, 0.02, 0.002]:\n        x, y = brennan_schwartz(0.005, K, 0.006, 0.05, T=10, N=200)\n        plot(x,y, label='K=%s'%K)\n\n    pylab.legend(loc='upper left')\n    pylab.xlabel('Brennan and Schwartz model');\n```", "```py\nIn [ ]:\n    import numpy as np\n    import math\n\n    def exact_zcb(theta, kappa, sigma, tau, r0=0.):\n        B = (1 - np.exp(-kappa*tau)) / kappa\n        A = np.exp((theta-(sigma**2)/(2*(kappa**2)))*(B-tau) - \\\n                   (sigma**2)/(4*kappa)*(B**2))\n        return A * np.exp(-r0*B)\n```", "```py\nIn [ ]:    \n    Ts = np.r_[0.0:25.5:0.5]\n    zcbs = [exact_zcb(0.5, 0.02, 0.03, t, 0.015) for t in Ts]\nIn [ ]:\n    %pylab inline\n\n    fig = plt.figure(figsize=(12, 8))\n    plt.title(\"Zero Coupon Bond (ZCB) Values by Time\")\n    plt.plot(Ts, zcbs, label='ZCB')\n    plt.ylabel(\"Value ($)\")\n    plt.xlabel(\"Time in years\")\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n```", "```py\nIn [ ]:\n    import math\n\n    def exercise_value(K, R, t):\n        return K*math.exp(-R*t)\n```", "```py\nIn [ ]:\n    Ts = np.r_[0.0:25.5:0.5]\n    Ks = [exercise_value(0.95, 0.015, t) for t in Ts]\n    zcbs = [exact_zcb(0.5, 0.02, 0.03, t, 0.015) for t in Ts]\nIn [ ]:\n    import matplotlib.pyplot as plt\n\n    fig = plt.figure(figsize=(12, 8))\n    plt.title(\"Zero Coupon Bond (ZCB) and Strike (K) Values by Time\")\n    plt.plot(Ts, zcbs, label='ZCB')\n    plt.plot(Ts, Ks, label='K', linestyle=\"--\", marker=\".\")\n    plt.ylabel(\"Value ($)\")\n    plt.xlabel(\"Time in years\")\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n```", "```py\nimport math\nimport numpy as np\nimport scipy.stats as st\n\nclass VasicekCZCB:\n\n    def __init__(self):\n        self.norminv = st.distributions.norm.ppf\n        self.norm = st.distributions.norm.cdf    \n```", "```py\ndef vasicek_czcb_values(self, r0, R, ratio, T, sigma, kappa, theta,\n                        M, prob=1e-6, max_policy_iter=10, \n                        grid_struct_const=0.25, rs=None):\n    (r_min, dr, N, dtau) = \\\n        self.vasicek_params(r0, M, sigma, kappa, theta,\n                            T, prob, grid_struct_const, rs)\n    r = np.r_[0:N]*dr + r_min\n    v_mplus1 = np.ones(N)\n\n    for i in range(1, M+1):\n        K = self.exercise_call_price(R, ratio, i*dtau)\n        eex = np.ones(N)*K\n        (subdiagonal, diagonal, superdiagonal) = \\\n            self.vasicek_diagonals(\n                sigma, kappa, theta, r_min, dr, N, dtau)\n        (v_mplus1, iterations) = \\\n            self.iterate(subdiagonal, diagonal, superdiagonal,\n                         v_mplus1, eex, max_policy_iter)\n    return r, v_mplus1\n```", "```py\ndef vasicek_params(self, r0, M, sigma, kappa, theta, T,\n                  prob, grid_struct_const=0.25, rs=None):\n    if rs is not None:\n        (r_min, r_max) = (rs[0], rs[-1])\n    else:\n        (r_min, r_max) = self.vasicek_limits(\n            r0, sigma, kappa, theta, T, prob)      \n\n    dt = T/float(M)\n    N = self.calculate_N(grid_struct_const, dt, sigma, r_max, r_min)\n    dr = (r_max-r_min)/(N-1)\n\n    return (r_min, dr, N, dt)\n\n```", "```py\ndef calculate_N(self, max_structure_const, dt, sigma, r_max, r_min):\n    N = 0\n    while True:\n        N += 1\n        grid_structure_interval = \\\n            dt*(sigma**2)/(((r_max-r_min)/float(N))**2)\n        if grid_structure_interval > max_structure_const:\n            break\n    return N\n\n```", "```py\ndef vasicek_limits(self, r0, sigma, kappa, theta, T, prob=1e-6):\n    er = theta+(r0-theta)*math.exp(-kappa*T)\n    variance = (sigma**2)*T if kappa==0 else \\\n                (sigma**2)/(2*kappa)*(1-math.exp(-2*kappa*T))\n    stdev = math.sqrt(variance)\n    r_min = self.norminv(prob, er, stdev)\n    r_max = self.norminv(1-prob, er, stdev)\n    return (r_min, r_max)\n```", "```py\ndef vasicek_diagonals(self, sigma, kappa, theta, r_min,\n                      dr, N, dtau):\n    rn = np.r_[0:N]*dr + r_min\n    subdiagonals = kappa*(theta-rn)*dtau/(2*dr) - \\\n                    0.5*(sigma**2)*dtau/(dr**2)\n    diagonals = 1 + rn*dtau + sigma**2*dtau/(dr**2)\n    superdiagonals = -kappa*(theta-rn)*dtau/(2*dr) - \\\n                    0.5*(sigma**2)*dtau/(dr**2)\n\n    # Implement boundary conditions.\n    if N > 0:\n        v_subd0 = subdiagonals[0]\n        superdiagonals[0] = superdiagonals[0]-subdiagonals[0]\n        diagonals[0] += 2*v_subd0\n        subdiagonals[0] = 0\n\n    if N > 1:\n        v_superd_last = superdiagonals[-1]\n        superdiagonals[-1] = superdiagonals[-1] - subdiagonals[-1]\n        diagonals[-1] += 2*v_superd_last\n        superdiagonals[-1] = 0\n\n    return (subdiagonals, diagonals, superdiagonals)\n\n```", "```py\ndef check_exercise(self, V, eex):\n    return V > eex\n```", "```py\ndef exercise_call_price(self, R, ratio, tau):\n    K = ratio*np.exp(-R*tau)\n    return K\n```", "```py\n def vasicek_policy_diagonals(self, subdiagonal, diagonal, \\\n                             superdiagonal, v_old, v_new, eex):\n    has_early_exercise = self.check_exercise(v_new, eex)\n    subdiagonal[has_early_exercise] = 0\n    superdiagonal[has_early_exercise] = 0\n    policy = v_old/eex\n    policy_values = policy[has_early_exercise]\n    diagonal[has_early_exercise] = policy_values\n    return (subdiagonal, diagonal, superdiagonal)\n```", "```py\ndef iterate(self, subdiagonal, diagonal, superdiagonal,\n            v_old, eex, max_policy_iter=10):\n    v_mplus1 = v_old\n    v_m = v_old\n    change = np.zeros(len(v_old))\n    prev_changes = np.zeros(len(v_old))\n\n    iterations = 0\n    while iterations <= max_policy_iter:\n        iterations += 1\n\n        v_mplus1 = self.tridiagonal_solve(\n                subdiagonal, diagonal, superdiagonal, v_old)\n        subdiagonal, diagonal, superdiagonal = \\\n            self.vasicek_policy_diagonals(\n                subdiagonal, diagonal, superdiagonal, \n                v_old, v_mplus1, eex)\n\n        is_eex = self.check_exercise(v_mplus1, eex)\n        change[is_eex] = 1\n\n        if iterations > 1:\n            change[v_mplus1 != v_m] = 1\n\n        is_no_more_eex = False if True in is_eex else True\n        if is_no_more_eex:\n            break\n\n        v_mplus1[is_eex] = eex[is_eex]\n        changes = (change == prev_changes)\n\n        is_no_further_changes = all((x == 1) for x in changes)\n        if is_no_further_changes:\n            break\n\n        prev_changes = change\n        v_m = v_mplus1\n\n    return v_mplus1, iterations-1\n```", "```py\ndef tridiagonal_solve(self, a, b, c, d):\n    nf = len(a)  # Number of equations\n    ac, bc, cc, dc = map(np.array, (a, b, c, d))  # Copy the array\n    for it in range(1, nf):\n        mc = ac[it]/bc[it-1]\n        bc[it] = bc[it] - mc*cc[it-1] \n        dc[it] = dc[it] - mc*dc[it-1]\n\n    xc = ac\n    xc[-1] = dc[-1]/bc[-1]\n\n    for il in range(nf-2, -1, -1):\n        xc[il] = (dc[il]-cc[il]*xc[il+1])/bc[il]\n\n    del bc, cc, dc  # Delete variables from memory\n\n    return xc\n```", "```py\nIn [ ]:\n    r0 = 0.05\n    R = 0.05\n    ratio = 0.95\n    sigma = 0.03\n    kappa = 0.15\n    theta = 0.05\n    prob = 1e-6\n    M = 250\n    max_policy_iter=10\n    grid_struct_interval = 0.25\n    rs = np.r_[0.0:2.0:0.1]\nIn [ ]:\n    vasicek = VasicekCZCB()\n    r, vals = vasicek.vasicek_czcb_values(\n        r0, R, ratio, 1., sigma, kappa, theta, \n        M, prob, max_policy_iter, grid_struct_interval, rs)\nIn [ ]:\n    %pylab inline\n\n    fig = plt.figure(figsize=(12, 8))\n    plt.title(\"Callable Zero Coupon Bond Values by r\")\n    plt.plot(r, vals, label='1 yr')\n\n    for T in [5., 7., 10., 20.]:\n        r, vals = vasicek.vasicek_czcb_values(\n            r0, R, ratio, T, sigma, kappa, theta, \n            M, prob, max_policy_iter, grid_struct_interval, rs)\n        plt.plot(r, vals, label=str(T)+' yr', linestyle=\"--\", marker=\".\")\n\n    plt.ylabel(\"Value ($)\")\n    plt.xlabel(\"r\")\n    plt.legend()\n    plt.grid(True)\n    plt.show()\n```"]