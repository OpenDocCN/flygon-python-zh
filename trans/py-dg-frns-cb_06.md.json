["```py\nfrom __future__ import print_function\nfrom argparse import ArgumentParser, FileType\nfrom email import message_from_file\nimport os\nimport quopri\nimport base64\n```", "```py\nif __name__ == '__main__':\n    parser = ArgumentParser(\n        description=__description__,\n        epilog=\"Developed by {} on {}\".format(\n            \", \".join(__authors__), __date__)\n    )\n    parser.add_argument(\"EML_FILE\",\n                        help=\"Path to EML File\", type=FileType('r'))\n    args = parser.parse_args()\n\n    main(args.EML_FILE)\n```", "```py\ndef main(input_file):\n    emlfile = message_from_file(input_file)\n\n    # Start with the headers\n    for key, value in emlfile._headers:\n        print(\"{}: {}\".format(key, value))\n\n    # Read payload\n    print(\"\\nBody\\n\")\n    if emlfile.is_multipart():\n        for part in emlfile.get_payload():\n            process_payload(part)\n    else:\n        process_payload(emlfile[1])\n```", "```py\ndef process_payload(payload):\n    print(payload.get_content_type() + \"\\n\" + \"=\" * len(\n        payload.get_content_type()))\n    body = quopri.decodestring(payload.get_payload())\n    if payload.get_charset():\n        body = body.decode(payload.get_charset())\n    else:\n        try:\n            body = body.decode()\n        except UnicodeDecodeError:\n            body = body.decode('cp1252')\n```", "```py\n    if payload.get_content_type() == \"text/html\":\n        outfile = os.path.basename(args.EML_FILE.name) + \".html\"\n        open(outfile, 'w').write(body)\n    elif payload.get_content_type().startswith('application'):\n        outfile = open(payload.get_filename(), 'wb')\n        body = base64.b64decode(payload.get_payload())\n        outfile.write(body)\n        outfile.close()\n        print(\"Exported: {}\\n\".format(outfile.name))\n    else:\n        print(body)\n```", "```py\nfrom __future__ import print_function\nfrom argparse import ArgumentParser\nimport os\nimport win32com.client\nimport pywintypes\n```", "```py\nif __name__ == '__main__':\n    parser = ArgumentParser(\n        description=__description__,\n        epilog=\"Developed by {} on {}\".format(\n            \", \".join(__authors__), __date__)\n    )\n    parser.add_argument(\"MSG_FILE\", help=\"Path to MSG file\")\n    parser.add_argument(\"OUTPUT_DIR\", help=\"Path to output folder\")\n    args = parser.parse_args()\n    out_dir = args.OUTPUT_DIR\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n    main(args.MSG_FILE, args.OUTPUT_DIR)\n```", "```py\ndef main(msg_file, output_dir):\n    mapi = win32com.client.Dispatch(\n        \"Outlook.Application\").GetNamespace(\"MAPI\")\n    msg = mapi.OpenSharedItem(os.path.abspath(args.MSG_FILE))\n    display_msg_attribs(msg)\n    display_msg_recipients(msg)\n    extract_msg_body(msg, output_dir)\n    extract_attachments(msg, output_dir)\n```", "```py\ndef display_msg_attribs(msg):\n    # Display Message Attributes\n    attribs = [\n        'Application', 'AutoForwarded', 'BCC', 'CC', 'Class',\n        'ConversationID', 'ConversationTopic', 'CreationTime',\n        'ExpiryTime', 'Importance', 'InternetCodePage', 'IsMarkedAsTask',\n        'LastModificationTime', 'Links', 'OriginalDeliveryReportRequested',\n        'ReadReceiptRequested', 'ReceivedTime', 'ReminderSet',\n        'ReminderTime', 'ReplyRecipientNames', 'Saved', 'Sender',\n        'SenderEmailAddress', 'SenderEmailType', 'SenderName', 'Sent',\n        'SentOn', 'SentOnBehalfOfName', 'Size', 'Subject',\n        'TaskCompletedDate', 'TaskDueDate', 'To', 'UnRead'\n    ]\n    print(\"\\nMessage Attributes\")\n    print(\"==================\")\n    for entry in attribs:\n        print(\"{}: {}\".format(entry, getattr(msg, entry, 'N/A')))\n```", "```py\ndef display_msg_recipients(msg):\n    # Display Recipient Information\n    recipient_attrib = [\n        'Address', 'AutoResponse', 'Name', 'Resolved', 'Sendable'\n    ]\n    i = 1\n    while True:\n        try:\n            recipient = msg.Recipients(i)\n        except pywintypes.com_error:\n            break\n\n        print(\"\\nRecipient {}\".format(i))\n        print(\"=\" * 15)\n        for entry in recipient_attrib:\n            print(\"{}: {}\".format(entry, getattr(recipient, entry, 'N/A')))\n        i += 1\n```", "```py\ndef extract_msg_body(msg, out_dir):\n    # Extract HTML Data\n    html_data = msg.HTMLBody.encode('cp1252')\n    outfile = os.path.join(out_dir, os.path.basename(args.MSG_FILE))\n    open(outfile + \".body.html\", 'wb').write(html_data)\n    print(\"Exported: {}\".format(outfile + \".body.html\"))\n\n    # Extract plain text\n    body_data = msg.Body.encode('cp1252')\n    open(outfile + \".body.txt\", 'wb').write(body_data)\n    print(\"Exported: {}\".format(outfile + \".body.txt\"))\n```", "```py\ndef extract_attachments(msg, out_dir):\n    attachment_attribs = [\n        'DisplayName', 'FileName', 'PathName', 'Position', 'Size'\n    ]\n    i = 1 # Attachments start at 1\n    while True:\n        try:\n            attachment = msg.Attachments(i)\n        except pywintypes.com_error:\n            break\n```", "```py\n        print(\"\\nAttachment {}\".format(i))\n        print(\"=\" * 15)\n        for entry in attachment_attribs:\n            print('{}: {}'.format(entry, getattr(attachment, entry,\n                                                 \"N/A\")))\n        outfile = os.path.join(os.path.abspath(out_dir),\n                               os.path.split(args.MSG_FILE)[-1])\n        if not os.path.exists(outfile):\n            os.makedirs(outfile)\n        outfile = os.path.join(outfile, attachment.FileName)\n        attachment.SaveAsFile(outfile)\n        print(\"Exported: {}\".format(outfile))\n        i += 1\n```", "```py\nfrom __future__ import print_function\nfrom argparse import ArgumentParser\nimport mailbox\nimport os\nimport time\nimport csv\nfrom tqdm import tqdm\nimport base64\n```", "```py\nif __name__ == '__main__':\n    parser = ArgumentParser(\n        description=__description__,\n        epilog=\"Developed by {} on {}\".format(\n            \", \".join(__authors__), __date__)\n    )\n    parser.add_argument(\"MBOX\", help=\"Path to mbox file\")\n    parser.add_argument(\"OUTPUT_DIR\",\n                        help=\"Path to output directory to write report \"\n                        \"and exported content\")\n    args = parser.parse_args()\n\n    main(args.MBOX, args.OUTPUT_DIR)\n```", "```py\ndef main(mbox_file, output_dir):\n    # Read in the MBOX File\n    print(\"Reading mbox file...\")\n    mbox = mailbox.mbox(mbox_file, factory=custom_reader)\n    print(\"{} messages to parse\".format(len(mbox)))\n```", "```py\ndef custom_reader(data_stream):\n    data = data_stream.read()\n    try:\n        content = data.decode(\"ascii\")\n    except (UnicodeDecodeError, UnicodeEncodeError) as e:\n        content = data.decode(\"cp1252\", errors=\"replace\")\n    return mailbox.mboxMessage(content)\n```", "```py\n    parsed_data = []\n    attachments_dir = os.path.join(output_dir, \"attachments\")\n    if not os.path.exists(attachments_dir):\n        os.makedirs(attachments_dir)\n    columns = [\"Date\", \"From\", \"To\", \"Subject\", \"X-Gmail-Labels\",\n               \"Return-Path\", \"Received\", \"Content-Type\", \"Message-ID\",\n               \"X-GM-THRID\", \"num_attachments_exported\", \"export_path\"]\n```", "```py\n    for message in tqdm(mbox):\n        # Preserve header information\n        msg_data = dict()\n        header_data = dict(message._headers)\n        for hdr in columns:\n            msg_data[hdr] = header_data.get(hdr, \"N/A\")\n```", "```py\n        if len(message.get_payload()):\n            export_path = write_payload(message, attachments_dir)\n            msg_data['num_attachments_exported'] = len(export_path)\n            msg_data['export_path'] = \", \".join(export_path)\n```", "```py\n        parsed_data.append(msg_data)\n\n    # Create CSV report\n    create_report(\n        parsed_data, os.path.join(output_dir, \"mbox_report.csv\"), columns\n    )\n```", "```py\ndef write_payload(msg, out_dir):\n    pyld = msg.get_payload()\n    export_path = []\n    if msg.is_multipart():\n        for entry in pyld:\n            export_path += write_payload(entry, out_dir)\n```", "```py\n    else:\n        content_type = msg.get_content_type()\n        if \"application/\" in content_type.lower():\n            content = base64.b64decode(msg.get_payload())\n            export_path.append(export_content(msg, out_dir, content))\n        elif \"image/\" in content_type.lower():\n            content = base64.b64decode(msg.get_payload())\n            export_path.append(export_content(msg, out_dir, content))\n        elif \"video/\" in content_type.lower():\n            content = base64.b64decode(msg.get_payload())\n            export_path.append(export_content(msg, out_dir, content))\n        elif \"audio/\" in content_type.lower():\n            content = base64.b64decode(msg.get_payload())\n            export_path.append(export_content(msg, out_dir, content))\n        elif \"text/csv\" in content_type.lower():\n            content = base64.b64decode(msg.get_payload())\n            export_path.append(export_content(msg, out_dir, content))\n        elif \"info/\" in content_type.lower():\n            export_path.append(export_content(msg, out_dir,\n                                              msg.get_payload()))\n        elif \"text/calendar\" in content_type.lower():\n            export_path.append(export_content(msg, out_dir,\n                                              msg.get_payload()))\n        elif \"text/rtf\" in content_type.lower():\n            export_path.append(export_content(msg, out_dir,\n                                              msg.get_payload()))\n```", "```py\n        else:\n            if \"name=\" in msg.get('Content-Disposition', \"N/A\"):\n                content = base64.b64decode(msg.get_payload())\n                export_path.append(export_content(msg, out_dir, content))\n            elif \"name=\" in msg.get('Content-Type', \"N/A\"):\n                content = base64.b64decode(msg.get_payload())\n                export_path.append(export_content(msg, out_dir, content))\n\n    return export_path\n```", "```py\ndef export_content(msg, out_dir, content_data):\n    file_name = get_filename(msg)\n    file_ext = \"FILE\"\n    if \".\" in file_name:\n        file_ext = file_name.rsplit(\".\", 1)[-1]\n```", "```py\n    file_name = \"{}_{:.4f}.{}\".format(\n        file_name.rsplit(\".\", 1)[0], time.time(), file_ext)\n    file_name = os.path.join(out_dir, file_name)\n```", "```py\n    if isinstance(content_data, str):\n        open(file_name, 'w').write(content_data)\n    else:\n        open(file_name, 'wb').write(content_data)\n\n    return file_name\n```", "```py\ndef get_filename(msg):\n    if 'name=' in msg.get(\"Content-Disposition\", \"N/A\"):\n        fname_data = msg[\"Content-Disposition\"].replace(\"\\r\\n\", \" \")\n        fname = [x for x in fname_data.split(\"; \") if 'name=' in x]\n        file_name = fname[0].split(\"=\", 1)[-1]\n\n    elif 'name=' in msg.get(\"Content-Type\", \"N/A\"):\n        fname_data = msg[\"Content-Type\"].replace(\"\\r\\n\", \" \")\n        fname = [x for x in fname_data.split(\"; \") if 'name=' in x]\n        file_name = fname[0].split(\"=\", 1)[-1]\n```", "```py\n    else:\n        file_name = \"NO_FILENAME\"\n\n    fchars = [x for x in file_name if x.isalnum() or x.isspace() or\n              x == \".\"]\n    return \"\".join(fchars)\n```", "```py\ndef create_report(output_data, output_file, columns):\n    with open(output_file, 'w', newline=\"\") as outfile:\n        csvfile = csv.DictWriter(outfile, columns)\n        csvfile.writeheader()\n        csvfile.writerows(output_data)\n```", "```py\nsudo apt-get install automake autoconf libtool pkg-config autopoint git python-dev\n```", "```py\n./synclibs.sh\n./autogen.sh\nsudo python setup.py install \n```", "```py\nfrom __future__ import print_function\nfrom argparse import ArgumentParser\nimport csv\nimport pypff\nimport re\n```", "```py\nif __name__ == '__main__':\n    parser = ArgumentParser(\n        description=__description__,\n        epilog=\"Developed by {} on {}\".format(\n            \", \".join(__authors__), __date__)\n    )\n    parser.add_argument(\"PFF_FILE\", help=\"Path to PST or OST File\")\n    parser.add_argument(\"CSV_REPORT\", help=\"Path to CSV report location\")\n    args = parser.parse_args()\n\n    # Open file\n    pff_obj = pypff.file()\n    pff_obj.open(args.PFF_FILE)\n\n    # Parse and close file\n    parsed_data = process_folders(pff_obj.root_folder)\n    pff_obj.close()\n\n    # Write CSV report\n    write_data(args.CSV_REPORT, parsed_data)\n```", "```py\ndef process_folders(pff_folder):\n    folder_name = pff_folder.name if pff_folder.name else \"N/A\"\n    print(\"Folder: {} (sub-dir: {}/sub-msg: {})\".format(folder_name,\n          pff_folder.number_of_sub_folders,\n          pff_folder.number_of_sub_messages))\n```", "```py\n    # Process messages within a folder\n    data_list = []\n    for msg in pff_folder.sub_messages:\n        data_dict = process_message(msg)\n        data_dict['folder'] = folder_name\n        data_list.append(data_dict)\n\n    # Process folders within a folder\n    for folder in pff_folder.sub_folders:\n        data_list += process_folders(folder)\n\n    return data_list\n```", "```py\ndef process_message(msg):\n    # Extract attributes\n    attribs = ['conversation_topic', 'number_of_attachments',\n               'sender_name', 'subject']\n    data_dict = {}\n    for attrib in attribs:\n        data_dict[attrib] = getattr(msg, attrib, \"N/A\")\n\n    if msg.transport_headers is not None:\n        data_dict.update(process_headers(msg.transport_headers))\n\n    return data_dict\n```", "```py\ndef process_headers(header):\n    # Read and process header information\n    key_pattern = re.compile(\"^([A-Za-z\\-]+:)(.*)$\")\n    header_data = {}\n    for line in header.split(\"\\r\\n\"):\n        if len(line) == 0:\n            continue\n\n        reg_result = key_pattern.match(line)\n        if reg_result:\n            key = reg_result.group(1).strip(\":\").strip()\n            value = reg_result.group(2).strip()\n        else:\n            value = line\n\n        if key.lower() in header_data:\n            if isinstance(header_data[key.lower()], list):\n                header_data[key.lower()].append(value)\n            else:\n                header_data[key.lower()] = [header_data[key.lower()],\n                                            value]\n        else:\n            header_data[key.lower()] = value\n    return header_data\n```", "```py\ndef write_data(outfile, data_list):\n    # Build out additional columns\n    print(\"Writing Report: \", outfile)\n    columns = ['folder', 'conversation_topic', 'number_of_attachments',\n               'sender_name', 'subject']\n    formatted_data_list = []\n    for entry in data_list:\n        tmp_entry = {}\n\n        for k, v in entry.items():\n            if k not in columns:\n                columns.append(k)\n\n            if isinstance(v, list):\n                tmp_entry[k] = \", \".join(v)\n            else:\n                tmp_entry[k] = v\n        formatted_data_list.append(tmp_entry)\n```", "```py\n    # Write CSV report\n    with open(outfile, 'wb') as openfile:\n        csvfile = csv.DictWriter(openfile, columns)\n        csvfile.writeheader()\n        csvfile.writerows(formatted_data_list)\n```"]