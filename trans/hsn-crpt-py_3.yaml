- en: Strong Encryption
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强加密
- en: Strong encryption conceals data even against determined adversaries, such as
    enemy military agencies, if done correctly. The two main methods of strong encryption
    are AES and RSA, which are both approved by the US government. You do not need
    to have programming experience to learn this, and you don't need any special computer;
    any computer that can run Python can do these projects. Also, you don't need much
    math because we are not going to be inventing new encryption techniques just to
    learn how to use the standard pre-existing ones that don't require anything more
    than very basic algebra.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 强加密甚至可以对抗决心坚定的对手，比如敌对军事机构，如果做得正确的话。强加密的两种主要方法是AES和RSA，它们都得到了美国政府的批准。你不需要有编程经验来学习这个，也不需要任何特殊的计算机；任何能运行Python的计算机都可以完成这些项目。而且你不需要太多的数学，因为我们不打算发明新的加密技术，只是学习如何使用标准的现有的那些，这些不需要任何比基本代数更高级的东西。
- en: 'In this chapter, we will cover  pre-existing:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Strong encryption with AES
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AES强加密
- en: ECB and CBC modes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECB和CBC模式
- en: Padding oracle attack
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充预言攻击
- en: Strong encryption with RSA
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RSA强加密
- en: What's next?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来呢？
- en: Strong encryption with AES
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AES强加密
- en: In this section, we will take a look at the **Advanced Encryption Standard**
    (**AES**), private key encryption, key and block size, how to influence AES, and
    Python and confusion and diffusion.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一下**高级加密标准**（**AES**），私钥加密，密钥和块大小，如何影响AES，以及Python和混淆和扩散。
- en: 'AES is the encryption standard approved by the United States National Institute
    of Standards and is considered very secure. It''s approved even for the storage
    of secret military information. It is private key cryptography, which is the kind
    of cryptography that has been used for thousands of years in which both the sender
    and the receiver use the same key. It''s a block cipher, so the input data has
    to be put in blocks that are 128-bits long, and a block of plaintext is encrypted
    with a key, producing a block of ciphertext:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: AES是美国国家标准技术研究所批准的加密标准，被认为非常安全。它甚至被批准用于保管机密军事信息。它是私钥加密，这是几千年来一直在使用的加密类型，发送方和接收方都使用相同的密钥。它是块密码，因此输入数据必须放在长度为128位的块中，明文块用密钥加密，产生密文块：
- en: '![](../images/00070.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00070.jpeg)'
- en: 'There are three key sizes: 128, 192, and 256-bits. The most common type of
    AES is the 128-bit key size, and that''s what we''ll use in this example. In Python,
    it''s quite easy to use.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种密钥大小：128、192和256位。最常见的AES类型是128位密钥大小，这就是我们在这个例子中要使用的。在Python中，使用起来非常容易。
- en: Firstly, you need to import the `AES` module from `crypto cipher`, then you
    need a 16-byte key and plaintext, which is some integral multiple of 16 bytes.
    You will then create a new AES object with the key and then calculate it with
    cipher encrypt. This gives you a 16-byte string, which may be unprintable, so
    it's best to encode it as hex to print it out; and, of course, if you decrypt
    it, you get back to your original plaintext. This has many desirable cryptographic
    properties, and one of them is confusion. If you change a bit of the key, it changes
    the entire ciphertext.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要从`crypto cipher`导入`AES`模块，然后你需要一个16字节的密钥和明文，这是16字节的整数倍。然后你将用密钥创建一个新的AES对象，然后用密码加密计算它。这会给你一个16字节的字符串，可能是不可打印的，所以最好将其编码为十六进制以打印出来；当然，如果你解密它，你会回到原始的明文。这具有许多理想的加密属性，其中之一是混淆。如果你改变密钥的一位，它会改变整个密文。
- en: So, if we change the key to `kex`, you will see that all of the ciphertext changes.
    This is what you want. Two very similar keys produce completely different results,
    so you cannot find any pattern in the results that you could use to deduce information
    about the key.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们将密钥改为`kex`，你会看到所有的密文都改变了。这就是你想要的。两个非常相似的密钥会产生完全不同的结果，因此你无法找到任何模式来推断密钥的信息。
- en: 'Similarly, diffusion is a desirable property, where if you encrypt something
    twice with the same key but you change even one bit of the plaintext, again, the
    entire ciphertext changes. See the following example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，扩散是一种理想的属性，如果你用相同的密钥对同一明文进行两次加密，但你改变了明文的一位，整个密文再次改变。看下面的例子：
- en: '![](../images/00071.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00071.jpeg)'
- en: Here we have bytes and we get the same `433` ending in `6a8`. If we change the
    last letter to `t`, you can see that it starts with `90c` and ends with `5d2`;
    that is, it completely changes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有字节，得到相同的`433`结尾于`6a8`。如果我们把最后一个字母改成`t`，你会发现它以`90c`开头，以`5d2`结尾；也就是说，它完全改变了。
- en: 'Let''s take a look at that in Python:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python中看一下：
- en: 'Open the Terminal window and start `python`. We will enter the following command,
    as shown in the sceenshot:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端窗口并启动`python`。我们将输入以下命令，如截图所示：
- en: '![](../images/00072.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00072.jpeg)'
- en: 'We import the `AES` module, where we have a 16-byte key and a 16-byte plaintext.
    We have created an AES object, encrypted it, and then we have printed out the
    hex value over here:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入`AES`模块，有一个16字节的密钥和一个16字节的明文。我们创建了一个AES对象，对其进行了加密，然后我们在这里打印出了十六进制值：
- en: '![](../images/00073.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00073.jpeg)'
- en: 'Now, we change the key:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们改变密钥：
- en: '![](../images/00074.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00074.jpeg)'
- en: Here we go up to the key line and change that to say `z`, and then do it again,
    creating a new AES object with that key. Performing the encryption and printing
    out the results again, you see everything is different.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来到密钥行，将其改为`z`，然后再次进行操作，用该密钥创建一个新的AES对象。进行加密并再次打印出结果，你会看到一切都不同了。
- en: It now starts with `b`, ends with `4`, and has completely changed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它以`b`开头，以`4`结尾，完全改变了。
- en: 'Now, we''ll leave the key where it is and change the plaintext. Let''s change
    `t` to `F`. Now if we encrypt that and print out the result in hexadecimal, once
    again, everything has changed; even though this is the same key as the one above
    it:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将保留密钥不变，改变明文。让我们把`t`改成`F`。现在如果我们加密它并以十六进制打印出结果，一切又都改变了；尽管这与上面的密钥相同：
- en: '![](../images/00075.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00075.jpeg)'
- en: So, this shows both confusion and diffusion, which are desirable properties.
    In the next section, we'll discuss ECB and CBC modes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这显示了混淆和扩散，这是可取的特性。在下一节中，我们将讨论ECB和CBC模式。
- en: ECB and CBC modes
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECB和CBC模式
- en: We'll compare **E****lectronic Codebook** (**ECB**) and **Cipher Block Chaining**
    (**CBC**) and show you how to implement AES CBC in Python.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将比较**电子密码本**（**ECB**）和**密码块链接**（**CBC**）并向您展示如何在Python中实现AES CBC。
- en: ECB
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECB
- en: 'In the ECB method, each block of plaintext is encrypted with the key separately,
    so if you have two blocks of plaintext that are the same, they will result in
    identical ciphertext:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECB方法中，每个明文块都分别使用密钥加密，因此如果你有两个相同的明文块，它们将产生相同的密文：
- en: '![](../images/00076.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00076.jpeg)'
- en: 'If you have something like an image here with large areas of solid colors such
    as gray and black and then you encrypt it, you''ll just get different colors but
    the pattern won''t change:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一张图片，上面有大片的纯色，比如灰色和黑色，然后你加密它，你会得到不同的颜色，但图案不会改变：
- en: '![](../images/00077.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00077.jpeg)'
- en: That's not good. You can still see that this is a picture of a penguin, and
    that's not what most people expect out of encryption. You expect the encryption
    to conceal the data so attackers looking at the encrypted data can't tell what
    the message is, and here that property is not present.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这不好。你仍然可以看到这是一只企鹅的图片，这不是大多数人对加密的期望。你期望加密隐藏数据，以便查看加密数据的攻击者无法知道消息是什么，而这里这种属性是不存在的。
- en: Thus, CBC is considered the best solution to this problem.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，CBC被认为是这个问题的最佳解决方案。
- en: CBC
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CBC
- en: 'In addition to the key, you add an initialization vector, which is XOR''d with
    the plaintext before encryption. Then for the next block, you take the ciphertext
    produced by encryption and use it as the initialization vector for the second
    block. The output of that is used as the initialization vector for the third block.
    Thus, even if the inputting plaintext is the same in every block, the ciphertext
    will be different in each block:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了密钥，你还需要添加一个初始化向量，它在加密之前与明文进行异或运算。然后对于下一个块，你取加密产生的密文，并将其用作第二个块的初始化向量。第三个块的输出被用作第三个块的初始化向量。因此，即使每个块中的输入明文相同，每个块中的密文也会不同：
- en: '![](../images/00078.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00078.jpeg)'
- en: 'This results in far more obfuscation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致更多的混淆：
- en: '![](../images/00079.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00079.jpeg)'
- en: You can see that the penguin is now completely invisible and all the bytes are
    just random, so this is preferred from almost every purpose.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到企鹅现在完全看不见，所有字节都是随机的，所以这几乎是每个目的的首选。
- en: To do it in Python, here's how we did the previous AES, which was the EBC mode.
    By default, you don't specify the mode.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python中执行它，这是我们之前在EBC模式下执行的AES的方法。默认情况下，你不需要指定模式。
- en: 'If you want to use CBC mode, you put the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用CBC模式，你可以输入以下命令：
- en: '![](../images/00080.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00080.jpeg)'
- en: AES mode CBC when you create the cipher object. You also have to provide an
    initialization vector, which can be 16 bytes, just like the key. If you encrypt
    one block of 16 bytes of text, there's no obvious difference in the result because
    of the initialization vector, but it's just a block of hexadecimal. To see the
    effect of this, you need to make the plaintext longer. When you encrypt it, you
    get a blob of hexadecimal. That's the ECB mode, which does not remove all the
    patterns in the data. Here's the CBC mode with the same repeating input. As you
    can see, the output has no pattern, and does not repeat however far you go. So,
    it much more effectively conceals the data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: AES模式CBC当你创建密码对象时。你还需要提供一个初始化向量，它可以是16字节，就像密钥一样。如果你加密16字节的文本块，由于初始化向量，结果中没有明显的差异，但它只是一个十六进制块。要看到这种效果，你需要使明文更长。当你加密它时，你会得到一个十六进制的块。这就是ECB模式，它并没有消除数据中的所有模式。这是具有相同重复输入的CBC模式。正如你所看到的，输出没有模式，并且无论你走多远，都不会重复。因此，它更有效地隐藏了数据。
- en: 'Let''s take a look at that. We start Python in the Terminal, and then add this
    code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看。我们在终端中启动Python，然后添加这段代码：
- en: '![](../images/00081.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00081.jpeg)'
- en: So, you can see the 16-byte key and the 16-byte plaintext AES in ECB mode. We
    encrypt it and print the answer.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以看到16字节的密钥和16字节的AES明文在ECB模式下。我们对其进行加密并打印答案。
- en: 'If we want to make it longer, we add this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使它更长，我们添加这个：
- en: '![](../images/00082.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00082.jpeg)'
- en: You can multiply a string object in Python and if you just print it out, you'll
    see it's just the same thing three times.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python中对字符串对象进行乘法运算，如果你只是打印它出来，你会看到它只是同样的东西三次。
- en: 'Now we can encrypt that `plain3`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以加密`plain3`：
- en: '![](../images/00083.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00083.jpeg)'
- en: 'When we print that out, it''ll have that repeating pattern for 33\. Now, if
    we change the mode, we''ll need an `iv`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印出来时，它将在33处有重复的模式。现在，如果我们改变模式，我们需要一个`iv`：
- en: '![](../images/00084.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00084.jpeg)'
- en: We just need 16 bytes, so we'll just 16 bytes to `iv`. Next, we create a new
    `AES` object. In the `iv` now, we encryp `plain3` again, and we print out the
    result again.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要16个字节，所以我们将16个字节添加到`iv`。接下来，我们创建一个新的`AES`对象。现在，在`iv`中，我们再次加密`plain3`，然后再次打印出结果。
- en: You see it has `61f`, and you can see that there's no longer any repetition.
    So, this is a much more effective way to encrypt things if you really want to
    obscure the input.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到它有`61f`，你可以看到不再有重复。因此，如果你真的想要模糊输入，这是一种更有效的加密方式。
- en: Padding oracle attack
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充预言攻击
- en: 'In this section, we will see how padding works in the PKCS # 7 system and then
    show you a system with the `PADDING ERROR` message. Plus, we''ll also deal with
    the padding oracle attack, which makes it possible to craft ciphertext that will
    decode 20 plaintext we want.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到PKCS＃7系统中填充的工作原理，然后向您展示带有“PADDING ERROR”消息的系统。此外，我们还将处理填充预言攻击，这使得可能制作解码我们想要的20个明文的密文。
- en: 'Here is the encryption routine:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是加密例程：
- en: '![](../images/00085.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00085.jpeg)'
- en: We'll have three blocks of data, each 16-bytes long. We'll encrypt the data
    with AES in CBC mode, so in comes the initialization vector and the key. You produce
    three blocks of ciphertext, and each one of the blocks after the first uses the
    output of the previous encryption routine as an initialization vector to XOR with
    the plaintext.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有三个数据块，每个块长16字节。我们将使用AES在CBC模式下加密数据，因此初始化向量和密钥就会出现。你会产生三个密文块，第一个块之后的每一个块都使用前一个加密例程的输出作为初始化向量与明文进行异或。
- en: 'Here''s how PKCS#7 padding works:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是PKCS#7填充的工作方式：
- en: If one byte of padding is needed, use `01`
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要一个字节的填充，使用`01`
- en: If two bytes of padding are needed, use `0202`
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要两个字节的填充，使用`0202`
- en: If three bytes of padding are needed, use `030303`
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要三个字节的填充，使用`030303`
- en: And so on...
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等等...
- en: 'If we have a message here that is only 47-bytes long, then we can''t fill the
    last block, so we have to add a byte of padding. You could use a variety of numbers
    as the padding, but in this system, we use one binary value one, if you have one
    byte of padding needed if you have two, you use two for both bytes and three for
    all three bytes for three bytes of padding and so on. This means that, if we decrypt
    it, we''ll have three blocks of ciphertext. We decrypt it and we''ll get the 47-byte
    message:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这里的消息只有47个字节长，那么我们无法填满最后一个块，所以我们必须添加一个字节的填充。你可以使用各种数字作为填充，但在这个系统中，我们使用一个二进制值1，如果你需要一个字节的填充，如果你需要两个字节，你就用两个字节，如果你需要三个字节的填充，你就用三个字节。这意味着，如果我们解密它，我们将得到三个密文块。我们解密它，我们将得到47字节的消息：
- en: '![](../images/00086.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00086.jpeg)'
- en: The last byte here will always be the padding byte, and that will be `0-1`,
    a binary value of `1`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的最后一个字节将始终是填充字节，即`0-1`，二进制值为`1`。
- en: Here is an example of a vulnerable system that you can attack. This is just
    using the same techniques we've made before where we just encrypt things with
    AES and CBC mode, which you can save in `pador.py`, and then you can just import
    it to make it easy to use and more realistic. There have been real systems that
    use this. So, we import, encrypt, and decrypt methods so that we can put in a
    47-pipe message and encrypt it. We'll get a long blob of hexadecimal output.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个易受攻击的系统的示例。这只是使用我们以前制作的相同技术，我们只是用AES和CBC模式加密东西，你可以保存在`pador.py`中，然后你可以导入它以使其易于使用和更加现实。已经有真实的系统使用了这个。所以，我们导入，加密和解密方法，以便我们可以输入一个47个字节的消息并对其进行加密。我们将得到一个长长的十六进制输出。
- en: If we decrypt that, we will get our original input plus one byte of `0`1 at
    the end. x01 is the Python notation for a single byte with the binary value of
    `1`. If you modify the input by keeping the first 47 bytes alone and changing
    the last byte to `A` or `65` and decrypt it, you'll get a padding error. This
    error message may seem harmless, but in fact it makes it possible to completely
    subvert the encryption.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们解密它，我们将得到我们原始的输入加上一个字节的`0`1。x01是Python表示法，表示二进制值为`1`的单个字节。如果你修改输入，保持前47个字节不变，并将最后一个字节更改为`A`或`65`并解密它，你将得到一个填充错误。这个错误消息看起来可能无害，但实际上它可能完全颠覆加密。
- en: 'Let''s take a look at that:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看：
- en: Open the Terminal and start `python`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并启动`python`。
- en: 'We will enter the following command:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将输入以下命令：
- en: '![](../images/00087.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00087.jpeg)'
- en: 'We will encrypt and decrypt routines. You can see we have the plaintext. When
    we encrypt 47 bytes of plaintext, we get a long binary blob:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将加密和解密例程。你可以看到我们有明文。当我们加密47个字节的明文时，我们得到一个长长的二进制块：
- en: '[PRE0]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we decrypt that, we get the following:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们解密时，我们得到以下结果：
- en: '![](../images/00088.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00088.jpeg)'
- en: We can see that it in fact added the single byte of padding at the end of it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，它实际上在末尾添加了一个字节的填充。
- en: 'Now, we should do the deformed one. If we set our modified text equal to the
    original plaintext going up to character `47` and then we add `"A"` at the end,
    when we decrypt it, we get `''PADDING ERROR''`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该做变形的。如果我们将我们修改后的文本设置为原始明文，直到第47个字符，然后我们在末尾添加`"A"`，当我们解密它时，我们得到`'PADDING
    ERROR'`：
- en: '![](../images/00089.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00089.jpeg)'
- en: 'That is the error message that we can exploit to subvert the system. So, here''s
    how the padding oracle attacked works change:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以利用来颠覆系统的错误消息。所以，填充预言攻击的工作方式如下更改：
- en: Change ciphertext `[16:31]` to any bytes
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将密文`[16:31]`更改为任何字节
- en: Change ciphertext `[31]` until padding is valid
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改密文`[31]`直到填充有效。
- en: Intermediate `[47]` must be `1`
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中间`[47]`必须是`1`
- en: 'Here is a diagram of CBC:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是CBC的图示：
- en: '![](../images/00090.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00090.jpeg)'
- en: Leave the first 16 bytes of the ciphertext alone. Change this to anything you
    like, such as all-As, and then decrypt that. What will happen is, because you
    changed the bytes in the second block, the second block will turn to random characters,
    and so will the third block. But it'll give you a padding error unless the, very
    last byte  of the very last block is one. So, you brute force it. You change a
    byte to all 256 possible values until the byte becomes `1`, and when that happens,
    you know this value is `1`. You know this value because it's the one that did
    not give you a padding error message, and you can XOR them to determine this intermediate
    value right here. So, proceeding byte by byte to the left, you can determine these
    intermediate values. If you know them, you can put in ciphertext that will make
    anything you like appear in the third block. So, you can defeat the encryption
    even though you don't know the key or the initialization vector.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 保持密文的前16个字节不变。将其更改为任何你喜欢的东西，比如全A，然后解密。会发生的是，因为你改变了第二个块中的字节，第二个块将变成随机字符，第三个块也是如此。但除非最后一个块的最后一个字节是1，否则会出现填充错误。所以，你可以用穷举法。你将一个字节更改为所有256个可能的值，直到该字节变为`1`，当发生这种情况时，你就知道这个值是`1`。你知道这个值，因为它没有给你一个填充错误消息，你可以对它们进行异或运算，以确定这个中间值。因此，逐个字节向左进行，你可以确定这些中间值。如果你知道它们，你可以输入密文，使得你喜欢的任何东西出现在第三个块中。因此，即使你不知道密钥或初始化向量，你也可以打败加密。
- en: 'Here''s the code that does it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行此操作的代码：
- en: '![](../images/00091.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00091.jpeg)'
- en: 'And will get the following output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 并将得到以下输出：
- en: '![](../images/00092.jpeg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00092.jpeg)'
- en: 'We set the ciphertext equal to the first original 16 bytes of ciphertext and
    then 15 bytes of `A`. Then we vary the next byte through all possible `256` values
    and add the third block of data unchanged. After that, we look to see when we
    no longer get a padding error, and that will be `234`, so the intermediate value
    is `234` XOR one:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将密文设置为原始密文的前16个字节，然后是15个`A`。然后，我们改变下一个字节的所有可能的`256`个值，并且保持第三个数据块不变。之后，我们查看何时不再出现填充错误，那将是`234`，因此中间值是`234`异或一：
- en: 'Now, if we want to get the next byte back, we have to arrange two bytes of
    padding, both of which will be `2`, as shown:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们想要得到下一个字节，我们必须安排两个字节的填充，两者都将是`2`，如下所示：
- en: '![](../images/00093.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00093.jpeg)'
- en: So, the final two bytes of ciphertext `46` and `47` will both be two. So, we
    set ciphertext `31` to the value needed to create two there. Now that we know
    the intermediate value, we can calculate it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，密文的最后两个字节`46`和`47`都将是两。因此，我们将密文`31`设置为创建两个所需的值。现在我们知道中间值，我们可以计算它。
- en: 'We vary ciphertext `30` until the padding is valid and that will determine
    the next byte of the intermediate:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们改变密文`30`直到填充有效，这将确定中间的下一个字节：
- en: '![](../images/00094.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00094.jpeg)'
- en: 'Leave the first block unchanged and add 14 bytes of a vary the next byte. Leave
    the byte at the chosen value of `233` so you know that the final byte of the decrypted
    output will be `2`, and when the padding error message goes away, you can take
    that number, XOR it with `2`, and you get the next value of the intermediate.
    So, now we can make messages. We would have to repeat this more times to get more
    bytes, but for this demonstration, we''ll settle for a message just one letter
    long. We''ll make an `A` followed by a binary value of `1` for valid padding.
    That''s our goal, and in order to do that, all we have to do is set ciphertext
    `30` and `31` to these chosen values:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持第一个块不变，并添加14个字节的变化下一个字节的填充。保持所选值为`233`的字节，这样你就知道解密输出的最后一个字节将是`2`，当填充错误消息消失时，你可以拿这个数字，与`2`异或，得到中间值的下一个值。因此，现在我们可以制作消息。我们必须重复这个过程更多次以获得更多字节，但是对于这个演示，我们将只接受一个字母长的消息。我们将制作一个以`A`开头，后面跟着一个二进制值为`1`的有效填充。这是我们的目标，为了做到这一点，我们只需要将密文`30`和`31`设置为这些选择的值：
- en: '`ciphertext[30] = ord("A") ^ 113`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ciphertext[30] = ord("A") ^ 113`'
- en: '`ciphertext[31] = 16 235`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ciphertext[31] = 16 235`'
- en: Since we know the intermediate values are `113` and `235`, we just need to XOR
    these intermediate values with the values we want.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为我们知道中间值是`113`和`235`，我们只需要用我们想要的值异或这些中间值。
- en: 'We will create ciphertext that will decrypt to a message ending in `A` and
    a binary `1`, so let''s see that go. Now, this one is a little complicated, so
    we''ve chosen to save some of the text here in a text editor so we can do it stage
    by stage:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个解密为以`A`结尾和二进制`1`的消息的密文，让我们看看它是如何进行的。现在，这个有点复杂，所以我们选择在文本编辑器中保存一些文本，这样我们可以逐个阶段地进行：
- en: '![](../images/00095.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00095.jpeg)'
- en: 'Here''s our Python:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们的Python代码：
- en: '[PRE1]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alright, we import the library, which we already had anyway. Here we leave
    the first 16 bytes unchanged and fill in 15 bytes with `A`. Then, we have the
    loop that changes the next byte''s every possible value and leave the third block
    of data unchanged. We run through the loop until we no longer get a padding error.
    This tells us that `234` is the value that gives us correct padding:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，我们导入了库，我们已经有了。在这里，我们保持前16个字节不变，并用15个`A`填充。然后，我们有一个循环，改变下一个字节的每个可能的值，并保持第三个数据块不变。我们运行循环，直到不再出现填充错误。这告诉我们`234`是给我们正确填充的值：
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So, we take `234` to the `1`, which tells us the intermediate value, all over
    cut the indentation right, so it''s `234` XOR `1`. This tells us that the value
    is `235`. That''s the intermediate value. For the next bit, use a very similar
    process, so now we have 14 bytes of padding. We will vary the next byte, and the
    byte after that is `233`, which is chosen to always give us a `2` at the end.
    So, when we run this loop through, it is correctly padded at `115`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们将`234`带到`1`，这告诉我们中间值，所有的缩进都被切断了，所以是`234`异或`1`。这告诉我们值是`235`。这是中间值。对于下一个位，使用非常相似的过程，所以现在我们有14个字节的填充。我们将改变下一个字节，接下来的字节是`233`，始终选择为`2`。因此，当我们通过这个循环运行时，它在`115`处被正确填充：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, `115` XOR `2` is `113`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，`115`异或`2`是`113`：
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Therefore, `113` is the next byte of intermediate value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`113`是中间值的下一个字节。
- en: 'Now that we know these two numbers, `235` and `113`, we can control the last
    two bytes of plaintext. Now we will keep the first block of input data unchanged.
    We have 14 bytes of padding:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道这两个数字`235`和`113`，我们可以控制明文的最后两个字节。现在我们将保持输入数据的第一个块不变。我们有14个字节的填充：
- en: '[PRE5]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We choose to make `A` and a binary one with the two bytes, `235` and `113`.
    When we create the modified ciphertext and decrypt it, we get the following message:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择用两个字节`235`和`113`来制作`A`和一个二进制`1`。当我们创建修改后的密文并解密它时，我们得到以下消息：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first block of data is unmodified. The second block and most of the third
    block have changed to random characters, but we controlled the last two bytes
    and we could make them say anything we wanted. So, we are able to create ciphertext
    that will decrypt at least partly two values we choose, even though we don't know
    the key or the initialization vector.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的第一个块没有被修改。第二个块和大部分第三个块已经改变为随机字符，但我们控制了最后两个字节，我们可以让它们说我们想要的任何东西。因此，我们能够创建一个解密至少部分为我们选择的两个值的密文，即使我们不知道密钥或初始化向量。
- en: Strong encryption with RSA
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RSA进行强加密
- en: In this section, we will cover public key encryption, the RSA algorithm, and
    implementation in Python.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍公钥加密、RSA算法以及在Python中的实现。
- en: Public key encryption
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公钥加密
- en: 'In public key encryption, we solve this problem: Google, for example, wants
    to receive confidential data from users, such as passwords and credit card numbers,
    but they don''t have a secure communication channel; what they have is the public
    internet, and any data being sent might be eavesdropped upon by any number of
    attackers. Thus, there''s no way to deliver a shared secret key, and symmetric
    encryption algorithms, such as AES, cannot solve this problem. That''s where public
    key encryption comes in.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在公钥加密中，我们解决了这个问题：例如，谷歌想要从用户那里接收机密数据，例如密码和信用卡号，但他们没有安全的通信渠道；他们拥有的是公共互联网，发送的任何数据都可能被任意数量的攻击者窃听。因此，没有办法交付共享的秘密密钥，对称加密算法，例如AES，无法解决这个问题。这就是公钥加密的作用。
- en: Google creates a key pair. They keep the private key secret and don't tell anyone,
    and they publish public key so anyone can know it. Everyone who wants to send
    secrets to Google can encrypt them with the public key and send them over an insecure
    channel because the only one who can decrypt them is Google, who has the private
    key. Mailboxes work like this. Anybody can go to the mailbox and put mail in the
    top slot, but the bottom door is locked, and only the postal worker with the private
    key can take the mail out. The private key and the public key must be related,
    but they have to be related by a one-way function so that it's easy to calculate
    the public key from the private key, which is what Google has to do when they
    first set up their key pair. But it has to be very difficult to calculate the
    private key from the public key, so it's safe to publish the public key and no
    one's going to find the private key.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌创建了一对密钥。他们保持私钥保密，不告诉任何人，并且公开公钥，以便任何人都可以知道。想要向谷歌发送秘密信息的人可以用公钥加密它们，然后通过不安全的渠道发送，因为唯一能解密的是谷歌，谷歌拥有私钥。邮箱的工作原理就是这样。任何人都可以去邮箱把信放在顶部槽里，但底部的门是锁着的，只有拥有私钥的邮递员才能把信拿出来。私钥和公钥必须有关联，但它们必须通过单向函数相关联，以便从私钥轻松计算出公钥，这是谷歌在首次设置密钥对时必须做的。但是从公钥计算出私钥必须非常困难，因此公开公钥是安全的，没有人会找到私钥。
- en: RSA algorithm
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RSA算法
- en: 'There are various one-way functions that can be used for this purpose, but
    in RSA, the function is factoring a large number:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种单向函数可以用于此目的，但在RSA中，该函数是分解一个大数：
- en: 'Private key `d` is made from two large prime numbers: `p` and `q`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私钥`d`由两个大素数`p`和`q`组成
- en: Public key is the product of `n = p * q`, and and arbitrary value `e`
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公钥是`n = p * q`的乘积，以及任意值`e`
- en: If `p` and `q` are large, factoring `n` into `p` and `q` is very difficult
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`p`和`q`很大，将`n`分解为`p`和`q`是非常困难的
- en: 'If you multiply the two prime numbers `p` and `q` together to create their
    product `n`, it is a well-known difficult problem to factor `n` into `p` and `q`.
    And if `p` and `q` are large enough, it becomes essentially impossible. This is
    the one-way function. You can easily multiply `p` and `q` to create the public
    key `n`, but knowledge of the public key cannot be used to determine `p` and `q`
    practically:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将两个素数`p`和`q`相乘以创建它们的乘积`n`，那么将`n`分解为`p`和`q`是一个众所周知的困难问题。如果`p`和`q`足够大，这几乎是不可能的。这就是单向函数。你可以轻松地将`p`和`q`相乘以创建公钥`n`，但是公钥的知识不能用于实际确定`p`和`q`：
- en: '**Public key**: This is two numbers, `(n,e)`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公钥**：这是两个数字`(n,e)`'
- en: '`e` can be any prime number, often `65537`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e`可以是任何素数，通常是`65537`'
- en: '**Encryption**: `y = x^(e )mod n`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密**：`y = x^(e)mod n`'
- en: '**Decryption**: `x = y^d mod n `'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解密**：`x = y^d mod n`'
- en: '`x` is plaintext, `y` is ciphertext'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`是明文，`y`是密文'
- en: 'So, the public key is `n`, which is the product of two prime numbers and another
    arbitrary number, `e`, which is often just this value `65,537`. Anyone who wishes
    to secretly send their plaintext, `x`, raises it to the power of `e`, modulus
    `n`, and sends that scrambled stuff over an insecure channel, such as the internet,
    to the recipient. The recipient has the private key so they can find the decryption
    key, `d`, and they take the ciphertext to `d` modulus `n`, and that turns into
    the decrypted message. The decryption key is calculated this way:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，公钥是`n`，它是两个素数的乘积和另一个任意数`e`，通常只是这个值`65,537`。任何希望秘密发送明文`x`的人，将其提升到`e`的幂，模`n`，并将其加密的内容发送到不安全的渠道，例如互联网，给接收者。接收者有私钥，因此可以找到解密密钥`d`，并将密文取模`n`，然后变成解密的消息。解密密钥是这样计算的：
- en: '`phin = (p-1) * (q-1)`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`phin = (p-1) * (q-1)`'
- en: '`d*e  = 1 mod phin`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d*e = 1 mod phin`'
- en: Since Google knows the `p` and `q` secrets, they can calculate this number `phin`
    which is `p - 1`, times `q - 1` and then they choose a decryption key so that
    `d` times `e` is `1` modulus `Phi` of `n`. Nobody else can do this calculation
    because they do not know the values of `p` and `q`. So, in Python, you can import
    the `RSA` module and then generate a key of whatever length you like. In this
    example, we have used `2048` bits, which is the current National Institute of
    Standards recommendation. Then, they have a public key. There's a message to encrypt
    and you encrypt it, and the result is this very long ciphertext, which is as long
    as `2048` bits. ciphertext is long and the calculations are very slow, so you
    do not normally send a long message with this method. What you do in RSA is just
    send a secret key, and then you use AES to encrypt everything after that point
    to make the calculations faster. This chapter covers something called textbook
    RSA, which contains many of the essential ingredients but is not really secure
    enough for real use, because you have to add a padding that is specified in RFC
    8017\. This adds a hash value, a mask, and padding to the message and protects
    the key from some attacks. Let's take a look at this in Python.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Google知道`p`和`q`的秘密，他们可以计算出这个数字`phin`，即`p - 1`乘以`q - 1`，然后他们选择一个解密密钥，使得`d`乘以`e`对`Phi`的`n`取模等于`1`。其他人无法进行这种计算，因为他们不知道`p`和`q`的值。因此，在Python中，您可以导入`RSA`模块，然后生成任意长度的密钥。在这个例子中，我们使用了`2048`位，这是当前国家标准研究所的推荐。然后，他们有一个公钥。有一条要加密的消息，你加密它，结果是这个非常长的密文，长度为`2048`位。密文很长，计算速度很慢，所以你通常不会用这种方法发送长消息。在RSA中，你只需要发送一个秘密密钥，然后你使用AES来加密之后的所有内容，以加快计算速度。本章介绍了一种称为教科书RSA的东西，其中包含许多基本要素，但实际上并不足够安全，因为你必须添加一个在RFC
    8017中指定的填充。这会向消息添加哈希值、掩码和填充，并保护密钥免受一些攻击。让我们在Python中看一下这个。
- en: Implementation in Python
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的实现
- en: 'Here is how we can implement what we''ve talked about in Python:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何在Python中实现我们所讨论的内容：
- en: 'We start up `python` and then add the following code:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们启动`python`，然后添加以下代码：
- en: '![](../images/00096.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00096.jpeg)'
- en: 'The last step shown takes around 2 to 4 seconds just to generate the key; that''s
    because it had to find two large prime numbers, and these are very difficult calculations:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所示的最后一步大约需要2到4秒钟才能生成密钥；这是因为它必须找到两个大素数，而这些是非常困难的计算：
- en: '![](../images/00097.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00097.jpeg)'
- en: 'It has to guess a number and test it, and typically, it has to try more than
    a hundred guesses for each of these large prime numbers, so this process is very
    time-consuming. However, it happens automatically, and now we can encrypt the
    message with the key, producing this very long ciphertext:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它必须猜一个数字并测试它，通常情况下，它必须为每个大素数尝试超过一百次猜测，因此这个过程非常耗时。但是，这是自动发生的，现在我们可以用密钥加密消息，生成这个非常长的密文：
- en: '![](../images/00098.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00098.jpeg)'
- en: 'Now, we could test this to see whether we change one bit of the message or
    take the plaintext and change that last letter to an `f`. If we encrypt that,
    the results will be similar to the following:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以测试一下，看看我们是否改变了消息的一个比特，或者将明文的最后一个字母改为`f`。如果我们加密这个，结果将类似于以下内容：
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we print the results:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们打印结果：
- en: '![](../images/00099.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00099.jpeg)'
- en: As you can see, all `4ac` go to `1dc`, and then it ends at `578` to `633`. This
    is the desirable property of strong encryption. Any change in the input changes
    all of the output clipping approximately half the bits.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，所有的`4ac`都变成了`1dc`，然后结束于`578`到`633`。这是强加密的理想特性。输入的任何更改都会改变所有输出，剪辑大约一半的位数。
- en: Challenge – cracking RSA with similar factors
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挑战-用类似的因子破解RSA
- en: In this section, we will cover topics such as large integers–in Python and the
    `decimal` library. We will also take a look at an example of factoring a large
    number and then two challenges for you to solve.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖诸如大整数-在Python和`decimal`库中的主题。我们还将看一个大数因式分解的例子，然后为您提供两个挑战来解决。
- en: Large integers in Python
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的大整数
- en: 'Python can do multiplication and division–and a contented multiplication and
    division of arbitrarily large integers with complete precision:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Python可以进行乘法和除法-并且可以完全精确地进行任意大的整数的乘法和除法：
- en: '![](../images/00100.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00100.jpeg)'
- en: If we have `1001` and then we calculate `1001` squared, we get the right answer,
    of course; and even if we take a number like `10**100 + 1`, it correctly gets
    that number a hundred places with a `1` at each end. Now, if we square that number,
    it again gets it correct, all the way to the one at each end.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有`1001`，然后计算`1001`的平方，我们当然会得到正确的答案；即使我们取一个像`10**100 + 1`这样的数字，它也能正确地得到这个数字的一百位数，每一端都是`1`。现在，如果我们再对这个数字求平方，它也能正确地得到它的一百位数，每一端都是`1`。
- en: 'So, for simple integer operations, Python''s precision is unlimited. However,
    if we want to square root, we need to import a `math` library:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于简单的整数运算，Python的精度是无限的。但是，如果我们想要平方根，我们需要导入`math`库：
- en: '![](../images/00101.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00101.jpeg)'
- en: The `math` library does not keep any arbitrary number of places, as you can
    see in the preceding code. If we take `10 **100 + 1` and square it, then take
    the square root, we don't get `10 **100 + 1`. We get `10 ** 100`, which means
    it rounded off to some number of places less than `100`, and that's fine for many
    purposes. However, it's not fine for what we want to do here, which is factor
    large integers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，`math`库不保留任意数量的位数。如果我们取`10 **100 + 1`并对其求平方，然后取平方根，我们得到的不是`10
    **100 + 1`。我们得到的是`10 ** 100`，这意味着它舍入到了少于`100`位数的一些数字，对于许多目的来说这是可以接受的。但是，对于我们想要做的事情来说不够，我们想要因式分解大整数。
- en: 'In order to do that, you use the `decimal` library, and we will import it as
    shown:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，您使用`decimal`库，并按照所示导入它：
- en: '![](../images/00102.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00102.jpeg)'
- en: As you can see, we have imported the `decimal` library and set value to `a`
    as `10 **100+ 1`. Here `b` equals to a squared, and then instead of calculating
    the square root of `b` with the `math` library, you calculate the decimal value
    of `b` with the `decimal` library. Use the square root method of that and this
    gives you again the wrong answer, because by default, the `decimal` library rounds
    things off. But if you set the precision to be higher, you get exactly the right
    answer, and that's why the `decimal` library is better for our purposes. This
    `getcontext().prec` command lets us set it to keep enough places to be as precise
    as we want.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经导入了`decimal`库，并将`a`的值设置为`10 **100+ 1`。这里`b`等于a的平方，然后不是使用`math`库计算`b`的平方根，而是使用`decimal`库计算`b`的十进制值。使用它的平方根方法，这会再次给出错误的答案，因为默认情况下，`decimal`库会四舍五入。但是如果将精度设置得更高，你将得到完全正确的答案，这就是为什么`decimal`库对我们的目的更好。这个`getcontext().prec`命令让我们设置它保留足够的位数，以便我们想要的精度。
- en: 'All right, so, you wouldn''t be able to factor a large number in the general
    case, and that''s what makes RSA secure. But, if a mistake is made by using numbers
    and can be predictable in some way, then RSA can be cracked:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以，在一般情况下，你无法分解一个大数，这就是RSA安全的原因。但是，如果在使用数字时出现错误，并且以某种方式可以预测，那么RSA就可以被破解：
- en: '![](../images/00103.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00103.jpeg)'
- en: Here the mistake is using two prime factors that are close together instead
    of choosing independent random numbers for the two prime factors. So, this large
    number is the product of two prime factors, and so you can factor it. So, if we
    put that number in a value called `n`, we set the precision to `50` places and
    calculate the square root. We find that the square root is `1` followed by many
    zeros, and that is ended at `83` +a fraction.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的错误是使用两个彼此接近的质数因子，而不是为这两个质数因子选择独立的随机数。因此，这个大数字是两个质数因子的乘积，因此你可以将其分解。因此，如果我们将该数字放入一个名为`n`的值中，我们将精度设置为`50`位并计算平方根。我们发现平方根是`1`后面跟着许多个零，然后以`83`结束+一个分数。
- en: Now, if the number is the product of two prime numbers, and the two prime numbers
    are close together, one number must be less than the square root and the other
    number must be larger than the square root.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果这个数字是两个质数的乘积，并且这两个质数彼此接近，一个数字必须小于平方根，另一个数字必须大于平方根。
- en: 'So, if we simply start at the square root and try numbers close to the square
    root by jumping back by two every time, we will eventually find the prime factor,
    and we do:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们从平方根开始，每次向后跳两个数字，尝试接近平方根的数字，我们最终会找到质数因子，我们找到了：
- en: '![](../images/00104.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00104.jpeg)'
- en: Of course, we can jump back by twos because even numbers are certainly not prime,
    so we don't need to test the even numbers.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以向后跳两步，因为偶数肯定不是质数，所以我们不需要测试偶数。
- en: And, as we can see, now we've found a number where the modulus of `n` modulus
    the number is zero, so this is a prime factor.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，现在我们找到了一个数字，其中`n`模这个数字的结果为零，因此这是一个质数因子。
- en: 'We can get the other prime factor by just dividing `n` by the first one:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`n`除以第一个质数来得到另一个质数因子：
- en: '![](../images/00105.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00105.jpeg)'
- en: So, here's the original number, `n`, which is the product of two primes, and
    we have one of the primes; `q` is `n` over `p` which you can see. To test it,
    if we calculate `p*q`, we get the original number again. So, we have factored
    a large number into `p` and `q`, and that is enough information to crack RSA.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里是原始数字`n`，它是两个质数的乘积，我们有其中一个质数；`q`是`n`除以`p`，你可以看到。为了测试它，如果我们计算`p*q`，我们会再次得到原始数字。因此，我们已经将一个大数字分解为`p`和`q`，这就足够破解RSA了。
- en: 'So, let''s try that in Python. Go to the Terminal and run `python`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们在Python中尝试一下。转到终端并运行`python`：
- en: '![](../images/00106.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00106.jpeg)'
- en: 'So, we have `n` equal to the large number shown. We import this number to the
    `decimal` library and set the position to `50` places. Now, if we take the square
    root, we get `1` followed by many zeros, and then `83`, and then a fraction. Then,
    we copy the integer part of the square root:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有`n`等于所示的大数字。我们将这个数字导入`decimal`库，并将位置设置为`50`位。现在，如果我们取平方根，我们得到`1`后面跟着许多个零，然后是`83`，然后是一个分数。然后，我们复制平方根的整数部分：
- en: '![](../images/00107.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00107.jpeg)'
- en: 'Now we set `p` in range of that number followed by the number, as shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将`p`设置在该数字的范围内，如下所示：
- en: '[PRE8]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This begins a loop, and all we have to do is print:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始了一个循环，我们所要做的就是打印：
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It will calculate `n` modulus `p`, which will be zero. If that''s an integral
    multiple, pressing *Enter* twice runs the loop:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 它将计算`n`模`p`，结果将为零。如果这是一个整数倍数，按两次*Enter*运行循环：
- en: '![](../images/00108.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00108.jpeg)'
- en: 'So, we can see this number is `p`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可以看到这个数字是`p`：
- en: '[PRE10]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we copy that number, we can set `p` equal to that and can set `q` equal
    to `n` over `p`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们复制那个数字，我们可以将`p`设置为那个数字，然后将`q`设置为`n`除以`p`：
- en: '[PRE11]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we print, we will get the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印，我们将得到以下结果：
- en: '![](../images/00109.jpeg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00109.jpeg)'
- en: You can see `n` matches with `p*q`. So, we've now factored that long number
    into its complement primes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`n`与`p*q`匹配。所以，我们现在已经将那个长数字分解为了它的互补质数。
- en: 'Here''s the first challenge:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个挑战：
- en: '![](../images/00110.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00110.jpeg)'
- en: 'Here''s the second challenge:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个挑战：
- en: '![](../images/00111.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00111.jpeg)'
- en: In both cases, you will be able to factor them.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你都能够将它们分解。
- en: What's next?
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来呢？
- en: '**Internet of Things** (**IoT**) has a promising future and will soon connect
    billions of devices. For IoT, security has always been a major concern. But the
    good news is that cryptography offers various options to secure IOT from hackers;
    hence, it is a key to the coming era of IoT.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**物联网**（**IoT**）有着光明的未来，很快将连接数十亿的设备。对于物联网，安全一直是一个主要关注点。但好消息是，加密为保护物联网免受黑客攻击提供了各种选择；因此，这是物联网即将到来的时代的关键。'
- en: Cryptography within IoT
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物联网中的加密
- en: 'When we talk about using cryptography within IoT, we are talking about using
    cryptography across many layers of the communication stack. If we look at the
    OSI model, we can see that crypto is used at Layer 2 and up with linking operating
    at level 2, networking operating at layer 3, and transporting operating at layer
    4:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论在物联网中使用加密时，我们谈论的是在通信堆栈的许多层上使用加密。如果我们看一下OSI模型，我们可以看到加密在第2层及以上使用，链接在第2层操作，网络在第3层操作，传输在第4层操作：
- en: '![](../images/00112.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00112.jpeg)'
- en: At the Application Layer, Cryptography is also used to protect communication
    through both authentication and encryption. Before we begin our description about
    specific cryptographic approaches for IOT protocols, let’s first talk about the
    ready availability of exploitation tools for existing wireless protocols. As IOT
    matures, keep in mind that there are many tools available to exploit IOT wireless
    communication protocols and these tools will continue to rapidly keep up with
    new technologies introduced to support the IOT.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用层，加密也用于通过认证和加密来保护通信。在我们开始描述物联网协议的特定加密方法之前，让我们先谈谈现有无线协议的利用工具的现成性。随着物联网的成熟，要记住有许多工具可用于利用物联网无线通信协议，这些工具将继续迅速跟上支持物联网引入的新技术。
- en: For example, looking at Wi-Fi 802.11, which was introduced in 1989, the AirCrack
    tool was introduced in 2004 and to this day is still a popular and well-supported
    tool. There are also many tools available to exploit Bluetooth communication and
    cellular communication.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看1989年推出的Wi-Fi 802.11，2004年推出的AirCrack工具至今仍然是一款受欢迎且得到良好支持的工具。还有许多工具可用于利用蓝牙通信和蜂窝通信。
- en: Besides this, keys that drive crypto must be securely managed both at the device
    (module) level as well as throughout an enterprise. Let’s explore some of them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，驱动加密的密钥必须在设备（模块）级别以及整个企业范围内得到安全管理。让我们来探讨其中一些。
- en: ZigBee cryptographic keys
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ZigBee加密密钥
- en: 'ZigBee uses many keys for cryptographic operations:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ZigBee使用许多密钥进行加密操作：
- en: '**Link key**: This is established based on the use of pre-provisioned master
    key from the manufacturer. The link key provides point-to-point secure connection
    between two ZigBee nodes. The link key is also used to establish derived keys,
    including data keys, key-transport keys, and Key-load keys'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链路密钥**：这是基于制造商预先配置的主密钥建立的。链路密钥提供了两个ZigBee节点之间的点对点安全连接。链路密钥还用于建立派生密钥，包括数据密钥、密钥传输密钥和密钥装载密钥'
- en: '**Key-transport keys**: This key is the outcome of executing the specialized
    keyed hash function under the link key with the 1-octet string 0x00 as the input
    string'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥传输密钥**：这个密钥是在使用链路密钥和1字节字符串0x00作为输入字符串执行专门的密钥散列函数的结果'
- en: Complexity of ZigBee key management
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ZigBee密钥管理的复杂性
- en: As mentioned earlier, key management is challenging. Let’s take a look at how
    challenging key management can be. Take, for example, the ZigBee protocol. There
    are three primary types of keys that can be employed within the ZigBee network.
    Master keys are often preinstalled by the vendor and protect the exchange between
    two ZigBee nodes as they generate link keys. Link keys support node-to-node communication
    and network keys support broadcast communication.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，密钥管理是具有挑战性的。让我们来看看密钥管理有多具有挑战性。例如，以ZigBee协议为例。在ZigBee网络中可以使用三种主要类型的密钥。主密钥通常由供应商预先安装，并保护两个ZigBee节点之间的交换，因为它们生成链路密钥。链路密钥支持节点之间的通信，网络密钥支持广播通信。
- en: Key management functions might be built into the media management software of
    utility, for example, and it might be provided as standalone software. However,
    all of these keys need to be sufficiently secured across their entire lifecycle.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥管理功能可能内置于实用程序的媒体管理软件中，例如，也可能作为独立软件提供。然而，所有这些密钥在它们的整个生命周期中都需要得到充分的安全保护。
- en: Bluetooth – LE
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝牙-LE
- en: The Bluetooth low energy protocol employs cryptography for pairing devices for
    future relationships. Bluetooth—LE uses various keys within these cryptographic
    processes, including a **long-term key** (**LTK**), which is used to generate
    a 128-bit key for the link layer encryption and a **connection signature resolving
    key** (**CSRK**), which is used for digitally signing data at the ATT layer.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝牙低功耗协议采用加密技术来配对设备以建立未来的关系。蓝牙-LE在这些加密过程中使用各种密钥，包括**长期密钥**（LTK），用于生成链路层加密的128位密钥，以及**连接签名解析密钥**（CSRK），用于在ATT层对数据进行数字签名。
- en: With this, we come to the end of this book. Cryptography applications should
    be tailored specifically for the threat environments. Cryptography is based on
    strong, well- designed algorithms and associated with all layers of the communication
    stack. It is everywhere and fundamental to the security of IOT systems.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一切，我们来到了本书的结尾。加密应用应该根据威胁环境进行定制。加密是基于强大、精心设计的算法，并与通信堆栈的所有层相关联。它无处不在，对物联网系统的安全至关重要。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered AES, the strongest private key system in common
    use today, and its two modes, ECB and CBC. We covered the padding oracle attack
    against CBC, which is made possible when an error message gives the attacker more
    information than they should have about the encryption process.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了AES，这是当今常用的最强大的私钥系统，以及它的两种模式，ECB和CBC。我们还介绍了针对CBC的填充预言攻击，这是可能的，当错误消息给予攻击者比他们应该获得的更多有关加密过程的信息时。
- en: Finally, we covered RSA, the primary public key algorithm in use today to send
    secrets over the internet, and we also looked at the challenge where we cracked
    RSA in the case where the two prime numbers are similar instead of being independent
    and randomly chosen. We also looked at the future of cryptography and how it will
    help secure IOT devices.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了RSA，这是当今用于通过互联网发送秘密的主要公钥算法，我们还研究了一个挑战，即在两个素数相似而不是独立和随机选择的情况下我们是如何破解RSA的。我们还研究了加密技术的未来以及它如何帮助保护物联网设备。
