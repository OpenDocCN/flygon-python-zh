["```py\nimport time\nimport tkinter as tk\n\nclass App(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.button = tk.Button(self, command=self.start_action,\n                                text=\"Wait 5 seconds\")\n        self.button.pack(padx=20, pady=20)\n\n    def start_action(self):\n        self.button.config(state=tk.DISABLED)\n        time.sleep(5)\n        self.button.config(state=tk.NORMAL)\n\nif __name__ == \"__main__\":\n    app = App()\n    app.mainloop()\n```", "```py\nimport tkinter as tk\n\nclass App(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.button = tk.Button(self, command=self.start_action,\n                                text=\"Wait 5 seconds\")\n        self.button.pack(padx=50, pady=20)\n\n    def start_action(self):\n        self.button.config(state=tk.DISABLED)\n        self.after(5000, lambda: self.button.config(state=tk.NORMAL))\n\nif __name__ == \"__main__\":\n    app = App()\n    app.mainloop()\n```", "```py\nprint(\"First\")\nself.after(1000, lambda: print(\"Third\"))\nprint(\"Second\")\n```", "```py\nimport time\nimport threading\nimport tkinter as tk\n\nclass App(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.button = tk.Button(self, command=self.start_action,\n                                text=\"Wait 5 seconds\")\n        self.button.pack(padx=50, pady=20)\n\n    def start_action(self):\n        self.button.config(state=tk.DISABLED)\n        thread = threading.Thread(target=self.run_action)\n        print(threading.main_thread().name)\n        print(thread.name)\n        thread.start()\n        self.check_thread(thread)\n\n    def check_thread(self, thread):\n        if thread.is_alive():\n            self.after(100, lambda: self.check_thread(thread))\n        else:\n            self.button.config(state=tk.NORMAL)\n\n    def run_action(self):\n        print(\"Starting long running action...\")\n        time.sleep(5)\n        print(\"Long running action finished!\")\n\nif __name__ == \"__main__\":\n    app = App()\n    app.mainloop()\n```", "```py\n    thread = threading.Thread(target=self.run_action)\n    thread.start()\n```", "```py\n    def check_thread(self, thread):\n        if thread.is_alive():\n            self.after(100, lambda: self.check_thread(thread))\n        else:\n            self.button.config(state=tk.NORMAL)\n```", "```py\n    def start_action(self):\n        self.button.config(state=tk.DISABLED)\n        thread = threading.Thread(target=self.run_action, args=(5,))\n        thread.start()\n        self.check_thread(thread)\n\n    def run_action(self, timeout):\n        # ...\n```", "```py\nimport time\nimport json\nimport random\nfrom http.server import HTTPServer, BaseHTTPRequestHandler\n\nclass RandomRequestHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        # Simulate latency\n        time.sleep(3)\n\n        # Write response headers\n        self.send_response(200)\n        self.send_header('Content-type', 'application/json')\n        self.end_headers()\n\n        # Write response body\n        body = json.dumps({'random': random.random()})\n        self.wfile.write(bytes(body, \"utf8\"))\n\ndef main():\n    \"\"\"Starts the HTTP server on port 8080\"\"\"\n    server_address = ('', 8080)\n    httpd = HTTPServer(server_address, RandomRequestHandler)\n    httpd.serve_forever()\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\nimport json\nimport threading\nimport urllib.request\nimport tkinter as tk\n\nclass App(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title(\"HTTP request example\")\n        self.label = tk.Label(self,\n                              text=\"Click 'Start' to get a random \n                              value\")\n        self.button = tk.Button(self, text=\"Start\",\n                                command=self.start_action)\n        self.label.pack(padx=60, pady=10)\n        self.button.pack(pady=10)\n\n    def start_action(self):\n        self.button.config(state=tk.DISABLED)\n        thread = AsyncAction()\n        thread.start()\n        self.check_thread(thread)\n\n    def check_thread(self, thread):\n        if thread.is_alive():\n            self.after(100, lambda: self.check_thread(thread))\n        else:\n            text = \"Random value: {}\".format(thread.result)\n            self.label.config(text=text)\n            self.button.config(state=tk.NORMAL)\n\nclass AsyncAction(threading.Thread):\n    def run(self):\n        self.result = None\n        url = \"http://localhost:8080\"\n        with urllib.request.urlopen(url) as f:\n            obj = json.loads(f.read().decode(\"utf-8\"))\n            self.result = obj[\"random\"]\n\nif __name__ == \"__main__\":\n    app = App()\n    app.mainloop()\n```", "```py\nclass AsyncAction(threading.Thread):\n    def run(self):\n        # ...\n```", "```py\n{\"random\": 0.0915826359180778}\n```", "```py\ndef run(self):\n    self.result = None\n    url = \"http://localhost:8080\"\n    with urllib.request.urlopen(url) as f:\n        obj = json.loads(f.read().decode(\"utf-8\"))\n        self.result = obj[\"random\"]\n```", "```py\n    def check_thread(self, thread):\n        if thread.is_alive():\n            self.after(100, lambda: self.check_thread(thread))\n        else:\n            text = \"Random value: {}\".format(thread.result)\n            self.label.config(text=text)\n            self.button.config(state=tk.NORMAL)\n```", "```py\nimport time\nimport queue\nimport threading\nimport tkinter as tk\nimport tkinter.ttk as ttk\nimport tkinter.messagebox as mb\n\nclass App(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title(\"Progressbar example\")\n        self.queue = queue.Queue()\n        self.progressbar = ttk.Progressbar(self, length=300,\n                                           orient=tk.HORIZONTAL)\n        self.button = tk.Button(self, text=\"Start\",\n                                command=self.start_action)\n\n        self.progressbar.pack(padx=10, pady=10)\n        self.button.pack(padx=10, pady=10)\n\n    def start_action(self):\n        self.button.config(state=tk.DISABLED)\n        thread = AsyncAction(self.queue, 20)\n        thread.start()\n        self.poll_thread(thread)\n\n    def poll_thread(self, thread):\n        self.check_queue()\n        if thread.is_alive():\n            self.after(100, lambda: self.poll_thread(thread))\n        else:\n            self.button.config(state=tk.NORMAL)\n            mb.showinfo(\"Done!\", \"Async action completed\")\n\n    def check_queue(self):\n        while self.queue.qsize():\n            try:\n                step = self.queue.get(0)\n                self.progressbar.step(step * 100)\n            except queue.Empty:\n                pass\n\nclass AsyncAction(threading.Thread):\n    def __init__(self, queue, steps):\n        super().__init__()\n        self.queue = queue\n        self.steps = steps\n\n    def run(self):\n        for _ in range(self.steps):\n            time.sleep(1)\n            self.queue.put(1 / self.steps)\n\nif __name__ == \"__main__\":\n    app = App()\n    app.mainloop()\n```", "```py\n# ...\nimport queue\nimport tkinter.ttk as ttk\n\nclass App(tk.Tk):\n    def __init__(self):\n        # ...\n        self.queue = queue.Queue()\n self.progressbar = ttk.Progressbar(self, length=300,\n orient=tk.HORIZONTAL)\n```", "```py\n    def start_action(self):\n        self.button.config(state=tk.DISABLED)\n        thread = AsyncAction(self.queue, 20)\n        thread.start()\n        self.poll_thread(thread)\n```", "```py\nclass AsyncAction(threading.Thread):\n    def __init__(self, queue, steps):\n        super().__init__()\n        self.queue = queue\n        self.steps = steps\n\n    def run(self):\n        for _ in range(self.steps):\n            time.sleep(1)\n            self.queue.put(1 / self.steps)\n```", "```py\n    def check_queue(self):\n        while self.queue.qsize():\n            try:\n                step = self.queue.get(0)\n                self.progressbar.step(step * 100)\n            except queue.Empty:\n                pass\n```", "```py\n    def poll_thread(self, thread):\n        self.check_queue()\n        if thread.is_alive():\n            self.after(100, lambda: self.poll_thread(thread))\n        else:\n            self.button.config(state=tk.NORMAL)\n            mb.showinfo(\"Done!\", \"Async action completed\")\n```", "```py\nimport time\nimport tkinter as tk\n\nclass App(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.button = tk.Button(self, command=self.start_action,\n                                text=\"Wait 5 seconds\")\n        self.cancel = tk.Button(self, command=self.cancel_action,\n                                text=\"Stop\", state=tk.DISABLED)\n        self.button.pack(padx=30, pady=20, side=tk.LEFT)\n        self.cancel.pack(padx=30, pady=20, side=tk.LEFT)\n\n    def start_action(self):\n        self.button.config(state=tk.DISABLED)\n        self.cancel.config(state=tk.NORMAL)\n        self.scheduled_id = self.after(5000, self.init_buttons)\n\n    def init_buttons(self):\n        self.button.config(state=tk.NORMAL)\n        self.cancel.config(state=tk.DISABLED)\n\n    def cancel_action(self):\n        print(\"Canceling scheduled\", self.scheduled_id)\n        self.after_cancel(self.scheduled_id)\n        self.init_buttons()\n\nif __name__ == \"__main__\":\n    app = App()\n    app.mainloop()\n```", "```py\n    def start_action(self):\n        self.button.config(state=tk.DISABLED)\n        self.cancel.config(state=tk.NORMAL)\n        self.scheduled_id = self.after(5000, self.init_buttons)\n```", "```py\n    def cancel_action(self):\n        print(\"Canceling scheduled\", self.scheduled_id)\n        self.after_cancel(self.scheduled_id)\n        self.init_buttons()\n```", "```py\nclass MyAsyncAction(threading.Thread):\n    def __init__(self):\n        super().__init__()\n        self.do_stop = False\n\n    def run(self):\n        # Start execution...\n        if not self.do_stop:\n            # Continue execution...\n```", "```py\nimport time\nimport tkinter as tk\n\nclass App(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.button = tk.Button(self, command=self.start_action,\n                                text=\"Wait 1 second\")\n        self.button.pack(padx=30, pady=20)\n\n    def start_action(self):\n        self.button.config(state=tk.DISABLED)\n        self.update_idletasks()\n        time.sleep(1)\n        self.button.config(state=tk.NORMAL)\n\nif __name__ == \"__main__\":\n    app = App()\n    app.mainloop()\n```", "```py\nimport threading\nimport subprocess\nimport tkinter as tk\n\nclass App(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.entry = tk.Entry(self)\n        self.button = tk.Button(self, text=\"Ping!\",\n                                command=self.do_ping)\n        self.output = tk.Text(self, width=80, height=15)\n\n        self.entry.grid(row=0, column=0, padx=5, pady=5)\n        self.button.grid(row=0, column=1, padx=5, pady=5)\n        self.output.grid(row=1, column=0, columnspan=2,\n                         padx=5, pady=5)\n\n    def do_ping(self):\n        self.button.config(state=tk.DISABLED)\n        thread = AsyncAction(self.entry.get())\n        thread.start()\n        self.poll_thread(thread)\n\n    def poll_thread(self, thread):\n        if thread.is_alive():\n            self.after(100, lambda: self.poll_thread(thread))\n        else:\n            self.button.config(state=tk.NORMAL)\n            self.output.delete(1.0, tk.END)\n            self.output.insert(tk.END, thread.result)\n\nclass AsyncAction(threading.Thread):\n    def __init__(self, ip):\n        super().__init__()\n        self.ip = ip\n\n    def run(self):\n        self.result = subprocess.run([\"ping\", self.ip], shell=True,\n                                     stdout=subprocess.PIPE).stdout\n\nif __name__ == \"__main__\":\n    app = App()\n    app.mainloop()\n```", "```py\n    def run(self):\n        self.result = subprocess.run([\"ping\", self.ip], shell=True,\n                                     stdout=subprocess.PIPE).stdout\n```", "```py\n    def poll_thread(self, thread):\n        if thread.is_alive():\n            self.after(100, lambda: self.poll_thread(thread))\n        else:\n            self.button.config(state=tk.NORMAL)\n self.output.delete(1.0, tk.END)\n self.output.insert(tk.END, thread.result)\n```"]