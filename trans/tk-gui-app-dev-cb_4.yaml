- en: Dialogs and Menus
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对话框和菜单
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Showing alert dialogs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示警报对话框
- en: Asking for user confirmation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要求用户确认
- en: Choosing files and directories
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择文件和目录
- en: Saving data into a file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据保存到文件中
- en: Creating a menu bar
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建菜单栏
- en: Using variables in menus
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在菜单中使用变量
- en: Displaying context menus
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示上下文菜单
- en: Opening a secondary window
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开次要窗口
- en: Passing variables between windows
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在窗口之间传递变量
- en: Handling window deletion
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理窗口删除
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Almost every nontrivial GUI application is composed of multiple views. In browsers,
    this is achieved by navigating from one HTML page to another, and in desktop applications,
    it is represented by multiple windows and dialogs that users can interact with.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个非平凡的GUI应用程序都由多个视图组成。在浏览器中，这是通过从一个HTML页面导航到另一个页面实现的，在桌面应用程序中，它由用户可以与之交互的多个窗口和对话框表示。
- en: So far, we have learned how to create only a root window, which is associated
    with the Tcl interpreter. However, Tkinter allows us to create multiple top-level
    windows under the same application, and it also includes specific modules with
    built-in dialogs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只学习了如何创建一个与Tcl解释器关联的根窗口。但是，Tkinter允许我们在同一个应用程序下创建多个顶级窗口，并且还包括具有内置对话框的特定模块。
- en: Another way to structure how to navigate in your application is using menus,
    which are usually displayed under the title bar in desktop applications. In Tkinter,
    these menus are represented by a widget class; we will dive later into its methods
    and how to integrate it with the rest of our application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种构造应用程序导航的方法是使用菜单，通常在桌面应用程序的标题栏下显示。在Tkinter中，这些菜单由一个小部件类表示；我们将在稍后深入研究其方法以及如何将其与我们应用程序的其余部分集成。
- en: Showing alert dialogs
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示警报对话框
- en: A common use case for dialogs is notifying users of events that occurred in
    our application, such as that a record has been saved, or that it failed to open
    a file. We will now take a look at some of the basic functions included in Tkinter
    to display informational dialogs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框的一个常见用例是通知用户应用程序中发生的事件，例如记录已保存，或者无法打开文件。现在我们将看一下Tkinter中包含的一些基本函数来显示信息对话框。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Our program will have three buttons, where each one illustrates a different
    dialog with a static title and message. This type of dialog boxes have only a
    button to confirm and close the dialog:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序将有三个按钮，每个按钮都显示一个不同的对话框，具有静态标题和消息。这种类型的对话框框只有一个确认和关闭对话框的按钮：
- en: '![](images/6bf8de6b-3907-4221-9ea0-3fc4a4fabd9a.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](images/6bf8de6b-3907-4221-9ea0-3fc4a4fabd9a.png)'
- en: 'When you run the preceding example, note that each dialog plays the corresponding
    sound defined by your platform, and the button label is translated to your language:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行上面的示例时，请注意每个对话框都会播放由您的平台定义的相应声音，并且按钮标签会被翻译成您的语言：
- en: '![](images/55c3bc6c-eb7e-4198-8f1a-4ee12827f024.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](images/55c3bc6c-eb7e-4198-8f1a-4ee12827f024.png)'
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The three dialogs mentioned in the preceding *Getting ready* section are opened
    with the `showinfo`, `showwarning`, and `showerror` functions from the `tkinter.messagebox` module:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的*准备就绪*部分提到的三个对话框是使用`tkinter.messagebox`模块中的`showinfo`、`showwarning`和`showerror`函数打开的：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we imported the `tkinter.messagebox` module with the shorter alias `mb`.
    This module was named `tkMessageBox` in Python 2, so this syntax also helps us
    to isolate compatibility issues in a single statement.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用较短的别名`mb`导入了`tkinter.messagebox`模块。这个模块在Python 2中被命名为`tkMessageBox`，因此这种语法也有助于我们将兼容性问题隔离在一个语句中。
- en: 'Each dialog is commonly used depending on the type of information that is notified
    to the users:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对话框通常根据通知给用户的信息类型而使用：
- en: '`showinfo`: The operation completed successfully'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`showinfo`：操作成功完成'
- en: '`showwarning`: The operation completed but something did not behave as expected'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`showwarning`：操作已完成，但某些内容未按预期行为'
- en: '`showerror`: The operation failed due to an error'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`showerror`：由于错误操作失败'
- en: 'These three functions receive two strings as input arguments: the first one
    is displayed on the title bar, and the second one corresponds to the message shown
    by the dialog.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数接收两个字符串作为输入参数：第一个显示在标题栏上，第二个对应对话框显示的消息。
- en: Dialog messages can also spawn across multiple lines by adding the new line
    character, `\n`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框消息也可以通过添加换行字符`\n`跨多行生成。
- en: Asking for user confirmation
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求用户确认
- en: Other types of dialogs included in Tkinter are those used to ask for user confirmation,
    such as the ones shown when we want to save a file and are about to override an
    existing one with the same name.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter中包括的其他类型的对话框是用于要求用户确认的对话框，例如当我们要保存文件并且要覆盖同名文件时显示的对话框。
- en: These dialogs differ from the preceding one because the values returned by the
    functions will depend on the confirmation button clicked by the user. This way,
    we can interact with the program to indicate whether to continue or cancel the
    action.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对话框与前面的对话框不同，因为函数返回的值将取决于用户点击的确认按钮。这样，我们可以与程序交互，指示是否继续或取消操作。
- en: Getting ready
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this recipe, we will cover the remaining dialog functions defined in the
    `tkinter.messagebox` module. Each button is labeled with the type of dialog that
    is opened when clicked:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将涵盖`tkinter.messagebox`模块中定义的其余对话框函数。每个按钮上都标有单击时打开的对话框类型：
- en: '![](images/fdcf033f-5f95-4a30-80e5-775993a13713.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](images/fdcf033f-5f95-4a30-80e5-775993a13713.png)'
- en: 'Since there are a few differences among these dialogs, you can try them out
    to see which one may better fit your needs for each situation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些对话框之间存在一些差异，您可以尝试它们，以查看哪一个可能更适合您每种情况的需求：
- en: '![](images/58981fea-4262-4b93-b599-d6baf00fe9f4.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](images/58981fea-4262-4b93-b599-d6baf00fe9f4.png)'
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'As we did in our preceding example, we will import `tkinter.messagebox` with
    the `import ... as` syntax and call each function with `title` and `message`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '与我们在前面的示例中所做的一样，我们将使用`import ... as`语法导入`tkinter.messagebox`并调用每个函数与`title`和`message`： '
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To avoid repeating the code for the button instantiation and the callback method,
    we defined a `create_button` method to reuse it as many times as we need to add
    all the buttons with their dialogs. The commands simply print the result of the
    `dialog` function passed as a parameter so that we can see the values returned,
    depending on the button clicked, to answer the dialog.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免重复编写按钮实例化和回调方法的代码，我们定义了一个`create_button`方法，以便根据需要多次重用它以添加所有带有其对话框的按钮。命令只是简单地打印作为参数传递的`dialog`函数的结果，以便我们可以看到根据点击的按钮返回的值来回答对话框。
- en: Choosing files and directories
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择文件和目录
- en: File dialogs allow users to select one or multiple files from the filesystem.
    In Tkinter, these functions are declared in the `tkinter.filedialog` module, which
    also includes dialogs for choosing directories. It also lets you customize the
    behavior of a new dialog, such as filtering the files by their extension or choosing
    the initial directory displayed by the dialog.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对话框允许用户从文件系统中选择一个或多个文件。在Tkinter中，这些函数声明在`tkinter.filedialog`模块中，该模块还包括用于选择目录的对话框。它还允许您自定义新对话框的行为，例如通过其扩展名过滤文件或选择对话框显示的初始目录。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Our application will contain two buttons. The first will be labeled Choose
    file, and it will display a dialog to select a file. By default, it will only
    show files with the `.txt` extension:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将包含两个按钮。第一个将被标记为选择文件，并且它将显示一个对话框以选择文件。默认情况下，它只会显示具有`.txt`扩展名的文件：
- en: '![](images/7f9c5028-420b-4ff0-b74b-840a8521687a.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](images/7f9c5028-420b-4ff0-b74b-840a8521687a.png)'
- en: 'The second button will be Choose directory, and it will open a similar dialog
    to select a directory:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个按钮将是选择目录，并且它将打开一个类似的对话框以选择目录：
- en: '![](images/04091bd1-b45c-4a74-8168-0cc0eca082a4.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](images/04091bd1-b45c-4a74-8168-0cc0eca082a4.png)'
- en: Both buttons will print the full path to the selected file or directory, and
    will not perform any action if the dialog is canceled.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 两个按钮都将打印所选文件或目录的完整路径，并且如果对话框被取消，将不执行任何操作。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The first button of our application will trigger a call to the `askopenfilename`
    function, whereas the second one will call the `askdirectory` function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的第一个按钮将触发对`askopenfilename`函数的调用，而第二个按钮将调用`askdirectory`函数：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Since these dialogs can be dismissed, we added conditional statements to check
    whether the dialog function returns a non-empty string before printing it into
    the console. We would need this validation in any application that must perform
    an action with this path, such as reading or copying files, or changing permissions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些对话框可能会被关闭，我们添加了条件语句来检查对话框函数在将其打印到控制台之前是否返回了非空字符串。我们需要在任何必须对此路径执行操作的应用程序中进行此验证，例如读取或复制文件，或更改权限。
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We create the first dialog with the `askopenfilename` function, which returns
    a string that represents the full path to the chosen file. It accepts the following
    optional arguments:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`askopenfilename`函数创建第一个对话框，该函数返回一个表示所选文件的完整路径的字符串。它接受以下可选参数：
- en: '`title`: Title displayed in the dialog''s title bar.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：对话框标题栏中显示的标题。'
- en: '`initialdir`: Initial directory.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialdir`：初始目录。'
- en: '`filetypes`: Sequence of tuples of two strings. The first one is a label indicating
    the type of the file in a human-readable format, whereas the second one is a pattern
    to match the filename.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filetypes`：两个字符串元组的序列。第一个是以人类可读格式指示文件类型的标签，而第二个是用于匹配文件名的模式。'
- en: '`multiple`: Boolean value to indicate whether users may select multiple files.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiple`：布尔值，指示用户是否可以选择多个文件。'
- en: '`defaultextension`: Extension added to the filename if it is not explicitly
    given.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultextension`：如果未明确给出文件名，则添加到文件名的扩展名。'
- en: 'In our example, we set the initial directory to the root folder and a custom
    title. In our tuple of file types, we have the following three valid choices:
    text files saved with the `.txt` extension; images with the `.jpg`, `.gif`, and
    `.png` extensions; and the wildcard (`"*"`) to match all files.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将初始目录设置为根文件夹和自定义标题。在我们的文件类型元组中，我们有以下三个有效选择：使用`.txt`扩展名保存的文本文件；带有`.jpg`、`.gif`和`.png`扩展名的图像；以及通配符(`"*"`)以匹配所有文件。
- en: 'Note that these patterns do not necessarily match the format of the data contained
    in the file since it is possible to rename a file with a different extension:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些模式不一定与文件中包含的数据的格式匹配，因为可以使用不同的扩展名重命名文件：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `askdirectory` function also takes the `title` and `initialdir` parameters,
    and a `mustexist` Boolean option to indicate whether users have to pick an existing
    directory:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`askdirectory`函数还接受`title`和`initialdir`参数，以及一个`mustexist`布尔选项，指示用户是否必须选择现有目录：'
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's more...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `tkinter.filedialog` module includes some variations of these functions
    that allow you to directly retrieve the file objects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkinter.filedialog`模块包括这些函数的一些变体，允许您直接检索文件对象。'
- en: 'For instance, `askopenfile` returns the file object corresponding to the selected
    file, instead of having to call `open` with the path returned by `askopenfilename`.
    We still have to check whether the dialog has not been dismissed before calling
    the file methods:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`askopenfile`返回与所选文件对应的文件对象，而不必使用`askopenfilename`返回的路径调用`open`。我们仍然必须检查对话框在调用文件方法之前是否已被关闭：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Saving data into a file
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据保存到文件中
- en: Apart from selecting existing files and directories, it is also possible to
    create a new file using Tkinter dialogs. They can be used to persist data generated
    by our application, letting users choose the name and location of the new file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除了选择现有文件和目录外，还可以使用Tkinter对话框创建新文件。它们可用于保存应用程序生成的数据，让用户选择新文件的名称和位置。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use the Save file dialog to write the contents of a Text widget into
    a plain text file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用保存文件对话框将文本窗口小部件的内容写入纯文本文件：
- en: '![](images/1d7858dc-1a91-4591-8f72-08ee9d0c6f1d.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](images/1d7858dc-1a91-4591-8f72-08ee9d0c6f1d.png)'
- en: How to do it...
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To open a dialog to save a file, we call the `asksaveasfile` function from
    the `tkinter.filedialog` module. It internally creates a file object with the
    `''w''` mode for writing, or `None` if the dialog is dismissed:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开保存文件的对话框，我们从`tkinter.filedialog`模块调用`asksaveasfile`函数。它内部使用`'w'`模式创建文件对象进行写入，或者如果对话框被关闭，则返回`None`：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `asksaveasfile` function accepts the same optional parameters as the `askopenfile`
    function, but also allows you to add the file extension by default with the `defaultextension` option.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`asksaveasfile`函数接受与`askopenfile`函数相同的可选参数，但还允许您使用`defaultextension`选项默认添加文件扩展名。'
- en: To prevent users from accidentally overriding previous files, this dialog automatically
    warns you if you try to save a new file with the same name as an existing one.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止用户意外覆盖先前的文件，此对话框会在您尝试保存与现有文件同名的新文件时自动警告您。
- en: 'With the file object, we can write the contents of the Text widget—always remember
    to close the file to free the resources taken by the object:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有了文件对象，我们可以写入Text小部件的内容-始终记得关闭文件以释放对象占用的资源：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the preceding recipe, we saw that there is a function equivalent to `askopenfilename`
    that returns a file object instead of a string, named `askopenfile`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的食谱中，我们看到有一个等价于`askopenfilename`的函数，它返回一个文件对象而不是一个字符串，名为`askopenfile`。
- en: To save files, there is also a `asksaveasfilename` function that returns the
    path of the selected file. You can use this function if you want to modify the
    path or perform any validation before opening the file for writing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存文件，还有一个`asksaveasfilename`函数，它返回所选文件的路径。如果要在打开文件进行写入之前修改路径或执行任何验证，可以使用此函数。
- en: See also
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Choosing files and directories* recipe
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择文件和目录*食谱'
- en: Creating a menu bar
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建菜单栏
- en: Complex GUIs typically use menu bars to organize the actions and navigations
    that are available in our application. This pattern is also used to group operations
    that are closely related, such as the File menu included in most text editors.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的GUI通常使用菜单栏来组织应用程序中可用的操作和导航。这种模式也用于将紧密相关的操作分组，例如大多数文本编辑器中包含的“文件”菜单。
- en: Tkinter natively supports these menus, which are displayed with the look and
    feel of the target desktop environment. Therefore, you do not have to simulate
    them with frames or labels, because you would lose the cross-platform features
    that have already been built into Tkinter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter本地支持这些菜单，显示为目标桌面环境的外观和感觉。因此，您不必使用框架或标签模拟它们，因为这样会丢失Tkinter中已经构建的跨平台功能。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will start by adding a menu bar to a root window with a nested drop-down
    menu. On Windows 10, this is displayed as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先向根窗口添加一个菜单栏，并嵌套下拉菜单。在Windows 10上，显示如下：
- en: '![](images/42b9c97d-a199-40bb-8c16-7be46d4ec632.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](images/42b9c97d-a199-40bb-8c16-7be46d4ec632.png)'
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Tkinter has a `Menu` widget class that can be used for many kinds of menus,
    including top menu bars. As any other widget classes, menus are instantiated with
    the parent container as the first argument and some optional configuration options:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter有一个`Menu`小部件类，可用于许多种类型的菜单，包括顶部菜单栏。与任何其他小部件类一样，菜单是用父容器作为第一个参数和一些可选的配置选项来实例化的：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you run the preceding script, you can see that the `File` entry shows the
    secondary menu, and you can close the application by clicking the `Quit` menu
    button.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行上述脚本，您会看到“文件”条目显示次级菜单，并且可以通过单击“退出”菜单按钮关闭应用程序。
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'First, we instantiate each menu, indicating the parent container. The `tearoff`
    option, set to `1` by default, indicates that the menu can be detached by clicking
    on the dashed line of its top border. This behavior is not applied to the top
    menu bar, but if we want to deactivate this functionality, we have to set this
    option to `0`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们实例化每个菜单，指定父容器。`tearoff`选项默认设置为`1`，表示菜单可以通过单击其顶部边框的虚线分离。这种行为不适用于顶部菜单栏，但如果我们想要停用此功能，就必须将此选项设置为`0`：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Menu entries are arranged in the same order that they are added, using the
    `add_command`, `add_separator`, and `add_cascade` methods:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单条目按照它们添加的顺序排列，使用`add_command`、`add_separator`和`add_cascade`方法：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Usually, `add_command` is called with a `command` option, which is the callback
    invoked when the entry is clicked. There are no arguments passed to the callback
    function, exactly as with the `command` option of the Button widget.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`add_command`与`command`选项一起调用，当单击条目时会调用回调。与Button小部件的`command`选项一样，回调函数不会传递任何参数。
- en: For illustration purposes, we only added this option to the `Quit` entry to
    destroy the `Tk` instance and close the application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，我们只在“退出”选项中添加了这个选项，以销毁“Tk”实例并关闭应用程序。
- en: Finally, we attach the menu to the top-level window by calling `self.config(menu=menu)`.
    Note that each top-level window can only have a single menu bar configured.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用`self.config(menu=menu)`将菜单附加到顶层窗口。请注意，每个顶层窗口只能配置一个菜单栏。
- en: Using variables in menus
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在菜单中使用变量
- en: Apart from calling commands and nesting submenus, it is also possible to connect
    Tkinter variables to menu entries.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了调用命令和嵌套子菜单外，还可以将Tkinter变量连接到菜单条目。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will add a check button entry and three radio button entries to the Options submenu,
    divided by a separator. There will be two underlying Tkinter variables to store
    the selected values, so we can retrieve them easily from other methods of our
    application:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向“选项”子菜单添加一个复选框条目和三个单选按钮条目，之间用分隔符分隔。将有两个基础的Tkinter变量来存储所选值，因此我们可以轻松地从应用程序的其他方法中检索它们：
- en: '![](images/d882404a-5f1c-428e-b30d-784413ff31e6.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](images/d882404a-5f1c-428e-b30d-784413ff31e6.png)'
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'These types of entries are added with the `add_checkbutton` and `add_radiobutton`
    methods of the `Menu` widget class. Like with regular radio buttons, all are connected
    to the same Tkinter variable, but each one sets a different value:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的条目是使用`Menu`小部件类的`add_checkbutton`和`add_radiobutton`方法添加的。与常规单选按钮一样，所有条目都连接到相同的Tkinter变量，但每个条目设置不同的值：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Additionally, we are tracing the variable changes so you can see the values
    printed on the console when you run this application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们正在跟踪变量更改，以便在运行此应用程序时可以在控制台上看到打印的值。
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: To connect a Boolean variable to the `Checkbutton` entry, we first define `BooleanVar` and
    then create the entry by calling `add_checkbutton` using the `variable` option.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要将布尔变量连接到`Checkbutton`条目，我们首先定义`BooleanVar`，然后使用`variable`选项调用`add_checkbutton`创建条目。
- en: 'Remember that the `onvalue` and `offvalue` options should match the type of
    the Tkinter variable, as we do with regular RadioButton and CheckButton widgets:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`onvalue`和`offvalue`选项应与Tkinter变量的类型匹配，就像我们在常规RadioButton和CheckButton小部件中所做的那样：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`Radiobutton` entries are created in a similar fashion using the `add_radiobutton`
    method, and only a single `value` option to set to the Tkinter variable when the
    radio is clicked. Since `StringVar` initially holds the empty string value, we
    set it to the first radio value so that it will display as checked:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Radiobutton`条目是使用`add_radiobutton`方法以类似的方式创建的，当单击单选按钮时，只需设置一个`value`选项即可将其设置为Tkinter变量。由于`StringVar`最初保存空字符串值，因此我们将其设置为第一个单选按钮值，以便它显示为已选中：'
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Both variables trace the changes with the `mark_checked` and `mark_radio` methods,
    which simply print the variable values into the console.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 两个变量都使用`mark_checked`和`mark_radio`方法跟踪更改，这些方法只是将变量值打印到控制台。
- en: Displaying context menus
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示上下文菜单
- en: Tkinter menus do not necessarily have to be located on the menu bar, but they
    can actually be freely placed at any coordinate. These types of menus are called
    context menus, and they are usually displayed when users right-click on an item.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter菜单不一定要位于菜单栏上，而实际上可以自由放置在任何坐标。这些类型的菜单称为上下文菜单，通常在用户右键单击项目时显示。
- en: Context menus are widely used in GUI applications; for instance, file browsers
    display them to offer the available operations over the selected file, so it is
    intuitive for users to know how to interact with them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文菜单广泛用于GUI应用程序；例如，文件浏览器显示它们以提供有关所选文件的可用操作，因此用户知道如何与它们交互是直观的。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will build a context menu for a Text widget to display some common actions
    of text editors, such as Cut, Copy, Paste, and Delete:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为文本小部件构建一个上下文菜单，以显示文本编辑器的一些常见操作，例如剪切、复制、粘贴和删除：
- en: '![](images/c344d057-cdb3-4c33-9a5c-1cc2ecf55991.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](images/c344d057-cdb3-4c33-9a5c-1cc2ecf55991.png)'
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Instead of configuring a menu instance with a top-level container as a top menu
    bar, you can explicitly place it using its `post` method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 不是使用顶级容器作为顶部菜单栏来配置菜单实例，而是可以使用其`post`方法将其明确放置。
- en: 'All the commands in the menu entries call a method that uses the text instance
    to retrieve the current selection or the insertion position:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单条目中的所有命令都调用一个使用文本实例来检索当前选择或插入位置的方法：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We bind the right-click event to the `show_popup` handler for the text instance,
    which displays the menu with its top-left corner over the clicked position. Each
    time this event is triggered, the same menu instance is displayed again:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将右键单击事件绑定到文本实例的`show_popup`处理程序，该处理程序将菜单显示在右键单击位置的左上角。每次触发此事件时，都会再次显示相同的菜单实例：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following methods are available for all widget classes to interact with
    the clipboard:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有小部件类可用的以下方法与剪贴板交互：
- en: '`clipboard_clear()`: Clears the data from the clipboard'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除剪贴板中的数据
- en: '`clipboard_append(string)`: Appends a string to the clipboard'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clipboard_append(string)`: 将字符串附加到剪贴板'
- en: '`clipboard_get()`: Returns the data from the clipboard'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clipboard_get()`: 从剪贴板返回数据'
- en: 'The callback method for the *copy* action gets the current selection and adds
    it to the clipboard:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*复制*操作的回调方法获取当前选择并将其添加到剪贴板：'
- en: '[PRE16]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The *paste* action inserts the clipboard contents into the insertion cursor
    position, defined by the `INSERT` index. We have to wrap this in a `try...except`
    block, since calling `clipboard_get` raises a `TclError` if the clipboard is empty:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*粘贴*操作将剪贴板内容插入到由`INSERT`索引定义的插入光标位置。我们必须将此包装在`try...except`块中，因为调用`clipboard_get`会在剪贴板为空时引发`TclError`：'
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The *delete* action does not interact with the clipboard, but removes the contents
    of the current selection:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*删除*操作不与剪贴板交互，但会删除当前选择的内容：'
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Since the cut action is a combination of copy and delete, we reused these methods
    to compose its callback function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于剪切操作是复制和删除的组合，我们重用这些方法来组成其回调函数。
- en: There's more...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `postcommand` option allows you to reconfigure a menu each time it is displayed
    with the `post` method. To illustrate how to use this option, we will disable
    the cut, copy, and delete entries if there is no current selection in the Text
    widget and disable the paste entry if there are no contents in the clipboard.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`postcommand`选项允许您使用`post`方法每次显示菜单时重新配置菜单。为了说明如何使用此选项，如果文本小部件中没有当前选择，则我们将禁用剪切、复制和删除条目，并且如果剪贴板中没有内容，则禁用粘贴条目。'
- en: 'Like the rest of our callback functions, we pass a reference to a method of
    our class to add this configuration option:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的其他回调函数一样，我们传递了对我们类的方法的引用以添加此配置选项：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we check whether the `SEL` range exists to determine whether the state
    of the entries should be `ACTIVE` or `DISABLED`. This value is passed to the `entryconfig` method,
    which takes the index of the entry to configure as its first argument, and the
    list of options to be updated—remember that menu entries are `0` indexed:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查`SEL`范围是否存在，以确定条目的状态应为`ACTIVE`或`DISABLED`。将此值传递给`entryconfig`方法，该方法以要配置的条目的索引作为其第一个参数，并以要更新的选项列表作为其第二个参数-请记住菜单条目是`0`索引的：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For instance, all the entries should be grayed out if there is no selection
    or if there are no contents on the clipboard:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果没有选择或剪贴板上没有内容，所有条目都应该变灰。
- en: '![](images/f731180c-8a40-4ad9-a552-df57e3a48a4b.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](images/f731180c-8a40-4ad9-a552-df57e3a48a4b.png)'
- en: With `entryconfig`, it is also possible to configure many other options, such
    as the label, font, and background. Refer to [https://www.tcl.tk/man/tcl8.6/TkCmd/menu.htm#M48](https://www.tcl.tk/man/tcl8.6/TkCmd/menu.htm#M48)
    for a complete reference of available entry options.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`entryconfig`，还可以配置许多其他选项，如标签、字体和背景。请参阅[https://www.tcl.tk/man/tcl8.6/TkCmd/menu.htm#M48](https://www.tcl.tk/man/tcl8.6/TkCmd/menu.htm#M48)以获取可用条目选项的完整参考。
- en: Opening a secondary window
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开一个次要窗口
- en: The root `Tk` instance represents the main window of our GUI—when it is destroyed,
    the application quits and the event mainloop finishes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 根`Tk`实例代表我们GUI的主窗口——当它被销毁时，应用程序退出，事件主循环结束。
- en: However, there is another Tkinter class to create additional top-level windows
    in our application, called `Toplevel`. You can use this class to display any kind
    of window, from custom dialogs to wizard forms.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的应用程序中创建额外的顶层窗口的另一个Tkinter类是`Toplevel`。您可以使用这个类来显示任何类型的窗口，从自定义对话框到向导表单。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will start by creating a simple window that is opened when a button of the
    main window is clicked. It will contain a button that closes it and returns the
    focus to the main window:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个简单的窗口，当主窗口的按钮被点击时打开。它将包含一个关闭它并将焦点返回到主窗口的按钮：
- en: '![](images/f4f3b50d-7dd0-487d-8db4-022b57435aac.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](images/f4f3b50d-7dd0-487d-8db4-022b57435aac.png)'
- en: How to do it...
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `Toplevel` widget class creates a new top-level window, which acts as a
    parent container like the `Tk` instance does. Unlike the `Tk` class, you can instantiate
    as many top-level windows as you like:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Toplevel`小部件类创建一个新的顶层窗口，它像`Tk`实例一样作为父容器。与`Tk`类不同，您可以实例化任意数量的顶层窗口：'
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We define a `Toplevel` subclass to represent our custom window, whose relationship
    with the parent window is defined in its `__init__` method. Widgets are added
    to this window as usual, since we are following the same conventions as when we
    subclass `Tk`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个`Toplevel`子类来表示我们的自定义窗口，它与父窗口的关系在它的`__init__`方法中定义。小部件被添加到这个窗口，因为我们遵循与子类化`Tk`相同的约定：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The window is opened by simply creating a new instance, but in order to make
    it receive all the events, we have to call its `grab_set` method. This prevents
    users from interacting with the main window until this one is closed:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地创建一个新实例来打开窗口，但是为了使其接收所有事件，我们必须调用它的`grab_set`方法。这可以防止用户与主窗口交互，直到该窗口关闭为止。
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Handling window deletion
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理窗口删除
- en: Under some circumstances, you might want to perform an action before the user
    closes a top-level window, for instance, to prevent you losing unsaved work. Tkinter
    allows you to intercept this type of event to conditionally destroy the window.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望在用户关闭顶层窗口之前执行某个操作，例如，以防止丢失未保存的工作。Tkinter允许您拦截这种类型的事件以有条件地销毁窗口。
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will reuse the `App` class from the preceding recipe, and we will modify
    the `Window` class so that it shows a dialog to confirm closing the window:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用前面一篇文章中的`App`类，并修改`Window`类以显示一个对话框来确认关闭窗口：
- en: '![](images/4c58c76f-dc88-4947-ba95-45a14f8417e0.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](images/4c58c76f-dc88-4947-ba95-45a14f8417e0.png)'
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In Tkinter, we can detect when a window is about to be closed by registering
    a handler function for the `WM_DELETE_WINDOW` protocol. This can be triggered
    by clicking on the X button of the title bar on most desktop environments:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tkinter中，我们可以通过为`WM_DELETE_WINDOW`协议注册处理程序函数来检测窗口即将关闭的情况。这可以通过在大多数桌面环境的标题栏上点击X按钮来触发：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our handler method displays a dialog to confirm window deletion. In more complex
    programs, this logic is usually extended with additional validations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的处理程序方法显示一个对话框来确认窗口删除。在更复杂的程序中，这种逻辑通常会通过额外的验证来扩展。
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: While the `bind()` method is used to register handlers for widget events, the
    `protocol` method does the same for window manager protocols.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind()`方法用于为小部件事件注册处理程序，`protocol`方法用于为窗口管理器协议注册处理程序。'
- en: The `WM_DELETE_WINDOW` handler is called when a top-level window is about to
    be closed, and, by default, `Tk` destroys the window for which it was received.
    Since we are overriding this behavior by registering the `confirm_delete` handler,
    it needs to explicitly destroy the window if the dialog is confirmed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当顶层窗口即将关闭时，`WM_DELETE_WINDOW`处理程序被调用，默认情况下，`Tk`会销毁接收到它的窗口。由于我们通过注册`confirm_delete`处理程序来覆盖此行为，如果对话框得到确认，它需要显式销毁窗口。
- en: Another useful protocol is `WM_TAKE_FOCUS`, which is called when a window takes
    the focus.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的协议是`WM_TAKE_FOCUS`，当窗口获得焦点时会调用它。
- en: There's more...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Bear in mind that to keep the focus of the second window when the dialog is
    displayed, we have to pass the reference to the top-level instance, the `parent` option,
    to the dialog function:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，为了在显示对话框时保持第二个窗口的焦点，我们必须将对顶层实例的引用，`parent`选项，传递给对话框函数：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Otherwise, the dialog will take the root window as its parent, and you would
    see that it pops over the second window. These quirks may confuse your users,
    so it is a good practice to correctly set the parent of each top-level instance
    or dialog.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，对话框将以根窗口为其父窗口，并且您会看到它弹出到第二个窗口上。这些怪癖可能会让您的用户感到困惑，因此正确设置每个顶层实例或对话框的父窗口是一个好的做法。
- en: Passing variables between windows
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在窗口之间传递变量
- en: Two different windows may need to share information during program execution.
    While this data might be saved to disk and read from the window that consumes
    it, in some circumstances it is more straightforward to handle it in memory and
    simply pass this information as variables.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行期间，两个不同的窗口可能需要共享信息。虽然这些数据可以保存到磁盘并从使用它的窗口读取，但在某些情况下，更直接地在内存中处理它并将这些信息作为变量传递可能更简单。
- en: Getting ready
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The main window will contain three radio buttons to select the type of user
    that we want to create, and the secondary window will open the form to fill in
    the user data:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 主窗口将包含三个单选按钮，用于选择我们要创建的用户类型，并且次要窗口将打开表单以填写用户数据：
- en: '![](images/4a23ce5f-f29c-4fea-ac85-e96904c0d994.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](images/4a23ce5f-f29c-4fea-ac85-e96904c0d994.png)'
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'To hold the user data, we create `namedtuple` with fields that represent each
    user instance. This function from the `collections` module receives the type name
    and a sequence of field names, and returns a tuple subclass to create lightweight
    objects with the given fields:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保存用户数据，我们使用`namedtuple`创建了一个字段，代表每个用户实例。`collections`模块中的这个函数接收类型名称和字段名称序列，并返回一个元组子类，用于创建具有给定字段的轻量级对象：
- en: '[PRE26]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When the execution flow returns to the main window, the user data is printed
    to the console.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行流返回到主窗口时，用户数据将被打印到控制台。
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Most of the code of this recipe have already been covered in other recipes,
    and the main difference is contained in the `open()` method of the `UserForm`
    class, where we moved the call to `grab_set()`. However, the `wait_window()` method
    is what actually stops the execution and prevents us from returning the data before
    the form has been modified:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的大部分代码已经在其他示例中涵盖，主要区别在于`UserForm`类的`open()`方法中，我们将调用`grab_set()`移到了那里。然而，`wait_window()`方法实际上是停止执行并防止我们在表单被修改之前返回数据的方法：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It is important to remark that `wait_window()` enters a local event loop, which
    finishes when the window is destroyed. Although it is possible to pass the widget
    we want to wait to be removed, we can omit it to implicitly refer to the instance
    that calls this method.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，`wait_window()`进入一个本地事件循环，当窗口被销毁时结束。虽然可以传递我们想要等待移除的部件，但我们可以省略它以隐式地引用调用此方法的实例。
- en: 'When the `UserForm` instance is destroyed, the execution of the `open()` method
    continues, and it returns the `User` object that can now be used in the `App`
    class:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当`UserForm`实例被销毁时，`open()`方法的执行将继续，并返回`User`对象，现在可以在`App`类中使用：
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
