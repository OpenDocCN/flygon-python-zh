["```py\n>>> grid = [[1,0,1,0,1,0],[0,1,0,1,0,1],[1,0,1,0,1,0]]\n```", "```py\n      Pen.speed(0)\n          Pen.color(\"#0000000\")   #or Pen.color(0, 0, 0)\n```", "```py\n       def box(Dimension): #box method creates rectangular box\n               Pen.begin_fill()\n           # 0 deg.\n               Pen.forward(Dimension)\n               Pen.left(90)\n           # 90 deg.\n               Pen.forward(Dimension)\n               Pen.left(90)\n           # 180 deg.\n               Pen.forward(Dimension)\n               Pen.left(90)\n           # 270 deg.\n               Pen.forward(Dimension)\n               Pen.end_fill()\n               Pen.setheading(0)\n```", "```py\n      Pen.penup()\n      Pen.forward(-100)\n      Pen.setheading(90)\n      Pen.forward(100)\n      Pen.setheading(0)\n```", "```py\n      boxSize = 10\n```", "```py\n      grid_of_pixels = [[1,1,1,1,2,2,2,2,2,2,2,2,1,1,1,1]]\n      grid_of_pixels.append([1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1])\n      grid_of_pixels.append([1,1,1,0,0,0,3,3,3,3,3,0,3,1,1,1])\n      grid_of_pixels.append([1,1,0,3,0,3,3,3,3,3,3,0,3,3,3,1])\n      grid_of_pixels.append([1,1,0,3,0,0,3,3,3,3,3,3,0,3,3,3])\n      grid_of_pixels.append([1,1,0,0,3,3,3,3,3,3,3,0,0,0,0,1])\n      grid_of_pixels.append([1,1,1,1,3,3,3,3,3,3,3,3,3,3,1,1])\n      grid_of_pixels.append([1,1,1,0,0,2,0,0,0,0,2,0,1,1,1,1])\n      grid_of_pixels.append([1,1,0,0,0,2,0,0,0,0,2,0,0,0,1,1])\n      grid_of_pixels.append([0,0,0,0,0,2,2,2,2,2,2,0,0,0,0,0])\n      grid_of_pixels.append([3,3,3,0,2,3,2,2,2,2,3,2,0,3,3,3])\n      grid_of_pixels.append([3,3,3,3,2,2,2,2,2,2,2,2,3,3,3,3])\n      grid_of_pixels.append([3,3,3,2,2,2,2,1,1,2,2,2,2,3,3,3])\n      grid_of_pixels.append([1,1,1,2,2,2,1,1,1,1,2,2,2,1,1,1])\n      grid_of_pixels.append([1,0,0,0,0,1,1,1,1,1,1,0,0,0,0,1])\n      grid_of_pixels.append([0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0])\n```", "```py\n      palette = [\"#4B610B\" , \"#FAFAFA\" , \"#DF0101\" , \"#FE9A2E\"]\n```", "```py\n       for i in range (0,len(grid_of_pixels)):\n               for j in range (0,len(grid_of_pixels[i])):\n                   Pen.color(palette[grid_of_pixels[i][j]])\n                   box(boxSize)\n                   Pen.penup()\n                   Pen.forward(boxSize)\n                   Pen.pendown()    \n               Pen.setheading(270)\n               Pen.penup()\n               Pen.forward(boxSize)\n               Pen.setheading(180)\n               Pen.forward(boxSize*len(grid_of_pixels[i]))\n               Pen.setheading(0)\n               Pen.pendown()\n```", "```py\n>>> v = (1,2) #vector coordinates\n>>> v.move(3,4) # vector addition is done (1,2) + (3,4)\n>>> v\n(4,6)\n```", "```py\n>>> v = vector(1, 2)\n>>> v.rotate(90)\n>>> v == vector(-2, 1)\nTrue\n```", "```py\n      #following class will create vector \n      #representing current position of game character\n      class vector(collections.Sequence):\n          \"\"\"Two-dimensional vector.\n\n          Vectors can be modified in-place.\n\n          >>> v = vector(0, 1)\n          >>> v.move(1)\n          >>> v\n          vector(1, 2)\n          >>> v.rotate(90)\n          >>> v\n          vector(-2.0, 1.0)\n\n          \"\"\"\n\n          PRECISION = 6 #value 6 represents level of rounding\n          #for example: 4.53434343 => 4.534343\n          __slots__ = ('_x', '_y', '_hash')\n```", "```py\n      def __init__(self, x, y):\n              \"\"\"Initialize vector with coordinates: x, y.\n\n              >>> v = vector(1, 2)\n              >>> v.x\n              1\n              >>> v.y\n              2\n\n              \"\"\"\n              self._hash = None\n              self._x = round(x, self.PRECISION)\n              self._y = round(y, self.PRECISION)\n```", "```py\n      @property\n          def x(self):\n              \"\"\"X-axis component of vector.\n\n              >>> v = vector(1, 2)\n              >>> v.x\n              1\n              >>> v.x = 3\n              >>> v.x\n              3\n\n              \"\"\"\n              return self._x\n\n          @x.setter\n          def x(self, value):\n              if self._hash is not None:\n                  raise ValueError('cannot set x after hashing')\n              self._x = round(value, self.PRECISION)\n\n          @property\n          def y(self):\n              \"\"\"Y-axis component of vector.\n\n              >>> v = vector(1, 2)\n              >>> v.y\n              2\n              >>> v.y = 5\n              >>> v.y\n              5\n\n              \"\"\"\n              return self._y\n\n          @y.setter\n          def y(self, value):\n              if self._hash is not None:\n                  raise ValueError('cannot set y after hashing')\n              self._y = round(value, self.PRECISION)\n```", "```py\n      def __hash__(self):\n              \"\"\"v.__hash__() -> hash(v)\n\n              >>> v = vector(1, 2)\n              >>> h = hash(v)\n              >>> v.x = 2\n              Traceback (most recent call last):\n                  ...\n              ValueError: cannot set x after hashing\n\n              \"\"\"\n              if self._hash is None:\n                  pair = (self.x, self.y)\n                  self._hash = hash(pair)\n              return self._hash\n```", "```py\n      def copy(self):\n              \"\"\"Return copy of vector.\n\n              >>> v = vector(1, 2)\n              >>> w = v.copy()\n              >>> v is w\n              False\n\n              \"\"\"\n              type_self = type(self)\n              return type_self(self.x, self.y)\n```", "```py\n      def __iadd__(self, other):\n              \"\"\"v.__iadd__(w) -> v += w\n\n              >>> v = vector(1, 2)\n              >>> w = vector(3, 4)\n              >>> v += w\n              >>> v\n              vector(4, 6)\n              >>> v += 1\n              >>> v\n              vector(5, 7)\n\n              \"\"\"\n              if self._hash is not None:\n                  raise ValueError('cannot add vector after hashing')\n              elif isinstance(other, vector):\n                  self.x += other.x\n                  self.y += other.y\n              else:\n                  self.x += other\n                  self.y += other\n              return self\n```", "```py\n       def __add__(self, other):\n              \"\"\"v.__add__(w) -> v + w\n\n              >>> v = vector(1, 2)\n              >>> w = vector(3, 4)\n              >>> v + w\n              vector(4, 6)\n              >>> v + 1\n              vector(2, 3)\n              >>> 2.0 + v\n              vector(3.0, 4.0)\n\n              \"\"\"\n              copy = self.copy()\n              return copy.__iadd__(other)\n\n          __radd__ = __add__\n```", "```py\n      def move(self, other):\n              \"\"\"Move vector by other (in-place).\n\n              >>> v = vector(1, 2)\n              >>> w = vector(3, 4)\n              >>> v.move(w)\n              >>> v\n              vector(4, 6)\n              >>> v.move(3)\n              >>> v\n              vector(7, 9)\n\n              \"\"\"\n              self.__iadd__(other)\n```", "```py\n      import math\n      def rotate(self, angle):\n              \"\"\"Rotate vector counter-clockwise by angle (in-place).\n\n              >>> v = vector(1, 2)\n              >>> v.rotate(90)\n              >>> v == vector(-2, 1)\n              True\n\n              \"\"\"\n              if self._hash is not None:\n                  raise ValueError('cannot rotate vector after hashing')\n              radians = angle * math.pi / 180.0\n              cosine = math.cos(radians)\n              sine = math.sin(radians)\n              x = self.x\n              y = self.y\n              self.x = x * cosine - y * sine\n              self.y = y * cosine + x * sine\n```", "```py\n      from random import *\n      from turtle import *\n      from base import vector\n```", "```py\n      ant = vector(0, 0) #ant is character\n      aim = vector(2, 0) #aim is next position\n```", "```py\n      def wrap(value):\n          return value \n```", "```py\n      def draw():\n          \"Move ant and draw screen.\"\n          ant.move(aim)\n          ant.x = wrap(ant.x)\n          ant.y = wrap(ant.y)\n\n          aim.move(random() - 0.5)\n          aim.rotate(random() * 10 - 5)\n\n          clear()\n          goto(ant.x, ant.y)\n          dot(10)\n\n          if running:\n              ontimer(draw, 100)\n```", "```py\n      setup(420, 420, 370, 0)\n      hideturtle()\n      tracer(False)\n      up()\n      running = True\n      draw()\n      done()\n```", "```py\n      from turtle import *\n      from random import randrange\n      from base import vector\n```", "```py\n      def square(x, y, size, name):\n          \"\"\"Draw square at `(x, y)` with side length `size` and fill color \n           `name`.\n\n          The square is oriented so the bottom left corner is at (x, y).\n\n          \"\"\"\n          import turtle\n          turtle.up()\n          turtle.goto(x, y)\n          turtle.down()\n          turtle.color(name)\n          turtle.begin_fill()\n\n          for count in range(4):\n              turtle.forward(size)\n              turtle.left(90)\n\n          turtle.end_fill()\n```", "```py\n      from base import square\n```", "```py\n      food = vector(0, 0)\n      snake = [vector(10, 0)]\n      aim = vector(0, -10)\n```", "```py\n      def inside(head):\n          \"Return True if head inside boundaries.\"\n          return -200 < head.x < 190 and -200 < head.y < 190\n```", "```py\n      def move():\n          \"Move snake forward one segment.\"\n          head = snake[-1].copy()\n          head.move(aim)\n\n          if not inside(head) or head in snake:\n              square(head.x, head.y, 9, 'red')\n              update()\n              return\n\n          snake.append(head)\n\n          if head == food:\n              print('Snake:', len(snake))\n              food.x = randrange(-15, 15) * 10\n              food.y = randrange(-15, 15) * 10\n          else:\n              snake.pop(0)\n\n          clear()\n\n          for body in snake:\n              square(body.x, body.y, 9, 'black')\n\n          square(food.x, food.y, 9, 'green')\n          update()\n          ontimer(move, 100)\n```", "```py\n      setup(420, 420, 370, 0)\n      hideturtle()\n      tracer(False)\n```", "```py\n      def change(x, y):\n          \"Change snake direction.\"\n          aim.x = x\n          aim.y = y\n\n      listen()\n      onkey(lambda: change(10, 0), 'Right')\n      onkey(lambda: change(-10, 0), 'Left')\n      onkey(lambda: change(0, 10), 'Up')\n      onkey(lambda: change(0, -10), 'Down')\n      move()\n      done()\n```", "```py\n      from random import choice, random\n      from turtle import *\n      from base import vector\n```", "```py\n      def value():\n          \"Randomly generate value between (-5, -3) or (3, 5).\"\n          return (3 + random() * 2) * choice([1, -1])\n      ball = vector(0, 0)\n      aim = vector(value(), value())\n      state = {1: 0, 2: 0}\n```", "```py\n      def rectangle(x, y, width, height):\n          \"Draw rectangle at (x, y) with given width and height.\"\n          up()\n          goto(x, y)\n          down()\n          begin_fill()\n          for count in range(2):\n              forward(width)\n              left(90)\n              forward(height)\n              left(90)\n          end_fill()\n```", "```py\n      def draw():\n          \"Draw game and move pong ball.\"\n          clear()\n          rectangle(-200, state[1], 10, 50)\n          rectangle(190, state[2], 10, 50)\n\n          ball.move(aim)\n          x = ball.x\n          y = ball.y\n\n          up()\n          goto(x, y)\n          dot(10)\n          update()\n```", "```py\n      #when ball hits upper or lower boundary  \n      #Total height is 420 (-200 down and 200 up)\n          if y < -200 or y > 200: \n              aim.y = -aim.y\n      #when ball is near left boundary\n          if x < -185:\n              low = state[1]\n              high = state[1] + 50\n\n              #when player1 hits ball\n              if low <= y <= high:\n                  aim.x = -aim.x\n              else:\n                  return\n      #when ball is near right boundary\n          if x > 185:\n              low = state[2]\n              high = state[2] + 50\n\n              #when player2 hits ball\n              if low <= y <= high:\n                  aim.x = -aim.x\n              else:   \n                  return\n\n          ontimer(draw, 50)\n```", "```py\n      setup(420, 420, 370, 0)\n      hideturtle()\n      tracer(False)\n```", "```py\n      def move(player, change):\n          \"Move player position by change.\"\n          state[player] += change\n```", "```py\n      listen()\n      onkey(lambda: move(1, 20), 'w')\n      onkey(lambda: move(1, -20), 's')\n      onkey(lambda: move(2, 20), 'i')\n      onkey(lambda: move(2, -20), 'k')\n      draw()\n      done()\n```", "```py\n      from turtle import *\n      setup(420, 420, 370, 0)\n```", "```py\n      def inside(point):\n          \"Return True if point on screen.\"\n          return -200 < point.x < 200 and -200 < point.y < 200\n```", "```py\n      bird = vector(0, 0)\n      balls = []\n```", "```py\n      def draw(alive):\n          \"Draw screen objects.\"\n          clear()\n\n          goto(bird.x, bird.y)\n\n          if alive:\n              dot(10, 'green')\n          else:\n              dot(10, 'red')\n\n          for ball in balls:\n              goto(ball.x, ball.y)\n              dot(20, 'black')\n\n          update()\n```", "```py\n      from random import *\n      from base import vector #for vectored motion \n      def move():\n          \"Update object positions.\"\n          bird.y -= 5\n\n          for ball in balls:\n              ball.x -= 3\n```", "```py\n       if randrange(10) == 0:\n          y = randrange(-199, 199)\n          ball = vector(199, y)\n          balls.append(ball)    #append each obstacles to list\n```", "```py\n      while len(balls) > 0 and not inside(balls[0]):\n          balls.pop(0)\n```", "```py\n      if not inside(bird):\n          draw(False)\n          return\n```", "```py\n      for ball in balls:\n          if abs(ball - bird) < 15:         \n              draw(False)\n              return\n      draw(True)\n      ontimer(move, 50) #calls move function at every 50ms\n```", "```py\n      def tap(x, y):\n          \"Move bird up in response to screen tap.\"\n          up = vector(0, 30)\n          bird.move(up)\n```", "```py\n      hideturtle()\n      up()\n      tracer(False)\n      onscreenclick(tap)\n      move()\n      done()\n```", "```py\n      import turtle\n      # Paddle A\n      paddle_a = turtle.Turtle()\n      paddle_a.speed(0)\n      paddle_a.shape('square')\n      paddle_a.color('white')\n      paddle_a.penup()\n      paddle_a.goto(-350, 0)\n      paddle_a.shapesize(5, 1)\n\n      # Paddle B\n      paddle_b = turtle.Turtle()\n      paddle_b.speed(0)\n      paddle_b.shape('square')\n      paddle_b.color('white')\n      paddle_b.penup()\n      paddle_b.goto(350, 0)\n      paddle_b.shapesize(5, 1)\n```", "```py\n      # Ball\n      ball = turtle.Turtle()\n      ball.speed(0)\n      ball.shape('circle')\n      ball.color('white')\n      ball.penup()\n      ball.dx = 0.15\n      ball.dy = 0.15\n```", "```py\n      # Pen\n      pen = turtle.Turtle()\n      pen.speed(0)\n      pen.color('white')\n      pen.penup()\n      pen.goto(0, 260)\n      pen.write(\"Player A: 0  Player B: 0\", align='center', \n        font=('Courier', 24, 'bold'))\n      pen.hideturtle()\n\n      # Score\n      score_a = 0\n      score_b = 0\n```", "```py\n      def paddle_a_up():\n          y = paddle_a.ycor()\n          y += 20\n          paddle_a.sety(y)\n\n      def paddle_b_up():\n          y = paddle_b.ycor()\n          y += 20\n          paddle_b.sety(y)\n\n      def paddle_a_down():\n          y = paddle_a.ycor()\n          y += -20\n          paddle_a.sety(y)\n\n      def paddle_b_down():\n          y = paddle_b.ycor()\n          y += -20\n          paddle_b.sety(y)\n\n      # Keyboard binding\n      wn.listen()\n      wn.onkeypress(paddle_a_up, 'w')\n      wn.onkeypress(paddle_a_down, 's')\n      wn.onkeypress(paddle_b_up, 'Up')\n      wn.onkeypress(paddle_b_down, 'Down')\n```", "```py\n      wn = turtle.Screen()\n      wn.title('Pong')\n      wn.bgcolor('black')\n      wn.setup(width=800, height=600)\n      wn.tracer(0)\n```", "```py\nwhile True:\n    wn.update()\n\n    # Moving Ball\n    ball.setx(ball.xcor() + ball.dx)\n    ball.sety(ball.ycor() + ball.dy)\n\n    # Border checking\n    #1: For upper and lower boundary\n    if ball.ycor() > 290 or ball.ycor() < -290:\n        ball.dy *= -1\n\n    #2: for RIGHT boundary\n    if ball.xcor() > 390:\n        ball.goto(0, 0)\n        ball.dx *= -1\n        score_a += 1\n        pen.clear()\n        pen.write(\"Player A: {}  Player B: {}\".format(score_a, score_b), \n          align='center', font=('Courier', 24, 'bold'))\n\n    #3: For LEFT boundary\n    if ball.xcor() < -390:\n        ball.goto(0, 0)\n        ball.dx *= -1\n        score_b += 1\n        pen.clear()\n        pen.write(\"Player A: {}  Player B: {}\".format(score_a, score_b), \n          align='center', font=('Courier', 24, 'bold'))\n```", "```py\n# Paddle and ball collisions\n    if (ball.xcor() > 340 and ball.xcor() < 350) and (ball.ycor() \n        < paddle_b.ycor() + 60 and ball.ycor() > paddle_b.ycor() -60):\n\n        ball.setx(340)\n        ball.dx *= -1\n\n    if (ball.xcor() < -340 and ball.xcor() > -350) and (ball.ycor() \n        < paddle_a.ycor() + 60 and ball.ycor() > paddle_a.ycor() -60):\n\n        ball.setx(-340)\n        ball.dx *= -1\n```"]