["```py\n>>> import logging, sys\n>>> \n>>> logging.basicConfig(level=logging.INFO, stream=sys.stderr,\n...                     format='%(asctime)s %(name)s %(levelname)s: %(message)s')\n>>> log = logging.getLogger(__name__)\n```", "```py\n>>> def dosum(a, b, count=1):\n...     log.info('Starting sum')\n...     if a == b == 0:\n...         log.warning('Will be just 0 for any count')\n...     res = (a + b) * count\n...     log.info('(%s + %s) * %s = %s' % (a, b, count, res))\n...     print(res)\n... \n>>> dosum(5, 3)\n2018-02-11 22:07:59,870 __main__ INFO: Starting sum\n2018-02-11 22:07:59,870 __main__ INFO: (5 + 3) * 1 = 8\n8\n>>> dosum(5, 3, count=2)\n2018-02-11 22:07:59,870 __main__ INFO: Starting sum\n2018-02-11 22:07:59,870 __main__ INFO: (5 + 3) * 2 = 16\n16\n>>> dosum(0, 1, count=5)\n2018-02-11 22:07:59,870 __main__ INFO: Starting sum\n2018-02-11 22:07:59,870 __main__ INFO: (0 + 1) * 5 = 5\n5\n>>> dosum(0, 0)\n2018-02-11 22:08:00,621 __main__ INFO: Starting sum\n2018-02-11 22:08:00,621 __main__ WARNING: Will be just 0 for any count\n2018-02-11 22:08:00,621 __main__ INFO: (0 + 0) * 1 = 0\n0\n```", "```py\n$ python dosum.py 2>/dev/null\n8\n16\n5\n0\n```", "```py\nimport logging, sys\n\nif __name__ == '__main__':\n    if len(sys.argv) < 2:\n        print('Please provide logging file name as argument')\n        sys.exit(1)\n\n    logging_file = sys.argv[1]\n    logging.basicConfig(level=logging.INFO, filename=logging_file,\n                        format='%(asctime)s %(name)s %(levelname)s: %(message)s')\n\nlog = logging.getLogger(__name__)\n\ndef fibo(num):\n    log.info('Computing up to %sth fibonacci number', num)\n    a, b = 0, 1\n    for n in range(num):\n        a, b = b, a+b\n        print(b, '', end='')\n    print(b)\n\nif __name__ == '__main__':\n    import datetime\n    fibo(datetime.datetime.now().second)\n```", "```py\nimport logging\nimport logging.config\n\n# OSX logs through /var/run/syslog this should be /dev/log \n# on Linux system or a tuple ('ADDRESS', PORT) to log to a remote server\nSYSLOG_ADDRESS = '/var/run/syslog'\n\nlogging.config.dictConfig({\n    'version': 1,\n    'formatters': {\n        'default': {\n            'format': '%(asctime)s %(name)s: %(levelname)s %(message)s'\n        },\n    },\n    'handlers': {\n        'syslog': {\n            'class': 'logging.handlers.SysLogHandler',\n            'formatter': 'default',\n            'address': SYSLOG_ADDRESS\n        }\n    },\n    'root': {\n        'handlers': ['syslog'],\n        'level': 'INFO'\n    }\n})\n\nlog = logging.getLogger()\nlog.info('Hello Syslog!')\n```", "```py\n$ syslog | tail -n 2\nFeb 18 17:52:43 Pulsar Google Chrome[294] <Error>: ... SOME CHROME ERROR MESSAGE ...\nFeb 18 17:53:48 Pulsar 2018-02-18 17[4294967295] <Info>: 53:48,610 INFO root Hello Syslog!\n```", "```py\nimport argparse\nimport operator\nimport logging\nimport functools\n\nparser = argparse.ArgumentParser(\n    description='Applies an operation to one or more numbers'\n)\nparser.add_argument(\"number\", \n                    help=\"One or more numbers to perform an operation on.\",\n                    nargs='+', type=int)\nparser.add_argument('-o', '--operation', \n                    help=\"The operation to perform on numbers.\",\n                    choices=['add', 'sub', 'mul', 'div'], default='add')\nparser.add_argument(\"-v\", \"--verbose\", action=\"store_true\",\n                    help=\"increase output verbosity\")\n\nopts = parser.parse_args()\n\nlogging.basicConfig(level=logging.INFO if opts.verbose else logging.WARNING)\nlog = logging.getLogger()\n\noperation = getattr(operator, opts.operation)\nlog.info('Applying %s to %s', opts.operation, opts.number)\nprint(functools.reduce(operation, opts.number))\n```", "```py\n$ python /tmp/doop.py\nusage: doop.py [-h] [-o {add,sub,mul,div}] [-v] number [number ...]\ndoop.py: error: the following arguments are required: number\n```", "```py\n$ python /tmp/doop.py -h\nusage: doop.py [-h] [-o {add,sub,mul,div}] [-v] number [number ...]\n\nApplies an operation to one or more numbers\n\npositional arguments:\nnumber                One or more numbers to perform an operation on.\n\noptional arguments:\n-h, --help            show this help message and exit\n-o {add,sub,mul,div}, --operation {add,sub,mul,div}\n                        The operation to perform on numbers.\n-v, --verbose         increase output verbosity\n```", "```py\n$ python /tmp/dosum.py 1 2 3 4 -o mul\n24\n```", "```py\nparser.add_argument(\"number\", \n                    help=\"One or more numbers to perform an operation on.\",\n                    nargs='+', type=int)\n```", "```py\nparser.add_argument('-o', '--operation', \n                    help=\"The operation to perform on numbers.\",\n                    choices=['add', 'sub', 'mul', 'div'], default='add')\n```", "```py\nparser.add_argument(\"-v\", \"--verbose\", action=\"store_true\",\n                    help=\"increase output verbosity\")\n```", "```py\nopts = parser.parse_args()\n```", "```py\nlogging.basicConfig(level=logging.INFO if opts.verbose else logging.WARNING)\n```", "```py\noperation = getattr(operator, opts.operation)\nlog.info('Applying %s to %s', opts.operation, opts.number)\nprint(functools.reduce(operation, opts.number))\n```", "```py\nEMAILS = [\n    {'sender': 'author1@domain.com', 'subject': 'First email', \n     'body': 'This is my first email'},\n    {'sender': 'author2@domain.com', 'subject': 'Second email', \n     'body': 'This is my second email'},\n]\n\nimport cmd\nimport shlex\n\nclass MyMail(cmd.Cmd):\n    intro = 'Simple interactive email client.'\n    prompt = 'mymail> '\n\n    def __init__(self, *args, **kwargs):\n        super(MyMail, self).__init__(*args, **kwargs)\n        self.selected_email = None\n\n    def do_list(self, line):\n        \"\"\"list\n\n        List emails currently in the Inbox\"\"\"\n        for idx, email in enumerate(EMAILS):\n            print('[{idx}] From: {e[sender]} - \n                    {e[subject]}'.format(\n                    idx=idx, e=email\n            ))\n\n    def do_read(self, emailnum):\n        \"\"\"read [emailnum]\n\n        Reads emailnum nth email from those listed in the Inbox\"\"\"\n        try:\n            idx = int(emailnum.strip())\n        except:\n            print('Invalid email index {}'.format(emailnum))\n            return\n\n        try:\n            email = EMAILS[idx]\n        except IndexError:\n            print('Email {} not found'.format(idx))\n            return\n\n        print('From: {e[sender]}\\n'\n              'Subject: {e[subject]}\\n'\n              '\\n{e[body]}'.format(e=email))\n        # Track the last read email as the selected one for reply.\n        self.selected_email = idx\n\n    def do_reply(self, message):\n        \"\"\"reply [message]\n\n        Sends back an email to the author of the received email\"\"\"\n        if self.selected_email is None:\n            print('No email selected for reply.')\n            return\n\n        email = EMAILS[self.selected_email]\n        print('Replied to {e[sender]} with: {message}'.format(\n            e=email, message=message\n        ))\n\n    def do_send(self, arguments):\n        \"\"\"send [recipient] [subject] [message]\n\n        Send a new email with [subject] to [recipient]\"\"\"\n        # Split the arguments with shlex \n        # so that we allow subject or message with spaces. \n        args = shlex.split(arguments)\n        if len(args) < 3:\n            print('A recipient, a subject and a message are \n                  required.')\n            return\n\n        recipient, subject, message = args[:3]\n        if len(args) >= 4:\n            message += ' '.join(args[3:])\n\n        print('Sending email {} to {}: \"{}\"'.format(\n            subject, recipient, message\n        ))\n\n    def complete_send(self, text, line, begidx, endidx):\n        # Provide autocompletion of recipients for send command.\n        return [e['sender'] for e in EMAILS if e['sender'].startswith(text)]\n\n    def do_EOF(self, line):\n        return True\n\nif __name__ == '__main__':\n    MyMail().cmdloop()\n```", "```py\n$ python /tmp/mymail.py \nSimple interactive email client.\nmymail> help\n\nDocumented commands (type help <topic>):\n========================================\nhelp  list  read  reply  send\n\nUndocumented commands:\n======================\nEOF\n```", "```py\nmymail> list\n[0] From: author1@domain.com - First email\n[1] From: author2@domain.com - Second email\nmymail> read 0\nFrom: author1@domain.com\nSubject: First email\n\nThis is my first email\nmymail> reply Thanks for your message!\nReplied to author1@domain.com with: Thanks for your message!\n```", "```py\nmymail> help send\nsend [recipient] [subject] [message]\n\nSend a new email with [subject] to [recipient]\nmymail> send author\nauthor1@domain.com  author2@domain.com  \nmymail> send author2@domain.com \"Saw your email\" \"I saw your message, thanks for sending it!\"\nSending email Saw your email to author2@domain.com: \"I saw your message, thanks for sending it!\"\nmymail> \n```", "```py\nimport shutil\nimport textwrap, itertools\n\ndef maketable(cols):\n    term_size = shutil.get_terminal_size(fallback=(80, 24))\n    colsize = (term_size.columns // len(cols)) - 3\n    if colsize < 1:\n        raise ValueError('Column too small')\n    return '\\n'.join(map(' | '.join, itertools.zip_longest(*[\n        [s.ljust(colsize) for s in textwrap.wrap(col, colsize)] for col in cols\n    ], fillvalue=' '*colsize)))\n```", "```py\nCOLUMNS = 5\nTEXT = ['Lorem ipsum dolor sit amet, consectetuer adipiscing elit. '\n        'Aenean commodo ligula eget dolor. Aenean massa. '\n        'Cum sociis natoque penatibus et magnis dis parturient montes, '\n        'nascetur ridiculus mus'] * COLUMNS\n\nprint(maketable(TEXT))\n```", "```py\n$ python myscript.py > output.txt\n```", "```py\nimport shlex\nimport subprocess\n\ndef run(command):\n    try:\n        result = subprocess.check_output(shlex.split(command), \n                                         stderr=subprocess.STDOUT)\n        return 0, result\n    except subprocess.CalledProcessError as e:\n        return e.returncode, e.output\n```", "```py\nfor path in ('/', '/should_not_exist'):\n    status, out = run('ls \"{}\"'.format(path))\n    if status == 0:\n        print('<Success>')\n    else:\n        print('<Error: {}>'.format(status))\n    print(out)\n```", "```py\n<Success>\nApplications\nDeveloper\nLibrary\nLibraryPreferences\nNetwork\n...\n\n<Error: 2>\nls: cannot access /should_not_exist: No such file or directory\n```", "```py\nimport sys\nif len(sys.argv) < 2:\n    print('Please provide a directory')\n    sys.exit(1)\n_, out = run('ls {}'.format(sys.argv[1]))\nprint(out)\n```", "```py\nimport shutil, sys\n\ndef withprogressbar(func):\n    \"\"\"Decorates ``func`` to display a progress bar while running.\n\n    The decorated function can yield values from 0 to 100 to\n    display the progress.\n    \"\"\"\n    def _func_with_progress(*args, **kwargs):\n        max_width, _ = shutil.get_terminal_size()\n\n        gen = func(*args, **kwargs)\n        while True:\n            try:\n                progress = next(gen)\n            except StopIteration as exc:\n                sys.stdout.write('\\n')\n                return exc.value\n            else:\n                # Build the displayed message so we can compute\n                # how much space is left for the progress bar \n                  itself.\n                message = '[%s] {}%%'.format(progress)\n                # Add 3 characters to cope for the %s and %%\n                bar_width = max_width - len(message) + 3  \n\n                filled = int(round(bar_width / 100.0 * progress))\n                spaceleft = bar_width - filled\n                bar = '=' * filled + ' ' * spaceleft\n                sys.stdout.write((message+'\\r') % bar)\n                sys.stdout.flush()\n\n    return _func_with_progress\n```", "```py\nimport time\n\n@withprogressbar\ndef wait(seconds):\n    \"\"\"Waits ``seconds`` seconds and returns how long it waited.\"\"\"\n    start = time.time()\n    step = seconds / 100.0\n    for i in range(1, 101):\n        time.sleep(step)\n        yield i  # Send % of progress to withprogressbar\n\n    # Return how much time passed since we started, \n    # which is in fact how long we waited for real.\n    return time.time() - start\n```", "```py\nprint('WAITED', wait(5))\n```", "```py\n$ python /tmp/progress.py \n[=====================================] 100%\nWAITED 5.308781862258911\n```", "```py\ngen = func(*args, **kwargs)\nwhile True:\n    try:\n        progress = next(gen)\n    except StopIteration as exc:\n        sys.stdout.write('\\n')\n        return exc.value\n    else:\n        # display the progressbar\n```", "```py\ngen = func(*args, **kwargs)\n```", "```py\nprogress = next(gen)\n```", "```py\nsys.stdout.write('\\n')\n```", "```py\nsys.stdout.write((message+'\\r') % bar)\nsys.stdout.flush()\n```", "```py\nmessage = '[%s] {}%%'.format(progress)\nbar_width = max_width - len(message) + 3  # Add 3 characters to cope for the %s and %%\n\nfilled = int(round(bar_width / 100.0 * progress))\nspaceleft = bar_width - filled\nbar = '=' * filled + ' ' * spaceleft\n```", "```py\nfilled = int(round(bar_width / 100.0 * progress))\n```", "```py\nspaceleft = bar_width - filled\n```", "```py\nbar = '=' * filled + ' ' * spaceleft\n```", "```py\nsys.stdout.write((message+'\\r') % bar)\n```", "```py\nimport curses\nimport textwrap\nimport itertools\n\nclass MessageBox(object):\n    @classmethod\n    def show(cls, message, cancel=False, width=40):\n        \"\"\"Show a message with an Ok/Cancel dialog.\n\n        Provide ``cancel=True`` argument to show a cancel button \n        too.\n        Returns the user selected choice:\n\n            - 0 = Ok\n            - 1 = Cancel\n        \"\"\"\n        dialog = MessageBox(message, width, cancel)\n        return curses.wrapper(dialog._show)\n\n    def __init__(self, message, width, cancel):\n        self._message = self._build_message(width, message)\n        self._width = width\n        self._height = max(self._message.count('\\n')+1, 3) + 6\n        self._selected = 0\n        self._buttons = ['Ok']\n        if cancel:\n            self._buttons.append('Cancel')\n\n    def _build_message(self, width, message):\n        lines = []\n        for line in message.split('\\n'):\n            if line.strip():\n                lines.extend(textwrap.wrap(line, width-4,                                             \n                             replace_whitespace=False))\n            else:\n                lines.append('')\n        return '\\n'.join(lines)\n\n    def _show(self, stdscr):\n        win = curses.newwin(self._height, self._width, \n                            (curses.LINES - self._height) // 2, \n                            (curses.COLS - self._width) // 2)\n        win.keypad(1)\n        win.border()\n        textbox = win.derwin(self._height - 1, self._width - 3, \n                             1, 2)\n        textbox.addstr(0, 0, self._message)\n        return self._loop(win)\n\n    def _loop(self, win):\n        while True:\n            for idx, btntext in enumerate(self._buttons):\n                allowedspace = self._width // len(self._buttons)\n                btn = win.derwin(\n                    3, 10, \n                    self._height - 4, \n                    (((allowedspace-10)//2*idx) + allowedspace*idx \n                       + 2)\n                )\n                btn.border()\n                flag = 0\n                if idx == self._selected:\n                    flag = curses.A_BOLD\n                btn.addstr(1, (10-len(btntext))//2, btntext, flag)\n            win.refresh()\n\n            key = win.getch()\n            if key == curses.KEY_RIGHT:\n                self._selected = 1\n            elif key == curses.KEY_LEFT:\n                self._selected = 0\n            elif key == ord('\\n'):\n                return self._selected\n```", "```py\nMessageBox.show('Hello World,\\n\\npress enter to continue')\n```", "```py\nif MessageBox.show('Are you sure?\\n\\npress enter to confirm',\n                   cancel=True) == 0:\n    print(\"Yeah! Let's continue\")\nelse:\n    print(\"That's sad, hope to see you soon\")\n```", "```py\nimport curses\nfrom curses.textpad import Textbox, rectangle\n\nclass TextInput(object):\n    @classmethod\n    def show(cls, message, content=None):\n        return curses.wrapper(cls(message, content)._show)\n\n    def __init__(self, message, content):\n        self._message = message\n        self._content = content\n\n    def _show(self, stdscr):\n        # Set a reasonable size for our input box.\n        lines, cols = curses.LINES - 10, curses.COLS - 40\n\n        y_begin, x_begin = (curses.LINES - lines) // 2, \n                           (curses.COLS - cols) // 2\n        editwin = curses.newwin(lines, cols, y_begin, x_begin)\n        editwin.addstr(0, 1, \"{}: (hit Ctrl-G to submit)\"\n         .format(self._message))\n        rectangle(editwin, 1, 0, lines-2, cols-1)\n        editwin.refresh()\n\n        inputwin = curses.newwin(lines-4, cols-2, y_begin+2, \n        x_begin+1)\n        box = Textbox(inputwin)\n        self._load(box, self._content)\n        return self._edit(box)\n\n    def _load(self, box, text):\n        if not text:\n            return\n        for c in text:\n            box._insert_printable_char(c)\n\n    def _edit(self, box):\n        while True:\n            ch = box.win.getch()\n            if not ch:\n                continue\n            if ch == 127:\n                ch = curses.KEY_BACKSPACE\n            if not box.do_command(ch):\n                break\n            box.win.refresh()\n        return box.gather()\n```", "```py\nresult = TextInput.show('Insert your name:')\nprint('Your name:', result)\n```", "```py\nresult = TextInput.show('Insert your name:', \n                        content='Some Text\\nTo be edited')\nprint('Your name:', result)\n```"]