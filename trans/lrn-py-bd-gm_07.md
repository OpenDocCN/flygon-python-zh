# 列表推导和属性

“需要是发明之母”是一句流行的英语谚语，意思是迄今为止或将来发明的任何先驱性想法都是因为它们的需要。例如，巨大的视频托管平台 YouTube 之所以受欢迎，不仅是因为其商业模式，还因为它的推出时间。许多创意艺术家，如视频编辑者、歌手、舞者和游戏玩家，希望该平台能在全球范围内得到认可，而观众希望有一个可以免费学习和娱乐的平台。因此，需求是任何新发明的推动力。然而，这并不意味着每一个在正确时间创造的革命性想法都会成功。其中一些因为没有解决技术所带来的限制而失败。我们的异想天开受到这些技术的限制，尽管我们一直在进步，但我们还没有到达那里。

因此，为了使任何革命性的想法成功，我们必须了解我们的限制。我们的主要限制是内存空间和处理能力。在处理这些限制的同时，本章将教会我们编写一个优雅的程序，可以在一定程度上节省内存存储和运行时间。我们将学习 Python 提供的理解和生成，它们将使程序在保持可读性的同时运行得更快。

本章将涵盖以下主题：

+   代码复杂性概述

+   循环与列表推导的比较

+   装饰器

+   Python 属性

+   使用 LC 和属性完善贪吃蛇游戏

# 技术要求

您需要满足以下要求才能完成本章：

+   Python 3.5 或更新版本

+   Python IDLE（Python 的内置 IDE）

+   文本编辑器

+   网络浏览器

本章的文件可以在本书的 GitHub 存储库中找到：[`github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter07`](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter07)

查看以下视频，了解代码的运行情况：

[`bit.ly/2pzX8Au`](http://bit.ly/2pzX8Au)

# 代码复杂性概述

到目前为止，我们一直在学习 Python 的基础知识，如函数、数据结构和面向对象编程。现在，我们能够创建自己的逻辑，甚至编写一些游戏。随着我们继续为这些游戏添加功能，我们预计会有数百万行代码。这些庞大的代码行（LOC）将很难理解、解释和处理。例如，在某些情况下，我们可能需要在代码可维护性和优化之间进行权衡。假设您维护一个购物网站的代码，有一天您的网站被数百万次点击，这超出了服务器的处理速度。现在，您必须适应这样一种情况，即您必须要么在没有延迟的情况下为客户提供没有适当产品推荐的页面，要么在稍有延迟的情况下为客户提供适当的推荐。

另一方面，我们可能希望实现一定程度的代码优化。如果某个程序需要几秒钟才能执行，那么优化后，我们可能希望在一毫秒内运行它。现在，我们可能认为这段时间微不足道，但在第一次运行时确实如此。然而，当我们不得不运行相同的程序一千次时，我们可能会节省一些时间，这对于任何实时应用可能是有用的。

在本章中，我们将专注于修改我们的代码以提高其质量和效率的方法。如果我们设法使原始程序的代码更短，减少内存消耗并增加其执行速度，并减少输入/输出指令的交互，那么可以说任何原始程序都已经被优化了。优化的基本规则是，优化的结果必须与非优化的结果具有相同的输出和后果。

然而，当优化后的程序在时间和空间复杂性方面比非优化程序有利的结果时，这些要求可能是微不足道的。例如，在火箭发射活动中，我们可能希望获得周围区域的实时数据，而不在乎数据的准确性。因此，即使优化可能以某种方式影响系统的输出，但在这种情况下优化是重要的。

在学习优化之前，我们将先看看它的必要性。为了检查优化的空间，我们必须首先分析代码，而分析代码的主要方法是使用复杂性分析。算法复杂性分析是一个工具，它将解释程序随着程序大小的增加而表现的行为。当输入到程序中增加时，程序的大小也会增加。因此，我们必须根据数学`f(n)`函数来检查程序，其中*n*代表程序的输入。现在，你可能会想知道，运行这个算法是否会导致时间单位的差异，这取决于诸如 NASA 或苹果公司等公司使用的不同计算机，它们的处理能力比我们的简单计算机要高。因此，对我们的 PC 上运行的算法进行评判可能是不公平的。如果你曾经面对这种模棱两可的情况，那么恭喜你，因为你正在像程序员一样思考。为了测试算法是否独立于处理速度、磁盘能力和强大的软件，科学家们开发了一种称为渐近分析的东西。这种分析将检查算法与输入的大小，并且不记录执行所需的时间。我们称之为**时间复杂度**，它允许我们检查算法在输入数据大小方面的运行情况。为了观察算法的时间复杂度，我们应该使用最好和最知名的符号，即大 O 符号。这个符号将帮助我们分析算法的最坏情况，并帮助我们优化它。让我们使用一些简单的例子来分析以下复杂性：

+   `O(1)`: 这个符号用来定义与输入大小无关的算法。增加或减少输入数据的任何集合可能不会影响算法的执行速度：

```py
arr = [1,2,3,4,5]
for i in arr:
    print(arr[0])
```

前面的程序将打印数组的第一个元素，无论其中的数据是什么。因此，它的时间复杂度为`O(1)`。这被认为是最佳情况，很难在现实情况中实现。

+   `O(n)`: 这个符号描述了随着输入数据的大小`(n)`的增加，算法的运行时间将呈线性增加。例如，在下面的程序中，最坏情况可能导致我们遍历整个列表。因此，性能取决于输入的大小：

```py
      n = int(input("Enter any number"))
      for i in range(1,100):
          if i == n:
              print(i)
              break
```

+   `O(n²)`: 这个符号指定了与输入数据的平方大小成正比的算法的性能。在嵌套循环中非常常见。

还有一些其他符号，比如`O(2^N)`和`O(log N)`，但我们不需要再深入了解，因为我们已经学到足够多，可以区分好的代码和坏的代码。

现在我们已经获得了足够的关于优化的信息，以及我们如何分析算法的方式，是时候看一些例子来澄清非优化和优化代码之间的差异了。在深入分析以下代码的算法之前，我们将学习如何分析程序的复杂性。由于本书不打算教授高级算法概念，我们将研究评估性能和优化的基本思想。这将为您提供一个工具，帮助您编写更短、可读且不浪费内存资源的程序。因此，这种实践将使我们能够在根据场景的资源的有效使用方面，即时间和内存，区分算法时做出正确的决策。让我们开始看一下以下代码：

```py
for i in range(1, 10):
    for j in range(i):
        print(i, end='')
    print()

#output
1
22
333
4444
55555
666666
7777777
88888888
999999999
```

在前面的代码中，我们使用了两个嵌套的`for`循环来获得所需的输出。在第一个 for 循环的情况下，它逐个获取范围的所有元素，并且在每次迭代时，我们进行第二个 for 循环。对于第二个循环，我们将有相同元素的相同数量的范围计数。例如，对于元素 2，我们将在第二个 j 循环中得到[2,2]，从而多次打印相同的数字。如果您正确地遵循了前面的章节，那么这段代码应该不难理解。现在，让我们观察有趣的部分。我们知道第一个 i^([-])循环将迭代整个数据集的范围，这将导致时间复杂度为`O(n)`。j 循环也是如此。因此，总时间复杂度将是`O(n) * O(n)`，这将导致`O(n²)`。这代表了一个昂贵的算法。我们必须尝试将嵌套循环的程序转换为单个循环，如下所示：

```py
for i in range(1, 10):
        print (str(i) * i)

#output
1
22
333
4444
55555
666666
7777777
88888888
999999999
```

前面的程序包含一个单独的 for 循环，因此它将一次循环整个数据集，结果只会是`O(n)`而不是`O(n²)`。

您可能想知道为什么这些东西如此重要，为什么我们在本章中涵盖了它们。答案很简单。尽管在 Python 编写的某些应用程序中，即 Android 应用程序或网站，节省几毫秒可能是不必要的。但是，在处理大量数据的大型应用程序中，这种时间测量可能会增加。例如，让我们想象一个应用程序调用一个函数来预测新闻是否是假的。假设非优化的代码需要几秒钟来进行预测，而优化则需要几毫秒。在这里，数量似乎很小，但想象一下我们调用相同的函数 100 万次。现在，计算整体上将节省的时间：277.5 小时。

这很麻烦，不是吗？Python 提供了两种构造来促进这些庞大数据集的更快和更有效的处理：推导和生成器。推导有三种类型，即列表、字典和集合。首先，我们将深入学习列表推导。然后，我们将通过与它们相关联来探索另外两种（字典和集合）。

# 循环与列表推导

自从第三章以来，我们一直在使用循环编写我们的程序，*流程控制-为您的游戏构建决策制造者*，我们对循环模式非常熟悉，特别是对于循环。它们将迭代一些项目，并且在每次迭代时，迭代变量将执行一些操作。通过将 for 循环与适当的数据结构结合使用，可以减轻 for 循环的强大力量，就像这样：

```py
new_list = []
for i in range(10):
    new_list.append(i)
print(new_list)

#output
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Python 还有另一种更简单的方法来做同样的事情，即列表推导。列表推导的输出将始终是一个列表，这将是在 for 循环上下文中表达式评估的结果。这之后是条件。使用列表推导通过表达式和条件模拟`for`循环的代码将是单行代码。因此，使用列表推导编写的代码更短，更易于维护。要理解列表推导的工作原理，我们必须熟悉其模式。我们将在下一节学习列表推导模式。

# 列表推导模式

在本节中，我们将使用列表推导修改之前由`for`循环编写的代码。列表推导的结果是一个列表。方括号内的模式是一个表达式，后面跟着一个循环，如下所示：

```py
new_list = [i for i in range(10)]
print(new_list)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

在上面的代码中，左侧的对象，即`new_list`代表存储列表推导结果的输出列表。在右侧的表达式中，由方括号括起来的语句将导致列表推导。首先，我们传递要执行的表达式，然后是循环和条件（如果有的话）。以下插图表示了列表推导的模式：

![](img/e20c0782-2c51-466c-b885-f82aec9c0a0a.png)

让我们看一个简单的例子来解释上述模式：

```py
even_power  = [i * i          for i in range(5)         if i % 2 == 0]
print(even_power)
[0, 4, 16]
```

方括号内的第一个语句表示一个表达式。在使用列表推导时，只能有一个单一的表达式，而不像`for`循环的主体那样。在表达式之后，我们应用空格并提供迭代。我们也可以添加嵌套循环。在添加迭代之后，我们必须指定条件，如果有的话。列表推导广泛用于连接两个列表的元素并创建一个新的列表，如下所示：

```py
numbers = [1,2,3,4,5]
alphabets = ['a','b','c','d','e']

new_list = [[n,a] for n in numbers for a in alphabets]
print(new_list)

[[1, 'a'], [1, 'b'], [1, 'c'], [1, 'd'], [1, 'e'], [2, 'a'], [2, 'b'], [2, 'c'], [2, 'd'], [2, 'e'], [3, 'a'], [3, 'b'], [3, 'c'], [3, 'd'], [3, 'e'], [4, 'a'], [4, 'b'], [4, 'c'], [4, 'd'], [4, 'e'], [5, 'a'], [5, 'b'], [5, 'c'], [5, 'd'], [5, 'e']]
```

上面的代码能够创建一个复杂的列表。推导不仅限于列表；还有字典和集合的推导。对于列表，我们使用方括号进行推导。对于集合和字典推导，我们需要使用大括号`{}`。然而，这些推导的模式对所有这些推导都是相似的。让我们看一个例子：

```py
dict_comp = {x:chr(65+x) for x in range(1, 6)}
print(dict_comp)
{1: 'B', 2: 'C', 3: 'D', 4: 'E', 5: 'F'}
```

上面的代码表示了字典推导的用法。模式与列表推导类似，只是我们使用大括号进行推导。字典推导的结果将是一个字典。同样，在集合推导的情况下，推导的结果将是一个集合。这在下面的代码中显示：

```py
set_comp = {x ** 2 for x in range(5) if x % 2 == 0}
type(set_comp)
print(set_comp)

#output
<class 'set'>
{0, 16, 4}
```

在结束本节之前，我们必须介绍 Python 的两个强大的内置函数，它们可以比以往更快地操作集合的数据。如果你曾经有机会学习大数据，你应该听说过这两个词：zip 和 map。Python 提供了这两个函数，以便在最小的负载和更快的计算下处理大量数据。让我们看一个简单的例子来理解 zip 和 map 的概念。假设我们有两个包含有限整数的列表。现在，你必须编写一个程序来创建一个新的列表，该列表将存储每个列表中的最小数字。将对具有相同索引的元素进行比较：

```py
Input: a = [2,3,4,5,6,7] and b = [0,3,2,1,3,4]
Output: [0, 3, 2, 1, 3, 4]
```

最简单和常规的方法如下所示：

```py
a = [2,3,4,5,6,7] 
b = [0,3,2,1,3,4]
result = []
length = len(a)
for i in range(length):
    result.append(min(a[i],b[i]))
print(result)
#output
[0, 3, 2, 1, 3, 4]
```

现在，让我们学习另一种执行上述计算的方法。这是使用`zip`和`map`函数制作的单行代码。`zip`函数是一个简单的 Python 内置函数，它接受两个相等长度的对象并将它们合并在一起。如果你将两个相等长度的列表传递给`zip`函数，它将把它们合并成一个，以便在单个对象内执行计算。这在下面的代码中显示：

```py
>>> numbers = [1,2,3]
>>> letters = ['a','b','c']
>>> list(zip(numbers,letters))
[(1, 'a'), (2, 'b'), (3, 'c')]
```

我们知道应该进行数字之间的比较，因为它们具有相同的索引。因此，我们可以使用`zip`函数将原始数字数组与`zip`函数结合起来，以便我们可以将数字的元组存储在单个列表中，就像这样：

```py
>>> list(zip(a,b))
[(2, 0), (3, 3), (4, 2), (5, 1), (6, 3), (7, 4)]
```

# 映射函数

编程的主要任务是执行计算。对元素进行的操作可以独立于彼此进行；也就是说，我们可以分别对列表 a 和 b 进行比较，就像我们在前面的代码中所做的那样，或者简单地将它们合并，以便可以更快地进行比较。`zip`方法能够将长度相同的两个对象合并为一个新的可迭代对象。现在，主要任务是创建一个比较操作，并将其应用于可迭代对象的每个元素，这是通过使用`map`函数来完成的。`map`函数采用某个函数，并将其应用于可迭代对象的每个元素。

根据 Python 的官方文档，可以描述`map`如下：

*Map 将函数应用于可迭代对象的每个项目，并返回结果列表。如果传递了额外的可迭代参数，则函数必须采用相同数量的参数，并且并行应用于所有可迭代对象的项目。如果一个可迭代对象比另一个短，则假定它将被扩展为 None 项目。如果函数为 None，则假定为恒等函数；如果有多个参数，*`map()`*返回一个由包含所有可迭代对象对应项目的元组的列表（一种转置操作）。可迭代参数可以是序列或任何可迭代对象；结果始终是列表。*

调用 map 函数时传递的参数是一个函数，后面跟着可迭代对象。通常，我们使用匿名或 lambda 函数，例如`some_function`，它接受一些位置参数并将它们作为元组返回。这在以下代码中显示：

```py
map(some_function, some_iterables)
```

让我们创建一个简单的示例来说明`map`函数的用法：

```py
>>> map(lambda x: x*2, (1,2,3,4))
<map object at 0x057E9AF0>
```

前面的代码并不成功，因为`map`函数并不返回任何可迭代对象。相反，它打印表示地图对象的字符串。为了实现期望的结果，我们必须使用列表构造函数包装`map`方法，就像这样：

```py
>>> list(map(lambda x: x*2, (1,2,3,4)))
[2, 4, 6, 8]
```

现在，我们将使用`map`和`zip`函数的概念来找到两个列表中最小元素的列表。以下代码非常简单；我们首先定义了两个数组。之后，我们使用`map`函数，它将采用包含比较操作的`lambda`函数和`zip`方法，并将两个数组合并为元组列表。`zip`方法生成的每对元组都会传递给比较的`lambda`函数：

```py
>>> a = [2,3,4,5,6,7] 
>>> b = [0,3,2,1,3,4]
>>> list(map(lambda pair: min(pair), zip(a,b)))
[0, 3, 2, 1, 3, 4]
```

借助`map`和`zip`的功能，我们可以做任何事情，类似于列表推导。通过使用列表推导、`map`函数和 for 循环完成的前面的程序，我们可以看到以下运行时性能：

```py
For Loop: 4.56s
List comprehension: 2.345s
Map: 2..11s
```

因此，Python 的这三个特性主要使集合的操作比任何其他操作都更快。但就代码的可维护性和可读性而言，列表推导在提供有效定制程序内部工作方式的方法方面名列前茅。现在，是时候了解 Python 的另一个特性，即装饰器。这使我们能够修改现有对象的功能，而不修改其当前结构。

# 装饰器

装饰器是一种设计模式，它在不改变原始结构的情况下为现有对象添加新功能。我们必须习惯于 Python 中的一切都是对象，甚至函数也是对象。用于定义这些对象的不同名称只是它们的标识符。让我们运行以下代码：

```py
def fun1(info):
    print(info)

fun1("Good Morning")
fun2 = fun1
fun2("Good Morning")
```

当我们运行上面的代码时，`fun1`和`fun2`函数打印出相同的输出`"Good Morning"`，因为两者都指向相同的对象（函数）。因此，函数只是带有属性的对象。让我们回到装饰器。基本上，装饰器是一个构造，其中程序的一部分试图在编译时改变程序的另一部分的行为。对于函数来说，装饰器接受一个函数，为其添加独特的功能，最终返回它，如下所示：

```py
def decorate_it(func):
    def inner():
        print("Decorated")
        func()
    return inner

def non_Decorated():
    print("Not-Decorated")
```

现在，让我们尝试从 Python shell 中运行上面的代码：

```py
>>> non_Decorated()
Not-Decorated

#now try to decorate the above function
>>> decorate = decorate_it(non_Decorated)
>>> decorate()
Decorated
Not-Decorated
```

在上面的例子中，`decorate_it()`是一个装饰器，它以未装饰的函数作为参数。`decorate = decorate_it(non_Decorated)`语句是一个赋值语句，其中`Non_Decorated`函数被传递给装饰器，它返回了名为 decorate 的函数。因此，我们可以得出结论，装饰器是可调用的，返回一个可调用的。在上面的例子中，我们可以看到`decorate_it()`装饰器为`non_Decorated`或普通函数添加了一些功能。当装饰器开始变得有名气时，引入的设计模式是首先装饰函数，然后返回第二个可调用对象的名称，就像我们在这个例子中所做的那样。然而，程序员们发现这项工作是多余的。因此，他们开发了另一种语法，简化了前面的结构：使用`@`符号。

要装饰一个普通函数，我们使用`@`符号，加上装饰器的名称，并将其放在未装饰的函数的顶部，如下所示：

```py
@decorate_it
def non_Decorated():
    print("Not-Decorated")
```

上面的代码是下面的代码的辅助，我们之前写过：

```py
def non_Decorated():
    print("Not-Decorated")

decorate = decorate_it(non_Decorated)
```

让我们看另一个例子。我们想制作一个装饰器，它就像一个异常处理程序，当程序遇到异常活动时抛出错误消息。上面的装饰器很简单，因为它不关心传递给内部函数的参数。现在，我们将制作一个程序，它将乘以任意两个数字，但也处理错误，如果传递了其他数据，比如字符串或复数：

```py
def multiply(a,b):
    print(a*b)

>>> multiply(2,5)
10
>>> multiply('c', 'f')
TypeError: can't multiply sequence by non-int of type 'str'
```

现在，我们将尝试制作一个装饰器，它将检查我们是否得到了异常，就像在上面的代码中一样，并自动处理它：

```py
def smart_multiply(func):
    def inner(a,b):
        if (a.isdigit() and b.isdigit()):
            a = int(a)
            b = int(b)
            print("multiplying",a," with ",b)
            return func(a,b)
        else:
            print("Whoops!! Not valid multiplication")
            return
    return inner

@smart_multiply
def multiply(a,b):
    print(a*b)
a = input("value of a: ")
b = input("value of b: ")
multiply(a,b)
```

一旦你运行了上面的代码，你将被要求在 Python Shell 中输入条目。你必须为`a`和`b`输入两个实体，然后代码就会完成剩下的工作：

```py
value of a: 4
value of b: 5
multiplying 4 with 5
20
```

让我们再次运行上面的代码。这一次，我们将把`a`和`b`的值输入为字符串：

```py
value of a: t
value of b: y
Whoops!! Not valid multiplication
```

正如你所看到的，装饰器的`inner`函数具有与未装饰函数传入的参数相同的数量。因此，可以使用`inner(*args, **kwargs)`进行泛化，其中`args`是位置参数的元组，`kwargs`表示关键字参数的字典。现在，我们可以制作能够处理任意数量参数的装饰器，如下所示：

```py
def universal(func):
    def inner(*args, **kwargs):
        print("It works for any function")
        return func(*args,**kwargs)
    return inner
```

因此，在编译时，装饰器修改了原始函数、方法甚至类的操作，而不改变被装饰对象的代码。这最终导致了**不要重复自己**（**DRY**）技术的使用。在下一节中，我们将学习`@property`装饰器 - Python 的内置装饰器，用于实现`property()`函数。正如你可能还记得上一章所述，`@property`的这种构造已经被使用，并且它被定义为实现 getter 和 setter 的 Pythonic 方式。现在，我们将详细了解它。

# Python 属性

要理解首先使用属性的用法，我们必须回顾面向对象范式的一个原则：数据封装。这将数据与方法捆绑为一个单一的胶囊。将要获取和设置类的属性的方法称为 getter 和 setter。面向对象编程的这一原则暗示了类的属性必须私有化，以防止意外修改或盗窃。让我们从一个简单的例子开始：

```py
class Speed:
    def __init__(self, speed = 0):
        self.speed = speed

    def change_to_mile(self):
        return (self.speed*0.6213,"miles")
```

在上述代码中，我们创建了一个名为`Speed`的类，用于存储车辆的速度（以公里为单位）。它有一个`members`方法，用于将公里转换为英里。现在，我们可以创建`Speed`类的对象，并随意操纵这个类的成员。我们将使用 Python Shell 进行操作，如下所示：

```py
>>> car = Speed()
>>> car.speed = 45
>>> car.speed
45
>>> car.change_to_mile()
(27.958499999999997, ' miles')
```

每当对类的属性进行赋值时，Python 解释器都会维护一个字典，其中属性及其值被维护为键和值。在`Speed`类的情况下，我们可以使用`__dict__ 属性`检索对象的任何属性，即`speed`：

```py
>>> car.__dict__ {'speed': 45} 
```

因此，每当我们执行`car.speed`操作时，Python 解释器会在上述字典中进行搜索，并将值提取为`car.__dict__['speed']`。

现在，假设上述代码在交通控制领域全球范围内变得流行。有一天，交通警察提出应该对车辆的速度进行约束，以便可以执行法律。现在，我们必须修改代码，以便如果任何驾驶员驾驶速度过快，程序会向他们提供警告消息。我们可以使用 getter 和 setter 来实现这一点。在`setter`方法内部，我们可以使用条件语句明确检查车辆的最高速度。可以这样做：

```py
class Speed:
    def __init__(self, speed = 0):
        self.set_speed(speed)

    def change_to_mile(self):
        return (self.get_speed*0.6213," miles")

#new updates are made as follows using getter and setter
    def get_speed(self):
        return self._speed
    def set_speed(self, km):
        if km > 50:
            raise ValueError("You are liable to speeding ticket")
        self._speed = km
```

在上述代码中，进行了两个重大修改，我们对它们很熟悉。它们是`getter: get_speed`方法和`setter: set_speed`方法。在代码中进行的另一个更改是属性的签名。速度属性以单下划线开头，这使其成为私有属性（数据封装）。在 Python Shell 中尝试以下代码：

```py
>>> car = Speed(30)
>>> car.get_speed()
30
>>> car.set_speed(38)
>>> car.get_speed()
38
>>> car.set_speed(70)
ValueError: You are liable to speeding ticket
```

对原始程序的更新成功地反映了新的限制范围。驾驶员不被允许以超过 50 公里/小时的速度驾驶他们的车辆。

现在，让我们运行上述代码，并观察新更新可能引起的开销。我们可以简单地比较使用 getter 和 setter 编写的代码与不使用它们编写的代码。当您尝试调整原始代码以适应新更改时，将会出现一个主要的头痛问题，因为您必须修改代码，从调用`car.speed`对象的属性到调用`car.get_speed()`的属性。构造函数必须更改为`car.set_speed`（speed）。我们可能会发现在这个程序中进行更改更容易，但是想象一下，如果程序有 10,000 多行代码。对于任何程序员来说，更新和与新代码同步将是一件困难的事情。现在，属性装饰器开始发挥作用。以下代码为我们解决了这个问题：

```py
class Speed:
    def __init__(self, speed = 0):
        self.speed = speed

    def change_to_mile(self):
        return (self.speed*0.6213," miles")

    @property
    def speed(self):
        return self._speed

    @speed.setter
    def speed(self,km):
        if km > 50:
            raise ValueError("You are liable to speeding ticket")
        self._speed = km
```

由于我们熟悉装饰器，上述构造对我们来说应该是熟悉的。现在，让我们在 Python Shell 中运行我们的代码：

```py
>>> car = Speed(40)
>>> car.speed
40
```

使用属性构造，我们修改了原始类并提供了一些约束。但是这一次，我们移除了我们所做的更改，比如由 getter 和 setter 添加的`get_speed`和`set_speed`。因此，交通控制系统可以使用这个新代码，而不需要对原始代码进行任何更改，这导致了向后兼容性。

我们还有另一种实现上述代码的方法，那就是使用`property()`函数。以下代码等同于使用`@`属性构造编写的上述代码：

```py
class Speed:
    def __init__(self, speed = 0):
        self.speed = speed

    def change_to_mile(self):
        return (self.speed*0.6213," miles")

    def get_speed(self):
        return self._speed
    def set_speed(self, km):
        if km > 50:
            raise ValueError("You are liable to speeding ticket")
        self._speed = km

    #using property
    speed = property(get_speed,set_speed)
```

前面代码的最后一行创建了一个 speed 属性的对象。请记住，属性必须由可能被更改的属性组成。我们添加了一些代码，创建了属性的对象，并在括号内传递了 getter 和 setter 方法。现在，任何使用 speed 值的程序都会自动调用`get_speed`方法，任何分配 speed 值的程序都会调用`set_speed`方法，而无需查找由类管理的`dictionary(obj.__dict__)`。

现在，让我们利用本章学到的列表理解和属性知识来修改我们的蛇游戏。

# 使用 LC 和属性完善蛇游戏

这一部分将尽可能保持简洁，因为没有新内容可覆盖。现在我们已经详细学习了列表理解和属性，我们应该能够快速地覆盖这个主题，就像我们在上一章的总结中讨论的那样。简而言之：列表理解是一种从其他可迭代对象创建新元素列表的技术。列表理解语句由包含必须对每个元素进行转换的方括号组成，以及一个 for 循环。然后是一些条件。另一方面，`@property`或`property()`构造是实现 getter 和 setter 的 Pythonic 方式。

让我们来看看我们可以对蛇游戏进行的一些改进：

1.  首先，我们可以创建一个函数，检查蛇与边界或自身的碰撞。例如，如果蛇头的坐标(x,y)与其身体的坐标相同，我们就有了碰撞。这个逻辑可以用列表理解来实现：`[body.coor == self.head.coor for body in self.body_list[:-1]]`。以下表达式将在结果列表中存储一个 True 或 False 的布尔值。对于蛇身的每个位置，都会进行`body.coor == self.head.coor`的比较。以下代码行表示一个函数，根据碰撞检查返回 True 或 False：

```py
      def collided(self):
          return any([body.coor == self.head.coor
                          for body in self.body_list[:-1]])
```

1.  其次，我们可以用`@property`构造装饰前面的方法。由于我们已经详细介绍过，这不应该对我们造成任何困惑。如果有的话，让我来解释一下。`@property`的主要用途是支持向后兼容。我们可以修改类的规范并实现约束，而不实际修改分发给客户的先前版本的代码。同样，我们可以用`@property`装饰一个得分函数，因为我们需要更新它的时间值。因此，为了不断地将得分方法作为属性访问，我们可以像这样添加我们之前装饰的属性：

```py
      @property
      def score(self):
          return 'Score : {0}'.format(self.score)
```

属性和列表理解的前面实现都是使代码更易读和易维护的简单有效的方式。在企业级 Python 编程中，我们经常会发现这些类型的构造。

# 总结

本章揭示了理解和生成的高级概念，接着是一些示例及其在现实世界中的应用。我们看到了理解的用法和 Python 的一些内置函数，比如 map 和 zip，它们超越了 for 循环的性能。虽然这些理解和映射的概念可能被高估了，但如果我们有大量代码需要考虑性能而不是代码可读性，通常会发现它们很有帮助。本章还探讨了装饰器，它为现有代码添加了一些额外功能，而不影响其原始内容。然后，我们学习了属性装饰器的概念，这是一种 Pythonic 的实现方式，可以实现 getter 和 setter，同时保持向后兼容的代码。

从下一章开始，我们的主要目标可能会倾向于游戏编程。我们已经成功学习了 Python 的基本知识，以便成为熟练的游戏程序员。现在，我们将学习关于图形用户界面以及使用 Python 提供的模块（如 turtle 和 pygame）制作图形界面的方法。但在我们跳到下一章之前，请确保你已经正确地使用我们迄今为止编写的代码。对于任何程序员来说，能够逐行阅读代码是非常重要的。如果你已经对自己的技能有足够的信心，那么可以继续到下一章，我们将学习 turtle 模块，这是在游戏屏幕上绘制形状的基本方法。
