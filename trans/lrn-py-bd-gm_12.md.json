["```py\n#creates snow \nfor eachSnow in range(50):\n     x_pos = random.randrange(0, 500)\n     y_pos = random.randrange(0, 500)\n     pygame.draw.circle(displayScreen, (255,255,255) , [x_pos, y_pos], 2) #size:2\n```", "```py\nfor eachSnow in range(50):\n     x_pos = random.randrange(0, 500)\n     y_pos = random.randrange(0, 500)\n     snowArray.append([x_pos, y_pos])\n```", "```py\nfor eachSnow in range(len(snowArray)):\n # Draw the snow flake\n     pygame.draw.circle(displayScreen, (255,255,255) , snowArray[i], 2)\n```", "```py\n      color_WHITE = (255, 255, 255)\n      for eachSnow in range(len(snowArray)):\n\n       # Draw the snow flake\n       pygame.draw.circle(displayScreen, color_WHITE, snow_Array[i], 2)\n\n       # moving snow one step or pixel below\n       snowArray[i][1] += 1\n```", "```py\n      if snowArray[i][1] > 500:\n      # Reset it just above the top\n      y_pos = random.randrange(-50, -10)\n      snowArray[i][1] = y_pos\n      # Give it a new x position\n      x_pos = random.randrange(0, 500)\n      snowArray[i][0] = y_pos\n```", "```py\n      import pygame as p\n      import random as r\n\n      # Initialize the pygame\n      p.init()\n\n      color_code_black = [0, 0, 0]\n      color_code_white = [255, 255, 255]\n\n      # Set the height and width of the screen\n      DISPLAY = [500, 500]\n\n      WINDOW = p.display.set_mode(DISPLAY)\n\n      # Create an empty list to store position of snow\n      snowArray = []\n```", "```py\n      # Loop 50 times and add a snow flake in a random x,y position\n      for eachSnow in range(50):\n          x_pos = r.randrange(0, 500)\n          y_pos = r.randrange(0, 500)\n          snowArray.append([x_pos, y_pos])\n\n          objectClock = game.time.Clock()\n```", "```py\n      # Loop until the user clicks the close button.\n      finish = False\n      while not finish:\n\n           for anyEvent in p.event.get(): # User did something\n               if anyEvent.type == p.QUIT: # If user clicked close\n                   finish = True # Flag that we are done so we \n                            exit this loop\n\n       # Set the screen background\n               WINDOW.fill(BLACK)\n\n       # Process each snow flake in the list\n               for eachSnow in range(len(snowArray)):\n\n       # Draw the snow flake\n                   p.draw.circle(WINDOW, color_code_white, snowArray[i], 2)\n\n       # One step down for snow [falling of snow]\n                   snowArray[i][1] += 1\n```", "```py\n# checking if snow is out of boundary or not\n if snowArray[i][1] > 500:\n # reset if it from top\n y_pos = r.randrange(-40, -10)\n snowArray[i][1] = y_pos\n # New random x_position\n x_pos = r.randrange(0, 500)\n snowArray[i][0] = x_pos\n```", "```py\n      # Update screen with what you've drawn.\n          game.display.update()\n          objectClock.tick(20)\n\n      #if you remove following line of code, IDLE will hang at exit\n      game.quit()\n```", "```py\n import pygame\n      pygame.init()\n\n      win = pygame.display.set_mode((500,480)) pygame.quit()\n```", "```py\n #walk_Right contains images in which character is turning towards \n         Right direction \n      walkRight = [pygame.image.load('Right1.png'), \n pygame.image.load('Right2.png'), pygame.image.load('Right3.png'), \n pygame.image.load('Right4.png'), pygame.image.load('Right5.png'), \n       pygame.image.load('Right6.png'), pygame.image.load('Right7.png'), \n pygame.image.load('Right8.png'), pygame.image.load('Right9.png')]        #walk_left contains images in which character is turning towards \n         left direction\n      walkLeft = [pygame.image.load('Left1.png'), \n pygame.image.load('Left2.png'), pygame.image.load('Left3.png'), \n pygame.image.load('Left4.png'), pygame.image.load('Left5.png'), \n pygame.image.load('Left6.png'), pygame.image.load('Left7.png'), \n pygame.image.load('Left8.png'), pygame.image.load('Left9.png')]\n\n      #Background and stand still images\n      background = pygame.image.load('bg.jpg')\n      char = pygame.image.load('standing.png')\n```", "```py\n x = 50\n      y = 400\n      width = 40\n      height = 60\n      vel = 5\n\n      clock = pygame.time.Clock()\n```", "```py\n left = False\n      right = False\n      walkCount = 0\n```", "```py\n finish = False \n\n while not finish: clock.tick(27)\n```", "```py\n      while not finish:\n           clock.tick(27)\n           for anyEvent in pygame.event.get():\n              if anyEvent.type == pygame.QUIT:\n                  finish = True\n\n           keys = pygame.key.get_pressed()\n\n          #checking key pressed and if character is at x(boundary) or not?\n           if keys[pygame.K_LEFT] and x > vel: \n              x -= vel #going left by 5pixels\n              left = True\n              right = False\n\n          #checking RIGHT key press and is character coincides with \n             RIGHT boundary.\n          # value (500 - vel - width) is maximum width of screen, \n             thus x should be less\n           elif keys[pygame.K_RIGHT] and x < 500 - vel - width:  \n              x += vel #going right by 5pixels\n              left = False\n              right = True\n\n           else: \n              #not pressing any keys\n              left = False\n              right = False\n              walkCount = 0\n\n          Animation_Logic()\n```", "```py\ndef Animation_Logic():\n    global walkCount\n\n    win.blit(background, (0,0))  \n\n    #check_1\n    if walkCount + 1 >= 27:\n        walkCount = 0\n\n    if left:  \n        win.blit(walkLeft[walkCount//3], (x,y))\n        walkCount += 1                          \n    elif right:\n        win.blit(walkRight[walkCount//3], (x,y))\n        walkCount += 1\n    else:\n        win.blit(char, (x, y))\n        walkCount = 0\n\n    pygame.display.update()\n```", "```py\n import math\n import os\n from random import randint\n from collections import deque\n\n import pygame\n from pygame.locals import *\n\n      Frame_Rate = 60 #FPS\n      ANIMATION_SPEED = 0.18 # pixels per millisecond\n      WINDOW_WIDTH = 284 * 2 # Background image sprite size: 284x512 px;                                                                                                  \n                              #our screen is twice so to rendered twice: *2\n      WINDOW_HEIGHT = 512 \n```", "```py\n\n def loading_Images():\n       \"\"\"Function to load images\"\"\"\n  def loading_Image(image_name):\n\n \"\"\"Return the sprites of pygame by create unique filename so that \n           we can reference them\"\"\"\n new_filename = os.path.join('.', 'images', image_name)\n              image = pygame.image.load(new_filename) #loading with pygame \n                                                       module \n              image.convert()\n              return image\n\n          return {'game_background': loading_Image('background.png'),\n  'endPipe': loading_Image('endPipe.png'),\n  'bodyPipe': loading_Image('bodyPipe.png'),\n  # GIF format file/images are not supported by Pygame\n  'WingUp': loading_Image('bird-wingup.png'),\n  'WingDown': loading_Image('bird-wingdown.png')}\n```", "```py\ndef frames_to_msec(frames, fps=FPS):\n    \"\"\"Convert frames to milliseconds at the specified framerate.   Arguments: frames: How many frames to convert to milliseconds. fps: The framerate to use for conversion.  Default: FPS. \"\"\"  return 1000.0 * frames / fps\n\ndef msec_to_frames(milliseconds, fps=FPS):\n    \"\"\"Convert milliseconds to frames at the specified framerate.   Arguments: milliseconds: How many milliseconds to convert to frames. fps: The framerate to use for conversion.  Default: FPS. \"\"\"  return fps * milliseconds / 1000.0\n```", "```py\nclass Bird(pygame.sprite.Sprite):     WIDTH = HEIGHT = 50\n  SINK_SPEED = 0.18\n  CLIMB_SPEED = 0.3   CLIMB_DURATION = 333.3    def __init__(self, x, y, msec_to_climb, images):\n        \"\"\"Initialize a new Bird instance.\"\"\"    super(Bird, self).__init__() \n        self.x, self.y = x, y\n        self.msec_to_climb = msec_to_climb\n        self._img_wingup, self._img_wingdown = images\n        self._mask_wingup = pygame.mask.from_surface(self._img_wingup)\n        self._mask_wingdown = pygame.mask.from_surface(self._img_wingdown)\n```", "```py\n@property def image(self):\n    \"Gets a surface containing this bird image\"   if pygame.time.get_ticks() % 500 >= 250:\n        return self._img_wingup\n    else:\n        return self._img_wingdown\n\n@property def mask(self):\n    \"\"\"Get a bitmask for use in collision detection.   The bitmask excludes all pixels in self.image with a transparency greater than 127.\"\"\"  if pygame.time.get_ticks() % 500 >= 250:\n        return self._mask_wingup\n    else:\n        return self._mask_wingdown\n\n@property def rect(self):\n    \"\"\"Get the bird's position, width, and height, as a pygame.Rect.\"\"\"\n  return Rect(self.x, self.y, Bird.WIDTH, Bird.HEIGHT)\n```", "```py\ndef update(self, delta_frames=1):\n    \"\"\"Update the bird's position.\n One complete climb lasts CLIMB_DURATION milliseconds, during which the bird ascends with an average speed of CLIMB_SPEED px/ms. This Bird's msec_to_climb attribute will automatically be decreased accordingly if it was > 0 when this method was called.   Arguments: delta_frames: The number of frames elapsed since this method was last called. \"\"\"  if self.msec_to_climb > 0:\n        frac_climb_done = 1 - self.msec_to_climb/Bird.CLIMB_DURATION\n        #logic for climb movement\n        self.y -= (Bird.CLIMB_SPEED * frames_to_msec(delta_frames) *\n                   (1 - math.cos(frac_climb_done * math.pi)))\n        self.msec_to_climb -= frames_to_msec(delta_frames)\n    else:\n        self.y += Bird.SINK_SPEED * frames_to_msec(delta_frames)\n```", "```py\nclass PipePair(pygame.sprite.Sprite):\n    \"\"\"class that provides obstacles in the way of the bird in the form of pipe-pair.\"\"\" \n\n WIDTH = 80\n  HEIGHT_PIECE = 32\n  ADD_INTERVAL = 3000\n```", "```py\n def __init__(self, end_image_pipe, body_image_pipe):\n          \"\"\"Initialises a new random PipePair.  \"\"\"  self.x = float(WINDOW_WIDTH - 1)\n          self.score_counted = False\n  self.image = pygame.Surface((PipePair.WIDTH, WINDOW_HEIGHT), \n                       SRCALPHA)\n          self.image.convert() # speeds up blitting\n  self.image.fill((0, 0, 0, 0))\n\n        #Logic 1: **create pipe-pieces**--- Explanation is provided after\n                     the code\n total_pipe_body_pieces = int((WINDOW_HEIGHT - # fill window from \n                                                           top to bottom\n  3 * Bird.HEIGHT - # make room for bird to fit through\n  3 * PipePair.HEIGHT_PIECE) / # 2 end pieces + 1 body piece\n  PipePair.HEIGHT_PIECE # to get number of pipe pieces\n  )\n self.bottom_pipe_pieces = randint(1, total_pipe_body_pieces)\n self.top_pipe_pieces = total_pipe_body_pieces - \n self.bottom_pieces\n```", "```py\n       # bottom pipe\n  for i in range(1, self.bottom_pipe_pieces + 1):\n              piece_pos = (0, WIN_HEIGHT - i*PipePair.PIECE_HEIGHT)\n              self.image.blit(body_image_pipe, piece_pos)\n          end_y_bottom_pipe = WIN_HEIGHT - self.bottom_height_px\n          bottom_end_piece_pos = (0, end_y_bottom_pipe - \n                                 PipePair.PIECE_HEIGHT)\n          self.image.blit(end_image_pipe, bottom_end_piece_pos)\n\n          # top pipe\n  for i in range(self.top_pipe_pieces):\n              self.image.blit(body_image_pipe, (0, i * \n                   PipePair.PIECE_HEIGHT))\n          end_y_top_pipe = self.top_height_px\n          self.image.blit(end_image_pipe, (0, end_y_top_pipe))\n\n          # external end pieces are further added to make compensation\n  self.top_pipe_pieces += 1\n  self.bottom_pipe_pieces += 1    # for collision detection\n  self.mask = pygame.mask.from_surface(self.image)\n```", "```py\n@property def height_topPipe_px(self):\n \"\"\"returns the height of the top pipe, measurement is done in pixels\"\"\"\n  return (self.top_pipe_pieces * PipePair.HEIGHT_PIECE)\n\n@property def height_bottomPipe_px(self):\n \"\"\"returns the height of the bottom pipe, measurement is done in pixels\"\"\"\n  return (self.bottom_pipe_pieces * PipePair.HEIGHT_PIECE)\n\n@property def visible(self):\n    \"\"\"Get whether this PipePair on screen, visible to the player.\"\"\"\n  return -PipePair.WIDTH < self.x < WINDOW_WIDTH\n\n@property def rect(self):\n    \"\"\"Get the Rect which contains this PipePair.\"\"\"\n  return Rect(self.x, 0, PipePair.WIDTH, PipePair.HEIGHT_PIECE)\n```", "```py\ndef collides_with(self, bird):\n    \"\"\"check whether bird collides with any pipe in the pipe-pair. The \n       collide-mask deploy a method which returns a list of sprites--in \n       this case images of bird--which collides or intersect with \n       another sprites (pipe-pair)   Arguments: bird: The Bird which should be tested for collision with this PipePair. \"\"\"  return pygame.sprite.collide_mask(self, bird)\n```", "```py\ndef update(self, delta_frames=1):\n    \"\"\"Update the PipePair's position.   Arguments: delta_frames: The number of frames elapsed since this method was last called. \"\"\"  self.x -= ANIMATION_SPEED * frames_to_msec(delta_frames)\n```", "```py\n def main():\n          \"\"\"Only function that will be externally called, this \n            is main function  Instead of importing externally, if we call this function from \n            if **name** == __main__(), this main module will be executed.  \"\"\"   pygame.init()\n\n          display_surface = pygame.display.set_mode((WIN_WIDTH, \n              WIN_HEIGHT)) #display for screen\n\n          objectClock = pygame.time.Clock()   images = loading_Images()\n```", "```py\n       #at any moment of game, bird can only change its y position, \n         so x is constant\n          #lets put bird at center           Objectbird = Bird(50, int(WIN_HEIGHT/2 - Bird.HEIGHT/2), 2,\n  (images['WingUp'], images['WingDown']))\n\n          pipes = deque() \n      #deque is similar to list which is preferred otherwise \n         if we need faster operations like \n      #append and pop\n\n          frame_clock = 0 # this counter is only incremented \n            if the game isn't paused\n```", "```py\n  done = paused = False\n while not done:\n              clock.tick(FPS)\n\n              # Handle this 'manually'.  \n                If we used pygame.time.set_timer(),\n # pipe addition would be messed up when paused.  if not (paused or frame_clock % \n                msec_to_frames(PipePair.ADD_INTERVAL)):\n                  pipe_pair = PipePair(images['endPipe'], \n                    images['bodyPipe'])\n                  pipes.append(pipe_pair)\n```", "```py\n      *#handling events\n          **#Since Flappy Bird is Tapped game**\n **#we will handle mouse events***\n *for anyEvent in pygame.event.get():\n              #EXIT GAME IF QUIT IS PRESSED*\n *if anyEvent.type == QUIT or (anyEvent.type == KEYUP and \n                anyEvent.key == K_ESCAPE):*\n *done = True\n break elif anyEvent.type == KEYUP and anyEvent.key in \n              (K_PAUSE, K_p):* *paused = not paused*\n *elif anyEvent.type == MOUSEBUTTONUP or \n                (anyEvent.type == KEYUP and anyEvent.key in \n                (K_UP, K_RETURN, K_SPACE)):* *bird.msec_to_climb = \n                Bird.CLIMB_DURATION*\n\n           if paused: \n              continue #not doing anything [halt position]  \n```", "```py\n # check for collisions  pipe_collision = any(eachPipe.collides_with(bird) \n                for eachPipe in pipes)\n if pipe_collision or 0 >= bird.y or \n                bird.y >= WIN_HEIGHT - Bird.HEIGHT:\n done = True\n #blit background for position_x_coord in (0, WIN_WIDTH / 2):\n display_surface.blit(images['game_background'], \n                    (position_x_coord, 0))\n\n              #pipes that are out of visible, remove them\n while pipes and not pipes[0].visible:\n pipes.popleft()\n\n for p in pipes:\n p.update()\n display_surface.blit(p.image, p.rect)\n\n bird.update()\n display_surface.blit(bird.image, bird.rect) \n```", "```py\n              pygame.display.flip()\n              frame_clock += 1\n          print('Game Over!')\n          pygame.quit()\n      #----------uptill here add it to main function----------\n\n      if __name__ == '__main__':\n        #indicates two things:\n        #In case other program import this file, then value of \n           __name__ will be flappybird\n        #if we run this program by double clicking filename \n           (flappybird.py), main will be called\n\n          main()     #calling main function\n```", "```py\nscore = 0\nscoreFont = pygame.font.SysFont(None, 30, bold=True) #Score default font: WHITE\n\nwhile not done:\n    #after check for collision\n    # procedure for displaying and updating scores of player\n     for eachPipe in pipes:\n         if eachPipe.x + PipePair.WIDTH < bird.x and not \n           eachPipe.score_counted: \n            #when bird crosses each pipe\n             score += 1\n             eachPipe.score_counted = True\n\n     Surface_Score = scoreFont.render(str(score), \n        True, (255, 255, 255)) #surface\n     x_score_dim = WIN_WIDTH/2 - score_surface.get_width()/2 \n     #to render score, no y-position\n     display_surface.blit(Surface_Score, (x_score_dim, \n        PipePair.HEIGHT_PIECE)) #rendering\n\n     pygame.display.flip() #update\n     frame_clock += 1\nprint('Game over! Score: %i' % score)\npygame.quit() \n```", "```py\nWIDTH = HEIGHT = 30 #change it to make space between pipe pairs \n                     smaller/bigger SINK_SPEED = 0.18 #speed at which bird falls CLIMB_SPEED = 0.3 #when user taps on screen, it is climb speed\n                  #make it smaller to make game harder CLIMB_DURATION = 333.3\n```"]