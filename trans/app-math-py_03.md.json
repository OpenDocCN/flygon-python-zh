["```py\n          python3.8 -m pip install sympy\n\n```", "```py\nclass Polynomial:\n    \"\"\"Basic polynomial class\"\"\"\n\n    def __init__(self, coeffs):\n        self.coeffs = coeffs\n\n    def __repr__(self):\n        return f\"Polynomial({repr(self.coeffs)})\"\n\n    def __call__(self, x):\n        return sum(coeff*x**i for i, coeff \n                in enumerate(self.coeffs))\n```", "```py\n    def differentiate(self):\n        \"\"\"Differentiate the polynomial and return the derivative\"\"\"\n        coeffs = [i*c for i, c in enumerate(self.coeffs[1:], start=1)]\n        return Polynomial(coeffs)\n```", "```py\n    def integrate(self, constant=0):\n        \"\"\"Integrate the polynomial, returning the integral\"\"\"\n        coeffs = [float(constant)] \n        coeffs += [c/i for i, c in enumerate(self.coeffs, start=1)]\n        return Polynomial(coeffs)\n```", "```py\np = Polynomial([1, -2, 1])\np.differentiate()\n# Polynomial([-2, 2])\np.integrate(constant=1)\n# Polynomial([1.0, 1.0, -1.0, 0.3333333333])\n```", "```py\nimport sympy\n```", "```py\nx = sympy.symbols('x')\n```", "```py\nf = (x**2 - 2*x)*sympy.exp(3 - x)\n```", "```py\nfp = sympy.simplify(sympy.diff(f))  # (x*(2 - x) + 2*x - 2)\n                                                       *exp(3 - x)\n```", "```py\nfp2 = (2*x - 2)*sympy.exp(3 - x) - (x**2 - 2*x)*sympy.exp(3 - x)\n```", "```py\nsympy.simplify(fp2 - fp) == 0  # True\n```", "```py\nF = sympy.integrate(f, x)  # -x**2*exp(3 - x)\n```", "```py\nfrom sympy.utilities import lambdify\nlam_f = lambdify(x, f)\nlam_fp = lambdify(x, fp)\n```", "```py\nlam_f(4)  # 2.9430355293715387\nlam_fp(7)  # -0.4212596944408861\n```", "```py\nlam_f(np.array([0, 1, 2]))  # array([ 0\\. , -7.3890561, 0\\. ])\n```", "```py\nfrom scipy import optimize\n```", "```py\nfrom math import exp\n\ndef f(x):\n    return x*(x - 2)*exp(3 - x)\n```", "```py\ndef fp(x):\n    return -(x**2 - 4*x + 2)*exp(3 - x)\n```", "```py\noptimize.newton(f, 1, fprime=fp) # Using the Newton-Raphson method\n# 2.0\n```", "```py\noptimize.newton(f, 1., x1=1.5) # Using x1 = 1.5 and the secant method\n# 1.9999999999999862\n```", "```py\nfrom math import copysign\n\ndef bisect(f, a, b, tol=1e-5):\n    \"\"\"Bisection method for root finding\"\"\"\n    fa, fb = f(a), f(b)\n    assert not copysign(fa, fb) == fa, \"Function must change signs\"\n    while (b - a) > tol:\n        m = (b - a)/2 # mid point of the interval\n        fm = f(m)\n        if fm == 0:\n            return m\n        if copysign(fm, fa) == fm: # fa and fm have the same sign\n            a = m\n            fa = fm\n        else: # fb and fm have the same sign\n            b = m\n        return a\n```", "```py\noptimize.brentq(f, 1.0, 3.0)  # 1.9999999999998792\n```", "```py\nfrom scipy import integrate\n```", "```py\ndef erf_integrand(t):\n    return np.exp(-t**2)\n```", "```py\nval_quad, err_quad = integrate.quad(erf_integrand, -1.0, 1.0)\n# (1.493648265624854, 1.6582826951881447e-14)\n```", "```py\nval_quadr, err_quadr = integrate.quadrature(erf_integrand, -1.0,\n    1.0)\n# (1.4936482656450039, 7.459897144457273e-10)\n```", "```py\ndef trapezium(func, a, b, n_steps):\n    \"\"\"Estimate an integral using the trapezium rule\"\"\"\n    h = (b - a) / n_steps\n    x_vals = np.arange(a + h, b, h) \n    y_vals = func(x_vals)\n    return 0.5*h*(func(a) + func(b) + 2.*np.sum(y_vals))\n```", "```py\ndef f(t, y):\n    return -0.2*y\n\nt_range = (0, 5)\n```", "```py\nT0 = np.array([50.])\n```", "```py\ndef true_solution(t):\n    return 50.*np.exp(-0.2*t)\n```", "```py\nsol = integrate.solve_ivp(f, t_range, T0, max_step=0.1)\n```", "```py\nt_vals = sol.t\nT_vals = sol.y[0, :]\n```", "```py\nfig, (ax1, ax2) = plt.subplots(1, 2, tight_layout=True)\nax1.plot(t_vals, T_vals)\nax1.set_xlabel(\"$t$\")\nax1.set_ylabel(\"$T$\")\nax1.set_title(\"Solution of the cooling equation\")\n```", "```py\nerr = np.abs(T_vals - true_solution(t_vals))\n```", "```py\nax2.semilogy(t_vals, err)\nax2.set_xlabel(\"$t$\")\nax2.set_ylabel(\"Error\")\nax2.set_title(\"Error in approximation\")\n```", "```py\ndef euler(func, t_range, y0, step_size):\n    \"\"\"Solve a differential equation using Euler's method\"\"\"\n    t = [t_range[0]]\n    y = [y0]\n    i = 0\n```", "```py\n    while t[i] < t_range[1]:\n        i += 1\n        t.append(t[i-1] + step_size)  # step t\n        y.append(y[i-1] + step_size*func(t[i-1], y[i-1]))  # step y\n    return t, y\n```", "```py\ndef predator_prey_system(t, y):\n    return np.array([5*y[0] - 0.1*y[0]*y[1], 0.1*y[1]*y[0] -\n       6*y[1]])\n```", "```py\np = np.linspace(0, 100, 25)\nw = np.linspace(0, 100, 25)\nP, W = np.meshgrid(p, w)\n```", "```py\ndp, dw = predator_prey_system(0, np.array([P, W]))\n```", "```py\nfig, ax = plt.subplots()\nax.quiver(P, W, dp, dw)\nax.set_title(\"Population dynamics for two competing species\")\nax.set_xlabel(\"P\")\nax.set_ylabel(\"W\")\n```", "```py\ninitial_conditions = np.array([85, 40])\n```", "```py\nfrom scipy import integrate\nsol = integrate.solve_ivp(predator_prey_system, (0., 5.),\n   initial_conditions, max_step=0.01)\n```", "```py\nax.plot(initial_conditions[0], initial_conditions[1], \"ko\")\nax.plot(sol.y[0, :], sol.y[1, :], \"k\", linewidth=0.5)\n```", "```py\nfrom mpl_toolkits import mplot3d\n```", "```py\nalpha = 1\nx0 = 0 # Left hand x limit\nxL = 2 # Right hand x limit\n```", "```py\nN = 10\nx = np.linspace(x0, xL, N+1)\nh = (xL - x0) / N\n```", "```py\nk = 0.01\nsteps = 100\nt = np.array([i*k for i in range(steps+1)])\n```", "```py\nr = alpha*k / h**2\nassert r < 0.5, f\"Must have r < 0.5, currently r={r}\"\n```", "```py\nfrom scipy import sparse\ndiag = [1, *(1-2*r for _ in range(N-1)), 1]\nabv_diag = [0, *(r for _ in range(N-1))]\nblw_diag = [*(r for _ in range(N-1)), 0]\n\nA = sparse.diags([blw_diag, diag, abv_diag], (-1, 0, 1), shape=(N+1,\n      N+1), dtype=np.float64, format=\"csr\")\n```", "```py\nu = np.zeros((steps+1, N+1), dtype=np.float64)\n```", "```py\ndef initial_profile(x):\n    return 3*np.sin(np.pi*x/2)\n\nu[0, :] = initial_profile(x)\n```", "```py\nfor i in range(steps):\n    u[i+1, :] = A @ u[i, :]\n```", "```py\nX, T = np.meshgrid(x, t)\nfig = plt.figure()\nax = fig.add_subplot(projection=\"3d\")\n\nax.plot_surface(T, X, u, cmap=\"hot\")\nax.set_title(\"Solution of the heat equation\")\nax.set_xlabel(\"t\")\nax.set_ylabel(\"x\")\nax.set_zlabel(\"u\")\n```", "```py\nfor i in range(steps):\n    u[i+1, :] = A @ u[i, :] + f(t[i], x)\n```", "```py\ndiag = [1-r, *(1-2*r for _ in range(N-1)), 1-r]\nabv_diag = [*(r for _ in range(N))]\nblw_diag = [*(r for _ in range(N))]\n\nA = sparse.diags([blw_diag, diag, abv_diag], (-1, 0, 1), shape=(N+1, N+1), dtype=np.float64, format=\"csr\")\n```", "```py\ndef signal(t, freq_1=4.0, freq_2=7.0):\n    return np.sin(freq_1 * 2 * np.pi * t) + np.sin(freq_2 * 2 *\n        np.pi * t)\n```", "```py\nstate = np.random.RandomState(12345)\nsample_size = 2**7 # 128\nsample_t = np.linspace(0, 4, sample_size)\nsample_y = signal(sample_t) + state.standard_normal(sample_size)\nsample_d = 4./(sample_size - 1) # Spacing for linspace array\ntrue_signal = signal(sample_t)\n```", "```py\nfrom numpy import fft\n```", "```py\nfig1, ax1 = plt.subplots()\nax1.plot(sample_t, sample_y, \"k.\", label=\"Noisy signal\")\nax1.plot(sample_t, signal(sample_t), \"k--\", label=\"True signal\")\n\nax1.set_title(\"Sample signal with noise\")\nax1.set_xlabel(\"Time\")\nax1.set_ylabel(\"Amplitude\")\nax1.legend()\n```", "```py\nspectrum = fft.fft(sample_y)\n```", "```py\nfreq = fft.fftfreq(sample_size, sample_d)\npos_freq_i = np.arange(1, sample_size//2, dtype=int)\n```", "```py\npsd = np.abs(spectrum[pos_freq_i])**2 + np.abs(spectrum[-\n        pos_freq_i])**2\n```", "```py\nfig2, ax2 = plt.subplots()\nax2.plot(freq[pos_freq_i], psd)\nax2.set_title(\"PSD of the noisy signal\")\nax2.set_xlabel(\"Frequency\")\nax2.set_ylabel(\"Density\")\n```", "```py\nfiltered = pos_freq_i[psd > 1e4]\n```", "```py\nnew_spec = np.zeros_like(spectrum)\nnew_spec[filtered] = spectrum[filtered]\nnew_spec[-filtered] = spectrum[-filtered]\n```", "```py\nnew_sample = np.real(fft.ifft(new_spec))\n```", "```py\nfig3, ax3 = plt.subplots()\nax3.plot(sample_t, true_signal, color=\"#8c8c8c\", linewidth=1.5, label=\"True signal\")\nax3.plot(sample_t, new_sample, \"k--\", label=\"Filtered signal\")\nax3.legend()\nax3.set_title(\"Plot comparing filtered signal and true signal\")\nax3.set_xlabel(\"Time\")\nax3.set_ylabel(\"Amplitude\")\n```"]