["```py\nimport pygame\nimport random\n\n#declare GLOBALS\nwidth = 800\nheight = 700\n\n#since each shape needs equal width and height as of square \ngame_width = 300 #each block will have 30 width\ngame_height = 600 #each block will have 30 height\nshape_size = 30\n\n#check top left position for rendering shapes afterwards\n\ntop_left_x, top_left_y = (width - game_width) // 2, height - game_height\n```", "```py\n#Example for creating shapes I\nI = [['..**0**..',\n      '..**0**..',\n      '..**0**..',\n      '..**0**..',\n      '.....'],\n     ['.....',\n      '**0000**.',\n      '.....',\n      '.....',\n      '.....']] #each 0 indicates block for shapes\n```", "```py\n#for square shapes square = [['.....',\n      '.....',\n      '.00..',\n      '.00..',\n      '.....']]\n```", "```py\n#following is for shape I\n\"\"\" first element of list represents original structure,\n    Second element represents rotational shape of objects \"\"\" I = [['..0..',\n      '..0..',\n      '..0..',\n      '..0..',\n      '.....'],\n     ['.....',\n      '0000.',\n      '.....',\n      '.....',\n      '.....']]\n#for square shape\nO = [['.....',\n      '.....',\n      '.00..',\n      '.00..',\n      '.....']]\n\n#for shape J\nJ = [['.....',\n      '.0...',\n      '.000.',\n      '.....',\n      '.....'],\n     ['.....',\n      '..00.',\n      '..0..',\n      '..0..',\n      '.....'],\n     ['.....',\n      '.....',\n      '.000.',\n      '...0.',\n      '.....'],\n     ['.....',\n      '..0..',\n      '..0..',\n      '.00..',\n      '.....']]\n```", "```py\n#for shape L\nL = [['.....',\n      '...0.',\n      '.000.',\n      '.....',\n      '.....'],\n     ['.....',\n      '..0..',\n      '..0..',\n      '..00.',\n      '.....'],\n     ['.....',\n      '.....',\n      '.000.',\n      '.0...',\n      '.....'],\n     ['.....',\n      '.00..',\n      '..0..',\n      '..0..',\n      '.....']]\n#for shape T\nT = [['.....',\n      '..0..',\n      '.000.',\n      '.....',\n      '.....'],\n     ['.....',\n      '..0..',\n      '..00.',\n      '..0..',\n      '.....'],\n     ['.....',\n      '.....',\n      '.000.',\n      '..0..',\n      '.....'],\n     ['.....',\n      '..0..',\n      '.00..',\n      '..0..',\n      '.....']]\n```", "```py\ngame_objects = [I, O, J, L, T] #you can create as many as you want\nobjects_color = [(255, 255, 0), (255, 0, 0), (0, 0 , 255), (255, 255, 0), (128, 165, 0)] \n```", "```py\n#observe that this is not defined inside any class\ndef build_Grid(occupied = {}):\n    shapes_grid = [[(0, 0, 0) for _ *in range(10)] for* _ in range(20)]\n    for row in range(len(shapes_grid)):\n        for column in range(len(shapes_grid[row])):\n            if (column, row) in occupied:\n piece = occupied[(column, row)]\n shapes_grid[row][column] = piece\n    return shapes_grid\n```", "```py\nclass Shape:\n    no_of_rows = 20 #for y dimension\n    no_of_columns = 10 #for x dimension\n\n    #constructor\n    def __init__(self, column, row, shape):\n        self.x = column\n        self.y = row\n        self.shape = shape\n        #class attributes\n        self.color = objects_color[game_objects.index(shape)] \n#get color based on character indicated by shape name or shape variable\n        self.rotation = 0 \n```", "```py\ndef generate_shapes():\n     global game_objects, objects_color\n     return Shape(4, 0, random.choice(game_objects)) #creating instance\n```", "```py\ndef create_Grid(screen_surface, grid_scene):\n     screen_surface.fill(0, 0, 0) #black background\n     for i in range(len(grid_scene)):\n     for j in range(len(grid_scene[i])):\n\n #draw main rectangle which represents window\n     pygame.draw.rect(screen_surface, grid_scene[i][j], (top_left_x + \n       j* 30, top_left_y + i * 30, 30, 30), 0)\n #above code will draw a rectangle at the middle of surface screen \n\n    build_Grid(screen_surface, 20 , 10) #creating grid positions       \n    pygame.draw.rect(screen_surface, (255, 0, 0), (top_left_x, top_left_y, \n      game_width, game_height), 5)\n    pygame.display.update() \n```", "```py\n\"\"\"function that will create borders in each row and column positions \"\"\"\n\ndef show_grid(screen_Surface, grid):\n    \"\"\" --- following two variables will show from where to \n     draw lines---- \"\"\"\n    side_x = top_left_x\n    side_y = top_left_y \n    for eachRow in range(grid):\n        pygame.draw.line(screen_Surface, (128,128,128), (side_x, side_y+ \n        eachRow*30), (side_x + game_width, side_y + eachRow * 30))  \n         # drawing horizontal lines (30) \n        for eachCol in range(grid[eachRow]):\n            pygame.draw.line(screen_Surface, (128,128,128), (side_x + \n            eachCol * 30, side_y), (side_x + eachCol * 30, side_y +\n               game_height))  \n            # drawing vertical group of lines\n```", "```py\ndef main():\n occupied = {} #this refers to the shapes occupied into the screen\n grid = build_Grid(occupied)\n\n done = False\n current_shape = generate_shapes() #random shapes chosen from lists. \n next_shape = generate_shapes() \n clock = pygame.time.Clock()\n time_of_fall = 0 #for automatic fall of shapes\n\n while not done:\n for eachEvent in pygame.event.get():\n if eachEvent.type == pygame.QUIT:\n done = True\n exit()    \n```", "```py\n        if anyEvent.type == pygame.KEYDOWN:\n                if anyEvent.key == pygame.K_LEFT:\n                    current_shape.x -= 1  #go left with shape\n\n                elif anyEvent.key == pygame.K_RIGHT:\n                    current_shape.x += 1 #go right with shape\n\n                elif anyEvent.key == pygame.K_UP:\n                    # rotate shape with angle of rotation \n                     (rotation variable)\n                    current_shape.rotation = current_shape.rotation + 1 % \n                     len(current_shape.game_objects)\n\n                if anyEvent.key == pygame.K_DOWN:\n                    # moving current shape down into the grid\n                    current_shape.y += 1\n```", "```py\n    create_Grid(screen_surface) #screen surface will be initialized with \n                                 pygame below\n```", "```py\nscreen_surface = pygame.display.set_mode((width, height))\nmain() #calling only\n```", "```py\n#for square shapes square = [['.....',\n      '.....',\n      '.00..',\n      '.00..',\n      '.....']]\n```", "```py\ndef define_shape_position(shape_piece):\n    positions = []\n    list_of_shapes = shape_piece.game_objects[shape_piece.rotation % \n                     len(shape_piece.shape)]\n\n    for i, line in enumerate(list_of_shapes):\n        row = list(line)\n        for j, column in enumerate(row):\n            if column == '0':\n                positions.append((shape_piece.x + j, shape_piece.y + i))\n\n    for p, block_pos in enumerate(positions):\n        positions[p] = (block_pos[0] - 2, block_pos[1] - 4)\n\n    return positions\n```", "```py\ndef check_Moves(shape, grid):\n    \"\"\" checking if the background color of particular position is \n        black or not, if it is, that means position is not occupied \"\"\"\n\n    valid_pos = [[(j, i) for j in range(10) if grid[i][j] == (0,0,0)] \n                for i in range(20)] \n    \"\"\" valid_pos contains color code in i variable and \n        position in j variable--we have to filter to get only \n        j variable \"\"\"\n\n    valid_pos = [j for p in valid_pos for j in p]\n\n           \"\"\" list comprehension --same as writing\n                    for p in valid_pos:\n                        for j in p:\n                            p\n                            \"\"\"\n    \"\"\" Now get only the position from such shapes using \n        define_shape_position function \"\"\"\n    shape_pos = define_shape_position(shape)\n\n    \"\"\"check if pos is valid or not \"\"\"\n    for eachPos in shape_pos:\n        if eachPos not in valid_pos:\n            if eachPos[1] > -1: #eachPos[1] represents y value of shapes \n              and if it hits boundary\n                return False #not valid move\n\n    return True\n```", "```py\n global grid\n\n occupied = {} # (x pos, y pos) : (128, 0, 128)\n grid = build_Grid(occupied)\n change_shape = False\n done = False\n current_shape = generate_shapes()\n next_shape = generate_shapes()\n clock = pygame.time.Clock()\n timeforFall = 0\n\n while not done:\n speedforFall = 0.25\n\n grid = build_Grid(occupied)\n timeforFall += clock.get_rawtime()\n clock.tick()\n\n # code for making shape fall freely down the grid\n if timeforFall/1000 >= speedforFall:\n timeForFall = 0\n current_shape.y += 1 #moving downward\n #moving freely downward for invalid moves\n if not (check_Moves(current_shape, grid)) and current_shape.y > 0:\n current_shape.y -= 1\n change_shape = True\n```", "```py\nif anyEvent.type == pygame.KEYDOWN:\n                if anyEvent.key == pygame.K_LEFT:\n                    current_shape.x -= 1\n                    if not check_Moves(current_shape, grid):\n                        current_shape.x += 1  # not valid move thus \n                           free falling shape\n\n                elif anyEvent.key == pygame.K_RIGHT:\n                    current_shape.x += 1\n                   if not check_Moves(current_shape, grid):\n                        current_shape.x -= **1**\n      \"\"\" ROTATING OBJECTS \"\"\"\n                elif anyEvent.key == pygame.K_UP:\n\n                    current_shape.rotation = current_shape.rotation + 1 % \n len(current_shape.shape)\n                    if not check_Moves(current_shape, grid):\n                        current_shape.rotation = current_shape.rotation - 1 \n % len(current_shape.shape)\n\n\"\"\"Moving faster while user presses down action key \"\"\"\n                if anyEvent.key == pygame.K_DOWN:\n\n                    current_shape.y += 1\n                    if not check_Moves(current_shape, grid):\n                        current_shape.y -= 1\n```", "```py\n     position_of_shape = define_shape_position(current_shape) \n     \"\"\" define_shape_function was created to return position of blocks of \n         an object \"\"\"\n\n        # adding color to each objects in to the grid. \n        for pos in range(len(position_of_shape)):\n            x, y = position_of_shape[pos]\n\n            \"\"\" when shapes is outside the main grid, we don't care \"\"\"\n            if y > -1: # But if we are inside the screen or grid, \n               we add color\n                grid[y][x] = current_shape.color #adding color to the grid\n```", "```py\n    if change_shape:\n            for eachPos in position_of_shape:\n                pos = (eachPos[0], eachPos[1])\n                occupied[pos] = current_shape.color\n            current_shape = next_shape\n            next_shape = generate_shapes()\n            change_shape = False\n```", "```py\ncreate_Grid(screen_surface, grid)\n```", "```py\ndef delete_Row(grid, occupied):\n    # check if the row is occupied or not\n    black_background_color = (0, 0, 0)\n    number_of_rows_deleted = 0\n    for i in range(len(grid)-1,-1,-1):\n        eachRow = grid[i]\n        if black_background_color not in eachRow:\n            number_of_rows_deleted += 1\n\n            index_of_deleted_rows = i\n            for j in range(len(eachRow)):\n try:\n del occupied[(j, i)]\n                except:\n                    continue\n```", "```py\n#code should be added within delete_Row function outside for loop\nif number_of_rows_deleted > 0:       #if there is at least one rows deleted \n\n        for position in sorted(list(occupied), position=lambda x: \n          x[1])[::-1]:\n            x, y = position\n            if y < index_of_deleted_rows:\n                \"\"\" shifting operation \"\"\"\n                newPos = (x, y + number_of_rows_deleted)\n                occupied[newPos] = occupied.pop(position)\n\nreturn number_of_rows_deleted\n```", "```py\ndef main():\n    ...\n    while not done:\n        ... \n        if change_shape:\n            ...\n            change_shape = False\n            delete_Row(grid, occupied)\n```", "```py\n\ndef Welcome_Screen(surface):  \n    done = False\n    while not done:\n        surface.fill((128,0,128))\n        font = pygame.font.SysFont(\"comicsans\", size, bold=True)\n        label = font.render('Press ANY Key To Play Tetris!!', 1, (255, 255, \n                255))\n\n        surface.blit(label, (top_left_x + game_width /2 - \n         (label.get_width()/2), top_left_y + game_height/2 - \n          label.get_height()/2))\n\n        pygame.display.update()\n        for eachEvent in pygame.event.get():\n            if eachEvent.type == pygame.QUIT:\n                done = True\n            if event.type == pygame.KEYDOWN:\n                main(surface) #calling main when user enters Enter key \n\n    pygame.display.quit()\n```", "```py\ntimeforLevel = 0\n\nwhile not done:\n    speedforFall = 0.27 - timeforLevel \n    ...\n    if timeforLevel / 10000 > 0.5:\n        timeforLevel = 0\n        if timeforLevel > 0.15:\n            timeforLevel += 0.05\n    ...\n\n\"\"\"  ---------------------------------------------------\n        speedforFall = 0.24 will make object to fall faster comparative \n                       to speedforFall = 0.30 \n\n    ----------------------------------------------------- \"\"\" \n```", "```py\ndef increaseSpeed(score):\n    game_level = int(score*speedForFall)\n    speedforFall = 0.28 - (game_level)\n    return speedforFall\n```"]