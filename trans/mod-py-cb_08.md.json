["```py\n **[2016-05-08 11:08:18,651] INFO in ch09_r09: Sample Message One** \n\n **[2016-05-08 11:08:18,651] DEBUG in ch09_r09: Debugging** \n\n **[2016-05-08 11:08:18,652] WARNING in ch09_r09: Something might have gone wrong** \n\n```", "```py\n **>>> data = [ \n...    ('2016-04-24 11:05:01,462', 'INFO', 'module1', 'Sample Message One'), \n...    ('2016-04-24 11:06:02,624', 'DEBUG', 'module2', 'Debugging'), \n...    ('2016-04-24 11:07:03,246', 'WARNING', 'module1', 'Something might have gone wrong') \n... ]** \n\n```", "```py\n            import datetime \n\n    ```", "```py\n            def parse_date_iter(source): \n\n    ```", "```py\n            for item in source: \n\n    ```", "```py\n            date = datetime.datetime.strptime( \n                item[0], \n                \"%Y-%m-%d %H:%M:%S,%f\") \n            new_item = (date,)+item[1:] \n\n    ```", "```py\n            yield new_item \n\n    ```", "```py\n    import datetime \n    def parse_date_iter(source): \n        for item in source: \n            date = datetime.datetime.strptime( \n                item[0], \n                \"%Y-%m-%d %H:%M:%S,%f\") \n            new_item = (date,)+item[1:] \n            yield new_item \n\n```", "```py\n **>>> from pprint import pprint \n>>> from ch08_r01 import parse_date_iter \n>>> for item in parse_date_iter(data): \n...     pprint(item) \n(datetime.datetime(2016, 4, 24, 11, 5, 1, 462000), \n 'INFO', \n 'module1', \n 'Sample Message One') \n(datetime.datetime(2016, 4, 24, 11, 6, 2, 624000), \n 'DEBUG', \n 'module2', \n 'Debugging') \n(datetime.datetime(2016, 4, 24, 11, 7, 3, 246000), \n 'WARNING', \n 'module1', \n 'Something might have gone wrong')** \n\n```", "```py\n **>>> details = list(parse_date_iter(data))** \n\n```", "```py\n **>>> parse_date_iter(data) \n<generator object parse_date_iter at 0x10167ddb0>** \n\n```", "```py\n    for i in some_collection: \n        process(i) \n\n```", "```py\n    the_iterator = iter(some_collection) \n    try: \n        while True: \n            i = next(the_iterator) \n            process(i) \n    except StopIteration: \n        pass \n\n```", "```py\n **>>> def gen_func(): \n...     print(\"pre-yield\") \n...     yield 1 \n...     print(\"post-yield\") \n...     yield 2** \n\n```", "```py\n **>>> y = gen_func() \n>>> next(y) \npre-yield \n1 \n>>> next(y) \npost-yield \n2** \n\n```", "```py\n **>>> next(y)  \nTraceback (most recent call last): \n  File \"<pyshell...>\", line 1, in <module> \n    next(y) \nStopIteration** \n\n```", "```py\n    def primeset(source): \n        for i in source: \n            if prime(i): \n                yield prime \n\n```", "```py\n    p_10 = set(primeset(range(2,2000000))) \n\n```", "```py\n    p_10 = {i for i in range(2,2000000) if prime(i)} \n\n```", "```py\n    def map(m, S): \n        for s in S: \n            yield m(s) \n\n```", "```py\n    def filter(f, S): \n        for s in S: \n            if f(s): \n                yield s \n\n```", "```py\n    p_10 = set(filter(prime, range(2,2000000))) \n\n```", "```py\n **>>> from pathlib import Path \n>>> import csv \n>>> with Path('code/fuel.csv').open() as source_file: \n...    reader = csv.reader(source_file) \n...    log_rows = list(reader) \n>>> log_rows[0] \n['date', 'engine on', 'fuel height'] \n>>> log_rows[-1] \n['', \"choppy -- anchor in jackson's creek\", '']** \n\n```", "```py\n    total_time = datetime.timedelta(0) \n    total_fuel = 0 \n    for row in date_conversion(row_merge(source_data)): \n        total_time += row['end_time']-row['start_time'] \n        total_fuel += row['end_fuel']-row['start_fuel'] \n\n```", "```py\n            def row_merge(source_iter): \n                group = [] \n                for row in source_iter: \n                    if len(row[0]) != 0: \n                        if group: \n                            yield group \n                        group = row.copy() \n                    else: \n                        group.extend(row) \n                if group: \n                    yield group \n\n    ```", "```py\n            import datetime \n            def start_datetime(row): \n                travel_date = datetime.datetime.strptime(row[0], \"%m/%d/%y\").date() \n                start_time = datetime.datetime.strptime(row[1], \"%I:%M:%S %p\").time() \n                start_datetime = datetime.datetime.combine(travel_date, start_time) \n                new_row = row+[start_datetime] \n                return new_row \n\n            def end_datetime(row): \n                travel_date = datetime.datetime.strptime(row[0], \"%m/%d/%y\").date() \n                end_time = datetime.datetime.strptime(row[4], \"%I:%M:%S %p\").time() \n                end_datetime = datetime.datetime.combine(travel_date, end_time) \n                new_row = row+[end_datetime] \n                return new_row \n\n    ```", "```py\n            for starting and ending.def duration(row): \n                travel_hours = round((row[10]-row[9]).total_seconds()/60/60, 1) \n                new_row = row+[travel_hours] \n                return new_row \n\n    ```", "```py\n            def skip_header_date(rows): \n                for row in rows: \n                    if row[0] == 'date': \n                        continue \n                    yield row \n\n    ```", "```py\n            def date_conversion(source): \n                tail_gen = skip_header_date(source) \n                start_gen = (start_datetime(row) for row in tail_gen) \n                end_gen = (end_datetime(row) for row in start_gen) \n                duration_gen = (duration(row) for row in end_gen) \n                return duration_gen \n\n    ```", "```py\n    for row in date_conversion(row_merge(data)): \n        print(row[11]) \n\n```", "```py\n    for row in fuel_use(date_conversion(row_merge(data))): \n        print(row[11]) \n\n```", "```py\n    from types import SimpleNamespace \n\n    def make_namespace(merge_iter): \n        for row in merge_iter: \n            ns = SimpleNamespace( \n                date = row[0], \n                start_time = row[1], \n                start_fuel_height = row[2], \n                end_time = row[4], \n                end_fuel_height = row[5], \n                other_notes = row[7] \n            ) \n            yield ns \n\n```", "```py\n    def duration(row_ns): \n        travel_time = row_ns.end_timestamp - row_ns.start_timestamp \n        travel_hours = round(travel_time.total_seconds()/60/60, 1) \n        return SimpleNamespace( \n            **vars(row_ns), \n            travel_hours=travel_hours \n        )\n\n```", "```py\n    def duration(row_ns): \n        travel_time = row_ns.end_timestamp - row_ns.start_timestamp \n        row_ns.travel_hours = round(travel_time.total_seconds()/60/60, 1) \n        return row_ns \n\n```", "```py\n    for item in source: \n        new_item = some transformation of item \n        yield new_item \n\n```", "```py\n    def start_gen(tail_gen): \n        for row in tail_gen: \n            new_row = start_datetime(row) \n            yield new_row \n\n```", "```py\n    start_gen = (start_datetime(row) for row in tail_gen) \n\n```", "```py\n **>>> data = [ \n...    ('2016-04-24 11:05:01,462', 'INFO', 'module1', 'Sample Message One'), \n...    ('2016-04-24 11:06:02,624', 'DEBUG', 'module2', 'Debugging'), \n...    ('2016-04-24 11:07:03,246', 'WARNING', 'module1', 'Something might have gone wrong') \n... ]** \n\n```", "```py\n    import datetime \n    def parse_date_iter(source): \n        for item in source: \n            date = datetime.datetime.strptime( \n                item[0], \n                \"%Y-%m-%d %H:%M:%S,%f\") \n            new_item = (date,)+item[1:] \n            yield new_item \n\n```", "```py\n    for row in parse_date_iter(data): \n        print(row[0], row[3]) \n\n```", "```py\n    for item in source: \n        new_item = transformation(item) \n        yield new_item \n\n```", "```py\n            def parse_date(item): \n                date = datetime.datetime.strptime( \n                    item[0], \n                    \"%Y-%m-%d %H:%M:%S,%f\") \n                new_item = (date,)+item[1:] \n                return new_item \n\n    ```", "```py\n            for item in collection: \n                new_item = parse_date(item) \n                yield new_item \n\n    ```", "```py\n            (parse_date(item) for item in data) \n\n    ```", "```py\n            map(parse_date, data) \n\n    ```", "```py\n            for row in map(parse_date, data): \n                print(row[0], row[3]) \n\n    ```", "```py\n    def map(f, iterable): \n        for item in iterable: \n            yield f(item) \n\n```", "```py\n    def map(f, iterable): \n        return (f(item) for item in iterable) \n\n```", "```py\n **>>> def mul(a, b): \n...    return a*b** \n\n```", "```py\n **>>> list_1 = [2, 3, 5, 7] \n>>> list_2 = [11, 13, 17, 23]** \n\n```", "```py\n **>>> list(map(mul, list_1, list_2)) \n[22, 39, 85, 161]** \n\n```", "```py\n **>>> def bundle(*args): \n...     return args \n>>> list(map(bundle, list_1, list_2)) \n[(2, 11), (3, 13), (5, 17), (7, 23)]** \n\n```", "```py\n **>>> list(zip(list_1, list_2)) \n[(2, 11), (3, 13), (5, 17), (7, 23)]** \n\n```", "```py\n    def skip_header_date(rows): \n        for row in rows: \n            if row[0] == 'date': \n                continue \n            yield row \n\n```", "```py\n    def row_merge(source_iter): \n        group = [] \n        for row in source_iter: \n            if len(row[0]) != 0: \n                if group: \n                    yield group \n                group = row.copy() \n            else: \n                group.extend(row) \n        if group: \n            yield group \n\n```", "```py\n **>>> from ch08_r02 import row_merge, log_rows \n>>> pprint(list(row_merge(log_rows))) \n\n[['date', \n  'engine on', \n  'fuel height', \n  '', \n  'engine off', \n  'fuel height', \n  '', \n  'Other notes', \n  ''], \n ['10/25/13', \n  '08:24:00 AM', \n  '29', \n  '', \n  '01:15:00 PM', \n  '27', \n  '', \n  \"calm seas -- anchor solomon's island\", \n  ''], \n ['10/26/13', \n  '09:12:00 AM', \n  '27', \n  '', \n  '06:25:00 PM', \n  '22', \n  '', \n  \"choppy -- anchor in jackson's creek\", \n  '']]** \n\n```", "```py\n            def pass_non_date(row): \n                return row[0] != 'date' \n\n    ```", "```py\n            for item in collection: \n                if pass_non_date(item): \n                    yield item \n\n    ```", "```py\n            (item for item in data if pass_non_date(item)) \n\n    ```", "```py\n            filter(pass_non_date, data) \n\n    ```", "```py\n            for row in filter(pass_non_date, row_merge(data)): \n                print(row[0], row[1], row[4]) \n\n    ```", "```py\n    def filter(f, iterable): \n        for item in iterable: \n            if f(item): \n                yield f(item) \n\n```", "```py\n    def filter(f, iterable): \n        return (item for item in iterable if f(item)) \n\n```", "```py\n    def reject_date(row): \n        return row[0] == 'date' \n\n```", "```py\n    for item in collection: \n        if reject_date(item): \n            continue \n        yield item \n\n```", "```py\n    for item in collection: \n        if not reject_date(item): \n            yield item \n\n```", "```py\n    (item for item in data if not reject_date(item)) \n\n```", "```py\n    def pass_date(row): \n        return not reject_date(row) \n\n```", "```py\n     filter(lambda item: not reject_date(item), data) \n\n```", "```py\n    (M(x) for x in C) \n\n```", "```py\n    map(M, c) \n\n```", "```py\n    filter(F, c) \n\n```", "```py\n     **>>> from functools import reduce** \n\n    ```", "```py\n     **>>> def mul(a, b): \n          ...     return a * b** \n\n    ```", "```py\n     **>>> def prod(values): \n          ...    return reduce(mul, values, 1)** \n\n    ```", "```py\n     **range(1, n+1)** \n\n    ```", "```py\n     **>>> prod(range(1, 5+1)) \n          120** \n\n    ```", "```py\n **>>> def factorial(n): \n...    return prod(range(1, n+1))** \n\n```", "```py\n **>>> factorial(52) \n80658175170943878571660636856403766975289505440883277824000000000000** \n\n```", "```py\n **>>> factorial(52)//(factorial(5)*factorial(52-5)) \n2598960** \n\n```", "```py\n    def reduce(function, iterable, base): \n        result = base \n        for item in iterable: \n            result = function(result, item) \n        return result \n\n```", "```py\n    def mul(a, b): \n        return a * b \n\n```", "```py\n **>>> add = lambda a, b: a + b \n>>> mul = lambda a, b: a * b** \n\n```", "```py\n **>>> def prod2(values): \n...     return reduce(lambda a, b: a*b, values, 1)** \n\n```", "```py\n    from operator import add, mul \n\n```", "```py\n    def mymax(sequence): \n        try: \n            base = sequence[0] \n            max_rule = lambda a, b: a if a > b else b \n            reduce(max_rule, sequence, base) \n        except IndexError: \n            raise ValueError \n\n```", "```py\n **>>> typical_iterator = iter([0, 1, 2, 3, 4]) \n>>> sum(typical_iterator) \n10 \n>>> sum(typical_iterator) \n0** \n\n```", "```py\n     **>>> round(sum_fuel(clean_data(row_merge(log_rows))), 3) \n          7.0** \n\n    ```", "```py\n            from ch08_r02 import row_merge \n\n    ```", "```py\n            def clean_data(source): \n                namespace_iter = map(make_namespace, source) \n                fitered_source = filter(remove_date, namespace_iter) \n                start_iter = map(start_datetime, fitered_source) \n                end_iter = map(end_datetime, start_iter) \n                delta_iter = map(duration, end_iter) \n                fuel_iter = map(fuel_use, delta_iter) \n                per_hour_iter = map(fuel_per_hour, fuel_iter) \n                return per_hour_iter \n\n    ```", "```py\n            from types import SimpleNamespace \n            def make_namespace(row): \n                ns = SimpleNamespace( \n                    date = row[0], \n                    start_time = row[1], \n                    start_fuel_height = row[2], \n                    end_time = row[4], \n                    end_fuel_height = row[5], \n                    other_notes = row[7] \n                ) \n                return ns \n\n    ```", "```py\n            def remove_date(row_ns): \n                return not(row_ns.date == 'date') \n\n    ```", "```py\n            import datetime \n            def timestamp(date_text, time_text): \n                date = datetime.datetime.strptime(date_text, \"%m/%d/%y\").date() \n                time = datetime.datetime.strptime(time_text, \"%I:%M:%S %p\").time() \n                timestamp = datetime.datetime.combine(date, time) \n                return timestamp \n\n    ```", "```py\n            def start_datetime(row_ns): \n                row_ns.start_timestamp = timestamp(row_ns.date, row_ns.start_time) \n                return row_ns \n\n            def end_datetime(row_ns): \n                row_ns.end_timestamp = timestamp(row_ns.date, row_ns.end_time) \n                return row_ns \n\n    ```", "```py\n            def duration(row_ns): \n                travel_time = row_ns.end_timestamp - row_ns.start_timestamp \n                row_ns.travel_hours = round(travel_time.total_seconds()/60/60, 1) \n                return row_ns \n\n    ```", "```py\n            def fuel_use(row_ns): \n                end_height = float(row_ns.end_fuel_height) \n                start_height = float(row_ns.start_fuel_height) \n                row_ns.fuel_change = start_height - end_height \n                return row_ns \n\n            def fuel_per_hour(row_ns): \n                row_ns.fuel_per_hour = row_ns.fuel_change/row_ns.travel_hours \n                return row_ns \n\n    ```", "```py\n    from statistics import * \n    def avg_fuel_per_hour(iterable): \n        return mean(row.fuel_per_hour for row in iterable) \n    def stdev_fuel_per_hour(iterable): \n        return stdev(row.fuel_per_hour for row in iterable) \n\n```", "```py\n **>>> round(avg_fuel_per_hour( \n...    clean_data(row_merge(log_rows))), 3) \n0.48** \n\n```", "```py\n    data = tuple(clean_data(row_merge(log_rows))) \n    m = avg_fuel_per_hour(data) \n    s = 2*stdev_fuel_per_hour(data) \n    print(\"Fuel use {m:.2f} \u00b1{s:.2f}\".format(m=m, s=s)) \n\n```", "```py\n    from itertools import tee \n    data1, data2 = tee(clean_data(row_merge(log_rows)), 2) \n    m = avg_fuel_per_hour(data1) \n    s = 2*stdev_fuel_per_hour(data2) \n\n```", "```py\n            def find_first(predicate, iterable): \n                for item in iterable: \n                    if predicate(item): \n                        yield item \n                        break \n\n    ```", "```py\n            lambda i: n % i == 0 \n\n    ```", "```py\n            import math \n            def prime(n): \n                factors = find_first( \n                    lambda i: n % i == 0, \n                    range(2, int(math.sqrt(n)+1)) ) \n                return len(list(factors)) == 0 \n\n    ```", "```py\n **>>> from itertools import takewhile \n>>> n = 13 \n>>> list(takewhile(lambda i: n % i != 0, range(2, 4))) \n[2, 3] \n>>> n = 15 \n>>> list(takewhile(lambda i: n % i != 0, range(2, 4))) \n[2]** \n\n```", "```py\n    def prime_t(n): \n        tests = set(range(2, int(math.sqrt(n)+1))) \n        non_factors = set( \n            takewhile( \n                lambda i: n % i != 0, \n                tests \n            ) \n        ) \n        return tests == non_factors \n\n```", "```py\n        map = starmap(function, zip(iter1, iter2)) \n\n```", "```py\n    reduce(operator.mul, ..., 1) \n\n```", "```py\n    def prod(iterable): \n        return reduce(operator.mul, iterable, 1) \n\n```", "```py\n    def standarize(mean, stdev, x): \n        return (x-mean)/stdev \n\n```", "```py\n    text_1 = '''10  8.04 \n    8       6.95 \n    13      7.58 \n    ... \n    5       5.68 \n    ''' \n\n```", "```py\n    text_parse = lambda text: (r.split() for r in text.splitlines()) \n\n```", "```py\n    [['10', '8.04'], \n     ['8', '6.95'], \n     ['13', '7.58'], \n     ... \n     ['5', '5.68']] \n\n```", "```py\n    from types import SimpleNamespace \n    row_build = lambda rows: (SimpleNamespace(x=float(x), y=float(y)) for x,y in rows) \n\n```", "```py\n    data_1 = list(row_build(text_parse(text_1))) \n    data_2 = list(row_build(text_parse(text_2))) \n\n```", "```py\n    [namespace(x=10.0, y=8.04), namespace(x=8.0, y=6.95), \nnamespace(x=13.0, y=7.58), \n    ..., \n    namespace(x=5.0, y=5.68)] \n\n```", "```py\n    import statistics \n    mean_x = statistics.mean(item.x for item in data_1) \n    stdev_x = statistics.stdev(item.x for item in data_1) \n\n    for row in data_1: \n        z_x = standardize(mean_x, stdev_x, row.x) \n        print(row, z_x) \n\n    for row in data_2: \n        z_x = standardize(mean_x, stdev_x, row.x) \n        print(row, z_x) \n\n```", "```py\n            from functools import partial \n\n    ```", "```py\n            z = partial(standardize, mean_x, stdev_x) \n\n    ```", "```py\n            lambda x: standardize(mean_v1, stdev_v1, x) \n\n    ```", "```py\n            z = lambda x: standardize(mean_v1, stdev_v1, x) \n\n    ```", "```py\n    for row in data_1: \n        print(row, z(row.x)) \n\n    for row in data_2: \n        print(row, z(row.x)) \n\n```", "```py\n    for row in data_1: \n        row.z = z(row.v1) \n\n    for row in data_2: \n        row.z = z(row.v1) \n\n```", "```py\n    z = lambda x, m=mean_v1, s=stdev_v1: standardize(m, s, x) \n\n```", "```py\n    def reduce(function, iterable, initializer=None) \n\n```", "```py\n    prod = partial(reduce(mul, initializer=1)) \n\n```", "```py\n **>>> from operator import mul \n>>> from functools import reduce \n>>> prod = lambda x: reduce(mul, x, 1)** \n\n```", "```py\n **>>> factorial = lambda x: prod(range(2,x+1)) \n>>> factorial(5) \n120** \n\n```", "```py\n    def prepare_z(data): \n        mean_x = statistics.mean(item.x for item in data_1) \n        stdev_x = statistics.stdev(item.x for item in data_1) \n        return partial(standardize, mean_x, stdev_x) \n\n```", "```py\n    z = prepare_z(data_1) \n    for row in data_2: \n        print(row, z(row.x)) \n\n```", "```py\n    text_1 = '''10  8.04 \n    8       6.95 \n    13      7.58 \n    ... \n    5       5.68 \n    ''' \n\n```", "```py\n    data = list(enrich(cleanse(get(text)))) \n\n```", "```py\n    from typing import * \n\n    def get(text: str) -> Iterator[List[str]]: \n        for line in text.splitlines(): \n            if len(line) == 0: \n                continue \n            yield line.split() \n\n```", "```py\n    from collections import namedtuple \n\n    DataPair = namedtuple('DataPair', ['x', 'y']) \n\n    def cleanse(iterable: Iterable[List[str]]) -> Iterator[DataPair]: \n        for text_items in iterable: \n            try: \n                x_amount = float(text_items[0]) \n                y_amount = float(text_items[1]) \n                yield DataPair(x_amount, y_amount) \n            except Exception as ex: \n                print(ex, repr(text_items)) \n\n```", "```py\n    list(cleanse(get(text))) \n    The output looks like this: \n    [DataPair(x=10.0, y=8.04), \n     DataPair(x=8.0, y=6.95), \n     DataPair(x=13.0, y=7.58), \n     ..., \n     DataPair(x=5.0, y=5.68)] \n\n```", "```py\n            RankYDataPair = namedtuple('RankYDataPair', ['y_rank', 'pair']) \n\n    ```", "```py\n            PairIter = Iterable[DataPair] \n            RankPairIter = Iterator[RankYDataPair] \n\n            def rank_by_y(iterable:PairIter) -> RankPairIter: \n\n    ```", "```py\n            all_data = sorted(iterable, key=lambda pair:pair.y) \n            for y_rank, pair in enumerate(all_data, start=1): \n                yield RankYDataPair(y_rank, pair) \n\n    ```", "```py\n    def rank_by_y(iterable: PairIter) -> RankPairIter: \n        all_data = sorted(iterable, key=lambda pair:pair.y) \n        for y_rank, pair in enumerate(all_data, start=1): \n            yield RankYDataPair(y_rank, pair) \n\n```", "```py\n **>>> data = rank_by_y(cleanse(get(text_1))) \n>>> pprint(list(data)) \n[RankYDataPair(y_rank=1, pair=DataPair(x=4.0, y=4.26)), \n RankYDataPair(y_rank=2, pair=DataPair(x=7.0, y=4.82)), \n RankYDataPair(y_rank=3, pair=DataPair(x=5.0, y=5.68)), \n ..., \n RankYDataPair(y_rank=11, pair=DataPair(x=12.0, y=10.84))]** \n\n```", "```py\n    DataPair = NamedTuple('DataPair', [ \n            ('x', float), \n            ('y', float) \n        ] \n    ) \n\n```", "```py\n    document = { \n        \"field\": \"value1\", \n        \"field2\": \"value\", \n        \"array\": [ \n            {\"array_item_key1\": \"value\"}, \n            {\"array_item_key2\": \"array_item_value2\"} \n        ], \n        \"object\": { \n            \"attribute1\": \"value\", \n            \"attribute2\": \"value2\" \n        } \n    } \n\n```", "```py\n    def find_path(value, node, path=[]): \n        if isinstance(node, dict): \n            for key in node.keys(): \n                # find_value(value, node[key], path+[key]) \n                # This must yield multiple values \n        elif isinstance(node, list): \n            for index in range(len(node)): \n                # find_value(value, node[index], path+[index]) \n                # This will yield multiple values \n        else: \n            # a primitive type \n            if node == value: \n                yield path \n\n```", "```py\n    for match in find_value(value, node[key], path+[key]): \n        yield match \n\n```", "```py\n            for match in find_value(value, node[key], path+[key]): \n                yield match \n\n    ```", "```py\n            yield from find_value(value, node[key], path+[key]) \n\n    ```", "```py\n    def find_path(value, node, path=[]): \n        if isinstance(node, dict): \n            for key in node.keys(): \n                yield from find_path(value, node[key], path+[key]) \n        elif isinstance(node, list): \n            for index in range(len(node)): \n                yield from find_path(value, node[index], path+[index]) \n        else: \n            if node == value: \n                yield path \n\n```", "```py\n **>>> list(find_path('array_item_value2', document)) \n[['array', 1, 'array_item_key2']]** \n\n```", "```py\n **>>> list(find_value('value', document)) \n[['array', 0, 'array_item_key1'], \n ['field2'], \n ['object', 'attribute1']]** \n\n```", "```py\n    for item in X: \n        yield item \n\n```", "```py\n    import math \n    def factor_list(x): \n        limit = int(math.sqrt(x)+1) \n        for n in range(2, limit): \n            q, r = divmod(x, n) \n            if r == 0: \n                return [n] + factor_list(q) \n        return [x] \n\n```", "```py\n    def factor_iter(x): \n        limit = int(math.sqrt(x)+1) \n        for n in range(2, limit): \n            q, r = divmod(x, n) \n            if r == 0: \n                yield n \n                yield from factor_iter(q) \n                return \n        yield x \n\n```", "```py\n **>>> from collections import Counter \n>>> Counter(factor_iter(384)) \nCounter({2: 7, 3: 1})** \n\n```"]