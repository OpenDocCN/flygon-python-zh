- en: Sorting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: Sorting means reorganizing the data in such as way that it is in the order of
    smallest to largest. Sorting is one of the most important issues in data structures
    and computing. Data is regularly sorted before being sorted, as it can then very
    efficiently be retrieved, be it a collection of names, telephone numbers, or items
    on a simple to-do list.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 排序意味着重新组织数据，使其按从小到大的顺序排列。排序是数据结构和计算中最重要的问题之一。数据在排序之前经常被排序，因为这样可以非常高效地检索，无论是一组姓名、电话号码，还是简单待办事项清单上的项目。
- en: 'In this chapter, we''ll study some of the most important and popular sorting
    techniques, including the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习一些最重要和流行的排序技术，包括以下内容：
- en: Bubble sort
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: Insertion sort
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入排序
- en: Selection sort
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择排序
- en: Quick sort
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速排序
- en: Heap sort
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆排序
- en: In this chapter, we compare different sorting algorithms by considering their
    asymptotic behavior. Some of the algorithms are relatively easy to develop, but
    may perform poorly, whereas other algorithms are slightly more complex to implement,
    but show good performance in sorting the list when we have a long lists.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过考虑它们的渐近行为来比较不同的排序算法。一些算法相对容易开发，但性能可能较差，而其他算法在实现上稍微复杂一些，但在对长列表进行排序时表现良好。
- en: After sorting, it becomes much easier to conduct search operations on a collection
    of items. We'll start with the simplest of all sorting algorithms; that is, the
    bubble sort algorithm.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 排序后，对一组项目进行搜索操作变得更加容易。我们将从最简单的排序算法开始；即冒泡排序算法。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All source code used to explain the concepts of this chapter is provided in
    the GitHub repository at the following link: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter10).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 用于解释本章概念的所有源代码都在以下GitHub存储库中提供：[https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter10)。
- en: Sorting algorithms
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序算法
- en: Sorting means arranging all the items in a list in ascending order of their
    magnitude. We will be discussing some of the most important sorting algorithms,
    which each have different performance attributes with respect to runtime complexity.
    Sorting algorithms are categorized by their memory usage, complexity, recursion,
    and whether they are comparison-based, among other considerations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 排序意味着将列表中的所有项目按其大小的升序排列。我们将讨论一些最重要的排序算法，它们各自具有不同的性能属性，涉及运行时复杂性。排序算法根据它们的内存使用、复杂性、递归性以及它们是否基于比较等考虑进行分类。
- en: Some of the algorithms use more CPU cycles, and, as such, have bad asymptotic
    values. Other algorithms chew on more memory and other computing resources as
    they sort a number of values. Another consideration is how sorting algorithms
    lend themselves to being expressed recursively, iteratively, or both. There are
    algorithms that use comparison as the basis for sorting elements. An example of
    this is the bubble sort algorithm. Examples of a non-comparison sorting algorithm
    are the bucket sort and pigeonhole sort algorithms.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一些算法使用更多的CPU周期，因此具有糟糕的渐近值。其他算法在对一些值进行排序时会消耗更多的内存和其他计算资源。另一个考虑因素是排序算法如何适合递归、迭代或两者表达。有些算法使用比较作为排序元素的基础。冒泡排序算法就是一个例子。非比较排序算法的例子包括桶排序和鸽巢排序算法。
- en: Bubble sort algorithms
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冒泡排序算法
- en: The idea behind the bubble sort algorithm is very simple. Given an unordered
    list, we compare adjacent elements in the list, and after each comparison, place
    them in the right order of magnitude. This works by swapping adjacent items if
    they are not in the correct order. The process is repeated `n-1` times for a list
    of `n` items. In each such iteration, the largest element is arranged in the end.
    For example, in the first iteration, the largest element would be placed in the
    last position of the list, and again, the same process will be followed for the
    remaining `n-1` items. In the second iteration, the second largest element will
    be placed at the second-to-last position in the list, and the process will then
    be repeated until the list is sorted.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序算法的思想非常简单。给定一个无序列表，我们比较列表中相邻的元素，每次比较后，将它们按大小顺序放置。这是通过交换相邻的项目来实现的，如果它们的顺序不正确。这个过程对于n个项目的列表会重复n-1次。在每次迭代中，最大的元素都会被放在最后。例如，在第一次迭代中，最大的元素将被放在列表的最后位置，然后，相同的过程将对剩下的n-1个项目进行。在第二次迭代中，第二大的元素将被放在列表的倒数第二个位置，然后该过程将重复，直到列表排序完成。
- en: 'Let''s take a list with only two elements, {**5**, **2**}, to understand the
    concept of the bubble sort, as shown in the following diagram:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以只有两个元素{5, 2}的列表来理解冒泡排序的概念，如下图所示：
- en: '![](Images/21f97a06-89a0-4128-a1e8-580c48e3d76b.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/21f97a06-89a0-4128-a1e8-580c48e3d76b.png)'
- en: 'To sort this list, we simply swap the values into the right positions, with **2** occupying
    index **0** and **5** occupying index **1**. To effectively swap these elements,
    we need to have a temporary storage area:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对这个列表进行排序，我们只需将值交换到正确的位置，**2** 占据索引**0**，**5** 占据索引**1**。为了有效地交换这些元素，我们需要一个临时存储区域：
- en: '![](Images/3e4f61f4-3eb8-413a-bbda-27ab37970caa.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3e4f61f4-3eb8-413a-bbda-27ab37970caa.png)'
- en: 'Implementation of the bubble sort algorithm starts with the swap method, illustrated
    in the preceding diagram. First, element **5** will be copied to a temporary location, `temp`.
    Then, element **2** will be moved to index **0**. Finally, **5** will be moved
    from temp to index **1**. At the end of it all, the elements will have been swapped.
    The list will now contain the elements as `[2, 5]`. The following code will swap
    the elements of `unordered_list[j]` with `unordered_list[j+1]` if they are not
    in the right order:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序算法的实现从交换方法开始，如前图所示。首先，元素**5**将被复制到临时位置`temp`。然后，元素**2**将被移动到索引**0**。最后，**5**将从temp移动到索引**1**。最终，元素将被交换。列表现在包含元素`[2,
    5]`。以下代码将交换`unordered_list[j]`的元素与`unordered_list[j+1]`的元素，如果它们不按正确顺序排列的话：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we have been able to swap a two-element array, it should be simple
    to use this same idea to sort a whole list.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经能够交换一个包含两个元素的数组，使用相同的思路对整个列表进行排序应该很简单。
- en: 'Let''s consider another example to understand the working of bubble sort algorithm
    to sort an unordered list of **6** elements, such as {**45**, **23**, **87**,
    **12**, **32**, **4**}. In the first iteration, we start comparing the first two
    elements, **45** and **23**, and we swap them, as **45** should be placed after
    **23**. Then, we compare the next adjacent values, **45** and **87**, to see whether
    they are in the correct order. Swap them if they are not in the correct order.
    We can see, in the following diagram, that after the first iteration of the bubble
    sort, the largest element, **87**, is placed in the last position of the list:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子，以了解冒泡排序算法对包含**6**个元素的无序列表进行排序的工作原理，例如{**45**，**23**，**87**，**12**，**32**，**4**}。在第一次迭代中，我们开始比较前两个元素**45**和**23**，并交换它们，因为**45**应该放在**23**之后。然后，我们比较下一个相邻值**45**和**87**，看它们是否按正确顺序排列。如果它们没有按正确顺序排列，则交换它们。我们可以看到，在冒泡排序的第一次迭代后，最大的元素**87**被放置在列表的最后位置：
- en: '![](Images/25605a4a-d41e-4ce3-826e-20fb3d1373c6.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/25605a4a-d41e-4ce3-826e-20fb3d1373c6.png)'
- en: 'After the first iteration, we just need to arrange the remaining `(n-1)` elements;
    we repeat the same process by comparing the adjacent elements for the remaining
    five elements. After the second iteration, the second largest element, **45**,
    is placed at the second-to-last position in the list, as shown in the following
    diagram:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次迭代后，我们只需要排列剩下的`(n-1)`个元素；我们通过比较剩下的五个元素的相邻元素来重复相同的过程。第二次迭代后，第二大的元素**45**被放置在列表中倒数第二个位置，如下图所示：
- en: '![](Images/da1be0d7-4d4c-4d22-aea5-5f96dee1e07c.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/da1be0d7-4d4c-4d22-aea5-5f96dee1e07c.png)'
- en: 'Next, we have to compare the remaining `(n-2)` elements to arrange them as
    shown in the following diagram:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要比较剩下的`(n-2)`个元素，将它们排列如下图所示：
- en: '![](Images/87da0f01-1e66-4064-8810-5fcc9f1daa5e.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/87da0f01-1e66-4064-8810-5fcc9f1daa5e.png)'
- en: 'Similarly, we compare the remaining elements to sort them, as well:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们比较剩下的元素来对它们进行排序：
- en: '![](Images/4ccbf25c-3e8e-40f9-a2e7-9ec1141a3987.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4ccbf25c-3e8e-40f9-a2e7-9ec1141a3987.png)'
- en: 'Finally, in the last two remaining elements, we place them in the correct order
    to obtain the final sorted list, as shown in the following diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在剩下的两个元素中，我们将它们按正确顺序放置，以获得最终排序的列表，如下图所示：
- en: '![](Images/e9d0d690-e962-400f-8610-6b7c2519d5e8.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e9d0d690-e962-400f-8610-6b7c2519d5e8.png)'
- en: 'The implementation of the bubble sort algorithm would work in a double-nested
    loop, where the inner loop repeatedly compares and swaps the adjacent elements
    in each iteration for a given list, and the outer loop keeps track of how many
    times the inner loop should be repeated. The implementation of the inner loop
    is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序算法的实现将在一个双嵌套循环中工作，其中内部循环重复比较和交换给定列表中每次迭代中的相邻元素，而外部循环则跟踪内部循环应重复多少次。内部循环的实现如下：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is important to know, when implementing a bubble sort algorithm, how many times
    the loop will need to run to complete all swaps. To sort a list of three numbers,
    for example, `[3, 2, 1]`, we need to swap the elements a maximum of two times.
    This is equal to the length of the list minus 1, and could be written as `iteration_number
    = len(unordered_list)-1`. We subtract 1 because it gives us exactly the maximum
    number of iterations to run. Let''s show this with the following example, where,
    in a list of 3 numbers, by swapping the adjacent elements in exactly two iterations,
    the largest number ends up at the last position in the list:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现冒泡排序算法时，了解循环需要运行多少次才能完成所有交换是很重要的。例如，要对一个包含三个数字的列表`[3, 2, 1]`进行排序，我们最多需要交换两次元素。这等于列表长度减1，可以写成`iteration_number
    = len(unordered_list)-1`。我们减1是因为它确切地给出了需要运行的最大迭代次数。让我们通过以下示例来展示这一点，在一个包含3个数字的列表中，通过在恰好两次迭代中交换相邻元素，最大的数字最终位于列表的最后位置：
- en: '![](Images/97ed985d-c7fa-4bb3-9a07-2d3d831f886a.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/97ed985d-c7fa-4bb3-9a07-2d3d831f886a.png)'
- en: The `if` statement makes sure that no unnecessary swaps occur if two adjacent
    elements are already in the right order. The inner `for` loop only causes the
    swapping of adjacent elements to occur exactly twice in our list.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句确保如果两个相邻元素已经按正确顺序排列，则不会发生不必要的交换。内部`for`循环只会导致相邻元素的交换在我们的列表中确切地发生两次。'
- en: 'How many times does this swapping operation have to occur in order for the
    entire list to be sorted? We know that, if we repeat the whole process of swapping
    the adjacent elements a number of times, the list will be sorted. An outer loop
    is used to make this happen. The swapping of elements in the list results in the
    following dynamics:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使整个列表排序，这个交换操作需要发生多少次？我们知道，如果我们重复整个交换相邻元素的过程多次，列表将被排序。外部循环用于实现这一点。列表中元素的交换导致以下动态：
- en: '![](Images/22b48f43-84eb-4f09-9156-a48f21eb1d6e.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/22b48f43-84eb-4f09-9156-a48f21eb1d6e.png)'
- en: 'We recognize that a total of four comparisons at most were needed to get our
    list sorted. Therefore, both inner and outer loops have to run `len(unordered_list)-1`
    times for all elements to be sorted, as shown:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们意识到最多需要四次比较才能使我们的列表排序。因此，内部和外部循环都必须运行`len(unordered_list)-1`次，以便对所有元素进行排序，如下所示：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The same principle is used even if the list contains many elements. There are
    a lot of variations of the bubble sort, too, that minimize the number of iterations
    and comparisons.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 即使列表包含许多元素，也可以使用相同的原则。冒泡排序也有很多变体，可以最小化迭代和比较的次数。
- en: For example, there is a variant of the bubble sort algorithm where, if there
    is no swapping within the inner loop, we simply quit the entire sorting process,
    because the absence of any swapping operation in the inner loop suggests that
    the list has already been sorted. In a way, this can help speed up the algorithm.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有一种冒泡排序算法的变体，如果在内部循环中没有交换，我们就会简单地退出整个排序过程，因为内部循环中没有任何交换操作表明列表已经排序。在某种程度上，这可以帮助加快算法的速度。
- en: The bubble sort is an inefficient sorting algorithm that provides worst-case
    and average-case runtime complexity of `O(n²)`, and a best-case complexity of
    `O(n)`. Generally, the bubble sort algorithm should not be used to sort large
    lists. However, on relatively small lists, it performs fairly well.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序是一种低效的排序算法，其最坏情况和平均情况的运行时间复杂度为`O(n²)`，最佳情况的复杂度为`O(n)`。通常，不应该使用冒泡排序算法对大型列表进行排序。但是，在相对较小的列表上，它的性能还算不错。
- en: Insertion sort algorithms
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入排序算法
- en: The idea of swapping adjacent elements to sort a list of items can also be used
    to implement the insertion sort. An insertion sorting algorithm maintains a sub-list
    that is always sorted, while the other portion of the list remains unsorted. We
    take elements from the unsorted sub-list and insert them in the correct position
    in the sorted sub-list, in such a way that this sub-list remains sorted.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将相邻元素交换以对项目列表进行排序的想法也可以用于实现插入排序。插入排序算法维护一个始终排序的子列表，而列表的另一部分保持未排序。我们从未排序的子列表中取出元素，并将它们插入到排序的子列表的正确位置，使得这个子列表保持排序。
- en: In insertion sorting, we start with one element, assuming it to be sorted, and
    then take another element from the unsorted sub-list and place it at the correct
    position (in relation to the first element) in the sorted sub-list. This means
    that our sorted sub-list now has two elements. Then, we again take another element
    from the unsorted sub-list, and place it in the correct position (in relation
    to the two already sorted elements) in the sorted sub-list. We repeatedly follow
    this process to insert all the elements one by one from the unsorted sub-list
    into the sorted sub-list. The shaded elements denote the ordered sub-lists, and
    in each iteration, an element from the unordered sub-list is inserted at the correct
    position in the sorted sub-list.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入排序中，我们从一个元素开始，假设它已经排序，然后从未排序的子列表中取出另一个元素，并将其放在排序的子列表中正确的位置（相对于第一个元素）。这意味着我们的排序子列表现在有两个元素。然后，我们再次从未排序的子列表中取出另一个元素，并将其放在排序的子列表中正确的位置（相对于已排序的两个元素）。我们反复遵循这个过程，将未排序的子列表中的所有元素一个接一个地插入到排序的子列表中。阴影元素表示有序子列表，在每次迭代中，未排序子列表中的一个元素被插入到排序子列表的正确位置。
- en: 'Let''s consider an example to understand the working of the insertion sorting
    algorithm. In our example, we''ll be sorting a list of `6` elements: `{45, 23,
    87, 12, 32, 4}`. Firstly, we start with `1` element, assuming it to be sorted,
    then take the next element, `23`, from the unsorted sub-list and insert it at
    the correct position in the sorted sub-list. In the next iteration, we take the
    third element, `87`, from the unsorted sub-list, and again insert it into the
    sorted sub-list at the correct position. We follow the same process until all
    elements are in the sorted sub-list. This whole process is shown in the following
    diagram:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子来理解插入排序算法的工作原理。在我们的例子中，我们将对包含`6`个元素的列表`{45, 23, 87, 12, 32, 4}`进行排序。首先，我们从`1`个元素开始，假设它已经排序，然后从未排序的子列表中取出下一个元素`23`，并将其插入到排序的子列表中的正确位置。在下一次迭代中，我们从未排序的子列表中取出第三个元素`87`，并再次将其插入到排序的子列表中的正确位置。我们一直遵循相同的过程，直到所有元素都在排序的子列表中。整个过程如下图所示：
- en: '![](Images/2be1efdb-8fd8-43d6-add6-aede489e3815.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2be1efdb-8fd8-43d6-add6-aede489e3815.png)'
- en: To understand the implementation of the insertion sorting algorithm, let's take
    another example list of `5` elements, `{5, 1, 100, 2, 10}`, and examine the process
    with a detailed explanation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解插入排序算法的实现，让我们以另一个包含`5`个元素的示例列表`{5, 1, 100, 2, 10}`为例，并用详细的解释来检查这个过程。
- en: 'Let''s consider the following array:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下数组：
- en: '![](Images/52c67297-48cb-4fb1-a6e6-863f02db06bb.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/52c67297-48cb-4fb1-a6e6-863f02db06bb.png)'
- en: 'The algorithm starts by using a `for` loop to run between the **1** and **4** indices.
    We start from index **1** because we assume the sub-array at index **0** to already
    be in the correctly sorted order:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法通过使用`for`循环在**1**和**4**索引之间运行来开始。我们从索引**1**开始，因为我们假设索引**0**处的子数组已经按正确的顺序排序：
- en: '![](Images/c140fcb5-08aa-4ad5-bafe-33fd12a82214.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c140fcb5-08aa-4ad5-bafe-33fd12a82214.png)'
- en: 'At the start of the execution of the loop, we have the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环执行的开始，我们有以下内容：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At the beginning of the execution of each run of the `for` loop, the element
    at `unsorted_list[index]` is stored in the `insert_value` variable. Later, when
    we find the appropriate position in the sorted portion of the list, `insert_value`
    will be stored at that index or location:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次运行`for`循环的开始时，将`unsorted_list[index]`处的元素存储在`insert_value`变量中。稍后，当我们找到列表的排序部分中的适当位置时，`insert_value`将存储在该索引或位置上：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `search_index` is used to provide information to the `while` loop; that
    is, exactly where to find the next element that needs to be inserted into the
    sorted sub-list.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`search_index`用于向`while`循环提供信息；也就是说，确切地找到下一个需要插入到排序子列表中的元素的位置。'
- en: 'The `while` loop traverses the list backward, guided by two conditions: first,
    if `search_index > 0`, then it means that there are more elements in the sorted
    portion of the list; second, for the `while` loop to run, `unsorted_list[search_index-1]`
    must be greater than the `insert_value` variable. The `unsorted_list[search_index-1]` array
    will do either of the following things:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环向后遍历列表，受两个条件的指导：首先，如果`search_index > 0`，那么意味着在列表的排序部分中还有更多的元素；其次，`while`循环运行时，`unsorted_list[search_index-1]`必须大于`insert_value`变量。`unsorted_list[search_index-1]`数组将执行以下操作之一：'
- en: Point to the element, just before the `unsorted_list[search_index]`, before
    the `while` loop is executed the first time
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`while`循环第一次执行之前，指向`unsorted_list[search_index]`之前的一个元素
- en: Point to one element before `unsorted_list[search_index-1]` after the `while`
    loop has been run the first time
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`while`循环第一次运行后，指向`unsorted_list[search_index-1]`之前的一个元素
- en: In our example list, the `while` loop will be executed because *5 > 1*. In the
    body of the while loop, the element at `unsorted_list[search_index-1]` is stored
    at `unsorted_list[search_index]`. `search_index -= 1` moves the list traversal
    backward until it holds a value of `0`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例列表中，`while`循环将被执行，因为*5 > 1*。在`while`循环的主体中，`unsorted_list[search_index-1]`处的元素存储在`unsorted_list[search_index]`处。`search_index
    -= 1`将列表向后遍历，直到它的值为`0`。
- en: 'Our list now looks like the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的列表现在如下所示：
- en: '![](Images/86df775f-a6fb-4bd2-9b93-0038bbdc97dc.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/86df775f-a6fb-4bd2-9b93-0038bbdc97dc.png)'
- en: 'After the `while` loop exits, the last known position of `search_index` (which,
    in this case, is `0`) now helps us to know where to insert `insert_value`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环退出后，`search_index`的最后已知位置（在这种情况下为`0`）现在帮助我们知道在哪里插入`insert_value`：
- en: '![](Images/ad028833-87aa-466e-8b28-8cb081f129b8.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ad028833-87aa-466e-8b28-8cb081f129b8.png)'
- en: On the second iteration of the `for` loop, `search_index` will have a value
    of **2**, which is the index of the third element in the array. At this point,
    we start our comparison in the leftward direction (toward index **0**). **100**
    will be compared with **5**, but because **100** is greater than **5**, the `while`
    loop will not be executed. **100** will be replaced by itself, because the `search_index` variable
    never got decremented. As such, `unsorted_list[search_index] = insert_value` will
    have no effect.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环的第二次迭代中，`search_index`的值将为**2**，这是数组中第三个元素的索引。此时，我们从左向右（朝向索引**0**）开始比较。**100**将与**5**进行比较，但因为**100**大于**5**，`while`循环不会执行。**100**将被替换为它自己，因为`search_index`变量从未被减少。因此，`unsorted_list[search_index]
    = insert_value`将不会产生影响。
- en: When `search_index` is pointing at index **3**, we compare **2** with **100**,
    and move **100** to where **2** is stored. We then compare **2** with **5** and
    move **5** to where **100** was initially stored. At this point, the `while` loop
    will break and **2** will be stored in index **1**. The array will be partially
    sorted with the values `[1, 2, 5, 100, 10]`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当`search_index`指向索引**3**时，我们将**2**与**100**进行比较，并将**100**移动到存储**2**的位置。然后我们将**2**与**5**进行比较，并将**5**移动到最初存储**100**的位置。此时，`while`循环将中断，**2**将存储在索引**1**中。数组将部分排序，值为`[1,
    2, 5, 100, 10]`。
- en: The preceding step will occur one last time for the list to be sorted.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤将为列表最后一次发生。
- en: The insertion sorting algorithm is considered stable, in the sense that it does
    not change the relative order of elements that have equal keys. It also only requires
    no more memory than that consumed by the list, because it does the swapping in-place.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序算法被认为是稳定的，因为它不会改变具有相等键的元素的相对顺序。它也只需要消耗列表占用的内存，因为它是原地交换的。
- en: Insertion sorting algorithm gives a worst-case runtime complexity of **`O(n²)`**,
    and a best-case complexity `O(n)`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序算法的最坏情况运行时间复杂度为**`O(n²)`**，最佳情况复杂度为`O(n)`。
- en: Selection sort algorithms
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择排序算法
- en: Another popular sorting algorithm is the selection sort. The selection sorting
    algorithm begins by finding the smallest element in the list, and interchanges
    it with the data stored at the first position in the list. Thus, it makes the sub-list
    sorted up to the first element. Next, the second smallest element, which is the
    smallest element in the remaining list, is identified and interchanged with the
    second position in the list. This makes the initial two elements sorted. The process
    is repeated, and the smallest element remaining in the list should be swapped
    with the element in the third index on the list. This means that the first three
    elements are now sorted. This process is repeated for `(n-1)` times to sort `n` items.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的排序算法是选择排序。选择排序算法首先找到列表中最小的元素，并将其与列表中的第一个位置存储的数据交换。因此，它使子列表排序到第一个元素。接下来，识别出剩余列表中最小的元素（即剩余列表中最小的元素），并将其与列表中的第二个位置交换。这使得初始的两个元素排序。该过程重复进行，列表中剩余的最小元素应该与列表中第三个索引处的元素交换。这意味着前三个元素现在已排序。这个过程重复了`(n-1)`次来对`n`个项目进行排序。
- en: 'Let''s look at an example to understand how the algorithm works. We''ll sort
    the following list of 4 elements using the selection sort algorithm:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来理解算法的工作原理。我们将使用选择排序算法对以下4个元素的列表进行排序：
- en: '![](Images/00f7ef2b-0bcf-4184-995c-2bebd03c2d85.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/00f7ef2b-0bcf-4184-995c-2bebd03c2d85.png)'
- en: Starting at index **0**, we search for the smallest item in the list that exists
    between index **1**, and the index of the last element. When this element has
    been found, it is exchanged with the data found at index **0**. We simply repeat
    this process until the list is fully sorted.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从索引**0**开始，我们搜索列表中存在于索引**1**和最后一个元素索引之间的最小项。找到这个元素后，将其与索引**0**处的数据交换。我们只需重复此过程，直到列表完全排序。
- en: 'Searching for the smallest item within the list is an incremental process:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中搜索最小的项目是一个递增的过程：
- en: '![](Images/11f39ec5-3839-4437-9724-52c16ca07749.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11f39ec5-3839-4437-9724-52c16ca07749.png)'
- en: A comparison of elements **2** and **5** selects **2**, as it is the lesser
    value among these two values, and thus, the two elements are swapped.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对元素**2**和**5**进行比较，选择**2**，因为它是这两个值中较小的值，因此这两个元素被交换。
- en: 'After the swap operation, the array looks like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 交换操作后，数组如下所示：
- en: '![](Images/394c7330-7323-4726-88e1-bd3c7546399a.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/394c7330-7323-4726-88e1-bd3c7546399a.png)'
- en: 'Further, at index **0**, we compare **2** with **65**:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在索引**0**处，我们将**2**与**65**进行比较：
- en: '![](Images/09719f77-d0ec-4f7a-8a48-d1fd6609a8e6.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09719f77-d0ec-4f7a-8a48-d1fd6609a8e6.png)'
- en: Since **65** is greater than **2**, the two elements are not swapped. A further
    comparison is made between the element at index **0**, which is **2**, and the
    element at index **3**, which is **10**. No swap takes place in this case. When
    we get to the last element in the list, we will have the smallest element occupying
    index **0**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**65**大于**2**，这两个元素不会交换。在索引**0**处的元素**2**和索引**3**处的元素**10**之间进行了进一步比较。在这种情况下不会发生交换。当我们到达列表中的最后一个元素时，最小的元素将占据索引**0**。
- en: In the next iteration, we start comparing elements from position **1** in the
    index. We repeat the whole process of comparing the element stored at index **1**
    with all the elements, from index **2** through to the last index.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次迭代中，我们从索引**1**开始比较元素。我们重复整个过程，将索引**1**处存储的元素与从索引**2**到最后一个索引的所有元素进行比较。
- en: 'The second iteration starts by comparing **5** and **65**, which will look
    like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次迭代从比较**5**和**65**开始，结果如下：
- en: '![](Images/d4fd4df3-f7aa-4980-9d86-39af6d2d5108.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d4fd4df3-f7aa-4980-9d86-39af6d2d5108.png)'
- en: Once we find out that the **5** is the smallest value in the sub-list from indices **1**
    to **3**, we place it at index **1**. Similarly, the next smallest element from
    the sub-lists **2** and **3** indices is placed at index **3**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们发现**5**是从索引**1**到**3**的子列表中的最小值，我们将其放在索引**1**处。同样，从子列表**2**和**3**的索引中找到的下一个最小元素被放置在索引**3**处。
- en: 'The following is an implementation of the selection sort algorithm. The argument
    to the function is the unsorted list of items we want to put in ascending order
    of magnitude:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是选择排序算法的实现。函数的参数是我们想要按大小顺序排列的未排序项目列表：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The algorithm begins by using the outer `for` loop to go through the list, `size_of_list`,
    a number of times. Because we pass `size_of_list` to the `range` method, it'll
    produce a sequence from **0** through to `size_of_list-1`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法通过使用外部`for`循环多次遍历列表`size_of_list`。因为我们将`size_of_list`传递给`range`方法，它将产生一个从**0**到`size_of_list-1`的序列。
- en: The inner loop is responsible for going through the list and swap elements if
    we encounter an element less than the element pointed to by `unsorted_list[i]`.
    Notice that the inner loop begins from `i+1` up to `size_of_list-1`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 内部循环负责遍历列表，并在遇到小于`unsorted_list[i]`指向的元素时交换元素。注意，内部循环从`i+1`开始，直到`size_of_list-1`。
- en: 'The inner loop begins its search for the smallest element from `i+1`, but uses
    the `j` index:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 内部循环从`i+1`开始搜索最小元素，但使用`j`索引：
- en: '![](Images/6a9bbfe0-c944-46d0-8109-daedd157611d.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6a9bbfe0-c944-46d0-8109-daedd157611d.png)'
- en: The preceding diagram shows the direction in which the algorithm searches for
    the next smallest item.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了算法搜索下一个最小项的方向。
- en: The selection sorting algorithm gives worst-case and best-case runtime complexities
    of `O(n2)`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 选择排序算法的最坏情况和最佳情况运行时间复杂度均为`O(n2)`。
- en: Quick sort algorithms
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速排序算法
- en: The quick sort algorithm is very efficient for sorting. The quick sort algorithm
    falls under the divide and conquer class of algorithms, similar to the merge sort
    algorithm, where we break (divide) a problem into smaller chunks that are much
    simpler to solve (conquer).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序算法对于排序非常有效。快速排序算法属于分治类算法，类似于归并排序算法，其中我们将问题分解为更简单的小块来解决。
- en: List partitioning
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表分区
- en: The concept behind quick sorting is partitioning a given list or array. To partition
    the list, we first select a pivot. All the elements in the list will be compared
    with this pivot. At the end of the partitioning process, all elements that are
    less than the pivot will be to the left of the pivot, while all elements greater
    than the pivot will lie to the right of the pivot in the array.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序的概念是对给定的列表或数组进行分区。为了对列表进行分区，我们首先选择一个枢轴。列表中的所有元素将与此枢轴进行比较。在分区过程结束时，所有小于枢轴的元素将位于枢轴的左侧，而所有大于枢轴的元素将位于数组中枢轴的右侧。
- en: Pivot selection
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枢轴选择
- en: For the sake of simplicity, we'll take the first element in an array as the
    pivot. This kind of pivot selection degrades in performance, especially when sorting
    an already sorted list. Randomly picking the middle or last element in the array
    as the pivot does not improve the performance of the quick sort. We will discuss
    a better approach to select the pivot and find the smallest element in a list in
    the next chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将数组中的第一个元素作为枢轴。这种枢轴选择在性能上会下降，特别是在对已排序列表进行排序时。随机选择数组中间或最后一个元素作为枢轴并不会改善快速排序的性能。我们将在下一章讨论更好的选择枢轴和找到列表中最小元素的方法。
- en: An illustration with an example
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 举例说明
- en: In this algorithm, we partition an unsorted array into two sub-arrays, in such
    a way that all the elements on the left side of that partition point (also called
    a pivot) should be smaller than the pivot, and all the elements on the right side
    of the pivot should be greater. After the first iteration of the quick sort algorithm,
    the chosen pivot point is placed in the list at its correct position. After the
    first iteration, we obtain two unordered sub-lists, and follow the same process
    again on these two sub-lists. Thus, the quick sort algorithm partitions the list
    into two parts and recursively applies the quick sort algorithm on these two sub-lists
    to sort the whole list.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个算法中，我们将一个未排序的数组分成两个子数组，使得分区点（也称为枢轴）左侧的所有元素都应该小于枢轴，而枢轴右侧的所有元素都应该大于枢轴。在快速排序算法的第一次迭代之后，选择的枢轴点被放置在列表中的正确位置。第一次迭代之后，我们得到两个无序的子列表，并在这两个子列表上再次执行相同的过程。因此，快速排序算法将列表分成两部分，并递归地在这两个子列表上应用快速排序算法以对整个列表进行排序。
- en: We start by choosing a pivot point with which all the items are to be compared,
    and at the end of the first iteration, this value will be placed in its correct
    position in the ordered list. Next, we use two pointers, a left pointer, and a
    right pointer. The left pointer initially points to the value at index **1**,
    and the right pointer points to the value at the last index. The main idea behind
    the quick sort algorithm is to move the items that are on the wrong side of the
    pivot value. So, we start with the left pointer, moving from in a left-to-right
    direction, until we reach a position where the item has a greater value than the
    pivot value. Similarly, we move the right pointer toward the left until we find
    a value less than a pivot value. Next, we swap these two values indicated by the
    left and right pointers. We repeat the same process until both pointers cross
    each other; in other words, when the right pointer index indicates a value less
    than that of the left pointer index.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先选择一个枢轴点，所有项目都将与其进行比较，并在第一次迭代结束时，该值将被放置在有序列表中的正确位置。接下来，我们使用两个指针，一个左指针和一个右指针。左指针最初指向索引**1**处的值，右指针指向最后一个索引处的值。快速排序算法的主要思想是移动在枢轴值错误一侧的项目。因此，我们从左指针开始，从左到右移动，直到找到一个比枢轴值大的位置。类似地，我们将右指针向左移动，直到找到一个小于枢轴值的值。接下来，我们交换左右指针指示的这两个值。我们重复相同的过程，直到两个指针交叉；换句话说，右指针索引指示的值小于左指针索引的值时。
- en: Let's take an example of a list of numbers, {**45**, **23**, **87**, **12**,
    **72**, **4**, **54**, **32**, **52**}, to understand how the quick sort algorithm
    works. Let's assume that the pivot point in our list is the first element, **45**.
    We move the left pointer from index **1** in a rightward direction, and stop when
    we reach the value **87**, because (**87**>**45**). Next, we move the right pointer
    toward the left, and stop when we find the value **32**, because (**32**<**45**).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个数字列表{**45**, **23**, **87**, **12**, **72**, **4**, **54**, **32**, **52**}为例，来理解快速排序算法的工作原理。假设我们列表中的枢轴点是第一个元素**45**。我们从索引**1**处向右移动左指针，并在找到值**87**时停止，因为（**87**>**45**）。接下来，我们将右指针向左移动，并在找到值**32**时停止，因为（**32**<**45**）。
- en: 'Now, we swap these two values, as shown in the following diagram:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们交换这两个值，如下图所示：
- en: '![](Images/7b232879-1527-4f8e-ac01-f56791cc7982.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7b232879-1527-4f8e-ac01-f56791cc7982.png)'
- en: 'After that, we repeat the same process and move the left pointer toward the
    right direction, and stop when we find the value **72**, because (**72**>**45**). Next,
    we move the right pointer toward the left and stop when we reach the value 4,
    because (**4**<**45**). Now, we swap these two values, because they are in the
    wrong direction of the pivot value. We repeat the same process and stop once the
    right pointer index value becomes less than the left pointer index. Here, we find
    **4** as the splitting point, and swap it with the pivot value. This is shown
    in the following diagram:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们重复相同的过程，将左指针向右移动，并在找到值**72**时停止，因为（**72**>**45**）。接下来，我们将右指针向左移动，并在找到值**4**时停止，因为（**4**<**45**）。现在，我们交换这两个值，因为它们与枢轴值的方向相反。我们重复相同的过程，并在右指针索引值小于左指针索引值时停止。在这里，我们找到**4**作为分割点，并将其与枢轴值交换。如下图所示：
- en: '![](Images/e05dddc1-22ab-495c-847c-b2765ed7d23c.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e05dddc1-22ab-495c-847c-b2765ed7d23c.png)'
- en: It can be observed that after the first iteration of the quick sort algorithm,
    the pivot value **45** is placed at its correct position in the list.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在快速排序算法的第一次迭代之后，可以观察到枢轴值**45**被放置在列表中的正确位置。
- en: 'Now we have two sub-lists:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了两个子列表：
- en: The sub-list to the left of the pivot value, **45**, has values of less than
    **45**.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枢轴值**45**左侧的子列表具有小于**45**的值。
- en: Another sub-list to the right of the pivot value contains values greater than
    45\. We will apply the quick sort algorithm recursively on these two sub-lists,
    and repeat it until the whole list is sorted.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枢轴值右侧的另一个子列表包含大于45的值。我们将在这两个子列表上递归应用快速排序算法，并重复此过程，直到整个列表排序完成。
- en: '![](Images/18334875-62fb-4170-bb9b-47f0b4b3a210.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/18334875-62fb-4170-bb9b-47f0b4b3a210.png)'
- en: Implementation
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: The partitioning step is very important in understanding the implementation
    of the quick sort algorithm, so we will start with an examination of implementing
    the partitioning first.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 分区步骤对于理解快速排序算法的实现非常重要，因此我们将从实现分区开始进行检查。
- en: 'Let''s look at another example to understand the implementation. Consider the
    following list of integers. We shall partition this list using the partition function,
    as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子来理解实现。考虑以下整数列表。我们将使用分区函数对此列表进行分区，如下所示：
- en: '![](Images/29b930cc-1cd7-4a9c-a5ba-54d2a951a9c5.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/29b930cc-1cd7-4a9c-a5ba-54d2a951a9c5.png)'
- en: 'Consider the following code for this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The partition function receives, as its parameters, the indices of the first
    and last elements of the array that we need to partition.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 分区函数接收数组的第一个和最后一个元素的索引作为其参数，我们需要对其进行分区。
- en: 'The value of the pivot is stored in the `pivot` variable, while its index is
    stored in `pivot_index`. We are not using `unsorted_array[0]`, because when the
    unsorted array parameter is called with a segment of an array, index `0` will
    not necessarily point to the first element in that array. The index of the next
    element to the pivot, that is, the **left pointer**, `first_index + 1`, marks
    the position where we begin to look for an element in the array that is greater
    than the `pivot`, as `greater_than_pivot_index = first_index + 1`. The **right
    pointer** `less_than_pivot_index` variable points to the position of the last
    element in the `less_than_pivot_index = index_of_last_element` list, where we
    begin the search for the element that is less than the pivot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 主元的值存储在`pivot`变量中，而其索引存储在`pivot_index`中。我们没有使用`unsorted_array[0]`，因为当调用未排序数组参数时，索引`0`不一定指向该数组中的第一个元素。主元的下一个元素的索引，即**左指针**，`first_index
    + 1`，标记了我们开始在数组中寻找大于主元的元素的位置，即`greater_than_pivot_index = first_index + 1`。**右指针**`less_than_pivot_index`变量指向`less_than_pivot_index
    = index_of_last_element`列表中最后一个元素的位置，我们从这里开始寻找小于主元的元素：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At the beginning of the execution of the main `while` loop, the array looks
    like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行主`while`循环的开始时，数组如下所示：
- en: '![](Images/16a3edea-4e3f-4532-82a8-500df977e3b9.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/16a3edea-4e3f-4532-82a8-500df977e3b9.png)'
- en: The first inner `while` loop moves one index to the right until it lands on
    index **2**, because the value at that index is greater than **43**. At this point,
    the first `while` loop breaks and does not continue. At each test of the condition
    in the first `while` loop, `greater_than_pivot_index += 1` is evaluated only if
    the `while` loop's test condition evaluates to `True`. This makes the search for
    an element, greater than the pivot, progress to the next element on the right.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个内部`while`循环向右移动一个索引，直到落在索引**2**上，因为该索引处的值大于**43**。此时，第一个`while`循环中断并且不再继续。在第一个`while`循环的条件测试中，只有在`while`循环的测试条件评估为`True`时，才会评估`greater_than_pivot_index
    += 1`。这使得对大于主元的元素的搜索向右边的下一个元素进行。
- en: 'The second inner `while` loop moves one index at a time to the left, until
    it lands on index **5**, whose value, **20**, is less than **43**:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个内部`while`循环每次向左移动一个索引，直到落在索引**5**上，其值**20**小于**43**：
- en: '![](Images/5de935b0-20a7-4973-8819-81babd0768f0.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5de935b0-20a7-4973-8819-81babd0768f0.png)'
- en: 'At this point, neither inner `while` loop can be executed any further:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，内部的`while`循环都无法再执行：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since `greater_than_pivot_index < less_than_pivot_index`, the body of the `if`
    statement swaps the element at those indexes. The `else` condition breaks the
    infinite loop any time that `greater_than_pivot_index` becomes greater than `less_than_pivot_index`.
    In such a condition, it means that `greater_than_pivot_index` and `less_than_pivot_index`
    have crossed over each other.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`greater_than_pivot_index < less_than_pivot_index`，`if`语句的主体交换了这些索引处的元素。`else`条件在任何时候`greater_than_pivot_index`变得大于`less_than_pivot_index`时打破无限循环。在这种情况下，这意味着`greater_than_pivot_index`和`less_than_pivot_index`已经交叉。
- en: 'Our array now looks like the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数组现在如下所示：
- en: '![](Images/b8479f3c-29f3-48f0-9807-ded22d7670e7.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b8479f3c-29f3-48f0-9807-ded22d7670e7.png)'
- en: The `break` statement is executed when `less_than_pivot_index` is equal to **3**
    and `greater_than_pivot_index` is equal to **4**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当`less_than_pivot_index`等于**3**且`greater_than_pivot_index`等于**4**时，执行`break`语句。
- en: 'As soon as we exit the `while` loop, we interchange the element at `unsorted_array[less_than_pivot_index]`
    with that of `less_than_pivot_index`, which is returned as the index of the pivot:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦退出`while`循环，我们就会交换`unsorted_array[less_than_pivot_index]`处的元素和作为主元索引返回的`less_than_pivot_index`处的元素：
- en: '[PRE9]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following diagram shows how the code interchanges **4** with **43** as
    the last step in the partitioning process:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了代码在分区过程的最后一步中如何交换**4**和**43**：
- en: '![](Images/31e49e1a-1589-4a9d-9404-1571133a1f64.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/31e49e1a-1589-4a9d-9404-1571133a1f64.png)'
- en: To recap, the first time the `quick_sort` function was called, it was partitioned
    about the element at index **0**. After the return of the partitioning function,
    we obtain the array in the order of [**4**, **3**, **20**, **43**, **89**, **77**].
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，第一次调用`quick_sort`函数时，它是围绕索引**0**的元素进行分区的。在分区函数返回后，我们得到的数组顺序为[**4**，**3**，**20**，**43**，**89**，**77**]。
- en: As you can see, all elements to the right of element **43** are greater than
    **43**, while those to the left are smaller. Thus, the partitioning is complete.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，主元**43**右边的所有元素都大于**43**，而左边的元素都小于**43**。因此，分区完成。
- en: Using the split point **43** with index **3**, we will recursively sort the
    two sub-arrays, [**4**, **30**, **20**] and [**89**, **77**], using the same process
    we just went through.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分割点**43**和索引**3**，我们将递归地对两个子数组进行排序，即[**4**，**30**，**20**]和[**89**，**77**]，使用刚刚经历的相同过程。
- en: 'The body of the main `quick_sort` function is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 主`quick_sort`函数的主体如下：
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `quick_sort` function is a very simple method, taking up no more than six
    lines of code. The heavy lifting is done by the `partition` function. When the
    `partition` method is called, it returns the partition point. This is the point
    in the `unsorted_array` array where all elements to the left are less than the
    pivot value, and all elements to its right are greater than it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`quick_sort`函数是一个非常简单的方法，代码不超过六行。繁重的工作由`partition`函数完成。当调用`partition`方法时，它返回分区点。这是`unsorted_array`数组中的一个点，其中所有左边的元素都小于主元值，而右边的元素都大于它。'
- en: 'When we print the state of `unsorted_array` immediately after the partition
    progress, we see clearly how the partitioning happens:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在分区进程之后立即打印`unsorted_array`的状态时，我们清楚地看到了分区是如何发生的：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Taking a step back, let's sort the first sub-array after the first partition
    has happened. The partitioning of the `[4, 3, 20]` sub-array will stop when `greater_than_pivot_index`
    is at index `2`, and `less_than_pivot_index` is at index `1`. At that point, the
    two markers are said to have crossed. Because `greater_than_pivot_index` is greater
    than `less_than_pivot_index`, further execution of the `while` loop will cease.
    Pivot `4` will be exchanged with `3`, while index `1` is returned as the partition
    point.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 退一步，让我们在第一次分区后对第一个子数组进行排序。当`[4, 3, 20]`子数组的分区停止时，`greater_than_pivot_index`
    在索引 `2`，`less_than_pivot_index` 在索引 `1`。此时，两个标记被认为已经交叉。因为 `greater_than_pivot_index`
    大于 `less_than_pivot_index`，`while` 循环的进一步执行将停止。将主元 `4` 与 `3` 交换，同时索引 `1` 被返回为分区点。
- en: In the quicksort algorithm, the partition algorithm takes `O(n)` time. As the
    quicksort algorithm follows the *divide and conquer* paradigm, it takes `O(log
    n)` time; therefore, the overall average-case runtime complexity of the quicksort
    algorithm is `O(n) * O(log n) = O(n log n)`. The quicksort algorithm gives a worst-case
    runtime complexity of `O(n²)`. The worst-case complexity for the quicksort algorithm
    would be when it selects the worst pivot point every time, and one of the partitions
    always has a single element. For example, if the list is already sorted, the worst-case
    complexity would occur if the partition picks the smallest element as a pivot
    point. When worst-case complexity does occur, the quicksort algorithm can be improved by
    using the randomized quicksort. The quicksort algorithm is very efficient when
    sorting large amounts of data compared to the other aforementioned algorithms
    for sorting.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在快速排序算法中，分区算法需要 `O(n)` 时间。由于快速排序算法遵循“分而治之”的范式，它需要 `O(log n)` 时间；因此，快速排序算法的整体平均情况运行时间复杂度为
    `O(n) * O(log n) = O(n log n)`。快速排序算法给出了最坏情况的运行时间复杂度为 `O(n²)`。快速排序算法的最坏情况复杂度是每次选择最坏的主元点，并且其中一个分区始终只有一个元素。例如，如果列表已经排序，最坏情况复杂度将发生在分区选择最小元素作为主元点时。当最坏情况复杂度发生时，可以通过使用随机化快速排序来改进快速排序算法。与其他上述排序算法相比，快速排序算法在对大量数据进行排序时非常高效。
- en: Heap sort algorithms
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆排序算法
- en: In Chapter 8, *Graphs and Other Algorithms*, we implemented a binary heap data
    structure. Our implementation always made sure that, after an element had been
    removed or added to a heap, the heap order property was maintained, by using the
    `sink()` and `arrange()` helper methods.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章《图和其他算法》中，我们实现了一个二叉堆数据结构。我们的实现始终确保，在从堆中移除或添加元素后，使用 `sink()` 和 `arrange()`
    辅助方法来维护堆顺序属性。
- en: 'The heap data structure can be used to implement a sorting algorithm called
    the heap sort. As a recap, let''s create a simple heap with the following items:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 堆数据结构可以用来实现一种称为堆排序的排序算法。简而言之，让我们创建一个包含以下项目的简单堆：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The heap, `h`, is created and the elements in the `unsorted_list` are inserted.
    After each method call to `insert`, the heap order property is restored by the
    subsequent call to the `float` method. After the loop is terminated, element `4` will
    be at the top of our heap.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 堆 `h` 被创建，`unsorted_list` 中的元素被插入。在每次调用 `insert` 方法后，堆顺序属性都会通过随后调用 `float` 方法得到恢复。循环结束后，元素
    `4` 将位于我们的堆顶。
- en: The number of elements in our heap is `10`. If we call the `pop` method on the
    `h` heap object 10 times, and store the actual elements being popped, we end up
    with a sorted list. After each `pop` operation, the heap is readjusted to maintain
    the heap order property.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的堆中的元素数量为 `10`。如果我们在 `h` 堆对象上调用 `pop` 方法 10 次，并存储被弹出的实际元素，我们最终得到一个排序好的列表。每次
    `pop` 操作后，堆都会被调整以保持堆顺序属性。
- en: 'The `heap_sort` method is as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`heap_sort` 方法如下：'
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `for` loop simply calls the `pop` method `self.size` number of times. Now, `sorted_list`
    will contain a sorted list of items after the loop terminates.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环简单地调用 `pop` 方法 `self.size` 次。现在，循环结束后，`sorted_list` 将包含一个排序好的项目列表。'
- en: The `insert` method is called *n* number of times. Together with the `arrange()` method,
    the `insert` operation takes a worst-case runtime of `O(n log n)`, as does the
    `pop` method. As such, this sorting algorithm incurs a worst-case runtime of `O(n
    log n)`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert` 方法被调用了 *n* 次。加上 `arrange()` 方法，`insert` 操作的最坏情况运行时间为 `O(n log n)`，`pop`
    方法也是如此。因此，这种排序算法的最坏情况运行时间为 `O(n log n)`。'
- en: 'A comparison of the complexities of different sorting algorithms is given in
    the following table:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不同排序算法的复杂性比较如下表所示：
- en: '| **Algorithm** | **worst-case** | **average-case** | **best-case** |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| **算法** | **最坏情况** | **平均情况** | **最佳情况** |'
- en: '| Bubble sort | `O(n²)` | `O(n²)` | `O(n)` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 冒泡排序 | `O(n²)` | `O(n²)` | `O(n)` |'
- en: '| Insertion sort | `O(n²)` | `O(n²)` | `O(n)` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 插入排序 | `O(n²)` | `O(n²)` | `O(n)` |'
- en: '| Selection sort | `O(n²)` | `O(n²)` | `O(n²)` |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 选择排序 | `O(n²)` | `O(n²)` | `O(n²)` |'
- en: '| Quicksort | `O(n²)` | `O(n log n)` | `O(n log n)` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: 快速排序 | `O(n²)` | `O(n log n)` | `O(n log n)` |
- en: '| heapsort | `O(n log n)` | `O(n log n)` | ` O(n Log n)` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 堆排序 | `O(n log n)` | `O(n log n)` | `O(n log n)` |'
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored a number of important and popular sorting algorithms,
    which are very useful for many real-world applications. We discussed bubble sort,
    insertion sort, selection sort, quick sort, and heap sort algorithms, along with
    the explanation of their implementation in Python. Quick sort performs much better
    than the other sorting algorithms. Of all the algorithms discussed, quick sort
    preserves the index of the list that it sorts. We'll use this property in the
    next chapter as we explore the selection algorithms.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了许多重要和流行的排序算法，这些算法对许多实际应用非常有用。我们讨论了冒泡排序、插入排序、选择排序、快速排序和堆排序算法，以及它们在Python中的实现解释。快速排序比其他排序算法表现要好得多。在所有讨论的算法中，快速排序保留了它所排序的列表的索引。在下一章中，我们将利用这一特性来探讨选择算法。
- en: In the next chapter, we will be discussing the concepts related to the selection
    strategy and algorithms.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论与选择策略和算法相关的概念。
