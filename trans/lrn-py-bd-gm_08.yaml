- en: Turtle Class - Drawing on the Screen
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 海龟类 - 在屏幕上绘制
- en: Not so long ago, programmers, especially game programmers, would face many intricacies
    while building programs. No wonder! Back then, there wasn't enough assistance
    from the internet portal, including no stack overflow, but more than that, there
    were no universal tools that programmers could use; they had to create one first
    and use it in the programs. The tools they created would handle some game specifics
    (specific drivers for sound and graphics). Programmers had to create games using
    assembly language due to the meager resources available, which would be trade-offs
    for processing power, display, sound, and control routines. Even the worst scenario
    would be encountered at the time of debugging. They would need complex and expensive
    machines in order to replicate their programs, and they would also have logging
    and debugging extensions. The main goal of this chapter will be to make us familiar
    with two-dimensional (2D) space drawing using turtle, along with the event handling
    method of turtle, and to create simple 2D idle animations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 不久以前，程序员，尤其是游戏程序员，在构建程序时会面临许多复杂性。难怪！那时，互联网门户的帮助还不够，包括没有堆栈溢出，更重要的是，程序员没有可以使用的通用工具；他们必须首先创建一个工具，然后在程序中使用它。他们创建的工具将处理一些游戏特定的内容（用于声音和图形的特定驱动程序）。由于资源稀缺，程序员不得不使用汇编语言创建游戏，这将是处理能力、显示、声音和控制例程的权衡。甚至在调试时也会遇到最糟糕的情况。他们需要复杂昂贵的机器来复制他们的程序，他们还需要日志记录和调试扩展。本章的主要目标是让我们熟悉使用海龟进行二维（2D）空间绘图，以及海龟的事件处理方法，并创建简单的2D空闲动画。
- en: At the time of writing, we have made gargantuan progress in the gaming industry.
    We have created tools that allow us to use any programming language in order to
    make games, such as Python and C (low-CPU-demanding games). All of the low-level
    routines are hidden by higher-level software due to the communication of device
    drivers. The high-level languages such as Python are abstract; they provide less
    access to the lower-level functions. We can group multiple things together as
    classes that can inherit characteristics from another class, which removes the
    duplication of code. Python provides modules such as turtle and Pygame, which
    contain a bunch of methods for designing game characters and handling user events.
    In this chapter, we will learn about the turtle module. Each of the things that
    will be built from this chapter onward will use techniques from the preceding
    chapters—with the addition of a few notable characteristics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，我们在游戏行业取得了巨大进步。我们已经创建了工具，使我们能够使用任何编程语言制作游戏，例如Python和C（对CPU要求低的游戏）。由于设备驱动程序的通信，所有低级例程都被高级软件隐藏起来。Python等高级语言是抽象的；它们提供较少的访问权限以获取低级功能。我们可以将多个东西组合在一起作为类，这些类可以从另一个类继承特性，从而消除了代码的重复。Python提供了海龟和Pygame等模块，其中包含了大量用于设计游戏角色和处理用户事件的方法。在本章中，我们将学习有关海龟模块的知识。从本章开始构建的每个东西都将使用前面章节的技术，同时还会添加一些显著的特性。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Overview of turtle
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 海龟概述
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术要求
- en: Introduction to turtle commands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 海龟命令简介
- en: Turtle events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 海龟事件
- en: Drawing shapes with turtle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用海龟绘制形状
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This section takes you through the basic Python graphical programming module
    and its working. Therefore, you are expected to have the following resources:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将带您了解基本的Python图形编程模块及其工作原理。因此，您需要以下资源：
- en: Python 3.5 or later; refer to [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml), *Getting
    to Know Python – Setting Up Python and the Editor*
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.5或更高版本；参见[第1章](0ef9574b-5690-454e-971f-85748021018d.xhtml)，*了解Python
    - 设置Python和编辑器*
- en: Python IDLE
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python IDLE
- en: A text editor
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文本编辑器
- en: A keyboard
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个键盘
- en: A mouse (a laptop's touchpad won't work)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个鼠标（笔记本电脑的触摸板无法使用）
- en: The files for this chapter can be found here: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter08](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter08)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的文件可以在此处找到：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter08](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter08)
- en: 'Check out the following video to see the code in action:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频以查看代码的运行情况：
- en: '[http://bit.ly/2pAmrCs](http://bit.ly/2pAmrCs)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2pAmrCs](http://bit.ly/2pAmrCs)'
- en: Understanding the turtle module
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解海龟模块
- en: Just like the different components of a computer are equally important in order
    to provide a better computing experience, we also need the different components
    of a computer to work together in order to provide a better gaming experience.
    The video card of the computer is responsible for computing the visual images
    of the screen and then modularizing the image signal before sending it to the
    monitor. The input devices such as the mouse, keyboard, and joysticks are required
    to handle user events according to the programs. The audio card is required to
    process the audio signals and then send them to output devices such as the speaker.
    At the early age of game programming, programmers needed to read the technical
    manual for each of these devices separately and code each of them in isolation.
    This meant making communication between them would take a single year, even for
    simple games. However, with advancements in technology—and drivers in particular—programmers
    obviated the headache of making communication between these devices and the operating
    system manually.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 就像计算机的不同组件同样重要以提供更好的计算体验一样，我们也需要计算机的不同组件共同工作，以提供更好的游戏体验。计算机的显卡负责计算屏幕的视觉图像，然后在发送到显示器之前对图像信号进行模块化。输入设备如鼠标、键盘和游戏手柄需要根据程序处理用户事件。音频卡需要处理音频信号，然后将其发送到扬声器等输出设备。在游戏编程的早期阶段，程序员需要分别阅读每个设备的技术手册，并在隔离状态下编写每个设备的代码。这意味着即使是简单的游戏，它们之间的通信也需要花费一年的时间。然而，随着技术的进步，特别是驱动程序的进步，程序员免除了手动处理这些设备与操作系统之间的通信的烦恼。
- en: 'Although we developed a simple program known as drivers, which acts as a common
    interface to communicate with different devices, different hardware and version
    incompatibilities made programmers'' lives harder when they were developing games
    that could be played across multiple platforms. Luckily, we have Python, a language
    that has the adept capability to make programs that can be platform independent.
    Turtle is the Python module that provides the drawing board that can be used to
    create pictures and packets. It is believed that the turtle module is the sister
    of another popular programming language from the 90s—*Logo—*which had an imaginary
    icon of a turtle, and a pen, which was used to draw over the screen. Python''s
    standard library, *turtle*, is similar to the Logo programming language. In order
    to use the turtle module, we have to import it. Importing it is easier as it comes
    packed as a standard Python library and it does not need to be installed manually.
    The following steps explain how to make any turtle application:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们开发了一个称为驱动程序的简单程序，它作为与不同设备通信的通用接口，但不同的硬件和版本不兼容性使得程序员在开发可以在多个平台上玩的游戏时更加困难。幸运的是，我们有Python，一种具有使程序可以跨平台的能力的语言。Turtle是Python模块，提供了可以用来创建图片和图形的绘图板。据说海龟模块是上世纪90年代另一种流行编程语言*Logo*的姐妹模块，*Logo*有一个想象中的海龟图标和一个用于在屏幕上绘制的笔。Python的标准库*turtle*类似于Logo编程语言。为了使用海龟模块，我们必须导入它。导入它更容易，因为它作为标准Python库打包，不需要手动安装。以下步骤解释了如何制作任何海龟应用程序：
- en: Import the turtle module with the `import` command. If you ignore this step,
    there won't be any interface to control turtle.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`import`命令导入海龟模块。如果忽略这一步，就不会有控制海龟的界面。
- en: Create a turtle to control. This step is used to instantiate turtle in order
    to create a new turtle controller, for example, `game = turtle.Turtle()`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个控制海龟。这一步用于实例化海龟，以创建一个新的海龟控制器，例如，`game = turtle.Turtle()`。
- en: After creating a control, we use the new turtle to draw and carry out multiple
    tasks in the drawing screen by calling the methods of the turtle module.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建控制后，我们可以通过调用海龟模块的方法在绘图屏幕上绘制和执行多个任务。
- en: We need to call one important method explicitly, which holds the game screen,
    that is, `turtle.done()`. This method will pause the program. You need to close
    the window manually in order to close the application.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要显式调用一个重要的方法，它持有游戏屏幕，即`turtle.done()`。这个方法会暂停程序。您需要手动关闭窗口以关闭应用程序。
- en: In a turtle package, when we run the program that is made by calling the methods
    of the turtle module, a new window will appear with a pen, along with the shapes
    that are drawn by the turtle commands. Let's learn about a few important turtle
    commands.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在海龟包中，当我们运行通过调用海龟模块的方法制作的程序时，将会出现一个新窗口，带有一支笔，以及由海龟命令绘制的形状。让我们了解一些重要的海龟命令。
- en: Introduction to turtle commands
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍海龟命令
- en: 'The turtle module comes with multiple commands in the form of methods that
    can be used independently. There are methods to make the pen move forward and
    backward, and some to create shapes. Take a look at the following table to find
    out about the most important turtle commands. You can read about them in detail
    on their official Python documentation pages:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 海龟模块带有多个命令，以方法的形式独立使用。有一些方法可以使笔向前和向后移动，还有一些可以创建形状。查看下表，了解最重要的海龟命令。您可以在官方Python文档页面上详细了解它们：
- en: '| **Method** | **Parameter** | **Description** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **参数** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Turtle()` | None | Creates and returns a new turtle object. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `Turtle()` | 无 | 创建并返回一个新的海龟对象。 |'
- en: '| `forward()` | Distance | Moves the turtle forward by the specified amount.
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `forward()` | 距离 | 将海龟向前移动指定的距离。 |'
- en: '| `backward()` | Distance | Moves the turtle backward by the specified amount.
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `backward()` | 距离 | 将海龟向后移动指定的距离。 |'
- en: '| `right()` | Angle | Turns the turtle clockwise. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `right()` | 角度 | 将海龟顺时针旋转。 |'
- en: '| `left()` | Angle | Turns the turtle counter-clockwise. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `left()` | 角度 | 将海龟逆时针旋转。 |'
- en: '| `penup()` | None | Picks up the turtle''s pen. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `penup()` | 无 | 抬起海龟的笔。 |'
- en: '| `pendown()` | None | Puts down the turtle''s pen. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `pendown()` | 无 | 放下海龟的笔。 |'
- en: '| `up()` | None | Picks up the turtle''s pen. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `up()` | 无 | 抬起海龟的笔。 |'
- en: '| `down()` | None | Puts down the turtle''s pen. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '`down()` | None | 放下海龟的笔。'
- en: '| `color()` | Color name | Changes the color of the turtle''s pen. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '`color()` | 颜色名称 | 更改海龟笔的颜色。'
- en: '| `fillcolor()` | Color name | Changes the color that the turtle will use to
    fill a polygon. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '`fillcolor()` | 颜色名称 | 更改海龟用于填充多边形的颜色。'
- en: '| `heading()` | None | Returns the current heading. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '`heading()` | None | 返回当前的方向。'
- en: '| `position()` | None | Returns the current position. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '`position()` | None | 返回当前位置。'
- en: '| `goto()` | *x*, *y* (positions) | Move the turtle to position *x*, *y*. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '`goto()` | *x*, *y* (位置) | 将海龟移动到位置 *x*, *y*。'
- en: '| `begin_fill()` | None | Remembers the starting point for a filled polygon.
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '`begin_fill()` | None | 记住填充多边形的起点。'
- en: '| `end_fill()` | None | Closes the polygon and fills it with the current fill
    color. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '`end_fill()` | None | 关闭多边形并用当前填充颜色填充它。'
- en: '| `dot()` | None | Leaves the dot in the current position. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '`dot()` | None | 在当前位置留下一个点。'
- en: '| `stamp()` | None | Leaves an impression of a turtle shape at the current
    location. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '`stamp()` | None | 在当前位置留下一个海龟形状的印记。'
- en: '| `shape()` | Shape name | Should be *arrow*, *classic*, *turtle,* or *circle*.
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '`shape()` | 形状名称 | 应该是 *arrow*, *classic*, *turtle,* 或 *circle*。'
- en: 'In the preceding table, we can guess the result of calling those methods by
    observing the literal meaning of the method''s name. For example, the `forward(amount)`
    method is going to move the pen forward with the amount specified as the argument.
    All of these methods are used to plot different shapes into the drawing canvas
    of turtle. Observe the first `>>> Turtle()` method. This will return the object
    of turtle, which must be used in order to invoke these methods. As an example,
    we are going to make a program that will draw a line onto the screen. The following
    is the code for this example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的表格中，我们可以通过观察方法名称的字面意义来猜测调用这些方法的结果。例如，`forward(amount)` 方法将以指定的参数作为参数向前移动笔。所有这些方法都用于在海龟的绘图画布中绘制不同的形状。观察第一个
    `>>> Turtle()` 方法。这将返回海龟的对象，必须使用该对象来调用这些方法。例如，我们将编写一个程序，该程序将在屏幕上绘制一条线。以下是此示例的代码：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can observe the following output by running the preceding code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行上面的代码，我们可以观察到以下输出：
- en: '![](Images/6b556b6f-26e0-4e80-8b39-5a7fd539ebe5.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6b556b6f-26e0-4e80-8b39-5a7fd539ebe5.png)'
- en: 'Along with the Python shell, the new screen, like the preceding one, should
    pop out, and this represents the turtle drawing board. Initially, the pen attached
    to the imaginary turtle will reside at the center of the drawing board. Any method
    call from the turtle object must manipulate the movement of the pen. The preceding
    code can be explained in the following steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 连同Python shell一起，新屏幕应该像之前的那个一样弹出，这代表了海龟绘图板。最初，附着在虚拟海龟上的笔将驻留在绘图板的中心。海龟对象的任何方法调用都必须操纵笔的移动。上面的代码可以通过以下步骤来解释：
- en: First, we have to import turtle, which is a first step that will make sure all
    the commands that reside inside the turtle class will be available for us to use.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须导入turtle，这是一个第一步，将确保海龟类中的所有命令对我们可用。
- en: The second step is to create a turtle controller, and we refer to it as pacman.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是创建一个海龟控制器，我们称之为吃豆人。
- en: Then, we make a movement of 100 pixels from the point that pacman is facing.
    Initially, the *pacman* turtle controller was facing toward the right; thus, the
    pen moved 100 pixels to the right from the center, creating the straight line.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从吃豆人面对的点向前移动100像素。最初，*吃豆人* 海龟控制器是朝右的；因此，笔从中心向右移动100像素，形成了一条直线。
- en: Finally, `turtle.done()` is going to pause the turtle drawing board screen so
    that we can observe the output clearly. In order to close the turtle screen, we
    have to manually close the Python shell or the turtle graphics screen.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`turtle.done()` 将暂停海龟绘图板屏幕，以便我们可以清楚地观察输出。为了关闭海龟屏幕，我们必须手动关闭Python shell或海龟图形屏幕。
- en: 'We''ve just learned how to create a straight line, but the lines look boring
    and do not add any aesthetics to the program. It''s time to learn how to use another
    method, which is going to turn the pen in another direction. For example, we may
    want to change the direction of the pen from where it was originally facing to
    another direction:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学会了如何创建一条直线，但是这些线看起来很无聊，对程序没有任何美感。现在是学习如何使用另一个方法的时候了，这个方法将转动笔到另一个方向。例如，我们可能想要将笔的方向从最初的方向改变到另一个方向：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are already familiar with the `forward` method, and alongside it, we have
    now introduced the `right()` method. If you have a look at the previous table
    of methods, you will see that the `right` method and angle have been passed as
    arguments. Thus, this method is going to perform some rotation, accompanied by
    the angle that was passed along with it. Since we passed 90 degrees to it, this
    method is going create a 90-degree clockwise rotation. If you want to rotate the
    pen anticlockwise, we have to call the left method and specify the angle of rotation.
    In the preceding program, we rotated it by 90 degrees. The geometrical shape that
    has all angles of 90 degrees is either the square or the rectangle. However, we
    know that the `forward` method will result in a straight line, which is the same
    as the sides of geometrical shapes. The sides that are created by the `forward`
    method will be equal in length, which is 50, and this is passed as an argument
    with the `forward` method. With all this evidence, we can surely expect the square
    shape to be drawn in the turtle board. Let''s run the preceding code to observe
    the output. As expected, the square shape is drawn:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了`forward`方法，现在我们引入了`right()`方法。如果你看一下之前的方法表，你会发现`right`方法和角度作为参数传递了进去。因此，这个方法将执行一些旋转，并伴随着传递进去的角度。由于我们传递了90度，这个方法将进行一个90度的顺时针旋转。如果你想要将笔逆时针旋转，我们需要调用left方法并指定旋转的角度。在前面的程序中，我们将它旋转了90度。所有角度都是90度的几何形状要么是正方形，要么是长方形。然而，我们知道`forward`方法会产生一条直线，这与几何形状的边是一样的。由`forward`方法创建的边的长度是相等的，为50，这作为`forward`方法的参数传递进去。有了这些证据，我们可以肯定地期望在乌龟画板上画出一个正方形形状。让我们运行前面的代码来观察输出。正如预期的那样，画出了正方形形状：
- en: '![](Images/0ba32ee6-1a60-4f2c-9cdb-04c4e19b47da.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0ba32ee6-1a60-4f2c-9cdb-04c4e19b47da.png)'
- en: 'Have a closer look at the preceding code; did you see some repetition of code?
    Obviously, the invocation of the `forward` and `left` methods is done multiple
    times, which ultimately disrespects the DRY principles. This epiphany does not
    come without practicing the paradigm of Python. Thus, we can say that practice
    is what differentiates good and bad programmers. Now, recall what we need in order
    to eliminate the redundancy of the code; we should use either loops or functions.
    We will use a loop here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看一下前面的代码；你看到了一些代码的重复吗？显然，`forward`和`left`方法的调用被多次执行，这最终违反了DRY原则。这种顿悟并非没有练习Python范式而来。因此，我们可以说练习是区分好坏程序员的关键。现在，回想一下我们需要什么来消除代码的冗余；我们应该使用循环或函数。我们将在这里使用一个循环：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I guess we won't have any problems in reading and understanding this code. As
    we mentioned in [Chapter 3](49a63c5e-e333-46c8-b8de-a54ca40d949c.xhtml), *Flow
    Control - Building a Decision Maker For Your Game*, we can create an iteration
    level with a range of functions. Since we need to run these methods four times,
    we have created four iterations using the range function. Anything that needs
    to be repeated is indented by four blocks inside the scope of the for loop.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜我们在阅读和理解这段代码时不会遇到任何问题。正如我们在[第3章](49a63c5e-e333-46c8-b8de-a54ca40d949c.xhtml)中提到的，*流程控制
    - 为你的游戏构建决策者*，我们可以使用一系列函数创建迭代级别。由于我们需要运行这些方法四次，我们使用了range函数创建了四次迭代。任何需要重复的内容都会在for循环的范围内缩进四个块。
- en: One thing to notice in this example is that we have multiple methods for handling
    the movements of the pen in the drawing screen. The two turtle commands that we
    have learned so far are `forward(amount)`, which moves the turtle forward in the
    direction it is facing with some amount, and `right(degree)`, which makes the
    turtle turn clockwise by a specified degree. Notice here that the `right` and
    `left` commands are not going to write anything on the screen; instead, they are
    used for rotation only.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中需要注意的一点是，我们有多个处理画板上笔的移动的方法。到目前为止我们学到的两个乌龟命令是`forward(amount)`，它将乌龟向它所面对的方向前进一定距离，以及`right(degree)`，它使乌龟顺时针旋转指定的角度。请注意，`right`和`left`命令不会在屏幕上写任何东西；它们只用于旋转。
- en: Following the patterns of everything that we have learned so far, we can predict
    that the `backward` method is going to move the pen in the backward direction
    from the original direction that it was facing by a specified amount. I recommend that
    you try modifying the preceding code a little bit—by refactoring the forward method
    using `backward`, and by refactoring `right` using `left`—and observe the result
    accordingly. I would like to take the time to conclude this topic here, without
    covering other functions, because we will go through each of them while making
    games in the upcoming chapters. We will make multiple games, such as the Snake
    game, the Pong game, and Flappy Bird using the turtle module. Now, we will explore
    the ways we can connect input devices, such as a mouse and a keyboard, to our
    game so that players can interact with the turtle environment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们迄今为止学到的一切模式，我们可以预测`backward`方法将会将笔从原来的方向向后移动指定的距离。我建议你尝试稍微修改前面的代码 - 通过使用`backward`重构`forward`方法，通过使用`left`重构`right`
    - 并相应地观察结果。我想在这里花点时间总结这个话题，而不涉及其他函数，因为我们将在接下来的章节中制作游戏时逐个学习它们。我们将制作多个游戏，比如蛇游戏、乒乓球游戏和使用乌龟模块的Flappy
    Bird。现在，我们将探索如何连接输入设备，比如鼠标和键盘，到我们的游戏中，以便玩家可以与乌龟环境进行交互。
- en: Exploring turtle events
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索乌龟事件
- en: As we mentioned in the previous chapters, handling the events of a user is one
    of the prime building blocks for creating any game. The event represents the action
    that needs to be performed at any time during the game. Have you ever wondered
    how the events are handled by programs at the low levels? When a user executes
    any event using the keyboard or mouse, that request is stored in a queue-like
    structure. The queue structure is important because the order of handling these
    events must be on a first come, first served basis. Then, according to the behavior
    of the user actions, events are handled by the program. These two tasks of rendering
    and action handling are performed independently by the programs. For example,
    in a counter strike game, the user can shoot from their gun, even when enemies
    are not around them. Here, the event is the user pressing a key to fire the gun
    and the rendering task is spawning the enemies around the player. These two tasks
    are not executed independently unless we write programs to make them. In this
    section, we are going to learn how to take a user action as an input, and handle
    it accordingly. Handling the user actions means serving the actions that are stored
    in the queue structure.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中提到的，处理用户事件是创建任何游戏的主要构建块之一。事件代表了在游戏过程中任何时候需要执行的动作。你是否曾经想过程序是如何在低层次处理事件的？当用户使用键盘或鼠标执行任何事件时，该请求被存储在一个类似队列的结构中。队列结构很重要，因为处理这些事件的顺序必须是先来先服务的。然后，根据用户操作的行为，程序处理事件。这两个任务——渲染和动作处理——由程序独立执行。例如，在反恐精英游戏中，用户可以从枪中射击，即使周围没有敌人。这里，事件是用户按键开枪，渲染任务是在玩家周围生成敌人。除非我们编写程序来执行这两个任务，否则这两个任务不会独立执行。在本节中，我们将学习如何将用户动作作为输入，并相应处理。处理用户动作意味着服务存储在队列结构中的动作。
- en: 'Most of the events are based on the use of a mouse or a keyboard, but some
    events must be predicted automatically by the program and handled accordingly,
    such as the `ontimer(fun, time)` method. This method takes two arguments: function
    and time in milliseconds. This method sets a timer that calls the `fun` function
    after `time` in milliseconds. Let''s make a simple program to understand this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数事件都是基于鼠标或键盘的使用，但有些事件必须由程序自动预测并相应处理，比如“ontimer(fun, time)”方法。这个方法接受两个参数：函数和毫秒时间。这个方法设置一个定时器，在“time”毫秒后调用“fun”函数。让我们做一个简单的程序来理解这一点：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The last line of code (`turtle.mainloop()`) simply performs the same operations
    that are carried out while looping. Until, and unless, the user exits the window
    screen explicitly, the call to the `main` function will not be terminated. Its
    importance can be observed when the program has a while loop, which is used to
    listen to the incoming connection, but we don''t want the computer to be constantly
    focused on the one case:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后一行（`turtle.mainloop()`）只是执行了在循环中执行的相同操作。直到用户明确退出窗口屏幕，对“main”函数的调用才会终止。当程序有一个用于监听传入连接的while循环时，它的重要性就会显现出来，但我们不希望计算机一直专注于这一情况：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The previous code works in exactly the same way as a while loop, but now the
    Python parser is not dedicated to performing only one task constantly. Instead,
    for every 100 milliseconds, `draw_objects()` tasks will be performed, and for
    the remaining 99.99 milliseconds, the Python parser is free to carry out any other
    tasks.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与while循环的工作方式完全相同，但现在Python解析器不再专门执行一个任务。相反，每100毫秒，“draw_objects()”任务将被执行，而剩下的99.99毫秒，Python解析器可以自由执行任何其他任务。
- en: 'Interestingly, the preceding code represents the proper outcome of any turtle
    program. Although calling a different function would make a different character
    on the screen, the main aim of using turtle is to render the game character onto
    the screen. Let''s break down the preceding code into the following points:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，前面的代码代表了任何turtle程序的正确结果。虽然调用不同的函数会在屏幕上显示不同的字符，但使用turtle的主要目的是将游戏角色渲染到屏幕上。让我们将前面的代码分解成以下几点：
- en: The first couple of steps represent importing turtle and creating a turtle controller,
    which will allow us to call all the `turtle` methods through it.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前几步代表着导入turtle并创建一个turtle控制器，这将允许我们通过它调用所有的“turtle”方法。
- en: We have created a `main` function, and inside it, we have some code to create
    a star pattern. The iteration is 100 times, which means we will have 100 stars
    printed onto the output screen, but remember, they will be closely spaced.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个“main”函数，在其中，我们有一些代码来创建一个星形图案。迭代次数是100次，这意味着我们将在输出屏幕上打印100颗星星，但请记住，它们会很接近。
- en: 'The best way to render the characters properly in the screen is by using the
    `ontimer` method. Let''s modify the same program with the `ontimer` method. Let''s
    see how we can use it in the program:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上正确渲染字符的最佳方法是使用“ontimer”方法。让我们用“ontimer”方法修改相同的程序。让我们看看如何在程序中使用它：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Unlike before, the preceding program is not going to print multiple stars;
    instead, it prints a single one. However, the `ontimer` method removes the overhead
    of calling the for loop since it sets the timer to call the same function again
    and again. In this program, we passed the `main` function and 500 as arguments,
    which means that the `main` function should be called in every `500` milliseconds.
    Running the preceding program will yield the following output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前不同，前面的程序不会打印多个星星；相反，它打印一个单一的星星。然而，“ontimer”方法消除了调用for循环的开销，因为它设置了定时器来一遍又一遍地调用相同的函数。在这个程序中，我们传递了“main”函数和500作为参数，这意味着“main”函数应该在每500毫秒调用一次。运行前面的程序将产生以下输出：
- en: '![](Images/56a5bc78-7ded-4b06-95fb-c27435241fa5.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/56a5bc78-7ded-4b06-95fb-c27435241fa5.png)'
- en: 'It''s time to learn how to handle keyboard and mouse events. As always, there
    are methods that have been defined to handle keyboard events and methods that
    have been defined to handle mouse events. But, before handling user events, turtle
    must launch a listener, which continuously remains awake to listen to any events.
    Such a listener controller is created using the `listen` method, that is, `>>>
    turtle.listen()`. The following table depicts the methods that are used to handle
    keyboard events:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习如何处理键盘和鼠标事件了。和往常一样，已经定义了用于处理键盘事件的方法和用于处理鼠标事件的方法。但是，在处理用户事件之前，乌龟必须启动一个监听器，它会持续保持清醒状态以监听任何事件。使用`listen`方法创建这样一个监听器控制器，即`>>>
    turtle.listen()`。以下表格描述了用于处理键盘事件的方法：
- en: '| **Method Name** | **Parameters** | **Description** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **方法名称** | **参数** | **描述** |'
- en: '| `turtle.onkeypress(function, key = None)` | **Function**: A function with
    no arguments or `None`.**Key**: A key in the form of strings or symbols, for example,
    `q` or `space`. | It is used to bind the function to any key events that are pressed
    on a keyboard. If no key is specified, any key will work. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `turtle.onkeypress(function, key = None)` | **Function**：没有参数或`None`的函数。**Key**：以字符串或符号形式的键，例如，`q`或`space`。
    | 用于将函数绑定到键盘上按下的任何键事件。如果未指定键，则任何键都可以使用。 |'
- en: '| `turtle.onkeyrelease(function, key)` | **Function**: A function with no arguments
    or `None`.**Key**: A key in the form of string, `a`, or symbols, `enter`. | It
    is used to bind the function to key-release events that are performed by key actions.
    If the function is `None`, the binding of events is removed. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `turtle.onkeyrelease(function, key)` | **Function**：没有参数或`None`的函数。**Key**：以字符串形式的键，如`a`，或符号，如`enter`。
    | 用于将函数绑定到键释放事件。如果函数为`None`，则解除事件的绑定。 |'
- en: 'Let''s make a simple program in order to grasp the idea of using these methods
    of handling keyboard actions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的程序，以便掌握使用这些处理键盘操作的方法的思想：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's run the program and observe the output. After pressing *F5*, you will
    observe two screens, one of which will have the turtle graphics board and pen
    at the center of it. Now, press the *Spacebar* key on the keyboard. As soon as
    you press it, it starts to draw a star onto the screen.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行程序并观察输出。按下*F5*后，你会看到两个屏幕，其中一个会有乌龟图形板和笔位于其中心。现在，按下键盘上的*Spacebar*键。一旦按下，它就开始在屏幕上绘制一个星星。
- en: Inside the `main` function, we have added some code that will make a star. However,
    as you can see, the `main` function has not been called explicitly, as we normally
    do while calling functions; instead, it is called using the `onkeypress` method.
    This method binds the key to the function, and whenever the key is pressed, the
    function is called automatically. If you remove the last line from the preceding
    code, the listener controller is not going to work. The `listen` method is used
    to make a controller for listening incessantly to these types of actions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数内部，我们添加了一些代码来制作一个星星。然而，正如你所看到的，`main`函数并没有被显式调用，就像我们通常调用函数一样；相反，它是使用`onkeypress`方法调用的。这个方法将键绑定到函数，每当按键时，函数就会自动调用。如果从前面的代码中删除最后一行，监听控制器就不会起作用。`listen`方法用于创建一个控制器，不断监听这些类型的操作。
- en: In a similar fashion, we can call the `onkeyrelease` method. Replace `onkeypress`
    with `onkeyrelease` in the preceding code and observe the output. The output is
    going to be the same. The `onkeyrelease` method is used to bind the function to
    be called with the key-release event of the key.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以调用`onkeyrelease`方法。在前面的代码中用`onkeyrelease`替换`onkeypress`，并观察输出。输出将是相同的。`onkeyrelease`方法用于将函数绑定到按键释放事件。
- en: 'Similarly, the ways of handling mouse events are not too different—they are
    also handled by method calls. The following table depicts the methods that can
    be used to handle mouse events:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，处理鼠标事件的方式也并不太不同——它们也是通过方法调用来处理的。以下表格描述了可以用来处理鼠标事件的方法：
- en: '| **Method** | **Parameter** | **Description** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **参数** | **描述** |'
- en: '| `onclick(function, button = 1, add = None)` | **Function**: A function is
    called with two arguments (*x, y*), which represent the coordinates of the clicked
    position by mouse or pointer.**Button**: It represents the mouse button, `default
    = 1`, which means the left mouse button.**Add**: It is used to add multiple bindings.
    If `True` is passed, a new binding will be added, otherwise it will stick to the
    current one. | Binds functions to mouse-click events. If the user clicks on any
    position of the turtle canvas, the coordinates of the clicked position will be
    used to call the function. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `onclick(function, button = 1, add = None)` | **Function**：使用两个参数（*x, y*）调用一个函数，表示鼠标或指针点击位置的坐标。**Button**：表示鼠标按钮，`默认
    = 1`，表示左键。**Add**：用于添加多个绑定。如果传递`True`，将添加新的绑定，否则将保持当前绑定。 | 将函数绑定到鼠标点击事件。如果用户点击乌龟画布的任何位置，将使用点击位置的坐标调用函数。
    |'
- en: '| `onrelease(function, button = 1, add = None)` | **Function**: A function
    is called with two arguments (*x, y*), which represent the coordinates of the
    clicked position on the drawing board of turtle.**Button**: `Default = 1` means
    that the left mouse button is used. It is used to add a number for mouse-button.**Add**:
    According to its value of `True` or `False`, it decides whether to add a new binding
    or not. | Binds functions to mouse-button release event. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `onrelease(function, button = 1, add = None)` | **Function**：使用两个参数（*x, y*）调用一个函数，表示乌龟绘图板上点击位置的坐标。**Button**：`默认
    = 1`表示使用左鼠标按钮。用于添加鼠标按钮的数字。**Add**：根据`True`或`False`的值，决定是否添加新的绑定。 | 将函数绑定到鼠标按钮释放事件。
    |'
- en: '| `ondrag(function, button = 1, add = None)` | **Function**: A function with
    two arguments, which represent the coordinates of the clicked point into the game
    screen.**Button**: Adds a number to indicate the mouse button listener. | Binds
    functions to mouse move events on the current turtle controller. If the function
    is `None`, the current binding will be removed. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `ondrag(function, button = 1, add = None)` | **Function**：带有两个参数的函数，表示点击点的坐标进入游戏屏幕。**Button**：添加一个数字以指示鼠标按钮监听器。
    | 将函数绑定到当前海龟控制器上的鼠标移动事件。如果函数为`None`，则将删除当前绑定。 |'
- en: 'Let''s make a simple program to grasp the idea of using the preceding methods
    for handling mouse events:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制作一个简单的程序来理解如何使用前面的方法处理鼠标事件：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see that the `onclick` method was called with only the move function,
    which in turn calls the move method with the *x* and *y* coordinates representing
    the clicked point onto the canvas. Running the preceding program does not draw
    any lines on the screen until you click on the drawing canvas. When you click
    on any point of the screen, you will see its coordinate printed in the Python
    shell, and a straight line will appear on the canvas. We will cover the remaining
    `turtle` methods in the upcoming chapter, along with how to make some mini games.
    Before that, we will try to make some shapes using the `turtle` module and the
    Python design patterns that we have learned about so far.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`onclick`方法只调用了移动函数，然后移动方法使用代表点击点的*x*和*y*坐标在画布上。运行上述程序在屏幕上不会绘制任何线条，直到您点击绘图画布。当您点击屏幕上的任何点时，您将在Python
    shell中看到其坐标，并且直线将出现在画布上。我们将在接下来的章节中介绍剩余的`turtle`方法，以及如何制作一些小游戏。在那之前，我们将尝试使用`turtle`模块和迄今为止学到的Python设计模式来制作一些形状。
- en: Drawing shapes with turtle
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用海龟绘制形状
- en: The process of making shapes may seem like a boring and tedious task for a human
    being, but it's not for computers. Imagine making a hexagonal shape with exact
    geometrical measurements while taking care of angles and sides. The process itself
    overwhelms most of us. On the other hand, computers are considered to work sedulously;
    we can throw as many tasks as we like at it, and it will perform them gracefully.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 制作形状的过程对人类来说可能看起来是一项乏味和繁琐的任务，但对计算机来说并非如此。想象一下在考虑角度和边的情况下制作具有精确几何测量的六边形。这个过程本身就会让我们大多数人感到不知所措。另一方面，计算机被认为是勤奋工作的；我们可以向它抛出尽可能多的任务，它会优雅地执行它们。
- en: As we have mentioned previously, two critical pieces of information while drawing
    any shape are the angle and length of each side. We can make variables to store
    them so that we can refer to them in the program whenever they are needed. For
    any shape, there will be a different number of sides. For example, a triangle
    has three sides, while a hexagon has six sides. We need to specify the number
    of sides explicitly in the program. In this section, we are going to make two
    shapes, a hexagon and a star shape, with some added colors. The main aim of this
    section is to help you understand how the programming paradigm is used, along
    with a particular module, in order to make appealing games.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，绘制任何形状时两个关键信息是每条边的角度和长度。我们可以创建变量来存储它们，以便在程序中需要时引用它们。对于任何形状，边的数量都会不同。例如，三角形有三条边，而六边形有六条边。我们需要在程序中明确指定边的数量。在本节中，我们将制作两种形状，一个六边形和一个星形，还加上一些颜色。本节的主要目的是帮助您了解编程范式是如何使用的，以及特定模块，以制作吸引人的游戏。
- en: 'The following list of steps depicts the roadmap that is needed in order to
    create two shapes, one by one. The first shape that we will create is a hexagon:
    a shape that has six sides, with a custom length. After that, we will make a star
    pattern again, but this time, we will add color properties to it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤列表描述了为了逐个创建两个形状所需的路线图。我们将首先创建的形状是一个六边形：一个有六条边的形状，具有自定义长度。之后，我们将再次制作星形图案，但这次我们将为其添加颜色属性：
- en: '**Hexagon**: We will create this shape by defining specific variables, such
    as the number of sides, interior angle, and length of sides. After that, we will
    use the for loop to create six iterations because we have to call the line rendering
    method six times (since a hexagon has six sides). We will use the `forward` method
    to draw a straight line and the `right` method to turn the turtle clockwise by
    a specific angle:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**六边形**：我们将通过定义特定变量来创建这个形状，比如边的数量、内角和边的长度。之后，我们将使用for循环创建六次迭代，因为我们必须调用线渲染方法六次（因为六边形有六条边）。我们将使用`forward`方法绘制一条直线，使用`right`方法将海龟顺时针旋转特定角度：'
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see how convenient it is to draw the shapes onto the canvas using the
    `turtle` module. We are already familiar with these methods and the usage of loops
    in order to remove the repetition of multiple lines of code; thus, it won't be
    hard to grasp the code that we have written over here.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以看到使用`turtle`模块在画布上绘制形状是多么方便。我们已经熟悉了这些方法以及使用循环来消除多行代码的重复；因此，理解我们在这里编写的代码不会很难。
- en: '**Star**: Making a star shape with Turtle is easier than using any other module.
    We have already made it using two methods of `turtle`, that is `forward` and `left`.
    But in this section, we are going to color the star shape using the `color` method
    provided by the `turtle` module. We will start by defining the color palette,
    that is, different color names, and we will make a method call of `begin_fill`
    and `begin_end`, which will add the color to the shapes. The following table shows
    three methods that can be used for coloring shapes in turtle:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**星形**：使用Turtle制作星形比使用任何其他模块更容易。我们已经使用了`turtle`的两种方法来制作它，即`forward`和`left`。但在本节中，我们将使用`turtle`模块提供的`color`方法为星形上色。我们将首先定义颜色调色板，即不同的颜色名称，并且我们将调用`begin_fill`和`begin_end`方法，这将为形状添加颜色。以下表格显示了可以用于给海龟着色的三种方法：'
- en: '| **Method** | **Parameter** | **Description** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **参数** | **描述** |'
- en: '|  `color(*args)` | Args represents the color''s name. The current color is
    used for drawing lines using the `forward` or `backward` methods. The color name
    can be given as `single value: color(“blue”)`, `double value: color(“black”,”green”)`,
    or `rgb` float values. | Used to change the color of the turtle pen. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `color(*args)` | Args代表颜色的名称。当前颜色用于使用`forward`或`backward`方法绘制线条。颜色名称可以作为`单个值：color(“blue”)`，`双值：color(“black”,”green”)`或`rgb`浮点值给出。
    | 用于改变乌龟笔的颜色。 |'
- en: '| `begin_fill()` | None | This method will remember the starting point for
    filled polygons. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `begin_fill()` | 无 | 这个方法将记住填充多边形的起始点。 |'
- en: '| `end_fill()` | None | It will close the shape drawn in the turtle canvas
    and fill it with the current fill color. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `end_fill()` | 无 | 它将关闭在乌龟画布中绘制的形状并用当前填充颜色填充它。 |'
- en: 'As an example, we will write a program that will use these methods to color
    the star pattern. We will use the color combination of red and yellow to make
    the star more attractive. We have been using the `import turtle` command to make
    `turtle` methods available for the program to use. Instead of doing it this way,
    we can import everything from turtle with the `from turtle import *` command.
    Now, instead of calling the `turtle` method with `>>> turtle.forward(100)`, we
    can call it directly, that is, `forward(100)`. Let''s write a program to create
    such a star pattern:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将编写一个程序，使用这些方法来给星形图案上色。我们将使用红色和黄色的颜色组合来使星星更具吸引力。我们一直在使用“import turtle”命令使“turtle”方法可供程序使用。与其这样做，我们可以使用“from
    turtle import *”命令从turtle中导入所有内容。现在，我们可以直接调用“turtle”方法，即“forward(100)”，而不是使用“>>>
    turtle.forward(100)”来调用它。让我们编写一个程序来创建这样一个星形图案：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I just love the way that turtle works with Python. Being able to bind every
    function to the programming paradigm of Python makes the `turtle` module effective
    to use. In the preceding code, we might not have any confusion with the first
    line of code, which simply imports everything from the `turtle` module—every attribute
    and member. We made a color palette of red and yellow using the `color` method.
    Inside the main loop, we will encounter two methods, which we have been using
    from the beginning of this chapter. In addition, we have added a conditional to
    indicate the stopping point for the turtle pen. The `abs()` method is used to
    return the absolute value of the number, that is, `>>> abs(-4)`, which yields
    4\. Inside the `abs()` function, we called the `pos()` method of the `turtle`
    module, which will return the position of turtle as a two-element list. We checked
    for the current position, and if it's less than 1, for example, 0, then it must
    represent the center position, because (0,0) represents the center position. If
    we encounter the center position after an iteration, that means we can terminate
    the program because at this point, we must have already drawn a star. If we proceed
    further, the turtle pen will draw another star on the same position, therefore
    overriding the old one.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢乌龟与Python一起工作的方式。能够将每个函数绑定到Python的编程范式使得“turtle”模块的使用效果很好。在前面的代码中，我们可能不会对第一行代码感到困惑，它只是从“turtle”模块中导入了所有内容——每个属性和成员。我们使用“color”方法制作了红色和黄色的调色板。在主循环中，我们将遇到两种方法，这些方法我们从本章开始就一直在使用。此外，我们添加了一个条件来指示乌龟笔的停止点。`abs()`方法用于返回数字的绝对值，即`>>>
    abs(-4)`，得到4。在`abs()`函数内部，我们调用了“turtle”模块的“pos()”方法，它将返回乌龟的位置作为一个两元素列表。我们检查了当前位置，如果小于1，例如0，那么它必须代表中心位置，因为(0,0)代表中心位置。如果我们在迭代后遇到中心位置，那么这意味着我们可以终止程序，因为在这一点上，我们必须已经画了一个星星。如果我们继续，乌龟笔将在相同的位置上画另一个星星，从而覆盖旧的星星。
- en: 'Thus, in order to prevent this continuous iteration, we have added a conditionals
    line: `if abs(pos()) < 1`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了防止这种连续迭代，我们添加了一个条件行：`if abs(pos()) < 1`。
- en: 'Executing the preceding programs yields the following output. One thing you
    must remember here is that, from the color palette, at the beginning, we used
    a red pen to draw the star, and after finishing it, we used yellow to fill the
    inner part of the star shape:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述程序会产生以下输出。在这里你必须记住的一件事是，从调色板开始，我们使用红色笔画星星，完成后，我们使用黄色填充星星形状的内部：
- en: '![](Images/d9d18f00-4b2e-4228-9cad-dc4770931526.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d9d18f00-4b2e-4228-9cad-dc4770931526.png)'
- en: Now that you know everything about the ways of using `turtle` methods for creating
    shapes and coloring them, we will wrap this chapter up here. We will be using
    the concepts we've learned in this chapter, such as creating patterns and handling
    user events, in the upcoming chapters by making simple mini games such as Snake,
    Pong, and Flappy Bird.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了使用“turtle”方法创建形状并对其上色的方法，我们将在此结束本章。我们将在接下来的章节中使用本章学到的概念，如创建图案和处理用户事件，制作简单的迷你游戏，比如Snake、Pong和Flappy
    Bird。
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The Python *turtle* module is a powerful platform for building 2D mini games.
    It contains a variety of methods in order to facilitate the design process of
    game characters. We have written a bunch of programs in this chapter, and also
    handled user events. We started this chapter by introducing the key features of
    the `turtle` module, and built a universal prototype for any game that can be
    made with the Python `turtle` module. This chapter taught us about animating a
    2D canvas using the `turtle` module. Along with animating game characters, we
    learned how to create interfaces that communicate between the game interface and
    the user controller by handling user events.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python的*turtle*模块是构建2D迷你游戏的强大平台。它包含各种方法，以便简化游戏角色的设计过程。我们在本章中编写了许多程序，并处理了用户事件。我们通过介绍“turtle”模块的关键特性开始了本章，并为可以使用Python“turtle”模块制作的任何游戏构建了一个通用原型。本章教会了我们如何使用“turtle”模块来制作2D画布动画。除了为游戏角色添加动画，我们还学会了如何通过处理用户事件创建游戏界面和用户控制器之间的通信接口。
- en: Following the completion of this chapter, you will be well equipped to create
    simple 2D games using the `turtle` module. You will also be able to handle the
    user actions that are provided by the mouse and the keyboard, which allows us
    to make user-interactive games. Now that you have learned how to create simple
    animations using the 2D Turtle canvas, you can create any geometrical shape; try
    a few more before hopping into the next chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够使用“turtle”模块创建简单的2D游戏。你还将能够处理鼠标和键盘提供的用户操作，这使我们能够制作用户交互式游戏。现在你已经学会了如何使用2D
    Turtle画布创建简单的动画，你可以创建任何几何形状；在进入下一章之前再尝试几个。
- en: We didn't cover any games in this chapter, because in order to create games
    with the `turtle` module, we need to explore vectors first—creating vectors, storing
    vectors, finding the magnitude of vectors, vector additions, negations, diagonal
    movements, and many more. We will cover all of these concepts in the next chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们没有涉及任何游戏，因为要使用“turtle”模块创建游戏，我们首先需要探索向量——创建向量、存储向量、找到向量的大小、向量相加、否定、对角线移动等等。我们将在下一章中涵盖所有这些概念。
- en: The topic of vectors is undoubtedly the most essential topic for any game developer's
    toolkit. Vectors are mathematical terms that represent the magnitude and direction
    of our game character that appears on the screen. Magnitude represents the modulus
    of the current coordinates of a point in which the character resides, while direction
    represents a course that the game character moves on. Now would be the perfect
    time for you to play around with the `turtle` module and grasp the idea of handling
    user events and building appealing shapes and characters.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的主题无疑是任何游戏开发者工具包中最基本的主题。向量是代表屏幕上出现的游戏角色的大小和方向的数学术语。大小表示角色所在点的当前坐标的模，而方向表示游戏角色移动的方向。现在是你玩弄“turtle”模块并掌握处理用户事件以及构建吸引人的形状和角色的完美时机。
