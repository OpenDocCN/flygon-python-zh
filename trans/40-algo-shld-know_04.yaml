- en: Sorting and Searching Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序和搜索算法
- en: In this chapter, we will look at the algorithms that are used for sorting and
    searching. This is an important class of algorithms that can be used on their
    own or can become the foundation for more complex algorithms (presented in the
    later chapters of this book). This chapter starts by presenting different types
    of sorting algorithms. It compares the performance of various approaches to designing
    a sorting algorithm. Then, some searching algorithms are presented in detail.
    Finally, a practical example of the sorting and searching algorithms presented
    in this chapter is explored.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下用于排序和搜索的算法。这是一类重要的算法，可以单独使用，也可以成为更复杂算法的基础（在本书的后面章节中介绍）。本章首先介绍了不同类型的排序算法。它比较了各种设计排序算法的方法的性能。然后，详细介绍了一些搜索算法。最后，探讨了本章介绍的排序和搜索算法的一个实际例子。
- en: By the end of this chapter, you will be able to understand the various algorithms
    that are used for sorting and searching, and you will be able to apprehend their
    strengths and weaknesses. As searching and sorting algorithms are the building
    blocks for most of the more complex algorithms, understanding them in detail will
    help you understand modern complex algorithms as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够理解用于排序和搜索的各种算法，并能够理解它们的优势和劣势。由于搜索和排序算法是大多数更复杂算法的基础，详细了解它们将有助于您理解现代复杂算法。
- en: 'The following are the main concepts discussed in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章讨论的主要概念：
- en: Introducing sorting algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍排序算法
- en: Introducing searching algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍搜索算法
- en: A practical example
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个实际的例子
- en: Let's first look at some sorting algorithms.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一些排序算法。
- en: Introducing Sorting Algorithms
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍排序算法
- en: In the era of big data, the ability to efficiently sort and search items in
    a complex data structure is quite important as it is needed by many modern algorithms.
    The right strategy to sort and search data will depend on the size and type of
    the data, as discussed in this chapter. While the end result is exactly the same,
    the right sorting and searching algorithm will be needed for an efficient solution
    to a real-world problem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在大数据时代，能够高效地对复杂数据结构中的项目进行排序和搜索是非常重要的，因为许多现代算法都需要这样做。正确的排序和搜索数据的策略将取决于数据的大小和类型，正如本章所讨论的。虽然最终结果是完全相同的，但对于实际问题的高效解决方案，需要正确的排序和搜索算法。
- en: 'The following sorting algorithms are presented in this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了以下排序算法：
- en: Bubble sort
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: Merge sort
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归并排序
- en: Insertion sort
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入排序
- en: Shell sort
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 希尔排序
- en: Selection sort
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择排序
- en: Swapping Variables in Python
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中交换变量
- en: 'When implementing sorting and searching algorithms, we need to swap the values
    of two variables. In Python, there is a simple way to swap two variables, which
    is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现排序和搜索算法时，我们需要交换两个变量的值。在Python中，有一种简单的交换两个变量的方式，如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s see how it works:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '![](assets/943d98a8-6cea-43f1-b3dc-1a96ed14a074.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/943d98a8-6cea-43f1-b3dc-1a96ed14a074.png)'
- en: This simple way of swapping values is used throughout the sorting and searching
    algorithms in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，这种简单的交换值的方式在排序和搜索算法中被广泛使用。
- en: Let's start by looking at the bubble sort algorithm in the next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从下一节开始看冒泡排序算法。
- en: Bubble Sort
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: Bubble sort is the simplest and slowest algorithm used for sorting. It is designed
    in a way that the highest value in its list bubbles its way to the top as the
    algorithm loops through iterations. As its worst-case performance is O(N²), as
    discussed previously, it should be used for smaller datasets.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序是用于排序的最简单和最慢的算法。它被设计成这样，列表中的最高值会在算法循环迭代时冒泡到顶部。正如之前讨论的，它的最坏情况性能是O(N²)，因此应该用于较小的数据集。
- en: Understanding the Logic Behind Bubble Sort
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解冒泡排序背后的逻辑
- en: 'Bubble sort is based on various iterations, called **passes**. For a list of
    size *N*, bubble sort will have *N*-1 passes. Let''s focus on the first iteration:
    pass one.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序基于各种迭代，称为**通行**。对于大小为*N*的列表，冒泡排序将有*N*-1个通行。让我们专注于第一次迭代：第一遍。
- en: The goal of pass one is pushing the highest value to the top of the list. We
    will see the highest value of the list bubbling its way to the top as pass one
    progresses.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一遍的目标是将最高的值推到列表的顶部。随着第一遍的进行，我们会看到列表中最高的值冒泡到顶部。
- en: 'Bubble sort compares adjacent neighbor values. If the value at a higher position
    is higher in value than the value at a lower index, we exchange the values. This
    iteration continues until we reach the end of the list. This is shown in the following
    diagram:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序比较相邻的邻居值。如果较高位置的值比较低索引处的值要大，我们交换这些值。这种迭代会一直持续，直到我们到达列表的末尾。如下图所示：
- en: '![](assets/1f24bd5d-ae99-4c23-b504-bdb9941e21d7.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1f24bd5d-ae99-4c23-b504-bdb9941e21d7.png)'
- en: 'Let''s now see how bubble sort can be implemented using Python:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用Python实现冒泡排序：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we implement pass one of bubble sort in Python, it will look as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Python中实现冒泡排序的第一遍，它将如下所示：
- en: '![](assets/4dd07ced-d8e2-4baa-a32d-73496686b03c.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4dd07ced-d8e2-4baa-a32d-73496686b03c.png)'
- en: Once the first pass is complete, the highest value is at the top of the list.
    The algorithm next moves on to the second pass. The goal of the second pass is
    to move the second highest value to the second highest position in the list. To
    do that, the algorithm will again compare adjacent neighbor values, exchanging
    them if they are not in order. The second pass will exclude the top element, which
    was put in the right place by pass one and need not be touched again.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一遍完成后，最高的值在列表的顶部。算法接下来进行第二遍。第二遍的目标是将第二高的值移动到列表中第二高的位置。为了做到这一点，算法将再次比较相邻的邻居值，如果它们不按顺序，则交换它们。第二遍将排除顶部元素，它已经被第一遍放在正确的位置上，不需要再次触摸。
- en: 'After completing pass two, the algorithm keeps on performing pass three and
    so on until all the data points of the list are in ascending order. The algorithm
    will need *N*-1 passes for a list of size *N* to completely sort it. The complete
    implementation of bubble sort in Python is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 完成第二次通行证后，算法将继续执行第三次通行证，直到列表的所有数据点按升序排列。算法将需要*N*-1次通行证来完全对大小为*N*的列表进行排序。Python中冒泡排序的完整实现如下：
- en: '![](assets/8112422d-7d3a-4910-b2e9-f1240a431250.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8112422d-7d3a-4910-b2e9-f1240a431250.png)'
- en: Now let's look into the performance of the `BubbleSort` algorithm.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`BubbleSort`算法的性能。
- en: A Performance Analysis of Bubble Sort
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冒泡排序的性能分析
- en: 'It is easier to see that bubble sort involves two levels of loops:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，冒泡排序涉及两个级别的循环：
- en: '**An outer loop**: This is also called **passes**. For example, pass one is
    the first iteration of the outer loop.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部循环**：这也被称为**通行证**。例如，通行证一是外部循环的第一次迭代。'
- en: '**An inner loop**: This is when the remaining unsorted elements in the list
    are sorted, until the highest value is bubbled to the right. The first pass will
    have *N*-1 comparisons, the second pass will have *N*-2 comparisons, and each
    subsequent pass will reduce the number of comparisons by one.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部循环**：这是当列表中剩余的未排序元素被排序时，直到最大值被冒泡到右侧。第一次通行证将有*N*-1次比较，第二次通行证将有*N*-2次比较，每次后续通行证将减少一次比较。'
- en: Due to two levels of looping, the worst-case runtime complexity would be O(n²).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个级别的循环，最坏情况下的运行时复杂度将是O(n²)。
- en: Insertion Sort
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入排序
- en: 'The basic idea of insertion sort is that in each iteration, we remove a data
    point from the data structure we have and then insert it into its right position.
    That is why we call this **the insertion sort algorithm**. In the first iteration,
    we select the two data points and sort them. Then, we expand our selection and
    select the third data point and find its correct position, based on its value.
    The algorithm progresses until all the data points are moved to their correct
    positions. This process is shown in the following diagram:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序的基本思想是，在每次迭代中，我们从数据结构中移除一个数据点，然后将其插入到正确的位置。这就是为什么我们称之为**插入排序算法**。在第一次迭代中，我们选择两个数据点并对它们进行排序。然后，我们扩展我们的选择并选择第三个数据点，并根据其值找到其正确的位置。算法进行到所有数据点都移动到它们的正确位置。这个过程如下图所示：
- en: '![](assets/8ba25bc4-942a-4704-abbe-558b0a521f69.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8ba25bc4-942a-4704-abbe-558b0a521f69.png)'
- en: 'The insertion sort algorithm can be coded in Python as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序算法可以在Python中编写如下：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that in the main loop, we iterate throughout all of the list. In each iteration,
    the two adjacent elements are `list[j]` (the current element) and `list[i]` (the
    next element).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在主循环中，我们遍历整个列表。在每次迭代中，两个相邻的元素分别是`list[j]`（当前元素）和`list[i]`（下一个元素）。
- en: In `list[j] > element_next` and `j >= 0`, we  compare the current element with
    the next element.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`list[j] > element_next`和`j >= 0`中，我们将当前元素与下一个元素进行比较。
- en: 'Let''s use this code to sort an array:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这段代码来对数组进行排序：
- en: '![](assets/f82e873e-fb1a-4e6f-a195-799328961525.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f82e873e-fb1a-4e6f-a195-799328961525.png)'
- en: Let's look at the performance of the insertion sort algorithm.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下插入排序算法的性能。
- en: 'It''s obvious from the description of the algorithm that if the data structure
    is already sorted, insertion sort will perform very fast. In fact, if the data
    structure is sorted, then the insertion sort will have a linear running time;
    that is, O(n). The worst case is when each of the inner loops has to move all
    the elements in the list. If the inner loop is defined by *i*, the worst-case
    performance of the insertion sort algorithm is given by the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从算法描述中很明显，如果数据结构已经排序，插入排序将执行得非常快。实际上，如果数据结构已排序，那么插入排序将具有线性运行时间；即O(n)。最坏情况是每个内部循环都必须移动列表中的所有元素。如果内部循环由*i*定义，插入排序算法的最坏情况性能如下所示：
- en: '![](assets/23bd35a5-d92c-42c8-80d7-c85821d98ffb.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/23bd35a5-d92c-42c8-80d7-c85821d98ffb.png)'
- en: '*![](assets/e136b412-be8f-4725-91d1-ab716386d1b8.png)*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](assets/e136b412-be8f-4725-91d1-ab716386d1b8.png)*'
- en: 'The total number of passes is shown in the following diagram:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总通行证数量如下图所示：
- en: '![](assets/03f8b384-ace0-401b-986f-d9fdfca57d1f.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/03f8b384-ace0-401b-986f-d9fdfca57d1f.png)'
- en: In general, insertion can be used on small data structures. For larger data
    structures, insertion sort is not recommended due to quadratic average performance.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，插入可以用于小型数据结构。对于较大的数据结构，由于二次平均性能，不建议使用插入排序。
- en: Merge Sort
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 归并排序
- en: 'We have presented, so far, two sorting algorithms: bubble sort and insertion
    sort. The performance of both of them will be better if the data is partially
    sorted. The third algorithm presented in this chapter is **the merge sort algorithm**,
    which was developed in 1940 by John von Neumann. The defining feature of this
    algorithm is that its performance is not dependent on whether the input data is
    sorted. Like MapReduce and other big data algorithms, it is based on a divide
    and conquer strategy. In the first phase, called splitting, the algorithm keeps
    on dividing the data into two parts recursively, until the size of the data is
    less than the defined threshold. In the second phase, called **merging**, the
    algorithm keeps on merging and processing until we get the final result. The logic
    of this algorithm is  explained in the following diagram:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了两种排序算法：冒泡排序和插入排序。如果数据部分排序，它们的性能都会更好。本章介绍的第三种算法是**归并排序算法**，它是由约翰·冯·诺伊曼于1940年开发的。该算法的特点是其性能不依赖于输入数据是否排序。与MapReduce和其他大数据算法一样，它基于分而治之的策略。在第一阶段，称为拆分，算法继续递归地将数据分成两部分，直到数据的大小小于定义的阈值。在第二阶段，称为**合并**，算法继续合并和处理，直到我们得到最终结果。该算法的逻辑如下图所示：
- en: '![](assets/bf2a1910-f8d4-4703-95e6-b68fe5a7ab3f.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bf2a1910-f8d4-4703-95e6-b68fe5a7ab3f.png)'
- en: 'Let''s first look into the pseudocode of the merge sort algorithm:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下归并排序算法的伪代码：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we can see the algorithm has the following three steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的算法有以下三个步骤：
- en: It divides the input list into two equal parts
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将输入列表分成两个相等的部分
- en: It uses recursion to split until the length of each list is 1
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用递归分割，直到每个列表的长度为1
- en: Then, it merges the sorted parts into a sorted list and returns it
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将排序好的部分合并成一个排序好的列表并返回它
- en: 'The code for implementing `MergeSort` is shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`MergeSort`的代码如下所示：
- en: '![](assets/90b41c82-5962-42c7-b781-57a59557f994.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/90b41c82-5962-42c7-b781-57a59557f994.png)'
- en: 'When the preceding Python code is run, it generates an output, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行上述Python代码时，它会生成以下输出：
- en: '![](assets/ff2f2912-318f-418a-800c-331c8ad48f00.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ff2f2912-318f-418a-800c-331c8ad48f00.png)'
- en: Note that the code results are in a sorted list.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码的结果是一个排序好的列表。
- en: Shell Sort
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谢尔排序
- en: The bubble sort algorithm compares immediate neighbors and exchanges them if
    they are out of order. If we have a partially sorted list, bubble sort should
    give reasonable performance as it will exit as soon as no more swapping of elements
    occurs in a loop.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序算法比较相邻的元素，如果它们的顺序不正确，则交换它们。如果我们有一个部分排序的列表，冒泡排序应该会有合理的性能，因为它会在循环中不再发生元素交换时立即退出。
- en: But for a totally unsorted list, sized *N*, you can argue that bubble sort will
    have to fully iterate through *N*-1 passes in order to get it fully sorted.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于完全无序的大小为*N*的列表，你可以说冒泡排序将不得不完全迭代*N*-1次才能完全排序它。
- en: Donald Shell proposed Shell sort (named after him), which questions the importance
    of selecting immediate neighbors for comparison and swapping.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 唐纳德·谢尔提出了谢尔排序（以他的名字命名），质疑了选择相邻元素进行比较和交换的重要性。
- en: Now, let's understand this concept.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们理解这个概念。
- en: 'In pass one, instead of selecting immediate neighbors, we use elements that
    are at a fixed gap, eventually sorting a sublist consisting of a pair of data
    points. This is shown in the following diagram. In pass two, it sorts sublists
    containing four data points (see the following diagram). In subsequent passes,
    the number of data points per sublist keeps on increasing and the number of sublists
    keeps on decreasing until we reach a situation where there is just one sublist
    that consists of all the data points. At this point, we can assume that the list
    is sorted:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次通过中，我们不是选择相邻的元素，而是使用固定间隔的元素，最终对由一对数据点组成的子列表进行排序。如下图所示。在第二次通过中，它对包含四个数据点的子列表进行排序（见下图）。在后续的通过中，每个子列表中的数据点数量不断增加，子列表的数量不断减少，直到我们达到只有一个包含所有数据点的子列表的情况。此时，我们可以假设列表已排序：
- en: '![](assets/495145de-2a5c-4d41-aceb-2a95e51cc8e6.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/495145de-2a5c-4d41-aceb-2a95e51cc8e6.png)'
- en: 'In Python, the code for implementing the Shell sort algorithm is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，实现谢尔排序算法的代码如下所示：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code can be used to sort the list, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以用于对列表进行排序，如下所示：
- en: '![](assets/0749878d-e9b5-4f42-8610-19075022e645.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0749878d-e9b5-4f42-8610-19075022e645.png)'
- en: Note that calling the `ShellSort` function has resulted in sorting the input
    array.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，调用`ShellSort`函数已导致对输入数组进行排序。
- en: A Performance Analysis of Shell Sort
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谢尔排序的性能分析
- en: Shell sort is not for big data. It is used for medium-sized datasets. Roughly
    speaking, it has a reasonably good performance on a list with up to 6,000 elements.
    If the data is partially in the correct order, the performance will be better.
    In a best-case scenario, if a list is already sorted, it will only need one pass
    through *N* elements to validate the order, producing a best-case performance
    of *O(N)*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 谢尔排序不适用于大数据。它用于中等大小的数据集。粗略地说，它在具有多达6000个元素的列表上具有相当不错的性能。如果数据部分处于正确的顺序，性能会更好。在最佳情况下，如果列表已经排序，它只需要通过*N*个元素进行一次验证，产生*O(N)*的最佳性能。
- en: Selection Sort
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择排序
- en: 'As we saw earlier in this chapter, bubble sort is one of the simplest sorting
    algorithms. Selection sort is an improvement on bubble sort, where we try to minimize
    the total number of swaps required with the algorithm. It is designed to make
    one swap for each pass, compared to *N*-1 passes with the bubble sort algorithm.
    Instead of bubbling the largest value toward the top in baby steps (as done in
    bubble sort, resulting in *N*-1 swaps), we look for the largest value in each
    pass and move it toward the top. So, after the first pass, the largest value will
    be at the top. After the second pass, the second largest value will be next to
    the top value. As the algorithm progresses, the subsequent values will move to
    their correct place based on their values. The last value will be moved after
    the (*N*-1)^(th)  pass. So, selection sort takes *N*-1 passes to sort *N* items:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面看到的，冒泡排序是最简单的排序算法之一。选择排序是对冒泡排序的改进，我们试图最小化算法所需的总交换次数。它旨在使每次通过只进行一次交换，而不是冒泡排序算法的*N*-1次通过。我们不是像冒泡排序中那样逐步将最大值向顶部冒泡（导致*N*-1次交换），而是在每次通过中寻找最大值并将其向顶部移动。因此，在第一次通过后，最大值将位于顶部。第二次通过后，第二大的值将位于顶部值旁边。随着算法的进行，后续的值将根据它们的值移动到它们的正确位置。最后一个值将在第(*N*-1)次通过后移动。因此，选择排序需要*N*-1次通过来排序*N*个项目：
- en: '![](assets/6e5e3334-1189-42eb-bb80-cac42d97f922.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6e5e3334-1189-42eb-bb80-cac42d97f922.png)'
- en: 'The implementation of selection sort in Python is shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Python中选择排序的实现如下所示：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the selection sort algorithm is executed, it will result in the following
    output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择排序算法被执行时，它将产生以下输出：
- en: '![](assets/d9494a36-e503-48a3-ad9f-b52b30611260.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d9494a36-e503-48a3-ad9f-b52b30611260.png)'
- en: Note that the final output is the sorted list.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最终输出是排序好的列表。
- en: The performance of the selection sort algorithm
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择排序算法的性能
- en: Selection sort's worst-case performance is *O(N**²**)*. Note that its worst
    performance is similar to bubble sort and it should not be used for sorting larger
    datasets. Still, selection sort is a better designed algorithm than bubble sort
    and its average performance is better than bubble sort due to the reduction in
    the number of exchanges.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 选择排序的最坏情况性能是*O(N**²)*。注意，它的最坏性能类似于冒泡排序，不应该用于对更大的数据集进行排序。尽管如此，选择排序比冒泡排序更好设计，并且由于交换次数的减少，其平均性能比冒泡排序更好。
- en: Choosing a sorting algorithm
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择排序算法
- en: The choice of the right sorting algorithm depends both on the size and the state
    of the current input data. For small input lists that are sorted, using an advanced
    algorithm will introduce unnecessary complexities to the code, with a negligible
    improvement in performance. For example, we do not need to use merge sort for
    smaller datasets. Bubble sort will be way easier to understand and implement.
    If the data is partially sorted, we can take advantage of that by using insertion
    sort. For larger datasets, the merge sort algorithm is the best one to use.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的排序算法取决于当前输入数据的大小和状态。对于已排序的小输入列表，使用高级算法会在代码中引入不必要的复杂性，而性能改善微乎其微。例如，对于较小的数据集，我们不需要使用归并排序。冒泡排序会更容易理解和实现。如果数据部分排序，我们可以利用插入排序。对于较大的数据集，归并排序算法是最好的选择。
- en: Introduction to Searching Algorithms
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索算法简介
- en: Efficiently searching data in complex data structures is one of the most important
    functionalities. The simplest approach, which will not be that efficient, is to
    search for the required data in each data point. But, as the data becomes bigger
    in size, we need more sophisticated algorithms designed for searching data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂数据结构中高效地搜索数据是最重要的功能之一。最简单的方法是在每个数据点中搜索所需的数据，但随着数据规模的增大，我们需要更复杂的为搜索数据设计的算法。
- en: 'The following searching algorithms are presented in this section:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了以下搜索算法：
- en: Linear search
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性搜索
- en: Binary search
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二分搜索
- en: Interpolation search
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插值搜索
- en: Let's look at each of them in more detail.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看它们每一个。
- en: Linear Search
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性搜索
- en: One of the simplest strategies for searching data is to simply loop through
    each element looking for the target. Each data point is searched for a match and
    when a match is found, the results are returned and the algorithm exits the loop.
    Otherwise, the algorithm keeps on searching until it reaches the end of the data.
    The obvious disadvantage of linear search is that it is very slow due to the inherent
    exhaustive search. The advantage is that the data does not need to be sorted,
    as required by the other algorithms presented in this chapter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索数据的最简单策略之一是简单地循环遍历每个元素寻找目标。每个数据点都被搜索匹配，当找到匹配时，结果被返回并且算法退出循环。否则，算法会继续搜索直到达到数据的末尾。线性搜索的明显缺点是由于固有的穷举搜索，它非常慢。优点是数据不需要像本章介绍的其他算法那样需要排序。
- en: 'Let''s look at the code for linear search:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下线性搜索的代码：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s now look at the output of the preceding code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下前面代码的输出：
- en: '![](assets/8406c7c9-2fee-4e53-be31-6c5efcd71876.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8406c7c9-2fee-4e53-be31-6c5efcd71876.png)'
- en: Note that running the `LinearSearch` function returns a `True` value if it can
    successfully find the data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，运行`LinearSearch`函数会在成功找到数据时返回`True`值。
- en: The Performance of Linear Search
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性搜索的性能
- en: As discussed, linear search is a simple algorithm that performs an exhaustive
    search. Its worst-case behavior is *O(N)*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如讨论的那样，线性搜索是一种执行穷举搜索的简单算法。它的最坏情况行为是*O(N)*。
- en: Binary Search
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二分搜索
- en: 'The pre-requisite of the binary search algorithm is sorted data. The algorithm
    iteratively divides a list into two parts and keeps a track of the lowest and
    highest indices until it finds the value it is looking for:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索算法的先决条件是排序数据。该算法迭代地将列表分成两部分，并跟踪最低和最高索引，直到找到所寻找的值：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](assets/4b23f9aa-ada6-4d28-841b-eea4256a3c7e.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4b23f9aa-ada6-4d28-841b-eea4256a3c7e.png)'
- en: Note that calling the `BinarySearch` function will return `True` if the value
    is found in the input list.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，调用`BinarySearch`函数将在输入列表中找到值时返回`True`。
- en: The Performance of Binary Search
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二分搜索的性能
- en: Binary search is so named because at each iteration, the algorithm bifurcates
    the data into two parts. If the data has *N* items, it will take a maximum of
    O(logN) steps to iterate. This means that the algorithm has an *O(logN)* runtime.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索之所以被这样命名，是因为在每次迭代中，算法将数据分成两部分。如果数据有*N*个项目，迭代最多需要O(logN)步。这意味着算法具有*O(logN)*的运行时间。
- en: Interpolation Search
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值搜索
- en: 'Binary search is based on the logic that it focuses on the middle section of
    the data. Interpolation search is more sophisticated. It uses the target value
    to estimate the position of the element in the sorted array. Let''s try to understand
    it by using an example. Let''s assume we want to search for a word in an English
    dictionary, such as the word *river*. We will use this information to interpolate
    and start searching for words starting with *r*. A more generalized interpolation
    search can be programmed as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索基于将重点放在数据的中间部分的逻辑。插值搜索更加复杂。它使用目标值来估计已排序数组中元素的位置。让我们通过一个例子来理解它。假设我们想在英语词典中搜索一个单词，比如*river*。我们将利用这些信息进行插值，并开始搜索以*r*开头的单词。更一般化的插值搜索可以编程如下：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](assets/bc21fe23-43bb-4852-8e42-1458f022db6a.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bc21fe23-43bb-4852-8e42-1458f022db6a.png)'
- en: Note that before using `IntPolsearch`, the array first needs to be sorted using
    a sorting algorithm.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在使用`IntPolsearch`之前，数组首先需要使用排序算法进行排序。
- en: The Performance of Interpolation Search
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插值搜索的性能
- en: If the data is unevenly distributed, the performance of the interpolation search
    algorithm will be poor. The worst-case performance of this  algorithm is *O(N)*
    and if the data is somewhat reasonably uniform, the best performance is O(log(log
    N)).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据分布不均匀，插值搜索算法的性能将很差。该算法的最坏情况性能为*O(N)*，如果数据相对均匀，最佳性能为O(log(log N))。
- en: Practical Applications
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际应用
- en: The ability to efficiently and accurately search data in a given data repository
    is critical to many real-life applications. Depending on your choice of searching
    algorithm, you may need to sort the data first  as well. The choice of the right
    sorting and searching algorithms will depend on the type and the size of the data,
    as well as the nature of the problem you are trying to solve.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定数据存储库中高效准确地搜索数据对许多现实生活应用至关重要。根据您选择的搜索算法，您可能需要首先对数据进行排序。选择正确的排序和搜索算法将取决于数据的类型和大小，以及您试图解决的问题的性质。
- en: Let's try to use the algorithms presented in this chapter to solve the problem
    of matching a new applicant at the immigration department of a certain country
    with historical records. When someone applies for a visa to enter the country,
    the system tries to match the applicant with the existing historical records.
    If at least one match is found, then the system further calculates the number
    of times that the individual has been approved or refused in the past. On the
    other hand, if no match is found, the system classes the applicant as a new applicant
    and issues them a new identifier. The ability to search, locate, and identify
    a person in the historical data is critical for the system. This information is
    important because if someone has applied in the past and the application is known
    to have been refused, then this may affect that individual's current application
    in a negative way. Similarly, if someone's application is known to have been approved
    in the past, this approval may increase the chances of that individual getting
    approval for their current application. Typically, the historical database will
    have millions of rows, and we will need a well-designed solution to match new
    applicants in the historical database.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用本章介绍的算法来解决某个国家移民局新申请人与历史记录匹配的问题。当有人申请签证进入该国时，系统会尝试将申请人与现有的历史记录进行匹配。如果至少找到一个匹配项，那么系统会进一步计算个人过去被批准或拒绝的次数。另一方面，如果没有找到匹配项，系统会将申请人分类为新申请人，并为其发放新的标识符。在历史数据中搜索、定位和识别个人的能力对系统至关重要。这些信息很重要，因为如果某人过去曾申请过并且已知申请被拒绝，那么这可能会对该个人当前的申请产生负面影响。同样，如果某人的申请过去已知被批准，那么这个批准可能会增加该个人当前申请获批准的机会。通常，历史数据库将有数百万行数据，我们需要一个精心设计的解决方案来将新申请人与历史数据库进行匹配。
- en: 'Let''s assume that the historical table in the database looks like the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设数据库中的历史表如下所示：
- en: '| **Personal ID** | **Application ID** | **First name** | **Surname** | **DOB**
    | **Decision** | **Decision date** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **个人ID** | **申请ID** | **名字** | **姓氏** | **出生日期** | **决定** | **决定日期** |'
- en: '| 45583 | 677862 | John | Doe | 2000-09-19 | Approved | 2018-08-07 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 45583 | 677862 | 约翰 | 多 | 2000-09-19 | 已批准 | 2018-08-07 |'
- en: '| 54543 | 877653 | Xman | Xsir | 1970-03-10 | Rejected | 2018-06-07 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 54543 | 877653 | Xman | Xsir | 1970-03-10 | 被拒绝 | 2018-06-07 |'
- en: '| 34332 | 344565 | Agro | Waka | 1973-02-15 | Rejected | 2018-05-05 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 34332 | 344565 | 阿格罗 | 瓦卡 | 1973-02-15 | 被拒绝 | 2018-05-05 |'
- en: '| 45583 | 677864 | John | Doe | 2000-09-19 | Approved | 2018-03-02 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 45583 | 677864 | 约翰 | 多 | 2000-09-19 | 已批准 | 2018-03-02 |'
- en: '| 22331 | 344553 | Kal | Sorts | 1975-01-02 | Approved | 2018-04-15 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 22331 | 344553 | 卡尔 | 索茨 | 1975-01-02 | 已批准 | 2018-04-15 |'
- en: In this table, the first column, `Personal ID`, is associated with each of the
    unique applicants in the historical database. If there are 30 million unique applicants
    in the historical database, then there will be 30 million unique personal IDs.
    Each personal ID identifies an applicant in the historical database system.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表中，第一列“个人ID”与历史数据库中的每个唯一申请人相关联。如果历史数据库中有3000万个唯一申请人，那么将有3000万个唯一的个人ID。每个个人ID标识历史数据库系统中的一个申请人。
- en: The second column we have is `Application ID`. Each application ID identifies
    a unique application in the system. A person may have applied more than once in
    the past. So, this means that in the historical database, we will have more unique
    application IDs than personal IDs. John Doe will only  have one personal ID but
    has two application IDs, as shown in the preceding table.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第二列是“申请ID”。每个申请ID标识系统中的一个唯一申请。一个人过去可能申请过多次。这意味着在历史数据库中，我们将有比个人ID更多的唯一申请ID。如上表所示，约翰·多只有一个个人ID，但有两个申请ID。
- en: 'The preceding table only shows a sample of the historical dataset. Let''s assume
    that we have close to 1 million rows in our historical dataset, which contains
    the records of the last 10 years of applicants. New applicants are continuously
    arriving at the average rate of around 2 applicants per minute. For each applicant,
    we need to do the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上表仅显示了历史数据集的一部分样本。假设我们的历史数据集中有接近100万行数据，其中包含过去10年申请人的记录。新申请人以每分钟约2人的平均速度持续到达。对于每个申请人，我们需要执行以下操作：
- en: Issue a new application ID for the applicant.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为申请人发放新的申请ID。
- en: See if there is a match with an applicant in the historical database.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看历史数据库中是否有与申请人匹配的记录。
- en: If a match is found, use the personal ID for that applicant, as found in the
    historical database. We also need to determine that how many times the application
    has been approved or refused in the historical database.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到匹配项，则使用历史数据库中找到的个人ID。我们还需要确定在历史数据库中申请已被批准或拒绝的次数。
- en: If no match is found, then we need to issue a new personal ID for that individual.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有找到匹配项，那么我们需要为该个人发放新的个人ID。
- en: 'Suppose a new person arrives with the following credentials:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个新的人员带着以下的证件到达：
- en: '`First Name`: `John`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “名字”： “约翰”
- en: '`Surname`: `Doe`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓氏：`多`
- en: '`DOB`: `2000-09-19`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`出生日期`：`2000-09-19`'
- en: Now, how can we design an application that can perform an efficient and cost-effective
    search?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何设计一个能够执行高效和具有成本效益的搜索的应用程序呢？
- en: 'One strategy for searching the new application in the database can be devised
    as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索数据库中新申请的一个策略可以设计如下：
- en: Sort the historical database by `DOB`.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按`出生日期`对历史数据库进行排序。
- en: Each time a new person arrives, issue a new application ID to the applicant.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次有新人到来时，都要为申请人发放新的申请ID。
- en: Fetch all the records that match that date of birth. This will be the primary
    search.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所有与该出生日期匹配的记录。这将是主要搜索。
- en: Out of the records that have come up as matches, perform a secondary search
    using the first and last name.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在出现匹配项的记录中，使用名字和姓氏进行次要搜索。
- en: If a match is found, use `Personal ID` to refer to the applicants. Calculate
    the number of approvals and refusals.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到匹配项，请使用`个人ID`来引用申请人。计算批准和拒绝的次数。
- en: If no match is found, issue a new personal ID to the applicant.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找不到匹配项，请为申请人发放新的个人ID。
- en: Let's try choosing the right algorithm to sort the historical database. We can
    safely rule out bubble sort as the size of the data is huge. Shell sort will perform
    better, but only if we have partially sorted lists. So, merge sort may be the
    best option for sorting the historical database.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试选择正确的算法来对历史数据库进行排序。我们可以安全地排除冒泡排序，因为数据量很大。希尔排序将表现更好，但仅当我们有部分排序的列表时。因此，归并排序可能是对历史数据库进行排序的最佳选择。
- en: When a new person arrives, we need to locate and search that person in the historical
    database. As the data is already sorted, either interpolation search or binary
    search can be used. Because applicants are likely to be equally spread out, as
    per `DOB`, we can safely use binary search.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当有新人到来时，我们需要在历史数据库中定位并搜索该人。由于数据已经排序，可以使用插值搜索或二分搜索。因为申请人可能根据`出生日期`均匀分布，所以可以安全地使用二分搜索。
- en: Initially, we search based on `DOB`, which returns a set of applicants sharing
    the same date of birth. Now, we need to find the required person within the small
    subset of people who share the same date of birth. As we have successfully reduced
    the data to a small subset, any of the search algorithms, including bubble sort,
    can be used to search for the applicant. Note that we have simplified the secondary
    search problem here a bit. We also need to calculate the total number of approvals
    and refusals by aggregating the search results, if more than one match is found.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们基于`出生日期`进行搜索，这将返回一组共享相同出生日期的申请人。现在，我们需要在共享相同出生日期的小子集中找到所需的人。由于我们已成功将数据减少到一个小子集，任何搜索算法，包括冒泡排序，都可以用于搜索申请人。请注意，我们在这里稍微简化了次要搜索问题。如果找到多个匹配项，我们还需要通过汇总搜索结果来计算批准和拒绝的总数。
- en: In a real-world scenario, each individual needs to be identified in the secondary
    search using some fuzzy search algorithm, as the first and last names may be spelled
    slightly differently. The search may need to use some kind of distance algorithm
    to implement the fuzzy search, where the data points whose similarity is above
    a defined threshold are considered the same.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实场景中，每个个体都需要在次要搜索中使用一些模糊搜索算法进行识别，因为名字可能拼写略有不同。搜索可能需要使用某种距离算法来实现模糊搜索，其中相似度高于定义的阈值的数据点被视为相同。
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we presented a set of sorting and searching algorithms. We
    also discussed the strengths and weaknesses of different sorting and searching
    algorithms. We quantified the performance of these algorithms and learned when
    to use each algorithm.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一组排序和搜索算法。我们还讨论了不同排序和搜索算法的优缺点。我们量化了这些算法的性能，并学会了何时使用每个算法。
- en: In the next chapter, we will study dynamic algorithms. We will also look at
    a practical example of designing an algorithm and the details of the page ranking
    algorithm. Finally, we will study the linear programming algorithm.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习动态算法。我们还将研究设计算法的实际示例以及页面排名算法的细节。最后，我们将学习线性规划算法。
