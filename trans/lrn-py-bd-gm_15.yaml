- en: Getting to Know Pymunk by Building an Angry Birds Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过构建愤怒的小鸟游戏来了解Pymunk
- en: Python, being a standalone language for half a decade in data science and machine
    learning, was not popular enough in the game development industry until open source
    packages such as pymunk evolved. These open source packages provided game developers
    with an easy interface for mimicking real-world environments through simulation,
    which allowed them to create single or multiple body objects that linked the player's
    input to physical impulses. This evolution brought the usage of a continuous physics
    model into Python game development, where some objects were allowed to rest for
    efficiency purposes and were only brought into the light with the principle of
    collision. With this model, we can handle multiple object collisions properly
    and efficiently.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python作为数据科学和机器学习领域的独立语言已有半个世纪之久，但在游戏开发行业并不够流行，直到像pymunk这样的开源软件包出现。这些开源软件包为游戏开发人员提供了一个简单的界面，通过模拟来模仿真实世界的环境，从而允许他们创建与玩家输入相关联的单个或多个物体。这一进步将连续物理模型引入了Python游戏开发中，其中一些物体被允许休息以提高效率，并且只有在碰撞原则下才会被引入光线。通过这种模型，我们可以正确而有效地处理多个物体的碰撞。
- en: By the end of this chapter, you will have learned about the fundamentals of
    Pythonic 2D physics library so that you know how to use classes and submodules
    to build complex games such as Angry Birds, which simulates the real-world environment
    by considering physical properties such as mass, motion, inertia, elasticity,
    and moment. You will also learn how to create 2D rigid bodies and link them to
    the player's input in order to simulate physical impulses. This will result in
    movement in the rigid bodies within the simulated environment (space). You will
    also learn how to use time interval steps (dt) by updating physical attributes
    that facilitate movement for rigid bodies within that space.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，您将了解Pythonic 2D物理库的基础知识，从而知道如何使用类和子模块来构建像愤怒的小鸟这样的复杂游戏，通过考虑质量、运动、惯性、弹性和力矩等物理属性来模拟真实世界的环境。您还将学习如何创建2D刚体并将它们与玩家的输入相关联，以模拟物理冲量。这将导致刚体在模拟环境（空间）内的运动。您还将学习如何使用时间间隔步长（dt）通过更新促进刚体在该空间内运动的物理属性。
- en: Up until now, you have been checking collisions between two game entities (in
    [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake
    Game UI with Pygame*, you checked collisions between the snake and the boundary
    wall, while in [Chapter](6eb72797-e976-49b0-878f-4db620a59aca.xhtml) [1](6eb72797-e976-49b0-878f-4db620a59aca.xhtml)[2](6eb72797-e976-49b0-878f-4db620a59aca.xhtml)*,
    Learning About Character Animation, Collision, and Movement*, you checked collisions
    between the bird and a vertical pipe), but this chapter will be more edifying
    in the sense that you will be checking collisions between three game objects one
    by one and performing actions by creating a collision handler.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您一直在检查两个游戏实体之间的碰撞（在[第11章](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml)中，*使用Pygame制作Outdo
    Turtle - Snake Game UI*，您检查了蛇与边界墙之间的碰撞，而在[第12章](6eb72797-e976-49b0-878f-4db620a59aca.xhtml)*，学习角色动画、碰撞和移动*中，您检查了鸟与垂直管道之间的碰撞），但本章将更加启发人，因为您将逐个检查三个游戏对象之间的碰撞，并通过创建碰撞处理程序执行操作。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding pymunk
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解pymunk
- en: Creating a character controller
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建角色控制器
- en: Creating a polygon class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多边形类
- en: Exploring Pythonic physics simulation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Pythonic物理模拟
- en: Implementing sling-action
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施弹弓动作
- en: Addressing collisions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理碰撞
- en: Creating levels
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建关卡
- en: Handling user events
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户事件
- en: Possible modifications
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的修改
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You must have the following requirements to be able to complete this chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须具备以下要求才能完成本章：
- en: The Pygame editor (IDLE) version 3.5 or higher.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pygame编辑器（IDLE）版本3.5或更高版本。
- en: The PyCharm IDE (refer to [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml), *Getting
    to Know Python – Setting Up Python and the Editor*, for the installation procedure).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm IDE（参考[第1章](0ef9574b-5690-454e-971f-85748021018d.xhtml)，*了解Python -
    设置Python和编辑器*，了解安装过程）。
- en: The `pymunk` module (an open source library that's available at [http://www.pymunk.org/en/latest/](http://www.pymunk.org/en/latest/)).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pymunk`模块（可在[http://www.pymunk.org/en/latest/](http://www.pymunk.org/en/latest/)找到的开源库）。'
- en: The code for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书的GitHub存储库中找到：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15)
- en: 'An external link to the sprite sheets for angry birds: [https://www.spriters-resource.com/mobile/angrybirds/sheet/59982/](https://www.spriters-resource.com/mobile/angrybirds/sheet/59982/).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 愤怒的小鸟的精灵表外部链接：[https://www.spriters-resource.com/mobile/angrybirds/sheet/59982/](https://www.spriters-resource.com/mobile/angrybirds/sheet/59982/)。
- en: 'Check out the following video to see the code in action:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频以查看代码的运行情况：
- en: '[http://bit.ly/2oG246k](http://bit.ly/2oG246k)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2oG246k](http://bit.ly/2oG246k)'
- en: Understanding pymunk
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解pymunk
- en: In a real-world environment, objects move in ubiquitous directions arbitrarily.
    Thus, to mimic such movements, games must address the different physical behaviors
    of objects. For example, when we throw an object in the air, due to the presence
    of gravity, the object will hit the ground at some point. Similarly, we must also
    address the reduction in the velocity of objects every time an object bounces
    back from the surface. For example, if we were to take a ball and throw it in
    the air, after some time, it must hit the ground with the original velocity, V[o], and
    after one hit to the surface, it will bounce off the surface and then ascend with
    velocity V[f]. Therefore, it is obvious that V[o] > V[f]. Implementing this kind
    of behavior for objects in a game environment will leave players with a good impression
    of the game.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实环境中，物体以各种方向任意移动。因此，为了模仿这种运动，游戏必须处理物体的不同物理行为。例如，当我们把一个物体扔到空中时，由于重力的存在，物体会在某个时刻撞击地面。同样，我们还必须处理每次物体从表面弹回时速度的减小。例如，如果我们拿一个球扔到空中，一段时间后，它必须以原始速度V[o]撞击地面，然后在表面弹起，以速度V[f]上升。因此，很明显V[o]
    > V[f]。在游戏环境中实现这种物体行为将给玩家留下良好的印象。
- en: 'Physics, being a branch of natural science, tries to simulate real-world actions
    through simulation and mathematical deduction. Different terminology is defined
    in physics, such as mass, inertia, impulse, elasticity, friction, and so on. These
    terminologies define the characteristics of objects when they''re exposed to different
    environments. Without getting bogged down in the intricacies of physics, let''s
    get down to business. The real question is, why do we need physics in games? The
    answer to this question is simple: similar to real-world objects, games also have
    objects/characters. These characters are governed by the players of the game.
    Most players love to play a game that simulates a real-world phenomenon.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为自然科学的一个分支，物理学试图通过模拟和数学推导来模拟真实世界的行为。物理学定义了不同的术语，如质量、惯性、冲量、弹性、摩擦等。这些术语定义了物体在不同环境中暴露时的特性。不要陷入物理学的复杂性，让我们开始做生意。真正的问题是，为什么我们需要在游戏中加入物理学？这个问题的答案很简单：与现实世界的物体一样，游戏也有物体/角色。这些角色由游戏的玩家控制。大多数玩家喜欢玩模拟真实世界现象的游戏。
- en: 'Some physical terms you must understand before using the `pymunk` module are
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`pymunk`模块之前，您必须了解一些物理术语，如下所示：
- en: '**Mass**: Literally, mass refers to the weight of any object. While considering
    its physical definition, the mass of an object is a measure of the amount of matter
    in the object.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量**: 从字面上讲，质量指的是任何物体的重量。在考虑其物理定义时，物体的质量是物体中物质的量的度量。'
- en: '**Force**: A force is a push or a pull upon an object resulting from the object''s
    *interaction* with another object.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力**: 力是由物体与另一个物体的*相互作用*而产生的对物体的推或拉。'
- en: '**Gravity**: The force that causes, for example, an apple to fall toward the
    ground. Gravity is the force that attracts two bodies to each other.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重力**: 导致苹果向地面掉落的力。重力是吸引两个物体彼此的力。'
- en: '**Elasticity**: A property of deformed objects where they get reshaped and
    go back to their original form. For example, a spring and a rubber band will go
    back to their original shape, even if force is applied to distort them.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**: 受变形的物体的属性，它们会重新塑形并恢复到原来的形状。例如，弹簧和橡皮筋即使受到力的作用也会恢复到原来的形状。'
- en: '**Moment**: A moment of force is a property that causes an object to rotate
    around a specific point or axis.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力矩**: 力矩是导致物体围绕特定点或轴旋转的属性。'
- en: 'If you have not played Angry Birds before, make sure to check out this link:
    [http://freeangrybirdsgame.org/play/angry_birds_online.html](http://freeangrybirdsgame.org/play/angry_birds_online.html.).
    While playing the game, observe the number of characters, structures, and catapult
    actions.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前没有玩过愤怒的小鸟，请确保查看此链接：[http://freeangrybirdsgame.org/play/angry_birds_online.html](http://freeangrybirdsgame.org/play/angry_birds_online.html)。在玩游戏时，观察角色、结构和弹弓动作的数量。
- en: It would be boring if both of the characters in our Angry Birds game (Bird and
    Pig) had horizontal movements. For instance, when the player shoots an Angry Bird
    from the catapult or material slingshot, what if it doesn't follow projectile
    motion (45-degree motion) and just goes in a horizontal direction (90-degree motion)?
    This violates one of the laws of physics which states that *Earth pulls down on
    you*. Maybe we could argue that's why this is a big deal. Violating such laws
    would make games asinine and absurd, which might hamper the reputation of the
    game. In order to simulate such real-world physics in games, the Python community
    has developed a 2D physics library. We can employ different characteristics for
    game objects such as mass, inertia, impulse, and friction using this library.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愤怒的小鸟游戏中的两个角色（鸟和猪）都有水平移动，那将会很无聊。例如，当玩家从弹弓或弹弓射出一只愤怒的小鸟时，如果它不遵循抛射运动（45度运动），而只是水平运动（90度运动）会怎么样？这违反了物理定律之一，即*地球对你产生吸引力*。也许我们可以说这就是为什么这很重要。违反这样的定律会使游戏变得愚蠢和荒谬，这可能会损害游戏的声誉。为了在游戏中模拟这种真实世界的物理现象，Python社区开发了一个2D物理库。我们可以使用这个库为游戏对象应用不同的特性，如质量、惯性、冲量和摩擦。
- en: First of all, I recommend that you check out the official documentation of pymunk
    at [http://www.pymunk.org/en/latest/pymunk.html.](http://www.pymunk.org/en/latest/pymunk.html)
    Since the packages and modules of `pymunk` are frequently updated, you will see
    a huge amount of resources on their official documentation page. Just don't get
    overwhelmed by how many there are—we will need only a few of them to make a game
    that uses the pymunk 2D physics library.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我建议您查看pymunk的官方文档[http://www.pymunk.org/en/latest/pymunk.html.](http://www.pymunk.org/en/latest/pymunk.html)。由于`pymunk`的软件包和模块经常更新，您将在官方文档页面上看到大量资源。只是不要被它们的数量所压倒——我们只需要其中的一些资源来制作使用pymunk
    2D物理库的游戏。
- en: Now that you have gone through the documentation, I assume that you might have
    seen several submodules and classes. We will need some of them, all of which we
    will discuss. We will start with pymunk, which is the most popular and widely
    used submodule. It's named `vec2d`. To observe the working of `vec2d`, you have
    to brush up on your basics, which we learned about in [Chapter 9](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml), *Data
    Model Implementation*. To recap, we used different data models to implement vector
    manipulation (we used `__add__()` to add vectors, `__str__()` to format vectors,
    and so on). We've already learned about vector manipulation, but in a Pythonic
    way; now, let's learn about it in a modular way. The Python developer community
    has created a submodule for `vec2d`; that is, the `Vec2d` class, in order to perform
    any vector-related manipulation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经阅读了文档，我假设您可能已经看到了几个子模块和类。我们将需要其中一些，我们将讨论所有这些。我们将从pymunk开始，这是最受欢迎和广泛使用的子模块。它被命名为“vec2d”。要观察“vec2d”的工作原理，您必须复习我们在[第9章](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml)中学到的基础知识，*数据模型实现*。简而言之，我们使用不同的数据模型来实现向量操作（我们使用`__add__（）`来添加向量，`__str__（）`来格式化向量等）。我们已经学习了关于向量操作的知识，但是以一种Pythonic的方式；现在，让我们以一种模块化的方式来学习。Python开发者社区已经为“vec2d”创建了一个子模块；也就是说，“Vec2d”类，以执行任何与向量相关的操作。
- en: Before looking at an example of the `Vec2d` class, let's set up our PyCharm
    project first. Open the PyCharm editor and create a new project. I will call it
    *Angry Bird*. After providing a name for the project, press the Create button
    to create a project. When PyCharm is ready with your project, create a new Python
    file called `test.py`. Before writing any code, we have to install the `pymunk`
    module in the current project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看“Vec2d”类的示例之前，让我们先设置PyCharm项目。打开PyCharm编辑器并创建一个新项目。我会称其为*愤怒的小鸟*。提供项目名称后，按“创建”按钮创建项目。当PyCharm准备好您的项目后，请创建一个名为“test.py”的新Python文件。在编写任何代码之前，我们必须在当前项目中安装“pymunk”模块。
- en: 'Follow these steps to do so (to get a detailed description of how to install
    any third-party library in PyCharm, refer to [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml), *Getting
    to Know Python – Setting Up Python and the Editor*):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作（要获取有关如何在PyCharm中安装任何第三方库的详细说明，请参阅[第1章](0ef9574b-5690-454e-971f-85748021018d.xhtml)，*了解Python
    - 设置Python和编辑器*）：
- en: Click on File | Settings. The Settings window will open.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“文件”|“设置”。将打开“设置”窗口。
- en: 'On the left-hand side tab, click on the Project: Angry Bird tab. It will list
    all the modules that have been installed in the Python interpreter.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧选项卡上，单击“项目：愤怒的小鸟”选项卡。它将列出已在Python解释器中安装的所有模块。
- en: To add a new module, click on the (+) button next to the Packages tab.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加新模块，请单击“包”选项卡旁边的(+)按钮。
- en: Search for `pymunk` and install the module (make sure your internet connection
    is up and running).
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索“pymunk”并安装该模块（确保您的互联网连接正常）。
- en: 'Now that the `pymunk` module has been successfully installed, let''s get back
    to the `Vec2d` class. As we mentioned previously, this class can be used to perform
    vector manipulation. It is an alternative to using data models for vector manipulation.
    Let''s look at a simple example of creating a vector using the `Vec2d` class:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在“pymunk”模块已成功安装，让我们回到“Vec2d”类。正如我们之前提到的，这个类可以用来执行向量操作。这是一种替代使用数据模型进行向量操作的方法。让我们看一个使用“Vec2d”类创建向量的简单示例：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Apart from performing mathematical computations, `Vec2d` can also perform different
    high-level functional computations. For instance, if you want to find the distance
    between two vectors, we can call the `get_distance()` function, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了执行数学计算之外，“Vec2d”还可以执行不同的高级功能计算。例如，如果您想要找到两个向量之间的距离，我们可以调用“get_distance（）”函数，如下所示：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding function calculates the distance between two vectored points using
    the formula √(x2 − x1)^2 + (y2 − y1)^2, where (x1, y1) and (x2, y2) are two vectored
    coordinates. To learn more about the distance formula, please go to [https://www.purplemath.com/modules/distform.htm](https://www.purplemath.com/modules/distform.htm).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数使用公式√（x2 − x1）^2 +（y2 − y1）^2计算两个向量点之间的距离，其中（x1，y1）和（x2，y2）是两个向量坐标。要了解有关距离公式的更多信息，请转到[https://www.purplemath.com/modules/distform.htm](https://www.purplemath.com/modules/distform.htm)。
- en: Now that we have explored `Vec2d`, we will learn about `pymunk` classes. There
    are more than 10 of them but we will only learn about the important ones. You
    can explore them by going to their official documentation pages. Let's learn about
    them one by one.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了“Vec2d”，我们将学习关于“pymunk”类。有超过10个类，但我们只会学习重要的类。您可以通过访问它们的官方文档页面来了解它们。让我们逐一学习。
- en: Exploring pymunk's built-in classes
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索pymunk的内置类
- en: To begin, we will start with the `Space` class. This class refers to the placeholders
    where all your game characters will reside. The movement of the game characters
    will also be defined within this space. The properties of rigid objects (with
    physical properties such as mass, friction, elasticity, and inertia) will change
    in this space as we begin to progress in the game. For example, an object in a
    different space will have different velocity and acceleration. In the case of
    the Angry Birds game, the velocity of an Angry Bird will differ from when the
    player initially slung it from the catapult to it then colliding with the structures
    in the game (beams and columns, which we will cover in a minute).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从“Space”类开始。这个类指的是所有游戏角色将驻留的占位符。游戏角色的移动也将在此空间中定义。随着游戏的进行，刚性物体的属性（具有质量、摩擦、弹性和惯性等物理属性）将在此空间中发生变化。例如，不同空间中的物体将具有不同的速度和加速度。在愤怒的小鸟游戏中，愤怒的小鸟的速度将与玩家最初从弹弓上射出它然后与游戏中的结构（横梁和柱子，我们将在一分钟内介绍）发生碰撞时不同。
- en: 'There are many methods defined inside the `pymunk` modules, so we will start
    with the most important one: `add_collision_handler(collision_type_a, collision_type_b)`.
    Recall from [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle
    – Snake Game UI with Pygame*, that you made a Snake game and added the collision
    handler by yourself, adding some logic that implies that *When the position of
    two objects is the same, they are said to have collided*. This method is a way
    of doing the same thing in an easier way, which is just by calling the `pymunk`
    built-in function. This collision handler that''s made by `pymunk` will take two
    arguments: `type_a` and `type_b`. You must remember that these two types are integers.
    We will use them to define two objects explicitly. For example, in the Angry Birds
    game, there will be three main characters: Bird, Wood, and Pig (to download the
    required assets, check the GitHub link mentioned in the *Technical requirements*
    section). Since we have three characters, we have to add a collision handler for
    each of them, like so:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`pymunk`模块中定义了许多方法，因此我们将从最重要的方法开始：`add_collision_handler(collision_type_a,
    collision_type_b)`。回想一下[第11章](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml)，*使用Pygame制作贪吃蛇游戏UI*，你制作了一个贪吃蛇游戏，并自己添加了碰撞处理程序，添加了一些逻辑，暗示*当两个对象的位置相同时，它们被认为发生了碰撞*。这种方法是以更简单的方式做同样的事情，只需调用`pymunk`内置函数。由`pymunk`创建的碰撞处理程序将接受两个参数：`type_a`和`type_b`。您必须记住这两种类型都是整数。我们将使用它们明确定义两个对象。例如，在愤怒的小鸟游戏中，将有三个主要角色：鸟、木头和猪（要下载所需的资源，请查看*技术要求*部分中提到的GitHub链接）。由于我们有三个角色，我们必须为每个角色添加碰撞处理程序，如下所示：'
- en: '**When Bird and Pig collide**: We will call `add_collision_handler(0, 1)`,
    where `0` indicates the integer type of the Bird character and 1 represents the
    integer type of the Pig game character.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当鸟和猪碰撞时**：我们将调用`add_collision_handler(0, 1)`，其中`0`表示鸟角色的整数类型，1表示猪游戏角色的整数类型。'
- en: '**When Bird and Wood collide**: We will call `add_collision_handler(0, 2)`,
    where `2` indicates the integer type of the Wood game character. (Remember that,
    throughout the game, 0 must represent the Bird character and must not be used
    for any other character).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当鸟和木头碰撞时**：我们将调用`add_collision_handler(0, 2)`，其中`2`表示木头游戏角色的整数类型。（请记住，在整个游戏过程中，0必须代表鸟角色，不能用于任何其他角色）。'
- en: '**When Pig and Wood collide**: We will call `add_collision_handler(1, 2)`.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当猪和木头碰撞时**：我们将调用`add_collision_handler(1, 2)`。'
- en: By doing this, we will get to feel the power of the collision handler defined
    inside the `Space` class. This function checks whether two objects collide and
    returns `CollisionHander` for collisions between objects represented by `type_a`
    and `type_b`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们将感受到`Space`类内定义的碰撞处理程序的强大。此函数检查两个对象是否发生碰撞，并返回`CollisionHander`，用于表示`type_a`和`type_b`之间的碰撞。
- en: 'Now that we have learned about handling collisions in pymunk, we will learn
    about two of the most important and most used classes of the `pymunk` module:
    `Body` and `Shape`. Firstly, we will start by learning about the pymunk `Body`
    class and its properties. Then, we will explore the pymunk `Shape` class, where
    we will learn how to add different physical properties such as elasticity, mass,
    and moment to geometrical figures.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何处理pymunk中的碰撞，我们将学习`pymunk`模块中最重要和最常用的两个类：`Body`和`Shape`。首先，我们将开始学习pymunk`Body`类及其属性。然后，我们将探索pymunk`Shape`类，学习如何向几何图形添加不同的物理属性，如弹性、质量和力矩。
- en: Exploring the pymunk Body class
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索pymunk Body类
- en: 'When making complex games such as Angry Birds, we have to define multiple game
    characters, such as the Bird, Pig, and Wood structures. The following illustration
    provides a visual of these game characters:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作像愤怒的小鸟这样的复杂游戏时，我们必须定义多个游戏角色，比如鸟、猪和木结构。以下插图提供了这些游戏角色的视觉效果：
- en: '![](Images/435e22c6-65cf-4688-aaf9-6dd2d3186c91.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/435e22c6-65cf-4688-aaf9-6dd2d3186c91.png)'
- en: 'All of these are images (in the sense of Pygame, they are sprites). They can''t
    be used directly until and unless we convert them into rigid bodies. The way that
    Pygame defines physical measurements (mass, motion, friction, and impulse) means
    that it will convert these sprites into rigid bodies. Here comes the power of
    the `Body` class: the `Body` class takes any shape (circular, polygon, sprites,
    and so on) and injects properties such as mass, moment, force, and many more,
    like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是图像（在Pygame的意义上，它们是精灵）。除非我们将它们转换为刚体，否则不能直接使用。Pygame定义物理测量（质量、运动、摩擦和冲量）的方式意味着它将这些精灵转换为刚体。这就是`Body`类的强大之处：`Body`类接受任何形状（圆形、多边形、精灵等）并注入质量、力矩、力和许多其他属性，如下所示：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The result of the preceding code is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的结果如下：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we started by defining `space`. As we mentioned previously,
    `Space` is a class that represents the placeholder for the objects. Take a close
    look at the `space.add(body, object)` statement: we have used the `add()` method
    to add the object to the `space`. Similarly, we made an instance of the `Body`
    class. The `Body` class does not necessarily mean the objects or game characters;
    rather, it is a virtual place where we can add game characters. The `object =
    pymunk.Circle(body, 4)` statement will create a circular object with a radius
    of `4` units and will add it to the scope of `Body`. After creating the circular
    objects, we added density (the intensive property of the object: mass per unit
    volume occupied by an object; please refer to the following link to learn more
    about density: [https://www.nuclear-power.net/nuclear-engineering/thermodynamics/thermodynamic-properties/what-is-density-physics/](https://www.nuclear-power.net/nuclear-engineering/thermodynamics/thermodynamic-properties/what-is-density-physics/)).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先定义了`space`。正如我们之前提到的，`Space`是一个代表物体的占位符的类。仔细看一下`space.add(body, object)`语句：我们使用`add()`方法将对象添加到`space`中。同样，我们创建了`Body`类的一个实例。`Body`类并不一定意味着物体或游戏角色；相反，它是一个虚拟的地方，我们可以在其中添加游戏角色。`object
    = pymunk.Circle(body, 4)`语句将创建一个半径为`4`单位的圆形物体，并将其添加到`Body`的范围内。创建圆形物体后，我们添加了密度（物体的强度属性：物体所占体积单位质量；请参考以下链接了解有关密度的更多信息：[https://www.nuclear-power.net/nuclear-engineering/thermodynamics/thermodynamic-properties/what-is-density-physics/](https://www.nuclear-power.net/nuclear-engineering/thermodynamics/thermodynamic-properties/what-is-density-physics/)）。
- en: 'After adding the `density` property to the objects, we printed the two bodies:
    the first one when the body was not added into the space and another circular
    body (along with `density`) added to the space. We printed both bodies. As expected,
    the first bodies were not into space and we didn''t define any properties for
    that body, and so its mass and moment were displayed as zero. Similarly, after
    the body was added to `space`, their mass and moment changed to 101 and 804 standard
    units, respectively.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`density`属性添加到对象后，我们打印了两个物体：第一个是当物体未添加到空间中时的情况，另一个是圆形物体（连同`density`）添加到空间中的情况。我们打印了两个物体。如预期的那样，第一个物体未添加到空间中，我们没有为该物体定义任何属性，因此其质量和力矩显示为零。同样，在物体添加到`space`后，它们的质量和力矩分别变为101和804标准单位。
- en: Now, let's learn about another important class of the `pymunk` module, which
    goes by the name of `Shape`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习另一个重要的`pymunk`模块类，名为`Shape`。
- en: Exploring the pymunk Shape class
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索pymunk Shape类
- en: 'There are three different class categories that come under the `Shape` class:
    `Circle`, `Poly`, and `Segment`. However, learning about the `Shape` class itself
    is enough for us to understand these categories. Let''s learn about a few important
    physical properties (all in lowercase) that we can call upon the shapes from the
    following points:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shape`类有三个不同的类别：`Circle`、`Poly`和`Segment`。然而，了解`Shape`类本身就足以让我们理解这些类别。让我们学习一下我们可以从以下几点调用形状的一些重要物理属性（全部小写）：'
- en: '`copy()`: Performs the deep copy of the current shape.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy()`：执行当前形状的深复制。'
- en: '`density`: The density of shapes. An extremely important property that calculates
    the mass and moment of inertia of a body from which shapes are attached. We looked
    at an example of this in the *Exploring* the *pymunk Body class* section.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`density`：形状的密度。这是一个非常重要的属性，用于计算附加形状的物体的质量和转动惯量。我们在*pymunk Body class*部分的示例中看到了这个属性。'
- en: '`elasticity`: Defines the elasticity of a shape. This property is used to define
    the bouncing nature of shapes. If the elasticity value is 0, that shape cannot
    bounce. For a perfect bounce, the value of elasticity should be 1.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elasticity`：定义形状的弹性。此属性用于定义形状的弹跳性质。如果弹性值为0，则该形状无法弹跳。对于完美的弹跳，弹性值应为1。'
- en: '`friction`: Defines the `friction` coefficient for a shape. A `friction` value
    of `0` defines a frictionless surface while `1` defines a perfectly fine (no rough)
    surface.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`friction`：定义形状的摩擦系数。`0`的`friction`值定义了无摩擦的表面，而`1`定义了完全光滑（无粗糙）的表面。'
- en: '`mass`: Defines the weight for a shape. When `mass` is higher, the object cannot
    bounce and move freely.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mass`：定义形状的重量。当`mass`较大时，物体无法弹跳和自由移动。'
- en: '`moment`: Calculates the moment for a shape.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`moment`：计算形状的力矩。'
- en: To observe the application of the preceding properties, we don't create instances
    of the `Shape` class. Instead, we use the `Circle`, `Poly` and `Segment` classes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了观察上述属性的应用，我们不创建`Shape`类的实例。相反，我们使用`Circle`、`Poly`和`Segment`类。
- en: 'The `Circle` class (which we used in the previous section) can be instantiated
    like so:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Circle`类（我们在上一节中使用过）可以这样实例化：'
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Properties such as density, elasticity, friction, mass, and moment can be also
    defined in the case of circular objects. We will see an example of this while
    making the Angry Birds game.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在圆形物体的情况下，也可以定义密度、弹性、摩擦、质量和力矩等属性。我们将在制作愤怒的小鸟游戏时看到这方面的例子。
- en: 'Similarly, we can create a polygon shape using the `Poly` class. The following
    syntax represents the creation of instances using the `Poly` class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`Poly`类创建多边形形状。以下语法表示使用`Poly`类创建实例：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding line of code, `body` is the instance of the `Body` class which
    represents the virtual space for the shape. The `vertices` argument defines the
    vertices for the convex hull of the polygon. A convex hull is calculated by the `Poly`
    class using vertices automatically. The remaining two arguments, *transform* and
    *radius*, are optional. `transform` is an object of the `Transform` class (refer
    to [http://www.pymunk.org/en/latest/pymunk.html#pymunk.Poly](http://www.pymunk.org/en/latest/pymunk.html#pymunk.Poly)
    to find out more about `transform`), which applies the transform to each vertex
    of the polygon, while the `radius` argument sets the radius of the created poly
    shape.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，`body`是`Body`类的实例，代表形状的虚拟空间。`vertices`参数定义了多边形凸包的顶点。凸包是由`Poly`类使用顶点自动计算的。剩下的两个参数，*transform*和*radius*是可选的。`transform`是`Transform`类的对象（参考[http://www.pymunk.org/en/latest/pymunk.html#pymunk.Poly](http://www.pymunk.org/en/latest/pymunk.html#pymunk.Poly)了解更多关于`transform`的信息），它将变换应用到多边形的每个顶点，而`radius`参数设置了创建的多边形形状的半径。
- en: You may be wondering what the application of the `Poly` class will be while
    making the Angry Birds game. In this game, we have two main characters, as well
    as the wood structures, consisting of beam and column, which are made using the `Poly`
    class. More on this will be discussed when we start making the Angry Birds game.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道在制作愤怒的小鸟游戏时`Poly`类的应用是什么。在这个游戏中，我们有两个主要角色，以及由`Poly`类制作的木结构，包括梁和柱。在制作愤怒的小鸟游戏时会进一步讨论这些内容。
- en: 'Finally, we have another useful class, known as the `Segment` class. Let''s
    explore how its instance is created:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有另一个有用的类，称为`Segment`类。让我们来探讨如何创建它的实例：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As its name suggests, the `Segment` class is responsible for defining a line
    segment shape between two points: `point1` and `point2`. It is an important class
    since it defines the surface for the game. The `radius` argument defines the thickness
    of the line segment drawn from `point1` to `point2`. Several aforementioned properties,
    such as `mass`, `density`, `elasticity`, and `friction` can also be added to this
    shape. Mostly, friction is used to define the roughness of the surface while creating
    the surface of the game. Even in the Angry Birds game, we can create a game surface
    using the `Segment` class and associate the body with some level of friction (0—1),
    which defines the level of fineness and roughness of the surface. The value of
    0 represents 100 percent fine, while 1 represents totally rough.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Segment`类负责定义两点之间的线段形状：`point1`和`point2`。这是一个重要的类，因为它定义了游戏的表面。`radius`参数定义了从`point1`到`point2`绘制的线段的厚度。还可以为这个形状添加一些前面提到的属性，比如`mass`、`density`、`elasticity`和`friction`。大多数情况下，摩擦用于定义游戏表面的粗糙程度。即使在愤怒的小鸟游戏中，我们也可以使用`Segment`类创建游戏表面，并将物体与一定程度的摩擦（0—1）关联起来，这定义了表面的精细度和粗糙度水平。数值0代表100%的精细，而1代表完全粗糙。'
- en: Now that we are fully equipped with all the classes and properties associated
    with the `pymunk` module, we can start coding our Angry Birds game.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经全面掌握了与`pymunk`模块相关的所有类和属性，我们可以开始编写愤怒的小鸟游戏了。
- en: Creating a character controller
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个角色控制器
- en: If you haven't played Angry Birds yet, I highly encourage you to do so. Search
    for Angry Birds online and play it for a few minutes. While playing the game,
    observe the main characters (bird and pig), their actions, and their interaction
    with wooden structures. The wooden structures are made of different beam and column
    structures where a different number of wooden structures are dovetailed, one after
    the other.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有玩过愤怒的小鸟，我强烈鼓励你去试一试。在网上搜索愤怒的小鸟并玩上几分钟。在玩游戏时，观察主要角色（小鸟和猪）、它们的动作以及它们与木结构的互动。木结构由不同的梁和柱结构组成，其中不同数量的木结构依次嵌套。
- en: After you've taken a look at the original game, you can start coding your own
    Angry Birds game. We made the Angry Bird project previously, in PyCharm, while
    installing the `pymunk` module. We will use the same project folder to create
    this game. Create a new Python file and name it `characters.py`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看原始游戏后，你可以开始编写自己的愤怒的小鸟游戏。我们之前在PyCharm中安装`pymunk`模块时制作了愤怒的小鸟项目。我们将使用相同的项目文件夹来创建这个游戏。创建一个新的Python文件并命名为`characters.py`。
- en: In this Angry Bird project, we are not going to write whole pieces of code within
    a single file. While coding complex games such as Angry Birds, it is important
    for us to create different modules for different tasks. Doing so, we can easily
    find bugs while testing our game. In this Angry Birds game, we will create four
    Python files: `characters.py`, `polygon.py`, `main.py`, and `level.py`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个愤怒的小鸟项目中，我们不会在一个单独的文件中编写整个代码。在编写像愤怒的小鸟这样复杂的游戏时，对于不同的任务，我们创建不同的模块是很重要的。这样做，我们可以在测试游戏时更容易地找到错误。在这个愤怒的小鸟游戏中，我们将创建四个Python文件：`characters.py`、`polygon.py`、`main.py`和`level.py`。
- en: 'The first file, which we just created, will contain the main game characters:
    Bird and Pig. The wooden beam and column structures will be created in the next
    file; that is, `polygon.py`. But for now, let''s concentrate on the `characters.py`
    file.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的第一个文件将包含主要的游戏角色：小鸟和猪。木梁和柱结构将在下一个文件中创建；也就是`polygon.py`。但现在，让我们集中在`characters.py`文件上。
- en: 'The `characters.py` file will contain two classes: one for `Bird` and another
    for `Pig`. Then, we will define several attributes that govern the movement, that
    is, the physical property, for each of these classes. The following code represents
    the content of the `characters.py` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`characters.py`文件将包含两个类：一个是`Bird`，另一个是`Pig`。然后，我们将定义几个属性来控制每个类的运动，也就是物理属性。以下代码表示了`characters.py`文件的内容：'
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After importing the necessary modules, let''s define the class for the `Bird`
    character (Angry Bird movement is handled by the player who is playing the game):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入必要的模块之后，让我们为`Bird`角色定义一个类（愤怒的小鸟的移动由玩游戏的玩家控制）：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding line of code, we defined all the physical and positional attributes
    for the Angry Birds character. We start by defining the constructor. The arguments
    for the constructor are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码行中，我们为愤怒的小鸟角色定义了所有的物理和位置属性。我们首先定义构造函数。构造函数的参数如下：
- en: '`distance` between the two body positions, usually calculated by the distance
    formula ([https://www.purplemath.com/modules/distform.htm](https://www.purplemath.com/modules/distform.htm))
    and passed to the `Bird` class.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个物体位置之间的`distance`，通常通过距离公式计算（[https://www.purplemath.com/modules/distform.htm](https://www.purplemath.com/modules/distform.htm)），并传递给`Bird`类。
- en: '`angle` in degrees to perform the movement of the `Bird` character.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`angle`以度为单位执行`Bird`角色的移动。'
- en: '**`x_pos`**, **`y_pos`** represents the position of `Bird`.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`x_pos`**，**`y_pos`**表示`Bird`的位置。'
- en: '`space` represents the `space` object where `Bird` is rendered.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`space`表示`Bird`被渲染的`space`对象。'
- en: Inside the constructor, we have added multiple physical attributes to the `Bird`
    character. For example, `elasticity= 0.95` represents the bouncing capability
    (standard), `friction = 1` (level of roughness of surface), power = work done
    (distance) * time (53). The mass (weight) of the Bird is 20, and the `birdLife` class
    attribute represents the quantity that reduces whenever the Bird character collides
    with the ground or other characters (Pig or the wooden structures).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们为`Bird`角色添加了多个物理属性。例如，`elasticity= 0.95`表示弹跳能力（标准），`friction = 1`（表面粗糙度水平），power
    = work done（距离）* time（53）。小鸟的质量（重量）为20，`birdLife`类属性表示每当Bird角色与地面或其他角色（Pig或木结构）发生碰撞时减少的数量。
- en: The values of friction, elasticity, and work done are not random (I didn't use
    them arbitrarily). They are defined on the official documentation page. Refer
    to the following URL to explore the chart: [http://www.pymunk.org/en/latest/pymunk.html#pymunk.Shape](http://www.pymunk.org/en/latest/pymunk.html#pymunk.Shape).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 摩擦、弹性和功都不是随机的（我没有随意使用它们）。它们在官方文档页面上有定义。请参考以下网址查看图表：[http://www.pymunk.org/en/latest/pymunk.html#pymunk.Shape](http://www.pymunk.org/en/latest/pymunk.html#pymunk.Shape)。
- en: The two important methods of the `Bird` class (highlighted in the preceding
    code) are the built-in functions defined by the `pymunk` module. The first method,
    `moment_for_circle()`, calculates the moment of inertia (the resistance of any
    physical object to any change in its velocity) for the hollow circle. The argument
    that's passed to the function is the *mass* of the object; that is, the *inner
    radius* and the *outer radius*. Observe the inner radius, which is passed as `0`,
    which means the Angry Bird (the main character of the game is a circular solid
    circle). If the inner radius is `0`, it means this is a solid circular object.
    The outer radius defines the circular dimension of the Angry Bird. Similarly,
    observe the `collision_type = 0` attribute. This statement will add the integer
    type to the Bird game character. When checking collisions between two objects
    with `add_collision_handler(type_a, type_b)`, we use this collision type value
    to indicate that the `0` value for the character is `Bird`. For the `Bird` character,
    we have a collision type equal to `0`. The `Pig` class will have its collision
    type defined as `1`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bird`类的两个重要方法（在上述代码中突出显示）是由`pymunk`模块定义的内置函数。第一个方法`moment_for_circle()`计算空心圆的转动惯量（任何物体对其速度变化的抵抗）。传递给函数的参数是物体的*质量*，即*内半径*和*外半径*。观察传递为`0`的内半径，这意味着愤怒的小鸟（游戏的主要角色）是一个实心圆。如果内半径是`0`，这意味着这是一个实心圆形物体。外半径定义了愤怒的小鸟的圆形尺寸。同样，观察`collision_type
    = 0`属性。这个语句将为Bird游戏角色添加整数类型。在使用`add_collision_handler(type_a, type_b)`检查两个对象之间的碰撞时，我们使用这个碰撞类型值来表示角色的`0`值是`Bird`。对于`Bird`角色，我们的碰撞类型等于`0`。`Pig`类将其碰撞类型定义为`1`。'
- en: Similarly, the next method, `apply_impulse_at_local_point(impulse, point = (0,
    0))`, will apply a local impulse to the body. This, in turn, will represent how
    much the momentum of the angry bird will change when force is provided. Refer
    to [https://study.com/academy/lesson/impulse-definition-equation-calculation-examples.html](https://study.com/academy/lesson/impulse-definition-equation-calculation-examples.html)
    to learn more about impulse and momentum.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，下一个方法`apply_impulse_at_local_point(impulse, point = (0, 0))`将对物体施加局部冲量。这将表示当施加力时愤怒的小鸟的动量将发生多大变化。参考[https://study.com/academy/lesson/impulse-definition-equation-calculation-examples.html](https://study.com/academy/lesson/impulse-definition-equation-calculation-examples.html)了解更多关于冲量和动量的知识。
- en: 'Next, we need to define the class for the `Pig` character. The following code
    should be written just after the `Bird` class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为`Pig`角色定义类。以下代码应该在`Bird`类之后编写：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code is similar to the `Bird` class. Like before, we defined the
    same level of elasticity and friction as the `Pig` character. We added the inertia
    and mass effects to the object. For the `Pig` character, the `collision_type`
    is added as `1`, which means that while checking the collision between Pig and
    Bird, we can simply call `add_collision_handler(0, 1)`, where `0` represents Bird
    and `1` represents Pig.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与`Bird`类类似。与之前一样，我们为`Pig`角色定义了相同级别的弹性和摩擦。我们为对象添加了惯性和质量效应。对于`Pig`角色，`collision_type`被添加为`1`，这意味着在检查Pig和Bird之间的碰撞时，我们可以简单地调用`add_collision_handler(0,
    1)`，其中`0`表示Bird，`1`表示Pig。
- en: Now that we have created two main classes for the Angry Birds game, that is, `RoundBird`
    and `RoundPig`, inside the `characters.py` file, we will create another game character,
    that is, the wooden structures (beams and columns).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为愤怒的小鸟游戏创建了两个主要的类，即`RoundBird`和`RoundPig`，在`characters.py`文件中，我们将创建另一个游戏角色，即木结构（横梁和柱子）。
- en: Creating the Polygon class
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多边形类
- en: For each of the game entities, we have created separate classes, that is, Bird
    and Pig. Since our final game entity is a wooden structure (that the player shoots
    at with the slingshot), we will make a different Python file and create a class
    for this entity. But before that, let's go through one of the important concepts
    regarding sprite sheets.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个游戏实体，我们都创建了单独的类，即Bird和Pig。由于我们最终的游戏实体是木结构（玩家用弹弓射击的目标），我们将创建一个不同的Python文件，并为该实体创建一个类。但在此之前，让我们先了解有关精灵表的一个重要概念。
- en: 'Images that are used in Python game development are usually called sprites,
    and they are the static images on which some manipulation (vectored movement)
    is done based on the user''s actions (such as moving the snake when clicking the
    arrow keys on the keyboard). In the preceding chapters ([Chapter 12](6eb72797-e976-49b0-878f-4db620a59aca.xhtml), *Learning
    About Character Animation, Collision, and Movement*, and [Chapter 13](fd4aec28-0e3c-4ba1-924a-56b9d53edd5a.xhtml),
    *Coding the Tetris Game with Pygame*), we used sprites (single images), but not
    sprite sheets (sheets containing multiple static images). The following is an
    example of a sprite sheet, and is specific to our Angry Birds game:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python游戏开发中使用的图像通常称为精灵，它们是静态图像，基于用户的操作（例如在键盘上点击箭头键时移动蛇）进行一些操作（矢量移动）。在前几章中（[第12章](6eb72797-e976-49b0-878f-4db620a59aca.xhtml)，*了解角色动画、碰撞和移动*，和[第13章](fd4aec28-0e3c-4ba1-924a-56b9d53edd5a.xhtml)，*使用Pygame编写俄罗斯方块游戏*），我们使用了精灵（单个图像），但没有使用精灵表（包含多个静态图像的表）。以下是一个精灵表的示例，特定于我们的愤怒的小鸟游戏：
- en: '![](Images/8fc3993a-cdcb-416e-8e57-0c281a714bcb.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8fc3993a-cdcb-416e-8e57-0c281a714bcb.png)'
- en: 'These image files generally don''t contain a single image of a game character.
    As you can see, they usually contain a large number of distinct game characters.
    But most of the time, we will only require a single image from the entire sprite
    sheet. Thus, the question is, how can we extract a single image from such sprite
    sheets? We do so using the `Rect` class of the `Pygame` module. Do you remember
    the `Rect` class ([Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo
    Turtle – Snake Game UI with Pygame*) from the Pygame module? This class creates
    a rectangular object based on the left, top, width, and height dimensions. To
    extract an image from the aforementioned sprite sheet, we will draw a rectangle
    around one of the sprites, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图像文件通常不包含游戏角色的单个图像。正如您所看到的，它们通常包含大量不同的游戏角色。但大多数情况下，我们只需要整个精灵表中的单个图像。因此，问题是，我们如何从这样的精灵表中提取单个图像？我们使用`Pygame`模块的`Rect`类来实现。您还记得Pygame模块中的`Rect`类（[第11章](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml)，*使用Pygame创建Outdo
    Turtle-蛇游戏UI*）吗？该类基于左、上、宽度和高度维度创建一个矩形对象。为了从上述精灵表中提取图像，我们将在其中一个精灵周围绘制一个矩形，如下所示：
- en: '![](Images/b14363a3-3d91-4b5b-8802-46f4df5f996e.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b14363a3-3d91-4b5b-8802-46f4df5f996e.png)'
- en: This mapping is done with the help of the `Rect` class. The `Rect` class will
    create a rectangle with the dimensions of four points on the screen (left, top,
    width, and height). In this way, by altering any four dimensions of the `Rect` object,
    we can extract the part or sub-surface of sprite sheets.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种映射是通过`Rect`类的帮助完成的。`Rect`类将创建一个具有四个屏幕点（左、上、宽度和高度）尺寸的矩形。通过更改`Rect`对象的任何四个维度，我们可以提取精灵表的部分或子表面。
- en: 'Now, let''s see this in action by creating a wooden structure. To begin, download
    the sprite assets from the following GitHub link: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15/res](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15/res).
    You will see various images, along with code assets. There will be two folders
    inside the `res` folder: one for photos and another for sound. You have to copy
    the entire folder and paste it into the Angry Bird project folder in the PyCharm
    editor.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过创建一个木结构来看看它的作用。首先，从以下GitHub链接下载精灵资源：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15/res](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15/res)。您将看到各种图像，以及代码资源。`res`文件夹内将有两个文件夹：一个用于照片，另一个用于声音。您必须复制整个文件夹并将其粘贴到PyCharm编辑器中愤怒的小鸟项目文件夹中。
- en: After you've imported the resources, I suggest that you open the `wood.png` file.
    This file contains different wooden structures. When creating a polygon out of
    these wooden structures, we have to crop one of the images using the `Rect` class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 导入资源后，我建议您打开`wood.png`文件。该文件包含不同的木结构。在创建多边形时，我们必须使用`Rect`类裁剪其中一个图像。
- en: 'In the same Angry Bird project, create another Python file with the name `polygon.py`.
    We will start by importing the necessary modules:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个愤怒的小鸟项目中，创建另一个名为`polygon.py`的Python文件。我们将从导入必要的模块开始：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s create the `Polygon` class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建`Polygon`类：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The attributes we''ve defined for the `Polygon` class are quite similar to
    what we did for the `Bird` and `Pig` classes: we initialized friction and added
    the `collision_type` so as to reference the Polygon shape with an integer of `2`.
    The constructor takes an argument, that is, `po*s*ition`, to tell us about the
    position of the polygon to render, the `length` and `height` of the polygon, the `space`
    object where the polygon will be rendered, and the `mass` for the polygon shape.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`Polygon`类定义的属性与我们为`Bird`和`Pig`类所做的非常相似：我们初始化了摩擦力，并添加了`collision_type`，以便用整数`2`引用多边形形状。构造函数接受一个参数，即`position`，告诉我们要渲染的多边形的位置，多边形的长度和高度，将渲染多边形的`space`对象，以及多边形形状的`mass`。
- en: The only novel thing in the preceding code is the highlighted part of the code.
    We have loaded the `wood.png` and `wood2.png` images into the Python project using
    Pygame's `load` method. The `convert_alpha()` method acts as an optimizer and
    will create a new image surface that is suitable for quick blitting. The `Rect`
    class takes four dimensions to create a rectangular surface (refer to [Chapter
    11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake Game UI
    with Pygame*). The dimensional values that are provided aren't given randomly
    and represent the values that cover the subsurface of the sprite sheets that we
    need to extract. For example, the `self.beam_image = wood.subsurface(rect).copy()` command
    will extract the horizontal beam image (the piece of wood enclosed by a red rectangle)
    from the `wood.png` file, as follows;
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中唯一的新颖之处是代码的高亮部分。我们使用Pygame的`load`方法将`wood.png`和`wood2.png`图像加载到Python项目中。`convert_alpha()`方法充当优化器，并将创建一个适合快速blitting的新图像表面。`Rect`类需要四个维度来创建一个矩形表面（参见[第11章](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml)，*使用Pygame制作贪吃蛇游戏UI*）。提供的尺寸值并非随机给出，而是代表我们需要提取的精灵表面的子表面的值。例如，`self.beam_image
    = wood.subsurface(rect).copy()`命令将从`wood.png`文件中提取水平横梁图像（由红色矩形包围的木块），如下所示；
- en: '![](Images/d6bcbc7a-2df6-4a23-a251-a9414936d9de.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d6bcbc7a-2df6-4a23-a251-a9414936d9de.png)'
- en: 'Now that we have extracted horizontal and vertical wooden images (a beam and
    a column, respectively), we can start drawing a polygon containing them. However,
    there''s a problem. Since, although we have been using Pygame and `pymunk` together,
    their coordinate systems are not alike: `pymunk` uses a coordinate system with
    the origin at the bottom left, while Pygame, as you probably already know, uses
    a coordinate system with the origin at the upper left. Thus, we will make a function
    that will convert the `pymunk` coordinate system into a compatible Pygame coordinate
    system:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经提取了水平和垂直的木质图像（横梁和柱子），我们可以开始绘制包含它们的多边形。然而，出现了一个问题。尽管我们一直在使用Pygame和`pymunk`，但它们的坐标系统并不相同：`pymunk`使用的坐标系统的原点在左下角，而Pygame则使用的坐标系统的原点在左上角。因此，我们将编写一个函数，将`pymunk`坐标系统转换为兼容的Pygame坐标系统：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding function is important because the game surface will be made out
    of the `Pygame` module. Thus, we must track the position where the beam and column
    must be rendered. Now, let''s start drawing the `polygon` into the surface:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数很重要，因为游戏表面将由`Pygame`模块制作。因此，我们必须跟踪横梁和柱子必须呈现的位置。现在，让我们开始在表面上绘制`polygon`：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding function will be used to place a beam on the screen in which
    an object is passed as an argument to it. The first argument to the function is
    *element*, which tells the function which polygon to draw: is it a beam or a column?
    We will add some logic to the draw column in the following code, but for now,
    let''s observe what we have written so far. The code starts by getting the *shape*
    object. Then, we check whether the element is `beam`. If it is `beam`, then we
    get the position of the image and convert it into the `Vec2d` coordinate position.
    The highlighted part of the code (getting the angle to rotate the beam image)
    will ensure that the image of the beam is within the red rectangular (virtual)
    area, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数将用于在屏幕上放置一个横梁，其中一个对象作为参数传递给它。函数的第一个参数是*element*，告诉函数要绘制哪个多边形：是横梁还是柱子？我们将在下面的代码中添加一些逻辑来绘制柱子，但现在让我们观察到目前为止我们已经写的内容。代码首先获取*shape*对象。然后，我们检查元素是否为`beam`。如果是`beam`，那么我们获取图像的位置并将其转换为`Vec2d`坐标位置。代码的高亮部分（获取旋转横梁图像的角度）将确保横梁图像在红色矩形（虚拟）区域内，如下所示：
- en: '![](Images/26e3cbaf-cfb1-4870-bf97-c7e89d53e932.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/26e3cbaf-cfb1-4870-bf97-c7e89d53e932.png)'
- en: 'Just remove that highlighted line from the preceding code and observe the result.
    You will see that the beam won''t be perfectly aligned because of the offset of
    the `Vec2d` coordinate system. Similarly, let''s add some code so that we can
    draw the column to the screen:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 只需从上述代码中删除高亮行并观察结果。您会发现由于`Vec2d`坐标系统的偏移，横梁不会完全对齐。同样，让我们添加一些代码，以便我们可以将柱子绘制到屏幕上：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding code, the first couple of lines will convert the `pymunk`
    coordinates into Pygame. Since column should be rendered in the Pygame surface,
    this conversion is necessary. Similarly, after getting the position coordinates,
    we take an angle of coordinate and make sure to add 180 or 0 to it so that it
    remains an original image with no rotation. After getting that image, we transform
    it and create a new image as a `rotated_column` image. Remember that if the rotating
    angle is not a multiple of 90, the image will be distorted. In the preceding line
    of code, if `offset` is not removed from the rotated image, the image will move
    down the surface, as shown in the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，前几行将`pymunk`坐标转换为Pygame坐标。由于柱子应该在Pygame表面上呈现，因此这种转换是必要的。同样，在获取位置坐标之后，我们取一个坐标角度，并确保向其添加180或0，以使其保持原始图像而不旋转。获取图像后，我们对其进行变换，并创建一个新图像作为`rotated_column`图像。请记住，如果旋转角度不是90的倍数，图像将会变形。在上一行代码中，如果不从旋转图像中移除`offset`，则图像将向下移动表面，如下面的截图所示：
- en: '![](Images/57833fcb-c2b1-4370-a67a-c2dcda32c369.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/57833fcb-c2b1-4370-a67a-c2dcda32c369.png)'
- en: In the preceding screenshot, the red line represents the surface. Thus, if you
    do not remove the offset from the column's body position, the column will be displayed
    below the surface.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，红线代表表面。因此，如果不从柱子的体位置中移除偏移量，柱子将显示在表面下方。
- en: Now that we have finished the `Polygon` class, which will render either a beam
    or a column whenever the `draw_poly()` function is called from the main class,
    it's time to make our main class, which is the director of all the classes. This
    class will be responsible for creating instances of all the classes and for calling
    the methods that are defined inside different classes to render game objects into
    the Pygame game surface.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`Polygon`类，该类在从主类中调用`draw_poly()`函数时将渲染横梁或柱子，现在是时候制作我们的主类了，这是所有类的指导者。这个类将负责创建所有类的实例，并调用不同类中定义的方法来将游戏对象渲染到Pygame游戏表面中。
- en: Exploring Pythonic physics simulation
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Python的物理模拟
- en: 'To begin, let''s start by revising what we have done so far. We started by
    defining two main game entities: `Bird` and `Pig`. All of the major physics properties,
    such as mass, inertia, and friction, were defined for each of these characters
    so as to simulate real-world physics. After creating the two major game characters,
    we made another Python file so that we could create the `Polygon` class. This
    class was created to render the wooden structures in the game with the help of
    beam and column. Now, we are going to create another Python file with the name
    `main.py`. This will be the main controller of the game.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从回顾我们迄今为止所做的工作开始。我们首先定义了两个主要的游戏实体：`Bird`和`Pig`。为了模拟真实世界的物理现象，为这些角色定义了所有主要的物理属性，如质量、惯性和摩擦力。在创建了这两个主要的游戏角色之后，我们又创建了另一个Python文件，以便我们可以创建`Polygon`类。这个类是为了在游戏中渲染木结构，借助横梁和柱子。现在，我们将创建另一个名为`main.py`的Python文件。这将是游戏的主控制器。
- en: 'Use the following code to declare the base physics in the `main.py` file. We
    will start by importing some essential modules:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码在`main.py`文件中声明基本物理。我们将从导入一些必要的模块开始：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After importing the necessary modules, we need to crop some subsurfaces from
    the sprites that we added previously. Obviously, we don''t want everything from
    the sprite sheets, and so we will be extracting only parts of them to create game
    characters. However, since our main character, our Angry Bird, only has a single
    image and is not present in the sprite sheets, we don''t need to crop the image
    for the Angry Bird and the slingshot. However, for the `Pig` character, we have
    to create a `Rect` object because the `Pig` images are bundled together in a sprite
    sheet. Thus, we will have to load the images by using the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入了必要的模块之后，我们需要从之前添加的精灵中裁剪一些子表面。显然，我们不希望从精灵表中获取所有内容，因此我们将只提取其中的部分内容来创建游戏角色。然而，由于我们的主要角色，愤怒的小鸟，只有一个图像，并且不在精灵表中，我们不需要为愤怒的小鸟和弹弓裁剪图像。然而，对于`Pig`角色，我们必须创建一个`Rect`对象，因为`Pig`图像在精灵表中是捆绑在一起的。因此，我们将使用以下代码加载图像：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we started by defining a game screen using the Pygame
    module. After that, we loaded all the images that exist as a single image but
    not the sprite sheets, such as `red-bird3.png`, `background3.png` and `sling-3.png`.
    As we mentioned previously, the image of the pig is part of a bundle of images
    in `full-sprite.png`. Since we need only one image of the pig, we will perform
    a similar process the one we carried out while extracting beam and column. We
    will create a `Rect` object with the exact dimensions of the pig's shape and then
    use it to extract a pig image from the sprite sheets. Then, we will crop that
    image and store it as a cropped object, which will eventually be transformed so
    that is has a height and width of `30`, `30`, respectively.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先使用Pygame模块定义了一个游戏屏幕。之后，我们加载了所有存在的单个图像的图像，而不是精灵表，比如`red-bird3.png`、`background3.png`和`sling-3.png`。正如我们之前提到的，猪的图像是`full-sprite.png`中一组图像的一部分。由于我们只需要一张猪的图像，我们将执行类似于提取横梁和柱子时进行的过程。我们将创建一个具有猪形状确切尺寸的`Rect`对象，然后使用它从精灵表中提取猪的图像。然后，我们将裁剪该图像并将其存储为一个裁剪对象，最终将其转换为高度和宽度分别为`30`、`30`的对象。
- en: 'Now that we have extracted the necessary images for the game objects, let''s
    get down to business by declaring the physical variables and positional variables
    for each of these objects:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经提取了游戏对象所需的图像，让我们开始通过声明每个对象的物理变量和位置变量来认真对待这项工作：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As we know, the Angry Birds game is played by using a mouse to stretch the
    catapult in a slinging motion. Thus, we have to declare some variables that will
    take care of these sling actions:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，愤怒的小鸟游戏是通过使用鼠标拉伸弹弓进行弹射动作来进行的。因此，我们必须声明一些变量来处理这些弹弓动作：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding code, we have defined different variables so that we can track
    the position of the mouse before and after the sling action. The `sling_action()`
    function, which we will declare afterward, will manipulate these values. For now,
    let''s create a list that will track the number of pigs, birds, beams, and columns
    that are displayed in the space:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已经定义了不同的变量，以便在弹弓动作之前和之后跟踪鼠标的位置。我们将在之后声明`sling_action()`函数，该函数将操作这些值。现在，让我们创建一个列表，用于跟踪在空间中显示的猪、鸟、横梁和柱子的数量：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have defined all the necessary variables for the Angry Birds game
    (we will add more variables later if needed), it''s time to create a surface for
    the screen. This surface is not a background surface; instead, it''s some ground
    in which all the structures will reside. The Angry Bird will also bounce off this
    surface, and so we have to add some physical properties to this ground, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为愤怒的小鸟游戏定义了所有必要的变量（如果需要，我们将稍后添加更多变量），现在是时候为屏幕创建一个表面了。这个表面不是一个背景表面；相反，它是所有结构所在的一些地面。愤怒的小鸟也会从这个表面上弹起，因此我们必须为这个地面添加一些物理属性，如下所示：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding line of code will create some static ground. While instantiating
    the static body, we can explicitly set `body-type` as `STATIC` by adding the `pymunk.Body.STATIC` constant.
    After defining the static body, we have to use the `Segment` class to create a
    line segment between one point and another (recall the `Segment` class from the *Exploring
    the pymunk Space class* section). For each line segment, we have added `elasticity` to
    support the bouncing property, `friction` to indicate the roughness, and `collision_type`
    to check whether other game objects have collided with the ground surface or not,
    which will be checked later, in the *Checking collision* section. After creating
    these static surfaces, we will add them to the `Space` object, which will render
    them onto the screen.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码行将创建一些静态地面。在实例化静态物体时，我们可以通过添加`pymunk.Body.STATIC`常量来明确设置`body-type`为`STATIC`。在定义静态物体之后，我们必须使用`Segment`类来创建一条线段，连接一个点和另一个点（回想一下*探索pymunk
    Space类*部分中的`Segment`类）。对于每个线段，我们已经添加了`elasticity`来支持弹跳属性，`friction`来表示粗糙度，以及`collision_type`来检查其他游戏对象是否与地面表面发生碰撞，这将在*检查碰撞*部分中稍后进行检查。在创建这些静态表面之后，我们将它们添加到`Space`对象中，这将把它们渲染到屏幕上。
- en: After defining the static surface, we need to define the sling action, that
    is, what happens when the player stretches the rope of the catapult. We will implement
    this in the next section.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义静态表面之后，我们需要定义弹弓动作，即玩家在拉动弹弓绳索时会发生什么。我们将在下一节中实现这一点。
- en: Implementing the sling action
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施弹弓动作
- en: 'In this section, we are going to implement the sling action. The player is
    going to interact with the game character through the sling action. But before
    implementing the sling action, we have to take care of a few things: how far can
    the player stretch the rope of the catapult? What is the angle of impulse (the
    track of motion after the player releases the rope)? What is the distance between
    the mouse action point and the rope''s current stretch point? All of these things
    must be addressed by declaring functions. First of all, we need to convert pymunk
    coordinates into Pygame coordinates so that we can align the game objects with
    the screen properly (the reason for this conversion was discussed in the *Creating
    the Polygon class* section).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将实施弹弓动作。玩家将通过弹弓动作与游戏角色进行交互。但在实施弹弓动作之前，我们必须注意一些事情：玩家可以拉动弹弓绳索多远？冲量的角度是多少（玩家释放绳索后的运动轨迹）？鼠标动作点与绳索当前伸展点之间的距离是多少？所有这些问题都必须通过声明函数来解决。首先，我们需要将pymunk坐标转换为Pygame坐标，以便我们可以正确地将游戏对象与屏幕对齐（这种转换的原因在*创建多边形类*部分中讨论过）。
- en: 'The following function will convert the `pymunk` coordinates to Pygame coordinates:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数将把`pymunk`坐标转换为Pygame坐标：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Although pymunk''s *x*-coordinates are the same as Pygame''s *x*-coordinates,
    due to pymunk''s origin being at the bottom left, we have to change it to the
    upper left. Similarly, let''s define another function, that is, `vector`, which
    will convert the passed point into a vector. The following code represents the
    implementation of the `vector` function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管pymunk的*x*坐标与Pygame的*x*坐标相同，但由于pymunk的原点在左下角，我们必须将其更改为左上角。同样，让我们定义另一个函数，即`vector`，它将把传递的点转换为向量。以下代码表示`vector`函数的实现：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Refer to [Chapter 9](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml), *Data Model
    Implementation*, to find out more about how vectors are created using positional
    vectors. Here, the arguments *a* and *b* represent the points that are converted
    into vectors from the reference point. Now that we have created a vector, let''s
    define a function that will return the distance between two points:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[第9章](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml)，*数据模型实现*，了解更多关于如何使用位置向量创建向量的信息。这里，参数*a*和*b*表示从参考点转换为向量的点。现在我们已经创建了一个向量，让我们定义一个函数，它将返回两点之间的距离：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code will calculate the distance formula between two points, that
    is, `(x0, y0)` and `(x1, y1)`, using the `sqrt((x1 - x0) + (y0 - yo))` distance
    formula, where `sqrt` represents `square root (math.sqrt(4) = 2)`. The ** operator
    represents the power. For example, `dx ** 2` is equivalent to `(dx)²`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将计算两点之间的距离公式，即`(x0, y0)`和`(x1, y1)`，使用`sqrt((x1 - x0) + (y0 - yo))`距离公式，其中`sqrt`代表`平方根
    (math.sqrt(4) = 2)`。**运算符代表幂。例如，`dx ** 2`等同于`(dx)²`。
- en: 'Now that we''ve calculated the distance, we need to learn how to calculate
    unit vectors. A unit vector is a vector that has a magnitude of 1\. We don''t
    really care about the magnitude, but the significance of a unit vector is that
    it tells us about the direction of the vector. Once we have a unit vector, we
    can amplify it by any factor to achieve the new vector in that particular direction.
    While creating the sling action, having knowledge about the unit vector is important
    as this will give us information about the direction the catapult is stretched
    in. To find the unit vector in the same direction as a vector, we have to divide
    it by its magnitude. Using mathematical deduction, let''s build a function and
    create a unit vector:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经计算出距离，我们需要学习如何计算单位向量。单位向量是具有大小为1的向量。我们并不真正关心大小，但单位向量的重要性在于它告诉我们向量的方向。一旦我们有了单位向量，我们就可以通过任何因子放大它，以获得特定方向的新向量。在创建弹弓动作时，了解单位向量的重要性很重要，因为这将为我们提供有关弹弓伸展方向的信息。要找到与向量相同方向的单位向量，我们必须将它除以它的大小。使用数学推导，让我们构建一个函数并创建一个单位向量：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, the value of h is determined by the `sqrt(a^2 + b^2)` magnitude
    formula. To find the unit vector, each component of the vector (`v[0]`, `v[1]`)
    is divided by the magnitude (`mag`).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，h的值由`sqrt(a^2 + b^2)`大小公式确定。要找到单位向量，向量的每个分量(`v[0]`, `v[1]`)都要除以大小(`mag`)。
- en: 'Now that we have declared different functions to define the position, magnitude,
    and direction for the sling action, we can begin to define the method that performs
    the sling action. The following picture represents the catapult, which has two
    ends but no rope attached to it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经声明了不同的函数来定义弹弓动作的位置、大小和方向，我们可以开始定义执行弹弓动作的方法。下图表示了弹弓，它有两端，但没有绳子连接：
- en: '![](Images/6db8057c-d225-45c0-9c97-58a21268b9e5.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6db8057c-d225-45c0-9c97-58a21268b9e5.png)'
- en: 'Here, our main task will be to add bird (the main character) to this catapult
    and to define the position for it. Let''s start by defining some globals inside
    `sling_action`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的主要任务将是将小鸟（主角）添加到这个弹弓上，并为其定义位置。让我们从在`sling_action`中定义一些全局变量开始：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding line of code, we have declared some globals. However, these
    attributes were initialized with some initial values at the beginning of the *Exploring
    pythonic physics simulation* section. This means we will have to do some manipulation
    to update the values of these variables. The `mouse_distance` variable will contain
    the distance value from the point where the catapult is at rest to the point where
    the player stretches the rope of the catapult. Similarly, `rope_length` represents
    the length of the rope when it's been stretched by the player. The angle represents
    the angle of impulse, which is calculated as a slope angle. The slope for the
    rope of the catapult represents how steep the rope is when it's stretched by the
    player. `mouse-x-pos` and `mouse-y-pos` represent the current position of the
    mouse when the rope of the catapult is stretched.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，我们声明了一些全局变量。然而，这些属性在*探索Python物理模拟*部分的开头被初始化为一些初始值。这意味着我们将不得不进行一些操作来更新这些变量的值。`mouse_distance`变量将包含从弹弓静止位置到玩家拉伸弹弓绳索的位置的距离值。同样，`rope_length`表示玩家拉伸弹弓绳索时的绳长。角度表示冲量的角度，它被计算为斜率角度。弹弓绳索的斜率表示玩家拉伸时绳索的陡峭程度。`mouse-x-pos`和`mouse-y-pos`表示弹弓绳索被拉伸时鼠标的当前位置。
- en: 'Now, we have to address three things in this `sling_action` function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`sling_action`函数中，我们需要解决三件事：
- en: Add the Angry Bird to the rope of the sling (as shown in the following screenshot).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将愤怒的小鸟添加到弹弓的绳索上（如下面的截图所示）。
- en: Make the bird stay on the rope, even when the rope of the sling is stretched.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使小鸟停留在绳索上，即使弹弓的绳索被拉伸。
- en: Address a situation where the rope of the sling is fully stretched.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决弹弓绳索被完全拉伸的情况。
- en: 'To understand what these events are, take a look at the following picture:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这些事件是什么，请看下面的图片：
- en: '![](Images/5635bd69-faaa-46bf-8169-e990b113e4c0.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5635bd69-faaa-46bf-8169-e990b113e4c0.png)'
- en: 'Now, let''s address all of the preceding actions in the `sling_action` function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`sling_action`函数中解决所有上述的行动：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code will create a view for the Angry Birds character in the sling
    action. First of all, the `v` vector is created by the two coordinate points (`sling_original`,
    `mouse_current`) for example, ((2, 3), (4, 5)), where (2, 3) represents the sling
    at the static position or the center point of the sling, while (4, 5) represents
    the position when the mouse action is activated by the player. We will create
    a unit vector from this vector to understand the direction of stretch made by
    the player. Then, we will calculate `mouse_distance`, which will be calculated
    by calling the previously defined `distance()` function. This distance represents
    the distance from the static sling's center to the current mouse position. The
    (`mouse_x_pos`, `mouse_y_pos`) value represents the final position for the bird
    after the rope has been stretched. The `uv_1` and `uv_2` unit vectors will ensure
    that the bird will remain on the rope, which is indicated by the mouse's position.
    For example, if the mouse pointer is pointed upward, the rope and the bird will
    stretch in an upward direction.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将在弹弓动作中为愤怒的小鸟角色创建一个视图。首先，通过两个坐标点（`sling_original`，`mouse_current`）创建了`v`向量，例如，((2,
    3), (4, 5))，其中(2, 3)表示静止位置的弹弓或弹弓的中心点，而(4, 5)表示玩家激活鼠标动作时的位置。我们将从这个向量创建一个单位向量，以了解玩家拉伸的方向。然后，我们将计算`mouse_distance`，通过调用先前定义的`distance()`函数来计算。这个距离表示从静止弹弓中心到当前鼠标位置的距离。(`mouse_x_pos`，`mouse_y_pos`)的值表示绳索被拉伸后小鸟的最终位置。`uv_1`和`uv_2`单位向量将确保小鸟保持在绳索上，这由鼠标的位置表示。例如，如果鼠标指针指向上方，绳索和小鸟将向上拉伸。
- en: 'Similarly, let''s address the second scenario, that is, making an Angry Bird
    remain on the rope, even when the rope has been fully stretched. We will implement
    it in the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，让我们解决第二种情况，即使愤怒的小鸟在绳索被完全拉伸时仍然停留在绳索上。我们将在以下代码中实现它：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A lot is going on in the preceding code, but the actions are easier and more
    mathematical. You must try to understand the logic rather than trying to understand
    the syntax. Let's delve into the code and uncover the reason behind each line
    of code. We start by decrementing the mouse position by 20 units to make sure
    that, while stretching, the bird remains at the edge of the rope. Try changing
    this value to 40 and observe the effect. Next, we checked whether `mouse_distance`
    is greater than `rope_length` to make sure that the distance of the stretch is
    within the limit. We don't want the mouse distance to be greater than the maximum
    rope length. In this situation, we will take the mouse distance and decrease it
    until and unless it comes under the maximum length of rope.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中发生了很多事情，但这些操作更容易和更数学化。你必须试着理解逻辑，而不是试图理解语法。让我们深入代码，揭示每行代码背后的原因。我们首先将鼠标位置减少20个单位，以确保在拉伸时，鸟仍然停留在绳子的边缘。尝试将这个值改为40并观察效果。接下来，我们检查`mouse_distance`是否大于`rope_length`，以确保拉伸的距离在限制范围内。我们不希望鼠标距离大于最大绳长。在这种情况下，我们将取鼠标距离并将其减少，直到它小于绳子的最大长度。
- en: 'After that, we will `blit` the redbird (Angry Birds image) at the end of the
    rope. Similarly, we have to `blit` the rope too. In the preceding picture, observe
    the rope pull where the rope has turned red. This red color will be created if
    we `blit` the rope from the center of the static sling to the maximum possible
    rope length. Observe the bold part of the code; we have drawn a line that represents
    the rope with the color code (255, 0, 0), that is, red. There are two statements
    for this: one on each side. Thus, we have implemented the condition where the
    user will stretch the rope to its maximum defined length.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将在绳子的末端`blit`红色小鸟（愤怒的小鸟图像）。同样，我们也必须`blit`绳子。在前面的图片中，观察绳子拉动的地方，绳子变成了红色。如果我们从静态弹弓的中心`blit`绳子到最大可能的长度，就会产生这种红色。观察代码的粗体部分；我们已经画了一条代表绳子的线，颜色代码为（255,
    0, 0），也就是红色。这有两个语句：一个在每一边。因此，我们已经实现了用户将绳子拉伸到其最大定义长度的条件。
- en: 'Now, we have to address the third and last scenario, that is, what happens
    when the player stretches the rope to its maximum length? In the preceding line
    of code we checked `if mouse_distance > rope_length`, and thus if the player stretches
    to less than `rope_length`, it should be addressed in the `else` part of the code,
    as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须解决第三种情况，也就是当玩家将绳子拉到最大长度时会发生什么？在前一行代码中，我们检查了`if mouse_distance > rope_length`，因此如果玩家拉伸小于`rope_length`，它应该在代码的`else`部分中解决，如下所示：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Similar to the previous code, we make the distance no less than 10, which means
    that when the user even slightly stretches the rope, its `mouse_distance` will
    be equal to or more than 10\. Then, we create `third_pos` to define the position
    in which to render the rope and the Angry Bird. `uv_1` and `uv_2` are unit vectors
    that indicate the direction of stretch. After getting the position, we `blit` the
    Angry Bird and then draw a line to indicate the rope. This will be in black and
    will be done on the front and the back.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的代码类似，我们使距离不小于10，这意味着当用户稍微拉伸绳子时，它的`mouse_distance`将等于或大于10。然后，我们创建`third_pos`来定义渲染绳子和愤怒的小鸟的位置。`uv_1`和`uv_2`是指示拉伸方向的单位向量。在获得位置后，我们`blit`愤怒的小鸟，然后画一条线表示绳子。这将是黑色的，并且将在前面和后面完成。
- en: Now that we have defined the scenario for all our cases, let's add a line of
    code to calculate the angle of impulse. This angle will be made whenever there
    is stretch in the rope. The tan (angle of impulse) is equal to the slope of the
    stretched rope. The slope is defined as the rise by run or (`dy`/`dx`), where
    `dy` is the change in `y` and `dx` is the change in x. Thus, the angle of impulse
    can be calculated as `tan^(-1)(dy / dx)`. To learn more about the origins and
    application of this formula, check out [https://www.intmath.com/plane-analytic-geometry/1b-gradient-slope-line.php](https://www.intmath.com/plane-analytic-geometry/1b-gradient-slope-line.php).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经为所有情况定义了场景，让我们添加一行代码来计算冲动的角度。只要绳子有拉伸，就会产生这个角度。tan（冲动角度）等于拉伸绳子的斜率。斜率被定义为上升除以下降或（`dy`/`dx`），其中`dy`是`y`的变化，`dx`是`x`的变化。因此，冲动角度可以计算为`tan^(-1)(dy
    / dx)`。要了解有关此公式的起源和应用的更多信息，请查看[https://www.intmath.com/plane-analytic-geometry/1b-gradient-slope-line.php](https://www.intmath.com/plane-analytic-geometry/1b-gradient-slope-line.php)。
- en: 'Let''s use this formula to calculate the angle of impulse, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个公式来计算冲动的角度，如下所示：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding angle of impulse will be necessary to determine the path of the
    Angry Bird after the sling action is performed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 冲动的前角度将是确定愤怒的小鸟在弹弓动作后路径的必要条件。
- en: Finally, we have completed the sling action. Now, let's hop over to the next
    section, where we will address a collision between two game objects.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经完成了弹弓动作。现在，让我们跳到下一节，解决两个游戏对象之间的碰撞。
- en: Addressing collisions
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决碰撞
- en: 'To recap, answer the following question: When do we know when two game objects
    have collided? Do you have your answer? Whenever two objects are in the same location
    within the coordinate system, they are said to have collided. However, in the
    case of pymunk, we don''t have to check whether a collision has occurred or not.
    Rather, a single method call will check this for us. For example, a call to `space.add_collision_handler(0,
    1)` will add a collision handler to check whether there has been a collision between
    the Bird and Pig characters. Here, the `0` integer represents the `collision_type` that''s
    defined inside the `Bird` class. The `collision_type` that''s defined for the
    `Pig` class is `1`. Thus, these `collision_type` must be unique so that each game
    entity can identify them uniquely.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，回答以下问题：我们如何知道两个游戏对象何时发生了碰撞？你有答案吗？每当两个对象在坐标系内的相同位置时，它们被认为发生了碰撞。然而，在pymunk的情况下，我们不需要检查是否发生了碰撞。相反，一个方法调用将为我们检查这一点。例如，调用`space.add_collision_handler(0,
    1)`将添加一个碰撞处理程序，以检查鸟和猪角色之间是否发生了碰撞。这里，`0`整数代表了`Bird`类内部定义的`collision_type`。`Pig`类定义的`collision_type`是`1`。因此，这些`collision_type`必须是唯一的，以便每个游戏实体可以唯一地识别它们。
- en: Although we have an easier method for adding a handler to check collisions,
    the program still asks for the details; that is, what happens when two game objects
    collide? What actions must be performed? This is resolved by using `post_solve`.
    We will explicitly tell the collision handler that if there is a collision between
    *X* and *Y*, then a specific method should be called; for example, `space.add_collision_handler(0,
    1).post_solve = perform_some_action`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们有一个更简单的方法来添加一个处理程序来检查碰撞，但程序仍然要求细节；也就是说，当两个游戏对象发生碰撞时会发生什么？必须执行什么操作？这是通过使用`post_solve`来解决的。我们将明确告诉碰撞处理程序，如果*X*和*Y*之间发生碰撞，那么应该调用特定的方法；例如，`space.add_collision_handler(0,
    1).post_solve = perform_some_action`。
- en: 'Let''s define each of these actions whenever there is a collision between game
    objects. We will start by defining an action that must be performed whenever there
    is a collision between Bird and Pig. Let''s write a function to do this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每当游戏对象之间发生碰撞时，让我们定义每个动作。我们将首先定义一个必须在Bird和Pig之间发生碰撞时执行的动作。让我们编写一个执行此操作的函数：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding code, the method takes an object of the Arbiter class: `arbiter`.
    The `arbiter` object will encapsulate all the colliding objects/shapes and even
    store all of the colliding object''s positions. Since the game objects are drawn
    into the Pygame screen, we need to know their exact location in terms of the Pygame
    coordinate system. Thus, a conversion is made from pymunk coordinates into Pygame
    coordinates. Similarly, the process that we defined for the `post_solve` function
    is to address the action that must be performed instantaneously after the collision
    between Pig and Bird. The action will reduce the health of pig and then eventually
    remove it from the space. The `space.remove()` statement will remove the game
    objects from the screen.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，该方法接受一个`Arbiter`类的对象：`arbiter`。`arbiter`对象将封装所有碰撞的对象/形状，甚至存储所有碰撞对象的位置。由于游戏对象被绘制到Pygame屏幕中，我们需要知道它们在Pygame坐标系中的确切位置。因此，需要将pymunk坐标转换为Pygame坐标。类似地，我们为`post_solve`函数定义的过程是在Pig和Bird之间发生碰撞后立即执行的动作。该动作将减少猪的生命，然后最终将其从空间中移除。`space.remove()`语句将从屏幕中移除游戏对象。
- en: 'Similarly, let''s define another action that must be performed after the collision
    between Bird and the wooden structure. Similar to the preceding code, after a
    collision, the wooden beams and columns must be removed from the space or screen.
    The following function will address such actions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们定义另一个必须在Bird和木结构之间发生碰撞后执行的动作。与前面的代码类似，在碰撞后，木梁和柱必须从空间或屏幕中移除。以下函数将处理此类动作：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Similar to before, the `arbiter` object will hold information about the colliding
    shapes and positions. Here, the `total_impulse` attribute will return the impulse
    that was applied to resolve the collision. To find out more about the `Arbiter`
    class, go to [http://www.pymunk.org/en/latest/pymunk.html](http://www.pymunk.org/en/latest/pymunk.html).
    Now, after getting the collision's impact, we will check whether `arbiter` has
    a shape of either `beam` or `column` since the arbiter object will contain the
    list of the collided object. After looping through the `beam` and `column` stored
    inside the `arbiter` object, we will remove it from the space.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前类似，`arbiter`对象将保存有关碰撞形状和位置的信息。在这里，`total_impulse`属性将返回应用于解决碰撞的冲量。要了解有关`Arbiter`类的更多信息，请转到[http://www.pymunk.org/en/latest/pymunk.html](http://www.pymunk.org/en/latest/pymunk.html)。现在，在获取碰撞的影响后，我们将检查`arbiter`是否具有`beam`或`column`的形状，因为arbiter对象将包含碰撞对象的列表。在循环遍历`arbiter`对象内存储的`beam`和`column`之后，我们将其从空间中移除。
- en: 'Finally, we will address the last collision—an action that must be implemented
    when `Pig` has collided with the wooden structure. Let''s add a method to implement
    it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将处理最后的碰撞——当`Pig`与木结构发生碰撞时必须执行的动作。让我们添加一个实现它的方法：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Similar to the previous two methods, this function will also check the content
    of the `arbiter` object, which is responsible for encapsulating all the information
    regarding the shape of collided objects and the position at which the collision
    happened. Using the content of the `Arbiter` class object, we have checked the
    length of after impact and then either removed or decreased the life unit of the `Pig`
    character.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与前两种方法类似，此函数还将检查`arbiter`对象的内容，该对象负责封装有关碰撞对象的形状和碰撞发生位置的所有信息。使用`Arbiter`类对象的内容，我们已经检查了冲击后的长度，然后要么删除了`Pig`角色，要么减少了其生命单位。
- en: 'The next step is to add a collision handler. Since we have declared all the
    `post_solve` actions that must be performed after a collision between two objects,
    let''s add it to the collision handler using `post_solve`, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加碰撞处理程序。由于我们已经声明了所有必须在两个对象之间发生碰撞后执行的`post_solve`动作，让我们使用`post_solve`将其添加到碰撞处理程序中，如下所示：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After adding the collision handler, all we need to do is add an event handler
    that handles the events of the player who's playing the game. But before that,
    it is easier to work on the levels. What I really mean by level is to create a
    structure using beams and columns. Although we extracted the beams and columns
    from the sprite sheets, we never created a structure out of them. Let's create
    some wooden structures using beams and columns.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加碰撞处理程序之后，我们需要添加一个事件处理程序，处理玩游戏的玩家的事件。但在此之前，更容易处理级别。我所说的级别实际上是使用横梁和柱子创建结构。尽管我们从精灵表中提取了横梁和柱子，但我们从未用它们创建过结构。让我们使用横梁和柱子创建一些木结构。
- en: Creating levels
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建级别
- en: 'Not only have we created three major game entities, but we have also made a
    collider handler and `sling_action` function. But we aren''t done yet. We have
    to add wooden structures to the space with the help of `beam` and `column` game
    objects. `beam` is a horizontal wooden rectangular structure while `column` is
    a vertical wooden rectangular structure. In this section, we''ll create another
    class and define a level for the game by defining different wooden structures.
    You will have to create a new Python file and name it `level.py`. In that file,
    start writing the following code to define the wooden structures:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅创建了三个主要的游戏实体，还创建了一个碰撞处理程序和`sling_action`函数。但我们还没有完成。我们必须使用`beam`和`column`游戏对象的帮助将木结构添加到空间中。`beam`是一个水平的木制矩形结构，而`column`是一个垂直的木制矩形结构。在这一部分，我们将创建另一个类，并通过定义不同的木结构来为游戏定义一个级别。您将需要创建一个新的Python文件并将其命名为`level.py`。在该文件中，开始编写以下代码来定义木结构：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After importing the essential modules, we can start creating a `Level` class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入必要的模块之后，我们可以开始创建一个`Level`类：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the aforementioned code, we have created a `Level` class with a constructor
    that takes `pigs`, `columns`, `beams`, and `space` as arguments. These arguments
    must not be foreign to you. All of these represent the objects of different classes.
    Similarly, we initialized the class variable using a constructor. The use of the `number` attribute
    will be discussed in a minute. It won''t make sense describing its usage until
    and unless we use it. There is another attribute with a `total_number_of_birds` signature,
    which represents the number of Angry Birds that must be available for the player
    to project with the catapult. Now, let''s build the first level for the game:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了一个`Level`类，它有一个构造函数，接受`pigs`、`columns`、`beams`和`space`作为参数。这些参数对你来说应该不陌生。所有这些都代表不同类的对象。同样地，我们使用构造函数初始化了类变量。`number`属性的使用将在一分钟内讨论。在使用之前，描述它的用法是没有意义的。还有一个带有`total_number_of_birds`签名的属性，它表示玩家在弹弓上投射的愤怒小鸟的数量。现在，让我们为游戏建立第一个级别：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, we have arranged `beam` and `column` in a window fashion
    (one layer on top of another). We also added two pigs inside the structure. To
    create such beams and columns, we have to create instances of the `Polygon` class
    (which we made in the *Creating the Polygon class* section). Although the code
    that's written inside the function seems lengthy, no novel logic is created here.
    We have just instantiated different beams and columns and provided a position
    to render. The value of `pos` is a tuple that represents the position in the space
    where the polygon should be placed.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们以窗口方式排列了`beam`和`column`（一个层叠在另一个上面）。我们还在结构内部添加了两只猪。要创建这样的横梁和柱子，我们必须创建`Polygon`类的实例（我们在*创建多边形类*部分中创建了它）。虽然函数中的代码看起来很长，但这里并没有创造新的逻辑。我们只是实例化了不同的横梁和柱子，并提供了一个渲染位置。`pos`的值是一个元组，表示多边形应该放置在空间中的位置。
- en: 'Now, let''s create another method inside the same `level.py` file and call
    this level `0`. Remember that this is the method of the `Level` class:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在同一个`level.py`文件中创建另一个方法，并将这个级别命名为`0`。记住，这是`Level`类的方法：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, here is the application of the number attribute that we initialized
    while creating the constructor of the class. This `load_level()` method will perform
    string concatenation to build the function name that represents `level_levelNumber`.
    For example, the highlighted part of the preceding code will yield `build_name
    = "build_0"  [initially number = 0] and getattr(self, "build_0)()`, which is equivalent
    to `build_0()`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是我们在创建类的构造函数时初始化的`number`属性的应用。这个`load_level()`方法将执行字符串连接来构建代表`level_levelNumber`的函数名。例如，上述代码的高亮部分将产生`build_name
    = "build_0"` [最初number = 0]和`getattr(self, "build_0)()`，这等同于`build_0()`。
- en: '`get_attr(object, p)` is equivalent to `object.p`. This method is important
    if you feel that there might be an Attribute Error exception. For example, `get_attr(object,
    p, 10)` will return 10 if there is an exception. Thus, this method can be used
    to provide a default value. Attribute Error occurs when an attribute with the
    given name doesn''t exist in the object.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_attr(object, p)`等同于`object.p`。如果你觉得可能会出现属性错误异常，这个方法就很重要。例如，`get_attr(object,
    p, 10)`会在出现异常时返回10。因此，这个方法可以用来提供一个默认值。当给定名称的属性在对象中不存在时，就会出现属性错误。'
- en: 'Since this `load_level()` method should be called explicitly from a file, we
    will do this in the `main.py` file. Open your `main.py` file and then continue
    with the code from where we left off. Write the following code to call the recently
    made `load_level()` method:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个`load_level()`方法应该从一个文件中被显式调用，我们将在`main.py`文件中执行这个操作。打开你的`main.py`文件，然后继续我们离开的地方的代码。写下以下代码来调用最近创建的`load_level()`方法：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding line of code, we import the `Level` class from the `level`
    module. We create an instance of the `Level` class by passing a list of `pig`,
    `columns`, `beams`, and `space`. Similarly, we assign an initial value of `number`
    equal to `0`, which means that the beginning of the `build_0` method should be
    called by the `load_level()` method. You can increment the value of `number` by
    adding more difficult levels.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，我们从`level`模块中导入`Level`类。我们通过传递`pig`、`columns`、`beams`和`space`的列表来创建`Level`类的一个实例。同样地，我们将`number`的初始值设为`0`，这意味着`load_level()`方法应该调用`build_0`方法的开始。你可以通过添加更难的级别来增加`number`的值。
- en: Now that we've loaded the level into our `main.py` file, it's high time to handle
    user action events. We will handle mouse events using Pygame in the next section.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经将级别加载到我们的`main.py`文件中，现在是时候处理用户操作事件了。我们将在下一节中使用Pygame来处理鼠标事件。
- en: Handling user events
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户事件
- en: In this section, we are going to handle user events. This won't be new to you.
    Ever since [Chapter 5](91942969-08b5-4e2d-a64e-3cd3a513b950.xhtml), *Learning
    About Curses by Building a Snake Game*, we have been handling user action events
    in various cases. While building the snake game, we handled keyboard events, and
    for Flappy Bird, we handled mouse tapping events. While handling those events,
    we found that the easiest and most universal way of doing this was by using the `pygame`
    module; it was just one line of code where we had to listen for the incoming actions
    and handle them accordingly.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将处理用户事件。这对你来说不是新鲜事。自从[第5章](91942969-08b5-4e2d-a64e-3cd3a513b950.xhtml)
    *通过构建蛇游戏学习关于Curses*以来，我们一直在各种情况下处理用户操作事件。在构建蛇游戏时，我们处理了键盘事件，而对于Flappy Bird，我们处理了鼠标点击事件。在处理这些事件时，我们发现使用`pygame`模块是最简单和最通用的方法；我们只需要一行代码来监听传入的操作并相应地处理它们。
- en: 'But in the case of Angry Birds, handling mouse actions is a little bit tricky.
    Problems arise when we take the mouse action beyond the scope of space and try
    to perform a sling action. This must not be allowed, and so we have to check whether
    or not the mouse action should be associated with the sling action (the previously
    created function that pulls the rope of the catapult). Thus, let''s learn how
    to handle the input events of the user by writing the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在愤怒的小鸟的情况下，处理鼠标动作有点棘手。当我们将鼠标动作超出空间范围并尝试执行弹弓动作时，问题就会出现。这是不允许的，因此我们必须检查鼠标动作是否应与弹弓动作相关联（先前创建的拉动弹弓绳子的函数）。因此，让我们学习如何通过编写以下代码来处理用户的输入事件：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now that we''ve checked for `QUIT` action events, we can get to mouse event
    handling (when the user uses the mouse to project the Angry Bird from the catapult):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了`QUIT`动作事件，我们可以开始处理鼠标事件（当用户使用鼠标从弹弓中发射愤怒的小鸟时）。
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code, we start off by checking whether the mouse action is
    within scope. We check whether the mouse click is within the scope of space of `(mouse_x_pos
    > 100 and mouse_x_pos < 250 and mouse_y_pos > 370 and mouse_y_pos < 550)`. If
    it is, we will assign a Boolean of `True` to the `mouse_pressed` variable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先检查鼠标动作是否在范围内。我们检查鼠标点击是否在空间范围内`(mouse_x_pos > 100 and mouse_x_pos
    < 250 and mouse_y_pos > 370 and mouse_y_pos < 550)`。如果是，我们将`mouse_pressed`变量赋值为`True`。
- en: 'Next, we will perform the action to release the bird from the catapult or sling.
    After releasing each bird, we check whether any other birds are left or not. If
    there is, we decrease the number of birds by one and assign the value of *x-initial,
    y-initial* = 154, 156, respectively. These values are the center coordinates of
    the sling when the sling is at rest. Now, when the sling is stretched, there will
    be a new value, which we will call `mouse-x-pos`, `mouse-y-pos`. Remember that
    we don''t have to calculate the distance from (`mouse_x_pos`, `mouse_y_pos`) to
    (`x-initial`, `y-initial`) because we did this while creating the `sling_action`
    function. Thus, we will use the `mouse_distance` we calculated there to perform
    the bird release action:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将执行释放小鸟的动作。释放每只鸟后，我们检查是否还有其他鸟。如果有，我们减少一只鸟的数量，并将*x-initial, y-initial*的值分别赋为154,
    156。这些值是弹弓静止时的中心坐标。现在，当弹弓被拉伸时，将会有一个新值，我们将称之为`mouse-x-pos`，`mouse-y-pos`。请记住，我们不必计算从(`mouse_x_pos`,
    `mouse_y_pos`)到(`x-initial`, `y-initial`)的距离，因为我们在创建`sling_action`函数时已经这样做了。因此，我们将使用我们在那里计算的`mouse_distance`来执行释放小鸟的动作：
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding code, we are adding the current `Bird` object that''s attached
    to the rope to the birds list. This list will provide us with information about
    the current bird distance from the center of the catapult, the angle of impulse,
    and the `space` object. Now that we have handled the input actions of the player,
    let''s `blit` every object into the space with the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们正在将附加到绳子的当前`Bird`对象添加到鸟列表中。这个列表将为我们提供有关当前鸟与弹弓中心的距离、冲量角度和`space`对象的信息。现在我们已经处理了玩家的输入动作，让我们使用以下代码将每个对象`blit`到空间中：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the preceding code, we got the current mouse position (the position in the
    space for the mouse action). Then, we drew the background with the background
    image that we loaded previously. Similarly, we `blit` the sling image into the
    screen. Now, we have to `blit` the Angry Birds that are waiting in line to be
    placed in the sling, as shown in the following screenshot:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们得到了当前鼠标位置（鼠标动作在空间中的位置）。然后，我们使用之前加载的背景图像绘制了背景。同样，我们将弹弓图像`blit`到屏幕上。现在，我们必须`blit`等待排队放入弹弓的愤怒小鸟，如下截图所示：
- en: '![](Images/16caf933-bc34-4ec3-902d-99d371fb6621.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/16caf933-bc34-4ec3-902d-99d371fb6621.png)'
- en: Since `total_number_of_birds` is an attribute that's defined inside the `Level`
    class, we have to use it by creating an instance of it. Until and unless the number
    of birds is greater than 0, we create a list representing the number of birds.
    In the `for` loop code, we have to decrease the number of birds by 1 because one
    bird will be in the sling. After getting the actual number of remaining birds,
    we have to get the position to render these birds into the space. Although the *y*-position
    (height) is constant, that is, 508 units, the *x*-position is calculated by providing
    a space between each of them by `i*35` units, where `i` represents the iterables
    that were created by the `for` loop. For example, for bird number 2, the position
    in the space will be (2*35, 508).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`total_number_of_birds`是在`Level`类中定义的属性，我们必须通过创建一个实例来使用它。除非鸟的数量大于0，我们才创建一个表示鸟数量的列表。在`for`循环代码中，我们必须减少鸟的数量1，因为一只鸟将被放入弹弓。在获取实际剩余鸟的数量后，我们必须获取将这些鸟渲染到空间中的位置。尽管*y*位置（高度）是恒定的，即508个单位，但*x*位置是通过提供每个鸟之间的空间来计算的，单位为`i*35`，其中`i`表示`for`循环创建的可迭代对象。例如，对于第2只鸟，空间中的位置将是（2*35,
    508）。
- en: 'Now, we will call the sling action. When the mouse is pressed within the scope
    and the bird possesses some angle of impulse in the space, we have to call the `sling_action`
    method using the following code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将调用弹弓动作。当鼠标在范围内按下并且小鸟在空间中具有一定的冲量角度时，我们必须使用以下代码调用`sling_action`方法：
- en: '[PRE43]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If we have `mouse_pressed` and the number of birds is greater than 0, we perform
    the sling action; otherwise, we just `blit` the bird in the position (`130`, `426`).
    In the `else` part of the code, we do not perform a sling action. The way to determine
    whether the sling action must be performed or not is by observing whether the
    mouse has been pressed or not (released) and the `time_of_release` after the release.
    If the current time has a significant difference, we do not perform the sling
    action. If there are differences of a significant amount, that means the bird
    hasn't been released. In order to release the bird, the current time must be equal
    to `time_of_release`. This is the case when we `blit` redbird in the sling just
    before release.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有`mouse_pressed`并且鸟的数量大于0，我们执行弹弓动作；否则，我们只在位置（`130`，`426`）上进行`blit`。在代码的`else`部分，我们不执行弹弓动作。确定是否必须执行弹弓动作的方法是观察鼠标是否已经按下（释放）以及释放后的`time_of_release`。如果当前时间有显著差异，我们不执行弹弓动作。如果有显著差异，那意味着鸟还没有被释放。为了释放鸟，当前时间必须等于`time_of_release`。这是当我们在释放之前在弹弓中进行`blit`
    redbird的情况。
- en: 'After performing `sling_action`, we can track the number of birds and pigs
    that must be removed from the scope with the following code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`sling_action`后，我们可以使用以下代码跟踪必须从范围内移除的鸟和猪的数量：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the highlighted part of the code, we check whether the bird hits the ground.
    If it does, that means we have to append the bird to the `removed_bird_after_sling`
    list. Similarly, we get the Pygame coordinates for the bird character and `blit`
    it in the (`x_pos`, `y_pos`) position. A blue circle is made around the bird after
    the impact.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的突出部分，我们检查鸟是否撞到了地面。如果是，那意味着我们必须将鸟添加到`removed_bird_after_sling`列表中。类似地，我们获取鸟角色的Pygame坐标并在（`x_pos`，`y_pos`）位置上进行`blit`。撞击后，鸟周围会出现一个蓝色圆圈。
- en: 'Similarly, we have to remove birds and pigs after impact. Write the following
    code to implement this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们必须在撞击后移除鸟和猪。编写以下代码来实现这一点：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Similarly, let''s draw pigs into the space:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，让我们将猪绘制到空间中：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: After the pig hits the ground, we have to add it to the `removed_pigs_after_sling`
    list. We get the position of the body using Pygame coordinates. Similarly, we
    perform a transformation on the `pig` objects. The rotation transformation is
    within 0.5 units. This auto transformation will make the pig move smoothly in
    the space without remaining static. If you change the value of rotation to more
    than 2 units, the pig's position will be drastically deteriorated.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 猪撞到地面后，我们必须将其添加到`removed_pigs_after_sling`列表中。我们使用Pygame坐标获取身体的位置。类似地，我们对`pig`对象执行变换。旋转变换在0.5单位内。这种自动变换将使猪在空间中平稳移动而不保持静止。如果将旋转值更改为超过2个单位，猪的位置将急剧恶化。
- en: 'Two primary game entities have already been rendered into the space; that is,
    pig and bird. Now, it''s time to add some other game entities to the game screen;
    that is, beam and column. We previously made a `beam` and `column` list to track
    the number of beams and columns. Let''s use it to render structures in the game:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 两个主要的游戏实体已经渲染到空间中；即猪和鸟。现在，是时候向游戏屏幕添加一些其他游戏实体了；即横梁和柱子。我们之前创建了一个`beam`和`column`列表来跟踪横梁和柱子的数量。让我们使用它来渲染游戏中的结构：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, it''s time to update the physics: how fast the bird should travel after
    the sling action, and how many updates per frame are to be established for the
    stability of the game. First of all, let''s define the time step''s length:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候更新物理：鸟在弹弓动作后应该以多快的速度前进，以及为了游戏的稳定性应该建立多少帧的更新。首先，让我们定义时间步长的长度：
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the previously defined time interval (`dt` or time step interval), observe
    that we have moved the simulation of space forward 50 times with a `dt` of 2 units.
    If you increase the value of `dt` from 2 to 4 or more, the simulation will be
    slower. According to pymunk''s official documentation: *Performing more steps
    by using smaller `dt` creates a stable simulation*. Here, the value 50 represents
    the steps defined and a `dt` of 2 creates a movement of a total of 100 units forward
    into the space. The forward simulation in the space represents the speed at which
    the Angry Bird is projected toward the wooden structure.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前定义的时间间隔（`dt`或时间步长）中，观察到我们使用2个单位的`dt`将空间的模拟向前推进了50次。如果将`dt`的值从2增加到4或更多，模拟将变慢。根据pymunk的官方文档：*使用更小的`dt`执行更多步骤会创建稳定的模拟*。这里，值50代表了定义的步骤，而2的`dt`创建了总共向空间前进100个单位的移动。空间中的前向模拟代表了愤怒的小鸟向木结构投射的速度。
- en: 'Now, using this time interval, let''s add these steps to the simulation:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用这个时间间隔，让我们将这些步骤添加到模拟中：
- en: '[PRE49]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `step` method, which is called using the `space` object, will update the
    space for the given time step interval (`dt` or time step interval). Refer to [http://www.pymunk.org/en/latest/_modules/pymunk/space.html](http://www.pymunk.org/en/latest/_modules/pymunk/space.html)
    to find out more about the `step` method.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`space`对象调用的`step`方法将更新给定时间步长（`dt`或时间步长）的空间。请参考[http://www.pymunk.org/en/latest/_modules/pymunk/space.html](http://www.pymunk.org/en/latest/_modules/pymunk/space.html)
    了解更多关于`step`方法的信息。
- en: 'Finally, let''s run our game. Click on the Run tab and then click on the `main.py`
    file. The following is the result of running the Angry Birds game:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们运行游戏。点击“Run”选项卡，然后点击`main.py`文件。运行愤怒的小鸟游戏的结果如下：
- en: '![](Images/7a557345-aa33-4389-a25e-af62ee6dd70c.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7a557345-aa33-4389-a25e-af62ee6dd70c.png)'
- en: Finally, our game is complete. You can test the different physical attributes
    we defined for the game entities by changing their values and observing their
    results. If I were you, I would probably change the step size value of `dt` and
    check how it affects the simulation of objects. Obviously, changing the value
    of `dt` from lower to higher would make the speed of objects slower after `sling_action`
    is triggered. For example, changing the value of step size (`dt = 4`), you would
    experience the Angry Bird going slower than before. This is due to an increase
    in the simulation forward movement by extra units.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的游戏完成了。您可以通过更改它们的值并观察结果来测试我们为游戏实体定义的不同物理属性。如果我是您，我可能会更改“dt”的步长值，并检查它如何影响对象的模拟。显然，将“dt”的值从较低更改为较高会使“弹弓动作”触发后对象的速度变慢。例如，更改步长值（`dt
    = 4`），您会发现愤怒的小鸟比以前慢。这是由于模拟向前移动增加了额外的单位。
- en: Although our game is perfectly fine to play and test with, there are a few tweaks
    that can be implemented to make our game even more appealing. For example, we
    can add sound effects to the game and add more levels. We'll go over this in the
    next section.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的游戏可以完全正常地玩和测试，但还有一些调整可以实现，使我们的游戏更具吸引力。例如，我们可以为游戏添加音效并增加更多关卡。我们将在下一节中讨论这一点。
- en: Possible modifications
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可能的修改
- en: 'When testing our game, it might be the case that there is not much space for
    further modifications. However, I came up with an important one: adding `soundFx`
    to the game. To provide an active experience to the user while they''re communicating
    with the virtual world, sound effects play an important role. With this consideration,
    Python''s `Pygame` module provides an interface so that we can add a soundtrack
    to the game.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试我们的游戏时，可能会出现没有太多空间进行进一步修改的情况。但是，我想到了一个重要的修改：为游戏添加`soundFx`。为了在用户与虚拟世界交流时提供积极的体验，音效起着重要作用。考虑到这一点，Python的`Pygame`模块提供了一个接口，以便我们可以为游戏添加配乐。
- en: First of all, to add sound effects to the game, we need to load music into the
    game. Check out this book's resource folder on GitHub: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15/res](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15/res).
    Then, check out the `sounds` folder, which will contain music files that can be
    added for the game project. I will use the `angry-birds.ogg` file (you can use
    any file you like—you can even download one off the internet).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要为游戏添加音效，我们需要将音乐加载到游戏中。在GitHub上查看本书的资源文件夹：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15/res](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter15/res)。然后，查看`sounds`文件夹，其中包含可以添加到游戏项目中的音乐文件。我将使用`angry-birds.ogg`文件（您可以使用任何您喜欢的文件，甚至可以从互联网上下载）。
- en: 'The following code will load the music file into your Python project. Make
    sure the code is written inside the `main.py` file:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将音乐文件加载到您的Python项目中。确保代码编写在`main.py`文件中：
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the preceding function definition, we started by defining the path for the
    music file and stored it as a string in the `song_name` variable. Now, to load
    the playback file, we can use the `mixer.music` class, which has a predefined
    `load()` method that will load the song into the Python project. To play the music
    that we have just loaded, we will call the `play()` method. The play method takes
    two arguments: loop and start. Both of these arguments are optional. The loop
    value will be `-1`, which means the loaded music must be played continuously.
    If you want to play music continuously, for example, six times, you can call the
    `play` method with a *loop = 5* argument on it. For example, `play(5)` will make
    the music play 6 times, continuously.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数定义中，我们首先定义了音乐文件的路径，并将其存储为`song_name`变量中的字符串。现在，要加载播放文件，我们可以使用`mixer.music`类，该类具有预定义的`load()`方法，该方法将歌曲加载到Python项目中。要播放刚刚加载的音乐，我们将调用`play()`方法。play方法接受两个参数：loop和start。这两个参数都是可选的。循环值将为`-1`，这意味着必须连续播放加载的音乐。例如，如果要连续播放音乐，例如六次，可以在其上调用`play`方法并带有`loop
    = 5`参数。例如，`play(5)`将使音乐连续播放6次。
- en: 'Now, let''s call the aforementioned function within the same `main.py` file.
    You can call it as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在同一个`main.py`文件中调用上述函数。您可以这样调用：
- en: '[PRE51]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: That's it if we want to load music into our Python game. Now, you can play your
    game and enjoy the soundtrack.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如果我们想要将音乐加载到我们的Python游戏中。现在，您可以玩游戏并享受配乐。
- en: 'The next modification we can make is adding different levels. Go back to the
    Python project and open the `level.py` file. It will contain the `Level `class,
    along with a single function called `build_0`. You can add as many levels as you
    want. In this section, we will add another level for the game and call it `build_1`.
    The following function should be written inside the `Level` class of the `level.py`
    file:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行的下一个修改是添加不同的关卡。返回Python项目并打开`level.py`文件。它将包含`Level`类以及一个名为`build_0`的单个函数。您可以添加任意多个关卡。在本节中，我们将为游戏添加另一个关卡，并将其命名为`build_1`。以下函数应该编写在`level.py`文件的`Level`类中：
- en: '[PRE52]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding code, we have defined a function that will create a wooden
    structure. Observe the code closely – we have created instances of the `Pig` and
    `Polygon` classes. The pig character was created at the position (1000, 10) in
    the space. Similarly, the three columns were created one after another and aligned
    vertically. The `pos` local variable denotes the position in the space where these
    game entities must be rendered. To create any random structure with the help of
    these game entities, you can test the different values for the `pos` variables.
    However, make sure that the position you defined is within the space and at the
    left-hand side corner of the space. For example, giving a position of (50 , 150)
    would render any game entities closer to the catapult and would not make the game
    competitive. Therefore, while building such structures, make sure that the entities
    are drawn far away from the catapult.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个函数，用于创建一个木结构。仔细观察代码-我们创建了`Pig`和`Polygon`类的实例。猪角色被创建在空间中的位置(1000,
    10)。同样，三根柱子依次创建并垂直对齐。`pos`局部变量表示这些游戏实体必须呈现的空间位置。要使用这些游戏实体创建任何随机结构，可以测试`pos`变量的不同值。但是，请确保您定义的位置在空间内并且在空间的左下角。例如，给定位置(50,
    150)会使任何游戏实体更靠近弹弓，并且不会使游戏具有竞争性。因此，在构建这样的结构时，请确保实体远离弹弓。
- en: 'Now, when you run the program with the second level, you will see the following
    output:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行第二关的程序时，你将看到以下输出：
- en: '![](Images/9d4c448c-af97-457d-8144-795c8bd35bef.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9d4c448c-af97-457d-8144-795c8bd35bef.png)'
- en: You can add as many levels as you want. All you need is a bit of creativity
    for making game levels—forming beam and column structures that would be hard to
    break by the player. If you want to add further modifications, you could add a
    score to the game. You could assign some values to the game entities (pig, beam,
    and column) and whenever the bird collides with those game entities, you could
    add that value to the player's score. We implemented similar logic in [Chapter
    12](6eb72797-e976-49b0-878f-4db620a59aca.xhtml), *Learning About Character Animation,
    Collision, and Movement*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加任意多的关卡。你只需要一点创造力来制作游戏关卡-形成横梁和柱子结构，这样玩家就很难打破。如果你想添加进一步的修改，你可以为游戏添加得分。你可以为游戏实体(猪、横梁和柱子)分配一些值，每当鸟与这些游戏实体发生碰撞时，你可以将该值添加到玩家的得分中。我们在第12章中实现了类似的逻辑，*学习角色动画、碰撞和移动*。
- en: Finally, our game is playable, and you can test the sound effects and physical
    attributes of each game entity. You can test how the elasticity property has provided
    real-world simulation for the surfaces of the game. You can also test the simulation
    speed of the space. To learn more about the simulation step and step time interval,
    check out the online resources that are available at [http://www.pymunk.org/en/latest/_modules/pymunk/space.html](http://www.pymunk.org/en/latest/_modules/pymunk/space.html).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的游戏是可玩的，你可以测试每个游戏实体的声音效果和物理属性。你可以测试弹性属性如何为游戏表面提供真实世界的模拟。你还可以测试空间的模拟速度。要了解更多关于模拟步骤和步长时间间隔的信息，请查看[http://www.pymunk.org/en/latest/_modules/pymunk/space.html](http://www.pymunk.org/en/latest/_modules/pymunk/space.html)上提供的在线资源。
- en: I had a lot of fun writing this chapter, along with building this game. I hope
    it was the same for you too. In the next chapter, we will learn about other important
    skills that every Python game developer must possess—adding an artificial character
    to the game. This character will play and compete with the human player in the
    same game. To be precise, we will be creating a human-like player in the game
    and adding intelligence to it, similar to what we humans have. The next chapter
    will be an interesting and edifying one. Let's get to it!
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我很享受写这一章，也很享受制作这个游戏。我希望你也一样。在下一章中，我们将学习每个Python游戏开发者都必须具备的其他重要技能-为游戏添加一个人工角色。这个角色将在同一个游戏中与人类玩家进行游戏和竞争。确切地说，我们将在游戏中创建一个类似人类的玩家，并为其添加智能，就像我们人类一样。下一章将是有趣而有教育意义的。让我们开始吧！
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored how we can create Pythonic 2D physics simulation
    spaces by adding real-world physical attributes to game characters and the environment.
    We began by learning about the fundamentals of various `pymunk` modules, such
    as vec2d, sub-modules, different classes, and attributes that will build 2D rigid
    bodies. These bodies have the ability to simulate real-world object characteristics
    such as mass, inertia, motion, and elasticity. Using these characteristics, we
    were able to provide unique features to each of the game entities; that is, bird,
    pig, beam, and column.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们探讨了如何通过为游戏角色和环境添加真实世界的物理属性来创建Pythonic 2D物理模拟空间。我们首先学习了各种`pymunk`模块的基础知识，比如vec2d、子模块、不同的类和属性，这些将构建2D刚体。这些刚体具有模拟真实世界物体特性的能力，比如质量、惯性、运动和弹性。利用这些特性，我们能够为每个游戏实体提供独特的特征，即鸟、猪、横梁和柱子。
- en: The main aim of this chapter was to make you understand how to use the `pymunk`
    module effectively to create complex games such as Angry Birds. Games such as
    Angry Birds are considered intricate—not because it contains a variety of entities,
    but because they have to simulate real-world physical attributes. Since `pymunk`
    contains different classes to address such an environment, we used it to create
    a game environment, surfaces, and game entities such as Angry Birds, pigs, and
    polygons. In this chapter, you also learned how to handle collisions and movements
    between more than two game characters. So far, we've learned how to create a handler
    to address collisions between two game objects (between the snake and the boundary
    and between the flappy bird and the vertical pipes), but this chapter helped you
    understand how easily a collision handler can be created to address collisions
    between multiple game entities.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目的是让你了解如何有效地使用`pymunk`模块来创建像愤怒的小鸟这样复杂的游戏。像愤怒的小鸟这样的游戏被认为是复杂的，不是因为它包含了各种实体，而是因为它们必须模拟真实世界的物理属性。由于`pymunk`包含了不同的类来处理这样的环境，我们使用它来创建游戏环境、表面和游戏实体，比如愤怒的小鸟、猪和多边形。在本章中，你还学会了如何处理超过两个游戏角色之间的碰撞和移动。到目前为止，我们已经学会了如何创建一个处理程序来处理两个游戏对象之间的碰撞（蛇和边界之间以及小鸟和垂直管道之间的碰撞），但本章帮助你了解了如何轻松地创建一个碰撞处理程序来处理多个游戏实体之间的碰撞。
- en: The next chapter will be a fun and challenging one. We will be learning about
    how to create **non-player characters** (**NPCs**)—an artificial player who is
    smart enough to compete with human players. We will create these NPCs by defining
    the moves and actions that human players would perform in the same instances.
    For example, when a human player sees a wall in front of them, they will make
    a move to omit a collision. A similar strategy will also be fed into the artificial
    player so that they can make smart moves and be able to compete with human players
    effectively.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将是有趣且具有挑战性的。我们将学习如何创建**非玩家角色**（**NPC**）—一个足够聪明以与人类玩家竞争的人工玩家。我们将通过定义人类玩家在相同情况下执行的移动和动作来创建这些NPC。例如，当人类玩家看到面前有墙时，他们会采取行动来避免碰撞。类似的策略也将被输入到人工玩家中，以便他们能够做出聪明的举动，并能够有效地与人类玩家竞争。
