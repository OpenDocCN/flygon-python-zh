["```py\ndef divide(x, y):\n    print('Going to divide {} / {}'.format(x, y))\n\n    # Stop execution here and enter the debugger\n    import pdb; pdb.set_trace()\n\n    return x / y\n```", "```py\n>>> print(divide(3, 2))\nGoing to divide 3 / 2\n> ../sources/devtools/devtools_01.py(4)divide()\n-> return x / y\n(Pdb) x\n3\n(Pdb) y\n2\n(Pdb) continue\n1.5\n```", "```py\ndef divide(x, y):\n    return x / y\n```", "```py\nfrom divide import divide\nimport unittest\n\nclass TestDivision(unittest.TestCase):\n    def setUp(self):\n        self.num = 6\n\n    def test_int_division(self):\n        res = divide(self.num, 3)\n        self.assertEqual(res, 2)\n\n    def test_float_division(self):\n        res = divide(self.num, 4)\n        self.assertEqual(res, 1.5)\n\n    def test_divide_zero(self):\n        with self.assertRaises(ZeroDivisionError) as err:\n            res = divide(self.num, 0)\n        self.assertEqual(str(err.exception), 'division by zero')\n```", "```py\n$ python -m unittest\n...\n------------------------------------------------------------------\nRan 3 tests in 0.000s\n\nOK\n```", "```py\n$ python -m unittest -v\ntest_divide_zero (test_devtools_02.TestDivision) ... ok\ntest_float_division (test_devtools_02.TestDivision) ... ok\ntest_int_division (test_devtools_02.TestDivision) ... ok\n\n----------------------------------------------------------------------\nRan 3 tests in 0.000s\n\nOK\n```", "```py\nclass TestDivision(unittest.TestCase):\n    def setUp(self):\n        self.num = 6\n```", "```py\ndef test_int_division(self):\n    res = divide(self.num, 3)\n    self.assertEqual(res, 2)\n\ndef test_float_division(self):\n    res = divide(self.num, 4)\n    self.assertEqual(res, 1.5)\n```", "```py\ndef test_divide_zero(self):\n    with self.assertRaises(ZeroDivisionError) as err:\n        res = divide(self.num, 0)\n    self.assertEqual(str(err.exception), 'division by zero')\n```", "```py\ndef print_division(x, y):\n    print(x / y)\n```", "```py\nfrom unittest import mock\n\nwith mock.patch('builtins.print') as mprint:\n    print_division(4, 2)\n\nmprint.assert_called_with(2)\n```", "```py\nmock_args, mock_kwargs = mprint.call_args\n>>> print(mock_args)\n(2, )\n```", "```py\nwith mock.patch('builtins.print') as mprint:\n    print_division(4, 2)\n```", "```py\nmprint.assert_called_with(2)\n```", "```py\nimport logging\nimport logging.handlers\nimport functools\n\ncrashlogger = logging.getLogger('__crashes__')\n\ndef configure_crashreport(mailhost, fromaddr, toaddrs, subject, \n                        credentials, tls=False):\n    if configure_crashreport._configured:\n        return\n\n    crashlogger.addHandler(\n        logging.handlers.SMTPHandler(\n            mailhost=mailhost,\n            fromaddr=fromaddr,\n            toaddrs=toaddrs,\n            subject=subject,\n            credentials=credentials,\n            secure=tuple() if tls else None\n        )\n    )\n    configure_crashreport._configured = True\nconfigure_crashreport._configured = False\n\ndef crashreport(f):\n    @functools.wraps(f)\n    def _crashreport(*args, **kwargs):\n        try:\n            return f(*args, **kwargs)\n        except Exception as e:\n            crashlogger.exception(\n                '{} crashed\\n'.format(f.__name__)\n            )\n            raise\n    return _crashreport\n```", "```py\n@crashreport\ndef main():\n    3 / 0\n\nconfigure_crashreport(\n    'your-smtp-host.com',\n    'no-reply@your-smtp-host.com',\n    'crashes_receiver@another-smtp-host.com',\n    'Automatic Crash Report from TestApp',\n    ('smtpserver_username', 'smtpserver_password'),\n    tls=True\n)\n\nmain()\n```", "```py\ndef crashreport(f):\n    @functools.wraps(f)\n    def _crashreport(*args, **kwargs):\n        try:\n            return f(*args, **kwargs)\n        except Exception as e:\n            crashlogger.exception(\n                '{} crashed\\n'.format(f.__name__)\n            )\n            raise\n    return _crashreport\n```", "```py\ndef configure_crashreport(mailhost, fromaddr, toaddrs, subject, \n                        credentials, tls=False):\n    if configure_crashreport._configured:\n        return\n\n    crashlogger.addHandler(\n        logging.handlers.SMTPHandler(\n            mailhost=mailhost,\n            fromaddr=fromaddr,\n            toaddrs=toaddrs,\n            subject=subject,\n            credentials=credentials,\n            secure=tuple() if tls else None\n        )\n    )\n    configure_crashreport._configured = True\nconfigure_crashreport._configured = False\n```", "```py\nconfigure_crashreport(\n    'your-smtp-host.com',\n    'no-reply@your-smtp-host.com',\n    'crashes_receiver@another-smtp-host.com',\n    'Automatic Crash Report from TestApp',\n    ('smtpserver_username', 'smtpserver_password'),\n    tls=True\n)\n```", "```py\ndef function1():\n    l = []\n    for i in range(100):\n        l.append(i)\n    return l\n\ndef function2():\n    return [i for i in range(100)]\n```", "```py\n>>> import timeit\n\n>>> print(\n...     timeit.timeit(function1)\n... )\n10.132873182068579\n\n>>> print(\n...     timeit.timeit(function2)\n... )\n5.13165780401323\n```", "```py\nimport inspect\n\ndef inspect_object(o):\n    if inspect.isfunction(o) or inspect.ismethod(o):\n        print('FUNCTION, arguments:', inspect.signature(o))\n    elif inspect.isclass(o):\n        print('CLASS, methods:', \n              inspect.getmembers(o, inspect.isfunction))\n    else:\n        print('OBJECT ({}): {}'.format(\n            o.__class__, \n            [(n, v) for n, v in inspect.getmembers(o) \n                if not n.startswith('__')]\n        ))\n```", "```py\nclass MyClass:\n    def __init__(self):\n        self.value = 5\n\n    def sum_to_value(self, other):\n        return self.value + other\n```", "```py\n>>> inspect_object(MyClass.sum_to_value)\nFUNCTION, arguments: (self, other)\n```", "```py\n>>> o = MyClass()\n>>> inspect_object(o)\nOBJECT (<class '__main__.MyClass'>): [\n    ('sum_to_value', <bound method MyClass.sum_to_value of ...>), \n    ('value', 5)\n]\n```", "```py\n>>> inspect_object(MyClass)\nCLASS, methods: [\n    ('__init__', <function MyClass.__init__ at 0x107bd0400>), \n    ('sum_to_value', <function MyClass.sum_to_value at 0x107bd0488>)\n]\n```", "```py\nif inspect.isfunction(o) or inspect.ismethod(o):\n    print('FUNCTION, arguments:', inspect.signature(o))\n```", "```py\nFUNCTION, arguments: (self, other)\n```", "```py\nelif inspect.isclass(o):\n    print('CLASS, methods:', inspect.getmembers(o, inspect.isfunction))\n```", "```py\nelse:\n    print('OBJECT ({}): {}'.format(\n        o.__class__, \n        [(n, v) for n, v in inspect.getmembers(o) \n            if not n.startswith('__')]\n    ))\n```", "```py\nOBJECT (<class '__main__.MyClass'>): [\n    ('sum_to_value', <bound method MyClass.sum_to_value of ...>), \n    ('value', 5)\n]\n```", "```py\nimport ast\n\ndef run_python(code, mode='evalsafe'):\n    if mode == 'evalsafe':\n        return ast.literal_eval(code)\n    elif mode == 'eval':\n        return eval(compile(code, '', mode='eval'))\n    elif mode == 'exec':\n        return exec(compile(code, '', mode='exec'))\n    else:\n        raise ValueError('Unsupported execution model \n                         {}'.format(mode))\n```", "```py\n>>> print(run_python('[1, 2, 3]'))\n[1, 2, 3]\n```", "```py\n>>> print(run_python('[1, 2, 3][0]'))\n[ ... ]\nmalformed node or string: <_ast.Subscript object at 0x10ee57ba8>\n```", "```py\n>>> print(run_python('[1, 2, 3][0]', 'eval'))\n1\n```", "```py\n>>> print(run_python('''\n... def x(): \n...     print(\"printing hello\")\n... x()\n... ''', 'eval'))\n[ ... ]\ninvalid syntax (, line 2)\n```", "```py\n>>> print(run_python('''\n... def x(): \n...     print(\"printing hello\")\n... x()\n... ''', 'exec'))\nprinting hello\nNone\n```", "```py\nimport trace\nimport collections\n\ndef report_tracing(func, *args, **kwargs):\n    outputs = collections.defaultdict(list)\n\n    tracing = trace.Trace(trace=False)\n    tracing.runfunc(func, *args, **kwargs)\n\n    traced = collections.defaultdict(set)\n    for filename, line in tracing.results().counts:\n        traced[filename].add(line)\n\n    for filename, tracedlines in traced.items():\n        with open(filename) as f:\n            for idx, fileline in enumerate(f, start=1):\n                outputs[filename].append(\n                  (idx, idx in tracedlines, fileline))\n                )  \n    return outputs\n```", "```py\ndef print_traced_execution(tracings):\n    for filename, tracing in tracings.items():\n        print(filename)\n        for idx, executed, content in tracing:\n            print('{:04d}{}  {}'.format(idx, \n                                        '+' if executed else ' ', \n                                        content),\n                end='')\n        print()\n```", "```py\ndef function(should_print=False):\n    a = 1\n    b = 2\n    if should_print:\n        print('Usually does not execute!')\n    return a + b\n```", "```py\n>>> print_traced_execution(\n...     report_tracing(function)\n... )\ndevtools_08.py\n0001   def function(should_print=False):\n0002+      a = 1\n0003+      b = 2\n0004+      if should_print:\n0005           print('Usually does not execute!')\n0006+      return a + b\n```", "```py\n>>> print_traced_execution(\n...     report_tracing(function, True)\n... )\nUsually does not execute!\ndevtools_08.py\n0001   def function(should_print=False):\n0002+      a = 1\n0003+      b = 2\n0004+      if should_print:\n0005+          print('Usually does not execute!')\n0006+      return a + b\n```", "```py\ndef report_tracing(func, *args, **kwargs):\n    outputs = collections.defaultdict(list)\n```", "```py\ntracing = trace.Trace(trace=False)\n```", "```py\ntracing.runfunc(func, *args, **kwargs)\n```", "```py\ntraced = collections.defaultdict(set)\nfor filename, line in tracing.results().counts:\n    traced[filename].add(line)\n```", "```py\nfor filename, tracedlines in traced.items():\n    with open(filename) as f:\n        for idx, fileline in enumerate(f, start=1):\n            outputs[filename].append((idx, idx in tracedlines, fileline))\n```", "```py\nreturn outputs\n```", "```py\ndef print_traced_execution(tracings):\n    for filename, tracing in tracings.items():\n        print(filename)\n```", "```py\nfor idx, executed, content in tracing:\n    print('{:04d}{}  {}'.format(idx, \n                                '+' if executed else ' ', \n                                content),\n        end='')\nprint()\n```", "```py\nimport time\n\ndef slowfunc(goslow=False):\n    l = []\n    for i in range(100):\n        l.append(i)\n        if goslow:\n            time.sleep(0.01)\n    return l\n```", "```py\nfrom cProfile import Profile\n\nprofiler = Profile()\nprofiler.runcall(slowfunc, True)\nprofiler.print_stats()\n```", "```py\n202 function calls in 1.183 seconds\n\nOrdered by: standard name\n\nncalls  tottime  percall  cumtime  percall filename:lineno(function)\n    1    0.002    0.002    1.183    1.183 devtools_09.py:3(slowfunc)\n  100    1.181    0.012    1.181    0.012 {built-in method time.sleep}\n  100    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\n```", "```py\nprofiler = Profile()\nprofiler.runcall(slowfunc, True)\n```", "```py\nprofiler.print_stats()\n```", "```py\nncalls  tottime  percall  cumtime  percall filename:lineno(function)\n    1    0.002    0.002    1.183    1.183 devtools_09.py:3(slowfunc)\n  100    1.181    0.012    1.181    0.012 {built-in method time.sleep}\n  ...\n```", "```py\nprofiler.runcall(slowfunc, False)\nprofiler.print_stats()\n```", "```py\n102 function calls in 0.000 seconds\n\nOrdered by: standard name\n\nncalls  tottime  percall  cumtime  percall filename:lineno(function)\n    1    0.000    0.000    0.000    0.000 devtools_09.py:3(slowfunc)\n  100    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\n```"]