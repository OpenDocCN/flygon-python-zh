- en: Chapter 13. Application Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。应用程序集成
- en: 'In this chapter, we''ll look at the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下示例：
- en: Finding configuration files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找配置文件
- en: Using YAML for configuration files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用YAML进行配置文件
- en: Using Python for configuration files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python进行配置文件
- en: Using class-as-namespace for configuration values
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类作为命名空间进行配置值
- en: Designing scripts for composition
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为构图设计脚本
- en: Using logging for control and audit output
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用日志进行控制和审计输出
- en: Combining two applications into one
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将两个应用程序合并为一个
- en: Combining many applications using the Command design pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令设计模式组合多个应用程序
- en: Managing arguments and configuration in composite applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在复合应用程序中管理参数和配置
- en: Wrapping and combining CLI applications
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装和组合CLI应用程序
- en: Wrapping a program and checking the output
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装程序并检查输出
- en: Controlling complex sequences of steps
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制复杂的步骤序列
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Python's extensible library gives us rich access to numerous computing resources.
    This makes Python programs particularly strong at integrating components to create
    sophisticated composite processing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Python的可扩展库为我们提供了丰富的访问多种计算资源的途径。这使得Python程序特别擅长于集成组件以创建复杂的复合处理。
- en: In the *Using argparse to get command line input* , *Using cmd for creating
    command-line applications* , and *Using the OS environment settings* recipes in [Chapter
    5](text00063.html#page "Chapter 5. User Inputs and Outputs") , *User Inputs and
    Outputs* , specific techniques for creating top-level (main) application scripts
    were shown. In [Chapter 9](text00099.html#page "Chapter 9. Input/Output, Physical
    Format, and Logical Layout") , *Input/Output, Physical Format, Logical Layout*
    , we looked at file-system input and output. In [Chapter 12](text00129.html#page
    "Chapter 12. Web Services") , *Web Services* , we looked at creating servers,
    which are main applications that receive requests from clients.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00063.html#page "第5章。用户输入和输出")中的*使用argparse获取命令行输入*，*使用cmd创建命令行应用程序*和*使用OS环境设置*的示例中，展示了创建顶层（主要）应用程序脚本的特定技术。在[第9章](text00099.html#page
    "第9章。输入/输出、物理格式和逻辑布局")中，我们研究了文件系统的输入和输出。在[第12章](text00129.html#page "第12章。Web服务")中，我们研究了创建服务器，这些服务器是从客户端接收请求的主要应用程序。
- en: 'All of these examples show some aspects of application programming in Python.
    There are some additional techniques that are helpful:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例展示了Python中的应用程序编程的一些方面。还有一些其他有用的技术：
- en: 'Processing configuration from files. In the  *Using argparse to get command
    line input*  recipe in [chapter 5](text00063.html#page "Chapter 5. User Inputs
    and Outputs") , *User Inputs and Outputs* , we showed techniques for parsing command
    line arguments. In the  *Using the OS environment settings* recipe, we touched
    on other kinds of configuration details. In this chapter, we''ll look at a number
    of ways to handle configuration files. There are many file formats that can be
    used to store long-term configuration information:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件中处理配置。在[第5章](text00063.html#page "第5章。用户输入和输出")的*使用argparse获取命令行输入*中，我们展示了解析命令行参数的技术。在*使用OS环境设置*的示例中，我们涉及了其他类型的配置细节。在本章中，我们将探讨处理配置文件的多种方法。有许多文件格式可用于存储长期配置信息：
- en: The INI file format as processed by the `configparser` module.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: INI文件格式由`configparser`模块处理。
- en: The YAML file format is very easy to work with, but requires an add-on module
    that's not currently part of the Python distribution. We'll look at this in the
    *Using YAML for configuration files* recipe.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAML文件格式非常易于使用，但需要一个不是Python发行版的附加模块。我们将在*使用YAML进行配置文件*中进行讨论。
- en: The Properties file format is typical of Java programming, and can be handled
    in Python without writing too much code. The syntax overlaps with Python scripts.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性文件格式是Java编程的典型格式，可以在Python中处理而不需要编写太多代码。语法与Python脚本重叠。
- en: For Python scripts, a file with assignment statements looks a lot like a properties
    file, and is very easy to process using `compile()` and `exec()` methods. We'll
    look at this in the *Using Python for configuration files* recipe.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Python脚本，具有赋值语句的文件看起来很像属性文件，并且非常容易使用`compile()`和`exec()`方法进行处理。我们将在*使用Python进行配置文件*中进行讨论。
- en: Python modules with class definitions is a variation that uses Python syntax,
    but isolates the settings into separate classes. This can be processed with the
    `import` statement. We'll look at this in the *Using class-as-namespace for configuration*
    recipe.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python模块与类定义是一种使用Python语法的变体，但将设置隔离到单独的类中。这可以通过`import`语句进行处理。我们将在*使用类作为命名空间进行配置*中进行讨论。
- en: In this chapter, we'll look at ways that we can design applications that can
    be composed to create larger, more sophisticated composite applications.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨设计应用程序的方法，这些应用程序可以组合在一起创建更大、更复杂的复合应用程序。
- en: We'll look at the complications that can arise from composite applications and
    the need to centralize some features like command line parsing.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将探讨由复合应用程序引起的复杂性以及需要集中一些功能（如命令行解析）的需求。
- en: We'll extend some of the concepts from [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* , and [Chapter 7](text00079.html#page
    "Chapter 7. More Advanced Class Design") , *More Advanced Class Design* , and
    apply the idea of the Command design pattern to Python programs.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将扩展[第6章](text00070.html#page "第6章。类和对象的基础")和[第7章](text00079.html#page "第7章。更高级的类设计")中的一些概念，应用命令设计模式的想法到Python程序中。
- en: Finding configuration files
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找配置文件
- en: Many applications will have a hierarchy of configuration options. There could
    be defaults that are built in to a particular release. There might be server-wide
    (or cluster-wide) values. There might be user-specific values, or perhaps even
    configuration files that are local to a specific invocation of a program.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序将具有配置选项的层次结构。可能会有内置于特定版本的默认值。可能会有服务器范围（或集群范围）的值。可能会有特定用户的值，或者甚至是特定程序调用的本地配置文件。
- en: In many cases, these configuration parameters will be written in files so that
    they are easy to change. The common tradition in Linux is to put system-wide configuration
    in the `/etc` directory. A user's personal changes would be in their home directory,
    often named `~username` .
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，这些配置参数将被写入文件中，以便更改。Linux中的常见传统是将系统范围的配置放在 `/etc` 目录中。用户的个人更改将在其主目录中，通常命名为
    `~username` 。
- en: How can we support a rich hierarchy of locations for configuration files?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何支持丰富的配置文件位置层次结构？
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example will be a web service that provides hands of cards to users. The
    service is shown in several recipes throughout [Chapter 12](text00129.html#page
    "Chapter 12. Web Services") , *Web Services* . We'll gloss over some details of
    the service so that we can focus on fetching configuration parameters from a variety
    of file-system locations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 示例将是一个为用户提供卡牌的网络服务。该服务在 [第12章](text00129.html#page "第12章 网络服务") 中的多个配方中都有展示，*网络服务*
    。我们将忽略服务的一些细节，以便专注于从各种文件系统位置获取配置参数。
- en: 'We''ll follow the design pattern of the **bash** shell, which looks for configuration
    files in several places:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循 **bash** shell 的设计模式，该模式在几个地方寻找配置文件：
- en: It starts with the `/etc/profile` file.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它始于 `/etc/profile` 文件。
- en: 'After reading that file, it looks for one of these files, in this order:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取该文件后，它会按照以下顺序寻找其中一个文件：
- en: '`~/.bash_profile` .'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`~/.bash_profile` 。'
- en: '`~/.bash_login` .'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`~/.bash_login` 。'
- en: '`~/.profile` .'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`~/.profile` 。'
- en: In a POSIX-compliant operating system, the shell expands the `~` to be the home
    directory for the logged-in user. This is defined as the value of the `HOME` environment
    variable. In general, the Python `pathlib` module can handle this automatically.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在符合POSIX的操作系统中，shell会将 `~` 扩展为已登录用户的主目录。这被定义为 `HOME` 环境变量的值。一般来说，Python的 `pathlib`
    模块可以自动处理这个问题。
- en: 'There are several ways to keep configuration parameters for a program:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以保存程序的配置参数：
- en: Using a class definition has the advantage of tremendous flexibility and a relatively
    simply Python syntax. It can use ordinary inheritance to include default values.
    It doesn't work as well when there are multiple sources of parameters because
    there's no trivial way to mutate a class definition.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类定义的优势在于极大的灵活性和相对简单的Python语法。它可以使用普通的继承来包含默认值。当参数有多个来源时，它的工作效果就不那么好，因为没有简单的方法来改变类定义。
- en: For a mapping parameter, we can then use the `ChainMap` collection to search
    multiple dictionaries, each from a different source.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于映射参数，我们可以使用 `collections` 模块中的 `ChainMap` 集合来搜索多个不同来源的字典。
- en: For the `SimpleNamespace` instance, the `types` module offers this class, which
    is mutable and can be updated from multiple sources.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `SimpleNamespace` 实例，`types` 模块提供了这个可变的类，可以从多个来源进行更新。
- en: A `Namespace` instance from the `argparse` module can be handy because it mirrors
    the options that come from the command-line.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`argparse` 模块中的 `Namespace` 实例可能很方便，因为它反映了来自命令行的选项。'
- en: The design pattern from the bash shell uses two separate files. When we include
    application-wide defaults, there are actually three levels of configuration. This
    can be done elegantly with a mapping and the `ChainMap` class from the `collections`
    module.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: bash shell 的设计模式使用了两个单独的文件。当我们包含应用程序范围的默认值时，实际上有三个配置级别。这可以通过映射和 `collections`
    模块中的 `ChainMap` 类来优雅地实现。
- en: 'In later recipes, we''ll look at ways to parse and process a configuration
    file. For the purposes of this recipe, we''ll assume that a function, `load_config_file()`
    , has been defined that will load a configuration map from the contents of the
    file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的配方中，我们将探讨解析和处理配置文件的方法。在本配方中，我们将假设已定义了一个名为 `load_config_file()` 的函数，该函数将从文件内容中加载配置映射：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We'll look at ways to implement this function separately. Variations on the
    implementation are covered in the  *Using YAML for configuration files*  and 
    *Using Python for configuration files*  recipes of this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别研究实现此功能的方法。本章还涵盖了实现的变体，包括 *使用YAML进行配置文件* 和 *使用Python进行配置文件* 配方。
- en: The `pathlib` module can help with this processing. This module provides the
    `Path` class definition that provides a great deal of sophisticated information
    about the OS's files. For more information, see the *Using pathlib to work with
    filenames* recipe in [Chapter 9](text00099.html#page "Chapter 9. Input/Output,
    Physical Format, and Logical Layout") , *Input/Output, Physical Format, Logical
    Layout* .
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`pathlib` 模块可以帮助处理这个问题。该模块提供了 `Path` 类的定义，可以提供有关操作系统文件的复杂信息。有关更多信息，请参阅 [第9章](text00099.html#page
    "第9章 输入/输出、物理格式和逻辑布局") 中的 *使用pathlib处理文件名* 配方，*输入/输出、物理格式、逻辑布局* 。'
- en: Why so many choices?
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么有这么多选择？
- en: There's a side-bar topic that sometimes arises when discussing this kind of
    design—Why have so many choices? Why not specify exactly two places?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论这种设计时，有时会出现一个侧边栏话题——为什么有这么多选择？为什么不明确指定两个地方？
- en: The answer depends on the context for the design. When creating an entirely
    new application, the choices can be limited to exactly two. However, when replacing
    legacy applications, it's common to have a new location that's better in some
    ways than the legacy location, but the legacy location still needs to be supported.
    After several such evolutionary changes, it's common to see a number of alternative
    locations for files.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 答案取决于设计的上下文。当创建一个全新的应用程序时，选择可能被限制在两个选项之间。然而，当替换遗留应用程序时，通常会有一个新的位置，在某些方面比遗留位置更好，但仍然需要支持遗留位置。经过几次这样的演变变化后，通常会看到一些文件的替代位置。
- en: Also, because of variations among Linux distributions, it's common to see variations
    that are typical for one distribution, but atypical for another. And, of course,
    when dealing with Windows, there will be variant file paths that are unique to
    that platform too.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于Linux发行版之间的差异，通常会看到对于一个发行版来说是典型的变化，但对于另一个发行版来说是非典型的变化。当处理Windows时，也会有独特于该平台的变体文件路径。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import the `Path` class and the `ChainMap` class:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`Path`类和`ChainMap`类：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define an overall function to get the configuration files:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个获取配置文件的整体函数：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create paths for the various locations. These are called pure paths because
    there''s no relationship with the file-system. They start as names of *potential*
    files:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为各种位置创建路径。这些被称为纯路径，因为它们与文件系统没有关系。它们起初是*潜在*文件的名称：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define the application''s built-in defaults:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义应用程序的内置默认值：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each individual configuration file is a mapping from key to value. The various
    mapping objects will form a list; this becomes the final `ChainMap` configuration
    mapping. We'll assemble the list of maps by appending items, and then reverse
    the order after the files are loaded.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个单独的配置文件都是从键到值的映射。各种映射对象将形成一个列表；这将成为最终的`ChainMap`配置映射。我们将通过追加项目来组装映射列表，然后在加载文件后反转顺序。
- en: 'If a system-wide configuration file exists, load this file:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在系统范围的配置文件，则加载该文件：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Iterate through other locations looking for a file to load. This loads the
    first of the files that it finds:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历其他位置，寻找要加载的文件。这会加载它找到的第一个文件：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We've included the **if-break** pattern to stop after the first file is found.
    This modifies the loop from the default semantics of For All to mean There Exists.
    See the Avoiding a potential problem with break statements recipe for more information.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了**if-break**模式，以在找到第一个文件后停止。这修改了循环的默认语义，从For All变为There Exists。有关更多信息，请参阅避免使用break语句配方中的潜在问题。
- en: 'Reverse the list and create the final `ChainMap` . The list needs to be reversed
    so that the local file is searched first, then the system settings, and finally
    the application default settings:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反转列表并创建最终的`ChainMap`。需要反转列表，以便首先搜索本地文件，然后是系统设置，最后是应用程序默认设置：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Return the final configuration mapping:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回最终的配置映射：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once we've built the `configuration` object, we can use the final configuration
    like a simple mapping. This object supports all of the expected dictionary operations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们构建了`configuration`对象，我们就可以像使用简单映射一样使用最终的配置。这个对象支持所有预期的字典操作。
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: One of the most elegant features of any object-oriented language is being able
    to create simple collections of objects. In this case, the objects are filesystem
    `Path` objects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 任何面向对象语言的最优雅的特性之一是能够创建简单的对象集合。在这种情况下，对象是文件系统`Path`对象。
- en: As noted in the *Using pathlib to work with file names* recipe in [Chapter 9](text00099.html#page
    "Chapter 9. Input/Output, Physical Format, and Logical Layout") , *Input/Output,
    Physical Format, Logical Layout* , the `Path` object has a `resolve()` method
    that can return a concrete `Path` built from a pure `Path` . In this recipe, we
    used the `exists()` method to determine if a concrete path could be built. The
    `open()` method, when used to read a file, will resolve the pure `Path` and open
    the associated file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[第9章](text00099.html#page "第9章.输入/输出、物理格式和逻辑布局")的*使用pathlib处理文件名*配方中所述，`Path`对象有一个`resolve()`方法，可以返回从纯`Path`构建的具体`Path`。在这个配方中，我们使用了`exists()`方法来确定是否可以构建一个具体路径。当用于读取文件时，`open()`方法将解析纯`Path`并打开相关文件。
- en: In the *Creating dictionaries – inserting and updating* recipe in [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structures
    – list, set, dict* , we looked at the basics of using a dictionary. Here we've
    combined several dictionaries into a chain. When a key is not located in the first
    dictionary of the chain, then later dictionaries in the chain are checked. This
    is a handy way to provide default values for each key in the mapping.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](text00048.html#page "第4章.内置数据结构-列表、集合、字典")的*创建字典-插入和更新*配方中，我们看了一下使用字典的基础知识。在这里，我们将几个字典合并成一个链。当一个键在链中的第一个字典中找不到时，会检查链中后面的字典。这是一种为映射中的每个键提供默认值的方便方法。
- en: 'Here''s an example of creating a `ChainMap` manually:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个手动创建`ChainMap`的示例：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `config` object is built from three separate mappings. The first might be
    details from a local file such as `~/.bash_login` . The second might be system-wide
    settings from the `/etc/profile` file. The third contains application-wide defaults.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`config`对象是从三个单独的映射构建而成的。第一个可能是来自本地文件的细节，比如`~/.bash_login`。第二个可能是来自`/etc/profile`文件的系统范围设置。第三个包含应用程序范围的默认值。'
- en: 'Here''s what we see when we query this object''s values:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查询这个对象的值时，我们会看到以下内容：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The value for any given key is taken from the first instance of that key in
    the chain of maps. This allows a very simple way to have local values that override
    system-wide values that override the built-in defaults.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何给定键的值都取自映射链中的第一个实例。这允许一种非常简单的方式来拥有覆盖系统范围值的本地值，覆盖内置默认值。
- en: There's more...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In the *Mocking External Resources* recipe in [Chapter 11](text00120.html#page
    "Chapter 11. Testing") , *Testing* , we looked at ways to mock external resources
    so that we could write a unit test that wouldn''t accidentally delete files. A
    test for the code in this recipe needs to mock the filesystem resources by mocking
    the `Path` class. Here''s how the unit test would look, starting with a high-level
    outline of the test class:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](text00120.html#page "Chapter 11. Testing")的*Mocking External Resources*配方中，我们讨论了模拟外部资源的方法，以便我们可以编写一个单元测试，而不会意外删除文件。这个配方中的代码的测试需要通过模拟`Path`类来模拟文件系统资源。下面是单元测试的高级概述：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This provides a boilerplate structure for a unit test. Mocking a `Path` becomes
    rather complex because of the number of distinct objects involved. Here''s a summary
    of what kinds of object creations occur:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这为单元测试提供了一个样板结构。由于涉及的不同对象数量，模拟`Path`变得相当复杂。以下是发生的各种对象创建的总结：
- en: 'A call to the `Path` class creates a `Path` object. The test process will create
    two `Path` objects, so we can use the `side_effect` feature to return each of
    these. We need to be sure that the values are in the correct order based on the
    code in the unit to be tested:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`Path`类的调用创建一个`Path`对象。测试过程将创建两个`Path`对象，因此我们可以使用`side_effect`特性返回每个对象。我们需要确保基于要测试的代码的正确顺序返回这些值：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For the value of `system_path` , there will be a call to a `Path` object `exists()`
    method; this will determine if the concrete file exists. There will then be calls
    to open the file and read the content:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`system_path`的值，将调用`Path`对象的`exists()`方法；这将确定具体文件是否存在。然后将调用打开文件并读取内容：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For the value of `home_path` , there will be a call to the `expanduser()` method
    to change the `~` to a proper home directory:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`home_path`的值，将调用`expanduser()`方法将`~`更改为正确的主目录：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The expanded `home_path` is then used with the `/` operator to create the three
    alternative directories:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`/`运算符将扩展的`home_path`与三个备用目录一起创建：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For the purposes of unit testing, we''ve decided that the first path to search
    doesn''t exist. The other two do exist, but we expect that only one of these will
    be read. The second will be ignored:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进行单元测试，我们决定第一个要搜索的路径不存在。其他两个存在，但我们期望只有一个会被读取。第二个将被忽略：
- en: 'For mock paths that don''t exist, we can use this:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不存在的模拟路径，我们可以使用这个：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For the mock paths that exist, we''ll have something more complex:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于存在的模拟路径，我们将有更复杂的东西：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We have to also handle the processing of the file via the `mock_open()` function
    in the mock module. This can handle all of the various details of files being
    used as context managers, something that becomes rather complex. The `with` statement
    requires `__enter__()` and `__exit__()` methods, which is handled by `mock_open()`
    .
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须通过模拟模块中的`mock_open()`函数来处理文件的处理。这可以处理文件作为上下文管理器使用的各种细节，这变得相当复杂。`with`语句需要`__enter__()`和`__exit__()`方法，这由`mock_open()`处理。
- en: 'We have to assemble each of these mock objects in reverse order. This assures
    that each variable is created before it''s used. Here''s the entire `setUp()`
    method showing the objects in the proper order:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须按照相反的顺序组装这些模拟对象。这样可以确保每个变量在使用之前都已经创建好了。下面是整个`setUp()`方法，显示了对象的正确顺序：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In addition to the mocks for `Path` manipulation, we've added one more mock
    module. The `mock_load` object is a stand-in for the undefined `load_config_file()`
    . We want to separate this test from the path processing, so the mock object uses
    the `side_effect` attribute to return two separate values, expecting that it will
    be invoked exactly twice.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对`Path`操作的模拟之外，我们还添加了一个模拟模块。`mock_load`对象是未定义的`load_config_file()`的替身。我们希望将这个测试与路径处理分开，因此模拟对象使用`side_effect`属性返回两个单独的值，期望它将被调用两次。
- en: 'Here are some of the tests that will confirm that the path search works as
    advertised. Each test starts by applying two patches to create a modified context
    for testing the `get_config()` function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些测试，将确认路径搜索是否按照广告进行。每个测试都从应用两个修补程序开始，以创建一个修改后的上下文，用于测试`get_config()`函数：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first use of `patch()` replaces the `Path` class with `self.mock_path` .
    The second use of `patch()` replaces the `load_config_file()` function with the
    `self.mock_load` function; this function will return two small configuration documents.
    In both cases, the context being patched is the current module, with the `__name__`
    value of `"__main__"` . In the cases where the unit test is in a separate module,
    then the module under test will be imported, and that module's name will be used.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`patch()`的第一个用法是用`self.mock_path`替换`Path`类。`patch()`的第二个用法是用`self.mock_load`函数替换`load_config_file()`函数；这个函数将返回两个小的配置文档。在这两种情况下，被修补的上下文是当前模块，`__name__`的值为`"__main__"`。在单元测试位于一个单独的模块的情况下，将导入被测试的模块，并使用该模块的名称。'
- en: 'We can check to see that the `load_config_file()` was called properly by examining
    the calls to `self.mock_load` . In this case, there should be one for each of
    the configuration files:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查对`self.mock_load`的调用来验证`load_config_file()`是否被正确调用。在这种情况下，每个配置文件应该有一个调用：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We've made sure that the `self.mock_system_path` file is checked first. Note
    the chain of calls—`Path()` returns a `Path` object. That object's `open()` must
    return a value that will be used as a context. The `__enter__()` method of a context
    is an object that will be used by the `load_config_file()` function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保首先检查`self.mock_system_path`文件。注意调用链——`Path()`返回一个`Path`对象。该对象的`open()`必须返回一个将被`load_config_file()`函数使用的值。上下文的`__enter__()`方法是`load_config_file()`函数将使用的对象。
- en: 'We''ve made sure that the other path is one for which the `exists()` method
    returns `True` . Here''s the check for the filenames that are built:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保另一个路径是`exists()`方法返回`True`的路径。这是构建文件名的检查：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `/` operator is implemented by the `__truediv__()` method. Each of the
    calls builds a separate the `Path` instance. We can confirm that overall, the `Path`
    object is used just twice. Once for the literal `''/etc/profile''` and once for
    the literal `''~''` :'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`/`运算符由`__truediv__()`方法实现。每次调用都会构建一个单独的`Path`实例。我们可以确认，总体上，`Path`对象只使用了两次。一次是用于字面量`''/etc/profile''`，一次是用于字面量`''~''`：'
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that two files answer `True` to the `exists()` method. We expect, however,
    that only one of those two will be checked. Once this is found, the second file
    will be ignored. Here''s a test that confirms that there''s only one check for
    existence:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，两个文件都对`exists()`方法返回`True`。然而，我们期望只有这两个文件中的一个会被检查。找到一个后，第二个文件将被忽略。以下是一个确认只有一个存在检查的测试：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Just to be complete, we''ve also checked that the file that exists will go
    through the entire context management sequence:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我们还检查了存在的文件是否会通过整个上下文管理序列：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first call is for the `self.exist` object's `open()` method. The return
    value from this is a context that will have the `__enter__()` method executed
    as well as the `__exit__()` method. In the preceding code, we checked that the
    return value from `__enter__()` is read to get the configuration file content.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用是为了`self.exist`对象的`open()`方法。从这里返回的是一个上下文，将执行`__enter__()`方法以及`__exit__()`方法。在前面的代码中，我们检查了从`__enter__()`返回的值是否被读取以获取配置文件内容。
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In the  *Using YAML for configuration files*  and *Using Python for configuration
    files*  recipes we'll look at ways to implement the `load_config_file()` function.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*使用YAML进行配置文件*和*使用Python进行配置文件*的方法中，我们将研究实现`load_config_file()`函数的方法。
- en: In the *Mocking external resources* recipe in [Chapter 11](text00120.html#page
    "Chapter 11. Testing") , *Testing* , we looked at ways to test functions such
    as this, which interact with external resources.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第11章](text00120.html#page "第11章。测试")的*模拟外部资源*方法中，我们研究了如何测试与外部资源交互的函数，比如这个函数。
- en: Using YAML for configuration files
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用YAML进行配置文件
- en: Python offers a variety of ways to package application inputs and configuration
    files. We'll look at writing files in YAML notation because it's elegant and simple.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了多种打包应用程序输入和配置文件的方式。我们将研究使用YAML符号写文件，因为它简洁而简单。
- en: How can we represent configuration details in YAML notation?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何用YAML符号表示配置细节？
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Python doesn''t have a YAML parser built in. We''ll need to add the `pyyaml`
    project to our library using the `pip` package management system. Here''s how
    the installation looks:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有内置的YAML解析器。我们需要使用`pip`软件包管理系统将`pyyaml`项目添加到我们的库中。安装的步骤如下：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The elegance of the YAML syntax is that simple indentation is used to show
    the structure of the document. Here''s an example of some settings that we might
    encode in YAML:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: YAML语法的优雅之处在于简单的缩进用于显示文档的结构。以下是我们可能在YAML中编码的一些设置的示例：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This document can be seen as a specification for a number of related URLs that
    are all similar to [http://forecast.weather.gov/shmrn.php?mz=ANZ532](http://forecast.weather.gov/shmrn.php?mz=ANZ532)
    . The document contains information about building the URL from a scheme, net
    location, base path, and several query strings. The `yaml.load()` function can
    load this YAML document; it will create the following Python structure:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文档可以被看作是一系列相关的URL的规范，它们都类似于[http://forecast.weather.gov/shmrn.php?mz=ANZ532](http://forecast.weather.gov/shmrn.php?mz=ANZ532)。文档包含了有关从方案、网络位置、基本路径和几个查询字符串构建URL的信息。`yaml.load()`函数可以加载这个YAML文档；它将创建以下Python结构：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This *dict-of-dict* structure can be used by an application to tailor its operations.
    In this case, it specifies a sequence of URLs to be queried to assemble a larger
    weather briefing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*字典-字典*结构可以被应用程序用来定制其操作。在这种情况下，它指定了一个要查询的URL序列，以组装更大的天气简报。
- en: We'll often use the *Finding configuration files*  recipe to check a variety
    of locations for finding a given configuration file. This flexibility is often
    essential for creating an application that's easily used on a variety of platforms.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用*查找配置文件*的方法来检查各种位置以找到给定的配置文件。这种灵活性通常对于创建一个可以轻松在各种平台上使用的应用程序至关重要。
- en: 'In this recipe, we''ll build the missing part of the previous example, the
    `load_config_file()` function. Here''s the template that needs to be filled in:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们将构建前一个示例中缺失的部分，即`load_config_file()`函数。以下是需要填写的模板：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Import the `yaml` module:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`yaml`模块：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Use the `yaml.load()` function to load the YAML-syntax document:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`yaml.load()`函数加载YAML语法文档：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The YAML syntax rules are defined at [http://yaml.org](http://yaml.org) . The
    idea of YAML is to provide JSON-like data structures with more flexible, human-friendly
    syntax. JSON is a special case of the more general YAML syntax.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: YAML语法规则在[http://yaml.org](http://yaml.org)中定义。YAML的理念是提供具有更灵活、人性化语法的类似JSON的数据结构。JSON是更一般的YAML语法的特例。
- en: The trade-off here is that some spaces and line breaks in JSON don't matter—there
    is visible punctuation to show the structure of the document. In some of the YAML
    variants, line breaks and indentation determine the structure of the document;
    the use of white-space means that line breaks will matter with YAML documents.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的权衡是，JSON中的一些空格和换行不重要——有可见的标点来显示文档的结构。在一些YAML变体中，换行和缩进决定了文档的结构；使用空格意味着YAML文档中的换行很重要。
- en: 'The principle data structures available in JSON syntax are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: JSON语法中可用的主要数据结构如下：
- en: '**Sequence** : `[item, item, ...]`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列**：`[item, item, ...]`'
- en: '**Mapping** : `{key: value, key: value, ...}`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**：`{key: value, key: value, ...}`'
- en: '**Scalar** :'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标量**：'
- en: 'String: `"value"`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：`"value"`
- en: 'Number: `3.1415926`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字：`3.1415926`
- en: 'Literal: `true` , `false` , and `null`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字面值：`true`，`false`和`null`
- en: JSON syntax is one style of YAML; it's a called flow style. In this style, the
    document structure is marked by explicit indicators. The syntax requires `{…}`
    and `[…]` to show the structure.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: JSON语法是YAML的一种风格；它被称为流风格。在这种风格中，文档结构由显式指示符标记。语法要求使用`{...}`和`[...]`来显示结构。
- en: 'The alternative that YAML offers is block style. The document structure is
    defined by line breaks and indentation. Furthermore, long string scalar values
    can use plain, quoted, and folded styles of syntax. Here is how the alternative
    YAML syntax works:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: YAML提供的另一种选择是块样式。文档结构由换行和缩进定义。此外，长字符串标量值可以使用普通、带引号和折叠样式的语法。以下是替代YAML语法的工作方式：
- en: '**Block sequence** : We preface each line of a sequence with a -. This looks
    like a bullet list, and is easy to read. Here''s an example:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块序列**：我们用-在序列的每一行前面加上。这看起来像一个项目列表，很容易阅读。这是一个例子：'
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When loaded, this will create a dictionary with a list of strings in Python:
    `{zoneid: [''ANZ532'', ''AMZ117'', ''AMZ080'']}` .'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '加载后，这将在Python中创建一个带有字符串列表的字典：`{zoneid: [''ANZ532'', ''AMZ117'', ''AMZ080'']}`。'
- en: '**Block mapping** : We can use simple `key: value` syntax to associate a key
    with a simple scalar. We can use `key:` on a line by itself; the value is indented
    on the following lines. Here''s an example:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块映射**：我们可以使用简单的`key: value`语法将键与简单的标量关联起来。我们可以单独在一行上使用`key:`；值缩进在下面的行上。这是一个例子：'
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This creates a nested dictionary that looks like this in Python: `{''url'':
    {''scheme'': ''http'', ''netloc'': ''marine.weather.gov''}}` .'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '这将创建一个嵌套字典，在Python中看起来像这样：`{''url'': {''scheme'': ''http'', ''netloc'': ''marine.weather.gov''}}`。'
- en: 'We can also use explicit key and value markers, `?` and `:` . This can help
    when the keys are particularly long strings or more complex objects:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用显式的键和值标记`?`和`:`。当键特别长或对象更复杂时，这可能有所帮助：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Some more advanced features of YAML will make use of this explicit separation
    between key and value:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: YAML的一些更高级功能将利用键和值之间的显式分隔：
- en: For short string scalar values, we can leave them plain, and the YAML rules
    will simply use all the characters with leading and trailing white-space stripped
    away. The examples all use this kind of assumption for string values.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于短字符串标量值，我们可以保持它们的普通状态，YAML规则将简单地使用所有字符，并去除前导和尾随空格。这些示例都使用了这种假设的字符串值。
- en: Quotes can be used for strings, exactly as they are in JSON.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引号可以用于字符串，就像在JSON中一样。
- en: For longer strings, YAML introduces the `|` prefix; the lines after this are
    preserved with all of the spacing and newlines intact.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于较长的字符串，YAML引入了`|`前缀；在此之后的行将保留所有的间距和换行符。
- en: It also introduces the `>` prefix, which preserves the words as a long string
    of text—any newlines are treated as single white-space characters. This is common
    for running text.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 它还引入了`>`前缀，将单词保留为一长串文本——任何换行符都被视为单个空格字符。这在连续文本中很常见。
- en: In both cases, the indentation determines how much of the document is part of
    the text.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，缩进决定了文档的哪部分是文本的一部分。
- en: In some cases, the value may be ambiguous. For example, a US ZIP code is all
    digits—`22102` . This should be understood as a string, even though the YAML rules
    will interpret it as a number. Quotes, of course, can be helpful. To be more explicit,
    a local tag of `!!str` in front of the value will force a specific data type.
    `!!str 22102` , for example, assures that the digits will be treated as a string
    object.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，值可能是模棱两可的。例如，美国的邮政编码都是数字——`22102`。尽管YAML规则会将其解释为数字，但应该理解为字符串。当然，引号可能会有所帮助。为了更明确，可以在值的前面使用`!!str`本地标签来强制指定数据类型。例如，`!!str
    22102`确保数字将被视为字符串对象。
- en: There's more...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are a number of additional features in YAML that are not present in JSON:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: YAML中有一些JSON中没有的其他功能：
- en: The comments, which begin with `#` and continue to the end of the line. They
    can go almost anywhere. JSON doesn't tolerate comments.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释以`#`开头，一直延续到行尾。它们几乎可以放在任何地方。JSON不允许注释。
- en: The document start, which is indicated by the `---` line at the start of a new
    document. This allows a YAML file to contain many individual objects. JSON is
    limited to a single document per file. The alternative to one document-per-file
    is somewhat a more complex parsing algorithm. YAML provides an explicit document
    separator and a very simple parsing interface.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档开始，由新文档开头的`---`行指示。这允许一个YAML文件包含许多单独的对象。JSON限制每个文件只能有一个文档。一个文档-每个文件的替代方案是一个更复杂的解析算法。YAML提供了显式的文档分隔符和一个非常简单的解析接口。
- en: 'The YAML file with two separate documents:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有两个单独文档的YAML文件：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `yaml_text` value contains two YAML documents, each of which starts with
    `---` . The `load_all()` function is an iterator that loads the documents one
    at a time. An application must iterate over the results of this to process each
    of the documents in the stream.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yaml_text`值包含两个YAML文档，每个文档都以`---`开头。`load_all()`函数是一个迭代器，一次加载一个文档。应用程序必须迭代处理流中的每个文档的结果。'
- en: Document end. A `...` line is the end of a document.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档结束。`...`行是文档的结束。
- en: Complex keys for mappings; JSON mapping keys are limited to the available scalar
    types—string, number, `true` , `false` , and `null` . YAML allows mapping keys
    to be considerably more complex.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射的复杂键；JSON映射键仅限于可用的标量类型——字符串、数字、`true`、`false`和`null`。YAML允许将映射键设置得更复杂。
- en: 'What''s important is that Python requires a hash able, immutable object for
    a mapping key. This means that a complex key must be transformed into an immutable
    Python object, generally a `tuple` . In order to create a Python-specific object,
    we need to use a more complex local tag. Here''s an example:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的是，Python要求映射键的哈希表是不可变的对象。这意味着复杂的键必须转换为不可变的Python对象，通常是`tuple`。为了创建一个特定于Python的对象，我们需要使用更复杂的本地标签。以下是一个例子：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This example uses `?` and `:` to mark the key and value of a mapping. We've
    done this because the key is a complex object. The key `value` uses a local tag,
    `!!python/tuple` , to create a tuple instead of the default, which would have
    been a `list` . The text of the key uses a flow-type YAML value, `["a", "b"]`
    .
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个例子使用`?`和`:`来标记映射的键和值。我们这样做是因为键是一个复杂对象。键`value`使用了一个本地标签`!!python/tuple`，来创建一个元组，而不是默认的`list`。键的文本使用了一个流类型的YAML值`["a",
    "b"]`。
- en: JSON has no provision for a set. YAML allows us to use the `!!set` tag to create
    a set instead of a simple sequence. The items in the set are identified by a `?`
    prefix because they are considered keys of a mapping for which there are no values.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON没有集合的规定。YAML允许我们使用`!!set`标签来创建一个集合，而不是一个简单的序列。集合中的项目以`?`前缀标识，因为它们被认为是一个映射的键，没有值。
- en: 'Note that the `!!set` tag is at the same level of indentation as the values
    within the set collection. It''s indented inside the dictionary key of `data_values`
    :'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，`!!set`标签与集合中的值处于相同的缩进级别。它在`data_values`的字典键内缩进：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `!!set` local tag modifies the following sequence to become a `set` object
    instead of the default list object. The resulting set is equal to the expected
    Python set object, `{'some', 'more', 'words'}` .
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!!set`本地标签修改以下序列，使其成为一个`set`对象，而不是默认的列表对象。结果集等于预期的Python集合对象`{''some'', ''more'',
    ''words''}`。'
- en: Python mutable object rules will have to be applied to the contents of a set.
    It's impossible to build a set of `list` objects because list instances don't
    have hash values. The `!!python/tuple` local tag will have to be used to build
    a set of tuples.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python可变对象规则将被应用于集合的内容。无法构建一个包含`list`对象的集合，因为列表实例没有哈希值。必须使用`!!python/tuple`本地标签来构建一个元组集合。
- en: 'We can create a Python list-of-two-tuples sequence, as well which implements
    ordered mapping. The `yaml` module doesn''t readily create an `OrderedDict` for
    us:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以创建一个Python的两元组列表序列，它实现了有序映射。`yaml`模块不会为我们直接创建`OrderedDict`：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that it's difficult to take the next step and create an `OrderedDict` from
    this without specifying a large number of details. Here's the YAML to create an
    instance of `OrderedDict` .
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，很难在不指定大量细节的情况下，进一步创建`OrderedDict`。以下是创建`OrderedDict`实例的YAML。
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `args` keyword is required to support the `!!python/object/apply` tag. There's
    only one positional argument, and it's a YAML `!!omap` built from a sequence of
    keys and values.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`关键字是必需的，以支持`!!python/object/apply`标签。只有一个位置参数，它是一个从键和值序列构建的YAML`!!omap`。'
- en: Python objects of almost any class can be built using YAML local tags. Any class
    with a simple `__init__()` method can be built from a YAML serialization.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎任何类的Python对象都可以使用YAML本地标签来构建。任何具有简单`__init__()`方法的类都可以从YAML序列化中构建。
- en: 'Here''s a simple class definition:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的类定义：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We''ve defined a class with two positional attributes. Here''s the YAML description
    of this object:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个具有两个位置属性的类。以下是该对象的YAML描述：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We've used the `kwds` key to provide two keyword-based argument values to the
    `Card` constructor function. The Unicode `♣` character works well because YAML
    files are text written using UTF-8 encoding.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`kwds`键为`Card`构造函数提供了两个基于关键字的参数值。Unicode`♣`字符很好用，因为YAML文件是使用UTF-8编码的文本。
- en: In addition to local tags, which start with `!!` , YAML also supports tags that
    are URIs using the `tag:` scheme. This allows URI-based type specifications that
    are globally unique. This can make YAML documents easier to process in a variety
    of contexts.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了以`!!`开头的本地标签之外，YAML还支持使用`tag:`方案的URI标签。这允许使用基于URI的类型规范，这些规范在全局范围内是唯一的。这可以使YAML文档在各种上下文中更容易处理。
- en: A tag includes an authority name, a date, and specific details in the form of
    a `/` -delimited path. For example, a tag might look like this—`!<tag:www.someapp.com,2016:rules/rule1>`
    .
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 标签包括权限名称、日期和具体细节，以`/`分隔的路径形式。例如，一个标签可能看起来像这样——`!<tag:www.someapp.com,2016:rules/rule1>`。
- en: See also
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Finding configuration files* recipe to see how to search multiple file-system
    locations for a configuration file. We can easily have application defaults, system-wide
    settings, and personal settings built into separate files and combined by an application
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看*查找配置文件*配方，了解如何在多个文件系统位置搜索配置文件。我们可以很容易地将应用程序默认值、系统范围的设置和个人设置构建到单独的文件中，并由应用程序组合。
- en: '![](image/614271.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](image/614271.jpg)'
- en: Using Python for configuration files
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行配置文件
- en: Python offers a variety of ways that we can package application inputs and configuration
    files. We'll look at writing files in Python notation because it's elegant and
    simple.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了多种打包应用程序输入和配置文件的方式。我们将看一下使用Python符号写文件，因为它既优雅又简单。
- en: A number of packages use assignment statements in a separate module for providing
    configuration parameters. The Flask project in particular, can do this. We looked
    at Flask in the *Using the Flask framework for RESTful APIs* recipe and a number
    of related recipes in [Chapter 12](text00129.html#page "Chapter 12. Web Services")
    , *Web Services* .
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 许多包使用单独的模块中的赋值语句来提供配置参数。特别是Flask项目可以这样做。我们在*使用Flask框架进行RESTful API*配方中看到了Flask，以及[第12章](text00129.html#page
    "第12章 网络服务")中的一些相关配方，*网络服务*。
- en: How can we represent configuration details in Python module notation?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何用Python模块符号表示配置细节？
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Python assignment statement notation is particularly elegant. It's quite simple,
    easy to read, and extremely flexible. If we use assignment statements, we can
    import the configuration details from a separate module. This could have a name
    like `settings.py` to shows that it's focused on configuration parameters.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Python赋值语句符号特别优雅。它非常简单，易于阅读，而且非常灵活。如果我们使用赋值语句，可以从一个单独的模块中导入配置细节。这个模块可以有一个名字，比如`settings.py`，以显示它专注于配置参数。
- en: Because Python treats each imported module as a global **Singleton** object,
    we can have several parts of an application all use the `import settings` statement
    to get a consistent view of the current, global application configuration parameters.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Python将每个导入的模块视为全局**单例**对象，所以我们可以让应用程序的几个部分都使用`import settings`语句来获得当前全局应用程序配置参数的一致视图。
- en: In some cases, however, we might want to choose one of several alternative settings
    files. In this case, we want to load a file using a technique that's more flexible
    than the `import` statement.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，我们可能希望选择几个备选的设置文件之一。在这种情况下，我们希望使用比`import`语句更灵活的技术来加载文件。
- en: 'We''d like to be able to provide definitions in a text file that look like
    this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够在文本文件中提供以下形式的定义：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is Python syntax. The parameters include two variables, `query` and `url.`
    The value of the `query` variable is a dictionary with a single key, `mz` , and
    a sequence of values.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Python语法。参数包括两个变量，`query`和`url`。`query`变量的值是一个带有单个键`mz`和一系列值的字典。
- en: This can be seen as a specification for a number of related URLs that are all
    similar to [http://forecast.weather.gov/shmrn.php?mz=ANZ532](http://forecast.weather.gov/shmrn.php?mz=ANZ532)
    .
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以看作是一系列相关的URL的规范，它们都类似于[http://forecast.weather.gov/shmrn.php?mz=ANZ532](http://forecast.weather.gov/shmrn.php?mz=ANZ532)。
- en: We'll often use the *Finding configuration files* recipe to check a variety
    of locations for finding a given configuration file. This flexibility is often
    essential for creating an application that's easily used on a variety of platforms.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用*查找配置文件*配方来检查各种位置以找到给定的配置文件。这种灵活性通常对于创建一个在各种平台上易于使用的应用程序是至关重要的。
- en: 'In this recipe, we''ll build the missing part of the previous example, the
    `load_config_file()` function. Here''s the template that needs to be filled in:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将构建前面示例中缺失的部分，即`load_config_file()`函数。这是需要填写的模板：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This code replaces the `# Details omitted.` line in the `load_config_file()`
    function:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码替换了`load_config_file()`函数中的`# Details omitted.`行：
- en: 'Compile the code in the configuration file using the built-in `compile()` function.
    This function requires the source text as well as a filename from which the text
    was read. The filename is essential for creating trace-back messages that are
    useful and correct:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内置的`compile()`函数编译配置文件中的代码。这个函数需要源文本以及从中读取文本的文件名。文件名对于创建有用和正确的回溯消息是必不可少的：
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In rare cases where the code doesn't come from a file, the general practice
    is to provide a name such as `<string>`  instead of a filename.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在罕见的情况下，代码不是来自文件时，一般的做法是提供一个名字，比如`<string>`，而不是文件名。
- en: 'Execute the code object created by the `compile()` function. This requires
    two contexts. The global context provides any previously imported modules, plus
    the `__builtins__` module. The local context is where new variables will be created:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`compile()`函数创建的代码对象。这需要两个上下文。全局上下文提供了任何先前导入的模块，以及`__builtins__`模块。本地上下文是新变量将被创建的地方：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When code is executed at the very top level of a script file—often inside the
    `if __name__ == "__main__"` condition—it executes in a context where globals and
    locals are the same. When code is executed inside a function, method, or class
    definition, the locals for that context are separate from the globals.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当代码在脚本文件的顶层执行时——通常在`if __name__ == "__main__"`条件内部执行——它在全局和本地是相同的上下文中执行。当代码在函数、方法或类定义内部执行时，该上下文的本地变量与全局变量是分开的。
- en: By creating a separate `locals` object, we've made sure that the imported statements
    don't make unexpected changes to any other global variables.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个单独的`locals`对象，我们确保导入的语句不会对任何其他全局变量进行意外更改。
- en: How it works...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The details of the Python language; syntax and semantics are embodied in the
    `compile()` and `exec()` functions. When we launch a script, the process is essentially
    this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言的细节，语法和语义都体现在`compile()`和`exec()`函数中。当我们启动一个脚本时，过程基本上是这样的：
- en: Read the text. Compile it with the `compile()` function to create a code object.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读文本。使用`compile()`函数编译它以创建一个代码对象。
- en: Use the `exec()` function to execute that code object.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`exec()`函数来执行该代码对象。
- en: The `__pycache__` directory holds code objects, and saves recompiling text files
    that haven't changed. It doesn't have a material impact on the processing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`__pycache__`目录保存代码对象，并保存未更改的文本文件的重新编译。这对处理没有实质影响。'
- en: The `exec()` function reflects the way Python handles global and local variables.
    There are two namespaces provided to this function. These are visible to a script
    that's running via the `globals()` and `locals()` functions.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec()`函数反映了Python处理全局和本地变量的方式。这个函数提供了两个命名空间。这些对于通过`globals()`和`locals()`函数运行的脚本是可见的。'
- en: 'We provided two distinct dictionaries:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了两个不同的字典：
- en: A dictionary of global objects. These variables can be accessed via the `global`
    statement. The most common use is to provide access to the imported modules, which
    are always global. The `__builtins__` module, for example, is often provided.
    In some cases, other modules should be added.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局对象的字典。这些变量可以通过`global`语句访问。最常见的用法是提供对导入模块的访问，这些模块始终是全局的。例如，通常会提供`__builtins__`模块。在某些情况下，可能需要添加其他模块。
- en: The dictionary provided for the locals is updated by each assignment statement.
    This local dictionary allows us to capture the variables created within the `settings`
    module.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地提供的字典会被每个赋值语句更新。这个本地字典允许我们捕获在`settings`模块内创建的变量。
- en: There's more...
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe builds a configuration file that can be entirely a sequence of `name
    = value` assignments. This statement is supported directly by the Python assignment
    statement syntax.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方构建了一个配置文件，可以完全是一系列`name = value`赋值。这个语句直接由Python赋值语句语法支持。
- en: Additionally, the full spectrum of Python programming is available. There are
    a number of engineering trade-offs that must be made.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Python编程的全部范围都是可用的。必须做出许多工程上的权衡。
- en: Any statement can be used in the configuration file. However, this can lead
    to complexity. If the processing becomes too complex, the file ceases to be configuration,
    and becomes a first-class part of the application. Very complex features should
    be done by modifying the application programming, not hacking around with the
    configuration settings. Since Python applications include the source, this is
    relatively easy to do.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件中可以使用任何语句。但这可能会导致复杂性。如果处理变得太复杂，文件就不再是配置文件，而成为应用程序的一部分。非常复杂的功能应该通过修改应用程序编程来完成，而不是通过配置设置进行操作。由于Python应用程序包括源代码，这相对容易做到。
- en: In addition to the simple assignment statement, it can be sensible to use `if`
    statements to handle alternatives. A file might provide a section for unique features
    of a specific run-time environment. For example, the `platform` package can be
    used to isolate features.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的赋值语句之外，使用`if`语句处理替代方案也是有道理的。文件可能提供一个特定运行时环境的独特特性部分。例如，`platform`包可以用于隔离特性。
- en: 'Something like this might be included:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 可能包括类似于这样的内容：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For this to work, the globals should include `platform` and `Path` . This a
    reasonable extension above and beyond `__builtins__` .
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个工作，全局变量应该包括`platform`和`Path`。这是对`__builtins__`的合理扩展。
- en: 'It can also be sensible to do some processing simply to make a number of related
    settings easier to organize. For example, an application might have a number of
    related files. It can be helpful to write a configuration file like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地进行一些处理也是有道理的，以便更容易地组织一些相关的设置。例如，一个应用程序可能有一些相关的文件。编写这样的配置文件可能会有所帮助：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The values of `log` and `out` are used by the application. The value of `base`
    is only used to assure that the other two locations are placed in the same directory.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`log`和`out`的值被应用程序使用。`base`的值仅用于确保其他两个位置放置在同一个目录中。'
- en: 'This leads to the following variation on the `load_config_file()` function
    shown earlier. This version includes some additional modules and global classes:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了对之前显示的`load_config_file()`函数的以下变化。这个版本包括一些额外的模块和全局类：
- en: '[PRE47]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Including `Path` and `platform` means that a configuration file can be written
    without the overhead of `import` statements. This can make the settings simpler
    to prepare and maintain.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 包括`Path`和`platform`意味着可以编写配置文件而无需`import`语句的开销。这可以使设置更容易准备和维护。
- en: See also
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: See the *Finding configuration files* recipe to learn how to search multiple
    file-system locations for a configuration file.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见*查找配置文件*配方，了解如何搜索多个文件系统位置以查找配置文件。
- en: Using class-as-namespace for configuration
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类作为命名空间进行配置
- en: Python offers a variety of ways for packaging application inputs and configuration
    files. We'll look at writing files in Python notation because it's elegant and
    simple.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了各种打包应用程序输入和配置文件的方法。我们将研究使用Python符号写文件，因为它既优雅又简单。
- en: A number of projects allow the use of a class definition for providing configuration
    parameters. The use of a class hierarchy means that inheritance techniques can
    be used to simplify organization of parameters. The Flask package in particular,
    can do this. We looked at Flask in the recipe,  *Using the Flask framework for
    RESTful APIs* , and a number of related recipes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 许多项目允许使用类定义来提供配置参数。类层次结构的使用意味着可以使用继承技术来简化参数的组织。特别是Flask包可以做到这一点。我们在配方*使用Flask框架进行RESTful
    API*以及一些相关的配方中看到了Flask。
- en: How can we represent configuration details in Python class notation?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在Python类符号中表示配置细节？
- en: Getting ready
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Python notation for defining the attributes of a class is particularly elegant.
    It's quite simple, easy to read, and reasonably flexible. We can, with little
    work, define a sophisticated configuration language that allows someone to change
    configuration parameters for a Python application quickly and reliably.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Python用于定义类属性的符号特别优雅。它非常简单，易于阅读，并且相当灵活。我们可以很容易地定义一个复杂的配置语言，允许某人快速可靠地更改Python应用程序的配置参数。
- en: We can base this language on class definitions. This allows us to package a
    number of configuration alternatives in a single module. An application can load
    the module and pick the relevant class definition from the module.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以基于类定义构建这种语言。这允许我们在单个模块中打包多个配置选项。应用程序可以加载模块并从模块中选择相关的类定义。
- en: 'We''d like to be able to provide definitions that look like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够提供以下类似的定义：
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can create this `Configuration` class in a single `settings` module. To
    use the configuration, the main application will do this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在单个`settings`模块中创建这个`Configuration`类。要使用配置，主应用程序将执行以下操作：
- en: '[PRE49]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This uses a fixed file with a fixed class name. In spite of the apparent lack
    of flexibility, this can often be more useful than other alternatives. We have
    two additional ways to support complex configuration files:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用一个固定的文件和一个固定的类名。尽管看起来缺乏灵活性，但这通常比其他选择更有用。我们有两种额外的方法来支持复杂的配置文件：
- en: We can use the `PYTHONPATH` environment variable to list a number of locations
    for a configuration module
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`PYTHONPATH`环境变量列出配置模块的多个位置。
- en: Use multiple inheritance and mix ins to combine defaults, system-wide settings,
    and localized settings into a configuration class definition
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多重继承和混合来将默认值、系统范围的设置和本地设置合并到配置类定义中
- en: These techniques can be helpful because the configuration file locations simply
    follow Python's rules for finding modules. We don't need to implement our own
    search for the configuration files.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术可能有所帮助，因为配置文件位置只需遵循Python查找模块的规则。我们不需要实现自己的搜索配置文件的方法。
- en: 'In this recipe, we''ll build the missing part of the previous example, the
    `load_config_file()` function. Here''s the template that needs to be filled in:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将构建前一个示例中缺失的部分，即`load_config_file()`函数。以下是需要填写的模板：
- en: '[PRE50]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How to do it...
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'This code replaces the `# Details omitted.` line in the `load_config_file()`
    function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码替换了`load_config_file()`函数中的`# Details omitted.`行：
- en: 'Compile the code in the given file using the built-in `compile()` function.
    This function requires the source text as well as a filename from which the text
    was read. The filename is essential for creating trace-back messages that are
    useful and correct:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内置的`compile()`函数编译给定文件中的代码。这个函数需要源文本以及从中读取文本的文件名。文件名对于创建有用和正确的回溯消息是必不可少的：
- en: '[PRE51]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Execute the code object created by the `compile()`  method. We need to provide
    two contexts. The global context can provide the `__builtins__` module, plus the
    `Path` class and the `platform` module. The local context is where new variables
    will be created:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`compile()`方法创建的代码对象。我们需要提供两个上下文。全局上下文可以提供`__builtins__`模块，以及`Path`类和`platform`模块。本地上下文是新变量将被创建的地方：
- en: '[PRE52]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This returns only the defined `Configuration` class from the locals which are
    set by the executed module. Any other variables will be ignored.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这只会从执行模块设置的本地变量中返回定义的`Configuration`类。任何其他变量都将被忽略。
- en: How it works...
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The details of the Python language—syntax and semantics—are embodied in the
    `compile()` and `exec()` functions. The `exec()` function reflects the way Python
    handles global and local variables. There are two namespaces provided to this
    function. The global `namespace` instance includes `__builtins__` plus a class
    and module that might be used in the file.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言的细节——语法和语义——体现在`compile()`和`exec()`函数中。`exec()`函数反映了Python处理全局和本地变量的方式。这个函数提供了两个命名空间。全局`namespace`实例包括`__builtins__`以及可能在文件中使用的类和模块。
- en: The local variable namespace will have the new class created in it. This namespace
    has a `__dict__` attribute that makes it accessible via dictionary methods. Because
    of this, we can then extract the class by name. The function returns the class
    object for use throughout the application.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本地变量命名空间将有新创建的类。这个命名空间有一个`__dict__`属性，使其可以通过字典方法访问。因此，我们可以通过名称提取类。该函数返回类对象，供整个应用程序使用。
- en: We can put any kind of object into the attributes of a class. Our example showed
    mapping objects. There's no limitation on what can be done when creating attributes
    at the class level.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任何类型的对象放入类的属性中。我们的示例展示了映射对象。在创建类级别的属性时，没有任何限制。
- en: We can have complex calculations within the `class` statement. We can use this
    to create attributes which are derived from other attributes. We can execute any
    kind of statement, including `if` statements and `for` statements to create attribute
    values.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`class`语句内进行复杂的计算。我们可以利用这一点创建从其他属性派生的属性。我们可以执行任何类型的语句，包括`if`语句和`for`语句来创建属性值。
- en: There's more...
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Using a class definition means that we can leverage inheritance to organize
    the configuration values. We can easily create multiple subclasses of `Configuration`
    , one of which will be selected for use in the application. The configuration
    might look like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类定义意味着我们可以利用继承来组织配置值。我们可以轻松创建`Configuration`的多个子类，其中一个将被选中用于应用程序。配置可能如下所示：
- en: '[PRE53]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This means that our application must choose an appropriate class from the available
    classes in the `settings` module. We might use an OS environment variable or a
    command-line option to specify the class name to use. The idea is that our program
    is executed like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的应用程序必须从`settings`模块中的可用类中选择一个合适的类。我们可以使用操作系统环境变量或命令行选项来指定要使用的类名。这个想法是我们的程序是这样执行的：
- en: '[PRE54]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This would locate the `Chesapeake` class in the `settings` module. Processing
    would then be based on the details in that particular configuration class. This
    idea leads to an extension to the `load_config_file()` function.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`settings`模块中找到`Chesapeake`类。然后处理将基于该特定配置类中的细节。这个想法导致了`load_config_file()`函数的扩展。
- en: 'In order to pick one of the available classes, we''ll provide an additional
    parameter with the class name:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了选择可用类中的一个，我们将提供一个额外的参数，其中包含类名：
- en: '[PRE55]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Rather than manually compile and execute the module, we've used the higher-level
    `importlib` module. This module implements the `import` statement semantics. The
    requested module is imported; compiled and executed—and the resulting module object
    assigned to the variable name `settings_module` .
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有手动编译和执行模块，而是使用了更高级别的`importlib`模块。该模块实现了`import`语句的语义。请求的模块被导入；编译和执行——并将生成的模块对象分配给变量名`settings_module`。
- en: We can then look inside the module's variables and pick out the class that was
    requested. The `vars()` built-in function will extract the internal dictionary
    from a module, class, or even the local variables.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以查看模块的变量并挑选出所请求的类。`vars()`内置函数将从模块、类甚至本地变量中提取内部字典。
- en: 'Now we can use this function as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以按照以下方式使用这个函数：
- en: '[PRE56]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We've located the `Chesapeake` configuration class in the `settings` module.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`settings`模块中找到了`Chesapeake`配置类。
- en: Configuration representation
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置表示
- en: 'One consequence of using a class like this is that the default display for
    a class isn''t too informative. When we try to print the configuration, it looks
    like this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似这样的类的一个后果是，类的默认显示并不是太有信息。当我们尝试打印配置时，它看起来像这样：
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is nearly useless. It provides one nugget of information, but that's not
    nearly enough for debugging.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎没有用。它提供了一小部分信息，但这远远不够用于调试。
- en: 'We can use the `vars()` function to see more details. However, this shows local
    variables, not inherited variables:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`vars()`函数查看更多细节。但是，这显示的是本地变量，而不是继承的变量：
- en: '[PRE58]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is better, but still incomplete.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做更好，但仍然不完整。
- en: In order to see all of the settings, we need something a little more sophisticated.
    Interestingly, we can't simply define `__repr__()` for this class. A method defined
    in a class will apply to the instances of this class, not the class itself.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看所有设置，我们需要更复杂的东西。有趣的是，我们不能简单地为这个类定义`__repr__()`。在类中定义的方法将适用于该类的实例，而不是类本身。
- en: Each class object we create is an instance of the built-in `type` class. We
    can, using a meta-class, tweak the way the `type` class behaves, and implement
    a slightly nicer `__repr__()` method, which looks through all parent classes for
    attributes.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的每个类对象都是内置`type`类的实例。我们可以使用元类调整`type`类的行为方式，并实现一个稍微更好的`__repr__()`方法，该方法查找所有父类的属性。
- en: 'We''ll extend the built-in type with a `__repr__` that does a somewhat better
    job at displaying the working configuration:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个`__repr__`扩展内置类型，该类型在显示工作配置时做得更好一些：
- en: '[PRE59]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The class name is available from the superclass, `type` , as the `__name__`
    attribute. The names of the base classes are included as well, to show the inheritance
    hierarchy for this configuration class.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 类名可以从超类`type`中的`__name__`属性中获得。基类的名称也包括在内，以显示此配置类的继承层次结构。
- en: The `base_values` are built from the attributes of all of the base classes.
    Each class is examined in reverse order of the **Method Resolution Order** ( **MRO**
    ). Loading all of the attribute values in reverse MRO means that all of the defaults
    are loaded first, then overridden with subclass values.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`base_values`是从所有基类的属性构建的。每个类按照**方法解析顺序**（**MRO**）的相反顺序进行检查。按照反向MRO加载所有属性值意味着首先加载所有默认值，然后用子类值覆盖。'
- en: The names that lack the `_` prefix are included. Names with the `_` prefix are
    quietly ignored.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 不包含`_`前缀的名称被包括在内。具有`_`前缀的名称被悄悄地忽略。
- en: The resulting values are used to create a text representation that resembles
    a class definition. It's not the original class source code; it's the net effect
    of the original class definition.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的值用于创建类似类定义的文本表示。这不是原始类源代码；这是原始类定义的净效果。
- en: 'Here''s a `Configuration` class hierarchy that uses this meta-class. The base
    class, `Configuration` , incorporates the meta-class, and provides default definitions.
    The subclass extends those definitions with values that are unique to a particular
    environment or context:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用这个元类的`Configuration`类层次结构。基类`Configuration`包含元类，并提供默认定义。子类使用唯一于特定环境或上下文的值扩展这些定义：
- en: '[PRE60]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We can leverage all of the power of Python's multiple inheritance to build `Configuration`
    class definitions. This can provide the ability to combine details on separate
    features into a single configuration object.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用Python的多重继承的所有功能来构建`Configuration`类定义。这可以提供将单独特性的细节合并到单个配置对象中的能力。
- en: See also
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: We'll look at class definitions in [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* , and [Chapter 7](text00079.html#page
    "Chapter 7. More Advanced Class Design") , *More Advanced Class Design*
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在[第6章](text00070.html#page "第6章。类和对象的基础")，*类和对象的基础*和[第7章](text00079.html#page
    "第7章。更高级的类设计")，*更高级的类设计*中查看类定义
- en: Designing scripts for composition
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为组合设计脚本
- en: Many large applications are actually amalgamations of multiple, smaller applications.
    In enterprise terminology, they are often called application systems comprising
    individual command-line application programs.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 许多大型应用实际上是由多个较小的应用程序组合而成的。在企业术语中，它们通常被称为包含单独命令行应用程序程序的应用系统。
- en: Some large, complex applications include a number of commands. For example,
    the Git application has numerous individual commands, such as `git pull` , `git
    commit` , and `git push` . These can also be seen as separate applications that
    are part of the overall Git system of applications.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一些大型复杂的应用程序包括许多命令。例如，Git应用程序有许多单独的命令，如`git pull`，`git commit`和`git push`。这些也可以看作是整个Git应用程序系统的一部分的单独应用程序。
- en: An application might start as a collection of separate Python script files.
    At some point during its evolution, it can become necessary to refactor the scripts
    to combine features and create new, composite scripts from older disjoint scripts.
    The other path is also possible, a large application might be decomposed and refactored
    into a new organization.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序可能起初是一组单独的Python脚本文件。在其演变过程中的某个时刻，有必要重构脚本，将特性组合起来，并从较旧的不连贯脚本创建新的组合脚本。另一条路径也是可能的，一个大型应用程序可能被分解和重构为一个新的组织。
- en: How can we design a script so that future combinations and refactoring is made
    as simple as possible?
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何设计一个脚本，以便将来的组合和重构尽可能简单？
- en: Getting ready
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We need to distinguish between several design features of a Python script:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要区分Python脚本的几个设计特性：
- en: 'We''ve seen several aspects of gathering input:'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经看到了收集输入的几个方面：
- en: Getting highly dynamic input from a command-line interface and environment variables.
    See the *Using argparse to get command-line input* recipe in [Chapter 5](text00063.html#page
    "Chapter 5. User Inputs and Outputs") , *User Inputs and Outputs* .
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行界面和环境变量获取高度动态的输入。请参阅[第5章](text00063.html#page "第5章。用户输入和输出")中的*使用argparse获取命令行输入*。
- en: Getting slow for changing configuration options from files. See the recipes, 
    *Finding configuration files* , *Using YAML for configuration files* , and *Using
    Python for configuration files* .
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件中获取更改配置选项变得很慢。请参阅*查找配置文件*，*使用YAML进行配置文件*和*使用Python进行配置文件*。
- en: For reading any input files, see the  *Reading delimited files with the CSV module*
    , *Reading complex formats using regular expressions* , *Reading JSON documents*
    , *Reading XML documents* , and *Reading HTML documents*  recipes in [Chapter
    9](text00099.html#page "Chapter 9. Input/Output, Physical Format, and Logical
    Layout") , *Input/Output, Physical Format, and Logical Layout* .
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读任何输入文件，请参阅[第9章](text00099.html#page "第9章 输入/输出、物理格式和逻辑布局")中的*使用CSV模块读取分隔文件*、*使用正则表达式读取复杂格式*、*读取JSON文档*、*读取XML文档*和*读取HTML文档*的示例，*输入/输出、物理格式和逻辑布局*。
- en: 'There are several aspects to producing output:'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产生输出有几个方面：
- en: Creating logs and offering other features that support audit, control, and monitoring.
    We'll look at some of this in the *Using logging for control and audit output*
    recipe.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建日志并提供其他支持审计、控制和监控的功能。我们将在*使用日志进行控制和审计输出*的示例中看到其中一些。
- en: Creating the principle output of the application. This might be printed or written
    to an output file, using the same library modules used to parse inputs.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建应用程序的主要输出。这可能会被打印或写入输出文件，使用与解析输入相同的库模块。
- en: The real work of the application. These are the essential features, disentangled
    from the various input parsing and output formatting considerations. This algorithm
    works exclusively with Python data structures.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的真正工作。这些是基本功能，与各种输入解析和输出格式考虑分离。该算法专门使用Python数据结构。
- en: This *separation of concerns* suggests that any application, no matter how simple,
    should be designed as several separate functions. These should be combined into
    a complete script. This lets us separate the input and output from the core processing.
    The processing is the part we'll often want to reuse. The input and output formats
    should be something that can easily be changed.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*关注点的分离*表明，无论多么简单的应用程序都应设计为几个单独的函数。这些函数应组合成一个完整的脚本。这样我们就可以将输入和输出与核心处理分开。处理是我们经常想要重用的部分。输入和输出格式应该是可以轻松更改的东西。
- en: 'As a concrete example, we''ll look at a simple application that creates sequences
    of dice rolls. Each sequence will follow the rules of the game of craps. Here
    are the rules:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个具体的例子，我们将看一个创建骰子掷出序列的简单应用程序。每个序列都将遵循craps游戏的规则。以下是规则：
- en: 'The first roll of two dice is the *come out* roll:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个骰子的第一次掷出是*come out*掷：
- en: A roll of two, three, or twelve is an immediate loss. The sequence has a single
    value, for example, `[(1, 1)]` .
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两点、三点或十二点的掷出是立即输。该序列有一个单一值，例如，`[(1, 1)]`。
- en: A roll of seven or eleven is an immediate win. This sequence also has a single
    value, for example, `[(3, 4)]` .
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 七点或十一点的掷出是立即赢。这个序列也有一个单一值，例如，`[(3, 4)]`。
- en: 'Any other number establishes a point. The sequence starts with the point value
    and continues until either a seven or the point value is rolled:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何其他数字都会确定一个点。序列从点值开始，直到掷出七点或点值：
- en: A final seven is a loss, for example, `[(3, 1), (3, 2), (1, 1), (5, 6), (4,
    3)]` .
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的七点是输，例如，`[(3, 1), (3, 2), (1, 1), (5, 6), (4, 3)]`。
- en: A final match of the original point value is a win. There will be a minimum
    of two rolls. There's no upper bound on the length of a game, for example, `[(3,
    1), (3, 2), (1, 1), (5, 6), (1, 3)]` .
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始点值的最终匹配是赢。至少会有两次掷骰子。游戏的长度没有上限，例如，`[(3, 1), (3, 2), (1, 1), (5, 6), (1, 3)]`。
- en: The output is a sequence of items with different structures. Some will be short
    lists. Some will be long lists. This is an ideal place for using YAML format files.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是具有不同结构的项目序列。有些会是短列表。有些会是长列表。这是使用YAML格式文件的理想场所。
- en: This output can be controlled by two inputs—how many samples to create, and
    whether or not to seed the random number generator. For testing purposes, it can
    help to have a fixed seed.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出可以由两个输入控制——要创建多少样本，以及是否要给随机数生成器设定种子。出于测试目的，固定种子可能有所帮助。
- en: How to do it...
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Design all of the output display into two broad areas:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有输出显示设计为两个广泛的领域：
- en: Functions (or classes) that do no processing, but display result objects.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不进行处理但显示结果对象的函数（或类）。
- en: Logging may be for debugging, monitoring, audit, or some other control. This
    is a cross-cutting concern that will be embedded in the rest of the application.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日志可能用于调试、监控、审计或其他控制。这是一个横切关注点，将嵌入到应用程序的其余部分中。
- en: For this example, there are two outputs—the sequence of sequences, and some
    additional information to confirm that processing worked properly. A count of
    each number rolled is a handy way to establish that the simulated dice were fair.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有两个输出——序列的序列和一些额外信息，以确认处理是否正常工作。每个掷出的点数计数是确定模拟骰子是否公平的方便方法。
- en: 'The sequence of rolls needs to be written to a file. This suggests that the
    `write_rolls()` function is given an iterator as a parameter. Here''s a function
    that iterates and dumps values to a file in YAML notation:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 掷出的序列需要写入文件。这表明`write_rolls()`函数被给定一个迭代器作为参数。这是一个迭代并以YAML格式将值转储到文件的函数：
- en: '[PRE61]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The monitoring and control output should display the input parameters used
    to control the processing. It should also provide the counts that show that the
    dice were fair:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 监控和控制输出应显示用于控制处理的输入参数。它还应提供显示骰子公平的计数：
- en: '[PRE62]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Design (or refactor) the essential processing of the application to look like
    a single function:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计（或重构）应用程序的基本处理，使其看起来像一个单一函数：
- en: All inputs are parameters.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有输入都是参数。
- en: All outputs are produced by `return` or `yield` . Use `return` to create the
    single result. Use `yield` to generate an sequence iterate for multiple results.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有输出都由`return`或`yield`产生。使用`return`创建单一结果。使用`yield`生成多个结果的序列迭代。
- en: 'In this example, we can easily make the core feature a function that emits
    an sequence iterate of values. The output function can use this iterator:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以很容易地将核心功能设为一个发出值序列迭代的函数。输出函数可以使用这个迭代器：
- en: '[PRE63]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This function relies on a `craps_game()` function to generate the requested
    number of samples. Each sample is a full game, showing all of the dice rolls.
    This function provides the `face_count` counter to this lower-level function to
    accumulate some totals to confirm that everything worked properly.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数依赖于`craps_game()`函数生成请求的样本数量。每个样本都是一个完整的游戏，显示所有的骰子掷出。此函数提供`face_count`计数器给这个低级函数以累积一些总数以确认一切是否正常工作。
- en: The `craps_game()` function implements the craps game rules to emit a single
    sequence of one or more rolls. This comprises all the rolls in a single game.
    We'll look at this `craps_game()` function later.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`craps_game()`函数实现了crap游戏规则以发出一个或多个掷骰子的单个序列。这包括了单个游戏中的所有掷骰子。我们稍后会看一下这个`craps_game()`函数。'
- en: 'Refactor all of the input gathering into a function (or class) that gathers
    the various input sources. This can include environment variables, command-line
    arguments, and configuration files. It may also include the names of multiple
    input files:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有的输入收集重构为一个函数（或类），它收集各种输入源。这可以包括环境变量、命令行参数和配置文件。它还可以包括多个输入文件的名称：
- en: '[PRE64]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This function gathers command-line arguments. It also checks the `os.environ`
    collection of environment variables.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数收集命令行参数。它还检查`os.environ`环境变量的集合。
- en: The argument parser will handle the details of parsing the `--samples` and `--output`
    options. We can leverage additional features of `argparse` to better validate
    the argument values.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 参数解析器将处理解析`--samples`和`--output`选项的细节。我们可以利用`argparse`的其他功能来更好地验证参数值。
- en: The value of `output_path` is created from the the value of the `--output` option.
    Similarly, the value of the `RANDOMSEED` environment variable is validated and
    placed into the `options` namespace. This use of the `options` object keeps all
    of the various arguments in one place.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`output_path`的值是从`--output`选项的值创建的。类似地，`RANDOMSEED`环境变量的值经过验证并放入`options`命名空间。`options`对象的使用将所有不同的参数放在一个地方。'
- en: 'Write the final `main()` function, which incorporates the three previous elements,
    to create the final, overall script:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写最终的`main()`函数，它包含了前面的三个元素，以创建最终的整体脚本：
- en: '[PRE65]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This brings the various aspects of the application together. It parses the command-line
    and environment options. It creates a control total counter.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这将应用程序的各个方面汇集在一起。它解析命令行和环境选项。它创建一个控制总计计数器。
- en: The `roll_iter()` function is the core processing. It takes the various options,
    and it emits a sequence of rolls.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`roll_iter()`函数是核心处理。它接受各种选项，并发出一系列掷骰子。'
- en: The primary output from `roll_iter()`  method is collected by `write_rolls()`
    and written to the given output path. The control output is written by a separate
    function, so that we can change the summary without an impact on the primary output.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`roll_iter()`方法的主要输出由`write_rolls()`收集，并写入给定的输出路径。控制输出由一个单独的函数写入，这样我们可以在不影响主要输出的情况下更改摘要。'
- en: How it works...
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: 'The output looks like this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE66]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The command line requested ten samples, and specified an output file of `x.yaml`
    . The control output is a simple dump of the options. It shows the values for
    the parameters plus the additional values set in the `options` object.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行请求了十个样本，并指定了一个名为`x.yaml`的输出文件。控制输出是选项的简单转储。它显示了参数的值以及在`options`对象中设置的附加值。
- en: The control output includes the counts from ten samples. This provides some
    confidence that values such as six, seven, and eight occur more often. It shows
    that values such as three and twelve occur less frequently.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 控制输出包括来自十个样本的计数。这提供了一些信心，例如六、七和八的值更常出现。它显示了像三和十二这样的值出现得更少。
- en: 'The central premise here is the separation of concerns. There are three distinct
    aspects to the processing:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的核心前提是关注点的分离。处理有三个明显的方面：
- en: '**Inputs** : The parameters from the command line, and environment variables
    are gathered by a single function, `get_options()` . This function can grab inputs
    from a variety of sources, including configuration files.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入**：来自命令行和环境变量的参数由一个名为`get_options()`的单个函数收集。这个函数可以从各种来源获取输入，包括配置文件。'
- en: '**Outputs** : The primary output was handled by the `write_rolls()` function.
    The other control output was handled by accumulating totals in a `Counter` object
    and then dumping this output at the end.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出**：主要输出由`write_rolls()`函数处理。其他控制输出由在`Counter`对象中累积总数，然后在最后转储此输出来处理。'
- en: '**Process** : The application''s essential processing is factored into the
    `roll_iter()` function. This function can be reused in a variety of contexts.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理**：应用程序的基本处理被分解到`roll_iter()`函数中。这个函数可以在各种上下文中重复使用。'
- en: The goal of this design is to separate the `roll_iter()` function from the surrounding
    application details. Another application might have different command-line arguments,
    or different output formats, but reuse the essential algorithm.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的目标是将`roll_iter()`函数与周围应用程序的细节分离开来。另一个应用程序可能有不同的命令行参数，或不同的输出格式，但可以重用基本算法。
- en: For example, there may be a second application that performs some statistical
    analyses on the sequences of rolls. This might include a count of rolls, and the
    final outcome of win or lose. We can assume that these two applications are `generator.py`
    (shown previously) and `overview_stats.py` .
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可能有第二个应用程序对掷骰子的序列进行一些统计分析。这可能包括掷骰子的次数，以及最终的输赢结果。我们可以假设这两个应用程序是`generator.py`（如前所示）和`overview_stats.py`。
- en: 'After using these two applications to create rolls, and summarize them, the
    users may determine that it would be advantageous to combine the roll creation
    and the statistical overview into a single application. Because the various aspects
    of each application have been separated, it becomes relatively easy to rearrange
    the features and create a new application. We can now build a new application
    that will start with the following two imports:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这两个应用程序创建骰子并总结它们之后，用户可能会确定将骰子创建和统计概述合并到一个单一应用程序中会更有利。因为每个应用程序的各个方面都被分开，所以重新排列功能并创建一个新应用程序变得相对容易。现在我们可以构建一个新应用程序，它将从以下两个导入开始：
- en: '[PRE67]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This new application can be built without any changes to the other two applications.
    This leaves the original applications untouched by the introduction of new features.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新应用程序可以在不对其他两个应用程序进行任何更改的情况下构建。这样一来，引入新功能不会影响原始应用程序。
- en: More importantly, the new application did not involve any copying or pasting
    of code. The new application imports working software—changes made to fix one
    application will also fix latent bugs in other applications.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，新应用程序没有涉及任何代码的复制或粘贴。新应用程序导入工作软件——对一个应用程序进行修复的更改也将修复其他应用程序中的潜在错误。
- en: Tip
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Reuse via copy and paste creates technical debt. Avoid copying and pasting the
    code.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 通过复制和粘贴进行重用会产生技术债务。避免复制和粘贴代码。
- en: When we try to copy code from one application to make a new application, we
    create a confusing situation. Any changes made to one copy won't magically fix
    latent bugs in the other copy. When changes are made to one copy, and the other
    copy is not kept up-to-date, this is one kind of *code rot* .
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试从一个应用程序复制代码来创建一个新应用程序时，我们会创建一个混乱的情况。对一个副本进行的任何更改不会奇迹般地修复另一个副本中的潜在错误。当对一个副本进行更改，而另一个副本没有保持更新时，这是一种*代码腐烂*。
- en: There's more...
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the previous section, we skipped over the details of the `craps_rules()`
    function. This function creates a sequence of dice rolls that comprise a single
    game of *Craps* . It can vary from a single roll to a sequence of indefinite length.
    About 98% of the games will be thirteen or fewer throws of the dice.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们跳过了`craps_rules()`函数的细节。这个函数创建了一个包含单个*Craps*游戏的骰子投掷序列。它可以从单次投掷到无限长度的序列。大约98%的游戏将是十三次或更少的骰子投掷。
- en: 'The rules depend on the total of two dice. The data captured include the two
    separate faces of the dice. In order to support these details, it''s helpful to
    have a `namedtuple` instance that has these two related properties:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 规则取决于两个骰子的总和。捕获的数据包括两个骰子的分开面。为了支持这些细节，有一个`namedtuple`实例，具有这两个相关属性：
- en: '[PRE68]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This `roll()` function creates a `namedtuple` instance with a sequence that
    shows the faces of the dice, as well as the total of the dice. The `craps_game()`
    function will generate enough rules to return one complete game:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`roll()`函数创建一个`namedtuple`实例，其中包含显示骰子面和骰子总和的序列。`craps_game()`函数将生成足够的规则来返回一个完整的游戏：
- en: '[PRE69]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `craps_game()` function implements the rules for craps. If the first roll
    is two, three, or twelve, the sequence only has a single value, and the game is
    a loss. If the first roll is seven or eleven, the sequence also has only a single
    value, and the game is a win. The remaining values establish a point. The sequence
    of rolls starts with the point value. The sequence continues until it's ended
    by seven or the point value.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`craps_game()`函数实现了Craps的规则。如果第一次投掷是两、三或十二，序列只有一个值，游戏就输了。如果第一次投掷是七或十一，序列也只有一个值，游戏就赢了。其余的值建立了一个点。投掷序列从点值开始。序列一直持续，直到被七或点值结束。'
- en: Designing as a class hierarchy
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计为类层次结构
- en: 'The close relationship between `roll_iter()` , `roll()` , and `craps_game()`
     methods suggests that it might be better to encapsulate these functions into
    a single class definition. Here''s a class that has all of these features bundled
    together:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`roll_iter()`，`roll()`和`craps_game()`方法之间的密切关系表明，将这些函数封装到一个单一的类定义中可能更好。下面是一个将所有这些功能捆绑在一起的类：'
- en: '[PRE70]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This class includes an initialization of the simulator to include its own random
    number generator. It will either use the given seed value, or the internal algorithm
    will pick seed value. The `roll()` method will set the `self.total` and `self.faces`
    instance variables.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包括模拟器的初始化，包括自己的随机数生成器。它将使用给定的种子值，或者内部算法将选择种子值。`roll()`方法将设置`self.total`和`self.faces`实例变量。
- en: The `craps_game()` generates one sequence of rolls for one game of craps. It
    uses the `roll()` method and the two instance variables, `self.total` and `self.faces`
    , to track the state of the dice.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`craps_game()`生成一个游戏的骰子序列。它使用`roll()`方法和两个实例变量`self.total`和`self.faces`来跟踪骰子的状态。'
- en: The `roll_iter()` method generates the sequence of games. Note that the signature
    of this method is not exactly like the preceding `roll_iter()` function. This
    class separates random number seeding from the game creation algorithm.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`roll_iter()`方法生成游戏序列。请注意，此方法的签名与前面的`roll_iter()`函数并不完全相同。这个类将随机数种子的生成与游戏创建算法分开。'
- en: Rewriting `main()` to use the `CrapsSimulator` class is left as an exercise
    for the reader. Since the method names are similar to the original function names,
    the refactoring should not be terribly complex.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 重写`main()`以使用`CrapsSimulator`类留给读者作为练习。由于方法名称与原始函数名称相似，重构不应该太复杂。
- en: See also
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the  *Using argparse to get command-line input* recipe in [Chapter 5](text00063.html#page
    "Chapter 5. User Inputs and Outputs") , *User Inputs and Outputs* , for background
    on using `argparse` to get inputs from a user
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](text00063.html#page "第5章。用户输入和输出")的*用户输入和输出*中查看*使用argparse获取命令行输入*的方法，了解使用`argparse`从用户那里获取输入的背景知识
- en: See the *Finding configuration files* recipe for a way to track down configuration
    files
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看*查找配置文件*的方法，以便追踪配置文件
- en: The *Using logging for control and audit output* recipe looks at logging
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用日志记录控制和审计输出*的方法查看日志记录'
- en: In the *Combining two applications into one* recipe, we'll look at ways to combine
    applications that follow this design pattern
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*将两个应用程序合并为一个*的配方中，我们将看看如何合并遵循这种设计模式的应用程序
- en: Using logging for control and audit output
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用日志记录控制和审计输出
- en: 'In the *Designing scripts for composition* recipe, we examined three aspects
    of an application:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在*为组合设计脚本*的配方中，我们考察了应用程序的三个方面：
- en: Gathering input
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集输入
- en: Producing output
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产生输出
- en: The essential processing that connects input and output
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接输入和输出的基本处理
- en: 'There are several different kinds of output that applications produce:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序产生几种不同类型的输出：
- en: The principle output that helps a user make a decision or take action
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助用户做出决策或采取行动的主要输出
- en: Control information that confirms that the program worked completely and correctly
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认程序完全正确工作的控制信息
- en: Audit summaries that are used to track the history of state changes in persistent
    databases
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于跟踪持久数据库中状态变化历史的审计摘要
- en: Any error messages that indicate why the application didn't work
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指示应用程序为什么不工作的任何错误消息
- en: It's less than optimal to lump all of these various aspects into `print()` requests
    that write to standard output. Indeed, it can lead to confusion because too many
    different outputs are conflated into a single stream.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些不同方面都归并到写入标准输出的`print()`请求中并不是最佳选择。实际上，这可能会导致混乱，因为太多不同的输出被合并到一个流中。
- en: The OS provides two output files, standard output and standard error. These
    are visible in Python through the `sys` module with the names `sys.stdout` and
    `sys.stderr` . By default, the `print()`  method writes to the `sys.stdout` file.
    We can change this and write the control, audit, and error messages to `sys.stderr`
    . This is an important step in the right direction.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统提供了两个输出文件，标准输出和标准错误。在Python中，可以通过`sys`模块的`sys.stdout`和`sys.stderr`来看到这些文件。默认情况下，`print()`方法会写入`sys.stdout`文件。我们可以改变这一点，将控制、审计和错误消息写入`sys.stderr`。这是朝着正确方向迈出的重要一步。
- en: Python offers the `logging` package, which can be used to direct the ancillary
    output to a separate file. It can also be used to format and filter that additional
    output.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了`logging`包，可以用来将辅助输出定向到单独的文件。它还可以用来格式化和过滤附加输出。
- en: How can we use logging properly?
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何正确使用日志记录？
- en: Getting ready
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the *Designing scripts for composition* recipe, we looked at an application
    that produced a YAML file with the raw output of a simulation in it. In this recipe,
    we'll look at an application that consumes that raw data and produces some statistical
    summaries. We'll call this application `overview_stats.py` .
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在*为组合设计脚本*的配方中，我们看了一个生成带有模拟原始输出的YAML文件的应用程序。在这个配方中，我们将看一个应用程序，它消耗这些原始数据并生成一些统计摘要。我们将称这个应用程序为`overview_stats.py`。
- en: 'Following the design pattern of separating the input, output, and processing,
    we''ll have an application `main()` that looks something like this:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循分离输入、输出和处理的设计模式，我们将有一个类似这样的`main()`应用程序：
- en: '[PRE71]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This function will get the options from various sources. If an output file is
    named, it will create the output file using a `with` statement context. This function
    will then process all of the command-line argument files as input from which statistics
    are gathered.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将从各种来源获取选项。如果命名了输出文件，它将使用`with`语句上下文创建输出文件。然后这个函数将处理所有命令行参数文件作为输入，从中收集统计信息。
- en: If no output file name is provided, this function will write to the `sys.stdout`
    file. This will display output that can be redirected using the OS shell's `>`
    operator to create a file.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供输出文件名，这个函数将写入`sys.stdout`文件。这将显示可以使用操作系统shell的`>`运算符重定向的输出，以创建一个文件。
- en: 'The `main()` function relies on a `process_all_files()` function. The `process_all_files()`
    function will iterate through each of the argument files, and gather statistics
    from that file. Here''s what that function looks like:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数依赖于`process_all_files()`函数。`process_all_files()`函数将遍历每个参数文件，并从该文件中收集统计信息。这个函数看起来是这样的：'
- en: '[PRE72]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `process_all_files()` function applies `gather_stats()` to each file in
    the `file_names` iterable. The resulting collection is written to the given `result_file`
    .
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_all_files()`函数将`gather_stats()`应用于`file_names`可迭代中的每个文件。然后将生成的集合写入给定的`result_file`。'
- en: Note
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The function shown here conflates processing and output in a design that is
    not ideal. We'll address this design flaw in the *Combining two applications into
    one* recipe.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的函数将处理和输出混合在一起，这种设计并不理想。我们将在*将两个应用程序合并为一个*的配方中解决这个设计缺陷。
- en: 'The essential processing is in the `gather_stats()` function. Given a path
    to a file, this will read and summarize the games in that file. The resulting
    summary object can then be written as part of the overall display or, in this
    case, appended to a sequence of YAML-format summaries:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 基本处理在`gather_stats()`函数中。给定一个文件路径，它将读取并总结该文件中的游戏。然后产生的摘要对象可以作为整体显示的一部分，或者在这种情况下，附加到一系列YAML格式的摘要中：
- en: '[PRE73]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This function determines which of the four game termination rules were applied
    to the sequence of dice rolls. It starts by opening the given source file, and
    using the `load_all()` function to iterate through all of the YAML documents.
    Each document is a single game, represented as a sequence of dice pairs.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数确定了四种游戏终止规则中的哪一种适用于骰子掷出的顺序。它首先打开给定的源文件，然后使用`load_all()`函数遍历所有的YAML文档。每个文档都是一个单独的游戏，表示为一系列骰子对。
- en: This function uses the first (and last) rolls to determine the overall outcome
    of the game. There are four rules, which should enumerate all possible logical
    combinations of events. In the event, if there is some error in our reasoning,
    an exception will get raised to alert us to a special case that didn't fit the
    design in some way.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用第一个（和最后一个）掷骰子来确定游戏的整体结果。有四条规则，应该列举出所有可能的逻辑事件组合。如果在我们的推理中出现错误，异常将被引发以警示我们某种特殊情况没有符合设计的方式。
- en: The game is reduced to a single event with an outcome and a length. These are
    accumulated into a `Counter` object. The outcome and length of a game are the
    two values we're computing. These are a stand-in for more complex or sophisticated
    statistical analyses that are possible.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏被简化为一个具有结果和长度的单个事件。这些被累积到一个`Counter`对象中。游戏的结果和长度是我们正在计算的两个值。这些是更复杂或复杂的统计分析的替代品。
- en: We've carefully segregated almost all file-related considerations from this
    function. The `gather_stats()` function will work with any iterable source of
    game data.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经仔细地将几乎所有与文件相关的考虑从这个函数中分离出来。`gather_stats()`函数将使用任何可迭代的游戏数据源。
- en: 'Here''s the output from this application. It''s not very pretty; it''s a YAML
    document that can be used for further processing:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序的输出。它不是很漂亮；这是一个YAML文档，可用于进一步处理：
- en: '[PRE74]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We'll need to insert logging features into all of these functions to show which
    file is being read, and any errors or problems with processing the file.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将日志记录功能插入所有这些函数中，以显示正在读取的文件以及处理文件时的任何错误或问题。
- en: Furthermore, we're going to create two logs. One will have details, and the
    other will have a minimal summary of files that are created. The first log can
    go to `sys.stderr` , which will be displayed at the console when the program runs.
    The other log will be appended to a long-term `log` file to cover all uses of
    the application.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将创建两个日志。一个将有详细信息，另一个将有已创建文件的最小摘要。第一个日志可以进入`sys.stderr`，当程序运行时将在控制台显示。另一个日志将附加到长期的`log`文件中，以覆盖应用程序的所有用途。
- en: One approach to having separate needs is to create two loggers, each with a
    different intent. The two loggers will also have dramatically different configurations.
    Another approach is to create a single logger, and use a `Filter` object to distinguish
    content intended for each logger. We'll focus on creating separate loggers because
    it's easier to develop and easier to unit test.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 满足不同需求的一种方法是创建两个记录器，每个记录器具有不同的意图。这两个记录器还将具有截然不同的配置。另一种方法是创建一个单一的记录器，并使用`Filter`对象来区分每个记录器的内容。我们将专注于创建单独的记录器，因为这样更容易开发和更容易进行单元测试。
- en: 'Each logger has a variety of methods reflecting the severity of the message.
    The severity levels defined in the `logging` package include the following:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 每个记录器都有各种方法，反映了消息的严重性。`logging`包中定义的严重级别包括以下内容：
- en: '**DEBUG** : These messages are not generally shown, since their intent is to
    support debugging.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DEBUG**：通常不显示这些消息，因为它们的目的是支持调试。'
- en: '**INFO** : These messages provide information on the normal, happy-path processing.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**INFO**：这些消息提供有关正常、顺利处理的信息。'
- en: '**WARNING** : These messages indicate that processing may be compromised in
    some way. The most sensible use case for a warning is when functions or classes
    have been deprecated: they work, but they should be replaced. These messages are
    often displayed.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WARNING**：这些消息表明处理可能以某种方式受到影响。警告的最明智用例是当函数或类已被弃用时：它们可以工作，但应该被替换。这些消息通常会显示。'
- en: '**ERROR** : Processing is invalid and the output is incorrect or incomplete.
    In the cases of a long-running server, an individual request may have problems,
    but the server, as a whole, can continue to operate.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ERROR**：处理无效，输出不正确或不完整。在长时间运行的服务器的情况下，单个请求可能会出现问题，但作为一个整体，服务器可以继续运行。'
- en: '**CRITICAL** : A more severe level of error. Generally, this is used by long-running
    servers where the server itself can no longer operate, and is about to crash.'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CRITICAL**：更严重的错误级别。通常，这是由长时间运行的服务器使用的，其中服务器本身无法继续运行，并且即将崩溃。'
- en: The method names are similar to the severity levels. We use `logging.info()`
    to write an INFO-level message.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名称与严重级别类似。我们使用`logging.info()`来写入INFO级别的消息。
- en: How to do it...
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We''ll start by implementing basic logging features into the existing functions.
    This means that we''ll need the `logging` module:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先将基本的日志记录功能实现到现有的函数中。这意味着我们需要`logging`模块：
- en: '[PRE75]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The rest of the application will use a number of other packages:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的其余部分将使用许多其他软件包：
- en: '[PRE76]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We'll create two logger objects as module globals. The creating functions can
    go anywhere in the script that creates global variables. One location is to put
    these early, after the `import` statements. Another common choice is near the
    end, but outside any `__name__ == "__main__"` script processing. These variables
    must always be created, even if the module is imported as a library.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建两个作为模块全局变量的记录器对象。创建函数可以放在创建全局变量的脚本的任何位置。一个位置是在`import`语句之后尽早放置这些内容。另一个常见的选择是在最后附近，但在任何`__name__
    == "__main__"`脚本处理之外。这些变量必须始终被创建，即使模块作为库导入。
- en: 'Loggers have hierarchical names. We''ll name the loggers using the application
    name and a suffix with the content. The `overview_stats.detail` logger will have
    processing details. The `overview_stats.write` logger will identify the files
    read and the files written; this parallels the idea of an audit log because the
    file writes track state changes in the collection of output files:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 记录器具有分层名称。我们将使用应用程序名称和内容后缀来命名记录器。`overview_stats.detail`记录器将具有处理详细信息。`overview_stats.write`记录器将标识已读取和已写入的文件；这与审计日志的概念相对应，因为文件写入跟踪输出文件集合中的状态更改：
- en: '[PRE77]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We don't need to configure these loggers at this time. If we do nothing more,
    the two logger objects will silently accept individual log entries, but won't
    do anything further with the data.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不需要配置这些记录器。如果我们什么都不做，这两个记录器对象将默默地接受单独的日志条目，但不会进一步处理数据。
- en: 'We''ll rewrite the `main()` function to summarize the two aspects of the processing.
    This will use the `write_log` logger object to show when a new file is created:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重写`main()`函数以总结处理的两个方面。这将使用`write_log`记录器对象来显示何时创建新文件：
- en: '[PRE78]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We've added the `write_log.info("wrote {}".format(result_path))` line to put
    an information message into the log for files that have been written.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`write_log.info("wrote {}".format(result_path))`一行，将信息消息放入日志中已写入的文件。
- en: 'We''ll rewrite the `process_all_files()` function to provide a note when a
    file is read:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重写`process_all_files()`函数，以在读取文件时提供注释：
- en: '[PRE79]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We've added the `detail_log.info("read {}".format(source_path))` line to put
    information messages in the detail log for every file that's read.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`detail_log.info("read {}".format(source_path))`行，以在每次读取文件时将信息消息放入详细日志中。
- en: 'The `gather_stats()` function can have a log line added to it to track normal
    operations. Additionally, we''ve added a log entry for the logic error:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gather_stats()`函数可以添加一行日志来跟踪正常操作。此外，我们还为逻辑错误添加了一个日志条目：'
- en: '[PRE80]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The `detail_log` logger is used to collect debugging information. If we set
    the overall logging level to include debug messages, we'll see this additional
    output.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`detail_log`记录器用于收集调试信息。如果将整体日志级别设置为包括调试消息，我们将看到此额外输出。'
- en: 'The `get_options()` function will also have a debugging line written. This
    can help diagnose problems by displaying the options into the log:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get_options()`函数还将写入一个调试行。这可以通过将选项显示在日志中来帮助诊断问题：'
- en: '[PRE81]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We can add a simple configuration to see the log entries. This works as a first
    step to simply confirm that there are two loggers and they''re being used properly:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以添加一个简单的配置来查看日志条目。这是作为第一步来简单确认有两个记录器，并且它们被正确使用：
- en: '[PRE82]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This logging configuration builds the default handler object. This object simply
    prints all of the log messages on the given stream. This handler is assigned to
    the root logger; it will apply to all children of this logger. Therefore, both
    of the loggers created in the preceding code will go to the same stream.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 此日志配置构建了默认处理程序对象。此对象仅在给定流上打印所有日志消息。此处理程序分配给根记录器；它将应用于此记录器的所有子记录器。因此，前面代码中创建的两个记录器将发送到同一个流。
- en: 'Here''s an example of running this script:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行此脚本的示例：
- en: '[PRE83]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: There are two lines in the log. Both have a severity of INFO. The first line
    is from the `overview_stats.detail` logger. The second line is from the `overview_stats.write`
    logger. The default configuration sends all loggers to `sys.stdout` .
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 日志中有两行。两者的严重性都是INFO。第一行来自`overview_stats.detail`记录器。第二行来自`overview_stats.write`记录器。默认配置将所有记录器发送到`sys.stdout`。
- en: 'In order to route the different loggers to different destinations, we''ll need
    a more sophisticated configuration than the `basicConfig()` function. We''ll use
    the `logging.config` module. The `dictConfig()` method can provide a complete
    set of configuration options. The easiest way to do this is to write the configuration
    in YAML and then convert this to an internal `dict` object using the `yaml.load()`
    function:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将不同的记录器路由到不同的目的地，我们需要比`basicConfig()`函数更复杂的配置。我们将使用`logging.config`模块。`dictConfig()`方法可以提供完整的配置选项。这样做的最简单方法是将配置写入YAML，然后使用`yaml.load()`函数将其转换为内部的`dict`对象：
- en: '[PRE84]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The YAML document is enclosed in a triple-apostrophe string. This allows us
    to write as much text as necessary. We''ve defined five things in the big block
    of text using YAML notation:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: YAML文档被包含在一个三重撇号字符串中。这使我们能够写入尽可能多的文本。我们使用YAML表示法在大块文本中定义了五件事：
- en: The value of the `version` key must be 1.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`键的值必须为1。'
- en: 'The value of the `formatters` key defines the log format. If this is not specified,
    the default format shows only the message body, without any level or logger information:'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`formatters`键的值定义了日志格式。如果未指定此项，那么默认格式只显示消息正文，不包括级别或记录器信息：'
- en: The `default` formatter defined here mirrors the format created by the `basicConfig()`
    function.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此处定义的`default`格式化程序与`basicConfig()`函数创建的格式相同。
- en: The `timestamp` formatter defined here is a more complex format that includes
    the date-time stamp for the record. To make the file easier to parse, a column
    separator of `//` was used.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此处定义的`timestamp`格式化程序是一个更复杂的格式，包括记录的日期时间戳。为了使文件更容易解析，使用了`//`作为列分隔符。
- en: The `handlers` key defines the two handlers for the two loggers. The `console`
    handler writes to the stream, `sys.stderr` . We specified the formatter this handler
    will use. This definition parallels the configuration created by the `basicConfig()`
    function.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handlers`键定义了两个记录器的两个处理程序。`console`处理程序写入流`sys.stderr`。我们指定了此处理程序将使用的格式化程序。此定义与`basicConfig()`函数创建的配置相对应。'
- en: 'The `file` handler writes to a file. The default mode for opening the file
    is `a` , which will append to the file with no upper limit on the file size. There
    are other handlers that can rotate through multiple files, each of a limited size.
    We''ve provided an explicit filename, and the formatter that will put more detail
    into the file than is shown on the console:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`file`处理程序写入文件。打开文件的默认模式是`a`，这将追加到文件，文件大小没有上限。还有其他处理程序可以在多个文件之间轮换，每个文件都有限制的大小。我们提供了一个显式的文件名，以及一个将在文件中放入比在控制台上显示的更多细节的格式化程序：'
- en: The `loggers` key provides a configuration for the two loggers that the application
    will create. Any logger name that begins with `overview_stats.detail`  will be
    handled only by the console handler. Any logger name that begins with `overview_stats.write`
     will go to both the file handler and the console handler.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loggers`键为应用程序将创建的两个记录器提供了配置。任何以`overview_stats.detail`开头的记录器名称将仅由控制台处理程序处理。任何以`overview_stats.write`开头的记录器名称将同时发送到文件处理程序和控制台处理程序。'
- en: The `root` key defines the top-level logger. It has a name of `''` (the empty
    string) in case we need to refer to it in code. Setting the level on the root
    logger will set the level for all of the children of this logger.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root`键定义了顶级记录器。它的名称是`''''`（空字符串），以防我们需要在代码中引用它。设置根记录器的级别将为该记录器的所有子记录器设置级别。'
- en: 'Use the configuration to wrap the `main()` function like this:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用配置来包装`main()`函数，如下所示：
- en: '[PRE85]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This will start the logging in a known state. It will do the processing of the
    application. It will finalize all of the logging buffers and properly close any
    files.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将以已知状态开始记录。它将处理应用程序。它将完成所有日志缓冲区的处理，并正确关闭任何文件。
- en: How it works...
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'There are three parts to introducing logging into an application:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志引入应用程序有三个部分：
- en: Creating logger objects
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建记录器对象
- en: Placing log requests near important state changes
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重要状态更改附近放置日志请求
- en: Configuring the logging system as a whole
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个整体配置日志系统
- en: Creating loggers can be done in a variety of ways. Additionally, it can also
    be ignored. As a default, we can use the `logging` module itself as a logger.
    If we use the `logging.info()` method, for example, this will implicitly use the
    root logger.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 创建记录器可以通过多种方式完成。此外，也可以忽略。作为默认值，我们可以使用`logging`模块本身作为记录器。例如，如果我们使用`logging.info()`方法，这将隐式地使用根记录器。
- en: 'A more common approach is to create one logger with the same name as the module:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的方法是创建一个与模块名称相同的记录器：
- en: '[PRE86]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: For the top-level, main script, this will have the name `"__main__"` . For imported
    modules, the name will match the module name.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 对于顶级主脚本，这将具有名称`"__main__"`。对于导入的模块，名称将与模块名称匹配。
- en: In more complex applications, there will be a variety of loggers serving a variety
    of purposes. In these cases, simply naming a logger after a module may not provide
    the needed level of flexibility.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的应用程序中，将有各种记录器用于各种目的。在这些情况下，仅仅将记录器命名为模块可能无法提供所需的灵活性。
- en: 'There are two concepts that can be used to assign names to the loggers. It''s
    often best to choose one of these and stick with it throughout a large application:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个概念可以用来为记录器分配名称。通常最好选择其中一个，并在整个大型应用程序中坚持使用它：
- en: Follow the package and module hierarchy. This means that a logger specific to
    a class might have a name like `package.module.class` . Other classes in the same
    module would share a common parent logger name. It's then possible to set the
    logging level for the the whole package, one of the specific modules, or just
    one of the classes.
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循包和模块的层次结构。这意味着特定于类的记录器可能具有类似`package.module.class`的名称。同一模块中的其他类将共享一个共同的父记录器名称。然后可以设置整个包的日志级别，特定模块之一的日志级别，或者只是其中一个类的日志级别。
- en: Follow a hierarchy based on the audience or use case. The top-level name will
    distinguish the audience or purpose for the log. We might have top-level loggers
    with names such as `event` , `audit` , and perhaps `debug` . This way, all of
    the audit loggers will have names that start with `"audit."` . This can make it
    easy to route all loggers under a given parent to a specific handler.
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据受众或用例遵循层次结构。顶级名称将区分日志的受众或目的。我们可能会有名称为`event`，`audit`和可能`debug`的顶级记录器。这样，所有审计记录器的名称都将以`"audit."`开头。这样可以很容易地将给定父级下的所有记录器路由到特定处理程序。
- en: 'In the recipe, we used the first style of naming. The logger names parallel
    the software architecture. Placing logging requests near all the important state
    changes should be relatively straightforward. There are a variety of interesting
    state changes that belong in a log:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了第一种命名风格。记录器名称与软件架构相对应。将日志请求放置在所有重要状态更改附近应该相对简单。日志中应包含各种有趣的状态更改：
- en: Any change to a persistent resource might be a good place to include a message
    of level INFO. Any OS change (usually to the file-system) is a candidate for logging.
    Similarly, database updates, and requests that should change the state of a web
    services should be logged.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对持久资源的任何更改都可能是包含`INFO`级别消息的好地方。任何OS更改（通常是文件系统）都有可能进行日志记录。同样地，数据库更新和应该更改Web服务状态的请求也应该被记录。
- en: Whenever there's a problem making a persistent state change, there should be
    a message `ERROR` . Any OS-level exceptions can be logged when they are caught
    and handled.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当出现无法进行持久状态更改的问题时，应该有一个`ERROR`消息。任何OS级别的异常在被捕获和处理时都可以被记录。
- en: In long, complex calculations, it may be helpful to log `DEBUG` messages after
    particularly import assignment statements. In some cases, this is a hint that
    the long calculation might need to be decomposed into functions so that they can
    be tested separately.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在长时间的复杂计算中，可能有助于在特别重要的赋值语句之后记录`DEBUG`消息。在某些情况下，这是一个提示，表明长时间的计算可能需要分解成函数，以便可以单独测试它们。
- en: Any change to an internal application resource deserves a `DEBUG` message so
    that object state changes can be tracked through the log.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对内部应用程序资源的任何更改都应该产生一个`DEBUG`消息，以便可以通过日志跟踪对象状态更改。
- en: When the application enters an erroneous state. This should generally be due
    to an exception. In some cases, an `assert` statement will be used to detect the
    state of the program and raise an exception when there are problems. Some exceptions
    are logged at the `EXCEPTION` level. Some exceptions, however, only need `DEBUG`
    level messages because the exception is being silenced or transformed. Some exceptions
    may be logged at the `ERROR` or `CRITICAL` level.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用程序进入错误状态时。这通常是由于异常。在某些情况下，将使用`assert`语句来检测程序的状态，并在出现问题时引发异常。一些异常以`EXCEPTION`级别记录。然而，一些异常只需要`DEBUG`级别的消息，因为异常被屏蔽或转换。一些异常可能以`ERROR`或`CRITICAL`级别记录。
- en: The third aspect of logging is configuring the loggers so that they route the
    requests to the appropriate destination. By default, with no configuration at
    all, the loggers will all quietly create log events, but won't display them.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 日志的第三个方面是配置记录器，以便将请求路由到适当的目的地。默认情况下，如果没有任何配置，记录器将悄悄地创建日志事件，但不会显示它们。
- en: With a minimal configuration, we can see all of the log events on the console.
    This can be done with the `basicConfig()`  method and covers a large number of
    simple use cases without any real fuss. Instead of a stream, we can use filename
    to provide a named file. Perhaps the most important feature is providing a simple
    way to enable debugging by setting the logging level on the root logger from `basicConfig()`
    method.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 通过最小配置，我们可以在控制台上看到所有日志事件。这可以通过`basicConfig()`方法完成，并且涵盖了大量简单的用例，而无需任何真正的麻烦。我们可以使用文件名而不是流来提供命名文件。也许最重要的功能是通过`basicConfig()`方法在根记录器上设置日志级别，从而提供一种简单的启用调试的方法。
- en: The example configuration in the recipe used two common handlers—the `StreamHandler`
    and `FileHandler` classes. There are over a dozen more handlers, each with unique
    features for gathering and publishing log messages.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 配方中的示例配置使用了两个常见的处理程序——`StreamHandler`和`FileHandler`类。还有十几个以上的处理程序，每个都具有独特的功能，用于收集和发布日志消息。
- en: There's more...
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: See the *Designing scripts for composition* recipe for the complementary part
    of this application
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅*为组合设计脚本*配方，了解这个应用程序的补充部分。
- en: Combining two applications into one
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将两个应用程序合并为一个
- en: In the *Designing scripts for composition* recipe, we looked at a simple application
    that creates a collection of statistics by simulating a process. In the *Using
    logging for control and audit output* recipe, we looked at an application that
    summarizes a collection of statistics. In this recipe, we'll combine those two
    separate applications to create a single, composite application that both creates
    and summarizes the statistical data.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在*为组合设计脚本*配方中，我们研究了一个简单的应用程序，通过模拟过程创建了一组统计数据。在*使用日志记录进行控制和审计输出*配方中，我们研究了一个总结统计数据的应用程序。在这个配方中，我们将结合这两个单独的应用程序，创建一个单一的复合应用程序，既创建又总结统计数据。
- en: 'There are several common approaches to combining these two applications:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种常见的方法可以将这两个应用程序组合起来：
- en: A shell script can run the simulator and then run the analyzer
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个shell脚本可以运行模拟器，然后运行分析器
- en: A Python program can stand in for the shell script and use the `runpy` module
    to run each program
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Python程序可以代替shell脚本，并使用`runpy`模块来运行每个程序
- en: We can build a composite application from the essential features of each application
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从每个应用程序的基本特性构建一个复合应用程序
- en: 'In the *Designing scripts for composition* recipe, we examined three aspects
    of an application:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在*为组合设计脚本*配方中，我们研究了应用程序的三个方面：
- en: Gathering input
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入收集
- en: Producing output
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产生输出
- en: The essential processing that connects input and output
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接输入和输出的基本处理
- en: In the recipe, we looked at a design pattern that would allow several Python
    language components to be combined into a larger application.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们研究了一种设计模式，可以将几个Python语言组件组合成一个更大的应用程序。
- en: How can we combine applications to create a composite?
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将应用程序组合成一个复合应用程序？
- en: Getting ready
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the *Designing scripts for composition*  and *Using logging for control and
    audit output* recipes, we followed a design pattern that separated the input gathering,
    the essential processing, and the production of output. The objective behind that
    design pattern was gathering the interesting pieces together to combine and recombine
    them into higher-level constructs.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在*为组合设计脚本*和*使用日志记录进行控制和审计输出*的配方中，我们遵循了一个设计模式，将输入收集、基本处理和输出产生分开。这个设计模式的目标是将有趣的部分聚集在一起，以便将它们组合和重新组合成更高级的结构。
- en: Note that we have a tiny mismatch between the two applications. We can borrow
    a phrase from database engineering (and also electrical engineering) and call
    this an impedance mismatch. In electrical engineering, it's a problem with circuit
    design, and it's often solved by using a device called a transformer. This can
    be used to match impedance between circuit components.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两个应用程序之间存在微小的不匹配。我们可以借用数据库工程（也是电气工程）的一个短语，称之为阻抗不匹配。在电气工程中，这是一个电路设计问题，通常通过使用一个叫做变压器的设备来解决。这可以用来匹配电路组件之间的阻抗。
- en: In database engineering, this kind of problem surfaces when the database has
    normalized, flat data, but the programming language uses richly structured complex
    objects. For SQL databases, this is a common problem and packages such as **SQLAlchemy**
    are used as an **Object-Relational Management** ( **ORM** ) layer. This layer
    is a transformer between flat database rows (often from multiple tables) and complex
    Python structures.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库工程中，当数据库具有规范化的扁平数据，但编程语言使用丰富结构的复杂对象时，这种问题会出现。对于SQL数据库，这是一个常见问题，使用**SQLAlchemy**等包作为**对象关系管理**（**ORM**）层。这一层是扁平数据库行（通常来自多个表）和复杂Python结构之间的变压器。
- en: 'When building a composite application, the impedance mismatch that surfaces
    in this example is a cardinal problem. The simulator is designed to run more frequently
    than the statistical summarizer. We have several choices for addressing cardinal
    issues such as this one:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建复合应用程序时，这个例子中出现的阻抗不匹配是一个主要问题。模拟器的设计是比统计摘要更频繁地运行。对于解决这类问题，我们有几种选择：
- en: '**Total Redesign** : This may not be a sensible alternative because the two
    component applications have an established base of users. In other cases, the
    new use cases are an opportunity to make sweeping fixes and retire some technical
    debt.'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总体重新设计**：这可能不是一个明智的选择，因为这两个组件应用程序有一定数量的用户基础。在其他情况下，新的用例是一个机会，可以进行全面的修复并清理一些技术债务。'
- en: '**Include the Iterator** : This means that when we build the composite application,
    we''ll add a `for` statement to perform many simulation runs and then process
    this into a single summary. This parallels the original design intent.'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包括迭代器**：这意味着当我们构建复合应用程序时，我们将添加一个`for`语句来执行多次模拟运行，然后将其处理成一个单一的摘要。这与原始设计意图相符。'
- en: '**List of One** : This means that the composite application will run one simulation
    and provide this single simulation output to the summarizer. This modifies the
    structure to do more summarization; the summaries may need to be combined into
    the expected single result.'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个列表**：这意味着复合应用程序将运行一个模拟，并将这个单一模拟输出提供给摘要。这修改了结构以进行更多的摘要;摘要可能需要组合成预期的单一结果。'
- en: The choice between these depends on the user story that leads to creating the
    composite application in the first place. It may also depend on the established
    base of users. For our purposes, we'll assume that the users have come to realize
    that 1,000 simulation runs of 1,000 samples is standard, and they would like to
    follow the *Include the Iterator* design to create a composite process.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两者之间的选择取决于首先导致创建复合应用程序的用户故事。这也可能取决于已建立的用户基础。对于我们的目的，我们将假设用户已经意识到1,000次模拟运行1,000个样本是标准的，并且他们希望遵循*包括迭代器*设计来创建一个复合过程。
- en: As an exercise, the reader should pursue the alternative design. Assume instead
    that the users would rather run 1,000,000 samples in a single simulation. For
    this, the users would prefer the summarizer work with a *List of One* design.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，读者应该追求替代设计。假设用户更愿意在单个模拟中运行1,000,000个样本。对于这一点，用户更希望摘要工作采用*一个列表*设计。
- en: We'll also look at another option. In this case, we'll perform 100 simulation
    runs spread over a number of concurrent worker processes. This will reduce the
    time to create a million samples. This is a variation of the *Include the Iterator*
    composite design.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看看另一个选项。在这种情况下，我们将执行100次模拟运行，分布在多个并发工作进程中。这将减少创建一百万个样本的时间。这是*包括迭代器*复合设计的变体。
- en: How to do it...
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Follow a design pattern that decomposes a complex process into functions that
    are independent of input or output details. See the *Designing scripts for composition*
    recipe for details on this.
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遵循将复杂过程分解为与输入或输出细节无关的函数的设计模式。有关此内容的详细信息，请参阅*设计用于组合的脚本*食谱。
- en: 'Import the essential functions from the working modules. In this case, the
    two modules have the relatively uninteresting names, `ch13_r05` and `ch13_r06`
    :'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从工作模块中导入基本函数。在这种情况下，这两个模块的名称相对不那么有趣，`ch13_r05`和`ch13_r06`：
- en: '[PRE87]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Import any other modules required. We''ll use a `Counter`  function to prepare
    the summaries in this example:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的任何其他模块。在本示例中，我们将使用`Counter`函数来准备摘要：
- en: '[PRE88]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Create a new function that combines the existing functions from the other applications.
    The output from one function is input to another:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新函数，该函数将来自其他应用程序的现有函数组合在一起。一个函数的输出是另一个函数的输入：
- en: '[PRE89]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In many cases, it makes more sense to explicitly stack the functions, creating
    intermediate results. This is particularly important when there are multiple functions
    creating a kind of map-reduce pipeline:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，明确地堆叠函数，创建中间结果更有意义。当有多个函数创建一种映射-减少管道时，这一点尤为重要：
- en: '[PRE90]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We've broken the processing into steps with intermediate variables. The `game_roll_history`
    variable is the output from the `roll_iter()` function. The output from this generator
    is the iterable input to the `gather_states()` function, which is saved in the
    `game_statistics` variable.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将处理分解为具有中间变量的步骤。`game_roll_history`变量是`roll_iter()`函数的输出。这个生成器的输出是`gather_states()`函数的可迭代输入，保存在`game_statistics`变量中。
- en: 'Write the output-formatting functions that use this composite process. Here,
    for example, is a composite process that exercises the `summarize_games()` function.
    This also writes the output report:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写使用此复合过程的输出格式化函数。例如，这是一个练习`summarize_games()`函数的复合过程。这也编写了输出报告：
- en: '[PRE91]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Gathering command-line options can be done using the `argparse` module. There
    are examples of this in recipes including the  *Designing scripts for composition*
    recipe.
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`argparse`模块来收集命令行选项。有关此内容的示例包括*设计用于组合的脚本*食谱。
- en: How it works...
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The central feature of this design is a separation of the various concerns of
    the application into isolated functions or classes. The two component applications
    started with a design divided up among input, process, and output concerns. Starting
    from this base made it easy to import and reuse the processing. This also left
    the two original applications in place, unchanged.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的核心特点是将应用程序的各种关注点分离为独立的函数或类。这两个组件应用程序从输入、处理和输出关注点开始进行了设计。从这个基础开始，很容易导入和重用处理。这也使得两个原始应用程序保持不变。
- en: The objective is to import functions from working modules and avoid copy and
    paste programming. Copying a function from one file and pasting it into another
    means that any change made to one is unlikely to be made to the other. The two
    copies will slowly diverge, leading to a phenomenon sometimes called *code rot*
    .
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是从工作模块中导入函数，并避免复制和粘贴编程。从一个文件复制一个函数并粘贴到另一个文件意味着对一个文件所做的任何更改不太可能被应用到另一个文件。这两个副本将慢慢分歧，导致有时被称为*代码腐烂*的现象。
- en: 'When a class or function does several things, the reuse potential is reduced.
    This leads to the observation of **Inverse Power Law of Reuse** —the re-usability
    of a class or function, *R(c)* , is related to the inverse of the number of features
    in that class or function, *F(c)* :'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类或函数做了几件事时，重用潜力会减少。这导致了**重用的反向幂定律**的观察——类或函数的可重用性*R(c)*与该类或函数中特性数量的倒数*F(c)*有关：
- en: '*R* ( *c* ) ∝ 1 / *F* ( *c* )'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '*R*（*c*）∝ 1 / *F*（*c*）'
- en: A single feature aids reuse. Multiple features reduce the opportunities for
    reuse of a component.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 单一特性有助于重用。多个特性会减少组件重用的机会。
- en: When we look at the two original applications from the *Designing scripts for
    composition* and *Using logging for control and audit output* recipes, we can
    see that the essential functions had few features. The `roll_iter()` function
    simulated a game, and yielded results. The `gather_stats()` function gathered
    statistics from any source of data.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看*设计用于组合的脚本*和*使用日志记录进行控制和审计输出*食谱中的两个原始应用程序时，我们可以看到基本函数的特性很少。`roll_iter()`函数模拟了一个游戏，并产生了结果。`gather_stats()`函数从任何数据源中收集统计信息。
- en: The idea of counting features depends, of course, on the level of abstraction.
    From a small-scale view, the functions do many small things. From a very large
    scale view, the functions require several helpers to form a complete application;
    from this viewpoint, an individual function is only a part of a feature.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 计数特性的想法当然取决于抽象级别。从小规模的视角来看，函数会做很多小事情。从非常大的尺度来看，函数需要几个辅助程序来形成一个完整的应用程序；从这个角度来看，单个函数只是一个特性的一部分。
- en: Our focus here is on technical features of the software. This has nothing to
    do with the agile concept of feature as a unifying concept behind multiple user
    stories. In this context, we're talking about software architecture technical
    features—input, output, processing, OS resources used, dependencies, and so on.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的重点是软件的技术特性。这与敏捷概念中的特性作为多个用户故事背后的统一概念无关。在这种情况下，我们谈论的是软件架构技术特性——输入、输出、处理、使用的操作系统资源、依赖关系等等。
- en: Pragmatically, the relevant technical features are tied to user stories. This
    puts the scale question into the realm of software properties as perceived by
    users. If the user sees more than one feature, it means that reuse may be a struggle.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 从实用的角度来看，相关的技术特性与用户故事相关。这将把规模问题置于用户所感知的软件属性领域。如果用户看到多个特性，这意味着重用可能会有困难。
- en: In this case, one application created files. The second application summarized
    files. Feedback from users may have revealed that the distinction was not important
    or perhaps confusing. This lead to a redesign to create a one-step operation from
    the two original steps.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，一个应用程序创建文件。第二个应用程序总结文件。用户的反馈可能表明区分并不重要，或者可能令人困惑。这导致重新设计，从两个原始步骤创建一个一步操作。
- en: There's more...
  id: totrans-556
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We''ll look at three other architectural features that can be part of the composite
    application:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看另外三个可以成为组合应用程序一部分的架构特性：
- en: '**Refactoring** : The *Combining two applications into one* recipe did not
    properly distinguish between processing and output. When trying to create a composite
    application, we may need to refactor the component modules.'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构**：*将两个应用程序合并为一个*的方法没有正确区分处理和输出。在尝试创建一个组合应用程序时，我们可能需要重构组件模块。'
- en: '**Concurrency** : Running several `roll_iter()` instances in parallel to use
    multiple cores.'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发**：并行运行多个`roll_iter()`实例以使用多个核心。'
- en: '**Logging** : When multiple applications are combined, the combined logging
    can become complex.'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志记录**：当多个应用程序组合在一起时，组合日志记录可能变得复杂。'
- en: Refactoring
  id: totrans-561
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构
- en: 'In some cases, it becomes necessary to rearrange software to extract the useful
    features. In one of the components, the `ch13_r06` module, the following function
    was available:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，有必要重新安排软件以提取有用的特性。在一个组件中，`ch13_r06`模块中有以下函数：
- en: '[PRE92]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This combines source file iteration, detailed processing, and output creation
    in one place. The `result_file.write()` output processing is a single, complex
    statement that's difficult to extract from this function.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 这将源文件迭代、详细处理和输出创建结合在一起。`result_file.write()`输出处理是一个单一的复杂语句，很难从这个函数中提取出来。
- en: In order to reuse this feature properly between two applications, we'll need
    to refactor the `ch13_r06` application so that the file output is not buried in
    the `process_all_files()` function. In this case, the refactoring isn't too difficult.
    In some cases, the wrong abstractions are chosen, and the refactoring is extremely
    difficult.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在两个应用程序之间正确地重用此特性，我们需要重构`ch13_r06`应用程序，以便文件输出不被埋在`process_all_files()`函数中。在这种情况下，重构并不太困难。在某些情况下，选择了错误的抽象，重构会变得非常困难。
- en: One line of code, `result_file.write(...)` , needs to be replaced with a separate
    function. This is a small change. Details are left as an exercise for the reader.
    When defined as a separate function, it is easier to replace.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 一行代码，`result_file.write(...)`，需要用一个单独的函数替换。这是一个小改变。具体细节留给读者作为练习。当定义为一个单独的函数时，更容易替换。
- en: This refactoring makes the new function available for other composite applications.
    When multiple applications share a common function, then it's much more likely
    that outputs between the applications are actually compatible.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重构使得新函数可以用于其他组合应用程序。当多个应用程序共享一个公共函数时，这样输出之间的兼容性更高。
- en: Concurrency
  id: totrans-568
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并发
- en: The underlying reason for running many simulations followed by a single summary
    is a kind of map-reduce design. The detailed simulations can be run concurrently,
    using multiple cores and multiple processors. The final summary, however, needs
    to be created from all of the simulations via a statistical reduction.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 运行许多模拟，然后进行单个摘要的根本原因是一种map-reduce设计。详细的模拟可以并行运行，使用多个核心和多个处理器。然而，最终摘要需要通过统计减少从所有模拟中创建。
- en: We often use OS features to run multiple concurrent processes. The POSIX shells
    include the `&` operator which can be used to fork concurrent subprocesses. Windows
    has a `**start**` command, which is similar. We can leverage Python directly to
    spawn a number of concurrent sumulation processes.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用操作系统特性来运行多个并发进程。POSIX shell包括`&`运算符，可以用于分叉并发子进程。Windows有一个`**start**`命令，类似。我们可以直接利用Python来生成多个并发模拟进程。
- en: 'One module for doing this is the `futures` module from the `concurrent` package.
    We can build a parallel simulation processor by creating an instance of `ProcessPoolExecutor`
    . We can submit requests to this executor and then collect the results from those
    concurrent requests:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 用于执行此操作的一个模块是`concurrent`包中的`futures`模块。我们可以通过创建`ProcessPoolExecutor`的实例来构建一个并行模拟处理器。我们可以向这个执行程序提交请求，然后收集这些并发请求的结果：
- en: '[PRE93]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We''ve initialized three objects: `start` , `total_stats` , and `worker_list`
    . The `start` object has the time at which processing started; `time.perf_counter()`
    is often the most accurate timer available. `total_stats` is a `Counter` object
    that will collect the final statistical summary. `worker_list` will be a list
    of individual `Future` objects, one for each request that''s made.'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化了三个对象：`start`，`total_stats`和`worker_list`。`start`对象记录了处理开始的时间；`time.perf_counter()`通常是最准确的可用计时器。`total_stats`是一个`Counter`对象，将收集最终的统计摘要。`worker_list`将是一个单独的`Future`对象列表，每个请求都有一个。
- en: The `ProcessPoolExecutor`  method defines a processing context in which a pool
    of workers are available to handle requests. By default, the pool has as many
    workers as the number of processors. Each worker process is running an executor
    which imports the given module. All functions and classes defined in the module
    are available to the workers.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessPoolExecutor`方法定义了一个处理上下文，其中有一个工作池可用于处理请求。默认情况下，池中的工作进程数量与处理器数量相同。每个工作进程都在导入给定模块的执行器中运行。模块中定义的所有函数和类都可供工作进程使用。'
- en: The `submit()` method of an executor is given a function to execute along with
    arguments to that function. In this example, there will be 100 requests made,
    each of which will simulate 1,000 games and return the sequence of dice rolls
    for those games. `submit()` returns a `Future` object, which is a model for the
    working request.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器的`submit()`方法会执行一个函数以及该函数的参数。在这个例子中，将进行100个请求，每个请求将模拟1,000场比赛，并返回这些比赛的骰子点数序列。`submit()`返回一个`Future`对象，它是工作请求的模型。
- en: After submitting all 100 requests, the results are collected. The `result()`
    method of a `Future` object waits for the processing to finish and gathers the
    resulting object. In this example, the result is a statistical summary of 1,000
    games. These are then combined to create the overall `total_stats` summary.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交所有100个请求后，收集结果。`Future`对象的`result()`方法等待处理完成并收集结果对象。在这个例子中，结果是1,000场比赛的统计摘要。然后将它们组合成整体的`total_stats`摘要。
- en: 'Here''s a comparison between serial and parallel execution:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是串行和并行执行之间的比较：
- en: '[PRE94]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The processing time is cut in half. Since there are 100 concurrent requests,
    why isn't the time cut by 1/100th of the original time? The observation is that
    there is considerable overhead in spawning the subprocesses, communicating the
    request data, and communication the result data.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 处理时间减少了一半。由于有100个并发请求，为什么时间没有减少原始时间的1/100？观察到在生成子进程、通信请求数据和通信结果数据方面存在相当大的开销。
- en: Logging
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录
- en: In the *Using logging for control and audit output* recipe, we looked at how
    to use the `logging` module for control, audit, and error outputs. When we build
    a composite application, we'll have to combine the logging features from each
    of the original applications.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用日志进行控制和审计输出*的示例中，我们看到了如何使用`logging`模块进行控制、审计和错误输出。当构建复合应用程序时，我们将不得不结合原始应用程序的每个日志功能。
- en: 'Logging involves a three-part recipe:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 记录涉及三个部分的步骤：
- en: Creating logger objects. This is generally a line such as `logger = logging.get_logger('some_name')`
    . It's generally done once at the class or module level.
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建记录器对象。通常是一行代码，如`logger = logging.get_logger('some_name')`。通常在类或模块级别执行一次。
- en: Using the logger objects to collect events. This involves lines such as `logger.info('some
    message')` . These lines are scattered throughout an application.
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用记录器对象收集事件。这涉及到诸如`logger.info('some message')`这样的行。这些行分散在整个应用程序中。
- en: 'Configuring the logging system as a whole. There are two possibilities for
    log configuration in an application:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整体配置日志系统。应用程序中有两种日志配置可能性：
- en: 'As external as possible. In this case, the logging configuration is done only
    at the outermost, global scope of the application:'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能外部化。在这种情况下，日志配置仅在应用程序的最外层全局范围内完成：
- en: '[PRE95]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This guarantees that there will only be a single configuration of the logging
    system.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 这保证了日志系统只有一个配置。
- en: Somewhere inside a class, function, or module. In this case, we may have several
    modules that are all attempting to do logging configuration. This is tolerated
    by the logging system. It can, however, be confusing to debug.
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类、函数或模块的某个地方。在这种情况下，我们可能有几个模块都试图进行日志配置。这是由日志系统容忍的。但是，调试可能会令人困惑。
- en: These recipes all follow the first approach. If all applications configure logging
    in the most global scope, then it's easy to understand how to configure a composite
    application.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例都遵循第一种方法。如果所有应用程序都在最全局范围内配置日志记录，那么很容易理解如何配置复合应用程序。
- en: 'In cases where there are multiple logging configurations, there are two approaches
    that a composite application can follow:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在存在多个日志配置的情况下，复合应用程序可以采用两种方法：
- en: 'The composite application contains a final configuration, which intentionally
    overwrites all previously-defined loggers. This is the default, and can be stated
    explicitly via `incremental: false` in a YAML configuration document.'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '复合应用程序包含最终配置，它有意覆盖了先前定义的所有记录器。这是默认设置，并可以通过在YAML配置文档中明确说明`incremental: false`来表示。'
- en: 'The composite application preserves other application loggers, and merely modifies
    the logger configurations, perhaps by setting the overall level. This is done
    by including `incremental: true` in the YAML configuration document.'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '复合应用程序保留其他应用程序记录器，仅修改记录器配置，可能是通过设置整体级别。这是通过在YAML配置文档中包含`incremental: true`来完成的。'
- en: The use of incremental configuration is helpful when combining Python applications
    that don't isolate the logging configuration. It can take some time to read and
    understand the code from each application in order to properly configure logging
    for composite applications.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 当组合Python应用程序时，增量配置对于不隔离日志配置的应用程序非常有用。为了正确为复合应用程序配置日志，可能需要一些时间来阅读和理解每个应用程序的代码。
- en: See also
  id: totrans-595
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In the *Designing scripts for composition* recipe, we looked at the core design
    pattern for a composable application
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*为组合设计脚本*配方中，我们看了一个可组合应用程序的核心设计模式
- en: Combining many applications using the Command design pattern
  id: totrans-597
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Command设计模式组合多个应用程序
- en: Many complex suites of applications follow a design pattern similar to the one
    used by the Git program. There's a base command, `git` , with a number of subcommands.
    For example, `git pull` , `git commit` , and `git push` .
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 许多复杂的应用程序套件遵循与Git程序类似的设计模式。有一个基本命令`git`，有许多子命令。例如，`git pull`，`git commit`和`git
    push`。
- en: What's central to this design is the idea of a collection of individual commands.
    Each of the various features of git can be thought of as a separate class definition
    that performs a given function.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计的核心是一系列单独的命令。git的各种功能可以被看作是执行给定功能的单独类定义。
- en: When we enter a command such as `git pull` , it's as if the program, `git` ,
    is locating a class to implement the command.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入诸如`git pull`这样的命令时，就好像程序`git`正在定位一个实现该命令的类。
- en: How can we create families of closely related commands?
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何创建一系列密切相关的命令？
- en: Getting ready
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll imagine an application built from three commands. This is based on the
    applications shown in the  *Designing scripts for composition* , *Using logging
    for control and audit output* , and *Combining two applications into one*  recipes.
    We'll have three applications— *simulate* , *summarize* , and a combined application
    called *simsum* .
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将想象一个由三个命令构建的应用程序。这是基于*为组合设计脚本*，*使用日志进行控制和审计输出*和*将两个应用程序合并为一个*配方中显示的应用程序。我们将有三个应用程序——*模拟*，*总结*和一个名为*simsum*的组合应用程序。
- en: These features are based on modules with names such as `ch13_r05` , `ch13_r06`
    , and `ch13_r07` . The idea is that we can restructure these separate modules
    into a single class hierarchy following the Command design pattern.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能基于诸如`ch13_r05`，`ch13_r06`和`ch13_r07`之类的模块。这个想法是我们可以将这些单独的模块重组成一个遵循Command设计模式的单一类层次结构。
- en: 'There are two key ingredients to this design:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计有两个关键要素：
- en: The client depends only on the abstract superclass, `Command` .
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端只依赖于抽象超类`Command`。
- en: Each individual subclass of the `Command` superclass has an identical interface.
    We can substitute any one of them for any other.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Command`超类的每个单独子类都有一个相同的接口。我们可以用其中任何一个替换其他任何一个。'
- en: When we've done this, then an overall application script can create and execute
    any one of the `Command` subclasses.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成这个之后，一个整体的应用程序脚本可以创建和执行任何一个`Command`子类。
- en: How to do it...
  id: totrans-609
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The overall application will have a structure that attempts to separate the
    features into two categories—argument parsing and command execution. Each subcommand
    will include both processing and the output bundled together.
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整体应用程序将具有一种结构，试图将功能分为两类——参数解析和命令执行。每个子命令都将包括处理和输出捆绑在一起。
- en: 'Here''s the `Command` superclass:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Command`超类：
- en: '[PRE96]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We're going to rely on the `argparse.Namespace` to provide a very flexible collection
    of options to each subclass. This is not required, but will be helpful in the
    *Managing arguments and configuration in composite applications* recipe. Since
    that recipe will include option parsing, it seems best to focus each class on
    using `argparse.Namespace` .
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依赖于`argparse.Namespace`为每个子类提供一个非常灵活的选项集合。这不是必需的，但在*管理复合应用程序中的参数和配置*配方中会很有帮助。由于该配方将包括选项解析，因此似乎最好专注于每个类使用`argparse.Namespace`。
- en: 'Create a subclass of the `Command` superclass for the `Simulate` command:'
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Simulate`命令创建`Command`超类的子类：
- en: '[PRE97]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We've wrapped the processing and output from the `ch13_r05` module into the
    `execute()` method of this class.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`ch13_r05`模块的处理和输出包装到这个类的`execute()`方法中。
- en: 'Create a subclass of the `Command` superclass for the `Summarize` command:'
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Summarize`命令创建`Command`超类的子类：
- en: '[PRE98]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: For this class, we've wrapped the file creation and the file processing into
    the `execute()` method of the class.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个类，我们已经将文件创建和文件处理包装到类的`execute()`方法中。
- en: 'All of the overall processes can be performed by the following `main()` function:'
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有的整体过程都可以由以下`main()`函数执行：
- en: '[PRE99]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: We've created two commands, an instance of `Simulate` class, and an instance
    of the `Summarize` class. These can be executed to provide a combined feature
    that both simulates and summarizes data.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个命令，一个是`Simulate`类的实例，另一个是`Summarize`类的实例。这些可以被执行以提供一个同时模拟和总结数据的组合功能。
- en: How it works...
  id: totrans-623
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Creating interchangeable, polymorphic classes for the various subcommands is
    a handy way to provide an extensible design. The `Command` design pattern strongly
    encourages each individual subclass to have an identical signature so that any
    command can be created and executed. Also, new commands can be added that fit
    the framework.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 为各种子命令创建可互换的多态类是提供可扩展设计的一种方便方式。`Command`设计模式强烈鼓励每个单独的子类具有相同的签名，以便可以创建和执行任何命令。此外，可以添加适合框架的新命令。
- en: One of the SOLID design principles is the **Liskov Substitution Principle**
    ( **LSP** ). Any of the subclasses of the `Command` abstract class can be used
    in place of the parent class.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID设计原则之一是**Liskov替换原则**（**LSP**）。`Command`抽象类的任何子类都可以替代父类。
- en: 'Each `Command` instance has a simple interface. There are two features:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Command`实例都有一个简单的接口。有两个功能：
- en: The `__init__()` method expects a namespace object that's created by the argument
    parser. Each class will pick only the needed values from this namespace, ignoring
    any others. This allows global arguments to be ignored by a subcommand that doesn't
    require it.
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`方法期望由参数解析器创建的命名空间对象。每个类将只从这个命名空间中选择所需的值，忽略其他任何值。这允许子命令忽略不需要的全局参数。'
- en: The `execute()` method does the processing and writes any output. This is based
    entirely on the values provided during initialization.
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute()`方法执行处理并写入任何输出。这完全基于初始化期间提供的值。'
- en: The use of the Command design pattern makes it easy to be sure that they can
    be interchanged with each other. The overall `main()` script can create instances
    of the `Simulate` or the `Summarize` class. The substitution principle means that
    either instance can be executed because the interfaces are the same. This flexibility
    makes it easy to parse the command-line options and create an instance of either
    of the available classes. We can extend this idea and create sequences of individual
    command instances.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令设计模式可以确保它们可以互换。整个`main()`脚本可以创建`Simulate`或`Summarize`类的实例。替换原则意味着任一实例都可以执行，因为接口是相同的。这种灵活性使得解析命令行选项并创建任一可用类的实例变得容易。我们可以扩展这个想法并创建单个命令实例的序列。
- en: There's more...
  id: totrans-630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'One of the more common extensions to this design pattern is to provide for
    composite commands. In the *Combining two applications into one* recipe, we showed
    one way to create composites. This is another way, based on defining a new command
    that implements a combination of existing commands:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式的更常见扩展之一是提供组合命令。在*将两个应用程序合并为一个*的示例中，我们展示了创建组合的一种方法。这是另一种方法，基于定义一个实现现有命令组合的新命令：
- en: '[PRE100]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This class will accept other `Command` classes via the `*commands` parameter.
    This sequence will combine all of the positional argument values. From the classes,
    it will build the individual class instances.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将通过`*commands`参数接受其他`Command`类。这个序列将组合所有的位置参数值。它将从这些类中构建单独的类实例。
- en: 'We might use this `CommandSequence` class like this:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用`CommandSequence`类：
- en: '[PRE101]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We created an instance of `CommandSequence` using two other classes—`Simulate`
    and `Summarize` . The `__init__()` method will build an internal sequence of the
    two objects. The `execute()` method of the `sim_sum_command` object will then
    perform the two processing steps in sequence.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了两个其他类`Simulate`和`Summarize`创建了一个`CommandSequence`的实例。`__init__()`方法将构建这两个对象的内部序列。然后`sim_sum_command`对象的`execute()`方法将按顺序执行这两个处理步骤。
- en: This design, while simple, exposes many implementation details. In particular,
    the two class names, and the intermediate `x.yaml` file are details that can be
    encapsulated into a better class design.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计虽然简单，但暴露了许多实现细节。特别是两个类名和中间的`x.yaml`文件是可以封装到更好的类设计中的细节。
- en: 'We can create a slightly nicer subclass of `CommandSequence`  argument if we
    focus specifically on the two commands being combined. This will have an `__init__()`
     method that follows the pattern of other `Command` subclasses:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们专门关注被组合的两个命令，我们可以创建一个稍微更好的`CommandSequence`子类参数。这将有一个`__init__()`方法，遵循其他`Command`子类的模式：
- en: '[PRE102]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This class definition incorporates two other classes into the already defined
    `CommandSequence` structure. We can continue this idea by also modifying the options
    slightly to eliminate the explicit values for `game_file` output from the `Simulate`
    step, which must also be part of the `game_files` input to the `Summarize` step.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类定义将两个其他类合并到已定义的`CommandSequence`结构中。我们可以通过稍微修改选项来继续这个想法，以消除`Simulate`步骤中`game_file`的显式值，这也必须是`Summarize`步骤的`game_files`输入的一部分。
- en: 'We want to build and use a simpler `Namespace` with options like this:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要构建和使用一个更简单的`Namespace`，其选项如下：
- en: '[PRE103]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'This means that some missing options must be injected by the `execute()` method.
    We''ll add this method to the `SimSum` class:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一些缺失的选项必须由`execute()`方法注入。我们将把这个方法添加到`SimSum`类中：
- en: '[PRE104]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This `execute()` method clones the options. It adds two additional values that
    are part of the integration of the commands, but not something that a user should
    provide.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`execute()`方法克隆了选项。它添加了两个额外的值，这些值是命令集成的一部分，但不是用户应该提供的。
- en: This design avoids updating the stateful set of options. In order to leave the
    original options object intact, a copy was made. The `vars()` function exposes
    the `Namespace` as a simple dict. We can then use the `**` keyword argument technique
    to make the dictionary into the keyword arguments for a new `Namespace` object.
    This will create a shallow copy. If any stateful objects within the namespace
    are updated, it will be clear that both the original `options` and `new_namespace`
     arguments have access to the same underlying value objects.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计避免了更新有状态的选项集。为了保持原始选项对象不变，我们进行了复制。`vars()`函数将`Namespace`公开为一个简单的字典。然后我们可以使用`**`关键字参数技术将字典转换为新的`Namespace`对象的关键字参数。这将创建一个浅拷贝。如果命名空间内的有状态对象被更新，原始的`options`和`new_namespace`参数都可以访问相同的基础值对象。
- en: Since `new_namespace` is a distinct collection, we can add new keys and values
    to this `Namespace` instance. These will only appear in `new_namespace` , leaving
    the original options object alone.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`new_namespace`是一个独立的集合，我们可以向这个`Namespace`实例添加新的键和值。这些只会出现在`new_namespace`中，不会影响原始选项对象。
- en: See also
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In the *Designing scripts for composition* , *Using logging for control and
    audit output* , and *Combining two applications into one* recipes, we looked at
    the constituent parts of this composite application. In most cases, we'll need
    to combine elements of all of these recipes to create a useful application.
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*为组合设计脚本*、*使用日志进行控制和审计输出*和*将两个应用程序合并为一个*的示例中，我们看了这个组合应用程序的组成部分。在大多数情况下，我们需要结合所有这些示例的元素来创建一个有用的应用程序。
- en: We'll often need to follow the *Managing arguments and configuration in composite
    applications* recipe.
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们经常需要遵循*在组合应用程序中管理参数和配置*的示例。
- en: Managing arguments and configuration in composite applications
  id: totrans-651
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在组合应用程序中管理参数和配置
- en: When we have a complex suite (or system) of individual applications, it's common
    for several applications to share common features. We can, of course, use ordinary
    inheritance to define a library module that provides the common classes and functions
    to each of the individual applications in a complex suite.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一套复杂的单独应用程序（或系统）时，几个应用程序共享共同特征是很常见的。当然，我们可以使用普通的继承来定义一个库模块，为复杂套件中的每个单独应用程序提供共同的类和函数。
- en: The downside of creating a number of separate applications is that the external
    CLI is tied directly to the software architecture. It becomes awkward to rearrange
    the software components because changes will also alter the visible CLI.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 创建许多单独应用程序的缺点是外部CLI直接与软件架构相关联。重新排列软件组件变得笨拙，因为更改也会改变可见的CLI。
- en: The coordination of common features among many application files can become
    awkward. For example, defining the various, one-letter abbreviated options for
    command-line arguments is difficult. It requires keeping some kind of master list
    of options, outside all of the individual application files. It seems like this
    should be kept in one place in the code somewhere.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用文件之间共同特征的协调可能变得笨拙。例如，定义命令行参数的各种一字母缩写选项是困难的。这需要在所有单个应用文件之外保持某种选项的主列表。看起来这应该在代码的某个地方集中保存。
- en: Is there an alternative to inheritance? How can we assure that a suite of applications
    can be refactored without creating unexpected changes to the CLI or requiring
    complex additional design notes?
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有继承的替代方案？如何确保一套应用程序可以重构而不会对CLI造成意外更改或需要复杂的额外设计说明？
- en: Getting ready
  id: totrans-656
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Many complex suites of applications follow a design pattern similar to the one
    used by Git. There's a base command, `git` , with a number of subcommands. For
    example, `git pull` , `git commit` , and `git push` . The core of the command-line
    interface can be centralized by the `git` command. The subcommands can then be
    organized and reorganized as needed with fewer changes to the visible CLI.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 许多复杂的应用套件遵循与Git使用的相似的设计模式。有一个基本命令`git`，带有许多子命令。例如，`git pull`，`git commit`和`git
    push`。命令行界面的核心可以由`git`命令集中。然后可以根据需要组织和重新组织子命令，而对可见CLI的更改较少。
- en: 'We''ll imagine an application built from three commands. This is based on the
    applications shown in the *Designing scripts for composition* , *Using logging
    for control and audit output* , and *Combining two applications into one*  recipes.
    We''ll have three applications with three commands: `craps simulate` , `craps
    summarize` , and the combined application `craps simsum` .'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将想象一个由三个命令构建的应用程序。这是基于*为组合设计脚本*，*使用日志记录进行控制和审计输出*和*将两个应用程序合并为一个*配方中显示的应用程序。我们将有三个应用程序，每个应用程序有三个命令：`craps
    simulate`，`craps summarize`和组合应用程序`craps simsum`。
- en: 'We''ll rely on the subcommand design from the *Combining many applications
    using the Command design pattern* recipe. This will provide a handy hierarchy
    of `Command` subclasses:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依赖于*使用命令设计模式合并多个应用程序*配方中的子命令设计。这将提供`Command`子类的方便层次结构：
- en: The `Command` class is an abstract superclass
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Command`类是一个抽象超类。'
- en: The `Simulate` subclass performs the simulation functions from the *Designing
    scripts for composition* recipe
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Simulate`子类执行*为组合设计脚本*配方中的模拟功能。'
- en: The `Summarize` subclass performs summarization functions from the *Using logging
    for control and audit output* recipe
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Summarize`子类执行*使用日志记录进行控制和审计输出*配方中的总结功能。'
- en: A `SimSum` subclass can perform combined simulation and summarization, following
    the ideas of the *Combining two applications into one* recipe
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimSum`子类可以执行组合模拟和总结，遵循*将两个应用程序合并为一个*的想法。'
- en: In order to create a simple command-line application, we'll need appropriate
    argument parsing.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个简单的命令行应用程序，我们需要适当的参数解析。
- en: This argument parsing will rely on the subcommand parsing capability of the
    `argparse` module. We can create a common set of command options that apply to
    all subcommands. We can also create unique options for each subcommand.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数解析将依赖于`argparse`模块的子命令解析能力。我们可以创建适用于所有子命令的一组公共命令选项。我们还可以为每个子命令创建唯一的选项。
- en: How to do it...
  id: totrans-666
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Define the command interface. This is an exercise in **User Experience** ( **UX**
    ) design. While most UX is focused on web and mobile device applications, the
    core principles are appropriate for CLI applications and servers, as well.
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义命令界面。这是一种**用户体验**（**UX**）设计练习。虽然大多数UX都集中在Web和移动设备应用程序上，但核心原则也适用于CLI应用程序和服务器。
- en: 'Earlier, we noted that the root application will be `craps` . It will have
    the following three subcommands:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们注意到根应用程序将是`craps`。它将有以下三个子命令：
- en: '[PRE105]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Define the root Python application. Consistent with other files in this book,
    we'll call it `ch13_r08.py` . At the OS level, we can provide an alias or a link
    to make the visible interface match the user expectation of `craps` .
  id: totrans-670
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义根Python应用程序。与本书中的其他文件一致，我们将称其为`ch13_r08.py`。在操作系统级别，我们可以提供一个别名或链接，使可见界面与用户对`craps`的期望相匹配。
- en: We'll import the class definitions from the *Combining many applications using
    the Command design pattern* recipe. This will include the `Command` superclass
    and the `Simulate` , `Summarize` , and `SimSum` subclasses.
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从*使用命令设计模式合并多个应用程序*配方中导入类定义。这将包括`Command`超类和`Simulate`，`Summarize`和`SimSum`子类。
- en: 'Create the overall argument parser then create a subparser builder. The `subparsers`
    object will be used to create each subcommand''s argument definition:'
  id: totrans-672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建整体参数解析器，然后创建一个子解析器构建器。`subparsers`对象将用于创建每个子命令的参数定义：
- en: '[PRE106]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: For each command, create a parser and add arguments that are unique to that
    command.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个命令，创建一个解析器，并添加该命令特有的参数。
- en: 'Define the `simulate` command with the two options that are unique to simulation.
    We''ll also provide a special default value that will initialize the resulting
    `Namespace` object:'
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个唯一于模拟的选项定义`simulate`命令。我们还将提供一个特殊的默认值，用于初始化生成的`Namespace`对象：
- en: '[PRE107]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Define the `summarize` command, with the arguments unique to this command.
    Provide the default value that will populate the `Namespace` object:'
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`summarize`命令，带有此命令特有的参数。提供将填充`Namespace`对象的默认值：
- en: '[PRE108]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Define the `simsum` command, and similarly, provide a unique default value
    that makes processing the `Namespace` easier:'
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`simsum`命令，并类似地提供一个独特的默认值，以便更轻松地处理`Namespace`：
- en: '[PRE109]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Parse the command-line values. In this case the overall argument to the `get_options()`
    function is expected to be the value of `sys.argv[1:]` , which includes the arguments
    to the Python command. We can override the argument value for testing purposes:'
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析命令行值。在这种情况下，`get_options()`函数的整体参数预期是`sys.argv[1:]`的值，其中包括Python命令的参数。我们可以覆盖参数值以进行测试：
- en: '[PRE110]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The overall parser includes three subcommand parsers. One will handle the `craps
    simulate` command, another handles `craps summarize` , and the third handles `craps
    simsum` . Each subcommand has slightly different combinations of options.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 整体解析器包括三个子命令解析器。一个将处理`craps simulate`命令，另一个处理`craps summarize`，第三个处理`craps simsum`。每个子命令具有略有不同的选项组合。
- en: The `command` option is set only via the `set_defaults()` method. This sends
    useful, additional information about the command to be executed. In this case,
    we've provided the class that must be instantiated.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '`command`选项只能通过`set_defaults()`方法设置。这会发送有关要执行的命令的有用的附加信息。在这种情况下，我们提供了必须实例化的类。'
- en: 'The overall application is defined by the following `main()` function:'
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整体应用程序由以下`main()`函数定义：
- en: '[PRE111]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The options will be parsed. Each distinct subcommand sets a unique class value
    for the `options.command`  argument. This class is used to build an instance of
    a `Command` subclass. This object will have an `execute()` method that does the
    real work of this command.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 选项将被解析。每个不同的子命令为`options.command`参数设置一个唯一的类值。这个类用于构建`Command`子类的实例。这个对象将有一个`execute()`方法，用于执行这个命令的真正工作。
- en: 'Implement the OS wrapper for the root command. We might have a file named `craps`
    . The file would have rx permissions so that it was readable by other users. The
    content of the file could be this line:'
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现根命令的操作系统包装器。我们可能有一个名为`craps`的文件。该文件将具有rx权限，以便其他用户可以读取。文件的内容可能是这一行：
- en: '[PRE112]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This small shell script provides a handy way to enter a command of `**craps**`
    and have it properly execute a Python script with a different name.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小的shell脚本提供了一个方便的方式来输入一个`**craps**`命令，并使其正确执行一个具有不同名称的Python脚本。
- en: 'We can create a bash shell alias like this:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样创建一个bash shell别名：
- en: '[PRE113]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: This can be placed in a `.bashrc` file to define a `**craps**` command.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以放在`.bashrc`文件中以定义一个`**craps**`命令。
- en: How it works...
  id: totrans-694
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'There are two parts to this recipe:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方有两个部分：
- en: Using the `Command` design pattern to define a related set of classes that are
    polymorphic. For more information on this, see the *Combining many applications
    using the Command design pattern* recipe.
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Command`设计模式来定义一组相关的多态类。有关更多信息，请参阅*使用命令设计模式组合多个应用程序*配方。
- en: Using features of the `argparse` module to handle subcommands.
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`argparse`模块的特性来处理子命令。
- en: The `argparse` module feature that's important here is the `add_subparsers()`
    method of a parser. This method returns an object that is used to build each distinct
    subcommand parser. We assigned this object to the variable `subparsers` .
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的`argparse`模块特性是解析器的`add_subparsers()`方法。此方法返回一个对象，用于构建每个不同的子命令解析器。我们将此对象分配给变量`subparsers`。
- en: We also defined a simple `command` argument in the top-level parser. This argument
    can only be filled by the defaults defined for each of the sub-parsers. This provides
    a value that shows which of the subcommands was actually invoked.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在顶层解析器中定义了一个简单的`command`参数。这个参数只能由为每个子解析器定义的默认值填充。这提供了一个值，显示实际调用了哪个子命令。
- en: Each sub-parser is built using the `add_parser()` method of the sub-parsers
    object. The `parser` object that is returned can then have arguments and defaults
    defined.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子解析器都是使用子解析器对象的`add_parser()`方法构建的。然后返回的`parser`对象可以定义参数和默认值。
- en: When the overall parser is executed, it will parse any arguments defined outside
    the subcommands. If there's a subcommand, this is used to determine how to parse
    the remaining arguments.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行整体解析器时，它将解析在子命令之外定义的任何参数。如果有子命令，这将用于确定如何解析剩余的参数。
- en: 'Look at the following command:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的命令：
- en: '[PRE114]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'This command will be parsed to create a `Namespace` object that looks like
    this:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将被解析为创建一个像这样的`Namespace`对象：
- en: '[PRE115]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The `command` attribute in the `Namespace` object is the default value provided
    as part of the subcommand definition. The values for `game_file` and `games` come
    from the `-o` and `-g` options.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '`Namespace`对象中的`command`属性是作为子命令定义的一部分提供的默认值。`game_file`和`games`的值来自`-o`和`-g`选项。'
- en: The Command design pattern
  id: totrans-707
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令设计模式
- en: Creating interchangeable, polymorphic classes for the various subcommands creates
    a design that's easily refactored or expanded. The `Command` design pattern strongly
    encourages each individual subclass to have an identical signature so that any
    one of the available command classes can be created and executed.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 为各种子命令创建可互换的多态类，创建一个易于重构或扩展的设计。`Command`设计模式强烈鼓励每个单独的子类具有相同的签名，以便可以创建和执行任何可用的命令类之一。
- en: One of the SOLID design principles is the Liskov Substitution Principle. Any
    of the subclasses of the Command abstract class can be used in place of the parent
    class.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID设计原则之一是Liskov替换原则。命令抽象类的任何子类都可以用于替换父类。
- en: 'Each `Command` has a consistent interface:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Command`都有一个一致的接口：
- en: The `__init__()` method expects a namespace object that's created by the argument
    parser. Each class will pick only the needed values from this namespace, ignoring
    any others. This allows global arguments to be ignored by a subcommand that doesn't
    require it.
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`方法期望由参数解析器创建的命名空间对象。每个类将只从这个命名空间中选择所需的值，忽略其他任何值。这允许全局参数被不需要它的子命令忽略。'
- en: The `execute()` method does the processing and writes any output. This is based
    entirely on the values provided during initialization.
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute()`方法执行处理并写入任何输出。这完全基于初始化时提供的值。'
- en: The use of the Command design pattern makes it easy to ensure that they can
    be interchanged with each other. The substitution principle means that the `main()`
    function can simply create an instance and then execute the `execute()` method
    of the object.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 命令设计模式的使用使得很容易确保它们可以相互替换。替换原则意味着`main()`函数可以简单地创建一个实例，然后执行对象的`execute()`方法。
- en: There's more...
  id: totrans-714
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can consider pushing the subcommand parser details down into each class
    definition. For example, the `Simulate` class defines two arguments:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑将子命令解析器的细节下推到每个类定义中。例如，“模拟”类定义了两个参数：
- en: '[PRE116]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: It doesn't seem appropriate for the `get_option()` function to define these
    details about the implementation class. It seems like a properly encapsulated
    design would allocate this detail to each `Command` subclass.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_option()`函数似乎不应该定义关于实现类的这些细节。一个适当封装的设计似乎应该将这些细节分配给每个`Command`子类。'
- en: 'We would need to add a static method that configures a given parser. The new
    class definitions would look like this:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个配置给定解析器的静态方法。新的类定义将如下所示：
- en: '[PRE117]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'We''ve added a `configure()` method to configure a parser. This change makes
    it very easy to see how the `__init__()` arguments will be created by parsing
    the command-line values. This allows us to rewrite the `get_option()` function,
    as well:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`configure()`方法来配置解析器。这个改变使得很容易看到`__init__()`参数将如何通过解析命令行值来创建。这使我们能够重写`get_option()`函数，如下：
- en: '[PRE118]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: This will leverage the static `configure()` method to provide the parameter
    details. The default value for the command argument can be handled by the overall
    `get_options()` because it doesn't involve internal details.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 这将利用静态的`configure()`方法来提供参数细节。命令参数的默认值可以由整体的`get_options()`处理，因为它不涉及内部细节。
- en: See also
  id: totrans-723
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the  *Designing scripts for composition* , *Using logging for control and
    audit output* , and *Combining two applications into one*  recipes for background
    on the components
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅*为组合设计脚本*，*使用日志记录进行控制和审计输出*和*将两个应用程序合并为一个*的方法，了解组件的背景
- en: See the *Using argparse to get command-line input* recipe in [Chapter 5](text00063.html#page
    "Chapter 5. User Inputs and Outputs") , *User Inputs and Outputs* , for more background
    in argument parsing
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](text00063.html#page "第5章. 用户输入和输出")的*使用argparse获取命令行输入*方法中，了解更多关于参数解析的背景
- en: Wrapping and combining CLI applications
  id: totrans-726
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装和组合CLI应用程序
- en: One common kind of automation involves running several programs, none of which
    are actually Python applications. Since the programs aren't written in Python,
    it's impossible to rewrite each program to create a composite Python application.
    We can't follow the *Combining two applications into one* recipe.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的自动化类型涉及运行几个程序，这些程序实际上都不是Python应用程序。由于这些程序不是用Python编写的，因此不可能重写每个程序以创建一个复合的Python应用程序。我们无法遵循*将两个应用程序合并为一个*的方法。
- en: 'Instead of aggregating the functionality, the alternative is to wrap the other
    programs in Python to provide a higher level construct. The use case is very similar
    to the use case for writing a shell script. The difference is that Python is used
    instead of the shell language. Using Python has some advantages:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 与聚合功能不同，另一种选择是在Python中包装其他程序以提供更高级的构造。使用情况与编写shell脚本的使用情况非常相似。不同之处在于使用Python而不是shell语言。使用Python有一些优势：
- en: Python has a rich collection of data structures. The shell only has strings
    and arrays of strings.
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python拥有丰富的数据结构集合。而shell只有字符串和字符串数组。
- en: Python has an outstanding unit test framework. This provides confidence that
    the Python version of a shell script works without the risk of crashing a widely-used
    service.
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python拥有出色的单元测试框架。这可以确保Python版本的shell脚本可以正常工作，而不会使广泛使用的服务崩溃的风险。
- en: How do we run other applications from within Python?
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从Python中运行其他应用程序？
- en: Getting ready
  id: totrans-732
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the *Designing scripts for composition* recipe, we identified an application
    that did some processing leading to the creation of a rather complex result. For
    the purposes of this recipe, we'll assume that the application is not written
    in Python.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 在*为组合设计脚本*的方法中，我们确定了一个应用程序，该应用程序进行了一些处理，导致了一个相当复杂的结果。对于这个方法，我们假设该应用程序不是用Python编写的。
- en: We'd like to run this program several hundred times, but we don't want to copy
    and paste the necessary commands into a script. Also, because the shell is difficult
    to test and has so few data structures, we'd like to avoid using the shell.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要运行这个程序几百次，但我们不想将必要的命令复制粘贴到脚本中。此外，由于shell很难测试并且数据结构很少，我们希望避免使用shell。
- en: For this recipe, we'll assume that the `ch13_r05` application is a native binary
    application; it might have been written in C++ or Fortran. This means that we
    can't simply import the Python module that comprises the application. Instead,
    we'll have to process this application by running a separate OS process.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个方法，我们假设`ch13_r05`应用程序是一个本地二进制应用程序；它可能是用C++或Fortran编写的。这意味着我们不能简单地导入包含应用程序的Python模块。相反，我们将不得不通过运行一个单独的操作系统进程来处理这个应用程序。
- en: 'We will use the `subprocess` module to run an application program at the OS
    level. There are two common use cases for running another binary program from
    within Python:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`subprocess`模块在操作系统级别运行应用程序。从Python中运行另一个二进制程序有两种常见的用例：
- en: There isn't any output, or we don't want to gather it in our Python program.
    The first situation is typical of OS utilities that return a status code when
    they succeed or fail. The second situation is typical where many child programs
    are all writing to the standard error logs; the parent Python program is merely
    starting a child processes.
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有输出，或者我们不想在我们的 Python 程序中收集它。第一种情况是当 OS 实用程序在成功或失败时返回状态码时的典型情况。第二种情况是当许多子程序都在写入标准错误日志时的典型情况；父
    Python 程序只是启动子进程。
- en: We need to capture and possibly analyze the output to retrieve information or
    ascertain the level of success.
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要捕获并可能分析输出以检索信息或确定成功的级别。
- en: In this recipe, we'll look at the first case—the output isn't something we need
    to capture. In the *Wrapping a program and checking the output* recipe, we'll
    look at the second case, where the output is scrutinized by the Python wrapper
    program.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看看第一种情况——输出不是我们需要捕获的东西。在*包装程序并检查输出*配方中，我们将看看第二种情况，即 Python 包装程序对输出进行了审查。
- en: How to do it...
  id: totrans-740
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import the `subprocess` module:'
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `subprocess` 模块：
- en: '[PRE119]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Design the command line. Generally, this should be tested at the OS prompt
    to be sure that it does the right things:'
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计命令行。通常，应该在操作系统提示符下进行测试，以确保它执行正确的操作：
- en: '[PRE120]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The output filename needs to be flexible, so that we can run the program hundreds
    of times. This means creating files with names such as `game_{n}.yaml` .
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件名需要灵活，这样我们可以运行程序数百次。这意味着创建名称为 `game_{n}.yaml` 的文件。
- en: 'Write a statement that iterates through the appropriate commands. Each command
    can be built as a sequence of individual words. Start with the working shell command
    and split that line on the spaces to create a proper sequence of words:'
  id: totrans-746
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个语句，通过适当的命令进行迭代。每个命令可以构建为一系列单词的序列。从工作的 shell 命令开始，并在空格上拆分该行，以创建适当的单词序列：
- en: '[PRE121]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This will create the various commands. We can use a `print()` function to show
    each command and confirm that the filenames are defined properly.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建各种命令。我们可以使用 `print()` 函数显示每个命令，并确认文件名是否定义正确。
- en: 'Evaluate the `run()` function from the `subprocess` module. This will execute
    the given command. Provide `check=True` so that if there''s any problem, it will
    raise a `subprocess.CalledProcessError` exception:'
  id: totrans-749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估 `subprocess` 模块中的 `run()` 函数。这将执行给定的命令。提供 `check=True`，这样如果有任何问题，它将引发 `subprocess.CalledProcessError`
    异常：
- en: '[PRE122]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: In order to test this properly, the entire sequence should be transformed into
    a proper function. If there will be more, related commands in the future, it should
    be a method of a subclass in a `Command` class hierarchy. See the *Managing arguments
    and configuration in composite applications* recipe.
  id: totrans-751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了正确测试这一点，整个序列应该转换为一个适当的函数。如果将来会有更多相关的命令，它应该是 `Command` 类层次结构中的子类的方法。参见*在复合应用程序中管理参数和配置*配方。
- en: How it works...
  id: totrans-752
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `subprocess` module is how Python programs run other programs available
    on a given computer. The `run()` function, does a number of things for us.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '`subprocess` 模块是 Python 程序运行计算机上其他程序的方式。`run()` 函数为我们做了很多事情。'
- en: 'In a POSIX (such as Linux or Mac OS X) context, the steps are similar to the
    following sequence:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 在 POSIX（如 Linux 或 Mac OS X）环境中，步骤类似于以下序列：
- en: Prepare the `stdin` , `stdout` , and `stderr` file descriptors for the child
    process. In this case, we've accepted the defaults, which means that the child
    inherits the files being used by the parent. If the child process prints to `stdout`
    , it will appear on the same console being used by the parent.
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为子进程准备 `stdin`、`stdout` 和 `stderr` 文件描述符。在这种情况下，我们接受了默认值，这意味着子进程继承了父进程正在使用的文件。如果子进程打印到
    `stdout`，它将出现在父进程使用的同一个控制台上。
- en: Invoke the `os.fork()` function to split the current process into a parent and
    a child. The parent will be given the process ID of the child; it can then wait
    for the child to finish.
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `os.fork()` 函数将当前进程分成父进程和子进程。父进程将获得子进程的进程 ID；然后它可以等待子进程完成。
- en: In the child, execute the `os.execl()` function (or a similar function) to provide
    the command path and arguments that will be executed by the child.
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在子进程中，执行 `os.execl()` 函数（或类似的函数）以提供子进程将执行的命令路径和参数。
- en: The child process then runs, using the given `stdin` , `stdout` , and `stderr`
    files.
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后子进程运行，使用给定的 `stdin`、`stdout` 和 `stderr` 文件。
- en: The parent, meanwhile, uses a function such as `os.wait()` to wait for the child
    to finish and return the final status.
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时，父进程使用诸如 `os.wait()` 的函数等待子进程完成并返回最终状态。
- en: Since we used the `check=True` option, a non-zero status is transformed into
    an exception by the `run()` function.
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们使用了 `check=True` 选项，`run()` 函数将非零状态转换为异常。
- en: An OS shell, such as bash, conceals these details from application developers.
    The `subprocess.run()` function, similarly, hides the details of creating and
    waiting for a child process.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: OS shell（如 bash）会向应用程序开发人员隐藏这些细节。`subprocess.run()` 函数同样隐藏了创建和等待子进程的细节。
- en: 'Python, with the `subprocess` module, offers many features similar to the shell.
    Most importantly, Python offers several additional sets of features:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `subprocess` 模块提供了许多类似于 shell 的功能。最重要的是，Python 提供了几组额外的功能：
- en: A much richer collection of data structures.
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更丰富的数据结构。
- en: Exceptions to identify problems that arise. This is much simpler and more reliable
    than inserting `if` statements throughout a shell script to check status codes.
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常用于识别出现的问题。这比在 shell 脚本中插入 `if` 语句来检查状态码要简单得多且更可靠。
- en: A way to unit test the script without using OS resources.
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种在不使用操作系统资源的情况下对脚本进行单元测试的方法。
- en: There's more...
  id: totrans-766
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We'll add a simple cleanup feature to this script. The idea is that all of the
    output files should be created as an atomic operation. We want all of the files,
    or none of the files. We don't want an incomplete collection of data files.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向这个脚本添加一个简单的清理功能。想法是所有的输出文件应该作为一个原子操作创建。我们希望所有文件都存在，或者没有文件存在。我们不希望有不完整的数据文件集。
- en: 'This fits with the ACID properties:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 这符合ACID属性：
- en: '**Atomicity** : The entire set of data is available or it is not available.
    The collection is a single, indivisible unit of work.'
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：整个数据集要么可用，要么不可用。集合是一个单一的、不可分割的工作单元。'
- en: '**Consistency** : The file-system should move from one internally consistent
    state to another consistent state. Any summaries or indices will properly reflect
    the actual files.'
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：文件系统应该从一个内部一致的状态转移到另一个一致的状态。任何摘要或索引都应该正确反映实际文件。'
- en: '**Isolation** : If we want to process data concurrently, then having multiple,
    parallel processes should work. Concurrent operations should not interfere with
    each other.'
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：如果我们想要并行处理数据，那么多个并行进程应该可以工作。并发操作不应该相互干扰。'
- en: '**Durability** : Once the files are written, they should remain on the file-system.
    This property almost goes without saying for files. For more complex databases,
    it becomes necessary to consider transaction data that might be acknowledged by
    a database client, but not actually written yet to a server.'
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久性**：一旦文件被写入，它们应该保留在文件系统上。对于文件来说，这个属性几乎是不言而喻的。对于更复杂的数据库，需要考虑可能被数据库客户端确认但实际上尚未写入服务器的事务数据。'
- en: Most of these features are relatively simple to achieve using OS processes with
    separate working directories. The atomicity property, however, leads to a need
    for a cleanup operation.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 使用操作系统进程和单独的工作目录可以相对简单地实现大多数这些特性。然而，原子性属性导致需要进行清理操作。
- en: 'In order to clean up, we''ll need to wrap the core processing with a `try:`
     block. The overall function would look like this:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清理，我们需要用 `try:` 块包装核心处理。整个函数看起来像这样：
- en: '[PRE123]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The exception-handling block does two things. First, it removes any incomplete
    files from the current working directory. Second, it re-raises the original exception
    so that the failure will propagate to the client application.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理块有两个作用。首先，它会从当前工作目录中删除任何不完整的文件。其次，它会重新引发原始异常，以便故障传播到客户端应用程序。
- en: Since the processing has failed, it's important to raise an exception. In some
    cases, an application may define a new exception, unique to this application.
    That new exception can be raised instead, re-raising the original `CalledProcessError`
    exception.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理失败，提高异常是很重要的。在某些情况下，应用程序可能会定义一个新的异常，特定于该应用程序。可以引发这个新的异常，而不是重新引发原始的 `CalledProcessError`
    异常。
- en: Unit test
  id: totrans-778
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: In order to unit test this, we'll need to mock two external objects. We need
    a mock for the `run()` function in the `subprocess` module. We don't want to actually
    run the other process, but we want to be sure that the `run()` function is called
    appropriately from the `make_files()` function.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对这个进行单元测试，我们需要模拟两个外部对象。我们需要模拟 `subprocess` 模块中的 `run()` 函数。我们不想实际运行其他进程，但我们想确保
    `run()` 函数从 `make_files()` 函数中被适当地调用。
- en: We also need to mock the `Path` class and the resulting `Path` object. These
    provide the filenames, and will have the `unlink()` method called. We need to
    create mocks for this so that we can be sure only the appropriate files will be
    unlinked by the real application.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要模拟 `Path` 类和生成的 `Path` 对象。这些提供文件名，并将调用 `unlink()` 方法。我们需要为此创建模拟，以确保真实应用程序只取消链接适当的文件。
- en: Testing with mock objects means that we never run the risk of accidentally deleting
    useful files when testing. This is a significant benefit of using Python for this
    kind of automation.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模拟对象进行测试意味着我们永远不会在测试时意外删除有用的文件。这是使用Python进行这种自动化的重要好处。
- en: 'Here''s the setup where we define the various mock objects:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们定义各种模拟对象的设置：
- en: '[PRE124]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: We've defined `self.mock_subprocess_run` , which will behave somewhat like the
    `run()` function. We've used the `side_effect` attribute to provide multiple return
    values for this function. The first response will be the `None` object. The second
    response, however, will be a `CalledProcessError` exception. This exception requires
    two arguments, a process return code, and the original command.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了 `self.mock_subprocess_run`，它将表现得有点像 `run()` 函数。我们使用了 `side_effect` 属性为这个函数提供多个返回值。第一个响应将是
    `None` 对象。然而，第二个响应将是一个 `CalledProcessError` 异常。这个异常需要两个参数，一个进程返回代码，和原始命令。
- en: The `self.mock_path_class` , shown last, responds to calls to the `Path` class
    requests. This will return a mocked instance of the class. The `self.mock_path_instance`
    object is the mock instance of `Path` .
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.mock_path_class`，最后显示，响应对 `Path` 类请求的调用。这将返回一个模拟的类实例。`self.mock_path_instance`
    对象是 `Path` 的模拟实例。'
- en: The first path instance that's created will have the `glob()` method evaluated.
    For this, we've used the `return_value` attribute to return a list of `Path` instances
    to be deleted. In this case, the return value will be a single `Path` object that
    we expect to be unlinked.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的第一个路径实例将评估 `glob()` 方法。为此，我们使用了 `return_value` 属性来返回要删除的 `Path` 实例列表。在这种情况下，返回值将是一个我们期望被取消链接的单个
    `Path` 对象。
- en: The `self.mock_path_glob_instance` object is the return from `glob()` . This
    should be unlinked if the algorithm operates correctly.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.mock_path_glob_instance` 对象是从 `glob()` 返回的。如果算法操作正确，这应该被取消链接。'
- en: 'Here''s the `runTest()` method for this unit test:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个单元测试的 `runTest()` 方法：
- en: '[PRE125]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'We''ve applied two patches:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用了两个补丁：
- en: In the `__main__` module, a reference to `subprocess` will have the `run()`
    function replaced with the `self.mock_subprocess_run` object. This will allow
    us to track how many times `run()` is called. It will allow us to confirm that
    `run()` is called with the correct arguments.
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `__main__` 模块中，对 `subprocess` 的引用将使用 `self.mock_subprocess_run` 对象替换 `run()`
    函数。这将允许我们跟踪 `run()` 被调用的次数。它将允许我们确认 `run()` 是否以正确的参数被调用。
- en: In the `__main__` module, the reference to `Path` will be replaced with the
    `self.mock_path_class` object. This will both return known values, and allow us
    to confirm that only the expected calls were made.
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `__main__` 模块中，对 `Path` 的引用将被替换为 `self.mock_path_class` 对象。这将返回已知的值，并允许我们确认只有预期的调用被执行。
- en: The `self.assertRaises`  method is used to confirm that a `CalledProcessError`
    exception is properly raised when `make_files()`  method is called in this particular
    patched context. The mocked version of `run()`  method will raise an exception—we
    expect that exact exception to be the one that stops processing.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.assertRaises`方法用于确认在调用`make_files()`方法时，在这个特定的修补上下文中正确引发了`CalledProcessError`异常。`run()`方法的模拟版本将引发异常——我们期望确切的异常是停止处理的异常。'
- en: The mocked `run()` function be called just two times. The first call will succeed.
    The second call will raise an exception. We can confirm that there are exactly
    two calls to `run()` using the `call_count` attribute of a `Mock` object.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟的`run()`函数只被调用两次。第一次调用将成功。第二次调用将引发异常。我们可以使用`Mock`对象的`call_count`属性来确认确实调用了两次`run()`。
- en: The `self.mock_path_instance`  method is a mock for the `Path('.')` object that's
    created as part of exception handling. This object must have the `glob()` method
    evaluated. The test assertion checks the argument value to be sure that `'game_*.yaml'`
    is used.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.mock_path_instance` 方法是`Path(''.'')`对象的模拟，该对象作为异常处理的一部分创建。这个对象必须评估`glob()`方法。测试断言检查参数值，以确保使用了`''game_*.yaml''`。'
- en: Finally, the `self.mock_path_glob_instance` is a mock for the `Path` object
    created by `Path('.').glob('game_*.yaml')` . This object will have the `unlink()`
    method evaluated. This will result in deleting the file.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`self.mock_path_glob_instance`是`Path('.').glob('game_*.yaml')`创建的`Path`对象的模拟。这个对象将评估`unlink()`方法。这将导致删除文件。
- en: This unit test provides confidence that the algorithm will work as advertised.
    The testing is done without tying up a lot of compute resources. Most importantly,
    the testing is done without accidentally deleting the wrong files.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单元测试提供了算法将按照广告运行的信心。测试是在不占用大量计算资源的情况下进行的。最重要的是，测试是在不小心删除错误文件的情况下进行的。
- en: See also
  id: totrans-798
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: This kind of automation is often combined with other Python processing. See
    the *Designing scripts for composition* recipe.
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种自动化通常与其他Python处理结合使用。请参阅*为组合设计脚本*配方。
- en: The goal is often to create a composite application; see the *Managing arguments
    and configuration in composite applications* recipe.
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标通常是创建一个复合应用程序；参见*在复合应用程序中管理参数和配置*配方。
- en: For a variation on this recipe, see the  *Wrapping a program and checking the
    output* recipe.
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关此配方的变体，请参阅*包装程序并检查输出*配方。
- en: Wrapping a program and checking the output
  id: totrans-802
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装程序并检查输出
- en: One common kind of automation involves running several programs, none of which
    are actually Python applications. In this case, it's impossible to rewrite each
    program to create a composite Python application. In order to properly aggregate
    the functionality, the other programs must be wrapped as a Python class or module
    to provide a higher level construct.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的自动化类型涉及运行几个程序，其中没有一个实际上是Python应用程序。在这种情况下，不可能重写每个程序以创建一个复合的Python应用程序。为了正确地聚合功能，其他程序必须被包装为Python类或模块，以提供一个更高级的构造。
- en: The use case for this is very similar to the use case for writing a shell script.
    The difference is that Python can be a better programming language than the OS's
    built-in shell languages.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用例与编写shell脚本的用例非常相似。不同之处在于Python可能是比操作系统内置的shell语言更好的编程语言。
- en: In some cases, the advantage Python offers is the ability to analyze the output
    files. A Python program might transform, filter, or summarize the output from
    a subprocess.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，Python提供的优势是能够分析输出文件。Python程序可能会转换、过滤或总结子进程的输出。
- en: How do we run other applications from within Python and process their output?
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从Python中运行其他应用程序并处理它们的输出？
- en: Getting ready
  id: totrans-807
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the *Designing scripts for composition* recipe, we identified an application
    that did some processing, leading to the creation of a rather complex result.
    We'd like to run this program several hundred times, but we don't want to copy
    and paste the necessary commands into a script. Also, because the shell is difficult
    to test and has so few data structures, we'd like to avoid using the shell.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 在*为组合设计脚本*配方中，我们确定了一个应用程序进行了一些处理，导致了一个相当复杂的结果。我们想运行这个程序几百次，但我们不想复制和粘贴必要的命令到一个脚本中。此外，由于shell很难测试并且数据结构很少，我们想避免使用shell。
- en: For this recipe, we'll assume that the `ch13_r05` application is a native binary
    application written in Fortran or C++. This means that we can't simply import
    the Python module that comprises the application. Instead, we'll have to process
    this application by running a separate OS process.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们假设`ch13_r05`应用程序是用Fortran或C++编写的本机二进制应用程序。这意味着我们不能简单地导入包含应用程序的Python模块。相反，我们将不得不通过运行一个单独的操作系统进程来处理这个应用程序。
- en: 'We will use the `subprocess` module to run an application program at the OS
    level. There are two common use cases for running another binary program from
    within Python:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`subprocess`模块在操作系统级别运行应用程序。从Python中运行另一个二进制程序有两种常见的用例：
- en: There isn't any output, or we don't want to gather it in our Python program.
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有任何输出，或者我们不想在我们的Python程序中收集它。
- en: We need to capture and possibly analyze the output to retrieve information or
    ascertain the level of success. We might need to transform, filter, or summarize
    the log output.
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要捕获并可能分析输出以检索信息或确定成功的级别。我们可能需要转换、过滤或总结日志输出。
- en: In this recipe, we'll look at the second case—the output must be captured and
    summarized. In the *Wrapping and combining CLI applications* recipe, we'll look
    at the first case, where the output is simply ignored.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看看第二种情况——输出必须被捕获和总结。在*包装和组合CLI应用程序*配方中，我们将看看第一种情况，即输出被简单地忽略。
- en: 'Here''s an example of running the `ch13_r05` application:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行`ch13_r05`应用程序的一个例子：
- en: '[PRE126]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: There are two lines of output that are written to the OS standard output file.
    The first has a summary of the options. The second line of output is a `Counter`
    object with a summary of the file. We want to capture the details of these `'Counter'`
    lines.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 有两行输出写入操作系统标准输出文件。第一行有选项的摘要。第二行的输出是一个带有文件摘要的`Counter`对象。我们想要捕获这些`'Counter'`行的细节。
- en: How to do it...
  id: totrans-817
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Import the `subprocess` module:'
  id: totrans-818
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`subprocess`模块：
- en: '[PRE127]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Design the command line. Generally, this should be tested at the OS prompt to
    be sure that it does the right things. We've shown an example of the command.
  id: totrans-820
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计命令行。通常，这应该在操作系统提示符下进行测试，以确保它执行正确的操作。我们展示了一个命令的示例。
- en: 'Define a generator for the various commands to be executed. Each command can
    be built as a sequence of individual words. The original shell command is split
    on spaces to create the sequence of words:'
  id: totrans-821
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为要执行的各种命令定义一个生成器。每个命令都可以作为一个单词序列构建。原始的shell命令被拆分成单词序列。
- en: '[PRE128]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: This generator will yield a sequence of command strings. A client can use a
    `for` statement to consume each of the generated commands.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成器将产生一系列命令字符串。客户端可以使用`for`语句来消耗生成的每个命令。
- en: 'Define a function which executes the various commands, collecting the output
    from each:'
  id: totrans-824
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个执行各种命令并收集输出的函数：
- en: '[PRE129]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Using the argument value of `stdout=subprocess.PIPE` means that the parent process
    will collect the output from the child. An OS-level pipe is created so that the
    child output can be read by the parent.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`stdout=subprocess.PIPE`的参数值意味着父进程将收集子进程的输出。创建一个操作系统级的管道，以便父进程可以读取子进程的输出。
- en: This generator will yield a sequence of lists of lines. Each list of lines will
    be the output lines from the `ch13_r05.py` application. There will, generally,
    be two lines in each list. The first line is the argument summary, and the second
    line is the `Counter` object.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成器将产生一系列行列表。每个行列表将是`ch13_r05.py`应用程序的输出行。通常每个列表中会有两行。第一行是参数摘要，第二行是`Counter`对象。
- en: 'Define an overall process to combine the two generators so that each command
    that is generated is then executed:'
  id: totrans-828
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个整体流程，将这两个生成器结合起来，以便执行生成的每个命令：
- en: '[PRE130]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The `command_sequence` variable is a generator that will produce a number of
    commands. This sequence is built by the `command_iter()` function.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '`command_sequence`变量是一个生成器，将产生多个命令。这个序列是由`command_iter()`函数构建的。'
- en: The `output_lines_sequence` is a generator that will produce a number of lists
    of output lines. This is is built by the `command_output_iter()` function, which
    will use the given `command_sequence object` , runs a number of commands, collecting
    the output.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '`output_lines_sequence`是一个生成器，将产生多个输出行列表。这是由`command_output_iter()`函数构建的，它将使用给定的`command_sequence`对象，运行多个命令，收集输出。'
- en: Each batch in `output_lines_sequence` will be a list of, ideally, two lines.
    The line that begins with `Counter`  has the representation of a `Counter` object.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '`output_lines_sequence`中的每个批次将是一个包含两行的列表。以`Counter`开头的行表示一个`Counter`对象。'
- en: We've used the `eval()` function to recreate the original `Counter` object from
    this text representation. We can use these `Counter` objects for analysis or summarization.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`eval()`函数从文本表示中重新创建原始的`Counter`对象。我们可以使用这些`Counter`对象进行分析或总结。
- en: Most practical applications will have to use a function that's more complex
    than the built-in `eval()` to interpret output. For information on processing
    complex line formats, see the *String parsing with regular expressions* in [Chapter
    1](text00014.html#page "Chapter 1. Numbers, Strings, and Tuples") , *Numbers,
    Strings, and Tuples* , and *Reading complex formats using regular expressions*
    recipe in [Chapter 9](text00099.html#page "Chapter 9. Input/Output, Physical Format,
    and Logical Layout") , *Input/Output, Physical Format, and Logical Layout* .
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数实际应用程序将不得不使用比内置的`eval()`更复杂的函数来解释输出。有关处理复杂行格式的信息，请参阅[第1章](text00014.html#page
    "第1章。数字、字符串和元组")中的*使用正则表达式解析字符串*，*数字、字符串和元组*，以及[第9章](text00099.html#page "第9章。输入/输出、物理格式和逻辑布局")中的*使用正则表达式读取复杂格式*，*输入/输出、物理格式和逻辑布局*。
- en: How it works...
  id: totrans-835
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `subprocess` module is how Python programs run other programs available
    on a given computer. The `run()` function, does a number of things for us.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '`subprocess`模块是Python程序运行在给定计算机上的其他程序的方式。`run()`函数为我们做了很多事情。'
- en: 'In a POSIX (such as Linux or Mac OS X) context, the steps are similar to the
    following:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 在POSIX（如Linux或Mac OS X）环境中，步骤类似于以下步骤：
- en: Prepare the `stdin` , `stdout` , and `stderr` files descriptors for the child
    process. In this case, we've arranged for the parent to collect output from the
    child. The child will produce `stdout`  file to a shared buffer (a pipe in Linux
    parlance) that is consumed by the parent. The `stderr` output, on the other hand,
    is left alone—the child inherits the same connection the parent has, and error
    messages will be displayed on the same console being used by the parent.
  id: totrans-838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为子进程准备`stdin`，`stdout`和`stderr`文件描述符。在这种情况下，我们安排父进程从子进程收集输出。子进程将`stdout`文件产生到一个共享缓冲区（在Linux术语中是一个管道），由父进程消耗。另一方面，`stderr`输出保持不变——子进程继承了父进程的相同连接，错误消息将显示在父进程使用的同一个控制台上。
- en: Invoke the `os.fork()` and `os.execl()` functions to split the current process
    into parent and child, and then start the child process.
  id: totrans-839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`os.fork()`和`os.execl()`函数将当前进程分成父进程和子进程，然后启动子进程。
- en: The child process then runs, using the given `stdin` , `stdout` , and `stderr`
    .
  id: totrans-840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后子进程运行，使用给定的`stdin`，`stdout`和`stderr`。
- en: The parent, meanwhile, is reading from the child's pipe while waiting for the
    child process to finish.
  id: totrans-841
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时，父进程正在从子进程的管道中读取，同时等待子进程完成。
- en: Since we used the `check=True` option, a non-zero status is transformed into
    an exception.
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们使用了`check=True`选项，非零状态被转换为异常。
- en: There's more...
  id: totrans-843
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We'll add a simple summarization feature to this script. Each individual batch
    of samples produces two lines of output. The output text is split into a sequence
    of two lines by the expression `list(l.strip() for l in output_bytes.splitlines())`
    . This splits text into lines and also strips leading and trailing spaces from
    each line, leaving text that's slightly easier to process.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向这个脚本添加一个简单的总结功能。每个样本批次产生两行输出。输出文本通过表达式`list(l.strip() for l in output_bytes.splitlines())`分割成两行的序列。这将文本分割成行，并从每行中去除前导和尾随空格，留下稍微容易处理的文本。
- en: The overall script filtered these lines, looking for the line that started with
    `'Counter'` . Each of these lines is a text representation of a `Counter` object.
    Using the `eval()` function on the line will rebuild a copy of that original `Counter`
    . Many Python class definitions work like this—the `repr()` and `eval()` functions
    are inverses of each other. The `repr()` function transforms an object to text,
    and the `eval()` function can convert the text back to an object. This isn't true
    for all classes, but it is true for many.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 总体脚本过滤了这些行，寻找以'Counter'开头的行。这些行中的每一行都是`Counter`对象的文本表示。在行上使用`eval()`函数将重建原始的`Counter`的副本。许多Python类定义都是这样的——`repr()`和`eval()`函数是彼此的反函数。`repr()`函数将对象转换为文本，`eval()`函数可以将文本转换回对象。这并不适用于所有类，但对于许多类来说是正确的。
- en: We can create a summary of the various `Counter` objects. In order to do this,
    it helps to have a generator that will process the batches and yield the final
    summaries.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建各种`Counter`对象的总结。为了做到这一点，有助于有一个生成器来处理批次并产生最终的总结。
- en: 'The function should look like this:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应该是这样的：
- en: '[PRE131]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This will create the processing commands with the `command_iter()` function.
    The `command_output_iter()` will process each individual command, collecting the
    entire set of output lines.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用`command_iter()`函数创建处理命令。`command_output_iter()`将处理每个单独的命令，收集整个输出行集。
- en: The nested `for` statements will examine each batch's list of lines. Within
    each list, it will examine each line. The line that starts with `Counter`  will
    be evaluated with the `eval()` function. The resulting sequence of `Counter` objects
    is the output from this generator.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的`for`语句将检查每个批次的行列表。在每个列表中，它将检查每一行。以`Counter`开头的行将使用`eval()`函数进行评估。`Counter`对象的结果序列是这个生成器的输出。
- en: 'We can use a process like this to summarize the sequence of `Counter` instances:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这样的流程来总结`Counter`实例的序列：
- en: '[PRE132]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: We'll create `Counter` to hold the grand total, `total_counter` . The `process_batches()`
    will yield individual `Counter` instances from each file that's processed. These
    batch-level objects are used to update the `total_counter` . We can then print
    the grand total to show the aggregate distribution of data in all of the files
    created.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建`Counter`来保存总数，`total_counter`。`process_batches()`将从处理的每个文件中产生单独的`Counter`实例。这些批次级别的对象用于更新`total_counter`。然后我们可以打印总数，显示所有文件中数据的聚合分布。
- en: See also
  id: totrans-854
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Wrapping and combining CLI applications* recipe for another approach
    to this recipe.
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见*包装和组合CLI应用程序*食谱，了解这个食谱的另一种方法。
- en: This kind of automation is often combined with other Python processing. See
    the *Designing scripts for composition* recipe.
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种自动化通常与其他Python处理结合在一起。请参见*为组合设计脚本*食谱。
- en: The goal is often to create a composite application; see the *Managing arguments
    and configuration in composite applications* recipe.
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标通常是创建一个组合应用程序；参见*管理组合应用程序中的参数和配置*食谱。
- en: '![](image/614271.jpg)'
  id: totrans-858
  prefs: []
  type: TYPE_IMG
  zh: '![](image/614271.jpg)'
- en: Controlling complex sequences of steps
  id: totrans-859
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制复杂的步骤序列
- en: In the *Combining two applications into one* recipe, we looked at ways to combine
    multiple Python scripts into a single, longer, more complex operation. In the
    *Wrapping and combining CLI applications* and *Wrapping a program and checking
    the output* recipes, we looked at ways to use Python to wrap non-Python programs.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 在*将两个应用程序合并为一个*食谱中，我们探讨了将多个Python脚本合并为一个更长、更复杂操作的方法。在*包装和组合CLI应用程序*和*包装程序并检查输出*食谱中，我们探讨了使用Python包装非Python程序的方法。
- en: How can we combine these techniques effectively? Can we create longer, more
    complex sequences of operations using Python?
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何有效地结合这些技术？我们能否使用Python创建更长、更复杂的操作序列？
- en: Getting ready
  id: totrans-862
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the *Designing scripts for composition* recipe, we created application that
    did some processing that lead to the creation of a rather complex result. In the
    *Using logging for control and audit output* recipe, we looked at a second application
    that built on those results to create a sophisticated statistical summary.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 在*为组合设计脚本*食谱中，我们创建了一个应用程序，进行了一些处理，导致了一个相当复杂的结果的产生。在*使用日志进行控制和审计输出*食谱中，我们看了第二个应用程序，它建立在这些结果的基础上，创建了一个复杂的统计摘要。
- en: 'The overall process looks like this:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 总体流程如下：
- en: Run the `ch13_r05` program 100 times to create 100 intermediate files.
  id: totrans-865
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ch13_r05`程序100次，创建100个中间文件。
- en: Run the `ch13_r06` program to summarize those intermediate files.
  id: totrans-866
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`ch13_r06`程序总结这些中间文件。
- en: We've kept this simple so that it's easy to focus on the Python programming
    involved.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保持这个简单，这样就可以专注于涉及的Python编程。
- en: For the purposes of this recipe, we'll assume that neither of these applications
    is written in Python. We'll pretend that they're written in Fortran or Ada or
    some other language that's not directly compatible with Python.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们假设这两个应用程序都不是用Python编写的。我们假装它们是用Fortran或Ada或其他与Python不直接兼容的语言编写的。
- en: In the *Combining two applications into one* recipe, we looked at how we can
    combine Python applications. When the applications are written in Python, this
    is the preferred approach. When applications are not written in Python, some additional
    work is required.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 在*将两个应用程序合并为一个*食谱中，我们看了如何可以组合Python应用程序。当应用程序是用Python编写时，这是首选的方法。当应用程序不是用Python编写时，需要额外的工作。
- en: This recipe uses the Command design pattern; this supports the expansion and
    modification of the sequences of commands.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方使用了命令设计模式；这支持命令序列的扩展和修改。
- en: How to do it...
  id: totrans-871
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll define an abstract `Command` class. The other commands will be defined
    as subclasses. We''ll push the subprocess processing into this class definition
    to simplify the subclasses:'
  id: totrans-872
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义一个抽象的`Command`类。其他命令将被定义为子类。我们将将子进程处理推入此类定义以简化子类：
- en: '[PRE133]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: The `execute()` method works by first creating the OS-level command to execute.
    Each subclass will provide distinct rules for the commands which are wrapped.
    Once the command has been built, then the `run()` function of the `subprocess`
    module will process this command.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute()`方法首先通过创建OS级别的要执行的命令来工作。每个子类将为包装的命令提供不同的规则。一旦命令构建完成，`subprocess`模块的`run()`函数将处理此命令。'
- en: The `create_command()` method builds the sequence of words that comprise the
    command to be executed by the OS. The options, generally, will be used to customize
    the command arguments that are created. The superclass implementation of this
    method provides some debugging information. Each subclass must override this method
    to produce useful output.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_command()` 方法构建由操作系统执行的命令的单词序列。通常，选项将用于自定义创建的命令参数。此方法的超类实现提供了一些调试信息。每个子类必须重写此方法以产生有用的输出。'
- en: 'We can use the `Command` superclass to define a command to simulate the game
    and create samples:'
  id: totrans-876
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`Command`超类来定义一个命令来模拟游戏并创建样本：
- en: '[PRE134]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: In this case, we provided an override for the `execute()` method so that this
    class could change the environment variables. This allows an integration test
    to set a specific random seed and confirm that the results match a fixed set of
    expected values.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们提供了对`execute()`方法的重写，以便这个类可以更改环境变量。这允许集成测试设置特定的随机种子，并确认结果与固定的预期值匹配。
- en: The `create_command()` method emits the words for a command-line execution of
    the `ch13_r05` command. This converts the numeric value of `options.samples` to
    a string.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_command()` 方法发出了用于执行`ch13_r05`命令的命令行的单词。这将数字值`options.samples`转换为字符串。'
- en: 'We can also use the `Command` superclass to define a command to summarize the
    various simulation processes:'
  id: totrans-880
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用`Command`超类来定义一个命令来总结各种模拟过程：
- en: '[PRE135]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: In this case, we only implemented `create_command()` . This implementation provides
    the arguments for the `ch13_r06` command.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只实现了`create_command()`。此实现为`ch13_r06`命令提供了参数。
- en: 'Given these two commands, the overall main program can follow the design pattern
    from the *Designing scripts for composition* recipe. We need to gather the options,
    and then use these options to execute the two commands:'
  id: totrans-883
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 鉴于这两个命令，整个主程序可以遵循*为组合设计脚本*配方的设计模式。我们需要收集选项，然后使用这些选项来执行这两个命令：
- en: '[PRE136]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: This demonstration function, `demo()` , creates a `Namespace` instance with
    the parameters that could have come from the command line. It builds the two processing
    steps. Finally, it executes each step.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 此演示函数`demo()`创建了一个带有可能来自命令行的参数的`Namespace`实例。它构建了两个处理步骤。最后，它执行每个步骤。
- en: This kind of function provides a high-level script for executing a sequence
    of applications. It's considerably more flexible than the shell, because we can
    make use of Python's rich collection of data structures. Because we're using Python,
    we can include unit tests as well.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 这种函数提供了一个执行一系列应用程序的高级脚本。它比shell要灵活得多，因为我们可以利用Python丰富的数据结构。因为我们使用Python，我们也可以包括单元测试。
- en: How it works...
  id: totrans-887
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'There are two interlocking design patterns in this recipe:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中有两个相互交织的设计模式：
- en: The `Command` class hierarchy
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Command`类层次结构'
- en: Wrapping external commands by using the `subprocess.run()` function
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`subprocess.run()`函数包装外部命令
- en: The idea behind a `Command` class hierarchy is to make each separate step or
    operation into a subclass of a common, abstract superclass. In this case, we've
    called that superclass `Command` . The two operations are subclasses of the `Command`
    class. This assures that we can provide common features to all of the classes.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '`Command`类层次结构的想法是将每个单独的步骤或操作变成一个共同的、抽象的超类的子类。在这种情况下，我们称这个超类为`Command`。这两个操作是`Command`类的子类。这确保我们可以为所有类提供共同的特性。'
- en: Wrapping external commands has several considerations. One primary question
    is how to build the command-line options that are required. In this case, the
    `run()` function will use a list of individual words, making it very easy to combine
    literal strings, filenames, and numeric values into a valid set of options for
    a program. The other primary question is how to handle the OS-defined standard
    input, standard output, and standard error files. In some cases, these files can
    be displayed on the console. In other cases, the application might capture those
    files for further analysis and processing.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 包装外部命令有几个考虑因素。一个主要问题是如何构建所需的命令行选项。在这种情况下，`run()`函数将使用一个单词列表，非常容易将文字字符串、文件名和数值组合成一个程序的有效选项集。另一个主要问题是如何处理OS定义的标准输入、标准输出和标准错误文件。在某些情况下，这些文件可以显示在控制台上。在其他情况下，应用程序可能会捕获这些文件以进行进一步的分析和处理。
- en: 'The essential idea here is to separate two considerations:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基本思想是分开两个考虑因素：
- en: The overview of the commands to be executed. This includes questions about sequence,
    iteration, conditional processing, and potential changes to the sequence. These
    are higher-level considerations related to the user stories.
  id: totrans-894
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行命令的概述。这包括关于顺序、迭代、条件处理和可能对顺序进行更改的问题。这些是与用户故事相关的高级考虑因素。
- en: The details of how to execute each command. This includes command-line options,
    output files used, and other OS-level considerations. These are more technical
    considerations of the implementation details.
  id: totrans-895
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行每个命令的详细信息。这包括命令行选项、使用的输出文件和其他OS级别的考虑因素。这些是更多关于实现细节的技术考虑因素。
- en: Separating the two makes it easier to implement or modify the user stories.
    Changes to the OS-level considerations should not alter the user stories; the
    process might be faster or use less memory, but is otherwise identical. Similarly,
    changes to the user stories should not break the OS-level considerations.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 将两者分开使得更容易实现或修改用户故事。对操作系统级别的考虑的更改不应该改变用户故事；处理可能会更快或使用更少的内存，但其他方面是相同的。同样，对用户故事的更改不应该破坏操作系统级别的考虑。
- en: There's more...
  id: totrans-897
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A complex sequence of steps can involve iteration of one or more steps. Since
    the high-level script is written in Python, adding iteration is done with the
    `for` statement:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列复杂的步骤可能涉及一个或多个步骤的迭代。由于高级脚本是用Python编写的，添加迭代是用`for`语句完成的：
- en: '[PRE137]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: This `process_i()` function will process the `Simulate` step many times. It
    uses the `simulations` option to specify how many simulations to run. Each simulation
    will produce the expected number of samples.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 此`process_i()`函数将多次处理`Simulate`步骤。它使用`simulations`选项来指定要运行多少次模拟。每次模拟将产生预期数量的样本。
- en: This function will set a distinct value for the `game_file` option for each
    iteration of the processing. Each of the resulting filenames will be unique, leading
    to a number of sample files. The list of files is also collected into the `game_files`
    option.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将为处理的每次迭代设置`game_file`选项的不同值。每个生成的文件名都将是唯一的，导致产生多个样本文件。文件列表也被收集到`game_files`选项中。
- en: When the next step, the `Summarize` class, is executed, it will have the proper
    list of files to process. The `Namespace` object, assigned to the `options` variable,
    can be used to track global state changes and provide this information to subsequent
    processing steps.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行下一步`Summarize`类时，它将具有适当的文件列表进行处理。分配给`options`变量的`Namespace`对象可用于跟踪全局状态变化，并将此信息提供给后续处理步骤。
- en: Building conditional processing
  id: totrans-903
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建有条件的处理。
- en: Since the high-level programming is written in Python, it's quite easy to add
    additional processing that isn't based on the two applications that are wrapped.
    One feature might be an optional summarization step.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 由于高级编程是用Python编写的，因此很容易添加不基于封装的两个应用程序的附加处理。一个功能可能是可选的总结步骤。
- en: 'For example, if the options do not have a `summary_file` option, then the processing
    can be skipped. This might lead to a version of the `process()` function that
    looks like this:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果选项没有`summary_file`选项，则可以跳过处理。这可能会导致`process()`函数的一个版本看起来像这样：
- en: '[PRE138]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: This `procees_c()` function will process the `Summarize` step conditionally.
    If there is a `summary_file` option, it will execute the second step. Otherwise,
    it will skip the summary step.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 此`procees_c()`函数将有条件地处理`Summarize`步骤。如果有`summary_file`选项，它将执行第二步。否则，它将跳过总结步骤。
- en: In this case, and the previous example, we've used Python programming features
    to augment the two application programs.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，以及前面的例子中，我们已经使用了Python编程功能来增强这两个应用程序。
- en: See also
  id: totrans-909
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Generally, these kinds of processing steps are done for larger or more complex
    applications. See the  *Combining two applications into one* and *Managing arguments
    and configuration in composite applications for more* recipes that work with larger
    and more complex composite applications.
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，这些类型的处理步骤是为更大或更复杂的应用程序完成的。有关与更大更复杂的复合应用程序一起使用的更多食谱，请参阅*将两个应用程序合并为一个*和*在复合应用程序中管理参数和配置*。
