- en: Coding the Tetris Game with Pygame
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pygame编写俄罗斯方块游戏
- en: '*Think out of the box*, an old adage that for the game developer might sound
    cliche, but is still very applicable. Most of the games that have revolutionized
    the gaming industry contain some unique elements and represent the taste of general
    audiences. But this worldwide assumption overestimates by discarding approaches
    that might be common among most game developers. After all, mathematical paradigms,
    object-rendering tools, and software remain the same. Thus, in this chapter, we
    are going to explore some of the advanced mathematical transformations and paradigms
    that every game programmer must know.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*打破常规思维*，这是一个老话，对于游戏开发者来说可能听起来陈词滥调，但仍然非常适用。大多数改变游戏行业的游戏都包含一些独特的元素，并代表了普通观众的口味。但这种全球性的假设通过丢弃可能在大多数游戏开发者中普遍存在的方法而被高估。毕竟，数学范式、对象渲染工具和软件保持不变。因此，在本章中，我们将探索一些每个游戏程序员都必须了解的高级数学变换和范式。'
- en: In this chapter, we will learn how to create one of the most played and downloaded
    games of the century that's very recognizable among 90s kids—*Tetris*. We will
    learn how to create it from scratch by building shapes that have been formatted
    from multi-dimensional lists. We will learn how to draw primitives and game grids,
    which will help us to locate the game objects. We will also learn how to implement
    rotational transformations of geometrical shapes and figures. Although this concept
    might sound simple, the application of these concepts ranges from different 2D
    to 3D **role-playing games** (**RPGs**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何创建本世纪最受欢迎和下载量最大的游戏之一，这是90年代孩子们非常熟悉的游戏——*俄罗斯方块*。我们将学习如何通过从多维列表中格式化的形状来从头开始创建它。我们将学习如何绘制基本图形和游戏网格，这将帮助我们定位游戏对象。我们还将学习如何实现几何形状和图形的旋转变换。尽管这个概念听起来可能很简单，但这些概念的应用范围从不同的2D到3D的**角色扮演游戏**（**RPGs**）。
- en: By the end of this chapter, you will be familiar with different concepts such
    as creating grid (virtual and physical) structures to locate game objects based
    on the position and color code. Then, you will learn about multi-dimensional list
    processing by using list comprehension. Furthermore, readers will also learn about
    the different shifting transformations and collision-checking principles. In the
    previous chapter, we implemented collision checks with the help of masking using
    pygame. However, in this chapter, we will do it in a programmer's way—it may be
    little complicated but it contains a profuse amount of knowledge.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将熟悉不同的概念，如创建网格（虚拟和物理）结构，以根据位置和颜色代码定位游戏对象。然后，您将学习如何使用列表推导来处理多维列表。此外，读者还将了解不同的移位变换和碰撞检查原则。在上一章中，我们使用pygame使用掩码实现了碰撞检查。然而，在本章中，我们将以程序员的方式来做这件事——这可能有点复杂，但包含了丰富的知识。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding Tetris essentials
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解俄罗斯方块的基本要素
- en: Creating a grid and random shapes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建网格和随机形状
- en: Setting up the windows and game loops
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置窗口和游戏循环
- en: Converting the shape format
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换形状格式
- en: Modifying the game loop
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改游戏循环
- en: Clearing the rows
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除行
- en: Game testing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏测试
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following requirements in order to complete this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下要求才能完成本章：
- en: Pygame editor (IDLE)—version 3.5+ is recommended.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pygame编辑器（IDLE）—建议使用3.5+版本。
- en: PyCharm IDE—refer to [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml), *Getting
    to Know Python – Setting Up Python and the Editor*, for the installation procedure.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm IDE-参考[第1章](0ef9574b-5690-454e-971f-85748021018d.xhtml)，*了解Python-设置Python和编辑器*，了解安装过程。
- en: The Code assets for the Tetris game can be found on GitHub at [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter13](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter13)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 俄罗斯方块游戏的代码资产可以在GitHub上找到，网址为[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter13](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter13)
- en: 'Check out the following video to see the code in action:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的运行情况：
- en: '[http://bit.ly/2oDbq2J](http://bit.ly/2oDbq2J)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2oDbq2J](http://bit.ly/2oDbq2J)'
- en: Understanding Tetris essentials
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解俄罗斯方块的基本要素
- en: Incorporating pygame sprites and images into our Python game is a straightforward
    process. It requires a built-in Python module—*os—*that will load files from your
    machine. In the previous chapter, while building the Flappy Bird game, we learned
    how to make rotations, translations, and collisions of the sprites, and dealt
    with them one by one. Such transformations are not merely applied to images, but
    also to different geometrical figures and shapes. Tetris is a game that comes
    to everyone's mind when we talk about using such transformation operations—where
    a player is allowed to change the shape and size of the geometrical shapes through
    periodic motion. This periodic motion will create a realistic rotational transformation
    of the geometrical shapes, in both anticlockwise and clockwise directions. For
    those who are not familiar with Tetris, check out [https://www.freetetris.org/game.php](https://www.freetetris.org/game.php) and
    observe the grid and the environment of the gameplay.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将pygame精灵和图像合并到我们的Python游戏中是一个简单的过程。它需要一个内置的Python模块—*os—*，它将从您的计算机加载文件。在上一章中，我们在构建Flappy
    Bird游戏时学习了如何对精灵进行旋转、平移和碰撞，并逐个处理它们。这些变换不仅仅适用于图像，还适用于不同的几何图形和形状。当我们谈论使用这样的变换操作时，俄罗斯方块是每个人心中的游戏——玩家被允许通过周期运动改变几何形状的形状和大小。这种周期性运动将在顺时针和逆时针方向上创建逼真的几何形状的旋转变换。对于不熟悉俄罗斯方块的人，请查看[https://www.freetetris.org/game.php](https://www.freetetris.org/game.php)并观察游戏的网格和环境。
- en: 'By observing the environment of the gameplay, you will notice three primary
    things:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察游戏环境，您会注意到三个主要的事情：
- en: '**Geometrical shapes, such as L, T, S, I, and square**: These geometrical shapes
    will be presented in the form of alphabetical characters, and to distinguish between
    them, each shape will have different colors.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**几何形状，如L、T、S、I和正方形**：这些几何形状将以字母字符的形式呈现，并且为了区分它们，每个形状将有不同的颜色。'
- en: '**Grid**: This will be the place where the geometrical shapes can move. This
    will be the game canvas, where geometrical shapes will fall from the top to the
    bottom. The player cannot control this grid, but they can control the shapes.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格**：这将是几何形状可以移动的地方。这将是游戏画布，几何形状将从顶部落到底部。玩家无法控制这个网格，但他们可以控制形状。'
- en: '**Rotate the shapes**: As shapes/blocks will be falling downwards, players
    can use the arrow keys from the keyboard in order to alter the structure of the
    shapes (remember that only rotation transformation is allowed).'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转形状**：当形状/块向下掉落时，玩家可以使用键盘上的箭头键来改变形状的结构（请记住，只允许旋转变换）。'
- en: 'The following diagram shows the shapes that we will be using for our game:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了我们将在游戏中使用的形状：
- en: '![](Images/ea74cf4a-be7c-4741-a349-b3cf92a2a87e.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ea74cf4a-be7c-4741-a349-b3cf92a2a87e.png)'
- en: If you've played the game in the aforementioned link, you will have seen that
    the preceding shapes move within the grid (canvas) of the game. The respective
    letters represent each the geometrical shape they resemble.  Players can only
    use the arrow key to rotate such shapes. For instance, when shape **I** is falling
    to the grid, players can switch between a vertical I and a horizontal **I**. But
    in the case of the square shapes, we do not have to define any rotations since
    the square (due to its equal sides) looks exactly the same after a rotation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩过上述链接中的游戏，你会看到前面的形状在游戏的网格（画布）内移动。相应的字母代表它们所类似的每个几何形状。玩家只能使用箭头键来旋转这些形状。例如，当形状**I**掉落到网格时，玩家可以在垂直**I**和水平**I**之间切换。但对于正方形形状，我们不必定义任何旋转，因为正方形（由于其相等的边）在旋转后看起来完全相同。
- en: Now that you are familiar with the game characters for our Tetris game (geometrical
    shapes), let's brainstorm further in order to extract some critical information
    about the game. Let's talk about the essentials of Tetris. Since Tetris requires
    the creation of different geometrical shapes, it is undoubtedly true that we will
    require the `pygame` module. The `pygame` module can be used to create grids,
    borders, and game characters. Do you remember the `draw` module (from [Chapter
    11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake Game UI
    with Pygame*) of pygame? Obviously, you cannot make good games without using the
    `pygame` `draw` module. Similarly, to handle user action events such as keyboard
    actions, we need pygame.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了我们俄罗斯方块游戏的游戏角色（几何形状），让我们进一步进行头脑风暴，以提取关于游戏的一些关键信息。让我们谈谈俄罗斯方块的基本要素。由于俄罗斯方块需要创建不同的几何形状，毫无疑问我们将需要`pygame`模块。`pygame`模块可以用来创建网格、边界和游戏角色。你还记得`pygame`的`draw`模块（来自[第11章](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml)，*使用Pygame制作Outdo
    Turtle - 贪吃蛇游戏UI*）吗？显然，如果不使用`pygame`的`draw`模块，你无法制作出好的游戏。同样，为了处理用户操作事件，如键盘操作，我们需要pygame。
- en: 'The blueprint of functions represents the top-level view of Tetris that can
    be built by the Python `pygame` module:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的蓝图代表了可以通过Python的`pygame`模块构建的俄罗斯方块的顶层视图：
- en: '`build_Grid()`:This function will draw the grid into the game canvas. The grid
    is the place where we can render geometrical shapes with different colors.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build_Grid()`: 这个函数将在游戏画布中绘制网格。网格是我们可以用不同颜色渲染几何形状的地方。'
- en: '`create_Grid()`: This function will create different horizontal lines into
    the grid so that we can track each shape for rotational transformation.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_Grid()`: 这个函数将在网格中创建不同的水平线，以便我们可以跟踪每个形状进行旋转变换。'
- en: '`rotating_shapes`: This technique will rotate the geometrical shapes within
    the same origin. This means that rotation will not alter the dimension (length
    and height) of an object.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotating_shapes`：这种技术将在相同的原点内旋转几何形状。这意味着旋转不会改变对象的尺寸（长度和高度）。'
- en: Now that we've completed the brainstorming process, let's dive into the fundamental
    concepts of Tetris. The environment of Tetris is simple, yet powerful. We have
    to draw grids into it so that we can track each (*x*,*y*) position of the different
    shapes. Similarly, for tracking each geometrical shape, we need to create a dictionary,
    which will store the **position** of an object as *key* and the **color** of an
    object as *value*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了头脑风暴的过程，让我们深入了解俄罗斯方块的基本概念。俄罗斯方块的环境简单而强大。我们必须在其中绘制网格，以便我们可以跟踪不同形状的每个（*x*，*y*）位置。同样，为了跟踪每个几何形状，我们需要创建一个字典，它将以*键*的形式存储对象的**位置**，以*值*的形式存储对象的**颜色**。
- en: 'Let''s start by writing the template code for our game:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为我们的游戏编写模板代码开始：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we have finished declaring the global for our game, which mostly takes
    care of the width and height of the screen, we can start defining the shapes format
    for the game objects. In the next section, we will define a nested list, which
    we can use to define the multiple structures of the game objects (mostly for geometrical
    shapes).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了为我们的游戏声明全局变量的工作，这些变量主要负责屏幕的宽度和高度，我们可以开始为游戏对象定义形状格式。在下一节中，我们将定义一个嵌套列表，我们可以用它来定义游戏对象的多个结构（主要用于几何形状）。
- en: Creating the shapes format
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建形状格式
- en: 'The upcoming information is tricky. We are going to declare the shapes format
    (all the essential geometrical shapes) for Tetris. Let''s look at a simple example,
    as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的信息有点棘手。我们将声明俄罗斯方块的形状格式（所有必要的几何形状）。让我们看一个简单的例子，如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Observe the shapes format from the preceding code. It is a nested list, and
    we require it because `I` supports one rotation, which will change the vertical
    `I` into a horizontal `I`. Observe the first element of the preceding list; it
    contains a period (`.`), along with an identifier (`0`), to indicate null and
    block placement. In the place of the dot or period, we won''t have anything, and
    so it will remain empty. But in the place of `0`, we will store the block. To
    do this, remove the dot from the preceding code, and observe only element `0`.
    You will see vertical `I` in the zero^([th]) index and horizontal `I` in the first
    index. In the case of square shapes, we don''t need an extra *rotation*, and so
    we will end up declaring only one element inside the list for the square shape.
    It will be something like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面代码中的形状格式。它是一个嵌套列表，我们需要它是因为`I`支持一次旋转，这将把垂直的`I`变成水平的`I`。观察前面列表的第一个元素；它包含一个句点（`.`），以及一个标识符（`0`），表示空和块的放置。在点或句点的位置，我们不会有任何东西，所以它将保持空白。但在`0`的位置，我们将存储块。为了做到这一点，从前面的代码中删除句点，并观察只有元素`0`。你会在零索引中看到垂直`I`，在第一个索引中看到水平`I`。对于正方形形状，我们不需要额外的*旋转*，所以我们最终将在列表内部声明正方形形状的一个元素。它将是这样的：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we know how to create a format for the geometrical shapes, let''s
    create the starter piece of code for different shapes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何为几何形状创建格式了，让我们为不同的形状创建代码的起始部分：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Similarly, let''s define the shape format for another few geometrical shapes,
    like we did previously:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们像之前一样为另外几个几何形状定义形状格式：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have successfully defined the characters for our game, let''s make
    a data structure to hold these objects, along with their color. Let''s write the
    following code to implement this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功地为我们的游戏定义了角色，让我们创建一个数据结构来保存这些对象，以及它们的颜色。让我们编写以下代码来实现这一点：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since we have completed the basic starter file, that is, we have understood
    and created our game objects, in the next section, we will start creating a grid
    for our game, as well as render the game objects onto the screen.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经完成了基本的起始文件，也就是说，我们已经理解并创建了我们的游戏对象，在下一节中，我们将开始为我们的游戏创建一个网格，并将游戏对象渲染到屏幕上。
- en: Creating a grid and random shapes
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建网格和随机形状
- en: Now that we have defined the format of the shapes, it is time to give actual
    characteristics to them. The way that we provide characteristics to the shapes
    is by defining dimensions and color. Previously, we defined the dimension of the
    block as being 30 in size, which is not arbitrary; the dimension of the shapes
    must be equal in height and width. Every geometrical shape that we are going to
    draw in this chapter will resemble at least square shapes. Confused? Look at the
    code where we defined the shape format, including period (`.`) and character (`0`).
    If you observe each element of the list closely, you will see the format of the
    square, with equal numbers of dots arranged in rows and columns.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了形状的格式，是时候给它们实际的特征了。我们为形状提供特征的方式是定义尺寸和颜色。之前，我们将方块的尺寸定义为30，这并不是任意的；形状的尺寸必须在高度和宽度上相等。在本章中我们要绘制的每个几何形状都将至少类似于正方形。感到困惑吗？看看我们定义形状格式的代码，包括句点（`.`）和字符（`0`）。如果你仔细观察列表的每个元素，你会看到正方形的格式，行和列中排列着相等数量的点。
- en: 'As we mentioned in the *Understanding Tetris essentials* section, the grid
    is the place or environment where our game characters will reside. The player
    control, or action, will be activated only within the grid area. Let''s talk about
    how the grid can be used in our game. The grid is the division of the screen in
    the form of vertical and horizontal lines, which will make up each row and column.
    Let''s make one for ourselves and observe the result:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*了解俄罗斯方块的基本要素*部分中提到的，网格是我们游戏角色将驻留的地方或环境。玩家控制或动作只能在网格区域内激活。让我们谈谈网格在我们的游戏中如何使用。网格是屏幕以垂直和水平线的形式划分，每行和每列都由此组成。让我们自己制作一个并观察结果：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code is complex, but it is an essential building block for most
    of the games that are made out of pygame. The preceding code will return a grid,
    which is obviously the environment for our Tetris game, but it can also be used
    for multiple purposes, such as building tic-tac-toe with little modification,
    or Pac-Man, and so on. The argument to the `build_Grid()` function is a single
    argument—the *occupied* dictionary. This dictionary will be passed to this function
    from the place where this function is called. Mainly, this function will be called
    inside the main function, which will initiate the process of creating a grid for
    the game.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码很复杂，但它是pygame大多数游戏的基本构建块。前面的代码将返回一个网格，显然是我们俄罗斯方块游戏的环境，但它也可以用于多种用途，比如稍加修改就可以用于制作井字游戏或吃豆人等。`build_Grid()`函数的参数是一个参数——*occupied* 字典。这个字典将从调用这个函数的地方传递给这个函数。主要是这个函数将在主函数内部调用，这将启动创建游戏网格的过程。
- en: 'The occupied dictionary that is passed to `build_Grid` will contain a key and
    a value (as it is a dictionary). The key will represent the position where each
    block or shapes resides. The value will contain the color code of each shape that
    is represented by the key. For example, in your print dictionary, you will see
    something like `{position: color_code}`.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`build_Grid`的occupied字典将包含一个键和一个值（因为它是一个字典）。键将表示每个块或形状所在的位置。值将包含每个形状的颜色代码，由键表示。例如，在你的打印字典中，你会看到类似`{位置:颜色代码}`的东西。
- en: The next line of the operation should be a gotcha moment for you. If not, you
    are missing something! This can be found in [Chapter 7](2d97aa5e-7fdd-459d-9c73-626e29c3a0ed.xhtml),
    *List Comprehension and Properties*. With the help of one line of code, we defined
    an arrangement of rows and columns (multi-dimensional list). It will provide us
    with a range of values that can be used to create a grid of lines. Of course,
    lines will be drawn later in the main function, with the help of the `pygame`
    `draw` module. We will create a list of 10 rows and a list of 20 columns. Now,
    let's talk about the last couple of lines of code (the highlighted part). These
    lines of code will loop through each occupied position and add that to the grid
    by modifying it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的下一行应该是一个让你大吃一惊的时刻。如果没有，你就错过了什么！这可以在[第7章](2d97aa5e-7fdd-459d-9c73-626e29c3a0ed.xhtml)中找到，*列表推导和属性*。借助一行代码，我们定义了行和列的排列（多维列表）。它将为我们提供一系列值，可以用来创建一系列线的网格。当然，线将在主函数中稍后借助`pygame`的`draw`模块来绘制。我们将创建一个包含10行和一个包含20列的列表。现在，让我们谈谈代码的最后几行（高亮部分）。这些代码将循环遍历每个占用的位置，并通过修改它将其添加到网格中。
- en: 'After defining the environment for our game, the next thing we need to do is
    define the shapes for our game. Remember that each shape will have attributes
    like these:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的游戏定义环境之后，我们需要做的下一件大事是定义游戏的形状。记住，每个形状都会有这样的属性：
- en: '**Row and column position**: The grid-specific position will be specified as
    a certain row and column of shapes or geometrical pieces.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行和列位置**：网格特定位置将被指定为一定行和列的形状或几何图形。'
- en: '**Shape name**: The identifier for a shape, which indicates which shapes to
    render. We will add alphabetical characters for each shape, for example, character
    S for shape S.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**形状名称**：形状的标识符，表示要渲染哪些形状。我们将为每个形状添加字母字符，例如，形状S的字符S。'
- en: '**Color**: The color of each shape.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色：每个形状的颜色。
- en: '**Rotation**: The angle of rotation for each shape.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转**：每个形状的旋转角度。'
- en: 'Now that we are aware of the available attributes for each shape, let''s define
    the class for shape and attach each attribute to it. Write the following code
    in order to create `Shape` class:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了每个形状的可用属性，让我们为形状定义类，并将每个属性附加到它上面。按照以下代码创建`Shape`类：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `objects_color and game_objects` variable was defined previously, and is
    two different lists that contain alphabetical characters in one list. The color
    code for each of them in the other list.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`objects_color`和`game_objects`变量之前已经定义，它们是两个包含一个列表中的字母字符的不同列表。另一个列表中包含它们的颜色代码。'
- en: 'At this moment, if you run your game, you won''t see anything except for an
    empty black screen, which is because our grid background was rendered with the
    color code of black. We know that, if we want anything to draw, it can be done
    with the help of the Python `pygame` module. Furthermore, we are drawing shapes
    from the top to the bottom of the grid, and so we have to generate shapes randomly.
    Since we have five shapes, that is, I, O, J, L, and T, we need to render them
    randomly, one by one. Let''s make a function to implement in the following code
    snippet. Remember, we already imported a random module at the beginning:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此刻，如果你运行你的游戏，你除了一个空的黑屏之外什么也看不到，这是因为我们的网格背景是用黑色代码渲染的。我们知道，如果我们想要画任何东西，可以借助Python的`pygame`模块来实现。此外，我们是从网格的顶部到底部绘制形状，所以我们必须随机生成形状。因为我们有五种形状，即I、O、J、L和T，我们需要随机地渲染它们，一一地。让我们编写一个函数来实现以下代码片段。记住，我们在开始时已经导入了一个随机模块：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding backend logic is vital for any game that has something to do with
    geometrical shapes and pieces. The scope of this knowledge is much broader than
    you will have expected. Many RPG games, including Minecraft, have the player interact
    with different geometrical shapes. Thus, creating a grid is vital so that we can
    reference the position and color of each piece. Now that we have created some
    general logic that will create pieces of different shapes and color, we need a
    tool that can render such shapes into the grid, which is normally done by either
    OpenGL or pygame (PyOpenGL will be covered in the upcoming [Chapter 14](6682d3f2-927b-4434-a452-dc64329ae6a3.xhtml),
    *Getting to Know PyOpenGL*). However, the superior tool will be pygame, in the
    case of Python. Thus, we will make the Tetris game shapes and characters with
    the help of the `pygame` module.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的后端逻辑对于任何涉及几何形状和图形的游戏都是至关重要的。这种知识的范围比你想象的要广泛得多。许多RPG游戏，包括Minecraft，都让玩家与不同的几何形状进行交互。因此，创建网格是至关重要的，这样我们就可以引用每个图形的位置和颜色。现在我们已经创建了一些通用逻辑，可以创建不同形状和颜色的图形，我们需要一个工具，可以将这些形状渲染到网格中，通常是通过OpenGL或pygame来完成（PyOpenGL将在接下来的[第14章](6682d3f2-927b-4434-a452-dc64329ae6a3.xhtml)中介绍，*了解PyOpenGL*）。然而，在Python的情况下，更优秀的工具将是pygame。因此，我们将使用`pygame`模块来制作俄罗斯方块游戏的形状和字符。
- en: In the next section, we will create some logic that will set up a game window
    for the grid structure. We will also try to run our game and observe its environment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建一些逻辑，为网格结构设置游戏窗口。我们还将尝试运行游戏并观察其环境。
- en: Setting up the window and game loop
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置窗口和游戏循环
- en: The next big thing in our game, after setting up the game objects, is to render
    the grid. Don't get confused by thinking that we have already created the grid,
    after we defined the `build_Grid()` method. Although it is a valid point, the
    grid that we built is virtual up to this point. If you simply call the `build_Grid`
    method, you won't see anything but a black screen, which is the background of
    the grid. Here, we are going to provide a structure to this grid. Using each position,
    specified by row and column, we are going to create a straight line using the
    `pygame` module.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置游戏对象之后，我们游戏中的下一个重要步骤是渲染网格。不要被误导以为我们已经创建了网格，因为我们定义了`build_Grid()`方法之后。虽然这是一个有效的观点，但我们建立的网格到目前为止都是虚拟的。如果你简单地调用`build_Grid`方法，你将看不到任何东西，只会看到一个黑屏，这是网格的背景。在这里，我们将为这个网格提供一个结构。使用每个位置，由行和列指定，我们将使用`pygame`模块创建一条直线。
- en: 'Let''s make a simple function to draw a window for our game (the main window)
    in which the grid will reside:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的函数来为我们的游戏绘制一个窗口（主窗口），网格将驻留在其中：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding line of code will create the physical structure of the grid, which
    will have different rows and columns. After looping through the entire grid scene
    or positions of the grid, we will enter the grid scope in order to draw a rectangle
    and a grid border with the previously highlighted part of the code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码行将创建网格的物理结构，它将有不同的行和列。在循环遍历整个网格场景或网格的位置之后，我们将进入网格范围，以便使用先前突出显示的代码部分绘制一个矩形和网格边框。
- en: 'Similarly, let''s provide a physical structure to this grid by defining borders
    for it. Each row and column will be distinguished by creating lines within it.
    Since we can draw lines with the pygame `draw` module, we will use it to write
    the following function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们通过为其定义边界来为这个网格提供物理结构。每一行和每一列都将通过在其中创建线条来区分。由于我们可以使用pygame `draw`模块绘制线条，我们将使用它来编写以下函数：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding function has one main loop, which loops into several rows, as
    determined by the `build_Grid` method. After going into each row of the grid structure,
    it will use the `pygame` `draw` module to draw lines with a color code of (128,
    128, 128), starting from (`side_x`, `side_y`) and then pointing to the next coordinate
    (`side_x + game_width, side_y + eachRow *30`). The starting point (`side_x`, `side_y`)
    is the left-most corner of the grid, while the next coordinate value of (`side_x
    + game_width, side_y + eachRow *30`) represents the coordinate of the right-most
    corner of grid. Thus, we will a draw line from the left-most corner of the grid
    to the right-most corner.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数有一个主循环，它循环进入由`build_Grid`方法确定的几行。在进入网格结构的每一行之后，它将使用`pygame` `draw`模块以颜色代码(128,
    128, 128)绘制线条，从(`side_x`, `side_y`)开始，然后指向下一个坐标(`side_x + game_width, side_y +
    eachRow *30`)。起始点(`side_x`, `side_y`)是网格的最左侧角，而下一个坐标值(`side_x + game_width, side_y
    + eachRow *30`)表示网格的最右侧角的坐标。因此，我们将从网格的最左侧角绘制一条线到最右侧角。
- en: 'After you explicitly call the previous function, you will see the following
    output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在显式调用了前一个函数之后，你会看到以下输出：
- en: '![](Images/308f5211-105f-4eb1-b438-b076b37c299b.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/308f5211-105f-4eb1-b438-b076b37c299b.png)'
- en: 'After setting up the aforementioned grid or environment, we will hop into the
    fun stuff, which is creating the main function. The main function will have a
    different bunch of stuff in it, mostly for calling up and setting the grid, and
    handling user events or actions, such as what happens when the user presses quit
    or presses an arrow key on the keyboard. Let''s define it with the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了上述的网格或环境之后，我们将进入有趣的部分，也就是创建主函数。主函数将包含不同的内容，主要是用于调用和设置网格，并处理用户事件或操作，比如用户按下退出键或键盘上的箭头键时会发生什么。让我们用以下代码来定义它：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since we have started defining the main function, which is the director of
    our game, let''s define what things it must do, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经开始定义主函数，它是我们游戏的指挥官，让我们定义它必须做的事情，如下所示：
- en: Call multiple functions, such as `build_Grid()` and `create_Grid()`, which will
    set up the environment for games
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用多个函数，比如`build_Grid()`和`create_Grid()`，它们将设置游戏的环境
- en: Define a method that will perform rotations for a shape that represents characters
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个方法，执行代表字符的形状的旋转
- en: Define some logic that will add fall time constraints to the game, that is,
    the speed at which objects fall
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一些逻辑，将下落时间限制添加到游戏中，也就是物体下落的速度
- en: Change a shape in, after one shape fall to the ground
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变一个形状，在一个形状落到地面后
- en: Create some logic to check the occupied position of the shapes
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一些逻辑来检查形状的占用位置
- en: The aforementioned processes are the main function capabilities, and we should
    address them. We will address the first two in this section, but the remaining
    two will be covered in the upcoming sections. So, the first operation of the main
    function is to call some essential functions that will create the grid for the
    game. If you look at the aforementioned line of code, you will see that we have
    already called the  `build_Grid` method, which is responsible for creating the
    virtual positions for rows and columns of a grid-like structure. Now, the remaining
    task is to only call the `create_Grid()` method, which will give a proper physical
    structure to this virtual grid, using the `pygame` `draw` module. We have already
    defined both of these functions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上述过程是主函数的功能，我们应该解决它们。我们将在本节中解决前两个问题，但剩下的两个问题将在接下来的部分中解决。因此，主函数的第一个操作是调用一些关键函数，用于创建游戏的网格。如果你看上述的代码行，你会看到我们已经调用了`build_Grid`方法，它负责创建网格结构的行和列的虚拟位置。现在，剩下的任务只是调用`create_Grid()`方法，它将使用`pygame`
    `draw`模块为这个虚拟网格提供适当的物理结构。我们已经定义了这两个函数。
- en: In the next section, we'll learn about one of the important mathematical paradigms
    of transformation, which is known as rotation, and will add the feature of rotating
    game objects to our Tetris game.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习一个重要的数学变换范式，即旋转，并将在我们的俄罗斯方块游戏中添加旋转游戏对象的功能。
- en: Understanding rotations
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解旋转
- en: 'Before we continue to code and modify the main function, let''s get into the
    mathematical stuff. Games are nothing if they are not related to a mathematical
    paradigm. Movement, motions, shapes, characters, and controls are all handled
    by mathematical expressions. In this section, we are going to cover another important
    concept of math: transformations. Although transformations is a nebulous concepts
    in math, we will try our best to learn this concept. Specifically, there are different
    types of transformations: rotation, translation, reflection, and enlargement.
    In most games, we will need only two types of transformation: rotation and enlargement.
    In this chapter, we will implement rotational transformations using Tetris, and
    then we will implement the enlargement transformation (while building an Angry
    Birds game in [Chapter 16](f8991a99-2dc4-4d55-8a7d-bb9b71f04109.xhtml), *Learning
    Game AI – Building a Bot to Play*).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续编写代码并修改主函数之前，让我们先了解一下数学知识。如果游戏与数学范式无关，那么游戏就什么都不是。运动、形状、角色和控制都由数学表达式处理。在本节中，我们将介绍数学的另一个重要概念：变换。尽管变换在数学中是一个模糊的概念，但我们将尽力学习这个概念。具体来说，有不同类型的变换：旋转、平移、反射和放大。在大多数游戏中，我们只需要两种类型的变换：旋转和放大。在本章中，我们将使用俄罗斯方块实现旋转变换，然后在[第16章](f8991a99-2dc4-4d55-8a7d-bb9b71f04109.xhtml)中实现放大变换（构建愤怒的小鸟游戏时，*学习游戏人工智能-构建一个玩游戏的机器人*）。
- en: 'The term *rotation* is a mathematical concept which states that *When an object
    is rotated, it means that it is turned either clockwise or anticlockwise with
    a certain amount of specified degree*. Consider the following example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*旋转*是一个数学概念，它表示*当一个对象被旋转时，意味着它以特定角度顺时针或逆时针旋转*。考虑以下例子：
- en: '![](Images/7370dec7-a5e6-4beb-a586-3e05a340cc64.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7370dec7-a5e6-4beb-a586-3e05a340cc64.png)'
- en: In the preceding example, we have a rectangular shape, which represents the
    alphabetical `I` character of our Tetris game. Now, imagine that the player presses
    the *up* arrow key on the keyboard. In such an event, the rectangular shape of
    `I` must be rotated with an angle of 90 degrees and placed as the horizontal `I`
    character, as shown in the preceding diagram. Thus, these rotations are done to
    change the shape of the figure, but not the dimensions. Horizontal `I` and vertical
    `I` have the same dimensions (height and width). Now that you know a little bit
    about rotations, you can go back to the code where we defined the shape format
    for each character (I, O, J, L, and T) and observe the multi-dimensional list.
    In the case of `I`, you could observe that it has two elements. The first element
    of the list is the original shape of the game object, `I`, and the second element
    of the list is a distorted shape after a rotation of about 90 degrees. Observe
    the same for the `O` character, which is square. The square will remain the same,
    even after a rotation by any degree. Thus, in the case of the square shape, we
    have only one element in the list.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个矩形形状，代表了俄罗斯方块游戏中的字母`I`字符。现在，想象一下玩家按下键盘上的*上*箭头键。在这种情况下，`I`的矩形形状必须以90度的角度旋转，并放置为水平的`I`字符，如前面的图表所示。因此，这些旋转是为了改变图形的形状，而不是尺寸。水平`I`和垂直`I`具有相同的尺寸（高度和宽度）。现在您已经了解了一些关于旋转的知识，您可以回到我们为每个字符（I、O、J、L和T）定义形状格式的代码，并观察多维列表。在`I`的情况下，您可以观察到它有两个元素。列表的第一个元素是游戏对象`I`的原始形状，列表的第二个元素是在旋转约90度后的扭曲形状。观察一下`O`字符，它是一个正方形。即使旋转任意角度，正方形仍然保持不变。因此，在正方形形状的情况下，列表中只有一个元素。
- en: 'Although we''ve learned this trivia about rotations, and how they are attached
    with the each shape format, the question still remains that: when can we render
    each shape, and when should the operation of rotations be carried out? The answer
    is simple. While a player presses any arrow key on the keyboard, we are going
    to perform rotations. But where is the code that implies that the user is pressing
    a keyboard key? Obviously, it is done inside the event handling process! In the
    main function, we started to capture the event, and we handled the actions for
    the `QUIT` key. Now, let''s perform the rotations for any arrow key with the following
    code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经了解了关于旋转的这些琐事，以及它们如何与每个形状格式相关联，但问题仍然存在：何时可以渲染每个形状，何时应执行旋转操作？答案很简单。当玩家按下键盘上的任何箭头键时，我们将执行旋转。但是哪里的代码暗示用户正在按键盘键？显然，这是在事件处理过程中完成的！在主函数中，我们开始捕获事件，并处理`QUIT`键的操作。现在，让我们使用以下代码对任何箭头键执行旋转：
- en: The code should be added inside the event handling steps, right after handling
    the `QUIT` key. Make sure that you provide a proper indentation for the code.
    The code will be available at [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter13](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter13).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码应该添加在事件处理步骤中，在处理`QUIT`键之后。确保为代码提供适当的缩进。代码将在[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter13](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter13)上提供。
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you want to learn more about how the rotation of objects works under the
    hood, make sure that you check out the following URL: [https://mathsdoctor.co.uk](https://mathsdoctor.co.uk).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于对象旋转如何在幕后工作的知识，请确保查看以下网址：[https://mathsdoctor.co.uk](https://mathsdoctor.co.uk)。
- en: 'In order to set up the window canvas or game screen, we can simply call the
    `pygame set_mode` method and render the window of the grid accordingly. The following
    line of the method call should be added within the main function, right after
    you have set up the user handling events:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置窗口画布或游戏屏幕，我们可以简单地调用`pygame set_mode`方法，并相应地渲染网格的窗口。方法调用的以下行应该在主函数中添加，在您设置了用户处理事件之后：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we have created a grid for the screen, let''s set up the main screen
    and call up the main function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为屏幕创建了一个网格，让我们设置主屏幕并调用主函数：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We have covered almost all of the important things, including rendering the
    display, rotating objects, creating grids, and rendering borders for grids; but
    one question still remains: how do we render the shapes into the grid? Obviously,
    our computer is not smart enough to understand the multi-dimensional list that
    we created earlier to define the shapes format. Still confused? Check the multi-dimensional
    list that we created for each character, such as I, O, J, L, and T—our computer
    won''t understand such a list. Thus, we have to convert these list values or attributes
    into the dimensions that will be recognized by our computer for further processing.
    The dimensional value that our computer will understand refers to the positional
    value. Since we have established the grid already, we can use rows and columns
    from the grid structure to give positional value to the computer. Thus, let''s
    make a function to implement it.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了几乎所有重要的事情，包括渲染显示，旋转对象，创建网格，渲染网格边界；但还有一个问题：我们如何将形状渲染到网格中？显然，我们的计算机还不够聪明，无法理解我们之前创建的多维列表来定义形状格式。还是困惑？检查我们为每个字符创建的多维列表，比如I，O，J，L和T——我们的计算机无法理解这样的列表。因此，我们必须将这些列表值或属性转换为我们的计算机将进一步处理的维度值。我们的计算机将理解的维度值是指位置值。由于我们已经建立了网格，我们可以使用网格结构的行和列为计算机提供位置值。因此，让我们创建一个函数来实现它。
- en: Converting the shape format
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换形状格式
- en: 'Our computer doesn''t have the capability to understand the obscure content
    of data structures, such as the content that is stored inside the multi-dimensional
    list. For example, take a look at the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算机无法理解数据结构的模糊内容，比如存储在多维列表中的内容。例如，看一下以下代码：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the previous square-shaped pattern, we have coupled a list of periods (`.`)
    with `0`. The computer won''t recognize what 0 means, and what the period refers
    to. We only have the knowledge that the period is in a position that is an empty
    place, which means its position can be ignored, and the position where `0` resides
    is the position for the block. Thus, we need to write a program to tell the computer
    to extract the position from the grid where only `0` resides for each of the pieces.
    We will implement it by defining the following function:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的方形模式中，我们将一系列句点（`.`）与`0`配对。计算机不会认识0代表什么，句点代表什么。我们只知道句点在一个空位上，这意味着它的位置可以被忽略，而`0`所在的位置是块的位置。因此，我们需要编写一个程序，告诉计算机从网格中提取只有`0`所在的位置的程序。我们将通过定义以下函数来实现它：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s look at the previous code in detail:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看一下以前的代码：
- en: To begin with, this function returns the position of the block of the objects.
    Thus, we start by creating a block dictionary.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，这个函数返回对象的块的位置。因此，我们首先创建一个块字典。
- en: Secondly, we store several lists of shapes, as defined by a multi-dimensional
    list of characters, which are defined by `game_objects` (I, O, J, L, and T) with
    rotations.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，我们存储了几个形状的列表，由多维字符列表`game_objects`（I，O，J，L和T）定义，并进行了旋转。
- en: 'Now, the important part: what are the positions that must be returned by this
    function? These positions are the position of `0`, placed in the grid.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重要的部分：这个函数必须返回什么位置？这些位置是放置在网格中的`0`的位置。
- en: Observe the multi-dimensional list again. You will see a bunch of dots (`.`)
    and `0` placed as elements. We only want the position where `0` resides, and not
    where the period or dot resides.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次观察多维列表。你会看到一堆点（`.`）和`0`作为元素。我们只想要`0`所在的位置，而不是句点或点所在的位置。
- en: After we check each column for `0` with the `if column == \'0\'` command, we
    only store such positions into the positions dictionary, and return it from the
    function.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们使用`if column == \'0\'`命令检查每一列是否有`0`之后，我们只将这样的位置存储到positions字典中，并从函数中返回。
- en: When operations such as rotation and movements are done, it is often the case
    that the user might trigger some invalid movements, such as rotating the objects
    outside of the grid. Thus, we have to check such invalid movements and prevent
    them from happening. We will create the `check_Moves()` function to implement
    this. The argument to this function will be the shape and grid position; shape
    is essential to check if a specific rotation is allowed or not within the position
    that is indicated by the grid argument. If the current position specified by the
    grid in which shape resides is already occupied, then we will get rid of such
    moves. There are different ways to implement it, but the quickest and easiest
    way is to check the color of the grid background. If the color of the particular
    position in the grid is anything other than black, it means that the position
    is occupied. Thus, you can make an articulated reference from this logic as to
    why we made the background color of the grid black. By doing so, we can check
    if the objects are already in the grid or not. If any new object comes down to
    the grid, we should not pass it through the object that is already present in
    the grid.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行旋转和移动等操作时，用户可能会触发一些无效的移动，比如将对象旋转到网格外部。因此，我们必须检查这些无效的移动并阻止它们发生。我们将创建`check_Moves()`函数来实现这一点。这个函数的参数将是形状和网格位置；形状是必要的，以检查特定旋转是否允许在由网格参数指示的位置内进行。如果网格指定的当前位置已经被占据，那么我们将摆脱这样的移动。有不同的实现方式，但最快最简单的方式是检查网格背景的颜色。如果网格中特定位置的颜色不是黑色，那么这意味着该位置已经被占据。因此，你可以从这个逻辑中得出一个详细的参考，解释为什么我们将网格的背景颜色设为黑色。通过这样做，我们可以检查对象是否已经在网格中。如果任何新对象下降到网格中，我们不应该通过已经存在于网格中的对象。
- en: 'Now, let''s make a function to check if the position is occupied or not:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个函数来检查位置是否被占用：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Up until now, we were building the backend logic for our game, which refers
    to rendering the grid, manipulating the grid, changing grid positions, implementing
    logic that determines what happens when two objects collide, and so on. Even though
    we have done so much already, when you run your game, you will still see only
    the formation of the grid, and nothing more. This is because our main loop is
    the director of our game—it will sequentially order the other functions, but inside
    the main loop, we have nothing except the code that handles the user events. Thus,
    in the next section, we will the modify main loop for the game and observe the
    output.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在为我们的游戏构建后端逻辑，这涉及到渲染网格、操作网格、改变网格位置、实现决定两个对象碰撞时发生什么的逻辑等。尽管我们已经做了这么多，但当你运行游戏时，你仍然只会看到网格的形成，什么都没有。这是因为我们的主循环是游戏的指挥官——它将顺序地命令其他函数，但在主循环内，除了处理用户事件的代码之外，我们什么都没有。因此，在下一节中，我们将修改游戏的主循环并观察输出。
- en: Modifying the game loop
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改游戏循环
- en: 'As we mentioned previously, our main game loop is accountable for performing
    many tasks, including handling user events, handing the grid, checking possible
    moves, and so on. We have been making functions that will check such actions,
    movements, and environments, but we have not called them once, which we will do
    in this section. If you observe the main game loop from a high-level perspective,
    it will contain four primary architectural building blocks:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们的主游戏循环负责执行许多任务，包括处理用户事件、处理网格、检查可能的移动等。我们一直在制作将检查这些动作、移动和环境的函数，但我们还没有调用它们一次，这将在本节中完成。如果你从高层次的角度观察主游戏循环，它将包含四个主要的架构构建块：
- en: Creating the grid and handling movements of the game objects. For instance,
    what should be the speed of the objects that will fall down into the grid?
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建网格和处理游戏对象的移动。例如，掉落到网格中的对象的速度应该是多少？
- en: Handling user events. We have already done this, when we checked the events
    and rotated the objects accordingly. But the preceding code didn't accommodate
    the `check_Moves()` function, which will check if the moves are valid or not.
    Thus, we will modify the preceding code accordingly.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户事件。我们已经在检查事件并相应地旋转对象时做过这个，但前面的代码没有考虑`check_Moves()`函数，它将检查移动是否有效。因此，我们将相应地修改前面的代码。
- en: Adding color to the game objects (unique color). For instance, the color of
    `S` should be different to `I`.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为游戏对象添加颜色（唯一颜色）。例如，`S` 的颜色应该与 `I` 不同。
- en: Adding the logic that will check what happens when the object hits the ground
    of the grid.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加逻辑，检查对象撞击网格底部时会发生什么。
- en: 'We will implement each of the aforementioned steps one by one. Let''s start
    by adding speed to the object. Speed refers to the free-falling speed of the objects
    in the grid structure. The following code should be added inside the main function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步实现上述每个步骤。让我们从为对象添加速度开始。速度指的是网格结构中对象的自由下落速度。以下代码应该添加到主函数中：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Suppose that the player tries to make an invalid move. Even in that case, the
    game objects (shapes) must fall freely downwards. Such an operation is done in
    the last three lines of the previous code. Other than that, the code is self-explanatory;
    we have defined the speed for the object to fall into the grid and used a clock
    module to implement the time constraints.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设玩家尝试进行无效的移动。即使在这种情况下，游戏对象（形状）也必须自由向下掉落。这样的操作是在前面代码的最后三行中完成的。除此之外，代码是不言自明的；我们已经为对象定义了下落到网格中的速度，并使用了时钟模块来实现时间约束。
- en: 'To implement the next logic, this is relatively easier. We have already discussed
    handling user events in Tetris while considering details such as rotating objects
    and performing simple left-to-right movements. However, in those lines of code,
    we didn''t check if the moves that the user tried to make were valid or not. We
    have to check this first in order to make sure that users are prevented from making
    any invalid moves. To implement this, we are going to call the `check_Moves()`
    method, which we created previously. The following code will handle user events:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 实现下一个逻辑，这相对容易一些。我们已经讨论了在俄罗斯方块中处理用户事件，考虑了旋转对象和进行简单的左右移动等细节。然而，在这些代码中，我们没有检查用户尝试的移动是否有效。我们必须首先检查这一点，以确保用户不能进行任何无效的移动。为了实现这一点，我们将调用之前创建的`check_Moves()`方法。以下代码将处理用户事件：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Firstly, focus on the code that is highlighted. The first highlighted part
    of the code refers to whether the move is valid into the grid, which is checked
    by the `check_Moves()` function. We are allowing the current shapes to move to
    the right corner, which is toward the positive *x*-axis. Similarly, regarding
    the up key, it is responsible for checking if rotation of the object is allowed
    or not (only the up key will rotate the objects; the *left* and *right* keys will
    move the objects from left to right, and vice versa).  In the case of rotation,
    we are rotating it through pixel transformations, which is done by selecting one
    of the positions indicated by the multi-dimensional list. For example, in the
    case of shape I, we have two elements in the list: one original shape and another
    rotational shape. Thus, to use another rotational shape, we will check if the
    move is valid or not, and if it is, we will render the new shape.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，关注被突出显示的代码。代码的第一个突出显示的部分是指移动是否有效进入网格，这是由`check_Moves()`函数检查的。我们允许当前形状向右角移动，即朝着正
    *x* 轴。同样，关于上键，它负责检查对象是否允许旋转（只有上键会旋转对象；*左* 和 *右* 键会将对象从左到右移动，反之亦然）。在旋转的情况下，我们通过像素变换来旋转它，这是通过选择多维列表中指示的位置之一来完成的。例如，在形状
    I 的情况下，列表中有两个元素：一个原始形状和另一个旋转形状。因此，为了使用另一个旋转形状，我们将检查移动是否有效，如果有效，我们将呈现新的形状。
- en: 'The third piece of code that should be added into the main function will deal
    with the technique that will add the color to the shapes in the grid for drawing.
    The following line of code will add the color to each of the objects that is inside
    the scope of the game:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 应该添加到主函数中的第三段代码将处理为绘制网格中的形状添加颜色的技术。以下代码将为游戏范围内的每个对象添加颜色：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, the last piece of logic that must be added to the main function will
    address the situation of when an object hits the ground. Let''s add the following
    code into the main function in order to implement it:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，必须添加到主函数中的最后一段逻辑将处理当对象触地时的情况。让我们添加以下代码到主函数中以实现它：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, we are checking whether the objects are falling freely
    or not by checking the contents of the Boolean variable, `change_shape`. Then,
    we are checking the current position of the shapes and creating (*x*, *y*), which
    will represent the occupied position. We then add such a position to the dictionary
    named occupied*.* You must remember that the value of this dictionary is the color
    code of the same object. After assigning the current object to the grid scope,
    we will generate a new shape with the help of the `generate_shapes ()` method.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们通过检查布尔变量`change_shape`的内容来检查对象是否自由下落。然后，我们检查形状的当前位置并创建（*x*，*y*），它将表示占用的位置。然后将这样的位置添加到名为occupied*的字典中。您必须记住，该字典的值是相同对象的颜色代码。在将当前对象分配给网格范围后，我们将使用`generate_shapes()`方法生成一个新形状。
- en: 'Finally, let''s end our main function by calling the `create_Grid()` function
    with the argument of the grid and surface objects that were initialized by the
    pygame `set_mode()` method in the following code (we initialized the pygame `surface`
    object previously):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过调用`create_Grid()`函数来结束我们的主函数，参数是在以下代码中由pygame的`set_mode()`方法初始化的网格和表面对象（我们之前初始化了pygame的`surface`对象）：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s run our game and observe the output for it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行游戏并观察输出：
- en: '![](Images/c2d46b20-3945-47a1-b433-1dd79e686249.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c2d46b20-3945-47a1-b433-1dd79e686249.png)'
- en: Now, you can clearly see that we are able to make a Tetris game where the users
    are able to transform the objects and play accordingly. But wait! We are missing
    one important piece of logic in our game. How do we incentivize our player to
    play this game? If the game was all about making rotations of objects, and filling
    up grids with the objects, it would not have been the historical game that it
    is (the game that revolutionized the 90s gaming industry). Yes! There is some
    logic that must be added into the game, and when this logic is called, we will
    observe that whenever the row positions are *occupied* by the blocks, we have
    to clear such rows and shift the row one step down, which will leave us with fewer
    rows than before. We will implement this in the next section.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以清楚地看到我们能够制作一个俄罗斯方块游戏，用户可以根据需要转换对象并进行游戏。但等等！我们的游戏缺少一个重要的逻辑。我们如何激励玩家玩这个游戏？如果游戏只是关于旋转对象和用对象填充网格，那它就不会是历史悠久的游戏（这个游戏改变了90年代的游戏产业）。是的！游戏中必须添加一些逻辑，当调用这个逻辑时，我们将观察到每当行位置被*占用*时，我们必须清除这些行并将行向下移动一步，这将使我们比以前少了几行。我们将在下一节中实现这一点。
- en: Clearing the rows
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除行
- en: 'As we mentioned previously, in this section, we will check if every position,
    of all the rows, is entirely occupied or not. If they are occupied, we will delete
    such rows from the grid, and this will create a shift in each row by one step
    down into the grid. This logic is simple to implement. We will check whether or
    not the entire row is occupied and delete such rows accordingly. Do you remember
    the case of creating the `check_Moves()` function? If this function checked the
    background color of each row, and if in each row there is no black background
    color, it means that such a row is occupied. But even if we have one position
    empty, this means that the background color of such a position will be black,
    and will be considered as not occupied. Thus, we can use a similar type of technique
    in the case of clearing the rows: if, in any row, the background color of any
    position is black, it means that the position is not occupied, and such rows cannot
    be cleared.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，在本节中，我们将检查所有行的每个位置是否完全被占用。如果它们被占用，我们将从网格中删除这些行，并且这将导致每一行在网格中向下移动一步。这个逻辑很容易实现。我们将检查整行是否被占用，并相应地删除这些行。您还记得`check_Moves()`函数的情况吗？如果此函数检查每行的背景颜色，如果每行都没有黑色背景颜色，这意味着这样的行是被占用的。但即使我们有一个空位置，这意味着这个位置的背景颜色将是黑色，并且将被视为未被占用。因此，在清除行的情况下，我们可以使用类似的技术：如果在任何行中，任何位置的背景颜色是黑色，这意味着该位置未被占用，这样的行不能被清除。
- en: 'Let''s make a function to implement the logic of clearing the rows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个函数来实现清除行的逻辑：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s digest the preceding code. It is quite a complex piece of logic, so
    make sure that you learn everything about it; these concepts are not only suitable
    for game creation but are also asked many times in a technical interview. The
    question lies in how to shift the values of the data structure by creating logic,
    and not by using the Python built-in function. I wanted to teach you this in this
    way instead of using any built-in method because knowing this might be helpful
    in any technical field of programming. Now, let''s observe the code. It starts
    with creating a `number_of_rows_deleted` variable, which indicates the number
    of rows that have been deleted from the grid. The information regarding the number
    of deleted rows is important because after deleting that number of rows, we need
    to shift the rows which reside above the deleted row(s) by an equal number down
    the grid. For example, look at the following diagram:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们消化前面的代码。这是一个相当复杂的逻辑，所以确保你学会了所有的东西；这些概念不仅适用于游戏创建，而且在技术面试中也经常被问到。问题在于如何通过创建逻辑来移动数据结构的值，而不是使用Python内置函数。我想以这种方式教给你，而不是使用任何内置方法，因为知道这个可能对编程的任何技术领域都有帮助。现在，让我们观察代码。它以创建一个`number_of_rows_deleted`变量开始，该变量表示已从网格中删除的行数。关于已删除行数的信息很重要，因为在删除这些行数后，我们需要将位于已删除行上方的行数向下移动相同的数量。例如，看看下面的图表：
- en: '![](Images/712a0c70-671e-482c-a693-9565bc90a21a.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/712a0c70-671e-482c-a693-9565bc90a21a.png)'
- en: Similarly, now that we know what to delete with the `if black_background_color
    not in eachRow` expression, we can determine whether or not each row of the grid
    has empty places or not. If there are empty places, this means that the rows are
    not occupied, and if yes, then a black background color, that is, (0, 0, 0), won't
    be within any row. If we didn't find a black background color, then we can be
    sure that the rows are occupied, and we can delete them by checking further conditions.
    In the highlighted part of the code, you can observe that we are taking only the
    j^([th]) element, which is only a column. This is because, while deleting row,
    the value of `I` remains the same, but the j^([th]) column value differs. Thus,
    we loop on an entire column within a single row and use the `del` command to delete
    the occupied position.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，现在我们知道了使用`if black_background_color not in eachRow`表达式要删除什么，我们可以确定网格的每一行是否有空位。如果有空位，这意味着行没有被占据，如果有，那么黑色背景颜色，即(0,
    0, 0)，不会出现在任何行中。如果我们没有找到黑色背景颜色，那么我们可以确定行被占据，我们可以通过进一步检查条件来删除它们。在代码的突出部分中，你可以看到我们只取第j个元素，这只是一列。这是因为在删除行时，`I`的值保持不变，但第j列的值不同。因此，我们在单行内循环整个列，并使用`del`命令删除被占据的位置。
- en: 'From the preceding line of code, we were able to delete entire rows if any
    rows were occupied, but we didn''t address what should happen after we delete
    it, and this is the tricky part. After we delete every occupied row, not only
    the blocks will be deleted—the entire grid containing rows will be deleted. Thus,
    in place of deleted block, we won''t have empty rows; instead, whole rows containing
    the grid will be deleted. Thus, to make sure that we do not decrease the count
    of the actual grid, we need to add another row from the top to compensate for
    it. Let''s write some code to implement this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一行代码中，我们能够删除整行，如果有任何行被占据，但我们没有解决删除后应该发生什么，这是棘手的部分。在我们删除每一行后，不仅会删除方块，整个包含行的网格也会被删除。因此，在删除的方块位置，我们不会有空行；相反，包含网格的整行将被删除。因此，为了确保我们不减少实际网格的数量，我们需要从顶部添加另一行来补偿。让我们编写一些代码来实现这一点：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Okay! Let''s digest it. This is quite complex but extremely powerful information.
    The preceding code will implement shifting the block of rows from the top, down
    into the grid. Firstly, the shift is required only if we have deleted any row;
    if yes, we enter into the logic to perform shifting. First of all, let''s only
    observe the code that involves the lambda function, that is, `list(occupied),
    position=lambda x: x[1]`. The code will create a list of all the positions of
    the grid and then use the lambda function to take the *y*-part of the position
    only. Remember, taking the *x* position of the block is superfluous—for each row,
    the value of *x* remains constant, but the *y* values differs. Thus, we will take
    the value of the *y*-position and then sort it with the `sorted(x)` function.
    The sorted function will sort the position based on the value of the *y*-coordinates.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '好了！让我们消化一下。这是相当复杂但非常强大的信息。前面的代码将实现将行块从顶部向下移入网格。首先，只有在我们删除了任何行时才需要移位；如果是，我们就进入逻辑来执行移位。首先，让我们只观察涉及lambda函数的代码，即`list(occupied),
    position=lambda x: x[1]`。该代码将创建一个包含网格所有位置的列表，然后使用lambda函数仅获取位置的*y*部分。请记住，获取方块的*x*位置是多余的——对于每一行，*x*的值保持不变，但*y*的值不同。因此，我们将获取*y*位置的值，然后使用`sorted(x)`函数对其进行排序。排序函数将根据*y*坐标的值对位置进行排序。'
- en: 'Firstly, the sorting will be done based on the lower value of *y* to the upper
    value of *y*. For example, look at the following diagram:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，排序将根据*y*的较小值到*y*的较大值进行。例如，看看下面的图表：
- en: '![](Images/f4cf74ea-2a52-4699-bc7a-b649e98cbffb.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f4cf74ea-2a52-4699-bc7a-b649e98cbffb.png)'
- en: Calling the sorted method and then reversing the list (refer to [Chapter 4](22e1090d-87f1-4dd8-9f82-ff25cd4862e2.xhtml), *Data
    Structures and Functions*, to learn more about how to reverse lists) is important
    because sometimes the bottom part of the grid won't be occupied, and only the
    upper layer will. In such cases, we don't want the shifting operation to cause
    any harm to the bottom rows, which are not occupied.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 调用sorted方法，然后反转列表（参见[第4章](22e1090d-87f1-4dd8-9f82-ff25cd4862e2.xhtml)，*数据结构和函数*，了解更多关于如何反转列表的信息）很重要，因为有时网格的底部部分可能没有被占据，只有上层会被占据。在这种情况下，我们不希望移位操作对未被占据的底部行造成任何伤害。
- en: Similarly, after taking track of the position of each row, we will check if
    there are any rows above the deleted row with the `if y < index_of_deleted_rows` expression.
    Again, in this case, the value of *x* is irrelevant because it will be the same
    within the single row; after we check if there is any row above the row that is
    deleted, we perform the shifting operation. The operation of shifting is quite
    simple; we will try to assign the new position for each of the rows that reside
    just above the deleted row. We can create a new position by increasing the value
    of *y* with the number of deleted rows. For instance, if there are two rows being
    deleted, we need to add two to the value of *y* so that the block just above the
    deleted rows, and the subsequent ones, will shift two rows down. After we shift
    the rows down into the grid, we have to pop the blocks out from the previous position.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在追踪每一行的位置后，我们将检查是否有任何删除行上方的行，使用`if y < index_of_deleted_rows`表达式。同样，在这种情况下，*x*的值是无关紧要的，因为它在单行内是相同的；在我们检查是否有任何删除行上方的行之后，我们执行移位操作。移位操作非常简单；我们将尝试为位于删除行正上方的每一行分配新位置。我们可以通过增加删除行的数量来创建新位置的值。例如，如果有两行被删除，我们需要将*y*的值增加两个，以便删除行上方的方块和随后的方块将向下移动两行。在我们将行向下移动到网格后，我们必须从先前的位置弹出方块。
- en: 'Now that we have defined a function that will clear the entire row if it is
    occupied, let''s call it from the main function to observe its effect:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了一个函数，如果整行被占据，它将清除整行，让我们从主函数中调用它来观察其效果：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, with this protracted and tedious day of coding, we have a very productive
    result. When you run your module where the main function is declared, you will
    see the following output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个漫长而乏味的编码日子里，我们取得了非常有成效的结果。当您运行声明了主函数的模块时，您将看到以下输出：
- en: '![](Images/529f38a4-88da-4c63-9baa-01e261a7d2de.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/529f38a4-88da-4c63-9baa-01e261a7d2de.png)'
- en: 'The game looks appealing, and I have tested everything in the code. The code
    looks thorough and exhaustive, with no loop holes. Similarly, you can play it
    and share it with your friends and uncover the possible modifications that can
    be done with this game. This is an advanced game and it adequately raises its
    bar, when it is coded with Python from scratch. We have learned so many things
    while building this game. We learned how to define the shapes format (we have
    done even more complicated stuff before, such as the transformation of sprites,
    and handling the collision of sprites), but this chapter was challenging on different
    aspects. For example, we had to take care of things such as invalid moves, possible
    collisions, shifting, and so on. We implemented some logic that determined if
    an object is placed in a certain position or not by comparing two distinct color
    objects: the **background color** of the grid or surface against the **game-object
    color**.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏看起来很吸引人，我已经在代码中测试了一切。代码看起来非常全面和详尽，没有漏洞。同样，您可以玩它并与朋友分享，并发现可以对这个游戏进行的可能修改。这是一个高级游戏，当用Python从头开始编码时，它充分提高了自己的水准。在构建这个游戏的过程中，我们学到了很多东西。我们学会了如何定义形状格式（我们以前做过更复杂的事情，比如精灵的转换和处理精灵的碰撞），但这一章在不同方面都具有挑战性。例如，我们必须注意诸如无效移动、可能的碰撞、移位等事项。我们实现了一些逻辑，通过比较两种不同的颜色对象：网格或表面的**背景颜色**与**游戏对象颜色**，来确定对象是否放置在某个位置。
- en: We are not done yet; we will try to implement some more logic in the next section.
    We will see what other modifications we can make to our game. We will try to build
    some logic that will increase the difficulty level of our game as we proceed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成；我们将在下一节尝试实现更多逻辑。我们将看看我们的游戏可以进行哪些其他修改。我们将尝试构建一些逻辑，随着游戏的进行，将增加游戏的难度级别。
- en: Game testing
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏测试
- en: 'Several modifications can be made to our game, but the most important ones
    will be to add a welcome screen, an increased difficulty level, and a score screen.
    Let''s start with the welcome screen, since it is easy to implement. We can use
    the `pygame` module to create a window, and a text surface to provide a message
    to the user. The following code shows how to create a main screen for our Tetris
    game:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏可以进行多种修改，但最重要的修改将是添加欢迎屏幕、增加难度级别和得分屏幕。让我们从欢迎屏幕开始，因为它很容易实现。我们可以使用`pygame`模块创建一个窗口，并使用文本表面向用户提供消息。以下代码显示了如何为我们的俄罗斯方块游戏创建一个主屏幕：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After you run the game, you will see the following output, in which the welcome
    screen will be rendered. After pressing any key, you will be redirected to the
    Tetris game:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏后，您将看到以下输出，其中将呈现欢迎屏幕。按下任意键后，您将被重定向到俄罗斯方块游戏：
- en: '![](Images/ff97e2d4-de62-4a0c-8075-dda1d8e9657b.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ff97e2d4-de62-4a0c-8075-dda1d8e9657b.png)'
- en: 'Similarly, let''s add some logic that will increase the difficulty of the game.
    There are two ways of implementing this logic. Firstly, you can create a timer,
    and if a player plays more than the range of the associated timer, we can decrease
    the fall speed so that shapes will fall faster than before (increase speed):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们添加一些逻辑，以增加游戏的难度。有两种实现这种逻辑的方法。首先，您可以创建一个计时器，如果玩家玩的时间超过关联计时器的范围，我们可以减慢下落速度，使形状比以前下落得更快（增加速度）：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Similarly, we can implement another piece of logic to increase the difficulty
    of the game. This method is better one than the preceding one. In this method,
    we will use *score* to increase the difficulty of the game. The following code
    represents a blueprint of how to implement the score of the player in order to
    increase the level of the game:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以实现另一段逻辑来增加游戏的难度。这种方法比之前的更好。在这种方法中，我们将使用*分数*来增加游戏的难度。以下代码表示了如何实现玩家的得分以增加游戏级别的蓝图：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, we implemented the relationship between the score and
    the speed of objects. Let's suppose a player's score is higher. This means that
    the user has been playing a less difficult level, and thus, such a high score
    value will be multiplied with the higher speed of fall value, resulting in an
    increase in `speedforFall`, which will be then subtracted from the speed of the
    objects, which will create a faster fall motion. In contrast, a player playing
    on a higher level will have a lower score, which will be multiplied with a lower
    value of the speed of objects, resulting in a lower number, which will be then
    subtracted from the `speedforFall` variable. This will result in less change in
    the speed for the player who is playing the harder level. But let's say a player
    is a pro and has scored higher in a harder level. In this case, the speed of the
    fall of an object is increased accordingly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们实现了分数和物体速度之间的关系。假设玩家的分数更高。这意味着用户一直在玩较低难度的级别，因此，这样一个高分值将与更高的下落速度值相乘，导致`speedforFall`的增加，然后从物体的速度中减去，这将创建一个更快的下落动作。相反，玩在更高级别的玩家将有一个较低的分数，这将与物体速度的较低值相乘，导致一个较低的数字，然后从`speedforFall`变量中减去。这将导致玩更难级别的玩家速度变化较小。但假设玩家是专业的，并且在更难的级别中得分更高。在这种情况下，物体的下落速度相应增加。
- en: We have finally completed a fully functional Tetris game. We have learned several
    advanced concepts of game programming using Python in this chapter. In the process
    of its creation, we revised a few of the concepts that we learned about previously
    while discovering the fundamental concepts of Python, such as manipulating multi-dimensional
    lists, list comprehensions, object-oriented paradigms, and mathematical transformations.
    Along with revising those concepts, we uncovered several novel concepts such as
    implementing rotations, implementing shifting operations, creating a shape format
    from scratch, creating a grid (virtual and physical) structure, and populating
    objects within the grids.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终完成了一个完全功能的俄罗斯方块游戏。在本章中，我们学习了使用Python进行游戏编程的几个高级概念。在创建过程中，我们复习了一些我们之前学到的关于Python的基本概念，比如操作多维列表，列表推导，面向对象的范式和数学变换。除了复习这些概念，我们还发现了一些新颖的概念，比如实现旋转，实现移位操作，从头开始创建形状格式，创建网格（虚拟和物理）结构，并在网格中放置物体。
- en: Summary
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have explored the *Pythonic* way of implementing multi-dimensional
    list processing. We have created a multi-dimensional list to store the format
    for different geometrical shapes, and manipulated it using mathematical transformations.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了实现多维列表处理的*Pythonic*方式。我们创建了一个多维列表来存储不同几何形状的格式，并使用数学变换对其进行操作。
- en: We have used the simple example of Tetris to demonstrate the usage of several
    data structures in the game, along with its manipulation. We have implemented
    a dictionary to store key as a position and value as the color code of those objects.
    Building such a dictionary is a life-saver for games such as Tetris. While making
    logic to check the collisions and shifting operations, we used the dictionary
    to observe whether the background color of any object is the same as the background
    of any position. Although Tetris is only one case study, the techniques that are
    used in this game are also used in many real-world games, including Minecraft,
    and in almost every RPG game.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了俄罗斯方块的简单示例来演示游戏中几种数据结构的使用，以及它们的操作。我们实现了一个字典，将键存储为位置，值存储为这些物体的颜色代码。构建这样一个字典对于俄罗斯方块等游戏来说是救命的。在制作检查碰撞和移位操作的逻辑时，我们使用字典来观察任何物体的背景颜色是否与任何位置的背景相同。尽管俄罗斯方块只是一个案例研究，但在这个游戏中使用的技术也被用于许多现实世界的游戏，包括Minecraft，几乎每个RPG游戏。
- en: The operations involving mathematical transformation were vital for us. We used
    rotational principles in this chapter in order to change the structure of the
    objects without changing their dimensions. The knowledge that you will have grasped
    from this chapter is enormous. Concepts such as the manipulation of a multi-dimensional
    list can be extended to data applications, and is termed as a 2D Numpy array,
    which is used in creating different analogies, such as street analogy, the multiple
    travelers problem, and so on. Although it is considered that the dictionary is
    the king of the data structures, processing a multi-dimensional list is not too
    far behind as it is combined with the simplicity of list comprehensions. Along
    with the implementation of such complex data structures, we learned how to implement
    mathematical transformations, that is, the rotational movement of game objects.
    This feature is extremely useful in any 3D game as it will provide the user with
    a 360-dimensional view of the scene. Similarly, we have learned how to create
    a grid structure.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 数学变换涉及的操作对我们非常重要。在本章中，我们使用了旋转原理来改变物体的结构而不改变其尺寸。从本章中您将掌握的知识是巨大的。诸如操作多维列表之类的概念可以扩展到数据应用程序，并被称为2D
    Numpy数组，用于创建不同的类比，比如街道类比，多旅行者问题等。尽管字典被认为是数据结构之王，但处理多维列表并不逊色，因为它与列表推导的简单性相结合。除了实现这些复杂的数据结构，我们还学会了如何实现数学变换，即游戏物体的旋转运动。这个特性在任何3D游戏中都非常有用，因为它将为用户提供对场景的360度视图。同样，我们还学会了如何创建网格结构。
- en: A grid structure is used to track the positions of the objects. In complex games
    such as WorldCraft, it is a mandatory task of any game developer to track the
    objects and resources for the game, and in such cases, the grid works perfectly.
    Invisible grids can be implemented as a dictionary, or as any complex collection.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 网格结构用于跟踪物体的位置。在像WorldCraft这样的复杂游戏中，跟踪游戏的物体和资源是任何游戏开发者的强制性任务，在这种情况下，网格非常有效。可以将不可见的网格实现为字典，或者作为任何复杂的集合。
- en: 'The main goal of this chapter was to familiarize you with 2D game graphics,
    that is, drawing primitives and game grids. Similarly, you learned about another
    way of detecting collisions between game objects (in the Flappy Bird game, we
    used the pygame masking technique to detect collisions). In this chapter, we implemented
    a universal and traditional way of implementing collision checks: by checking
    the background color attributes with the object color attributes. Similarly, we
    learned how to create different objects (that differed in structure) by using
    rotations. This technique can be used to spawn multiple enemies into games. Instead
    of designing multiple different objects for each character (which can be time-consuming
    and costly), we used transformations to change the structures of objects.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是让您熟悉2D游戏图形，即绘制基本图形和游戏网格。同样，您还了解了另一种检测游戏对象之间碰撞的方法（在Flappy Bird游戏中，我们使用了pygame掩模技术来检测碰撞）。在本章中，我们实现了一种通用和传统的碰撞检测方法：通过检查背景颜色属性和对象颜色属性。同样，我们学会了如何通过旋转来创建不同结构的对象。这种技术可以用来在游戏中生成多个敌人。我们没有为每个角色设计多个不同的对象（这可能耗时且昂贵），而是使用变换来改变对象的结构。
- en: The next chapter is about Python OpenGL, which is often termed PyOpenGL. We
    will see how we can create different geometrical structures using openGL, and
    observe how to use PyOpenGL and pygame together. We will primarily focus on different
    mathematical paradigms. We will see how attributes such as vertices and edges
    are used to create different complex mathematical shapes. Furthermore, we will
    see how we can implement ZOOM IN and ZOOM OUT features in the game using PyOpenGL.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是关于Python OpenGL，通常称为PyOpenGL。我们将看到如何使用OpenGL创建不同的几何结构，并观察如何将PyOpenGL和pygame一起使用。我们将主要关注不同的数学范式。我们将看到顶点和边等属性如何用于创建不同的复杂数学形状。此外，我们将看到如何使用PyOpenGL实现游戏中的放大和缩小功能。
