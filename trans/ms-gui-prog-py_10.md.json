["```py\nclass ChatWindow(qtw.QWidget):\n\n    submitted = qtc.pyqtSignal(str)\n\n    def __init__(self):\n        super().__init__()\n\n        self.setLayout(qtw.QGridLayout())\n        self.message_view = qtw.QTextEdit(readOnly=True)\n        self.layout().addWidget(self.message_view, 1, 1, 1, 2)\n        self.message_entry = qtw.QLineEdit()\n        self.layout().addWidget(self.message_entry, 2, 1)\n        self.send_btn = qtw.QPushButton('Send', clicked=self.send)\n        self.layout().addWidget(self.send_btn, 2, 2)\n```", "```py\n    def write_message(self, username, message):\n        self.message_view.append(f'<b>{username}: </b> {message}<br>')\n\n    def send(self):\n        message = self.message_entry.text().strip()\n        if message:\n            self.submitted.emit(message)\n            self.message_entry.clear()\n```", "```py\n        self.cw = ChatWindow()\n        self.setCentralWidget(self.cw)\n```", "```py\nfrom PyQt5 import QtNetwork as qtn\n```", "```py\nclass UdpChatInterface(qtc.QObject):\n\n    port = 7777\n    delimiter = '||'\n    received = qtc.pyqtSignal(str, str)\n    error = qtc.pyqtSignal(str)\n```", "```py\n    def __init__(self, username):\n        super().__init__()\n        self.username = username\n\n        self.socket = qtn.QUdpSocket()\n        self.socket.bind(qtn.QHostAddress.Any, self.port)\n```", "```py\n        self.socket.readyRead.connect(self.process_datagrams)\n        self.socket.error.connect(self.on_error)\n```", "```py\n    def on_error(self, socket_error):\n        error_index = (qtn.QAbstractSocket\n                       .staticMetaObject\n                       .indexOfEnumerator('SocketError'))\n        error = (qtn.QAbstractSocket\n                 .staticMetaObject\n                 .enumerator(error_index)\n                 .valueToKey(socket_error))\n        message = f\"There was a network error: {error}\"\n        self.error.emit(message)\n```", "```py\n    def process_datagrams(self):\n        while self.socket.hasPendingDatagrams():\n            datagram = self.socket.receiveDatagram()\n            raw_message = bytes(datagram.data()).decode('utf-8')\n```", "```py\n            if self.delimiter not in raw_message:\n                continue\n            username, message = raw_message.split(self.delimiter, 1)\n            self.received.emit(username, message)\n```", "```py\n   def send_message(self, message):\n        msg_bytes = (\n            f'{self.username}{self.delimiter}{message}'\n        ).encode('utf-8')\n        self.socket.writeDatagram(\n            qtc.QByteArray(msg_bytes),\n            qtn.QHostAddress.Broadcast,\n            self.port\n        )\n```", "```py\n        username = qtc.QDir.home().dirName()\n        self.interface = UdpChatInterface(username)\n        self.cw.submitted.connect(self.interface.send_message)\n        self.interface.received.connect(self.cw.write_message)\n        self.interface.error.connect(\n            lambda x: qtw.QMessageBox.critical(None, 'Error', x))\n```", "```py\nclass TcpChatInterface(qtc.QObject):\n\n    port = 7777\n    delimiter = '||'\n    received = qtc.pyqtSignal(str, str)\n    error = qtc.pyqtSignal(str)\n```", "```py\n    def __init__(self, username, recipient):\n        super().__init__()\n        self.username = username\n        self.recipient = recipient\n```", "```py\n        self.listener = qtn.QTcpServer()\n        self.listener.listen(qtn.QHostAddress.Any, self.port)\n        self.listener.acceptError.connect(self.on_error)\n\n        self.listener.newConnection.connect(self.on_connection)\n        self.connections = []\n```", "```py\n    def on_connection(self):\n        connection = self.listener.nextPendingConnection()\n        connection.readyRead.connect(self.process_datastream)\n        self.connections.append(connection)\n```", "```py\n    def process_datastream(self):\n        for socket in self.connections:\n            self.datastream = qtc.QDataStream(socket)\n            if not socket.bytesAvailable():\n                continue\n```", "```py\n            raw_message = self.datastream.readQString()\n            if raw_message and self.delimiter in raw_message:\n                username, message = raw_message.split(self.delimiter, 1)\n                self.received.emit(username, message)\n```", "```py\n        self.client_socket = qtn.QTcpSocket()\n        self.client_socket.error.connect(self.on_error)\n```", "```py\n    def send_message(self, message):\n        raw_message = f'{self.username}{self.delimiter}{message}'\n```", "```py\n    socket_state = self.client_socket.state()\n    if socket_state != qtn.QAbstractSocket.ConnectedState:\n        self.client_socket.connectToHost(\n            self.recipient, self.port)\n```", "```py\n        self.datastream = qtc.QDataStream(self.client_socket)\n```", "```py\n        self.datastream.writeQString(raw_message)\n```", "```py\n        self.datastream.writeUInt32(len(raw_message))\n        self.datastream.writeQString(raw_message)\n```", "```py\n    def process_datastream(self):\n        #...\n        message_length = self.datastream.readUInt32()\n        raw_message = self.datastream.readQString()\n```", "```py\n        self.received.emit(self.username, message)\n```", "```py\n        recipient, _ = qtw.QInputDialog.getText(\n            None, 'Recipient',\n            'Specify of the IP or hostname of the remote host.')\n        if not recipient:\n            sys.exit()\n\n        self.interface = TcpChatInterface(username, recipient)\n        self.cw.submitted.connect(self.interface.send_message)\n        self.interface.received.connect(self.cw.write_message)\n        self.interface.error.connect(\n            lambda x: qtw.QMessageBox.critical(None, 'Error', x))\n```", "```py\nimport sys\nfrom os import path\nfrom PyQt5 import QtNetwork as qtn\nfrom PyQt5 import QtCore as qtc\n```", "```py\nclass Downloader(qtc.QObject):\n\n    def __init__(self, url):\n        super().__init__()\n        self.manager = qtn.QNetworkAccessManager(\n            finished=self.on_finished)\n        self.request = qtn.QNetworkRequest(qtc.QUrl(url))\n        self.manager.get(self.request)\n```", "```py\n    def on_finished(self, reply):\n        filename = reply.url().fileName() or 'download'\n        if path.exists(filename):\n            print('File already exists, not overwriting.')\n            sys.exit(1)\n        with open(filename, 'wb') as fh:\n            fh.write(reply.readAll())\n        print(f\"{filename} written\")\n        sys.exit(0)\n```", "```py\nif __name__ == '__main__':\n    if len(sys.argv) < 2:\n        print(f'Usage: {sys.argv[0]} <download url>')\n        sys.exit(1)\n    app = qtc.QCoreApplication(sys.argv)\n    d = Downloader(sys.argv[1])\n    sys.exit(app.exec_())\n```", "```py\n        widget = qtw.QWidget(minimumWidth=600)\n        self.setCentralWidget(widget)\n        widget.setLayout(qtw.QVBoxLayout())\n        self.url = qtw.QLineEdit()\n        self.table = qtw.QTableWidget(columnCount=2, rowCount=5)\n        self.table.horizontalHeader().setSectionResizeMode(\n            qtw.QHeaderView.Stretch)\n        self.table.setHorizontalHeaderLabels(['key', 'value'])\n        self.fname = qtw.QPushButton(\n            '(No File)', clicked=self.on_file_btn)\n        submit = qtw.QPushButton('Submit Post', clicked=self.submit)\n        response = qtw.QTextEdit(readOnly=True)\n        for w in (self.url, self.table, self.fname, submit, response):\n            widget.layout().addWidget(w)\n```", "```py\n    def on_file_btn(self):\n        filename, accepted = qtw.QFileDialog.getOpenFileName()\n        if accepted:\n            self.fname.setText(filename)\n```", "```py\nclass Poster(qtc.QObject):\n\n    replyReceived = qtc.pyqtSignal(str)\n```", "```py\n    def __init__(self):\n        super().__init__()\n        self.nam = qtn.QNetworkAccessManager()\n        self.nam.finished.connect(self.on_reply)\n```", "```py\n    def on_reply(self, reply):\n        reply_bytes = reply.readAll()\n        reply_string = bytes(reply_bytes).decode('utf-8')\n        self.replyReceived.emit(reply_string)\n```", "```py\n    def make_request(self, url, data, filename):\n        self.request = qtn.QNetworkRequest(url)\n```", "```py\n        self.multipart = qtn.QHttpMultiPart(\n            qtn.QHttpMultiPart.FormDataType)\n```", "```py\n        for key, value in (data or {}).items():\n            http_part = qtn.QHttpPart()\n            http_part.setHeader(\n                qtn.QNetworkRequest.ContentDispositionHeader,\n                f'form-data; name=\"{key}\"'\n            )\n            http_part.setBody(value.encode('utf-8'))\n            self.multipart.append(http_part)\n```", "```py\n        if filename:\n            file_part = qtn.QHttpPart()\n            file_part.setHeader(\n                qtn.QNetworkRequest.ContentDispositionHeader,\n                f'form-data; name=\"attachment\"; filename=\"{filename}\"'\n            )\n            filedata = open(filename, 'rb').read()\n            file_part.setBody(filedata)\n            self.multipart.append(file_part)\n```", "```py\n        self.nam.post(self.request, self.multipart)\n```", "```py\n        self.poster = Poster()\n        self.poster.replyReceived.connect(self.response.setText)\n```", "```py\n    def submit(self):\n        url = qtc.QUrl(self.url.text())\n        filename = self.fname.text()\n        if filename == '(No File)':\n            filename = None\n        data = {}\n        for rownum in range(self.table.rowCount()):\n            key_item = self.table.item(rownum, 0)\n            key = key_item.text() if key_item else None\n            if key:\n                data[key] = self.table.item(rownum, 1).text()\n        self.poster.make_request(url, data, filename)\n```", "```py\n       def on_ready_read(self):\n           while self.socket.hasPendingDatagrams():\n               self.process_data(self.socket.readDatagram())\n```", "```py\n       def download(self, url):\n        self.manager = qtn.QNetworkAccessManager(\n            finished=self.on_finished)\n        self.request = qtn.QNetworkRequest(qtc.QUrl(url))\n        reply = self.manager.get(self.request)\n        with open('datafile.dat', 'wb') as fh:\n            fh.write(reply.readAll())\n```"]