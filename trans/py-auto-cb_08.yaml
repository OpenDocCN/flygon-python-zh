- en: Dealing with Communication Channels
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理通信渠道
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Working with email templates
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用电子邮件模板
- en: Sending an individual email
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送单个电子邮件
- en: Reading an email
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读电子邮件
- en: Adding subscribers to an email newsletter
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将订阅者添加到电子邮件通讯中
- en: Sending notifications via email
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过电子邮件发送通知
- en: Producing SMS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成短信
- en: Receiving SMS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收短信
- en: Creating a Telegram bot
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Telegram机器人
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Dealing with communication channels is where automating things can produce big
    gains. In this recipe, we'll see how to work with two of the most common communication
    channels—emails, including newsletters, as well as sending and receiving text
    messages by phone.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 处理通信渠道是自动化事务可以产生巨大收益的地方。在本配方中，我们将看到如何处理两种最常见的通信渠道——电子邮件，包括新闻通讯，以及通过电话发送和接收短信。
- en: During the years, there has been a fair amount of abuse in methods of delivery,
    like spam or unsolicited marketing messages, making necessary to partner with
    external tools to avoid messages to be automatically rejected by automated filters.
    We will present the proper caveats where applicable. All the tools presented have
    excellent documentation, so do not be afraid to read it. They also have a lot
    of features, and they may be able to do something that is exactly what you're
    looking for.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，交付方法中存在相当多的滥用，如垃圾邮件或未经请求的营销信息，这使得与外部工具合作以避免消息被自动过滤器自动拒绝成为必要。我们将在适用的情况下提出适当的注意事项。所有工具都有很好的文档，所以不要害怕阅读它。它们还有很多功能，它们可能能够做一些正是你所寻找的东西。
- en: Working with email templates
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用电子邮件模板
- en: To send an email, we first need to generate its content. In this recipe, we'll
    see how to generate a proper template, in both text-only style and HTML.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送电子邮件，我们首先需要生成其内容。在本配方中，我们将看到如何生成适当的模板，既以纯文本样式又以HTML样式。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We should start by installing the `mistune` module, which will compile Markdown
    documents into HTML. We will also use the `jinja2` module to combine HTML with
    our text:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该首先安装`mistune`模块，它将Markdown文档编译为HTML。我们还将使用`jinja2`模块将HTML与我们的文本组合在一起。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the GitHub repo, there are a couple of templates we will use—`email_template.md`
    in [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/email_template.md](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/email_template.md)
    and a template for styling, `email_styling.html`, in [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/email_styling.html](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/email_styling.html).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub存储库中，有一些我们将使用的模板——`email_template.md`在[https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/email_template.md](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/email_template.md)和一个用于样式的模板，`email_styling.html`在[https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/email_styling.html](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/email_styling.html)。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import the modules:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入模块：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Read both templates from disk:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从磁盘读取两个模板：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Define the `data` to include in the template. The template is quite simple
    and accepts only a single parameter:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义要包含在模板中的`data`。模板非常简单，只接受一个参数：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Render the Markdown template. This produces the text-only version of the `data`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 呈现Markdown模板。这会产生`data`的纯文本版本：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Render the Markdown and add the styling:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 呈现Markdown并添加样式：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Save the text and the HTML version to disk to check them:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本和HTML版本保存到磁盘以进行检查：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Check the text version:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查文本版本：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Check the HTML version in a browser:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中检查HTML版本：
- en: '![](assets/cc6cc1e0-aeaf-4e3a-911b-dacf333609ee.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cc6cc1e0-aeaf-4e3a-911b-dacf333609ee.png)'
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Step 1 gets the modules that will be used later, and step 2 reads the two templates
    that will be rendered. `email_template.md` is the basis of the content, and it's
    a Markdown template. `email_styling.html` is an HTML template that contains the
    basic HTML surrounding and CSS styling information.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第1步获取稍后将使用的模块，第2步读取将呈现的两个模板。`email_template.md`是内容的基础，它是一个Markdown模板。`email_styling.html`是一个包含基本HTML环绕和CSS样式信息的HTML模板。
- en: The basic structure is to create the content in Markdown format. This is a plain-text
    file that's readable and can be send as part of the email. That content can then
    be converted into HTML and surrounded with some styling to create an HTML function. `email_styling.html`
    has a content area to put the rendered HTML from Markdown.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 基本结构是以Markdown格式创建内容。这是一个可读的纯文本文件，可以作为电子邮件的一部分发送。然后可以将该内容转换为HTML，并添加一些样式来创建HTML函数。`email_styling.html`有一个内容区域，用于放置从Markdown呈现的HTML。
- en: Step 3 defines the data that will render in `email_template.md`. It is a very
    simple template that only requires a parameter called `name`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步定义了将在`email_template.md`中呈现的数据。这是一个非常简单的模板，只需要一个名为`name`的参数。
- en: In step 4, the Markdown template gets rendered with the `data`. This produces
    the plain-text version of the email.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步，Markdown模板与`data`一起呈现。这会产生电子邮件的纯文本版本。
- en: The `HTML` version is rendered in step 5\. The plain-text version is rendered
    to `HTML` using `mistune`, and then it is wrapped in `email_styling.html` using
    a `jinja2` template. The final version is a self-contained HTML document.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第5步呈现了`HTML`版本。使用`mistune`将纯文本版本呈现为`HTML`，然后使用`jinja2`模板将其包装在`email_styling.html`中。最终版本是一个独立的HTML文档。
- en: Finally, we save both versions, plain-text (as `text`) and HTML (as `html`),
    to a file in step 6\. Steps 7 and 8 check the stored values. The information is
    the same, but in the `HTML` version, it is styled.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将两个版本，纯文本（作为`text`）和HTML（作为`html`），保存到文件中的第6步。第7步和第8步检查存储的值。信息是相同的，但在`HTML`版本中，它是有样式的。
- en: There's more...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Using Markdown makes dual emails with text and HTML easy to generate. Markdown
    is quite readable in text format, and renders very naturally into HTML. That said,
    it is possible to generate a totally different HTML version, which will allow
    for more customization and taking advantage of HTML's features.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Markdown可以轻松生成包含文本和HTML的双重电子邮件。Markdown在文本格式中非常易读，并且可以自然地呈现为HTML。也就是说，可以生成完全不同的HTML版本，这将允许更多的自定义和利用HTML的特性。
- en: The full Markdown syntax can be found at [https://daringfireball.net/projects/markdown/syntax](https://daringfireball.net/projects/markdown/syntax) and
    a good cheat sheet with the most commonly used elements is at [https://beegit.com/markdown-cheat-sheet](https://beegit.com/markdown-cheat-sheet).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的Markdown语法可以在[https://daringfireball.net/projects/markdown/syntax](https://daringfireball.net/projects/markdown/syntax)找到，最常用元素的好的速查表在[https://beegit.com/markdown-cheat-sheet](https://beegit.com/markdown-cheat-sheet)。
- en: While making a plain-text-only version of an email is not strictly necessary,
    it is a good practice and shows you care about who reads the email. Most email
    clients accept HTML, but it's not totally universal.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然制作电子邮件的纯文本版本并不是绝对必要的，但这是一个很好的做法，表明您关心谁阅读了电子邮件。大多数电子邮件客户端接受HTML，但并非完全通用。
- en: For an HTML email, note that the whole style should be contained in the email.
    That means that the CSS needs to be embedded into the `HTML`. Avoid making external
    calls that could lead the email to not render properly in some email clients,
    or even be qualified as spam.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于HTML电子邮件，请注意整个样式应该包含在电子邮件中。这意味着CSS需要嵌入到HTML中。避免进行可能导致电子邮件在某些电子邮件客户端中无法正确呈现，甚至被视为垃圾邮件的外部调用。
- en: The styling in `email_styling.html` is based on the modest style that can be
    found here: [http://markdowncss.github.io/](http://markdowncss.github.io/). There
    are more CSS styles that can be used, and a search in Google should find more.
    Remember to remove any external references, as discussed before.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`email_styling.html`中的样式基于可以在[http://markdowncss.github.io/](http://markdowncss.github.io/)找到的`modest`样式。还有更多可以使用的CSS样式，可以在Google中搜索找到更多。请记住删除任何外部引用，如前面所讨论的。'
- en: 'Images can be included in HTML by encoding the image in `base64` format so
    it can be embedded directly in the HTML `img` tag, instead of adding a reference:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以`base64`格式对图像进行编码，以便直接嵌入HTML`img`标签中，而不是添加引用，将图像包含在HTML中。
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can find more information about this technique in this article: [https://css-tricks.com/data-uris/](https://css-tricks.com/data-uris/).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://css-tricks.com/data-uris/](https://css-tricks.com/data-uris/)的文章中找到有关此技术的更多信息。
- en: The `mistune` full docs are available at [http://mistune.readthedocs.io/en/latest/](http://mistune.readthedocs.io/en/latest/) and
    the `jinja2` documentation at [http://jinja.pocoo.org/docs/2.10/](http://jinja.pocoo.org/docs/2.10/).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`mistune`完整文档可在[http://mistune.readthedocs.io/en/latest/](http://mistune.readthedocs.io/en/latest/)找到，`jinja2`文档可在[http://jinja.pocoo.org/docs/2.10/](http://jinja.pocoo.org/docs/2.10/)找到。'
- en: See also
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Formatting text in Markdown* recipe in [Chapter 5](d628b5e8-8d78-4884-905c-18b393bfcb47.xhtml),
    *Generating Fantastic Reports*
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](d628b5e8-8d78-4884-905c-18b393bfcb47.xhtml)中的*在Markdown中格式化文本*食谱，*生成精彩的报告*'
- en: The *Using templates for reports recipe* in [Chapter 5](d628b5e8-8d78-4884-905c-18b393bfcb47.xhtml),
    *Generating Fantastic Reports *
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](d628b5e8-8d78-4884-905c-18b393bfcb47.xhtml)中的*使用模板生成报告食谱*，*生成精彩的报告*'
- en: The *Sending transactional emails* recipe in [Chapter 5](d628b5e8-8d78-4884-905c-18b393bfcb47.xhtml),
    *Generating Fantastic Reports *
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第5章](d628b5e8-8d78-4884-905c-18b393bfcb47.xhtml)中的*发送事务性电子邮件*食谱，*生成精彩的报告*'
- en: Sending an individual email
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送单个电子邮件
- en: The most basic way of sending an email is to send an individual one from an
    email account. This option is only recommended for very sporadic use, but for
    simple purposes such as sending a couple of emails a day to controlled addresses,
    it can be good enough.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 发送电子邮件的最基本方法是从电子邮件帐户发送单个电子邮件。这个选项只建议用于非常零星的使用，但对于简单的目的，比如每天向受控地址发送几封电子邮件，这可能足够了。
- en: Do not use this method to send emails in bulk to distribution lists or to customers
    with unknown email addresses. You risk being banned from your service provider
    due to anti-spam rules. See other recipes in this chapter for more options.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用此方法向分发列表或具有未知电子邮件地址的客户批量发送电子邮件。您可能因反垃圾邮件规则而被服务提供商禁止。有关更多选项，请参阅本章中的其他食谱。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll need an email account with a service provider. There
    are small differences based on the provider to use, but we'll use a Gmail account,
    as it is very common and free to access.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将需要一个带有服务提供商的电子邮件帐户。根据要使用的提供商有一些小的差异，但我们将使用Gmail帐户，因为它非常常见且免费访问。
- en: Due to Gmail's security, we'll need to create a specific app password that can
    be used to send an email. Follow the instructions here: [https://support.google.com/accounts/answer/185833](https://support.google.com/accounts/answer/185833).
    This will help to generate a password for the purpose of this recipe. Remember
    to create it for mail access. You can delete the password afterwards to remove
    it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Gmail的安全性，我们需要创建一个特定的应用程序密码，用于发送电子邮件。请按照这里的说明操作：[https://support.google.com/accounts/answer/185833](https://support.google.com/accounts/answer/185833)。这将有助于为此示例生成一个密码。记得为邮件访问创建它。您可以随后删除密码以将其删除。
- en: We'll use the `smtplib` module, which is part of Python's standard library.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python标准库中的`smtplib`模块。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import the `smtplib` and `email` modules:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`smtplib`和`email`模块：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Set up the credentials, replacing these with your own ones. For testing purposes,
    we''ll send to the same email, but feel free to use a different address:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置凭据，用您自己的凭据替换这些。出于测试目的，我们将发送到相同的电子邮件，但请随意使用不同的地址：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define the data to be sent. Notice the two alternatives, a plain-text one and
    an HTML one:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义要发送的数据。注意两种选择，纯文本和HTML：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Compose the message as a `MIME` multipart, including `subject`, `to`, and `from`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将消息组成为`MIME`多部分，包括`主题`，`收件人`和`发件人`：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Fill the data content parts of the email:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写电子邮件的数据内容部分：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Send the email, using the `SMTP SSL` protocol:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SMTP SSL`协议发送电子邮件：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The email is sent. Check your email account for the message. Checking the *original
    email*, you can see the full raw email, with elements in both HTML and plain-text.
    The email is presented redacted:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 邮件已发送。检查您的电子邮件帐户是否收到了消息。检查*原始电子邮件*，您可以看到完整的原始电子邮件，其中包含HTML和纯文本元素。电子邮件已被编辑：
- en: '![](assets/eedfbdbd-64da-4f0e-abd9-7fa23bbaf20d.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/eedfbdbd-64da-4f0e-abd9-7fa23bbaf20d.png)'
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: After step 1, making the pertinent imports from `stmplib` and `email`, step
    2 defines the credentials obtained from Gmail.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步之后，从`stmplib`和`email`进行相关导入，第2步定义了从Gmail获取的凭据。
- en: Step 3 shows the HTML and text that is going to be sent. They are alternatives,
    so they should present the same information, but in different formats.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步显示了将要发送的HTML和文本。它们是替代方案，因此它们应该呈现相同的信息，但以不同的格式呈现。
- en: The basic message information is set up in step 4\. It specifies the subject
    of the email, as well as the *from* and *to*. Step 5 adds multiple parts, each
    with the proper `MIMEText` type.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的消息信息在第4步中设置。它指定了电子邮件的主题，以及*from*和*to*。第5步添加了多个部分，每个部分都有适当的`MIMEText`类型。
- en: The last part added is the preferred alternative, according to the `MIME` format,
    so we add the `HTML` part last.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后添加的部分是首选的替代方案，根据`MIME`格式，因此我们最后添加了`HTML`部分。
- en: Step 6 sets up the connection with the server, logs in using the credentials,
    and sends the message. It uses a `with` context to get the connection.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第6步建立与服务器的连接，使用凭据登录并发送消息。它使用`with`上下文来获取连接。
- en: If there's an error with the credentials, it will raise an exception with username
    and password not accepted.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果凭据出现错误，它将引发一个异常，显示用户名和密码不被接受。
- en: There's more...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Note that `sent_to` is a list of addresses. You can send an email to more than
    one address. The only caveat is in step 4, where it needs to be specified as a
    list of comma-separated value for all addresses.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`sent_to`是一个地址列表。您可以将电子邮件发送给多个地址。唯一的注意事项在第4步，需要将其指定为所有地址的逗号分隔值列表。
- en: Although it is possible to label `sent_from` as a different address than that
    used to send the email, it is not recommended. That can be interpreted as an indication
    of trying to fake the origin of the email, and provoke detection as a spam source.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以将`sent_from`标记为与发送电子邮件时使用的地址不同，但并不建议这样做。这可能被解释为试图伪造电子邮件的来源，并引发检测为垃圾邮件来源的迹象。
- en: 'The server used here, `smtp.gmail.com`*, *is the one specified by Gmail, and
    the defined port for `SMTPS` (secure `SMTP`) is `465`. Gmail also accepts port `587`,
    which is the standard, but requires you to specify the kind of session by calling `.starttls`,
    as shown in the next code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此处使用的服务器`smtp.gmail.com`*是Gmail指定的服务器，并且`SMTPS`（安全`SMTP`）的定义端口为`465`。Gmail还接受端口`587`，这是标准端口，但需要您通过调用`.starttls`指定会话的类型，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you are interested in more details about these differences and both protocols,
    you can find more information in this article: [https://www.fastmail.com/help/technical/ssltlsstarttls.html](https://www.fastmail.com/help/technical/ssltlsstarttls.html).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对这些差异和两种协议的更多细节感兴趣，可以在这篇文章中找到更多信息：[https://www.fastmail.com/help/technical/ssltlsstarttls.html](https://www.fastmail.com/help/technical/ssltlsstarttls.html)。
- en: The full `smtplib` documentation can be found at [https://docs.python.org/3/library/smtplib.html](https://docs.python.org/3/library/smtplib.html),
    and the `email` module, with info on the different formats for emails, including
    examples on `MIME` types, can be found here: [https://docs.python.org/3/library/email.html](https://docs.python.org/3/library/email.html).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`smtplib`文档可以在[https://docs.python.org/3/library/smtplib.html](https://docs.python.org/3/library/smtplib.html)找到，`email`模块中包含有关电子邮件不同格式的信息，包括`MIME`类型的示例，可以在这里找到：[https://docs.python.org/3/library/email.html](https://docs.python.org/3/library/email.html)。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Working with email templates* recipe
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用电子邮件模板*示例'
- en: The *Sending an individual email* recipe
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发送单个电子邮件*示例'
- en: Reading an email
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读电子邮件
- en: In this recipe, we'll see how to read emails from an account. We'll use the
    `IMAP4` standard, which is the most commonly used standard for reading email.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将看到如何从帐户中读取电子邮件。我们将使用`IMAP4`标准，这是最常用的用于阅读电子邮件的标准。
- en: Once read, the email can be processed and analyzed automatically to generate
    actions such as smart automated responses, forwarding the email to a different
    target, aggregating the results for monitoring, and so on. The options are unlimited!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦读取，电子邮件可以被自动处理和分析，以生成智能自动响应、将电子邮件转发到不同的目标、聚合结果进行监控等操作。选项是无限的！
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: For this recipe, we'll need an email account with a service provider. There
    are small differences based on the provider to use, but we'll use a Gmail account,
    as it is very common and free to access.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，我们将需要一个带有服务提供商的电子邮件帐户。基于要使用的提供商的小差异，但我们将使用Gmail帐户，因为它非常常见且免费访问。
- en: Due to Gmail's security, we'll need to create a specific app password to use
    to send an email. Follow the instructions here: [https://support.google.com/accounts/answer/185833](https://support.google.com/accounts/answer/185833).
    This will generate a password for the purpose of this recipe. Remember to create
    it for mail. You can delete the password afterwards to remove it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Gmail的安全性，我们需要创建一个特定的应用程序密码来发送电子邮件。请按照这里的说明操作：[https://support.google.com/accounts/answer/185833](https://support.google.com/accounts/answer/185833)。这将为此示例生成一个密码。记得为邮件创建它。您可以在之后删除密码以将其删除。
- en: We'll use the `imaplib` module, which is part of Python's standard library.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python标准库中的`imaplib`模块。
- en: The recipe will read the last received email, so you can use it for better control
    over what's going to be read. We'll send a short email that looks like it was
    sent to support.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例将读取最后收到的电子邮件，因此您可以使用它更好地控制将要读取的内容。我们将发送一封看起来像是发送给支持的简短电子邮件。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import the `imaplib` and `email` modules:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`imaplib`和`email`模块：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Set up the credentials, replacing these with your own ones:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置凭据，用您自己的凭据替换这些：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Connect to the email server:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到电子邮件服务器：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Select the inbox folder:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择收件箱文件夹：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Read all email UIDs and retrieve the latest received email:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取所有电子邮件UID并检索最新收到的电子邮件：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Parse the email into a Python object:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电子邮件解析为Python对象：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Display the subject and sender of the email:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示电子邮件的主题和发件人：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Retrieve the payload of the text:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索文本的有效载荷：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: After importing the modules that will be used and defining the credentials,
    we connect to the server in step 3.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 导入将要使用的模块并定义凭据后，我们在第3步连接到服务器。
- en: Step 4 connects to the `inbox`. This is a default folder in Gmail that contains
    the received email.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步连接到`inbox`。这是Gmail中包含收件箱的默认文件夹，其中包含收到的电子邮件。
- en: Of course, you may need to read a different folder. You can get a list of all
    folders by calling `mail.list()`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可能需要阅读不同的文件夹。您可以通过调用`mail.list()`来获取所有文件夹的列表。
- en: In step 5, first a list of UIDs is retrieved for all the emails in the inbox
    by calling `.uid('search', None, "ALL")`. The last email received is then retrieved
    again from the server through a `fetch` action with `.uid('fetch', latest_email_uid,
    '(RFC822)')`. This retrieves the email in RFC822 format, which is the standard.
    Note that retrieving the email marks it as read.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步，首先通过调用`.uid('search', None, "ALL")`检索收件箱中所有电子邮件的UID列表。然后通过`fetch`操作和`.uid('fetch',
    latest_email_uid, '(RFC822)')`再次从服务器检索最新收到的电子邮件。这将以RFC822格式检索电子邮件，这是标准格式。请注意，检索电子邮件会将其标记为已读。
- en: The `.uid` command allows us to call IMAP4 commands, returning a tuple with
    the result (`OK` or `NO`) and the data. If there's an error, it will raise the
    proper exception.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`.uid`命令允许我们调用IMAP4命令，返回一个带有结果（`OK`或`NO`）和数据的元组。如果出现错误，它将引发适当的异常。'
- en: The `BytesParser` module is used to transform from the raw `RFC822` email into
    a Python object. This is done in Step 6.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`BytesParser`模块用于将原始的`RFC822`电子邮件转换为Python对象。这是在第6步完成的。'
- en: The metadata, including details such as the subject, the sender, and the timestamp,
    can be accessed like a dictionary, as shown in step 7\. The addresses can be parsed
    from raw text format to separate the part with `email.utils.parseaddr`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据，包括主题、发件人和时间戳等详细信息，可以像字典一样访问，如第7步所示。地址可以从原始文本格式解析为带有`email.utils.parseaddr`的部分。
- en: Finally, the content can be unfolded and extracted. If the type of the email
    is multipart, each of the parts can be extracted by iterating through `.get_payload()`.
    The one that's easier to deal with is `plain/text`, so assuming it is present,
    the code in step 8 will extract it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，内容可以展开和提取。如果电子邮件的类型是多部分的，可以通过迭代`.get_payload()`来提取每个部分。最容易处理的是`plain/text`，因此假设它存在，第8步中的代码将提取它。
- en: The email body is stored in the `payload` variable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件正文存储在`payload`变量中。
- en: There's more...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In step 5, we are retrieving all the emails in the inbox, but that''s not necessary.
    The search can be filtered, for example by retrieving only the last day''s emails:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步，我们正在检索收件箱中的所有电子邮件，但这并非必要。搜索可以进行过滤，例如只检索最近一天的电子邮件：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will search according to the date of the email. Notice the resolution is
    in days.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据电子邮件的日期进行搜索。请注意，分辨率以天为单位。
- en: There are more actions that can be done through `IMAP4`. Check RFC 3501  [https://tools.ietf.org/html/rfc3501](https://tools.ietf.org/html/rfc3501) and
    RFC 6851 [https://tools.ietf.org/html/rfc6851](https://tools.ietf.org/html/rfc6851) for
    further details.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多可以通过`IMAP4`完成的操作。查看RFC 3501  [https://tools.ietf.org/html/rfc3501](https://tools.ietf.org/html/rfc3501)和RFC
    6851 [https://tools.ietf.org/html/rfc6851](https://tools.ietf.org/html/rfc6851)以获取更多详细信息。
- en: The RFCs describe the IMAP4 protocol and can be a little arid. Checking the
    possible actions will give you an idea of the possibilities to investigate in
    detail, probably by Googling for examples.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: RFC描述了IMAP4协议，可能有点枯燥。检查可能的操作将让您了解详细调查的可能性，可能通过Google搜索示例。
- en: 'The subject and body of the email, as well as other metadata such as date,
    to, from, and so on, can be parsed and processed. For example, the subject retrieved
    in this recipe can be processed in the following way:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 可以解析和处理电子邮件的主题和正文，以及日期、收件人、发件人等其他元数据。例如，本食谱中检索的主题可以按以下方式处理：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml), *Let Us Begin Our
    Automation Journey* for more info about regular expressions and other ways of
    parsing information.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有关正则表达式和其他解析信息的更多信息，请参见[第1章](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml)，*让我们开始自动化之旅*。
- en: See also
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Introducing regular expressions* recipe in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml),
    *Let Us Begin Our Automation Journey*
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml)中的*介绍正则表达式*食谱，*让我们开始自动化之旅*'
- en: Adding subscribers to an email newsletter
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向电子邮件通讯订阅者添加订阅者
- en: A common marketing tool is email newsletters. They are convenient ways of sending
    information to multiple targets. A good newsletter system is difficult to implement,
    and the recommended way is to use ones available in the market. A well known one
    is MailChimp ([https://mailchimp.com/](https://mailchimp.com/)).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的营销工具是电子邮件通讯。它们是向多个目标发送信息的便捷方式。一个好的通讯系统很难实现，推荐的方法是使用市场上可用的。一个著名的是MailChimp
    ([https://mailchimp.com/](https://mailchimp.com/))。
- en: MailChimp has a lot of possibilities, but the interesting one in regard to this
    book is its API, which can be scripted to automate tools. This RESTful API can
    be accessed through Python. In this recipe, we will see how to add more subscribers
    to an existing list.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: MailChimp有很多可能性，但与本书相关的有趣之一是其API，可以编写脚本来自动化工具。这个RESTful API可以通过Python访问。在这个食谱中，我们将看到如何向现有列表添加更多的订阅者。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: As we will use MailChimp, we need to have an account available. You can create
    a free account at [https://login.mailchimp.com/signup/](https://login.mailchimp.com/signup/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用MailChimp，因此需要有一个可用的帐户。您可以在[https://login.mailchimp.com/signup/](https://login.mailchimp.com/signup/)上创建一个免费帐户。
- en: 'After creating the account, be sure to at least have a list that we will add
    subscribers to. As part of the registration, it is possible that it has been created.
    It will appear under Lists:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建帐户后，请确保至少有一个我们将向其添加订阅者的列表。作为注册的一部分，可能已经创建了。它将显示在列表下：
- en: '![](assets/05182753-f7ff-4002-8e63-40cdbcfe5e36.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/05182753-f7ff-4002-8e63-40cdbcfe5e36.png)'
- en: The list will contain the subscribed users.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表将包含已订阅的用户。
- en: 'For the API, we''ll need an API key. Go to Account | Extras | API keys and
    create a new one:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于API，我们将需要一个API密钥。转到帐户|额外|API密钥并创建一个新的：
- en: '![](assets/a2174005-2a85-4c91-880a-a14ec426ca66.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a2174005-2a85-4c91-880a-a14ec426ca66.png)'
- en: 'We will use the requests module for accessing the API. Add it to your virtual
    environment:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`requests`模块来访问API。将其添加到您的虚拟环境中：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The MailChimp API uses the concept of the **DC** (**data center**) that your
    account uses. This can be obtained from the last digits of your API, or from the
    start of the URL from the MailChimp admin site. For example, in all the previous
    screenshots, it is `us19`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: MailChimp API使用**DC**（数据中心）的概念，您的帐户使用它。这可以从您的API的最后几位数字中获得，或者从MailChimp管理站点的URL开头获得。例如，在所有先前的截图中，它是`us19`。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import the `requests` module:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`requests`模块：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define the authentication and base URLs. The base URL requires your `dc` at
    the start (such as `us19`):'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义身份验证和基本URL。基本URL需要在开头加上您的`dc`（例如`us19`）：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Obtain all your lists:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有列表：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Filter your lists to obtain the `href` for the required list:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过滤列表以获取所需列表的`href`：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With the list URL, you can obtain the URL for the members of the list:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用列表URL，您可以获取列表成员的URL：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The list of members can be retrieved through a `GET` request to `members_url`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过向`members_url`发出`GET`请求来检索成员列表：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Append a new member to the list:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向列表添加新成员：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Retrieving the list of users with a `GET` obtains both users:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GET`获取用户列表会获取到所有用户：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: After importing the requests module in step 1, we define the basic values to
    connect in step 2, the base URL, and the credentials. Note that for the authentication,
    we only require the API key as the password, and any user (as described by the
    MailChimp documentation: [https://developer.mailchimp.com/documentation/mailchimp/guides/get-started-with-mailchimp-api-3/](https://developer.mailchimp.com/documentation/mailchimp/guides/get-started-with-mailchimp-api-3/)).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步导入requests模块后，在第2步定义连接的基本值，即基本URL和凭据。请注意，对于身份验证，我们只需要API密钥作为密码，以及任何用户（如MailChimp文档所述：[https://developer.mailchimp.com/documentation/mailchimp/guides/get-started-with-mailchimp-api-3/](https://developer.mailchimp.com/documentation/mailchimp/guides/get-started-with-mailchimp-api-3/)）。
- en: Step 3 retrieves all the lists, calling the proper URL. The result is returned
    in JSON format. The call includes the `auth` parameter with the defined credentials.
    All subsequent calls will be made with that `auth` parameter for authentication
    purposes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步检索所有列表，调用适当的URL。结果以JSON格式返回。调用包括具有定义凭据的`auth`参数。所有后续调用都将使用该`auth`参数进行身份验证。
- en: Step 4 shows how to filter the returned list to grab the URL of the particular
    list of interest. Each of the returned calls includes a list of `_links` with
    related information, making it possible to walk through the API.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步显示了如何过滤返回的列表以获取感兴趣的特定列表的URL。每个返回的调用都包括一系列与相关信息的`_links`列表，使得可以通过API进行遍历。
- en: The URL for the list is called in step 5\. This returns information for the
    list, including the basic stats. Applying a similar filtering to step 4, we retrieve
    the URL for the members.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步调用列表的URL。这将返回列表的信息，包括基本统计信息。类似于第4步的过滤，我们检索成员的URL。
- en: Due to size constraints and to show relevant data, not all of the retrieved
    elements are displayed. Feel free to analyze them interactively and find out about
    them. The data is well constructed, following the RESTful principles of discoverability;
    plus the Python ability of introspection makes it quite readable and understandable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于尺寸限制和显示相关数据，未显示所有检索到的元素。请随时进行交互式分析并了解它们。数据构造良好，遵循RESTful的可发现性原则；再加上Python的内省能力，使其非常易读和易懂。
- en: Step 6 retrieves the list of members, making a `GET` request to `members_url`,
    which can be seen as a single user. This can be seen in the *Getting Ready* section,
    in the web interface.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第6步检索成员列表，向`members_url`发出`GET`请求，可以将其视为单个用户。这可以在网页界面的*Getting Ready*部分中看到。
- en: Step 7 creates a new user and posts on the `members_url` with the information
    passed in the `json` parameter, so it gets translated into JSON format. The updated
    data is retrieved in step 7, showing that there's a new user in the list.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第7步创建一个新用户，并在`members_url`上发布`json`参数中传递的信息，以便将其转换为JSON格式。第7步检索更新后的数据，显示列表中有一个新用户。
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The full MailChimp API is quite powerful and can perform a large number of tasks.
    Go to the full MailChimp documentation to discover all the possibilities: [https://developer.mailchimp.com/](https://developer.mailchimp.com/).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的MailChimp API非常强大，可以执行大量任务。请查看完整的MailChimp文档以发现所有可能性：[https://developer.mailchimp.com/](https://developer.mailchimp.com/)。
- en: As a brief note, and a little out of scope of this book, please be aware of
    the legal implications of adding subscribers to an automated list. Spam is a serious
    worry and there are new regulations in place to protect the rights of customers,
    such as GPDR. Ensure that you have the permission of users to email them. The
    good thing is that MailChimp automatically implements tools to help with this,
    such as automatic unsubscribe buttons.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 简要说明一下，超出了本书的范围，请注意向自动列表添加订阅者的法律影响。垃圾邮件是一个严重的问题，有新的法规来保护客户的权利，如GPDR。确保您有用户的许可才能给他们发送电子邮件。好消息是，MailChimp自动实现了帮助解决这个问题的工具，如自动退订按钮。
- en: The general MailChimp documentation is also quite interesting and shows a lot
    of possibilities. MailChimp is capable of managing newsletter and general distribution
    lists, but it can also be tailored to generate flows, schedule the sending of
    emails, and automatically send messages to your audience based on parameters such
    as their birthday.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的MailChimp文档也非常有趣，展示了许多可能性。MailChimp能够管理通讯和一般的分发列表，但也可以定制生成流程，安排发送电子邮件，并根据参数（如生日）自动向您的受众发送消息。
- en: See also
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Sending an individual email* recipe
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发送单个电子邮件*配方'
- en: The *Sending transactional emails* recipe
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发送交易电子邮件*配方'
- en: Sending notifications via email
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过电子邮件发送通知
- en: In this recipe, we will cover how to send emails that will be send towards customers.
    An email that is sent in response to an action by a user, for example, a confirmation
    email or an alert email, is called *a* **transactional email**. Due to spam protection
    and other limitations, it is better to implement this kind of email with the help
    of external tools.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将介绍如何发送将发送给客户的电子邮件。作为对用户操作的响应发送的电子邮件，例如确认电子邮件或警报电子邮件，称为*交易电子邮件*。由于垃圾邮件保护和其他限制，最好使用外部工具来实现这种类型的电子邮件。
- en: In this recipe, we will use Mailgun ([https://www.mailgun.com](https://www.mailgun.com)),
    which is able to send this kind of email, as well as communicate responses.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用Mailgun ([https://www.mailgun.com](https://www.mailgun.com))，它能够发送这种类型的电子邮件，并与之通信。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need to create an account in Mailgun. Go to [https://signup.mailgun.com](https://signup.mailgun.com/new/signup)
    to create one. Notice that the credit card information is optional.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在Mailgun中创建一个帐户。转到[https://signup.mailgun.com](https://signup.mailgun.com/new/signup)创建一个。请注意，信用卡信息是可选的。
- en: 'Once registered, go to Domains to see there''s a sandbox environment. We can
    use it to test the functionality, although it will only send emails to registered
    test email accounts. The API credentials will be displayed there:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注册后，转到域以查看是否有沙箱环境。我们可以使用它来测试功能，尽管它只会向注册的测试电子邮件帐户发送电子邮件。API凭据将显示在那里：
- en: '![](assets/f287dcdc-a84e-4cd0-9df3-abae2afae51a.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f287dcdc-a84e-4cd0-9df3-abae2afae51a.png)'
- en: 'We need to register the account so we''ll receive the email as an *authorized
    recipient*. You can add it here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注册帐户，以便我们将作为*授权收件人*收到电子邮件。您可以在此处添加：
- en: '![](assets/eacf6ffc-c628-4baf-8292-c4eec436fd98.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/eacf6ffc-c628-4baf-8292-c4eec436fd98.png)'
- en: 'To verify the account, check the email of the authorized recipient and confirm
    it. The email address is now ready to receive test emails:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证帐户，请检查授权收件人的电子邮件并确认。电子邮件地址现在已准备好接收测试邮件：
- en: '![](assets/485590b4-1022-4f34-82ad-2859dac25be9.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/485590b4-1022-4f34-82ad-2859dac25be9.png)'
- en: 'We will use the requests module for making the connection to the Mailgun API.
    Install it in the virtual environment:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`requests`模块来连接Mailgun API。在虚拟环境中安装它：
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Everything is ready to send emails, but notice only to authorized recipients.
    Being able to send emails everywhere requires us to set up a domain. Follow the
    Mailgun documentation: [https://documentation.mailgun.com/en/latest/quickstart-sending.html#verify-your-domain](https://documentation.mailgun.com/en/latest/quickstart-sending.html#verify-your-domain).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一切准备就绪，可以发送电子邮件，但请注意只发送给授权收件人。要能够在任何地方发送电子邮件，我们需要设置域。请参阅Mailgun文档：[https://documentation.mailgun.com/en/latest/quickstart-sending.html#verify-your-domain](https://documentation.mailgun.com/en/latest/quickstart-sending.html#verify-your-domain)。
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import the `requests` module:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`requests`模块：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Prepare the credentials, as well as the to and from emails. Note we''re using
    a mock from:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备凭据，以及要发送和接收的电子邮件。请注意，我们正在使用模拟发件人：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Prepare the email to be sent. Here, there is the HTML version and an alternative
    plain-text one:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备要发送的电子邮件。这里有HTML版本和备用纯文本版本：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Set up the data to send to Mailgun:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置要发送到Mailgun的数据：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Make the call to the API:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用API：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Retrieve the events and check the email has been delivered:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索事件并检查电子邮件是否已发送：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The email should appear in your inbox. As it was sent through the sandbox environment,
    be sure to check your spam folder if it doesn't show up directly.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 邮件应该出现在您的收件箱中。由于它是通过沙箱环境发送的，请确保在直接显示时检查您的垃圾邮件文件夹。
- en: How it works...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Step 1 imports the `requests` module to be used later. The credentials and the
    basic information in the message are defined in step 2, and should be extracted
    from the Mailgun web interface, as shown before.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 第1步导入`requests`模块以供以后使用。第2步定义了凭据和消息中的基本信息，并应从Mailgun Web界面中提取，如前所示。
- en: Step 3 defines the email that will be sent. Step 4 structures the information
    in the way Mailgun expects. Notice the `html` and `text` fields. By default, it
    will set HTML as preferred and the plain-text option as an alternative. The format
    for the `TO` and `FROM` should be in the `Name <address>` format. You can use
    commas to separate multiple recipients in `TO`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步定义将要发送的电子邮件。第4步将信息结构化为Mailgun所期望的方式。请注意`html`和`text`字段。默认情况下，它将设置HTML为首选项，并将纯文本选项作为备选项。`TO`和`FROM`的格式应为`Name
    <address>`格式。您可以使用逗号将多个收件人分隔在`TO`中。
- en: The call to the API  is made in step 5\. It is a `POST` call to the messages
    endpoint. The data is transferred in the standard way, and basic authentication
    is used with the `auth` parameter. Notice the definition in step 2\. All calls
    to Mailgun should include this parameter. It returns a message notifying you that
    it was successful and the message is queued.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步进行API调用。这是对消息端点的`POST`调用。数据以标准方式传输，并使用`auth`参数进行基本身份验证。请注意第2步中的定义。所有对Mailgun的调用都应包括此参数。它返回一条消息，通知您它已成功排队了消息。
- en: In step 6, a call to retrieve the events through a `GET` request is made. This
    will show the latest actions performed, the last of which will be the recent send.
    Information about delivery can also be found.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步，通过`GET`请求调用检索事件。这将显示最新执行的操作，其中最后一个将是最近的发送。还可以找到有关交付的信息。
- en: There's more...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To send emails, you'll need to set up the domain with which to send it, instead
    of using the sandbox environment. You can find the instructions here: [https://documentation.mailgun.com/en/latest/quickstart-sending.html#verify-your-domain](https://documentation.mailgun.com/en/latest/quickstart-sending.html#verify-your-domain).
    This requires you to change your DNS records to verify that you are their legitimate
    owner, and increases the deliverability of emails.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送电子邮件，您需要设置用于发送电子邮件的域，而不是使用沙箱环境。您可以在这里找到说明：[https://documentation.mailgun.com/en/latest/quickstart-sending.html#verify-your-domain](https://documentation.mailgun.com/en/latest/quickstart-sending.html#verify-your-domain)。这需要您更改DNS记录以验证您是其合法所有者，并提高电子邮件的可交付性。
- en: 'The emails can include attachments in the following way:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件可以以以下方式包含附件：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The data can include the usual info such as `cc` or `bcc`, but you can also
    delay the delivery for up to three days with the `o:deliverytime` parameter:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以包括常规信息，如`cc`或`bcc`，但您还可以使用`o:deliverytime`参数将交付延迟最多三天：
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Mailgun can also be used to receive emails and to trigger processes when they
    arrive, for example, forwarding them based on rules. Check the Mailgun documentation
    to find more.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Mailgun还可以用于接收电子邮件并在其到达时触发流程，例如，根据规则转发它们。查看Mailgun文档以获取更多信息。
- en: The full Mailgun documentation can be found here, [https://documentation.mailgun.com/en/latest/quickstart.html](https://documentation.mailgun.com/en/latest/quickstart.html).
    Be sure to check their *Best Practices* section ([https://documentation.mailgun.com/en/latest/best_practices.html#email-best-practices](https://documentation.mailgun.com/en/latest/best_practices.html#email-best-practices))
    to understand the world of sending emails and how to avoid being labeled as spam.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的Mailgun文档可以在这里找到，[https://documentation.mailgun.com/en/latest/quickstart.html](https://documentation.mailgun.com/en/latest/quickstart.html)。一定要检查他们的*最佳实践*部分([https://documentation.mailgun.com/en/latest/best_practices.html#email-best-practices](https://documentation.mailgun.com/en/latest/best_practices.html#email-best-practices))，以了解发送电子邮件的世界以及如何避免被标记为垃圾邮件。
- en: See also
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Working with email templates* recipe
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用电子邮件模板*配方'
- en: The *Sending an individual email* recipe
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发送单个电子邮件*配方'
- en: Producing SMS
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成短信
- en: One of the most widely available communication channels is text messages. Text
    messages are very convenient to use to distribute information.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛使用的通信渠道之一是短信。短信非常方便用于分发信息。
- en: SMS messages can be used for marketing purposes, but also as ways of alerting
    or sending notifications, or, very common recently, as a way of implementing two-factor
    authentication systems.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 短信可以用于营销目的，也可以用作警报或发送通知的方式，或者最近非常常见的是作为实施双因素身份验证系统的一种方式。
- en: We will use Twilio, a service exposing an API to send SMS in an easy way.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Twilio，这是一个提供API以轻松发送短信的服务。
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We need to create an account for Twilio at [https://www.twilio.com/](https://www.twilio.com/).
    Go to the page and register a new account.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在[https://www.twilio.com/](https://www.twilio.com/)为Twilio创建一个帐户。转到该页面并注册一个新帐户。
- en: You'll need to follow the instructions and set up a phone number to receive
    messages. You'll need to input a code sent to this phone or receive a call to
    verify this line.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要按照说明设置一个电话号码来接收消息。您需要输入发送到此电话的代码或接听电话以验证此线路。
- en: 'Create a new project and check the dashboard. From there, you''ll be able to
    create a first phone number, able to receive and send SMS:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新项目并检查仪表板。从那里，您将能够创建第一个电话号码，能够接收和发送短信：
- en: '![](assets/93858574-0d63-4bac-b762-e8e0f5435059.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/93858574-0d63-4bac-b762-e8e0f5435059.png)'
- en: Once the number is configured, it will appear in the Active Numbers section
    in All Products and Services | Phone Numbers*.*
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦号码配置完成，它将出现在所有产品和服务 | 电话号码*.*的活动号码部分。
- en: On the main dashboard, check `ACCOUNT SID` and `AUTH TOKEN`. They'll be used
    later. Notice you'll need to display the auth token.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在主仪表板上，检查`ACCOUNT SID`和`AUTH TOKEN`。稍后将使用它们。请注意，您需要显示身份验证令牌。
- en: 'We''ll also need to install the `twilio` module. Add it to your virtual environment:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装`twilio`模块。将其添加到您的虚拟环境中：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Notice that the receiver phone number can only be a verified number with a trial
    account. You can verify more than one number; follow the documentation at [https://support.twilio.com/hc/en-us/articles/223180048-Adding-a-Verified-Phone-Number-or-Caller-ID-with-Twilio](https://support.twilio.com/hc/en-us/articles/223180048-Adding-a-Verified-Phone-Number-or-Caller-ID-with-Twilio).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，接收者电话号码只能是经过试用账户验证的号码。您可以验证多个号码；请参阅[https://support.twilio.com/hc/en-us/articles/223180048-Adding-a-Verified-Phone-Number-or-Caller-ID-with-Twilio](https://support.twilio.com/hc/en-us/articles/223180048-Adding-a-Verified-Phone-Number-or-Caller-ID-with-Twilio)上的文档。
- en: How to do it...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import the `Client` from the `twilio` module:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`twilio`模块导入`Client`：
- en: '[PRE46]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Set up the authentication credentials obtained from the dashboard before. Also,
    set your Twilio phone number; as an example, here we set `+353 12 345 6789`, a
    fake Irish number. It will be local to your country:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前从仪表板获取的身份验证凭据。还要设置您的Twilio电话号码；例如，这里我们设置了`+353 12 345 6789`，一个虚假的爱尔兰号码。它将是您国家的本地号码：
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Start the `client` to access the API:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`client`以访问API：
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Send a message to your authorized phone number. Notice the underscore at the
    end of `from_`:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向您授权的电话号码发送一条消息。请注意`from_`末尾的下划线：
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You''ll receive an SMS to your phone:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将收到一条短信到您的手机：
- en: '![](assets/89dfa2a3-a312-4789-bbbe-74a394a84b48.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/89dfa2a3-a312-4789-bbbe-74a394a84b48.png)'
- en: How it works...
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The use of the Twilio client to send messages is very straightforward.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Twilio客户端发送消息非常简单。
- en: In step 1, we import the `Client`, and prepare the credentials and the phone
    number configured in step 2.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步，我们导入`Client`，并准备在第2步配置的凭据和电话号码。
- en: Step 3 creates the client with the proper authentication, and the message is
    sent in step 4.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步使用适当的身份验证创建客户端，并在第4步发送消息。
- en: Note that the `to` number needs to be one of the authenticated numbers while
    in a trial account, or it will produce an error. You can add more authenticated
    numbers; check the Twilio documentation.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`to`号码需要是试用帐户中经过身份验证的号码之一，否则将产生错误。您可以添加更多经过身份验证的号码；请查看Twilio文档。
- en: All the messages that are sent from a trial account will include that detail
    in the SMS, as you can see in step 5.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 从试用帐户发送的所有消息都将在短信中包含该详细信息，正如您在第5步中所看到的。
- en: There's more...
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In certain regions (US and Canada at the time of writing this), SMS numbers
    have the ability to send MMS messages, including images. To attach images to the
    message, add the `media_url` parameter and the URL of the image to send:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些地区（在撰写本文时为美国和加拿大），短信号码具有发送MMS消息（包括图像）的功能。要将图像附加到消息中，请添加`media_url`参数和要发送的图像的URL：
- en: '[PRE50]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The client is based on a RESTful API, and allows you to perform multiple operations,
    such as create a new phone number, or obtain an available number first and then
    purchase it:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端基于RESTful API，并允许您执行多个操作，例如创建新的电话号码，或首先获取一个可用的号码，然后购买它：
- en: '[PRE51]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Check the documentation for more available actions, but most of the dashboard
    point-and-click actions can be performed programmatically.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 查看文档以获取更多可用操作，但大多数仪表板的点按操作都可以以编程方式执行。
- en: Twilio is also capable of performing other phone services, such as phone calls
    and text-to-speech. Check it out in the full documentation.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Twilio还能够执行其他电话服务，如电话呼叫和文本转语音。请在完整文档中查看。
- en: The full Twilio documentation is available here: [https://www.twilio.com/docs/](https://www.twilio.com/docs/).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的Twilio文档在此处可用：[https://www.twilio.com/docs/](https://www.twilio.com/docs/)。
- en: See also
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Receiving SMS* recipe
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*接收短信*配方'
- en: The *Creating a Telegram bot* recipe
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建Telegram机器人*配方'
- en: Receiving SMS
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收短信
- en: SMS can also be received and processed automatically. This enables services
    such as delivering information on request (for instance, send INFO GOALS to receive
    the results from the Soccer League), but also more complex flows such as in bots,
    which can have simple conversations with users that enable rich services such
    as remotely configuring a thermostat.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 短信也可以自动接收和处理。这使得可以提供按请求提供信息的服务（例如，发送INFO GOALS以接收足球联赛的结果），但也可以进行更复杂的流程，例如在机器人中，它可以与用户进行简单的对话，从而实现诸如远程配置恒温器之类的丰富服务。
- en: Each time Twilio receives an SMS to one of your registered phone numbers, it
    performs a request to a publicly available URL. This is configured in the service,
    meaning it should be under your control. This creates the problem of having a
    URL under your control available on the internet. This means that just your local
    computer won't work, as it's not addressable. We will use Heroku ([http://heroku.com](http://heroku.com))
    to deliver an available service, but there are other alternatives. The Twilio
    documentation has examples using `grok`, which allows for local development by
    creating a tunnel between a public address and your local development environment.
    See here for more details: [https://www.twilio.com/blog/2013/10/test-your-webhooks-locally-with-ngrok.html](https://www.twilio.com/blog/2013/10/test-your-webhooks-locally-with-ngrok.html).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 每当Twilio接收到您注册的电话号码之一的短信时，它会执行对公开可用的URL的请求。这在服务中进行配置，这意味着它应该在您的控制之下。这会产生一个问题，即在互联网上有一个在您控制之下的URL。这意味着仅仅您的本地计算机是行不通的，因为它是不可寻址的。我们将使用Heroku（[http://heroku.com](http://heroku.com)）来提供一个可用的服务，但也有其他选择。Twilio文档中有使用`grok`的示例，它允许通过在公共地址和您的本地开发环境之间创建隧道来进行本地开发。有关更多详细信息，请参见此处：[https://www.twilio.com/blog/2013/10/test-your-webhooks-locally-with-ngrok.html](https://www.twilio.com/blog/2013/10/test-your-webhooks-locally-with-ngrok.html)。
- en: This way of operating is common in communication APIs. It should be noted that
    Twilio has a beta API for WhatsApp, which works in a similar way. Check the docs
    for more information at [https://www.twilio.com/docs/sms/whatsapp/quickstart/python](https://www.twilio.com/docs/sms/whatsapp/quickstart/python).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作方式在通信API中很常见。值得注意的是，Twilio有一个WhatsApp的beta API，其工作方式类似。请查看文档以获取更多信息：[https://www.twilio.com/docs/sms/whatsapp/quickstart/python](https://www.twilio.com/docs/sms/whatsapp/quickstart/python)。
- en: Getting ready
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We need to create an account for Twilio at [https://www.twilio.com/](https://www.twilio.com/). Refer
    to the *Getting ready* section in the *Producing SMS* recipe for detailed instructions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在[https://www.twilio.com/](https://www.twilio.com/)为Twilio创建一个帐户。有关详细说明，请参阅*准备就绪*部分中*生成短信*配方。
- en: 'For this recipe, we will also need to set up a web service in Heroku ([https://www.heroku.com/](https://www.heroku.com/))
    to be able to create a webhook capable of receiving SMS addressed to Twilio. Because
    the main objective of this recipe is the SMS part, we will be concise when setting
    up Heroku, but you can refer to its excellent documentation. It is quite easy
    to use:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们还需要在Heroku（[https://www.heroku.com/](https://www.heroku.com/)）中设置一个Web服务，以便能够创建一个能够接收发送给Twilio的短信的Webhook。因为这个配方的主要目标是短信部分，所以在设置Heroku时我们将简洁一些，但您可以参考其出色的文档。它非常易于使用：
- en: Create an account in Heroku.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Heroku中创建一个帐户。
- en: 'You''ll need to install the command line interface for Heroku (instructions
    for all platforms are at [https://devcenter.heroku.com/articles/getting-started-with-python#set-up](https://devcenter.heroku.com/articles/getting-started-with-python#set-up))
    and then log in to the command line:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要安装Heroku的命令行界面（所有平台的说明都在[https://devcenter.heroku.com/articles/getting-started-with-python#set-up](https://devcenter.heroku.com/articles/getting-started-with-python#set-up)），然后登录到命令行：
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Download a basic Heroku template from[ https://github.com/datademofun/heroku-basic-flask](https://github.com/datademofun/heroku-basic-flask).
    We will use it as a base for our server.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/datademofun/heroku-basic-flask](https://github.com/datademofun/heroku-basic-flask)下载一个基本的Heroku模板。我们将把它用作服务器的基础。
- en: 'Add the `twilio` client to the `requirements.txt` file:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`twilio`客户端添加到`requirements.txt`文件中：
- en: '[PRE53]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Replace `app.py` with the one in GitHub at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/app.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/app.py).
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用GitHub中的`app.py`替换`app.py`：[https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/app.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/app.py)。
- en: You can keep the existing `app.py` to check the template example and how Heroku
    works. Check out the README at [https://github.com/datademofun/heroku-basic-flask](https://github.com/datademofun/heroku-basic-flask).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以保留现有的`app.py`来检查模板示例和Heroku的工作原理。查看[https://github.com/datademofun/heroku-basic-flask](https://github.com/datademofun/heroku-basic-flask)中的README。
- en: 'Once done, commit the changes to Git:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，将更改提交到Git：
- en: '[PRE54]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create a new service in Heroku. It will generate a new service name randomly
    (we use `service-name-12345` here). This URL is accessible:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Heroku中创建一个新服务。它将随机生成一个新的服务名称（我们在这里使用`service-name-12345`）。此URL是可访问的：
- en: '[PRE55]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Deploy the service. In Heroku, deploying a service pushes the code to the remote
    Git server:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署服务。在Heroku中，部署服务会将代码推送到远程Git服务器：
- en: '[PRE56]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Check that the service is up and running at the webhook URL. Note it is displayed
    as output in the previous step. You can also check it in a browser:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查Webhook URL的服务是否正在运行。请注意，它显示为上一步的输出。您也可以在浏览器中检查：
- en: '[PRE57]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How to do it...
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Go to Twilio and access the PHONE NUMBER section. Configure the webhook URL.
    This will make the URL be called on each received SMS. Go to the Active Numbers section
    in All Products and Services | Phone Numbers and fill in the webhook. Note the
    `/sms` at the end of the webhook. Click on Save:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到Twilio并访问PHONE NUMBER部分。配置Webhook URL。这将使URL在每次收到短信时被调用。转到All Products and
    Services | Phone Numbers中的Active Numbers部分，并填写Webhook。请注意Webhook末尾的`/sms`。单击保存：
- en: '![](assets/278c3fc0-7ec7-4567-815a-060e27cd40f0.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/278c3fc0-7ec7-4567-815a-060e27cd40f0.png)'
- en: 'The service is now up and can be used. Send an SMS to your Twilio phone number
    and you should get back an automated response:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务现在已经启动并可以使用。向您的Twilio电话号码发送短信，您应该会收到自动回复：
- en: '![](assets/9853424c-d223-4767-88b5-55a161028b3a.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9853424c-d223-4767-88b5-55a161028b3a.png)'
- en: Note the blurred parts should be replaced with your info.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，模糊的部分应该用您的信息替换。
- en: If you have a trial account, you can only send messages back to one of your
    authorized phone numbers, so you'll need to send the text from them.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有试用账户，您只能向您授权的电话号码之一发送消息，所以您需要从它们发送文本。
- en: How it works...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Step 1 sets up the webhook, so Twilio calls your Heroku app when receiving an
    SMS on the phone line.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 第1步设置了Webhook，因此Twilio在电话线上收到短信时调用您的Heroku应用程序。
- en: 'Let''s take a look at the code in `app.py` to see how this works. Here it is
    redacted for clarity; check the full file at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/app.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/app.py):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`app.py`中的代码，看看它是如何工作的。这里为了清晰起见对其进行了编辑；请在[https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/app.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/app.py)中查看完整文件：
- en: '[PRE58]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`app.py` can be divided into three parts—the Python imports at start of the
    file and startup of the Flask app at the end, which is just setting up Flask (not
    shown here); the call to `homepage`, which is generated to test that the server
    is working; and `sms_reply`, which is where the magic happens.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.py`可以分为三个部分——文件开头的Python导入和Flask应用程序的启动，这只是设置Flask（此处不显示）；调用`homepage`，用于测试服务器是否正常工作；和`sms_reply`，这是魔术发生的地方。'
- en: The `sms_reply` function obtains the phone number that sends the SMS, as well
    as the body of the message, from the `request.form` dictionary. Then, compose
    a response in `msg`, attach it to a new `MessagingResponse`, and return it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`sms_reply`函数从`request.form`字典中获取发送短信的电话号码以及消息的正文。然后，在`msg`中组成一个响应，将其附加到一个新的`MessagingResponse`，并返回它。'
- en: We are using the message from the user as a whole, but remember all the techniques
    to parse text mentioned in [Chapter 1](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml),
    *Let Us Begin Our Automation Journey*. They are all applicable here to detecting
    predefined actions or any other text processing.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将用户的消息作为一个整体使用，但请记住[第1章](e139aa50-5631-4b75-9257-d4eb2e12ef90.xhtml)中提到的解析文本的所有技术，*让我们开始自动化之旅*。它们都适用于在此处检测预定义操作或任何其他文本处理。
- en: The returned value will be sent back by Twilio to the sender, producing the
    result seen in step 2.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的值将由Twilio发送回发送者，产生步骤2中看到的结果。
- en: There's more...
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To be able to generate automated conversations, the state of the conversation
    should be stored. For advanced state, it should probably be stored in a database,
    generating a flow, but for simple cases, storing information in `session` may
    be enough. The session is able to store information in the cookies that is persistent
    between the same combination of to and from phone numbers, allowing you to retrieve
    it between messages.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够生成自动对话，对话的状态应该被存储。对于高级状态，它可能应该被存储在数据库中，生成一个流程，但对于简单情况，将信息存储在`session`中可能足够了。会话能够在cookies中存储信息，这些信息在相同的来去电话号码组合之间是持久的，允许您在消息之间检索它。
- en: 'For example, this modification will return not only the send body, but the
    previous one as well. Only the relevant parts have been included:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，此修改将返回不仅发送正文，还有先前的正文。只包括相关部分：
- en: '[PRE59]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The previous `body` is stored in the `MESSAGE` key of the session, which is
    carried over. Notice the requirement for a secret key to use the session data.
    Read this for information about it: [http://flask.pocoo.org/docs/1.0/quickstart/?highlight=session#sessions](http://flask.pocoo.org/docs/1.0/quickstart/?highlight=session#sessions).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个`body`存储在会话的`MESSAGE`键中，会话会被保留。注意使用会话数据需要秘密密钥的要求。阅读此处的信息：[http://flask.pocoo.org/docs/1.0/quickstart/?highlight=session#sessions](http://flask.pocoo.org/docs/1.0/quickstart/?highlight=session#sessions)。
- en: To deploy the new version in Heroku, commit the new `app.py` to Git, and then
    do `git push heroku master`. The new version will be deployed automatically!
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Heroku中部署新版本，将新的`app.py`提交到Git，然后执行`git push heroku master`。新版本将自动部署！
- en: Because the main objective of this recipe is to demonstrate how to reply, Heroku
    and Flask as not described in detail, but they both have excellent documentation.
    The full documentation for Heroku can be found at [https://devcenter.heroku.com/categories/reference](https://devcenter.heroku.com/categories/reference) and
    the documentation for Flask is here: [http://flask.pocoo.org/docs/](http://flask.pocoo.org/docs/).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个食谱的主要目标是演示如何回复，Heroku和Flask没有详细描述，但它们都有很好的文档。Heroku的完整文档可以在这里找到：[https://devcenter.heroku.com/categories/reference](https://devcenter.heroku.com/categories/reference)，Flask的文档在这里：[http://flask.pocoo.org/docs/](http://flask.pocoo.org/docs/)。
- en: 'Remember, the use of Heroku and Flask is just a convenience for this recipe,
    as they are great and easy tools to use. There are multiple alternatives to them,
    as long as you are able to expose a URL so Twilio can call it. Also, check the
    security measures to ensure that requests to this endpoint come from Twilio: [https://www.twilio.com/docs/usage/security#validating-requests](https://www.twilio.com/docs/usage/security#validating-requests).'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，使用Heroku和Flask只是为了方便这个食谱，因为它们是很好和易于使用的工具。有多种替代方案，只要您能够公开一个URL，Twilio就可以调用它。还要检查安全措施，以确保对此端点的请求来自Twilio：[https://www.twilio.com/docs/usage/security#validating-requests](https://www.twilio.com/docs/usage/security#validating-requests)。
- en: The full documentation for Twilio can be found here: [https://www.twilio.com/docs/](https://www.twilio.com/docs/).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Twilio的完整文档可以在这里找到：[https://www.twilio.com/docs/](https://www.twilio.com/docs/)。
- en: See also
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Producing SMS* recipe
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成短信*食谱'
- en: The *Creating a Telegram bot* recipe
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建Telegram机器人*食谱'
- en: Creating a Telegram bot
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Telegram机器人
- en: Telegram Messenger is an instant messaging app that has good support for creating
    bots. Bots are small applications that aim to produce automatic conversations.
    The big promise of bots is as machines that can create any kind of conversation,
    totally indistinguishable from a conversation with a human being, and pass the
    *Turing Test,* but that objective is quite ambitious and not realistic yet for
    the most part.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Telegram Messenger是一个即时通讯应用程序，对创建机器人有很好的支持。机器人是旨在产生自动对话的小型应用程序。机器人的重要承诺是作为可以产生任何类型对话的机器，完全无法与人类对话区分开来，并通过*Turing测试*，但这个目标对大部分来说是相当雄心勃勃且不现实的。
- en: The Turing Test was proposed by Alan Turing in 1951\. Two participants, a human
    and an Artificial Intelligence (a machine or software program), communicate via
    text (like in an instant messaging app) with a human judge that decides which
    one is human and which one is not. If the judge can only guess correctly 50% of
    the time, it can't be easily differentiated and therefore the AI passes the test.
    This was one of the first attempts to measure Artificial Intelligence.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵测试是由艾伦·图灵于1951年提出的。两个参与者，一个人类和一个人工智能（机器或软件程序），通过文本（就像在即时通讯应用程序中）与一个人类评委进行交流，评委决定哪一个是人类，哪一个不是。如果评委只能猜对一半的时间，就无法轻易区分，因此人工智能通过了测试。这是对衡量人工智能的最早尝试之一。
- en: But bots can be very useful with a more limited approach, similar to phone systems
    where you need to press *2* for checking your account, and press *3* for reporting
    a missing card. We'll see in this recipe how to generate a simple bot that will
    display offers and events for a company.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，机器人也可以以更有限的方式非常有用，类似于需要按*2*来检查您的账户，按*3*来报告遗失的卡片的电话系统。在这个食谱中，我们将看到如何生成一个简单的机器人，用于显示公司的优惠和活动。
- en: Getting ready
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We need to create a new bot for Telegram. This is done through an interface
    called **the BotFather**, which is a Telegram special channel that allows us to
    create a new bot. You can access the channel here: [https://telegram.me/botfather](https://telegram.me/botfather).
    Access it through your Telegram account.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为Telegram创建一个新的机器人。这是通过一个名为**BotFather**的界面完成的，它是一个特殊的Telegram频道，允许我们创建一个新的机器人。您可以通过此链接访问该频道：[https://telegram.me/botfather](https://telegram.me/botfather)。通过您的Telegram帐户访问它。
- en: Run `/start` to start the interface and then create a new bot with `/newbot`.
    The interface will ask you the name of the bot and a username, which should be
    unique.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`/start`以启动界面，然后使用`/newbot`创建一个新的机器人。界面会要求您输入机器人的名称和用户名，用户名应该是唯一的。
- en: 'Once it''s set up, it will give you the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好，它将给您以下内容：
- en: The Telegram channel of your bot—`https:/t.me/<yourusername>`.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的机器人的Telegram频道-`https:/t.me/<yourusername>`。
- en: A token to allow access the bot. Copy it as it will be used later.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许访问机器人的令牌。复制它，因为稍后会用到。
- en: You can generate a new token if you lose it. Read The BotFather's documentation.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果丢失令牌，可以生成一个新的令牌。阅读BotFather的文档。
- en: 'We also need to install the Python module `telepot`, which wraps the RESTful
    interface from Telegram:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装Python模块`telepot`，它包装了Telegram的RESTful接口：
- en: '[PRE60]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Download the `telegram_bot.py` script from GitHub at [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/telegram_bot.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/telegram_bot.py).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub上下载`telegram_bot.py`脚本：[https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/telegram_bot.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/telegram_bot.py)。
- en: How to do it...
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Setup your generated token into the `telegram_bot.py` script on the `TOKEN`
    constant in line 6:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将生成的令牌设置到`telegram_bot.py`脚本的第6行的`TOKEN`常量中：
- en: '[PRE61]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Start the bot:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动机器人：
- en: '[PRE62]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Open the Telegram channel in your phone using the URL and start it. You can
    use the `help`, `offers`, and `events` commands:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用URL在手机上打开Telegram频道并启动它。您可以使用`help`，`offers`和`events`命令：
- en: '![](assets/e8a122ba-dadf-4e78-9c32-d29e8d56449c.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e8a122ba-dadf-4e78-9c32-d29e8d56449c.png)'
- en: How it works...
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Step 1 sets the token to use for your specific channel. In step 2, we start
    the bot locally.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 第1步设置要用于您特定频道的令牌。在第2步中，我们在本地启动机器人。
- en: 'Let''s see how the code in `telegram_bot.py` is structured:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`telegram_bot.py`中的代码结构：
- en: '[PRE63]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `MarketingBot` class creates an interface to handle the communication with
    Telegram:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`MarketingBot`类创建了一个与Telegram进行通信的接口：'
- en: When the channel is started, the `open` method will be called
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当频道启动时，将调用`open`方法
- en: When a message is received, the `on_chat_message` method will be called
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当收到消息时，将调用`on_chat_message`方法
- en: If there's no answer in a while, `on_idle` will be called
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有一段时间没有回应，将调用`on_idle`
- en: 'In each case, the `self.sender.sendMessage` method is used to send a message
    back to the user. Most of the interesting bits happen in `on_chat_message`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，`self.sender.sendMessage`方法用于向用户发送消息。大部分有趣的部分都发生在`on_chat_message`中：
- en: '[PRE64]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: First, it checks whether the received message is text and returns an error message
    if it's not. It analyzes the received text, and if it's one of the defined commands,
    it executes the corresponding function to retrieve the text to return.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它检查接收到的消息是否为文本，如果不是，则返回错误消息。它分析接收到的文本，如果是定义的命令之一，则执行相应的函数以检索要返回的文本。
- en: Then, it sends the message back to the user.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将消息发送回用户。
- en: Step 3 shows how this works from the point of view of the user who is interacting
    with the bot.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步显示了从与机器人交互的用户的角度来看这是如何工作的。
- en: There's more...
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can add more info, an avatar picture, and so on to your Telegram channel
    using the `BotFather` interface.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`BotFather`接口向您的Telegram频道添加更多信息，头像图片等。
- en: 'To simplify our interface, we can create a custom keyboard to simplify the
    bot. Create it after defining the commands, around line 44 of the script:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们的界面，我们可以创建一个自定义键盘来简化机器人。在定义命令之后创建它，在脚本的第44行左右：
- en: '[PRE66]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Notice it is creating a keyboard with three rows, each with one of the commands.
    Then, add the resulting `KEYBOARD` as the `reply_markup` on each of the `sendMessage`
    calls, for example as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它正在创建一个带有三行的键盘，每行都有一个命令。然后，在每个`sendMessage`调用中添加生成的`KEYBOARD`作为`reply_markup`，例如如下所示：
- en: '[PRE67]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This replaces the keyboard with only the defined buttons, making the interface very
    obvious:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这将键盘替换为仅有定义的按钮，使界面非常明显：
- en: '![](assets/c7d4fc8c-6861-4cb5-b4e2-72ac8dd1108c.png)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c7d4fc8c-6861-4cb5-b4e2-72ac8dd1108c.png)'
- en: These changes can be downloaded in the `telegram_bot_custom_keyboard.py` file,
    available in GitHub here: [https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/telegram_bot_custom_keyboard.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/telegram_bot_custom_keyboard.py).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改可以在GitHub的`telegram_bot_custom_keyboard.py`文件中下载，链接在这里：[https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/telegram_bot_custom_keyboard.py](https://github.com/PacktPublishing/Python-Automation-Cookbook/blob/master/Chapter08/telegram_bot_custom_keyboard.py)。
- en: You can create other kinds of custom interfaces, such as inline buttons or even
    a platform for creating games. Check the Telegram API docs for more information.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建其他类型的自定义界面，例如内联按钮，甚至是创建游戏的平台。查看Telegram API文档以获取更多信息。
- en: Interacting with Telegram can also be done through webhooks, in a similar way
    as presented in the Receiving SMS recipe. Check the example for Flask in the `telepot`
    documentation here: [https://github.com/nickoala/telepot/tree/master/examples/webhook](https://github.com/nickoala/telepot/tree/master/examples/webhook).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 与Telegram的交互也可以通过webhook完成，方式与*接收短信*配方中介绍的类似。在`telepot`文档中查看Flask的示例：[https://github.com/nickoala/telepot/tree/master/examples/webhook](https://github.com/nickoala/telepot/tree/master/examples/webhook)。
- en: Setting up a Telegram webhook can be done through `telepot`. It requires that
    your service is behind an HTTPS address to ensure the communication is private.
    This can be tricky to do with simple services. You can check the documentation
    on setting up a webhook in the Telegram docs: [https://core.telegram.org/bots/api#setwebhook](https://core.telegram.org/bots/api#setwebhook).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`telepot`可以设置Telegram webhook。这要求您的服务位于HTTPS地址后，以确保通信是私密的。这可能对于简单的服务来说有点棘手。您可以在Telegram文档中查看有关设置webhook的文档：[https://core.telegram.org/bots/api#setwebhook](https://core.telegram.org/bots/api#setwebhook)。
- en: The full Telegram API for bots can be found here: [https://core.telegram.org/bots](https://core.telegram.org/bots).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 电报机器人的完整API可以在这里找到：[https://core.telegram.org/bots](https://core.telegram.org/bots)。
- en: The documentation for the `telepot` module is found here: [https://telepot.readthedocs.io/en/latest/](https://telepot.readthedocs.io/en/latest/).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`telepot`模块的文档可以在这里找到：[https://telepot.readthedocs.io/en/latest/](https://telepot.readthedocs.io/en/latest/)。'
- en: See also
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Producing SMS* recipe
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成短信*配方'
- en: The *Receiving SMS* recipe
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*接收短信*配方'
