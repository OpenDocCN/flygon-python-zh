- en: Networking and Managing Large Documents
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络和管理大型文档
- en: 'In this chapter, we will learn how to use networking concepts and about how
    large documents can be viewed in chunks. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用网络概念以及如何以块的形式查看大型文档。我们将涵盖以下主题：
- en: Creating a small browser
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个小型浏览器
- en: Creating a server-side application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个服务器端应用程序
- en: Establishing client-server communication
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立客户端-服务器通信
- en: Creating a dockable and floatable sign-in form
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可停靠和可浮动的登录表单
- en: Multiple Document Interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多文档界面
- en: Displaying information in sections using Tab Widget
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用选项卡小部件在部分中显示信息
- en: Creating a custom menu bar
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义菜单栏
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Space on a device screen is always limited, but sometimes you come across a
    situation in which you want to display lots of information or services on the
    screen. In such a situation, you can either use dockable widgets that can be floated
    anywhere on the screen; MDI to display multiple documents as and when desired;
    a Tab Widget box to display information in different chunks; or menus to display
    the required information on the click of a menu item. Also, to better understand
    networking concepts, you need to understand how clients and servers communicate.
    This chapter will help you understand all this.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 设备屏幕上的空间总是有限的，但有时您会遇到这样的情况：您想在屏幕上显示大量信息或服务。在这种情况下，您可以使用可停靠的小部件，这些小部件可以在屏幕的任何位置浮动；MDI可以根据需要显示多个文档；选项卡小部件框可以显示不同块中的信息；或者菜单可以在单击菜单项时显示所需的信息。此外，为了更好地理解网络概念，您需要了解客户端和服务器如何通信。本章将帮助您了解所有这些。
- en: Creating a small browser
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个小型浏览器
- en: Let's now learn a technique to display a web page or the content of an HTML document.
    We will simply be making use of the Line Edit and Push Button widgets so that
    the user can enter the URL of the desired site, followed by clicking on the Push
    Button widget. On clicking the push button, that site will appear in a customized
    widget. Let's see how.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们学习一种显示网页或HTML文档内容的技术。我们将简单地使用LineEdit和PushButton小部件，以便用户可以输入所需站点的URL，然后点击PushButton小部件。单击按钮后，该站点将显示在自定义小部件中。让我们看看。
- en: In this recipe, we will learn how to make a small browser. Because Qt Designer
    does not includes any widgets specifically, the focus of this recipe is to make
    you understand how a custom widget can be promoted into `QWebEngineView`, which
    in turn can be used for displaying a web page.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何制作一个小型浏览器。因为Qt Designer没有包含任何特定的小部件，所以这个示例的重点是让您了解如何将自定义小部件提升为`QWebEngineView`，然后可以用于显示网页。
- en: The application will prompt for a URL and when the user clicks the Go button
    after entering the URL, the specified web page will open in the `QWebEngineView`
    object.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将提示输入URL，当用户输入URL并点击“Go”按钮后，指定的网页将在`QWebEngineView`对象中打开。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will require just three widgets: one for entering the URL,
    a second for clicking the button, and a third for displaying the website. Here
    are the steps to creating a simple browser:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们只需要三个小部件：一个用于输入URL，第二个用于点击按钮，第三个用于显示网站。以下是创建一个简单浏览器的步骤：
- en: Create an application based on the Dialog without Buttons template.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于没有按钮的对话框模板创建一个应用程序。
- en: Add the `QLabel`, `QLineEdit`, `QPushButton`, and `QWidget` widgets to the form
    by dragging and dropping Label, Line Edit, Push Button, and Widget onto the form.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过拖放Label、LineEdit、PushButton和Widget将`QLabel`、`QLineEdit`、`QPushButton`和`QWidget`小部件添加到表单中。
- en: Set the text property of the Label widget to `Enter URL`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Label小部件的文本属性设置为“输入URL”。
- en: Set the text property of the Push Button widget to `Go`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将PushButton小部件的文本属性设置为“Go”。
- en: Set the objectName property of the Line Edit widget to `lineEditURL` and that
    of the Push Button widget to `pushButtonGo`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LineEdit小部件的objectName属性设置为`lineEditURL`，将PushButton小部件的objectName属性设置为`pushButtonGo`。
- en: Save the application as `demoBrowser.ui`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序保存为`demoBrowser.ui`。
- en: 'The form will now appear as shown in the following screenshot:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 表单现在将显示如下截图所示：
- en: '![](assets/7edee36a-8e27-42e5-b7b6-de89b3c3fd4c.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7edee36a-8e27-42e5-b7b6-de89b3c3fd4c.png)'
- en: The next step is to promote `QWidget` to `QWebEngineView` because, to display
    web pages, `QWebEngineView` is required.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将`QWidget`提升为`QWebEngineView`，因为要显示网页，需要`QWebEngineView`。
- en: Promote the `QWidget` object by right-clicking on it and selecting the Promote
    to ... option from the menu that pops up.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击QWidget对象并从弹出菜单中选择“提升为...”选项来提升`QWidget`对象。
- en: In the dialog box that appears, leave the Base class name option as the default,
    QWidget.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的对话框中，将基类名称选项保留为默认的QWidget。
- en: In the Promoted class name box, enter `QWebEngineView` and in the Header file
    box type `PyQt5.QtWebEngineWidgets`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Promoted类名框中输入`QWebEngineView`，在头文件框中输入`PyQt5.QtWebEngineWidgets`。
- en: 'Select the Promote button to promote QWidget to the `QWebEngineView` class,
    as shown in the following screenshot:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Promote按钮，将QWidget提升为`QWebEngineView`类，如下截图所示：
- en: '![](assets/03e31411-d4ea-45fe-997b-13b698a4aebe.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/03e31411-d4ea-45fe-997b-13b698a4aebe.png)'
- en: The user interface created with Qt Designer is stored in a `.ui` file, which
    is an XML file, and needs to be converted into Python code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Qt Designer创建的用户界面存储在`.ui`文件中，这是一个XML文件，需要转换为Python代码。
- en: 'To do the conversion, you need to open a Command Prompt window and navigate
    to the folder where the file is saved, then issue the following command:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要进行转换，您需要打开命令提示符窗口并导航到保存文件的文件夹，然后发出以下命令：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can see the auto-generated Python script file `demoBrowser.py` in the source
    code bundle of this book.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的源代码包中看到自动生成的Python脚本文件`demoBrowser.py`。
- en: Treat the preceding code as a header file, and import it into the file from
    which you will invoke its user interface design.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将上述代码视为一个头文件，并将其导入到将调用其用户界面设计的文件中。
- en: 'Let''s create another Python file with the name `callBrowser.pyw` and import
    the `demoBrowser.py` code into it:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个名为`callBrowser.pyw`的Python文件，并将`demoBrowser.py`代码导入其中：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `demoBrowser.py` file, a class with the name of the top-level object
    is created, with `Ui_ prepended`. That is, for the top-level object, `Dialog`,
    the `Ui_Dialog` class is created and stores the interface elements of our widget.
    That class includes two methods, `setupUi()` and `retranslateUi()`. The `setupUi()`
    method creates the widgets that are used in defining the user interface in Qt
    Designer. Also, the properties of the widgets are set in this method. The `setupUi()`
    method takes a single argument, which is the top-level widget of the application,
    an instance of `QDialog`. The `retranslateUi()` method translates the interface.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`demoBrowser.py`文件中，创建了一个名为顶级对象的类，前面加上`Ui_`。也就是说，对于顶级对象`Dialog`，创建了`Ui_Dialog`类，并存储了我们小部件的接口元素。该类包括两个方法，`setupUi()`和`retranslateUi()`。`setupUi()`方法创建了在Qt
    Designer中定义用户界面时使用的小部件。此方法还设置了小部件的属性。`setupUi()`方法接受一个参数，即应用程序的顶级小部件，即`QDialog`的实例。`retranslateUi()`方法翻译了界面。
- en: In the `callBrowser.pyw` file, you see that the click() event of the Push Button
    widget is connected to the `dispSite` method; after entering a URL in the Line
    Edit widget, when the user clicks the Push Button, the `dispSite` method will
    be invoked.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`callBrowser.pyw`文件中，您会看到推送按钮小部件的click()事件连接到`dispSite`方法；在行编辑小部件中输入URL后，当用户单击推送按钮时，将调用`dispSite`方法。
- en: The `dispSite()` method invokes the `load()` method of the `QWidget` class.
    Recall that the `QWidget` object is promoted to the `QWebEngineView` class for
    viewing web pages. The `load()` method of the `QWebEngineView` class is supplied
    with the URL entered in the `lineEditURL` object consequently, the web page of
    the specified URL opens up or loads in the `QWebEngine` widget.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispSite()`方法调用`QWidget`类的`load()`方法。请记住，`QWidget`对象被提升为`QWebEngineView`类，用于查看网页。`QWebEngineView`类的`load()`方法接收`lineEditURL`对象中输入的URL，因此指定URL的网页将在`QWebEngine`小部件中打开或加载。'
- en: 'On running the application, you get an empty Line Edit box and a Push Button
    widget. Enter the desired URL in the Line Edit widget and click on the Go push
    button, and you will find the web page opens in the `QWebEngineView` widget, as
    shown in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序时，您会得到一个空的行编辑框和一个推送按钮小部件。在行编辑小部件中输入所需的URL，然后单击“Go”按钮，您会发现网页在`QWebEngineView`小部件中打开，如下屏幕截图所示：
- en: '![](assets/4f26797c-c0ca-406f-886f-3fb16878c474.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4f26797c-c0ca-406f-886f-3fb16878c474.png)'
- en: Creating a server-side application
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务器端应用程序
- en: Networking plays a major role in modern life. We need to understand how communication
    is established between two machines. When two machines communicate, one is usually
    a server and the other is a client. The client sends requests to the server and
    the server responds by serving the request made by the client.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 网络在现代生活中扮演着重要角色。我们需要了解两台机器之间的通信是如何建立的。当两台机器通信时，一台通常是服务器，另一台是客户端。客户端向服务器发送请求，服务器通过为客户端提出的请求提供响应。
- en: In this recipe, we will be creating a client-server application where a connection
    is established between client and server and each will be able to transfer text
    messages to the other. That is, two applications will be made and will be executed
    simultaneously, and the text written in one application will appear in the other.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将创建一个客户端-服务器应用程序，在客户端和服务器之间建立连接，并且每个都能够向另一个传输文本消息。也就是说，将创建两个应用程序，并且将同时执行，一个应用程序中编写的文本将出现在另一个应用程序中。
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s begin by creating a server application first, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个服务器应用程序，如下所示：
- en: Create an application based on the Dialog without Buttons template.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于无按钮对话框模板创建应用程序。
- en: Add a `QLabel`, `QTextEdit`, `QLineEdit`, and `QPushButton` to the form by dragging
    and dropping the Label, a Text Edit, Line Edit, and Push Button widgets on the
    form.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将标签、文本编辑、行编辑和推送按钮小部件拖放到表单上，向表单添加`QLabel`、`QTextEdit`、`QLineEdit`和`QPushButton`。
- en: Set the text property of the Label widget to `Server` to indicate that this
    is the server application.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标签小部件的文本属性设置为“服务器”，以指示这是服务器应用程序。
- en: Set the text property of the Push Button widget to `Send`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将推送按钮小部件的文本属性设置为“发送”。
- en: Set the objectName property of the Text Edit widget to `textEditMessages`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本编辑小部件的对象名称属性设置为`textEditMessages`。
- en: Set the objectName property of the Line Edit widget to `lineEditMessage`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将行编辑小部件的对象名称属性设置为`lineEditMessage`。
- en: Set the Push Button widget to `pushButtonSend`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将推送按钮小部件设置为`pushButtonSend`。
- en: 'Save the application as `demoServer.ui`. The form will now appear as shown
    in the following screenshot:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序保存为`demoServer.ui`。表单现在将显示如下屏幕截图所示：
- en: '![](assets/88690655-831b-4b2a-a84e-5c04aabf9418.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/88690655-831b-4b2a-a84e-5c04aabf9418.png)'
- en: The user interface created with Qt Designer is stored in a `.ui` file, which
    is an XML file, and needs to be converted into Python code. The code of the generated
    file, `demoServer.py`, can be seen in the source code bundle of this book.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Qt Designer创建的用户界面存储在`.ui`文件中，这是一个XML文件，需要转换为Python代码。生成文件`demoServer.py`的代码可以在本书的源代码包中看到。
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `demoServer.py` file will be treated as a header file and will be imported
    into another Python file that will use the GUI of the header file and transmit
    the data from the server to client and vice versa. But before that, let's create
    a GUI for the client application. The GUI of the client application is exactly
    the same as that of the server application, with the only difference that the
    Label widget at the top of this application will display the text Client.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`demoServer.py`文件将被视为头文件，并将被导入到另一个Python文件中，该文件将使用头文件的GUI并在服务器和客户端之间传输数据。但在此之前，让我们为客户端应用程序创建一个GUI。客户端应用程序的GUI与服务器应用程序完全相同，唯一的区别是该应用程序顶部的标签小部件将显示文本“客户端”。'
- en: The `demoServer.py` file is a generated Python script of the GUI widgets that
    we dragged and dropped onto the form.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`demoServer.py`文件是我们拖放到表单上的GUI小部件的生成Python脚本。'
- en: 'To establish a connection between the server and client, we will require a
    socket object. To create the socket object, you need to supply the following two
    arguments:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要在服务器和客户端之间建立连接，我们需要一个套接字对象。要创建套接字对象，您需要提供以下两个参数：
- en: '**Socket address:** The socket address is represented using certain address
    families. Each address family requires certain parameters to establish a connection.
    We will be using the `AF_INET` address family in this application. The `AF_INET`
    address family needs a pair of (host, port) to establish a connection where the
    parameter, `host` is the hostname which can either be in string format, internet
    domain notation, or IPv4 address format and the parameter; `port` is an integer
    that represents the port number used for communication.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套接字地址**：套接字地址使用特定的地址系列表示。每个地址系列都需要一些参数来建立连接。在本应用程序中，我们将使用`AF_INET`地址系列。`AF_INET`地址系列需要一对（主机，端口）来建立连接，其中参数`host`是主机名，可以是字符串格式、互联网域表示法或IPv4地址格式，参数`port`是用于通信的端口号。'
- en: '**Socket type**: The socket type is represented through several constants: `SOCK_STREAM`,
    `SOCK_DGRAM`, `SOCK_RAW`, `SOCK_RDM`, and `SOCK_SEQPACKET`. We will use the most
    generally used socket type, `SOCK_STREAM`, in this application.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套接字类型**：套接字类型通过几个常量表示：`SOCK_STREAM`、`SOCK_DGRAM`、`SOCK_RAW`、`SOCK_RDM`和`SOCK_SEQPACKET`。在本应用程序中，我们将使用最常用的套接字类型`SOCK_STREAM`。'
- en: 'The `setsockopt()` method is used in the application for setting the value
    of the given socket option. It includes the following two essential parameters:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中使用`setsockopt()`方法设置给定套接字选项的值。它包括以下两个基本参数：
- en: '`SOL_SOCKET`: This parameter is the socket layer itself. It is used for protocol-independent
    options.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOL_SOCKET`：此参数是套接字层本身。它用于协议无关的选项。'
- en: '`SO_REUSEADDR`: This parameter allows other sockets to `bind()` to this port
    unless there is an active listening socket bound to the port already.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SO_REUSEADDR`：此参数允许其他套接字`bind()`到此端口，除非已经有一个活动的监听套接字绑定到该端口。'
- en: You can see in the earlier code that a `ServerThread` class is created, which
    inherits the `Thread` class of Python's threading module. The `run()` function
    is overridden where the `TCP_IP` and `TCP_HOST` variables are defined and `tcpServer`
    is bound with these variables.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在先前的代码中看到，创建了一个`ServerThread`类，它继承了Python的线程模块的`Thread`类。`run()`函数被重写，其中定义了`TCP_IP`和`TCP_HOST`变量，并且`tcpServer`与这些变量绑定。
- en: Thereafter, the server waits to see whether any client connection is made. For
    each new client connection, the server creates a new `ClientThread` inside the
    `while` loop. This is because creating a new thread for each client will not block
    the GUI functionality of the server. Finally, the threads are joined.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，服务器等待看是否有任何客户端连接。对于每个新的客户端连接，服务器在`while`循环内创建一个新的`ClientThread`。这是因为为每个客户端创建一个新线程不会阻塞服务器的GUI功能。最后，线程被连接。
- en: Establishing client-server communication
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立客户端-服务器通信
- en: In this recipe, we will learn to make a client and will see how it can send
    messages to the server. The main idea is to understand how a message is sent,
    how the server listens to the port, and how communication is established between
    the two.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何制作一个客户端，并看到它如何向服务器发送消息。主要思想是理解消息是如何发送的，服务器如何监听端口，以及两者之间的通信是如何建立的。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To send messages to the server, we will be making use of the Line Edit and
    Push Button widgets. The message written in the Line Edit widget will be passed
    to the server on the click of the push button. Here is the step-by-step procedure
    for creating a client application:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要向服务器发送消息，我们将使用`LineEdit`和`PushButton`小部件。在单击推送按钮时，LineEdit小部件中编写的消息将传递到服务器。以下是创建客户端应用程序的逐步过程：
- en: Create another application based on the Dialog without Buttons template.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于没有按钮的对话框模板创建另一个应用程序。
- en: Add `QLabel`, `QTextEdit`, `QLineEdit`, and `QPushButton` to the form by dragging
    and dropping the Label, Text Edit, Line Edit, and Push Button widgets on the form.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将Label、TextEdit、LineEdit和PushButton小部件拖放到表单上，向表单添加`QLabel`、`QTextEdit`、`QLineEdit`和`QPushButton`。
- en: Set the text property of the Label widget to `Client`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Label小部件的文本属性设置为`Client`。
- en: Set the text property of the Push Button widget to `Send`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将PushButton小部件的文本属性设置为`Send`。
- en: Set the objectName property of the Text Edit widget to `textEditMessages`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将TextEdit小部件的objectName属性设置为`textEditMessages`。
- en: Set the objectName property of the Line Edit widget to `lineEditMessage`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将LineEdit小部件的objectName属性设置为`lineEditMessage`。
- en: Set the Push Button widget to `pushButtonSend`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将PushButton小部件设置为`pushButtonSend`。
- en: Save the application by name as `demoClient.ui`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序保存为`demoClient.ui`。
- en: 'The form will now appear as shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表单现在将显示如下截图所示：
- en: '![](assets/f513ff3a-a1bc-4cb3-8baf-e2b9e965d3f0.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f513ff3a-a1bc-4cb3-8baf-e2b9e965d3f0.png)'
- en: The user interface created with Qt Designer is stored in a `.ui` file, which
    is an XML file, and needs to be converted into Python code. The code of the autogenerated
    file, `demoClient.py`, can be seen in the source code bundle of this book. To
    use the GUI created in the `demoClient.py` file, it needs to be imported into
    another Python file that will use the GUI and will transmit data from the server
    to the client and vice versa.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Qt Designer创建的用户界面存储在`.ui`文件中，这是一个XML文件，需要转换为Python代码。自动生成的文件`demoClient.py`的代码可以在本书的源代码包中找到。要使用`demoClient.py`文件中创建的GUI，需要将其导入到另一个Python文件中，该文件将使用GUI并在服务器和客户端之间传输数据。
- en: 'Create another Python file with the name `callServer.pyw` and import the `demoServer.py`
    code into it. The code in the `callServer.pyw` script is as shown here:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`callServer.pyw`的Python文件，并将`demoServer.py`代码导入其中。`callServer.pyw`脚本中的代码如下所示：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the `ClientThread` class, the `run` function is overridden. In the `run`
    function, each client waits for data received from the server and displays that
    data in the Text Edit widget. A `window` class object is passed to the `ServerThread`
    class, which passes that object to `ClientThread`, which, in turn, uses it to
    access the content written in the Line Edit element.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ClientThread`类中，`run`函数被重写。在`run`函数中，每个客户端等待从服务器接收的数据，并在文本编辑小部件中显示该数据。一个`window`类对象被传递给`ServerThread`类，后者将该对象传递给`ClientThread`，后者又使用它来访问在行编辑元素中编写的内容。
- en: The received data is decoded because the data received is in the form of bytes,
    which have to be converted into strings using UTF-8 encoding.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到的数据被解码，因为接收到的数据是以字节形式，必须使用UTF-8编码转换为字符串。
- en: 'The `demoClient.py` file that we generated in the preceding section needs to
    be treated as a header file and needs to be imported into another Python file
    that will use the GUI of the header file and transmit data from the client to
    the server and vice versa. So, let''s create another Python file with the name
    `callClient.pyw` and import the `demoClient.py` code into it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分生成的`demoClient.py`文件需要被视为一个头文件，并且需要被导入到另一个Python文件中，该文件将使用头文件的GUI并在客户端和服务器之间传输数据。因此，让我们创建另一个名为`callClient.pyw`的Python文件，并将`demoClient.py`代码导入其中：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A `ClientThread` class is a class that inherits the `Thread` class and overrides
    the `run` function. In the `run` function, you fetch the IP address of the server
    by invoking the `hostname` method on the `socket` class; and, using port `80`,
    the client tries to connect to the server. Once a connection with the server is
    made, the client tries to receive data from the server inside the while loop.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClientThread`类是一个继承`Thread`类并重写`run`函数的类。在`run`函数中，通过在`socket`类上调用`hostname`方法来获取服务器的IP地址；并且，使用端口`80`，客户端尝试连接到服务器。一旦与服务器建立连接，客户端尝试在while循环内从服务器接收数据。'
- en: On receiving the data from the server, the data is converted into string format
    from byte format and displayed in the Text Edit widget.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器接收数据后，将数据从字节格式转换为字符串格式，并显示在文本编辑小部件中。
- en: 'We need to run both applications to see client-server communication. On running
    the `callServer.pyw` file, you get the output shown on the left side of the following
    screenshot, and on running the `callClient.pyw` file, you get the output shown
    on the right side. Both are same; only the labels at the top distinguish them:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要运行两个应用程序来查看客户端-服务器通信。运行`callServer.pyw`文件，您将在以下截图的左侧看到输出，运行`callClient.pyw`文件，您将在右侧看到输出。两者相同；只有顶部的标签有所区别：
- en: '![](assets/61308f2b-a3b2-4762-8c4f-ed9a4dfe39fc.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/61308f2b-a3b2-4762-8c4f-ed9a4dfe39fc.png)'
- en: 'The user can type the text in the Line Edit box at the bottom, followed by
    pressing the Send button. On pressing the Send button, the text entered in the
    Line Edit widget will appear in the Text Edit box of both server and client applications.
    Text is prefixed with `Server:` to indicate that the text is sent from the server,
    as shown in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以在底部的行编辑框中输入文本，然后按下发送按钮。按下发送按钮后，输入的文本将出现在服务器和客户端应用程序的文本编辑框中。文本以`Server:`为前缀，以指示该文本是从服务器发送的，如下截图所示：
- en: '![](assets/e91410d8-0334-44a0-8414-ba6f766587fe.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e91410d8-0334-44a0-8414-ba6f766587fe.png)'
- en: 'Similarly, if text is written in the Line Edit widget of the client application
    followed by pressing the Send button, the text will appear in the Text Edit widget
    of both applications. The text will be prefixed with `Client:` to indicate that
    the text has been sent from the client, as shown in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果在客户端应用程序的行编辑小部件中输入文本，然后按下发送按钮，文本将出现在两个应用程序的文本编辑小部件中。文本将以`Client:`为前缀，以指示该文本已从客户端发送，如下截图所示：
- en: '![](assets/17844150-0e96-41b8-9d78-ff12122757dd.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/17844150-0e96-41b8-9d78-ff12122757dd.png)'
- en: Creating a dockable and floatable sign-in form
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个可停靠和可浮动的登录表单
- en: In this recipe, we will learn to create a sign-in form that will ask for the
    email address and password of the user for authentication. This sign-in form is
    different from the usual sign-in form, in the sense that it is a dockable form.
    That is, you can dock this sign-in form to any of the four sides of the window—top,
    left, right, and bottom and can even use it as a floatable form. This dockable
    sign-in form will be created using the Dock widget, so let's get a quick idea
    about the Dock widget.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习创建一个登录表单，该表单将要求用户输入电子邮件地址和密码以进行身份验证。这个登录表单不同于通常的登录表单，因为它是一个可停靠的表单。也就是说，您可以将这个登录表单停靠在窗口的四个边缘之一——顶部、左侧、右侧和底部，甚至可以将其用作可浮动的表单。这个可停靠的登录表单将使用Dock小部件创建，所以让我们快速了解一下Dock小部件。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To create a detachable set of widgets or tools, you need a Dock widget. A Dock
    widget is created with the `QDockWidget` class and is a container that has a title
    bar and buttons at the top to size it. The Dock widget, which contains a collection
    of widgets or tools, can be closed, docked in the dock area, or floated and placed
    anywhere on the desktop. The Dock widget can be docked in different dock areas,
    such as `LeftDockWidgetArea`, `RightDockWidgetArea`, `TopDockWidgetArea`, and
    `BottomDockWidgetArea`. The `TopDockWidgetArea` dock area is below the toolbar.
    You can also restrict the dock areas where the Dock widget can be docked. When
    you do so, the Dock widget can be docked to the specified dock areas only. When
    a Dock window is dragged out of the dock area, it becomes a free-floating window.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一组可分离的小部件或工具，您需要一个Dock小部件。Dock小部件是使用`QDockWidget`类创建的，它是一个带有标题栏和顶部按钮的容器，用于调整大小。包含一组小部件或工具的Dock小部件可以关闭、停靠在停靠区域中，或者浮动并放置在桌面的任何位置。Dock小部件可以停靠在不同的停靠区域，例如`LeftDockWidgetArea`、`RightDockWidgetArea`、`TopDockWidgetArea`和`BottomDockWidgetArea`。`TopDockWidgetArea`停靠区域位于工具栏下方。您还可以限制Dock小部件可以停靠的停靠区域。这样做后，Dock小部件只能停靠在指定的停靠区域。当将Dock窗口拖出停靠区域时，它将成为一个自由浮动的窗口。
- en: 'Here are the properties that control the movement of the Dock widget and the
    appearance of its title bar and other buttons:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是控制Dock小部件的移动以及其标题栏和其他按钮外观的属性：
- en: '| **Property** | **Description** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `DockWidgetClosable` |  Makes the Dock widget closable. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `DockWidgetClosable` | 使Dock小部件可关闭。 |'
- en: '| `DockWidgetMovable` | Makes the Dock widget movable between dock areas. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `DockWidgetMovable` | 使Dock小部件在停靠区域之间可移动。 |'
- en: '| `DockWidgetFloatable` | Makes the Dock widget floatable, that is, the Dock
    widget can be detached from the main window and floated on the desktop. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `DockWidgetFloatable` | 使Dock小部件可浮动，也就是说，Dock小部件可以从主窗口中分离并在桌面上浮动。 |'
- en: '| `DockWidgetVerticalTitleBar` | Displays a vertical title bar on the left
    side of the Dock widget. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `DockWidgetVerticalTitleBar` | 在Dock小部件的左侧显示垂直标题栏。 |'
- en: '| `AllDockWidgetFeatures` | It switches on properties such as `DockWidgetClosable`,
    `DockWidgetMovable`, and `DockWidgetFloatable`, that is, the Dock widget can be
    closed, moved, or floated. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `AllDockWidgetFeatures` | 它打开属性，如`DockWidgetClosable`，`DockWidgetMovable`和`DockWidgetFloatable`，也就是说，Dock小部件可以关闭，移动或浮动。
    |'
- en: '| `NoDockWidgetFeatures` | If selected, the Dock widget cannot be closed, moved,
    or floated. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `NoDockWidgetFeatures` | 如果选择，Dock小部件将无法关闭，移动或浮动。 |'
- en: In order to make a dockable sign-in form for this recipe, we will be making
    use of the Dock widget and a few more widgets. Let's see the step-by-step procedure
    for doing this.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作可停靠的登录表单，我们将使用Dock小部件和其他一些小部件。让我们看看逐步的操作步骤。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s make a small sign-in form in the Dock widget that will prompt the user
    for their email address and password. Being dockable, this sign-in form can be
    moved anywhere on the screen and can be made floatable. Here are the steps to
    create this application:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Dock小部件中制作一个小的登录表单，提示用户输入其电子邮件地址和密码。由于可停靠，此登录表单可以移动到屏幕上的任何位置，并且可以浮动。以下是创建此应用程序的步骤：
- en: Launch Qt Designer and create a new Main Window application.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Qt Designer并创建一个新的主窗口应用程序。
- en: Drag and drop a Dock widget onto the form.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个Dock小部件拖放到表单上。
- en: Drag and drop the widgets that you want to be available in dock areas or as
    floating windows in the Dock widget.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖放您希望在停靠区域或作为浮动窗口在Dock小部件中可用的小部件。
- en: Drag and drop three Label widgets, two Line Edit widgets, and a Push Button
    widget on the Dock widget.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Dock小部件上拖放三个Label小部件，两个LineEdit小部件和一个PushButton小部件。
- en: Set the text property of the three Label widgets to `Sign In`, `Email Address`,
    and `Password`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三个Label小部件的文本属性设置为`登录`，`电子邮件地址`和`密码`。
- en: Set the text property of the Push Button widget to `Sign In`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Push Button小部件的文本属性设置为`登录`。
- en: We will not set the objectName property of the Line Edit and Push Button widgets
    and will not provide any code for the Push Button widget, because the purpose
    of this application is to understand how the Dock widget works.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将不设置LineEdit和PushButton小部件的objectName属性，并且不会为PushButton小部件提供任何代码，因为此应用程序的目的是了解Dock小部件的工作原理。
- en: Save the application as `demoDockWidget.ui`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序保存为`demoDockWidget.ui`。
- en: 'The form will appear as shown in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 表单将显示如下屏幕截图所示：
- en: '![](assets/f23980de-4068-42d2-aca1-6e4cf5dfcd66.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f23980de-4068-42d2-aca1-6e4cf5dfcd66.png)'
- en: 'To enable all features in the Dock widget, select it and check its AllDockWidgetFeatures
    property in the features section of the Property Editor window, as shown in the
    following screenshot:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用Dock小部件中的所有功能，请选择它并在属性编辑器窗口的功能部分中检查其AllDockWidgetFeatures属性，如下图所示：
- en: '![](assets/fca7bb78-58e2-446e-a112-ca985a7a692c.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fca7bb78-58e2-446e-a112-ca985a7a692c.png)'
- en: In the preceding screenshot, the AllDockWidgetFeatures property is to make the
    Dock widget closable, movable in the dock, and floatable anywhere on the Desktop.
    If the NoDockWidgetFeatures property is selected, then all other properties in
    the features section are unchecked automatically. That means all buttons will
    disappear from the Dock widget, and you will not be able to close or move it.
    If you want the Dock widget to appear as floatable on application startup, check
    the floating property just above the features section in the Property Editor window.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述屏幕截图中，AllDockWidgetFeatures属性是使Dock小部件可关闭，在停靠时可移动，并且可以在桌面的任何位置浮动。如果选择了NoDockWidgetFeatures属性，则功能部分中的所有其他属性将自动取消选中。这意味着所有按钮将从Dock小部件中消失，您将无法关闭或移动它。如果希望Dock小部件在应用程序启动时显示为可浮动，请在属性编辑器窗口中的功能部分上方检查浮动属性。
- en: 'Look at the following screenshot depicting various features and constraints
    on the Dock widget:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下屏幕截图，显示了Dock小部件上的各种功能和约束：
- en: '![](assets/8a6db2f9-92ff-4fb9-9d8c-92b896669a56.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8a6db2f9-92ff-4fb9-9d8c-92b896669a56.png)'
- en: 'Perform the following steps to apply the desired features and constraints to
    the Dock widget:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤，将所需的功能和约束应用于Dock小部件：
- en: Check the AllDockWidgetAreas option in the allowedAreas section to enable the
    Dock widget to be docked in all of the left, right, top, and bottom Dock widget
    areas.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在allowedAreas部分中检查AllDockWidgetAreas选项，以使Dock小部件可以停靠在左侧，右侧，顶部和底部的所有Dock小部件区域。
- en: Also, by using the windowTitle property in the Property Editor window, set the
    title of the dock window to Dockable Sign In Form, as shown in the preceding screenshot.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，通过在属性编辑器窗口中使用windowTitle属性，将停靠窗口的标题设置为Dockable Sign In Form，如上图所示。
- en: Check the docked property because it is an essential property to make a Dock
    widget dockable. If the docked property is not checked, the Dock widget cannot
    be docked to any of the allowable areas.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查停靠属性，因为这是使Dock小部件可停靠的重要属性。如果未选中停靠属性，则Dock小部件无法停靠到任何允许的区域。
- en: Leave the dockWidgetArea property with its default value, LeftDockWidgetArea.
    The dockWidgetArea property determines the location where you want the Dock widget
    to appear as docked when the application is launched. The LeftDockWidgetArea value
    for the dockWidgetArea property will make the Dock widget first appear as docked
    in the left Dock widget area. If the NoDockWidgetArea property is set in the allowedAreas
    section, then all other properties in the allowedAreas section are unselected
    automatically. Consequently, you can move the Dock window anywhere on the desktop,
    but you cannot dock it in the dock areas of the Main Window template. The user
    interface created with Qt Designer is stored in a `.ui` file, which is an XML
    file, and needs to be converted into Python code. On the application of the `pyuic5`
    command line utility on the XML file, the generated file is a Python script file,
    `demoDockWidget.py`. You can see the code of the generated `demoDockWidget.py` file
    in the source code bundle of this book.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将dockWidgetArea属性保留其默认值LeftDockWidgetArea。dockWidgetArea属性确定您希望停靠窗口小部件在应用程序启动时出现为停靠的位置。dockWidgetArea属性的LeftDockWidgetArea值将使停靠窗口小部件首先出现为停靠在左侧停靠窗口区域。如果在allowedAreas部分设置了NoDockWidgetArea属性，则allowedAreas部分中的所有其他属性将自动取消选择。因此，您可以将停靠窗口移动到桌面的任何位置，但不能将其停靠在主窗口模板的停靠区域中。使用Qt
    Designer创建的用户界面存储在一个`.ui`文件中，这是一个XML文件，需要转换为Python代码。在XML文件上应用`pyuic5`命令行实用程序后，生成的文件是一个Python脚本文件`demoDockWidget.py`。您可以在本书的源代码包中看到生成的`demoDockWidget.py`文件的代码。
- en: Treat the code in the `demoDockWidget.py` file as a header file, and import
    it into the file from which you will invoke its user interface design.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`demoDockWidget.py`文件中的代码视为头文件，并将其导入到将调用其用户界面设计的文件中。
- en: 'Create another Python file with the name `callDockWidget.pyw` and import the
    `demoDockWidget.py` code into it:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`callDockWidget.pyw`的Python文件，并将`demoDockWidget.py`的代码导入其中：
- en: '[PRE4]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As you can see in the preceding code, the necessary modules are imported. An
    `AppWindow` class is created that inherits from the base class, `QMainWindow`.
    The default constructor for `QMainWindow` is invoked.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，导入了必要的模块。创建了一个`AppWindow`类，它继承自基类`QMainWindow`。调用了`QMainWindow`的默认构造函数。
- en: Because every PyQt5 application needs an application object, in the preceding
    code, an application object was created with the name app by invoking the `QApplication()`
    method. For passing command line arguments and other external attributes to the
    application, the `sys.argv` parameter was passed as a parameter to the `QApplication()`
    method. The `sys.argv` parameter contains command line arguments and other external
    attributes, if there are any. In order to display the widgets defined in the interface,
    an instance of the `AppWindow` class was created with the name `w`, and the `show()`
    method was invoked on it. To exit the application and return the code to Python
    interpreter that might be used for error handling, the `sys.exit()` method was
    called.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个PyQt5应用程序都需要一个应用程序对象，在上面的代码中，通过调用`QApplication()`方法创建了一个名为app的应用程序对象。将`sys.argv`参数作为参数传递给`QApplication()`方法，以传递命令行参数和其他外部属性给应用程序。`sys.argv`参数包含命令行参数和其他外部属性（如果有的话）。为了显示界面中定义的小部件，创建了一个名为`w`的`AppWindow`类的实例，并在其上调用了`show()`方法。为了退出应用程序并将代码返回给可能用于错误处理的Python解释器，调用了`sys.exit()`方法。
- en: 'When the application is executed, you get a Dock widget that is docked to the
    left dockable area by default, as shown in the following screenshot. This is because
    you have assigned the `LeftDockWidgetArea` value to the `dockWidgetArea` property
    of the Dock widget:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序执行时，默认情况下会得到一个停靠在左侧可停靠区域的停靠窗口小部件，如下面的屏幕截图所示。这是因为您已经将`dockWidgetArea`属性的值分配给了`LeftDockWidgetArea`：
- en: '![](assets/81e13139-7926-4a9a-88b9-0681a52e6606.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/81e13139-7926-4a9a-88b9-0681a52e6606.png)'
- en: 'The widgets inside the Dock widget are not completely visible, as the default
    left and dockable areas are narrower than the widgets placed in the Dock widget.
    So, you can drag the right border of the Dock widget to make all the contained
    widgets visible, as shown in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 停靠窗口小部件内的小部件不完全可见，因为默认的左侧和可停靠区域比停靠窗口小部件中放置的小部件要窄。因此，您可以拖动停靠窗口小部件的右边框，使所有包含的小部件可见，如下面的屏幕截图所示：
- en: '![](assets/ede66a10-a27a-4042-9199-7976711f57af.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ede66a10-a27a-4042-9199-7976711f57af.png)'
- en: 'You can drag the widget to any area. If you drag it to the top, it will be
    docked in the `TopDockWidgetArea` dock area, as shown in the following screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将小部件拖动到任何区域。如果将其拖动到顶部，则会停靠在`TopDockWidgetArea`停靠区域，如下面的屏幕截图所示：
- en: '![](assets/b2259d77-1078-4302-9c9c-e1f24625a314.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b2259d77-1078-4302-9c9c-e1f24625a314.png)'
- en: Similarly, when the Dock widget is dragged to the right, it will be docked in
    the `RightDockWidgetArea`
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当将停靠窗口小部件拖动到右侧时，它将停靠在`RightDockWidgetArea`中
- en: 'You can drag the Dock widget outside the Main Window template to make it an
    independent floating window. The Dock widget will appear as an independent floating
    window and can be moved anywhere on the desktop:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将停靠窗口小部件拖动到主窗口模板之外，使其成为一个独立的浮动窗口。停靠窗口小部件将显示为一个独立的浮动窗口，并可以移动到桌面的任何位置：
- en: '![](assets/f01528da-0749-4beb-9fb3-8c921e4cf9c5.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f01528da-0749-4beb-9fb3-8c921e4cf9c5.png)'
- en: Multiple Document Interface
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多文档界面
- en: In this recipe, we will learn how to create an application that will display
    more than one document at a time. Not only will we be able to manage more than
    one document, but we will also learn to arrange the documents in different formats.
    We will be able to manage more than one document using a concept called Multiple
    Document Interface, so let's see a quick introduction to this.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何创建一个应用程序，可以同时显示多个文档。我们不仅能够管理多个文档，还将学会以不同的格式排列这些文档。我们将能够使用称为多文档界面的概念来管理多个文档，让我们快速了解一下这个概念。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Usually, an application provides one document per main window and such applications
    are said to be **Single Document Interface** (**SDI**) applications. As the name
    suggests, a **Multiple Document Interface** (**MDI**) application is able to display
    several documents. An MDI application consists of a main window along with a menu
    bar, a toolbar, and a central space. Several documents can be displayed in the
    central space, where each document can be managed through individual child window
    widgets; in MDI, several documents can be displayed and each document is displayed
    in its own window. These child windows are also known as subwindows.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个应用程序提供一个主窗口对应一个文档，这样的应用程序被称为**单文档界面**（**SDI**）应用程序。顾名思义，**多文档界面**（**MDI**）应用程序能够显示多个文档。MDI应用程序由一个主窗口以及一个菜单栏、一个工具栏和一个中心空间组成。多个文档可以显示在中心空间中，每个文档可以通过各自的子窗口小部件进行管理；在MDI中，可以显示多个文档，每个文档都显示在自己的窗口中。这些子窗口也被称为子窗口。
- en: MDI is implemented by making use of the `MdiArea` widget. The `MdiArea` widget
    provides an area where child windows or subwindows are displayed. A subwindow
    has a title and buttons to show, hide, and maximize its size. Each subwindow can
    display an individual document. The subwindows can be arranged in a cascade or
    tile pattern by setting the respective property of the `MdiArea` widget. The `MdiArea`
    widget is an instance of the `QMdiArea` class and the subwindows are instances
    of `QMdiSubWindow`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: MDI是通过使用`MdiArea`小部件来实现的。`MdiArea`小部件提供了一个区域，用于显示子窗口。子窗口有标题和按钮，用于显示、隐藏和最大化其大小。每个子窗口可以显示一个单独的文档。可以通过设置`MdiArea`小部件的相应属性，将子窗口以级联或平铺方式排列。`MdiArea`小部件是`QMdiArea`类的一个实例，子窗口是`QMdiSubWindow`的实例。
- en: 'Here are the methods provided by `QMdiArea`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`QMdiArea`提供的方法：
- en: '`subWindowList()`: This method returns a list of all subwindows in the MDI
    area. The returned list is arranged in the order that is set through the `WindowOrder()`
    function.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subWindowList()`: 这个方法返回MDI区域中所有子窗口的列表。返回的列表按照通过`WindowOrder()`函数设置的顺序排列。'
- en: '`WindowOrder`: This static variable sets the criteria for ordering the list
    of child windows. Following are the valid values that can be assigned to this
    static variable:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WindowOrder`：这个静态变量设置了对子窗口列表进行排序的标准。以下是可以分配给这个静态变量的有效值：'
- en: '`CreationOrder`: The windows are returned in the order of their creation. This
    is the default order.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreationOrder`：窗口按照它们创建的顺序返回。这是默认顺序。'
- en: '`StackingOrder`: The windows are returned in the order in which they are stacked,
    with the topmost window last in the list.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackingOrder`：窗口按照它们叠放的顺序返回，最上面的窗口最后出现在列表中。'
- en: '`ActivationHistoryOrder`: The windows are returned in the order in which they
    were activated.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivationHistoryOrder`：窗口按照它们被激活的顺序返回。'
- en: '`activateNextSubWindow()`: This method sets the focus to the next window in
    the list of child windows. The current window order determines the next window
    to be activated.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activateNextSubWindow()`: 这个方法将焦点设置为子窗口列表中的下一个窗口。当前窗口的顺序决定了要激活的下一个窗口。'
- en: '`activatePreviousSubWindow()`: This method sets the focus to the previous window
    in the list of child windows. The current window order determines the previous
    window to be activated.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activatePreviousSubWindow()`: 这个方法将焦点设置为子窗口列表中的上一个窗口。当前窗口的顺序决定了要激活的上一个窗口。'
- en: '`cascadeSubWindows()`: This method arranges subwindows in cascade fashion.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cascadeSubWindows()`: 这个方法以级联方式排列子窗口。'
- en: '`tileSubWindows()`: This method arranges subwindows in tile fashion.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tileSubWindows()`: 这个方法以平铺方式排列子窗口。'
- en: '`closeAllSubWindows()`: This method closes all subwindows.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`closeAllSubWindows()`: 这个方法关闭所有子窗口。'
- en: '`setViewMode()`: This method sets the view mode of the MDI area. The subwindows
    can be viewed in two modes, SubWindow View and Tabbed View:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setViewMode()`: 这个方法设置MDI区域的视图模式。子窗口可以以两种模式查看，子窗口视图和选项卡视图：'
- en: 'SubWindow View: This method displays subwindows with window frames (default).
    You can see the content of more than one subwindow if arranged in tile fashion.
    It is also represented by a constant value, `0`.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子窗口视图：这个方法显示带有窗口框架的子窗口（默认）。如果以平铺方式排列，可以看到多个子窗口的内容。它还由一个常量值`0`表示。
- en: 'Tabbed View: Displays subwindows with tabs in a tab bar. Only the content of
    one subwindow contents can be seen at a time. It is also represented by a constant
    value, `1`.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项卡视图：在选项卡栏中显示带有选项卡的子窗口。一次只能看到一个子窗口的内容。它还由一个常量值`1`表示。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s create an application that consists of two documents, and each document
    will be displayed via its individual subwindow. We will learn how to arrange and
    view these subwindows as desired:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个应用程序，其中包含两个文档，每个文档将通过其各自的子窗口显示。我们将学习如何按需排列和查看这些子窗口：
- en: Launch Qt Designer and create a new Main Window application.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Qt Designer并创建一个新的主窗口应用程序。
- en: Drag and drop a `MdiArea` widget onto the form.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MdiArea`小部件拖放到表单上。
- en: Right-click on the widget and select Add Subwindow from the context menu to
    add a subwindow to the `MdiArea` widget.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击小部件，从上下文菜单中选择“添加子窗口”以将子窗口添加到`MdiArea`小部件中。
- en: 'When the subwindow is added to the `MdiArea` widget, the widget appears as
    the dark background, as shown in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当子窗口添加到`MdiArea`小部件时，该小部件将显示为深色背景，如下面的屏幕截图所示：
- en: '![](assets/bfb235c6-0e67-49ea-aad6-142b11a6c7d2.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bfb235c6-0e67-49ea-aad6-142b11a6c7d2.png)'
- en: Let's, right-click again on the `MdiArea` widget and add one more subwindow
    to it.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次右键单击`MdiArea`小部件，并向其添加一个子窗口。
- en: To know which one is the first and which one is the second subwindow, drag and
    drop a Label widget onto each subwindow.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要知道哪一个是第一个，哪一个是第二个子窗口，可以在每个子窗口上拖放一个Label小部件。
- en: Set the text property of the Label widget placed in the first subwindow to `First
    subwindow`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将放置在第一个子窗口中的Label小部件的文本属性设置为“First subwindow”。
- en: 'Set the text property of the Label widget placed in the second subwindow to
    `Second subwindow`, as shown in the following screenshot:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将放置在第二个子窗口中的Label小部件的文本属性设置为“Second subwindow”，如下面的屏幕截图所示：
- en: '![](assets/4847a248-744d-47d0-b837-3ddeac8fd0dd.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4847a248-744d-47d0-b837-3ddeac8fd0dd.png)'
- en: 'The `MdiArea` widget displays the documents placed in its subwindows in the
    following two modes:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`MdiArea`小部件以以下两种模式显示放置在其子窗口中的文档：'
- en: 'SubWindow View: This is the default view mode. The subwindows can be arranged
    in cascade or tile fashion in this view mode. When subwindows are arranged in
    tile fashion, you can see the content of more than one subwindow simultaneously.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子窗口视图：这是默认视图模式。在此视图模式下，子窗口可以以级联或平铺方式排列。当子窗口以平铺方式排列时，可以同时看到多个子窗口的内容。
- en: 'Tabbed View: In this mode, several tabs appear in a tab bar. When a tab is
    selected, the subwindow associated with it is displayed. Only the content of one
    subwindow can be seen at a time.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项卡视图：在此模式下，选项卡栏中会显示多个选项卡。选择选项卡时，将显示与之关联的子窗口。一次只能看到一个子窗口的内容。
- en: 'To activate the SubWindow View and Tabbed View modes through the menu options,
    double-click the Type Here placeholder in the menu in the menu bar and add two
    entries to it: SubWindow View and Tabbed View.'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过菜单选项激活子窗口视图和选项卡视图模式，双击菜单栏中的Type Here占位符，并向其添加两个条目：子窗口视图和选项卡视图。
- en: 'Also, to see how the subwindows appear when arranged in cascade and tile fashion,
    add two more menu items, Cascade View and Tile View, to the menu bar as shown
    in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了查看子窗口以级联和平铺方式排列时的外观，将两个菜单项Cascade View和Tile View添加到菜单栏中，如下面的屏幕截图所示：
- en: '![](assets/1aed9dce-6c6e-4c3c-9dc7-9aacb6562892.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1aed9dce-6c6e-4c3c-9dc7-9aacb6562892.png)'
- en: 'Save the application as `demoMDI.ui`. The user interface created with Qt Designer
    is stored in a `.ui` file, which is an XML file, and needs to be converted into
    Python code.On the application of the `pyuic5` command line utility, the `.ui`
    (XML) file will be converted into Python code:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序保存为`demoMDI.ui`。使用Qt Designer创建的用户界面存储在`.ui`文件中，这是一个XML文件，需要转换为Python代码。在应用`pyuic5`命令行实用程序时，`.ui`（XML）文件将被转换为Python代码：
- en: '[PRE5]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see the generated Python code, `demoMDI.py`, in the source code bundle
    of this book.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的源代码包中看到生成的Python代码`demoMDI.py`。
- en: 'Treat the code in the `demoMDI.py` file as a header file, and you will import
    it to the file from which you will invoke its user interface design. The user
    interface design in the previous code includes `MdiArea` to display the subwindows
    created in it, along with their respective widgets. The Python script that we
    are going to create will contain the code for the menu options to do different
    tasks, such as cascading and tiling the subwindows, changing the view mode from
    SubWindow View to Tabbed View, and vice versa. Let''s name that Python script `callMDI.pyw`
    and import the `demoMDI.py` code into it:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`demoMDI.py`文件中的代码视为头文件，并将其导入到您将调用其用户界面设计的文件中。前面的代码中的用户界面设计包括`MdiArea`，用于显示其中创建的子窗口以及它们各自的小部件。我们将要创建的Python脚本将包含用于执行不同任务的菜单选项的代码，例如级联和平铺子窗口，将视图模式从子窗口视图更改为选项卡视图，反之亦然。让我们将该Python脚本命名为`callMDI.pyw`，并将`demoMDI.py`代码导入其中：
- en: '[PRE6]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the preceding code, you can see that the two subwindows with the default
    objectName properties, `subwindow` and `subwindow_2`, are added to the `MdiArea`
    widget. After that, the four menu options with objectName properties, `actionSubWindow_View`,
    `actionTabbed_View`, `actionCascade_View`, and `actionTile_View` are connected
    to the four methods `SubWindow_View`, `Tabbed_View`, `cascadeArrange`, and `tileArrange`
    respectively. Hence, when the SubWindow View menu option is selected by the user,
    the `SubWindow_View` method will be invoked. In the `SubWindow_View` method, the
    SubWindow View mode is activated by passing the `0` constant value to the `setViewMode` method
    of the `MdiArea` widget. The SubWindow View displays subwindows with window frames.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，您可以看到具有默认objectName属性`subwindow`和`subwindow_2`的两个子窗口被添加到`MdiArea`小部件中。之后，具有objectName属性`actionSubWindow_View`、`actionTabbed_View`、`actionCascade_View`和`actionTile_View`的四个菜单选项分别连接到四个方法`SubWindow_View`、`Tabbed_View`、`cascadeArrange`和`tileArrange`。因此，当用户选择子窗口视图菜单选项时，将调用`SubWindow_View`方法。在`SubWindow_View`方法中，通过将`0`常量值传递给`MdiArea`小部件的`setViewMode`方法来激活子窗口视图模式。子窗口视图显示带有窗口框架的子窗口。
- en: Similarly, when the Tabbed View menu option is selected by the user, the `Tabbed_View` method
    will be invoked. In the `Tabbed_View` method, the Tabbed View mode is activated
    by passing the `1` constant value to the `setViewMode` method of the `MdiArea`
    widget. The Tabbed View mode displays tabs in a tab bar and on clicking a tab,
    the associated subwindow will be displayed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当用户选择选项卡视图菜单选项时，将调用`Tabbed_View`方法。在`Tabbed_View`方法中，通过将`1`常量值传递给`MdiArea`小部件的`setViewMode`方法来激活选项卡视图模式。选项卡视图模式在选项卡栏中显示选项卡，单击选项卡时，将显示关联的子窗口。
- en: When the Cascade View menu option is selected, the `cascadeArrange` method is
    invoked, which in turn invokes the `cascadeSubWindows` method of the `MdiArea`
    widget to arrange subwindows in cascade form.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 选择级联视图菜单选项时，将调用`cascadeArrange`方法，该方法又调用`MdiArea`小部件的`cascadeSubWindows`方法以级联形式排列子窗口。
- en: When the Tile View menu option is selected, the `tileArrange` method is invoked,
    which in turn invokes the `tileSubWindows` method of the `MdiArea` widget to arrange
    subwindows in tile form.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 选择平铺视图菜单选项时，将调用`tileArrange`方法，该方法又调用`MdiArea`小部件的`tileSubWindows`方法以平铺形式排列子窗口。
- en: 'On running the application, the subwindows initially appear in shrunken mode
    in the `MdiArea` widget, as shown in the following screenshot. You can see the
    subwindows along with their titles and minimize, maximize, and close buttons:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序时，子窗口最初以缩小模式出现在`MdiArea`小部件中，如下面的屏幕截图所示。您可以看到子窗口以及它们的标题和最小化、最大化和关闭按钮：
- en: '![](assets/1ebe29d9-558d-47d0-b8f1-5a58f3fc8a95.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1ebe29d9-558d-47d0-b8f1-5a58f3fc8a95.png)'
- en: 'You can drag their borders to the desired size. On selecting the first window
    from the Windows menu, a subwindow becomes active; on selecting the second window,
    the next subwindow will become active. The active subwindow appears with the brighter
    title and boundary. In the following screenshot, you can notice that the second
    subwindow is active. You can drag the boundaries of any subwindow to increase
    or decrease its size. You can also minimize a subwindow and drag the boundaries
    of another subwindow to take up the whole width of the `MdiArea` widget. If you
    select maximize in any subwindow, it will take up all the space of `MdiArea`,
    making other subwindows invisible:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以拖动它们的边框到所需的大小。在Windows菜单中选择第一个窗口时，子窗口将变为活动状态；选择第二个窗口时，下一个子窗口将变为活动状态。活动子窗口显示为更亮的标题和边界。在下面的截图中，您可以注意到第二个子窗口是活动的。您可以拖动任何子窗口的边界来增加或减少其大小。您还可以最小化一个子窗口，并拖动另一个子窗口的边界以占据整个`MdiArea`小部件的整个宽度。如果在任何子窗口中选择最大化，它将占据`MdiArea`的所有空间，使其他子窗口不可见：
- en: '![](assets/416296d6-bf06-45ad-a2d8-98efad13ec01.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/416296d6-bf06-45ad-a2d8-98efad13ec01.png)'
- en: 'On selecting Cascade, the subwindows are arranged in cascade mode, as shown
    in the following screenshot. If windows are maximized in Cascade mode, the top
    subwindow takes up the whole `MdiArea` widget, hiding other subwindows behind
    it, as shown in the following screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择级联时，子窗口以级联模式排列，如下截图所示。如果在级联模式下最大化窗口，则顶部子窗口将占据整个`MdiArea`小部件，将其他子窗口隐藏在其后，如下截图所示：
- en: '![](assets/0db471f4-3caa-4770-99c6-c1bfa496aadd.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0db471f4-3caa-4770-99c6-c1bfa496aadd.png)'
- en: 'On selecting the Tile button, the subwindows are expanded and tiled. Both subwindows
    expand equally to cover up the entire workspace, as shown in the following screenshot:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择平铺按钮时，子窗口会展开并平铺。两个子窗口均等地扩展以覆盖整个工作区，如下截图所示：
- en: '![](assets/a869236e-f6a6-4acb-acde-4a1c66edab7f.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a869236e-f6a6-4acb-acde-4a1c66edab7f.png)'
- en: 'On selecting the Tabbed View button, the `MdiArea` widget will change from
    the Subwindow view to Tabbed View. You can select the tab of any subwindow to
    make it active, as shown in the following screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择选项卡视图按钮时，`MdiArea`小部件将从子窗口视图更改为选项卡视图。您可以选择任何子窗口的选项卡使其处于活动状态，如下截图所示：
- en: '![](assets/26183590-38c9-433f-8129-cdb27e2b27b0.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/26183590-38c9-433f-8129-cdb27e2b27b0.png)'
- en: Displaying information in sections using Tab Widget
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用选项卡小部件显示信息的部分
- en: In this application, we will make a small shopping cart that will display certain
    products for sale in one tab; after selecting the desired products from the first
    tab, when the user selects the second tab, they will be prompted to enter the
    preferred payment option. The third tab will ask the user to enter the address
    for delivering the products.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们将制作一个小型购物车，它将在一个选项卡中显示某些待售产品；在用户从第一个选项卡中选择所需产品后，当用户选择第二个选项卡时，他们将被提示输入首选付款选项。第三个选项卡将要求用户输入交付产品的地址。
- en: We will use Tab Widget to enable us to select and fill in the desired information
    in chunks, so you must be wondering, what is a Tab Widget?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用选项卡小部件使我们能够选择并分块填写所需的信息，所以您一定想知道，选项卡小部件是什么？
- en: When certain information is divided into small sections, and you want to display
    the information for the section required by the user, then you need to use Tab
    Widget. In a Tab Widget container, there are a number of tabs and when the user
    selects any tab, the information assigned to that tab will be displayed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当某些信息被分成小节，并且您希望为用户显示所需部分的信息时，您需要使用选项卡小部件。在选项卡小部件容器中，有许多选项卡，当用户选择任何选项卡时，将显示分配给该选项卡的信息。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here is the step-by-step procedure to create an application that displays information
    in chunks using tabs:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是逐步创建应用程序以使用选项卡显示信息的过程：
- en: Let's create a new application based on the Dialog without Buttons template.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们基于没有按钮的对话框模板创建一个新应用程序。
- en: 'Drag and drop Tab Widget onto the form. When you drag Tab Widget onto a dialog,
    it appears with two default tab buttons, labeled Tab1 and Tab2, as shown in the
    following screenshot:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选项卡小部件拖放到表单上。当您将选项卡小部件拖放到对话框上时，它将显示两个默认选项卡按钮，标有Tab1和Tab2，如下截图所示：
- en: '![](assets/d0bb4b0d-397e-4ec6-9e3f-a24ae20c57a7.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d0bb4b0d-397e-4ec6-9e3f-a24ae20c57a7.png)'
- en: You can add more tab buttons to Tab Widget and delete existing buttons if you
    want by adding a new tab button; right-click on either tab button and select Insert
    Page from the menu that pops up. You will see two suboptions, After Current Page
    and Before Current Page.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以向选项卡小部件添加更多选项卡按钮，并通过添加新的选项卡按钮删除现有按钮；右键单击任一选项卡按钮，然后从弹出的菜单中选择“插入页面”。您将看到两个子选项，当前页面之后和当前页面之前。
- en: 'Select the After Current Page suboption to add a new tab after the current
    tab. The new tab will have the default text Page, which you can always change.
    The application that we are going to make consists of the following three tabs:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“当前页面之后”子选项以在当前选项卡之后添加一个新选项卡。新选项卡将具有默认文本“页面”，您可以随时更改。我们将要制作的应用程序包括以下三个选项卡：
- en: The first tab displays certain products along with their prices. The user can
    select any number of products from the first tab, followed by clicking the Add
    to Cart button.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个选项卡显示某些产品以及它们的价格。用户可以从第一个选项卡中选择任意数量的产品，然后单击“添加到购物车”按钮。
- en: On selecting the second tab, all the payment options will be displayed. The
    user can choose to pay via Debit Card, Credit Card, Net Banking, or Cash on Delivery.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在选择第二个选项卡时，将显示所有付款选项。用户可以选择通过借记卡、信用卡、网上银行或货到付款进行付款。
- en: 'The third tab, when selected, will prompt the user for a delivery address:
    the complete address of the customer along with state, country, and contact number.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个选项卡在选择时将提示用户输入交付地址：客户的完整地址以及州、国家和联系电话。
- en: 'The first task that we will do is to change the default text of the tabs:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先更改选项卡的默认文本：
- en: Using the currentTabText property of Tab Widget, change the text displayed on
    each tab button.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用选项卡小部件的currentTabText属性，更改每个选项卡按钮上显示的文本。
- en: Set the text property of the first tab button to `Product Listing` and that
    of the second tab button to `Payment Method`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第一个选项卡按钮的文本属性设置为“产品列表”，将第二个选项卡按钮的文本属性设置为“付款方式”。
- en: To add a new tab button, right-click on the Payment Method tab and select Insert
    Page from the context menu that appears.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加一个新的选项卡按钮，在“付款方式”选项卡上右键单击，并从出现的上下文菜单中选择“插入页面”。
- en: From the two options that appear, After Current Page and Before Current Page,
    select After Current Page to add a new tab after the Payment Method tab. The new
    tab will have the default text Page.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从出现的两个选项中，选择“当前页之后”和“当前页之前”，选择“当前页之后”以在“付款方式”选项卡之后添加一个新选项卡。新选项卡将具有默认文本“页面”。
- en: Using the currentTabText property, change its text to `Delivery Address`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用currentTabText属性，将其文本更改为“交付地址”。
- en: 'Expand Tab Widget by selecting and dragging its nodes to provide a blank space
    below the tab buttons, as shown in the following screenshot:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择并拖动其节点来展开选项卡窗口，以在选项卡按钮下方提供空白空间，如下面的屏幕截图所示：
- en: '![](assets/b6126880-8e88-4af4-8962-2e6c6189ab03.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b6126880-8e88-4af4-8962-2e6c6189ab03.png)'
- en: Select each tab button and drop the desired widgets into the blank space provided.
    For example, drop four Check Box widgets onto the first tab button, Product Listing,
    to display the items available for sale.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择每个选项卡按钮，并将所需的小部件放入提供的空白空间。例如，将四个复选框小部件放到第一个选项卡按钮“产品列表”上，以显示可供销售的物品。
- en: Drop a Push Button widget on the form.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单上放置一个推送按钮小部件。
- en: Change the text property of the four checkboxes to `Cell Phone $150`, `Laptop
    $500`, `Camera $250`, and `Shoes $200`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将四个复选框的文本属性更改为`手机$150`、`笔记本电脑$500`、`相机$250`和`鞋子$200`。
- en: 'Change the text property of the Push Button widget to `Add to Cart`, as shown
    in the following screenshot:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将推送按钮小部件的文本属性更改为“添加到购物车”，如下面的屏幕截图所示：
- en: '![](assets/b2d67f02-bf7b-429a-ab06-7126574542d3.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b2d67f02-bf7b-429a-ab06-7126574542d3.png)'
- en: Similarly, to provide different payment methods, select the second tab and place
    four radio buttons in the available space.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，要提供不同的付款方式，选择第二个选项卡，并在可用空间中放置四个单选按钮。
- en: 'Set the text property of the four radio buttons to `Debit Card`, `Credit Card`,
    `Net Banking`, and `Cash On Delivery`, as shown in the following screenshot:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将四个单选按钮的文本属性设置为“借记卡”、“信用卡”、“网上银行”和“货到付款”，如下面的屏幕截图所示：
- en: '![](assets/4364f884-9029-4a33-8108-ea92a68f713a.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4364f884-9029-4a33-8108-ea92a68f713a.png)'
- en: Select the third tab and drag and drop few Line Edit widgets that prompt the
    user to provide a delivery address.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择第三个选项卡，然后拖放几个LineEdit小部件，提示用户提供交付地址。
- en: Drag and drop six Label and six Line Edit widgets onto the form.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将六个Label和六个LineEdit小部件拖放到表单上。
- en: 'Set the text property of the Label widgets to `Address 1`, `Address 2`, `State`,
    `Country`, `Zip Code`, and `Contact Number`. The Line Edit widgets in front of
    each Label widget will be used to get the address for delivery, as shown in the
    following screenshot:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Label小部件的文本属性设置为`地址1`、`地址2`、`州`、`国家`、`邮政编码`和`联系电话`。每个Label小部件前面的LineEdit小部件将用于获取交付地址，如下面的屏幕截图所示：
- en: '![](assets/a7e83202-7705-4a75-be08-304e168d0f2a.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a7e83202-7705-4a75-be08-304e168d0f2a.png)'
- en: Save the application as `demoTabWidget.ui`.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将应用程序保存为`demoTabWidget.ui`。
- en: 'The user interface created with Qt Designer is stored in a `.ui` file, which
    is an XML file, and needs to be converted into Python code. To do the conversion,
    you need to open a Command Prompt window, navigate to the folder where the file
    is saved, and issue this command:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Qt Designer创建的用户界面存储在一个`.ui`文件中，这是一个XML文件，需要转换为Python代码。要进行转换，需要打开命令提示符窗口，转到保存文件的文件夹，并发出此命令：
- en: '[PRE7]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code of the generated Python script file, `demoTabWidget.py`, can be seen
    in the source code bundle of this book. The user interface design created in the
    autogenerated code `demoTablWidget.py`, is used by importing it into another Python
    script.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的Python脚本文件`demoTabWidget.py`的代码可以在本书的源代码包中找到。通过将其导入到另一个Python脚本中，使用自动生成的代码`demoTablWidget.py`创建的用户界面设计。
- en: 'Create another Python file with the name `callTabWidget.pyw` and import the
    `demoTabWidget.py` code into it:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`callTabWidget.pyw`的Python文件，并将`demoTabWidget.py`代码导入其中：
- en: '[PRE8]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As you can see in `callTabWidget.pyw`, the necessary modules are imported. The `MyForm`
    class is created and inherits from the base class, `QDialog`. The default constructor
    for `QDialog` is invoked.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如`callTabWidget.pyw`中所示，导入了必要的模块。创建了`MyForm`类，并继承自基类`QDialog`。调用了`QDialog`的默认构造函数。
- en: An application object is created with the name `app` through the `QApplication()`
    method. Every PyQt5 application must create an application object. The `sys.argv`
    parameter is passed to the `QApplication()` method while creating the application
    object. The `sys.argv` parameter contains a list of arguments from the command
    line and helps in passing and controlling the startup attributes of a script.
    After this, an instance of the `MyForm` class is created with the name `w`. The
    `show()` method is invoked on the instance, which will display the widgets on
    the screen. The `sys.exit()` method ensures a clean exit, releasing memory resources.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`QApplication()`方法创建名为`app`的应用程序对象。每个PyQt5应用程序都必须创建一个应用程序对象。在创建应用程序对象时，将`sys.argv`参数传递给`QApplication()`方法。`sys.argv`参数包含来自命令行的参数列表，并有助于传递和控制脚本的启动属性。之后，使用`MyForm`类的实例创建名为`w`的实例。在实例上调用`show()`方法，将在屏幕上显示小部件。`sys.exit()`方法确保干净的退出，释放内存资源。
- en: 'When the application is executed, you will find that the first tab, Products
    Listing, is selected by default and the products available for sale specified
    in that tab are displayed as shown in the following screenshot:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序执行时，您会发现默认情况下选择了第一个选项卡“产品列表”，并且该选项卡中指定的可供销售的产品如下屏幕截图所示：
- en: '![](assets/e9c425e7-bfb5-4e0f-9260-a0fc9787747a.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e9c425e7-bfb5-4e0f-9260-a0fc9787747a.png)'
- en: Similarly, on selecting the other tabs, Payment Method and Delivery Address,
    you will see the widgets prompting the user to choose the desired payment method
    and enter a delivery address.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在选择其他选项卡“付款方式”和“交货地址”时，您将看到小部件提示用户选择所需的付款方式并输入交货地址。
- en: Creating a custom menu bar
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义菜单栏
- en: A big application is usually broken into small, independent, and manageable
    modules. These modules can be invoked either by making different toolbar buttons
    or menu items. That is, we can invoke a module on the click of a menu item. We
    have seen the File menu, the Edit menu, and so on in different packages, so let's
    learn to make a custom menu bar of our own.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大型应用程序通常被分解为小的、独立的、可管理的模块。这些模块可以通过制作不同的工具栏按钮或菜单项来调用。也就是说，我们可以在单击菜单项时调用一个模块。我们在不同的软件包中看到了文件菜单、编辑菜单等，因此让我们学习如何制作自己的自定义菜单栏。
- en: In this recipe, we will learn to create a menu bar that shows certain menu items.
    We will learn to add menu items, add submenu items to a menu item, add separators
    between menu items, add shortcuts and tool tips to menu items, and much more.
    We will also learn to add actions to these menu items, so that when any menu item
    is clicked, a certain action will take place.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习创建显示特定菜单项的菜单栏。我们将学习如何添加菜单项，向菜单项添加子菜单项，在菜单项之间添加分隔符，向菜单项添加快捷键和工具提示，以及更多内容。我们还将学习如何向这些菜单项添加操作，以便单击任何菜单项时会执行某个操作。
- en: Our menu bar will consist of two menus, Draw and Edit. The Draw menu will consist
    of four menu items, Draw Circle, Draw Rectangle, Draw Line, and Properties. The
    Properties menu item will consist of two submenu items, Page Setup and Set Password.
    The second menu, Edit, will consist of three menu items, Cut, Copy, and Paste.
    Let's create a new application to understand how to create this menu bar practically.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的菜单栏将包括两个菜单，绘图和编辑。绘图菜单将包括四个菜单项，绘制圆形、绘制矩形、绘制直线和属性。属性菜单项将包括两个子菜单项，页面设置和设置密码。第二个菜单，编辑，将包括三个菜单项，剪切、复制和粘贴。让我们创建一个新应用程序，以了解如何实际创建这个菜单栏。
- en: How to do it…
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will be following a step-by-step procedure to make two menus, along with
    the respective menu items in each. For quick access, each menu item will be associated
    with a shortcut key too. Here are the steps to create our customized menu bar:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照逐步程序来制作两个菜单，以及每个菜单中的相应菜单项。为了快速访问，每个菜单项也将与快捷键相关联。以下是创建我们自定义菜单栏的步骤：
- en: Launch Qt Designer and create a Main Window template-based application.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Qt Designer并创建一个基于Main Window模板的应用程序。
- en: 'You get the new application with the default menu bar because the Main Window
    template of Qt Designer provides a main application window that displays a menu
    bar by default. The default menu bar appears as shown in the following screenshot:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您会得到具有默认菜单栏的新应用程序，因为Qt Designer的Main Window模板默认提供了一个显示菜单栏的主应用程序窗口。默认菜单栏如下截图所示：
- en: '![](assets/2e3d83c2-7891-4cdd-894e-b425ca161c42.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2e3d83c2-7891-4cdd-894e-b425ca161c42.png)'
- en: We can always remove the default menu bar by right-clicking in the main window
    and selecting the Remove Menu Bar option from the context menu that pops up.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过右键单击主窗口并从弹出的上下文菜单中选择“删除菜单栏”选项来删除默认菜单栏。
- en: You can also add a menu bar later by selecting the Create Menu Bar option from
    the context menu.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以通过从上下文菜单中选择“创建菜单栏”选项来稍后添加菜单栏。
- en: The default menu bar contains Type Here placeholders. You can replace those
    with the menu item text.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 默认菜单栏包含“在此处输入”占位符。您可以用菜单项文本替换它们。
- en: Click the placeholder to highlight it and type to modify its text. When you
    add a menu item, Type Here appears below the new menu item.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击占位符以突出显示它，并输入以修改其文本。当您添加菜单项时，“在此处输入”将出现在新菜单项下方。
- en: Again, just single left-click the Type Here placeholder to select it and simply
    type the text for the next menu item.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，只需单击“在此处输入”占位符以选择它，然后简单地输入下一个菜单项的文本。
- en: You can delete any menu entry by right-clicking it and, from the context menu
    that pops up, select the option Remove Action action_name.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过右键单击任何菜单项并从弹出的上下文菜单中选择“删除操作action_name”选项来删除任何菜单项。
- en: The menus and menu items in the menu bar can be arranged by dragging and dropping
    them at the desired location.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单栏中的菜单和菜单项可以通过拖放在所需位置进行排列。
- en: While writing menu or menu item text, if you add an ampersand character (`&`)
    before any character, that character in the menu will appear as underlined and
    will be treated as a shortcut key. We will also learn how to assign a shortcut
    key to a menu item later.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写菜单或菜单项文本时，如果在任何字符之前添加一个“&”字符，菜单中的该字符将显示为下划线，并且将被视为快捷键。我们还将学习如何稍后为菜单项分配快捷键。
- en: When you create a new menu item by replacing the Type Here placeholders, that
    menu item will appear as an individual action in the Action Editor box, from where
    you can configure its properties.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您通过替换“在此处输入”占位符创建新菜单项时，该菜单项将显示为操作编辑框中的单独操作，您可以从那里配置其属性。
- en: Recall that we want to create two menus in this menu bar with text, `Draw` and
    `Edit`. The Draw menu will have three menu items, Draw Circle, Draw Rectangle,
    and Draw Line. After these three menu items, a separator will be inserted followed
    by a fourth menu item called Properties. The Properties menu item will have two
    submenu items, Page Setup and Set Password. The Edit menu will contain three menu
    items, Cut, Copy, and Paste.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们想在这个菜单栏中创建两个菜单，文本为“绘图”和“编辑”。绘图菜单将包含三个菜单项，绘制圆形、绘制矩形和绘制直线。在这三个菜单项之后，将插入一个分隔符，然后是一个名为“属性”的第四个菜单项。属性菜单项将包含两个子菜单项，页面设置和设置密码。编辑菜单将包含三个菜单项，剪切、复制和粘贴。
- en: Double-click the Type Here placeholder and enter the text for the first menu,
    `Draw`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击“在此处输入”占位符，输入第一个菜单“绘图”的文本。
- en: 'The down arrow key on the Draw menu brings up the Type Here and Add Separator
    options, as shown in the following screenshot:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在“绘图”菜单上按下箭头键会弹出“在此处输入”和“添加分隔符”选项，如下截图所示：
- en: '![](assets/ffd03bb2-b7a0-4bfd-b06f-8ff20c3fe644.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ffd03bb2-b7a0-4bfd-b06f-8ff20c3fe644.png)'
- en: Double-click Type Here and type `Draw Circle` for the first menu item under
    the Draw menu. The down arrow key on the Draw Circle menu provides the Type Here
    and Add Separator options again.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击“在此处输入”，并为“绘制”菜单下的第一个菜单项输入“绘制圆形”。在“绘制圆形”菜单上按下箭头键会再次提供“在此处输入”和“添加分隔符”选项。
- en: Double-click Type Here and type `Draw Rectangle` for the menu item.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击“在此处输入”并输入“绘制矩形”作为菜单项。
- en: Press the down arrow key to get two options, Type Here and Add Separator.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下下箭头键以获取两个选项，“在此处输入”和“添加分隔符”。
- en: Double-click Type Here and type `Draw Line` for the third menu item.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击“在此处输入”，并为第三个菜单项输入“绘制线条”。
- en: 'On pressing the down arrow key, again you get two options, Type Here and Add
    Separator, as shown in the following screenshot:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下下箭头键后，再次会出现两个选项，“在此处输入”和“添加分隔符”，如下截图所示：
- en: '![](assets/3c657aa6-7475-4351-b2ec-cf8ee426cad9.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3c657aa6-7475-4351-b2ec-cf8ee426cad9.png)'
- en: Select Add Separator to add a separator after the first three menu items.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“添加分隔符”以在前三个菜单项后添加分隔符。
- en: Press the down arrow key after the separator and add a fourth menu item, `Properties`.
    This is done because we want two submenu items for the Properties menu item.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分隔符后按下下箭头键，并添加第四个菜单项“属性”。这是因为我们希望“属性”菜单项有两个子菜单项。
- en: Select the right arrow to add submenu items to the Properties menu.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择右箭头以向“属性”菜单添加子菜单项。
- en: Press the right arrow key on any menu item to add a submenu item to it. In the
    submenu item, select Type Here and enter the first submenu, `Page Setup`.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何菜单项上按下右箭头键，以向其添加子菜单项。在子菜单项中，选择“在此处输入”，并输入第一个子菜单“页面设置”。
- en: 'Select the down arrow and enter `Set Password` below the Page Setup submenu
    item, as shown in the following screenshot:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择下箭头，并在页面设置子菜单项下输入“设置密码”，如下截图所示：
- en: '![](assets/825e7797-8b3e-40b5-a874-80eaa7cb8b7b.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/825e7797-8b3e-40b5-a874-80eaa7cb8b7b.png)'
- en: The first menu, Draw, is complete. Now, we need to add another menu, Edit. Select
    the Draw menu and press the right arrow key to indicate that you want to add a
    second menu to the menu bar.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个菜单“绘制”已完成。现在，我们需要添加另一个菜单“编辑”。选择“绘制”菜单，并按下右箭头键，表示要在菜单栏中添加第二个菜单。
- en: Replace Type Here with `Edit`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“在此处输入”替换为“编辑”。
- en: 'Press the down arrow and add three menu items, Cut, Copy, and Paste, as shown
    in the following screenshot:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下下箭头，并添加三个菜单项，剪切、复制和粘贴，如下截图所示：
- en: '![](assets/7a3b7048-2461-4c44-bc0c-f8fa84ae0c48.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7a3b7048-2461-4c44-bc0c-f8fa84ae0c48.png)'
- en: 'The actions for all menu items will appear in the Action Editor box automatically,
    as shown in the following screenshot:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 所有菜单项的操作将自动显示在操作编辑框中，如下截图所示：
- en: '![](assets/82d0ef70-87a2-4caf-b144-188354deaddd.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/82d0ef70-87a2-4caf-b144-188354deaddd.png)'
- en: You can see that the action names are generated by prefixing the text action
    to every menu text and replacing the spaces with underscores. These actions can
    be used to configure menu items.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到操作名称是通过在每个菜单文本前缀文本操作并用下划线替换空格而生成的。这些操作可用于配置菜单项。
- en: To add a tooltip message that appears when the user hovers over any menu item,
    you can use the ToolTip property.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加悬停在任何菜单项上时出现的工具提示消息，可以使用ToolTip属性。
- en: To assign a tooltip message to the Draw Circle menu item of the Draw menu, select
    actionDraw_Circle in the Action Editor box and set the ToolTip property to `To
    draw a circle`. Similarly, you can assign tooltip messages to all of the menu
    items.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为“绘制”菜单的“绘制圆形”菜单项分配工具提示消息，请在操作编辑框中选择actionDraw_Circle，并将ToolTip属性设置为“绘制圆形”。类似地，您可以为所有菜单项分配工具提示消息。
- en: To assign a shortcut key to any menu item, open its action from the Action Editor
    box and click inside the Shortcut box.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为任何菜单项分配快捷键，请从操作编辑框中打开其操作，并单击快捷方式框内。
- en: In the Shortcut box, press the key combination that you want to assign to the
    selected menu item.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在快捷方式框中，按下要分配给所选菜单项的键组合。
- en: 'For example, if you press *Ctrl* + *C* in the Shortcut box, Ctrl+C appears
    in the box, as shown in the following screenshot:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果在快捷方式框中按下*Ctrl* + *C*，则如下截图所示，Ctrl+C将出现在框中：
- en: '![](assets/6bb09b03-387a-4d7a-8c93-cf97e7cb1f01.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6bb09b03-387a-4d7a-8c93-cf97e7cb1f01.png)'
- en: You can have any combination of shortcut keys, such as *Shift* + key, *Alt*
    + key, and *Ctrl* + *Shift* + key, for any menu item. The shortcut keys will appear
    automatically with the menu item in the menu bar. You can also make any menu item
    checkable, that is, you can make it a toggle menu item.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何组合的快捷键，例如*Shift* +键，*Alt* +键和*Ctrl* + *Shift* +键，用于任何菜单项。快捷键将自动显示在菜单栏中的菜单项中。您还可以使任何菜单项可选，即可以将其设置为切换菜单项。
- en: 'To do so, select the action of the desired menu item and check the Checkable
    checkbox. The actions of each menu item, along with its action name, menu text,
    shortcut keys, checkable status, and tooltip, appear in the Action Editor box.
    The following screenshot shows the action of the Set Password submenu item, which
    confirms that its shortcut key is *Shift* + *P* and it is checkable:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，选择所需菜单项的操作并勾选可选复选框。每个菜单项的操作，以及其操作名称、菜单文本、快捷键、可选状态和工具提示，都会显示在操作编辑框中。以下截图显示了“设置密码”子菜单项的操作，确认其快捷键为*Shift*
    + *P*，并且可以选择：
- en: '![](assets/f59b87e8-e715-4468-955c-e06836bb1e81.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f59b87e8-e715-4468-955c-e06836bb1e81.png)'
- en: For the Draw Circle, Draw Rectangle, and Draw Line menu items, we will be adding
    code to draw a circle, draw a rectangle, and draw a line respectively.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于“绘制圆形”、“绘制矩形”和“绘制线条”菜单项，我们将添加代码来分别绘制圆形、矩形和直线。
- en: For the rest of the menu items, we want them so that when the user selects any
    of them, a text message appears on the form indicating which menu item is selected.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于其余的菜单项，我们希望当用户选择任何一个时，在表单上会出现一个文本消息，指示选择了哪个菜单项。
- en: To display a message, drag and drop a Label widget onto the form.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示消息，请将标签小部件拖放到表单上。
- en: Our menu bar is complete; save the application with the name `demoMenuBar.ui`.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的菜单栏已完成；使用名称“demoMenuBar.ui”保存应用程序。
- en: We use the `pyuic5` command line utility to convert the `.ui` (XML) file into
    Python code.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`pyuic5`命令行实用程序将`.ui`（XML）文件转换为Python代码。
- en: The generated Python code, `demoMenuBar.py`, can be seen in the source code
    bundle of this book.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的Python代码`demoMenuBar.py`可以在本书的源代码包中找到。
- en: Create a Python script with the name `callMenuBar.pyw` that imports the previous
    code, `demoMenuBar.py`, to invoke the menu and display the text message with a
    Label widget when a menu item is selected.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`callMenuBar.pyw`的Python脚本，导入之前的代码`demoMenuBar.py`，以调用菜单并在选择菜单项时显示带有Label小部件的文本消息。
- en: 'You want a message to appear that indicates which menu item is selected. Also,
    you want to draw a circle, rectangle, and line when the Draw Circle, Draw Rectangle,
    and Draw Line menu items are selected, respectively. The code in the Python `callMenuBar.pyw` script
    will appear as shown in the following screenshot:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望出现一条消息，指示选择了哪个菜单项。此外，当选择Draw Circle、Draw Rectangle和Draw Line菜单项时，您希望分别绘制一个圆、矩形和线。Python
    `callMenuBar.pyw`脚本中的代码将如下屏幕截图所示：
- en: '[PRE9]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '工作原理... '
- en: The triggered() signal of the action of each menu item is connected to its respective
    method. The triggered() signal of the actionDraw_Circle menu item is connected
    to the `drawCircle()` method, so that whenever the Draw Circle menu item is selected
    from the menu bar, the `drawCircle()` method will be invoked. Similarly, the triggered()
    signal of the actionDraw_Rectangle and actionDraw_Line menus are connected to
    the `drawRectangle()` and `drawLine()` methods respectively. In the `drawCircle()` method,
    the `toDraw` variable is assigned a string, `circle`. The `toDraw` variable will
    be used to determine the graphics to be drawn in the `paintEvent` method. The
    `toDraw` variable can be assigned any of the three strings, `line`, `circle`,
    or `rectangle`. A conditional branching is applied to the value in the `toDraw`
    variable and the methods to draw a line, rectangle, or circle will be invoked accordingly.
    The figures will be drawn to the size determined by the mouse, that is, the user
    needs to click the mouse and drag it to determine the size of the figure.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 每个菜单项的操作的triggered()信号都连接到其相应的方法。每个菜单项的triggered()信号都连接到`drawCircle()`方法，因此每当从菜单栏中选择Draw
    Circle菜单项时，都会调用`drawCircle()`方法。类似地，actionDraw_Rectangle和actionDraw_Line菜单的triggered()信号分别连接到`drawRectangle()`和`drawLine()`方法。在`drawCircle()`方法中，`toDraw`变量被分配一个字符串`circle`。`toDraw`变量将用于确定在`paintEvent`方法中要绘制的图形。`toDraw`变量可以分配三个字符串中的任何一个，即`line`、`circle`或`rectangle`。对`toDraw`变量中的值应用条件分支，相应地将调用绘制线条、矩形或圆的方法。图形将根据鼠标确定的大小进行绘制，即用户需要单击鼠标并拖动以确定图形的大小。
- en: Two methods, `mousePressEvent()` and `mouseReleaseEvent()`, are automatically
    called when left mouse button is pressed and released respectively. To store the
    `x` and `y` coordinates of the location where the left mouse button was pressed
    and released, two arrays, `pos1` and `pos2`, are used. The `x` and `y` coordinate
    values of the locations where the left mouse button was pressed and released are
    assigned to the `pos1` and `pos2` arrays via the `mousePressEvent` and `mouseReleaseEvent` methods.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法，`mousePressEvent()`和`mouseReleaseEvent()`，在按下和释放左鼠标按钮时会自动调用。为了存储按下和释放左鼠标按钮的位置的`x`和`y`坐标，使用了两个数组`pos1`和`pos2`。左鼠标按钮按下和释放的位置的`x`和`y`坐标值通过`mousePressEvent`和`mouseReleaseEvent`方法分配给`pos1`和`pos2`数组。
- en: In the `mouseReleaseEvent` method, after assigning the `x` and `y` coordinate
    values of the location where the mouse button was released, the `self.update` method
    is invoked to invoke the `paintEvent()` method. In the `paintEvent()` method,
    branching takes place on the basis of the string assigned to the `toDraw` variable.
    If the `toDraw` variable is assigned the `line` string, the `drawLine()` method
    will be invoked by the `QPainter` class to draw the line between the two mouse
    locations. Similarly, if the `toDraw` variable is assigned the `circle` string,
    the `drawArc()` method will be invoked by the `QPainter` class to draw a circle
    with the diameter supplied by mouse locations. If the `toDraw` variable is assigned
    the `rectangle` string, then the `drawRect()` method will be invoked by the `QPainter`
    class to draw the rectangle of the width and height supplied by the mouse locations.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mouseReleaseEvent`方法中，分配鼠标释放位置的`x`和`y`坐标值后，调用`self.update`方法来调用`paintEvent()`方法。在`paintEvent()`方法中，基于分配给`toDraw`变量的字符串进行分支。如果`toDraw`变量分配了`line`字符串，`QPainter`类将通过`drawLine()`方法来绘制两个鼠标位置之间的线。类似地，如果`toDraw`变量分配了`circle`字符串，`QPainter`类将通过`drawArc()`方法来绘制直径由鼠标位置提供的圆。如果`toDraw`变量分配了`rectangle`字符串，`QPainter`类将通过`drawRect()`方法来绘制由鼠标位置提供的宽度和高度的矩形。
- en: Besides the three menu items, Draw Circle, Draw Rectangle, and Draw Line, if
    the user clicks any other menu item, a message will be displayed indicating the
    menu item clicked on by the user. Hence, the triggered() signals of the rest of
    the menu items are connected to the methods that display the message information
    for the menu item that has been selected by the user through a Label widget.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 除了三个菜单项Draw Circle、Draw Rectangle和Draw Line之外，如果用户单击任何其他菜单项，将显示一条消息，指示用户单击的菜单项。因此，其余菜单项的triggered()信号将连接到显示用户通过Label小部件选择的菜单项的消息信息的方法。
- en: 'On running the application, you will find a menu bar with two menus, Draw and
    Edit. The Draw menu will show the four menu items Draw Circle, Draw Rectangle,
    Draw Line, and Properties, with a separator before the Properties menu item. The
    Properties menu item shows two submenu items, Page Setup and Set Password, along
    with their shortcut keys, as shown in the following screenshot:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序时，您会发现一个带有两个菜单Draw和Edit的菜单栏。Draw菜单将显示四个菜单项Draw Circle、Draw Rectangle、Draw
    Line和Properties，在Properties菜单项之前显示一个分隔符。Properties菜单项显示两个子菜单项Page Setup和Set Password，以及它们的快捷键，如下面的屏幕截图所示：
- en: '![](assets/de30b61b-0eec-478b-9087-8742218d3ff2.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/de30b61b-0eec-478b-9087-8742218d3ff2.png)'
- en: 'To draw a circle, click on the Draw Circle menu item, click the mouse button
    at a location on the form, and keeping the mouse button pressed, drag it to define
    the diameter of the circle. On releasing the mouse button, a circle will be drawn
    between the mouse pressed and mouse released locations, as shown in the following
    screenshot:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一个圆，点击“绘制圆”菜单项，在窗体上的某个位置点击鼠标按钮，保持鼠标按钮按住，拖动以定义圆的直径。释放鼠标按钮时，将在鼠标按下和释放的位置之间绘制一个圆，如下截图所示：
- en: '![](assets/84c641ca-4c5c-4551-adf5-3fda193607ee.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/84c641ca-4c5c-4551-adf5-3fda193607ee.png)'
- en: 'On selecting any other menu item, a message will be displayed, indicating the
    menu item that is pressed. For example, on selecting the Copy menu item, you get
    a message, Copy menu item is selected, as shown in the following screenshot:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 选择其他菜单项时，将显示一条消息，指示按下的菜单项。例如，选择“复制”菜单项时，将显示消息“选择了复制菜单项”，如下截图所示：
- en: '![](assets/a080f906-4107-4d99-bc5b-3206026fb4fa.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a080f906-4107-4d99-bc5b-3206026fb4fa.png)'
