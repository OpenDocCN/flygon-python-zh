- en: The CUDA Device Function Libraries and Thrust
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CUDA设备函数库和Thrust
- en: In the last chapter, looking at a fairly broad overview of the libraries that
    are available in CUDA through the Scikit-CUDA wrapper module. We will now look
    at a few other libraries that we will have to use directly from within CUDA C
    proper, without the assistance of wrappers like those in Scikit-CUDA. We will
    start by looking at two standard libraries that consist of device functions that
    we may invoke from any CUDA C kernel cuRAND and the CUDA Math API. By the end
    of learning how to use these libraries, we will know how to use these libraries
    in the context of Monte Carlo integration. Monte Carlo integration is a well-known
    randomized method that provides estimates for the values of definite integrals
    from calculus. We will first look at a basic example of how to implement a simple
    Monte Carlo method with cuRAND to do a basic estimate of the value of Pi (as in
    the well-known constant, π=3.14159...), and then we'll embark on a more ambitious
    project where we will construct a Python class that can perform definite integration
    on any arbitrary mathematical function, and use the Math API for creating such
    functions. We'll also look at how to effectively use some ideas from metaprogramming
    in our design of this class.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们对通过Scikit-CUDA包装器模块在CUDA中可用的库进行了相当广泛的概述。我们现在将看一下另外一些库，我们将不得不直接从CUDA
    C中使用这些库，而不是像Scikit-CUDA中的包装器那样。我们将首先看一下两个标准库，其中包含我们可以从任何CUDA C内核中调用的设备函数cuRAND和CUDA
    Math API。通过学习如何使用这些库，我们将了解如何在蒙特卡罗积分的上下文中使用这些库。蒙特卡罗积分是一种众所周知的随机方法，可以提供来自微积分的定积分值的估计。我们首先将看一个基本示例，演示如何使用cuRAND实现简单的蒙特卡罗方法来对π的值进行基本估计（如众所周知的常数，π=3.14159...），然后我们将着手进行一个更有雄心的项目，我们将构建一个Python类，可以对任意数学函数执行定积分，并使用Math
    API创建这样的函数。我们还将看一下如何在设计这个类时有效地使用元编程的一些思想。
- en: We will then take another look at writing some pure CUDA programs with the help
    of the Thrust C++ library. Thrust is a library that provides C++ template containers,
    similar to those in the C++ Standard Template Library (STL). This will enable
    us to manipulate CUDA C arrays from C++ in a more natural way that is closer to
    PyCUDA's `gpuarray` and the STL's vector container. This will save us from having
    to constantly use pointers, such as *mallocs* and *frees*, that plagued us before
    in CUDA C.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将再次使用Thrust C++库来编写一些纯CUDA程序。Thrust是一个提供C++模板容器的库，类似于C++标准模板库（STL）中的容器。这将使我们能够以更接近PyCUDA的`gpuarray`和STL的向量容器的更自然的方式从C++中操作CUDA
    C数组。这将使我们免受在CUDA C中以前不断使用指针（如*mallocs*和*frees*）的困扰。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Understanding the purpose that a seed has in generating lists of pseudo-random
    numbers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解种子在生成伪随机数列表中的作用
- en: Using cuRAND device functions for generating random numbers in a CUDA kernel
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CUDA内核中使用cuRAND设备函数生成随机数
- en: Understanding the concept of Monte Carlo integration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解蒙特卡罗积分的概念
- en: Using dictionary-based string formatting in Python for metaprogramming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中使用基于字典的字符串格式化进行元编程
- en: Using the CUDA Math API device function library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CUDA Math API设备函数库
- en: Understanding what a functor is
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解functor是什么
- en: Using the Thrust vector container when programming in pure CUDA C
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在纯CUDA C编程时使用Thrust向量容器
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A Linux or Windows 10 PC with a modern NVIDIA GPU (2016—onward) is required
    for this chapter, with all of the necessary GPU drivers and the CUDA Toolkit (9.0–onward)
    installed. A suitable Python 2.7 installation (such as Anaconda Python 2.7) with
    the PyCUDA module is also required.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要具有现代NVIDIA GPU（2016年至今）的Linux或Windows 10 PC，并安装了所有必要的GPU驱动程序和CUDA Toolkit（9.0及以上）。还需要适当的Python
    2.7安装（如Anaconda Python 2.7），并安装了PyCUDA模块。
- en: This chapter's code is also available on GitHub, and can be found at [https://github.com/PacktPublishing/Hands-On-GPU-Programming-with-Python-and-CUDA.](https://github.com/PacktPublishing/Hands-On-GPU-Programming-with-Python-and-CUDA)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码也可以在GitHub上找到，网址为[https://github.com/PacktPublishing/Hands-On-GPU-Programming-with-Python-and-CUDA.](https://github.com/PacktPublishing/Hands-On-GPU-Programming-with-Python-and-CUDA)
- en: For more information about the prerequisites for this chapter, check the preface
    of this book. For the software and hardware requirements, check out the README
    at [https://github.com/PacktPublishing/Hands-On-GPU-Programming-with-Python-and-CUDA](https://github.com/PacktPublishing/Hands-On-GPU-Programming-with-Python-and-CUDA).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章先决条件的更多信息，请查看本书的前言。有关软件和硬件要求，请查看[https://github.com/PacktPublishing/Hands-On-GPU-Programming-with-Python-and-CUDA](https://github.com/PacktPublishing/Hands-On-GPU-Programming-with-Python-and-CUDA)上的README。
- en: The cuRAND device function library
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cuRAND设备函数库
- en: Let's start with cuRAND. This is a standard CUDA library that is used for generating
    pseudo-random values within a CUDA kernel on a thread-by-thread basis, which is
    initialized and invoked by calling device functions from each individual thread
    within a kernel. Let's emphasize again that this is a **pseudo-random** sequence
    of values—since the digital hardware is always deterministic and never random
    or arbitrary, we use algorithms to generate a sequence of apparently random values
    from an initial **seed value**. Usually, we can set the seed value to a truly
    random value (such as the clock time in milliseconds), which will yield us with
    a nicely arbitrary sequence of *random* values. These generated random values
    have no correlation with prior or future values in the sequence generated by the
    same seed, although there can be correlations and repeats when you combine values
    generated from different seeds. For this reason, you have to be careful that the
    values you wish to be mutually *random* are generated by the same seed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从cuRAND开始。这是一个标准的CUDA库，用于在CUDA内核中按线程生成伪随机值，通过调用每个线程内核中的设备函数进行初始化和调用。让我们再次强调，这是一个**伪随机**值序列——因为数字硬件始终是确定性的，从不是随机或任意的，我们使用算法从初始**种子值**生成一系列表面上随机的值。通常，我们可以将种子值设置为真正的随机值（例如毫秒级的时钟时间），这将产生一系列*随机*值。这些生成的随机值与由相同种子生成的序列中的先前或未来值没有相关性，尽管当您组合从不同种子生成的值时，可能会出现相关性和重复。因此，您必须小心，希望彼此*随机*的值是由相同的种子生成的。
- en: 'Let''s start by looking at the function prototype for `curand_init`, which
    we will initialize with an appropriate seed:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`curand_init`的函数原型开始，我们将使用适当的种子进行初始化：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, all of the inputs are unsigned long, which in C is an unsigned (non-negative
    valued) 64-bit integer. First, we can see the `seed`, which is, of course, the
    seed value. Generally speaking, you'll set this with the clock value or some variation.
    We then see a value called `sequence` and as we stated previously, values generated
    by cuRAND will only be truly mathematically mutually random if they are generated
    by the same seed value. So, if we have multiple threads using the same seed value,
    we use `sequence` to indicate which sub-sequence of random numbers of length 2^(190 )for
    the current thread to use, while we use `offset` to indicate at which point to
    start within this sub-sequence; this will generate values in each thread that
    are all mathematically mutually random with no correlation. Finally, the last
    parameter is for a pointer to a `curandState_t` object; this keeps track of where
    we are in the sequence of pseudo-random numbers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，所有的输入都是无符号长整型，在C中是无符号（非负值）的64位整数。首先，我们可以看到`seed`，这当然是种子值。一般来说，您将使用时钟值或某种变化来设置这个值。然后我们看到一个称为`sequence`的值，正如我们之前所述，cuRAND生成的值只有在它们由相同的种子值生成时才是真正的数学上相互随机的。因此，如果我们有多个线程使用相同的种子值，我们使用`sequence`来指示当前线程使用长度为2^(190)的随机数子序列的哪个子序列，而我们使用`offset`来指示从这个子序列的哪个点开始；这将在每个线程中生成所有数学上相互随机且没有相关性的值。最后，最后一个参数是指向`curandState_t`对象的指针；这将跟踪我们在伪随机数序列中的位置。
- en: 'After you initialize a class object, you will then generate random values from
    the appropriate random distribution by calling the appropriate device function.
    The two most common distributions are uniform and normal (Gaussian). A uniform
    distribution (`curand_uniform`, in cuRAND) is a function that outputs values that
    are all equally probable over a given range: that is to say, for a uniform distribution
    over 0 to 1, there is a 10% chance that a value will fall between 0 and 0.1, or
    between 0.9 to 1, or between any two points that are spaced .1 away from each
    other. The normal distribution (`curand_normal`, in cuRAND) has values that are
    centered at a particular mean, which will be distributed according to the well-known
    bell-shaped curve that is defined by the distribution''s standard deviation. (The
    default mean of `curand_normal` is `0` and the standard deviation is 1 in cuRAND,
    so this will have to be shifted and scaled manually for other values.) Another
    well-known distribution supported by cuRAND is the Poisson distribution (`curand_poisson`),
    which is used for modeling the occurrences of random events over time.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化类对象后，您将通过调用适当的设备函数从适当的随机分布生成随机值。最常见的两种分布是均匀分布和正态（高斯）分布。均匀分布（`curand_uniform`，在cuRAND中）是一个输出值在给定范围内都是等概率的函数：也就是说，对于0到1的均匀分布，值在0到0.1之间的概率是10%，或者在0.9到1之间，或者在任何两个相距0.1的点之间。正态分布（`curand_normal`，在cuRAND中）具有以特定均值为中心的值，这些值将根据分布的标准差分布在众所周知的钟形曲线上。
    （`curand_normal`的默认均值为`0`，标准差为1，在cuRAND中，因此必须手动移位和缩放为其他值。）cuRAND支持的另一个众所周知的分布是泊松分布（`curand_poisson`），用于对随机事件的发生进行建模。
- en: We will be primarily looking at how to use cuRAND in the context of uniform
    distributions in the next section, due to their applicability to Monte Carlo integration.
    Readers interested in learning how to use more features in cuRAND are encouraged
    to look at the official documentation from NVIDIA.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将主要研究如何在均匀分布的背景下使用cuRAND，因为它们适用于蒙特卡罗积分。鼓励有兴趣学习如何使用cuRAND更多功能的读者查看NVIDIA的官方文档。
- en: Estimating π with Monte Carlo
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用蒙特卡洛法估算π
- en: First, we will apply our new knowledge of cuRAND to perform an estimate of the
    well-known mathematical constant π, or Pi, which is, of course, the never-ending
    irrational number 3.14159265358979...
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将运用我们对cuRAND的新知识来估算众所周知的数学常数π，或圆周率，这当然是永不停止的无理数3.14159265358979...
- en: 'To get an estimate, though, we need to take a moment to think about what this
    means. Let''s think about a circle. Remember that the radius of a circle is the
    length from the center of the circle to any point in the circle; usually, this
    is designated with *R*. The diameter is defined as *D = 2R*, and the circumference
    *C* is the length around the circle. Pi is then defined as *π = C / D* . We can
    use Euclidean geometry to find a formula for the area of the circle, which turns
    out being *A = πR²* . Now, let''s think about a circle with radius *R* being circumscribed
    in a square with all sides of length *2R*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要得到一个估计值，我们需要花点时间思考这意味着什么。让我们想想一个圆。记住，圆的半径是从圆心到圆上任意一点的长度；通常用 *R* 表示。直径被定义为
    *D = 2R*，周长 *C* 是围绕圆的长度。然后，π 被定义为 *π = C / D*。我们可以使用欧几里得几何来找到圆的面积公式，结果是 *A = πR²*。现在，让我们考虑一个半径为
    *R* 的圆被内切在边长为 *2R* 的正方形中：
- en: '![](assets/310fec25-8742-4878-a6e6-e5d917ef29bc.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/310fec25-8742-4878-a6e6-e5d917ef29bc.png)'
- en: 'So, of course, we know that the area of the square is *(2R)² = 4R²*. Let''s
    consider *R=1*, so that we have known that the area of the circle is exactly π,
    while the area of the square is exactly 4\. Let''s make a further assumption and
    state that both the circle and square are centered at (0,0) in the Cartesian plane.
    Now, let''s take a completely random value within the square, (*x,y*), and see
    if it falls within the circle. How can we do this? By applying the Pythagorean
    formula: we do this by checking whether *x² + y²* is less than or equal to 1\.
    Let''s designate the total number of random points we choose with *iters*, and
    the number of hits with *hits*.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当然，我们知道正方形的面积是 *(2R)² = 4R²*。让我们考虑 *R=1*，这样我们就知道圆的面积恰好是 π，而正方形的面积恰好是 4。让我们进一步假设并声明，圆和正方形都以
    (0,0) 为中心。现在，让我们在正方形内取一个完全随机的值 (*x,y*)，并查看它是否落在圆内。我们如何做到这一点？通过应用勾股定理公式：我们通过检查
    *x² + y²* 是否小于或等于 1 来做到这一点。让我们用 *iters* 表示我们选择的随机点的总数，用 *hits* 表示命中的次数。
- en: 'Let''s do a little bit more thinking about this: the probability of picking
    a point within the circle should be proportionate to the area of the circle divided
    by the area of the rectangle; here, this is π / 4\. However, if we choose a very
    large value of random points, notice that we will get the following approximation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再多想一下：在圆内选择一个点的概率应该与圆的面积与矩形的面积之比成比例；在这里，这是 π / 4。然而，如果我们选择一个非常大的随机点值，注意到我们将得到以下近似值：
- en: '![](assets/36f08e8a-fac6-413e-9276-a44a18fba9a1.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/36f08e8a-fac6-413e-9276-a44a18fba9a1.png)'
- en: 'This is exactly how we will estimate π! The number of iterations we will have
    to do will be very high before we can come up with a decent estimate of Pi, but
    notice how nicely parallelizable this is: we can check the "hits" in different
    threads, splitting the total number of iterations among different threads. At
    the end of the day, we can just sum up the total number of hits among all of the
    threads to get our estimate.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们将估计 π 的方法！在我们能得出合理的 π 估计之前，我们将不得不进行非常多的迭代，但请注意这是多么好的可并行化：我们可以在不同的线程中检查“命中”，将总迭代次数分配给不同的线程。在一天结束时，我们只需将所有线程中的命中总数相加，即可得到我们的估计值。
- en: 'We can now begin to write a program to make our Monte Carlo estimate. Let''s
    first import the usual Python modules that we will need for a PyCUDA program,
    with one addition from SymPy:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始编写一个程序来进行蒙特卡洛估计。让我们首先导入我们在 PyCUDA 程序中需要的常规 Python 模块，再加上 SymPy 中的一个模块：
- en: SymPy is used for perfect *symbolic* computations that are to be made in Python
    so that when we have very large integers, we can use the `Rational` function to
    make a much more accurate floating-point estimate of a division.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 用于在 Python 中进行完美的 *符号* 计算，因此当我们有非常大的整数时，我们可以使用 `Rational` 函数来对除法进行更准确的浮点估计。
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we have to do something a little different than normal when we build our
    kernel: we need to set the option `no_extern_c=True` in `SourceModule`. This modifies
    how the code is compiled so that our code can properly link with C++ code, as
    required by the cuRAND library. We then begin writing our kernel and include the
    appropriate header:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们构建内核时，我们必须做一些与正常情况不同的事情：我们需要在 `SourceModule` 中设置选项 `no_extern_c=True`。这会修改代码的编译方式，以便我们的代码可以正确地与
    cuRAND 库所需的 C++ 代码链接。然后我们开始编写我们的内核并包含适当的头文件：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s include a macro for the Pythagorean distance. Since we are just
    checking if this value is equal to or below `1`, we can, therefore, omit the square
    root. We will be using a lot of unsigned 64-bit integers, so let''s make another
    macro to save us from typing `unsigned long long` over and over:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们包含一个用于勾股定理距离的宏。由于我们只是检查这个值是否等于或小于 `1`，因此可以省略平方根。我们将使用大量的无符号 64 位整数，因此让我们再定义一个宏，以免我们一遍又一遍地输入
    `unsigned long long`：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now set up our kernel. By the nature of PyCUDA, this will have to be
    compiled to the interface as a bonafide C function rather than as a C++ function.
    We do this with an `extern "C"` block:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以设置我们的内核。根据 PyCUDA 的性质，这将不得不编译为接口的真正的 C 函数，而不是 C++ 函数。我们可以通过 `extern "C"`
    块来实现这一点：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can now define our kernel. We will have two parameters: one for `iters`,
    which is the total number of iterations for each thread, and another for an array
    that will hold the total number of hits for each thread. We will need a `curandState`
    object for this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义我们的内核。我们将有两个参数：一个是 `iters`，它是每个线程的总迭代次数，另一个是一个数组，将保存每个线程的命中总数。我们将需要一个
    `curandState` 对象：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s hold the global thread ID in an integer called `tid`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个名为 `tid` 的整数来保存全局线程 ID：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`clock()` is a device function that outputs the current time down to the millisecond.
    We can add `tid` to the output of `clock()` to get a unique seed for each thread.
    We don''t need to use different subsequences or offsets, so let''s set them both
    to 0\. We will also carefully typecast everything here to 64-bit unsigned integers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`clock()`是一个设备函数，输出当前时间到毫秒。我们可以将`tid`添加到`clock()`的输出中，以获得每个线程的唯一种子。我们不需要使用不同的子序列或偏移量，所以让我们都设置为0。我们还将在这里仔细地将所有内容强制转换为64位无符号整数：'
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s set up the `x` and `y` values to hold a random point in the rectangle:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置`x`和`y`值以保存矩形中的随机点：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will then iterate `iters` times to see how many hits in the circle we get.
    We generate these with `curand_uniform(&cr_state)`. Notice that we can generate
    them over 0 to 1, rather than from -1 to 1, since the squaring of these in the
    `_PYTHAG` macro will remove any negative values:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将迭代`iters`次，看看我们在圆中得到了多少次命中。我们使用`curand_uniform(&cr_state)`生成这些。请注意，我们可以在0到1之间生成它们，而不是从-1到1，因为在`_PYTHAG`宏中对它们进行平方运算将消除任何负值：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now end and close off our kernel, as well as the `extern "C"` block
    with another final `}` bracket:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以结束并关闭我们的内核，以及`extern "C"`块，最后用另一个`}`括号结束：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s get the Python wrapper function to our kernel with `get_function`.
    We will also set up the block and grid sizes: 32 threads per block, and 512 blocks
    per grid. Let''s calculate the total number of threads and set up an array on
    the GPU to hold all of the hits (initialized to 0s, of course):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用`get_function`将Python包装函数传递给我们的内核。我们还将设置块和网格大小：每个块32个线程，每个网格512个块。让我们计算总线程数，并在GPU上设置一个数组来保存所有的命中（当然初始化为0）：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s set up the total number of iterations per thread to 2^(24):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置每个线程的迭代总数为2^(24)：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now launch the kernel as usual:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以像往常一样启动内核：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s sum over the number of hits in the array, which gives us the total
    number of hits. Let''s also calculate the total number of iterations among all
    of the threads in the array:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对数组中的命中次数求和，这给我们了总命中次数。让我们还计算数组中所有线程的总迭代次数：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can now make our estimate with `Rational`, like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以用`Rational`进行估计，就像这样：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can now convert this into a floating point value:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将其转换为浮点值：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s check our estimate against NumPy''s constant value, `numpy.pi`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查我们的估计与NumPy的常数值`numpy.pi`：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are now done. Let''s run this from IPython and check it out (This program is
    also available as the `monte_carlo_pi.py` file under `Chapter08` in this book''s
    repository.):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完成了。让我们从IPython中运行并检查一下（这个程序也可以在本书的存储库中的`Chapter08`下的`monte_carlo_pi.py`文件中找到）。
- en: '![](assets/5d4875e3-6231-4fc4-a2e2-3004f3933636.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5d4875e3-6231-4fc4-a2e2-3004f3933636.png)'
- en: The CUDA Math API
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CUDA数学API
- en: Now, we will take a look at the **CUDA Math API**. This is a library that consists
    of device functions similar to those in the standard C `math.h` library that can
    be called from individual threads in a kernel. One difference here is that single
    and double valued floating-point operations are overloaded, so if we use `sin(x)`
    where `x` is a float, the sin function will yield a 32-bit float as the output,
    while if `x` were a 64-bit double, then the output of `sin` would also be a 64-bit
    value (Usually, this is the proper name for a 32-bit function, but it has an `f` at
    the end, such as `sinf`). There are also additional **instrinsic** functions.
    Intrinsic functions are less accurate but faster math functions that are built
    into the NVIDIA CUDA hardware; generally, they have similar names to the original
    function, except that they are preceded with two underscores—therefore, the intrinsic,
    32-bit sin function is `__sinf`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看一下**CUDA数学API**。这是一个库，由设备函数组成，类似于标准C `math.h`库中的函数，可以从内核中的单个线程调用。这里的一个区别是，单精度和双精度浮点运算被重载，因此如果我们使用`sin(x)`，其中`x`是一个浮点数，sin函数将产生一个32位浮点数作为输出，而如果`x`是一个64位双精度浮点数，那么`sin`的输出也将是一个64位值（通常，这是32位函数的正确名称，但它在末尾有一个`f`，比如`sinf`）。还有其他**内在**函数。内在函数是内置到NVIDIA
    CUDA硬件中的不太准确但更快的数学函数；通常，它们的名称与原始函数相似，只是在前面加上两个下划线—因此，内在的32位sin函数是`__sinf`。
- en: A brief review of definite integration
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 明确积分的简要回顾
- en: 'Now, we''re going to use some object-oriented programming in Python to set
    up a class that we can use to evaluate definite integrals of functions using a
    Monte Carlo method. Let''s stop for a moment and talk about what we mean: suppose
    we have a mathematical function (as in the type you might see in a calculus class)
    that we call *f(x)*. When we graph this out on the Cartesian plane between points
    *a* and *b*, it may look something like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在Python中使用一些面向对象的编程，设置一个类，我们可以使用蒙特卡洛方法来评估函数的定积分。让我们停下来，谈谈我们的意思：假设我们有一个数学函数（就像你在微积分课上可能看到的那种类型），我们称之为*f(x)*。当我们在笛卡尔平面上在点*a*和*b*之间绘制它时，它可能看起来像这样：
- en: '![](assets/35cc22f9-0a21-45ae-89b9-367edd83aa59.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/35cc22f9-0a21-45ae-89b9-367edd83aa59.png)'
- en: Now, let's review exactly what definite integration means—let's denote the first
    gray area in this graph as *I*, the second gray area as *II*, and the third gray
    area as *III*. Notice that the second gray area here is below zero. The definite
    integral of *f* here, from *a* to *b,* will be the value *I - II + III*, and we
    will denote this mathematically as  ![](assets/6fbf2855-0340-4589-9e3e-a007a7276e06.png). In
    general, the definite integral from *a* to *b* is just the sum of all of the total
    "positive" area bounded by the *f* function and x-axis with y > 0 between *a*
    and *b*, minus all of the "negative" area bounded by the *f* function and the
    x-axis with y < 0 between *a* and *b*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们仔细回顾一下定积分的确切含义——让我们将这个图中的第一个灰色区域表示为*I*，第二个灰色区域表示为*II*，第三个灰色区域表示为*III*。请注意，这里的第二个灰色区域是小于零的。这里的*f*的定积分，从*a*到*b*，将是值*I
    - II + III*，我们将在数学上表示为![](assets/6fbf2855-0340-4589-9e3e-a007a7276e06.png)。一般来说，从*a*到*b*的定积分就是所有在*f*函数和x轴之间的总“正”区域的总和，其中y
    > 0，减去所有在*f*函数和x轴之间的总“负”区域的总和，其中y < 0，位于*a*和*b*之间。
- en: 'There are many ways to calculate or estimate the definite integral of a function
    between two points. One that you may have seen in a calculus class is to find
    a closed-form solution: find the anti-derivative of *f*, *F*, and calculate *F(b)
    - F(a)*. In many areas, though, we won''t be able to find an exact anti-derivative,
    and we will have to determine the definite integral numerically. This is exactly
    the idea behind Monte Carlo integration: we evaluate *f* at many, many random
    points between *a* and *b*, and then use those to make an estimate of the definite
    integral.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以计算或估计两点之间函数的定积分。 在微积分课程中可能见过的一种方法是找到一个封闭形式的解：找到*f*的反导数*F*，并计算*F(b) -
    F(a)*。 然而，在许多领域，我们将无法找到确切的反导数，而必须以数值方式确定定积分。 这正是蒙特卡罗积分的想法：我们在*a*和*b*之间的许多随机点上评估*f*，然后使用这些点来估计定积分。
- en: Computing definite integrals with the Monte Carlo method
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蒙特卡罗方法计算定积分
- en: 'We are now going to use the CUDA Math API for representing an arbitrary mathematical
    function, *f*, while using the cuRAND library to implement the Monte Carlo integral.
    We will do this with **metaprogramming**: we will use Python to generate the code
    for a device function from a code template, which will plug into an appropriate
    Monte Carlo kernel for integration.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用CUDA Math API来表示任意数学函数*f*，同时使用cuRAND库来实现蒙特卡罗积分。 我们将使用**元编程**来实现这一点：我们将使用Python从代码模板生成设备函数的代码，这将插入适当的蒙特卡罗核心以进行积分。
- en: The idea here is that it will look and act similarly to some of the metaprogramming
    tools we've seen with PyCUDA, such as `ElementwiseKernel`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是它看起来和行为类似于我们在PyCUDA中看到的一些元编程工具，比如`ElementwiseKernel`。
- en: 'Let''s start by importing the appropriate modules into our new project:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先将适当的模块导入到我们的新项目中：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We''re going to use a trick in Python called **dictionary based string formatting**.
    Let''s go over this for a minute before we continue. Suppose we are writing a
    chunk of CUDA C code, and we are unsure of whether we want a particular collection
    of variables to be float or double; perhaps it looks like this: `code_string="float
    x, y; float * z;"`. We might actually want to format the code so that we can switch
    between floats and doubles on the fly. Let''s change all references from `float` in
    the string to `%(precision)s`—`code_string="%(precision)s x, y; %(precision)s
    * z;"`. We can now set up an appropriate dictionary that will swap `%(presision)s` with
    `double`, which is, `code_dict = {''precision'' : ''double''}`, and get the new
    double string with `code_double = code_string % code_dict`. Let''s take a look:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将使用Python中称为**基于字典的字符串格式化**的技巧。 让我们在继续之前花一分钟来了解一下。 假设我们正在编写一段CUDA C代码，并且我们不确定是否希望特定的变量集是float还是double；也许看起来像这样：`code_string="float
    x, y; float * z;"`。 我们实际上可能希望格式化代码，以便我们可以随时在浮点数和双精度之间切换。 让我们将字符串中所有对`float`的引用更改为`%(precision)s`—`code_string="%(precision)s
    x, y; %(precision)s * z;"`。 现在，我们可以设置一个适当的字典，它将用`double`交换`%(presision)s`，即`code_dict
    = {''precision'' : ''double''}`，并使用`code_double = code_string % code_dict`获取新的双精度字符串。
    让我们看一下：'
- en: '![](assets/508d1ba2-6545-46ad-b443-f494ecbeba3f.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/508d1ba2-6545-46ad-b443-f494ecbeba3f.png)'
- en: Now, let's think for a moment about how we want our new Monte Carlo integrator
    to work. We will also have it take a string that is a math equation that is written
    using the CUDA Math API to define the function we want to integrate. We can then
    fit this string into the code using the dictionary trick we just learned, and
    use this to integrate arbitrary functions. We will also use the template to switch
    between `float` and `double` precision, as per the user's discretion.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想一想我们想要我们的新蒙特卡洛积分器如何工作。 我们还将使其接受一个使用CUDA Math API编写的数学方程的字符串，以定义我们想要积分的函数。
    然后，我们可以使用我们刚学到的字典技巧将这个字符串嵌入到代码中，并使用它来积分任意函数。 我们还将使用模板在`float`和`double`精度之间进行切换，根据用户的自由裁量。
- en: 'We can now begin our CUDA C code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始我们的CUDA C代码：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will keep the unsigned 64-bit integer macro from before, `ULL`. Let''s define
    some new macros for a reciprocal of x (`_R`), and for squaring (`_P2`):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留以前的无符号64位整数宏`ULL`。 让我们为x的倒数（`_R`）和平方（`_P2`）定义一些新的宏：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s define a device function that our equation string will plug into.
    We will use the `math_function` value when we have to swap the text from a dictionary.
    We will have another value called `p`, for precision (which will either be a `float`
    or `double`). We''ll call this device function `f`. We''ll put an `inline` in
    the declaration of the function, which will save us a little time from branching
    when this is called from the kernel:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个设备函数，我们的方程字符串将插入其中。 当我们必须从字典中交换文本时，我们将使用`math_function`值。 我们将有另一个值称为`p`，表示精度（将是`float`或`double`）。
    我们将称这个设备函数为`f`。 我们将在函数的声明中放置一个`inline`，这将节省我们一些时间，因为从核心调用时会有一些分支：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, let's think about how this will work— We declare a 32 or 64-bit floating
    point value called `y`, call `math_function`, and then return `y`. `math_function`, which
    will only make sense if it's some code that acts on the input parameter `x` and
    sets some value to `y`, such as `y = sin(x)`. Let's keep this in mind and continue.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一下这将如何工作——我们声明一个名为`y`的32位或64位浮点值，调用`math_function`，然后返回`y`。 `math_function`，如果它是对输入参数`x`进行操作并将某个值设置为`y`的一些代码，那么这只有意义。
    让我们记住这一点，然后继续。
- en: We will now begin writing our Monte Carlo integration kernel. Let's remember
    that we have to make our CUDA kernel visible from plain C with the `extern "C"` keyword.
    We will then set up our kernel.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始编写我们的蒙特卡洛积分核。 让我们记住，我们必须使用`extern "C"`关键字使我们的CUDA核可从普通C中访问。 然后我们将设置我们的核心。
- en: 'First, we will indicate how many random samples each thread in the kernel should
    take with `iters`; we then indicate the lower bound of integration (*b*) with
    `lo` and the upper bound (*a*) with `hi`, and pass in an array, `ys_out`, to store
    the collection of partial integrals for each thread (we will later sum over `ys_out`
    to get the value of the complete definite integral from `lo` to `hi` on the host
    side). Again, notice how we are referring to the precision as `p`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将用`iters`指示内核中每个线程应该采样多少随机样本；然后我们用`lo`指示积分的下界（*b*），用`hi`指示上界（*a*），并传入一个数组`ys_out`来存储每个线程的部分积分集合（我们稍后将对`ys_out`求和，以得到从主机端的`lo`到`hi`的完整定积分值）。再次注意我们将精度称为`p`：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will need a `curandState` object for generating random values. We will also
    need to find the global thread ID and the total number of threads. Since we are
    working with a one-dimensional mathematical function, it makes sense to set up
    our block and grid parameters in one dimension, `x`, as well:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一个`curandState`对象来生成随机值。我们还需要找到全局线程ID和线程的总数。由于我们正在处理一维数学函数，因此在一维`x`中设置我们的块和网格参数是有意义的：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will now calculate the amount of area there is between `lo` and `hi` that
    a single thread will process. We''ll do this by dividing up the entire length
    of the integration (which will be `hi - lo`) by the total number of threads.:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们将计算单个线程将处理的`lo`和`hi`之间的面积量。我们将通过将整个积分的长度（即`hi - lo`）除以线程的总数来实现这一点。:'
- en: Again, note how we are using templating tricks so that this value can be multi-precision.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意我们如何使用模板技巧，以便这个值可以是多精度的。
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Recall that we have a parameter called `iters`; this indicates how many random
    values each thread will sample. We need to know what the density of the samples
    is in a little bit; that is, the average number of samples per unit distance.
    We calculate it like so, remembering to typecast the integer `iters` into a floating-point
    value:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们有一个名为`iters`的参数；这表示每个线程将采样多少个随机值。我们需要稍后知道样本的密度是多少；也就是说，每单位距离的平均样本数。我们可以这样计算，记得将整数`iters`强制转换为浮点值：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Recall that we are dividing the area we are integrating over by the number
    of threads. This means that each thread will have its own start and end point.
    Since we are dividing up the lengths fairly for each thread, we calculate this
    like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们正在将我们正在积分的区域按线程数进行划分。这意味着每个线程将有自己的起点和终点。由于我们正在为每个线程公平地划分长度，我们可以这样计算：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can now initialize cuRAND like we did previously, making sure that each
    thread is generating random values from its own individual seed:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像之前一样初始化cuRAND，确保每个线程都从自己的个体种子生成随机值：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Before we start sampling, we will need to set up some additional floating point
    values. `y` will hold the final value for the integral estimate from `t_lo` to
    `t_hi`, and `y_sum` will hold the sum of all of the sampled values. We will also
    use the `rand_val` variable to hold the raw random value we generate, and `x`
    to store the scaled random value from the area that we will be sampling from:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始采样之前，我们需要设置一些额外的浮点值。`y`将保存从`t_lo`到`t_hi`的积分估计的最终值，`y_sum`将保存所有采样值的总和。我们还将使用`rand_val`变量来保存我们生成的原始随机值，`x`来存储我们将要从中采样的区域的缩放随机值：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s loop to the sample values from our function, adding the values
    into `y_sum`. The one salient thing to notice is the `%(p_curand)`s at the end
    of `curand_uniform—`the 32-bit floating point version of this function is `curand_uniform`,
    while the 64-bit version is `curand_uniform_double`. We will have to swap this
    with either `_double` or an empty string later, depending on what level of precision
    we go with here. Also, notice how we scale `rand_val` so that `x` falls between
    `t_lo` and `t_hi`, remembering that random uniform distributions in cuRAND only
    yields values between 0 and 1:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们循环从我们的函数中取样值，将这些值加入`y_sum`中。需要注意的一点是`curand_uniform`末尾的`%(p_curand)`s——这个函数的32位浮点版本是`curand_uniform`，而64位版本是`curand_uniform_double`。稍后我们将根据这里使用的精度级别，用`_double`或空字符串来替换它。还要注意我们如何缩放`rand_val`，使得`x`落在`t_lo`和`t_hi`之间，记住cuRAND中的随机均匀分布只产生0到1之间的值：
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can now calculate the value of the subintegral from `t_lo` to `t_hi` by
    dividing `y_sum` by density:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过密度将`y_sum`除以`t_hi`到`t_lo`的子积分的值：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We output this value into the array and close off our CUDA kernel, as well
    as the `extern "C"`, with the final closing bracket. We''re done writing CUDA
    C, so we will close off this section with a triple-quote:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个值输出到数组中，并关闭我们的CUDA内核，以及`extern "C"`，以及最终的闭括号。我们已经写完了CUDA C，所以我们将用三个引号结束这一部分：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We will now do something a little different—we're going to set up a class to
    handle our definite integrals. Let's call it `MonteCarloIntegrator`. We will start,
    of course, by writing the constructor, that is, the `__init__` function. This
    is where we will input the object reference, `self`. Let's set up the default
    value for `math_function` to be `'y = sin(x)'`, with the default precision as
    `'d'`, for double. We'll also set the default value for `lo` as 0 and `hi` as
    the NumPy approximation of π . Finally, we'll have values for the number of random
    samples each thread will take (`samples_per_thread`), and the grid size that we
    will launch our kernel over (`num_blocks`).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做一些不同的事情——我们将设置一个类来处理我们的定积分。让我们称之为`MonteCarloIntegrator`。当然，我们将首先编写构造函数，也就是`__init__`函数。这是我们将输入对象引用`self`的地方。让我们将`math_function`的默认值设置为`'y
    = sin(x)'`，默认精度为`'d'`，即双精度。我们还将把`lo`的默认值设置为0，`hi`的默认值设置为π的NumPy近似值。最后，我们将有每个线程将采样的随机样本数（`samples_per_thread`）和我们将在其上启动内核的网格大小（`num_blocks`）的值。
- en: 'Let''s start this function by storing the text string `math_function` within
    the `self` object for later use:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将文本字符串`math_function`存储在`self`对象中开始这个函数，以便以后使用：
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s set up the values related to our choice of floating-point precision
    that we will need for later, particularly for setting up our template dictionary.
    We will also store the `lo` and `hi` values within the object. Let''s also be
    sure to raise exception errors if the user inputs an invalid datatype, or if `hi`
    is actually smaller than `lo`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置与我们选择的浮点精度相关的值，这将在以后设置我们的模板字典时特别需要，特别是为了存储`lo`和`hi`的值。让我们还在对象中存储`lo`和`hi`的值。如果用户输入无效的数据类型，或者`hi`实际上小于`lo`，让我们确保引发异常错误：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now set up our code template dictionary:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以设置我们的代码模板字典：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can now generate the actual final code using dictionary-based string formatting,
    and compile. Let''s also turn off warnings from the `nvcc` compiler by setting
    `options=[''-w'']` in `SourceModule`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用基于字典的字符串格式生成实际的最终代码，并进行编译。让我们还通过在`SourceModule`中设置`options=['-w']`来关闭`nvcc`编译器的警告：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We will now set up a function reference in our object to our compiled kernel
    with `get_function`. Let''s save the remaining two parameters within our object
    before we continue:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在我们的对象中设置一个函数引用到我们编译的内核，使用`get_function`。在继续之前，让我们保存对象中的剩余两个参数：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, while we will need different instantiations of `MonteCarloIntegrator` objects
    to evaluate definite integrals of different mathematical functions or floating
    point precision, we might want to evaluate the same integral over different `lo`
    and `hi` bounds, change the number of threads/grid size, or alter the number of
    samples we take at each thread. Thankfully, these are easy alterations to make,
    and can all be made at runtime.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然我们需要不同实例的`MonteCarloIntegrator`对象来评估不同数学函数或浮点精度的定积分，但我们可能希望在不同的`lo`和`hi`边界上评估相同的积分，改变线程/网格大小，或者改变我们在每个线程上取样的数量。幸运的是，这些都是容易进行的修改，并且都可以在运行时进行。
- en: 'We''ll set up a specific function for evaluating the integral of a given object.
    We will set the default values of these parameters to be those that we stored
    during the call to the constructor:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个特定的函数来评估给定对象的积分。我们将这些参数的默认值设置为在调用构造函数时存储的值：
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can finish this function off by setting up an empty array to store the partial
    sub-integrals and launching the kernel. We then need to sum over the sub-integrals
    to get the final value, which we return:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置一个空数组来存储部分子积分并启动内核来完成这个函数。然后我们需要对子积分求和以获得最终值，然后返回：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We are ready to try this out. Let''s just set up a class with the default values—this
    will integrate `y = sin(x)` from 0 to π. If you remember calculus, the anti-derivative
    of *sin(x)* is *-cos(x)*, so we can evaluate the definite integral like so:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好尝试这个了。让我们只是设置一个具有默认值的类——这将从0到*π*积分`y = sin(x)`。如果您记得微积分，*sin(x)*的反导数是*-cos(x)*，所以我们可以这样评估定积分：
- en: '![](assets/0f237e46-f4f9-459c-a1db-29766ce488b7.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0f237e46-f4f9-459c-a1db-29766ce488b7.png)'
- en: 'Therefore, we should get a numerical value close to 2\. Let''s see what we
    get:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该得到一个接近2的数值。让我们看看我们得到了什么：
- en: '![](assets/49e7d08f-4958-4e3e-96f6-2168b71e628a.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/49e7d08f-4958-4e3e-96f6-2168b71e628a.png)'
- en: Writing some test cases
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一些测试用例
- en: Now, we will finally get to see how to use the CUDA Math API to write some test
    cases for our class by way of the `math_function` parameter. These will be fairly
    straightforward if you have any experience with the C/C++ standard math library.
    Again, these functions are overloaded so that we don't have to change the names
    of anything when we switch between single and double precision.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于将看到如何使用CUDA Math API通过`math_function`参数编写一些测试用例来测试我们的类。如果您有C/C++标准数学库的经验，这将会相当简单。同样，这些函数是重载的，这样当我们在单精度和双精度之间切换时，我们就不必更改任何名称。
- en: 'We''ve already seen one example, namely *y = sin(x)*. Let''s try something
    a little more ambitious:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个例子，即*y = sin(x)*。让我们尝试一些更有雄心的东西：
- en: '![](assets/94a6e5b9-688f-4fee-9cde-34949e6f0386.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/94a6e5b9-688f-4fee-9cde-34949e6f0386.png)'
- en: We will integrate this function from *a=*11.733 to *b=*18.472, and then check
    the output of our Monte Carlo integrator against the known value of this integral
    from another source. Here, Mathematica indicates that the value of this definite
    integral is 8.9999, so we will check against that.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从*a=*11.733积分到*b=*18.472，然后检查我们的蒙特卡洛积分器的输出与另一个来源的已知值进行比较。在这里，Mathematica指出这个定积分的值是8.9999，所以我们将与其进行比较。
- en: 'Now, let''s think of how to represent this function: here, *log* refers to
    the base-*e* logarithm (also known as *ln*), and this is just `log(x)` in the
    Math API. We already set up a macro for squaring, so we can represent *sin²(x)*
    as `_P2(sin(x))`. We can now represent the entire function with `y = log(x)*_P2(sin(x))`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑如何表示这个函数：这里，*log*指的是自然对数（也称为*ln*），在Math API中就是`log(x)`。我们已经设置了一个宏来表示平方，所以我们可以用`_P2(sin(x))`来表示*sin²(x)*。现在我们可以用`y
    = log(x)*_P2(sin(x))`来表示整个函数。
- en: 'Let''s use the following equation, integrating from *a=.9* to *b=4*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下方程，从*a=.9*积分到*b=4*：
- en: '![](assets/41e43277-2c80-488e-b8ab-78355f6c0c53.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/41e43277-2c80-488e-b8ab-78355f6c0c53.png)'
- en: 'Remembering that `_R` is the macro we set up for a reciprocal, we can write
    the function with the Math API like so:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`_R`是我们设置的倒数宏，我们可以这样用Math API来写这个函数：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Before we move on, let's note that Mathematica tells us that the value of this
    definite integral is .584977.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们注意到Mathematica告诉我们这个定积分的值是.584977。
- en: 'Let''s check on one more function. Let''s be a little ambitious and say that
    it''s this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再检查一个函数。让我们有点雄心勃勃地说它是这样的：
- en: '![](assets/b33f7b41-e613-4e37-96ac-9b12a223a7e0.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b33f7b41-e613-4e37-96ac-9b12a223a7e0.png)'
- en: We can represent this as `'y = (cosh(x)*sin(x))/ sqrt( pow(x,3) + _P2(sin(x)))'`;
    naturally `sqrt` is the square root in the denominator, and `pow` allows us to
    take a value of arbitrary power. Of course, `sin(x)` is *sin(x)* and `cosh(x)`
    is *cosh(x)*. We integrate this from *a*=1.85 to *b*=4.81; Mathematica tells us
    that the true value of this integral is -3.34553.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这表示为`'y = (cosh(x)*sin(x))/ sqrt( pow(x,3) + _P2(sin(x)))'`；自然地，`sqrt`是分母中的平方根，`pow`允许我们取任意幂的值。当然，`sin(x)`是*sin(x)*，`cosh(x)`是*cosh(x)*。我们从*a*=1.85积分到*b*=4.81；Mathematica告诉我们这个积分的真实值是-3.34553。
- en: 'We are now ready to check some test cases and verify that our Monte Carlo integral
    is working! Let''s iterate over a list, whose first value is a string indicating
    the function (using the Math API), the second value indicates the lower bound
    of integration, the third indicates the upper bound of integration, and the last
    value indicates the expected value that was calculated with Mathematica:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备检查一些测试用例，并验证我们的蒙特卡洛积分是否有效！让我们迭代一个列表，其第一个值是指示函数（使用Math API）的字符串，第二个值指示积分的下限，第三个值指示积分的上限，最后一个值指示用Mathematica计算出的预期值：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can now iterate over this list and see how well our algorithm works compared
    to Mathematica:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以迭代这个列表，看看我们的算法与Mathematica相比效果如何：
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let''s run this right now:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就运行这个：
- en: '![](assets/b788faff-a6b9-4c86-ad21-26edd0e614e6.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b788faff-a6b9-4c86-ad21-26edd0e614e6.png)'
- en: This is also available as the `monte_carlo_integrator.py` file under the `Chapter08`
    directory in this book's repository.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以在本书存储库的`Chapter08`目录下的`monte_carlo_integrator.py`文件中找到。
- en: The CUDA Thrust library
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CUDA Thrust库
- en: We will now look at the CUDA Thrust Library. This library's central feature
    is a high-level vector container that is similar C++'s own vector container. While
    this may sound trivial, this will allow us to program in CUDA C with less reliance
    on pointers, mallocs, and frees. Like the C++ vector container, Thrust's vector
    container handles the resizing and concatenation of elements automatically, and
    with the magic of C++ destructors, *freeing* is also handled automatically when
    a Thrust vector object goes out of scope.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看一下CUDA Thrust库。这个库的核心特性是一个高级向量容器，类似于C++自己的向量容器。虽然这听起来可能很琐碎，但这将使我们在CUDA
    C中编程时更少地依赖指针、malloc和free。与C++向量容器一样，Thrust的向量容器会自动处理元素的调整大小和连接，并且借助C++析构函数的魔力，*释放*也会在Thrust向量对象超出范围时自动处理。
- en: 'Thrust actually provides two vector containers: one for the host-side, and
    one for the device-side. The host-side Thrust vector is more or less identical
    to the STL vector, with the main difference being that it can interact more easily
    with the GPU. Let''s write a little bit of code in proper CUDA C to get a feel
    for how this works.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Thrust实际上提供了两个向量容器：一个用于主机端，一个用于设备端。主机端的Thrust向量与STL向量几乎相同，主要区别在于它可以更轻松地与GPU交互。让我们用适当的CUDA
    C代码写一点代码，以了解它是如何工作的。
- en: 'Let''s start with the include statements. We''ll be using the headers for both
    the host and device side vectors, and we''ll also include the C++ `iostream` library,
    which will allow us to perform basic I/O operations on the Terminal:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从包含语句开始。我们将使用主机和设备端向量的头文件，并且还将包括C++的`iostream`库，这将允许我们在终端上执行基本的I/O操作：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s just use the standard C++ namespace (this is so that we don''t have
    to type in the `std::` resolution operator when checking the output):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们只使用标准的C++命名空间（这样我们在检查输出时就不必输入`std::`分辨率运算符）：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We will now make our main function and set up an empty Thrust vector on the
    host side. Again, these are C++ templates, so we have to choose the datatype upon
    declaration with the `< >` brackets. We will set this up to be an array of integers:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将制作我们的主函数，并在主机端设置一个空的Thrust向量。同样，这些都是C++模板，所以我们必须在声明时使用`< >`括号选择数据类型。我们将把这设置为一个整数数组：
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let''s append some integers to the end of `v` by using `push_back`, exactly
    how we would do so with a regular STL vector:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用`push_back`在`v`的末尾添加一些整数，就像我们用常规STL向量一样：
- en: '[PRE45]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We will now iterate through all of the values in the vector, and output each
    value:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将迭代向量中的所有值，并输出每个值：
- en: The output here should be `v[0] == 1` through `v[3] == 4`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的输出应该是`v[0] == 1`到`v[3] == 4`。
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This may have seemed trivial so far. Let''s set up a Thrust vector on the GPU
    and then copy the contents from `v`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这可能看起来很琐碎。让我们在GPU上设置一个Thrust向量，然后将内容从`v`复制过去：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Yes, that's all—only one line, and we're done. All of the content of `v` on
    the host will now be copied to `v_gpu` on the device! (If this doesn't amaze you,
    please take another look at [Chapter 6](6d1c808f-1dc2-4454-b0b8-d0a36bc3c908.xhtml),
    *Debugging and Profiling Your CUDA Code*, and think about how many lines this
    would have taken us before.)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，就这样了——只有一行，我们就完成了。现在主机上的`v`的所有内容都将被复制到设备上的`v_gpu`！（如果这让你感到惊讶，请再看一下[第6章](6d1c808f-1dc2-4454-b0b8-d0a36bc3c908.xhtml)，*调试和分析您的CUDA代码*，想想在这之前我们需要多少行。）
- en: 'Let''s try using `push_back` on our new GPU vector, and see if we can concatenate
    another value to it:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在我们的新GPU向量上使用`push_back`，看看我们是否可以将另一个值连接到它上面：
- en: '[PRE48]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We will now check the contents of `v_gpu`, like so:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将检查`v_gpu`的内容，如下所示：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This part should output `v_gpu[0] == 1` through `v_gpu[4] == 5`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分应该输出`v_gpu[0] == 1`到`v_gpu[4] == 5`。
- en: 'Again, thanks to the destructors of these objects, we don''t have to do any
    cleanup in the form of freeing any chunks of allocated memory. We can now just
    return from the program, and we are done:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 再次感谢这些对象的析构函数，我们不必进行任何清理工作，释放任何已分配内存的块。现在我们可以从程序中返回，我们完成了：
- en: '[PRE50]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Using functors in Thrust
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Thrust中使用函数对象
- en: Let's see how we can use a concept known as **functors** in Thrust. In C++,
    a **functor** is a class or struct object that looks and acts like a function;
    this lets us use something that looks and acts like a function, but can hold some
    parameters that don't have to be set every time it is used.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Thrust中使用称为**functors**的概念。在C++中，**functor**是一个看起来和行为像函数的类或结构对象；这让我们可以使用看起来和行为像函数的东西，但可以保存一些不必每次使用时都设置的参数。
- en: 'Let''s start a new Thrust program with the appropriate include statements,
    and use the standard namespace:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用适当的包含语句开始一个新的Thrust程序，并使用标准命名空间：
- en: '[PRE51]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, let''s set up a basic functor. We will use a `struct` to represent this,
    rather than `class`. This will be a weighted multiplication function, and we will
    store the weight in a float called `w`. We will make a constructor that sets up
    the weight with a default value of `1`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置一个基本的函数对象。我们将使用`struct`来表示这个函数对象，而不是`class`。这将是一个加权乘法函数，我们将在一个名为`w`的浮点数中存储权重。我们将创建一个构造函数，用默认值`1`设置权重：
- en: '[PRE52]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We will now set up our functor with the `operator()` keyword; this will indicate
    to the compiler to treat the following block of code as the `default` function
    for objects of this type. Remember that this will be running on the GPU as a device
    function, so we precede the whole thing with `__device__`. We indicate the inputs
    with parentheses and output the appropriate value, which is just a scaled multiple.
    Now, we can close off the definition of our struct with `};`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`operator()`关键字设置我们的函数对象；这将告诉编译器将以下代码块视为此类型对象的`default`函数。请记住，这将在GPU上作为设备函数运行，因此我们在整个代码块之前加上`__device__`。我们用括号指示输入，并输出适当的值，这只是一个缩放的倍数。现在，我们可以用`};`关闭我们的结构的定义：
- en: '[PRE53]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, let''s use this to make a basic dot product function; recall that this
    requires a pointwise multiplication between two arrays, followed by a `reduce` type
    sum. Let''s start by declaring our function and creating a new vector, `z`, that
    will hold the values of the point-wise multiplication:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用这个来制作一个基本的点积函数；回想一下，这需要两个数组之间的逐点乘法，然后是一个`reduce`类型的求和。让我们首先声明我们的函数，并创建一个新的向量`z`，它将保存逐点乘法的值：
- en: '[PRE54]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We will now use Thrust''s `transform` operation, which will act on the inputs
    of `v` and `w` point-wise, and output into `z`. Notice how we input the functor
    into the last slot of transform; by using the plain closed parentheses like so,
    it will use the default value of the constructor (w = 1) so that this will act
    as a normal, non-weighted/scaled dot product:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用Thrust的`transform`操作，它将对`v`和`w`的输入进行逐点操作，并输出到`z`。请注意，我们将函数对象输入到transform的最后一个槽中；通过这样使用普通的闭括号，它将使用构造函数的默认值（w
    = 1），因此这将作为一个普通的、非加权/缩放的点积：
- en: '[PRE55]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can now sum over `z` with Thrust''s reduce function. Let''s just return
    the value:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用Thrust的reduce函数对`z`进行求和。让我们返回这个值：
- en: '[PRE56]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We're done. Now, let's write some test code—we'll just take the dot product
    of the vectors `[1,2,3]` and `[1,1,1]`, which will be easy for us to check. (This
    will be 6.)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了。现在，让我们编写一些测试代码——我们将只计算向量`[1,2,3]`和`[1,1,1]`的点积，这对我们来说很容易检查。（结果将是6。）
- en: 'Let''s just set up the first vector, `v`, using `push_back`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`push_back`设置第一个向量`v`：
- en: '[PRE57]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We can now declare a vector, `w`, to be of size `3`, and we can set its default
    values to `1` using Thrust''s fill function, like so:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以声明一个大小为`3`的向量`w`，并使用Thrust的fill函数将其默认值设置为`1`，如下所示：
- en: '[PRE58]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s do a check to make sure that our values are set correctly by outputting
    their values to `cout`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一次检查，确保我们的值被正确设置，通过将它们的值输出到`cout`：
- en: '[PRE59]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, we can check the output of our dot product, and then return from the program:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以检查我们的点积的输出，然后从程序中返回：
- en: '[PRE60]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s compile this (from the command line in both Linux or Windows by using
    `nvcc thrust_dot_product.cu -o thrust_dot_product`) and run it:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编译这个程序（在Linux或Windows的命令行中使用`nvcc thrust_dot_product.cu -o thrust_dot_product`）并运行它：
- en: '![](assets/03884f6c-d05f-4127-a8b1-3f66dd0cbbf9.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/03884f6c-d05f-4127-a8b1-3f66dd0cbbf9.png)'
- en: The code for this is also available in the `thrust_dot_product.cu` file in the
    `Chapter08` directory in this book's repository.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码也可以在本书存储库的`Chapter08`目录中的`thrust_dot_product.cu`文件中找到。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to initialize a stream of random numbers in
    cuRAND by choosing the appropriate seed. Since computers are deterministic devices,
    they can only generate lists of pseudo-random numbers, so our seed should be something
    truly random; generally, adding a thread ID to the clock time in milliseconds
    will work well enough for most purposes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了如何通过选择适当的种子在cuRAND中初始化随机数流。由于计算机是确定性设备，它们只能生成伪随机数列表，因此我们的种子应该是真正随机的；通常，将线程ID添加到毫秒级的时钟时间中就足够满足大多数目的。
- en: We then looked at how we can use the uniform distribution from cuRAND to do
    a basic estimate of Pi. Then we took on a more ambitious project of creating a
    Python class that can compute definite integrals of arbitrary functions; we used
    some ideas from metaprogramming coupled with the CUDA Math API to define these
    `arbitrary` functions. Finally, we had a brief overview of the CUDA Thrust library,
    which is generally used for writing pure CUDA C programs outside of Python. Thrust
    most notably provides a `device_vector` container that is similar to the standard
    C++ `vector`. This reduces some of the cognitive overhead from using pointers
    in CUDA C.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看了如何使用cuRAND的均匀分布来对Pi进行基本估计。然后，我们承担了一个更有雄心的项目，创建一个可以计算任意函数的定积分的Python类；我们使用了一些元编程的思想，结合CUDA
    Math API来定义这些`任意`函数。最后，我们简要介绍了CUDA Thrust库，它通常用于在Python之外编写纯CUDA C程序。Thrust最显著的提供了一个类似于标准C++
    `vector`的`device_vector`容器。这减少了在CUDA C中使用指针的一些认知开销。
- en: Finally, we looked at a brief example of how to use Thrust with an appropriate
    functor to do simple `point-wise` and `reduce` operations, in the form of the
    implementation of a simple dot product function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要介绍了如何使用Thrust和适当的函数对象来执行简单的`point-wise`和`reduce`操作，即实现一个简单的点积函数。
- en: Questions
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Try rewriting the Monte Carlo integration examples (in the `__main__` function
    in `monte_carlo_integrator.py`) to use the CUDA `instrinsic` functions. How does
    the accuracy compare to before?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试重写蒙特卡洛积分示例（在`monte_carlo_integrator.py`的`__main__`函数中）以使用CUDA的`intrinsic`函数。精度与以前相比如何？
- en: We only used the uniform distribution in all of our cuRAND examples. Can you
    name one possible use or application of using the normal (Gaussian) random distribution
    in GPU programming?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们所有的cuRAND示例中，我们只使用了均匀分布。你能说出在GPU编程中使用正态（高斯）随机分布的一个可能的用途或应用吗？
- en: Suppose that we use two different seeds to generate a list of 100 pseudo-random
    numbers. Should we ever concatenate these into a list of 200 numbers?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们使用两个不同的种子生成一个包含100个伪随机数的列表。我们应该将它们连接成一个包含200个数字的列表吗？
- en: In the last example, try adding `__host__` before `__device__` in the definition
    of our `operator()` function in the `multiply_functor` struct. Now, see if you
    can directly implement a host-side dot-product function using this functor without
    any further modifications.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一个示例中，在`multiply_functor`结构体的`operator()`函数定义之前添加`__host__`，现在，看看是否可以直接使用这个函数对象实现一个主机端的点积函数，而不需要任何进一步的修改。
- en: Take a look at the `strided_range.cu` file in the Thrust `examples` directory.
    Can you think of how to use this to implement a general matrix-matrix multiplication
    using Thrust?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下Thrust `examples`目录中的`strided_range.cu`文件。你能想到如何使用这个来使用Thrust实现通用矩阵乘法吗？
- en: What is the importance of the `operator()` function when defining a functor?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义一个函数对象时，`operator()`函数的重要性是什么？
