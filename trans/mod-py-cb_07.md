# 第七章。更高级的类设计

在本章中，我们将看一下以下的配方：

+   在继承和扩展之间进行选择 - is-a 问题

+   通过多重继承分离关注点

+   利用 Python 的鸭子类型

+   管理全局和单例对象

+   使用更复杂的结构 - 映射列表

+   创建一个具有可排序对象的类

+   定义一个有序集合

+   从映射列表中删除

# 介绍

在第六章的*类和对象的基础*中，我们看了一些涵盖类设计基础的配方。在本章中，我们将更深入地了解 Python 类。

在第六章的*设计具有大量处理的类*和*使用属性进行惰性属性*中，我们确定了面向对象编程的一个设计选择，即包装与扩展的选择。可以通过扩展向类添加功能，也可以创建一个新的类，将现有类包装起来添加新功能。Python 中有许多扩展技术可供选择。

Python 类可以从多个超类继承特性。这可能会导致混乱，但一个简单的设计模式，即**mixin**，可以避免问题。

一个更大的应用程序可能需要一些全局数据，这些数据被许多类或模块广泛共享。这可能很难管理。然而，我们可以使用一个模块来管理全局对象并创建一个简单的解决方案。

在第四章的*内置数据结构 - 列表，集合，字典*中，我们看了核心的内置数据结构。现在是时候结合一些特性来创建更复杂的对象了。这也可以包括扩展内置数据结构以添加复杂性。

# 在继承和扩展之间进行选择 - is-a 问题

在第五章的*使用 cmd 创建命令行应用程序*和第六章的*扩展集合 - 进行统计的列表*中，我们看到了扩展类的方法。在这两种情况下，我们的类都是内置类的子类。

扩展的概念有时被称为泛化-特化关系。有时也被称为**is-a 关系**。

这里有一个重要的语义问题，我们也可以总结为**包装与扩展问题**：

+   我们真的是指子类是超类的一个例子吗？这就是 is-a 关系。Python 中的一个例子是内置的`Counter`，它扩展了基类`dict`。

+   或者我们是指其他的东西吗？也许有一种关联，有时被称为**has-a 关系**。这在第六章的*设计具有大量处理的类*中有一个例子，其中`CounterStatistics`包装了一个`Counter`对象。

有什么好方法来区分这两种技术吗？

## 准备工作

这个问题有点形而上学的哲学，特别关注**本体论**的思想。本体论是定义存在类别的一种方式。

当我们扩展一个对象时，我们必须问以下问题：

> *“这是一个新类的对象，还是现有类的对象的混合？”*

我们将看两种模拟一副扑克牌的方法：

+   作为一个扩展内置`list`类的新类对象

+   作为一个将内置的`list`类与其他一些特性结合的包装器

一副牌是一组卡片。那么，核心成分就是底层的`Card`对象。我们将使用`namedtuple()`来非常简单地定义这个：

```py
 **>>> from collections import namedtuple 
>>> Card = namedtuple('Card', ('rank', 'suit')) 
>>> SUITS = '\u2660\u2661\u2662\u2663' 
>>> Spades, Hearts, Diamonds, Clubs = SUITS 
>>> Card(2, Spades) 
Card(rank=2, suit='♣')** 

```

我们使用`namedtuple()`创建了类定义`Card`。这创建了一个具有两个属性 - `rank`和`suit`的简单类。

我们还将各种花色`SUITS`定义为 Unicode 字符的字符串。为了更容易地创建特定花色的卡片，我们还将字符串分解为四个单个字符的子字符串。如果您的交互环境无法正确显示 Unicode 字符，您可能会遇到问题。可能需要更改操作系统环境变量`PYTHONIOENCODING`为“UTF-8”，以便进行正确的编码。

`\u2660`字符串是一个 Unicode 字符。您可以通过`len(SUITS) == 4`来确认这一点。如果长度不是 4，请检查是否有多余的空格。

我们将在本配方的其余部分使用这个`Card`类。在一些纸牌游戏中，使用一副 52 张卡片的牌组。在其他游戏中，使用发牌鞋。鞋子是一个允许荷官将多副牌洗在一起并方便地发牌的盒子。

重要的是各种集合 - 牌组、鞋子和内置列表在它们支持的功能种类上有相当大的重叠。它们都或多或少相关吗？还是它们基本上是不同的？

## 如何做...

我们将在第六章中的*使用类封装数据和处理*配方中，与此配方一起包装*类和对象的基础*：

1.  使用原始故事或问题陈述中的名词和动词来识别所有的类。

1.  寻找各种类的特征集中的重叠。在许多情况下，关系将直接来自问题陈述本身。在我们之前的例子中，游戏可以从一副牌中发牌，或者从一双鞋中发牌。在这种情况下，我们可能陈述这两种观点之一：

+   鞋子是一个专门的牌组，由 52 张卡片的多个副本开始

+   一副牌是一个专门的鞋子，只有 52 张卡片的一个副本

1.  创建一个小本体，澄清类之间的关系。有几种关系。

一些类彼此独立。它们是为了实现用户故事而链接的。在我们的例子中，`Card`指的是花色的字符串。这两个对象彼此独立。许多卡片将共享一个常见的花色字符串。这些是对象之间的普通引用，没有特殊的设计考虑：

+   **聚合**：一些对象被绑定到集合中，但这些对象具有独立的存在。我们的`Card`对象可能被聚合到一个`Hand`集合中。游戏结束时，`Hand`对象可以被删除，但`Card`对象仍然存在。我们可以创建一个引用内置`list`的`Deck`。

+   **组合**：一些对象被绑定到集合中，但没有独立的存在。在看牌游戏时，一手牌不能没有玩家而存在。我们可能会说`Player`对象在某种程度上是由`Hand`组成的。如果一个`Player`被从游戏中淘汰，那么`Hand`对象也必须被移除。虽然这对于理解对象之间的关系很重要，但在下一节中我们将考虑一些实际的考虑。

+   **是一个或继承**：这是一个`Shoe`是一个带有额外功能（或两个）的`Deck`的想法。这可能是我们设计的核心。我们将在本配方的*扩展 - 继承*部分详细研究这一点。

我们已经确定了几种实现关联的路径。聚合和组合案例都是包装技术。继承案例是扩展技术。我们将分别研究聚合和组合 - 包装技术和扩展技术。

### 包装 - 聚合和组合

包装是一种理解集合的方式。它可以是一个包含独立对象的类。它也是一个包装现有列表的组合，这意味着底层的`Card`对象将被`list`集合和`Deck`集合共享。

1.  定义独立的集合。它可能是一个内置的集合，例如`set`，`list`或`dict`。在这个例子中，它将是一个包含卡片的列表：

```py
            domain = [Card(r+1,s) for r in range(13) for s in SUITS] 

    ```

1.  定义聚合类。在这个例子中，名称带有`_W`后缀。这不是一个推荐的做法；这里只是为了更清楚地区分类定义之间的区别。稍后，我们将看到对这种设计的稍微不同的变化：

```py
            class Deck_W: 

    ```

1.  使用这个类的`__init__()`方法作为提供底层集合对象的一种方式。这也将初始化任何有状态的变量。我们可能会创建一个用于发牌的迭代器：

```py
            def __init__(self, cards:List[Card]): 
                self.cards = cards.copy() 
                self.deal_iter = iter(cards) 

    ```

这使用了一个类型提示，`List[Card]`。`typing`模块提供了`List`的必要定义。

1.  如果需要，提供其他方法来替换集合，或更新集合。这在 Python 中很少见，因为底层属性`cards`可以直接访问。然而，提供一个替换`self.cards`值的方法可能是有帮助的。

1.  提供适用于聚合对象的方法：

```py
            def shuffle(self): 
                random.shuffle(self.cards) 
                self.deal_iter = iter(self.cards) 
            def deal(self) -> Card: 
                return next(self.deal_iter) 

    ```

`shuffle()`方法随机化内部列表对象`self.cards`。`deal()`对象创建一个迭代器，可以用来遍历`self.cards`列表。我们在`deal()`上提供了一个类型提示，以澄清它返回一个`Card`实例。

这是我们如何使用这个类的方法。我们将共享一个`Card`对象列表。在这种情况下，`domain`变量是从一个列表推导式中创建的，该推导式生成了 13 个等级和四种花色的 52 种组合：

```py
 **>>> domain = list(Card(r+1,s) for r in range(13) for s in SUITS) 
>>> len(domain) 
52** 

```

我们可以使用这个集合中的项目`domain`来创建一个共享相同底层`Card`对象的第二个聚合对象。我们将从`domain`变量中的对象列表构建`Deck_W`对象：

```py
 **>>> import random 
>>> from ch07_r01 import Deck_W 
>>> d = Deck_W(domain)** 

```

一旦`Deck_W`对象可用，就可以使用独特的功能：

```py
 **>>> random.seed(1) 
>>> d.shuffle() 
>>> [d.deal() for _ in range(5)]  
[Card(rank=13, suit='♡'), 
Card(rank=3, suit='♡'), 
Card(rank=10, suit='♡'), 
Card(rank=6, suit='♢'), 
Card(rank=1, suit='♢')]** 

```

我们已经种子化了随机数生成器，以强制卡片有一个定义的顺序。这样可以进行单元测试。之后，我们根据随机种子对牌组进行了洗牌。一旦种子被播下，结果就是一致的，这样单元测试就变得容易了。我们可以从牌组中发出五张牌。这展示了`Deck_W`对象`d`如何与`domain`列表共享相同的对象池。

我们可以删除`Deck_W`对象`d`，并从`domain`列表中创建一个新的牌组。这是因为`Card`对象不是组合的一部分。这些卡片与`Deck_W`集合有独立的存在。

### 扩展-继承

这是一种定义扩展对象集合的类的方法。我们将一个`Deck`定义为一个包装现有列表的聚合体。底层的`Card`对象将被列表和`Deck`共享：

1.  将扩展类定义为内置集合的子类。在这个例子中，名称带有`_X`后缀。这不是一个推荐的做法；这里只是为了更清楚地区分这个配方中两个类定义之间的区别：

```py
            class Deck_X(list): 

    ```

这是一个清晰而正式的陈述——`Deck`是一个列表。

1.  使用从`list`类继承的`__init__()`方法。不需要代码。

1.  使用`list`类的其他方法来向`Deck`添加、更改或删除项目。不需要代码。

1.  为扩展对象提供适当的方法：

```py
            def shuffle(self): 
                random.shuffle(self) 
                self.deal_iter = iter(self) 
            def deal(self) -> Card: 
                return next(self.deal_iter) 

    ```

`shuffle()`方法将对象作为一个整体进行随机化，因为它是列表的扩展。`deal()`对象创建一个迭代器，可以用来遍历`self.cards`列表。我们在`deal()`上提供了一个类型提示，以澄清它返回一个`Card`实例。

这是我们如何使用这个类的方法。首先，我们将构建一副牌：

```py
 **>>> from ch07_r01 import Deck_X 
>>> d2 = Deck_X(Card(r+1,s) for r in range(13) for s in SUITS) 
>>> len(d2) 
52** 

```

我们使用生成器表达式构建了单独的`Card`对象。我们可以像使用`list()`类函数一样使用`Deck_X()`类函数。在这种情况下，我们从生成器表达式构建了一个`Deck_X`对象。我们也可以类似地构建一个`list`。

我们没有为内置的`__len__()`方法提供实现。这是从`list`类继承的，并且工作得很好。

对于这个实现，使用特定于牌组的特性看起来与另一个实现`Deck_W`完全相同：

```py
 **>>> random.seed(1) 
>>> d2.shuffle() 
>>> [d2.deal() for _ in range(5)]  
[Card(rank=13, suit='♡'), 
Card(rank=3, suit='♡'), 
Card(rank=10, suit='♡'), 
Card(rank=6, suit='♢'), 
Card(rank=1, suit='♢')]** 

```

我们已经初始化了随机数生成器，洗牌了牌组，并发了五张牌。扩展方法对`Deck_X`和`Deck_W`同样适用。`shuffle()`和`deal()`方法都能正常工作。

## 它是如何工作的...

Python 查找方法（或属性）的机制如下：

1.  在类中搜索方法或属性。

1.  如果在当前类中未定义名称，则在所有父类中搜索方法或属性。

这就是 Python 实现继承的方式。通过搜索父类，可以确保两件事：

+   任何超类中定义的方法都可用于所有子类

+   任何子类都可以重写一个方法来替换超类方法

因此，`list`类的子类继承了父类的所有特性。它是内置`list`类的专门变体。

这也意味着所有方法都有可能被子类重写。一些语言有方法可以锁定方法防止扩展。像 C++和 Java 这样的语言使用`private`关键字。Python 没有这个限制，子类可以重写任何方法。

要明确引用超类的方法，我们可以使用`super()`函数来强制搜索超类。这允许子类通过包装方法的超类版本来添加特性。我们可以像这样使用它：

```py
    def some_method(self): 
        # do something extra 
        super().some_method() 

```

在这种情况下，`some_method()`对象将执行一些额外的操作，然后执行方法的超类版本。这使我们能够方便地扩展类的选定方法。我们可以保留超类的特性，同时添加子类独有的特性。

## 还有更多...

在设计类时，我们必须在几种基本技术之间进行选择：

+   **包装**：这种技术创建了一个新的类。必须定义所有必需的方法。这可能需要大量的代码来提供所需的方法。包装可以分解为两种广泛的实现选择：

+   **聚合**：被包装的对象与包装器具有独立的存在。`Deck_W`示例展示了`Card`对象甚至牌组列表与类是独立的。当任何`Deck_W`对象被删除时，底层列表将继续存在。

+   **组合**：被包装的对象没有独立的存在；它们是组合的重要部分。这涉及到 Python 的引用计数的微妙难题。我们很快会详细看一下这个问题。

+   **通过继承进行扩展**：这是 is-a 关系。当扩展内置类时，许多方法都可以从超类中获得。`Deck_X`示例通过创建一个作为内置`list`类扩展的牌组来展示了这种技术。

在查看对象的独立存在时，有一个重要的考虑因素。我们实际上并没有从内存中删除对象。相反，Python 使用一种称为引用计数的技术来跟踪对象被使用的次数。例如`del deck`这样的语句实际上并没有删除`deck`对象，而是删除了`deck`变量，这会减少底层对象的引用计数。如果引用计数为零，则对象未被使用，可以被删除。

考虑以下示例：

```py
 **>>> c_2s = Card(2, Spades) 
>>> c_2s 
Card(rank=2, suit='♠') 
>>> another = c_2s 
>>> another 
Card(rank=2, suit='♠')** 

```

此时，我们有一个对象`Card(2, Spades)`，以及两个引用该对象的变量`c_2s`和`another`。

如果我们使用`del`语句删除其中一个变量，另一个变量仍然引用底层对象。直到两个变量都被删除，对象才能从内存中删除。

这一考虑使得聚合和组合的区别对于 Python 程序员来说基本上无关紧要。在不使用自动垃圾收集或引用计数器的语言中，组合变得重要，因为对象可能会消失。在 Python 中，对象不会意外消失。我们通常关注聚合，因为未使用的对象的删除是完全自动的。

## 另请参见

+   我们已经在第四章中查看了内置集合，*内置数据结构-列表、集合、字典*。此外，在第六章中，*类和对象的基础知识*，我们已经了解了如何定义简单的集合。

+   在*设计具有大量处理的类*配方中，我们研究了用一个处理处理细节的单独类包装一个类。我们可以将其与第六章中的*使用属性进行延迟属性*配方进行对比，*类和对象的基础知识*，在那里我们将复杂的计算作为属性放入类中；这种设计依赖于扩展。

# 通过多重继承分离关注点

在*选择继承和扩展之间-是一个问题*配方中，我们研究了定义一个`Deck`类的想法，它是扑克牌对象的组合。对于该示例，我们将每个`Card`对象简单地视为具有等级和花色。这产生了一些小问题：

+   卡片的显示总是显示数字等级。我们没有看到 J、Q 或 K。相反，我们看到 11、12 和 13。同样，Ace 显示为 1 而不是 A。

+   许多游戏，如*Blackjack*和*Cribbage*，为每个等级分配一个点值。通常，花牌有 10 点。对于 Blackjack，Ace 有两个不同的点值；取决于手中其他牌的总数，它可以值 1 点或 10 点。

我们如何处理卡牌游戏规则的所有变化？

## 准备好

`Card`类实际上是两个特征集的混合：

1.  一些基本特性，如等级和花色。

1.  一些特定于游戏的特性，如点数。对于*Cribbage*这样的游戏，无论上下文如何，点数都是一致的。然而，对于*Blackjack*，`Hand`和`Hand`中的`Card`对象之间存在关系。

Python 允许我们定义一个具有多个父类的类。一个类可以同时拥有`Card`超类和`GameRules`超类。

为了理解这种设计，我们经常将各种类层次结构分为两组特征：

+   **基本特征**：这包括`rank`和`suit`

+   **Mixin 特性**：这些特性被混合到类定义中

这个想法是一个工作类定义将具有基本特征和 mixin 特征。

## 如何做…

1.  定义基本类：

```py
            class Card: 
                __slots__ = ('rank', 'suit') 
                def __init__(self, rank, suit): 
                    super().__init__() 
                    self.rank = rank 
                    self.suit = suit 
                def __repr__(self): 
                    return "{rank:2d} {suit}".format( 
                        rank=self.rank, suit=self.suit 
                    ) 

    ```

我们已经定义了一个通用的`Card`类，适用于等级为 2 到 10。我们通过`super().__init__()`显式调用任何超类初始化。

1.  定义任何子类来处理特殊化：

```py
            class AceCard(Card): 
                def __repr__(self): 
                    return " A {suit}".format( 
                        rank=self.rank, suit=self.suit 
                    ) 
            class FaceCard(Card): 
                def __repr__(self): 
                    names = {11: 'J', 12: 'Q', 13: 'K'} 
                    return " {name} {suit}".format( 
                        rank=self.rank, suit=self.suit, 
                        name=names[self.rank] 
                    ) 

    ```

我们已经定义了`Card`类的两个子类。`AceCard`类处理 Ace 的特殊格式规则。`FaceCard`类处理 Jack、Queen 和 King 的其他格式规则。

1.  定义一个标识将要添加的附加特征的 mixin 超类。在某些情况下，mixin 将全部继承自一个共同的抽象类。在这个例子中，我们将使用一个处理 Ace 到 10 的规则的具体类：

```py
            class CribbagePoints: 
                def points(self): 
                    return self.rank 

    ```

对于*Cribbage*游戏，大多数卡片的点数等于卡片的等级。

1.  为各种特征定义具体的 mixin 子类：

```py
            class CribbageFacePoints(CribbagePoints): 
                def points(self): 
                    return 10 

    ```

对于三个花色的牌，点数总是 10。

1.  创建结合基本类和混合类的类定义。虽然在这里技术上可以添加独特的方法定义，但这经常会导致混乱。目标是有两组简单合并以创建结果类定义的特性。

```py
            class CribbageAce(AceCard, CribbagePoints): 
                pass 

            class CribbageCard(Card, CribbagePoints): 
                pass 

            class CribbageFace(FaceCard, CribbageFacePoints): 
                pass 

    ```

1.  创建一个工厂函数（或工厂类）来根据输入参数创建适当的对象：

```py
            def make_card(rank, suit): 
                if rank == 1: return CribbageAce(rank, suit) 
                if 2 <= rank < 11: return CribbageCard(rank, suit) 
                if 11 <= rank: return CribbageFace(rank, suit) 

    ```

1.  我们可以使用这个函数来创建一副牌：

```py
     **>>> from ch07_r02 import make_card, SUITS 
          >>> import random 
          >>> random.seed(1) 
          >>> deck = [make_card(rank+1, suit) for rank in range(13) for suit in SUITS] 
          >>> random.shuffle(deck) 
          >>> len(deck) 
          52 
          >>> deck[:5] 
          [ K ♡,  3 ♡, 10 ♡,  6 ♢,  A ♢]** 

    ```

我们已经种子化了随机数生成器，以确保每次评估`shuffle()`函数时结果都是相同的。这使得单元测试成为可能。

我们使用列表推导来生成一个包含所有 13 个等级和四种花色的卡牌列表。这是 52 个单独的对象的集合。这些对象属于两个类层次结构。每个对象都是`Card`的子类，也是`CribbagePoints`的子类。这意味着所有对象都可以使用这两个特性集合。

例如，我们可以评估每个`Card`对象的`points()`方法：

```py
     **>>> sum(c.points() for c in deck[:5]) 
          30** 

    ```

手中有两张花色牌，加上三、六和 A，所以总点数是`30`。

## 它是如何工作的...

Python 查找方法（或属性）的机制如下：

1.  在类中搜索方法或属性。

1.  如果名称在当前类中未定义，则在所有父类中搜索该方法或属性。父类按照称为**方法解析顺序**（**MRO**）的顺序进行搜索。

当类被创建时，方法解析顺序被计算。使用的算法称为 C3。更多信息可在[`en.wikipedia.org/wiki/C3_linearization`](https://en.wikipedia.org/wiki/C3_linearization)找到。该算法确保每个父类只被搜索一次。它还确保了超类的相对顺序被保留，以便所有子类在任何父类之前被搜索。

我们可以使用类的`mro()`方法来查看方法解析顺序。这里有一个例子：

```py
 **>>> c = deck[5] 
>>> c 
10 ♢ 
>>> c.__class__.__name__ 
'CribbageCard' 
>>> c.__class__.mro()  
[<class 'ch07_r02.CribbageCard'>, <class 'ch07_r02.Card'>, 
<class 'ch07_r02.CribbagePoints'>, <class 'object'>]** 

```

我们从牌堆中抽取了一张牌`c`。牌的`__class__`属性是对该类的引用。在这种情况下，类名是`CribbageCard`。这个类的`mro()`方法向我们展示了用于解析名称的顺序：

1.  首先搜索类本身，`CribbageCard`。

1.  如果找不到，搜索`Card`。

1.  尝试在`CribbagePoints`中找到它。

1.  最后使用`object`。

类定义通常使用内部的`dict`对象来存储方法定义。这意味着搜索是一个非常快速的哈希查找。额外的开销差异大约是搜索`object`（当在任何之前的类中找不到时）比搜索`Card`多 3%的时间。

如果我们进行一百万次操作，我们会看到以下数字：

```py
    Card.__repr__ 1.4413
    object.__str__ 1.4789

```

我们比较了查找`Card`中定义的`__repr__()`和查找`object`中定义的`__str__()`的时间。在一百万次重复中额外的时间总和是 0.03 秒。

由于成本微乎其微，这种能力是构建类层次结构设计的重要方式。

## 还有更多...

有几种关注点，我们可以像这样分开：

+   **持久性和状态的表示**：我们可以添加方法来管理转换为一致的外部表示。

+   **安全性**：这可能涉及一个执行一致授权检查的混合类，这成为每个对象的一部分。

+   日志记录：创建一个跨多个类一致的记录器的混合类可能被定义。

+   **事件信号和变更通知**：在这种情况下，我们可能有一些产生状态变化通知的对象，以及将订阅这些通知的对象。这些有时被称为可观察者和观察者设计模式。GUI 小部件可能观察对象的状态；当对象发生变化时，它会通知 GUI 小部件，以便刷新显示。

举个小例子，我们可以添加一个 mixin 来引入日志记录。我们将定义这个类，以便它必须首先在超类列表中提供。由于它在 MRO 列表中很早，`super()`函数将找到后面类列表中定义的方法。

这个类将为每个类添加`logger`属性：

```py
    class Logged: 
        def __init__(self, *args, **kw): 
            self.logger = logging.getLogger(self.__class__.__name__) 
            super().__init__(*args, **kw) 
        def points(self): 
            p = super().points() 
            self.logger.debug("points {0}".format(p)) 
            return p 

```

请注意，我们已经使用`super().__init__()`来执行 MRO 中定义的任何其他类的`__init__()`方法。正如我们刚才指出的，通常最简单的方法是有一个类来定义对象的基本特征，所有其他 mixin 只是为该对象添加特性。

我们已经为`points()`提供了一个定义。这将在 MRO 列表中搜索其他类的`points()`实现。然后，它将记录另一个类的方法计算的结果。

以下是一些包含`Logged` mixin 特性的类：

```py
    class LoggedCribbageAce(Logged, AceCard, CribbagePoints): 
        pass 
    class LoggedCribbageCard(Logged, Card, CribbagePoints): 
        pass 
    class LoggedCribbageFace(Logged, FaceCard, CribbageFacePoints): 
        pass 

```

这些类中的每一个都是由三个单独的类定义构建的。由于`Logged`类首先提供，我们可以确保所有类都具有一致的日志记录。我们还可以确保`Logged`中的任何方法都可以使用`super()`来定位在类定义中跟随它的超类列表中的实现。

要使用这些类，我们需要对应用程序进行一个小的改变：

```py
    def make_logged_card(rank, suit): 
        if rank == 1: return LoggedCribbageAce(rank, suit) 
        if 2 <= rank < 11: return LoggedCribbageCard(rank, suit) 
        if 11 <= rank: return LoggedCribbageFace(rank, suit) 

```

我们需要使用这个函数来代替`make_card()`。这个函数将使用另一组类定义。

以下是我们如何使用这个函数来构建一副卡片实例：

```py
    deck = [make_logged_card(rank+1, suit) 
        for rank in range(13) 
            for suit in SUITS] 

```

在创建一副牌时，我们用`make_logged_card()`替换了`make_card()`。一旦我们这样做，我们现在可以以一致的方式从多个类中获得详细的调试信息。

## 另请参阅

+   在考虑多重继承时，始终要考虑包装器是否是更好的设计。参见*选择继承和扩展之间的选择-是一个问题*食谱。

# 利用 Python 的鸭子类型

大多数情况下，设计涉及继承，从超类到一个或多个子类都有一个明确的关系。在本章的*选择继承和扩展之间的选择-是一个问题*食谱以及第六章中的*扩展集合-进行统计的列表*食谱中，我们已经看到了涉及适当子类-超类关系的扩展。

Python 没有正式的抽象超类机制。然而，标准库有一个`abc`模块，支持创建抽象类。

然而，这并不总是必要的。Python 依赖于鸭子类型来定位类中的方法。这个名字来自这句话：

> *"当我看到一只像鸭子一样走路、游泳和嘎嘎叫的鸟时，我就称那只鸟为鸭子。"*

这句话最初来自詹姆斯·惠特科姆·赖利。有时被视为**归纳推理**的总结：我们从观察到一个更完整的理论，其中包括了那个观察。在 Python 类关系的情况下，如果两个对象具有相同的方法和属性，这与具有共同的超类具有相同的效果。即使除了`object`类之外没有共同的超类定义，它也可以工作。

我们可以称方法和属性的集合为类的签名。签名唯一标识了类的属性和行为。在 Python 中，签名是动态的，匹配只是在对象的命名空间中查找名称。

我们能利用这个吗？

## 准备好

通常很容易创建一个超类，并确保所有子类都扩展了这个类。但在某些情况下，这可能会很麻烦。例如，如果一个应用程序分布在几个模块中，可能很难因素出一个共同的超类，并将其单独放在一个单独的模块中，以便可以广泛包含它。

相反，有时更容易避免共同的超类，只需检查两个类是否等效，使用鸭子测试——两个类具有相同的方法和属性，因此，它们实际上是某个没有正式实现为 Python 代码的超类的成员。

我们将使用一对简单的类来展示这是如何工作的。这些类都将模拟掷一对骰子。虽然问题很简单，但我们可以轻松地创建各种实现。

## 如何做...

1.  定义一个具有所需方法和属性的类。在这个例子中，我们将有一个属性`dice`，它保留了上次掷骰子的结果，以及一个方法`roll()`，它改变了骰子的状态：

```py
            class Dice1: 
                def __init__(self, seed=None): 
                    self._rng = random.Random(seed) 
                    self.roll() 
                def roll(self): 
                    self.dice = (self._rng.randint(1,6), 
                        self._rng.randint(1,6)) 
                    return self.dice 

    ```

1.  定义其他具有相同方法和属性的类。以下是一个稍微复杂的定义，它创建了一个与`Dice1`类具有相同签名的类：

```py
            class Die: 
                def __init__(self, rng): 
                    self._rng= rng 
                def roll(self): 
                    return self._rng.randint(1, 6) 
            class Dice2: 
                def __init__(self, seed=None): 
                    self._rng = random.Random(seed) 
                    self._dice = [Die(self._rng) for _ in range(2)] 
                    self.roll() 
                def roll(self): 
                    self.dice = tuple(d.roll() for d in self._dice) 
                    return self.dice 

    ```

这个类引入了一个额外的属性，`_dice`。这种实现上的改变并不会改变单个属性`dice`和方法`roll()`的公开接口。

在这一点上，这两个类可以自由交换：

```py
    def roller(dice_class, seed=None, *, samples=10): 
        dice = dice_class(seed) 
        for _ in range(samples): 
            yield dice.roll() 

```

我们可以使用这个函数如下：

```py
 **>>> from ch07_r03 import roller, Dice1, Dice2 
>>> list(roller(Dice1, 1, samples=5)) 
[(1, 3), (1, 4), (4, 4), (6, 4), (2, 1)] 
>>> list(roller(Dice2, 1, samples=5)) 
[(1, 3), (1, 4), (4, 4), (6, 4), (2, 1)]** 

```

从`Dice1`和`Dice2`构建的对象有足够的相似之处，以至于它们是无法区分的。

当然，我们可以推动边界，并寻找`_dice`属性作为区分两个类的方法。我们也可以使用`__class__`来区分这两个类。

## 它是如何工作的...

当我们编写形式为`namespace.name`的表达式时，Python 将在给定的命名空间中查找名称。算法的工作方式如下：

1.  搜索对象的`self.__dict__`集合以查找名称。一些类定义将节省空间，使用`__slots__`。有关此优化的更多信息，请参阅第六章中的*使用 __slots__ 优化小对象*，*类和对象的基础知识*。这通常是如何找到属性值的。

1.  搜索对象的`self.__class__.__dict__`集合以查找名称。这通常是方法被找到的方式。

1.  正如我们在*选择继承和扩展之间的区别——is-a 问题*和*通过多重继承分离关注点*中所指出的，搜索可以继续通过类的所有超类。这个搜索是按照定义的方法解析顺序进行的。

有两个基本的结果：

+   该值是一个不可调用的对象。这就是值。这是属性的典型特征。

+   属性的值是类的绑定方法。这对于普通方法和属性都是正确的。有关属性的更多信息，请参阅第六章中的*使用属性进行惰性属性*，*类和对象的基础知识*。绑定方法必须被评估。对于简单的方法，参数在方法名称后的`()`中。对于属性，没有带有方法参数值的`()`。

### 注意

我们省略了一些关于如何使用描述符的细节。对于最常见的用例，描述符的存在并不重要。

这的本质是通过`__dict__`（或`__slots__`）名称集合进行搜索。如果对象有一个共同的超类，那么我们可以保证会找到匹配的名称。如果对象没有共同的超类，那么我们就没有同样的保证。我们必须依赖纪律性的设计和良好的测试覆盖率。

## 还有更多...

当我们查看 `decimal` 模块时，我们看到了一个与所有其他数值类型不同的数值类型的例子。为了使其正常工作，`numbers` 模块包括了将类注册为 `Number` 类层次结构的一部分的概念。这样可以在不使用继承的情况下将一个新类注入到层次结构中。

`codecs` 模块使用类似的技术来添加新的数据编码。我们可以定义一个新的编码并将其注册，而不使用 `codecs` 模块中定义的任何类。

之前，我们注意到类的方法的搜索涉及描述符的概念。在内部，Python 使用描述符对象来创建对象的可获取和可设置属性。

描述符对象必须实现一些特殊方法 `__get__` 、`__set__` 和 `__delete__` 的组合。当属性出现在表达式中时，将使用 `__get__` 来定位值。当属性出现在赋值的左侧时，将使用 `__set__`。在 `del` 语句中，将使用 `__delete__` 方法。

描述符对象充当中介，以便一个简单的属性可以在各种上下文中使用。很少直接使用描述符。我们可以使用 `@property` 装饰器为我们构建描述符。

## 另请参阅

+   鸭子类型问题在*选择继承和扩展之间——is-a 问题*的示例中是隐含的；如果我们利用鸭子类型，我们也在声称两个类不是同一种东西。当我们绕过继承时，我们隐含地声称 is-a 关系不成立。

+   当查看*通过多重继承分离关注点*的示例时，我们还可以利用鸭子类型来创建可能没有简单继承层次结构的组合类。由于使用混合设计模式非常简单，很少需要使用鸭子类型。

# 管理全局和单例对象

Python 环境包含许多隐式全局对象。这些对象提供了一种方便的方式来处理其他对象的集合。由于集合是隐式的，我们不必写任何显式的初始化代码，从而避免了麻烦。

其中一个例子是 `random` 模块中的一个隐式随机数生成对象。当我们评估 `random.random()` 时，实际上是在使用 `random` 模块中隐式的 `random.Random` 类的一个实例。

其他例子包括以下内容：

+   可用的数值类型的集合。默认情况下，我们只有 `int` 、`float` 和 `complex` 。但是，我们可以添加更多的数值类型，并且它们将与现有类型无缝配合。有一个可用数值类型的全局注册表。

+   可用的数据编码/解码方法（编解码器）的集合。`codecs` 模块列出了可用的编码器和解码器。这也涉及到一个隐式注册。我们可以向这个注册表中添加编码和解码。

+   `webbrowser` 模块有一个已知浏览器的注册表。在大多数情况下，操作系统默认浏览器是用户首选的浏览器，也是要使用的正确的浏览器，但应用程序也可以启动用户首选浏览器之外的浏览器。还可以注册一个新的浏览器，该浏览器是特定应用程序的唯一浏览器。

我们如何处理这种隐式全局对象？

## 准备工作

通常，隐式对象可能会引起一些混淆。想法是提供一套功能作为独立的函数，而不是对象的方法。然而，好处是允许独立的模块共享一个公共对象，而无需编写任何显式协调模块之间的代码。

举个简单的例子，我们将定义一个具有全局单例对象的模块。我们将在第十三章中更详细地了解模块，*应用集成*。

我们的全局对象将是一个计数器，我们可以用它来积累来自几个独立模块或对象的集中数据。我们将使用简单的函数来提供对这个对象的接口。

目标是能够编写类似这样的内容：

```py
    for row in source: 
        count('input') 
        some_processing() 
    print(counts()) 

```

这意味着会有两个函数引用一个全局计数器：

+   `count()`：它将增加计数器并返回当前值

+   `counts()`：它将提供所有不同的计数器值

## 如何做...

有两种处理全局状态信息的方法。一种技术使用模块全局变量，因为模块是单例对象。另一种使用类级（静态）变量，因为类定义也是单例对象，我们将展示这两种技术。

### 模块全局变量

1.  创建一个模块文件。这将是一个`.py`文件，其中包含定义。我们将其称为`counter.py`。

1.  如果有必要，为全局单例定义一个类。在我们的例子中，我们可以使用这个定义：

```py
            from collections import Counter 

    ```

在某些情况下，可能会使用`types.SimpleNamespace`。在其他情况下，可能需要一个更复杂的类，其中包括方法和属性。

1.  定义全局单例对象的唯一实例：

```py
            _global_counter = Counter() 

    ```

我们在名称中使用了一个前导`_`，使其稍微不太可见。它不是——技术上——私有的。然而，它被许多 Python 工具和实用程序优雅地忽略了。

1.  定义任何包装函数：

```py
            def count(key, increment=1): 
                _global_counter[key] += increment 
            def counts(): 
                return _global_counter.most_common() 

    ```

我们定义了两个使用全局对象`_global_counter`的函数。这些函数封装了计数器的实现细节。

现在我们可以编写应用程序，在各种地方使用`count()`函数。然而，计数的事件完全集中在这个单一对象中。

我们可能有这样的代码：

```py
 **>>> from ch07_r04 import count, counts 
>>> from ch07_r03 import Dice1 
>>> d = Dice1(1) 
>>> for _ in range(1000): 
...     if sum(d.roll()) == 7: count('seven') 
...     else: count('other') 
>>> print(counts()) 
[('other', 833), ('seven', 167)]** 

```

我们从一个中央模块导入了`count()`和`counts()`函数。我们还导入了`Dice1`对象作为一个方便的对象，我们可以用它来创建一系列事件。当我们创建`Dice1`的一个实例时，我们提供一个初始化来强制使用特定的随机种子。这可以得到可重复的结果。

然后我们可以使用对象`d`来创建随机事件。在这个演示中，我们将事件分类为两个简单的桶，标记为`seven`和`other`。`count()`函数使用了一个隐含的全局对象。

当模拟完成时，我们可以使用`counts()`函数来输出结果。这将访问模块中定义的全局对象。

这种技术的好处是，几个模块都可以共享`ch07_r04`模块中的全局对象。只需要一个`import`语句。不需要进一步的协调或开销。

### 类级静态变量

1.  定义一个类并在`__init__`方法之外提供一个变量。这个变量是类的一部分，而不是每个单独实例的一部分。它被所有类的实例共享：

```py
            from collections import Counter 
            class EventCounter: 
                _counts = Counter() 

    ```

我们给类级变量加了一个前导下划线，使其不太公开。这是对使用类的任何人的一个提示，该属性是一个可能会改变的实现细节。它不是类的可见接口的一部分。

1.  添加方法来更新和提取这个变量的数据：

```py
            def count(self, key, increment=1): 
                EventCounter._counts[key] += increment 
            def counts(self): 
                return EventCounter._counts.most_common() 

    ```

我们在这个例子中没有使用`self`，是为了说明变量赋值和实例变量。当我们在赋值语句的右侧使用`self.name`时，名称可以由对象、类或任何超类解析。这是搜索类的普通规则。

当我们在赋值语句的左侧使用`self.name`时，那将创建一个实例变量。我们必须使用`Class.name`来确保更新类级变量，而不是创建一个实例变量。

各种应用程序组件可以创建对象，但所有对象都共享一个公共类级值：

```py
>>> from ch07_r04 import EventCounter 
>>> c1 = EventCounter() 
>>> c1.count('input') 
>>> c2 = EventCounter() 
>>> c2.count('input') 
>>> c3 = EventCounter() 
>>> c3.counts() 
[('input', 2)] 

```

在这个示例中，我们创建了三个单独的对象，`c1`，`c2`和`c3`。由于所有三个对象共享`EventCounter`类中定义的一个公共变量，因此每个对象都可以用于增加该共享变量。这些对象可以是单独的模块、单独的类或单独的函数的一部分，但仍然共享一个共同的全局状态。

## 它是如何工作的...

Python 导入机制使用`sys.modules`来跟踪加载了哪些模块。一旦模块在这个映射中，它就不会再次加载。这意味着在模块内定义的任何变量都将是单例：只会有一个实例。

我们有两种方法来共享这些全局单例变量：

+   显式使用模块名称。我们本可以在模块中简单地创建`Counter`的实例，并通过`counter.counter`共享它。这样可以工作，但它暴露了一个实现细节。

+   使用包装函数，如本示例所示。这需要更多的代码，但它允许在不破坏应用程序的其他部分的情况下进行实现的更改。

这些函数提供了一种识别全局变量相关特征的方式，同时封装了它的实现细节。这使我们有自由考虑改变实现细节的自由。只要包装函数具有相同的语义，实现就可以自由更改。

由于我们通常只提供一个类的定义，Python 导入机制倾向于向我们保证类定义是一个正确的单例对象。如果我们错误地复制一个类定义，并将其粘贴到单个应用程序使用的两个或更多模块中，我们将不会在这些类定义之间共享一个全局对象。这是一个容易避免的错误。

我们如何在这两种机制之间进行选择？选择是基于多个类共享全局状态所造成的混乱程度。如前面的示例所示，三个变量共享一个公共的`Counter`对象。隐式共享全局状态的存在可能会令人困惑。

## 还有更多...

共享全局状态在某种程度上与面向对象编程相反。面向对象编程的一个理想是将所有状态变化封装在各个对象中。当我们有一个共享的全局状态时，我们已经偏离了这个理想：

+   使用包装函数使共享对象变得隐式

+   使用类级变量隐藏了对象是共享的事实

当然，另一种选择是显式地创建一个全局对象，并以一种更明显的方式将其作为应用程序的一部分。这可能意味着将对象作为初始化参数提供给整个应用程序中的对象。在复杂的应用程序中，这可能是一个相当大的负担。

拥有一些共享的全局对象更具吸引力，因为应用程序变得更简单。当这些对象用于普遍特性，如审计、日志记录和安全性时，它们可能会有所帮助。

这是一种容易被滥用的技术。依赖过多全局对象的设计可能会令人困惑。它也可能存在微妙的错误，因为在类中封装对象可能难以辨别。它也可能使单元测试用例难以编写，因为对象之间的隐式关系。

![](img/614271.jpg)

# 使用更复杂的结构 - 列表的映射

在第四章中，*内置数据结构 - 列表，集合，字典*，我们看了 Python 中可用的基本数据结构。这些示例通常独立地查看了各种结构。

我们将看一下一个常见的组合结构 - 从一个键到一个列表的映射。这用于累积有关由给定键标识的对象的详细信息。这个示例将把详细信息的平面列表转换成一个结构，其中一个列包含来自其他列的值。

## 准备工作

我们将使用一个虚构的网络日志，它已经从原始网络格式转换为 CSV（逗号分隔值）格式。这种转换通常是通过使用正则表达式来选择各种句法组完成的。有关解析可能如何工作的信息，请参阅第一章中的*使用正则表达式解析字符串*配方，*数字、字符串和元组*。

原始数据看起来像这样：

```py
 **[2016-04-24 11:05:01,462] INFO in module1: Sample Message One** 

 **[2016-04-24 11:06:02,624] DEBUG in module2: Debugging** 

 **[2016-04-24 11:07:03,246] WARNING in module1: Something might have gone wrong** 

```

文件中的每一行都有一个时间戳、一个严重级别、一个模块名称和一些文本。解析后，数据实际上是一个事件的平面列表。它看起来像这样：

```py
 **>>> data = [ 
    ('2016-04-24 11:05:01,462', 'INFO', 'module1', 'Sample Message One'), 
    ('2016-04-24 11:06:02,624', 'DEBUG', 'module2', 'Debugging'), 
    ('2016-04-24 11:07:03,246', 'WARNING', 'module1', 'Something might have gone wrong') 
]** 

```

我们想要检查日志，创建一个按模块组织的所有消息的列表，而不是按时间顺序。这种重组可以使分析更简单。

## 操作方法...

1.  从`collections`导入`defaultdict`：

```py
            from collections import defaultdict 

    ```

1.  使用`list`函数作为`defaultdict`的默认值：

```py
            module_details = defaultdict(list) 

    ```

1.  通过数据进行迭代，将其附加到与每个键关联的列表中。`defaultdict`对象将使用`list()`函数为每个新键构建一个空列表：

```py
            for row in data: 
                module_details[row[2]].append(row) 

    ```

这将产生一个从模块到该模块名称的所有日志行的列表的字典。数据看起来像这样：

```py
    { 
        'module1': [ 
            ('2016-04-24 11:05:01,462', 'INFO', 'module1', 'Sample Message One'), 
            ('2016-04-24 11:07:03,246', 'WARNING', 'module1', 'Something might have gone wrong') 
            ], 
        'module2': [ 
            ('2016-04-24 11:06:02,624', 'DEBUG', 'module2', 'Debugging') 
        ] 
    } 

```

该映射的键是模块名称，映射中的值是该模块名称的行列表。现在我们可以专注于特定模块的分析。

## 工作原理...

当键未找到时，映射的行为有两种选择：

+   内置的`dict`类在键丢失时会引发异常。

+   `defaultdict`类在键丢失时会评估一个创建默认值的函数。在许多情况下，该函数是`int`或`float`，用于创建默认的数值。在这种情况下，该函数是`list`，用于创建一个空列表。

我们可以想象使用`set`函数为缺少的键创建一个空的`set`对象。这适用于从键到共享该键的对象集的映射。

## 还有更多...

当我们考虑 Python 3.5 和进行类型推断的能力时，我们需要有一种描述这种结构的方法：

```py
    from typing import * 
    def summarize(data) -> Mapping[str, List]: 
        the body of the function. 

```

这使用符号`Mapping[str, List]`来显示结果是从字符串键到字符串数据项列表的映射。

我们还可以构建一个作为内置`dict`类的扩展版本：

```py
    class ModuleEvents(dict): 
        def add_event(self, event): 
            if event[2] not in self: 
                self[event[2]] = list() 
            self[event[2]].append(row) 

```

我们已经定义了一个对这个类独有的方法`add_event()`。如果字典中当前不存在`event[2]`中的模块名称的键，则将添加空列表。在`if`语句之后，可以添加一个后置条件来断言该键现在在字典中。

这使我们能够使用以下代码：

```py
    module_details = ModuleEvents() 
    for row in data: 
        module_details.add_event(row) 

```

结果结构与`defaultdict`非常相似。

## 另请参阅

+   在第四章的*创建字典 - 插入和更新*配方中，我们看到了使用映射的基础知识

+   在第四章的*避免函数参数的可变默认值*配方中，我们看到了其他使用默认值的地方

+   在第六章的*使用更复杂的集合*配方中，我们看到了使用`defaultdict`类的其他示例

# 创建一个具有可排序对象的类

在模拟纸牌游戏时，能够将`Card`对象排序到一个定义的顺序中通常是至关重要的。当卡片形成一个序列时，有时被称为顺子，这可能是评分手的重要方式。这是类似扑克牌、Cribbage 甚至 Pinochle 的游戏的一部分。

我们的大多数类定义都没有包括对将对象排序的必要特征。许多示例都将对象保留在基于`__hash__()`计算的内部哈希值的映射或集合中。

为了将项目保留在有序集合中，我们需要实现`<`、`>`、`<=`、`>=`、`==`和`!=`的比较方法。这些比较是基于每个对象的属性值。

我们如何创建可比较的对象？

## 准备工作

Pinochle 游戏通常涉及一副有 48 张牌的牌组。有六个等级——9、10、J、Q、K 和 A。有标准的四种花色。这 24 张牌中的每一张在牌组中都出现两次。我们必须小心使用诸如 dict 或 set 之类的结构，因为在 Pinochle 中卡片并不是唯一的；可能会有重复。

在*通过多重继承分离关注点*的示例中，我们使用了两个类定义来定义纸牌。`Card`类层次结构定义了每张牌的基本特征。第二组混合类为每张牌提供了特定于游戏的特征。

我们需要为这些牌添加特征，以创建可以正确排序的对象。为了支持*定义有序集合*的示例，我们将研究 Pinochle 游戏的牌。

以下是设计的前两个元素：

```py
    from ch07_r02 import AceCard, Card, FaceCard, SUITS 
    class PinochlePoints: 
        _points = {9: 0, 10:10, 11:2, 12:3, 13:4, 14:11} 
        def points(self): 
            return self._points[self.rank] 

```

我们已经导入了现有的`Card`层次结构。我们还定义了在玩牌过程中计算每张牌得分的规则，`PinochlePoints`类。这个类有一个从卡片等级到每张卡片可能令人困惑的点数的映射。

10 点值 10 分，A 值 11 分，但 K、J 和 Q 分别值 4、3 和 2 分。这可能会让新玩家感到困惑。

因为 A 的排名在识别顺子的目的上高于 K，所以我们将 A 的排名设为 14。这在一定程度上简化了处理过程。

为了使用有序的卡片集合，我们需要为卡片添加另一个特征。我们需要定义比较操作。用于对象比较的有六个特殊方法。

## 如何做...

1.  我们正在使用混合设计。因此，我们将创建一个新的类来保存比较特征：

```py
            class SortedCard: 

    ```

这个类将加入`Card`层次结构的成员加上`PinochlePoints`，以创建最终的复合类定义。

1.  定义六个比较方法：

```py
            def __lt__(self, other): 
                return (self.rank, self.suit) < (other.rank, other.suit) 

            def __le__(self, other): 
                return (self.rank, self.suit) <= (other.rank, other.suit) 

            def __gt__(self, other): 
                return (self.rank, self.suit) > (other.rank, other.suit) 

            def __ge__(self, other): 
                return (self.rank, self.suit) >= (other.rank, other.suit) 

            def __eq__(self, other): 
                return (self.rank, self.suit) == (other.rank, other.suit) 

            def __ne__(self, other): 
                return (self.rank, self.suit) != (other.rank, other.suit) 

    ```

我们已经完整地写出了所有六个比较。我们将`Card`的相关属性转换为元组，并依赖于 Python 的内置元组比较来处理细节。

1.  编写复合类定义，由一个基本类和两个混合类构建以提供额外特征：

```py
            class PinochleAce(AceCard, SortedCard, PinochlePoints): 
                pass 

            class PinochleFace(FaceCard, SortedCard, PinochlePoints): 
                pass 

            class PinochleNumber(Card, SortedCard, PinochlePoints): 
                pass 

    ```

最终的类包含具有三个独立且大部分独立的特征集的元素：基本的`Card`特征，混合比较特征和混合 Pinochle 特定特征。

1.  创建一个函数，从先前定义的类中创建单独的卡片对象：

```py
            def make_card(rank, suit): 
                if rank in (9, 10): 
                    return PinochleNumber(rank, suit) 
                elif rank in (11, 12, 13): 
                    return PinochleFace(rank, suit) 
                else: 
                    return PinochleAce(rank, suit) 

    ```

尽管点数规则非常复杂，但复杂性隐藏在`PinochlePoints`类中。构建复合类作为`Card`和`PinochlePoints`的基类子类会导致对牌的准确建模，而不会有太多明显的复杂性。

现在我们可以制作可以响应比较运算符的卡片：

```py
 **>>> from ch07_r06a import make_card 
>>> c1 = make_card(9, '♡') 
>>> c2 = make_card(10, '♡') 
>>> c1 < c2 
True 
>>> c1 == c1 
True 
>>> c1 == c2 
False 
>>> c1 > c2 
False** 

```

这是一个构建 48 张牌的牌组的函数：

```py
    SUITS = '\u2660\u2661\u2662\u2663' 
    Spades, Hearts, Diamonds, Clubs = SUITS 
    def make_deck(): 
        return [make_card(r, s) for _ in range(2) 
            for r in range(9, 15) 
            for s in SUITS] 

```

`SUITS`的值是四个 Unicode 字符。我们本可以分别设置每个花色字符串，但这样似乎稍微简单一些。`make_deck()`函数内部的生成器表达式构建了每张牌的两份副本。只有六种等级和四种花色。

## 工作原理...

Python 为大量的事情使用特殊方法。语言中几乎每个可见的行为都归因于某些特殊方法名称。在这个示例中，我们利用了六个比较运算符。

写下以下内容：

```py
    c1 <= c2 

```

前面的代码被评估为我们写了以下内容：

```py
    c1.__le__(c2) 

```

这种转换适用于所有表达式运算符。

仔细研究*Python 语言参考*的*第 3.3 节*表明，特殊方法可以组织成几个不同的组：

+   基本定制

+   自定义属性访问

+   自定义类创建

+   自定义实例和子类检查

+   模拟可调用对象

+   模拟容器类型

+   模拟数值类型

+   使用语句上下文管理器

在这个配方中，我们只看了这些类别中的第一个。其他的遵循一些类似的设计模式。

当我们创建这个类层次结构的实例时，它看起来是这样的。第一个例子将创建一个 48 张牌的 Pinochle 牌组：

```py
 **>>> from ch07_r06a import make_deck 
>>> deck = make_deck() 
>>> len(deck) 
48** 

```

如果我们看一下前八张牌，我们可以看到它们是如何由所有等级和花色的组合构建而成的：

```py
 **>>> deck[:8] 
[ 9 ♠,  9 ♡,  9 ♢,  9 ♣, 10 ♠, 10 ♡, 10 ♢, 10 ♣]** 

```

如果我们看一下牌组的后半部分，我们会发现它与牌组的前半部分是一样的：

```py
 **>>> deck[24:32] 
[ 9 ♠,  9 ♡,  9 ♢,  9 ♣, 10 ♠, 10 ♡, 10 ♢, 10 ♣]** 

```

由于`deck`变量是一个简单的列表，我们可以打乱列表对象并选择十二张牌。

```py
 **>>> import random 
>>> random.seed(4) 
>>> random.shuffle(deck) 
>>> sorted(deck[:12]) 
[ 9 ♣, 10 ♣,  J ♠,  J ♢,  J ♢,  Q ♠,  Q ♣,  K ♠,  K ♠,  K ♣, A ♡,  A ♣]** 

```

重要的部分是使用`sorted()`函数。因为我们已经定义了适当的比较运算符，我们可以对`Card`实例进行排序，并按预期顺序呈现。

## 还有更多...

一点形式逻辑表明，我们实际上只需要实现两种比较。对于任何两个，其他所有的都可以推导出来。例如，如果我们只能执行小于(`__lt__()` )和等于(`__eq__()` )的操作，我们可以相当容易地计算出其余的三个：

*a* ≤ *b* ≡ *a < b* ∨ *a* = *b*

*a* ≥ *b* ≡ *a > b* ∨ *a* = *b*

*a* ≠ *b* ≡ ¬(*a* = *b*)

Python 明确不会为我们执行任何这种高级代数。我们需要仔细进行代数运算，或者如果我们对逻辑不确定，可以完整地写出所有六个比较。

我们假设每个`Card`都与另一张卡进行比较。试试这个：

```py
 **>>> c1 = make_card(9, '♡') 
>>> c1 == 9** 

```

我们将得到一个`AttributeError`异常。

如果我们需要这个功能，我们将不得不修改比较运算符来处理两种比较：

+   `Card`对`Card`

+   `Card`对`int`

这是通过使用`isinstance()`函数来区分参数类型来完成的。

我们的每个比较方法将被更改为这样：

```py
    def __lt__(self, other): 
        if isinstance(other, Card): 
            return (self.rank, self.suit) < (other.rank, other.suit) 
        else: 
            return self.rank < other 

```

这处理了`Card`与`Card`之间的情况，使用等级和花色进行比较。对于所有其他情况，Python 使用普通的规则来将等级与其他值进行比较。如果由于某种隐晦的原因，另一个值是`float`，那么将在`self.rank`上使用`float()`转换。

## 另请参阅

+   查看依赖于对这些卡进行排序的*定义有序集合*配方

# 定义一个有序集合

在模拟纸牌游戏时，玩家的手可以被建模为一组牌或一叠牌。对于大多数传统的单副牌游戏，集合是很好的选择，因为任何给定的牌只有一个实例，并且集合类可以非常快速地执行操作来确认给定的牌是否在集合中（或不在）。

然而，在建模 Pinochle 时，我们面临一个具有挑战性的问题。Pinochle 牌组有 48 张牌；它有两张 9、10、J、Q、K 和 A。简单的集合对于这个不太适用；我们需要一个多重集或袋子。这是一个允许重复项的集合。

这些操作仍然仅限于成员测试。例如，我们可以多次添加对象`Card(9,'♢')`对象，然后多次删除它。

我们有多种方法来创建多重集：

+   我们可以使用列表。添加一个项目几乎是固定成本，被描述为*O*(1)。搜索项目的性能有严重问题。测试成员资格的复杂性往往随着集合大小的增长而增长。它变成了*O*(n)。

+   我们可以使用映射；值可以是重复元素出现的整数计数。这只需要映射中每个对象都有默认的`__hash__()`方法。我们有三种实现这种方法的方式：

+   定义我们自己的 dict 子类。

+   使用`defaultdict`。请参阅*使用更复杂的结构-列表映射*示例，该示例使用`defaultdict(list)`为每个键创建一个值列表。该列表的`len()`是键出现的次数。实际上，这是一种多重集。

+   使用`Counter`。这可以非常简单。我们已经在许多示例中看过`Counter`。请参阅第四章中的*避免函数参数的可变默认值*，*内置数据结构-列表、集合、字典*，以及第六章中的*设计具有大量处理的类*和*使用属性进行惰性属性*，*类和对象的基础知识*，以及本章的*管理全局和单例对象*示例。

+   我们可以使用有序列表。插入维护此排序顺序的项目比插入列表稍微昂贵，***O*** ( *n* log *[2] n* )。然而，搜索比无序列表便宜;它是***O*** (log *[2] n* )。`bisect`模块提供了一组很好地执行此操作的函数。然而，这需要具有完整比较方法集的对象。

我们如何构建一个有序对象的有序集合？如何使用有序集合构建多重集或袋？

## 准备就绪

在*创建具有可排序对象的类*示例中，我们定义了可以排序的卡片。这对于使用`bisect`至关重要。该模块中的算法要求对象之间进行全面的比较。

我们将定义一个多重集，以保留 12 张 Pinochle 手牌。由于重复，同一等级和花色的卡片将会有多张。

为了将手牌视为一种集合，我们还需要在手牌对象上定义一些集合运算符。其思想是定义集合成员和子集运算符。

我们希望有 Python 代码等效于以下内容：

*c* ∈ *H*

这是针对一张卡片*c*和一手牌*H*={ *c* [1] *, c* [2] *, c* [3] *,...* }。

我们还希望有与此等效的代码：

{ *J, Q* } ⊂ *H*

这是针对一对特定的卡片，称为 Pinochle，以及一手牌，*H*。

我们需要导入两样东西：

```py
    from ch07_r06a import * 
    import bisect 

```

第一个导入将我们可排序的卡片定义从*创建具有可排序对象的类*示例中引入。第二个导入将我们将用来维护一个有序集合的各种 bisect 函数引入。

## 如何做...

1.  定义一个类，其中初始化可以从任何可迭代的数据源加载集合：

```py
            class Hand: 
                def __init__(self, card_iter): 
                    self.cards = list(card_iter) 
                    self.cards.sort() 

    ```

我们可以使用这个从列表或可能是生成器表达式构建一个`Hand`。如果列表不为空，我们需要将项目排序。`self.cards`列表的`sort()`方法将依赖于`Card`对象实现的各种比较运算符。

从技术上讲，我们只关心那些是`SortedCard`的子类的对象，因为这是定义比较方法的地方。

1.  定义一个将卡片添加到手牌的方法：

```py
            def add(self, aCard: Card): 
                bisect.insort(self.cards, aCard) 

    ```

我们使用`bisect`算法来确保卡片被正确插入到`self.cards`列表中。

1.  定义一个查找给定卡片在手牌中位置的方法：

```py
            def index(self, aCard: Card): 
                i = bisect.bisect_left(self.cards, aCard) 
                if i != len(self.cards) and self.cards[i] == aCard: 
                    return i 
                raise ValueError 

    ```

我们使用`bisect`算法来定位给定的卡片。建议在`bisect.bisect_left()`的文档中使用额外的`if`测试来正确处理处理中的边缘情况。

1.  定义实现`in`运算符的特殊方法：

```py
            def __contains__(self, aCard: Card): 
                try: 
                    self.index(aCard) 
                    return True 
                except ValueError: 
                    return False 

    ```

当我们在 Python 中编写`card in some_hand`时，它会被计算为如果我们编写了`some_hand.__contains__(card)`。我们使用`index()`方法来查找卡片或引发异常。异常被转换为`False`的返回值。

1.  定义手牌上的迭代器。这只是对`self.cards`集合的简单委托：

```py
            def __iter__(self): 
                return iter(self.cards) 

    ```

当我们在 Python 中编写`iter(some_hand)`时，它会被计算为如果我们编写了`some_hand.__iter__()`。

1.  在两个手实例之间定义一个子集操作：

```py
            def __le__(self, other): 
                for card in self: 
                    if card not in other: 
                        return False 
                return True 

    ```

Python 没有*a*⊂*b*或*a*⊆*b*符号，因此<和<=被用来比较集合。当我们写`pinochle <= some_hand`来查看手中是否包含特定的卡片组合时，它被评估为如果我们写了`pinochle.__le__(some_hand)`。子集是 self 实例变量，目标 Hand 是另一个参数值。

in 运算符由 __contains__()方法实现。这显示了简单的 Python 语法是如何由特殊方法实现的。

我们可以像这样使用这个 Hand 类：

```py
 **>>> from ch07_r06b import make_deck, make_card, Hand 
>>> import random 
>>> random.seed(4) 
>>> deck = make_deck() 
>>> random.shuffle(deck) 
>>> h = Hand(deck[:12]) 
>>> h.cards 
[ 9 ♣, 10 ♣,  J ♠,  J ♢,  J ♢,  Q ♠,  Q ♣,  K ♠,  K ♠,  K ♣, A ♡,  A ♣]** 

```

卡片在手中被正确排序。这是手的创建方式的结果。

以下是使用子集运算符`<=`将特定模式与整个手进行比较的示例：

```py
 **>>> pinochle = Hand([make_card(11,'♢'), make_card(12,'♠')]) 
>>> pinochle <= h 
True** 

```

手是一个集合，并支持迭代。我们可以使用引用整个手中的卡对象的生成器表达式：

```py
 **>>> sum(c.points() for c in h) 
56** 

```

## 它是如何工作的...

我们的 Hand 集合通过包装内部的 list 对象并对该对象应用重要的约束来工作。项目按排序顺序保留。这增加了插入新项目的成本，但减少了搜索项目的成本。

用于查找项目位置的核心算法是`bisect`模块的一部分，这样我们就不必编写（和调试）它们。这些算法实际上并不是非常复杂。但利用现有代码似乎更有效。

该模块的名称来自于对排序列表进行二分查找的想法。其本质是：

```py
    while lo < hi: 
        mid = (lo+hi)//2 
        if x < a[mid]: hi = mid 
        else: lo = mid+1 

```

这将搜索列表`a`以查找给定值`x`。`lo`的值最初为零，`hi`的值最初为列表的大小`len(a)`。

首先，确定中点。如果目标值`x`小于中点值`a[mid]`，那么它必须在列表的前半部分：将`hi`的值移动，以便只考虑前半部分。

如果目标值`x`大于或等于中点值`a[mid]`，那么`x`必须在列表的后半部分：将`lo`的值移动，以便只考虑后半部分。

由于每次操作都会将列表减半，因此需要*O*(log*[2]n*)步才能使 lo 和 hi 的值收敛到应该具有目标值的位置。

如果我们有一个有 12 张卡的手，那么第一个比较会丢弃六张。下一个比较会再丢弃三张。下一个比较会丢弃最后三张中的一张。第四个比较将找到卡片应该占据的位置。

如果我们使用普通列表，卡片按到达的随机顺序存储，那么找到一张卡片将平均需要六次比较。最坏的情况意味着它是 12 张卡片中的最后一张，需要检查所有 12 张。

使用`bisect`，比较的次数始终是*O*(log*[2]n*)。这是平均值和最坏情况。

## 还有更多...

`collections.abc`模块为各种集合定义了抽象基类。如果我们希望我们的 Hand 表现得更像其他类型的集合，我们可以利用这些定义。

我们可以在这个类定义中添加许多集合运算符，使其更像内置的`MutableSet`抽象类定义。

`MutableSet`是`Set`的扩展。`Set`类是由三个类定义构建的复合类：`Sized`，`Iterable`和`Container`。这意味着它必须定义以下方法：

+   `__contains__()`

+   `__iter__()`

+   `__len__()`

+   add()

+   `discard()`

我们还需要提供一些其他作为可变集合的方法：

+   `clear()`，`pop()`：这些将从集合中删除项目。

+   `remove()`：与`discard()`不同，当尝试删除缺失的项目时，这将引发异常。

为了具有唯一的集合特性，还需要一些额外的方法。我们提供了一个基于 __le__()的子集的示例。我们还需要提供以下子集比较：

+   `__le__()`

+   `__lt__()`

+   `__eq__()`

+   `__ne__()`

+   `__gt__()`

+   `__ge__()`

+   `isdisjoint()`

这些通常不是简单的一行定义。为了实现核心比较集，我们经常会写两个，然后使用逻辑来基于这两个构建其余部分。

由于`__eq__()`很简单，让我们假设我们已经为`==`和`<=`运算符定义了定义。其他的将定义如下：

*x* ≠ *y* ≡ ¬( *x* = *y* )

*x* < *y* ≡ ( *x* ≤ *y* ) ∧ ¬( *x* = *y* )

*x* > *y* ≡ ¬( *x* ≤ *y* )

*x* ≥ *y* ≡ ¬( *x* < *y* ) ≡ ¬( *x* ≤ *y* ) ∨ ( *x* = *y* )

为了进行集合操作，我们需要提供以下内容：

+   `__and__()`和`__iand__()`。这些方法实现了 Python 的`&`运算符和`&=`赋值语句。在两个集合之间，这是一个集合的交集，或者*a* ∩ *b*。

+   `__or__()`和`__ior__()`。这些方法实现了 Python 的`|`运算符和`|=`赋值语句。在两个集合之间，这是一个集合的并集，或者*a* ∪ *b*。

+   `__sub__()`和`__isub__()`。这些方法实现了 Python 的`-`运算符和`-=`赋值语句。在集合之间，这是一个集合的差，通常写作*a* - *b*。

+   `__xor__()`和`__ixor__()`。这些方法实现了 Python 的`^`运算符和`^=`赋值语句。当应用于两个集合之间时，这是对称差，通常写作*a* ∆ *b*。

抽象类允许每个运算符有两个版本。有两种情况：

+   如果我们提供了`__iand__()`，那么语句`A &= B`将被计算为`A.__iand__(B)`。这可能会允许有效的实现。

+   如果我们不提供`__iand__()`，那么语句`A &= B`将被计算为`A = A.__and__(B)`。这可能会有点不太高效，因为我们将创建一个新对象。新对象被标记为`A`，旧对象将从内存中删除。

几乎需要两打方法来为内置的集合类提供适当的替代。一方面，这是大量的代码。另一方面，Python 让我们以透明的方式扩展内置类，并使用相同的语义和操作符。

## 另请参阅

+   查看*创建一个具有可排序对象的类*配方，以获取定义 Pinochle 卡的伴侣配方

# 从映射列表中删除

从列表中删除项目会产生有趣的后果。具体来说，当删除项目`list[x]`时，将会发生以下两种情况之一：

+   项目`list[x+1]`取代了`list[x]`

+   项目`x+1 == len(list)`取代了`list[x]`，因为`x`是列表中的最后一个索引

这些是除了删除项目之外发生的副作用。因为列表中的项目可能会移动，所以一次删除多个项目变得更具挑战性。

当列表包含具有`__eq__()`特殊方法定义的项目时，列表`remove()`方法可以删除每个项目。当列表项没有简单的`__eq__()`测试时，从列表中删除多个项目就变得更具挑战性。

我们如何从列表中删除多个项目？

## 准备工作

我们将使用一个字典列表结构。在这种情况下，我们有一些包括歌曲名称、作者和持续时间的数据。数据看起来像这样：

```py
 **>>> source = [ 
...    {'title': 'Eruption', 'writer': ['Emerson'], 'time': '2:43'}, 
...    {'title': 'Stones of Years', 'writer': ['Emerson', 'Lake'], 'time': '3:43'}, 
...    {'title': 'Iconoclast', 'writer': ['Emerson'], 'time': '1:16'}, 
...    {'title': 'Mass', 'writer': ['Emerson', 'Lake'], 'time': '3:09'}, 
...    {'title': 'Manticore', 'writer': ['Emerson'], 'time': '1:49'}, 
...    {'title': 'Battlefield', 'writer': ['Lake'], 'time': '3:57'}, 
...    {'title': 'Aquatarkus', 'writer': ['Emerson'], 'time': '3:54'} 
... ]** 

```

要使用这种数据结构，我们需要`pprint`函数：

```py
 **>>> from pprint import pprint** 

```

我们可以很容易地使用`for`语句遍历值列表。问题是，我们如何删除选定的项目？

```py
 **>>> data = source.copy() 
>>> for item in data: 
...     if 'Lake' in item['writer']: 
...        print("remove", item['title']) 
remove Stones of Years 
remove Mass 
remove Battlefield** 

```

我们不能简单地在这里使用语句`del item`，因为它对源集合`data`没有影响。这个语句只会通过删除`item`变量和相关对象来删除原始列表中项目的本地变量副本。

要正确地从列表中删除项目，我们必须使用列表中的索引位置。这是一个天真的方法，绝对行不通：

```py
 **>>> data = source.copy() 
>>> for index in range(len(data)):  
...    if 'Lake' in data[index]['writer']: 
...       del data[index] 
Traceback (most recent call last): 
  File "/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/doctest.py", line 1320, in __run 
    compileflags, 1), test.globs) 
  File "<doctest __main__.__test__.chapter[5]>", line 2, in <module> 
    if 'Lake' in data[index]['writer']: 
IndexError: list index out of range** 

```

不能简单地使用`range(len(data))`基于列表的原始大小。随着项目的移除，列表变得更小。索引的值将被设置为一个太大的值。

当删除具有简单相等测试的简单项目时，我们将使用类似这样的东西：

```py
    while x in list: 
        list.remove(x) 

```

问题在于我们没有一个`__contains__()`的实现，它可以识别`item['writer']`中带有`Lake`的项目。我们可以使用 dict 的子类来实现`__eq__()`，作为`self['writer']`中的字符串参数值。这显然违反了相等性的语义，因为它只检查一个字段。

我们不能扩展这些类的内置特性。这里的用例非常特定于问题域，而不是字典结构的一般特性。

为了与基本的`while in...remove`循环并行，我们需要写出类似这样的东西：

```py
 **>>> def index(data): 
...    for i in range(len(data)): 
...        if 'Lake' in data[i]['writer']: 
...            return i 
>>> data = source.copy() 
>>> position = index(data) 
>>> while position: 
...    del data[position] # or data.pop(position) 
...    position = index(data)** 

```

我们编写了一个名为`index()`的函数，它定位目标值的第一个实例。这个函数的结果是一个提供两种信息的单个值：

+   当返回的值不是`None`时，该项目存在于列表中

+   返回值是列表中项目的正确索引

`index()`函数冗长且不灵活。如果我们有替代规则，我们需要编写多个`index()`函数，或者我们需要使测试更灵活。

更重要的是，考虑当目标值在*n*个项目的列表中出现*x*次时。这个循环将进行*x*次。每次循环平均检查列表中的**O**(*x*×*n/2*)次。最坏的情况是项目都在列表的末尾，导致处理迭代次数略少于**O**(*x*×*n*)。

我们可以做得更好。我们的首选解决方案建立在第二章的*设计一个正确终止的 while 语句*配方中的想法上，*语句和语法*，以设计一个适当的循环来从列表结构中删除复杂的项目。

## 如何做...

1.  将索引值初始化为零。这建立了一个将遍历数据集合的变量：

```py
            i = 0 

    ```

1.  终止条件必须表明列表中的每个项目都已经被检查过了。此外，循环体需要删除所有符合目标条件的项目。这导致了一个不变条件，即`item[i]`尚未被检查。项目被检查后，它可能被保留，这意味着索引`i`必须被递增以重置尚未被检查的不变条件。如果项目被移除，那么项目将向前移动，`item[i]`将自动满足尚未被检查的不变条件：

```py
            if 'Lake' in data[i]['writer']: 
                del data[i] # Remove 
            else: 
                i += 1 # Preserve 

    ```

删除一个项目时，列表变短了一个，索引值`i`将指向一个新的未检查的项目。保留一个项目时，索引值`i`将被提前到下一个未检查的项目。

1.  终止条件用于包装处理体：

```py
            while i != len(data): 

    ```

在`while`语句结束时，`i`的值将表明所有项目都已经被检查过了。

这导致了以下结果：

```py
     **>>> i = 0 
          >>> while i != len(data): 
          ...    if 'Lake' in data[i]['writer']: 
          ...        del data[i] 
          ...    else: 
          ...        i += 1 
          >>> pprint(data) 
          [{'time': '2:43', 'title': 'Eruption', 'writer': ['Emerson']}, 
           {'time': '1:16', 'title': 'Iconoclast', 'writer': ['Emerson']}, 
           {'time': '1:49', 'title': 'Manticore', 'writer': ['Emerson']}, 
           {'time': '3:54', 'title': 'Aquatarkus', 'writer': ['Emerson']}]** 

    ```

这使得数据只经过一次，并且在不引发索引错误或跳过应该被删除的项目的情况下删除了请求的项目。

## 工作原理...

目标是确切地检查每个项目一次，并且要么删除它，要么跳过它。循环设计反映了 Python 列表项目移除的工作方式。当一个项目被移除时，所有后续项目都会在列表中向前移动。

基于`range()`和`len()`函数的天真过程将有两个问题：

+   当项目向前移动并且范围对象产生下一个值时，项目将被跳过。

+   索引可以超出列表结构的末尾，因为`len()`只被用来获取原始大小，而不是当前大小

由于这两个问题，循环体中不变条件的设计非常重要。这反映了两种可能的状态变化：

+   如果一个项目被移除，索引就不会改变。列表本身将会改变。

+   如果一个项目被保留，索引必须改变。

我们可以说循环使数据通过一次，并且具有**O**(*n*)的复杂度。这里没有考虑的是每次删除的相对成本。从列表中删除项目`0`意味着每个剩余项目都向前移动一个位置。每次删除的成本实际上是*O*(*n*)。因此，复杂度更像是**O**(*n × x*)，其中从*n*个项目的列表中移除*x*个项目。

即使这个算法也不是从列表中删除项目的最快方法。

## 还有更多...

如果我们放弃删除的想法，我们甚至可以做得更好。制作项目的浅拷贝比从列表中删除项目要快得多，但使用的存储空间更多。这是一种常见的时间与内存的权衡。

我们可以使用类似以下的生成器表达式：

```py
 **>>> data = [item for item in source if not('Lake' in item['writer'])]** 

```

这将创建一个列表中我们想要保留的项目的浅拷贝。我们不想保留的项目将被忽略。有关浅拷贝的更多信息，请参阅第四章中的*制作对象的浅拷贝和深拷贝*配方，*内置数据结构 - 列表、集合、字典*。

我们还可以使用这样的高阶函数：

```py
 **>>> data = list(filter(lambda item: not('Lake' in item['writer']), source))** 

```

`filter()`函数有两个参数：一个`lambda`对象和原始数据集。`lambda`对象是函数的一种退化情况：它有参数和一个单一表达式。在这种情况下，单一表达式用于决定要传递哪些项目。`lambda`为`False`的项目将被拒绝。

`filter()`函数是一个生成器。这意味着我们需要收集所有项目来创建最终的列表对象。`for`语句是处理生成器的所有结果的一种方法。`list()`和`tuple()`函数也会消耗生成器的所有项目。

我们可以实现这一点的第三种方法是编写自己的生成器函数，体现了过滤的概念。这将使用比生成器或`filter()`函数更多的语句，但可能更清晰。

这是一个生成器函数定义：

```py
    def writer_rule(iterable): 
        for item in iterable: 
            if 'Lake' in item['writer']: 
                continue 
            yield item 

```

我们使用`for`语句来检查源列表中的每个项目。如果项目在作者列表中有'Lake'，我们将继续`for`语句的处理过程，有效地拒绝这个项目。如果'Lake'不在作者列表中，我们将产生该项目。

当我们调用这个函数时，它将产生有趣的列表。我们可以像这样使用函数`writer_rule()`：

```py
 **>>> from ch07_r07 import writer_rule 
>>> data = list(writer_rule(source)) 
>>> pprint(data) 
[{'time': '2:43', 'title': 'Eruption', 'writer': ['Emerson']}, 
 {'time': '1:16', 'title': 'Iconoclast', 'writer': ['Emerson']}, 
 {'time': '1:49', 'title': 'Manticore', 'writer': ['Emerson']}, 
 {'time': '3:54', 'title': 'Aquatarkus', 'writer': ['Emerson']}]** 

```

这将把有趣的行累积到一个新的结构中。由于这是一个浅拷贝，它不会浪费大量的存储空间。

## 另请参阅

+   这是基于第二章中的*设计一个正确终止的 while 语句*配方，*语句和语法*

+   我们还利用了另外两个配方：*制作对象的浅拷贝和深拷贝*和*切片和切割列表*在第四章，*内置数据结构 - 列表、集合、字典*。
