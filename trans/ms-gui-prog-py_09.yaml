- en: Working with Audio-Visual Using QtMultimedia
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QtMultimedia处理音频-视频
- en: Whether in games, communications, or media production applications, audio and
    video content is often a crucial part of modern applications. When working with
    native APIs, even the simplest **audio-visual** (**AV**) applications can be quite
    complicated, especially when supporting multiple platforms. However, fortunately
    for us, Qt provides us with a simple cross-platform multimedia API in the form
    of `QtMultimedia`. With `QtMultimedia`, we can easily work with audio content,
    video content, or devices such as cameras and radios.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是在游戏、通信还是媒体制作应用中，音频和视频内容通常是现代应用的重要组成部分。当使用本机API时，即使是最简单的音频-视频（AV）应用程序在支持多个平台时也可能非常复杂。然而，幸运的是，Qt为我们提供了一个简单的跨平台多媒体API，即`QtMultimedia`。使用`QtMultimedia`，我们可以轻松地处理音频内容、视频内容或摄像头和收音机等设备。
- en: 'In this chapter, we''ll use `QtMultimedia` to explore the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将使用`QtMultimedia`来探讨以下主题：
- en: Simple audio playback
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的音频播放
- en: Recording and playing audio
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 录制和播放音频
- en: Recording and playing video
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 录制和播放视频
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In addition to the basic PyQt setup described in [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml),
    *Getting Started with PyQt,* you will need to make sure the `QtMultimedia` and
    `PyQt.QtMultimedia` libraries are installed. If you installed PyQt5 using `pip`,
    then it should already be installed. Linux users who are using their distro's
    package manager should check that these packages are installed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml)中描述的基本PyQt设置外，您还需要确保已安装`QtMultimedia`和`PyQt.QtMultimedia`库。如果您使用`pip`安装了PyQt5，则应该已经安装了。使用发行版软件包管理器的Linux用户应检查这些软件包是否已安装。
- en: You may also want to download the code from our GitHub repository at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter07](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter07),
    which contains not only the example code but the audio data used for these examples.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还想从我们的GitHub存储库[https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter07](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter07)下载代码，其中包含示例代码和用于这些示例的音频数据。
- en: If you want to create your own audio files to work with, you might want to install
    the free Audacity sound editor at [https://www.audacityteam.org/](https://www.audacityteam.org/).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建自己的音频文件进行处理，您可能需要安装免费的Audacity音频编辑器，网址为[https://www.audacityteam.org/](https://www.audacityteam.org/)。
- en: Finally, you will get the most out of this chapter if your computer has a working
    audio system, microphone, and webcam. If it does not, then some of the examples
    will not work for you.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您的计算机没有工作的音频系统、麦克风和网络摄像头，您将无法充分利用本章。如果没有，那么其中一些示例将无法为您工作。
- en: Check out the following video to see the code in action: [http://bit.ly/2Mjr8vx](http://bit.ly/2Mjr8vx)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[http://bit.ly/2Mjr8vx](http://bit.ly/2Mjr8vx)
- en: Simple audio playback
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的音频播放
- en: Quite often, applications need to playback sounds in response to GUI events,
    as you might do in a game or just to provide audio feedback for user actions.
    For this application, `QtMultimedia` offers the `QSoundEffect` class. `QSoundEffect`
    is limited to playing back uncompressed audio, so it works with **Pulse Code M****odulation** (**PCM**), **Waveform
    data** (**WAV**) files but not MP3 or OGG files. The trade-off is that it is low-latency
    and very efficient with resources, so while it's not useful as a general-purpose
    audio player, it is perfect for fast playback of sound effects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，应用程序需要对GUI事件做出声音回应，就像在游戏中一样，或者只是为用户操作提供音频反馈。对于这种应用程序，`QtMultimedia`提供了`QSoundEffect`类。`QSoundEffect`仅限于播放未压缩音频，因此它可以使用**脉冲编码调制**（**PCM**）、**波形数据**（**WAV**）文件，但不能使用MP3或OGG文件。这样做的好处是它的延迟低，资源利用率非常高，因此虽然它不适用于通用音频播放器，但非常适合快速播放音效。
- en: To demonstrate `QSoundEffect`, let's build a phone dialer. Copy the application
    template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml), *Building
    Applications with QMainWindow,* into a new file called `phone_dialer.py` and open
    it in your editor.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`QSoundEffect`，让我们构建一个电话拨号器。将[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)中的应用程序模板*使用QMainWindow构建应用程序*复制到一个名为`phone_dialer.py`的新文件中，并在编辑器中打开它。
- en: 'Let''s start by importing the `QtMultimedia` library, as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先导入`QtMultimedia`库，如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Importing `QtMultimedia` will be a necessary first step for all the examples
    in this chapter, and we will consistently use `qtmm` as an alias for it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`QtMultimedia`将是本章所有示例的必要第一步，我们将一贯使用`qtmm`作为其别名。
- en: 'We''ll also import a `resources` library containing the necessary WAV data:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将导入一个包含必要的WAV数据的`resources`库：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This `resources` file contains a collection of **Dial Tone Multi-Frequency** (**DTMF**)
    tones. These are the tones generated by telephones when dialing, and we've included `0`
    through to `9`, `*`, and `#`. We've included this file in the example code; alternatively,
    you can create your own `resources` file from your own audio samples (you can
    refer to [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml), *Styling Qt
    Applications,* for information on how to do this).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`resources`文件包含一系列**双音多频**（**DTMF**）音调。这些是电话拨号时电话生成的音调，我们包括了`0`到`9`、`*`和`#`。我们已经在示例代码中包含了这个文件；或者，您可以从自己的音频样本创建自己的`resources`文件（您可以参考[第6章](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml)中关于如何做到这一点的信息）。
- en: You can generate DTMF tones using the free Audacity sound editor. To do so,
    select Generate | DTMF from Audacity's main menu.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用免费的Audacity音频编辑器生成DTMF音调。要这样做，请从Audacity的主菜单中选择生成|DTMF。
- en: 'Once that''s in place, we''re going to create a `QPushButton` subclass that
    plays a sound effect when it is clicked on, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些，我们将创建一个`QPushButton`子类，当单击时会播放声音效果，如下所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, we've modified the constructor to take a sound file path as
    an argument. This value is converted to `QUrl` and passed into our `QSoundEffect`
    object using the `setSource()` method. Finally, the `QSoundEffect.play()` method
    triggers playback of the sound, so we've connected it to the button's `clicked`
    signal. This is all it takes to create our `SoundButton` object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们修改了构造函数以接受声音文件路径作为参数。这个值被转换为`QUrl`并通过`setSource()`方法传递到我们的`QSoundEffect`对象中。最后，`QSoundEffect.play()`方法触发声音的播放，因此我们将其连接到按钮的`clicked`信号。这就是创建我们的`SoundButton`对象所需的全部内容。
- en: 'Back in the `MainWindow.__init__()` method, let''s create some `SoundButton`
    objects and arrange them in the GUI:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`MainWindow.__init__()`方法，让我们创建一些`SoundButton`对象并将它们排列在GUI中：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We've set up the resource file so that each DTMF tone can be accessed by its
    symbol under the `dtmf` prefix; for example, `':/dtmf/1.wav'` refers to the DTMF
    tone for 1\. In this way, we can just iterate through a string of symbols and
    create a `SoundButton` object for each, which we add to a three-column grid.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了资源文件，以便可以通过`dtmf`前缀下的符号访问每个DTMF音调；例如，`':/dtmf/1.wav'`指的是1的DTMF音调。通过这种方式，我们可以遍历一串符号并为每个创建一个`SoundButton`对象，然后将其添加到三列网格中。
- en: That's all there is to it; run this program and push the buttons. It should
    sound just like dialing a phone!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样；运行这个程序并按下按钮。它应该听起来就像拨打电话！
- en: Recording and playing audio
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 录制和播放音频
- en: '`QSoundEffect` is adequate for dealing with simple event sounds, but for more
    advanced audio projects we''re going to need something with more capabilities.
    Ideally, we want the ability to load more formats, control various aspects of
    the playback, and record new sounds.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSoundEffect`足以处理简单的事件声音，但对于更高级的音频项目，我们需要具备更多功能的东西。理想情况下，我们希望能够加载更多格式，控制播放的各个方面，并录制新的声音。'
- en: 'In this section, we''re going to focus on two classes that provide these features:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将专注于提供这些功能的两个类：
- en: The `QMediaPlayer` class, which is like a virtual media player device that can
    load audio or video content
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QMediaPlayer`类，它类似于一个虚拟媒体播放器设备，可以加载音频或视频内容'
- en: The `QAudioRecorder` class, which manages the recording of audio data to a disk
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QAudioRecorder`类，用于管理将音频数据录制到磁盘'
- en: To see these classes in action, we're going to build a sampling soundboard.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这些类的实际效果，我们将构建一个采样音效板。
- en: The initial setup
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始设置
- en: First, make a fresh copy of the application template and call it `soundboard.py`.
    Then, import `QtMultimedia` as you did for the last project, and let's layout
    the main interface.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，制作一个新的应用程序模板副本，并将其命名为`soundboard.py`。然后，像上一个项目一样导入`QtMultimedia`，并布局主界面。
- en: 'Inside the `MainWindow` constructor, add in the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainWindow`构造函数中，添加以下代码：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All we're doing here is creating an empty central widget, adding a grid layout,
    and then filling it with `3` rows and `3` columns of `SoundWidget` objects.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的只是创建一个空的中央小部件，添加一个网格布局，然后用`3`行`3`列的`SoundWidget`对象填充它。
- en: Implementing sound playback
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现声音播放
- en: Our `SoundWidget` class is going to be a `QWidget` object that manages a single
    sound sample. When finished, it will allow us to load or record an audio sample,
    play it back looped or as a one-shot, and control its volume and playback position.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SoundWidget`类将是一个管理单个声音样本的`QWidget`对象。完成后，它将允许我们加载或录制音频样本，循环播放或单次播放，并控制其音量和播放位置。
- en: 'Above the `MainWindow` constructor, let''s create the class and give it a layout:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainWindow`构造函数之前，让我们创建这个类并给它一个布局：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first thing we've added is a label that will display the name of the sample
    file the widget has loaded. The next thing we need is a button to control the
    playback. Instead of just a plain push button, let's apply some of our styling
    skills to create a custom button that can switch between being a Play button and
    a Stop button.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '我们添加的第一件事是一个标签，它将显示小部件加载的样本文件的名称。我们需要的下一件事是一个控制播放的按钮。我们不只是一个普通的按钮，让我们运用一些我们的样式技巧来创建一个可以在播放按钮和停止按钮之间切换的自定义按钮。 '
- en: 'Start a `PlayButton` class above the `SoundWidget` class, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SoundWidget`类的上方开始一个`PlayButton`类，如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Back in the `SoundWidget` class, we''ll add a `PlayButton` object, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`SoundWidget`类，我们将添加一个`PlayButton`对象，如下所示：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have a control button, we need to create the `QMediaPlayer` object
    that will play the sample, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个控制按钮，我们需要创建将播放采样的`QMediaPlayer`对象，如下所示：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can think of `QMediaPlayer` as the software equivalent to a hardware media
    player such as a CD or Blu-ray player. Just like a hardware media player has Play,
    Pause, and Stop buttons, the `QMediaPlayer` object has `play()`, `stop()`, and
    `pause()` slots to control the playback of the media.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`QMediaPlayer`视为硬件媒体播放器（如CD或蓝光播放器）的软件等效物。就像硬件媒体播放器有播放、暂停和停止按钮一样，`QMediaPlayer`对象有`play()`、`stop()`和`pause()`槽来控制媒体的播放。
- en: 'Let''s connect our dual-function `PlayButton` object to the player. We''ll
    do this by way of an instance method called `on_playbutton()`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的双功能`PlayButton`对象连接到播放器。我们将通过一个名为`on_playbutton()`的实例方法来实现这一点：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is how `SoundWidget.on_playbutton()` will look:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoundWidget.on_playbutton()`将如何看起来：'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method examines the player object's `state` property, which returns a constant
    indicating whether the player is playing, has paused, or has stopped. If the player
    is currently playing, we stop it—if not, we ask it to play.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法检查了播放器对象的`state`属性，该属性返回一个常量，指示播放器当前是正在播放、已暂停还是已停止。如果播放器当前正在播放，我们就停止它；如果没有，我们就要求它播放。
- en: 'Since our button is switching between a play and stop button, let''s update
    its label and appearance. `QMediaPlayer` emits a `stateChanged` signal when its
    state changes, which we can send to our `PlayButton` object, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的按钮在播放和停止按钮之间切换，让我们更新它的标签和外观。`QMediaPlayer`在其状态改变时发出`stateChanged`信号，我们可以将其发送到我们的`PlayButton`对象，如下所示：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Back in the `PlayButton` class, let''s handle that signal, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`PlayButton`类，让我们处理该信号，如下所示：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, `stateChanged` passes along the new state of the media player, which we
    use to set the button to its play or stop appearance.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`stateChanged`传递了媒体播放器的新状态，我们用它来设置按钮的播放或停止外观。
- en: Loading the media
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载媒体
- en: Just as a hardware media player requires a CD, a DVD, or a Blu-ray disc loaded
    into it to actually play anything back, our `QMediaPlayer` also needs some kind
    of content loaded before it can play any audio. Let's explore how to load a sound
    from a file.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 就像硬件媒体播放器需要加载CD、DVD或蓝光光盘才能实际播放任何内容一样，我们的`QMediaPlayer`在播放任何音频之前也需要加载某种内容。让我们探讨如何从文件中加载声音。
- en: 'Start by adding a button to the `SoundWidget` layout, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在`SoundWidget`布局中添加一个按钮，如下所示：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This button calls to the `get_file()` method, which looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个按钮调用`get_file()`方法，看起来是这样的：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This method simply calls `QFileDialog` to retrieve a file URL and then passes
    it along to another method, `set_file()`, which we'll write next. We've set the
    filter to look for five common audio file types, but feel free to add more if
    you have audio in a different format—`QMediaPlayer` is quite flexible in what
    it can load.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法简单地调用`QFileDialog`来检索文件URL，然后将其传递给另一个方法`set_file()`，我们将在下面编写。我们已经设置了过滤器来查找五种常见的音频文件类型，但如果你有不同格式的音频，可以随意添加更多——`QMediaPlayer`在加载方面非常灵活。
- en: Note that we're calling `getOpenFileUrl()`, which returns a `QUrl` object rather
    than a file path string. `QMediaPlayer` prefers working with `QUrl` objects so
    this will save us a conversion step.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在调用`getOpenFileUrl()`，它返回一个`QUrl`对象，而不是文件路径字符串。`QMediaPlayer`更喜欢使用`QUrl`对象，因此这将节省我们一个转换步骤。
- en: 'The `set_file()` method is where we''ll finally load our media into the player:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_file()`方法是我们最终将媒体加载到播放器中的地方：'
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Before we can pass the URL to our media player, we have to wrap it in a `QMediaContent`
    class. This provides the player with the API it needs to playback the content.
    Once wrapped, we can use `QMediaPlayer.setMedia()` to load it up, and then it's
    ready for playback. You can visualize this process as putting audio data onto
    a CD (the `QMediaContent` object), and then loading that CD into a CD player (using
    `setMedia()`).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以将URL传递给媒体播放器之前，我们必须将其包装在`QMediaContent`类中。这为播放器提供了播放内容所需的API。一旦包装好，我们就可以使用`QMediaPlayer.setMedia()`来加载它，然后它就准备好播放了。你可以将这个过程想象成将音频数据放入CD（`QMediaContent`对象），然后将CD加载到CD播放器中（使用`setMedia()`）。
- en: As a last touch, we've retrieved the filename of the loaded file and put it
    in the label.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的修饰，我们已经检索了加载文件的文件名，并将其放在标签中。
- en: Tracking the playback position
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪播放位置
- en: At this point, our soundboard can load and play samples, but it would be nice
    to see and control the position of playback, particularly for long samples. `QMediaPlayer`
    allows us to retrieve and control the playback position through signals and slots,
    so let's look into that from our GUI.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的声音板可以加载和播放样本，但是看到并控制播放位置会很好，特别是对于长样本。`QMediaPlayer`允许我们通过信号和槽来检索和控制播放位置，所以让我们从我们的GUI中来看一下。
- en: 'Start by creating a `QSlider` widget, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个`QSlider`小部件，如下所示：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`QSlider` is a widget that we haven''t looked at yet; it''s just a slider control
    that can be used to input integers between a minimum and maximum value.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSlider`是一个我们还没有看过的小部件；它只是一个滑块控件，可以用来输入最小值和最大值之间的整数。'
- en: 'Now connect the slider and player, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在连接滑块和播放器，如下所示：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `QMediaPlayer` class reports its position in integers representing the number
    of milliseconds from the start of the file so that we can connect the `positionChanged`
    signal to the slider's `setSliderPosition()` slot.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMediaPlayer`类以表示从文件开始的毫秒数的整数报告其位置，因此我们可以将`positionChanged`信号连接到滑块的`setSliderPosition()`槽。'
- en: However, we also need to adjust the slider's maximum position so that it matches
    the duration of the sample, otherwise, the slider won't know what percentage the
    value represents. Therefore, we've connected the player's `durationChanged` signal
    (which is emitted whenever new content is loaded into the player) to the slider's
    `setMaximum()` slot.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还需要调整滑块的最大位置，使其与样本的持续时间相匹配，否则滑块将不知道值代表的百分比。因此，我们已经将播放器的`durationChanged`信号（每当新内容加载到播放器时发出）连接到滑块的`setMaximum()`槽。
- en: Finally, we'd like to be able to control the playback position using the slider,
    so we set the `sliderMoved` signal to the player's `setPosition()` slot. Note
    that we definitely want to use `sliderMoved` and not `valueChanged` (which `QSlider`
    emits when the value is changed by the user *or* by an event), because the latter
    would create a feedback loop when the media player changes the position.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望能够使用滑块来控制播放位置，因此我们将`sliderMoved`信号设置为播放器的`setPosition()`槽。请注意，我们绝对要使用`sliderMoved`而不是`valueChanged`（当用户*或*事件更改值时，`QSlider`发出的信号），因为后者会在媒体播放器更改位置时创建一个反馈循环。
- en: These connections are all we need for our slider to work. Now you can run the
    program and load up a long sound; you'll see that the slider tracks the playback
    position and can be moved around before or during playback to alter the position.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些连接是我们的滑块工作所需的全部。现在你可以运行程序并加载一个长声音；你会看到滑块跟踪播放位置，并且可以在播放之前或期间移动以改变位置。
- en: Looping the audio
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环音频
- en: Playing our samples in one-shots is neat, but we'd also like to loop them. Looping
    audio in a `QMediaPlayer` object requires a slightly different approach. Instead
    of loading a `QMediaContent` object directly, we need to first add it to a `QMediaPlayList`
    object. We can then tell the playlist to loop.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在一次性播放我们的样本很好，但我们也想循环播放它们。在`QMediaPlayer`对象中循环音频需要稍微不同的方法。我们需要先将`QMediaContent`对象添加到`QMediaPlayList`对象中，然后告诉播放列表循环播放。
- en: 'Back in our `set_file()` method, we need to make the following changes to our
    code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`set_file()`方法，我们需要对我们的代码进行以下更改：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A playlist can, of course, have multiple files loaded, but, in this case, we
    only want one. We load the `QMediaContent` object into the playlist using the
    `addMedia()` method and then point the playlist to that file using the `setCurrentIndex()`
    method. Note that the playlist won't automatically point to any item by default.
    This means that if you skip this last step, then nothing will happen when you
    try to play the playlist.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一个播放列表可以加载多个文件，但在这种情况下，我们只想要一个。我们使用`addMedia（）`方法将`QMediaContent`对象加载到播放列表中，然后使用`setCurrentIndex（）`方法将播放列表指向该文件。请注意，播放列表不会自动指向任何项目。这意味着如果您跳过最后一步，当您尝试播放播放列表时将不会发生任何事情。
- en: Finally, we use the media player's `setPlaylist()` method to add the playlist.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用媒体播放器的`setPlaylist（）`方法添加播放列表。
- en: 'Now that our content is in a playlist, we''ll create a checkbox to switch looping
    on and off:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的内容在播放列表中，我们将创建一个复选框来切换循环播放的开关：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, we''re connecting the checkbox''s `stateChanged` signal to
    a callback method; the method will be as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们正在将复选框的`stateChanged`信号连接到一个回调方法；该方法将如下所示：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `playbackMode` property of the `QMediaPlaylist` class is very similar to
    the track mode button on a CD player, which can be used to switch between repeat,
    shuffle, or sequential play. There are five playback modes, as shown in the following
    table:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMediaPlaylist`类的`playbackMode`属性与CD播放器上的曲目模式按钮非常相似，可以用于在重复、随机或顺序播放之间切换。如下表所示，有五种播放模式：'
- en: '| Mode | Description |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 描述 |'
- en: '| --- | --- |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CurrentItemOnce` | Play the current track once and stop. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `CurrentItemOnce` | 播放当前曲目一次，然后停止。 |'
- en: '| `CurrentItemInLoop` | Play the current item repeatedly. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `CurrentItemInLoop` | 重复播放当前项目。 |'
- en: '| `Sequential` | Play all the items in the order and then stop. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `顺序` | 播放所有项目，然后停止。 |'
- en: '| `Loop` | Play all the items in the order and then repeat. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `循环` | 播放所有项目，然后重复。 |'
- en: '| `Random` | Play all the items in a random order. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `随机` | 以随机顺序播放所有项目。 |'
- en: In this method, we're switching between `CurrentItemOnce` and `CurrentItemInLoop`
    depending on whether the checkbox is checked. Since our playlist only has one
    item, the remaining modes aren't meaningful.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们根据复选框是否被选中来在`CurrentItemOnce`和`CurrentItemInLoop`之间切换。由于我们的播放列表只有一个项目，剩下的模式是没有意义的。
- en: 'As a final touch, we''ll clear the checkbox on loading a new file. So, add
    this to the end of `set_file()`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当加载新文件时，我们将清除复选框。因此，请将以下内容添加到`set_file（）`的末尾：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: At this point, you should be able to run the program and loop the sample. Note
    that looping audio using this method may not guarantee a seamless loop; depending
    on your platform and system capabilities, there may be a small gap between iterations
    of the loop.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您应该能够运行程序并循环播放示例。请注意，使用此方法循环音频可能无法保证无缝循环；取决于您的平台和系统功能，循环的迭代之间可能会有一个小间隙。
- en: Setting the volume
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置音量
- en: Our final playback feature will be volume control. To allow us to control the
    playback level, `QMediaPlayer` has a `volume` parameter that accepts values from
    `0` (muted) to `100` (full volume).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终播放功能将是音量控制。为了让我们能够控制播放级别，`QMediaPlayer`有一个接受值从`0`（静音）到`100`（最大音量）的`volume`参数。
- en: 'We''ll simply add another slider widget to control the volume, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简单地添加另一个滑块小部件来控制音量，如下所示：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After setting the minimum and maximum values accordingly, we just need to connect
    `sliderMoved` to the media player's `setVolume()` slot. That's all there is to
    it!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置最小和最大值后，我们只需要将`sliderMoved`连接到媒体播放器的`setVolume（）`槽。就是这样！
- en: For smoother volume control, the Qt documentation recommends converting the
    slider's linear scale to a logarithmic scale. We recommend that you read [https://doc.qt.io/qt-5/qaudio.html#convertVolume](https://doc.qt.io/qt-5/qaudio.html#convertVolume)
    and see whether you can do this yourself.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更平滑地控制音量，Qt文档建议将滑块的线性刻度转换为对数刻度。我们建议您阅读[https://doc.qt.io/qt-5/qaudio.html#convertVolume](https://doc.qt.io/qt-5/qaudio.html#convertVolume)，看看您是否可以自己做到这一点。
- en: Implementing recording
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现录音
- en: The audio recording in Qt is facilitated by the `QAudioRecorder` class. Just
    as the `QMediaPlayer` class was analogous to a media playback device, the `QAudioRecorder` class
    is analogous to a media recording device such as a digital audio recorder (or,
    if you're of the author's generation, a tape recorder). The recorder is controlled
    using the `record()`, `stop()`, and `pause()` methods, much like the media player
    object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Qt中的音频录制是通过`QAudioRecorder`类实现的。就像`QMediaPlayer`类类似于媒体播放设备一样，`QAudioRecorder`类类似于媒体录制设备，例如数字音频录音机（或者如果您是作者的一代人，磁带录音机）。录音机使用`record（）`、`stop（）`和`pause（）`方法进行控制，就像媒体播放器对象一样。
- en: 'Let''s add a recorder object to our `SoundWidget`, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的`SoundWidget`添加一个录音机对象，如下所示：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To control the recorder, we''ll create another dual-function button class that
    is similar to the play button that we previously created:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制录音机，我们将创建另一个双功能按钮类，类似于我们之前创建的播放按钮：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Just as with the `PlayButton` class, we're switching the appearance of the button
    whenever a new `state` value is received from the recorder's `stateChanged` signal.
    In this case, we're looking for the recorder's `RecordingState` state.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`PlayButton`类一样，每当从录音机的`stateChanged`信号接收到新的`state`值时，我们就会切换按钮的外观。在这种情况下，我们正在寻找录音机的`RecordingState`状态。
- en: 'Let''s add a `RecordButtoon()` method to our widget, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的小部件添加一个`RecordButtoon（）`方法，如下所示：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We've connected the `clicked` signal to an `on_recordbutton()` method, which
    will handle the starting and stopping of the audio recording.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`clicked`信号连接到`on_recordbutton（）`方法，该方法将处理音频录制的开始和停止。
- en: 'This method is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法如下：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first thing that we'll do is check the state of the recorder. If it's currently
    recording, then we'll stop it by calling `recorder.stop()`, which not only stops
    the recording but writes the recorded data to an audio file on a disk. We can
    then get the location of that file by calling the recorder's `actualLocation()`
    method. This method returns a `QUrl` object, which we can pass directly to `self.set_file()`
    to set our playback to the newly recorded file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先检查录音机的状态。如果它当前正在录制，那么我们将通过调用`recorder.stop()`来停止它，这不仅会停止录制，还会将录制的数据写入磁盘上的音频文件。然后，我们可以通过调用录音机的`actualLocation()`方法来获取该文件的位置。此方法返回一个`QUrl`对象，我们可以直接将其传递给`self.set_file()`以将我们的播放设置为新录制的文件。
- en: Make sure that you use `actualLocation()` to get the location of the file. The
    recording location can be configured using `setLocation()`, and this value is
    available from the `location()` accessor. However, Qt may fall back to a default
    setting if the configured location is invalid or non-writable. `actualLocation()`
    returns the URL where the file was actually saved.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用`actualLocation()`获取文件的位置。可以使用`setLocation()`配置录制位置，并且此值可以从`location()`访问器中获取。但是，如果配置的位置无效或不可写，Qt可能会回退到默认设置。`actualLocation()`返回文件实际保存的URL。
- en: 'If we''re not currently recording, we''ll tell the recorder to start recording
    by calling `recorder.record()`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们当前没有录制，我们将通过调用`recorder.record()`来告诉录音机开始录制：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When `record()` is called, the audio recorder begins recording audio in the
    background and will continue to do so until `stop()` is called.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`record()`时，音频录制器将在后台开始录制音频，并将一直保持录制，直到调用`stop()`。
- en: 'Before we can playback our recorded files, we need to make one fix to `set_file()`.
    At the time of writing, the `QAudioRecorder.actualLocation()` method neglects
    to add a scheme value to the URL, so we''ll need to specify this manually:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以播放录制的文件之前，我们需要对`set_file()`进行一次修复。在撰写本文时，`QAudioRecorder.actualLocation()`方法忽略了向URL添加方案值，因此我们需要手动指定这个值：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In `QUrl` terms, the `scheme` object indicates the protocol of the URL, such
    as HTTP, HTTPS, or FTP. Since we're accessing local files, the scheme should be
    `'file'`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`QUrl`术语中，`scheme`对象指示URL的协议，例如HTTP、HTTPS或FTP。由于我们正在访问本地文件，因此方案应为`'file'`。
- en: If the default settings of `QAudioRecorder` work correctly on your system, then
    you should be able to record and playback audio. However, that's a big *if*; it
    is more than likely that you'll need to do some configuration on the audio recorder
    object to get things working. Let's look at how to do that next.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`QAudioRecorder`的默认设置在您的系统上正常工作，则应该能够录制和播放音频。但是，这是一个很大的*如果*；很可能您需要对音频录制器对象进行一些配置才能使其正常工作。让我们看看如何做到这一点。
- en: Examining and configuring the recorder
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查和配置录音机
- en: Even if the `QAudioRecorder` class worked well for you, you might wonder whether
    there's a way to control the type and quality of the audio that it records, what
    source it records the audio from, and what location it writes the audio files
    to.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`QAudioRecorder`类对您来说运行良好，您可能会想知道是否有一种方法可以控制它记录的音频类型和质量，它从哪里记录音频，以及它将音频文件写入的位置。
- en: In order to configure these things, we first have to know what your system supports,
    as support for different audio recording features can be dependent on hardware,
    drivers, or operating system capabilities. `QAudioRecorder` has methods that can
    provide information about the capabilities that are available.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了配置这些内容，我们首先必须知道您的系统支持什么，因为对不同音频录制功能的支持可能取决于硬件、驱动程序或操作系统的能力。`QAudioRecorder`有一些方法可以提供有关可用功能的信息。
- en: 'The following script will display information about supported audio features
    on your system:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本将显示有关系统支持的音频功能的信息：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can run this script on your system and get a list of the supported `Inputs`,
    `Codecs`, `Sample Rates`, and `container` formats. For instance, on a typical
    Microsoft Windows system, your results will probably be as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在您的系统上运行此脚本并获取受支持的`Inputs`、`Codecs`、`Sample Rates`和`container`格式的列表。例如，在典型的Microsoft
    Windows系统上，您的结果可能如下所示：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To configure the input source for a `QAudioRecorder` object, you need to pass
    the name of the audio input to the `setAudioInput()` method, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`QAudioRecorder`对象配置输入源，您需要将音频输入的名称传递给`setAudioInput()`方法，如下所示：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The actual name of the input may be different on your system. Unfortunately,
    `QAudioRecorder` will not throw an exception or register an error when you set
    an invalid audio input—it will simply fail to record any audio. So, if you decide
    to customize this attribute, take pains to ensure that the value is valid first.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 输入的实际名称可能在您的系统上有所不同。不幸的是，当您设置无效的音频输入时，`QAudioRecorder`不会抛出异常或注册错误，它只是简单地无法录制任何音频。因此，如果决定自定义此属性，请务必确保该值首先是有效的。
- en: 'To change the output file that is recorded, we need to call `setOutputLocation()`,
    as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改记录的输出文件，我们需要调用`setOutputLocation()`，如下所示：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that `setOutputLocation()` requires a `QUrl` object and not a file path.
    Once set, Qt will try to use this location for recording audio. However, as mentioned
    previously, it will revert to a platform-specific default if this location is
    not available.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`setOutputLocation()`需要一个`QUrl`对象，而不是文件路径。一旦设置，Qt将尝试使用此位置来录制音频。但是，如前所述，如果此位置不可用，它将恢复到特定于平台的默认值。
- en: 'The container format is the type of file that holds the audio data. For example,
    `audio/x-wav` is the container used for WAV files. We can set this value in the
    record object using the `setContainerFormat()` method, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 容器格式是保存音频数据的文件类型。例如，`audio/x-wav`是用于WAV文件的容器。我们可以使用`setContainerFormat()`方法在记录对象中设置此值，如下所示：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The value of this property should be a string returned by `QAudioRecorder.supportedContainers()`.
    Using an invalid value will result in an error when you try to record.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性的值应为`QAudioRecorder.supportedContainers()`返回的字符串。使用无效值将在您尝试录制时导致错误。
- en: 'Setting the codec, sample rate, and quality requires a new object called a
    `QAudioEncoderSettings` object. The following example demonstrates how to create
    and configure a `settings` object:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 设置编解码器、采样率和质量需要一个称为`QAudioEncoderSettings`对象的新对象。以下示例演示了如何创建和配置`settings`对象：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case, we've configured our audio to high-quality encoding at `44100`
    Hz using the PCM codec.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们已经将我们的音频配置为使用PCM编解码器以`44100` Hz进行高质量编码。
- en: Understand that not all codecs are compatible with all container types. If you
    pick two incompatible types, Qt will print errors to the console and the recording
    will fail, but it will not otherwise crash or throw an exception. It's up to you
    to do the proper research and testing to make sure that you are picking compatible
    settings.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有编解码器都与所有容器类型兼容。如果选择了两种不兼容的类型，Qt将在控制台上打印错误并且录制将失败，但不会崩溃或抛出异常。您需要进行适当的研究和测试，以确保您选择了兼容的设置。
- en: Depending on the codec chosen, there may be other settings you can set on your
    `QAudioEncoderSettings` object. You can consult the Qt documentation at [https://doc.qt.io/qt-5/qaudioencodersettings.html](https://doc.qt.io/qt-5/qaudioencodersettings.html)
    for more information.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 根据所选择的编解码器，您可以在`QAudioEncoderSettings`对象上设置其他设置。您可以在[https://doc.qt.io/qt-5/qaudioencodersettings.html](https://doc.qt.io/qt-5/qaudioencodersettings.html)的Qt文档中查阅更多信息。
- en: Configuring audio settings can be very tricky, especially as support varies
    widely from system to system. It's best to let Qt use its default settings when
    you can, or let the user configure these settings using values obtained from the support
    detection methods of `QAudioRecorder`. Whatever you do, don't hardcode settings
    or options if you cannot guarantee that the systems running your software will
    support them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 配置音频设置可能非常棘手，特别是因为支持在各个系统之间差异很大。最好在可以的时候让Qt使用其默认设置，或者让用户使用从`QAudioRecorder`的支持检测方法获得的值来配置这些设置。无论您做什么，如果您不能保证运行您的软件的系统将支持它们，请不要硬编码设置或选项。
- en: Recording and playing video
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 录制和播放视频
- en: Once you understand how to work with audio in Qt, working with video is only
    a small step up in terms of complexity. Just as with audio, we'll use a player
    object to load and playback content, and a recorder object to record it. However,
    with video, we'll need to add in a few extra components to handle the visualization
    of the content and to initialize the source device.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您了解了如何在Qt中处理音频，处理视频只是在复杂性方面迈出了一小步。就像处理音频一样，我们将使用一个播放器对象来加载和播放内容，以及一个记录器对象来记录它。但是，对于视频，我们需要添加一些额外的组件来处理内容的可视化并初始化源设备。
- en: In order to understand how it works, we're going to build a video-logging application.
    Copy the application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow,* to a new file called `captains_log.py`
    and we'll start coding.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解它是如何工作的，我们将构建一个视频日志应用程序。将应用程序模板从[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)
    *使用QMainWindow构建应用程序*复制到一个名为`captains_log.py`的新文件中，然后我们将开始编码。
- en: Building the basic GUI
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基本GUI
- en: The **Captain's Log** application will allow us to record videos from a webcam
    to a timestamped file in a preset directory and play them back. Our interface
    will feature a list of past logs on the right and a preview/playback area on the
    left. We'll have a tabbed interface so that the user can swap between playback
    and recording mode.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**船长的日志**应用程序将允许我们从网络摄像头录制视频到一个预设目录中的时间戳文件，并进行回放。我们的界面将在右侧显示过去日志的列表，在左侧显示预览/回放区域。我们将有一个分页式界面，以便用户可以在回放和录制模式之间切换。'
- en: 'Inside `MainWindow.__init__()`, start laying out the basic GUI as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainWindow.__init__()`中，按照以下方式开始布局基本GUI：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we''ll add a toolbar to hold the transport controls:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个工具栏来容纳传输控件：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We want our application to only display log videos, so we need to isolate our
    recordings to a unique directory rather than using the record''s default location.
    Using `QtCore.QDir`, we''ll create and store a custom location in a cross-platform
    way, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的应用程序只显示日志视频，因此我们需要将我们的记录隔离到一个独特的目录，而不是使用记录的默认位置。使用`QtCore.QDir`，我们将以跨平台的方式创建和存储一个自定义位置，如下所示：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This creates the `captains_log` directory under your home directory (if it doesn't
    exist) and sets the `self.video_dir` object to point to that directory.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的主目录下创建`captains_log`目录（如果不存在），并将`self.video_dir`对象设置为指向该目录。
- en: 'We now need a method to scan this directory for videos and populate the list
    widget:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要一种方法来扫描这个目录以查找视频并填充列表小部件：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`QDir.entryList()` returns a list of the contents of our `video_dir`. This
    first argument is a list of filters for common video file types so that non-video
    files won''t be listed in our log list (feel free to add whatever formats your
    OS prefers), and the second is a set of flags that will limit the entries returned
    to readable files. Once retrieved, these files are sorted and added to the list
    widget.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDir.entryList()`返回我们的`video_dir`内容的列表。第一个参数是常见视频文件类型的过滤器列表，以便非视频文件不会在我们的日志列表中列出（可以随意添加您的操作系统喜欢的任何格式），第二个是一组标志，将限制返回的条目为可读文件。检索到这些文件后，它们将被排序并添加到列表小部件中。'
- en: 'Back in `__init__()`, let''s call this function to refresh the list:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`__init__()`，让我们调用这个函数来刷新列表：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You may want to drop a video file or two in that directory to make sure they're
    being read and added to the list widget.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望在该目录中放入一个或两个视频文件，以确保它们被读取并添加到列表小部件中。
- en: Video playback
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频播放
- en: Our old friend `QMediaPlayer` can handle video playback as well as audio. However,
    just as a Blu-ray player needs to be connected to a TV or monitor to display what
    it's playing, `QMediaPlayer` needs to be connected to a widget that will actually
    display the video. The widget we need is the `QVideoWidget` class, which is found
    in the `QtMultimediaWidgets` module.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的老朋友`QMediaPlayer`可以处理视频播放以及音频。但是，就像蓝光播放器需要连接到电视或监视器来显示它正在播放的内容一样，`QMediaPlayer`需要连接到一个实际显示视频的小部件。我们需要的小部件是`QVideoWidget`类，它位于`QtMultimediaWidgets`模块中。
- en: 'To use it, we''ll need to import `QMultimediaWidgets`, as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们需要导入`QMultimediaWidgets`，如下所示：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To connect our `QMediaPlayer()` method to a `QVideoWidget()` method, we set
    the player''s `videoOutput` property, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的`QMediaPlayer()`方法连接到`QVideoWidget()`方法，我们设置播放器的`videoOutput`属性，如下所示：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is easier than hooking up your Blu-ray player, right?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这比连接蓝光播放器要容易，对吧？
- en: 'Now we can add the video widget to our GUI and connect the transport to our
    player:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将视频小部件添加到我们的GUI，并将传输连接到我们的播放器：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As a final touch, we've added a connection to switch back to the Play tab whenever
    the Play button is clicked on.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了一个连接，以便在单击播放按钮时切换回播放选项卡。
- en: The last thing we need to do to enable playback is to connect the selecting
    of a file in the file list to the loading and playing of the video in the media
    player.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 启用播放的最后一件事是将文件列表中的文件选择连接到加载和播放媒体播放器中的视频。
- en: 'We''ll do that in a callback called `on_file_selected()`, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个名为`on_file_selected()`的回调中执行此操作，如下所示：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The callback receives `QListWidgetItem` from `file_list` and extracts the `text`
    parameter, which should be the name of the file. We pass this to the `filePath()`
    method of our `QDir` object to get a full path to the file and build a `QUrl`
    object from this (remember that `QMediaPlayer` works with URLs, not file paths).
    Finally, we wrap the content in a `QMediaContent` object, load it into the player,
    and hit `play()`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数从`file_list`接收`QListWidgetItem`并提取`text`参数，这应该是文件的名称。我们将其传递给我们的`QDir`对象的`filePath()`方法，以获得文件的完整路径，并从中构建一个`QUrl`对象（请记住，`QMediaPlayer`使用URL而不是文件路径）。最后，我们将内容包装在`QMediaContent`对象中，将其加载到播放器中，并点击`play()`。
- en: 'Back in `__init__()`, let''s connect this callback to our list widget:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`__init__()`，让我们将此回调连接到我们的列表小部件：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we're connecting `itemDoubleClicked`, which passes the item that's been
    clicked on to the slot just as our callback expects. Note that we're also connecting
    the action to a `lambda` function to switch to the video widget. This is so that
    if the user double-clicks on a file while on the Record tab, they will be able
    to watch it without manually switching back to the Play tab.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们连接了`itemDoubleClicked`，它将被点击的项目传递给槽，就像我们的回调所期望的那样。请注意，我们还将该操作连接到一个`lambda`函数，以切换到视频小部件。这样，如果用户在录制选项卡上双击文件，他们将能够在不手动切换回播放选项卡的情况下观看它。
- en: At this point, your player is capable of playing videos. Drop a few video files
    in your `captains_log` directory if you haven't already and see if they play.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的播放器已经可以播放视频。如果您还没有在`captains_log`目录中放入一些视频文件，请放入一些并查看它们是否可以播放。
- en: Video recording
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频录制
- en: To record videos, we first need a source. In Qt, this source must be a subclass
    of `QMediaObject`, which can include an audio source, a media player, a radio,
    or—as we'll be using in this program—a camera.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要录制视频，我们首先需要一个来源。在Qt中，此来源必须是`QMediaObject`的子类，其中可以包括音频来源、媒体播放器、收音机，或者在本程序中将使用的相机。
- en: Qt 5.12 currently does not support video recording on Windows, only macOS, and
    Linux. For more information about the current state of multimedia support on Windows,
    please see [https://doc.qt.io/qt-5/qtmultimedia-windows.html](https://doc.qt.io/qt-5/qtmultimedia-windows.html).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Qt 5.12目前不支持Windows上的视频录制，只支持macOS和Linux。有关Windows上多媒体支持当前状态的更多信息，请参阅[https://doc.qt.io/qt-5/qtmultimedia-windows.html](https://doc.qt.io/qt-5/qtmultimedia-windows.html)。
- en: Cameras themselves are represented as `QCamera` objects in Qt. To create a working
    `QCamera` object, though, we need to first get a `QCameraInfo` object.  The `QCameraInfo` object
    contains information about a physical camera attached to the computer. A list
    of these objects can be obtained from the `QtMultimedia.QCameraInfo.availableCameras()`
    method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt中，相机本身表示为`QCamera`对象。要创建一个可工作的`QCamera`对象，我们首先需要获取一个`QCameraInfo`对象。`QCameraInfo`对象包含有关连接到计算机的物理相机的信息。可以从`QtMultimedia.QCameraInfo.availableCameras()`方法获取这些对象的列表。
- en: 'Let''s put this together into a method that will find a camera on your system
    and return a `QCamera` object for it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些放在一起，形成一个方法，该方法将在您的系统上查找相机并返回一个`QCamera`对象：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`availableCameras()` should return a list of `QCameraInfo` objects if you have
    one or more cameras attached to your system. If it does not, then we''ll display
    an error and return nothing; if it does, then we pass the info object to the `QCamera`
    constructor and return an object representing the camera.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统连接了一个或多个相机，`availableCameras()`应该返回一个`QCameraInfo`对象的列表。如果没有，那么我们将显示一个错误并返回空；如果有，那么我们将信息对象传递给`QCamera`构造函数，并返回表示相机的对象。
- en: 'Back in `__init__()`, we''ll use the following function to acquire a camera
    object:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`__init__()`，我们将使用以下函数来获取相机对象：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If there is no camera, then none of the remaining code in this method will work,
    so we'll just show the window and return.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有相机，那么此方法中剩余的代码将无法工作，因此我们将只显示窗口并返回。
- en: Before we use our camera, we need to tell it what we want it to capture. Cameras
    can capture still images or video content, which are configured by the camera's
    `captureMode` property.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用相机之前，我们需要告诉它我们希望它捕捉什么。相机可以捕捉静态图像或视频内容，这由相机的`captureMode`属性配置。
- en: 'Here, we set it to video using the `QCamera.CaptureVideo` constant:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将其设置为视频，使用`QCamera.CaptureVideo`常量：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Before we hit record, we'd like to be able to preview what the camera is capturing
    (after all, the captain needs to make sure their hair looks good for posterity).
    `QtMultimediaWidgets` has a special widget just for this purpose called `QCameraViewfinder`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始录制之前，我们希望能够预览相机捕捉的内容（毕竟，船长需要确保他们的头发看起来很好以供后人纪念）。`QtMultimediaWidgets`有一个专门用于此目的的特殊小部件，称为`QCameraViewfinder`。
- en: 'We''ll add one and connect our camera to it as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个并将我们的相机连接到它，如下所示：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The camera is now created and configured, so we need to activate it by calling
    the `start()` method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 相机现在已经创建并配置好了，所以我们需要通过调用`start()`方法来激活它：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If you run the program at this point, you should see a real-time display of
    what your camera is capturing on the Record tab.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您此时运行程序，您应该在录制选项卡上看到相机捕捉的实时显示。
- en: The final piece of this puzzle is the recorder object. In the case of video,
    we use the `QMediaRecorder` class to create a video recording object. This class
    is actually the parent of the `QAudioRecorder` class we used in our soundboard
    and works much the same way.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题的最后一块是录制器对象。在视频的情况下，我们使用`QMediaRecorder`类来创建一个视频录制对象。这个类实际上是我们在声音板中使用的`QAudioRecorder`类的父类，并且工作方式基本相同。
- en: 'Let''s create our recorder object, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的录制器对象，如下所示：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that we pass in our camera object to the constructor. You must pass `QMediaObject`
    (of which `QCamera` is a subclass) whenever you are creating a `QMediaRecorder` property.
    This property cannot be set later, nor can the constructor be called without it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将摄像头对象传递给构造函数。每当创建`QMediaRecorder`属性时，必须传递`QMediaObject`（其中`QCamera`是子类）。此属性不能以后设置，也不能在没有它的情况下调用构造函数。
- en: 'Just as with our audio recorder, we can configure various settings about the
    video we capture. This is done by creating a `QVideoEncoderSettings` class and
    passing it to the recorder''s `videoSettings` property:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的音频录制器一样，我们可以配置有关我们捕获的视频的各种设置。这是通过创建一个`QVideoEncoderSettings`类并将其传递给录制器的`videoSettings`属性来完成的：
- en: '[PRE51]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'It''s important to understand that if you set a configuration that your camera
    doesn''t support, then the recording will likely fail and you may see errors in
    the console:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，如果你设置了你的摄像头不支持的配置，那么录制很可能会失败，你可能会在控制台看到错误：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To make sure that this doesn''t happen, we can query our recorder object to
    see which settings are supported just as we did with the audio settings. The following
    script will print supported codecs, frame rates, resolutions, and containers to
    the console for each detected camera on your system:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这不会发生，我们可以查询我们的录制对象，看看支持哪些设置，就像我们对音频设置所做的那样。以下脚本将打印每个检测到的摄像头在您的系统上支持的编解码器、帧速率、分辨率和容器到控制台：
- en: '[PRE53]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Bear in mind that, on some systems, the results returned may be empty. When
    in doubt, it may be best to either experiment or accept whatever the default settings
    provide.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在某些系统上，返回的结果可能为空。如果有疑问，最好要么进行实验，要么接受默认设置提供的任何内容。
- en: 'Now that our recorder is ready, we need to connect the transport and enable
    it to record. Let''s start by writing a callback method for recording:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的录制器已经准备好了，我们需要连接传输并启用它进行录制。让我们首先编写一个用于录制的回调方法：
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This callback has two jobs—to create and set the filename to record to, and
    to start the recording. We're using our `QDir` object again in conjunction with
    a `QDateTime` class to generate a filename containing the date and time when the
    record was pressed. Note that we don't add a file extension to the filename. This
    is because `QMediaRecorder` will do this automatically based on the type of file
    it has been configured to create.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个回调有两个作用——创建并设置要记录的文件名，并开始录制。我们再次使用我们的`QDir`对象，结合`QDateTime`类来生成包含按下记录时的日期和时间的文件名。请注意，我们不向文件名添加文件扩展名。这是因为`QMediaRecorder`将根据其配置为创建的文件类型自动执行此操作。
- en: The recording is started by simply calling `record()` on the `QMediaRecorder`
    object. It will record video in the background until the `stop()` slot is called.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单调用`QMediaRecorder`对象上的`record()`来启动录制。它将在后台记录视频，直到调用`stop()`插槽。
- en: 'Back in `__init__()`, let''s finish things up by wiring in the transport controls
    as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`__init__()`，让我们通过以下方式完成连接传输控件：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We're connecting the record action to our callback and to a lambda function,
    which switches to the recording tab. We're then connecting the pause and stop
    actions directly to the recorder's `pause()` and `stop()` slots. Finally, when
    the video stops recording, we will want to refresh the file list to display the
    new file, so we connect `stop_act` to the `refresh_video_list()` callback.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将记录操作连接到我们的回调和一个lambda函数，该函数切换到录制选项卡。然后，我们直接将暂停和停止操作连接到录制器的`pause()`和`stop()`插槽。最后，当视频停止录制时，我们将希望刷新文件列表以显示新文件，因此我们将`stop_act`连接到`refresh_video_list()`回调。
- en: And that's all we need; dust your webcam's lens, fire up this script, and start
    keeping track of your stardates!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的一切；擦拭一下你的网络摄像头镜头，启动这个脚本，开始跟踪你的星际日期！
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the capabilities of the `QtMultimedia` and `QMultimediaWidgets`
    modules. You learned how to play back low-latency sound effects with `QSoundEffect`,
    and how to play and record a variety of media formats using `QMediaPlayer` and
    `QAudioRecorder`. Finally, we created a video recording and playback application
    using `QCamera`, `QMediaPlayer`, and `QMediaRecorder`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了`QtMultimedia`和`QMultimediaWidgets`模块的功能。您学会了如何使用`QSoundEffect`播放低延迟音效，以及如何使用`QMediaPlayer`和`QAudioRecorder`播放和记录各种媒体格式。最后，我们使用`QCamera`、`QMediaPlayer`和`QMediaRecorder`创建了一个视频录制和播放应用程序。
- en: In the next chapter, we'll connect to the wider world by exploring Qt's networking
    features. We'll work with low-level networking with sockets and higher-level networking
    with the `QNetworkAccessManager`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过探索Qt的网络功能来连接到更广泛的世界。我们将使用套接字进行低级网络和使用`QNetworkAccessManager`进行高级网络。
- en: Questions
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些问题来测试你从本章学到的知识：
- en: Using `QSoundEffect`, you've written a utility for a call center that allows
    them to review recorded phone calls. They're moving to a new phone system that
    stores the audio calls as MP3 files. Do you need to make any changes to your utility?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`QSoundEffect`，你为呼叫中心编写了一个实用程序，允许他们回顾录制的电话呼叫。他们正在转移到一个将音频呼叫存储为MP3文件的新电话系统。你需要对你的实用程序进行任何更改吗？
- en: '`cool_songs` is a Python list containing path strings to your favorite songs.
    What do you need to do to play these songs back in a random order?'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cool_songs`是一个包含你最喜欢的歌曲路径字符串的Python列表。要以随机顺序播放这些歌曲，你需要做什么？'
- en: 'You have installed the `audio/mpeg` codec on your system, but the following
    code isn''t working. Find out what''s wrong with it:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已经在你的系统上安装了`audio/mpeg`编解码器，但以下代码不起作用。找出问题所在：
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Run `audio_test.py` and `video_test.py` on several different Windows, macOS,
    and Linux systems. How is the output different? Are there any items supported
    across all systems?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在几个不同的Windows、macOS和Linux系统上运行`audio_test.py`和`video_test.py`。输出有什么不同？有哪些项目在所有系统上都受支持？
- en: The properties of the `QCamera` class include several control objects, which
    allow you to manage different aspects of the camera. One of these is `QCameraFocus`.
    Investigate `QCameraFocus` in the Qt documentation at [https://doc.qt.io/qt-5/qcamerafocus.html](https://doc.qt.io/qt-5/qcamerafocus.html)
    and write a simple script that shows a viewfinder and lets you adjust the digital
    zoom.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QCamera`类的属性包括几个控制对象，允许您管理相机的不同方面。其中之一是`QCameraFocus`。在Qt文档中调查`QCameraFocus`，网址为[https://doc.qt.io/qt-5/qcamerafocus.html](https://doc.qt.io/qt-5/qcamerafocus.html)，并编写一个简单的脚本，显示取景器并让您调整数字变焦。'
- en: You've noticed the audio being recorded to your **Captain's Log** video log
    is quite loud. You want to add a control to adjust it; how would you do this?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您注意到录制到您的**船长日志**视频日志中的音频相当响亮。您想添加一个控件来调整它；您会如何做？
- en: Implement a dock widget in `captains_log.py` that allows you to control as many
    aspects of the audio and video recording as you can. You can include things such
    as focus, zoom, exposure, white balance, frame rate, resolution, audio volume,
    audio quality, and more.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`captains_log.py`中实现一个停靠窗口小部件，允许您控制尽可能多的音频和视频录制方面。您可以包括焦点、变焦、曝光、白平衡、帧速率、分辨率、音频音量、音频质量等内容。
- en: Further reading
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can check the following references for further information:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查阅以下参考资料以获取更多信息：
- en: You can get an overview of the Qt Multimedia system and its capabilities at [https://doc.qt.io/qt-5/multimediaoverview.html](https://doc.qt.io/qt-5/multimediaoverview.html).
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在[https://doc.qt.io/qt-5/multimediaoverview.html](https://doc.qt.io/qt-5/multimediaoverview.html)上了解Qt多媒体系统及其功能。
- en: The official PyQt `QtMultimedia` and `QtMultimediaWidgets` examples can be found
    at [https://github.com/pyqt/examples/tree/master/multimedia](https://github.com/pyqt/examples/tree/master/multimedia)
    and [https://github.com/pyqt/examples/tree/master/multimediawidgets](https://github.com/pyqt/examples/tree/master/multimediawidgets).
    They provide more example code of using PyQt for media capture and playback.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyQt的官方`QtMultimedia`和`QtMultimediaWidgets`示例可以在[https://github.com/pyqt/examples/tree/master/multimedia](https://github.com/pyqt/examples/tree/master/multimedia)和[https://github.com/pyqt/examples/tree/master/multimediawidgets](https://github.com/pyqt/examples/tree/master/multimediawidgets)找到。它们提供了更多使用PyQt进行媒体捕获和播放的示例代码。
