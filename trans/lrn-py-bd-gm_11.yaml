- en: Outdo Turtle - Snake Game UI with Pygame
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pygame超越Turtle - 使用Pygame制作贪吃蛇游戏UI
- en: Python game development, in one way or another, is related to the `pygame` module.
    We have learned about a variety of topics and techniques regarding Python so far
    because we have to know about them before we progress to the `pygame` module.
    And all of these concepts will be used as apportioned techniques while build a
    game using Pygame. We can now start to use object-oriented principles, vectored
    movements for event handling, rotation techniques to rotate the images or sprites used
    in th     e game, and even use things that we learned about in the turtle module.
    In the turtle module, we learned how to create objects (refer to [Chapter 6](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml), *Object-Oriented
    Programming*), which can be used to debug different features at the rudimentary
    stages of the game that we may build using Pygame. Thus, whatever we have learned
    so far will be used, along with the additional features of the Pygame module,
    which can help us make more appealing games.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python游戏开发在某种程度上与`pygame`模块相关。到目前为止，我们已经学习了关于Python的各种主题和技术，因为在我们进入`pygame`模块之前，我们必须了解它们。所有这些概念将被用作构建Pygame游戏时的技术。我们现在可以开始使用面向对象的原则，矢量化移动进行事件处理，旋转技术来旋转游戏中使用的图像或精灵，甚至使用我们在turtle模块中学到的东西。在turtle模块中，我们学习了如何创建对象（参见[第6章](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml)，*面向对象编程*），这些对象可以用于在我们可能使用Pygame构建的游戏的基本阶段调试不同的功能。因此，我们迄今为止学到的东西将与Pygame模块的其他功能一起使用，这些功能可以帮助我们制作更吸引人的游戏。
- en: 'In this chapter, we are going to cover multiple things, starting with learning
    the basics of Pygame—the installation, building blocks, and different features.
    After that, we are going to learn about different objects of Pygame. They are
    the modules that can be used for several functionalities, such as drawing shapes
    into the screen, handling mouse and keyboard events, loading images into the Pygame
    projects, and many more. At the end of this chapter, we will try to make our snake
    game visually attractive by adding multiple features, such as a custom-made snake
    image, apples as food, and a menu screen for the game. Finally, we will convert
    our snake game into executable files so that you can distribute your game with
    your friends and family and get responses from them. The following topics will
    be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖多个内容，从学习Pygame的基础知识——安装、构建模块和不同功能开始。之后，我们将学习Pygame的不同对象。它们是可以用于多种功能的模块，例如将形状绘制到屏幕上，处理鼠标和键盘事件，将图像加载到Pygame项目中等等。在本章的最后，我们将尝试通过添加多个功能使我们的贪吃蛇游戏在视觉上更具吸引力，例如自定义的贪吃蛇图像、苹果作为食物以及游戏的菜单屏幕。最后，我们将把我们的贪吃蛇游戏转换为可执行文件，以便您可以将游戏与朋友和家人分享，并从他们那里获得反馈。本章将涵盖以下主题：
- en: Pygame basics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pygame基础知识
- en: Pygame objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pygame对象
- en: Initializing display and handling events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化显示和处理事件
- en: Object rendering—making the snake game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象渲染——制作贪吃蛇游戏
- en: Menu for the game
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏菜单
- en: Converting into an executable
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换为可执行文件
- en: Game testing and possible modifications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏测试和可能的修改
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following requirements to complete this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下要求才能完成本章：
- en: Python—3.5 or higher
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python—3.5或更高版本
- en: PyCharm IDE—refer to [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml), *Getting
    to Know Python – Setting Up Python and the Editor*, for the download procedure
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm IDE——参考[第1章](0ef9574b-5690-454e-971f-85748021018d.xhtml)，*了解Python-设置Python和编辑器*，了解下载过程
- en: The files for this chapter can be found at [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter11](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter11).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的文件可以在[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter11](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter11)找到。
- en: 'Check out the following video to see the code in action:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，以查看代码的运行情况：
- en: '[http://bit.ly/2o2GngQ](http://bit.ly/2o2GngQ)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2o2GngQ](http://bit.ly/2o2GngQ)'
- en: Understanding pygame
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解pygame
- en: Writing games with the `pygame` module requires pygame to be installed on your
    machine. You can download it manually from the official Pygame library by visiting
    the website ([www.pygame.org](http://www.pygame.org).), or install it by using
    the Terminal with the  `pip install pygame` command.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pygame`模块编写游戏需要在您的计算机上安装pygame。您可以通过访问官方Pygame库的网站（[www.pygame.org](http://www.pygame.org)）手动下载，或者使用终端并使用`pip
    install pygame`命令进行安装。
- en: The pygame module is free to download from the aforementioned website, so we
    can download it by following a similar process to what we do for any other Python
    module. However, we can remove the headache of downloading pygame manually by
    using a visually more attractive and effective alternative IDE, **PyCharm**, which
    we  downloaded back in [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml),
    *Getting to Know Python – Setting Up Python and the Editor*. We are became familiar
    with the techniques that are used to download and install third-party packages
    within PyCharm in that chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame模块可以免费从上述网站下载，因此我们可以按照与下载其他Python模块相似的过程进行下载。但是，我们可以通过使用视觉上更具吸引力和有效的替代IDE
    **PyCharm** 来消除手动下载pygame的麻烦，我们在[第1章](0ef9574b-5690-454e-971f-85748021018d.xhtml)，*了解Python-设置Python和编辑器*中下载了PyCharm。在该章节中，我们熟悉了在PyCharm中下载和安装第三方包的技术。
- en: 'Once you have downloaded the pygame package into PyCharm, give it some time
    to load. Now, we can test it by writing the following code. The following two
    lines of code check if the `pygame` module is downloaded or not, and if it is,
    it will print its version:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将pygame包下载到PyCharm中，请给它一些时间来加载。现在，我们可以通过编写以下代码来测试它。以下两行代码检查`pygame`模块是否已下载，如果已下载，它将打印其版本：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If pygame is successfully installed onto your machine, you will observe the
    following output. The version may vary, but at the time of writing this book,
    it is version 1.9.6 (the latest version of 2019). The contents of this book works
    for any version of `pygame` because of its backward compatibility. Make sure that
    you have a pygame version that is newer than 1.9+:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果pygame成功安装到您的计算机上，您将观察到以下输出。版本可能有所不同，但在撰写本书时，它是1.9.6版（2019年最新版本）。本书的内容适用于任何版本的`pygame`，因为它具有向后兼容性。请确保您的pygame版本新于1.9+：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Pygame is a utopia for many Python game developers; it contains a surfeit amount
    of modules, ranging from making an interface to handling user events. All of these
    modules that are defined within pygame can be used independently, according to
    our needs. Most importantly, you can also make games using pygame, which may or
    may not be platform-specific. Invoking the modules of pygame is similar to invoking
    the methods of the class. You can always access these classes using the pygame
    namespace, followed by the class that you want to use. For instance, `pygame.key`
    will read the key that is pressed on the keyboard. Thus, the `key` class is responsible
    for handling keyboard actions. Similarly, the `pygame.mouse` module is used to
    manage mouse events. These, and many other modules of pygame, can be called independently
    from one another, which makes our code more manageable and readable. You can search
    for the list of modules that are available in the pygame module from its official
    documentation page, but almost 80 percent of the games require only four to six
    modules. If you want to learn more about them, it''s always good to explore its
    official documentation page. Among them, we mostly use two classes in each and
    every game, that is, the display module, in order to access and manipulate the
    game display; and the mouse and key or joystick module, in order to handle input
    events for the game. I won''t say that the others are less important, but these
    modules are the building blocks of games. The following table has been extracted
    from the Python pygame official documentation; it gives us a succinct idea about
    the `pygame` modules and their usages:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame对许多Python游戏开发者来说是一个乌托邦；它包含大量的模块，从制作界面到处理用户事件。pygame中定义的所有这些模块都可以根据我们的需求独立使用。最重要的是，您也可以使用pygame制作游戏，这可能是平台特定的，也可能不是。调用pygame的模块类似于调用类的方法。您可以始终使用pygame命名空间访问这些类，然后使用您想要使用的类。例如，`pygame.key`将读取键盘上按下的键。因此，`key`类负责处理键盘操作。类似地，`pygame.mouse`模块用于管理鼠标事件。pygame的这些以及许多其他模块都可以相互独立地调用，这使得我们的代码更易于管理和阅读。您可以从pygame模块的官方文档页面搜索可用模块的列表，但几乎80%的游戏只需要四到六个模块。如果您想了解更多信息，最好是探索其官方文档页面。在其中，我们在每个游戏中主要使用两个类，即显示模块，以便访问和操作游戏显示；以及鼠标和键盘或操纵杆模块，以处理游戏的输入事件。我不会说其他模块不重要，但这些模块是游戏的基石。以下表格摘自Python
    pygame官方文档；它给了我们关于`pygame`模块及其用法的简洁概念：
- en: '| **Module name** | **Description** |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **模块名称** | **描述** |'
- en: '| `pygame.draw` | Draws shapes, lines, and points. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.draw` | 绘制形状、线条和点。 |'
- en: '| `pygame.event` | Deals with external events. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.event` | 处理外部事件。 |'
- en: '| `pygame.font` | Deals with system fonts. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.font` | 处理系统字体。 |'
- en: '| `pygame.image` | Loads the image into the project. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.image` | 将图像加载到项目中。 |'
- en: '| `pygame.joystick` | Deals with joystick movements/events. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.joystick` | 处理操纵杆移动/事件。 |'
- en: '| `pygame.key` | Reads key presses from the keyboard. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.key` | 从键盘读取按键。 |'
- en: '| `pygame.mixer` | Mixing, loading, and playing sound. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.mixer` | 混音、加载和播放声音。 |'
- en: '| `pygame.mouse` | Reads mouse events. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.mouse` | 读取鼠标事件。 |'
- en: '| `pygame.movie` | Plays/runs movie files. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.movie` | 播放/运行电影文件。 |'
- en: '| `pygame.music` | Plays streaming audio files. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.music` | 播放流式音频文件。 |'
- en: '| `pygame` | Bundled as high-level pygame functions/methods. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `pygame` | 捆绑为高级pygame函数/方法。 |'
- en: '| `pygame.rect` | Deals with rectangular areas and can create a box structure.
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `pygame.rect` | 处理矩形区域并可以创建一个框结构。 |'
- en: 'There are also a few more, such as surface, time, and transform. We will explore
    each of them in this and the upcoming chapters. All of the preceding modules are
    platform-independent, which means that they can be evoked, regardless of the operating
    system that is used by the machines. But there are some OS-specific errors, and
    errors due to hardware incompatibilities or improper device drivers. If any module
    is not compatible with any machine, the Python parser returns it as `None`, which
    means we can check beforehand to make sure that the game works properly. The following
    line of code will check whether any specified module (`pygame.module_name`) is
    present, and if not, it will return a custom message in the print statement, which
    in this case is, *No such module! Try other one*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外还有一些其他模块，比如surface、time和transform。我们将在本章和接下来的章节中探讨它们。所有前述的模块都是平台无关的，这意味着它们可以被调用，无论机器使用的操作系统是什么。但是会有一些特定于操作系统的错误，以及由于硬件不兼容或不正确的设备驱动程序而导致的错误。如果任何模块与任何机器不兼容，Python解析器将其返回为“None”，这意味着我们可以事先检查以确保游戏正常工作。以下代码将检查是否存在任何指定的模块（`pygame.module_name`），如果没有，它将在打印语句中返回一个自定义消息，本例中是“没有这样的模块！尝试其他”：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To completely grasp the concept of `pygame`, we have to make a habit of observing
    the code that is written by other pygame developers. In doing so, you will learn
    the pattern for building games with `pygame`. If, like me, you only check documentation
    if you are at an impasse, then we can make a simple program to help us understand
    the concept of `pygame` and the ways that we can call its different modules. We
    are going to write a simple code to illustrate this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全掌握`pygame`的概念，我们必须养成观察其他pygame开发者编写的代码的习惯。通过这样做，您将学习使用`pygame`构建游戏的模式。如果像我一样，只有在陷入僵局时才查看文档，那么我们可以编写一个简单的程序来帮助我们理解`pygame`的概念以及我们可以调用其不同模块的方式。我们将编写一个简单的代码来说明这一点：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Before discussing the preceding code, let''s run it and observe the output.
    You will get a geometrical shape—a green rectangular box that will be rendered
    inside the screen of a certain height and width. Now, it''s time to make a quick
    mental note of the building blocks of the `pygame` module. To make things simpler,
    I have listed them in the following points:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论上述代码之前，让我们运行它并观察输出。您将得到一个几何形状—一个绿色的矩形框，它将呈现在特定高度和宽度的屏幕内。现在，是时候快速地记下`pygame`模块的构建块了。为了简化事情，我已经在以下几点中列出了它们：
- en: '`import pygame`: The import statement that we have been with familiar from
    the beginning of this book. This time, we are importing the pygame framework into
    our Python file.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`import pygame`: 这是我们从本书开始就熟悉的导入语句。这次，我们将pygame框架导入到我们的Python文件中。'
- en: '`pygame.init()`: This method is going to initialize a bundle of modules/classes
    that are embedded inside pygame. This means that we can call pygame''s other modules
    with its namespace.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.init()`: 这个方法将初始化pygame内嵌的一系列模块/类。这意味着我们可以使用pygame的命名空间调用其他模块。'
- en: '`pygame.display.set_mode((width, height))`: The size passed as a tuple (width,
    height) is the desired screen size. This size represents our games console. The
    returned object will be a window screen, or surface, on which we will perform
    different graphical computations.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.display.set_mode((width, height))`: 作为元组(width, height)传递的大小是期望的屏幕大小。这个大小代表我们的游戏控制台。返回的对象将是一个窗口屏幕，或者表面，我们将在其中执行不同的图形计算。'
- en: '`pygame.event.get()`: This statement is going to handle the event queue. The
    queue, as we discussed in previous chapters, is going to store different events
    of the user. If this statement is not called explicitly, the game will be hindered
    by overwhelming Windows messages, and eventually it will become unresponsive.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.event.get()`: 这个语句将处理事件队列。正如我们在前几章中讨论的那样，队列将存储用户的不同事件。如果不显式调用此语句，游戏将受到压倒性的Windows消息的阻碍，最终将变得无响应。'
- en: '`pygame.draw.rect()`: We will be able to draw into the screen using the draw
    module. Different shapes can be drawn with this module. More on this will be covered
    in the next section—*Pygame objects*. Taking a screen object, color, and position
    as arguments, the `rect()` method draws a rectangle. The first argument represents
    the screen object, which is the returned object of the display class; the second
    is the color code that is passed as a tuple in the form of RGB (red, green, blue)
    code; and the third is the dimensions of a rectangle. In order to manipulate and
    store rectangular areas, pygame uses `Rect`objects. `Rect()` can be created by
    combining four different values—height, width, left, and top.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.draw.rect()`: 我们将能够使用绘图模块在屏幕上绘制。不同的形状可以使用此模块绘制。关于这一点，我们将在下一节—*Pygame对象*中进行更多讨论。`rect()`方法以屏幕对象、颜色和位置作为参数，绘制一个矩形。第一个参数代表屏幕对象，它是显示类的返回对象；第二个是颜色代码，以RGB(red,
    green, blue)代码的形式作为元组传递；第三个是矩形的尺寸。为了操纵和存储矩形区域，pygame使用`Rect`对象。`Rect()`可以通过组合四个不同的值—高度、宽度、左侧和顶部来创建。'
- en: '`pygame.QUIT`: This event is invoked whenever you explicitly close the pygame
    screen, which is done by pressing the `close(X)` button at the top-most right
    corner of the games console.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.QUIT`: 每当您明确关闭pygame屏幕时，就会调用此事件，这是通过按游戏控制台最右上角的`close(X)`按钮来完成的。'
- en: '`pygame.display.flip()`: This is same as the `update()` function, which makes
    any new updates on the screen visible. While making or blitting shapes or characters,
    this method must be invoked at the end of the game in order to ensure that all
    the objects are rendered properly. This will swap the pygame buffer, as pygame
    is a double-buffered framework.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.display.flip()`: 这与`update()`函数相同，可以使屏幕上的任何新更新可见。在制作或blitting形状或字符时，必须在游戏结束时调用此方法，以确保所有对象都被正确渲染。这将交换pygame缓冲区，因为pygame是一个双缓冲框架。'
- en: The aforementioned code renders the green rectangular shape when executed. As
    we mentioned previously, the `rect()` method is responsible for creating the rectangular
    area, and the color code (0, 128, 0) represents the green color.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在执行时呈现绿色矩形形状。正如我们之前提到的，`rect()`方法负责创建矩形区域，颜色代码(0, 128, 0)代表绿色。
- en: 'Don''t get overwhelmed with this jargon; you will learn about it in detail
    in the upcoming chapters. While you read this chapter, make sure that you make
    a habit of making a logical connection between the code: something like a blueprint
    that maps the game from one position to another, that is, the display screen,
    to rendering characters, to handling events.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被这些术语所压倒；您将在接下来的章节中详细了解它们。在阅读本章时，请确保养成一个习惯，即在代码之间建立逻辑连接：从一个位置映射游戏到另一个位置，也就是显示屏，渲染字符，处理事件。
- en: If you get into a situation where you are unable to close the pygame Terminal,
    it's surely because you haven't handled the event queue properly. In such cases,
    you can always stop Python from the Terminal by pressing *Ctrl* + *C*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到无法关闭pygame终端的情况，那肯定是因为您没有正确处理事件队列。在这种情况下，您可以通过按下*Ctrl* + *C*来停止终端中的Python。
- en: Before hopping over to the next section, I want to discuss the rather simple
    but abyss working of commands—pygame initialization—which is done by the `pygame.init()`
    statement. This is just a single line of command, but it carries out more tasks
    than we can imagine. As the name suggests, it is the initialization of pygame.
    Thus, it must initialize each of the sub-modules of the `pygame` package, that
    is, `display`, `rect`, `key`, and so on. Not only that, but it is also going to
    load all the essential drivers and queries of the hardware components in order
    to communicate.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳转到下一节之前，我想讨论一下命令的简单但深奥的工作—pygame初始化—这是通过`pygame.init()`语句完成的。这只是一条简单的命令，但它执行的任务比我们想象的要多。顾名思义，这是pygame的初始化。因此，它必须初始化`pygame`包的每个子模块，即`display`、`rect`、`key`等。不仅如此，它还将加载所有必要的驱动程序和硬件组件的查询，以便进行通信。
- en: If you want to load any submodules quicker, you can explicitly initialize the
    specific ones, and avoid all the unnecessary ones. For example, `pygame.music.init()` will
    only initialize the music sub-module from the bucket of submodules that is maintained
    by Pygame. For most of the games that we are going to cover in this book, the
    `pygame` module requires more than three submodules. Thus, we can use the universal
    `pygame.init()` method to perform initialization. After making the preceding call,
    we will be well-equipped to use all of the specified submodules of the `pygame`
    module.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更快地加载任何子模块，可以显式初始化特定的子模块，并避免所有不必要的子模块。例如，`pygame.music.init()`将只初始化pygame维护的子模块中的音乐子模块。对于本书中将要涵盖的大多数游戏，`pygame`模块需要超过三个子模块。因此，我们可以使用通用的`pygame.init()`方法来执行初始化。在进行了上述调用之后，我们将能够使用`pygame`模块的所有指定子模块。
- en: 'After the process of initialization, it''s good practice to start creating
    a display screen. The dimension of the display screen depends on the demand of
    the game. Sometimes, you may have to provide full-screen resolution to the games
    in order to make it fully interactive and appealing. The manipulation of the screen
    size can be done via the pygame surface object. The method call of `set_mode`
    on the display class returns the object, which represents the entire window screen.
    You can also set the caption to the display screen if you want; the caption will
    be added to the top navigation bar, which is along with the close button. The
    following code represents a way of adding captions or game names to the game screen:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化过程之后，开始创建显示屏是一个良好的实践。显示屏的尺寸取决于游戏的需求。有时，您可能需要为游戏提供全屏分辨率，以使其完全互动和吸引人。可以通过pygame表面对象来操作屏幕大小。在显示类上调用`set_mode`方法将返回表示整个窗口屏幕的对象。如果需要，还可以为显示屏设置标题；标题将添加到顶部导航栏中，与关闭按钮一起。以下代码表示了向游戏屏幕添加标题或游戏名称的方法：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, let's talk about the argument that is passed with the `set_mode` method.
    The first—and an most important–argument is the dimension of the screen's surface.
    The size should be passed as a tuple, that is, in terms of width and height, and
    it is mandatory. The others are optional (in the previous program, we didn't even
    bother using them); they are called flags. We need them because the information
    related to width and height sometimes won't be enough to make an appropriate display.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈传递给`set_mode`方法的参数。第一个——也是最重要的——参数是屏幕表面的尺寸。尺寸应该以元组的形式传递，即宽度和高度，这是强制性的。其他参数是可选的（在之前的程序中，我们甚至都没有使用它们）；它们被称为标志。我们需要它们是因为与宽度和高度相关的信息有时不足以进行适当的显示。
- en: 'We may want a **fullscreen** or **resizable** display, and in such cases, flags
    can be better suited for display creation. Speaking of flags, it is a feature
    that can be turned on and off, based on the situation, and sometimes working with
    it may be time-saving, relatively speaking. Let''s observe some of the flags in
    the following table, though we are not going to use them any time soon, but covering
    them here obviates the unnecessary introduction in the upcoming sections:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望有**全屏**或**可调整大小**的显示，在这种情况下，标志可能更适合于显示创建。说到标志，它是一个可以根据情况打开和关闭的功能，有时候使用它可能会节省时间，相对而言。让我们来看一下下表中的一些标志，尽管我们不会很快使用它们，但在这里介绍它们可以避免在即将到来的部分中不必要的介绍：
- en: '| **Flag** | **Purpose** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **标志** | **目的** |'
- en: '| `FULLSCREEN` | Creation of a display that covers the entire screen. Windowed
    screen recommended for debugging. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `FULLSCREEN` | 创建覆盖整个屏幕的显示。建议用于调试的窗口化屏幕。'
- en: '| `DOUBLEBUF` | Used in the creation of a *double-buffered* display. It is
    highly recommended for `HWSURFACE` or `OPENGL`, which simulates a 3D display.
    |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `DOUBLEBUF` | 用于创建*双缓冲*显示。强烈建议用于`HWSURFACE`或`OPENGL`，它模拟了3D显示。'
- en: '| `HWSURFACE` | Used in creating a hardware-accelerated display, that is, it
    uses video card memory instead of main memory (must be combined with the `FULLSCREEN`
    flag). |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `HWSURFACE` | 用于创建硬件加速的显示，即使用视频卡内存而不是主内存（必须与`FULLSCREEN`标志结合使用）。'
- en: '| `RESIZABLE` | Creates a resizable display. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `RESIZABLE` | 创建可调整大小的显示。'
- en: '| `NOFRAME` | Display without frame or border, along with no title bar. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `NOFRAME` | 无边框或边框的显示，也没有标题栏。'
- en: '| `OPENGL` | Creates an OpenGL renderable display. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `OPENGL` | 创建可渲染的OpenGL显示。'
- en: You can use the bitwise OR operator to combine multiple flags together, which
    facilitates a better experience in terms of the screen surface. In order to create
    a double-buffered OpenGL rendered display, you can set an optional flag parameter
    to `DOUBLEBUF|OPENGL;` here, (`|`) is the bitwise `OR` operator. Even if pygame
    is not able to render the perfect display that we asked for, which may be due
    to the lack of the appropriate graphics card, pygame will make a decision for
    us in terms of choosing a  display that is compatible with our hardware.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用按位或运算符将多个标志组合在一起，这有助于在屏幕表面方面获得更好的体验。为了创建一个双缓冲的OpenGL渲染显示，您可以将可选的标志参数设置为`DOUBLEBUF|OPENGL;`这里，(`|`)是按位`OR`运算符。即使pygame无法渲染我们要求的完美显示，这可能是由于缺乏适当的显卡，pygame将为我们在选择与我们的硬件兼容的显示方面做出决定。
- en: One of the most important aspects of game development is handling a user event,
    and it is normally done within the game loop. Inside the main game loop, we usually
    have another loop to handle user events—an event loop. An event is a course of
    messages that inform pygame of what to expect outside the periphery of the code.
    Events may vary from the user pressing the key events, to any information transferred
    through a third-party library, for example, the internet.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发中最重要的一个方面是处理用户事件，通常是在游戏循环内完成的。在主游戏循环内，通常有另一个循环来处理用户事件——事件循环。事件是一系列消息，通知pygame在代码外部可以期待什么。事件可能是用户按键事件，也可能是通过第三方库传输的任何信息，例如互联网。
- en: The events that are created as a chunk are stored in the queue, and remain there
    until we explicitly address them. While there are different functions in event
    modules from pygame that provide a way to capture the events, `get()` is the most
    reliable, and is also easy to use. After getting the gamut of actions, we can
    address them using the pygame event handler—using functions such as `pump` or
    `get`. Remember that if you are only addressing specific actions, the event queue
    may infuse with other superficial events that you might not be interested in.
    Thus, the handling of events must be done explicitly using event attributes, similar
    to what we did in the preceding example using the `QUIT` event attribute. You
    may also get full access to the event object's attributes through the `eventType.__dict__`
    attribute. We will learn about them thoroughly in the upcoming *Event handling*
    section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一组创建的事件被存储在队列中，并保留在那里，直到我们明确地处理它们。虽然在pygame的事件模块中有不同的函数提供了捕获事件的方法，`get()`是最可靠的，也很容易使用。在获取了各种操作后，我们可以使用pygame事件处理程序来处理它们，使用`pump`或`get`等函数。请记住，如果您只处理特定的操作，事件队列可能会混入其他您不感兴趣的表面事件。因此，必须明确地使用事件属性来处理事件，类似于我们在前面的示例中使用`QUIT`事件属性所做的。您还可以通过`eventType.__dict__`属性完全访问事件对象的属性。我们将在即将到来的*事件处理*部分中彻底学习它们。
- en: Before learning how to upgrade our own previously made *snake* game using pygame,
    we have to learn about a few important concepts of pygame—*Pygame objects*, *Drawing
    into the screen*, and *Handling User Events*. We will learn about these concepts
    in detail, one by one. We will start with *Pygame objects*, where we will learn
    about surface objects, creating surfaces, and rectangular objects. We will also
    learn how to draw shapes using pygame.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何使用pygame升级我们之前制作的*snake*游戏之前，我们必须学习pygame的一些重要概念——*Pygame对象*、*绘制到屏幕*和*处理用户事件*。我们将逐一详细学习这些概念。我们将从*Pygame对象*开始，学习表面对象、创建表面和矩形对象。我们还将学习如何使用pygame绘制形状。
- en: Pygame objects
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pygame对象
- en: The `pygame` module, which is made by internally using classes, makes code readable
    and reusable by allowing us to create objects and use their properties. As we
    mentioned earlier, there are several classes that are defined in the `pygame`
    module that can be called independently to perform independent tasks. For instance,
    the `draw` class can be used to draw different shapes such as rectangles, polygons,
    circles, and many more; the `event` class can call functions such as get or pump
    in order to handle user events. These invocations can be done using objects, by
    creating them first for each action. In this section, you are going to explore
    the concepts that will help you learn about accessing surface objects, rectangular
    objects, and drawing to the screen.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由内部使用类制作的`pygame`模块通过允许我们创建对象并使用它们的属性，使代码可读性和可重用性。正如我们之前提到的，`pygame`模块中定义了几个类，可以独立调用以执行独立的任务。例如，`draw`类可用于绘制不同的形状，如矩形、多边形、圆形等；`event`类可以调用`get`或`pump`等函数来处理用户事件。可以通过创建对象来进行这些调用，首先为每个操作创建对象。在本节中，您将探索这些概念，这将帮助您学习如何访问表面对象、矩形对象和绘制到屏幕。
- en: 'The most basic way to create a blank surface of customized dimensions is by
    calling a `Surface` constructor from the pygame namespace. While creating objects
    of the `Surface` class, tuples containing width and height information must be
    passed. The following line of code creates a blank surface of 200 by 200 pixels:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义尺寸的空白表面最基本的方法是从pygame命名空间调用`Surface`构造函数。在创建`Surface`类的对象时，必须传递包含宽度和高度信息的元组。以下代码行创建了一个200x200像素的空白表面：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can specify a few more optional parameters that can ultimately affect the
    screen visuals. You can set the flag parameter to one or more of the following
    parameters:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定一些可选参数，最终会影响屏幕的视觉效果。您可以将标志参数设置为以下一个或多个参数之一：
- en: '`HWSURFACE`: Creates a hardware surface. This is not very important in the
    context of games because it is done internally by pygame.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HWSURFACE`：创建硬件表面。在游戏的上下文中这并不是很重要，因为它是由pygame内部完成的。'
- en: '`SRCALPHA`: It uses *alpha information* for the conversion of the background,
    which refers to a process that makes the background of the screen transparent.
    It creates a surface with alpha conversion. The alpha information will make a
    part of your surface transparent. If you are using this as an optional flag, you
    have to specify one more mandatory parameters, including depth, and assign its
    value to 32, which is standard for alpha information.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SRCALPHA`：它使用*alpha信息*来转换背景，这是指使屏幕背景透明的过程。它创建一个带有alpha转换的表面。alpha信息将使表面的一部分变为透明。如果您将其用作可选标志，您必须指定一个以上的强制参数，包括深度，并将其值分配为32，这是alpha信息的标准值。'
- en: 'Furthermore, if you want to create a surface that contains an image as a background,
    you can call up the `image` class from the `pygame` module. The image class contains
    the `load` method, which can be called with the argument of the background image
    filename that needs to be rendered. The filename that is passed should be the
    full name, with its original extension:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您想创建一个包含图像作为背景的表面，可以从`pygame`模块中调用`image`类。image类包含`load`方法，可以使用需要呈现的背景图像文件名作为参数进行调用。传递的文件名应该是完整的名称，带有其原始扩展名：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The load function that is called from the `image` class reads an image file
    from your machine and then returns the surface containing an image. Here, the
    screen dimension will be determined by the image size. The `convert()` member
    function of the `Surface` object will convert the specified image into the format
    that is supported by your display screen.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从`image`类调用的load函数会从您的计算机中读取图像文件，然后返回包含图像的表面。在这里，屏幕尺寸将由图像大小确定。`Surface`对象的`convert()`成员函数将把指定的图像转换为显示屏支持的格式。
- en: Now, let's learn how to create multiple surfaces inside a single one, which
    is normally called a subsurface.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何在单个表面内创建多个表面，通常称为子表面。
- en: Subsurfaces
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子表面
- en: 'As the name suggests, subsurfaces are a list of nested surfaces inside the
    single main surface. The main surface can be referenced as the parent surface.
    The parent surface can be created with any of the aforementioned methods using
    the `Surface` constructor, `set_mode`, or image. When you draw onto the subsurface,
    it is also going to draw onto the parent one, as subsurfaces are part of the parent,
    too. Creating a subsurface is easy; you just need to call the `subsurface` method
    from the `Surface` object, and the argument that is passed should indicate the
    position of the `parent` class to be covered. Normally, the coordinate that is
    passed should create a small rectangle inside the parent screen. The following
    code shows how a subsurface can be created:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，子表面是单个主表面内的嵌套表面列表。主表面可以被称为父表面。父表面可以使用`Surface`构造函数、`set_mode`或图像创建。当你在子表面上绘制时，它也会绘制在父表面上，因为子表面也是父表面的一部分。创建子表面很容易；你只需要从`Surface`对象调用`subsurface`方法，并且传递的参数应该指示要覆盖的`parent`类的位置。通常传递的坐标应该在父屏幕内创建一个小矩形。下面的代码显示了如何创建一个子表面：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can store these subsurfaces into data structures such as a dictionary so
    that you can reference them easily. You can observe the position that is passed
    inside the subsurface method—they are heretic from the others. The point (0, 0)
    always means that a subsurface starts from the top-left corner of the parent screen.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些子表面存储到数据结构中，比如字典，这样你就可以轻松地引用它们。你可以观察到传递给子表面方法的位置——它们与其他位置不同。点（0，0）总是表示子表面从父屏幕的左上角开始。
- en: There are several methods available with subsurfaces, all of which you can pry
    from its official documentation. One of the most useful methods is `get_parent()`,
    which returns the parent surface of the subsurface. It will return `None` if the
    `get_parent` method is not called with any subsurface.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 子表面有几种可用的方法，你可以从官方文档中了解到所有这些方法。其中最有用的方法之一是`get_parent()`，它返回子表面的父表面。如果没有使用`get_parent`方法调用任何子表面，它将返回`None`。
- en: Now, we will learn about the next method regarding surface objects that you
    will frequently use while making any game with pygame, which is `blit`, which
    stands for **bit block transfer**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习关于表面对象的下一个方法，这是在使用pygame制作任何游戏时经常使用的`blit`，它代表**位块传输**。
- en: Blitting your objects
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`blit`你的对象'
- en: While the term *blitting* may not have been defined in the Oxford dictionary,
    it has greater significance while making games with pygame. Often referred to
    as bit-boundary block transfer, or Block Information Transfer, `blit` is a way
    of copying the image from one surface to another, usually by cropping or shifting.
    Let's asume you have `Surfaceb`(your screen), and you would like to draw a shape,
    let's say, a rectangle onto the screen. So, what you have to do is draw a rectangle
    and then transfer a rectangular block of the buffer to the screen buffer. This
    process is called *blitting*. When we cover games using pygame, you will find
    it being used for drawing backgrounds, fonts, characters, and everything that
    you can imagine.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然术语*blitting*可能没有在牛津词典中定义，但在使用pygame制作游戏时具有更大的意义。`blit`通常被称为位边界块传输，或块信息传输，是一种将图像从一个表面复制到另一个表面的方法，通常是通过裁剪或移动。假设你有`Surfaceb`（你的屏幕），你想在屏幕上绘制一个形状，比如一个矩形。所以，你需要做的是绘制一个矩形，然后将缓冲区的矩形块传输到屏幕缓冲区。这个过程叫做*blitting*。当我们使用pygame制作游戏时，你会发现它被用来绘制背景、字体、角色，以及你能想象到的一切。
- en: 'In order to `blit` the surface, you can call the `blit` method from the resulting
    surface object, which is often the display object. You have to pass your source
    surface, such as characters, animations, and images, along with the coordinate
    to `blit` in as arguments. The invocation of the `blit` method is rather simple,
    compared to what it sounds like, theoretically. The following line of code shows
    how to `blit` the background image in the specified position (0,0), which is the
    top-most corner of the screen:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了`blit`表面，你可以从结果表面对象（通常是显示对象）调用`blit`方法。你必须传递你的源表面，比如角色、动画和图像，以及要`blit`的坐标作为参数。与理论上听起来的相比，调用`blit`方法相当简单。下面的代码显示了如何在指定位置（0,0）`blit`背景图像，即屏幕的左上角：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Let's say you have a collection of images that needs to be rendered, based on
    different frame rates. We could also do this using the `blit` method. We can change
    the value of the frame number and `blit` in a different area of the resulting
    screen to make an animation of the images. This is normally done in the case of
    static images. For example, we are going to create a clone of the flappy bird
    game, using Pygame, in the next chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一组需要根据不同帧率渲染的图像。我们也可以使用`blit`方法来做到这一点。我们可以改变帧数的值，并在结果屏幕的不同区域`blit`图像，以制作图像的动画。这通常是在静态图像的情况下完成的。例如，我们将在下一章中使用Pygame创建flappy
    bird游戏的克隆。
- en: 'In that game, we have to `blit` the pipes and the bird (characters for the
    flappy game) on the different position, out of the static image, which we normally
    call sprites. These sprites are nothing but images that can be used directly from
    the internet, or we can make one for ourselves, according to our needs. The following
    code shows a simple way to `blit` images, based on the different frame rates:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个游戏中，我们需要在不同的位置（通常称为精灵）上`blit`管道和小鸟（flappy游戏的角色）的静态图像。这些精灵只是可以直接从互联网使用的图像，或者根据我们的需要自己制作的图像。以下代码展示了一种根据不同帧率`blit`图像的简单方法：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the case of the flappy bird game, a list of images contains the images of
    the bird in two positions: flying and falling. Based on the user events, we will
    render each of them using the `blit` method.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flappy Bird游戏中，一个图像列表包含了鸟在飞行和下落两种姿势的图像。根据用户事件，我们将使用`blit`方法渲染它们。
- en: Before jumping into the next section, let's learn about the maybe paltry, but
    must-know topic, of *frame rates*. It is the term that is often used as the benchmark
    for measuring game performance. The frame rate in a video game infers the resultant
    simulation movements, or motions of how many times the images that you observe
    in the screen, are refreshed or fetched. The frame rate is a measurement that
    is done in **frames per second** or **FPS** (do not be confuse this with the term **first
    person shooter**).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在跳转到下一节之前，让我们了解一下可能微不足道但必须了解的*帧率*主题。这个术语经常被用作衡量游戏性能的基准。视频游戏中的帧率意味着你在屏幕上观察到的图像刷新或获取的次数。帧率是以**每秒帧数**或**FPS**（不要与**第一人称射击**混淆）来衡量的。
- en: There are many factors that go into determining a game's frame rate, but contemporary
    game players want anything but lag, or a sluggish game. Therefore, the higher
    rate is always better. Low frame rates may develop a hapless situation at an inopportune
    time. An example may be in games where users are able to jump or are chopped from
    a certain height; low FPS causes a lag in the system, and often makes the screen
    *Frozen*, which makes the user unable to interact with the game. Many modern games,
    for example, first-person shooter games such as Pubg and Fortnite, are developed
    with the intention of approaching a frame rate of around 60 FPS. But in a simple
    game developed by Pygame, anywhere from 15 to 30 FPS is considered acceptable.
    Some critics argue that anything below 30 FPS will create choppy animation and unrealistic
    motion, but as we know, pygame allows us to create mostly mini games. Therefore,
    anything between 15 to 30 FPS will be sufficient for us.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 决定游戏帧率的因素有很多，但当代游戏玩家希望的是没有任何滞后或游戏运行缓慢。因此，更高的帧率总是更好。低帧率可能会在不合适的时候产生不幸的情况。一个例子可能是在用户能够跳跃或从一定高度跌落的游戏中；低帧率会导致系统滞后，并经常使屏幕*冻结*，使用户无法与游戏进行交互。许多现代游戏，例如第一人称射击游戏，如绝地求生和堡垒之夜，都是以达到大约60帧每秒的帧率为目标开发的。但在Pygame开发的简单游戏中，15到30帧每秒之间被认为是可以接受的。一些批评者认为30帧每秒以下会产生断断续续的动画和不真实的运动，但正如我们所知，pygame允许我们创建大多数迷你游戏。因此，15到30帧每秒之间对我们来说是足够的。
- en: Let's hop into the next section, in which we will learn how to draw different
    shapes using the `pygame` draw module.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入下一节，我们将学习如何使用`pygame`绘制不同的形状。
- en: Drawing with the pygame draw module
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pygame绘制模块进行绘制
- en: One of the most used modules is `draw`, which has plenty of methods declared,
    and can be used to draw shapes onto the game screen. The aim of using this module
    is to draw lines, circles, and polygons—in fact, any geometrical shape. You might
    be wondering about the importance of using it—it has a broad range of uses. We
    might have to create shapes so as to perform cropping, or to blit the sprites
    or images onto the screen. Sometimes, you may want to use these shapes as characters
    for your game; games such as Tetris, which is one of the most popular games, is
    a perfect example. Even though you might not find it very useful while creating
    the games, and you would use sprites instead, it may be helpful while testing
    your game animation. You don't have to go anywhere to understand the importance
    of these shapes in game development; you can observe the games that we have created
    so far. Up until now, in the snake game, we have been using simple rectangular
    shapes to denote the snake's body and head. Although it might not be very appealing,
    at the incipient stage of games, we can always make games using such shapes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的模块之一是`draw`，它声明了许多方法，可以用来在游戏屏幕上绘制形状。使用此模块的目的是绘制线条、圆形和多边形，事实上，任何几何形状。你可能会想知道使用它的重要性——它有广泛的用途。我们可能需要创建形状以执行裁剪，或者将精灵或图像渲染到屏幕上。有时，您可能希望将这些形状用作游戏中的角色；像俄罗斯方块这样的游戏就是一个完美的例子。即使在创建游戏时您可能不会发现它非常有用，而是会使用精灵，但在测试游戏动画时可能会有所帮助。您不必去任何地方了解这些形状在游戏开发中的重要性；您可以观察到我们迄今为止创建的游戏。直到现在，在贪吃蛇游戏中，我们一直在使用简单的矩形形状来表示蛇的身体和头部。虽然这可能并不十分吸引人，在游戏的初期阶段，我们总是可以使用这样的形状来制作游戏。
- en: 'Creating such shapes using pygame is easier than with any other module. We
    can call up the draw module, along with the function name. The function name will
    be the name of the shape that you want to draw. For example, for a circle, we
    would use `pygame.draw.circle()`, and for a rectangle, we would use: `pygame.draw.rect()`.
    The first two parameters for the functions in `pygame.draw` are the surface on
    which you want to draw, followed by the color with which you want to draw it.
    The first parameter for drawing the function is the `Surface` object, which represents
    the screen in which you want to draw. The next parameter represents the position
    of the screen on which you want to draw your shapes.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pygame创建这样的形状比使用任何其他模块都要容易。我们可以调用绘制模块，以及函数名称。函数名称将是您想要绘制的形状的名称。例如，对于一个圆，我们将使用`pygame.draw.circle()`，对于一个矩形，我们将使用：`pygame.draw.rect()`。`pygame.draw`中函数的前两个参数是要绘制的表面，后面是要用来绘制的颜色。绘制函数的第一个参数是`Surface`对象，表示要在其上绘制的屏幕。下一个参数表示要在其上绘制形状的屏幕位置。
- en: 'These three arguments are mandatory for each of the geometrical shapes, but
    the last one depends on the shapes. The last argument of the method represents
    the mathematical quantity that is used while drawing such shapes, such as the
    radius or diameter of a circle. Normally, the third argument that is passed should
    represent the coordinate position in the form of *x* and *y* coordinates, where
    the point (0, 0) represents the top-most left area of the screen. The following
    table lists the number of methods that are available inside the draw module, which
    can be used to draw any geometric shape:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个参数对于每个几何形状都是强制性的，但最后一个取决于形状。该方法的最后一个参数表示在绘制这些形状时使用的数学量，例如圆的半径或直径。通常，传递的第三个参数应该表示坐标位置，以*x*和*y*坐标的形式，其中点（0,
    0）表示屏幕左上角的位置。下表列出了在绘制模块中可用的方法数量，这些方法可用于绘制任何几何形状：
- en: '| **Function** | **Description** |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `rect` | Draws a rectangle |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `rect` | 绘制矩形|'
- en: '| `polygon` | Draws a regular polygon (geometrical shape that has three or
    more enclosed sides) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `polygon` | 绘制正多边形（具有三个或更多封闭边的几何形状）|'
- en: '| `line` | Draws a line |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `line` | 绘制线条|'
- en: '| `lines` | Draws several lines |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `lines` | 绘制多条线|'
- en: '| `circle` | Draws a circle |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `circle` | 绘制圆|'
- en: '| `ellipse` | Draws an ellipse |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `ellipse` | 绘制椭圆|'
- en: 'As an example, let''s use the `circle` method and observe the `pygame` draw
    module in action. We need to know the value of the radius in order to draw a circle.
    The radius is the distance from the center of the circle to the edge of the circle,
    which is the arc of the circle. The arguments that should be passed while calling
    the circle functions are screen, which represents the surface object; the color
    of the circle; the position where the circle should be drawn; and finally, the
    radius of the circle. Since we used the random module to generate random values
    of the radius for the circle, instead of giving specific values, the following
    code creates multiple circles, with random widths in a random position, and blatantly
    with a random color. If you type specific values for each parameter, a shape will
    be drawn:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们使用`circle`方法并观察`pygame`绘图模块的运行情况。我们需要知道半径的值才能画一个圆。半径是从圆的中心到圆的边缘的距离，也就是圆的弧长。调用圆函数时应传递的参数是屏幕，代表表面对象；圆的颜色；圆应该被绘制的位置；最后是圆的半径。由于我们使用随机模块生成圆的半径的随机值，而不是给定特定值，以下代码创建了多个圆，具有随机宽度和随机位置，并且使用随机颜色。如果为每个参数输入特定值，将会绘制一个形状：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code, which will be written from this chapter onward, is in the PyCharm
    Community IDE, which was downloaded in [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml), *Getting
    to Know Python - Setting Up Python and the Editor*. Make sure that `pygame` is
    installed on the interpreter main directory so that `pygame` can be used universally
    on any newly created Python file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始编写的代码在PyCharm Community IDE中，该IDE是在[第1章](0ef9574b-5690-454e-971f-85748021018d.xhtml)中下载的，*了解Python-设置Python和编辑器*。确保`pygame`安装在解释器的主目录上，以便在任何新创建的Python文件上都可以通用地使用`pygame`。
- en: One of the important features that can be noted while using the PyCharm IDE
    is that it can give us information about all the modules that come with the installation
    of the `pygame` module. To determine which functions reside in the `draw` module,
    select the `circle` or `draw` keyboard from your code and press *Ctrl* + *B* on
    the keyboard, which will, in turn, redirect you to the declaration file of the
    `draw` module.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用PyCharm IDE时可以注意到的一个重要特性是，它可以为我们提供有关安装`pygame`模块的所有模块的信息。要确定`draw`模块中存在哪些函数，选择代码中的`circle`或`draw`关键字，然后在键盘上按*Ctrl*
    + *B*，这将将您重定向到`draw`模块的声明文件。
- en: While talking about the code, it is simple to understand. The main three lines
    of code are highlighted so that you can directly observe the importance of them.
    Mostly, the third line, which calls the `circle` method, is declared within the
    `draw` module, which takes the arguments, screen object, color, position, and
    radius in order to draw a circle. The output of the preceding program will print
    the circle with a random radius and a random color incessantly, until and unless
    the user closes the screen manually, which is due to the event handler, and is
    done by the `pygame.event.get` method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论代码时，很容易理解。主要的三行代码被突出显示，以便您可以直接观察它们的重要性。大多数情况下，第三行调用`circle`方法，声明在`draw`模块中，它接受参数，屏幕对象，颜色，位置和半径以绘制一个圆。前面程序的输出将不断打印具有随机半径和随机颜色的圆，直到用户手动关闭屏幕，这是由于事件处理程序完成的，由`pygame.event.get`方法完成。
- en: Similarly, you can draw polygons of many shapes and sizes, which may range from
    a three-sided triangle to a 9999-sided polygon. Just like we have used the `pygame.draw.circle`
    function to create a circle, we can use `pygame.draw.polygon` to draw any kind
    of polygon. A call to the polygon function takes the argument in the form of a
    list of points, and will draw a polygon shape using these points. We can draw
    different geometrical shapes using a specific appellation in a similar fashion.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以绘制许多形状和大小的多边形，范围可以从三边形到9999边形。就像我们使用`pygame.draw.circle`函数创建圆形一样，我们可以使用`pygame.draw.polygon`来绘制任何类型的多边形。对多边形函数的调用以点列表的形式作为参数，并将使用这些点绘制多边形形状。我们可以使用类似的方式使用特定的称谓绘制不同的几何形状。
- en: In the next section, we are going to learn about the different ways of initializing
    the display screen and handling keyboard and mouse events using the `pygame` module.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将学习使用`pygame`模块初始化显示屏和处理键盘和鼠标事件的不同方法。
- en: Initializing the display and handling events
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化显示屏和处理事件
- en: 'Primarily, the game developer will be focusing on how to make the game more
    interactive by making players feel like they are engaged. The two things that
    must be tied as dovetail in such cases is a visually attractive display and handling
    the events of the player. We don''t want our player to be overwhelmed with a deplorable
    display screen and a game that lags in movement. In this section, we are going
    to address the two primary things that the developer must take into account while
    making games: different ways of initializing the display by accommodating the
    available optional parameters and handling the user action events, such as when
    a keyboard key or a mouse button is pressed. The type of the display that you
    want to create depends on the type of game that you are planning to develop.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发人员主要将专注于如何使玩家感到参与其中，使游戏更具互动性。在这种情况下，必须将两个方面紧密联系在一起，即视觉上吸引人的显示和处理玩家的事件。我们不希望玩家被糟糕的显示屏和游戏运动中的滞后所压倒。在本节中，我们将讨论开发人员在制作游戏时必须考虑的两个主要方面：通过适应可用的可选参数来初始化显示的不同方式，以及处理用户操作事件，例如按下键盘键或鼠标按钮时。您想要创建的显示类型取决于您计划开发的游戏类型。
- en: One thing that you have to remember while making games with the `pygame` module
    is that adding more actions to the game will affect the smoothness of the game,
    which means that if you add multiple features into the game, the more the game
    will lag in interactivity. Thus, we will primarily focus on making mini games
    with the `pygame` module. There are more advanced Python modules on the market
    that can be used for making high-feature games, and we will explore them in the
    upcoming chapters. For now, we will see how to initialize the display, which is
    done by selecting a lower resolution, because we don't want our game to lag in
    any way.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`pygame`模块制作游戏时，您必须记住的一件事是，向游戏添加更多操作将影响游戏的流畅性，这意味着如果您向游戏中添加多个功能，游戏的互动性就会越来越差。因此，我们将主要专注于使用`pygame`模块制作迷你游戏。市场上还有更先进的Python模块可用于制作高功能游戏，我们将在接下来的章节中探讨它们。目前，我们将看到如何初始化显示，这是通过选择较低的分辨率来完成的，因为我们不希望游戏以任何方式滞后。
- en: 'Any games that will be made from now on will have a fixed and low resolution,
    but you can experiment on your own by making the user choose their own customized
    display. The following code is a simple way of creating a pygame window, and we
    have also seen this in the previously written code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始制作的任何游戏都将具有固定和低分辨率，但您可以通过让用户选择自定义显示来进行实验。以下代码是创建pygame窗口的简单方法，我们之前编写的代码中也见过：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first parameter of `set_mode()` will be the dimension of the screen. The
    value in the tuple (640, 480) represents the height and width of the screen. This
    dimension value will create a small window box, which is compatible with most
    desktop screens. We might, however, encounter a situation where a game must have
    a `FULLSCREEN`, instead of a small screen. In such cases, we can use an optional
    parameter, giving the value of `FULLSCREEN`. The code that displays the fullscreen
    looks something like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_mode()`的第一个参数将是屏幕的尺寸。元组中的值（640, 480）表示屏幕的高度和宽度。这个尺寸值将创建一个小窗口，与大多数桌面屏幕兼容。然而，我们可能会遇到一个情况，即游戏必须具有`FULLSCREEN`，而不是小屏幕。在这种情况下，我们可以使用一个可选参数，给出`FULLSCREEN`的值。显示全屏的代码看起来像这样：'
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We might, however, observe the performance difference between using fullscreen
    mode versus a customized display. While opening the game in fullscreen mode will
    run faster, as it doesn''t interact with other background desktop screens, the
    other screen, with a customized display, may become incorporated with other running
    display screens on your machine. Apart from that, debugging games with a small
    display screen is easier than games with a fullscreen because you should address
    alternative ways of closing the game in fullscreen mode as the close button will
    not be visible. To check the different resolutions of display that are supported
    by your PC, you can call the `list_modes()` method, which will return tuples containing
    a list of the resolutions, which appear like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可能会观察到使用全屏模式与自定义显示之间的性能差异。在全屏模式下打开游戏将运行得更快，因为它不会与其他后台桌面屏幕进行交互，而另一个屏幕，具有自定义显示，可能会与您的机器上运行的其他显示屏合并。除此之外，在小屏幕上调试游戏比全屏游戏更容易，因为您应该考虑在全屏模式下关闭游戏的替代方法，因为关闭按钮将不可见。要检查PC支持的不同显示分辨率，您可以调用`list_modes()`方法，它将返回包含分辨率列表的元组，看起来像这样：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Sometimes, you may feel that there is slight decrease in the quality of the
    image that is displayed in your screen. This is primarily due to a graphics card
    with fewer features, which doesn't provide the color of the image that you have
    requested . This is compensated for by `pygame`, who converts the image into one
    that is appropriate for your device.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能会感到屏幕上显示的图像质量略有下降。这主要是由于显卡功能较少，无法提供您请求的图像颜色。这由`pygame`进行补偿，它将图像转换为适合您设备的图像。
- en: In some games, you might want the user to decide on choosing the size of the
    display screen. The trade-offs are concerned with whether a player chooses either
    high-quality visuals or making the game run smoothly. Our main goal will be to
    handle the event, which can toggle a screen between a resizable screen and a fullscreen.
    The following code illustrates a switch between a windowed screen to a fullscreen,
    and vice versa. When the user presses *F* on the keyboard, it will toggle between
    screens.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些游戏中，您可能希望用户决定选择显示屏的大小。权衡的问题在于玩家选择高质量视觉还是使游戏运行顺畅。我们的主要目标将是处理事件，可以在可调整大小的屏幕和全屏之间切换。以下代码说明了在窗口化屏幕和全屏之间切换的方法。当用户在键盘上按下*F*时，它将在屏幕之间切换。
- en: 'As you run the program, the toggling process between the windowed screen and
    the fullscreen is not spontaneous. This is because `pygame` takes some time to
    check the features of the graphics card, and handles the quality of images itself
    if the card is not capable enough:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，窗口屏幕和全屏之间的切换过程并不是即时的。这是因为`pygame`需要一些时间来检查显卡的特性，如果显卡不够强大，它会自行处理图像的质量：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s learn about the display toggling process, line by line:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行学习显示切换的过程：
- en: 'You must begin by importing the `pygame` module. The second import statement
    is going to import constants that are used by Pygame. However, its contents are
    automatically placed in the `pygame` module namespace, and we can use `pygame.locals`
    to include only the `pygame` constants. Examples of constants include: KEYDOWN,
    Keyboard `k_constants`, and so on.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须从`pygame`模块开始导入。第二个导入语句将导入Pygame使用的常量。然而，它的内容会自动放置在`pygame`模块的命名空间中，我们可以使用`pygame.locals`来仅包含`pygame`常量。常量的例子包括：KEYDOWN，键盘`k_constants`等。
- en: You will set the default display mode at the start of the game. This display
    will be a default display, whenever you run your program for first time; the current
    customized display will be rendered. We have a passed display screen of (640,
    480) by default.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将在游戏开始时设置默认的显示模式。这个显示将是默认显示，每当你第一次运行程序时，当前定制的显示将被渲染。我们默认传递了一个(640, 480)的显示屏。
- en: To toggle the display screen, you have to make a Boolean variable, `Fullscreen`, which
    will be either `True` or `False`, and based on that, we will set the mode for
    the screen.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要切换显示屏，你必须创建一个布尔变量`Fullscreen`，它将是`True`或`False`，基于这一点，我们将设置屏幕的模式。
- en: Inside the main loop, you must handle the event for keyboard key actions. Whenever
    the user presses *F* on the keyboard, we will change the value of the Boolean
    variable, and if the value of the `FULLSCREEN` variable is `True`, we have to
    change the display to fullscreen. The extra flag, `FULLSCREEN`, is added as a
    second argument to the `add_mode()` function with a depth of 32.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主循环中，你必须处理键盘按键动作的事件。每当用户在键盘上按下*F*键时，我们将改变布尔变量的值，如果`FULLSCREEN`变量的值为`True`，我们必须将显示切换到全屏模式。额外的标志`FULLSCREEN`作为第二个参数添加到`add_mode()`函数中，深度为32。
- en: In the else part, if the value of fullscreen is `False`, you have to display
    the screen in the windowed version. The same key, *F*, is used to toggle the screen
    between the windowed and the fullscreen.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在else部分，如果全屏的值为`False`，你必须以窗口版本显示屏幕。相同的键*F*用于在窗口和全屏之间切换屏幕。
- en: Now that we have learned how to modify the windowed visuals using the different
    available flags, let's hop into the next section, where we will discuss accepting
    user input and controlling the game, which is often referred as *h**andling user
    events*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用不同的可用标志修改窗口可视化效果，让我们进入下一部分，我们将讨论接受用户输入和控制游戏，这通常被称为*处理用户事件*。
- en: Handling user events
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户事件
- en: 'On conventional PC games, we normally see the player playing games using just
    the keyboard. Even today, most games fully rely on keyboard actions. With the
    advancement of the game industry, we can accept user input from several input
    devices, such as the mouse and joysticks. Often, the mouse is used to handle the
    action, which gives a panoramic view of the game visuals. If you have ever played
    counter strike, or any first person shooter game, the mouse allows the player
    to rotate the view in several angles, whereas keyboard actions handle the player
    movements, such as moving left, right, jumping, and so on. The keyboard is normally
    used to trigger actions such as firing and dodging, because its action is pretty
    much like a switch. A switch only has two possibilities: on or off; keyboard keys
    are also either pressed, or not, which generalizes the technique for handling
    the keyboard actions. In typical 19th-century games, we used to spawn the game
    enemy by checking the actions of the keyboard. When a user presses a keyboard
    key relentlessly, we used to generate the enemy in a greater quantity.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的PC游戏中，我们通常看到玩家只使用键盘来玩游戏。即使在今天，大多数游戏仍然完全依赖于键盘操作。随着游戏行业的发展，我们可以从多种输入设备接受用户输入，如鼠标和操纵杆。通常，鼠标用于处理动作，它可以给游戏画面提供全景视图。如果你玩过反恐精英或任何第一人称射击游戏，鼠标允许玩家在多个角度旋转视角，而键盘操作则处理玩家的移动，如向左移动、向右移动、跳跃等。键盘通常用于触发射击和躲避等动作，因为它的操作就像一个开关。开关只有两种可能性：打开或关闭；键盘按键也只有按下或未按下，这概括了处理键盘操作的技术。在典型的19世纪游戏中，我们曾经通过检查键盘的操作来生成游戏敌人。当用户不断按下键盘按键时，我们会生成更多的敌人。
- en: The combination of the two input devices, that is, the mouse and the keyboard,
    works perfectly for these games because the mouse is capable of handling directional
    movements and does it in a smooth manner. For instance, when you play a first-person
    shooter game, you rotate the player using the keyboard and the mouse. Whenever
    any enemy is behind you, you normally use the mouse to rotate quickly to that
    position, rather than using the keyboard to rotate.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标和键盘这两种输入设备的组合非常适合这些游戏，因为鼠标能够处理方向运动，并且以平滑的方式进行操作。例如，当你玩第一人称射击游戏时，你可以使用键盘和鼠标来旋转玩家。当有敌人在你身后时，通常会使用鼠标快速旋转到那个位置，而不是使用键盘来旋转。
- en: 'In order to detect and listen to (capture) all of the keyboard keys, you have
    to use the `pygame.key` module. This module is capable of detecting whether any
    key is pressed or not, and even supports directional movements. This module is
    also capable of handling any keyboard actions. Basically, there are two ways of
    handling key presses in pygame:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测和监听所有的键盘按键，你必须使用`pygame.key`模块。这个模块能够检测任何键是否被按下，甚至支持方向运动。这个模块还能够处理任何键盘动作。基本上，有两种处理pygame中按键的方法：
- en: By handling KEYDOWN events, which are triggered when a key is pressed on the
    keyboard.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过处理按键按下事件，当键盘上的键被按下时触发。
- en: By handling KEYUP events, which are triggered or issued when a key on the keyboard
    is released.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过处理键盘上释放键时触发的KEYUP事件。
- en: While these event handlers are a great way to check for the key presses, handling
    the keyboard input for movement is not appropriate with them. We need to know
    beforehand if the keyboard key is being pressed or not in order to draw the next
    frame. Thus, using the `pygame.key` module directly will give us the power to
    handle keyboard keys effectively. The keys of the keyboard (a-z, 0-9, and F1-F12)
    have key constants which are predefined by pygame. These key constants can be
    referred to as keycode, which is used to identify them uniquely. Keycode always
    starts with `K_`. For every possible key, the keycode looks something like (`K_a`
    to `K_z`), (`K_0` to `K_9`), and contains other constants such as `K_SPACE`, `K_LEFT`,
    and `K_RETURN`. Some keyboard keys cannot be handled by pygame due to hardware
    incompatibility. This anomaly is discussed in "Keyboards are Evil," by several
    developers online. You might want to refer to them to understand this in more
    detail.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些事件处理程序是检查按键的一个很好的方法，但处理键盘输入以进行移动并不适合它们。我们需要事先知道键盘键是否被按下，以便绘制下一帧。因此，直接使用`pygame.key`模块将使我们能够有效地处理键盘键。键盘的键（a-z，0-9和F1-F12）具有由pygame预定义的键常量。这些键常量可以被称为键码，用于唯一标识它们。键码总是以`K_`开头。对于每个可能的键，键码看起来像（`K_a`到`K_z`），（`K_0`到`K_9`），并包含其他常量，如`K_SPACE`，`K_LEFT`和`K_RETURN`。由于硬件不兼容性，pygame无法处理一些键盘键。这个异常在网上由几位开发者讨论过。你可能需要参考他们以更详细地了解这一点。
- en: 'The most basic way of handling any keyboard action is by using the `pygame.key
    get_pressed` function. This method is quite powerful as it assigns Boolean values
    to all the keyboard constants; either `True` or `False`. We can check this by
    using `if` conditionals: is the value of the keyboard constant `True` or `False`?
    If it is `True`, it is obvious that a key is being pressed. The `get_pressed`
    method call returns a dictionary of the key constants, where the key of the dictionary
    is the key constants of the keyboard and a value of the dictionary is boolean,
    `dictionary_name[K_a] = True`. Let''s say you are making a program that will use
    an *up* movement as a jump button. You would have to write the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 处理任何键盘动作的最基本方法是使用`pygame.key get_pressed`函数。这个方法非常强大，因为它为所有键盘常量分配布尔值，要么是`True`，要么是`False`。我们可以通过使用`if`条件来检查：键盘常量的值是`True`还是`False`？如果是`True`，显然是有键被按下了。`get_pressed`方法调用返回一个键常量的字典，字典的键是键盘的键常量，字典的值是布尔值，`dictionary_name[K_a]
    = True`。假设你正在制作一个程序，它将使用*up*作为跳跃按钮。你需要编写以下代码：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s learn about the `pygame.key` module in more detail. Each of the following
    functions are going to handle keyboard keys, but with different approaches:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地了解`pygame.key`模块。以下每个函数都将以不同的方式处理键盘键：
- en: '`pygame.key.get_pressed()`: As we saw in the preceding code, this method returns
    a dictionary containing Boolean values for each key of the keyboard. You have
    to check the value of the keys to determine if it has been pressed or not. In
    other words, if any value for the keyboard key is set to `True`, the key for that
    index is said to be pressed.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.key.get_pressed()`: 正如我们在前面的代码中看到的，这个方法返回一个包含键盘每个键的布尔值的字典。你必须检查键的值来确定它是否被按下。换句话说，如果键盘键的任何值被设置为`True`，则该索引的键被认为是被按下的。'
- en: '`pygame.key.name()`: As the name suggests, this method call will return the
    name of the pressed key. For example, if I get a `KEY_UP` event for a key that
    has a value of 115, you can use `key.name` to print out the name of the key, which
    in this case is a string, *s*.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.key.name()`: 正如其名称所示，这个方法调用将返回按下的键的名称。例如，如果我得到一个值为115的`KEY_UP`事件，你可以使用`key.name`来打印出这个键的名称，这种情况下是一个字符串，*s*。'
- en: '`pygame.key.get_mods()`: This will determine which modifier key has been pressed.
    Modifier keys are normal keys combined with *Shift*, *Alt*, and *Ctrl*. In order
    to check if any modifier key is being pressed or not, you have to call the `get_mods`
    method first, followed by `K_MOD`. The method call and constants are separated
    by a bitwise AND operator, for example, `event.key == pygame.K_RIGHT` and `pygame.key.get_mods()
    & pygame`. The  `KMOD_LSHIFT` method can be used to check for the LEFT *Shift*
    key.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.key.get_mods()`: 这将确定哪个修改键被按下。修改键是与*Shift*、*Alt*和*Ctrl*组合的普通键。为了检查是否有任何修改键被按下，你必须首先调用`get_mods`方法，然后跟着`K_MOD`。方法调用和常量之间用按位与运算符分隔，例如，`event.key
    == pygame.K_RIGHT`和`pygame.key.get_mods() & pygame`。`KMOD_LSHIFT`方法可用于检查左*Shift*键。'
- en: '`pygame.key.set_mods()`: You can also automatically set the modifier key temporarily
    to observe the effect of the modifier key being pressed. To set multiple modifier
    keys, we normally combine them using the bitwise OR operator (|). For instance,
    `pygame.key.set_mods(KMOD_SHIFT | KMOD_LSHIFT)` will set the SHIFT and LEFT *Shift*
    modifier keys.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.key.set_mods()`: 你也可以临时设置修改键以观察修改键被按下的效果。要设置多个修改键，通常使用按位或运算符（|）将它们组合起来。例如，`pygame.key.set_mods(KMOD_SHIFT
    | KMOD_LSHIFT)`将设置SHIFT和LEFT *Shift*修改键。'
- en: '`pygame.key.get_focused()`: To grab every pressed key from the keyboard, the
    display must focus on the keyboard actions. This method call will return a Boolean
    value by checking if the display is receiving keyboard input from the system or
    not. In the case of games where there may be a customized screen, and the game
    screen is not focused because you may be using other application; this will return
    `False`, which means that the display is not active or focused to listen to keyboard
    actions. But in the case of a fullscreen display mode, you will be fully focused
    on the single screen, and in such cases, this method will always return `True`.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.key.get_focused()`: 要从键盘获取每个按下的键，显示必须专注于键盘操作。这个方法调用将通过检查显示是否正在从系统接收键盘输入来返回一个布尔值。在游戏中可能有一个自定义屏幕的情况下，游戏屏幕没有焦点，因为你可能在使用其他应用程序；这将返回`False`，这意味着显示不活跃或没有专注于监听键盘操作。但在全屏显示模式下，你将完全专注于单个屏幕，在这种情况下，这个方法将始终返回`True`。'
- en: 'There are couple more pygame key functions, such as `get_repeat` and `set_repeat`,
    they are useful in cases where you want the repeated action to occur when you
    continously hold down any key on the keyboard. For instance, open your notepad
    and press the *s *key, continuously. You will see that the character `s` will
    be printed several times. This feature can be embedded using the `pygame.key set_repeat`
    function. This function will take two arguments: delay and interval in milliseconds.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些pygame按键功能，比如`get_repeat`和`set_repeat`，它们在你想要在键盘上连续按住任意键时发生重复动作的情况下非常有用。例如，打开记事本并连续按下*s*键。你会看到字符`s`会被打印多次。这个功能可以使用`pygame.key
    set_repeat`函数嵌入。这个函数将接受两个参数：延迟和间隔，单位为毫秒。
- en: 'The first delay value is for the initial delay before a key repeats, while
    the next interval value is for the delay between repeated keys. You can disable
    these key-repeating features by using the `calling set_repeat` method with no
    parameter. By default, when pygame is initialized, the key-repeat feature is disabled.
    Thus, you need not have to disable it manually. Go to the following website for
    the pygame official documentation in order to learn more about pygame''s key functions:
    [https://www.pygame.org/docs/ref/key.html](https://www.pygame.org/docs/ref/key.html).'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个延迟值是按键重复之前的初始延迟，而下一个间隔值是重复按键之间的延迟。您可以使用`调用set_repeat`方法并不带参数来禁用这些按键重复功能。默认情况下，当pygame被初始化时，按键重复功能是被禁用的。因此，您不需要手动禁用它。请访问以下网站以获取pygame官方文档，以了解更多关于pygame按键功能的信息：[https://www.pygame.org/docs/ref/key.html](https://www.pygame.org/docs/ref/key.html)。
- en: You can set a movement for a sprite/image/object of the game screen with the
    keyboard by assigning a key of Up, Down, Left, or Right. Up until now, we have
    been doing this using different modules such as Python turtle and curses. However,
    we were unable to handle the movement of static sprites or images. We were only
    handling up, down, left, right, and key events for geometrical objects, but now
    pygame allows us to use more intricate graphics and handle them accordingly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过分配上、下、左或右键来使用键盘为游戏屏幕的精灵/图像/对象设置移动。直到现在，我们一直在使用不同的模块，如Python turtle和curses来做到这一点。然而，我们无法处理静态精灵或图像的移动。我们只处理了上、下、左、右和几何对象的按键事件，但现在pygame允许我们使用更复杂的图形并相应地处理它们。
- en: 'We can allocate any keyboard key to perform directional movements, but following
    conventional methods, we can appropriate cursor keys or arrow keys as they are
    perfectly placed on the keyboard, which allows the player to play easily. But
    in some complex multiplayer games, such as first-person shooter games, the *A*,
    *W*, *S*, and *D* keys are allocated for directional movements. Now, you might
    be wondering what you have to do in order to make any arrow key behave in such
    a way that it can be used for directional movements. Just recall the power of
    vectors: the mathematical concept that is useful for game development, irrespective
    of whatever language or module you use. The technique for moving any geometrical
    shapes and images is the same; we need to create a vector that points in the direction
    that we might want to head in. Representing the position of a game character is
    quite simple: you can represent it in 2D using the (*x*, *y*) position, and in
    3D using (*x*, *y*, *z*) position. The directional vector, however, is the unit
    quantity that must be added to the current vectored position in order to change
    to the next frame. For instance, by pressing the down key on the keyboard, we
    have to move downward with no change in the *x* position, but with a unit increment
    in the *y* coordinates. The following table explains the directional movement
    for four directions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以分配任何键盘键来执行方向移动，但按照传统方法，我们可以适当地将光标键或箭头键分配为它们在键盘上的位置完美，这样玩家可以轻松游戏。但在一些复杂的多人游戏中，比如第一人称射击游戏，*A*、*W*、*S*和*D*键被分配用于方向移动。现在，你可能想知道为了使任何箭头键以这样的方式行为，可以用于方向移动，你需要做什么。只需回想一下向量的力量：这是一个数学概念，无论你使用什么语言或模块，都对游戏开发有用。移动任何几何形状和图像的技术是相同的；我们需要创建一个指向我们可能想要前进的方向的向量。表示游戏角色的位置非常简单：你可以用2D坐标(*x*,
    *y*)表示它，用3D坐标(*x*, *y*, *z*)表示它。然而，方向向量是必须添加到当前向量位置的单位量，以便转到下一帧。例如，通过按下键盘上的下键，我们必须向下移动，*x*位置不变，但*y*坐标增加一个单位。下表解释了四个方向的方向移动：
- en: '| **Position** | **Directional vector** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **位置** | **方向向量** |'
- en: '| Up | (0, -1) |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 上 | (0, -1) |'
- en: '| Down | (0, 1) |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 下 | (0, 1) |'
- en: '| Left | (-1, 0) |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 左 | (-1, 0) |'
- en: '| Right | (1, 0) |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 右 | (1, 0) |'
- en: 'We may also want the player to allow diagonal movements, as shown in the following
    illustration:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还希望玩家允许对角线移动，如下图所示：
- en: '![](Images/8a263cf7-95c9-4277-ad7c-2dfd24d02cd3.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8a263cf7-95c9-4277-ad7c-2dfd24d02cd3.png)'
- en: 'The preceding illustration represents a vectored motion for the up and right
    keyboard keys. Suppose, at the beginning of the game, the player is at position
    (0, 0), which means they are at the center. Now, when the user presses the up
    (arrow key) keyboard key, there will be addition of (0, 0) with the up directional
    vectors (0, -1), and the resulting vector will be the player''s new position.
    The diagonal movement (the combination of two keys, in this case, up and right),
    will give an addition of (0.707, -0.707) to the current vectored position of the
    player. We can use this technique of vectored motion in order to provide the directional
    movement to any game objects, either sprites/static images or geometrical shapes.
    The following code represents the vectored movement using pygame event handling
    techniques:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的插图代表了上和右键盘键的矢量运动。假设在游戏开始时，玩家位于位置(0, 0)，这意味着他们位于中心。现在，当用户按上（箭头键）键盘键时，将(0,
    0)与上方向矢量(0, -1)相加，得到的矢量将是玩家的新位置。对角线移动（两个键的组合，这种情况下是上和右）将在玩家当前矢量位置上增加(0.707, -0.707)。我们可以使用这种矢量运动技术来为任何游戏对象提供方向运动，无论是精灵/静态图像还是几何形状。以下代码代表了使用pygame事件处理技术的矢量运动：
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Although it is worth knowing how to make things move in eight directions (four
    basic directions and four diagonal movements), using all eight of these won''t
    make the game smoother. Hypothetically, it is a little artificial to make things
    go in eight directions. However, games nowadays allow game players to observe
    a view with a 360-degree facility. Thus, in order to make games with such features,
    instead of using eight keyboard actions, we can make rotational movements with
    the keys. To calculate the resultant vector from the rotation, we must calculate
    the sine and cosine of the angle using math modules. The sine of the angle is
    responsible for the movement in the *x*-component, while cosine is responsible
    for the movement in the *y*-component. Both of these functions take angles in
    radians; if the rotation angle is in degrees, you have to convert it into radians
    using (`degree*pi/180`):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管了解如何使物体在八个方向移动（四个基本方向和四个对角线移动）是值得的，但使用所有八个方向不会使游戏更加流畅。在假设中，使物体朝八个方向移动有点不自然。然而，现在的游戏允许玩家以360度的方式观察视图。因此，为了制作具有这种功能的游戏，我们可以使用键进行旋转运动，而不是使用八个键动作。为了计算旋转后的矢量，我们必须使用数学模块计算角度的正弦和余弦。角度的正弦负责*x*分量的运动，而余弦负责*y*分量的运动。这两个函数都使用弧度角；如果旋转角度是度数，你必须使用(`degree*pi/180`)将其转换为弧度：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, let's learn about implementing mouse control and observe how it can be
    used in game development.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习实现鼠标控制，并观察它如何在游戏开发中使用。
- en: Mouse control
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鼠标控制
- en: Having mouse control, along with keyboard control, comes in handy if you want
    to make games more interactive. Sometimes, handling eight directional keys is
    not enough, and in such cases, you also have to handle mouse events. For example,
    in games such as flappy bird, users have to essentially be able to play with a
    mouse, and although it uses screen taps in mobile games, on a PC, you have to
    be able to provide mouse actions. Drawing a mouse cursor into the display screen
    is quite simple; you need to get the coordinates of the mouse from `MOUSEMOTION`
    events. Similar to the keyboard `get_pressed` function, you can call up the `pygame.mouse.get_pos()`
    function in order to obtain the position of the mouse. Mouse movements are extremely
    helpful in the game—if you want to make the game characters rotate, or make a
    screen tap game, or even if you want to look up and down the game screen.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有鼠标控制，以及键盘控制，如果你想使游戏更加互动，这是很方便的。有时，处理八个方向键是不够的，在这种情况下，你还必须处理鼠标事件。例如，在像flappy
    bird这样的游戏中，用户基本上必须能够使用鼠标玩，尽管在移动游戏中使用屏幕点击，在PC上，你必须能够提供鼠标操作。在显示屏中绘制鼠标光标非常简单；你只需要从`MOUSEMOTION`事件中获取鼠标的坐标。类似于键盘`get_pressed`函数，你可以调用`pygame.mouse.get_pos()`函数来获取鼠标的位置。鼠标移动在游戏中非常有用——如果你想使游戏角色旋转，或者制作一个屏幕点击游戏，甚至如果你想上下查看游戏屏幕。
- en: 'In order to understand the ways of handling mouse events, let''s look at a
    simple example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解处理鼠标事件的方法，让我们看一个简单的例子：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'I have highlighted some important parts of the code. The focus is primarily
    on those parts that help us understand the implementation of mouse events. Let''s
    look at the code, line by line:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出了代码的一些重要部分。重点主要放在帮助我们理解鼠标事件实现的那些部分上。让我们逐行看代码：
- en: First of all, you have to define an object—an area that will have the mouse
    event listener set to capture it. In this case, you have to declare the area as
    a rectangle using the `pygame.draw.rect` method call.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你必须定义一个对象——一个将有鼠标事件监听器设置以捕获它的区域。在这种情况下，你必须使用`pygame.draw.rect`方法调用将区域声明为矩形。
- en: Inside the main loop, you have to get the position of the mouse, which will
    represent the current cursor coordinates using the `pygame.mouse.get_pos()` function.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主循环内，你必须使用`pygame.mouse.get_pos()`函数获取鼠标的位置，这将表示当前光标坐标。
- en: Then, you have to call the `get_pressed()` method from the `pygame.mouse` module.
    A list of Boolean values will be returned. A Boolean `True` value for LEFT, RIGHT,
    or CENTER means that, at a particular instance, a specific mouse button is pressed,
    and the remaining two are not. Here, we captured three Boolean values for three
    mouse buttons.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你必须从`pygame.mouse`模块调用`get_pressed()`方法。将返回一个布尔值列表。对于左、右或中间，布尔值`True`表示在特定实例中，特定鼠标按钮被按下，而其余两个没有。在这里，我们捕获了三个鼠标按钮的布尔值。
- en: Now, to check if the user has pressed in the rectangle or not, you have to call
    the `collidepoint` method and pass a position value to it. The position represents
    the current cursor position. `pressed1` is going to be `True` if the mouse is
    clicked at the current position.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要检查用户是否按在矩形内，你必须调用`collidepoint`方法并向其传递一个位置值。位置表示当前光标位置。如果鼠标在当前位置点击，`pressed1`将为`True`。
- en: When both of these statements are `True`, you can perform any action accordingly.
    Remember that this program is not going to print a message, even if you clicked
    in the window screen, which is not part of the rectangle.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当这两个语句都为`True`时，您可以相应地执行任何操作。请记住，即使您在窗口屏幕中点击了，这个程序也不会打印消息，因为它不属于矩形的一部分。
- en: 'Similar to the `pygame.key` module, let''s learn about the `pygame.mouse` module
    in detail. This module contains eight functions:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与`pygame.key`模块类似，让我们详细了解`pygame.mouse`模块。该模块包含八个函数：
- en: '`pygame.mouse.get_rel()`: It will return the relative mouse movement as a tuple,
    with the *x* and *y* relative movement.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.mouse.get_rel()`: 它将以元组形式返回相对鼠标移动，包括*x*和*y*的相对移动。'
- en: '`pygame.mouse.get_pressed()`: It will return three Boolean values, which represent
    the mouse buttons, and if any one is `True`, the corresponding button is assumed
    as pressed.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.mouse.get_pressed()`: 它将返回三个布尔值，代表鼠标按钮，如果任何一个为`True`，则相应的按钮被视为按下。'
- en: '`pygame.mouse.set_cursor()`: It will set the standard cursor image. This is
    rarely needed since better results can be achieved by blitting an image to the
    mouse coordinate.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.mouse.set_cursor()`: 它将设置标准光标图像。这很少需要，因为通过在鼠标坐标上绘制图像可以获得更好的效果。'
- en: '`pygame.mouse.get_cursor()`: Two different tasks are performed: firstly, it
    sets the cursor standard image, and secondly, it fetches the deterministic data
    regarding the system cursor.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.mouse.get_cursor()`: 它执行两个不同的任务：首先，它设置光标的标准图像，其次，它获取关于系统光标的确定性数据。'
- en: '`pygame.mouse.set_visible()`: It changes the visibility of the standard mouse
    cursor. If `False`, the cursor will be invisible.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.mouse.set_visible()`: 它改变标准鼠标光标的可见性。如果为`False`，光标将不可见。'
- en: '`pygame.mouse.get_pos()`: It returns a tuple containing the *x* and *y* values
    of the position in the canvas where the mouse is clicked.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.mouse.get_pos()`: 它返回一个元组，包含鼠标在画布中点击位置的*x*和*y*值。'
- en: '`pygame.mouse.set_pos()`: It will set the mouse position. It takes an argument
    in the form of a tuple containing the coordinates of *x* and *y* in the canvas.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.mouse.set_pos()`: 它将设置鼠标位置。它接受一个元组作为参数，其中包含画布中*x*和*y*的坐标。'
- en: '`pygame.mouse.get_focused()`: This Boolean function result is based on the
    condition of whether the window screen is getting input from mouse or not. It
    is similar to the `key.get_focused` function. When pygame is running in the current
    window screen, the window will get the input from the mouse, but only if the pygame
    window is selected and is running at the front of the display. If another program
    is running in the background and is selected, then the pygame window won''t get
    an input from the mouse, and the output of this method call will be `False`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pygame.mouse.get_focused()`: 这个布尔函数的结果基于窗口屏幕是否接收鼠标输入的条件。它类似于`key.get_focused`函数。当pygame在当前窗口屏幕中运行时，窗口将接收鼠标输入，但只有当pygame窗口被选中并在显示器的最前面运行时才会接收。如果另一个程序在后台运行并被选中，那么pygame窗口将无法接收鼠标输入，这个方法调用的输出将是`False`。'
- en: You might have played games where you fly an airplane or destroy tanks where
    the mouse is used as an aiming device and the keyboard is used for movement and
    firing actions. These games are highly interactive. Therefore, you have to try
    to make a game that can combine both of these events as much as possible. These
    two types of events are very useful and are important for any game development
    I suggest that you take the time to experiment with these events. If possible,
    try to make your own game using only geometrical objects. Now, we are going to
    learn how to make a game using pygame, and our own sprites.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能玩过一些飞机或坦克游戏，鼠标用作瞄准设备，键盘用于移动和射击动作。这些游戏非常互动。因此，您应该尝试制作一个可以尽可能结合这两种事件的游戏。这两种类型的事件非常有用，对于任何游戏开发都很重要。我建议您花时间尝试这些事件。如果可能的话，尝试只使用几何对象制作自己的游戏。现在，我们将学习如何使用pygame和我们自己的精灵制作游戏。
- en: This game will be a modified version of the snake game that was made by the
    turtle module in the previous chapter. All the concepts will be same, but instead
    of dull and bland-looking game characters, we will make visually appealing characters,
    and we will handle events using pygame.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏将是前一章中由turtle模块制作的贪吃蛇游戏的修改版本。所有的概念都是一样的，但是我们将制作外观吸引人的角色，并且我们将使用pygame处理事件。
- en: Object rendering
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象渲染
- en: Computers store images in the form of grids of colors. Mostly, RGB (red, green,
    and blue) are enough to provide information for pixels. But apart from RGB values,
    there is another component of an image that is useful when dealing with pygame
    game development, which is alpha information (usually known as attribute components).
    The alpha information represents image transparency. This extra bit of information
    is quite useful; what usually happens in the case of pygame is that we normally
    draw or place one image on top of another with the alpha property activated. By
    doing this, we can see part of the background through it. We normally use third-party
    software such as GIMP in order to make an images' background transparent.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机以颜色网格的形式存储图像。通常，RGB（红色、绿色和蓝色）足以提供像素的信息。但除了RGB值之外，在处理pygame游戏开发时，图像的另一个组成部分也很有用，那就是alpha信息（通常称为属性组件）。alpha信息代表图像的透明度。这些额外的信息非常有用；在pygame的情况下，通常我们会激活alpha属性，然后将一张图像绘制或放置在另一张图像的顶部。通过这样做，我们可以看到部分背景。通常，我们会使用GIMP等第三方软件来使图像的背景透明。
- en: 'Apart from knowing how to make an images'' background transparent, we have
    to know how to import them into our project so that we can use them. Importing
    any static images or sprites into the Python project is easy, and pygame makes
    it even easier. We have an image module, which provides a load method to import
    images. While calling the load method, you have to pass an image with the full
    filename, including the extensions. The following code represents a way of importing
    images into Python projects:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了知道如何使图像的背景透明之外，我们还必须知道如何将它们导入到我们的项目中，以便我们可以使用它们。将任何静态图像或精灵导入Python项目非常容易，pygame使其变得更加容易。我们有一个图像模块，它提供了一个load方法来导入图像。在调用load方法时，您必须传递一个带有完整文件名的图像，包括扩展名。以下代码表示了一种将图像导入Python项目的方法：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The image that you want to import into the game project should be in the same
    directory where the game project resides. For example, if the Python file is saved
    in the snake directory, the image that is loaded by the Python file should also
    be saved inside the snake directory.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要导入游戏项目的图像应该与游戏项目所在的目录相同。例如，如果Python文件保存在snake目录中，则Python文件加载的图像也应保存在snake目录中。
- en: In the image module, the load function will load a file from your hard drive
    and return a newly generated surface that contains the image that you want to
    load. The first call to `pygame.image.load` will read the image file, and then
    an immediate call to the `convert` method takes place, which will convert the
    image into the same format as our display. Due to the conversion of the image
    and the display screen being in the same depth level, drawing into the screen
    is relatively faster.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像模块中，load函数将从硬盘加载文件并返回一个包含要加载的图像的新生成的表面。对`pygame.image.load`的第一次调用将读取图像文件，然后立即调用`convert`方法，将图像转换为与我们的显示器相同的格式。由于图像和显示屏的转换处于相同的深度级别，因此绘制到屏幕上相对较快。
- en: The second statement is to load the mouse cursor. Sometimes, you might want
    to load a custom-made mouse cursor into game, and a second line of code is the
    way to do this. In the case of loading `mouse_cursor`, `convert_alpha` is used
    instead of the convert function. This is because the image of the mouse cursor
    contains special information regarding transparency, which is termed as *alpha
    information*, and makes part of the image invisible to detect. By disabling the
    alpha information, our mouse cursor would be besieged by rectangular or square
    shapes, and thus would make the cursor look unprepossessing. Essentially, the
    alpha information is used to denote images that will have a transparent background.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个语句是加载鼠标光标。有时，您可能希望将自定义鼠标光标加载到游戏中，第二行代码就是这样做的方法。在加载`mouse_cursor`的情况下，使用`convert_alpha`而不是convert函数。这是因为鼠标光标的图像包含有关透明度的特殊信息，称为*alpha信息*，并使图像的一部分变得不可见。通过禁用alpha信息，我们的鼠标光标将被矩形或正方形形状包围，从而使光标看起来不太吸引人。基本上，alpha信息用于表示将具有透明背景的图像。
- en: 'Now that we have learned how to import images into the Python projects, let''s
    learn how to rotate these images. This is an extremely useful technique because,
    while building games, we may have to rotate images by a certain degree in order
    to make the game appealing. For instance, let''s say that we are making a snake
    game, and we are using an image for the head of the snake. Now, when the user
    presses *up* key on the keyboard, the head of the snake should rotate, and must
    move smoothly upward. This is done by the `pygame.transform` module. The `Rotate`
    method can be called from the transform module in order to facilitate rotation.
    The rotate method takes the image surface, which is loaded from the `image.load()`
    function and specifies the degrees by which the rotation must be done. Usually,
    the operation of transformation would resize, or move part of the pixel, in order
    to make the surface look compatible with the display screen:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何将图像导入Python项目，让我们学习如何旋转这些图像。这是一种非常有用的技术，因为在构建游戏时，我们可能需要按一定角度旋转图像，以使游戏更具吸引力。例如，假设我们正在制作一个贪吃蛇游戏，我们正在使用一张图像作为蛇头。现在，当用户在键盘上按下“上”键时，蛇头应该旋转，并且必须平稳地向上移动。这是通过`pygame.transform`模块完成的。`Rotate`方法可以从transform模块中调用以便进行旋转。旋转方法接受从`image.load()`函数加载的图像表面，并指定旋转的角度。通常，转换操作会调整像素的大小或移动部分像素，以使表面与显示屏兼容：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Before we begin to develop our own visually appealing snake game, you have
    to learn about the Pygame `time` module. Follow this link to learn more about
    it: [https://www.pygame.org/docs/ref/time.html#pygame.time.Clock](https://www.pygame.org/docs/ref/time.html#pygame.time.Clock).
    The `Pygame.time` module is used for monitoring time. The time-clock also provides
    several functions to help control a game''s frame rate. The term frame rate is
    the rate or frequency at which consecutive images appear on a display screen.
    Whenever you call the `Clock()` constructor of the time module, it will create
    an object, which can be used to track time. There are a variety of functions that
    are defined internally by Pygame developers inside the Pygame time module. However,
    we are only going to use the `tick` method, which will update the clock.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始开发自己的视觉吸引人的贪吃蛇游戏之前，您必须了解Pygame `time`模块。点击此链接了解更多信息：[https://www.pygame.org/docs/ref/time.html#pygame.time.Clock](https://www.pygame.org/docs/ref/time.html#pygame.time.Clock)。`Pygame.time`模块用于监控时间。时间时钟还提供了几个函数来帮助控制游戏的帧速率。帧速率是连续图像出现在显示屏上的速率或频率。每当调用时间模块的`Clock()`构造函数时，它将创建一个对象，该对象可用于跟踪时间。Pygame开发人员在Pygame时间模块内部定义了各种函数。但是，我们只会使用`tick`方法，它将更新时钟。
- en: '`Pygame.time.Clock.tick()` should be called once per frame. Between two successive
    calls of the function, the `tick()` method tracks the time between each call in
    milliseconds. By calling `Clock.tick(60)` once per frame, programs are limited
    to running within the boundary of 60 FPS, and cannot exceed it, even if the processing
    power is higher. Thus, it can be used to limit the runtime speed of the game.
    This is important in the case of games that are developed by Pygame because we
    want to run the game smoothly, instead of compensating with CPU resources. The
    value of frames per second (frame rate) can be anywhere from 15 to 40 in the games
    that are developed by Pygame.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pygame.time.Clock.tick()`应该在每帧调用一次。在函数的两次连续调用之间，`tick()`方法跟踪每次调用之间的时间（以毫秒为单位）。通过每帧调用`Clock.tick(60)`，程序被限制在60
    FPS的范围内运行，并且即使处理能力更高，也不能超过它。因此，它可以用来限制游戏的运行速度。这在由Pygame开发的游戏中很重要，因为我们希望游戏能够平稳运行，而不是通过CPU资源来补偿。每秒帧数（帧速率）的值可以在由Pygame开发的游戏中的游戏中任何地方从15到40。'
- en: Now, we have enough information to make our very own game using Pygame, which
    will have sprites and smooth movements for game characters. We will start by initializing
    the display in the next section. We are going to update our snake game using the
    Pygame module.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有足够的信息来使用Pygame制作我们自己的游戏，其中将有精灵和游戏角色的平滑移动。我们将在下一节中开始初始化显示。我们将使用Pygame模块更新我们的贪吃蛇游戏。
- en: Initializing the display
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化显示
- en: 'Initializing the display is pretty basic; you can always start by importing
    the essential modules and providing specific dimensions of the display to the
    `set_mode()` method in order to create a windowed screen. Apart from that, we
    are going to declare a main loop. Refer to the following code to observe the declaration
    of the main loop:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化显示非常基础；您可以始终通过导入必要的模块并在`set_mode()`方法中提供显示的特定尺寸来创建窗口化屏幕。除此之外，我们将声明一个主循环。请参考以下代码以观察主循环的声明：
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After the initialization, you can run your program to check if everything works.
    If you get an error saying `No pygame module`, make sure that you follow the aforementioned
    steps for installing Pygame on your PyCharm IDE. Now, we will learn how to work
    with colors.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化后，您可以运行程序检查一切是否正常。如果出现“没有pygame模块”的错误，请确保您按照上述步骤在PyCharm IDE上安装Pygame。现在，我们将学习如何使用颜色。
- en: Working with colors
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用颜色
- en: The basic principle that works with computer color is *color addition*, which
    is a technique that will add the three primary colors in order to create a new
    one. The three primary colors are red, green, and blue, and often referred to
    as the RGB value. Whenever Pygame requires any color to be added into a game,
    you have to pass it in the tuple of three integers, one for each of the components
    referring to either red, green, or blue.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机颜色的基本原理是*颜色相加*，这是一种将三种基本颜色相加以创建新颜色的技术。三种基本颜色是红色、绿色和蓝色，通常称为RGB值。每当Pygame需要将任何颜色添加到游戏中时，您必须将其传递给三个整数的元组，每个整数分别对应红色、绿色或蓝色。
- en: 'The order in which you pass the integer value to the tuple matters, with a
    small change being made in integer resulting in different colors. The value of
    each of the components of color must range from 0 to 255, where 255 represents
    a color having absolute intensity, and 0 represents that color having no intensity
    at all. For example, (255, 0, 0) represents a red color. The following table indicates
    the color codes for different colors:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将整数值传递给元组的顺序很重要，对整数进行微小的更改会导致不同的颜色。颜色的每个组件的值必须在0到255之间，其中255表示颜色具有绝对强度，而0表示该颜色根本没有强度。例如，(255,
    0, 0)表示红色。以下表格指示了不同颜色的颜色代码：
- en: '| Color name | Hex code#RRGGBB | Decimal code(R,G,B) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: 颜色名称 十六进制码#RRGGBB 十进制码(R,G,B)
- en: '| --- | --- | --- |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '---'
- en: '| Black | #000000 | (0,0,0) |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '黑色 #000000 (0,0,0)'
- en: '| White | #FFFFFF | (255,255,255) |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '白色 #FFFFFF (255,255,255)'
- en: '| Red | #FF0000 | (255,0,0) |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '红色 #FF0000 (255,0,0)'
- en: '| Lime | #00FF00 | (0,255,0) |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '酸橙色 #00FF00 (0,255,0)'
- en: '| Blue | #0000FF | (0,0,255) |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '蓝色 #0000FF (0,0,255)'
- en: '| Yellow | #FFFF00 | (255,255,0) |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '黄色 #FFFF00 (255,255,0)'
- en: '| Cyan/Aqua | #00FFFF | (0,255,255) |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '青色/水绿色 #00FFFF (0,255,255)'
- en: '| Magenta/Fuchsia | #FF00FF | (255,0,255) |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '洋红/紫红 #FF00FF (255,0,255)'
- en: 'Now, let''s add some color to our snake game project:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的贪吃蛇游戏项目添加一些颜色：
- en: '[PRE22]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, in the next section, we will learn how to create game objects using the
    `pygame` module.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在下一节中，我们将学习如何使用`pygame`模块创建游戏对象。
- en: Making game objects
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作游戏对象
- en: 'In order to begin the creation of game objects, we won''t use snake sprites
    or images directly. Instead, we will start by using a small rectangular box, and
    later we will replace it with a snake image. This needs to be done in most game
    because we have to test multiple things at the beginning of game development,
    such as frame rate, collisions, rotations, and so on. After we deal with all of
    these, it is easy to add images to the pygame project. Thus, in this section,
    we will make game objects that resemble the rectangular box. We will make the
    head and body of the snake, which will be a small rectangular box. We will initially
    make one box for the head of the snake and another for the food, and then add
    color to it:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始创建游戏对象，我们不会直接使用贪吃蛇精灵或图像。相反，我们将从使用一个小矩形框开始，然后我们将用贪吃蛇图像替换它。这在大多数游戏中都需要做，因为我们必须在游戏开发的开始测试多个事物，比如帧速率、碰撞、旋转等。在处理所有这些之后，很容易将图像添加到pygame项目中。因此，在本节中，我们将制作类似矩形框的游戏对象。我们将制作贪吃蛇的头部和身体，它将是一个小矩形框。我们最初将为贪吃蛇的头部制作一个盒子，另一个为食物，然后为其添加颜色：
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will now add movement to the `game` objects. We have been talking about
    these a lot in the previous chapters, such as while handling directional movements
    using vectors::'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为`game`对象添加移动。在之前的章节中，我们已经谈论了很多这些内容，比如在处理方向移动时使用向量：
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, `change_x` and `change_y` denote the initial position
    for the snake. Whenever start playing our game, the default position for the snake
    will be (`change_x`, `change_y`). By pressing either the left or the right key,
    we change its position.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，`change_x`和`change_y`表示蛇的初始位置。每当开始玩我们的游戏时，蛇的默认位置将是(`change_x`, `change_y`)。通过按下左键或右键，我们改变它的位置。
- en: 'When you run the game at this moment, you might observe that your game will
    move only one step, and will eventually stop when you press, and then immediately
    release, the keyboard key. This anomaly can be corrected by handling multiple
    movements. In this case, we will create `lead_x_change`, this will change according
    to the main `change_x` variable. Remember that, we are not handling key events
    for up and down; thus, `lead_y_change` is not needed:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当你此刻运行游戏时，你可能会观察到你的游戏只会移动一步，当你按下并立即释放键盘键时，游戏会立即停止。这种异常行为可以通过处理多个运动来纠正。在这种情况下，我们将创建`lead_x_change`，这将根据主`change_x`变量的变化。请记住，我们没有处理上下键事件；因此，不需要`lead_y_change`。
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since, in the new line of code, we added extra information, `lead_x_change`,
    it will be called as a change in the *x* coordinates, and every time the user
    hits the left and right keyboard keys, the snake will move automatically. The
    highlighted part of the code (`change_x += lead_x_change`) is responsible for
    giving the snake continuous movement, even if the user doesn't press any keys
    (the rule of the snake game).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的代码行中，我们添加了额外的信息`lead_x_change`，它将被称为*x*坐标的变化，每当用户按下左右键盘键时，蛇就会自动移动。代码的突出部分(`change_x
    += lead_x_change`)负责使蛇持续移动，即使用户不按任何键（蛇游戏的规则）。
- en: Now, when you press one key, you might see another unusual behavior in the game.
    In my case, I ran my game, and as soon as I started to press the left key, the
    snake began to move quickly, and continuously, from left to right. This is due
    to leniency in the frame rate; we now have to explicitly indicate the frame rate
    for the game so that it limits the runtime speed of the game. We will cover this
    in the next section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你按下一个键时，你可能会在游戏中看到另一种不寻常的行为。在我的情况下，我运行了我的游戏，当我开始按下左键时，蛇开始快速地连续地从左到右移动。这是由于帧速率的宽松性；我们现在必须明确指示游戏的帧速率，以限制游戏的运行速度。我们将在下一节中介绍这个问题。
- en: Using the frame rate concept
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用帧速率概念
- en: 'This topic is not foreign to us; I have tried my best to introduce this topic
    as early as I could. We learned about the concept of frame rate while discussing
    the clock module, too. In this section, we will look at the concept of frame rate
    in action. Up until now, we have made a game that can run, but that has no restraint
    in its movements. It is continuously moving in one direction or another, with
    high speed, and we certainly don''t want that. What we really want is to make
    the snake move continuously, but within a certain frame rate. We will use `pygame.time.Clock`
    to create an object, that will track the time on our game. We will use the `tick`
    function to update the clock. The tick method should be called once per frame.
    By calling `Clock.tick(15)` once per frame, the game will never run at more than
    15 FPS:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个话题对我们来说并不陌生；我已经尽我最大的努力尽早介绍这个话题。在讨论时钟模块时，我们也学习了帧速率的概念。在本节中，我们将看到帧速率的概念在实际中的应用。到目前为止，我们已经制作了一个可以运行的游戏，但它在移动上没有任何限制。它在一个方向或另一个方向上持续移动，速度很快，我们当然不希望这样。我们真正想要的是使蛇持续移动，但在一定的帧速率内。我们将使用`pygame.time.Clock`来创建一个对象，它将跟踪我们游戏的时间。我们将使用`tick`函数来更新时钟。tick方法应该每帧调用一次。通过每帧调用`Clock.tick(15)`，游戏将永远不会以超过15
    FPS的速度运行。
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It is important to understand that FPS is not the same as the speed of a sprite
    in the game. Developers make games in such a way that they can be played on both
    high- and low-end devices. You would see that the game is a little sluggish and
    jerky in a low-featured machine, but sprites or characters in both devices will
    move at an average speed. We are not denying that machines that use time-based
    motion games with slow frame rates will have a less appealing visual experience,
    but it won't slow down the speed of the actions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解FPS并不等同于游戏中精灵的速度。开发者制作游戏的方式是可以在高端和低端设备上玩。你会发现在低配置的机器上游戏有点迟缓和抖动，但两种设备上的精灵或角色都会以平均速度移动。我们并不否认使用基于时间的运动游戏的机器，帧速率慢会导致视觉体验不佳，但它不会减慢动作的速度。
- en: Thus, to make a game that is visually appealing, and even compatible in pervasive
    devices, it is usually good practice to offer a frame rate of between 20 to 40
    FPS.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了制作一个视觉上吸引人的游戏，甚至在普及设备上也兼容，通常最好将帧速率设置在20到40 FPS之间。
- en: In the upcoming sections, we will handle the remaining directional movements.
    Handling these movements is no different; they can be handled by vectored motion.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将处理剩余的方向运动。处理这些运动并没有什么不同；它们可以通过矢量运动来处理。
- en: Handling directional movements
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理方向运动
- en: 'We have already handled movements for a change in the *x*-axis. Now, let''s
    add some code that will handle movements in the *y*-axis. To make continuous movements
    of the snake, we have to make `lead_y_change`, which represents the directional
    quantity that is added continuously to the current position, even if the user
    doesn''t press any keyboard keys:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经处理了*x*轴变化的运动。现在，让我们添加一些代码来处理*y*轴的运动。为了使蛇持续移动，我们必须使`lead_y_change`，它代表连续添加到当前位置的方向量，即使用户不按任何键盘键：
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that we have handled every possible movement for the snake, let''s define
    the boundary for the snake game. The values of `change_x` and `change_y` represent
    the current position of the head. If the head hits the boundary, the  game will
    be terminated:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了蛇的每种可能的运动，让我们为蛇游戏定义边界。`change_x`和`change_y`的值表示头部的当前位置。如果头部撞到边界，游戏将终止。
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we will learn about another concept of programming, that will make our
    code look cleaner. Until now, we have been using numerical values for many components,
    such as the height, width, FPS, and so on. But what happens if you have to change
    one of these values? There will be a lot of overheads in searching the code and
    debugging it again. Now, instead of using those numerical value directly, we can
    create constant variables, in which we store the values and retrieve them whenever
    they are needed. This process is called the *removal of hardcoding*. Let''s create
    a variable for each of these numeric values with an appropriate name. The code
    should look like something like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习另一个编程概念，这将使我们的代码看起来更清晰。到目前为止，我们已经为许多组件使用了数值，比如高度、宽度、FPS等。但是如果你必须更改其中一个这些值会发生什么？在搜索代码和再次调试时会有很多开销。现在，我们可以创建常量变量，而不是直接使用这些数值，我们将这些值存储在其中，并在需要时检索它们。这个过程叫做*去除硬编码*。让我们为每个这些数值创建一个合适的名称的变量。代码应该看起来像这样：
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After removing the hardcoding from the variable initialization steps, we will
    move onto the main game loop. The following code represents the main game loop
    (add it after the initialization step):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量初始化步骤中去除硬编码后，我们将转向主游戏循环。以下代码表示主游戏循环（在初始化步骤之后添加）：
- en: '[PRE30]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that we have added ways to handle user events inside the main loop, let''s
    refractor the code that represents logic, such as what happens when the snake
    hits boundary of game, or when the snake changes its speed. The following code
    should be added inside the main loop after handling the user events:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了处理用户事件的方法到主循环中，让我们重构代表逻辑的代码，比如当蛇撞到游戏边界时会发生什么，或者当蛇改变速度时会发生什么。在处理用户事件后，应该在主循环中添加以下代码：
- en: '[PRE31]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All of the preceding code has been described briefly already and what we actually
    did in the preceding three blocks of code is refract the variable to some meaningful
    names so as to remove hardcoding; for instance, adding a variable name to display
    the width, adding a variable name to the color code, and so on.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的所有代码已经简要描述过了，我们在前面的三个代码块中实际上是将变量重构为一些有意义的名称，以消除硬编码；例如，为显示宽度添加一个变量名，为颜色代码添加一个变量名，等等。
- en: In the following section, we are going to add a food character to the screen,
    and create some logic to check if the snake has eaten the apple or not.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将在屏幕上添加一个食物字符，并创建一些逻辑来检查蛇是否吃了苹果。
- en: Adding food to the game
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加食物到游戏中
- en: 'Adding a character to the screen is pretty simple. First of all, create a position
    for the character, and eventually, `blit` the character to that position. In the
    case of the snake game, the food must be rendered in the arbitrary position. Therefore,
    we will use a random module to create the random position. I have created a new
    function, `gameLoop()`, which will use the code from the preceding section. I
    have used `apple` as the food. Later, I will add an apple image to it. The following
    line of code defines the main loop for the game:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上添加一个字符非常简单。首先，为字符创建一个位置，最后，在该位置上`blit`字符。在蛇游戏中，食物必须在任意位置渲染。因此，我们将使用随机模块创建随机位置。我创建了一个新的函数`gameLoop()`，它将使用前面部分的代码。我使用`apple`作为食物。稍后，我将为它添加一个苹果图像。以下代码定义了游戏的主循环：
- en: '[PRE32]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After defining some initials for the game display and the characters, let''s
    add some logic to add the apples (food) for the snake game (this should be inside
    the `MainLoopForGame` function):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在为游戏显示和角色定义一些初始值之后，让我们添加一些逻辑来为蛇游戏添加苹果（食物）（这应该在`MainLoopForGame`函数内）。
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The two lines of code will create random positions for *x* and *y*. Make sure
    that you import the random module.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码将为*x*和*y*创建随机位置。确保导入随机模块。
- en: 'Next up, we need to define the main game loop inside the `MainLoopForGame`
    function. The code that is added inside the main loop will handle multiple things,
    such as handling user events, drawing game characters, and so on. Let''s start
    by getting the user events from the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在`MainLoopForGame`函数内定义主游戏循环。添加到主循环内的代码将处理多个事情，比如处理用户事件，绘制游戏角色等。让我们从以下代码中获取用户事件开始：
- en: '[PRE34]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code will be easy to grasp, as we did this earlier in this chapter.
    We start by filling background screen of the game with a white color, and then
    we get the event using the event class of the `pygame` module. We check if the
    user entered the `q` key, and if they did, then we quit the game. Similarly, now
    that we have an event from the user, let''s handle the events that make the movements
    for snake game—the arrow keys such as the left and right keys. The following code
    must be added after getting the user events:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将很容易理解，因为我们在本章的前面已经做过这个。我们首先用白色填充游戏的背景屏幕，然后使用`pygame`模块的事件类获取事件。我们检查用户是否输入了`q`键，如果是，我们就退出游戏。同样，既然我们从用户那里得到了一个事件，让我们处理使蛇游戏移动的事件，比如左右箭头键。在获取用户事件后，应该添加以下代码：
- en: '[PRE35]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code was already written, so make sure you follow the sequence
    of the program. Refer to the code asset that is provided at the [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter11](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter11).
    Let''s add the remaining code inside the main loop, which handles the logic to
    render the snake''s food. The following code should be added after handling the
    user events:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码已经编写好了，所以确保你按照程序的顺序进行。参考提供的代码资产[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter11](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter11)。让我们把剩下的代码添加到主循环中，处理渲染蛇食物的逻辑。在处理用户事件之后，应该添加以下代码：
- en: '[PRE36]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the highlighted part of the code, we will draw a rectangle that is red, and
    render it in the position that is defined by the random modules of the height
    and width of `pixel_size= 10`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的突出部分，我们将绘制一个红色的矩形，并将其渲染在由`pixel_size= 10`的高度和宽度的随机模块定义的位置。
- en: 'Now that we have added food for the snake, let''s make a function which that
    make the body of the snake. Up until now, we have only been working with the head
    of the snake; now, it''s time to make a function that will increase the snake''s
    body by unit blocks. Remember, this function is only going to be called if the
    snake eats the food:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为蛇添加了食物，让我们制作一个函数，使蛇的身体增长。到目前为止，我们只处理了蛇的头部；现在是时候制作一个函数，通过单位块来增加蛇的身体。请记住，只有在蛇吃了食物之后才会调用这个函数：
- en: '[PRE37]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Inside the main game loop, we have to declare multiple things. To begin with,
    we will declare `snakeArray`, which will contain the body of the snake. The snake
    length''s will be one at the beginning of the game. We will increase it whenever
    the snake eats the food:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在主游戏循环中，我们必须声明多个东西。首先，我们将声明`snakeArray`，它将包含蛇的身体。游戏开始时，蛇的长度为1。每当蛇吃食物时，我们将增加它：
- en: '[PRE38]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The name of the variable tells you everything that you need to know. We have
    done this many times previously, that is, making lists for the snake's head and
    checking if it collides with the snake's body. The snake method call takes `pixel_size`,
    which is the snake dimension, and the snake's list, which contains a list of positions
    that relate to the snake's body. The snake will be `blit`, according to these
    lists, by drawing statements that are defined inside the `snake` function.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的名称告诉你一切你需要知道的。我们以前做过很多次，也就是为蛇的头部制作列表，并检查它是否与蛇的身体发生碰撞。蛇方法调用`pixel_size`，这是蛇的尺寸，以及包含与蛇身体相关的位置列表的蛇列表。蛇将根据这些列表进行`blit`，通过在`snake`函数内定义的绘制语句。
- en: 'Next, we need to define the logic to make the snake eat the food. This logic
    has been repeatedly used, and it is no different in the case of pygame. Whenever
    the snake''s head position is the same as the food position, we will increase
    the length of the snake by one and generate food in a new, random position. Make
    sure that you add the following code inside the main game loop, after updating
    the display:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义逻辑来使蛇吃食物。这个逻辑已经被反复使用，在pygame的情况下也不例外。每当蛇的头部位置与食物位置相同时，我们将增加蛇的长度，并在一个新的随机位置生成食物。确保在更新显示后，在主游戏循环中添加以下代码：
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Since we are able to add some logic that will check if the snake has eaten the
    food or not, and respond accordingly, it's time to add a sprite or image to the
    characters. As we mentioned earlier, instead of using dull rectangular shapes,
    we are going to add our own snake head. Let's start creating one.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们能够添加一些逻辑来检查蛇是否吃了食物，并做出相应的反应，现在是时候为角色添加精灵或图像了。正如我们之前提到的，我们将添加我们自己的蛇头，而不是使用沉闷的矩形形状。让我们开始创建一个。
- en: Adding snake sprites
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加蛇的精灵
- en: Finally, we can start making our game more appealing—we are going to make the
    snake's head. We don't need any extra knowledge to create images for game characters.
    You can also download images from the internet and use them instead. However,
    here, I will show you how to create one for yourself, and how to use it in our
    snake game.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以开始使我们的游戏更具吸引力——我们将制作蛇的头。我们不需要额外的知识来为游戏角色创建图像。你也可以从互联网上下载图像并使用它们。然而，在这里，我将向你展示如何为自己创建一个，并如何在我们的蛇游戏中使用它。
- en: 'Follow these steps, line by line:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤，逐行进行：
- en: Open any *paint* application, or search paint in the search tab, and open the
    application.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开任何*绘图*应用程序，或者在搜索栏中搜索绘图，然后打开应用程序。
- en: 'Press *Ctrl* + *W* to resize and skew the picture that you have selected, or
    simply use the resize button on the upper menu bar. It will open a new resize
    window. Resizing can be done by percentage and pixels. Use percentage resize and
    maintain an aspect ratio of 20 by 20, that is, horizontal: 20 and vertical: 20.'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *W*来调整和扭曲你选择的图片，或者直接使用上方菜单栏的调整按钮。这将打开一个新的调整窗口。可以按百分比和像素进行调整。使用百分比调整并保持20x20的纵横比，即水平：20，垂直：20。
- en: 'After that, you will get a draw screen. Choose the color of the snake head
    that you want to make. While making the game, we created a snake body that was
    green; therefore, I will also choose green for the snake''s head. I will use a
    pen and draw something like the following image. You can take your time and create
    an even better one if you wish. After completing it, save the file:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你会得到一个绘制屏幕。选择你想要制作的蛇头的颜色。在制作游戏时，我们创建了一个绿色的蛇身体；因此，我也会选择绿色作为蛇头的颜色。我会使用画笔画出类似以下图片的东西。如果你愿意，你可以花时间创作一个更好的。完成后，保存文件：
- en: '![](Images/38c3a904-cd84-46db-9eb7-458cab37f736.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/38c3a904-cd84-46db-9eb7-458cab37f736.png)'
- en: Now, you have to make the background of the image transparent. You can use several
    online tools too, but I am going to use GIMP software, which we have talked about
    before. You have to download it from its official website. It is open source,
    and freely available to use. Go to the website and download GIMP: [https://www.gimp.org/downloads/](https://www.gimp.org/downloads/).
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你必须使图像的背景透明。你也可以使用一些在线工具，但我将使用之前提到过的GIMP软件。你必须从官方网站上下载它。它是开源的，可以免费使用。去网站上下载GIMP：[https://www.gimp.org/downloads/](https://www.gimp.org/downloads/)。
- en: Open your previously made snake head with the GIMP software. Go to the Layer
    tab from the upper-most menu, select Transparency, and click on Add alpha channel.
    This will add a channel, which can be used to make the background of our image
    transparent.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用GIMP软件打开你之前制作的蛇头。从最上面的菜单中选择图层选项卡，选择透明度，然后点击添加Alpha通道。这将添加一个通道，可以用来使我们图像的背景透明。
- en: Click on the Color tab from the menu screen. A drop-down menu will appear. Click
    on Color to Alpha to make the background transparent. Export that file in the
    same directory as where your Python file is stored.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单屏幕中点击颜色选项卡。将会出现一个下拉菜单。点击颜色到Alpha，使背景透明。将该文件导出到与您的Python文件存储在同一目录中。
- en: 'Now that we have a sprite of the snake head, let''s use it and render it using
    the `blit` command in the Python file. As you know, before using any image, you
    have to import it. Since I have saved the snake head image in the same directory
    where the Python file is saved, I can use the `pygame.image.load` command:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了蛇头的精灵，让我们在Python文件中使用`blit`命令来渲染它。如你所知，在使用任何图像之前，你必须导入它。由于我已经将蛇头图像保存在与Python文件相同的目录中，我可以使用`pygame.image.load`命令：
- en: '[PRE40]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Inside the body of the `drawSnake` method, you have to blit the image; something
    like this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在`drawSnake`方法的主体内，你必须blit图像；就像这样：
- en: '[PRE41]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, when you run the game, you will observe one strange thing. As we press
    any one arrow key, the head won''t rotate accordingly. It will remain in its default
    position. Thus, in order to make the sprite rotate, based on the directional movements,
    we have to use the `transform.rotate` function. Observe the snake method, as it
    has a way to `blit` images without rotation. Now, we will add couple of lines
    of code that will make the sprites rotate:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行游戏时，你会观察到一个奇怪的事情。当我们按下任何一个箭头键时，头部不会相应地旋转。它将保持在默认位置。因此，为了使精灵根据方向的移动而旋转，我们必须使用`transform.rotate`函数。观察蛇的方法，因为它有一种方法可以在没有旋转的情况下`blit`图像。现在，我们将添加几行代码，使精灵旋转：
- en: '[PRE42]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, instead of using a rectangular box for the apple, let me download a sample
    of an apple from internet, in the form of a PNG (transparent background), and
    `blit` that, too:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不再使用苹果的矩形框，让我从互联网上下载一个苹果的样本，以PNG的形式（透明背景），也`blit`它：
- en: '[PRE43]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s run the game and observe the output. Although the snake head looks bigger,
    we can always resize it:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行游戏并观察输出。虽然蛇头看起来更大了，但我们可以随时调整它的大小：
- en: '![](Images/ade1f80d-3bf7-4b01-84e0-f80900e83a5f.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ade1f80d-3bf7-4b01-84e0-f80900e83a5f.png)'
- en: In the next section, we will learn how to add a menu to our game. The menu is
    a screen that is seen whenever you open a game, and it is generally a welcome
    screen.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何为我们的游戏添加一个菜单。菜单是每次打开游戏时看到的屏幕，通常是一个欢迎屏幕。
- en: Adding a menu to the game
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为游戏添加一个菜单
- en: 'Adding an introductory screen to any game requires us to have the knowledge
    of working with fonts using the `pygame` module. pygame provides a feature so
    that we can use different types of fonts, including a feature to change the size
    of them. The `pygame.font` module is used to add fonts to games. Fonts are used
    to add text to the game screen. Since the intro or welcome screen requires a player
    to show a screen containing fonts, we have to use this module. The `SysFont` method
    is called to add a font to the screen. The `SysFont` method takes two arguments:
    the first is the name of the font, and the second one is size of the font. The
    following line of code initializes three different sizes of the same font:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为任何游戏添加一个介绍屏幕需要我们具备使用`pygame`模块处理字体的知识。pygame提供了一个功能，使我们可以使用不同类型的字体，包括改变它们的大小的功能。`pygame.font`模块用于向游戏添加字体。字体用于向游戏屏幕添加文本。由于介绍或欢迎屏幕需要玩家显示一个包含字体的屏幕，我们必须使用这个模块。调用`SysFont`方法向屏幕添加字体。`SysFont`方法接受两个参数：第一个是字体的名称，第二个是字体的大小。以下一行代码初始化了相同字体的三种不同大小：
- en: '[PRE44]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will use the `text_object` function first in order to create a surface for
    the small, medium, and large fonts. The text object function will create a rectangular
    surface using the text. The text that is passed to this method is added to the
    box-shaped object and is returned from it, as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用`text_object`函数创建一个表面，用于小号、中号和大号字体。文本对象函数将使用文本创建一个矩形表面。传递给此方法的文本将添加到框形对象中，并从中返回，如下所示：
- en: '[PRE45]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s create a new function in the Python file, which will add a message to
    the screen using the aforementioned fonts:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python文件中创建一个新的函数，使用上述字体向屏幕添加一条消息：
- en: '[PRE46]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The message to the `screen` method will create a rectangular surface to `blit`
    the text that is passed as a `msg` to it. The default font size is small, and
    the text is aligned at the center of the rectangular surface. Now, let''s create
    a game intro method for our game:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 向`screen`方法传递的消息将创建一个矩形表面，以`blit`传递给它的文本作为`msg`。默认字体大小是小号，文本居中对齐在矩形表面的中心。现在，让我们为我们的游戏创建一个游戏介绍方法：
- en: '[PRE47]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This game `intro` method is called before the game `loop` method call. For
    example, look at the following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个游戏的`intro`方法在游戏`loop`方法调用之前被调用。例如，看看下面的代码：
- en: '[PRE48]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, the output of the welcome menu should look like this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，欢迎菜单的输出应该是这样的：
- en: '![](Images/6fb16dc8-2ad6-4d90-bfc6-9ef51d3d3be5.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6fb16dc8-2ad6-4d90-bfc6-9ef51d3d3be5.png)'
- en: Finally, our game is ready to be distributed. You might see that our game is
    a Python file with the extension of `.py`, and it cannot be executed in a machine
    that doesn't have Python installed. Thus, in the next section, we will learn how
    to convert a Python file into executables so that we can distribute our game globally
    on Windows machines.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的游戏已经准备好分发了。你可能会看到我们的游戏是一个扩展名为`.py`的Python文件，它不能在没有安装Python的机器上执行。因此，在下一节中，我们将学习如何将Python文件转换为可执行文件，以便我们可以在Windows机器上全球分发我们的游戏。
- en: Converting into executables
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换为可执行文件
- en: If you have got to the point of making your own game with pygame, it's obvious
    that you would like to share it with your friends and family. In the world of
    the internet, sharing a file is pretty easy, but problems arise when a user on
    the other side doesn't have Python preinstalled. It is not possible for everybody
    to install Python for the sole purpose of testing your game. A better idea is
    to make executables that can be executed on many of these machines. We will learn
    how to convert into `.exe` in this section—other versions (Linux and Mac) will
    be covered in the upcoming chapters.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经制作了自己的pygame游戏，显然您希望与朋友和家人分享。在互联网世界中，共享文件非常容易，但当另一端的用户没有预安装Python时，问题就会出现。不是每个人都能为了测试您的游戏而安装Python。更好的想法是制作可在许多这些机器上执行的可执行文件。我们将在本节中学习如何转换为`.exe`，其他版本（Linux和Mac）将在接下来的章节中介绍。
- en: The conversion of Python files into executables is easier if you use the modules
    that are provided by Python. There are a couple of them—`them—py2exe` and `cx_Freeze`.
    We will use the first one in this section.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用Python提供的模块，将Python文件转换为可执行文件会更容易。其中有几个模块——`py2exe`和`cx_Freeze`。我们将在本节中使用第一个。
- en: Using py2exe
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用py2exe
- en: 'To convert Python files into executables, we can use another Python module,
    which is named `py2exe`. The `py2exe` module is not preinstalled in pygame—it''s not
    a standard library—but it can be downloaded by using the following command:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Python文件转换为可执行文件，我们可以使用另一个名为`py2exe`的Python模块。`py2exe`模块不是pygame中预安装的——它不是标准库——但可以通过使用以下命令进行下载：
- en: '[PRE49]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After downloading the `py2exe` module, navigate to the folder that contains
    your Python file. Open a Command Prompt or Terminal in that position and run code..
    It will package your Python file into an `.exe` file, or into executables. The
    following command will search for and copy all the files that are used by the
    script to a folder called `dist`. Inside `dist` will be a `snake.exe` file; this
    file will be the output simulation of the Python code, which can be executed without
    Python being installed on the machine. For example, your friend might not have
    installed Python on their machine, but he or she can still run this file. In order
    to distribute the games to any other Windows machine, you can simply send the
    content of the `dist` folder or `snake.exe` file. Just run the following command:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 下载`py2exe`模块后，转到包含您的Python文件的文件夹。在该位置打开命令提示符或终端并运行代码。它将把您的Python文件打包成一个`.exe`文件，或者成为可执行文件。以下命令将搜索并复制脚本使用的所有文件到一个名为`dist`的文件夹中。在`dist`中将会有一个`snake.exe`文件；这个文件将是Python代码的输出模拟，可以在没有安装Python的机器上执行。例如，您的朋友可能没有在他们的机器上安装Python，但他们仍然可以运行这个文件。为了将游戏分发到任何其他Windows机器，您只需发送`dist`文件夹或`snake.exe`文件的内容。只需运行以下命令：
- en: '[PRE50]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This will create your game with the name, *snake* and an extension of `.exe`.
    You can distribute these files across Windows platforms and get a response from
    them. Congratulations! You have finally made it. Now, let's learn about game testing
    using pygame.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为*snake*的游戏，并带有`.exe`的扩展名。您可以在Windows平台上分发这些文件并从中获得响应。恭喜！你终于做到了。现在，让我们学习使用pygame进行游戏测试。
- en: Game testing and possible modifications
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏测试和可能的修改
- en: Sometimes, there may be a case of memory shortage in your machine. If you run
    out of memory and you try to load more images into the game, even with pygame's
    best efforts, this process will be aborted. `pygame.image.load` must be accompanied
    by some memory in order to perform tasks properly. In the case of memory shortages,
    you can predict that you are surely going to trigger some kind of exception. And
    even if there is enough memory, if you try to load an image that is not in your
    hard drive, or say, you made a typo when writing the name of the file, you are
    likely to get an exception. Therefore, it's better to handle them beforehand so
    that we won't have the trouble of debugging them afterward.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您的机器可能会出现内存不足的情况。如果内存不足，并且您尝试将更多图像加载到游戏中，即使使用了pygame的最大努力，此过程也将被中止。`pygame.image.load`必须伴随一些内存才能正常执行任务。在内存不足的情况下，您可以预测到肯定会触发某种异常。即使有足够的内存，如果尝试加载不在硬盘驱动器中的图像，或者说，在编写文件名时出现了拼写错误，您可能会收到异常。因此，最好事先处理它们，这样我们就不必事后再去调试它们。
- en: 'Secondly, let''s check what happens when we provide unusual dimensions of the
    screen to the `set_mode` method. Recall that `set_mode`, is a method that we use
    to create a `Surface` object. For instance, let''s say we forget to add two values
    to `set_mode` and we carried on adding only one. We are going to trigger an error
    in such cases, too:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，让我们检查当我们向`set_mode`方法提供不寻常的屏幕尺寸时会发生什么。回想一下，`set_mode`是我们用来创建`Surface`对象的方法。例如，假设我们忘记向`set_mode`添加两个值，而只添加了一个。在这种情况下，我们也会触发错误：
- en: '[PRE51]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s say that, instead of forgetting to add proper dimensions for the height
    and width, what happens if we add a height value of 0? This problem does not create
    any exception in the case of PyCharm IDE. Instead, the program will run infinitely,
    causing your machine to break down. However, these programs will normally throw
    an exception of `pygame.error: cannot set 0 sized display`. Now that you know
    the areas where `pygame` could go wrong, you can catch those exceptions and handle
    them accordingly:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '假设，与其忘记为高度和宽度添加适当的尺寸，如果我们将高度值添加为0会发生什么？在PyCharm IDE的情况下，这个问题不会创建任何异常。相反，程序将无限运行，导致您的机器崩溃。然而，这些程序通常会抛出一个`pygame.error:
    cannot set 0 sized display`的异常。现在您知道了`pygame`可能出错的地方，可以捕获这些异常并相应地处理它们：'
- en: '[PRE52]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: So, it's better to choose your display screen sensibly in order to remove any
    unwanted exceptions. But, more likely, you can get the exception of the `pygame`
    error if you try to load an image that is not in your hard drive. Thus, it's good
    practice to handle the exceptions so that the sprites or images for the game are
    loaded properly .
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好明智地选择您的显示屏，以消除任何不必要的异常。但更有可能的是，如果您尝试加载不在硬盘上的图像，您可能会遇到`pygame`错误的异常。因此，处理异常是一个很好的做法，以确保游戏的精灵或图像被正确加载。
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at the `pygame` module and discovered the reasons
    for using it in game development. Most of the games that we are covering from
    the next chapter onwards will be somehow based on the `pygame` module. Thus, make
    sure that you make one simple game using pygame by yourself, before moving on.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了`pygame`模块，并发现了在游戏开发中使用它的原因。我们从下一章开始涵盖的大多数游戏都将在某种程度上基于`pygame`模块。因此，在继续之前，请确保自己使用pygame制作一个简单的游戏。
- en: We began by learning about how to use pygame objects to make games. We learned
    various things, including handling user key events that involve input devices
    such as the mouse and the keyboard; we made a sprite animation; we learned about
    color properties; and we handled different diagonal and directional movements
    using vectored motion. We have created our own sprites using a simple paint application,
    and added alpha properties using the GIMP application. We tried to make a game
    more interactive by incorporating an interactive game screens, that is, the menu
    screen. Finally, we learned how to convert Python files into executables using
    `py2exe` modules.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始学习如何使用pygame对象制作游戏。我们学到了各种东西，包括处理涉及鼠标和键盘等输入设备的用户按键事件；我们制作了精灵动画；我们学习了颜色属性；并且使用向量运动处理了不同的对角线和方向性移动。我们使用简单的绘图应用程序创建了自己的精灵，并使用GIMP应用程序添加了alpha属性。我们尝试通过整合交互式游戏屏幕，也就是菜单屏幕，使游戏更具互动性。最后，我们学会了如何使用`py2exe`模块将Python文件转换为可执行文件。
- en: The main goal of this chapter was to make you familiar with the usage of sprites
    so that you can build 2D games. You have also learned how to handle user events
    and different movements, including diagonal movements. You also learned how to
    create custom sprites and images using external software, and also the ways of
    using them in the game. Not only that, but you were made familiar with the concepts
    of color and `rect` objects, and learned how to use them to make games more user-interactive,
    by deploying menu and score screens.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是让您熟悉精灵的使用，以便您可以制作2D游戏。您还学会了如何处理用户事件和不同的移动，包括对角线移动。您还学会了如何使用外部软件创建自定义精灵和图像，以及在游戏中使用它们的方法。不仅如此，您还熟悉了颜色和`rect`对象的概念，并学会了如何使用它们使游戏更具用户互动性，通过部署菜单和得分屏幕。
- en: In the next chapter, we are going to use the concepts that we have learned in
    this chapter to make our own flappy bird clone. In addition to whatever we have
    learned in this chapter, we will learn about game animation, character animation,
    collision principles, random object generation, adding scores, and many more concepts.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将运用本章学到的概念制作自己的flappy bird克隆游戏。除了本章学到的内容，我们还将学习游戏动画、角色动画、碰撞原理、随机对象生成、添加分数等许多概念。
