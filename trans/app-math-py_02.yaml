- en: Mathematical Plotting with Matplotlib
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Matplotlib进行数学绘图
- en: Plotting is a fundamental tool in all of mathematics. A good plot can reveal
    hidden details, suggest future directions, verify results, or reinforce an argument.
    It is no surprise, then, that the scientific Python stack features a powerful
    and flexible plotting library called Matplotlib.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图是数学中的基本工具。一个好的图可以揭示隐藏的细节，建议未来的方向，验证结果或加强论点。因此，科学Python堆栈中拥有一个名为Matplotlib的强大而灵活的绘图库并不奇怪。
- en: In this chapter, we will plot functions and data in a variety of styles and
    create figures that are fully labeled and annotated. We will create three-dimensional
    plots, customize the appearance of figures, create figures that contain multiple
    plots using subplots, and save figures directly to files for applications that
    are not running in an interactive environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将以各种样式绘制函数和数据，并创建完全标记和注释的图。我们将创建三维图，自定义图的外观，使用子图创建包含多个图的图，并直接将图保存到文件中，以供在非交互式环境中运行的应用程序使用。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下示例：
- en: Basic plotting with Matplotlib
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Matplotlib进行基本绘图
- en: Changing the plotting style
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改绘图样式
- en: Adding labels and legends to plots
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为绘图添加标签和图例
- en: Adding subplots
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加子图
- en: Saving Matplotlib figures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存Matplotlib图
- en: Surface and contour plots
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表面和等高线图
- en: Customizing three-dimensional plots
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义三维图
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The main plotting package for Python is Matplotlib, which can be installed
    using your favorite package manager, such as `pip`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python的主要绘图包是Matplotlib，可以使用您喜欢的软件包管理器（如`pip`）进行安装：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will install the most recent version of Matplotlib, which, at the time
    of writing this book, is version 3.2.1.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装最新版本的Matplotlib，在撰写本书时，最新版本是3.2.1。
- en: 'Matplotlib contains numerous sub-packages, but the main user interface is the
    `matplotlib.pyplot`package, which, by convention, is imported under the `plt`alias.
    This is achieved using the following import statement:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib包含许多子包，但主要用户界面是`matplotlib.pyplot`包，按照惯例，它被导入为`plt`别名。可以使用以下导入语句来实现这一点：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Many of the recipes in this chapter also require NumPy, which, as usual, is
    imported under the `np`alias.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多示例还需要NumPy，通常情况下，它被导入为`np`别名。
- en: The code for this chapter can be found in the `Chapter 02` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2002](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2002).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub存储库的`Chapter 02`文件夹中找到，网址为[https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2002](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2002)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2ZOSuhs](https://bit.ly/2ZOSuhs).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码实际操作：[https://bit.ly/2ZOSuhs](https://bit.ly/2ZOSuhs)。
- en: Basic plotting with Matplotlib
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Matplotlib进行基本绘图
- en: Plotting is an important part of understanding behavior. So much can be learned
    by simply plotting a function or data that would otherwise be hidden. In this
    recipe, we will walk through how to plot a simple function or data using Matplotlib.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图是理解行为的重要部分。通过简单地绘制函数或数据，可以学到很多原本隐藏的东西。在这个示例中，我们将介绍如何使用Matplotlib绘制简单的函数或数据。
- en: Matplotlib is a very powerful plotting library, which means it can be rather
    intimidating to perform simple tasks with it. For users who are used to working
    with MATLAB and other mathematical software packages, there is a state-based interface
    called `pyplot`. There is also an object-orientated interface, which might be
    more appropriate for more complex plots. The `pyplot` interface is a convenient
    way to create basic objects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib是一个非常强大的绘图库，这意味着用它执行简单任务可能会令人畏惧。对于习惯于使用MATLAB和其他数学软件包的用户，有一个称为`pyplot`的基于状态的接口。还有一个面向对象的接口，对于更复杂的绘图可能更合适。`pyplot`接口是创建基本对象的便捷方式。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Most commonly, the data that you wish to plot will be stored in two separate
    NumPy arrays, which we will label `x`and `y`for clarity (although this naming
    does not matter in practice). We will demonstrate plotting the graph of a function,
    so we will generate an array of `x` values and use the function to generate the
    corresponding `y` values. We define the function that we will plot as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，要绘制的数据将存储在两个单独的NumPy数组中，我们将为了清晰起见将它们标记为`x`和`y`（尽管在实践中这个命名并不重要）。我们将演示绘制函数的图形，因此我们将生成一组`x`值的数组，并使用函数生成相应的`y`值。我们定义将要绘制的函数如下：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'Before we can plot the function, we must generate the `x` and `y` data to be
    plotted. If you are plotting existing data, you can skip these commands. We need
    to create a set of the `x` values that cover the desired range, and then use the
    function to create the `y` values:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们绘制函数之前，我们必须生成要绘制的`x`和`y`数据。如果要绘制现有数据，可以跳过这些命令。我们需要创建一组覆盖所需范围的`x`值，然后使用函数创建`y`值：
- en: 'The `linspace` routine from NumPy is ideal for creating arrays of numbers for
    plotting. By default, it will create 50 equally spaced points between the specified
    arguments. The number of points can be customized by providing an additional argument,
    but 50 is sufficient for most cases:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy中的`linspace`例程非常适合创建用于绘图的数字数组。默认情况下，它将在指定参数之间创建50个等间距点。可以通过提供额外的参数来自定义点的数量，但对于大多数情况来说，50就足够了。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we have created the `x` values, we can generate the `y` values:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们创建了`x`值，就可以生成`y`值：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To plot the data, we simply need to call the `plot` function from the `pyplot`
    interface, which is imported under the `plt` alias. The first argument is the
    `x`*data and the second is the `y` data. The function returns a handle to the
    axes object on which the data is plotted:*
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要绘制数据，我们只需要从`pyplot`接口调用`plot`函数，该接口被导入为`plt`别名。第一个参数是`x`数据，第二个是`y`数据。该函数返回一个用于绘制数据的轴对象的句柄：
- en: '*[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE5]'
- en: 'This will plot the `y` values against the `x` values on a new figure. If you
    are working within IPython or with a Jupyter notebook, then the plot should automatically
    appear at this point; otherwise, you might need to call the `plt.show` function
    to make the plot appear:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在新的图形上绘制`y`值与`x`值。如果你在IPython中工作或者使用Jupyter笔记本，那么图形应该会自动出现；否则，你可能需要调用`plt.show`函数来使图形出现：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you use `plt.show`, the figure should appear in a new window. The resulting
    plot should look something like the plot in *Figure 2.1*. The default plot color
    might be different on your plot. It has been changed for high visibility for this
    book:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`plt.show`，图形应该会出现在一个新窗口中。生成的图形应该看起来像*图2.1*中的图形。你的默认绘图颜色可能与你的绘图不同。这是为了增加可见性而更改的默认绘图颜色：
- en: '![](assets/c3c939df-e3cf-44f2-b35b-897b2b5ba75a.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c3c939df-e3cf-44f2-b35b-897b2b5ba75a.png)'
- en: 'Figure 2.1: Plot of a function produced using Matplotlib without any additional
    styling parameters'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：使用Matplotlib绘制的函数的图形，没有任何额外的样式参数
- en: We won't add this command to any further recipes in this chapter, but you should
    be aware that you will need to use it if you are not working in an environment
    where plots will be rendered automatically, such as an IPython console or Jupyter
    Notebook.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本章的其他配方中添加这个命令，但是你应该知道，如果你不是在自动渲染图形的环境中工作，比如在IPython控制台或Jupyter Notebook中，你将需要使用它。
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: If there are currently no `Figure` or `Axes` objects, the `plt.plot` routine
    creates a new `Figure` object, adds a new `Axes` object to the figure, and populates
    this `Axes` object with the plotted data. A list of handles to the plotted lines
    is returned. Each of these handles is a `Lines2D` object. In this case, this list
    will contain a single `Lines2D` object. We can use this `Lines2D` object to customize
    the appearance of the line later (see the *Changing the plotting style* recipe).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前没有`Figure`或`Axes`对象，`plt.plot`例程会创建一个新的`Figure`对象，向图形添加一个新的`Axes`对象，并用绘制的数据填充这个`Axes`对象。返回一个指向绘制线的句柄列表。每个句柄都是一个`Lines2D`对象。在这种情况下，这个列表将包含一个单独的`Lines2D`对象。我们可以使用这个`Lines2D`对象稍后自定义线的外观（参见*更改绘图样式*配方）。
- en: The object layer of Matplotlib interacts with a lower-level *backend*, which
    does the heavy lifting of producing the graphical plot. The `plt.show` function
    issues an instruction to the backend to render the current figure. There are a
    number of backends that can be used with Matplotlib, which can be customized by
    setting the `MPLBACKEND` environment variable, modifying the `matplotlibrc` file,
    or by calling `matplotlib.use` from within Python with the name of an alternative
    backend.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib的对象层与较低级别的*后端*进行交互，后端负责生成图形绘图的繁重工作。`plt.show`函数发出指令给后端来渲染当前的图形。Matplotlib可以使用多个后端，可以通过设置`MPLBACKEND`环境变量、修改`matplotlibrc`文件，或者在Python中调用`matplotlib.use`并指定替代后端的名称来自定义。
- en: The `plt.show` function does more than simply call the `show` method on a figure.
    It also hooks into an event loop to correctly display the figure. The `plt.show`
    routine should be used to display a figure, rather than the `show` method on a
    `Figure` object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`plt.show`函数不仅仅是在图形上调用`show`方法。它还连接到一个事件循环，以正确显示图形。应该使用`plt.show`例程来显示图形，而不是在`Figure`对象上调用`show`方法。'
- en: There's more...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It is sometimes useful to manually instantiate a `Figure` object prior to calling
    the `plot` routine—for instance, to force the creation of a new figure. The code
    in this recipe could instead have been written as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候在调用`plot`例程之前手动实例化一个`Figure`对象是有用的，例如，强制创建一个新的图形。这个配方中的代码也可以写成如下形式：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `plt.plot` routine accepts a variable number of positional inputs. In the
    preceding code, we supplied two positional arguments that were interpreted as
    `x` values and `y` values (in that order). If we had instead provided only a single
    array, the `plot` routine would have plotted the values against their position
    in the array; that is, the `x` values are taken to be `0`, `1`, `2`, and so on.
    We could also supply multiple pairs of arrays to plot several sets of data on
    the same axes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`plt.plot`例程接受可变数量的位置输入。在前面的代码中，我们提供了两个位置参数，它们被解释为`x`值和`y`值（按顺序）。如果我们只提供了一个单一的数组，`plot`例程会根据数组中的位置绘制数值；也就是说，`x`值被视为`0`、`1`、`2`等等。我们还可以提供多对数组来在同一坐标轴上绘制多组数据：'
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![](assets/c6e0b680-a648-4082-bbf0-b7d40a1635c6.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c6e0b680-a648-4082-bbf0-b7d40a1635c6.png)'
- en: 'Figure 2.2: Multiple plots on a single figure, produced using a single call
    to the plot routine in Matplotlib'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：在Matplotlib中使用一次调用plot例程产生单个图形上的多个图形
- en: 'It is occasionally useful to create a new figure and explicitly create a new
    set of axes in this figure together. The best way to accomplish this is to use
    the `subplots` routine in the `pyplot` interface (refer to the *Adding subplots*
    recipe). This routine returns a pair, where the first object is `Figure` and the
    second is an `Axes` object:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候需要创建一个新的图形，并在该图形中显式地创建一组新的坐标轴。实现这一目标的最佳方法是使用`pyplot`接口中的`subplots`例程（参见*添加子图*配方）。这个例程返回一对对象，第一个对象是`Figure`，第二个对象是`Axes`：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This sequence of commands produces the same plot as the preceding one displayed
    in *Figure 2.2*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这一系列命令产生了与前面显示的*图2.2*中相同的图形。
- en: Matplotlib has many other plotting routines besides the `plot` routine described
    here. For example, there are plotting methods that use a different scale for the
    axes, including the logarithmic *x* or *y* axes separately (`semilogx` or `semilogy`,
    respectively) or together (`loglog`). These are explained in the Matplotlib documentation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib除了这里描述的`plot`例程之外，还有许多其他绘图例程。例如，有一些绘图方法使用不同的比例尺来绘制坐标轴，包括分别使用对数*x*轴或对数*y*轴（`semilogx`或`semilogy`）或同时使用（`loglog`）。这些在Matplotlib文档中有解释。
- en: Changing the plotting style
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改绘图样式
- en: The basic style of Matplotlib plots is fine for plotting functions or data that
    is ordered, but it is less appropriate for plotting discrete data that is not
    presented in any order. To prevent Matplotlib from drawing lines between each
    data point, we can change the plotting style to "turn off" the line drawing. In
    this recipe, we will customize the plotting style for each line on the axes by
    adding a format string argument to the `plot` method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib绘图的基本样式适用于绘制有序的函数或数据，但对于不按任何顺序呈现的离散数据来说，这种样式就不太合适了。为了防止Matplotlib在每个数据点之间绘制线条，我们可以将绘图样式更改为“关闭”线条绘制。在这个示例中，我们将通过向`plot`方法添加格式字符串参数来为坐标轴上的每条线自定义绘图样式。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need to have your data stored in pairs of arrays. For the purposes
    of this demonstration, we will define the following data:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将数据存储在数组对中。为了演示目的，我们将定义以下数据：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will plot these points against their position in the array (that is, the
    *x* coordinate will be `0`, `1`, `2`, `3`, or `4`, respectively, for each array).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据数组中的位置（即*x*坐标将分别为`0`、`1`、`2`、`3`或`4`）绘制这些点。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: The easiest way to control the style of a plot is to use a **format string**,
    which is provided as an optional argument after the *x-y* pair or the `y`*data
    in the `plot` command. When plotting multiple sets of data, a different format
    string can be provided for each set of arguments. The following steps give a general
    procedure for creating a new figure and plotting data on this figure:*
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 控制绘图样式的最简单方法是使用**格式字符串**，它作为`plot`命令中*x-y*对或`plot`命令中的`y`*data后的可选参数提供。在绘制多组数据时，可以为每组参数提供不同的格式字符串。以下步骤提供了创建新图并在该图上绘制数据的一般过程：*
- en: '*1.  We first create the `Figure` and `Axes` objects explicitly using the `subplots`
    routine from `pyplot`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*1. 我们首先使用`pyplot`中的`subplots`例程显式创建`Figure`和`Axes`对象：'
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we have created the `Figure` and `Axes` objects, we can plot the data
    using the `plot` method on the `Axes` object. This method takes the same arguments
    as the `plot` routine from `pyplot`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`Figure`和`Axes`对象，可以使用`Axes`对象上的`plot`方法绘制数据。这个方法接受与`pyplot`中的`plot`例程相同的参数：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This plots the first dataset (`y1`) with a circle marker, the second (`y2`)
    with an `x` marker, and the third (`y3`) with a star (`*`) marker. The output
    of this command is shown in *Figure 2.3*. The format string can specify a number
    of different marker lines and color styles. The same applies if we instead used
    the plot routine from the `pyplot` interface, which has the same calling signature
    as the `plot` method:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用圆圈标记绘制第一个数据集（`y1`），使用`x`标记绘制第二个数据集（`y2`），使用星号（`*`）标记绘制第三个数据集（`y3`）。这个命令的输出显示在*图2.3*中。格式字符串可以指定多种不同的标记线和颜色样式。如果我们改为使用`pyplot`接口中的`plot`例程，其调用签名与`plot`方法相同，也是一样的。
- en: '![](assets/a98c28e3-2c76-4e50-87ac-079979b9bd71.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a98c28e3-2c76-4e50-87ac-079979b9bd71.png)'
- en: 'Figure 2.3: Plot of three sets of data, each plotted using a different marker
    style'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：绘制三组数据，每组数据使用不同的标记样式绘制
- en: How it works...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The format string has three optional parts, each consisting of one or more
    characters. The first part controls the marker style, which is the symbol that
    is printed at each data point; the second controls the style of the line that
    connects the data points; and the third controls the color of the plot. In this
    recipe, we onlyspecified the marker style, which means that no connecting line
    is drawn between adjacent data points. This is useful for plotting discrete data
    where no interpolation between points is necessary. Four line style parameters
    are available: a solid line (`-`); a dashed line (`--`); a dash-dot line (`-.`);
    or a dotted line (`:`). Only a limited number of colors can be specified in the
    format string; they are red, green, blue, cyan, yellow, magenta, black, and white.
    The character used in the format string is the first letter of each color (with
    the exception of black), so the corresponding characters are`r`, `g`, `b`, `c`,
    `y`,`m`, `k`, and `w`, respectively.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串有三个可选部分，每个部分由一个或多个字符组成。第一部分控制标记样式，即打印在每个数据点处的符号；第二部分控制连接数据点的线条样式；第三部分控制绘图的颜色。在这个示例中，我们只指定了标记样式，这意味着在相邻数据点之间不会绘制连接线。这对于绘制不需要在点之间进行插值的离散数据非常有用。有四种线条样式参数可用：实线（`-`）；虚线（`--`）；点划线（`-.`）；或点线（`:`）。格式字符串中只能指定有限数量的颜色；它们是红色、绿色、蓝色、青色、黄色、品红色、黑色和白色。格式字符串中使用的字符是每种颜色的第一个字母（黑色除外），因此相应的字符分别是`r`、`g`、`b`、`c`、`y`、`m`、`k`和`w`。
- en: For example, if we want to change the marker style only, as we did in this recipe,
    to a plus character, we would use the `"+"`format string. If we also want to change
    the line style to a dash-dot line, we would use the `"+-."`format string. Finally,
    if we also wish to change the color of the marker to red, we would use the `"+-.r"`format
    string. These specifiers can also be provided in other configurations, such as
    specifying the color before the marker style, but this might lead to ambiguities
    in the way Matplotlib parses the format string.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们只想更改标记样式，就像在这个示例中所做的那样，改为加号字符，我们将使用`"+"`格式字符串。如果我们还想将线条样式更改为点划线，我们将使用`"+-."`格式字符串。最后，如果我们还希望将标记的颜色更改为红色，我们将使用`"+-.r"`格式字符串。这些指定符也可以以其他配置提供，例如在标记样式之前指定颜色，但这可能会导致Matplotlib解析格式字符串的方式存在歧义。
- en: If you are using a Jupyter notebook and the `subplots` command, you must include
    the call to `subplots` within the same cell as the plotting commands or the figure
    will not be produced.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Jupyter笔记本和`subplots`命令，则必须在与绘图命令相同的单元格中包含对`subplots`的调用，否则图形将不会被生成。
- en: There's more...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `plot` method also accepts a number of keyword arguments that can also be
    used to control the style of a plot. Keyword arguments take precedence over format
    string parameters if both are present, and they apply to all sets of data plotted
    by the call. The keyword to control the marker style is `marker`, the keyword
    for the line style is `linestyle`, and the keyword for color is `color`. The `color`
    keyword argument accepts a number of different formats to specify a color, which
    includes RGB values as a `(r, g, b)`tuple, where each character is a float between
    `0` and `1` or is a hex string. The width of the line plotted can be controlled
    using the `linewidth`keyword, which should be provided with a`float` value. There
    are many other keyword arguments that can be passed to `plot`; a list is given
    in the Matplotlib documentation. Many of these keyword arguments have a shorter
    version, such as `c` for `color` and `lw` for `linewidth`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot`方法还接受许多关键字参数，这些参数也可以用于控制图的样式。如果同时存在关键字参数和格式字符串参数，则关键字参数优先，并且它们适用于调用绘制的所有数据集。控制标记样式的关键字是`marker`，线型的关键字是`linestyle`，颜色的关键字是`color`。`color`关键字参数接受许多不同的格式来指定颜色，其中包括RGB值作为`(r,
    g, b)`元组，其中每个字符都是`0`到`1`之间的浮点数，或者是十六进制字符串。可以使用`linewidth`关键字控制绘制的线的宽度，应该提供一个`float`值。`plot`还可以传递许多其他关键字参数；在Matplotlib文档中列出了一个列表。这些关键字参数中的许多都有较短的版本，例如`c`代表`color`，`lw`代表`linewidth`。'
- en: 'For example, we could set the color of all of the markers in the recipe by
    using the `color` keyword argument in the call to `plot` using the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用以下命令通过在调用`plot`时使用`color`关键字参数来设置配方中所有标记的颜色：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Line2D` objects returned from calls to the `plot` method (or the `plt.plot`
    routine) can also be used to customize the appearance of each set of data. For
    example, the `set_linestyle` method in a `Line2D` object can be used, with the
    appropriate line style format string, to set the line style.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从对`plot`方法（或`plt.plot`例程）的调用返回的`Line2D`对象也可以用于自定义每组数据的外观。例如，可以使用`Line2D`对象中的`set_linestyle`方法，使用适当的线型格式字符串设置线型。
- en: Other aspects of the plot can be customized by using methods on the `Axes` object.
    The axes ticks can be modified using the `set_xticks` and `set_yticks` methods
    on the `Axes` object, and the grid appearance can be configured using the `grid`
    method. There are also convenient methods in the `pyplot` interface that apply
    these modifications to the current axes (if they exist).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`Axes`对象上的方法自定义图的其他方面。可以使用`Axes`对象上的`set_xticks`和`set_yticks`方法修改坐标轴刻度，可以使用`grid`方法配置网格外观。`pyplot`接口中还有方便的方法，可以将这些修改应用于当前坐标轴（如果存在）。
- en: 'For example, we modify the axis limits, set the ticks at every multiple of
    `0.5` in both the *x* and *y* direction, and add a grid to the plot by using the
    following commands:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们修改轴限制，在*x*和*y*方向上的每个`0.5`的倍数设置刻度，并通过以下命令向图添加网格：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice how we set the limits slightly larger than the extent of the plot. This
    is to avoid markers being placed on the boundary of the plot window.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们将限制设置为略大于图的范围。这是为了避免标记放在图窗口的边界上。
- en: The `scatter` plotting routine may be better if you wish to plot discrete data
    on axes without connecting the points with a line. This allows more control over
    the style of the marker. For example, you can scale the marker according to some
    additional information.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望在轴上绘制离散数据而不连接点与线，则`scatter`绘图例程可能更好。这允许更多地控制标记的样式。例如，可以根据一些额外信息调整标记的大小。
- en: Adding labels and legends to plots
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向绘图添加标签和图例
- en: Every plot should have a title, and the axes should be properly labeled. For
    plots displaying multiple sets of data, legends are a good way to help the reader
    quickly identify the marker, the line, and the color of different datasets. In
    this recipe, we will add axes labels and a title to a plot, and then add a legend
    to help distinguish between the different sets of data. To keep the code simple,
    we will plot the data from the previous recipe.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图应该有一个标题，并且轴应该被正确标记。对于显示多组数据的图，图例是帮助读者快速识别不同数据集的标记、线条和颜色的好方法。在本示例中，我们将向图添加轴标签和标题，然后添加一个图例来帮助区分不同的数据集。为了保持代码简单，我们将绘制上一个示例中的数据。
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to add labels and a legend to your plots to help distinguish
    the sets of data that they represent:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤向您的图添加标签和图例，以帮助区分它们代表的数据集：
- en: 'We first recreate the plot from the previous recipe using the following `plot`
    command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先使用以下`plot`命令从上一个示例中重新创建图：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we have a reference to the `Axes` object on which our data is plotted,
    and so we can start to customize these axes by adding labels and titles. The title
    and axes labels can be added to a figure by using the `set_title`, `set_xlabel`,
    and `set_ylabel` methods on the `ax` object created by the `subplots` routine.
    In each case, the argument is a string that contains the text to be displayed:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有了一个`Axes`对象的引用，我们可以开始通过添加标签和标题来自定义这些轴。可以使用`subplots`例程创建的`ax`对象上的`set_title`、`set_xlabel`和`set_ylabel`方法向图中添加标题和轴标签。在每种情况下，参数都是包含要显示的文本的字符串：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we plot the three datasets with a different style. The marker style is
    the same as in the previous recipe, but we have added a solid line for the first
    dataset, a dashed line for the second, and a dash-dot line for the third.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用不同的样式绘制了三个数据集。标记样式与上一个示例中相同，但我们为第一个数据集添加了实线，为第二个数据集添加了虚线，为第三个数据集添加了点划线。
- en: 'To add a legend, we call the `legend` method on the `ax` object. The argument
    should be a tuple or list containing the description to be placed in the legend
    for each set of data:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加图例，我们在`ax`对象上调用`legend`方法。参数应该是一个包含每组数据在图例中的描述的元组或列表：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The result of the preceding sequence of commands is shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上述一系列命令的结果如下：
- en: '![](assets/0ab005b7-27f6-4a24-8ec9-acdb04abd3d8.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0ab005b7-27f6-4a24-8ec9-acdb04abd3d8.png)'
- en: 'Figure 2.4: A plot with axes labels, a title, and a legend produced using Matplotlib'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：使用Matplotlib生成的带有轴标签、标题和图例的图
- en: How it works...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `set_title`, `set_xlabel`, and `set_ylabel` methods simply add the text
    argument to the corresponding position of the `Axes` object. The `legend` method,
    as called in the preceding code, adds the labels to the datasets in the order
    that they were added to the plot—in this case, `y1`, `y2`, and then `y3`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_title`、`set_xlabel`和`set_ylabel`方法只是将文本参数添加到`Axes`对象的相应位置。如前面的代码中调用的`legend`方法，按照它们添加到图中的顺序添加标签，本例中为`y1`、`y2`，然后是`y3`。'
- en: There are a number of keyword arguments that can be supplied to the `set_title`,
    `set_xlabel`, and `set_ylabel`routines to control the style of the text. For example,
    the `fontsize`keyword can be used to specify the size of the label font in the
    usual `pt`point measure. The text argument can also be rendered using TeX for
    additional formatting by supplying `usetex=True`to the routine. The TeX formatting
    of labels is demonstrated in *Figure 2.5*. This is especially useful if the title
    or axis label contains a mathematical formula. Unfortunately, the `usetex`keyword
    argument cannot be used if TeX is not installed on the system—it will cause an
    error in this case. However, it is still possible to use the TeX syntax for formatting
    mathematical text within labels, but this will be typeset by Matplotlib, rather
    than by TeX.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 可以提供一些关键字参数给`set_title`、`set_xlabel`和`set_ylabel`方法来控制文本的样式。例如，`fontsize`关键字可以用来指定标签字体的大小，通常使用`pt`点度量。还可以通过向例程提供`usetex=True`来使用TeX格式化标签。标签的TeX格式化在*图2.5*中演示。如果标题或轴标签包含数学公式，这是非常有用的。不幸的是，如果系统上没有安装TeX，就不能使用`usetex`关键字参数，否则会导致错误。但是，仍然可以使用TeX语法来格式化标签中的数学文本，但这将由Matplotlib而不是TeX来排版。
- en: We can use a different font by using the `fontfamily` keyword, the value of
    which can be the name of a font or `serif`, `sans-serif`, or `monospace`, which
    will choose the appropriate built-in font. A complete list of modifiers can be
    found in the Matplotlib documentation for the `matplotlib.text.Text` class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`fontfamily`关键字来使用不同的字体，其值可以是字体的名称或`serif`、`sans-serif`或`monospace`，它将选择适当的内置字体。可以在Matplotlib文档中找到`matplotlib.text.Text`类的完整修饰符列表。
- en: To add separate text annotations to a plot, you can use the `annotate` method
    on the `Axes` object. This routine takes two arguments—the text to display as
    a string and the coordinates of the point at which the annotation should be placed.
    This routine also accepts the previously mentioned styling keyword arguments.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要向图添加单独的文本注释，可以在`Axes`对象上使用`annotate`方法。这个例程接受两个参数——要显示的文本作为字符串和注释应放置的点的坐标。这个例程还接受前面提到的样式关键字参数。
- en: Adding subplots
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加子图
- en: Occasionally, it is useful to place multiple related plots within the same figure
    side by side but not on the same axes. Subplots allow us to produce a grid of
    individual plots within a single figure. In this recipe, we will see how to create
    two plots side by side on a single figure using subplots.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将多个相关的图放在同一图中并排显示，但不在同一坐标轴上是很有用的。子图允许我们在单个图中生成一个网格的单独图。在这个示例中，我们将看到如何使用子图在单个图上并排创建两个图。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need the data to be plotted on each subplot. As an example, we will
    plot the first five iterates of Newton's method applied to the *f*(*x*) = *x²-1*function*with
    an initial value of *x[0] = 2*on the first subplot, and for the second, we will
    plot the error of the iterate. We first define a generator function to get the
    iterates:*
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将要绘制在每个子图上的数据。例如，我们将在第一个子图上绘制应用于*f*(*x*) = *x²-1*函数的牛顿法的前五个迭代，初始值为*x[0] =
    2*，对于第二个子图，我们将绘制迭代的误差。我们首先定义一个生成器函数来获取迭代：
- en: '*[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE18]'
- en: 'This routine generates two lists. The first list contains iterates of Newton''s
    method applied to the function, and the second contains the error in the approximation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例程生成两个列表。第一个列表包含应用于函数的牛顿法的迭代，第二个包含近似值的误差：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps show how to create a figure that contains multiple subplots:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤显示了如何创建包含多个子图的图：
- en: 'We use the `subplots` routine to create a new figure and references to all
    of the `Axes` objects in each subplot, arranged in a grid with one row and two
    columns. We also set the `tight_layout` keyword argument to `True` to fix the
    layout of the resulting plots. This isn''t strictly necessary, but it is in this
    case as it produces a better result than the default:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`subplots`例程创建一个新的图和每个子图中的所有`Axes`对象的引用，这些子图在一个行和两个列的网格中排列。我们还将`tight_layout`关键字参数设置为`True`，以修复生成图的布局。这并不是严格必要的，但在这种情况下是必要的，因为它产生的结果比默认的更好：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once the `Figure` and `Axes` objects are created, we can populate the figure
    by calling the relevant plotting method on each `Axes` object. For the first plot
    (displayed on the left), we use the `plot` method on the `ax1` object, which has
    the same signature as the standard `plt.plot` routine. We can then call the `set_title`,
    `set_xlabel`, and `set_ylabel` methods on `ax1` to set the title and the `x` and
    `y`*labels. We also use TeX formatting for the axes labels by providing the `usetex`
    keyword argument; you can ignore this if you don't have TeX installed on your
    system:*
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了`Figure`和`Axes`对象，我们可以通过在每个`Axes`对象上调用相关的绘图方法来填充图。对于第一个图（显示在左侧），我们在`ax1`对象上使用`plot`方法，它与标准的`plt.plot`例程具有相同的签名。然后我们可以在`ax1`上调用`set_title`、`set_xlabel`和`set_ylabel`方法来设置标题和`x`和`y`标签。我们还通过提供`usetex`关键字参数来使用TeX格式化轴标签；如果您的系统上没有安装TeX，可以忽略这一点：
- en: '*[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*[PRE21]'
- en: 'Now, we can plot the error values on the second plot (displayed on the right)
    using the `ax2` object. We use an alternative plotting method that uses a logarithmic
    scale on the *y*-axis, called `semilogy`. The signature for this method is the
    same as the standard `plot` method. Again, we set the axes labels and the title.
    Again, the use of `usetex` can be left out if you don''t have TeX installed:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`ax2`对象在第二个图上（显示在右侧）绘制错误值。我们使用了一种使用对数刻度的替代绘图方法，称为`semilogy`。该方法的签名与标准的`plot`方法相同。同样，我们设置了轴标签和标题。如果没有安装TeX，可以不使用`usetex`。
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The result of this sequence of commands is shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令序列的结果如下图所示：
- en: '![](assets/f335dbe8-fa72-4b78-8a52-20f3159250f8.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f335dbe8-fa72-4b78-8a52-20f3159250f8.png)'
- en: 'Figure 2.5: Matplotlib subplots'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：Matplotlib子图
- en: The left-hand side plots the first five iterates of Newton's method and the
    right-hand side is the approximation error plotted on a logarithmic scale.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧绘制了牛顿法的前五次迭代，右侧是以对数刻度绘制的近似误差。
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A `Figure` object in Matplotlib is simply a container for plot elements, such
    as `Axes`, of a certain size. A `Figure` object will usually onlyhold a single
    `Axes`object, which occupies the entire figure area, but it can contain any number
    of `Axes`objects in the same area. The `subplots`routine does several things.
    It first creates a new figure and then creates a grid with the specified shape
    in the figure area. Then, a new `Axes`object is added to each position of the
    grid. The new `Figure`object and one or more `Axes`objects are then returned to
    the user. If a single subplot is requested (one row and one column, with no arguments)
    then a plain`Axes`object is returned. If a single row or column is requested (with
    more than one column or row, respectively), then a list of the `Axes`objects is
    returned. If more than one row and column is requested, a list of lists, with
    rows represented by inner lists filled with the `Axes`objects, will be returned.
    We can then use the plotting methods on each of the `Axes`objects to populate
    the figure with the desired plots.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib中的`Figure`对象只是一个特定大小的绘图元素（如`Axes`）的容器。`Figure`对象通常只包含一个`Axes`对象，该对象占据整个图形区域，但它可以在相同的区域中包含任意数量的`Axes`对象。`subplots`例程执行几项任务。首先创建一个新的图形，然后在图形区域内创建一个指定形状的网格。然后，在网格的每个位置添加一个新的`Axes`对象。然后将新的`Figure`对象和一个或多个`Axes`对象返回给用户。如果请求单个子图（一行一列，没有参数），则返回一个普通的`Axes`对象。如果请求单行或单列（分别具有多于一个列或行），则返回`Axes`对象的列表。如果请求多行和多列，则将返回一个列表的列表，其中行由填充有`Axes`对象的内部列表表示。然后我们可以使用每个`Axes`对象上的绘图方法来填充图形以显示所需的绘图。
- en: In this recipe, we used the standard `plot` method for the left-hand side plot,
    as we have seen in previous recipes. However, for the right-hand side plot, we
    used a plot where the *y-*axis had been changed to a logarithmic scale. This means
    that each unit on the *y*-axis represents a change of a power of 10, rather than
    a change of one unit, so that `0` represents 10⁰ = 1, `1` represents 10, `2` represents
    100, and so on. The axes labels are automatically changed to reflect this change
    in scale. This type of scaling is useful when the values change by an order of
    magnitude, such as the error in an approximation, as we use more and more iterations.
    We can also plot with a logarithmic scale for *x* only by using the `semilogx`
    method, or both axes on a logarithmic scale by using the `loglog` method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们在左侧使用了标准的`plot`方法，就像我们在以前的示例中看到的那样。但是，在右侧绘图中，我们使用了一个将*y*轴更改为对数刻度的绘图。这意味着*y*轴上的每个单位代表10的幂的变化，而不是一个单位的变化，因此`0`代表10⁰=1，`1`代表10，`2`代表100，依此类推。轴标签会自动更改以反映这种比例变化。当值按数量级变化时，例如近似误差随着迭代次数的增加而变化时，这种缩放是有用的。我们还可以使用`semilogx`方法仅对*x*使用对数刻度进行绘制，或者使用`loglog`方法对两个轴都使用对数刻度进行绘制。
- en: There's more...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are several ways to create subplots in Matplotlib. If you have already
    created a `Figure` object, then subplots can be added using the `add_subplot`
    method of the `Figure` object. Alternatively, you can use the `subplot` routine
    from `matplotlib.pyplot` to add subplots to the current figure. If one does not
    yet exist, it will be created when this routine is called. The `subplot` routine
    is a convenience wrapper of the `add_subplot` method on the `Figure` object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在Matplotlib中有几种创建子图的方法。如果已经创建了一个`Figure`对象，则可以使用`Figure`对象的`add_subplot`方法添加子图。或者，您可以使用`matplotlib.pyplot`中的`subplot`例程将子图添加到当前图。如果尚不存在，则在调用此例程时将创建一个新的图。`subplot`例程是`Figure`对象上`add_subplot`方法的便利包装。
- en: To create a new figure with one or more subplots, you can also use the `subplots`
    routine from the `pyplot` interface—as we saw in the *Changing the plotting style*
    recipe—which returns a new figure object and an array of the `Axes` objects, one
    for each position. All three of these methods require the number of rows and columns
    for the subplot matrix. The `add_subplot` method and the `subplot` routine also
    require a third argument, which is the index of the subplot to modify. The `Axes`
    object of the current subplot is returned.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个具有一个或多个子图的新图形，还可以使用`pyplot`接口中的`subplots`例程（如*更改绘图样式*中所示），它返回一个新的图形对象和一个`Axes`对象的数组，每个位置一个。这三种方法都需要子图矩阵的行数和列数。`add_subplot`方法和`subplot`例程还需要第三个参数，即要修改的子图的索引。返回当前子图的`Axes`对象。
- en: In the preceding example, we created two plots with differently scaled *y-*axes.
    This demonstrates one of the many possible uses of subplots. Another common use
    is for plotting data in a matrix where columns have a common `x` label and rows
    have a common `y` label, which is especially common in multivariate statistics
    when investigating the correlation between various sets of data. The `plt.subplots`
    routine for creating subplots accepts the `sharex` and `sharey`keyword parameters,
    which allows the axes to be shared among all the subplots or among a row or column.
    This setting affects the scale and ticks of the axes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了两个具有不同比例的*y*轴的图。这展示了子图的许多可能用途之一。另一个常见用途是在矩阵中绘制数据，其中列具有共同的`x`标签，行具有共同的`y`标签，这在多元统计中特别常见，用于研究各组数据之间的相关性。用于创建子图的`plt.subplots`例程接受`sharex`和`sharey`关键字参数，允许轴在所有子图或行或列之间共享。此设置会影响轴的比例和刻度。
- en: See also
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Matplotlib supports more advanced layouts by providing the `gridspec_kw` keyword
    arguments to the `subplots` routine. See the documentation for `matplotlib.gridspec`
    for more information.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib通过为`subplots`例程提供`gridspec_kw`关键字参数来支持更高级的布局。有关更多信息，请参阅`matplotlib.gridspec`的文档。
- en: Saving Matplotlib figures
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存Matplotlib图
- en: When you work in an interactive environment, such as an IPython console or a
    Jupyter notebook, displaying a figure at runtime is perfectly normal. However,
    there are plenty of situations where it would be more appropriate to store a figure
    directly to a file, rather than rendering it on screen. In this recipe, we will
    see how to save a figure directly to a file, rather than displaying it on screen.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在交互式环境中工作，例如IPython控制台或Jupyter笔记本时，运行时显示图是完全正常的。但是，有很多情况下，直接将图存储到文件中而不是在屏幕上呈现会更合适。在本示例中，我们将看到如何将图直接保存到文件中，而不是在屏幕上显示。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need the data to be plotted and the path or file object in which you
    wish to store the output. We store the result in `savingfigs.png` in the current
    directory. In this example, we will plot the following data:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要要绘制的数据以及要存储输出的路径或文件对象。我们将结果存储在当前目录中的`savingfigs.png`中。在此示例中，我们将绘制以下数据：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps show how to save a Matplotlib plot directly to a file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤显示了如何将Matplotlib图直接保存到文件：
- en: 'The first step is to create the figure, as usual, and add any labels, titles,
    and annotations that are necessary. The figure will be written to the file in
    its current state, so any changes to the figure should be made before saving:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是像往常一样创建图，并添加任何必要的标签、标题和注释。图将以其当前状态写入文件，因此应在保存之前进行对图的任何更改：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we use the `savefig`method on `fig` to save this figure to a file. The
    only required argument is the path to output to or a file-like object that the
    figure can be written to. We can adjust various settings for the output format,
    such as the resolution, by providing the appropriate keyword arguments. We''ll
    set the **Dots per Inch** (**DPI**) of the output figure to `300`, which is a
    reasonable resolution for most applications:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`fig`上的`savefig`方法将此图保存到文件。唯一必需的参数是要输出的路径或可以写入图形的文件对象。我们可以通过提供适当的关键字参数来调整输出格式的各种设置，例如分辨率。我们将输出图的**每英寸点数**（**DPI**）设置为`300`，这对于大多数应用程序来说是合理的分辨率：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Matplotlib will infer that we wish to save the image in the **Portable Network
    Graphics** (**PNG**) format from the extension of the file given. Alternatively,
    a format can be explicitly provided as a keyword argument (by using the `format`keyword),
    or it will fall back to the default from the configuration file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib将根据给定文件的扩展名推断我们希望以**便携式网络图形**（**PNG**）格式保存图像。或者，可以通过提供关键字参数（使用`format`关键字）显式地提供格式，或者可以从配置文件中回退到默认格式。
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `savefig` method chooses the appropriate backend for the output format and
    then renders the current figure in that format. The resulting image data is written
    to the specified path or file-like object. If you have manually created a `Figure`
    instance, the same effect can be achieved by calling the `savefig` method on that
    instance.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`savefig`方法选择适合输出格式的后端，然后以该格式呈现当前图。生成的图像数据将写入指定的路径或文件对象。如果您手动创建了`Figure`实例，则可以通过在该实例上调用`savefig`方法来实现相同的效果。'
- en: There's more...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `savefig` routine takes a number of additional optional keyword arguments
    to customize the output image. For example, the resolution of the image can be
    specified using the `dpi` keyword. The plots in this chapter have been produced
    by saving the Matplotlib figures to the file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`savefig`例程接受许多额外的可选关键字参数来自定义输出图像。例如，可以使用`dpi`关键字指定图像的分辨率。本章中的图是通过将Matplotlib图保存到文件中生成的。'
- en: The output formats available include PNG, **Scalable Vector Graphics** (**SVG**),
    **PostScript** (**PS**), **Encapsulated PostScript** (**EPS**), and **Portable
    Document Format** (**PDF**). You can also save to JPEG format if the Pillow package
    is installed, but Matplotlib does not support this natively since version 3.1\.
    There are additional customization keyword arguments for JPEG images, such as
    `quality` and `optimize`. A dictionary of image metadata can be passed to the
    `metadata` keyword, which will be written as image metadata when saving.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的输出格式包括PNG、**可缩放矢量图形**（**SVG**）、**PostScript**（**PS**）、**Encapsulated PostScript**（**EPS**）和**便携式文档格式**（**PDF**）。如果安装了Pillow软件包，还可以保存为JPEG格式，但自Matplotlib
    3.1版本以来就不再原生支持此功能。JPEG图像还有其他自定义关键字参数，如`quality`和`optimize`。可以将图像元数据的字典传递给`metadata`关键字，在保存时将其写入图像元数据。
- en: See also
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The examples gallery on the Matplotlib website includes examples of embedding
    Matplotlib figures into a **Graphical User Interface** (**GUI**) application using
    several common Python GUI frameworks.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib网站上的示例库包括使用几种常见的Python GUI框架将Matplotlib图嵌入到**图形用户界面**（**GUI**）应用程序中的示例。
- en: Surface and contour plots
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 曲面和等高线图
- en: Matplotlib can also plot three-dimensional data in a variety of ways. Two common
    choices for displaying data like this are by using **surface plots** or **contour
    plots** (think of contour lines on a map). In this recipe, we will see a method
    for plotting surfaces from three-dimensional data and how to plot contours of
    three-dimensional data.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib还可以以各种方式绘制三维数据。显示这种数据的两种常见选择是使用**表面图**或**等高线图**（类似于地图上的等高线）。在本示例中，我们将看到一种从三维数据绘制表面和绘制三维数据等高线的方法。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To plot three-dimensional data, it needs to be arranged into two-dimensional
    arrays for the *x*, *y*, and *z* components, where both the *x* and *y* components
    must be of the same shape as the *z* component. For the sake of this demonstration,
    we will plot the surface corresponding to the *f*(*x*, *y*) = *x*²*y*³function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制三维数据，需要将其排列成*x*、*y*和*z*分量的二维数组，其中*x*和*y*分量必须与*z*分量的形状相同。为了演示，我们将绘制对应于*f*(*x*,
    *y*) = *x*²*y*³函数的表面。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We want to plot the *f*(*x*, *y*) = *x*²*y*³functionon the -2 ≤ *x* ≤ 2 and
    -1 ≤ *y ≤* 1range. The first task is to create a suitable grid of (*x*, *y*) pairs
    on which to evaluate this function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要在-2≤*x*≤2和-1≤*y*≤1范围内绘制*f*(*x*, *y*) = *x*²*y*³函数。第一项任务是创建一个适当的(*x*, *y*)对的网格，以便对该函数进行评估：
- en: 'We first use `np.linspace`to generate a reasonable number of points in these
    ranges:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先使用`np.linspace`在这些范围内生成合理数量的点：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we need to create a grid on which to create our *z*values. For this, we
    use the `np.meshgrid`routine:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个网格来创建我们的*z*值。为此，我们使用`np.meshgrid`例程：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we can create the *z*values to plot, which hold the value of the function
    at each of the grid points:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以创建要绘制的*z*值，这些值保存了每个网格点上函数的值：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To plot three-dimensional surfaces, we need to load a Matplotlib toolbox, `mplot3d`,
    which comes with the Matplotlib package. This won''t be used explicitly in the
    code, but behind the scenes, it makes the three-dimensional plotting utilities
    available to Matplotlib:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要绘制三维表面，我们需要加载一个Matplotlib工具箱`mplot3d`，它随Matplotlib包一起提供。这不会在代码中明确使用，但在幕后，它使三维绘图实用程序可用于Matplotlib：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we create a new figure and a set of three-dimensional axes for the figure:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新的图和一组三维坐标轴用于该图：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we can call the `plot_surface` method on these axes to plot the data:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在这些坐标轴上调用`plot_surface`方法来绘制数据：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It is extra important to add axis labels to three-dimensional plots because
    it might not be clear which axis is which on the displayed plot:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为三维图添加轴标签非常重要，因为在显示的图上可能不清楚哪个轴是哪个：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We should also set a title at this stage:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时我们还应该设置一个标题：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can use the `plt.show` routine to display the figure in a new window (if
    you are using Python interactively and not in a Jupyter notebook or on an IPython
    console) or `plt.savefig` to save the figure to a file. The result of the preceding
    sequence is shown here:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`plt.show`例程在新窗口中显示图（如果您在Python中交互使用，而不是在Jupyter笔记本或IPython控制台上使用），或者使用`plt.savefig`将图保存到文件中。上述序列的结果如下所示：
- en: '![](assets/b844fb9d-e453-46f2-a233-9ec2e4eeb71e.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b844fb9d-e453-46f2-a233-9ec2e4eeb71e.png)'
- en: 'Figure 2.6: A three-dimensional surface plot produced with Matplotlib using
    the default settings'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：使用默认设置使用Matplotlib生成的三维表面图
- en: 'Contour plots do not require the `mplot3d` toolkit, and there is a `contour`
    routine in the `pyplot` interface that produces contour plots. However, unlike
    the usual (two-dimensional) plotting routines, the `contour` routine requires
    the same arguments as the `plot_surface` method. We use the following sequence
    to produce a plot:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等高线图不需要`mplot3d`工具包，在`pyplot`接口中有一个`contour`例程可以生成等高线图。但是，与通常的（二维）绘图例程不同，`contour`例程需要与`plot_surface`方法相同的参数。我们使用以下顺序生成绘图：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The result is shown in the following plot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在以下图中：
- en: '![](assets/18cd3684-5b44-4b67-9ce2-d48ecd675303.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/18cd3684-5b44-4b67-9ce2-d48ecd675303.png)'
- en: 'Figure 2.7: Contour plot produced using Matplotlib with the default settings'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：使用默认设置使用Matplotlib生成的等高线图
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `mplot3d` toolkit provides an `Axes3D` object, which is a three-dimensional
    version of the `Axes` object in the core Matplotlib package. This is made available
    to the `axes` method on a `Figure` object when the `projection="3d"` keyword argument
    is given. A surface plot is obtained by drawing quadrilaterals, in the three-dimensional
    projection, between nearby points in the same way that a two-dimensional curve
    is approximated by straight lines joining adjacent points.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`mplot3d`工具包提供了一个`Axes3D`对象，这是核心Matplotlib包中`Axes`对象的三维版本。当给定`projection="3d"`关键字参数时，这将被提供给`Figure`对象上的`axes`方法。通过在三维投影中在相邻点之间绘制四边形，可以获得表面图。这与用直线连接相邻点来近似二维曲线的方式相同。'
- en: The `plot_surface` method needs the *z* values to be provided as a two-dimensional
    array that encodes the *z* values on a grid of (*x*, *y*) pairs. We created the
    range of *x* and *y* values that we are interested in, but if we simply evaluate
    our function on the pairs of corresponding values from these arrays, we will get
    the *z* values along a line and not over a grid. Instead, we use the `meshgrid`
    routine, which takes the two `X` and `Y`arrays and creates from them a grid consisting
    of all the possible combinations of values in `X`and `Y`. The output is a pair
    of two-dimensional arrays on which we can evaluate our function. We can then provide
    all three of these two-dimensional arrays to the `plot_surface`method.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot_surface`方法需要提供*z*值，这些值作为二维数组编码在(*x*, *y*)对的网格上的*z*值。我们创建了我们感兴趣的*x*和*y*值的范围，但是如果我们简单地在这些数组的对应值上评估我们的函数，我们将得到一条线上的*z*值，而不是整个网格上的值。相反，我们使用`meshgrid`例程，它接受两个`X`和`Y`数组，并从中创建一个网格，其中包含`X`和`Y`中所有可能的值的组合。输出是一对二维数组，我们可以在其上评估我们的函数。然后我们可以将这三个二维数组全部提供给`plot_surface`方法。'
- en: There's more...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The routines described in the preceding section, `contour` and `plot_contour`,
    only work with highly structured data where the *x*, *y*, and *z* components are
    arranged into grids. Unfortunately, real-life data is rarely so structured. In
    this case, you need to perform some kind of interpolation between known points
    to approximate the value on a uniform grid, which can then be plotted. A common
    method for performing this interpolation is by triangulating the collection of
    (*x*, *y*) pairs and then using the values of the function on the vertices of
    each triangle to estimate the value on the grid points. Fortunately, Matplotlib
    has a method that does all of these steps and then plots the result, which is
    the `plot_trisurf` routine. We briefly explain how this can be used here:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中描述的例程`contour`和`plot_contour`只适用于高度结构化的数据，其中*x*、*y*和*z*分量被排列成网格。不幸的是，现实生活中的数据很少有这么结构化的。在这种情况下，您需要在已知点之间执行某种插值，以近似均匀网格上的值，然后可以绘制出来。执行这种插值的常见方法是通过对(*x*,
    *y*)对的集合进行三角剖分，然后使用每个三角形顶点上的函数值来估计网格点上的值。幸运的是，Matplotlib有一个方法可以执行所有这些步骤，然后绘制结果，这就是`plot_trisurf`例程。我们在这里简要解释一下如何使用它：
- en: 'To illustrate the use of `plot_trisurf`, we will plot a surface and contours
    from the following data:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了说明`plot_trisurf`的用法，我们将从以下数据绘制表面和等高线：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This time, we will plot both the surface and contour(approximations) on the
    same figure as two separate subplots. For this, we supply the `projection="3d"`
    keyword argument to the subplot that will contain the surface. We use the `plot_trisurf`
    method on the three-dimensional axes to plot the approximated surface, and the
    `tricontour` method on the two-dimensional axes to plot the approximated contours:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，我们将在同一图中绘制表面和等高线（近似），作为两个单独的子图。为此，我们向包含表面的子图提供`projection="3d"`关键字参数。我们在三维坐标轴上使用`plot_trisurf`方法绘制近似表面，并在二维坐标轴上使用`tricontour`方法绘制近似等高线：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can now plot the contours for the triangulated surface using the following
    command:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令绘制三角剖分表面的等高线：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We include the `tight_layout=True`keyword argument with the figure to save
    a call to the `plt.tight_layout`routine later. The result is shown here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在图中包含`tight_layout=True`关键字参数，以避免稍后调用`plt.tight_layout`例程。结果如下所示：
- en: '![](assets/c347d304-3e13-4341-a1e8-20ce0854d5a8.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c347d304-3e13-4341-a1e8-20ce0854d5a8.png)'
- en: 'Figure 2.8: Approximate surface and contour plots generated from unstructured
    data using triangulation'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：使用三角剖分生成的近似表面和等高线图
- en: In addition to surface plotting routines, the `Axes3D` object has a `plot` (or
    `plot3D`) routine for simple three-dimensional plotting, which works exactly as
    the usual `plot` routine but on the three-dimensional axes. This method can also
    be used to plot two-dimensional data on one of the axes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了表面绘图例程外，`Axes3D`对象还有一个用于简单三维绘图的`plot`（或`plot3D`）例程，其工作方式与通常的`plot`例程完全相同，但在三维坐标轴上。该方法还可用于在其中一个轴上绘制二维数据。
- en: Customizing three-dimensional plots
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义三维图
- en: Contour plots can hide some detail of the surface that they represent since
    they only show where the "height" is similar and not what the value is, even in
    relation to the surrounding values. On a map, this is remedied by printing the
    height onto certain contours. Surface plots are more revealing, but the problem
    of projecting three-dimensional objects into 2D to be displayed on a screen can
    itself obscure some details. To address these issues, we can customize the appearance
    of a three-dimensional plot (or contour plot) to enhance the plot and make sure
    the detail that we wish to highlight is clear. The easiest way to do this is by
    changing the colormap of the plot.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 等高线图可能会隐藏表示的表面的一些细节，因为它们只显示“高度”相似的地方，而不显示值是多少，甚至与周围的值相比如何。在地图上，这可以通过在特定等高线上打印高度来解决。表面图更具启发性，但是将三维对象投影到二维以在屏幕上显示可能会模糊一些细节。为了解决这些问题，我们可以自定义三维图（或等高线图）的外观，以增强图表并确保我们希望突出显示的细节清晰可见。最简单的方法是通过更改图表的颜色映射来实现这一点。
- en: In this recipe, we will use the reverse of the `binary` colormap.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`binary`颜色映射的反转。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will generate surface plots for the following function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为以下函数生成表面图：
- en: '![](assets/de81842d-a1b9-4ec4-b7a8-5e3fe30bb458.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/de81842d-a1b9-4ec4-b7a8-5e3fe30bb458.png)'
- en: 'We generate the points at which this should be plotted as in the previous recipe:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成应该绘制的点，就像在前一个示例中一样：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Matplotlib has a number of built-in colormaps that can be applied to plots.
    By default, surface plots are plotted with a single color that is shaded according
    to a light source (see the *There''s more...* section of this recipe). A colormap
    can dramatically improve the effect of a plot. The following steps show how to
    add a colormap to surface and contour plots:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib有许多内置的颜色映射，可以应用于图表。默认情况下，表面图是用根据光源进行着色的单一颜色绘制的（请参阅本示例的*更多信息*部分）。颜色映射可以显著改善图表的效果。以下步骤显示了如何向表面和等高线图添加颜色映射：
- en: 'To start, we simply apply one of the built-in colormaps, `binary_r`, which
    is done by providing the `cmap="binary_r"` keyword argument to the `plot_surface`
    routine:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们只需应用内置的颜色映射之一`binary_r`，通过向`plot_surface`例程提供`cmap="binary_r"`关键字参数来实现：
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The result is a figure (*Figure* 2.9) where the surface is colored according
    to its value, with the most extreme values at either end of the colormap—in this
    case, the larger the *z* value, the lighter the shade of gray. Note that the jaggedness
    of the plot in the following diagram is due to the relatively small number of
    points in the mesh grid:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个图（*图* 2.9），其中表面的颜色根据其值而变化，颜色映射的两端具有最极端的值——在本例中，*z*值越大，灰度越浅。请注意，下图中的不规则性是由网格中相对较少的点造成的：
- en: '![](assets/cf0e7c34-b176-49b8-b54f-0a4150f9b746.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cf0e7c34-b176-49b8-b54f-0a4150f9b746.png)'
- en: 'Figure 2.9: A surface plot with a grayscale colormap applied'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：应用灰度颜色映射的表面图
- en: Colormaps apply to other plot types in addition to surface plots. In particular,
    colormaps can be applied to contour plots, which can help to distinguish between
    the contours that represent higher values and those that represent lower values.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色映射适用于表面绘图以外的其他绘图类型。特别是，颜色映射可以应用于等高线图，这有助于区分代表较高值和代表较低值的等高线。
- en: 'For the contour plot, the method for changing the colormap is the same; we
    simply specify a value for the `cmap` keyword argument:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于等高线图，更改颜色映射的方法是相同的；我们只需为`cmap`关键字参数指定一个值：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The result of the preceding code is shown here:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果如下所示：
- en: '![](assets/34011236-d782-49c1-910d-b4283dbe9951.png)Figure 2.10: A contour
    plot with an alternative colormap set'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/34011236-d782-49c1-910d-b4283dbe9951.png)图2.10：具有替代颜色映射设置的等高线图'
- en: The darker shades of gray in the diagram correspond to the lower values of z.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图中较深的灰色阴影对应于z的较低值。
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Color mapping works by assigning an RGB value according to a scale—the **colormap**.
    First, the values are normalized so that they lie between `0` and `1`, which is
    typically done by a linear transformation that takes the minimum value to `0`
    and the maximum value to `1`. The appropriate color is then applied to each face
    of the surface plot (or line, in another kind of plot).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色映射通过根据比例尺分配RGB值来工作——**颜色映射**。首先，对值进行归一化，使其介于`0`和`1`之间，通常通过线性变换来实现，将最小值取为`0`，最大值取为`1`。然后将适当的颜色应用于表面绘图的每个面（或者在另一种类型的绘图中是线）。
- en: Matplotlib comes with a number of built-in colormaps that can be applied by
    simply passing the name to the `cmap`keyword argument. A list of these colormaps
    is given in the documentation ([https://matplotlib.org/tutorials/colors/colormaps.html](https://matplotlib.org/tutorials/colors/colormaps.html)),
    and also comes with a reversed variant, which is obtained by adding the `_r`suffix
    to the name of the chosen colormap.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib带有许多内置的颜色映射，可以通过简单地将名称传递给`cmap`关键字参数来应用。这些颜色映射的列表在文档中给出（[https://matplotlib.org/tutorials/colors/colormaps.html](https://matplotlib.org/tutorials/colors/colormaps.html)），还有一个反转的变体，通过在所选颜色映射的名称后添加`_r`后缀来获得。
- en: There's more...
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The normalization step in applying a colormap is performed by an object derived
    from the `Normalize` class. Matplotlib provides a number of standard normalization
    routines, including `LogNorm` and `PowerNorm`. Of course, you can also create
    your own subclass of `Normalize` to perform the normalization. An alternative
    `Normalize` subclass can be added using the `norm` keyword of `plot_surface` or
    other plotting functions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 应用颜色映射中的归一化步骤是由`Normalize`类派生的对象执行的。Matplotlib提供了许多标准的归一化例程，包括`LogNorm`和`PowerNorm`。当然，您也可以创建自己的`Normalize`子类来执行归一化。可以使用`plot_surface`或其他绘图函数的`norm`关键字添加替代`Normalize`子类。
- en: 'For more advanced uses, Matplotlib provides an interface for creating custom
    shading using light sources. This is done by importing the `LightSource` class
    from the `matplotlib.colors` package, and then using an instance of this class
    to shade the surface elements according to the *z* value. This is done using the
    `shade` method on the `LightSource` object:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的用途，Matplotlib提供了一个接口，用于使用光源创建自定义阴影。这是通过从`matplotlib.colors`包中导入`LightSource`类，然后使用该类的实例根据*z*值对表面元素进行着色来完成的。这是使用`LightSource`对象的`shade`方法完成的：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Complete examples are shown in the Matplotlib gallery should you wish to learn
    more about how this works.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望了解更多关于这个工作原理的内容，可以在Matplotlib库中查看完整的示例。
- en: Further reading
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The Matplotlib package is extensive and we can scarcely do it justice in such
    a short space. The documentation contains far more detail than is provided here.
    Moreover, there is a large gallery ([https://matplotlib.org/gallery/index.html#](https://matplotlib.org/gallery/index.html#))
    of examples covering many more of the capabilities of the package than in this
    book.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib包非常庞大，我们在这么短的篇幅内几乎无法充分展现它。文档中包含的细节远远超过了这里提供的内容。此外，还有一个大型的示例库（[https://matplotlib.org/gallery/index.html#](https://matplotlib.org/gallery/index.html#)），其中包含了比本书中更多的包功能。
- en: There are other packages that build on top of Matplotlib that offer high-level
    plotting methods for specific applications. For example, the Seaborn libraries
    provide routines for visualizing data ([https://seaborn.pydata.org/](https://seaborn.pydata.org/)).****
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他构建在Matplotlib之上的包，为特定应用程序提供了高级绘图方法。例如，Seaborn库提供了用于可视化数据的例程（[https://seaborn.pydata.org/](https://seaborn.pydata.org/)）。
