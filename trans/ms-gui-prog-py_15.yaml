- en: Creating 2D Graphics with QPainter
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`QPainter`创建2D图形
- en: We've already seen that Qt provides a vast array of widgets with extensive styling
    and customization capabilities. There are times, however, when we need to take
    direct control of what is being drawn on the screen; for example, we might like
    to edit an image, create a unique widget, or build an interactive animation. At
    the core of all these tasks in Qt sits a humble, hardworking object known as `QPainter`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到Qt提供了大量的小部件，具有广泛的样式和自定义功能。然而，有时我们需要直接控制屏幕上的绘制内容；例如，我们可能想要编辑图像，创建一个独特的小部件，或者构建一个交互式动画。在所有这些任务的核心是Qt中一个谦卑而勤奋的对象，称为`QPainter`。
- en: 'In this chapter, we''re going to explore Qt''s **two-dimensional** (**2D**)
    graphics capabilities in three sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在三个部分中探索Qt的**二维**（**2D**）图形功能：
- en: Image editing with `QPainter`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QPainter`进行图像编辑
- en: Custom widgets with `QPainter`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QPainter`创建自定义小部件
- en: Animating 2D graphics with `QGraphicsScene`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QGraphicsScene`动画2D图形
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the basic Python and PyQt5 setup that you've been using
    throughout the book. You may also wish to download the example code from [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter12](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter12).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要基本的Python和PyQt5设置，这是您在整本书中一直在使用的。您可能还希望从[https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter12](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter12)下载示例代码。
- en: 'You will also need the `psutil` library, which you can install from PyPI using
    the following command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要`psutil`库，可以使用以下命令从PyPI安装：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Finally, it would be helpful to have some images on hand that you can use for
    sample data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一些图像在手边会很有帮助，您可以用它们作为示例数据。
- en: Check out the following video to see the code in action: [http://bit.ly/2M5xzlL](http://bit.ly/2M5xzlL)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的运行情况：[http://bit.ly/2M5xzlL](http://bit.ly/2M5xzlL)
- en: Image editing with QPainter
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`QPainter`进行图像编辑
- en: Images can be edited in Qt using a `QPainter` object to draw on a `QImage` object.
    In [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml), *Styling Qt Applications,*
    you learned about the `QPixmap` object, which is a display-optimized object representing
    a graphical image. The `QImage` object is a similar object, which is optimized
    for editing rather than display. To demonstrate how we can draw on a `QImage` object
    using `QPainter`, we're going to build a classic meme generator application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt中，可以使用`QPainter`对象在`QImage`对象上绘制图像。在[第6章](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml)中，*Qt应用程序的样式*，您了解了`QPixmap`对象，它是一个表示图形图像的显示优化对象。`QImage`对象是一个类似的对象，它针对编辑而不是显示进行了优化。为了演示如何使用`QPainter`在`QImage`对象上绘制图像，我们将构建一个经典的表情包生成器应用程序。
- en: The meme generator GUI
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成表情包的图形用户界面
- en: Create a copy of your Qt application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow,* and call it `meme_gen.py`. We will begin
    by building the GUI form for our meme generator.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)中创建Qt应用程序模板的副本，*使用QMainWindow构建应用程序*，并将其命名为`meme_gen.py`。我们将首先构建用于表情包生成器的GUI表单。
- en: The editing form
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑表单
- en: 'Before we create the actual form, we''re going to simplify our code slightly
    by creating some custom button classes: a `ColorButton` class for setting colors,
    a `FontButton` class for setting fonts, and an `ImageFileButton` class for selecting
    images.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建实际表单之前，我们将通过创建一些自定义按钮类稍微简化我们的代码：一个用于设置颜色的`ColorButton`类，一个用于设置字体的`FontButton`类，以及一个用于选择图像的`ImageFileButton`类。
- en: 'The `ColorButton` class begins like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorButton`类的开始如下：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This button inherits `QPushButton` but makes a few changes. We've defined a
    `changed` signal to track when the value of the button changes and added a keyword
    option so that this signal can be connected using keywords, just like built-in
    signals.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个按钮继承自`QPushButton`，但做了一些改动。我们定义了一个`changed`信号来跟踪按钮值的变化，并添加了一个关键字选项，以便可以像内置信号一样使用关键字连接这个信号。
- en: 'We''ve also added the ability to specify a default color, which will be passed
    to a `set_color` method:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了指定默认颜色的功能，该颜色将传递给`set_color`方法：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This method stores the passed color value in an instance variable and then generates
    a `pixmap` object of the given color to use as a button icon (we saw this technique
    in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml), *Styling Qt Applications*).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将传递的颜色值存储在实例变量中，然后生成给定颜色的`pixmap`对象，用作按钮图标（我们在[第6章](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml)中看到了这种技术，*Qt应用程序的样式*）。
- en: 'The button''s `clicked` signal is connected to an `on_click()` method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的`clicked`信号连接到`on_click()`方法：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method opens `QColorDialog`, allowing the user to choose a color and, if
    one is selected, it sets its color and emits the `changed` signal.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法打开`QColorDialog`，允许用户选择颜色，并且如果选择了颜色，则设置其颜色并发出`changed`信号。
- en: 'The `FontButton` class will be nearly identical to the preceding class:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`FontButton`类将与前一个类几乎相同：'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Similar to the color button, it defines a `changed` signal that can be connected
    through a keyword. It takes a default family and size, which is used to generate
    a default `QFont` object stored in the button's `_font` property using the `set_font()`
    method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与颜色按钮类似，它定义了一个可以通过关键字连接的`changed`信号。它采用默认的字体和大小，用于生成存储在按钮的`_font`属性中的默认`QFont`对象，使用`set_font()`方法。
- en: The `set_font()` method also changes the button's font and text to the selected
    family and size.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_font()`方法还会更改按钮的字体和文本为所选的字体和大小。'
- en: 'Finally, the `on_click()` method handles the button clicks:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`on_click()`方法处理按钮点击：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Similar to the color button, we're displaying a `QFontDialog` dialog box and,
    if the user selects a font, setting the button's font accordingly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与颜色按钮类似，我们显示一个`QFontDialog`对话框，并且如果用户选择了字体，则相应地设置按钮的字体。
- en: 'Finally, the `ImageFileButton` class will be very much like the preceding two
    classes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`ImageFileButton`类将与前两个类非常相似：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The only difference here is that the dialog is now a `getOpenFileName` dialog
    that allows the user to select PNG, XPM, or JPEG files.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是对话框现在是一个`getOpenFileName`对话框，允许用户选择PNG、XPM或JPEG文件。
- en: '`QImage` can actually handle a wide variety of image files. You can find these
    at [https://doc.qt.io/qt-5/qimage.html#reading-and-writing-image-files](https://doc.qt.io/qt-5/qimage.html#reading-and-writing-image-files) or
    by calling `QImageReader.supportedImageFormats()`. We''ve shortened the list here
    for brevity.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`QImage`实际上可以处理各种各样的图像文件。您可以在[https://doc.qt.io/qt-5/qimage.html#reading-and-writing-image-files](https://doc.qt.io/qt-5/qimage.html#reading-and-writing-image-files)找到这些信息，或者调用`QImageReader.supportedImageFormats()`。出于简洁起见，我们在这里缩短了列表。'
- en: 'Now that these classes are created, let''s build a form for editing the meme''s
    properties:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些类已经创建，让我们为编辑表情包属性构建一个表单：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This form will be very similar to those that we have created in previous chapters,
    but, rather than using a `submitted` signal for when the form is submitted, the `changed`
    signal will be triggered whenever any form item is changed. This will allow us
    to display any changes in real-time rather than requiring a button push.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表单将与我们在之前章节中创建的表单非常相似，但是，与其在表单提交时使用`submitted`信号不同，`changed`信号将在任何表单项更改时触发。这将允许我们实时显示任何更改，而不需要按按钮。
- en: 'Our first control will be to set the filename of the source image:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个控件将是设置源图像的文件名：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We're going to be linking the `changed` signal (or something similar) on each
    widget to a method called `on_change()`, which will gather up the data in the
    form and emit the `changed` signal of `MemeEditForm`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把每个小部件的`changed`信号（或类似的信号）链接到一个名为`on_change()`的方法上，该方法将收集表单中的数据并发射`MemeEditForm`的`changed`信号。
- en: 'First, though, let''s add fields to control the text itself:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，首先让我们添加字段来控制文本本身：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our memes will have separate text drawn at the top and bottom of the images,
    and we've used our `ColorButton` and `FontButton` classes to create inputs for
    the text's color and font. Once again, we're connecting an appropriate `changed` signal
    from each widget to an `on_changed()` instance method.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表情包将在图像的顶部和底部分别绘制文本，并且我们使用了`ColorButton`和`FontButton`类来创建文本颜色和字体的输入。再次，我们将每个小部件的适当`changed`信号连接到一个`on_changed()`实例方法。
- en: 'Let''s finish up the form GUI by adding controls to draw background boxes for
    the text:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加控件来绘制文本的背景框来完成表单GUI：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These fields allow the user to add opaque backgrounds behind the text in case
    the image is too colorful for it to be readable. The controls allow you to change
    the number of lines for the top and bottom backgrounds, the color of the boxes,
    and the padding.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段允许用户在图像太丰富而无法阅读时在文本后面添加不透明的背景。控件允许您更改顶部和底部背景的行数、框的颜色和填充。
- en: 'That takes care of the form layout, so now we''ll deal with the `on_change()`
    method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了表单布局，现在我们来处理`on_change()`方法：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, we define a `get_data()` method, which assembles a `dict` object of values
    from the form's widgets and returns them. This will be useful if we need to pull
    data from the form explicitly, rather than rely on a signal. The `on_change()`
    method retrieves this `dict` object and emits it with the `changed` signal.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个`get_data()`方法，该方法从表单的小部件中组装一个值的`dict`对象并返回它们。如果我们需要显式地从表单中提取数据，而不是依赖信号，这将非常有用。`on_change()`方法检索这个`dict`对象并用`changed`信号发射它。
- en: The main GUI
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主GUI
- en: With the form widget created, let's now assemble our main GUI.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了表单小部件后，现在让我们组装我们的主GUI。
- en: 'Let''s start with `MainView.__init__()`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`MainView.__init__()`开始：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We're going to begin by setting a window title and then defining a maximum size
    for our generated meme image. We'll use this to create our `QImage` object. Since
    we haven't got an image file at program launch time, we'll just generate a black
    placeholder image that is of the maximum size, which we do using the `fill()`
    method—just as we did with our pixmaps. However, when creating a blank `QImage` object,
    we need to specify an image format to use for the generated image. In this case,
    we're using the ARGB32 format, which can be used to make full-color images with
    transparency.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从设置窗口标题开始，然后定义生成的表情包图像的最大尺寸。我们将使用这个尺寸来创建我们的`QImage`对象。由于在程序启动时我们没有图像文件，所以我们将生成一个最大尺寸的黑色占位图像，使用`fill()`方法来实现，就像我们用像素图一样。然而，当创建一个空白的`QImage`对象时，我们需要指定一个图像格式来用于生成的图像。在这种情况下，我们使用ARGB32格式，可以用于制作具有透明度的全彩图像。
- en: 'We''ll use this image as we create the main GUI layout:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建主GUI布局时，我们将使用这个图像：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This GUI is a simple two-panel layout featuring a `QLabel` object on the left
    for displaying our meme image, and the `MemeTextForm()` method on the right for
    editing it. We've connected the form's `changed` signal to a `MainWindow` method
    called `build_image()`, which will contain our main drawing logic. Note that we
    cannot display a `QImage` object in a `QLabel` object directly; we must convert
    it to a `QPixmap` object first.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个GUI是一个简单的两面板布局，左边是一个`QLabel`对象，用于显示我们的表情包图像，右边是用于编辑的`MemeTextForm()`方法。我们将表单的`changed`信号连接到一个名为`build_image()`的`MainWindow`方法，其中包含我们的主要绘图逻辑。请注意，我们不能直接在`QLabel`对象中显示`QImage`对象；我们必须先将其转换为`QPixmap`对象。
- en: Drawing with QImage
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QImage进行绘制
- en: Now that our GUI is squared away, it's time to create `MainView.build_image()`.
    This method will contain all of the image manipulation and painting methods.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的GUI已经准备好了，现在是时候创建`MainView.build_image()`了。这个方法将包含所有的图像处理和绘制方法。
- en: 'We''ll begin by adding the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从添加以下代码开始：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our first task is to set up the base image of our meme. If we don't have an
    `image_source` value in the form data, then we'll just fill our `QImage` object
    with the color black, providing us a blank canvas for the rest of the drawing.
    If we do have an image source, then we can load in the selected image by passing
    its file path to `QImage.load()`. In the event that our loaded image is larger
    than the maximum size, we will want to scale it down so that it is smaller than
    the maximum width and height while keeping the same aspect ratio.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个任务是设置我们的表情包的基本图像。如果在表单数据中没有 `image_source` 值，那么我们将用黑色填充我们的 `QImage` 对象，为我们的绘图提供一个空白画布。如果我们有图像来源，那么我们可以通过将其文件路径传递给
    `QImage.load()` 来加载所选图像。如果我们加载的图像大于最大尺寸，我们将希望将其缩小，使其小于最大宽度和高度，同时保持相同的纵横比。
- en: A quick way to check whether the image is too large in either dimension is to
    subtract its size from our maximum size. If either the width or the height is
    larger than the maximum, then one of the dimensions will be negative, which makes
    the `QSize` object produced by the subtraction expression invalid.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 检查图像在任一维度上是否太大的一种快速方法是从最大尺寸中减去它的尺寸。如果宽度或高度大于最大值，则其中一个维度将为负，这使得减法表达式产生的 `QSize`
    对象无效。
- en: The `QImage.scaled()` method will return a new `QImage` object, which has been
    scaled to the provided `QSize` object. By specifying `KeepAspectRatio`, our width
    and height will be scaled separately so that the resulting size has an identical
    aspect ratio to the original.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`QImage.scaled()` 方法将返回一个新的 `QImage` 对象，该对象已经按照提供的 `QSize` 对象进行了缩放。通过指定 `KeepAspectRatio`，我们的宽度和高度将分别进行缩放，以使结果大小与原始大小具有相同的纵横比。'
- en: Now that we have our image, we can start painting on it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的图像，我们可以开始在上面绘画。
- en: The QPainter object
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`QPainter` 对象'
- en: At last, we get to meet the `QPainter` class! `QPainter` can be thought of as
    a little robot that lives inside your screen—to whom we can provide a brush and
    a pen, and issue drawing commands.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来认识一下 `QPainter` 类！`QPainter` 可以被认为是屏幕内部的一个小机器人，我们可以为它提供一个画笔和一个笔，然后发出绘图命令。
- en: 'Let''s create our painting `robot`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的绘画“机器人”：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The painter's constructor is passed a reference to the object on which it will
    paint. The object to be painted must be a subclass of `QPaintDevice`; in this
    case, we're passing a `QImage` object, which is such a class. The passed object
    will be the painter's canvas on which the painter will draw when we issue drawing
    commands.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图者的构造函数接收一个它将绘制的对象的引用。要绘制的对象必须是 `QPaintDevice` 的子类；在这种情况下，我们传递了一个 `QImage`
    对象，它是这样一个类。传递的对象将成为绘图者的画布，在这个画布上，当我们发出绘图命令时，绘图者将进行绘制。
- en: 'To see how basic painting works, let''s start with our top and bottom background
    blocks. We''ll first figure out the boundaries of the rectangles that we need
    to paint:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解基本绘画是如何工作的，让我们从顶部和底部的背景块开始。我们首先要弄清楚我们需要绘制的矩形的边界：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The coordinates used by `QPainter` start from the upper-left side of the painting
    surface. Therefore, the coordinates `(0, 0)` are the upper-left side of the screen,
    and `(width, height)` will be the lower-right of the screen.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPainter` 使用的坐标从绘画表面的左上角开始。因此，坐标 `(0, 0)` 是屏幕的左上角，而 `(width, height)` 将是屏幕的右下角。'
- en: To calculate the height of our top rectangle, we've multiplied the number of
    lines desired by the pixel height of our selected font (which we obtained from
    `QFontInfo`; see [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml), *Styling
    Qt Applications,* for more information about using `QFontInfo`). Finally, we add
    in the padding amount. We end up with a rectangle that starts at the origin (`(0,
    0)`) and ends on a point that is at the full width and height of the image of
    our box. These coordinates are used to create a `QRect` object representing the
    box area.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算我们顶部矩形的高度，我们将所需行数乘以我们选择的字体的像素高度（我们从 `QFontInfo` 中获取），最后加上填充量。我们最终得到一个从原点(`(0,
    0)`)开始并在框的图像的完整宽度和高度处结束的矩形。这些坐标用于创建一个表示框区域的 `QRect` 对象。
- en: For the bottom box, we will need to calculate from the bottom of the image; this
    means that we must first calculate the height of the rectangle and then *subtract*
    it from the height of the box. Then, we construct a rectangle that starts at that
    coordinate on the left-side and extends to the bottom-right.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于底部的框，我们需要从图像的底部计算；这意味着我们必须首先计算矩形的高度，然后从框的高度中*减去*它。然后，我们构造一个从左侧开始并延伸到右下角的矩形。
- en: '`QRect` coordinates must always be defined from upper-left to bottom-right.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`QRect` 坐标必须始终从左上到右下定义。'
- en: 'Now that we have our rectangles, let''s draw them:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的矩形，让我们来绘制它们：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`QPainter` has a number of drawing functions for creating lines, circles, polygons,
    and other shapes. In this case, we''re using `drawRect()`, which draws a rectangle.
    To define the fill of this rectangle, we''ve set the painter''s `brush` property
    to a `QBrush` object, which is set to our selected background color. The painter''s
    `brush` value determines the color and pattern with which it will fill any shape.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPainter` 有许多用于创建线条、圆圈、多边形和其他形状的绘图函数。在这种情况下，我们使用 `drawRect()`，它用于绘制矩形。为了定义这个矩形的填充，我们将绘图者的
    `brush` 属性设置为一个 `QBrush` 对象，该对象设置为我们选择的背景颜色。绘图者的 `brush` 值决定了它将用什么颜色和图案来填充任何形状。'
- en: 'In addition to `drawRect()`, `QPainter` contains a number of other drawing
    methods, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `drawRect()`，`QPainter` 还包含一些其他绘图方法，如下所示：
- en: '| Method | For drawing |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: 方法 | 用于绘制 |
- en: '| --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `drawEllipse()` | Circles and ellipses |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '`drawEllipse()` | 圆和椭圆 |'
- en: '| `drawLine()` | Straight lines |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '`drawLine()` | 直线 |'
- en: '| `drawRoundedRect()` | Rectangle with rounded corners |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '`drawRoundedRect()` | 带有圆角的矩形 |'
- en: '| `drawPolygon()` | Polygons of any kind |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '`drawPolygon()` | 任何类型的多边形 |'
- en: '| `drawPixmap()` | `QPixmap` objects |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '`drawPixmap()` | `QPixmap` 对象 |'
- en: '| `drawText()` | Text |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '`drawText()` | 文本 |'
- en: 'To place our meme text on the image, we need to use `drawText()`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的表情包文本放在图像上，我们需要使用 `drawText()`：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Before we draw the text, we need to give the painter a `QPen` object to define
    the text color and a `QFont` object to define the font used. The painter's `QPen`
    determines the color used for text, shape outlines, lines, and points drawn by
    our painter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制文本之前，我们需要给画家一个`QPen`对象来定义文本颜色，并给一个`QFont`对象来定义所使用的字体。画家的`QPen`确定了画家绘制的文本、形状轮廓、线条和点的颜色。
- en: To control where the text is drawn on the image, we could use the first argument
    to `drawText()`, which is a `QRect` object defining the bounding box for our text.
    However, since we don't know how many lines of text we're dealing with, we're
    just going to use the entire image as a bounding box and use vertical alignment
    to determine whether the text is written at the top or bottom.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制文本在图像上的绘制位置，我们可以使用`drawText()`的第一个参数，它是一个`QRect`对象，用于定义文本的边界框。然而，由于我们不知道我们要处理多少行文本，我们将使用整个图像作为边界框，并使用垂直对齐来确定文本是在顶部还是底部写入。
- en: Behaviors such as alignment and word-wrap are configured using flag values from
    the `QtCore.Qt.TextFlag` and `QtCore.Qt.AlignmentFlag` enums. In this case, we're
    specifying the center alignment and word wrap for both the top and bottom text,
    and then adding the vertical alignment option inside the `drawText()` call.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`QtCore.Qt.TextFlag`和`QtCore.Qt.AlignmentFlag`枚举的标志值来配置对齐和自动换行等行为。在这种情况下，我们为顶部和底部文本指定了居中对齐和自动换行，然后在`drawText()`调用中添加了垂直对齐选项。
- en: The last argument to `drawText()` is the actual text, which we've pulled from
    our `dict` data.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawText()`的最后一个参数是实际的文本，我们从我们的`dict`数据中提取出来。'
- en: 'Now that we''ve drawn our text, the final thing we need to do is set the image
    in our image display label:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经绘制了文本，我们需要做的最后一件事是在图像显示标签中设置图像：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At this point, you should be able to start up the program and create an image.
    Go ahead and try it out!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你应该能够启动程序并创建一个图像。试试看吧！
- en: Saving our image
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存我们的图像
- en: 'After creating a snazzy meme image, our user probably wants to save it so that
    they can upload it to their favorite social media website. To enable that, let''s
    head back to `MainWindow.__init_()` and create a toolbar:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个时髦的迷因图像后，我们的用户可能想要保存它，以便他们可以将其上传到他们最喜欢的社交媒体网站。为了实现这一点，让我们回到`MainWindow.__init_()`并创建一个工具栏：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You could, of course, do this using the menu options or another widget. In
    any case, we need to define the `save_image()` method called by this action:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以使用菜单选项或其他小部件来做到这一点。无论如何，我们需要定义由此操作调用的`save_image()`方法：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To save a `QImage` file to disk, we need to call its `save()` method with a
    file path string and a second string defining the image format. In this case,
    we're going to retrieve a save location using `QFileDialog.getSaveFileName()`
    and save it in the `PNG` format.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`QImage`文件保存到磁盘，我们需要使用文件路径字符串和第二个字符串定义图像格式调用其`save()`方法。在这种情况下，我们将使用`QFileDialog.getSaveFileName()`来检索保存位置，并以`PNG`格式保存。
- en: 'If you run your meme generator, you should find that it looks something like
    the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行你的迷因生成器，你应该会发现它看起来像下面的截图：
- en: '![](assets/ce619532-1f47-4b59-bcbf-e28f4e9401a2.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ce619532-1f47-4b59-bcbf-e28f4e9401a2.png)'
- en: As an additional exercise, try thinking up some other things that you'd like
    to draw on a meme and add this capability to the code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的练习，尝试想出一些其他你想在迷因上绘制的东西，并将这个功能添加到代码中。
- en: Custom widgets with QPainter
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QPainter创建自定义小部件
- en: '`QPainter` is not merely a specialized tool for drawing on images; it''s actually
    the workhorse that draws all the graphics for all the widgets in Qt. In other
    words, every pixel of every widget you see in your PyQt application was drawn
    by a `QPainter` object. We can take control of `QPainter` to create a purely custom
    widget.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`QPainter`不仅仅是一个专门用于在图像上绘制的工具；它实际上是为Qt中所有小部件绘制所有图形的工作马。换句话说，你在PyQt应用程序中看到的每个小部件的每个像素都是由`QPainter`对象绘制的。我们可以控制`QPainter`来创建一个纯自定义的小部件。'
- en: To explore this idea, let's create a CPU monitor application. Get a fresh copy
    of the Qt application template and call it `cpu_graph.py`, and then we'll begin.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这个想法，让我们创建一个CPU监视器应用程序。获取Qt应用程序模板的最新副本，将其命名为`cpu_graph.py`，然后我们将开始。
- en: Building a GraphWidget
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个GraphWidget
- en: Our CPU monitor will display real-time CPU activity using an area graph. The
    graph will be enhanced by a color gradient, which will show higher values in a
    different color from lower values. The graph will only show a configured number
    of values at one time, scrolling old values off to the left side of the widget
    as new ones are added from the right.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的CPU监视器将使用区域图显示实时CPU活动。图表将通过颜色渐变进行增强，高值将以不同颜色显示，低值将以不同颜色显示。图表一次只显示配置数量的值，随着从右侧添加新值，旧值将滚动到小部件的左侧。
- en: 'To accomplish this, we need to build a custom widget. We''ll call it `GraphWidget`,
    and begin it as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要构建一个自定义小部件。我们将其命名为`GraphWidget`，并开始如下：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The custom widget begins with some class properties to define colors for *good*,
    *warning*, and *critical* values. Feel free to change these if you prefer.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义小部件从一些类属性开始，用于定义*good*、*warning*和*critical*值的颜色。如果你愿意，可以随意更改这些值。
- en: 'Our constructor takes a number of keyword arguments, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构造函数接受一些关键字参数，如下所示：
- en: '`data_width`: This refers to how many values will be displayed at a time'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data_width`：这指的是一次将显示多少个值'
- en: '`minimum` and `maximum`: The minimum and maximum values to be displayed'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minimum`和`maximum`：要显示的最小和最大值'
- en: '`warn_val` and `crit_val`: These are threshold values for color changes'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`warn_val`和`crit_val`：这些是颜色变化的阈值值'
- en: '`Scale`: This refers to how many pixels will be used on each data point'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scale`：这指的是每个数据点将使用多少像素'
- en: 'Our next step is to save all of these values as instance properties:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是将所有这些值保存为实例属性：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To store our values, we require something like a Python `list` but constrained
    to a fixed number of items. Python''s `collections` module offers the perfect
    object for this: the `deque` class.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储我们的值，我们需要类似Python `list`的东西，但受限于固定数量的项目。Python的`collections`模块为此提供了完美的对象：`deque`类。
- en: 'Let''s import this class at the top of our code block:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码块的顶部导入这个类：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `deque` class can take a `maxlen` argument, which will limit its length.
    When new items are appended to the `deque` class, pushing it beyond its `maxlen`
    value, old items will be dropped from the beginning of the list to keep it under
    the limit. This is perfect for our graph since we only want to display a fixed
    number of data points in the graph at one time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`deque`类可以接受一个`maxlen`参数，这将限制其长度。当新项目附加到`deque`类时，将其推到其`maxlen`值之外，旧项目将从列表的开头删除，以使其保持在限制之下。这对于我们的图表非常完美，因为我们只想在图表中同时显示固定数量的数据点。'
- en: 'We''ll create our `deque` class as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建我们的`deque`类如下：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`deque` can take a `list` as an argument, which will be used to initialize
    its data. In this case, we''re initializing it with a `list` of `data_width` items
    containing our minimum value and setting the `maxlen` value of the `deque` class
    to `data_width`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`deque`可以接受一个`list`作为参数，该参数将用于初始化其数据。在这种情况下，我们使用一个包含最小值的`data_width`项的`list`进行初始化，并将`deque`类的`maxlen`值设置为`data_width`。'
- en: You can create a list of *N* items quickly in Python by multiplying a list of
    1 item by *N*, as we've done here; for example, `[2] * 4` will create a list of `[2,
    2, 2, 2]`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将包含1个项目的列表乘以*N*在Python中快速创建*N*个项目的列表，就像我们在这里所做的那样；例如，`[2] * 4`将创建一个列表`[2,
    2, 2, 2]`。
- en: We finish off the `__init__()` method by setting the fixed width of the widget
    to `data_width * scale`, which represents the total number of pixels that we want
    to display.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将小部件的固定宽度设置为`data_width * scale`来完成`__init__()`方法，这代表了我们想要显示的总像素数。
- en: 'Next, we need a method to add a new value to our `deque` class, which we''ll
    call `add_value()` :'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个方法来向我们的`deque`类添加一个新值，我们将其称为`add_value()`：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The method begins by constraining our value between the minimum and maximum
    values and then appending it to the `deque` object.  This has the additional effect
    of popping the first item off the beginning of the `deque` object so that it remains
    at the `data_width` value.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先通过将我们的值限制在最小值和最大值之间，然后将其附加到`deque`对象上。这还有一个额外的效果，即将`deque`对象的开头弹出第一项，使其保持在`data_width`值。
- en: Finally, we call `update()`, which is a `QWidget` method that tells the widget
    to redraw itself. We'll handle this drawing process next.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用`update()`，这是一个`QWidget`方法，告诉小部件重新绘制自己。我们将在下一步处理这个绘图过程。
- en: Painting the widget
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制小部件
- en: The `QWidget` class, just like `QImage`, is a subclass of `QPaintDevice`; as
    such, we can use a `QPainter` object to draw directly onto the widget. When a
    widget gets a request to redraw itself (similar to how we issued our call to `update()`),
    it calls its `paintEvent()` method. We can override this method with our own drawing
    commands to define a custom look for our widget.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`QWidget`类，就像`QImage`一样，是`QPaintDevice`的子类；因此，我们可以使用`QPainter`对象直接在小部件上绘制。当小部件收到重新绘制自己的请求时（类似于我们发出`update()`的方式），它调用其`paintEvent()`方法。我们可以用我们自己的绘图命令覆盖这个方法，为我们的小部件定义一个自定义外观。'
- en: 'Let''s start the method as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式开始该方法：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`paintEvent()` will be called with one argument, a `QPaintEvent` object. This
    object contains information about the event that requested the repaint – most
    notably, the region and rectangle that needs to be redrawn. For a complex widget,
    we can use this information to only redraw requested parts. For our simple widget,
    we''re going to ignore this information and just redraw the whole thing.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`paintEvent()`将被调用一个参数，一个`QPaintEvent`对象。这个对象包含有关请求重绘的事件的信息 - 最重要的是，需要重绘的区域和矩形。对于复杂的小部件，我们可以使用这些信息来仅重绘请求的部分。对于我们简单的小部件，我们将忽略这些信息，只重绘整个小部件。'
- en: 'We''ve defined a painter object that is pointed to the widget itself, so any
    commands we issue to the painter will be drawn on our widget. Let''s start by
    creating a background:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个指向小部件本身的画家对象，因此我们向画家发出的任何命令都将在我们的小部件上绘制。让我们首先创建一个背景：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Just as we did in our meme generator, we're defining a brush, giving it to our
    painter, and drawing a rectangle.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在我们的模因生成器中所做的那样，我们正在定义一个画刷，将其给我们的画家，并画一个矩形。
- en: Notice that we're using an alternate form of `drawRect()` here, which takes
    coordinates directly instead of a `QRect` object.  Many of the `QPainter` object's
    drawing functions have alternate versions that take slightly different types of
    arguments for flexibility.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里使用了`drawRect()`的另一种形式，它直接取坐标而不是`QRect`对象。`QPainter`对象的许多绘图函数都有取稍微不同类型参数的替代版本，以增加灵活性。
- en: 'Next, let''s draw some dotted lines to show where the thresholds for warning
    and critical are. To do this, we''re going to need to translate a raw data value
    to a *y* coordinate on the widget. Since this will need to happen often, let''s
    create a convenient method to convert values to *y* coordinates:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们画一些虚线，显示警告和临界的阈值在哪里。为此，我们需要将原始数据值转换为小部件上的*y*坐标。由于这将经常发生，让我们创建一个方便的方法来将值转换为*y*坐标：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To convert a value to a *y* coordinate, we need to first determine what fraction
    of the data range the value represents. We then multiply that fraction by the
    height of the widget to determine how many pixels it should be from the bottom
    of the widget. Then, because pixel coordinates count *down* from the top, we have
    to subtract our offset from the height of the widget to determine the *y* coordinate.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要将值转换为*y*坐标，我们首先需要确定值代表数据范围的什么比例。然后，我们将该分数乘以小部件的高度，以确定它应该离小部件底部多少像素。然后，因为像素坐标从顶部开始计数*向下*，我们必须从小部件的高度中减去我们的偏移量，以确定*y*坐标。
- en: 'Back in `paintEvent()`, let''s use this method to draw a warning threshold
    line:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`paintEvent()`，让我们使用这个方法来画一个警告阈值线：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since we're drawing a line, we need to set the painter's `pen` property. The
    `QPen.setDashPattern()` method allows us to define a dash pattern for the line
    by passing it a list of `1` and `0` values, representing drawn or not-drawn pixels.
    In this case, our pattern will alternate between a drawn pixel and an empty pixel.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在绘制一条线，我们需要设置绘图者的`pen`属性。`QPen.setDashPattern()`方法允许我们通过向其传递`1`和`0`值的列表来为线定义虚线模式，表示绘制或未绘制的像素。在这种情况下，我们的模式将在绘制像素和空像素之间交替。
- en: With the pen created, we use our new conversion method to convert our `warn_val` value
    to a *y* coordinate and set the color of the pen to `warn_color`. We hand the
    configured pen to our painter and instruct it to draw a line across the width
    of the widget at the *y* coordinate that we calculated.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了笔之后，我们使用我们的新转换方法将`warn_val`值转换为*y*坐标，并将笔的颜色设置为`warn_color`。我们将配置好的笔交给我们的绘图者，并指示它在我们计算出的*y*坐标处横跨小部件的宽度绘制一条线。
- en: 'The same approach can be used to draw our critical threshold line:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法可以用来绘制我们的临界阈值线：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can reuse our `QPen` object, but remember that any time we make changes to
    a pen or brush, we have to reassign it to the painter. The painter is passed a
    copy of the pen or brush, so the changes that we make to the object *after* assigning
    it to a painter are not implicitly passed along to the pen or brush that is used.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用我们的`QPen`对象，但请记住，每当我们对笔或刷子进行更改时，我们都必须重新分配给绘图者。绘图者传递了笔或刷子的副本，因此我们对对象进行的更改*在*分配给绘图者之后不会隐式传递给使用的笔或刷子。
- en: In [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml), *Styling Qt Applications,*
    you learned how to make a gradient object and apply it to a `QBrush` object. We'll
    want to use a gradient in this application to draw our data values so that high
    values are red at the top, medium values are yellow, and low values are green.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml)中，*Qt应用程序的样式*，您学习了如何创建一个渐变对象并将其应用于`QBrush`对象。在这个应用程序中，我们希望使用渐变来绘制我们的数据值，使得高值在顶部为红色，中等值为黄色，低值为绿色。
- en: 'Let''s define a `QLinearGradient` gradient object as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个`QLinearGradient`渐变对象如下：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This gradient will go from the bottom of the widget (`self.height()`) to the
    top (`0`). This is important to remember because, as we define the color stops,
    a `0` location indicates the start of the gradient (which is at the bottom of
    the widget) and a `1` location will indicate the end of the gradient (which is
    at the top).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个渐变将从小部件的底部（`self.height()`）到顶部（`0`）进行。这一点很重要要记住，因为在定义颜色停止时，`0`位置表示渐变的开始（即小部件的底部），`1`位置将表示渐变的结束（即顶部）。
- en: 'We''ll set our color stops as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置我们的颜色停止如下：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Similar to how we calculated the *y* coordinates, here, we're determining the
    fraction of the data range represented by the warning and critical values by dividing
    them by the difference between the minimum and maximum values. This fraction is
    what `setColorAt()` needs for its first argument.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们计算*y*坐标的方式，在这里，我们通过将警告和临界值除以最小值和最大值之间的差来确定数据范围表示的警告和临界值的分数。这个分数是`setColorAt()`需要的第一个参数。
- en: 'Now that we have a gradient, let''s set up our painter for drawing the data:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个渐变，让我们为绘制数据设置我们的绘图者：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To make our area graph look smooth and cohesive, we don't want any outlines
    on the chart sections. To stop `QPainter` from outlining shapes, we're setting
    our pen to a special constant: `QtCore.Qt.NoPen`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的面积图看起来平滑和连贯，我们不希望图表部分有任何轮廓。为了阻止`QPainter`勾勒形状，我们将我们的笔设置为一个特殊的常数：`QtCore.Qt.NoPen`。
- en: To create our area chart, each data point is going to be represented by a quadrilateral,
    where the upper-right corner will be the current data point and the upper left
    corner will be the previous data point. The width will be equal to the `scale`
    property we set in the constructor.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的面积图，每个数据点将由一个四边形表示，其中右上角将是当前数据点，左上角将是上一个数据点。宽度将等于我们在构造函数中设置的`scale`属性。
- en: 'Since we''re going to need a *previous* value for each data point, we need
    to start with a bit of bookkeeping:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将需要每个数据点的*上一个*值，我们需要从一点开始进行一些簿记：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The first thing we need to do is to determine a starting value. Since we need
    a value *before* our current value, our first item needs a place to start drawing.
    We're going to create an instance variable called `start_value`, which persists
    between calls to `paintEvent` and stores the value, to begin with. We then assign
    that to `last_value`, which is a local variable that will be used to remember
    the previous value for each iteration of the loop. Finally, we update the start
    value for the *next* call to `paintEvent` as the first value of the `deque` object.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是确定一个起始值。由于我们需要在当前值*之前*有一个值，我们的第一项需要一个开始绘制的地方。我们将创建一个名为`start_value`的实例变量，它在`paintEvent`调用之间保持不变，并存储初始值。然后，我们将其赋值给`last_value`，这是一个本地变量，将用于记住循环的每次迭代的上一个值。最后，我们将起始值更新为`deque`对象的第一个值，以便*下一次*调用`paintEvent`。
- en: 'Now, let''s start looping through the data and calculating `x` and `y` values
    for each point:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始循环遍历数据并计算每个点的`x`和`y`值：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The two *x* coordinates for the polygon will be (`1`) the index of the value
    multiplied by the scale, and (`2`) the scale multiplied by the index of the value
    plus one. For the *y* values, we pass the current and last values to our conversion
    method. These four values will give us the ability to draw a four-sided shape
    representing a change from one point of data to the next.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形的两个*x*坐标将是（1）值的索引乘以比例，和（2）比例乘以值的索引加一。对于*y*值，我们将当前值和上一个值传递给我们的转换方法。这四个值将使我们能够绘制一个四边形，表示从一个数据点到下一个数据点的变化。
- en: To draw that shape, we're going to use something called a `QPainterPath` object.
    In digital graphics, a **path** is an object built from individual line segments
    or shapes combined together. The `QPainterPath` object allows us to create a unique
    shape by drawing each side individually in code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制该形状，我们将使用一个称为`QPainterPath`的对象。在数字图形中，**路径**是由单独的线段或形状组合在一起构建的对象。`QPainterPath`对象允许我们通过在代码中逐个绘制每一边来创建一个独特的形状。
- en: 'Let''s start drawing our path object using the `x` and `y` data we''ve calculated:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用我们计算出的`x`和`y`数据开始绘制我们的路径对象：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To draw a path, we begin by creating a `QPainterPath` object. We then use its
    `moveTo()` method to set a starting point for drawing. We then connect the four
    corners of the path using the `lineTo()` method to draw a straight line between
    the points. The last connection between our end and start points is made automatically.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制路径，我们首先创建一个`QPainterPath`对象。然后我们使用它的`moveTo()`方法设置绘制的起始点。然后我们使用`lineTo()`方法连接路径的四个角，以在点之间绘制一条直线。最后一个连接我们的结束点和起始点是自动完成的。
- en: Note that we're not actually drawing on the screen at this point; we're merely
    defining an object that our painter can paint to the screen using its current
    brush and pen.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此时我们实际上并没有在屏幕上绘制；我们只是在定义一个对象，我们的绘图器可以使用其当前的画笔和笔将其绘制到屏幕上。
- en: 'Let''s draw this object:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们绘制这个对象：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We've finished out the method by painting the path and updating the last value
    to the current value. Of course, this path, which is made of straight lines, is
    rather dull—we could have just used the painter's `drawPolygon()` method for this.
    The real power of using a `QPainterPath` object is to take advantage of some of
    its non-linear drawing methods.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过绘制路径和更新最后一个值到当前值来完成了这个方法。当然，这条由直线组成的路径相当乏味——我们本可以只使用绘图器的`drawPolygon()`方法。使用`QPainterPath`对象的真正威力在于利用它的非线性绘制方法。
- en: 'For example, if we want our chart to be smooth and rounded rather than jagged,
    then we can draw the last line (which is the top of the shape) using a **cubic
    Bezier curve** rather than a straight line:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们希望我们的图表是平滑和圆润的，而不是锯齿状的，那么我们可以使用**立方贝塞尔曲线**来绘制最后一条线（即形状的顶部），而不是直线：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A cubic Bezier curve uses two control points to define its curve. Each control
    point *pulls* a segment of the line towards it—the first control point pulling
    the first half of the line, and the second control point pulling the second half
    of the line:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 贝塞尔曲线使用两个控制点来定义其曲线。每个控制点都会将线段拉向它自己——第一个控制点拉动线段的前半部分，第二个控制点拉动线段的后半部分：
- en: '![](assets/004dbd50-bd0b-40cc-8967-020135f4a640.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/004dbd50-bd0b-40cc-8967-020135f4a640.png)'
- en: We're setting the first control point at the last *y* value and the second control
    point at the current *y* value—both of these are halfway between the start and
    end *x* values. This gives us an *S* curve on the upward slopes and a reverse
    *S* curve on the downward slopes, resulting in softer peaks and valleys.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将第一个控制点设置为最后的y值，将第二个控制点设置为当前的y值——这两个值都是开始和结束x值的中间值。这给我们在上升斜坡上一个S形曲线，在下降斜坡上一个反S形曲线，从而产生更柔和的峰值和谷值。
- en: After setting up the `GraphWidget` object in an application, you can try switching
    between the curve and line commands to see the difference.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中设置`GraphWidget`对象后，您可以尝试在曲线和线命令之间切换以查看差异。
- en: Using GraphWidget
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GraphWidget
- en: Our graph widget is finished, so let's head down to `MainWindow` and use it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图形小部件已经完成，所以让我们转到`MainWindow`并使用它。
- en: 'Start by creating your widget and making it the central widget:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建您的小部件并将其设置为中央小部件：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, let''s create a method that will read the current CPU usage and send
    it to `GraphWidget`. To do this, we''ll need to import the `cpu_percent` function
    from the `psutil` library:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个方法，该方法将读取当前的CPU使用情况并将其发送到`GraphWidget`。为此，我们需要从`psutil`库导入`cpu_percent`函数：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we can write our graph-updating method as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写我们的图形更新方法如下：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `cpu_percent()` function returns an integer from 0 to 100, reflecting the
    current CPU utilization on your computer. This is perfect for sending directly
    to our `GraphWidget`, whose default range is 0 to 100.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpu_percent()`函数返回一个从0到100的整数，反映了计算机当前的CPU利用率。这非常适合直接发送到我们的`GraphWidget`，其默认范围是0到100。'
- en: 'Now we just need to call this method periodically to update the graph; back
    in `MainWindow.__init__()`, add the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要定期调用这个方法来更新图形；在`MainWindow.__init__()`中，添加以下代码：
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is just a `QTimer` object, which you learned about in [Chapter 10](06a74416-66c5-4538-9dc5-c540a3a44da9.xhtml),
    *Multithreading with QTimer and QThread,* set to call `update_graph()` on a one-second
    interval.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个`QTimer`对象，您在[第10章](06a74416-66c5-4538-9dc5-c540a3a44da9.xhtml)中学到的，*使用QTimer和QThread进行多线程处理*，设置为每秒调用一次`update_graph()`。
- en: 'If you run the application now, you should get something like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行应用程序，您应该会得到类似于这样的结果：
- en: '![](assets/9f215c0b-8fcb-4e0d-acbf-b344e4bf5605.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9f215c0b-8fcb-4e0d-acbf-b344e4bf5605.png)'
- en: Notice the smooth peaks created by our Bezier curves. If you switch back to
    the straight-line code, you'll see those peaks sharpen up.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的贝塞尔曲线所创建的平滑峰值。如果切换回直线代码，您将看到这些峰值变得更加尖锐。
- en: 'If your CPU is too powerful to provide an interesting activity graph, try the
    following changes to `update_graph()` for a better test of the widget:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的CPU太强大，无法提供有趣的活动图，请尝试对`update_graph()`进行以下更改以更好地测试小部件：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will just spit out random values between `1` and `100` and should make
    for some fairly chaotic results.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只输出介于`1`和`100`之间的随机值，并且应该产生一些相当混乱的结果。
- en: Seeing this CPU graph animated in real-time might make you wonder about the
    animation capabilities of Qt. In the next section, we'll learn how to create 2D
    animations in Qt using `QPainter` in conjunction with the Qt Graphics View framework.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这个CPU图表实时动画可能会让您对Qt的动画能力产生疑问。在下一节中，我们将学习如何使用`QPainter`和Qt图形视图框架一起创建Qt中的2D动画。
- en: Animating 2D graphics with QGraphicsScene
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QGraphicsScene进行2D图形动画
- en: Painting on a `QPaintDevice` object works well for simple widgets and image
    editing, but in situations where we want to draw a large number of 2D objects,
    and possibly animate them in real-time, we need a more powerful object. Qt provides
    the Graphics View Framework, an item-based model-view framework for composing
    complex 2D graphics and animations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的小部件和图像编辑中，对`QPaintDevice`对象进行绘制效果很好，但在我们想要绘制大量的2D对象，并可能实时地对它们进行动画处理的情况下，我们需要一个更强大的对象。Qt提供了Graphics
    View Framework，这是一个基于项目的模型视图框架，用于组合复杂的2D图形和动画。
- en: To explore how this framework operates, we're going to create a game called
    **Tankity Tank Tank Tank**.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这个框架的运作方式，我们将创建一个名为**Tankity Tank Tank Tank**的游戏。
- en: First steps
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一步
- en: This tank game will be a two-player combat game modeled after the kind of simple
    action game you might find on a classic 1980s game system. One player will be
    at the top of the screen, one at the bottom, and the two tanks will move constantly
    from left to right while each player tries to shoot the other with a single bullet.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个坦克游戏将是一个两人对战游戏，模拟了你可能在经典的1980年代游戏系统上找到的简单动作游戏。一个玩家将在屏幕顶部，一个在底部，两辆坦克将不断从左到右移动，每个玩家都试图用一颗子弹射击对方。
- en: 'To get started, copy your Qt application template to a new file called `tankity_tank_tank_tank.py`.
    Starting just after the `import` statements at the top of the file, we''ll add
    a few constants:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，将您的Qt应用程序模板复制到一个名为`tankity_tank_tank_tank.py`的新文件中。从文件顶部的`import`语句之后开始，我们将添加一些常量：
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'These constants will be used throughout the game code to calculate sizes and
    locations. In fact, we''ll use two of them right away in `MainWindow.__init__()`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些常量将在整个游戏代码中用于计算大小和位置。实际上，我们将立即在`MainWindow.__init__()`中使用其中的两个：
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is all the code we''re going to add into `MainWindow`. After resizing
    the window to our width and height constants, we''ll create two objects, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要添加到`MainWindow`中的所有代码。在将窗口调整大小为我们的宽度和高度常量之后，我们将创建两个对象，如下：
- en: The first is a `Scene` object. This is a custom class we're going to create,
    subclassed from `QGraphicsScene`. `QGraphicsScene` is the model in this model-view
    framework and represents a 2D scene containing a variety of graphics items.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是`Scene`对象。这是一个我们将要创建的自定义类，是从`QGraphicsScene`派生的。`QGraphicsScene`是这个模型视图框架中的模型，表示包含各种图形项目的2D场景。
- en: The second is the `QGraphicsView` object, which is the view component of the
    framework. This widget's job is simply to render the scene and display it for
    the user.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是`QGraphicsView`对象，它是框架的视图组件。这个小部件的工作只是渲染场景并将其显示给用户。
- en: Our `Scene` object is going to contain most of the code for the game, so we
    will build that part next.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Scene`对象将包含游戏的大部分代码，所以我们将下一步构建那部分。
- en: Making a scene
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个场景
- en: The `Scene` class will be the main stage for our game and will manage all the
    various objects involved in the game, such as the tanks, bullets, and walls. It
    will also display the scores and keep track of other game logic.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scene`类将是我们游戏的主要舞台，并将管理游戏中涉及的各种对象，如坦克、子弹和墙壁。它还将显示分数并跟踪其他游戏逻辑。'
- en: 'Let''s start it as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样开始：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first thing we've done here is to paint our scene black by setting the `backgroundBrush` property.
    This property, naturally, takes a `QBrush` object, which it will use to fill the
    background of the scene. We've also set the `sceneRect` property, which describes
    the size of the scene, to a `QRect` object set to our width and height constants.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的第一件事是通过设置`backgroundBrush`属性将我们的场景涂成黑色。这个属性自然地需要一个`QBrush`对象，它将用来填充场景的背景。我们还设置了`sceneRect`属性，它描述了场景的大小，设置为我们的宽度和高度常量的`QRect`对象。
- en: 'To begin placing objects on the scene, we can use one of its many add methods:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始在场景上放置对象，我们可以使用它的许多add方法之一：
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we've used `addRect()` to draw two rectangles on the scene—one across
    the bottom for a floor and one across the top for a ceiling. Just like the `QPainter`
    class, `QGraphicsScene` has methods to add ellipses, pixmaps, lines, polygons,
    text, and other such items. Unlike the painter, however, the `QGraphicsScene`
    methods don't just draw pixels to the screen; instead, they create items of the
    `QGraphicsItem` class (or a subclass). We can subsequently query or manipulate
    the items created.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`addRect()`在场景上绘制了两个矩形——一个在底部作为地板，一个在顶部作为天花板。就像`QPainter`类一样，`QGraphicsScene`有方法来添加椭圆、像素图、线、多边形、文本和其他这样的项目。然而，与绘图程序不同，`QGraphicsScene`方法不仅仅是将像素绘制到屏幕上；相反，它们创建了`QGraphicsItem`类（或其子类）的项目。我们随后可以查询或操作所创建的项目。
- en: 'For example, we can add some text items to display our scores as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以添加一些文本项目来显示我们的分数，如下所示：
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, after creating the text items, we are manipulating their properties and
    setting the position of each text item using the `setPos()` method.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在创建文本项目之后，我们正在操作它们的属性，并使用`setPos()`方法设置每个文本项目的位置。
- en: 'We can also update the text in the items; for example, let''s create methods
    to update our scores:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以更新项目中的文本；例如，让我们创建方法来更新我们的分数：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If you think about `QPainter` as being analogous to painting on paper, adding
    `QGraphicsItems` to a `QGraphicsScene` class is analogous to placing felt shapes
    on a flannel-graph. The items are *on* the scene, but they not part of it and,
    subsequently, they can be altered or removed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你把`QPainter`比作在纸上绘画，那么把`QGraphicsItems`添加到`QGraphicsScene`类就相当于在毛毯图上放置毛毡形状。项目*在*场景上，但它们不是场景的一部分，因此它们可以被改变或移除。
- en: Creating the tanks
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建坦克
- en: Our game will have two tanks, one at the top of the screen and one at the bottom.
    These will be drawn on the `Scene` object and be animated so that the players
    can move them left and right. In [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml),
    *Styling Qt Applications,* you learned that animation can be done using `QPropertyAnimation`,
    but *only* if the property being animated belongs to a descendant of `QObject`.
    `QGraphicsItem` is *not* a `QObject` descendant, but the `QGraphicsObject` object
    combines both to provide us with a graphics item that we can animate.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏将有两辆坦克，一辆在屏幕顶部，一辆在底部。这些将在`Scene`对象上绘制，并进行动画处理，以便玩家可以左右移动它们。在[第6章](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml)中，*Qt应用程序的样式*，您学到了可以使用`QPropertyAnimation`进行动画处理，但是*只有*被动画处理的属性属于`QObject`的后代。`QGraphicsItem`不是`QObject`的后代，但`QGraphicsObject`对象将两者结合起来，为我们提供了一个可以进行动画处理的图形项。
- en: 'Therefore, we''ll need to build our `Tank` class as a subclass of `QGraphicsObject`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要将我们的`Tank`类构建为`QGraphicsObject`的子类：
- en: '[PRE51]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This class begins by defining two constants, `TOP`, and `BOTTOM`. These will
    be used to signify whether we're creating the tank at the top of the screen or
    the bottom.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类首先定义了两个常量，`TOP`和`BOTTOM`。这将用于表示我们是在屏幕顶部还是底部创建坦克。
- en: '`TANK_BM` is a `bytes` object that contains data for an 8 × 8 bitmap of a tank
    graphic. We''ll see how this works shortly.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`TANK_BM`是一个包含坦克图形的8×8位图数据的`bytes`对象。我们很快就会看到这是如何工作的。'
- en: 'First, though, let''s begin the constructor:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们开始构造函数：
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Our tank will be given a color, a *y* coordinate, and a `side` value, which
    will be either `TOP` or `BOTTOM`. We'll use this information to position and orient
    the tank.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的坦克将被赋予颜色、*y*坐标和`side`值，该值将是`TOP`或`BOTTOM`。我们将使用这些信息来定位和定向坦克。
- en: 'Next, let''s use our `bytes` string to create a bitmap for our tank:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用我们的`bytes`字符串为我们的坦克创建一个位图：
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: A `QBitmap` object is a special case of `QPixmap` for monochromatic images.
    By passing a size and `bytes` object to the `fromData()` static method, we can
    generate a simple bitmap object without needing a separate image file.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`QBitmap`对象是`QPixmap`的单色图像的特殊情况。通过将大小和`bytes`对象传递给`fromData()`静态方法，我们可以生成一个简单的位图对象，而无需单独的图像文件。'
- en: To understand how this works, consider the `TANK_BM` string. Because we're interpreting
    it as an 8 × 8 graphic, each byte (which is 8 bits) in this string corresponds
    to one row of the graphic.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这是如何工作的，请考虑`TANK_BM`字符串。因为我们将其解释为8×8图形，所以该字符串中的每个字节（8位）对应于图形的一行。
- en: 'If you were to convert each row to binary numbers and lay them out one byte
    per line, it would look like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将每一行转换为二进制数字并将它们按每行一个字节的方式排列，它将如下所示：
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The shape created by the ones is essentially the shape that this bitmap will
    take. Of course, an 8x8 graphic will be quite small, so we ought to enlarge it.
    Additionally, this tank is clearly pointing up, so if we're the top tank, we need
    to flip it over.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由1创建的形状实质上是该位图将采用的形状。当然，8x8的图形将非常小，所以我们应该将其放大。此外，这辆坦克显然是指向上的，所以如果我们是顶部的坦克，我们需要将其翻转过来。
- en: 'We can do both of those things using a `QTransform` object:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`QTransform`对象来完成这两件事：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: A `QTransform` object represents a set of transformations to be done on `QPixmap`
    or `QBitmap`. After creating the transform object, we can set the various transformations
    to be applied, starting with a scaling operation and adding a `rotate` transformation
    if the tank is on the top. The `QTransform` object can be passed to a bitmap `transformed()`
    method, which returns a new `QBitmap` object with the transformations applied.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTransform`对象表示要在`QPixmap`或`QBitmap`上执行的一组变换。创建变换对象后，我们可以设置要应用的各种变换，首先是缩放操作，然后是添加`rotate`变换（如果坦克在顶部）。`QTransform`对象可以传递给位图的`transformed()`方法，该方法返回一个应用了变换的新`QBitmap`对象。'
- en: 'The bitmap is monochromatic and, by default, it draws in black. To draw in
    another color, we will need a `QPen` (not a brush!) object set to the desired
    color. Let''s use our `color` argument to create this as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 该位图是单色的，默认情况下是黑色。要以其他颜色绘制，我们将需要一个设置为所需颜色的`QPen`（而不是刷子！）对象。让我们使用我们的`color`参数按如下方式创建它：
- en: '[PRE56]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The actual appearance of the `QGraphicsObject` object is determined by overriding
    the `paint()` method. Let''s create this as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`QGraphicsObject`对象的实际外观是通过重写`paint()`方法确定的。让我们按照以下方式创建它：'
- en: '[PRE57]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The first argument to `paint()` is the `QPainter` object, which Qt has created
    and assigned to paint the object. We simply need to apply commands to that painter,
    which will draw the image as we desire. We'll start by setting the `pen` property
    to the pen we've created, and then use the painter's `drawPixmap()` method to
    draw our bitmap.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`paint()`的第一个参数是`QPainter`对象，Qt已经创建并分配给绘制对象。我们只需要对该绘图程序应用命令，它将根据我们的要求绘制图像。我们将首先将`pen`属性设置为我们创建的笔，然后使用绘图程序的`drawPixmap()`方法来绘制我们的位图。'
- en: Note that the coordinates we pass to `drawPixmap()` do not refer to coordinates
    of the `QGraphicsScene` class, but coordinates within the bounding rectangle of
    the `QGraphicsObject` object itself. Because of that, we need to make sure that
    our object returns a proper bounding rectangle so that our image is drawn correctly.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们传递给`drawPixmap()`的坐标不是`QGraphicsScene`类的坐标，而是`QGraphicsObject`对象本身的边界矩形内的坐标。因此，我们需要确保我们的对象返回一个适当的边界矩形，以便我们的图像被正确绘制。
- en: 'To do this, we''ll need to override the `boundingRect()` method:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要重写`boundingRect()`方法：
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this case, we want our `boundingRect()` method to return a rectangle that
    is the same size as the bitmap.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望我们的`boundingRect()`方法返回一个与位图大小相同的矩形。
- en: 'Back in `Tank.__init__()`, let''s position our tank:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`Tank.__init__()`，让我们定位我们的坦克：
- en: '[PRE59]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `QGraphicsObject.setPos()` method allows you to position the object anywhere
    on its assigned `QGraphicsScene` using pixel coordinates. Since pixel coordinates
    always count from the top-left of the object, we need to adjust the *y* coordinate
    of our object if it is on the bottom of the screen, raising it by its own height
    so that the *bottom* of the tank is at `y_pos` pixels from the top.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`QGraphicsObject.setPos()`方法允许您使用像素坐标将对象放置在其分配的`QGraphicsScene`上的任何位置。由于像素坐标始终从对象的左上角计数，如果对象在屏幕底部，我们需要调整对象的*y*坐标，使其自身高度升高，以便坦克的*底部*距离屏幕顶部`y_pos`像素。'
- en: The position of an object always indicates the position of its upper-left corner.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的位置始终表示其左上角的位置。
- en: Now we want to animate our tanks; each tank will move back and forth along the
    *x* axis, bouncing back when it hits the edge of the screen.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想要让我们的坦克动起来；每个坦克将在*x*轴上来回移动，在触碰屏幕边缘时会反弹。
- en: 'Let''s create a `QPropertyAnimation` method to do this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`QPropertyAnimation`方法来实现这一点：
- en: '[PRE60]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `QGraphicsObject` object has `x` and `y` properties that define its *x*
    and *y* coordinates on the scene, so animating the object is as simple as directing
    our property animation to these properties. We're going to animate `x` starting
    at `0` and ending at the width of the screen; however, to keep our tanks from
    going off the edge, we need to subtract the width of the bitmap from the value.
    Finally, we set duration of two seconds.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`QGraphicsObject`对象具有定义其在场景上的*x*和*y*坐标的`x`和`y`属性，因此将对象进行动画处理就像是将我们的属性动画指向这些属性。我们将从`0`开始动画`x`，并以屏幕的宽度结束；但是，为了防止我们的坦克离开边缘，我们需要从该值中减去位图的宽度。最后，我们设置两秒的持续时间。'
- en: 'A property animation can be run forward or backward. So, to enable the left
    and right movement, we simply need to toggle the direction in which the animation
    runs. Let''s create some methods to do this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 属性动画可以向前或向后运行。因此，要启用左右移动，我们只需要切换动画运行的方向。让我们创建一些方法来做到这一点：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Switching directions is just a matter of setting the animation object's `direction`
    property to `Forward` or `Backward`, and then calling `start()` to apply it.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 改变方向只需要设置动画对象的`direction`属性为`Forward`或`Backward`，然后调用`start()`来应用它。
- en: 'Back in `__init__()`, let''s use the `toggle_direction()` method to create
    the *bounce*:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`__init__()`，让我们使用`toggle_direction()`方法来创建*反弹*：
- en: '[PRE62]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To make the game more interesting, we should also start our tanks on opposite
    ends of the screen:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使游戏更有趣，我们还应该让我们的坦克从屏幕的两端开始：
- en: '[PRE63]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: After setting up the animation, we start it by calling `start()`. This takes
    care of the tank animation; now it's time to load our weapons.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 设置动画后，通过调用`start()`来启动它。这处理了坦克的动画；现在是时候装载我们的武器了。
- en: Creating the bullets
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建子弹
- en: In this game, each tank will only be allowed one bullet on the screen at a time.
    This simplifies our game code, but also keeps the game relatively challenging.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，每个坦克一次只能在屏幕上有一个子弹。这简化了我们的游戏代码，但也使游戏保持相对具有挑战性。
- en: To implement these bullets, we'll create another `QGraphicsObject` object called
    `Bullet`, which is animated to move along the *y* axis.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些子弹，我们将创建另一个名为`Bullet`的`QGraphicsObject`对象，它被动画化沿着*y*轴移动。
- en: 'Let''s start our `Bullet` class as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的`Bullet`类如下：
- en: '[PRE64]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The bullet class starts by defining a `hit` signal indicating that it has hit
    an enemy tank. The constructor takes a `y_pos` argument to define the starting
    point of the bullet, and a Boolean indicating whether the bullet is to travel
    up or down. These arguments are saved as instance variables.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 子弹类首先通过定义`hit`信号来表示它击中了敌方坦克。构造函数接受一个`y_pos`参数来定义子弹的起始点，并且一个布尔值来指示子弹是向上还是向下移动。这些参数被保存为实例变量。
- en: 'Next, let''s define the bullet''s look as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们按照以下方式定义子弹的外观：
- en: '[PRE65]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Our bullet will simply be a 10 × 10 yellow square created using the painter''s
    `drawRect()` method. This is appropriate for a retro game but, just for fun, let''s
    make it a bit more interesting. To do this, we can apply something called a `QGraphicsEffect` class
    to the `QGraphicsObject`. The `QGraphicsEffect` class can apply a visual effect
    to the object in real-time. We implement this by creating an instance of one of
    the `QGraphicEffect` class''s subclasses and assigning it to the bullet''s `graphicsEffect`
    property, as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的子弹将简单地是一个10×10的黄色正方形，使用绘图器的`drawRect()`方法创建。这对于复古游戏来说是合适的，但是为了好玩，让我们把它变得更有趣。为此，我们可以将称为`QGraphicsEffect`的类应用于`QGraphicsObject`。`QGraphicsEffect`类可以实时地对对象应用视觉效果。我们通过创建`QGraphicEffect`类的子类实例并将其分配给子弹的`graphicsEffect`属性来实现这一点，如下所示：
- en: '[PRE66]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This code added to `Bullet.__init__()`, creates a blur effect and applies it
    to our `QGraphicsObject` class. Note that this is applied at the object level,
    and not at the painting level, so it is applied to any pixels we draw. We've adjusted
    the blur radius to 10 pixels and added the `AnimationHint` object, which tells
    us the effect that is being applied to an animated object and activates certain
    performance optimizations.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到`Bullet.__init__()`的这段代码创建了一个模糊效果并将其应用到我们的`QGraphicsObject`类。请注意，这是应用在对象级别上的，而不是在绘画级别上，因此它适用于我们绘制的任何像素。我们已将模糊半径调整为10像素，并添加了`AnimationHint`对象，告诉我们正在应用于动画对象的效果，并激活某些性能优化。
- en: 'Speaking of animation, let''s create the bullet''s animation as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 说到动画，让我们按照以下方式创建子弹的动画：
- en: '[PRE67]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The animation is configured so that it takes the bullet one second to go from
    its current `y_pos` argument to either the top or bottom of the screen, depending
    on whether the bullet is to shoot up or down. We aren't starting the animation
    yet, though, because we don't want the bullet to start moving until it's shot.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 动画被配置为使子弹从当前的`y_pos`参数到屏幕的顶部或底部花费一秒的时间，具体取决于子弹是向上还是向下射击。不过我们还没有开始动画，因为我们不希望子弹在射击前就开始移动。
- en: 'Shooting will happen in a `shoot()` method, as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 射击将在`shoot()`方法中发生，如下所示：
- en: '[PRE68]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: When a player shoots a bullet, we first stop any animation that might be happening.
    Since only one bullet is allowed at a time, rapid-firing will just result in the
    bullet starting over (while this is not terribly realistic, it makes gameplay
    more challenging).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家射出子弹时，我们首先停止任何可能发生的动画。由于一次只允许一颗子弹，快速射击只会导致子弹重新开始（虽然这并不是非常现实，但这样做可以使游戏更具挑战性）。
- en: Then, the bullet is repositioned to the *x* coordinate and passed into the `shoot()`
    method and the tank's *y* coordinate. Finally, the animation is started. The idea
    is that we'll pass in the tank's current *x* coordinate when the player shoots
    and the bullet will fly up or down from that position in a straight line.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将子弹重新定位到*x*坐标并传递到`shoot()`方法和坦克的*y*坐标。最后，启动动画。这个想法是，当玩家射击时，我们将传入坦克当前的*x*坐标，子弹将从那个位置直线飞出。
- en: 'Let''s go back to our `Tank` class and add a `Bullet` object. In `Tank.__init__()`,
    add in the following code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`Tank`类，并添加一个`Bullet`对象。在`Tank.__init__()`中，添加以下代码：
- en: '[PRE69]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: So that we don't hit our own tank with our own bullet, we want the bullet to
    start at a position just above the bottom tank or just below the top tank, which
    is what we've calculated in the first statement. Since our tanks don't move up
    or down, this position is a constant, and we can pass it to the bullet's constructor.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免我们的子弹击中自己的坦克，我们希望子弹从底部坦克的正上方或顶部坦克的正下方开始，这是我们在第一条语句中计算出来的。由于我们的坦克不会上下移动，这个位置是一个常数，我们可以将它传递给子弹的构造函数。
- en: 'To make the tank shoot the bullet, we''ll create a method in the `Tank` class
    called `shoot()`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让坦克射出子弹，我们将在`Tank`类中创建一个名为`shoot()`的方法：
- en: '[PRE70]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The first thing we need to do is to add the bullet to the scene if it's not
    yet added (or if it's been removed). We can determine this by checking the bullet's `scene`
    property, which returns `None` if the object is not on the scene.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将子弹添加到场景中（如果尚未添加或已被移除）。我们可以通过检查子弹的`scene`属性来确定这一点，如果对象不在场景中，则返回`None`。
- en: Then, we call the bullet's `shoot()` method by passing in the tank's *x* coordinate.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过传入坦克的*x*坐标来调用子弹的`shoot()`方法。
- en: Collision detection
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞检测
- en: Bullets don't do much good if nothing happens when they hit the target. To make
    something happen when a bullet hits a tank, we need to implement **collision detection**.
    We will implement this in the `Bullet` class by asking it to check whether it
    has hit anything whenever it moves.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子弹击中目标后什么都不发生，那么子弹就没有什么用。为了在子弹击中坦克时发生一些事情，我们需要实现**碰撞检测**。我们将在`Bullet`类中实现这一点，要求它在移动时检查是否击中了任何东西。
- en: 'Start by creating a method in `Bullet` called `check_colllision()`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在`Bullet`中创建一个名为`check_colllision()`的方法：
- en: '[PRE71]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`QGraphicsObject.collidingItems()` returns a list of any `QGraphicsItem` objects
    whose bounding rectangles overlap with this item. This includes not only our `Tank`
    objects, but also the `floor` and `ceiling` items we created in the `Scene` class,
    or even the other tank''s `Bullet` object. If our bullet touches any of these
    items, we need to remove it from the scene; to do this, we call `self.scene().removeItem(self)`
    to eliminate the bullet.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`QGraphicsObject.collidingItems()`返回一个列表，其中包含任何与此项的边界矩形重叠的`QGraphicsItem`对象。这不仅包括我们的`Tank`对象，还包括我们在`Scene`类中创建的`floor`和`ceiling`项，甚至是另一个坦克的`Bullet`对象。如果我们的子弹触碰到这些物品中的任何一个，我们需要将其从场景中移除；为此，我们调用`self.scene().removeItem(self)`来消除子弹。'
- en: Then, we need to check whether any of the items we've collided with are `Tank`
    objects. This we do by simply checking the type and name of the object hit. If
    we hit a tank, we emit our `hit` signal. (We can safely assume it's the other
    tank because of the way our bullets move.)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要检查我们碰撞的物品中是否有`Tank`对象。我们只需检查被击中的对象的类型和名称即可。如果我们击中了坦克，我们就会发出`hit`信号。（我们可以安全地假设它是另一个坦克，因为我们的子弹移动的方式）
- en: This method needs to be called every time the `Bullet` object moves, since every
    movement could result in a collision. Fortunately, the `QGraphicsObject` method
    has a `yChanged` signal, which is emitted every time its *y* coordinate changes.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 每次`Bullet`对象移动时都需要调用这个方法，因为每次移动都可能导致碰撞。幸运的是，`QGraphicsObject`方法有一个`yChanged`信号，每当它的*y*坐标发生变化时就会发出。
- en: 'So, back in the `Bullet.__init__()` method, we can add a connection, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`Bullet.__init__()`方法中，我们可以添加一个连接，如下所示：
- en: '[PRE72]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Our tank and bullet objects are now ready, so let's head back to the `Scene`
    object to finish out our game.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的坦克和子弹对象现在已经准备就绪，所以让我们回到`Scene`对象来完成我们的游戏。
- en: Finishing the game
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结束游戏
- en: 'Back in `Scene.__init__()`, let''s create our two tanks:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`Scene.__init__()`，让我们创建我们的两辆坦克：
- en: '[PRE73]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The bottom tank sits on top of the floor, and the top tank is positioned on
    the bottom of the ceiling. Now we can connect the `hit` signals of their bullets
    to the proper score-incrementing methods:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 底部坦克位于地板上方，顶部坦克位于天花板下方。现在我们可以将它们的子弹的`hit`信号连接到适当的分数增加方法：
- en: '[PRE74]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'At this point, our game is almost done:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的游戏几乎已经完成了：
- en: '![](assets/492381be-ba26-4e11-91b5-de1470a9ef5a.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/492381be-ba26-4e11-91b5-de1470a9ef5a.png)'
- en: Of course, there is one very important aspect still missing—the controls!
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有一个非常重要的方面还缺失了——控制！
- en: Our tanks will be controlled by the keyboard; we'll assign the bottom player
    the arrow keys for movement and the return key for firing, while the top player
    will get *A* and *D* for movement and the spacebar for firing.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的坦克将由键盘控制；我们将为底部玩家分配箭头键进行移动和回车键进行射击，而顶部玩家将使用*A*和*D*进行移动，空格键进行射击。
- en: 'To handle keystrokes, we need to override the `Scene` object''s `keyPressEvent()`
    method:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理按键，我们需要重写`Scene`对象的`keyPressEvent()`方法：
- en: '[PRE75]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`keyPressEvent()` is called whenever the user presses a key while the `Scene` object
    is focused. It''s the only argument that is a `QKeyEvent` object whose `key()`
    method returns a constant from the `QtCore.Qt.Key` enum telling us what key was
    pressed. In this method, we''ve created a `dict` object that maps certain key
    constants to methods on our tank objects. Whenever we receive a keystroke, we
    attempt to fetch a callback method, and if we''re successful, we call the method.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`keyPressEvent()`在`Scene`对象聚焦时每当用户按下键盘时被调用。它是唯一的参数，是一个`QKeyEvent`对象，其`key()`方法返回`QtCore.Qt.Key`枚举中的常量，告诉我们按下了什么键。在这个方法中，我们创建了一个`dict`对象，将某些键常量映射到我们的坦克对象的方法。每当我们接收到一个按键，我们尝试获取一个回调方法，如果成功，我们调用这个方法。'
- en: The game is now ready to play! Grab a friend (preferably someone you don't mind
    sharing a keyboard with) and fire it up.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在已经准备好玩了！找个朋友（最好是你不介意和他共享键盘的人）并开始玩吧。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned all about working with 2D graphics in PyQt. We
    learned how to use the `QPainter` object to edit images and create custom widgets.
    You then learned how to use a `QGraphicsScene` method in conjunction with the
    `QGraphicsObject` class to create animated scenes that can be controlled using
    automated logic or user input.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何在PyQt中使用2D图形。我们学习了如何使用`QPainter`对象编辑图像并创建自定义小部件。然后，您学习了如何使用`QGraphicsScene`方法与`QGraphicsObject`类结合使用，创建可以使用自动逻辑或用户输入控制的动画场景。
- en: In the next chapter, we'll add an additional dimension to our graphics as we
    explore the use of OpenGL 3D graphics with PyQt. You'll learn some of the basics
    of OpenGL programming and how it can be integrated into a PyQt application.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为我们的图形添加一个额外的维度，探索在PyQt中使用OpenGL 3D图形。您将学习一些OpenGL编程的基础知识，以及如何将其集成到PyQt应用程序中。
- en: Questions
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些问题来测试你从本章学到的知识：
- en: 'Add code to this method to write your name in blue on the bottom of the picture:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中添加代码，以在图片底部用蓝色写下你的名字：
- en: '[PRE76]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Given a `QPainter` object called `painter`, write a line of code to paint an
    80 × 80 pixel octagon in the upper-left corner of the painter's paint device.
    You can refer to the documentation at [https://doc.qt.io/qt-5/qpainter.html#drawPolygon](https://doc.qt.io/qt-5/qpainter.html#drawPolygon) for
    guidance.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个名为`painter`的`QPainter`对象，写一行代码在绘图设备的左上角绘制一个80×80像素的八边形。您可以参考[https://doc.qt.io/qt-5/qpainter.html#drawPolygon](https://doc.qt.io/qt-5/qpainter.html#drawPolygon)中的文档进行指导。
- en: 'You''re creating a custom widget and can''t figure out why the text is showing
    up in black. The following is your `paintEvent()` method; see whether you can
    figure out the problem:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您正在创建一个自定义小部件，但不知道为什么文本显示为黑色。以下是您的`paintEvent()`方法；看看你能否找出问题：
- en: '[PRE77]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: A deep-fried meme is a style of a meme that uses extreme compression, saturation,
    and other processing to make the meme image look intentionally low quality. Add
    a feature to your meme generator to optionally make the meme deep-fried. Some
    things you can try include reducing the color bit depth and adjusting the hue
    and saturation of the colors in the image.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 深炸迷因是一种使用极端压缩、饱和度和其他处理来使迷因图像故意看起来低质量的迷因风格。在你的迷因生成器中添加一个功能，可以选择使迷因深炸。你可以尝试的一些事情包括减少颜色位深度和调整图像中颜色的色调和饱和度。
- en: 'You''d like to animate a circle moving horizontally across the screen. Change
    the following code to animate the circle:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您想要动画一个圆在屏幕上水平移动。更改以下代码以动画圆：
- en: '[PRE78]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The following code attempts to set up a `QPainter` object with a gradient brush.
    Discover what is wrong with it:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码尝试使用渐变刷设置`QPainter`对象。找出其中的问题所在：
- en: '[PRE79]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'See whether you can implement some of the following improvements to the game
    we created:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看你是否可以实现一些对我们创建的游戏的改进：
- en: Pulsating bullets
  id: totrans-342
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脉动子弹
- en: Explosions when a tank is hit
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坦克被击中时爆炸
- en: Sounds (see [Chapter 7](0234c71b-292c-4423-89d7-e9d9906d730e.xhtml), *Working
    with Audio-Visual Using QtMultimedia,* for guidance)
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音（参见[第7章](0234c71b-292c-4423-89d7-e9d9906d730e.xhtml)，*使用QtMultimedia处理音频-视觉*，以获取指导）
- en: Background animation
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景动画
- en: Multiple bullets
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个子弹
- en: Further reading
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For further information, please refer the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅以下内容：
- en: An in-depth discussion of `QPainter` and Qt's paint system can be found at [https://doc.qt.io/qt-5/paintsystem.html](https://doc.qt.io/qt-5/paintsystem.html)
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`QPainter`和Qt绘图系统的深入讨论可以在[https://doc.qt.io/qt-5/paintsystem.html](https://doc.qt.io/qt-5/paintsystem.html)找到
- en: An overview of the Qt Graphics View framework can be found at [https://doc.qt.io/qt-5/graphicsview.html](https://doc.qt.io/qt-5/graphicsview.html)
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Qt图形视图框架的概述可以在[https://doc.qt.io/qt-5/graphicsview.html](https://doc.qt.io/qt-5/graphicsview.html)找到
- en: An overview of the animation framework can be found at [https://doc.qt.io/qt-5/animation-overview.html](https://doc.qt.io/qt-5/animation-overview.html)
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画框架的概述可以在[https://doc.qt.io/qt-5/animation-overview.html](https://doc.qt.io/qt-5/animation-overview.html)找到
