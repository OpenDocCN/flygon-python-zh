- en: Working with Images, Audio, and other Assets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理图像、音频和其他资产
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Downloading media content on the web
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网上下载媒体内容
- en: Parsing a URL with urllib to get the filename
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用urllib解析URL以获取文件名
- en: Determining type of content for a URL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定URL的内容类型
- en: Determining a file extension from a content type
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从内容类型确定文件扩展名
- en: Downloading and saving images to the local file system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载并将图像保存到本地文件系统
- en: Downloading and saving images to S3
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载并将图像保存到S3
- en: Generating thumbnails for images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为图像生成缩略图
- en: Taking website screenshots with Selenium
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Selenium进行网站截图
- en: Taking a website screenshot with an external service
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外部服务对网站进行截图
- en: Performing OCR on images with pytessaract
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pytessaract对图像执行OCR
- en: Creating a Video Thumbnail
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建视频缩略图
- en: Ripping an MP4 video to an MP3
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将MP4视频转换为MP3
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: A common practice in scraping is the download, storage, and further processing
    of media content (non-web pages or data files). This media can include images,
    audio, and video.  To store the content locally (or in a service like S3) and
    do it correctly, we need to know what the type of media is, and it's not enough
    to trust the file extension in the URL.  We will learn how to download and correctly
    represent the media type based on information from the web server.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在抓取中的一个常见做法是下载、存储和进一步处理媒体内容（非网页或数据文件）。这些媒体可以包括图像、音频和视频。为了正确地将内容存储在本地（或在S3等服务中），我们需要知道媒体类型，并且仅仅信任URL中的文件扩展名是不够的。我们将学习如何根据来自Web服务器的信息下载和正确表示媒体类型。
- en: Another common task is the generation of thumbnails of images, videos, or even
    a page of a website.  We will examine several techniques of how to generate thumbnails
    and make website page screenshots.  Many times these are used on a new website
    as thumbnail links to the scraped media that is now stored locally.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的任务是生成图像、视频甚至网站页面的缩略图。我们将研究如何生成缩略图并制作网站页面截图的几种技术。这些缩略图经常用作新网站上缩略图链接，以链接到现在存储在本地的抓取媒体。
- en: Finally, it is often the need to be able to transcode media, such as converting
    non-MP4 videos to MP4, or changing the bit-rate or resolution of a video.  Another
    scenario is to extract only the audio from a video file.  We won't look at video
    transcoding, but we will rip MP3 audio out of an MP4 file using `ffmpeg`.  It's
    a simple step from there to also transcode video with `ffmpeg`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通常需要能够转码媒体，例如将非MP4视频转换为MP4，或更改视频的比特率或分辨率。另一个场景是从视频文件中提取音频。我们不会讨论视频转码，但我们将使用`ffmpeg`从MP4文件中提取MP3音频。从那里开始，还可以使用`ffmpeg`转码视频。
- en: Downloading media content from the web
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从网上下载媒体内容
- en: 'Downloading media content from the web is a simple process: use Requests or
    another library and download it just like you would HTML content.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从网上下载媒体内容是一个简单的过程：使用Requests或其他库，就像下载HTML内容一样。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: There is a class named `URLUtility` in the `urls.py mdoule` in the `util` folder
    of the solution.  This class handles several of the scenarios in this chapter
    with downloading and parsing URLs. We will be using this class in this recipe
    and a few others. Make sure the `modules` folder is in your Python path.  Also,
    the example for this recipe is in the `04/01_download_image.py` file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案的`util`文件夹中的`urls.py`模块中有一个名为`URLUtility`的类。该类处理本章中的几种场景，包括下载和解析URL。我们将在这个配方和其他一些配方中使用这个类。确保`modules`文件夹在您的Python路径中。此外，此配方的示例位于`04/01_download_image.py`文件中。
- en: How to do it
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'Here is how we proceed with the recipe:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何进行的步骤：
- en: 'The `URLUtility` class can download content from a URL.  The code in the recipe''s
    file is the following:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`URLUtility`类可以从URL下载内容。配方文件中的代码如下：'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When running this you will see the following output:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行时，您将看到以下输出：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The example reads `171014` bytes of data.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 示例读取了`171014`字节的数据。
- en: How it works
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The URL is defined as a constant  `const.ApodEclipseImage()` in the `const`
    module:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: URL被定义为`const`模块中的常量`const.ApodEclipseImage()`：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The constructor of the `URLUtility` class has the following implementation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`URLUtility`类的构造函数具有以下实现：'
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The constructor stores the URL, parses it, and downloads the file with the
    `read()` method.  The following is the code of the `read()` method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数存储URL，解析它，并使用`read()`方法下载文件。以下是`read()`方法的代码：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function uses `urlopen` to get a response object, and then reads the stream
    and stores it as a property of the object.  That data can then be retrieved using
    the data property:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用`urlopen`获取响应对象，然后读取流并将其存储为对象的属性。然后可以使用数据属性检索该数据：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code then simply reports on the length of that data, with the value of `171014`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，该代码简单地报告了该数据的长度，值为`171014`。
- en: There's more...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This class will be used for other tasks such as determining content types, filename,
    and extensions for those files.  We will examine parsing of URLs for filenames
    next.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将用于其他任务，比如确定文件的内容类型、文件名和扩展名。接下来我们将研究解析URL以获取文件名。
- en: Parsing a URL with urllib to get the filename
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用urllib解析URL以获取文件名
- en: When downloading content from a URL, we often want to save it in a file.  Often
    it is good enough to save the file in a file with a name found in the URL.  But
    the URL consists of a number of fragments, so how can we find the actual filename
    from the URL, especially where there are often many parameters after the file
    name?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从URL下载内容时，我们经常希望将其保存在文件中。通常情况下，将文件保存在URL中找到的文件名中就足够了。但是URL由许多片段组成，那么我们如何从URL中找到实际的文件名，特别是在文件名后经常有许多参数的情况下？
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will again be using the `URLUtility` class for this task.  The code file
    for the recipe is `04/02_parse_url.py`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用`URLUtility`类来完成这个任务。该配方的代码文件是`04/02_parse_url.py`。
- en: How to do it
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'Execute the recipe''s file with your python interpreter.  It will run the following
    code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的Python解释器执行配方文件。它将运行以下代码：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This results in the following output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'In the constructor for `URLUtility`, there is a call to `urlib.parse.urlparse`.
     The following demonstrates using the function interactively:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`URLUtility`的构造函数中，调用了`urlib.parse.urlparse`。 以下演示了交互式使用该函数：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `ParseResult` object contains the various components of the URL.  The path
    element contains the path and the filename.  The call to the `.filename_without_ext`
    property returns just the filename without the extension:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParseResult`对象包含URL的各个组件。 路径元素包含路径和文件名。 对`.filename_without_ext`属性的调用仅返回没有扩展名的文件名：'
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The call to `os.path.basename` returns only the filename portion of the path
    (including the extension). `os.path.splittext()` then separates the filename and
    the extension, and the function returns the first element of that tuple/list (the
    filename).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对`os.path.basename`的调用仅返回路径的文件名部分（包括扩展名）。 `os.path.splittext()`然后分隔文件名和扩展名，并且该函数返回该元组/列表的第一个元素（文件名）。
- en: There's more...
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It may seem odd that this does not also return the extension as part of the
    filename.  This is because we cannot assume that the content that we received
    actually matches the implied type from the extension.  It is more accurate to
    determine this using headers returned by the web server.  That's our next recipe.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎有点奇怪，它没有将扩展名作为文件名的一部分返回。 这是因为我们不能假设我们收到的内容实际上与扩展名所暗示的类型匹配。 更准确的是使用Web服务器返回的标题来确定这一点。
    这是我们下一个配方。
- en: Determining the type of content for a URL
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定URL的内容类型
- en: When performing a `GET` requests for content from a web server, the web server
    will return a number of headers, one of which identities the type of the content
    from the perspective of the web server.  In this recipe we learn to use that to
    determine what the web server considers the type of the content.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当从Web服务器获取内容的`GET`请求时，Web服务器将返回许多标题，其中一个标识了内容的类型，从Web服务器的角度来看。 在这个配方中，我们学习如何使用它来确定Web服务器认为的内容类型。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: We again use the `URLUtility` class.  The code for the recipe is in `04/03_determine_content_type_from_response.py`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`URLUtility`类。 配方的代码在`04/03_determine_content_type_from_response.py`中。
- en: How to do it
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'We proceed as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按以下步骤进行：
- en: 'Execute the script for the recipe.  It contains the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行配方的脚本。 它包含以下代码：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With the following result:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 得到以下结果：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The `.contentype` property is implemented as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`.contentype`属性的实现如下：'
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `.headers` property of the `_response` object is a dictionary-like class
    of headers.  The `content-type` key will retrieve the `content-type` specified
    by the server.  This call to the `ensure_response()` method simply ensures that
    the `.read()` function has been executed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`_response`对象的`.headers`属性是一个类似字典的标题类。 `content-type`键将检索服务器指定的`content-type`。
    对`ensure_response()`方法的调用只是确保已执行`.read()`函数。'
- en: There's more...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The headers in a response contain a wealth of information.  If we look more
    closely at the `headers` property of the response, we can see the following headers
    are returned:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 响应中的标题包含大量信息。 如果我们更仔细地查看响应的`headers`属性，我们可以看到返回以下标题：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: And we can see the values for each of these headers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到每个标题的值。
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Many of these we will not examine in this book, but for the unfamiliar it is
    good to know that they exist.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书中有许多我们不会讨论的内容，但对于不熟悉的人来说，知道它们存在是很好的。
- en: Determining the file extension from a content type
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从内容类型确定文件扩展名
- en: It is good practice to use the `content-type` header to determine the type of
    content, and to determine the extension to use for storing the content as a file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`content-type`标题来确定内容的类型，并确定用于存储内容的扩展名是一个很好的做法。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: We again use the `URLUtility` object that we created. The recipe's script is `04/04_determine_file_extension_from_contenttype.py):`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用了我们创建的`URLUtility`对象。 配方的脚本是`04/04_determine_file_extension_from_contenttype.py`。
- en: How to do it
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: Proceed by running the recipe's script.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行配方的脚本来进行。
- en: 'An extension for the media type can be found using the `.extension` property:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`.extension`属性找到媒体类型的扩展名：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This results in the following output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This reports both the extension determined from the file type, and also from
    the URL.  These can be different, but in this case they are the same.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这报告了从文件类型和URL确定的扩展名。 这些可能不同，但在这种情况下它们是相同的。
- en: How it works
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The following is the implementation of the `.extension_from_contenttype` property:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`.extension_from_contenttype`属性的实现：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first line ensures that we have read the response from the URL.  The function
    then uses a python dictionary, defined in the `const` module, which contains a
    dictionary of content-types to extension:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行确保我们已从URL读取响应。 然后，该函数使用在`const`模块中定义的Python字典，其中包含内容类型到扩展名的字典：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If the content type is in the dictionary, then the corresponding value will
    be returned.  Otherwise, `None` is returned.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内容类型在字典中，则将返回相应的值。 否则，将返回`None`。
- en: 'Note the corresponding property, `.extension_from_url`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意相应的属性`.extension_from_url`：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This uses the same technique as the `.filename` property to parse the URL, but
    instead returns the `[1]` element, which represents the extension instead of the
    base filename.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用与`.filename`属性相同的技术来解析URL，但是返回代表扩展名而不是基本文件名的`[1]`元素。
- en: There's more...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As stated, it's best to use the `content-type` header to determine an extension
    for storing the file locally.  There are other techniques than what is provided
    here, but this is the easiest.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，最好使用`content-type`标题来确定用于本地存储文件的扩展名。 除了这里提供的技术之外，还有其他技术，但这是最简单的。
- en: Downloading and saving images to the local file system
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载并将图像保存到本地文件系统
- en: Sometimes when scraping we just download and parse data, such as HTML, to extract
    some data, and then throw out what we read.  Other times, we want to keep the
    downloaded content by storing it as a file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在爬取时，我们只是下载和解析数据，比如HTML，提取一些数据，然后丢弃我们读取的内容。其他时候，我们希望通过将其存储为文件来保留已下载的内容。
- en: How to do it
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做
- en: 'The code example for this recipe is in the `04/05_save_image_as_file.py` file.
    The portion of the file of importance is:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的代码示例在`04/05_save_image_as_file.py`文件中。文件中重要的部分是：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the script with your Python interpreter and you will get the following
    output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 用你的Python解释器运行脚本，你将得到以下输出：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The sample simply writes the data to a file using standard Python file access
    functions.  It does it in an object oriented manner by using a standard interface
    for writing data and with a file based implementation in the `FileBlobWriter`
    class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例只是使用标准的Python文件访问函数将数据写入文件。它通过使用标准的写入数据接口以面向对象的方式来实现，使用了`FileBlobWriter`类的基于文件的实现：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The class is passed a string representing the directory where the file should
    be placed.  The data is actually written during a later call to the `.write()`
    method.  This method merges the filename and `directory (_location)`, and then
    opens/creates the file and writes the bytes.  The `with` statement ensures that
    the file is closed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该类传递一个表示文件应该放置的目录的字符串。实际上，数据是在稍后调用`.write()`方法时写入的。这个方法合并了文件名和`directory (_location)`，然后打开/创建文件并写入字节。`with`语句确保文件被关闭。
- en: There's more...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This write could have simply been handled using a function that wraps the code. 
    This object will be reused throughout this chapter. We could use the duck-typing
    of python, or just a function, but the clarity of interfaces is easier.  Speaking
    of that, the following is the definition of this interface:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇文章可以简单地使用一个包装代码的函数来处理。这个对象将在本章中被重复使用。我们可以使用Python的鸭子类型，或者只是一个函数，但是接口的清晰度更容易。说到这一点，以下是这个接口的定义：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We will also see another implementation of this interface that lets us store
    files in S3.  Through this type of implementation, through interface inheritance,
    we can easily substitute implementations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看到另一个实现这个接口的方法，让我们可以将文件存储在S3中。通过这种类型的实现，通过接口继承，我们可以很容易地替换实现。
- en: Downloading and saving images to S3
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载并保存图像到S3
- en: We have seen how to write content into S3 in [Chapter 3](acb4595a-ad11-49ca-91bd-71ee144229d9.xhtml),
    *Processing Data*.  Here we will extend that process into an interface implementation
    of IBlobWriter to write to S3.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在[第3章](acb4595a-ad11-49ca-91bd-71ee144229d9.xhtml)中将内容写入S3，*处理数据*。在这里，我们将把这个过程扩展到IBlobWriter的接口实现，以便写入S3。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The code example for this recipe is in the `04/06_save_image_in_s3.py` file. 
    Also ensure that you have set your AWS keys as environment variables so that Boto
    can authenticate the script.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的代码示例在`04/06_save_image_in_s3.py`文件中。还要确保你已经将AWS密钥设置为环境变量，这样Boto才能验证脚本。
- en: How to do it
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做
- en: 'We proceed as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下步骤进行：
- en: 'Run the recipe''s script.  It will execute the following:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行配方的脚本。它将执行以下操作：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Checking in S3, we can see that the bucket was created and the image placed
    within the bucket:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在S3中检查，我们可以看到存储桶已经创建，并且图像已放置在存储桶中：
- en: '![](assets/5abb4f94-3072-4d9a-b868-60ac32c2d295.png)The Image in S3'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5abb4f94-3072-4d9a-b868-60ac32c2d295.png)S3中的图像'
- en: How it works
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The following is the implementation of the `S3BlobWriter`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`S3BlobWriter`的实现：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have seen this code in before  in the recipe on writing to S3\.  This class
    wraps that up neatly into a reusable interface implementation.  When creating
    an instance, specify the bucket name.  Then every call to `.write()` will save
    in the same bucket.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在写入S3的配方中看到了这段代码。这个类将它整齐地包装成一个可重用的接口实现。创建一个实例时，指定存储桶名称。然后每次调用`.write()`都会保存在同一个存储桶中。
- en: There's more...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: S3 provides a capability on buckets known as enabling a website.  Essentially,
    if you set this option, the content in your bucket will be served via HTTP.  We
    could write many images to this directory and then have them served directly from
    S3 without implementing a web server!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: S3在存储桶上提供了一个称为启用网站的功能。基本上，如果你设置了这个选项，存储桶中的内容将通过HTTP提供。我们可以将许多图像写入这个目录，然后直接从S3中提供它们，而不需要实现一个Web服务器！
- en: Generating thumbnails for images
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为图像生成缩略图
- en: Many times when downloading an image, you do not want to save the full image,
    but only a thumbnail. Or you may also save both the full-size image and a thumbnail.
     Thumbnails can be easily created in python using the Pillow library.  Pillow
    is a fork of the Python Image Library, and contains many useful functions for
    manipulating images.  You can find more information on Pillow at [https://python-pillow.org](https://python-pillow.org). 
    In this recipe, we use Pillow to create an image thumbnail.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，在下载图像时，你不想保存完整的图像，而只想保存缩略图。或者你也可以同时保存完整尺寸的图像和缩略图。在Python中，使用Pillow库可以很容易地创建缩略图。Pillow是Python图像库的一个分支，包含许多有用的图像处理函数。你可以在[Pillow官网](https://python-pillow.org)找到更多关于Pillow的信息。在这个配方中，我们使用Pillow来创建图像缩略图。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The script for this recipe is `04/07_create_image_thumbnail.py`.  It uses the
    Pillow library, so make sure you have installed Pillow into your environment with
    pip or other package management tools:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的脚本是`04/07_create_image_thumbnail.py`。它使用了Pillow库，所以确保你已经用pip或其他包管理工具将Pillow安装到你的环境中。
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How to do it
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做
- en: 'Here is how proceed with the recipe:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何进行配方：
- en: 'Run the script for the recipe.  It will execute the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 运行配方的脚本。它将执行以下代码：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The result from this will be a file named `eclipse_thumbnail.png` written into
    your home directory.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个名为`eclipse_thumbnail.png`的文件写入你的主目录。
- en: '![](assets/bc8c1992-366f-43c9-bcb4-281c5644df69.png)The Thumbnail we Created'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/bc8c1992-366f-43c9-bcb4-281c5644df69.png)我们创建的缩略图'
- en: Pillow keeps the ratio of width and height consistent.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Pillow保持宽度和高度的比例一致。
- en: How it works
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The `ImageThumbnailGenerator` class wraps calls to Pillow to provide a very
    simple API for creating a thumbnail for an image:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageThumbnailGenerator`类封装了对Pillow的调用，为创建图像缩略图提供了一个非常简单的API：'
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The constructor is passed the data for the image and creates a Pillow image
    object from that data.  The thumbnail is created by calling `.thumbnail()` with
    a tuple representing the desired size of the thumbnail.  This resizes the existing
    image, and Pillow preserves the aspect ratio.  It will determine the longer side
    of the image and scale that to the value in the tuple representing that axis.
     This image is taller than it is wide, so the thumbnail is made 200 pixels high,
    and the width is scaled accordingly (in this case, to 160 pixels).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数传递图像数据并从该数据创建Pillow图像对象。通过调用`.thumbnail()`创建缩略图，参数是表示缩略图所需大小的元组。这将调整现有图像的大小，并且Pillow会保留纵横比。它将确定图像的较长边并将其缩放到元组中表示该轴的值。此图像的高度大于宽度，因此缩略图的高度为200像素，并且宽度相应地缩放（在本例中为160像素）。
- en: Taking a screenshot of a website
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对网站进行截图
- en: A common scraping task is to create a screenshot of a website.  In Python we
    can create a thumbnail using selenium and webdriver.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的爬取任务是对网站进行截图。在Python中，我们可以使用selenium和webdriver来创建缩略图。
- en: Getting ready
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The script for this recipe is `04/08_create_website_screenshot.py`.  Also, make
    sure you have selenium in your path and have installed the Python library.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的脚本是`04/08_create_website_screenshot.py`。还要确保您的路径中有selenium，并且已安装Python库。
- en: How to do it
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'Run the script for the recipe.  The code in the script is the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该示例的脚本。脚本中的代码如下：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A `WebsiteScreenshotGenerator` object is created, and then its capture method
    is called, passing the URL of the website to capture, and a desired width in pixels
    for the image.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`WebsiteScreenshotGenerator`对象，然后调用其capture方法，传递要捕获的网站的URL和图像的所需宽度（以像素为单位）。
- en: This creates a Pillow image that can be accessed using the `.image` property,
    and the bytes for the image can be directly accessed using `.image_bytes`.  This
    script gets those bytes and writes them to the `website_screenshot.png` file in
    you home directory.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个Pillow图像，可以使用`.image`属性访问，并且可以直接使用`.image_bytes`访问图像的字节。此脚本获取这些字节并将它们写入到您的主目录中的`website_screenshot.png`文件中。
- en: 'You will see the following output from this script:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您将从此脚本中看到以下输出：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And our resulting image is the following (the image will vary in its content):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果图像如下（图像的内容会有所不同）：
- en: '![](assets/b9c8c756-e789-43ae-a20b-d90e7b146181.png)The Screenshot of the Web
    Page'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/b9c8c756-e789-43ae-a20b-d90e7b146181.png)网页截图'
- en: How it works
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The following is the code of the `WebsiteScreenshotGenerator` class:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`WebsiteScreenshotGenerator`类的代码：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The call to `driver.get_screenshot_as_png()` does the heavy lifting.  It renders
    the page to a PNG format image and returns the bytes of the image.  This data
    is then converted into a Pillow Image object.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`driver.get_screenshot_as_png()`完成了大部分工作。它将页面呈现为PNG格式的图像并返回图像的字节。然后将这些数据转换为Pillow图像对象。
- en: Note in the output that the height of the image returned from webdriver is 7416
    pixels, and not 500 as we specified.  The PhantomJS renderer will attempt to handle
    infinitely scrolling web sites, and generally won't constrain the screenshot to
    the height given to the window.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意输出中来自webdriver的图像高度为7416像素，而不是我们指定的500像素。PhantomJS渲染器将尝试处理无限滚动的网站，并且通常不会将截图限制在窗口给定的高度上。
- en: To actually make the screenshot the specified height, set the crop parameter
    to `True` (the default).  Then this code will use the crop method of the Pillow
    Image to set the desired height.  If you run this code with `crop=False`, then
    the result would be an image 7416 pixels in height.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际使截图达到指定的高度，请将裁剪参数设置为`True`（默认值）。然后，此代码将使用Pillow Image的裁剪方法设置所需的高度。如果使用`crop=False`运行此代码，则结果将是高度为7416像素的图像。
- en: Taking a screenshot of a website with an external service
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部服务对网站进行截图
- en: The previous recipe used selenium, webdriver, and PhantomJS to create the screenshot.
     This obviously requires having those packages installed.  If you don't want to
    install those and still want to make website screenshots, then you can use one
    of a number of web services that can take screenshots.  In this recipe, we will
    use the service at [www.screenshotapi.io](http://www.screenshotapi.io) to create
    a screenshot.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个示例使用了selenium、webdriver和PhantomJS来创建截图。这显然需要安装这些软件包。如果您不想安装这些软件包，但仍想制作网站截图，则可以使用许多可以截图的网络服务之一。在此示例中，我们将使用[www.screenshotapi.io](http://www.screenshotapi.io)上的服务来创建截图。
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'First, head over to `www.screenshotapi.io` and sign up for a free account:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，前往`www.screenshotapi.io`注册一个免费账户：
- en: '![](assets/ec4f1644-7736-4e42-ad3f-6f1b12bf1cc0.png)Screenshot of the free
    account sign up'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/ec4f1644-7736-4e42-ad3f-6f1b12bf1cc0.png)免费账户注册的截图'
- en: 'Once your account is created, proceed to get an API key.  This will be needed
    to authenticate against their service:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 创建账户后，继续获取API密钥。这将需要用于对其服务进行身份验证：
- en: '![](assets/4834f589-e457-4f33-aac9-c809451b33c5.png)The API Key'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/4834f589-e457-4f33-aac9-c809451b33c5.png)API密钥'
- en: How to do it
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'The script for this example is `04/09_screenshotapi.py`.  Give this a run and
    it will make a screenshot.  The code is the following, and is very similar to
    the previous recipe in structure:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的脚本是`04/09_screenshotapi.py`。运行此脚本将生成一个截图。以下是代码，结构与前一个示例非常相似：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The functional difference to the previous recipe is that we used a different
    `WebsiteScreenshotGenerator` implementation.  This one comes from the `core.website_screenshot_with_screenshotapi`
    module.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个示例的功能区别在于，我们使用了不同的`WebsiteScreenshotGenerator`实现。这个来自`core.website_screenshot_with_screenshotapi`模块。
- en: 'When run, the following will output to the console:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，以下内容将输出到控制台：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And gives us the following image:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 并给我们以下图像：
- en: '![](assets/6e8e5801-80c3-4d34-a228-f6633af08c75.png)The Website Screenshot
    from screenshotapi.io'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6e8e5801-80c3-4d34-a228-f6633af08c75.png)`screenshotapi.io`的网站截图'
- en: How it works
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The following is the code of this `WebsiteScreenshotGenerator`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此`WebsiteScreenshotGenerator`的代码：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `screenshotapi.io` API is a REST API.  There are two different endpoints:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`screenshotapi.io` API是一个REST API。有两个不同的端点：'
- en: '[https://api.screenshotapi.io/capture](https://api.screenshotapi.io/capture)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://api.screenshotapi.io/capture](https://api.screenshotapi.io/capture)'
- en: '[https://api.screenshotapi.io/retrieve](https://api.screenshotapi.io/retrieve)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://api.screenshotapi.io/retrieve](https://api.screenshotapi.io/retrieve)'
- en: The first endpoint is called and passes the URL and other parameters to their
    service.  Upon successful execution, this API returns a key that can be used on
    the other endpoint to retrieve the image.  The screenshot is performed asyncronously,
    and we need to continually call the `retrieve` API using the key returned from
    the capture endpoint.  This endpoint will return a status value of `ready` when
    the screenshot is complete.  The code simply loops until this is set, an error
    occurs, or the code times out.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先调用第一个端点，并将URL和其他参数传递给其服务。成功执行后，此API将返回一个密钥，可用于在另一个端点上检索图像。截图是异步执行的，我们需要不断调用使用从捕获端点返回的密钥的“检索”API。当截图完成时，此端点将返回“ready”状态值。代码简单地循环，直到设置为此状态，发生错误或代码超时。
- en: When the snapshot is available, the API returns a URL to the image in the `retrieve`
    response.  The code then retrieves this image and constructs a Pillow Image object
    from the received data.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当快照可用时，API会在“检索”响应中返回图像的URL。然后，代码会检索此图像，并从接收到的数据构造一个Pillow图像对象。
- en: There's more...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `screenshotapi.io` API has many useful parameters.  Several of these allow
    you to adjust which browser engine to use (Firefox, Chrome, or PhantomJS), device
    emulation, and whether or not to execute JavaScript in the web page.  For more
    details on these options and the API, go to [http://docs.screenshotapi.io/rest-api/](http://docs.screenshotapi.io/rest-api/).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`screenshotapi.io` API有许多有用的参数。其中几个允许您调整要使用的浏览器引擎（Firefox、Chrome或PhantomJS）、设备仿真以及是否在网页中执行JavaScript。有关这些选项和API的更多详细信息，请访问[http://docs.screenshotapi.io/rest-api/](http://docs.screenshotapi.io/rest-api)。'
- en: Performing OCR on an image with pytesseract
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pytesseract对图像执行OCR
- en: It is possible to extract text from within images using the pytesseract library.
     In this recipe, we will use pytesseract to extract text from an image. Tesseract
    is an open source OCR library sponsored by Google.  The source is available here: [https://github.com/tesseract-ocr/tesseract](https://github.com/tesseract-ocr/tesseract),
    and you can also find more information on the library there. 0;pytesseract is
    a thin python wrapper that provides a pythonic API to the executable.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用pytesseract库从图像中提取文本。在本示例中，我们将使用pytesseract从图像中提取文本。Tesseract是由Google赞助的开源OCR库。源代码在这里可用：[https://github.com/tesseract-ocr/tesseract](https://github.com/tesseract-ocr/tesseract)，您还可以在那里找到有关该库的更多信息。pytesseract是一个提供了Python
    API的薄包装器，为可执行文件提供了Python API。
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Make sure you have pytesseract installed:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已安装pytesseract：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You will also need to install tesseract-ocr.  On Windows, there is an executable
    installer, which you can get here: `https://github.com/tesseract-ocr/tesseract/wiki/4.0-with-LSTM#400-alpha-for-windows`.
     On a Linux system, you can use `apt-get`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要安装tesseract-ocr。在Windows上，有一个可执行安装程序，您可以在此处获取：`https://github.com/tesseract-ocr/tesseract/wiki/4.0-with-LSTM#400-alpha-for-windows`。在Linux系统上，您可以使用`apt-get`：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The easiest means of installation on a Mac is using brew:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上安装最简单的方法是使用brew：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The code for this recipe is in `04/10_perform_ocr.py`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的代码位于`04/10_perform_ocr.py`中。
- en: How to do it
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做
- en: 'Execute the script for the recipe.  The script is very straightforward:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 执行该配方的脚本。脚本非常简单：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The image that will be processed is the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将要处理的图像是以下图像：
- en: '![](assets/1ede956f-a997-4723-8f79-39bdd0d1d30f.png)The Image we will OCR'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/1ede956f-a997-4723-8f79-39bdd0d1d30f.png)我们将进行OCR的图像'
- en: 'And the script gives the following output:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本给出以下输出：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: The image is first loaded as a Pillow Image object.  We can directly pass this
    object to the pytesseract `image_to_string()` function.  That function runs tesseract
    on the image and returns the text that it found.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将图像加载为Pillow图像对象。我们可以直接将此对象传递给pytesseract的`image_to_string()`函数。该函数在图像上运行tesseract并返回它找到的文本。
- en: There's more...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: One of the primary purposes for using OCR in a scraping application is in the
    solving of text-based captchas.  We won't get into captcha solutions as they can
    be cumbersome and are also documented in other Packt titles.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在爬取应用程序中使用OCR的主要目的之一是解决基于文本的验证码。我们不会涉及验证码解决方案，因为它们可能很麻烦，而且也在其他Packt标题中有记录。
- en: Creating a Video Thumbnail
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建视频缩略图
- en: You might want to create a thumbnail for a video that you downloaded from a
    website. These could be used on a page that shows a number of video thumbnails
    and lets you click on them to watch the specific video.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望为从网站下载的视频创建缩略图。这些可以用于显示多个视频缩略图的页面，并允许您单击它们观看特定视频。
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This sample will use a tool known as ffmpeg.  ffmpeg is available at www.ffmpeg.org. 
    Download and install as per the instructions for your operating system.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将使用一个名为ffmpeg的工具。ffmpeg可以在www.ffmpeg.org上找到。根据您的操作系统的说明进行下载和安装。
- en: How to do it
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做
- en: 'The example script is in `04/11_create_video_thumbnail.py`.  It consists of
    the following code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 示例脚本位于`04/11_create_video_thumbnail.py`中。它包括以下代码：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When run you will see output from ffmpeg:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，您将看到来自ffmpeg的输出：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And the output JPG file will be the following JPG image:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的JPG文件将是以下JPG图像：
- en: '![](assets/c9568a21-3200-4c2b-ad42-12ad7f7b92e4.jpg)The Thumbnail Created from
    the Video'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c9568a21-3200-4c2b-ad42-12ad7f7b92e4.jpg)从视频创建的缩略图'
- en: How it works
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'The `.ffmpeg` file is actually an executable. The code executes the following
    ffmpeg command as a sub process:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`.ffmpeg`文件实际上是一个可执行文件。代码将以下ffmpeg命令作为子进程执行：'
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The input file is `BigBuckBunny.mp4`.  The `-ss` option informs where we want
    to examine the video.  `-frames:v` states that we want to extract one frame. 
    Finally we tell `ffmpeg` to write that frame to `thumbnail.jpg` (and `-y` confirms
    overwriting an existing file).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件是`BigBuckBunny.mp4`。`-ss`选项告诉我们要检查视频的位置。`-frames:v`表示我们要提取一个帧。最后，我们告诉`ffmpeg`将该帧写入`thumbnail.jpg`（`-y`确认覆盖现有文件）。
- en: There's more..
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: ffmpeg is an incredibly versatile and power tool.  A scraper I once created
    would crawl and find media (actually, commercials played on websites), and store
    them in a digital archive.  The scraper would then send a message through a message
    queue that would be picked up by a farm of servers whose only job was to run ffmpeg
    to convert the video into many different formats, bit rates, and also create thumbnails.
    From that point, more messages would be sent to auditor to use a front end application
    to check the content for compliance to advertising contract terms.  Get to know
    ffmeg, it is a great tool.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ffmpeg是一个非常多才多艺和强大的工具。我曾经创建过一个爬虫，它会爬取并找到媒体（实际上是在网站上播放的商业广告），并将它们存储在数字档案中。然后，爬虫会通过消息队列发送消息，这些消息会被一组服务器接收，它们的唯一工作就是运行ffmpeg将视频转换为许多不同的格式、比特率，并创建缩略图。从那时起，更多的消息将被发送给审计员，使用一个前端应用程序来检查内容是否符合广告合同条款。了解ffmeg，它是一个很棒的工具。
- en: Ripping an MP4 video to an MP3
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将MP4视频转换为MP3
- en: Now let's examine how to rip the audio from an MP4 video into an MP3 file. 
    The reasons you may want to do this include wanting to take the audio of the video
    with you (perhaps it's a music video), or you are building a scraper / media collection
    system that also requires the audio separate from the video.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看如何将MP4视频中的音频提取为MP3文件。你可能想这样做的原因包括想要携带视频的音频（也许是音乐视频），或者你正在构建一个爬虫/媒体收集系统，它还需要音频与视频分开。
- en: This task can be accomplished using the `moviepy`  library.  `moviepy` is a
    neat library that lets you do all kinds of fun processing on your videos.  One
    of those capabilities is to extract the audio as an MP3.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务可以使用`moviepy`库来完成。`moviepy`是一个很棒的库，可以让你对视频进行各种有趣的处理。其中一个功能就是提取音频为MP3。
- en: Getting ready
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Make sure that you have moviepy installed in your environment:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的环境中安装了moviepy：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We also need to have ffmpeg installed, which we used in the previous recipe,
    so you should be good to go with this requirement.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装ffmpeg，这是我们在上一个示例中使用过的，所以你应该已经满足了这个要求。
- en: How to do it
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作
- en: The code to demonstrate ripping to MP3 is in `04/12_rip_mp3_from_mp4.py`. `moviepy` 
    makes this process incredibly easy.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 演示将视频转换为MP3的代码在`04/12_rip_mp3_from_mp4.py`中。`moviepy`使这个过程变得非常容易。
- en: 'The following rips the MP4 downloaded in the previous recipe:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是在上一个示例中下载的MP4文件的提取：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When running this, you will see output, such as the following, as the file
    is ripped. This only took a few seconds:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当运行时，你会看到输出，比如下面的内容，因为文件正在被提取。这只花了几秒钟：
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When complete, you will have an MP3 file:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，你将得到一个MP3文件：
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There's more...
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: For more info on moviepy, check out the project site at[ http://zulko.github.io/moviepy/](http://zulko.github.io/moviepy/).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有关moviepy的更多信息，请查看项目网站[http://zulko.github.io/moviepy/](http://zulko.github.io/moviepy/)。
