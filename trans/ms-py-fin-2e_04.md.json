["```py\nIn [ ]:\n    \"\"\" \n    Linear regression with SciPy \n    \"\"\"\n    from scipy import stats\n\n    stock_returns = [0.065, 0.0265, -0.0593, -0.001, 0.0346]\n    mkt_returns = [0.055, -0.09, -0.041, 0.045, 0.022]\n    beta, alpha, r_value, p_value, std_err = \\\n        stats.linregress(stock_returns, mkt_returns)\n```", "```py\nIn [ ]:\n    print(beta, alpha)\nOut[ ]:\n 0.5077431878770808 -0.008481900352462384 \n```", "```py\n$ pip install -U statsmodels\n```", "```py\nIn [ ]:\n    \"\"\" \n    Least squares regression with statsmodels \n    \"\"\"\n    import numpy as np\n    import statsmodels.api as sm\n\n    # Generate some sample data\n    num_periods = 9\n    all_values = np.array([np.random.random(8) \\\n                           for i in range(num_periods)])\n\n    # Filter the data\n    y_values = all_values[:, 0] # First column values as Y\n    x_values = all_values[:, 1:] # All other values as X\n    x_values = sm.add_constant(x_values) # Include the intercept\n    results = sm.OLS(y_values, x_values).fit() # Regress and fit the model\n```", "```py\nIn [ ]:\n    print(results.summary())\n```", "```py\n===================================================================\n                 coef    std err          t      P>|t|      [0.025      \n-------------------------------------------------------------------\nconst          0.7229      0.330      2.191      0.273      -3.469\nx1             0.4195      0.238      1.766      0.328      -2.599\nx2             0.4930      0.176      2.807      0.218      -1.739\nx3             0.1495      0.102      1.473      0.380      -1.140\nx4            -0.1622      0.191     -0.847      0.552      -2.594\nx5            -0.6123      0.172     -3.561      0.174      -2.797\nx6            -0.2414      0.161     -1.499      0.375      -2.288\nx7            -0.5079      0.200     -2.534      0.239      -3.054\n```", "```py\nIn [ ]:    \n    print(results.params)\nOut[ ]:\n    [ 0.72286627  0.41950411  0.49300959  0.14951292 -0.16218313 -0.61228465 -0.24143028 -0.50786377]\n```", "```py\n$ pip install pulp\n```", "```py\nIn [ ]:\n    \"\"\" \n    A simple linear optimization problem with 2 variables \n    \"\"\"\n    import pulp\n\n    x = pulp.LpVariable('x', lowBound=0)\n    y = pulp.LpVariable('y', lowBound=0)\n\n    problem = pulp.LpProblem(\n        'A simple maximization objective', \n        pulp.LpMaximize)\n    problem += 3*x + 2*y, 'The objective function'\n    problem += 2*x + y <= 100, '1st constraint'\n    problem += x + y <= 80, '2nd constraint'\n    problem += x <= 40, '3rd constraint'\n    problem.solve()\n```", "```py\nIn [ ]:\n    print(\"Maximization Results:\")\n    for variable in problem.variables():\n        print(variable.name, '=', variable.varValue)\nOut[ ]:\n    Maximization Results:\n    x = 20.0\n    y = 60.0\n```", "```py\nIn [ ]:\n    \"\"\" \n    An example of implementing an integer \n    programming model with binary conditions \n    \"\"\"\n    import pulp\n\n    dealers = ['X', 'Y', 'Z']\n    variable_costs = {'X': 500, 'Y': 350, 'Z': 450}\n    fixed_costs = {'X': 4000, 'Y': 2000, 'Z': 6000}\n\n    # Define PuLP variables to solve\n    quantities = pulp.LpVariable.dicts('quantity', \n                                       dealers, \n                                       lowBound=0,\n                                       cat=pulp.LpInteger)\n    is_orders = pulp.LpVariable.dicts('orders', \n                                      dealers,\n                                      cat=pulp.LpBinary)\n```", "```py\nIn [ ]:\n    \"\"\"\n    This is an example of implementing an integer programming model\n    with binary variables the wrong way.\n    \"\"\"\n    # Initialize the model with constraints\n    model = pulp.LpProblem('A cost minimization problem',\n                           pulp.LpMinimize)\n    model += sum([(variable_costs[i] * \\\n                   quantities[i] + \\\n                   fixed_costs[i])*is_orders[i] \\\n                  for i in dealers]), 'Minimize portfolio cost'\n    model += sum([quantities[i] for i in dealers]) == 150\\\n        , 'Total contracts required'\n    model += 30 <= quantities['X'] <= 100\\\n        , 'Boundary of total volume of X'\n    model += 30 <= quantities['Y'] <= 90\\\n        , 'Boundary of total volume of Y'\n    model += 30 <= quantities['Z'] <= 70\\\n        , 'Boundary of total volume of Z'\n    model.solve() # You will get an error running this code!\n```", "```py\nOut[ ]:\n    TypeError: Non-constant expressions cannot be multiplied\n```", "```py\nIn [ ]:\n    \"\"\"\n    This is an example of implementing an \n    IP model with binary variables the correct way.\n    \"\"\"\n    # Initialize the model with constraints\n    model = pulp.LpProblem('A cost minimization problem',\n                           pulp.LpMinimize)\n    model += sum(\n        [variable_costs[i]*quantities[i] + \\\n             fixed_costs[i]*is_orders[i] for i in dealers])\\\n        , 'Minimize portfolio cost'\n    model += sum([quantities[i] for i in dealers]) == 150\\\n        ,  'Total contracts required'\n    model += is_orders['X']*30 <= quantities['X'] <= \\\n        is_orders['X']*100, 'Boundary of total volume of X'\n    model += is_orders['Y']*30 <= quantities['Y'] <= \\\n        is_orders['Y']*90, 'Boundary of total volume of Y'\n    model += is_orders['Z']*30 <= quantities['Z'] <= \\\n        is_orders['Z']*70, 'Boundary of total volume of Z'\n    model.solve()\n```", "```py\nIn [ ]:\n    print('Minimization Results:')\n    for variable in model.variables():\n        print(variable, '=', variable.varValue)\n\n    print('Total cost:',  pulp.value(model.objective))\nOut[ ]:\n    Minimization Results:\n    orders_X = 0.0\n    orders_Y = 1.0\n    orders_Z = 1.0\n    quantity_X = 0.0\n    quantity_Y = 90.0\n    quantity_Z = 60.0\n    Total cost: 66500.0\n```", "```py\nIn [ ]:\n    \"\"\" \n    Linear algebra with NumPy matrices \n    \"\"\"\n    import numpy as np\n\n    A = np.array([[2, 1, 1],[1, 3, 2],[1, 0, 0]])\n    B = np.array([4, 5, 6])\n```", "```py\nIn [ ]:\n    print(np.linalg.solve(A, B))\nOut[ ]:\n   [  6\\.  15\\. -23.]\n```", "```py\nIn  [ ]:\n    \"\"\" \n    LU decomposition with SciPy \n    \"\"\"\n    import numpy as np\n    import scipy.linalg as linalg\n\n    # Define A and B\n    A = np.array([\n        [2., 1., 1.],\n        [1., 3., 2.],\n        [1., 0., 0.]])\n    B = np.array([4., 5., 6.])\n\n    # Perform LU decomposition\n    LU = linalg.lu_factor(A)\n    x = linalg.lu_solve(LU, B)\n```", "```py\nIn  [ ]:\n   print(x)\nOut[ ]:\n   [  6\\.  15\\. -23.]\n```", "```py\nIn [ ]:\n    import scipy\n\n    P, L, U = scipy.linalg.lu(A)\n\n    print('P=\\n', P)\n    print('L=\\n', L)\n    print('U=\\n', U)\n```", "```py\nIn  [ ]:\n    \"\"\" \n    Cholesky decomposition with NumPy \n    \"\"\"\n    import numpy as np\n\n    A = np.array([\n        [10., -1., 2., 0.],\n        [-1., 11., -1., 3.],\n        [2., -1., 10., -1.],\n        [0., 3., -1., 8.]])\n    B = np.array([6., 25., -11., 15.])\n\n    L = np.linalg.cholesky(A)\n```", "```py\nIn  [ ]:\n    print(L)\nOut[ ]:\n   [[ 3.16227766  0\\.          0\\.          0\\.        ]\n    [-0.31622777  3.3015148   0\\.          0\\.        ]\n    [ 0.63245553 -0.24231301  3.08889696  0\\.        ]\n    [ 0\\.          0.9086738  -0.25245792  2.6665665 ]]\n```", "```py\nIn  [ ]:\n    print(np.dot(L, L.T.conj())) # A=L.L*\nOut [ ]:\n    [[10\\. -1\\.  2\\.  0.]\n     [-1\\. 11\\. -1\\.  3.]\n     [ 2\\. -1\\. 10\\. -1.]\n     [ 0\\.  3\\. -1\\.  8.]]\n```", "```py\nIn  [ ]:\n    y = np.linalg.solve(L, B)  # L.L*.x=B; When L*.x=y, then L.y=B\n```", "```py\nIn  [ ]:\n    x = np.linalg.solve(L.T.conj(), y)  # x=L*'.y\n```", "```py\nIn  [ ]:\n    print(x)\nOut[ ]:\n   [ 1\\.  2\\. -1\\.  1.]\n```", "```py\nIn [ ] :\n    print(np.mat(A) * np.mat(x).T)  # B=Ax\nOut[ ]:\n    [[  6.]\n     [ 25.]\n     [-11.]\n     [ 15.]]\n```", "```py\nIn  [ ]:\n    \"\"\" \n    QR decomposition with scipy \n    \"\"\"\n    import numpy as np\n    import scipy.linalg as linalg\n\n    A = np.array([\n        [2., 1., 1.],\n        [1., 3., 2.],\n        [1., 0., 0]])\n    B = np.array([4., 5., 6.])\n\n    Q, R = scipy.linalg.qr(A)  # QR decomposition\n    y = np.dot(Q.T, B)  # Let y=Q'.B\n    x = scipy.linalg.solve(R, y)  # Solve Rx=y\n```", "```py\nIn [ ]:\n    print(x)\nOut[ ]:\n    [  6\\.  15\\. -23.]\n```", "```py\nIn [ ]:\n    \"\"\"\n    Solve Ax=B with the Jacobi method \n    \"\"\"\n    import numpy as np\n\n    def jacobi(A, B, n, tol=1e-10):\n        # Initializes x with zeroes with same shape and type as B\n        x = np.zeros_like(B)\n\n        for iter_count in range(n):\n            x_new = np.zeros_like(x)\n            for i in range(A.shape[0]):\n                s1 = np.dot(A[i, :i], x[:i])\n                s2 = np.dot(A[i, i + 1:], x[i + 1:])\n                x_new[i] = (B[i] - s1 - s2) / A[i, i]\n\n            if np.allclose(x, x_new, tol):\n                break\n\n            x = x_new\n\n        return x\n```", "```py\nIn [ ] :\n    A = np.array([\n        [10., -1., 2., 0.], \n        [-1., 11., -1., 3.], \n        [2., -1., 10., -1.], \n        [0.0, 3., -1., 8.]])\n    B = np.array([6., 25., -11., 15.])\n    n = 25\n```", "```py\nIn [ ]:\n    x = jacobi(A, B, n)\n    print('x', '=', x)\nOut[ ]:\n    x = [ 1\\.  2\\. -1\\.  1.]\n```", "```py\nIn  [ ]:\n    \"\"\" \n    Solve Ax=B with the Gauss-Seidel method \n    \"\"\"\n    import numpy as np\n\n    def gauss(A, B, n, tol=1e-10):\n        L = np.tril(A)  # returns the lower triangular matrix of A\n        U = A-L  # decompose A = L + U\n        L_inv = np.linalg.inv(L)\n        x = np.zeros_like(B)\n\n        for i in range(n):\n            Ux = np.dot(U, x)\n            x_new = np.dot(L_inv, B - Ux)\n\n            if np.allclose(x, x_new, tol):\n                break\n\n            x = x_new\n\n        return x\n```", "```py\nIn  [ ]:\n    A = np.array([\n        [10., -1., 2., 0.], \n        [-1., 11., -1., 3.], \n        [2., -1., 10., -1.], \n        [0.0, 3., -1., 8.]])\n    B = np.array([6., 25., -11., 15.])\n    n = 100\n    x = gauss(A, B, n)\n```", "```py\nIn [ ]:\n    print('x', '=', x)\nOut[ ]:   \n    x = [ 1\\.  2\\. -1\\.  1.]\n```"]