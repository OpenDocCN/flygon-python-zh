- en: Learning About Character Animation, Collision, and Movement
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习角色动画、碰撞和移动
- en: '*Animation is an art*. This raises questions about how we can create a virtual
    world that imitates the physical behavior of a person or objects by adding a texture
    or skin to each character or by maintaining an impeccable graphical user interface.
    While creating animation, we do not require knowledge of how controllers or physical
    devices work, yet animation is a medium between the physical devices and the characters
    of the games. Animation instructs players by guiding them with proper shading
    and movements in a pictorial view, and thus it is an art. We, as programmers,
    are accountable for where and why game characters move in certain directions,
    while animators are accountable for how they look and move.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*动画是一门艺术*。这引发了关于如何通过为每个角色添加纹理或皮肤，或者通过保持无可挑剔的图形用户界面来创建模拟人物或物体的物理行为的虚拟世界的问题。在创建动画时，我们不需要了解控制器或物理设备的工作原理，但动画是物理设备和游戏角色之间的媒介。动画通过在图像视图中以适当的阴影和动作引导玩家，因此它是一门艺术。作为程序员，我们负责游戏角色在特定方向移动的位置和原因，而动画师负责它们的外观和动作。'
- en: 'In the Python `pygame` module, we can create animation and collision using
    sprites—a two-dimensional image that is part of the larger graphical scene. Maybe
    we can make one for ourselves or download one from the internet. After loading
    such sprites with pygame, we are going to learn about two fundamental blocks for
    building games: handling user events and building animation logic. Animation logic
    is a simple yet powerful logic that makes sprites or images move in a particular
    direction that is governed by user events.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的`pygame`模块中，我们可以使用精灵来创建动画和碰撞-这是大型图形场景的一部分的二维图像。也许我们可以自己制作一个，或者从互联网上下载一个。在使用pygame加载这样的精灵之后，我们将学习构建游戏的两个基本模块：处理用户事件和构建动画逻辑。动画逻辑是一个简单而强大的逻辑，它使精灵或图像在用户事件控制下朝特定方向移动。
- en: By the end of this chapter, you will be familiar with the concepts of the game
    controller and ways of using it to create animations for game characters. Along
    with this, you will also learn about collision principles and ways of dealing
    with them using the pygame masking method. Not only that, but you will also learn
    about ways to handle movements for game characters, such as jumping, tapping,
    and scrolling while making games such as flappy bird.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，您将熟悉游戏控制器的概念以及使用它为游戏角色创建动画的方法。除此之外，您还将了解有关碰撞原理以及使用pygame掩模方法处理碰撞的方法。不仅如此，您还将学习处理游戏角色的移动方式，如跳跃、轻拍和滚动，同时制作类似flappy
    bird的游戏。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Overview of game animation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏动画概述
- en: Scrolling background and character animation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动背景和角色动画
- en: Random object generation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机对象生成
- en: Detecting collisions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: Scoring and end screen
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 得分和结束屏幕
- en: Game testing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏测试
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following list of requirements to be able to complete this
    chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下要求清单才能完成本章：
- en: Pygame editor (IDLE) version 3.5 or higher.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pygame编辑器（IDLE）版本3.5或更高。
- en: Pycharm IDE (refer to [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml), *Getting
    to Know Python – Setting Up Python and the Editor*, for the installation procedure).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pycharm IDE（参考[第1章](0ef9574b-5690-454e-971f-85748021018d.xhtml)，*了解Python-设置Python和编辑器*，进行安装程序）。
- en: The code assets and sprites for the Flappy Bird game are available in this book's
    GitHub repository: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flappy Bird游戏的代码资产和精灵可在本书的GitHub存储库中找到：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12)
- en: 'Check out the following video to see the code in action:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频，查看代码的运行情况：
- en: '[http://bit.ly/2oKQQxC](http://bit.ly/2oKQQxC)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2oKQQxC](http://bit.ly/2oKQQxC)'
- en: Understanding game animation
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解游戏动画
- en: Like just about everything you see in computer games, animation mimics the real
    world or tries to create one in which players can feel that they are interacting
    with it. Drawing a game with two-dimensional sprites is fairly simple, as we saw
    in the previous chapter while making the snake character for our Snake game. Even
    with the 2D characters, we can create three-dimensional movements with proper
    shading and motion. Animating single objects is easier with the `pygame` module;
    we saw a bit of this in action in the previous chapter when we created a simple
    animation for the Snake game. In this section, we are going to animate a number
    of objects using the `pygame` module. We will make a simple program that will
    create a snowfall animation. To begin, we will use some shapes to fill in the
    snowflakes (in this program, we are using a circular geometrical shape, but you
    can choose any shape) and then create some animation logic that will make the
    snowflake move within a milieu.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你在电脑游戏中看到的一切一样，动画模仿现实世界，或者试图创造一个让玩家感觉自己正在与之交互的世界。用二维精灵绘制游戏相当简单，就像我们在上一章中为贪吃蛇游戏制作角色时所看到的那样。即使是二维角色，我们也可以通过适当的阴影和动作创建三维运动。使用`pygame`模块可以更容易地为单个对象创建动画；我们在上一章中看到了一点实际操作，当时我们为贪吃蛇游戏创建了一个简单的动画。在本节中，我们将使用`pygame`模块为多个对象创建动画。我们将制作一个简单的程序，用于创建下雪的动画。首先，我们将使用一些形状填充雪花（在此程序中，我们使用的是圆形几何形状，但您可以选择任何形状），然后创建一些动画逻辑，使雪花在环境中移动。
- en: Before we write the code, make sure you brainstorm a little bit. Since we coded
    some advanced logic in the previous chapter too, this section might be easier
    for you, but make sure you learn about what we do here too as it is extremely
    useful for the next section, in which we will start making a clone of the Flappy
    Bird game.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码之前，确保你进行了一些头脑风暴。由于在上一章中我们编写了一些高级逻辑，所以这一部分对你来说可能更容易，但是确保你也学习了我们在这里做的事情，因为对接下来的部分非常有用，我们将开始制作Flappy
    Bird游戏的克隆版本。
- en: 'As we know, the snowflakes animation requires a location (*x*, *y*) to render
    snow on it. This location can be chosen arbitrarily, and so you can use a random
    module to choose such locations. The following code shows how any shape can be
    drawn in a random location using the `pygame` module. Since a `for` loop is used
    for iteration, we will be using it to create a range for an iteration of at 50
    calls at the most (the value of `eachSnow` ranging from 0 to 49). Recall the previous
    chapter, where you learned how to use pygame''s `draw` module to draw any shape
    into the screen. Considering this, let''s take a look at the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，雪花动画需要一个位置（*x*，*y*）来渲染雪花。这个位置可以任意选择，因此你可以使用随机模块来选择这样的位置。以下代码展示了如何使用`pygame`模块在随机位置绘制任何形状。由于使用了`for`循环进行迭代，我们将使用它来创建一个迭代的范围，最多进行50次调用（`eachSnow`的值从0到49）。回想一下前一章，你学习了如何使用pygame的`draw`模块将任何形状绘制到屏幕上。考虑到这一点，让我们看看以下代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Imagine that we made animation using the preceding code which will, in turn,
    draw circular snowflakes. After running this, you will observe something odd in
    the output. You may have guessed this already, but let me shed some light on this.
    The preceding code makes a circle—in some random position—and the previously made
    circle vanishes as soon as the new circle is created. Instead of that, we want
    our code to generate numbers of snow and must make sure that the previously made
    circle is on the right-hand position instead of vanishing. Did you discover that
    the preceding code was kind of buggy? Now that you know what causes that error,
    take your time and think about how to solve this error. One ubiquitous idea that
    might occur to you is solving this using a data structure. I prefer to use lists.
    Let''s make some modifications to the preceding code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们使用了前面的代码来制作动画，这将绘制圆形雪花。运行后，你会发现输出中有些奇怪的地方。你可能已经猜到了，但让我为你解释一下。前面的代码制作了一个圆圈——在某个随机位置——并且先前制作的圆圈在新圆圈创建时立即消失。我们希望我们的代码生成多个雪花，并确保先前制作的圆圈位于右侧位置而不是消失。你发现前面的代码有点bug吗？既然你知道了错误的原因，花点时间考虑如何解决这个错误。你可能会想到一个普遍的想法，那就是使用数据结构来解决这个问题。我倾向于使用列表。让我们对前面的代码进行一些修改：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, in the `snowArray` list, we have added the position of the randomly created
    snow at position *x* and *y*. For multiple `x_pos` and `y_pos` values of snow,
    a nested list will be formed. For instance, a list might look something like `[[20,40],[40,30],[30,33]]` for
    three randomly made circular pieces of snow.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`snowArray`列表中，我们已经添加了随机创建的雪的位置，即*x*和*y*。对于雪的多个`x_pos`和`y_pos`值，将形成一个嵌套列表。例如，一个列表可能看起来像`[[20,40],[40,30],[30,33]]`，表示随机制作的三个圆形雪花。
- en: 'For each of piece of snow made by using the preceding `for` loop, you have
    to render it using another loop. Getting the length of the `snow_list` variable
    might be helpful as this will give us an idea about how much snow should be drawn.
    For the number of positions indicated by `snow_list`, we can use the `pygame.draw`
    module to draw any shape, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用前面的`for`循环创建的每一片雪花，你必须使用另一个循环进行渲染。获取`snow_list`变量的长度可能会有所帮助，因为这将给我们一个关于应该绘制多少雪花的想法。对于由`snow_list`指示的位置数量，我们可以使用`pygame.draw`模块绘制任何形状，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Can you see how easy it is to make drawings with the `pygame` module? Even
    though it is not alienating stuff for you, this concept will come handy in a little
    while. Next, we will look at how to make the snow fall downward. Follow these
    steps to create a downward movement for the circular snow:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到使用`pygame`模块绘制图形有多容易吗？即使这对你来说并不陌生，这个概念很快就会派上用场。接下来，我们将看看如何让雪花向下飘落。按照以下步骤创建圆形雪花的向下运动：
- en: 'To begin, you have to make the snow move downward with unit pixels. You only
    have to make changes to the `y_pos` coordinates of the `snowArray` elements, like
    so:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你必须让雪向下移动一个单位像素。你只需要对`snowArray`元素的`y_pos`坐标进行更改，如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Secondly, you have to make sure that, whenever snow falls out of sight, it
    is created continuously. In *Step 1*, we have created a downfall for the circular
    snow. At some point, it is going to strike with a lower horizontal boundary. If
    it hits this, you have to reset it to render it from the top. By adding the following
    code, the circular snow will be rendered at the top of the screen using a random
    library:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，你必须确保，无论何时雪花消失在视野之外，都会不断地创建。在*步骤1*中，我们已经为圆形雪花创建了向下运动。在某个时候，它将与较低的水平边界相撞。如果它碰到了这个边界，你必须将它重置，以便从顶部重新渲染。通过添加以下代码，圆形雪花将在屏幕顶部使用随机库进行渲染：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The full code for this animation is as follows (code that''s written with comments
    is self-explanatory):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动画的完整代码如下（带有注释的代码是不言自明的）：
- en: 'To begin, the preceding code that we wrote needs to be redefined and refactored
    so that the code looks good. Let''s start by initializing it:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们编写的前面的代码需要重新定义和重构，以使代码看起来更好。让我们从初始化开始：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, add your `for` loop, right below the initialization:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在初始化的下面添加你的`for`循环：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Similarly, we will end the logic by creating the main loop, which *loops* until
    the user clicks the Close button explicitly:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，我们将通过创建主循环来结束逻辑，该循环将一直循环，直到用户显式点击关闭按钮：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, check if snow is within the boundary or not:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，检查雪花是否在边界内：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, update the screen with whatever has been drawn:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新屏幕上已经绘制的内容：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code consists of many fragments of code: the initialization of
    game variables, followed by creating game models. In *Step 3*, we created some
    simple logic that governs the animation of the game. We built two models of code
    in *Step 3*, which make our game interactive for the user (handling user events)
    and make a game object (circular snowfall) that it renders with a `for` loop.
    Although we are going to create more intricate animations in upcoming chapters,
    this is a good animation program to start with. You can clearly see that, under
    the hood, the creation of animations requires the use of looping, conditionals,
    and game objects. We use Python programming paradigms such as if-else statements,
    looping, arithmetic, and vectored manipulation to create game-object animations.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码由许多代码片段组成：初始化游戏变量，然后创建游戏模型。在*步骤3*中，我们创建了一些简单的逻辑来控制游戏的动画。我们在*步骤3*中构建了两个代码模型，使我们的游戏对用户进行交互（处理用户事件），并创建一个游戏对象（圆形降雪），它使用`for`循环进行渲染。尽管我们将在接下来的章节中创建更复杂的动画，但这是一个很好的动画程序开始。您可以清楚地看到，在幕后，创建动画需要使用循环、条件和游戏对象。我们使用Python编程范式，如if-else语句、循环、算术和向量操作来创建游戏对象动画。
- en: Apart from animating geometrical shapes, you can even animate sprites or images.
    To do this, you have to make your own sprites or download some from the internet.
    In the next section, we are going to animate sprites using the `pygame` module.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了动画几何形状，您甚至可以动画精灵或图像。为此，您必须制作自己的精灵或从互联网上下载一些。在接下来的部分中，我们将使用`pygame`模块来动画精灵。
- en: Animating sprites
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画精灵
- en: Animating sprites is no different from animating geometrical shapes, but they
    are considered complex because you have to write extra bits of code to `blit`
    such images using animation logic. This animation logic, however, won't be the
    same for every image you load; it differs from game to game. Thus, you must analyze
    what type of animation is suitable for your sprites beforehand so that you can
    code it accordingly. In this section, we aren't going to create any custom images;
    instead, we will be downloading some (thanks to the internet!). We are going to
    embed animation logic into those sprites so that our program will facilitate adequate
    shading and movement.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 动画精灵与动画几何形状没有什么不同，但它们被认为是复杂的，因为您必须编写额外的代码来使用动画逻辑`blit`这样的图像。然而，这种动画逻辑对于您加载的每个图像都不会相同；它因游戏而异。因此，您必须事先分析适合您的精灵的动画类型，以便您可以相应地编写代码。在本节中，我们不打算创建任何自定义图像；相反，我们将下载一些（感谢互联网！）。我们将在这些精灵中嵌入动画逻辑，以便我们的程序将促进适当的阴影和移动。
- en: 'Just to give you a flavor of how easy it is to animate static images or sprites,
    we are going to create a simple program that will load about 15 images of a character
    (moving left and right). We will `blit` (render) them whenever the user presses
    the LEFT or RIGHT key on their keyboard. Perform the following steps to learn
    how to create an animated sprite program:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解动画静态图像或精灵有多容易，我们将创建一个简单的程序，该程序将加载大约15个角色图像（向左和向右移动）。每当用户按键盘上的左键或右键时，我们将`blit`（渲染）它们。执行以下步骤来学习如何创建一个动画精灵程序：
- en: 'To begin, you should start by creating a base template for the `pygame` program.
    You must import some important modules, create a surface for the animation console,
    and declare the *idle* friendly `quit()` function:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您应该从为`pygame`程序创建一个基本模板开始。您必须导入一些重要的模块，为动画控制台创建一个表面，并声明*空闲*友好的`quit()`函数。
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Secondly, you must load all the sprites and images listed in the *images* directory.
    This directory contains several sprites. You must download it and save it in the
    directory where your Python file is stored (the sprites/images file can be found
    on GitHub at [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12)):'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，您必须加载*images*目录中列出的所有精灵和图像。该目录包含几个精灵。您必须下载它并保存在存储Python文件的目录中（可以在GitHub上找到sprites/images文件，网址为[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12)）：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we need to declare some essential variables, such as the initial position
    of the character and its velocity, that is, the distance traveled per unit keystroke
    by the game sprites. In the following code, I have declared the velocity as five
    units, which suggests that the game character will move a fixed 5 pixels from
    the current position:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要声明一些基本变量，例如角色的初始位置和速度，即游戏精灵每单位按键击移动的距离。在下面的代码中，我已经将速度声明为五个单位，这意味着游戏角色将从当前位置移动固定的5个像素：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You have to declare a few more variables in order to track the movement of
    sprites based on what the user is pressing on the keyboard. If the LEFT arrow
    key is pressed, the `left` variable will be `True`, while if the RIGHT arrow key
    is pressed, the `right` variable will be `False`. The `walkCount` variable will
    track the number of times the key is pressed:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您必须声明一些额外的变量，以便根据用户在键盘上按下什么来跟踪精灵的移动。如果按下左箭头键，则`left`变量将为`True`，而如果按下右箭头键，则`right`变量将为`False`。`walkCount`变量将跟踪按下键的次数：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we have completed the basic layout for any pygame program—importing appropriate
    modules, declaring variables to track movements, loading sprites, and so on. The
    two remaining parts of the program are the most important ones, so make sure you
    understand them. We will start by creating a main loop, as usual. This main loop
    will handle user events, that is, what to do when a user presses the LEFT or RIGHT
    key. Secondly, you have to create some animation logic, which will determine what
    image to `blit` at what point of time based on user events.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经完成了任何pygame程序的基本布局——导入适当的模块，声明变量以跟踪移动，加载精灵等等。程序的另外两个部分是最重要的，所以请确保您理解它们。我们将开始创建一个主循环，像往常一样。这个主循环将处理用户事件，也就是说，当用户按下左或右键时要做什么。其次，您必须创建一些动画逻辑，这将根据用户事件确定在什么时间点`blit`什么图像。
- en: 'We will start by handling user events. Follow these steps to do so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从处理用户事件开始。按照以下步骤进行：
- en: 'To begin, you must declare a main loop, which much be an infinite loop. We
    will provide **FPS** for the game using the `tick` method. As you may recall,
    this method should be called once per frame. It will compute how many milliseconds
    have passed since the previous call:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您必须声明一个主循环，它必须是一个无限循环。我们将使用`tick`方法为游戏提供**FPS**。正如您可能记得的那样，这个方法应该在每帧调用一次。它将计算自上一次调用以来经过了多少毫秒：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Secondly, start by handling critical user events. In simple sprite animations,
    you can start by handling two basic movements: LEFT and RIGHT. In upcoming sections,
    we will make games by handling the JUMPING/TAPPING action. This code should be
    written inside a while loop:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，开始处理关键的用户事件。在简单的精灵动画中，您可以从处理两种基本移动开始：左和右。在接下来的部分中，我们将通过处理跳跃/轻击动作来制作游戏。这段代码应该写在一个while循环内：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Observe the last line of the preceding code—the call to the `Animation_Logic()`
    function is complete. However, this method hasn''t been declared yet. This method
    is a central block for any game that''s made out of sprites or images. Code written
    inside the animation logic will perform two different tasks:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 观察上述代码的最后一行——对`Animation_Logic()`函数的调用已经完成。然而，这个方法还没有被声明。这个方法是由精灵或图像制作的任何游戏的核心模块。在动画逻辑内编写的代码将执行两个不同的任务：
- en: Blit or render images from the list of images defined while loading the sprites.
    In our case, these are `walkRight`, `walkLeft`, `bg`, and `char`.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从加载精灵时定义的图像列表中blit或渲染图像。在我们的情况下，这些是`walkRight`、`walkLeft`、`bg`和`char`。
- en: Redraw the game window based on the logic, which will check which image to select
    from the pool of images. Note that `walkLeft` contains nine different images.
    This logic will make a selection from these images.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据逻辑重新绘制游戏窗口，这将检查从图像池中选择哪个图像。请注意，`walkLeft`包含九个不同的图像。这个逻辑将从这些图像中进行选择。
- en: Now that we have handled user events, let's learn how to make animation logic
    for our previously loaded sprites.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了用户事件，让我们学习如何为之前加载的精灵制作动画逻辑。
- en: Animation logic
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画逻辑
- en: 'Sprites are static images that contain characters and have a transparent background.
    Extra alpha information for these sprites is essential because, in 2D games, we
    want the user to only see the characters and not their background. Imagine a game
    that has a character blit with a bland background. It would leave the players
    with a bad impression of the game. For instance, the following sprites are Mario
    characters. Let''s say you are making a Mario game and you crop a character from
    the following sprites and forget to remove its blue background. The character,
    along with its blue background, will be rendered in the game, making the game
    awful. Thus, we have to manually remove (if any) the character background using
    online tools or offline tools such as GIMP. An example of a sprite sheet is as
    follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵是包含角色并具有透明背景的静态图像。这些精灵的额外alpha信息是必不可少的，因为在2D游戏中，我们希望用户只看到角色而不是他们的背景。想象一下一个游戏，其中一个角色与单调的背景blit。这会给玩家留下对游戏的坏印象。例如，以下精灵是马里奥角色。假设您正在制作一个马里奥游戏，并且从以下精灵中裁剪一个角色，却忘记去除其蓝色背景。角色连同其蓝色背景将在游戏中呈现，使游戏变得糟糕。因此，我们必须手动使用在线工具或离线工具（如GIMP）去除（如果有的话）角色背景。精灵表的一个示例如下：
- en: '![](Images/3e5970c4-966c-4bd4-92fa-1e9e2452d573.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3e5970c4-966c-4bd4-92fa-1e9e2452d573.png)'
- en: 'Now, let''s continue with our sprite animation. Up until now, we have declared
    a template for handling events using `pygame`; now, let''s write our animation
    logic. As we previously affirmed, *Animation logic is simple logic that will make
    a selection between the images and blit it accordingly.* Let''s make that logic
    now:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续我们的精灵动画。到目前为止，我们已经使用`pygame`声明了处理事件的模板；现在，让我们编写我们的动画逻辑。正如我们之前所断言的那样，*动画逻辑是简单的逻辑，将在图像之间进行选择并相应地进行blit。*现在让我们制定这个逻辑：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first thing you will see is the `global` variable. The `walkCount` variable
    was initially declared inside the main loop and counts the number of times the
    user has pressed any keys. However, if you remove the `global walkCount` statement,
    you won''t be able to change the value of `walkCount` inside the `Animation_Logic`
    function. If you only want to access or print the value of `walkCount` inside
    the function, you don''t need to define it as global. However, if you want to
    manipulate its value inside a function, you must declare it as a global variable.
    The `blit` command is going to take two arguments: one is the sprite that needs
    to be rendered while the other is the position at which the sprite must be rendered
    onto the screen. In the preceding code, the code that''s written after `#check_1`
    is to qualify the character whenever it reaches extreme positions. It is a check
    for which we have to render a *char* image, which is a still image of a character.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到的第一件事是`global`变量。`walkCount`变量最初在主循环中声明，并计算用户按下任何键的次数。然而，如果你删除`global walkCount`语句，你将无法在`Animation_Logic`函数内改变`walkCount`的值。如果你只想在函数内访问或打印`walkCount`的值，你不需要将其定义为全局变量。但是，如果你想在函数内操作它的值，你必须将其声明为全局变量。`blit`命令将采用两个参数：一个是需要渲染的精灵，另一个是精灵必须渲染到屏幕上的位置。在前面的代码中，写在`#check_1`之后的代码是为了在角色到达极限位置时对其进行限定。这是一个检查，我们必须渲染一个*char*图像，这是一个角色静止的图像。
- en: Rendering the sprites begins with our checking whether the left movement is
    active or not. If `True`, `blit` the images at the (*x*, *y*) position. The value
    of (*x*, *y*) is manipulated by the event handler. Whenever the user presses the
    LEFT arrow key, the *x* value will be decreased by five units from its previous
    value and the image will be rendered to it. Since this animation allows the character
    to move only in a horizontal direction on either the positive *X*-axis or negative
    *X*-axis, there is no change in the y-coordinates. Similarly, for the right movement,
    we are going to render images from the pool of `walkRight` at the position specified
    by (*x*, *y*). In the else part of the code, we `blit` a char image, which is
    an idle image of the character with no movements. Thus, `walkCount` is equal to
    zero. After we `blit` everything, we have to update it to reflect the changes.
    We do this by calling the `display.update` method.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染精灵始于我们检查左移动是否激活。如果为`True`，则在(*x*, *y*)位置`blit`图像。(*x*, *y*)的值由事件处理程序操作。每当用户按下左箭头键时，*x*的值将从其先前的值减少五个单位，并且图像将被渲染到该位置。由于这个动画只允许角色在水平方向上移动，要么在正的*X*轴上，要么在负的*X*轴上，y坐标没有变化。同样，对于右移动，我们将从`walkRight`的图像池中渲染图像到指定的(*x*,
    *y*)位置。在代码的else部分，我们`blit`一个char图像，这是一个角色静止的图像，没有移动。因此，`walkCount`等于零。在我们`blit`完所有东西之后，我们必须更新它以反映这些变化。我们通过调用`display.update`方法来做到这一点。
- en: 'Let''s run the animation and observe the output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行动画并观察输出：
- en: '![](Images/d090b846-6b24-4c12-9ce4-197a81fc49fa.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d090b846-6b24-4c12-9ce4-197a81fc49fa.png)'
- en: 'In the console, if you press the LEFT arrow key, the character will begin moving
    to the left, and if you press the RIGHT arrow key the character will move to the
    right. Since there is no change in y coordinates and we are not handling any events
    in the main loop to facilitate vertical movements, the character is restricted
    to moving in a horizontal direction. I strongly urge you to experiment with these
    sprites and try handling vertical movements by changing y-coordinates. Although
    I have provided you with a list of resources containing a list of images, if you
    want to use any other sprites for your game, you can go over to the following
    site and download any of the sprites from there: [https://www.spriters-resource.com/](https://www.spriters-resource.com/).
    This website is a paradise for any pygame developer, so make sure you visit it
    and download any game sprites you want so that you can experiment with this (Mario
    would be better to experiment with).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中，如果你按下左箭头键，角色将开始向左移动，如果你按下右箭头键，角色将向右移动。由于y坐标没有变化，并且我们没有在主循环中处理任何事件来促进垂直移动，角色只能在水平方向移动。我强烈建议你尝试这些精灵，并尝试通过改变y坐标来处理垂直移动。虽然我已经为你提供了一个包含图像列表的资源列表，但如果你想在游戏中使用其他精灵，你可以去以下网站下载任何你想要的精灵：[https://www.spriters-resource.com/](https://www.spriters-resource.com/)。这个网站对于任何pygame开发者来说都是一个天堂，所以一定要去访问并下载任何你想要的游戏精灵，这样你就可以尝试这个（用马里奥来尝试可能会更好）。
- en: From the next section onward, we will start making a clone of the Flappy Bird
    game. We will learn about techniques such as a scrolling background and character
    animation, random object generation, collision, and scoring.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一节开始，我们将开始制作Flappy Bird游戏的克隆。我们将学习滚动背景和角色动画、随机对象生成、碰撞和得分等技术。
- en: Scrolling background and character animation
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滚动背景和角色动画
- en: Now that you know enough about pygame sprites and animation, you are capable of
    making a game that contains intricate sprite animations that contain multiple
    objects. In this section, we are going to learn about scrolling backgrounds and
    character animation by making a Flappy Bird game. This game contains multiple
    objects, with Bird being the main character for the game and a pipe pair for the
    obstacles in the game. If you haven't played this game before, give it a go by
    visiting its official website: [https://flappybird.io/](https://flappybird.io/).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解足够关于pygame精灵和动画，你有能力制作一个包含复杂精灵动画和多个对象的游戏。在这一部分，我们将通过制作一个Flappy Bird游戏来学习滚动背景和角色动画。这个游戏包含多个对象，鸟是游戏的主角，游戏中的障碍物是一对管道。如果你以前没有玩过这个游戏，可以访问它的官方网站试一试：[https://flappybird.io/](https://flappybird.io/)。
- en: Speaking of the game, it isn't that hard to make, but by taking care of multiple
    aspects of game programming it can be an arduous task for beginners. Having said
    that, we aren't going to make any sprites ourselves—they are freely available
    on the internet. This makes our task even easier. Since the designs of the game
    characters are open source, we can directly focus on the coding part of the game.
    But if you want to design your game characters from scratch, start making them
    using any simple Paint application. For this Flappy Bird game, I am going to use
    sprites that are freely available.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 说到游戏，制作起来并不难，但通过照顾游戏编程的多个方面，对于初学者来说可能是一项艰巨的任务。话虽如此，我们不打算自己制作任何精灵——它们在互联网上是免费提供的。这使得我们的任务变得更加容易。由于游戏角色的设计是开源的，我们可以直接专注于游戏的编码部分。但是，如果你想从头开始设计你的游戏角色，可以使用任何简单的绘图应用程序开始制作它们。对于这个Flappy
    Bird游戏，我将使用免费提供的精灵。
- en: I have added resources in the GitHub links. If you open the images folder and
    then open the background image file, you will see that it contains background
    images of a specific height and width. But in the Flappy Bird game, you can observe
    that background images are rendered continuously. Thus, using pygame, we can make
    a scrolling background so that we can `blit` the background image continuously.
    Thus, instead of using thousands of copies of the same images for the background,
    we can use one image and `blit` it continuously.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在GitHub链接中添加了资源。如果你打开图像文件夹，然后打开背景图像文件，你会看到它包含特定高度和宽度的背景图像。但是在Flappy Bird游戏中，你可以观察到背景图像是连续渲染的。因此，使用pygame，我们可以制作一个滚动背景，这样我们就可以连续`blit`背景图像。因此，我们可以使用一张图像并连续`blit`它，而不是使用成千上万份相同的背景图像副本。
- en: 'Let''s start by making a character animation, along with a scrolling background.
    The following steps show us how to use object-oriented programming to make a class
    for each game character:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从制作一个角色动画和一个滚动背景开始。以下步骤向我们展示了如何使用面向对象编程为每个游戏角色制作一个类：
- en: 'To begin, you must start declaring modules such as math, os (for loading images
    with a specified filename), random, collections, and pygame. You must also declare
    some variables representing the frames-per-second setting, animation speed, and
    the game console''s height and width:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你必须开始声明诸如math、os（用于加载具有指定文件名的图像）、random、collections和pygame等模块。你还必须声明一些变量，表示每秒帧数设置、动画速度和游戏控制台的高度和宽度：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, let's load all the images from the image folder into the Python project.
    I will also make two more methods that will perform the conversion between frames
    to milliseconds and vice versa.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将图像文件夹中的所有图像加载到Python项目中。我还将创建两个方法，用于在帧和毫秒之间进行转换。
- en: 'Let''s see how the `loading_Images` function works by using the following code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看`loading_Images`函数是如何通过以下代码工作的：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding program, we defined the `loading_Image` function, which loads/extracts
    all the images from a certain directory and returns them as a dictionary containing
    name as key and image as value. Let''s analyze how the keys and values will be
    stored in such a dictionary via the following arguments:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们定义了`loading_Image`函数，它从特定目录加载/提取所有图像，并将它们作为包含名称作为键和图像作为值的字典返回。让我们通过以下参数分析这样一个字典中的键和值将如何存储：
- en: '`background.png`: The background image for the flappy bird game.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`background.png`：Flappy Bird游戏的背景图像。'
- en: '`img:bird-wingup.png`: This image of the flappy bird has one wing pointing
    upward and is rendered when the screen is tapped in the game.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`img:bird-wingup.png`：这张Flappy Bird的图像有一只翅膀向上指，当在游戏中点击屏幕时渲染。'
- en: '`img:bird-wingdown.png`: This part of the image is used when the flappy bird
    has free fall, that is, when a user is not tapping the screen. This image has
    the flappy bird''s wing pointing downward.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`img:bird-wingdown.png`：这部分图像在Flappy Bird自由下落时使用，也就是当用户没有点击屏幕时。这张图像有Flappy
    Bird的翅膀向下指。'
- en: '`img:bodyPipe.png`: This contains the discrete body parts that can be used
    to create a single pipe. For instance, in the Flappy Bird game, there should be
    two discrete slices of the pipe rendered from the top and bottom, leaving a gap
    between them.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`img:bodyPipe.png`：这包含了可以用来创建单个管道的离散身体部位。例如，在Flappy Bird游戏中，应该从顶部和底部渲染两个离散的管道片段，它们之间留有一个间隙。'
- en: '`img:endPipe.png`: This part of the image is the base of the pipe pair. There
    are two types of such images: the small pipe-end for the small pipe pair and the
    big pipe-end image for the larger pipe pair.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`img:endPipe.png`：这部分图像是管道对的底部。有两种类型的这样的图像：小管道对的小管道底部和大管道对的大管道底部图像。'
- en: Similarly, we have a nested `loading_Image` function that creates a filename
    for each sprite that's being loaded. It loads images from `/images/ folder`. After
    loading each image successively, they are called with the `convert()` method to
    speed up the blitting (rendering) process. The argument that's passed to the `loading_Image`
    function is the filename of the image. `image_name` is the filename that's given
    (along with its extension; `.png` is preferred) to load it via the `os.path.join`
    method, along with the `convert()` method to speed up the blitting (rendering)
    process.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们有一个嵌套的`loading_Image`函数，用于为每个加载的精灵创建一个文件名。它从`/images/文件夹`加载图像。在连续加载每个图像之后，它们会使用`convert()`方法进行调用，以加快blitting（渲染）过程。传递给`loading_Image`函数的参数是图像的文件名。`image_name`是给定的文件名（连同其扩展名；`.png`是首选）通过`os.path.join`方法加载它，以及`convert()`方法以加快blitting（渲染）过程。
- en: 'After loading the images, we need to make two functions that perform conversions
    of frame rates (please go to [Chapter 10](b6bfaeca-a5ea-4d39-a757-653f2e2be083.xhtml), *Upgrading
    the Snake Game with Turtle* to find out more about frame rates). These sets of
    functions primarily perform conversion from frames to milliseconds at the specified
    frame rates and vice versa. This conversion of frames to milliseconds is important
    because we have to use milliseconds for the movement of the `Bird` character,
    that is, the number of milliseconds left to climb, where a complete climb lasts
    `Bird.CLIMB_DURATION` milliseconds. Use this if you want the bird to make a (small)
    climb at the very beginning of the game. Let''s make such two sets of functions
    (an exhaustive description of the code is also available on GitHub at [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12))
    in the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 加载图像后，我们需要创建两个函数，用于在指定的帧速率下执行帧率的转换（请参阅[第10章](b6bfaeca-a5ea-4d39-a757-653f2e2be083.xhtml)，*使用海龟升级贪吃蛇游戏*，了解更多关于帧速率的信息）。这些函数集主要执行从帧到毫秒的转换以及相反的转换。帧到毫秒的转换很重要，因为我们必须使用毫秒来移动`Bird`角色，也就是鸟要上升的毫秒数，一个完整的上升需要`Bird.CLIMB_DURATION`毫秒。如果你想让鸟在游戏开始时做一个（小）上升，可以使用这个。让我们创建这样两组函数（代码的详细描述也可以在GitHub上找到：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter12)）：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, declare a class for the bird character. Recall [Chapter 6](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml), *Object-Oriented
    Programming* where we learned that each entity should be represented by a single
    class. In the Flappy Bird game, the entity or model representing the `PipePair`
    (obstacles) is different from another entity, let's say, Bird. Thus, we have to
    make a new class to represent another entity. This class will represent the bird
    that will be controlled by the player. Since the bird is the "hero" of our game,
    any movements that are defined for the Bird character are only allowed by the
    user who's playing the game. The player can make the bird climb (ascend quickly)
    by tapping the screen; otherwise, it will sink (descend slowly). The bird must
    pass through the space in-between the pipe-pair, and for every pipe that's passed,
    one point will be rewarded. Similarly, if the bird crashes into a pipe, the game
    ends.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为鸟角色声明一个类。回想一下[第6章](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml)，*面向对象编程*，我们学到每个实体都应该由一个单独的类来表示。在Flappy
    Bird游戏中，代表`PipePair`（障碍物）的实体或模型与另一个实体（比如鸟）是不同的。因此，我们必须创建一个新的类来表示另一个实体。这个类将代表由玩家控制的鸟。由于鸟是我们游戏的“英雄”，鸟角色的任何移动只允许由玩游戏的用户来控制。玩家可以通过点击屏幕使鸟上升（快速上升），否则它会下沉（缓慢下降）。鸟必须通过管道对之间的空间，每通过一个管道就会得到一个积分。同样，如果鸟撞到管道，游戏就结束了。
- en: 'Now, we can start coding our main character. Do you remember how to do this?
    This is one of the most important characteristics of any good game programmer—they
    brainstorm too much and write small but optimized code. So, let''s brainstorm
    and predict how we want to build the bird character beforehand so that we can
    code flawlessly afterward. The following are some essentials attributes and constants
    that must be defined as Bird class members:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始编写我们的主角了。你还记得如何做吗？这是任何优秀游戏程序员的最重要特征之一——他们会进行大量头脑风暴，然后写出小而优化的代码。因此，让我们先进行头脑风暴，预测我们想要如何构建鸟角色，以便之后可以无缺陷地编写代码。以下是一些必须作为Bird类成员定义的基本属性和常量：
- en: '**Attributes of the class:** `x` is the bird''s *X* coordinates, `y` is the
    bird''s *Y* coordinates, and `msec_to_climb` represents the number of milliseconds
    left to climb, where a complete climb lasts `Bird.CLIMB_DURATION` milliseconds.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类的属性**：`x`是鸟的X坐标，`y`是鸟的Y坐标，`msec_to_climb`表示鸟要上升的毫秒数，一个完整的上升需要`Bird.CLIMB_DURATION`毫秒。'
- en: '**Constants**:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常量**：'
- en: '`WIDTH`: The width, in pixels, of the bird''s image.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WIDTH`：鸟图像的宽度（以像素为单位）。'
- en: '`HEIGHT`: The height, in pixels, of the bird''s image.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEIGHT`：鸟图像的高度（以像素为单位）。'
- en: '`SINK_SPEED`: The speed at which, in pixels per millisecond, the bird descends
    in one second while not climbing.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SINK_SPEED`：鸟在不上升时每毫秒下降的像素速度。'
- en: '`CLIMB_SPEED`: The speed at which, in pixels per millisecond, the bird ascends
    in one second while climbing, on average. See the `Bird.update` doc-string for
    more information.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLIMB_SPEED`：鸟在上升时每毫秒上升的像素速度，平均而言。更多信息请参阅`Bird.update`文档字符串。'
- en: '`CLIMB_DURATION`: The number of milliseconds it takes the bird to execute a
    complete climb.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLIMB_DURATION`：鸟执行完整上升所需的毫秒数。'
- en: 'Now that we have enough information about the Bird character in our game, we
    can start writing the code for it. The following line of code represents the Bird
    class, which has members defined as class attributes and constants:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了关于游戏中鸟角色的足够信息，我们可以开始为其编写代码了。下面的代码行表示Bird类，其中成员被定义为类属性和常量：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s talk about the constructor, or initializer, that''s defined inside the
    Bird class. It contains many arguments that might overwhelm you, but they are
    rather easy to grasp. In the constructor, we normally define the attributes of
    the class, in this case, variables such as the x and y coordinates that represent
    the bird''s position, as well as other arguments. Let''s go over these now:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来谈谈鸟类内部定义的构造函数或初始化器。它包含许多参数，可能会让你感到不知所措，但它们实际上很容易理解。在构造函数中，我们通常定义类的属性，比如代表鸟位置的x和y坐标，以及其他参数。现在让我们来看看这些：
- en: '`x`: The bird''s initial *X* coordinates.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`：鸟的初始X坐标。'
- en: '`y`: The bird''s initial *Y* coordinates.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y`：鸟的初始Y坐标。'
- en: '`msec_to_climb`: The number of milliseconds left to climb, where a complete
    climb lasts `Bird.CLIMB_DURATION` milliseconds. Use this if you want the bird
    to make a (small) climb at the very beginning of the game.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msec_to_climb`: 剩余的毫秒数要爬升，完整的爬升需要 `Bird.CLIMB_DURATION` 毫秒。如果你想让小鸟在游戏开始时做一个（小）爬升，可以使用这个。'
- en: '`images`: A tuple containing the images used by this bird. It must contain
    the following images, in the following order:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`images`: 包含此小鸟使用的图像的元组。它必须按照以下顺序包含以下图像：'
- en: Bird wing when flying up
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小鸟上飞时的翅膀
- en: Bird wing when falling down
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小鸟下落时的翅膀
- en: 'Finally, three important properties should be declared. These properties are `image`,
    `mask`, and `rect`. Imagine properties are what the bird is essentially doing
    in the game. It can fly up and down, which is defined inside the image property.
    However, the other two properties of the bird class are quite different. The `rect`
    property will get the bird''s position, height, and width as a `Pygame.Rect` (in
    the form of a rectangle). Remember that `pygame` can track every game character
    with the `rect` property, and something like an invisible rectangle will be drawn
    around the sprites. The mask property gets a bit-mask that can be used in collision
    detection with obstacles:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应声明三个重要属性。这些属性是`image`、`mask`和`rect`。想象属性是小鸟在游戏中的基本动作。它可以上下飞行，这在图像属性中定义。然而，小鸟类的另外两个属性相当不同。`rect`属性将获取小鸟的位置、高度和宽度作为`Pygame.Rect`（矩形的形式）。记住，`pygame`可以使用`rect`属性跟踪每个游戏角色，类似于一个无形的矩形将被绘制在精灵周围。mask属性获取一个位掩码，可用于与障碍物进行碰撞检测：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Since we are already familiar with the concepts of the `rect` and `mask` properties,
    I won't bother repeating myself here, so let's learn about the image property
    in detail. The image property gets the surface that points to the current image
    of a bird. This will decide whether to return an image where the bird's visible
    wing is pointing upward or where it is pointing downward based on `pygame.time.get_ticks()`.
    This will animate the Flappy Bird, even though pygame doesn't support *animated
    GIFs.*
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经熟悉了`rect`和`mask`属性的概念，我就不再重复了，所以让我们详细了解一下图像属性。图像属性获取指向小鸟当前图像的表面。这将决定根据`pygame.time.get_ticks()`返回一个图像，其中小鸟的可见翅膀指向上方或指向下方。这将使Flappy
    Bird动画化，即使pygame不支持*动画GIF*。
- en: 'The time has come to wrap up the Bird class, but before that, you have to declare
    one more method, which will update the bird''s position. Ensure that you read
    the description that I''ve added inside the triple quote as a comment:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候结束`Bird`类了，但在此之前，你必须声明一个方法，用于更新小鸟的位置。确保你阅读了我在三引号中添加的描述，作为注释：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The mathematical `cosine(angle)` function is used to make a smooth climb for
    the bird. Cosine is an even function, which means it is an even climb and a fall
    movement is given to the bird: when the bird is in the middle of the screen, a
    high jump can be performed, but when the bird is near the top/bottom boundary,
    only a slight jump can be made (this is a basic principle for the Flappy Bird''s
    movement).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 数学`cosine(angle)`函数用于使小鸟平稳爬升。余弦是一个偶函数，这意味着小鸟会做一个平稳的爬升和下降运动：当小鸟在屏幕中间时，可以执行一个高跳，但当小鸟靠近顶部/底部边界时，只能做一个轻微的跳跃（这是Flappy
    Bird运动的基本原理）。
- en: 'Let''s run the game to check how the bird has been rendered. However, we haven''t created
    any logic to enable the player yo play the game (we will do this soon). For now,
    let''s run our game and observe what the interface looks like:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行游戏，看看小鸟是如何渲染的。然而，我们还没有创建任何逻辑来让玩家玩游戏（我们很快会做到）。现在，让我们运行游戏，观察界面的样子：
- en: '![](Images/be35d72a-846f-4d44-b17f-72a7b29304f2.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/be35d72a-846f-4d44-b17f-72a7b29304f2.png)'
- en: In the light of the preceding code, you must be able to make a complete `Bird`
    class that has properties for masking, updating, and getting the position, that
    is, the height and width, using `rect`. The bird character in our Flappy Bird
    game is only associated with motion—moving either up or down, vertically. The
    next character in our game is Pipes (obstacles for the bird), which is quite complex
    to deal with. We have to `blit` pipe pairs randomly and continuously. Let's see
    how we can do this.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述代码，你必须能够创建一个完整的`Bird`类，其中包含用于遮罩、更新和获取位置（即高度和宽度）的属性，使用`rect`。我们Flappy Bird游戏中的小鸟角色仅与运动相关——垂直上下移动。我们游戏中的下一个角色是管道（小鸟的障碍物），处理起来相当复杂。我们必须随机连续地`blit`管道对。让我们看看如何做到这一点。
- en: Understanding random object generation
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解随机对象生成
- en: We've already covered the `Bird` character's animation in the previous sections.
    It consists of a list of properties and attributes that deal with the vertical
    motion of the bird. Since the `Bird` class is restricted to performing movements
    for the bird character only, we can't add any other character attributes to it.
    For instance, if you want to add attributes for obstacles (pipes) in the game,
    they can't be added to the `Bird` class. You have to create another class to define
    the next object. This concept is called encapsulation (we learned about this back
    in [Chapter 6](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml), *Object-Oriented Programming*)
    in which code and data are wrapped together within a single unit so that no other
    entity can harm it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面的部分中介绍了`Bird`角色的动画。它包括一系列处理小鸟垂直运动的属性和特性。由于`Bird`类仅限于为小鸟角色执行动作，我们无法向其添加任何其他角色属性。例如，如果你想在游戏中为障碍物（管道）添加属性，不能将其添加到`Bird`类中。你必须创建另一个类来定义下一个对象。这个概念被称为封装（我们在[第6章](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml)中学习过，*面向对象编程*），其中代码和数据被包装在一个单元内，以便其他实体无法伤害它。
- en: 'Let''s make a new class to spawn obstacles for the game. You must start by
    defining a class, along with some constants. I have added comments along with
    the code so that you can understand the primary use of this class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的类来生成游戏的障碍物。你必须首先定义一个类，以及一些常量。我已经在代码中添加了注释，以便你能理解这个类的主要用途：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Before we actually write this `PipePair` class, let me give you some pithy
    information about this class so that you can grasp each of the following concepts.
    We will use different attributes and constants, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际编写这个`PipePair`类之前，让我给你一些关于这个类的简洁信息，以便你能理解以下每个概念。我们将使用不同的属性和常量，如下所示：
- en: '`PipePair` **class**:A pipe pair (a combination of two pipes) is inserted to
    form two pipes, and only a small gap is provided between them so that the Flappy
    Bird can pass through them. Whenever the bird touches or collides with any of
    pipe-pairs, the game will be over.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PipePair`类：一个管道对（两根管道的组合）被插入以形成两根管道，它们之间只提供了一个小间隙，这样小鸟才能穿过它们。每当小鸟触碰或与任何管道对碰撞时，游戏就会结束。'
- en: '**Attributes****:** `x` is the *X*-position for `pipePair`. This value is a
    float to make movement smoother. There is no *Y*-position for `pipePair` as it
    doesn''t change in the *y*-direction; it always remains 0.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性**：`x`是`pipePair`的*X*位置。这个值是一个浮点数，以使移动更加平滑。`pipePair`没有*Y*位置，因为它在*y*方向上不会改变；它始终保持为0。'
- en: '`image`: This is the surface provided by the `pygame` module and is used to
    `blit` the `pipePair`.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`：这是`pygame`模块提供的表面，用于`blit` `pipePair`。'
- en: '`mask`: There is a bitmask that excludes all the pixels in `self.image` with
    a transparency greater than 127\. This can be used for collision detection.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mask`：有一个位掩码，排除了所有`self.image`中透明度大于127的像素。这可以用于碰撞检测。'
- en: '`top_pieces`: A combination of top-pipes along with an end-piece, which is
    the base for the top pieces of the pipe (this is a one-pair consisting of the
    top-pieces of the pipe).'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top_pieces`：顶部管道与末端部分的组合，这是管道顶部部分的基础（这是一个由管道顶部部分组成的一对）。'
- en: '`bottom_pieces`: A combination of down-pipes (tunnel pointing upward) with
    an end-piece, which is the base for the bottom pipes.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottom_pieces`：下管道（向上指向的隧道）与末端部分的组合，这是底部管道的基础。'
- en: '**Constants**:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常量**：'
- en: '`WIDTH`: The width, in pixels, of a pipe piece.  Because a pipe is only one-piece
    wide, this is also the width of a `PipePair` image.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WIDTH`：管道片段的宽度，以像素为单位。因为管道只有一片宽，这也是`PipePair`图像的宽度。'
- en: '`PIECE_HEIGHT`: The height, in pixels, of a pipe piece.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PIECE_HEIGHT`：管道片段的高度，以像素为单位。'
- en: '`ADD_INTERVAL`: The interval, in milliseconds, between adding new pipes.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD_INTERVAL`：添加新管道之间的间隔，以毫秒为单位。'
- en: 'As we already know, the first thing that we need to do for any class is the
    initialization of a class or constructor. This method will initialize the new
    random pipe pair. The following screenshot shows how the pipe pair should be rendered.
    There are two parts of the pipe, that is, the top and the bottom, and a small
    space is inserted between them:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，对于任何类，我们需要做的第一件事就是初始化一个类或构造函数。这个方法将初始化新的随机管道对。以下截图显示了管道对应该如何渲染。管道有两部分，即顶部和底部，它们之间插入了一个小空间：
- en: '![](Images/66b04e30-29e3-4eaf-b559-771accc219a8.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/66b04e30-29e3-4eaf-b559-771accc219a8.png)'
- en: 'Let''s make an initializer for the `PipePair` class that will `blit` the bottom
    and top parts of the pipe, as well as mask it. Let''s learn about the arguments
    that need to be initialized in this constructor:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`PipePair`类创建一个初始化器，它将`blit`管道的底部和顶部部分，并对其进行蒙版处理。让我们了解一下需要在这个构造函数中初始化的参数：
- en: '`end_image_pipe`: Image representing the base of the pipe (end-piece)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end_image_pipe`：代表管道底部（末端部分）的图像'
- en: '`body_image_pipe`:Image representing the vertical piece of the pipe (one-slice
    of pipe)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`body_image_pipe`：代表管道垂直部分（管道的一部分）的图像'
- en: The pipe pair only has an x-attribute and the y-attribute is 0\. Therefore,
    the value of the `x` attribute is assigned as `WIN_WIDTH`, that is, `float(WIN_WIDTH
    - 1)`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 管道对只有一个x属性，y属性为0。因此，`x`属性的值被赋为`WIN_WIDTH`，即`float(WIN_WIDTH - 1)`。
- en: 'The following steps represent the code that needs to be added to the constructor
    to create a random pipe pair in the game''s interface:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤代表了需要添加到构造函数中以在游戏界面中创建一个随机管道对的代码：
- en: 'Let''s initialize a new random pipe pair for `PipePair`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为`PipePair`初始化一个新的随机管道对：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we need to define two types of pipe pair—the bottom pipe and the top
    pipe. The code that adds the pipe pair blits the pipe image and only cares about
    the *y*-position for the pipe pair. No horizontal coordinates are required for
    pipe pairs (they should be rendered vertically):'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义两种类型的管道对——底部管道和顶部管道。添加管道对的代码会将管道图像blit，并且只关心管道对的*y*位置。管道对不需要水平坐标（它们应该垂直渲染）：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Although the comments that were provided alongside the code are helpful when
    it comes to understanding the code, we need to learn about the logic in a more
    pithy way. The `total_pipe_body_piece` variable stores the height for the number
    of pipe pieces that can be added in one frame. For example, it infers the number
    of bottom pipes and top pipes that can be inserted into the current instance.
    We typecast it to the integer since pipe pairs will be always integers. The `bottom_pipe_piece` class
    attribute represents the height of the bottom pipe. It may range anywhere from
    1 to the maximum width supported by `total_pipe_piece`. Similarly, the height
    of the top pipe piece depends on the total pipe piece. For example, if the total
    height of the canvas is 10 and the height of the bottom pipe is 1, then by leaving
    a gap between the two pipe pairs (let's say, 3), the remaining height should be
    that of the top pipe (that is, its height is 10 - (3+1) = 6) which means that,
    except from the gap between the pipe pair, no other gap must be provided.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码旁边提供的注释有助于理解代码，但我们需要以更简洁的方式了解逻辑。`total_pipe_body_piece`变量存储了一帧中可以添加的管道数量的高度。例如，它推断了可以插入当前实例的底部管道和顶部管道的数量。我们将其强制转换为整数，因为管道对始终是整数。`bottom_pipe_piece`类属性表示底部管道的高度。它可以在1到`total_pipe_piece`支持的最大宽度范围内。类似地，顶部管道的高度取决于总管道件数。例如，如果画布的总高度为10，底部管道的高度为1，那么通过在两个管道对之间留下一个间隙（假设为3），剩下的高度应该是顶部管道的高度（即其高度为10
    - (3+1) = 6），这意味着除了管道对之间的间隙外，不应提供其他间隙。
- en: Everything that is written in the preceding code is self-explanatory. Although
    the code is simple, I want you to focus on the last line of code, which we used
    to detect a collision. This process of detection is significant because, in the
    Flappy Bird game, we have to check if the bird is colliding with the pipe pair
    or not. This is usually done by adding a mask using the `pygame.mask` module.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中的所有内容都是不言自明的。尽管代码很简单，但我希望你专注于代码的最后一行，我们用它来检测碰撞。检测的过程很重要，因为在Flappy Bird游戏中，我们必须检查小鸟是否与管道对发生碰撞。通常通过使用`pygame.mask`模块添加蒙版来实现。
- en: 'Now, it''s time to a add few properties to the `PipePair` class. We will add
    four properties: `visible`, `rect`, `height_topPipe_px`, and `height_bottomPipe_px`.
    The `rect` property works similarly to the `Bird` class'' `rect` call—it returns
    the rectangle that contains the `PipePair`. The `visible` property of the class
    checks if the pipe pair is visible in the screen or not. The two other properties
    return the top and bottom pipe''s height in pixels. The following is the code
    for the preceding four properties of the `PipePair` class:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候向`PipePair`类添加一些属性了。我们将添加四个属性：`visible`、`rect`、`height_topPipe_px`和`height_bottomPipe_px`。`rect`属性的工作方式类似于`Bird`类的`rect`调用，它返回包含`PipePair`的矩形。类的`visible`属性检查管道对在屏幕上是否可见。另外两个属性返回以像素为单位的顶部和底部管道的高度。以下是`PipePair`类的前四个属性的代码：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, it''s time to add two more methods to the `PipePair` class before wrapping
    it. The first method, `collides_with`, is going to check whether the bird collides
    with a pipe in the pipe pair or not:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在封装之前，我们需要向`PipePair`类添加另外两个方法。第一个方法`collides_with`将检查小鸟是否与管道对中的管道发生碰撞：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The second method, `update`, will update the pipe pair''s positions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法`update`将更新管道对的位置：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that we know how every method works, let''s see the code in action. You
    won''t understand any flaws in your game until you run it. Take the time to run
    your game and observe the output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道每个方法的工作原理，让我们看看代码的运行情况。在运行游戏之前，你不会了解游戏中的任何缺陷。花时间运行游戏并观察输出：
- en: '![](Images/3876e226-50d8-48e1-9258-9fc566b22a87.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3876e226-50d8-48e1-9258-9fc566b22a87.png)'
- en: Okay, so the game is appealing enough to play. The tapping events are working
    perfectly, and the background image is rendered along with the bird images and
    the physics for climbing and sinking actions. However, one strange thing you might
    have observed (if not, take a look at the preceding screenshot), is that, after
    colliding with the pipe pair, our bird was able to move forward. This is a big
    flaw in our game, and we don't want it. Instead, we want to close the game when
    this happens. Thus, to overcome such an error, we have to use concepts of collision
    (a technique that handles the event when multiple game objects collide with each
    other).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，游戏足够吸引人了。点击事件完美地工作，背景图像与鸟的图像一起呈现，并且上升和下沉动作的物理效果也很好。然而，你可能已经观察到一个奇怪的事情（如果没有，请看前面的截图），即在与管道对碰撞后，我们的小鸟能够继续向前移动。这是我们游戏中的一个大缺陷，我们不希望出现这种情况。相反，我们希望在发生这种情况时关闭游戏。因此，为了克服这样的错误，我们必须使用碰撞的概念（一种处理多个游戏对象相互碰撞的技术）。
- en: 'Now that we have completed the two game character classes, that is, `Bird`
    and `PipePair`, let''s move toward making the physical part of the game: initializing
    the display and handling collisions.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了两个游戏角色类，即`Bird`和`PipePair`，让我们继续制作游戏的物理部分：初始化显示和处理碰撞。
- en: Detecting collision
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测碰撞
- en: The process of *handling collisions* is done by figuring out what actions must
    be performed when two independent objects touch each other. In the preceding section,
    we added a mask for each object to check whether two objects collide or not. The
    `pygame` module makes checking the process of collisions extremely easy; we can
    simply use `sprite.collide_mask` to check if two objects are touching or not.
    However, the argument that this method takes is the masking object. In the previous
    section, we added the `collides_with` method to check if the bird collides with
    one of the pipes in the pipe pairs or not. Now, let's use that method to check
    for collision.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*处理碰撞*的过程是通过找出两个独立对象触碰时必须执行的操作来完成的。在前面的部分中，我们为每个对象添加了一个掩码，以检查两个对象是否发生碰撞。`pygame`模块使得检查碰撞过程非常容易；我们可以简单地使用`sprite.collide_mask`来检查两个对象是否接触。然而，这个方法所需的参数是掩码对象。在前一节中，我们添加了`collides_with`方法来检查鸟是否与管道对中的一个碰撞。现在，让我们使用该方法来检查碰撞。'
- en: 'Along with detecting collisions, we will make a physical layout/template for
    the game. I am not emphasizing the basic pygame layout in this section because
    it should be self-explanatory for you since we have been doing this for a long
    time now. The following steps depict the layout for making a model that detects
    game characters collisions (`Bird` with `pipePairs`):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了检测碰撞，我们还将为游戏制作一个物理布局/模板。我在这一部分没有强调基本的pygame布局，因为自从我们开始做这个以来，这对你来说应该是不言自明的。以下步骤描述了制作一个检测游戏角色碰撞（`Bird`与`pipePairs`）的模型的布局：
- en: 'Start by defining the main function, which will be externally called afterward:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先定义主函数，之后将被外部调用：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s create some logic that will make the bird appear at the center of the
    screen. If you have played the Flappy Bird game, you will know that the bird is
    placed at the center of the canvas and that it can move either vertically upward
    or downward:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一些逻辑，使鸟出现在屏幕的中心。如果你玩过Flappy Bird游戏，你会知道鸟被放在画布的中心，它可以向上或向下移动：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we have to add pipe pair images to the `pipes` variable since a pipe is
    formed by concatenating `pipe-body` with `pipe-end`. This concatenation is done
    inside the `PipePair` class, so that, after creating the instances, we can append
    the pipe pair to the pipes list:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须将管道对图像添加到`pipes`变量中，因为一个管道是由`pipe-body`和`pipe-end`连接而成的。这个连接是在`PipePair`类内部完成的，因此在创建实例后，我们可以将管道对附加到管道列表中：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, handle the user''s actions. Since the Flappy Bird game is a tapped game,
    we will handle mouse events (refer to the *Mouse control* section we covered in
    [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake
    Game UI with Pygame*):'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，处理用户的操作。由于Flappy Bird游戏是一个点击游戏，我们将处理鼠标事件（参考我们在[第11章](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml)中涵盖的*鼠标控制*部分，*使用Pygame制作超越乌龟-贪吃蛇游戏UI*）：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, here''s what you''ve been waiting for: how to build a collision interface
    with the help of Python''s `pygame` module. The highlighted part of the following
    code will be discussed in detail after we''ve completed the rest of these steps:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这就是你一直在等待的：如何利用Python的`pygame`模块构建碰撞接口。在完成这些步骤的其余部分后，我们将详细讨论以下代码的突出部分：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, end the program with some superfluous steps, such as rendering the
    game with an update function, giving an extraneous message to the user, and so
    on:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，以一些多余的步骤结束程序，比如使用更新函数渲染游戏，给用户一个多余的消息等等：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The highlighted parts in the preceding code are important, so ensure that you
    understand them. Here, the `any()` function returns a Boolean by checking whether
    the bird collides with the pipe pair or not. Based on that check, if it is `True`,
    we exit the game. We will also check whether the bird is touching the lowest horizontal
    or upper horizontal boundary or not and exit from the game if it is.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，突出显示的部分很重要，所以确保你理解它们。在这里，`any()`函数通过检查鸟是否与管道对碰撞来返回一个布尔值。根据这个检查，如果是`True`，我们就退出游戏。我们还将检查鸟是否触碰到了水平最低或水平最高的边界，如果是的话也会退出游戏。
- en: 'Let''s run the game and observe the output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行游戏并观察输出：
- en: '![](Images/4296ca36-a86e-479b-9b3b-7178b05417fe.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4296ca36-a86e-479b-9b3b-7178b05417fe.png)'
- en: The game is playable enough, so let's add one more feature to the game that
    tells the player how well they're scoring.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏已经足够可玩了，所以让我们为游戏添加一个告诉玩家他们得分如何的功能。
- en: Scoring and end screen
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 得分和结束屏幕
- en: 'Adding a score to the Flappy Bird game is quite simple. The player''s score
    will be the number of pipes or obstacles a player has passed through. If the player
    passes through 20 pipes—their score will be 20\. Let''s add a score screen to
    the game:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 给Flappy Bird游戏添加分数非常简单。玩家的分数将是玩家通过的管道或障碍物的数量。如果玩家通过了20个管道，他们的分数将是20。让我们给游戏添加一个得分屏幕：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, the game looks more appealing:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，游戏看起来更吸引人了：
- en: '![](Images/70199436-5df8-4e03-acf8-bef436d2120a.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/70199436-5df8-4e03-acf8-bef436d2120a.png)'
- en: In the next section, we'll look at how we can test everything out and even try
    to apply some modifications.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何测试一切，并尝试应用一些修改。
- en: Game testing
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏测试
- en: 'Although there are fewer areas where Flappy Bird can be modified, you can always
    test the game by modifying some game character attributes in order to change the
    difficulty of the game. In the previous section, we ran our game and saw that
    there was a huge space between a pipe pair. This will make the game extremely
    easy for many users to play, and so we need to increase the difficulty by narrowing
    down the space between the two pipe pairs. For instance, inside the `Bird` class,
    we have declared four attributes. Change them to different values to observe the
    effect:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Flappy Bird可以修改的地方较少，但你总是可以通过修改一些游戏角色属性来测试游戏，以改变游戏的难度。在前一节中，我们运行了我们的游戏，并看到管道对之间有很大的空间。这将使游戏对许多用户来说非常容易，所以我们需要通过缩小两个管道对之间的空间来增加难度。例如，在`Bird`类中，我们声明了四个属性。将它们更改为不同的值以观察效果：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can also vary the values of game attributes to give your game a unique look.
    Some of the different game attributes that are used in Flappy Bird are *frames
    per second* and *animation speed*. You can alter these values to implement the
    necessary changes. Although you can change the value of the animation speed, a
    value of 60 for FPS is adequate for the Flappy Bird game.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以改变游戏属性的值，使您的游戏看起来独一无二。Flappy Bird 中使用的一些不同游戏属性包括*每秒帧数*和*动画速度*。您可以改变这些值来实现必要的变化。虽然您可以改变动画速度的值，但对于
    Flappy Bird 游戏来说，每秒帧数为 60 是足够的。
- en: Instead of debugging and searching for possible modifications manually, you
    can simply run your program in debug mode to test it faster. Assuming that you
    have coded the Flappy Bird game in Pycharm's IDE ( I recommend this), you can
    run your program in debug mode by pressing *Shift* + *F9* or simply clicking on
    the Run tab and running it in debug mode from there. After you run it, try to
    play the game and try to make it fit every possible situation that the user might
    encounter. Any errors will be located in the Terminal of the program, from which
    you can jump to a location in the program that has multiple errors.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与手动调试和搜索可能的修改不同，您可以简单地在调试模式下运行程序以更快地测试它。假设您已经在 Pycharm 的 IDE 中编写了 Flappy Bird
    游戏（我推荐这样做），您可以通过按下*Shift* + *F9*或简单地点击运行选项卡并从那里以调试模式运行程序。运行后，尝试玩游戏，并尝试使其适应用户可能遇到的任何情况。任何错误都将出现在程序的终端中，您可以从中跳转到具有多个错误的程序位置。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the concepts of sprite animations and collision
    more deeply. We looked at how to make a simple animation for geometrical shapes
    and create complex sprite animations, and learned which works best in certain
    scenarios. We combined pygame's event handling method with animation logic, which
    renders the images based on the current game state. Essentially, animation logic
    maintains a queue in which user events will be stored. Fetching one action at
    a time renders the image to a position.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更深入地探讨了精灵动画和碰撞的概念。我们看了如何为几何形状制作简单动画，创建复杂的精灵动画，并了解了在某些情况下哪种方法最有效。我们将 pygame
    的事件处理方法与动画逻辑相结合，根据当前的游戏状态渲染图像。基本上，动画逻辑维护一个队列，用户事件将被存储在其中。一次获取一个动作将图像渲染到一个位置。
- en: 'Game prototypes that are made by using pygame have three central blocks: loading
    ant sprites (the original sprites or those downloaded from the internet), handling
    user events, and animation logic, which governs the movement of game characters.
    Sometimes, instead of having independent sprite images, you might have sprite
    sheets—sheets containing images of characters. You can crop them by using online
    tools or even pygame''s `rect` method. After getting the proper images or sprites
    for the game, we handled user events and created animation logic to make the game
    sprites move. We also looked at pygame''s masking properties, which can be used
    to detect collisions between objects.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pygame 制作的游戏原型有三个核心模块：加载精灵（原始精灵或从互联网下载的精灵）、处理用户事件和动画逻辑，控制游戏角色的移动。有时，您可能不是拥有独立的精灵图像，而是精灵表—包含角色图像的表。您可以使用在线工具或甚至
    pygame 的`rect`方法来裁剪它们。在获得游戏的适当图像或精灵后，我们处理了用户事件，并创建了动画逻辑来使游戏精灵移动。我们还研究了 pygame
    的遮罩属性，可以用来检测对象之间的碰撞。
- en: After completing this chapter, you now understand game controllers and animation,
    have learned about the collision principle (including pygame's masking property),
    have learned about sprite animations (creating a running animation of a character),
    and have learned about adding an interactive score screen to make the game more
    user-friendly.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您现在了解了游戏控制器和动画，已经了解了碰撞原理（包括 pygame 的遮罩属性），已经了解了精灵动画（创建角色的奔跑动画），并已经了解了添加交互式记分屏幕以使游戏更加用户友好。
- en: The wide range of areas where you can apply the knowledge you have gained in
    this chapter is *pure* *gold* to most Python pygame developers. Handling sprites
    is important for almost all pygame-based games. Although simple yet powerful concepts,
    character animation, collision, and movements are three primary aspects of Python
    games that make them appealing and interactive. Now, experiment by creating a
    simple **role-playing game** (**RPG**) game such as Junction Jam (if you haven't
    heard of it, Google it) and try to embed the concepts of collision and sprite
    movement in it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本章中获得的知识可以应用的领域范围广泛，对大多数 Python pygame 开发人员来说是*纯金*。处理精灵对于几乎所有基于 pygame 的游戏都很重要。尽管角色动画、碰撞和移动是简单但强大的概念，但它们是使
    Python 游戏具有吸引力和互动性的三个主要方面。现在，尝试创建一个简单的**角色扮演游戏**（**RPG**）游戏，比如 Junction Jam（如果您还没有听说过，可以搜索一下），并尝试在其中嵌入碰撞和精灵移动的概念。
- en: In the next chapter, we are going to learn about pygame's primitive graphics
    programming by creating game grids and shapes. We will learn about multi-dimensional
    list processing and valid space determination by coding a Tetris game.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过创建游戏网格和形状来学习 pygame 的基本图形编程。我们将通过编写俄罗斯方块游戏来学习多维列表处理和有效空间确定。
