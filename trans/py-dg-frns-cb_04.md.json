["```py\npip install mutagen==1.38\n```", "```py\nfrom __future__ import print_function\nimport argparse\nimport json\nimport mutagen\n```", "```py\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(\n        description=__description__,\n        epilog=\"Developed by {} on {}\".format(\n            \", \".join(__authors__), __date__)\n    )\n    parser.add_argument(\"AV_FILE\", help=\"File to extract metadata from\")\n    args = parser.parse_args()\n    av_file = mutagen.File(args.AV_FILE)\n\n    file_ext = args.AV_FILE.rsplit('.', 1)[-1]\n    if file_ext.lower() == 'mp3':\n        handle_id3(av_file)\n    elif file_ext.lower() == 'mp4':\n        handle_mp4(av_file)\n```", "```py\ndef handle_id3(id3_file):\n    # Definitions from http://id3.org/id3v2.4.0-frames\n    id3_frames = {\n        'TIT2': 'Title', 'TPE1': 'Artist', 'TALB': 'Album',\n        'TXXX': 'Custom', 'TCON': 'Content Type', 'TDRL': 'Date released',\n        'COMM': 'Comments', 'TDRC': 'Recording Date'}\n    print(\"{:15} | {:15} | {:38} | {}\".format(\"Frame\", \"Description\",\n                                              \"Text\", \"Value\"))\n    print(\"-\" * 85)\n```", "```py\n    for frames in id3_file.tags.values():\n        frame_name = id3_frames.get(frames.FrameID, frames.FrameID)\n        desc = getattr(frames, 'desc', \"N/A\")\n        text = getattr(frames, 'text', [\"N/A\"])[0]\n        value = getattr(frames, 'value', \"N/A\")\n        if \"date\" in frame_name.lower():\n            text = str(text)\n\n        print(\"{:15} | {:15} | {:38} | {}\".format(\n            frame_name, desc, text, value))\n```", "```py\ndef handle_mp4(mp4_file):\n    cp_sym = u\"\\u00A9\"\n    qt_tag = {\n        cp_sym + 'nam': 'Title', cp_sym + 'art': 'Artist',\n        cp_sym + 'alb': 'Album', cp_sym + 'gen': 'Genre',\n        'cpil': 'Compilation', cp_sym + 'day': 'Creation Date',\n        'cnID': 'Apple Store Content ID', 'atID': 'Album Title ID',\n        'plID': 'Playlist ID', 'geID': 'Genre ID', 'pcst': 'Podcast',\n        'purl': 'Podcast URL', 'egid': 'Episode Global ID',\n        'cmID': 'Camera ID', 'sfID': 'Apple Store Country',\n        'desc': 'Description', 'ldes': 'Long Description'}\n    genre_ids = json.load(open('apple_genres.json'))\n```", "```py\n    print(\"{:22} | {}\".format('Name', 'Value'))\n    print(\"-\" * 40)\n    for name, value in mp4_file.tags.items():\n        tag_name = qt_tag.get(name, name)\n        if isinstance(value, list):\n            value = \"; \".join([str(x) for x in value])\n        if name == 'geID':\n            value = \"{}: {}\".format(\n                value, genre_ids[str(value)].replace(\"|\", \" - \"))\n        print(\"{:22} | {}\".format(tag_name, value))\n```", "```py\npip install pillow==4.2.1\n```", "```py\npip install simplekml==1.3.0\n```", "```py\nfrom __future__ import print_function\nimport argparse\nfrom PIL import Image\nfrom PIL.ExifTags import TAGS\nimport simplekml\nimport sys\n```", "```py\nparser = argparse.ArgumentParser(\n    description=__description__,\n    epilog=\"Developed by {} on {}\".format(\", \".join(__authors__), __date__)\n)\nparser.add_argument('PICTURE_FILE', help=\"Path to picture\")\nargs = parser.parse_args()\n```", "```py\ngmaps = \"https://www.google.com/maps?q={},{}\"\nopen_maps = \"http://www.openstreetmap.org/?mlat={}&mlon={}\"\n\ndef process_coords(coord):\n    coord_deg = 0\n    for count, values in enumerate(coord):\n        coord_deg += (float(values[0]) / values[1]) / 60**count\n    return coord_deg\n```", "```py\nimg_file = Image.open(args.PICTURE_FILE)\nexif_data = img_file._getexif()\n\nif exif_data is None:\n    print(\"No EXIF data found\")\n    sys.exit()\n\nfor name, value in exif_data.items():\n    gps_tag = TAGS.get(name, name)\n    if gps_tag is not 'GPSInfo':\n        continue\n```", "```py\n    lat_ref = value[1] == u'N'\n    lat = process_coords(value[2])\n    if not lat_ref:\n        lat = lat * -1\n\n    lon_ref = value[3] == u'E'\n    lon = process_coords(value[4])\n    if not lon_ref:\n        lon = lon * -1\n```", "```py\n    kml = simplekml.Kml()\n    kml.newpoint(name=args.PICTURE_FILE, coords=[(lon, lat)])\n    kml.save(args.PICTURE_FILE + \".kml\")\n```", "```py\n    print(\"GPS Coordinates: {}, {}\".format(lat, lon))\n    print(\"Google Maps URL: {}\".format(gmaps.format(lat, lon)))\n    print(\"OpenStreetMap URL: {}\".format(open_maps.format(lat, lon)))\n    print(\"KML File {} created\".format(args.PICTURE_FILE + \".kml\"))\n```", "```py\npip install PyPDF2==1.26.0\n```", "```py\nfrom __future__ import print_function\nfrom argparse import ArgumentParser, FileType\nimport datetime\nfrom PyPDF2 import PdfFileReader\nimport sys\n```", "```py\nparser = ArgumentParser(\n    description=__description__,\n    epilog=\"Developed by {} on {}\".format(\", \".join(__authors__), __date__)\n)\nparser.add_argument('PDF_FILE', help='Path to PDF file',\n                    type=FileType('rb'))\nargs = parser.parse_args()\n```", "```py\npdf_file = PdfFileReader(args.PDF_FILE)\n\nxmpm = pdf_file.getXmpMetadata()\nif xmpm is None:\n    print(\"No XMP metadata found in document.\")\n    sys.exit()\n```", "```py\ncustom_print(\"Title: {}\", xmpm.dc_title)\ncustom_print(\"Creator(s): {}\", xmpm.dc_creator)\ncustom_print(\"Contributors: {}\", xmpm.dc_contributor)\ncustom_print(\"Subject: {}\", xmpm.dc_subject)\ncustom_print(\"Description: {}\", xmpm.dc_description)\ncustom_print(\"Created: {}\", xmpm.xmp_createDate)\ncustom_print(\"Modified: {}\", xmpm.xmp_modifyDate)\ncustom_print(\"Event Dates: {}\", xmpm.dc_date)\n```", "```py\ndef custom_print(fmt_str, value):\n    if isinstance(value, list):\n        print(fmt_str.format(\", \".join(value)))\n    elif isinstance(value, dict):\n        fmt_value = [\":\".join((k, v)) for k, v in value.items()]\n        print(fmt_str.format(\", \".join(value)))\n    elif isinstance(value, str) or isinstance(value, bool):\n        print(fmt_str.format(value))\n    elif isinstance(value, bytes):\n        print(fmt_str.format(value.decode()))\n    elif isinstance(value, datetime.datetime):\n        print(fmt_str.format(value.isoformat()))\n    elif value is None:\n        print(fmt_str.format(\"N/A\"))\n    else:\n        print(\"warn: unhandled type {} found\".format(type(value)))\n```", "```py\ncustom_print(\"Created With: {}\", xmpm.xmp_creatorTool)\ncustom_print(\"Document ID: {}\", xmpm.xmpmm_documentId)\ncustom_print(\"Instance ID: {}\", xmpm.xmpmm_instanceId)\n```", "```py\ncustom_print(\"Language: {}\", xmpm.dc_language)\ncustom_print(\"Publisher: {}\", xmpm.dc_publisher)\ncustom_print(\"Resource Type: {}\", xmpm.dc_format)\ncustom_print(\"Type: {}\", xmpm.dc_type)\n```", "```py\nif xmpm.custom_properties:\n    print(\"Custom Properties:\")\n    for k, v in xmpm.custom_properties.items():\n        print(\"\\t{}: {}\".format(k, v))\n```", "```py\npip install pefile==2017.8.1\n```", "```py\nfrom __future__ import print_function\nimport argparse\nfrom datetime import datetime\nfrom pefile import PE\n```", "```py\nparser = argparse.ArgumentParser(\n    description=__description__,\n    epilog=\"Developed by {} on {}\".format(\n        \", \".join(__authors__), __date__)\n)\nparser.add_argument(\"EXE_FILE\", help=\"Path to exe file\")\nparser.add_argument(\"-v\", \"--verbose\", help=\"Increase verbosity of output\",\n                    action='store_true', default=False)\nargs = parser.parse_args()\n```", "```py\npe = PE(args.EXE_FILE)\nped = pe.dump_dict()\n```", "```py\nfile_info = {}\nfor structure in pe.FileInfo:\n    if structure.Key == b'StringFileInfo':\n        for s_table in structure.StringTable:\n            for key, value in s_table.entries.items():\n                if value is None or len(value) == 0:\n                    value = \"Unknown\"\n                file_info[key] = value\nprint(\"File Information: \")\nprint(\"==================\")\nfor k, v in file_info.items():\n    if isinstance(k, bytes):\n        k = k.decode()\n    if isinstance(v, bytes):\n        v = v.decode()\n    print(\"{}: {}\".format(k, v))\n```", "```py\n# Compile time \ncomp_time = ped['FILE_HEADER']['TimeDateStamp']['Value']\ncomp_time = comp_time.split(\"[\")[-1].strip(\"]\")\ntime_stamp, timezone = comp_time.rsplit(\" \", 1)\ncomp_time = datetime.strptime(time_stamp, \"%a %b %d %H:%M:%S %Y\")\nprint(\"Compiled on {} {}\".format(comp_time, timezone.strip()))\n```", "```py\n# Extract IOCs from PE Sections \nprint(\"\\nSections: \")\nprint(\"==========\")\nfor section in ped['PE Sections']:\n    print(\"Section '{}' at {}: {}/{} {}\".format(\n        section['Name']['Value'], hex(section['VirtualAddress']['Value']),\n        section['Misc_VirtualSize']['Value'],\n        section['SizeOfRawData']['Value'], section['MD5'])\n    )\n```", "```py\nif hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):\n    print(\"\\nImports: \")\n    print(\"=========\")\n    for dir_entry in pe.DIRECTORY_ENTRY_IMPORT:\n        dll = dir_entry.dll\n        if not args.verbose:\n            print(dll.decode(), end=\", \")\n            continue\n\n        name_list = []\n        for impts in dir_entry.imports:\n            if getattr(impts, \"name\", b\"Unknown\") is None:\n                name = b\"Unknown\"\n            else:\n                name = getattr(impts, \"name\", b\"Unknown\")\n            name_list.append([name.decode(), hex(impts.address)])\n        name_fmt = [\"{} ({})\".format(x[0], x[1]) for x in name_list]\n        print('- {}: {}'.format(dll.decode(), \", \".join(name_fmt)))\n    if not args.verbose:\n        print()\n```", "```py\n# Display Exports, Names, and Addresses \nif hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):\n    print(\"\\nExports: \")\n    print(\"=========\")\n    for sym in pe.DIRECTORY_ENTRY_EXPORT.symbols:\n        print('- {}: {}'.format(sym.name.decode(), hex(sym.address)))\n```", "```py\nfrom __future__ import print_function\nfrom argparse import ArgumentParser\nfrom datetime import datetime as dt\nfrom xml.etree import ElementTree as etree\nimport zipfile\n```", "```py\nparser = argparse.ArgumentParser(\n    description=__description__,\n    epilog=\"Developed by {} on {}\".format(\", \".join(__authors__), __date__)\n)\nparser.add_argument(\"Office_File\", help=\"Path to office file to read\")\nargs = parser.parse_args()\n```", "```py\n# Check if input file is a zipfile\nzipfile.is_zipfile(args.Office_File)\n\n# Open the file (MS Office 2007 or later)\nzfile = zipfile.ZipFile(args.Office_File)\n\n# Extract key elements for processing\ncore_xml = etree.fromstring(zfile.read('docProps/core.xml'))\napp_xml = etree.fromstring(zfile.read('docProps/app.xml'))\n```", "```py\n# Core.xml tag mapping \ncore_mapping = {\n    'title': 'Title',\n    'subject': 'Subject',\n    'creator': 'Author(s)',\n    'keywords': 'Keywords',\n    'description': 'Description',\n    'lastModifiedBy': 'Last Modified By',\n    'modified': 'Modified Date',\n    'created': 'Created Date',\n    'category': 'Category',\n    'contentStatus': 'Status',\n    'revision': 'Revision'\n}\n```", "```py\nfor element in core_xml.getchildren():\n    for key, title in core_mapping.items():\n        if key in element.tag:\n            if 'date' in title.lower():\n                text = dt.strptime(element.text, \"%Y-%m-%dT%H:%M:%SZ\")\n            else:\n                text = element.text\n            print(\"{}: {}\".format(title, text))\n```", "```py\napp_mapping = {\n    'TotalTime': 'Edit Time (minutes)',\n    'Pages': 'Page Count',\n    'Words': 'Word Count',\n    'Characters': 'Character Count',\n    'Lines': 'Line Count',\n    'Paragraphs': 'Paragraph Count',\n    'Company': 'Company',\n    'HyperlinkBase': 'Hyperlink Base',\n    'Slides': 'Slide count',\n    'Notes': 'Note Count',\n    'HiddenSlides': 'Hidden Slide Count',\n}\nfor element in app_xml.getchildren():\n    for key, title in app_mapping.items():\n        if key in element.tag:\n            if 'date' in title.lower():\n                text = dt.strptime(element.text, \"%Y-%m-%dT%H:%M:%SZ\")\n            else:\n                text = element.text\n            print(\"{}: {}\".format(title, text))\n```"]