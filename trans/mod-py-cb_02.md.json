["```py\n **>>> print(\"hello world\")** \n\n **hello world** \n\n```", "```py\n **quotient, remainder = divmod(355, 113)** \n\n```", "```py\n                #!/usr/bin/env python3 \n\n    ```", "```py\n            ''' \n            A summary of this script. \n            ''' \n\n    ```", "```py\n            print('hello world') \n\n    ```", "```py\n    #!/usr/bin/env python3 \n    ''' \n    My First Script: Calculate an important value. \n    ''' \n\n    print(355/113) \n\n```", "```py\n    \u03c0=355/113 \n    print(\u03c0) \n\n```", "```py\n    color = 355/113 # type: float \n\n```", "```py\n    # vim: tabstop=8 expandtab shiftwidth=4 softtabstop=4 \n\n```", "```py\n **>>> import math** \n\n **>>> example_value = (63/25) * (17+15*math.sqrt(5)) / (7+15*math.sqrt(5))** \n\n **>>> mantissa_fraction, exponent = math.frexp(example_value)** \n\n **>>> mantissa_whole = int(mantissa_fraction*2**53)** \n\n **>>> message_text = 'the internal representation is {mantissa:d}/2**53*2**{exponent:d}'.format(mantissa=mantissa_whole, exponent=exponent)** \n\n **>>> print(message_text)** \n\n **the internal representation is 7074237752514592/2**53*2**2** \n\n```", "```py\n **>>> import math** \n\n **>>> example_value = (63/25) * (17+15*math.sqrt(5)) / (7+15*math.sqrt(5))** \n\n **>>> mantissa_fraction, exponent = math.frexp(example_value)** \n\n **>>> mantissa_whole = int(mantissa_fraction*2**53)** \n\n```", "```py\n     **>>> message_text = 'the internal representation is {mantissa:d}/2**53*2**{exponent:d}'.format(mantissa=mantissa_whole, exponent=exponent)** \n\n    ```", "```py\n     **>>> message_text = 'the internal representation is \\** \n\n     **... {mantissa:d}/2**53*2**{exponent:d}'.\\** \n\n     **... format(mantissa=mantissa_whole, exponent=exponent)** \n\n     **>>> message_text** \n\n     **'the internal representation is 7074237752514592/2**53*2**2'** \n\n    ```", "```py\n     **>>> import math** \n\n     **>>> example_value1 = (63/25) * (17+15*math.sqrt(5)) / (7+15*math.sqrt(5))** \n\n    ```", "```py\n     **>>> example_value2 = (63/25) * ( (17+15*math.sqrt(5)) / (7+15*math.sqrt(5)) )** \n\n     **>>> example_value2 == example_value1** \n\n     **True** \n\n    ```", "```py\n     **>>> example_value3 = (63/25) * (** \n\n     **...      (17+15*math.sqrt(5))** \n\n     **...    / ( 7+15*math.sqrt(5))** \n\n     **... )** \n\n     **>>> example_value3 == example_value1** \n\n     **True** \n\n    ```", "```py\n     **>>> message_text = (** \n\n     **... 'the internal representation '** \n\n     **... 'is {mantissa:d}/2**53*2**{exponent:d}'** \n\n     **... ).format(** \n\n     **... mantissa=mantissa_whole, exponent=exponent)** \n\n     **>>> message_text** \n\n     **'the internal representation is 7074237752514592/2**53*2**2'** \n\n    ```", "```py\n **>>> import math** \n\n **>>> example_value = (63/25) * (17+15*math.sqrt(5)) / (7+15*math.sqrt(5))** \n\n```", "```py\n     **>>> a = (63/25)** \n\n     **>>> b = (17+15*math.sqrt(5))** \n\n     **>>> c = (7+15*math.sqrt(5))** \n\n    ```", "```py\n     **>>> example_value = a * b / c** \n\n    ```", "```py\n **>>> print(** \n\n **...    'several values including',** \n\n **...    'mantissa =', mantissa,** \n\n **...    'exponent =', exponent** \n\n **... )** \n\n```", "```py\n **>>> from math import (sin, cos, tan,** \n\n **...    sqrt, log, frexp)** \n\n```", "```py\n    ''' \n    Downloads and decodes the current Special Marine Warning (SMW) \n    for the area 'AKQ'. \n    ''' \n\n```", "```py\n    ''' \n    Downloads and decodes the current Special Marine Warning (SMW) \n    for the area 'AKQ' \n\n    SYNOPSIS \n    ======== \n\n    :: \n\n        python3 akq_weather.py \n\n    DESCRIPTION \n    =========== \n\n    Downloads the Special Marine Warnings \n\n    Files \n    ===== \n\n    Writes a file, ``AKW.html``. \n\n    EXAMPLES \n    ======== \n\n    Here's an example:: \n\n        slott$ python3 akq_weather.py \n        <h3>There are no products active at this time.</h3> \n    ''' \n\n```", "```py\n            Here's an example:: \n\n                more_code()  \n\n    ```", "```py\n            Topic \n            ===== \n\n    ```", "```py\n    ==== \n    ----- \n    ^^^^^^ \n    ^^^^^^ \n    ----- \n    ^^^^^^ \n    ~~~~~~~~ \n    ^^^^^^ \n\n```", "```py\n            ..  important:: \n\n                Do not flip the bozo bit. \n\n    ```", "```py\n    ..  note:: Note Title \n\n        We need to indent the content of an admonition. \n        This will set the text off from other material. \n\n```", "```py\n    ..  parsed-literal:: \n\n        any text \n            *almost* any format \n        the text is preserved \n            but **inline** markup can be used. \n\n```", "```py ). Links are followed by a `_` . We might use ``section title`_` to refer to a specific section within a document. We don't generally need to put anything around URL's. The Docutils tools recognize these. Sometimes we want a word or phrase to be shown and the URL concealed. We can use this: ``the Sphinx documentation <http://www.sphinx-doc.org/en/stable/>`_` .\n*   We can surround code-related words with double back-tick (```", "```pycode```", "```py back-ticks. A text role looks like this `:strong:`this`` .\n\nThere are a number of standard role names including `:emphasis:` , `:literal:` , `:code:` , `:math:` , `:pep-reference:` , `:rfc-reference:` , `:strong:` , `:subscript:` , `:superscript:` , and `:title-reference:` . Some of these are also available with simpler markup like `*emphasis*` or `**strong**` . The rest are only available as explicit roles.\n\nAlso, we can define new roles with a simple directive. If we want to do very sophisticated processing, we can provide docutils with class definitions for handling roles, allowing us to tweak the way our document is processed. Sphinx adds a large number of roles to support detailed cross references among functions, methods, exceptions, classes, and modules.\n\n## See also\n\n*   For more information on RST syntax, see [http://docutils.sourceforge.net](http://docutils.sourceforge.net) . This includes a description of the docutils tools.\n*   For information on **Sphinx Python Documentation Generator** , see [http://www.sphinx-doc.org/en/stable/](http://www.sphinx-doc.org/en/stable/) .\n*   The Sphinx tool adds many additional directives and text roles to the basic definitions.\n\n# Designing complex if...elif chains\n\nIn most cases, our scripts will involve a number of choices. Sometimes the choices are simple, and we can judge the quality of the design with a glance at the code. In other cases, the choices are more complex, and it's not easy to determine whether or not our if statements are designed properly to handle all of the conditions.\n\nIn the simplest case, we have one condition, *C* , and its inverse, *C* . These are the two conditions for an `if...else` statement. One condition, \u00ac *C* , is stated in the `if` clause, the other is implied in the `else` .\n\nWe'll use *p* \u2228 *q* to mean Python's **OR** operator in this explanation. We can call these two conditions *complete* because:\n\n*C* \u2228 *C =* \u00ac ***T***\n\nWe call this complete because no other conditions can exist. There's no third choice. This is the **Law of the Excluded Middle** . It's also the operating principle behind the `else` clause. The `if` statement body is executed or the `else` statement is executed. There's no third choice.\n\nIn practical programming, we often have complex choices. We may have a set of conditions, *C* = { *C[1] , C[2] , C[3] , ..., C[n]* }.\n\nWe don't want to simply assume that:\n\n*C[1]* \u2228 *C[2]* \u2228 *C[3]* \u2228 *...* \u2228 *C[n] = **T***\n\nWe can use\u00a0![Designing complex if...elif chains](Image00003.jpg)  to have a meaning similar to `any(C)` , or perhaps `any([C_1, C_2, C_3, ..., C_n])` . We need to prove that ![Designing complex if...elif chains](Image00004.jpg)  ; we can't assume this is `true` .\n\nHere's what might go wrong\u2014we might miss some condition, *C[n+1]* , that got lost in the tangle of logic. Missing this will mean that our program will fail to work properly for this case.\n\nHow can we be sure we haven't missed something?\n\n## Getting ready\n\nLet's look at a concrete example of an `if...elif` chain. In the casino game of *Craps* , there are a number of rules that apply to a roll of two dice. These rules apply on the first roll of the game, called the *come out* roll:\n\n*   2, 3, or 12, is *Craps* , which is a loss for all bets placed on the pass line\n*   7 or 11 is a winner for all bets placed on the pass line\n*   The remaining numbers establish a *point*\n\nMany players place their bets on the pass line. There's also a *don't pass* line, which is less commonly used. We'll use this set of three conditions as an example for looking at this recipe because it has a potentially vague clause in it.\n\n## How to do it...\n\nWhen we write an `if` statement, even when it appears trivial, we need to be sure that all conditions are covered.\n\n1.  Enumerate the alternatives we know. In our example, we have three rules: (2, 3, 12), (7, 11), and the vague remaining numbers.\n2.  Determine the universe of all possible conditions. For this example, there are 10 conditions: the numbers from 2 to 12.\n3.  Compare the known alternatives with the universe. There are three possible outcomes of this comparison between the set of conditions, *C* , and the universe of all possible conditions, *U* :\n\nThe known alternatives have more conditions than the universe; *C* \u2283 *U* . This is a huge design problem. This requires rethinking the design from the foundations.\n\nThere's a gap between the known conditions and the universe of possible conditions; U \\ C \u2260 \u2205. In some cases, it's clear that we haven't covered all of the possible conditions. In other cases, it takes some careful reasoning. We'll need to replace any vague or poorly defined terms with something much more precise.\n\nIn this example, we have a vague term, which we can replace with something more specific. The term **remaining numbers** appears to be the list of values (4, 5, 6, 8, 9, 10). Supplying this list removes any possible gaps and doubts.\n\nThe known alternatives match the universe of possible alternatives; *U* \u2261 *C* . There are two common cases:\n\n*   We have something as simple as *C* \u2228 \u00ac *C* . We can use a single `if` and `else` clause\u2014we do not need to use this recipe because we can easily deduce \u00ac *C* .\n*   We might have something more complex. Since we know the entire universe, we can show that ![How to do it...](Image00004.jpg)  . We need to use this recipe to write a chain of `if` and `elif` statements, one clause per condition.\n\nThe distinction is not always crisp. In our example, we don't have a detailed specification for one of the conditions, but the condition is *mostly* clear. If we think the missing condition is obvious, we can use an `else` clause instead of writing it out explicitly. If we think the missing condition might be misunderstood, we should treat it as vague and use this recipe.\n\n1.  Write the `if...elif...elif` chain that covers all of the known conditions. For our example, it will look like this:\n\n    ```", "```py\n\n2.  Add an `else` clause that raises an exception, like this:\n\n    ```", "```py\n\nThis extra `else` crash condition gives us a way to positively identify when a logic problem is found. We can be sure that any error we make will lead to a conspicuous problem.\n\n## How it works...\n\nOur goal is to be sure that our program always works. While testing helps, we can still have wrong assumptions in both design and test cases.\n\nWhile rigorous logic is essential, we can still make errors. Further, someone else could try to tweak our code and introduce an error. More embarrassingly, we could make a change in our own code that leads to breakage.\n\nThe `else` crash option forces us to be explicit for each and every condition. Nothing is assumed. As we noted previously, any error in our logic will be uncovered when an exception gets raised.\n\nThe `else` crash option doesn't have a significant performance impact. A simple `else` clause is slightly faster than an `elif` clause with a condition. If we think that our application performance depends in any way on the cost of a single expression, we've got more serious design problems to solve. The cost of evaluating a single expression is rarely the costliest part of an algorithm.\n\nCrashing with an exception is a sensible behavior in the presence of a design problem. It doesn't make much sense to follow the design pattern of writing a warning message to a log. If we have this kind of logic gap, the program is fatally broken and it's important to find and fix this as soon as it's known.\n\n## There's more...\n\nIn many cases, we can derive an `if...elif...elif` chain from an examination of the desired post-condition at some point in the program's processing. For example, we may need a statement that establishes something simple like *m* the larger of *a* or *b* .\n\n(For the sake of working through the logic, we'll avoid `m = max(a, b)` .)\n\nWe can formalize the final condition like this:\n\n*(m = a* \u2228 *m = b)* \u2227 *m > a\u00a0* \u2227 *m > b*\n\nWe can work backwards from this final condition, by writing the goal as an assert statement:\n\n```", "```py\n\nOnce we have the goal stated, we can identify statements that lead to that goal. Clearly assignment statements like `m = a` and `m = b` will be appropriate, but only under certain conditions.\n\nEach of these statements is part of the solution, and we can derive a precondition that shows when the statement should be used. The preconditions for each assignment statement are the `if` and `elif` expressions. We need to use `m = a` when `a >= b` ; we need to use `m=b` when `b >= a` . Rearranging logic into code gives us this:\n\n```", "```py\n\nNote that our universe of conditions, \u00a0 *U* = { *a \u2265 b, b \u2265 a* }, is complete; there's no other possible relationship. Also notice that in the edge case of *a = b* , we don't actually care which assignment statement we use. Python will process the decisions in order, and will execute `m = a` . The fact that this choice is consistent shouldn't have any impact on our design of `if...elif...elif` chains. We should always write the conditions without regard to order of evaluation of the clauses.\n\n## See also\n\n*   This is similar to the syntactic problem of a **dangling else** . See [https://en.wikipedia.org/wiki/Dangling_else](https://en.wikipedia.org/wiki/Dangling_else) .\n*   Python's indentation removes the dangling else syntax problem. It doesn't remove the semantic issue of trying to be sure that all conditions are properly accounted for in a complex `if...elif...elif` chain.\n*   Also, see [https://en.wikipedia.org/wiki/Predicate_transformer_semantics](https://en.wikipedia.org/wiki/Predicate_transformer_semantics) .\n\n# Designing a while statement which terminates properly\n\nMuch of the time, the Python `for` statement provides all of the iteration controls we need. In many cases, we can use built-in functions like `map()` , `filter()` , and `reduce()` to process collections of data.\n\nThere are a few situations, however, where we need to use a `while` statement. Some of those situations involve data structures where we can't create a proper iterator to step through the items. Other items involve interactions with human users, where we don't have the data until we get input from the person.\n\n## Getting ready\n\nLet's say that we're going to be prompting a user for their password. We'll use the `getpass` module so that there's no echo.\n\nFurther, to be sure they've entered it properly, we'll want to prompt them twice and compare the results. This is a situation where a simple `for` statement isn't going to work out well. It can be pressed into service, but the resulting code looks strange: `for` statements have an explicit upper bound; prompting a user for input doesn't really have an upper bound.\n\n## How to do it...\n\nWe'll look at a six-step process that outlines the core of designing this kind of iterative algorithm. This is the kind of thing we need to do when a simple `for` statement doesn't solve our problem.\n\n1.  Define done. In our case, we'll have two copies of the password, `password_text` and `confirming_password_text` . The condition which must be `true` after the loop is that `password_text == confirming_password_text` . Ideally, reading from people (or files) is a bounded activity. Eventually, people will enter the matching pair of values. Until they enter the matching pair, we'll iterate indefinitely.\n\n    There are other boundary conditions. For example, end of file. Or we allow the person to go back to a previous prompt. Generally, we handle these other conditions with exceptions in Python.\n\n    Of course, we can always add these additional conditions to our definition of done. We may need to have a complex terminating condition like end of file OR `password_text == confirming_password_text` .\n\n    In this example, we'll opt for exception handling and assume that a `try:` block will be used. It greatly simplifies the design to have only a single clause in the terminating condition.\n\n    We can rough out the loop like this:\n\n    ```", "```py\n\n    We've written our definition of done as a final `assert` statement. We've included comments for the rest of the iteration that we'll fill in in subsequent steps.\n\n2.  Define a condition that's `true` while the loop is iterating. This is called an **invariant** because it's always `true` at the start and end of loop processing. It's often created by generalizing the post-condition or introducing another variable.\n\n    When reading from people (or files) we have an implied state change that is an important part of the invariant. We can call this the *get the next input* change in state. We often have to articulate clearly that our loop will be acquiring some next value from an input stream.\n\n    We have to be sure that our loop properly gets the next item in spite of any complex logic in the body of the `while` statement. It's a common bug to have a condition where a next input is not actually fetched. This leads to programs which *hang* \u2014there's no state change in one logic path through the `if` statements in the body of the `while` statement. The invariant wasn't reset properly, or it wasn't articulated properly when designing the loop.\n\n    In our case, the invariant will use a conceptual `new-input()` condition. This condition is `true` when we've read a new value using the `getpass()` function. Here's our expanded loop design:\n\n    ```", "```py\n\n3.  Define the condition for leaving the loop. We need to be sure that this condition depends on the invariant being `true` . We also need to be sure that, when this termination condition is finally `false,` the target state will become `true` .\n\n    In most cases, the loop condition is the logical negation of the target state. Here's the expanded design:\n\n    ```", "```py\n\n4.  Define the initialization that will make sure that both the invariant will be `true` and that we can actually test the terminating condition. In this case, we need to get values for the two variables. The loop now looks like this:\n\n    ```", "```py\n\n5.  Write the body of the loop which will reset the invariant to `true` . We need to write the fewest statements that will do this. For this example loop, the fewest statements are pretty obvious\u2014they match the initialization. Our updated loop looks like this:\n\n    ```", "```py\n\n6.  Identify a clock\u2014a monotonically decreasing function that shows that each iteration of the loop really does make progress toward the terminating condition.\n\n    When gathering input from people, we're forced to make an assumption that\u2014eventually\u2014they'll enter a matching pair. Each trip through the loop brings us one step closer to that matching pair. To be properly formal, we can assume that there will be *n* inputs before they match; we have to show that each trip through the loop decreases the number which remain.\n\n    In complex situations, we may need to treat the user's input as a list of values. For our example, we'd think of the user input as a sequence of pairs: *[(p[1] , q[1] ),(p[2] , q[2] ),(p[3] , q[3] ),...,(p[n] , q[n] )]* . With a finite list, we can more easily reason about whether or not our loop really is making progress towards completion.\n\nBecause we built the loop based on the target `final` condition, we can be absolutely sure that it does what we want it to do. If our logic is sound, the loop will terminate, and will terminate with the expected results. This is the goal of all programming\u2014to have the machine reach a desired state given some initial state.\n\nRemoving some comments, we have this as our final loop:\n\n```", "```py\n\nWe left the final post-condition in place as an `assert` statement. For complex loops it's both a built-in test, as well as a comment that explains how the loop works.\n\nThis design process often produces a loop that looks similar to one we might develop based on intuition. There's nothing wrong with having a step by step justification for an intuitive design. Once we've done this a few times, we can be much more confident in using a loop knowing that we can justify the design.\n\nIn this case, the loop body and the initialization happen to be the same code. If this is a problem, we can define a tiny two-line function to avoid repeating the code. We'll look at this in [Chapter 3](text00039.html#page \"Chapter\u00a03.\u00a0Function Definitions\") , *Function Definitions* .\n\n## How it works...\n\nWe start out by articulating the goal for the loop. Everything else that we do will assure that the code written leads to that goal condition. Indeed, this is the motivation behind all software design\u2014we're always trying to write the fewest statements that lead to a given goal state. We're often working *backwards* from goal to initialization. Each step in the chain of reasoning is essentially stating the weakest precondition for some statement, `S` , that leads to our desired outcome condition.\n\nGiven a post-condition, we're trying to solve for a statement and a precondition. We're always building this pattern:\n\n```", "```py\n\nThe post-condition is our definition of done. We need to hypothesize a statement, `S` , that leads to done, and a precondition for that statement. There are always an infinite number of alternative statements; we focus on the weakest precondition\u2014the one that has the fewest assumptions.\n\nAt some point\u2014usually when writing the initialization statements\u2014we find that the pre-condition is merely `true` : any initial state will do as the precondition for a statement. That's how we know that our program can start from any initial state and complete as expected. This is ideal.\n\nWhen designing a `while` statement, we have a nested context inside the statement's body. The body should always be in a process of resetting the invariant condition to be `true` again. In our example, this means reading more input from the user. In other examples, we might be processing another character in a string, or another number from a set of numbers.\n\nWe need to prove that when the invariant is `true` and the loop condition is `false` then our final goal is achieved. This proof is easier when we start from the final goal and create the invariant and the loop condition based on that final goal.\n\nWhat's important is patiently doing each step so that our reasoning is solid. We need to be able to prove that the loop will work. Then we can run unit tests with confidence.\n\n## See also\n\n*   We look at some other aspects of advanced loop design in the *Avoiding a potential problem with break statements* recipe.\n*   We also looked at this concept in the *Designing complex if...elif chains* recipe.\n*   A classic article on this topic is by David Gries, *A note on a standard strategy for developing loop invariants and loops* . See [http://www.sciencedirect.com/science/article/pii/0167642383900151](http://www.sciencedirect.com/science/article/pii/0167642383900151) .\n*   Algorithm design is a big subject. A good introduction is by Skiena, *Algorithm Design Manual* . See [http://www3.cs.stonybrook.edu/~algorith/](http://www3.cs.stonybrook.edu/~algorith/) .\n\n# Avoiding a potential problem with break statements\n\nThe common way to understand a `for` statement is that it creates a *for all* condition. At the end of the statement, we can assert that, for all items in a collection, some processing has been done.\n\nThis isn't the only meaning for a `for` statement. When we introduce the `break` statement inside the body of a `for` , we change the semantics to *there exists* . When the `break` statement leaves the `for` (or `while` ) statement, we can assert only that there exists at least one item that caused the statement to end.\n\nThere's a side issue here. What if the loop ends without executing the `break` ? We are forced to assert that there does not exist even one item that triggered the `break` . **DeMorgan's Law** tells us that a not exists condition can be restated as a *for all* condition: \u00ac\u2203 [*x*] *B* ( *x* ) \u2261 \u2200 [*x*] \u00ac *B* ( *x* ). In this formula, *B(x)* is the condition on the `if` statement that includes the `break` . If we never found *B(x)* , then for all items \u00ac *B(x)* was `true` . This shows some of the symmetry between a typical *for all* loop and a *there exists* loop which includes a `break` .\n\nThe condition that's `true` upon leaving a `for` or `while` statement can be ambiguous. Did it end normally? Did it execute the `break` ? We can't *easily* tell, so we'll provide a recipe that gives us some design guidance.\n\nThis can become an even bigger problem when we have multiple `break` statements, each with its own condition. How can we minimize the problems created by having complex `break` conditions?\n\n## Getting ready\n\nLet's find the first occurrence of a `:` or `=` in a string. This is a good example of a *there exists* modification to a `for` statement. We don't want to process all characters, we want to know where there exists the left-most `:` or `=` .\n\n```", "```py\n\nWhat about this edge case?\n\n```", "```py\n\nThat's awkwardly wrong. What happened?\n\n## How to do it...\n\nAs we noted in the *Designing a while statement which terminates properly* recipe, every statement establishes a post-condition. When designing a loop, we need to articulate that condition. In this case, we didn't properly articulate the post-condition.\n\nIdeally, the post-condition would be something simple like `text[position] in '=:'` . However, if there's no `=` or `:` in the given text, the simple post-condition doesn't make logical sense. When no character exists which matches the criteria, we can't make any assertion about the position of a character that's not there.\n\n1.  Write the obvious post-condition. We sometimes call this the *happy-path* condition because it's the one that's `true` when nothing unusual has happened.\n\n    ```", "```py\n\n2.  Add post-conditions for the edge cases. In this example, we have two additional conditions:\n\n    *   There's no `=` or `:` .\n    *   There are no characters at all. The `len()` is zero, and the loop never actually does anything. In this case, the position variable will never be created.\n\n        ```", "```py\n\n3.  If a `while` statement is being used, consider redesigning it to have completion conditions. This can eliminate the need for a `break` statement.\n4.  If a `for` statement is being used, be sure a proper initialization is done, and add the various terminating conditions to the statements after the loop. It can look redundant to have `x = 0` followed by `for x = ...` . It's necessary in the case of a loop which doesn't execute the `break` statement, though.\n\n    ```", "```py\n\nIn the statements after the `for` , we've enumerated all of the terminating conditions explicitly. The final output, `name= name_only value= None` , confirms that we've correctly processed the sample text.\n\n## How it works...\n\nThis approach forces us to work out the post-condition carefully so that we can be absolutely sure that we know all the reasons for the loop terminating.\n\nIn more complex loops\u2014with multiple `break` statements\u2014the post-condition can be difficult to work out fully. The post-condition for a loop must include all of the reasons for leaving the loop\u2014the *normal* reasons plus all of the `break` conditions.\n\nIn many cases, we can refactor the loop to push the processing into the body of the loop. Rather than simply assert that `position` is the index of the `=` or `:` character, we include the next processing steps of assigning the `name` and `value` values. We might have something like this:\n\n```", "```py\n\nThis version pushes some of the processing forward, based on the complete set of post-conditions evaluated previously. This kind of refactoring is common.\n\nThe idea is to forego any assumptions or intuition. With a little bit of discipline, we can be sure of the post-conditions from any statement.\n\nIndeed, the more we think about post-conditions, the more precise our software can be. It's imperative to be explicit about the goal for our software and work backwards from the goal by choosing the simplest statements that will make the goal become `true` .\n\n## There's more...\n\nWe can also use an `else` clause on a `for` statement to determine if the loop finished normally or a `break` statement was executed. We can use something like this:\n\n```", "```py\n\nThe `else` condition is sometimes confusing, and we don't recommend it. It's not clear that it is substantially better than any of the alternatives. It's too easy to forget the reason why the `else` is executed because it's used so rarely.\n\n## See also\n\n*   A classic article on this topic is by David Gries, *A note on a standard strategy for developing loop invariants and loops* . See [http://www.sciencedirect.com/science/article/pii/0167642383900151](http://www.sciencedirect.com/science/article/pii/0167642383900151) .\n\n# Leveraging the exception matching rules\n\nThe `try` statement lets us capture an exception. When an exception is raised, we have a number of choices for handling it:\n\n*   **Ignore it** : If we do nothing, the program stops. We can do this in two ways\u2014don't use a `try` statement in the first place, or don't have a matching `except` clause in the `try` statement.\n*   **Log it** : We can write a message and let it propagate; generally this will stop the program.\n*   **Recover from it** : We can write an `except` clause to do some recovery action to undo the effects of something that was only partially completed in the `try` clause. We can take this a step further and wrap the `try` statement in a `while` statement and keep retrying until it succeeds.\n*   **Silence it** : If we do nothing (that is, `pass` ) then processing is resumed after the `try` statement. This silences the exception.\n*   **Rewrite it** : We can raise a different exception. The original exception becomes a context for the newly-raised exception.\n*   **Chain it** : We chain a different exception to the original exception. We'll look at this in the *Chaining exceptions with the raise from statement* recipe.\n\nWhat about nested contexts? In this case, an exception could be ignored by an inner `try` but handled by an outer context. The basic set of options for each `try` context are the same. The overall behavior of the software depends on the nested definitions.\n\nOur design of a `try` statement depends on the way that Python exceptions form a class hierarchy. For details, see *Section 5.4* , *Python Standard Library* . For example, `ZeroDivisionError` is also an `ArithmeticError` and an `Exception` . For another example, a `FileNotFoundError` is also an `OSError` as well as an `Exception` .\n\nThis hierarchy can lead to confusion if we're trying to handle detailed exceptions as well as generic exceptions.\n\n## Getting ready\n\nLet's say we're going to make simple use of the `shutil` to copy a file from one place to another. Most of the exceptions that might be raised indicate a problem too serious to work around. However, in the rare event of a `FileExistsError` , we'd like to attempt a recovery action.\n\nHere's a rough outline of what we'd like to do:\n\n```", "```py\n\nWe have two paths, `source_path` and `target_path` . We've located all of the directories under the `source_path` that have `*.rst` files.\n\nThe expression `source_file_path.relative_to(source_path)` gives us the tail end of the file name, the portion after the base directory. We use this to build a new path under the `target` directory.\n\nWhile we can use `pathlib.Path` objects for a lot of ordinary path processing, in Python 3.5 modules like `shutil` expect string filenames instead of `Path` objects; we need to explicitly convert the `Path` objects. We can only hope that Python 3.6 changes this.\n\nThe problems arise with handling exceptions raised by the `shutil.copy()` function. We need a `try` statement so that we can recover from certain kinds of errors. We'll see this kind of error if we try to run this:\n\n```", "```py\n\nHow do we create a `try` statement that handles the exceptions in the proper order?\n\n## How to do it...\n\n1.  Write the code we want to use indented in the `try` block:\n\n    ```", "```py\n\n2.  Include the most specific exception classes first. In this case, we have separate responses for the specific `FileNotFoundError` and the more general `OSError` .\n\n    ```", "```py\n\n3.  Include any more general exceptions later:\n\n    ```", "```py\n\n    We've matched exceptions with the most specific first and the more generic after that.\n\n    We handled the `FileNotFoundError` by creating the missing directories. Then we did the `copy()` again, knowing it would now work properly.\n\n    We silenced any other exceptions of the class `OSError` . For example, if there's a permission problem, that error will simply be logged. Our objective is to try and copy all of the files. Any files that cause problems will be logged, but the copying process will continue.\n\n## How it works...\n\nPython's matching rules for exceptions are intended to be simple:\n\n*   Process the `except` clauses in order\n*   Match the actual exception against the exception class (or tuple of exception classes). A match means that the actual exception object (or any of the base classes of the exception object) is of the given class in the `except` clause.\n\nThese rules show why we put the most specific exception classes first and the more general exception classes last. A generic exception class like the `Exception` will match almost every kind of exception. We don't want this first, because no other clauses will be checked. We must always put generic exceptions last.\n\nThere's an even more generic class, the `BaseException` class. There's no good reason to ever handle exceptions of this class. If we do, we will be catching `SystemExit` and `KeyboardInterrupt` exceptions, which interferes with the ability to kill a misbehaving application. We only use the `BaseException` class as a superclass when defining new exception classes that exist outside the normal exception hierarchy.\n\n## There's more...\n\nOur example includes a nested context in which a second exception can be raised. Consider this `except` clause:\n\n```", "```py\n\nIf the `os.makedirs()` or `shutil.copy()` functions raise another exception, it won't be handled by this `try` statement. Any exceptions raised here will crash the program as a whole. We have two ways to handle this, both of which involve nested `try` statements.\n\nWe can rewrite this to include a nested `try` during recovery:\n\n```", "```py\n\nIn this example, we've repeated the `OSError` processing in two places. In our nested context, we'll log the exception and let it propagate, which will likely stop the program. In the outer context, we'll do the same thing.\n\nWe say *likely stop the program* because this code could be used inside a `try` statement, which might handle these exceptions. If there's no other `try` context, then these unhandled exceptions will stop the program.\n\nWe can also rewrite our overall statement to have nested `try` statements that separate the two exception handling strategies into more local and more global considerations. It would look like this:\n\n```", "```py\n\nThe copy with `makedirs` processing in the inner `try` statement handles only the `FileNotFoundError` exception. Any other exception will propagate out to the outer `try` statement. In this example, we've nested the exception handling so that the generic processing wraps the specific processing.\n\n## See also\n\n*   In the *Avoiding a potential problem with an except: clause* recipe we look at some additional considerations when designing exceptions\n*   In the *Chaining exceptions with the raise from statement* recipe we look at how we can chain exceptions so that a single class of exception wraps different detailed exceptions\n\n# Avoiding a potential problem with an except: clause\n\nThere are some common mistakes in exception handling. These can cause programs to become unresponsive.\n\nOne of the mistakes we can make is to use the `except:` clause. There are a few other mistakes which we can make if we're not cautious about the exceptions we try to handle.\n\nThis recipe will show some common exception handling errors that we can avoid.\n\n## Getting ready\n\nIn the *Avoiding a potential problem with an except: clause* recipe we looked at some considerations when designing exception handling. In that recipe, we discouraged the use of `BaseException` because we can interfere with stopping a misbehaving Python program.\n\nWe'll extend the idea of *what not to do* in this recipe.\n\n## How to do it...\n\nUse `except Exception:` as the most general kind of exception managing.\n\nHandling too many exceptions can interfere with our ability to stop a misbehaving Python program. When we hit *Ctrl* + *C* , or send a `SIGINT` signal via `kill -2` , we generally want the program to stop. We rarely want the program to write a message and keep running, or stop responding altogether.\n\nThere are a few other classes of exceptions which we should be wary of attempting to handle:\n\n*   SystemError\n*   RuntimeError\n*   MemoryError\n\nGenerally, these exceptions mean that things are going badly somewhere in Python's internals. Rather than silence these exceptions, or attempt some recovery, we should allow the program to fail, find the root cause, and fix it.\n\n## How it works...\n\nThere are two techniques we should avoid:\n\n*   Don't capture the `BaseException` class\n*   Don't use `except:` with no exception class. This matches all exceptions; this will include exceptions we should avoid trying to handle.\n\nUsing `except BaseException` or except without a specific class can cause a program to become unresponsive at exactly the time we need to stop it.\n\nFurther, if we capture any of these exceptions, we can interfere with the way these internal exceptions are handled:\n\n*   `SystemExit`\n*   `KeyboardInterrupt`\n*   `GeneratorExit`\n\nIf we silence, wrap, or rewrite any of these, we may have created a problem where none existed. We may have exacerbated a simple problem into a larger and more mysterious problem.\n\n### Note\n\nIt's a noble aspiration to write a program which never crashes. Interfering with some of Python's internal exceptions doesn't create a more reliable program. Instead, it creates a program where a clear failure is masked and made into an obscure mystery.\n\n## See also\n\n*   In the *Leveraging the exception matching rules* recipe we look at some considerations when designing exceptions\n*   In the *Chaining exceptions with the raise from statement* recipe we look at how we can chain exceptions so that a single class of exception wraps different detailed exceptions.\n\n# Chaining exceptions with the raise from statement\n\nIn some cases, we may want to merge some seemingly unrelated exceptions into a single generic exception. It's common for a complex module to define a single generic `Error` exception which applies to many situations that can arise within the module.\n\nMost of the time, the generic exception is all that's required. If the module's `Error` is raised, something didn't work.\n\nLess frequently, we want the details for debugging or monitoring purposes. We might want to write them to a log, or include the details in an e-mail. In this case, we need to provide supporting details that amplify or extend the generic exception. We can do this by chaining from the generic exception to the root cause exception.\n\n## Getting ready\n\nAssume we're writing some complex string processing. We'd like to treat a number of different kinds of detailed exceptions as a single generic error so that users of our software are insulated from the implementation details. We can attach details to the generic error.\n\n## How to do it...\n\n1.  To create a new exception, we can do this:\n\n    ```", "```py\n\n    That's sufficient to define a new class of exception.\n\n2.  When handling exceptions, we can chain them using the `raise from` statement like this:\n\n    ```", "```py\n\n    In the first `except` clause, we matched two kinds of exception classes. No matter which kind we get, we'll raise a new exception from the module's generic `Error` exception class. The new exception will be chained to the root cause exception.\n\n    In the second `except` clause, we matched the generic `Exception` class. We wrote a log message and re-raised the exception. Here, we're not chaining, but simply continuing exception handling in another context.\n\n## How it works...\n\nThe Python exception classes all have a place to record the cause of the exception. We can set this `__cause__` attribute using the `raise Exception from Exception` statement.\n\nHere's how it looks when this exception is raised:\n\n```", "```py\n\nThe exception that we just saw was the direct cause of the following exception:\n\n```", "```py\n\nThis shows a chained exception. The first exception in the `Traceback` message is an `IndexError` exception. This is the direct cause. The second exception in the `Traceback` is our generic `Error` exception. This is a generic summary exception, which was chained to the original cause.\n\nAn application will see the `Error` exception in a `try:` statement. We might have something like this:\n\n```", "```py\n\nHere we've shown a function named `some_function()` that can raise the generic `Error` exception. If this function does raise the exception, the `except` clause will match the generic `Error` exception. We can print the exception's message, `exception` , as well as the root cause exception, `exception.__cause__` . In many applications, the `exception.__cause__` value may get written to a debugging log rather than be displayed to users.\n\n## There's more...\n\nIf an exception is raised inside an exception handler, this also creates a kind of chained exception relationship. This is the *context* relationship rather than the *cause* relationship.\n\nThe context message looks similar. The message is slightly different. It says `During handling of the above exception, another exception occurred:` . The first `Traceback` will show the original exception. The second message is the exception raised without using an explicit from connection.\n\nGenerally, the context is something unplanned that indicates an error in the `except` processing block. For example, we might have this:\n\n```", "```py\n\nThis will raise a `NameError` exception with a context of a `ValueError` exception. The `NameError` exception stems from misspelling the exception variable as `exceotuib` .\n\n## See also\n\n*   In the *Leveraging the exception matching rules* recipe we look at some considerations when designing exceptions\n*   In the *Avoiding a potential problem with an except: clause* recipe we look at some additional considerations when designing exceptions\n\n# Managing a context using the with statement\n\nThere are many instances where our scripts will be entangled with external resources. The most common examples are disk files and network connections to external hosts. A common bug is retaining these entanglements forever, tying up these resources uselessly. These are sometimes called memory **leaks** because the available memory is reduced each time a new file is opened without closing a previously used file.\n\nWe'd like to isolate each entanglement so that we can be sure that the resource is acquired and released properly. The idea is to create a context in which our script uses an external resource. At the end of the context, our program is no longer bound to the resource and we want to be guaranteed that the resource is released.\n\n## Getting ready\n\nLet's say we want to write lines of data to a file in CSV format. When we're done, we want to be sure that the file is closed and the various OS resources\u2014including buffers and file handles\u2014are released. We can do this in a context manager, which guarantees that the file will be properly closed.\n\nSince we'll be working with CSV files, we can use the `csv` module to handle the details of the formatting:\n\n```", "```py\n\nWe'll also use the `pathlib` module to locate the files we'll be working with:\n\n```", "```py\n\nFor the purposes of having something to write, we'll use this silly data source:\n\n```", "```py\n\nThis will give us a context in which to learn about the `with` statement.\n\n## How to do it...\n\n1.  Create the context by opening the file, or creating the network connection with `urllib.request.urlopen()` . Other common contexts include archives like `zip` files and `tar` files:\n\n    ```", "```py\n\n2.  Include all the processing, indented within the `with` statement:\n\n    ```", "```py\n\n3.  When we use a file as a context manager, the file is automatically closed at the end of the indented context block. Even if an exception is raised, the file is still closed properly. Outdent the processing that is done after the context is finished and the resources are released:\n\n    ```", "```py\n\nThe statements outside the `with` context will be executed after the context is closed. The named resource\u2014the file opened by `target_path.open()` \u2014will be properly closed.\n\nEven if an exception is raised inside the `with` statement, the file is still properly closed. The context manager is notified of the exception. It can close the file and allow the exception to propagate.\n\n## How it works...\n\nA context manager is notified of two kinds of exits from the block of code:\n\n*   Normal exit with no exception\n*   An exception was raised\n\nThe context manager will\u2014under all conditions\u2014disentangle our program from external resources. Files can be closed. Network connections can be dropped. Database transactions can be committed or rolled back. Locks can be released.\n\nWe can experiment with this by including a manual exception inside the `with` statement. This can show that the file was properly closed.\n\n```", "```py\n\nIn this example, we've wrapped the real work in a `try` statement. This allows us to raise an exception after writing the first to the CSV file. When the exception is raised, we can print the exception. At this point, the file will also be closed. The output is simply this:\n\n```"]