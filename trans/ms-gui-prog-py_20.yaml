- en: Preparing Your Software for Distribution
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备软件进行分发
- en: Up to this point in the book, we have primarily been concerned with writing
    a working piece of code. Our projects have all been single scripts with, at most,
    a handful of supporting data files. Producing a finished project doesn't end with
    writing the code, however; we also need our projects to be easily distributable
    so that we can share them with (or sell them to) other people.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们主要关注的是编写一个可工作的代码。我们的项目都是单个脚本，最多有几个支持数据文件。然而，完成一个项目并不仅仅是编写代码；我们还需要我们的项目能够轻松分发，这样我们就可以与其他人分享（或出售）它们。
- en: In this chapter, we're going to look at ways to prepare our code for sharing
    and distribution.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨为分享和分发准备我们的代码的方法。
- en: 'We''ll cover these topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Structuring a project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目结构
- en: Distributing with `setuptools`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`setuptools`进行分发
- en: Compiling with PyInstaller
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PyInstaller编译
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the basic Python and PyQt setup we have used
    throughout the book. You will also need the `setuptools`, `wheel`, and `pyinstaller`
    libraries available from PyPI with this command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将需要我们在整本书中使用的基本Python和PyQt设置。您还需要使用以下命令从PyPI获取`setuptools`、`wheel`和`pyinstaller`库：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Windows users will want to install the 7-Zip program from [https://www.7-zip.org/](https://www.7-zip.org/)
    so that they can work with `tar.gz` files, and users on all platforms should install
    the UPX utility from [https://upx.github.io/](https://upx.github.io/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户将需要从[https://www.7-zip.org/](https://www.7-zip.org/)安装7-Zip程序，以便他们可以使用`tar.gz`文件，所有平台的用户都应该从[https://upx.github.io/](https://upx.github.io/)安装UPX实用程序。
- en: Finally, you will want the example code from the repository at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter17](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter17).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将希望从存储库中获取示例代码[https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter17](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter17)。
- en: Check out the following video to see the code in action: [http://bit.ly/2M5xH4J](http://bit.ly/2M5xH4J)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码是如何运行的：[http://bit.ly/2M5xH4J](http://bit.ly/2M5xH4J)
- en: Structuring a project
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: So far in this book, we've been putting all the Python code in each example
    project into a single file. Real-world Python projects, however, benefit from
    better organization. While there are no official standards on how to structure
    a Python project, there are some conventions and general concepts we can apply
    to our project structure that will not only keep things organized, but encourage
    others to contribute to our code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们一直将每个示例项目中的所有Python代码放入单个文件中。然而，现实世界的Python项目受益于更好的组织。虽然没有关于如何构建Python项目的官方标准，但我们可以应用一些约定和一般概念来构建我们的项目结构，这不仅可以保持组织，还可以鼓励其他人贡献我们的代码。
- en: To see how this works, we're going to create a simple tic-tac-toe game in PyQt,
    then spend the rest of the chapter getting it ready for distribution.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这是如何工作的，我们将在PyQt中创建一个简单的井字棋游戏，然后花费本章的其余部分来准备分发。
- en: Tic-tac-toe
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 井字棋
- en: 'Our tic-tac-toe game is made up of three classes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的井字棋游戏由三个类组成：
- en: An engine class that manages the logic of the game
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理游戏逻辑的引擎类
- en: A board class that provides a view of the game state and a way to make plays
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供游戏状态视图和进行游戏的方法的棋盘类
- en: The main window class that brings the other two together into a GUI
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其他两个类合并到GUI中的主窗口类
- en: Open a new copy of the application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow*, and call it `ttt-qt.py`. Now let's create
    these classes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 打开[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)中的应用程序模板的新副本，*使用QMainWindow构建应用程序*，并将其命名为`ttt-qt.py`。现在让我们创建这些类。
- en: The engine class
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引擎类
- en: Our game engine object's main responsibility is to keep track of plays and to
    check whether there is a winner or whether the game is a draw. The players will
    be represented simply by the `'X'` and `'O'` strings, and the board will be modeled
    as a list of nine items that will either be a player or `None`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏引擎对象的主要责任是跟踪游戏并检查是否有赢家或游戏是否为平局。玩家将简单地由`'X'`和`'O'`字符串表示，棋盘将被建模为九个项目的列表，这些项目将是玩家或`None`。
- en: 'It begins like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 它开始如下：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `winning_sets` list contains `set` objects with every combination of board
    indexes that constitutes a win. We'll be using that list to check whether a player
    won. We've also defined signals to be emitted when the game is won or when there
    is a draw (that is, all the squares are filled and nobody won). The constructor
    populates the board list and sets the current player to `X`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`winning_sets`列表包含`set`对象，其中包含构成胜利的每个棋盘索引的组合。我们将使用该列表来检查玩家是否获胜。我们还定义了信号，当游戏获胜或平局时发出（即，所有方块都填满了，没有人获胜）。构造函数填充了棋盘列表，并将当前玩家设置为`X`。'
- en: 'We''ll need a method to update the current player after each turn, which looks
    like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一个方法来在每轮之后更新当前玩家，看起来是这样的：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we''ll add a method for marking a square:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个标记方块的方法：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method first checks for any reason the given square shouldn't be marked,
    returning `False` if there is a reason; otherwise, we mark the square, swap to
    the next player, and return `True`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法首先检查给定方块是否应该被标记的任何原因，如果有原因则返回`False`；否则，我们标记方块，切换到下一个玩家，并返回`True`。
- en: 'The last method in this class will check the state of the board to see whether
    there is a winner or a draw:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中的最后一个方法将检查棋盘的状态，看看是否有赢家或平局：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This method uses some set operations to check each player's currently-marked
    squares against the list of winning combinations. If any match is found, the `game_won`
    signal is emitted and the method returns. If nobody has won yet, we also check
    to see whether there are any unmarked squares; if there aren't, the game is a
    draw. If neither of these cases is true, we do nothing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用一些集合操作来检查每个玩家当前标记的方块是否与获胜组合列表匹配。如果找到任何匹配项，将发出`game_won`信号并返回。如果还没有人赢，我们还要检查是否有任何未标记的方块；如果没有，游戏就是平局。如果这两种情况都不成立，我们什么也不做。
- en: The board class
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 棋盘类
- en: For the board GUI, we'll use a `QGraphicsScene` object just as we did for our
    tank game in [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml), *Creating
    2D Graphics with QPainter*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于棋盘GUI，我们将使用一个`QGraphicsScene`对象，就像我们在[第12章](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml)中为坦克游戏所做的那样，*使用QPainter创建2D图形*。
- en: 'We''ll start with some class variables:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一些类变量开始：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `square_rects` tuple defines a `QRectF` object for each of the nine squares
    on the board, and a `square_clicked` signal is emitted whenever a square is clicked
    on; the accompanying integer will indicate which square (0-8) was clicked on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`square_rects`元组为棋盘上的九个方块定义了一个`QRectF`对象，并且每当点击一个方块时会发出一个`square_clicked`信号；随附的整数将指示点击了哪个方块（0-8）。'
- en: 'Here is the `=__init__()` method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`=__init__()`方法：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method sets the scene size and paints a cyan background, and then it draws
    each of the squares in `square_rects`. We then load up the `QPixmap` objects for
    the `'X'` and `'O'` images that will be used to mark the squares, and we create
    an empty list to keep track of the `QGraphicsSceneItem` objects for our marks.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法设置了场景大小并绘制了青色背景，然后在`square_rects`中绘制了每个方块。然后，我们加载了用于标记方块的`'X'`和`'O'`图像的`QPixmap`对象，并创建了一个空列表来跟踪我们标记的`QGraphicsSceneItem`对象。
- en: 'Next, we''ll add a method to draw the current state of the board:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个方法来绘制棋盘的当前状态：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method will take a list of the marks on our board and draw the appropriate
    pixmap in each square, keeping track of the `QGraphicsSceneItems` objects created.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将接受我们棋盘上的标记列表，并在每个方块中绘制适当的像素项，跟踪创建的`QGraphicsSceneItems`对象。
- en: 'Now we''ll need a method to clear the board:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个方法来清空棋盘：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method simply iterates through the saved pixmap items and removes them
    all.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法只是遍历保存的像素项并将它们全部删除。
- en: 'The last thing we need to do is handle mouse clicks:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是处理鼠标点击：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `mousePressEvent())` method is called by `QGraphicsScene` whenever the user
    makes a mouse click. It includes a `QMouseEvent` object that contains details
    about the event, including the position of the mouse click. We can check whether
    this click is inside any of our `square_rects` objects, and if so, we'll emit
    the `square_clicked` signal and exit the method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`mousePressEvent()`方法由`QGraphicsScene`在用户进行鼠标点击时调用。它包括一个`QMouseEvent`对象，其中包含有关事件的详细信息，包括鼠标点击的位置。我们可以检查此点击是否在我们的`square_rects`对象中的任何一个内部，如果是，我们将发出`square_clicked`信号并退出该方法。'
- en: The main window class
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主窗口类
- en: 'In `MainWindow.__init__()`, we''ll start by creating a board and a `QGraphicsView` object
    to display it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainWindow.__init__()`中，我们将首先创建一个棋盘和一个`QGraphicsView`对象来显示它：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we need to create an instance of the game engine and connect its signals.
    In order to allow us to start games over and over, we''ll create a separate method
    for this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个游戏引擎的实例并连接它的信号。为了让我们能够一遍又一遍地开始游戏，我们将为此创建一个单独的方法：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This method clears the board, and then it creates an instance of the game engine
    object, connecting the engine's signals to `MainWindow` methods to handle the
    two game-over scenarios.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法清空了棋盘，然后创建了游戏引擎对象的一个实例，将引擎的信号连接到`MainWindow`方法以处理两种游戏结束的情况。
- en: 'Back in `__init__()`, we''ll go ahead and call this method to set up the first
    game automatically:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`__init__()`，我们将调用这个方法来自动设置第一局游戏：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we need to enable player input. We''ll need a method that will try to
    mark the square in the engine and then check the board for a win or a draw if
    the mark was successful:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要启用玩家输入。我们需要一个方法，该方法将尝试在引擎中标记方块，然后在标记成功时检查棋盘是否获胜或平局：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That method can be connected to the board''s `square_clicked` signal; back
    in `__init__()`, add this code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法可以连接到棋盘的`square_clicked`信号；在`__init__()`中，添加以下代码：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we need to handle the two game-over scenarios:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要处理两种游戏结束的情况：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In both cases, we're just going to display an appropriate message in `QMessageBox` and
    then restart the game.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们只会在`QMessageBox`中显示适当的消息，然后重新开始游戏。
- en: This completes our game. Take a moment to run the game and make sure you understand
    how it responds when working correctly (maybe get a friend to play a few rounds
    with you; it helps if your friend is quite young or not particularly bright).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的游戏。花点时间运行游戏，并确保您了解它在正常工作时的响应（也许找个朋友和您一起玩几局；如果您的朋友很年轻或者不太聪明，这会有所帮助）。
- en: Now that we have a working game, it's time to prepare it for distribution. The
    first thing we'll do is structure our project in a way that will make it easier
    for us to maintain and expand, and for other Python programmers to collaborate
    on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可用的游戏，是时候准备将其分发了。我们首先要做的是以一种使我们更容易维护和扩展的方式构建我们的项目，以及让其他Python程序员合作。
- en: Module-style structure
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块式结构
- en: As programmers, we tend to think of applications and libraries as two very different
    things, but, in truth, well-structured applications aren't that different from
    libraries. A library is just a collection of ready-made classes and functions.
    Our application is mostly just class definitions as well; it just happens to have
    a few lines of code at the end that allow it to be executed as an application.
    When we see things this way, structuring our application as a Python library module
    makes a lot of sense. To do this, we're going to convert our single Python file
    to a directory full of files, each containing an individual unit of code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们倾向于将应用程序和库视为两个非常不同的东西，但实际上，结构良好的应用程序与库并没有太大的不同。库只是一组现成的类和函数。我们的应用程序主要也只是类定义；它只是碰巧在最后有几行代码，使其能够作为应用程序运行。当我们以这种方式看待事物时，将我们的应用程序结构化为Python库模块是很有道理的。为了做到这一点，我们将把我们的单个Python文件转换为一个包含多个文件的目录，每个文件包含一个单独的代码单元。
- en: The first step is to consider our project's name; right now, that name is `ttt-qt.py`.
    It's not uncommon to come up with a quick and short name when you first start
    hacking on a project, but that doesn't need to be the name you stick with. In
    this case, our name is rather cryptic and doesn't work as a Python module name
    due to the hyphen. Instead, let's call it `qtictactoe`, a name that is more explicit
    and avoids the hyphen.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是考虑我们项目的名称；现在，那个名称是`ttt-qt.py`。当你开始着手一个项目时，想出一个快速简短的名称是很常见的，但这不一定是你要坚持的名称。在这种情况下，我们的名称相当神秘，由于连字符而不能作为Python模块名称。相反，让我们称之为`qtictactoe`，这是一个更明确的名称，避免了连字符。
- en: To begin, create a new directory called `QTicTacToe`; this will be our **project
    root**. The project root is the directory under which all our project files will
    go.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`QTicTacToe`的新目录；这将是我们的**项目根目录**。项目根目录是所有项目文件都将放置在其中的目录。
- en: Inside that directory, we'll create a second directory called `qtictactoe`;
    this will be the **module directory** inside which the bulk of our source code
    will live.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在该目录下，我们将创建一个名为`qtictactoe`的第二个目录；这将是我们的**模块目录**，其中将包含大部分我们的源代码。
- en: Structuring the module
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块的结构
- en: To begin our module, we're going to start by adding the code for our three classes.
    We're going to put each one in a separate file; this isn't strictly necessary,
    but it will help us to keep our code decoupled and make it easier to find the
    class we want to edit.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的模块，我们将首先添加我们三个类的代码。我们将把每个类放在一个单独的文件中；这并不是严格必要的，但这将帮助我们保持代码解耦，并使得更容易找到我们想要编辑的类。
- en: 'Therefore, under `qtictactoe`, create three files:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`qtictactoe`下，创建三个文件：
- en: '`engine.py` will hold our game engine class. Copy in the `TicTacToeEngine`
    definition along with the necessary `PyQt5` import statements for the classes
    it uses. In this case, you only need `QtCore`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`engine.py`将保存我们的游戏引擎类。复制`TicTacToeEngine`的定义以及它所使用的必要的`PyQt5`导入语句。在这种情况下，你只需要`QtCore`。'
- en: '`board.py` will hold the `TTTBoard` class. Copy in that code as well as the
    full set of `PyQt5` import statements.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`board.py`将保存`TTTBoard`类。也复制那段代码以及完整的`PyQt5`导入语句。'
- en: Finally, `mainwindow.py` will hold the `MainWindow` class. Copy in the code
    for that class as well as the `PyQt5` imports.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`mainwindow.py`将保存`MainWindow`类。复制该类的代码以及`PyQt5`导入。
- en: '`mainwindow.py` also needs access to the `TicTacToeEngine` and `TTTBoard` classes
    from the other files. To provide this access, we need to use **relative imports**.
    A relative import is a way of importing submodules from the same module.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`mainwindow.py`还需要从其他文件中获取`TicTacToeEngine`和`TTTBoard`类的访问权限。为了提供这种访问权限，我们需要使用**相对导入**。相对导入是一种从同一模块中导入子模块的方法。'
- en: 'At the top of `mainwindow.py`, add this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mainwindow.py`的顶部添加这行：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The dot in the import indicates that this is a relative import, and refers specifically
    to the current container module (in this case, `qtictactoe`). By using relative
    imports like this, we can ensure that we're importing these modules from our own
    project and not from some other Python library on the end user's system.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入中的点表示这是一个相对导入，并且特指当前容器模块（在本例中是`qtictactoe`）。通过使用这样的相对导入，我们可以确保我们从自己的项目中导入这些模块，而不是从用户系统上的其他Python库中导入。
- en: The next code we need to add to our module is code to make it actually run.
    This is the code we usually put under our `if __name__ == '__main__'` block.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加到我们模块的下一个代码是使其实际运行的代码。这通常是我们放在`if __name__ == '__main__'`块下的代码。
- en: 'In the module, we''ll put it in a file called `__main__.py`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块中，我们将把它放在一个名为`__main__.py`的文件中：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `__main__.py` file serves a special purpose in a Python module. It is executed
    whenever our module is run using the `-m` switch, like so:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`__main__.py`文件在Python模块中有着特殊的用途。每当我们使用`-m`开关运行我们的模块时，它就会被执行，就像这样：'
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Essentially, `__main__.py` is the module equivalent of the `if __name__ == '__main__':`
    block in a Python script.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，`__main__.py`是Python脚本中`if __name__ == '__main__':`块的模块等价物。
- en: Note that we have placed our three main lines of code inside a function called
    `main()`. The reason for that will become apparent when we discuss the use of
    `setuptools`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经将我们的三行主要代码放在一个名为`main()`的函数中。当我们讨论`setuptools`的使用时，这样做的原因将变得明显。
- en: The last file we need to create inside our module is an empty file called `__init__.py`.
    The `__init__.py` file of a Python module is analogous to the `__init__()` method
    of a Python class. It is executed whenever the module is imported, and anything
    in its namespace is considered to be in the root namespace of the module. In this
    case, though, we're going to just leave it empty. That may seem pointless, but
    without this file many of the tools we're going to be working with won't recognize
    this folder of Python files as an actual module.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在模块内创建的最后一个文件是一个名为`__init__.py`的空文件。Python模块的`__init__.py`文件类似于Python类的`__init__()`方法。每当导入模块时，它都会被执行，并且其命名空间中的任何内容都被视为模块的根命名空间。但在这种情况下，我们将它留空。这可能看起来毫无意义，但如果没有这个文件，我们将要使用的许多工具将不会将这个Python文件夹识别为一个实际的模块。
- en: 'At this point, your directory structure should look like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的目录结构应该是这样的：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now we can execute our program using `python3 -m qtictactoe`, but that's not
    terribly intuitive for most users. Let's help out a little by creating an obvious
    file for executing the application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`python3 -m qtictactoe`来执行我们的程序，但对大多数用户来说，这并不是非常直观。让我们通过创建一个明显的文件来帮助一下执行应用程序。
- en: 'Directly under the project root (outside the module), create a file called
    `run.py`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录下（模块外部），创建一个名为`run.py`的文件：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This file's only purpose is to load the `main()` function from our module and
    execute it. Now you can execute `python run.py` and you'll find it launches just
    fine. However, there's a problem—when you click a square, nothing happens. That's
    because our image files are missing. We'll need to deal with those next.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的唯一目的是从我们的模块中加载`main()`函数并执行它。现在，您可以执行`python run.py`，您会发现它可以正常启动。但是，有一个问题——当您点击一个方块时，什么也不会发生。那是因为我们的图像文件丢失了。我们需要处理这些问题。
- en: Non-Python files
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非Python文件
- en: In a PyQt program, the best way to deal with files such as our `X` and `O` images
    is to use the `pyrcc5` tool to generate a resources file that can then be added
    to your module like any other Python file (we learned about this in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml),
    *Styling Qt Applications*). However, in this case, we're going to keep our images
    as PNG files so that we can explore our options for dealing with non-Python files.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在PyQt程序中，处理诸如我们的`X`和`O`图像之类的文件的最佳方法是使用`pyrcc5`工具生成一个资源文件，然后像任何其他Python文件一样将其添加到您的模块中（我们在[第6章](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml)中学习了这个）。然而，在这种情况下，我们将保留我们的图像作为PNG文件，以便我们可以探索处理非Python文件的选项。
- en: There is little consensus on where these kinds of files should live inside a
    project directory, but since these images are a required component of the `TTTBoard`
    class, it makes sense to put them inside our module. For the sake of organization,
    put them in a directory called `images`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些文件应该放在项目目录的何处，目前还没有达成一致的意见，但是由于这些图像是`TTTBoard`类的一个必需组件，将它们放在我们的模块内是有意义的。为了组织起见，将它们放在一个名为`images`的目录中。
- en: 'Your directory structure should now look like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的目录结构应该是这样的：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The way we have written `TTTBoard`, you can see that each image is loaded using
    a relative file path. In Python, relative paths are always relative to the current
    working directory—that is, the directory from which the user launched the script.
    Unfortunately, this is a rather brittle design, as we have no control over this
    directory. We also can't hardcode an absolute file path since we don't know where
    our application might be stored on a user's system (see our discussion of this
    problem in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml), *Styling Qt
    Applications*, under the *Using Qt Resource files* section).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写`TTTBoard`的方式是，您可以看到每个图像都是使用相对文件路径加载的。在Python中，相对路径始终相对于当前工作目录，也就是用户启动脚本的目录。不幸的是，这是一个相当脆弱的设计，因为我们无法控制这个目录。我们也不能硬编码绝对文件路径，因为我们不知道我们的应用程序可能存储在用户系统的何处（请参阅我们在[第6章](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml)中对这个问题的讨论，*Styling
    Qt Applications*，*Using Qt Resource files*部分）。
- en: The ideal way to solve this problem in a PyQt application is to use Qt Resource
    files; however, we're going to try a different approach just to illustrate how
    to solve this problem in cases where that isn't an option.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在PyQt应用程序中解决这个问题的理想方式是使用Qt资源文件；然而，我们将尝试一种不同的方法，只是为了说明在这种情况下如何解决这个问题。
- en: 'To get around this, we need to modify the way `TTTBoard` loads the images so
    that it''s relative to the location of our module, rather than the user''s current
    working directory. This will require us to use the `os.path` module from the Python
    standard library, so add this at the top of `board.py`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要修改`TTTBoard`加载图像的方式，使其相对于我们模块的位置，而不是用户的当前工作目录。这将需要我们使用Python标准库中的`os.path`模块，因此在`board.py`的顶部添加这个：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, down in `__init__()`, we''ll modify the lines that load in the images:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`__init__()`中，我们将修改加载图像的行：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `__file__` variable is a built-in variable that always contains the absolute
    path to the current file (`board.py`, in this case). Using `path.dirname`, we
    can find the directory that contains this file. Then, we can use `path.join` to
    assemble a path that looks for the files under a folder called `images` in the
    same directory.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`__file__`变量是一个内置变量，它始终包含当前文件（在本例中是`board.py`）的绝对路径。使用`path.dirname`，我们可以找到包含此文件的目录。然后，我们可以使用`path.join`来组装一个路径，以便在同一目录下的名为`images`的文件夹中查找文件。'
- en: If you run the program now, you should find that it works perfectly, just as
    before. We're not quite done yet, though.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行程序，您应该会发现它完美地运行，就像以前一样。不过，我们还没有完成。
- en: Documentation and metadata
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档和元数据
- en: Working and well-organized code is a great start for our project; however if
    you want others to use or contribute to your project, you'll need to address some
    of the questions they're likely to have. For example, they'll need to know how
    to install the program, what its prerequisites are, or what the legal terms of
    use or distribution are.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 工作和组织良好的代码是我们项目的一个很好的开始；但是，如果您希望其他人使用或贡献到您的项目，您需要解决一些他们可能会遇到的问题。例如，他们需要知道如何安装程序，它的先决条件是什么，或者使用或分发的法律条款是什么。
- en: 'To answer these questions, we''ll include a series of standard files and directories:
    the `LICENSE` file, the `README` file, the `docs` directory, and the `requirements.txt`
    file.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，我们将包括一系列标准文件和目录：`LICENSE`文件，`README`文件，`docs`目录和`requirements.txt`文件。
- en: The LICENSE file
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 许可文件
- en: When you share code, it's important to spell out exactly what others can or
    cannot do with that code. In most countries, a person who creates a piece of work such
    as a program is automatically the copyright holder of that work; that means you
    exercise control over the copying of your work. If you want others to contribute
    to or use what you've created, you need to grant them a **license** to do so.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当您分享代码时，非常重要的是明确说明其他人可以或不可以对该代码做什么。在大多数国家，创建作品的人自动成为该作品的版权持有人；这意味着您对您的作品的复制行为行使控制。如果您希望其他人为您创建的作品做出贡献或使用它们，您需要授予他们一个**许可证**。
- en: The license that governs your project is usually provided in a plain-text file
    in the project root called `LICENSE`. In our example code, we've included such
    a file that contains a copy of the **MIT license**. The MIT license is a permissive
    open source license which basically allows anyone to do anything with the code
    as long as they retain our copyright notice. It also states that we aren't responsible
    for anything terrible that happens as a result of someone using our code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 管理您项目的许可证通常以项目根目录中的一个名为`LICENSE`的纯文本文件提供。在我们的示例代码中，我们已经包含了这样一个文件，其中包含了**MIT许可证**的副本。MIT许可证是一种宽松的开源许可证，基本上允许任何人对代码做任何事情，只要他们保留我们的版权声明。它还声明我们对因某人使用我们的代码而发生的任何可怕事件不负责。
- en: This file is sometimes called `COPYING`, and may have a file extension such
    as `txt` as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件有时被称为`COPYING`，也可能有一个名为`txt`的文件扩展名。
- en: You are certainly free to put any conditions you wish in your license; however,
    for PyQt applications, you need to make sure your license is compatible with the
    terms of PyQt's **General Public License** (**GPL**) GNU and Qt's **Lesser General
    Public License** (**LGPL**) GNU. If you intend to release commercial or restrictively-licensed
    PyQt software, remember from [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml),
    *Getting Started with PyQt,* that you will need to purchase commercial licenses
    from both the Qt company and Riverbank Computing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您当然可以在许可证中加入任何条件；但是，对于PyQt应用程序，您需要确保您的许可证与PyQt的**通用公共许可证**（**GPL**）GNU和Qt的**较宽松的通用公共许可证**（**LGPL**）GNU的条款兼容。如果您打算发布商业或限制性许可的PyQt软件，请记住来自[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml)，*PyQt入门*，您需要从Qt公司和Riverbank
    Computing购买商业许可证。
- en: For open source projects, the Python community strongly recommends you stick
    with well-known licenses such as the MIT, BSD, GPL, or LGPL. A list of recognized
    open source licenses can be found on the website of the Open Source Initiative
    at [https://opensource.org/licenses](https://opensource.org/licenses). You may
    also want to consult [https://choosealicense.com](https://choosealicense.com),
    a site that offers guidance on selecting a license that best matches your intentions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开源项目，Python社区强烈建议您坚持使用MIT、BSD、GPL或LGPL等知名许可证。可以在开放源代码倡议组织的网站[https://opensource.org/licenses](https://opensource.org/licenses)上找到已知的开源许可证列表。您还可以参考[https://choosealicense.com](https://choosealicense.com)，这是一个提供有关选择最符合您意图的许可证的指导的网站。
- en: The README file
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: README文件
- en: The `README` file is one of the oldest traditions in software distribution.
    Dating back to the mid 1970s, this plain-text file is usually meant to convey
    the most basic set of instructions and information to users of the program before
    they install or run the software.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`README`文件是软件分发中最古老的传统之一。追溯到20世纪70年代中期，这个纯文本文件通常旨在在用户安装或运行软件之前向程序的用户传达最基本的一组指令和信息。'
- en: 'Although there is no standard for what a `README` file should contain, there
    are certain things a user would expect to find; some of these include the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有关于`README`文件应包含什么的标准，但用户希望找到某些内容；其中一些包括以下内容：
- en: The name and home page of the software
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件的名称和主页
- en: The author of the software (with contact information)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件的作者（带有联系信息）
- en: A short description of the software
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件的简短描述
- en: Basic usage instructions, including any command-line switches or arguments
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本使用说明，包括任何命令行开关或参数
- en: Instructions for reporting bugs or contributing to the project
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告错误或为项目做出贡献的说明
- en: A list of known bugs
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已知错误的列表
- en: Notes such as platform-specific issues or instructions
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如特定平台问题或说明之类的注释
- en: Whatever you include in the file, you should aim to keep it concise and organized.
    To facilitate some organizations, many modern software projects employ a markup
    language when writing a `README` file; this allows us to use elements such as
    headers, bullet lists, and even tables.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您在文件中包含什么，您都应该力求简洁和有组织。为了方便一些组织，许多现代软件项目在编写`README`文件时使用标记语言；这使我们可以使用诸如标题、项目列表甚至表格等元素。
- en: In Python projects, the preferred markup language is the **ReStructured Text**
    (**RST**). This language is part of the `docutils` project, which provides documentation
    utilities for Python.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python项目中，首选的标记语言是**重新结构化文本**（**RST**）。这种语言是`docutils`项目的一部分，为Python提供文档实用程序。
- en: 'We''ll take a brief look at RST as we walk through creating a `README.rst`
    file for `qtictactoe`. Start with a title:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`qtictactoe`的`README.rst`文件时，我们将简要介绍RST。从一个标题开始：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The equals signs around the top line indicate that it is a title; in this case,
    we've just used the name of our project.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部行周围的等号表示它是一个标题；在这种情况下，我们只是使用了我们项目的名称。
- en: 'Next, we''ll create a couple of sections for basic information about the project;
    we indicate section headers by simply underlining a line of text with symbols,
    like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为项目的基本信息创建几个部分；我们通过简单地用符号划线下一行文本来指示部分标题，就像这样：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The symbols used for underlining section headers must be one of the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 用于下划线部分标题的符号必须是以下之一：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The order in which we use them isn't important, as RST interpreters will assume
    the first symbols used as an underline representing a top-level header, the next
    type of symbol is a second-level header, and so on. In this case, we're using
    the equals sign first, so it will indicate a level-one header wherever we use
    it throughout this document.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用它们的顺序并不重要，因为RST解释器会假定第一个使用的符号作为表示顶级标题的下划线，下一个类型的符号是第二级标题，依此类推。在这种情况下，我们首先使用等号，所以无论我们在整个文档中使用它，它都会指示一个一级标题。
- en: Note the double asterisks around the words `tic-tac-toe`; this indicates bold
    text. RST can also indicate underlines, italics, and similar typographic styles.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意单词`tac-tac-toe`周围的双星号，这表示粗体文本。RST还可以表示下划线、斜体和类似的排版样式。
- en: 'For example, we can indicate monospaced code text by using the backtick:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用反引号来指示等宽代码文本：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This example also shows a bullet list: each line is prefixed with a dash and
    space. We can alternately use the `+` or `*` symbols as well, and create subpoints
    by indenting.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子还展示了一个项目列表：每行前面都加了一个破折号和空格。我们也可以使用`+`或`*`符号，并通过缩进创建子项目。
- en: 'Let''s finish our `README.rst` file with some information about contributing
    and some notes:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些关于贡献的信息和一些注释来完成我们的`README.rst`文件：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `Contributing` section shows how to create a hyperlink: put the hyperlink
    text inside backticks, with the URL inside angle brackets, and add an underscore
    after the closing backtick. The `Notes` section demonstrates a block quote, which
    is accomplished by simply indenting the line four spaces.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contributing`部分显示如何创建超链接：将超链接文本放在反引号内，URL放在尖括号内，并在关闭反引号后添加下划线。`Notes`部分演示了块引用，只需将该行缩进四个空格即可。'
- en: 'Although our file is perfectly readable as text, many popular code-sharing
    sites will translate RST and other markup languages to HTML. For example, on GitHub
    this file will appear in the browser like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的文件作为文本是完全可读的，但是许多流行的代码共享网站会将RST和其他标记语言转换为HTML。例如，在GitHub上，这个文件将在浏览器中显示如下：
- en: '![](assets/74f798bd-47d8-4941-8a14-63b614ce31d7.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/74f798bd-47d8-4941-8a14-63b614ce31d7.png)'
- en: This simple `README.rst` file is sufficient for our small application; as an
    application grows, it will warrant further expansion to document added features,
    contributors, community policies, and more. This is why we prefer to use a plain-text
    format such as RST and why we make it part of the project repository; it should
    be updated along with the code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的`README.rst`文件对于我们的小应用已经足够了；随着应用的增长，它将需要进一步扩展以记录添加的功能、贡献者、社区政策等。这就是为什么我们更喜欢使用RST这样的纯文本格式，也是为什么我们将其作为项目仓库的一部分；它应该随着代码一起更新。
- en: A quick reference for RST syntax can be found at [docutils.sourceforge.net/docs/user/rst/quickref.html](http://docutils.sourceforge.net/docs/user/rst/quickref.html).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: RST语法的快速参考可以在[docutils.sourceforge.net/docs/user/rst/quickref.html](http://docutils.sourceforge.net/docs/user/rst/quickref.html)找到。
- en: The docs directory
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档目录
- en: 'While this `README` file is sufficient documentation for `QTicTacToe`, a more
    complex program or library may demand more robust documentation. The standard
    place to put such documentation is in the `docs` directory. This directory should
    be right under our project root, and can contain any sort of additional documentation,
    including the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个`README`文件对于`QTicTacToe`已经足够了，但是一个更复杂的程序或库可能需要更健壮的文档。放置这样的文档的标准位置是在`docs`目录中。这个目录应该直接位于我们的项目根目录下，并且可以包含任何类型的额外文档，包括以下内容：
- en: Sample configuration files
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例配置文件
- en: User manuals
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户手册
- en: API documentation
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API文档
- en: Database diagrams
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库图表
- en: Since our program doesn't need any of these things, we don't need to add a `docs`
    directory to this project.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的程序不需要这些东西，所以我们不需要在这个项目中添加`docs`目录。
- en: The requirements.txt file
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`requirements.txt`文件'
- en: Python programs often require packages outside the standard library to operate,
    and users will need to know what to install in order for your project to run.
    You can (and probably should) put this information in the `README` file, but you
    should also put it in `requirements.txt`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序通常需要标准库之外的包才能运行，用户需要知道安装什么才能让你的项目运行。你可以（而且可能应该）将这些信息放在`README`文件中，但你也应该将它放在`requirements.txt`中。
- en: 'The format for `requirements.txt` is one library per line, like so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements.txt`的格式是每行一个库，如下所示：'
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The library names in this file should match what is used in PyPI, as this file
    can then be used by `pip` to install all the required libraries for the project,
    like so:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件中的库名称应该与PyPI中使用的名称相匹配，因为这个文件可以被`pip`用来安装项目所需的所有库，如下所示：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We don't actually have to specify `PyQt5-sip` since it's a dependency of `PyQt5`
    and will be installed automatically. We added it here to show how multiple libraries
    are specified.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上不需要指定`PyQt5-sip`，因为它是`PyQt5`的依赖项，会自动安装。我们在这里添加它是为了展示如何指定多个库。
- en: 'If specific versions of libraries are required, this can also be noted using
    version specifiers:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要特定版本的库，也可以使用版本说明符进行说明：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, we are specifying `PyQt5` version `5.12` or greater, and only
    version `4.19.4` of `PyQt5-sip`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们指定了`PyQt5`版本`5.12`或更高，并且只有`PyQt5-sip`的`4.19.4`版本。
- en: More information about the `requirements.txt` file can be found at [https://pip.readthedocs.io/en/1.1/requirements.html](https://pip.readthedocs.io/en/1.1/requirements.html).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`requirements.txt`文件的更多信息可以在[https://pip.readthedocs.io/en/1.1/requirements.html](https://pip.readthedocs.io/en/1.1/requirements.html)找到。
- en: Other files
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他文件
- en: 'These are the bare essentials of project documentation and metadata, but you
    may find some additional files useful in certain situations:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是项目文档和元数据的基本要素，但在某些情况下，你可能会发现一些额外的文件有用：
- en: '`TODO.txt`: A shortlist of bugs or missing features that need work'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TODO.txt`：需要处理的错误或缺失功能的简要列表'
- en: '`CHANGELOG.txt`: A log of the history of major project changes and releases'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CHANGELOG.txt`：主要项目变更和发布历史的日志'
- en: '`tests`: A directory containing unit tests for your module'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests`：包含模块单元测试的目录'
- en: '`scripts`: A directory containing Python or shell scripts that are useful to,
    but not part of, your module'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts`：包含对你的模块有用但不是其一部分的Python或shell脚本的目录'
- en: '`Makefile`: Some projects benefit from a scripted build process, and for that,
    a utility such as `make` can be helpful; alternatives include CMake, SCons, or
    Waf'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Makefile`：一些项目受益于脚本化的构建过程，对此，像`make`这样的实用工具可能会有所帮助；其他选择包括CMake、SCons或Waf'
- en: At this point, though, your project is ready to upload to your favorite source
    code-sharing site. In the next section, we'll look at getting it ready for PyPI.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，此时你的项目已经准备好上传到你喜欢的源代码共享站点。在下一节中，我们将看看如何为PyPI做好准备。
- en: Distributing with setuptools
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用setuptools进行分发
- en: Many times throughout this book, you have installed Python packages using `pip`.
    You probably know that `pip` downloads these packages from PyPI and installs them
    to your system, Python virtual environment, or user environment. What you may
    not know is that the tool used to create and install these packages is called
    `setuptools`, and it's readily available to us if we want to make our own packages
    for PyPI or for personal use.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的许多部分，你已经使用`pip`安装了Python包。你可能知道`pip`会从PyPI下载这些包，并将它们安装到你的系统、Python虚拟环境或用户环境中。你可能不知道的是，用于创建和安装这些包的工具称为`setuptools`，如果我们想要为PyPI或个人使用制作自己的包，它就可以随时为我们提供。
- en: Although `setuptools` is the officially recommended tool for creating Python
    packages, it is not part of the standard library. However, it *is* included in
    the default distributions for most **operating systems** (**OS**es) if you elect
    to include `pip` during installation. If for some reason you don't have `setuptools`
    installed, consult the documentation at [https://setuptools.readthedocs.io/en/latest/](https://setuptools.readthedocs.io/en/latest/)
    to see how you can install it on your platform.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`setuptools`是官方推荐的用于创建Python包的工具，但它并不是标准库的一部分。但是，如果你在安装过程中选择包括`pip`，它通常会包含在大多数操作系统的默认发行版中。如果由于某种原因你没有安装`setuptools`，请参阅[https://setuptools.readthedocs.io/en/latest/](https://setuptools.readthedocs.io/en/latest/)上的文档，了解如何在你的平台上安装它。
- en: The main task involved in using `setuptools` is writing a `setup.py` script.
    In this section, we'll learn how to write and use our `setup.py` script to generate
    distributable packages.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setuptools`的主要任务是编写一个`setup.py`脚本。在本节中，我们将学习如何编写和使用我们的`setup.py`脚本来生成可分发的包。
- en: Writing the setuptools configuration
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写setuptools配置
- en: The primary purpose of `setup.py` is to call the `setuptools.setup()` function
    with keyword arguments, which will define our project's metadata as well as how
    our project should be packaged and installed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py`的主要目的是使用关键字参数调用`setuptools.setup()`函数，这将定义我们项目的元数据以及我们的项目应该如何打包和安装。'
- en: 'So, the first thing we''ll do is import that function:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将首先导入该函数：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The remaining code in `setup.py` will be keyword arguments to `setup()`. Let's
    go through the different categories of those arguments.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py`中的剩余代码将作为`setup()`的关键字参数。让我们来看看这些参数的不同类别。'
- en: Basic metadata arguments
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本元数据参数
- en: 'The simplest arguments involve the basic metadata about the project:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的参数涉及项目的基本元数据：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we've described the package name, version, short description, project
    URL, and license, as well as the author's name and email. This information will
    be written to the package metadata and used by sites such as PyPI to build a profile
    page for your project.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经描述了包名称、版本、简短描述、项目URL和许可证，以及作者的姓名和电子邮件。这些信息将被写入包元数据，并被PyPI等网站使用，以构建项目的个人资料页面。
- en: 'For example, look at the PyPI page for PyQt5:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看一下PyQt5的PyPI页面：
- en: '![](assets/816fd19d-7d1a-4e06-88c6-53ff5541c532.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/816fd19d-7d1a-4e06-88c6-53ff5541c532.png)'
- en: Along the left-side of the page, you'll see a link to the project's home page,
    the author (with a hyperlinked email address), and the license. At the top, you
    see the project name and version, as well as a short description of the project.
    All of this kind of data can be extracted from a project's `setup.py` script.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面的左侧，你会看到一个指向项目主页的链接，作者（带有超链接的电子邮件地址）和许可证。在顶部，你会看到项目名称和版本，以及项目的简短描述。所有这些数据都可以从项目的`setup.py`脚本中提取出来。
- en: If you plan to submit a package to PyPI, please see PEP 440 at [https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/)
    for how your version number should be specified.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划向PyPI提交一个包，请参阅[https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/)上的PEP
    440，了解你的版本号应该如何指定。
- en: 'The long text you see in the main body of this page comes from the `long_description`
    argument. We could just put a long string directly into this argument, but since
    we already have such a nice `README.rst` file, why not use that here? Since `setup.py`
    is a Python script, we can just read in the file''s contents, like so:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这个页面的主体中看到的长文本来自`long_description`参数。我们可以直接将一个长字符串放入这个参数，但既然我们已经有了一个很好的`README.rst`文件，为什么不在这里使用呢？由于`setup.py`是一个Python脚本，我们可以直接读取文件的内容，就像这样：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: One advantage of using RST here is that PyPI (and many other code-sharing sites)
    will automatically render your markup into nicely-formatted HTML.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用RST的一个优点是，PyPI（以及许多其他代码共享站点）将自动将你的标记渲染成格式良好的HTML。
- en: 'If we wish to make our project easier to search for, we can include a string
    of space-separated keywords:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望使我们的项目更容易搜索，我们可以包含一串空格分隔的关键字：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this case, a person who searched for "multiplayer pyqt5" in PyPI should find
    our project.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，搜索PyPI中的“multiplayer pyqt5”的人应该能找到我们的项目。
- en: 'Finally, you can include a dictionary of project-related URLs:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以包含一个与项目相关的URL字典：
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The format is `{''label'': ''URL''}`; examples of things you might include
    here are the project''s bug tracker, documentation site, Wiki page, or source
    repository, especially if any of those are different to the home URL.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '格式为`{''label'': ''URL''}`；你可能会在这里包括项目的bug跟踪器、文档站点、Wiki页面或源代码库，特别是如果其中任何一个与主页URL不同的话。'
- en: Packages and dependencies
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包和依赖关系
- en: Apart from establishing the basic metadata, `setup()` needs information about
    the actual code that needs to be included, or the environment that needs to be
    present on the system for this package to be executed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除了建立基本元数据外，`setup()`还需要有关需要包含的实际代码或需要在系统上存在的环境的信息，以便执行此包。
- en: 'The first keyword we need to deal with here is `packages`, which defines the
    modules in our project that need to be included:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们需要处理的第一个关键字是`packages`，它定义了我们项目中需要包含的模块：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that we need to include both the `qtictactoe` module and the `qtictactoe.images`
    module explicitly; even though the `images` directory is under `qtictactoe`, it
    will not be included automatically.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要明确包括`qtictactoe`模块和`qtictactoe.images`模块；即使`images`目录位于`qtictactoe`下，也不会自动包含它。
- en: 'If we had a lot of submodules and didn''t want to explicitly list them, `setuptools`
    offers an automatic solution as well:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有很多子模块，并且不想明确列出它们，`setuptools`也提供了自动解决方案：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you want to use `find_packages`, make sure each submodule has an `__init__.py`
    file in it so that `setuputils` can identify it as a module. In this case, you'd
    need to add an `__init__.py` file to the `images` folder or it will be ignored.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用`find_packages`，请确保每个子模块都有一个`__init__.py`文件，以便`setuputils`可以将其识别为模块。在这种情况下，您需要在`images`文件夹中添加一个`__init__.py`文件，否则它将被忽略。
- en: Both approaches have advantages and drawbacks; the manual approach is more work,
    but `find_packages` may sometimes fail to identify a library in certain circumstances.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都有优点和缺点；手动方法更费力，但`find_packages`有时可能在某些情况下无法识别库。
- en: 'We also need to specify the external libraries that are needed for this project
    to run—in this case, `PyQt5`. That can be done with the `install_requires` keyword:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要指定此项目运行所需的外部库，例如`PyQt5`。可以使用`install_requires`关键字来完成：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This keyword takes a list of names for packages that must be installed for the
    program to be installed. When your program is installed using `pip`, it will use
    this list to install all dependency packages automatically. You should include
    anything that isn't part of the standard library in this list.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关键字接受一个包名列表，这些包必须被安装才能安装程序。当使用`pip`安装程序时，它将使用此列表自动安装所有依赖包。您应该在此列表中包括任何不属于标准库的内容。
- en: 'Just like the `requirements.txt` file, we can even be explicit about the version
    number of each dependency required:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`requirements.txt`文件一样，我们甚至可以明确指定每个依赖项所需的版本号：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this case, `pip` would make sure a version of PyQt5 greater than or equal
    to 5.12 is installed. If no version is specified, `pip` will install the latest
    version available from PyPI.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`pip`将确保安装大于或等于5.12的PyQt5版本。如果未指定版本，`pip`将安装PyPI提供的最新版本。
- en: 'In some cases, we might require a certain version of Python as well; for example,
    our project uses f-strings, a feature only found in Python 3.6 or greater. We
    can specify that with the `python_requires` keyword:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能还需要指定特定版本的Python；例如，我们的项目使用f-strings，这是Python 3.6或更高版本才有的功能。我们可以使用`python_requires`关键字来指定：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can also specify dependencies for optional features; for example, if we
    added an optional network-play feature to `qtictactoe`, which required the `requests`
    library, we would specify that like so:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为可选功能指定依赖项；例如，如果我们为`qtictactoe`添加了一个可选的网络游戏功能，需要`requests`库，我们可以这样指定：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `extras_require` keyword accepts a mapping of feature names (which can
    be anything you want) to lists of package names. These modules won''t be automatically
    installed when your package is, but other modules can depend on these subfeatures.
    For example, another module can specify a dependency on our project''s `NetworkPlay`
    extra keywords like so:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`extras_require`关键字接受一个特性名称（可以是任何您想要的内容）到包名称列表的映射。这些模块在安装您的包时不会自动安装，但其他模块可以依赖于这些子特性。例如，另一个模块可以指定对我们项目的`NetworkPlay`额外关键字的依赖，如下所示：'
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This would trigger a cascade of dependencies that would result in the `requests`
    library being installed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这将触发一系列依赖关系，导致安装`requests`库。
- en: Non-Python files
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非Python文件
- en: 'By default, `setuptools` will package the Python files it finds in our project,
    and other file types will be ignored. In almost any project, however, there are
    going to be non-Python files that we''re going to want to include in our distribution
    package. These files fall generally into two categories: those that are part of
    a Python module, such as our PNG files, and those that are not, such as the `README`
    file.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`setuptools`将打包在我们项目中找到的Python文件，其他文件类型将被忽略。然而，在几乎任何项目中，都会有一些非Python文件需要包含在我们的分发包中。这些文件通常分为两类：一类是Python模块的一部分，比如我们的PNG文件，另一类是不是，比如`README`文件。
- en: 'To incorporate files that are *not* part of a Python package, we need to create
    a file called `MANIFEST.in`. This file contains `include` directives for file
    paths underneath the project root. For example, if we want to include our documentation
    files, ours should look like the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含*不*是Python包的文件，我们需要创建一个名为`MANIFEST.in`的文件。此文件包含项目根目录下文件路径的`include`指令。例如，如果我们想要包含我们的文档文件，我们的文件应该如下所示：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The format is simple: the word `include` followed by a filename, path, or pattern
    that will match a set of files. All paths are relative to the project root.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 格式很简单：单词`include`后跟文件名、路径或匹配一组文件的模式。所有路径都是相对于项目根目录的。
- en: To include files that are part of a Python package, we have two choices.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含Python包的文件，我们有两种选择。
- en: 'One way is to include them in the `MANIFEST.in` file, and then set `include_package_data`
    to `True` in `setup.py`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是将它们包含在`MANIFEST.in`文件中，然后在`setup.py`中将`include_package_data`设置为`True`：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Another way to include non-Python files is to use the `package_data` keyword
    argument in `setup.py`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 包含非Python文件的另一种方法是在`setup.py`中使用`package_data`关键字参数：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This argument takes a `dict` object, where each item is a module path and a
    list of patterns that match the files included. In this case, we want to include
    all PNG files found in the `qtictactoe.images` module, and any TXT or RST files
    anywhere in the package. Keep in mind this argument only applies to files *in
    the module directory* (that is, files under `qtictactoe`). If we want to include
    files such as `README.rst` or `run.py`, those should be put in the `MANIFEST.in`
    file.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数接受一个`dict`对象，其中每个条目都是一个模块路径和一个匹配包含的文件的模式列表。在这种情况下，我们希望包括在`qtictactoe.images`模块中找到的所有PNG文件，以及包中任何位置的TXT或RST文件。请记住，这个参数只适用于*模块目录中*的文件（即`qtictactoe`下的文件）。如果我们想要包括诸如`README.rst`或`run.py`之类的文件，那些应该放在`MANIFEST.in`文件中。
- en: You can use either approach to including files, but you cannot use *both* approaches
    in the same project; if you enable `include_package_data`, the `package_data`
    directives will be ignored.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任一方法来包含文件，但您不能在同一个项目中同时使用*两种*方法；如果启用了`include_package_data`，则将忽略`package_data`指令。
- en: Executables
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可执行文件
- en: We tend to think of PyPI as a tool to install Python libraries; in fact, it
    works well for installing applications as well, and many Python applications are
    available from it. Even if you are creating a library, it's likely your library
    will ship with executable utilities, such as the `pyrcc5` and `pyuic5` utilities
    that come with PyQt5.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们倾向于将PyPI视为安装Python库的工具；事实上，它也很适合安装应用程序，并且许多Python应用程序都可以从中获取。即使你正在创建一个库，你的库很可能会随附可执行的实用程序，比如PyQt5附带的`pyrcc5`和`pyuic5`实用程序。
- en: To accommodate these, `setuputils` gives us a way to specify particular functions
    or methods as console scripts; when the package is installed, it will create a
    simple executable file, which will call that function or method when executed
    from the command line.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这些需求，`setuputils` 为我们提供了一种指定特定函数或方法作为控制台脚本的方法；当安装包时，它将创建一个简单的可执行文件，在从命令行执行时将调用该函数或方法。
- en: 'This is specified using the `entry_points` keyword:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`entry_points`关键字指定的：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `entry_points` dictionary has other uses, but the one we''re most concerned
    with is the `''console_scripts''` key. This key points to a list of strings that
    specify the functions we want set up as command-line scripts. The format for these
    strings is as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`entry_points`字典还有其他用途，但我们最关心的是`''console_scripts''`键。这个键指向一个字符串列表，指定我们想要设置为命令行脚本的函数。这些字符串的格式如下：'
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can add as many console scripts as you wish; they just need to point to
    a function or method in the package that can be run directly. Note that you *must*
    specify an actual callable here; you can't just point to a Python file to run.
    This is why we've put all the execution code under a `main()` function inside
    `__main__.py`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加尽可能多的控制台脚本；它们只需要指向包中可以直接运行的函数或方法。请注意，您*必须*在这里指定一个实际的可调用对象；您不能只是指向一个要运行的Python文件。这就是为什么我们将所有执行代码放在`__main__.py`中的`main()`函数下的原因。
- en: '`setuptools` contains many more directives to deal with less common situations;
    for a complete list, see [https://setuptools.readthedocs.io/en/latest/setuptools.html](https://setuptools.readthedocs.io/en/latest/setuptools.html).'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuptools`包含许多其他指令，用于处理不太常见的情况；有关完整列表，请参阅[https://setuptools.readthedocs.io/en/latest/setuptools.html](https://setuptools.readthedocs.io/en/latest/setuptools.html)。'
- en: Source distributions
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源码分发
- en: 'Now that `setup.py` is ready to go, we can use it to actually create our package
    distributions. There are two basic types of package distributions: `source` and
    `built`. In this section, we''ll talk about how to use **source distributions**.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`setup.py`已经准备就绪，我们可以使用它来实际创建我们的软件包分发。软件包分发有两种基本类型：`源码`和`构建`。在本节中，我们将讨论如何使用**源码分发**。
- en: A source distribution is a bundle of all the source code and extra files needed
    to build our project. It includes the `setup.py` file and is useful for distributing
    your project in a cross-platform way.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 源码分发是我们构建项目所需的所有源代码和额外文件的捆绑包。它包括`setup.py`文件，并且对于以跨平台方式分发您的项目非常有用。
- en: Creating a source distribution
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建源码分发
- en: 'To build a source distribution, open Command Prompt in your project root and
    enter this command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建源码分发，打开项目根目录中的命令提示符，并输入以下命令：
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will create a couple of directories and many files:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一些目录和许多文件：
- en: The `ProjectName.egg-info` directory (in our case, the `QTicTacToe.egg-info`
    directory) will contain several files of metadata generated from our `setup.py`
    arguments.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProjectName.egg-info`目录（在我们的情况下是`QTicTacToe.egg-info`目录）将包含从我们的`setup.py`参数生成的几个元数据文件。'
- en: The `dist` directory will contain the `tar.gz` archive file containing our distribution.
    Ours is called `QTicTacToe-1.0.tar.gz`.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dist`目录将包含包含我们分发的`tar.gz`存档文件。我们的文件名为`QTicTacToe-1.0.tar.gz`。'
- en: Take a few minutes to explore the contents of `QTicTacToe.egg-info`; you'll
    see that all the information we specified in `setup()` is there in some form.
    This directory is also included inside the source distribution.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 花几分钟时间来探索`QTicTacToe.egg-info`的内容；您会看到我们在`setup()`中指定的所有信息以某种形式存在。这个目录也包含在源码分发中。
- en: Also, take a moment to open the `tar.gz` file and see what it contains; you'll
    see all the files we specified in `MANIFEST.in`, as well as the `qtictactoe` module
    and all the files from `QTicTacToe.egg-info`. Essentially, this is a complete
    copy of our project directory.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，花点时间打开`tar.gz`文件，看看它包含了什么；你会看到我们在`MANIFEST.in`中指定的所有文件，以及`qtictactoe`模块和来自`QTicTacToe.egg-info`的所有文件。基本上，这是我们项目目录的完整副本。
- en: Linux and macOS have native support for `tar.gz` archives; on Windows, you can
    use the free 7-Zip utility. See the *Technical requirements* section for information
    about 7-Zip.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Linux和macOS原生支持`tar.gz`存档；在Windows上，您可以使用免费的7-Zip实用程序。有关7-Zip的信息，请参阅*技术要求*部分。
- en: Installing a source distribution
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装源码分发
- en: A source distribution can be installed using `pip`; to see how this works in
    a clean environment, we'll install our library in a Python **virtual environment**.
    Virtual environments are a way to create an isolated Python stack in which you
    can add or remove libraries independently of your system Python installation.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 源分发可以使用`pip`进行安装；为了在一个干净的环境中看到这是如何工作的，我们将在Python的**虚拟环境**中安装我们的库。虚拟环境是创建一个隔离的Python堆栈的一种方式，您可以在其中独立于系统Python安装添加或删除库。
- en: 'In a console window, create a new directory and then make it a virtual environment:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台窗口中，创建一个新目录，然后将其设置为虚拟环境：
- en: '[PRE50]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `virtualenv` command copies the necessary files into the given directory
    so that Python can be run, as well as some scripts to activate and deactivate
    the environment.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`virtualenv`命令将必要的文件复制到给定目录，以便可以运行Python，以及一些激活和停用环境的脚本。'
- en: 'To start using your new environment, run this command:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用您的新环境，请运行此命令：
- en: '[PRE51]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Depending on your platform, your command-line prompt may change to indicate
    that you're in a virtual environment. Now when you run `python` or Python-related
    tools such as `pip`, they will do all the operations in the virtual environment
    rather than in your system Python.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的平台，您的命令行提示可能会更改以指示您处于虚拟环境中。现在当您运行`python`或Python相关工具，如`pip`时，它们将在虚拟环境中执行所有操作，而不是在您的系统Python中执行。
- en: 'Let''s install our source distribution package:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装我们的源分发包：
- en: '[PRE52]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This command will cause `pip` to extract our source distribution and execute
    `python setup.py install` inside the project root. The `install` directive will
    download any dependencies, build an entry point executable, and copy the code
    into the directory where your Python libraries are stored (in the case of our
    virtual environment, that would be `test_env/lib/python3.7/site-packages/`). Notice
    that a fresh copy of `PyQt5` is downloaded; your virtual environment has nothing
    but Python and the standard library installed, so any dependencies we listed in
    `install_requires` will have to be installed anew.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将导致`pip`提取我们的源分发并在项目根目录内执行`python setup.py install`。`install`指令将下载任何依赖项，构建一个入口点可执行文件，并将代码复制到存储Python库的目录中（在我们的虚拟环境的情况下，那将是`test_env/lib/python3.7/site-packages/`）。请注意，`PyQt5`的一个新副本被下载；您的虚拟环境中除了Python和标准库之外没有安装任何依赖项，因此我们在`install_requires`中列出的任何依赖项都必须重新安装。
- en: After `pip` finishes, you should be able to run the `qtictactoe` command and
    launch the application successfully. This command is stored in `test_env/bin`,
    in case your OS does not automatically append the virtual environment directories
    to your `PATH`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pip`完成后，您应该能够运行`qtictactoe`命令并成功启动应用程序。该命令存储在`test_env/bin`中，以防您的操作系统不会自动将虚拟环境目录附加到您的`PATH`。
- en: 'To remove the package from the virtual environment, you can run the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要从虚拟环境中删除包，可以运行以下命令：
- en: '[PRE53]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This should clean up the sources and all the generated files.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该清理源代码和所有生成的文件。
- en: Built distributions
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建分发
- en: Source distributions are essential for developers, but they often contain many
    elements that aren't necessary for an end user, such as unit tests or example
    code. In addition to this, if the project contains compiled code (such as Python
    extensions written in C), that code will require compilation before it can be
    used on the target. To address this, `setuptools` offers a variety of **built
    distribution** types. A built distribution provides a ready-made set of files,
    which only need to be copied to the appropriate directories to use.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 源分发对开发人员至关重要，但它们通常包含许多对最终用户不必要的元素，例如单元测试或示例代码。除此之外，如果项目包含编译代码（例如用C编写的Python扩展），那么该代码在目标上使用之前将需要编译。为了解决这个问题，`setuptools`提供了各种**构建分发**类型。构建分发提供了一组准备好的文件，只需要将其复制到适当的目录中即可使用。
- en: In this section, we'll talk about how to work with built distributions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何使用构建分发。
- en: Types of built distributions
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建分发的类型
- en: The first step in creating a built distribution is determining the type of built
    distribution we want. The `setuptools` library offers a few different built distribution
    types, and we can install other libraries to add more options.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 创建构建分发的第一步是确定我们想要的构建分发类型。`setuptools`库提供了一些不同的构建分发类型，我们可以安装其他库以添加更多选项。
- en: 'The built-in types are as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 内置类型如下：
- en: '**Binary distribution**: This is a `tar.gz` file just like a source distribution,
    but unlike the source distribution it contains precompiled code (for example,
    the `qtictactoe` executable) and omits certain types of files (such as tests).
    The contents of a built distribution need to be extracted and copied to an appropriate
    location to be run.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制分发**：这是一个`tar.gz`文件，就像源分发一样，但与源分发不同，它包含预编译的代码（例如`qtictactoe`可执行文件），并省略了某些类型的文件（例如测试）。构建分发的内容需要被提取和复制到适当的位置才能运行。'
- en: '**Windows installer**: This is just like the binary distribution, except that
    it''s an executable that will launch an install wizard on Windows. The wizard
    merely serves to copy the files to the proper location for execution or library
    use.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows安装程序**：这与二进制分发类似，只是它是一个在Windows上启动安装向导的可执行文件。向导仅用于将文件复制到适当的位置以供执行或库使用。'
- en: '**RPM Package Manager** (**RPM**) **installer**: Again, this one is just like
    the binary distribution, except that it packages code in an RPM file. RPM files
    are used by package management utilities on several Linux distributions (such
    as Red Hat, CentOS, Suse, Fedora, and more).'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RPM软件包管理器**（**RPM**）**安装程序**：再次，这与二进制分发类似，只是它将代码打包在一个RPM文件中。RPM文件被用于几个Linux发行版的软件包管理工具（如Red
    Hat、CentOS、Suse、Fedora等）。'
- en: While you may find these distribution types useful in certain situations, they
    are all a bit dated in 2019; the standard way to distribute Python today is using
    a **wheel distribution**. These are the binary distribution packages you'll find
    on PyPI.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可能会发现这些分发类型在某些情况下很有用，但它们在2019年都有点过时；今天分发Python的标准方式是使用**wheel分发**。这些是您在PyPI上找到的二进制分发包。
- en: Let's look at creating and installing wheel packages.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何创建和安装wheel包。
- en: Creating a wheel distribution
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建wheel分发
- en: To create a wheel distribution, you first need to make sure the `wheel` library
    is installed from PyPI (see the *Technical requirements* section). After that,
    `setuptools` will have an additional `bdist_wheel` option.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个wheel分发，您首先需要确保从PyPI安装了`wheel`库（请参阅*技术要求*部分）。之后，`setuptools`将有一个额外的`bdist_wheel`选项。
- en: 'You can use that to create your wheel file like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下方法创建您的`wheel`文件：
- en: '[PRE54]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Just as before, this command will create the `QTicTacToe.egg-info` directory
    and populate it with files containing your project metadata. It also creates a
    `build` directory, where compiled files are staged before being compacted into
    the `wheel` file.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 就像以前一样，这个命令将创建`QTicTacToe.egg-info`目录，并用包含您项目元数据的文件填充它。它还创建一个`build`目录，在那里编译文件被分阶段地压缩成`wheel`文件。
- en: 'Under `dist`, we''ll find our completed `wheel` file. In our case, it''s called
    `QTicTacToe-1.0-py3-none-any.whl`. The format for the filename is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dist`下，我们会找到我们完成的`wheel`文件。在我们的情况下，它被称为`QTicTacToe-1.0-py3-none-any.whl`。文件名的格式如下：
- en: The project name (`QTicTacToe`).
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目名称（`QTicTacToe`）。
- en: The version (1.0).
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本（1.0）。
- en: The version of Python that is supported, whether 2, 3, or `universal` (`py3`).
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的Python版本，无论是2、3还是`universal`（`py3`）。
- en: The `ABI` tag, which indicates a specific release of Python on whose binary
    interface our project depends (`none`). This will only be used if we have compiled
    the code.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ABI`标签，它表示我们的项目依赖的Python二进制接口的特定版本（`none`）。如果我们已经编译了代码，这将被使用。'
- en: The platform (OS and CPU architecture). Ours is any because we aren't including
    any platform-specific binaries.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台（操作系统和CPU架构）。我们的是`any`，因为我们没有包含任何特定平台的二进制文件。
- en: 'Binary distributions come in three types:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制分发有三种类型：
- en: A **Universal** type has only Python and is compatible with Python 2 or 3
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用**类型只有Python，并且与Python 2或3兼容'
- en: A **Pure Python** type has only Python but is compatible with Python 2 or Python
    3
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯Python**类型只有Python，但与Python 2或Python 3兼容'
- en: A **Platform** type includes a compiled code that only runs on a particular
    platform
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台**类型包括只在特定平台上运行的已编译代码'
- en: As reflected in the distribution name, our package is of the pure Python variety
    since it contains no compiled code and only supports Python 3\. PyQt5 is an example
    of a platform package type since it includes the Qt libraries compiled for specific
    platforms.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 正如分发名称所反映的那样，我们的包是纯Python类型，因为它不包含已编译的代码，只支持Python 3。PyQt5是一个平台包类型的例子，因为它包含为特定平台编译的Qt库。
- en: Recall from [Chapter 15](77583d1b-8a70-4118-8210-b0a5f09c9603.xhtml), *PyQt
    on the Raspberry Pi*, that we could not install PyQt from PyPI on the Raspberry
    Pi because there was no `wheel` file for the Linux ARM platform. Since PyQt5 is
    a platform package type, it can only be installed on platforms for which this
    `wheel` file has been generated.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第15章](77583d1b-8a70-4118-8210-b0a5f09c9603.xhtml)，*树莓派上的PyQt*，我们无法在树莓派上从PyPI安装PyQt，因为Linux
    ARM平台上没有`wheel`文件。由于PyQt5是一个平台包类型，它只能安装在已生成此`wheel`文件的平台上。
- en: Installing a built distribution
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装构建的分发
- en: 'Just as with source distributions, we can install our wheel file using `pip`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 与源分发一样，我们可以使用`pip`安装我们的wheel文件：
- en: '[PRE55]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If you try this in a fresh virtual environment, you should find that, once again,
    PyQt5 is downloaded from PyPI and installed and that you have the `qtictactoe`
    command available afterward. There isn't much difference to the end user in the
    case of a program such as `QTicTacToe`, but in the case of a library with binary
    files to compile (such as PyQt5), it makes the set up considerably less problematic.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在一个新的虚拟环境中尝试这个，您应该会发现，PyQt5再次从PyPI下载并安装，并且您之后可以使用`qtictactoe`命令。对于像`QTicTacToe`这样的程序，对最终用户来说并没有太大的区别，但对于一个包含需要编译的二进制文件的库（如PyQt5）来说，这使得设置变得相当不那么麻烦。
- en: Of course, even a `wheel` file requires that the target system have Python and
    `pip` installed, as well as access to the internet and PyPI. This is still a lot
    to ask of many users or computing environments. In the next section, we're going
    to explore a tool that will allow us to create a standalone executable from our
    Python projects, which can run without any prerequisites.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，即使`wheel`文件也需要目标系统安装了Python和`pip`，并且可以访问互联网和PyPI。这对许多用户或计算环境来说仍然是一个很大的要求。在下一节中，我们将探讨一个工具，它将允许我们从我们的Python项目创建一个独立的可执行文件，而无需任何先决条件。
- en: Compiling with PyInstaller
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PyInstaller编译
- en: After successfully writing their first application, the most common question
    many Python programmers have is *How do I make this code into an executable?.* Unfortunately,
    there isn't a single, official answer to this question. Over the years, many projects
    have been launched to address this task (such as Py2Exe, cx _Freeze, Nuitka, and
    PyInstaller to name a few), with varying degrees of support, simplicity of use,
    and consistency of results. In terms of these qualities, the current best option
    is **PyInstaller**.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 成功编写他们的第一个应用程序后，许多Python程序员最常见的问题是*如何将这段代码制作成可执行文件？*不幸的是，对于这个问题并没有一个单一的官方答案。多年来，许多项目已经启动来解决这个任务（例如Py2Exe、cx_Freeze、Nuitka和PyInstaller等），它们在支持程度、使用简单性和结果一致性方面各有不同。在这些特性方面，目前最好的选择是**PyInstaller**。
- en: PyInstaller overview
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyInstaller概述
- en: Python is an interpreted language; instead of being compiled to machine code
    the way C or C++ is, your Python code (or an optimized version of it called **bytecode**)
    is read and executed by the Python interpreter each time you run it. This allows
    Python to have some features that make it very easy to use, but also make it hard
    to compile into machine code to provide a traditional standalone executable.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种解释语言；与C或C++编译成机器代码不同，您的Python代码（或称为**字节码**的优化版本）每次运行时都会被Python解释器读取和执行。这使得Python具有一些使其非常易于使用的特性，但也使得它难以编译成机器代码以提供传统的独立可执行文件。
- en: PyInstaller steps around this problem by packaging your script with a Python
    interpreter, as well as any libraries or binaries required for it to run. These
    things are bundled together into either a directory or a single file to provide
    a distributable application that can be copied over to any system and executed,
    even if that system doesn't have Python.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: PyInstaller通过将您的脚本与Python解释器以及运行所需的任何库或二进制文件打包在一起来解决这个问题。这些东西被捆绑在一起，形成一个目录或一个单一文件，以提供一个可分发的应用程序，可以复制到任何系统并执行，即使该系统没有Python。
- en: To see how this works, make sure you have PyInstaller installed from PyPI (see
    the *Technical requirements* section) and let's create an executable for `QTicTacToe`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这是如何工作的，请确保您已经从PyPI安装了PyInstaller（请参阅*技术要求*部分），然后让我们为`QTicTacToe`创建一个可执行文件。
- en: Note that the application packages created by PyInstaller are platform-specific
    and can only be run on an OS and CPU architecture compatible with that on which
    it was compiled. For example, if you build your PyInstaller executable on 64-bit
    Linux, it will not run on 32-bit Linux or 64-bit Windows.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，PyInstaller创建的应用程序包是特定于平台的，只能在与编译平台兼容的操作系统和CPU架构上运行。例如，如果您在64位Linux上构建PyInstaller可执行文件，则它将无法在32位Linux或64位Windows上运行。
- en: Basic command-line usage
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的命令行用法
- en: 'In theory, using PyInstaller is as simple as opening Command Prompt and typing
    this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，使用PyInstaller就像打开命令提示符并输入这个命令一样简单：
- en: '[PRE56]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In fact, let's try this with our `qt_template.py` file from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow*; copy it to an empty directory, and run
    `pyinstaller qt_template.py` in that directory.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，让我们尝试一下，使用[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)中的`qt_template.py`文件，*使用QMainWindow构建应用程序*；将其复制到一个空目录，并在该目录中运行`pyinstaller
    qt_template.py`。
- en: 'You''ll get a great deal of output to the console and find that several directories
    and files were generated:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在控制台上获得大量输出，并发现生成了几个目录和文件：
- en: The `build` and `__pycache__` directories mainly contain intermediate files
    generated during the build process. These may be helpful during debugging, but
    they are not part of the end product.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`和`__pycache__`目录主要包含在构建过程中生成的中间文件。这些文件在调试过程中可能有所帮助，但它们不是最终产品的一部分。'
- en: The `dist` directory contains our distributable output.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dist`目录包含我们的可分发输出。'
- en: The `qt_template.spec` file holds the configuration data generated by PyInstaller.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qt_template.spec`文件保存了PyInstaller生成的配置数据。'
- en: By default, PyInstaller produces a directory containing the executable file
    plus all the libraries and data files required for it to work. The entire directory
    must be copied over to another computer if you want to run the executable.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，PyInstaller会生成一个包含可执行文件以及运行所需的所有库和数据文件的目录。如果要运行可执行文件，整个目录必须复制到另一台计算机上。
- en: Enter this directory and look for an executable file called `qt_template`. If
    you run it, you should see a blank `QMainWindow` object pop open.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 进入这个目录，寻找一个名为`qt_template`的可执行文件。如果运行它，您应该会看到一个空白的`QMainWindow`对象弹出。
- en: If you'd rather just have a single file, PyInstaller can compress this directory
    into a single executable, which when run, extracts itself into a temporary location
    and runs the main executable.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢只有一个文件，PyInstaller可以将这个目录压缩成一个单独的可执行文件，当运行时，它会将自身提取到临时位置并运行主可执行文件。
- en: 'This can be accomplished with the `--onefile` argument; delete the contents
    of `dist` and `build`, and then run this command:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过`--onefile`参数来实现；删除`dist`和`build`的内容，然后运行这个命令：
- en: '[PRE57]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, under `dist`, you'll just find a single `qt_template` executable file.
    Again, run it and you'll see our blank `QMainWindow`. Keep in mind, while this
    approach is tidier, it increases the start-up time (since the application needs
    to be extracted) and may create some complications if your application opens up
    local files, as we'll see next.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`dist`下，您只会找到一个单一的`qt_template`可执行文件。再次运行它，您将看到我们的空白`QMainWindow`。请记住，虽然这种方法更整洁，但它会增加启动时间（因为应用程序需要被提取），并且如果您的应用程序打开本地文件，可能会产生一些复杂性，我们将在下面看到。
- en: If you make significant changes to your code, environment, or build specifications,
    it's a good idea to delete the `build` and `dist` directories, and possibly the
    `.spec` file.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对代码、环境或构建规范进行了重大更改，最好删除`build`和`dist`目录，可能还有`.spec`文件。
- en: Before we attempt to package `QTicTacToe`, let's take a deeper look into the
    `.spec` file.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试打包`QTicTacToe`之前，让我们深入了解一下`.spec`文件。
- en: The .spec file
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .spec文件
- en: The `.spec` file is a Python-syntax `config` file that contains all the metadata
    about our build. You can think of it as PyInstaller's answer to a `setup.py` file.
    Unlike `setup.py`, however, the `.spec` file is automatically generated. This
    happens whenever we run `pyinstaller`, using a combination of detected data from
    our script and data passed in through command-line switches. We can also just
    generate the `.spec` file (and not start the build) using the `pyi-makespec` command.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`.spec`文件是一个Python语法的`config`文件，包含了关于我们构建的所有元数据。您可以将其视为PyInstaller对`setup.py`文件的回答。然而，与`setup.py`不同，`.spec`文件是自动生成的。这是在我们运行`pyinstaller`时发生的，使用了从我们的脚本和通过命令行开关传递的数据的组合。我们也可以只生成`.spec`文件（而不开始构建）使用`pyi-makespec`命令。'
- en: 'Once generated, a `.spec` file can be edited and then passed back to `pyinstaller`
    to rebuild the distribution without having to specify command-line switches every
    time:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 生成后，可以编辑`.spec`文件，然后将其传递回`pyinstaller`，以重新构建分发，而无需每次都指定命令行开关：
- en: '[PRE58]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To see what kind of things we might edit in this file, run `pyi-makespec qt_template.py`
    again and open up `qt_template.spec` in your editor. Inside the file, you''ll
    find four kinds of objects being created: `Analysis`, `PYZ`, `EXE`, and `COLLECT`.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们可能在这个文件中编辑的内容，再次运行`pyi-makespec qt_template.py`，然后在编辑器中打开`qt_template.spec`。在文件内部，您将发现正在创建四种对象：`Analysis`、`PYZ`、`EXE`和`COLLECT`。
- en: 'The `Analysis` constructor receives information about our script, data files,
    and libraries. It uses this information to analyze the dependencies of the project
    and produces five tables of paths pointing to the files that should be included
    in the distribution. The five tables are:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`Analysis`构造函数接收有关我们的脚本、数据文件和库的信息。它使用这些信息来分析项目的依赖关系，并生成五个指向应包含在分发中的文件的路径表。这五个表是：'
- en: '`scripts`: The Python files that serve as entry points and will be converted
    into executables'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts`：作为入口点的Python文件，将被转换为可执行文件'
- en: '`pure`: The pure Python modules required by the scripts'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pure`：脚本所需的纯Python模块'
- en: '`binaries`: The binary libraries required by the scripts'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binaries`：脚本所需的二进制库'
- en: '`datas`: The non-Python data files, such as text files or images'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`datas`：非Python数据文件，如文本文件或图像'
- en: '`zipfiles`: Any zipped Python `.egg` files'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zipfiles`：任何压缩的Python`.egg`文件'
- en: 'In our file, the `Analysis` portions look something like this:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的文件中，`Analysis`部分看起来像这样：
- en: '[PRE59]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You see the name of the Python script, the path, and a lot of empty keyword
    arguments. Most of these arguments correspond to the output tables and are used
    to manually supplement the results of the analysis with things that PyInstaller
    fails to detect, including the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到Python脚本的名称、路径和许多空关键字参数。这些参数大多对应于输出表，并用于手动补充分析结果，以弥补PyInstaller未能检测到的内容，包括以下内容：
- en: '`binaries` correspond to the `binaries` table.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binaries` 对应于`binaries`表。'
- en: '`datas` corresponds to the `datas` table.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`datas` 对应于`datas`表。'
- en: '`hiddenimports` corresponds to the `pure` table.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hiddenimports` 对应于`pure`表。'
- en: '`excludes` allows us to leave out modules that may have been automatically
    included but aren''t really needed.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`excludes` 允许我们排除可能已自动包含但实际上并不需要的模块。'
- en: '`hookspath` and `runtime_hooks` allow you to manually specify PyInstaller **hooks**;
    hooks allow you to override aspects of the analysis. They''re typically used for
    dealing with troublesome dependencies.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hookspath` 和 `runtime_hooks` 允许您手动指定PyInstaller **hooks**；hooks允许您覆盖分析的某些方面。它们通常用于处理棘手的依赖关系。'
- en: 'The next object created is the `PYZ` object:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来创建的对象是`PYZ`对象：
- en: '[PRE60]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: A `PYZ` object represents a compressed archive of all the pure Python scripts
    detected in the analysis phase. All the pure Python scripts in our project will
    be compiled to bytecode (`.pyc`) files and packed into this archive.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`PYZ` 对象表示在分析阶段检测到的所有纯Python脚本的压缩存档。我们项目中的所有纯Python脚本将被编译为字节码（.pyc）文件并打包到这个存档中。'
- en: 'Note the `cipher` argument present in both `Analysis` and `PYZ`; this argument
    can be used to obfuscate our Python bytecode further using AES256 encryption.
    While it doesn''t fully prevent decryption and decompiling of the code, it can
    be a useful deterrent to the curious if you plan to distribute your code commercially.
    To use this option, specify an encryption string using the `--key` argument when
    creating the file, like so:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Analysis`和`PYZ`中都有`cipher`参数；这个参数可以使用AES256加密进一步混淆我们的Python字节码。虽然它不能完全阻止代码的解密和反编译，但如果您计划商业分发，它可以成为好奇心的有用威慑。要使用此选项，请在创建文件时使用`--key`参数指定一个加密字符串，如下所示：
- en: '[PRE61]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'After the `PYZ` section, an `EXE()` object is generated:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PYZ`部分之后，生成了一个`EXE()`对象：
- en: '[PRE62]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `EXE` object represents the executable file. The positional arguments here
    represent all the file tables we're bundling into the executable. Right now, this
    is just the compressed Python libraries and the main scripts; if we had specified
    the `--onefile` option, the other tables (`binaries`, `zipfiles`, and `datas`)
    would also be included here.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXE` 对象表示可执行文件。这里的位置参数表示我们要捆绑到可执行文件中的所有文件表。目前，这只是压缩的Python库和主要脚本；如果我们指定了`--onefile`选项，其他表（`binaries`、`zipfiles`和`datas`）也会包含在这里。'
- en: 'The keyword arguments to `EXE` allow us to control aspects of the executable
    file:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXE`的关键字参数允许我们控制可执行文件的各个方面：'
- en: '`name` is the filename of the executable'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 是可执行文件的文件名'
- en: '`debug` toggles the debugging output for the executable'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug` 切换可执行文件的调试输出'
- en: '`upx` toggles whether the executable will be compressed with **UPX**'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upx` 切换是否使用**UPX**压缩可执行文件'
- en: '`console` toggles whether to run the program in console or GUI mode in Windows
    and macOS; in Linux, it has no effect'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`console` 切换在Windows和macOS中以控制台或GUI模式运行程序；在Linux中，它没有效果'
- en: UPX is a free executable packer available for multiple platforms from [https://upx.github.io/](https://upx.github.io/).
    If you have it installed, enabling this argument can make your executables smaller.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: UPX是一个可用于多个平台的免费可执行文件打包工具，网址为[https://upx.github.io/](https://upx.github.io/)。如果您已安装它，启用此参数可以使您的可执行文件更小。
- en: 'The final phase in the process is generating a `COLLECT` object:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的最后阶段是生成一个`COLLECT`对象：
- en: '[PRE63]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This object gathers all the necessary files into the final distribution directory.
    It only runs in one-directory mode, and its positional arguments include the components
    to be included in the directory. We can also override a few other aspects of the
    folder, such as whether to use UPX on the binaries and the name of the output
    directory.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象将所有必要的文件收集到最终的分发目录中。它只在单目录模式下运行，其位置参数包括要包含在目录中的组件。我们还可以覆盖文件夹的其他一些方面，比如是否在二进制文件上使用UPX以及输出目录的名称。
- en: Now that we understand a bit more about how PyInstaller works, let's package
    QTicTacToe.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对PyInstaller的工作原理有了更多的了解，让我们来打包QTicTacToe。
- en: Preparing QTicTacToe for PyInstaller
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为PyInstaller准备QTicTacToe
- en: PyInstaller is simple enough when working with a single script, but how does
    it work with our module-style project arrangement? We cannot point PyInstaller
    at our module, as it will return an error; it needs to be pointed at a Python
    script that serves as the entry point, such as our `run.py` file.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: PyInstaller在处理单个脚本时非常简单，但是在处理我们的模块式项目安排时该如何工作呢？我们不能将PyInstaller指向我们的模块，因为它会返回一个错误；它需要指向一个作为入口点的Python脚本，比如我们的`run.py`文件。
- en: 'This seems to work:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎有效：
- en: '[PRE64]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: However, the resulting distribution and executable are now called `run`, which
    is not so great. You might be tempted to change `run.py` to `qtictactoe.py`; in
    fact, some tutorials on Python packaging recommend this arrangement (that is,
    having the `run` script the same name as the main module).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，生成的分发和可执行文件现在被称为`run`，这并不太好。您可能会想要将`run.py`更改为`qtictactoe.py`；事实上，一些关于Python打包的教程建议这种安排（即，将`run`脚本与主模块具有相同的名称）。
- en: 'If you attempt this, however, you may find you got an error such as this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您尝试这样做，您可能会发现出现以下错误：
- en: '[PRE65]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Because a Python module can be either a `.py` file or a directory, PyInstaller
    can't be sure which one constitutes the `qtictactoe` module, so having the same
    name for both will fail.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Python模块可以是`.py`文件或目录，PyInstaller无法确定哪一个构成了`qtictactoe`模块，因此两者具有相同的名称将失败。
- en: 'The correct approach is to use the `--name` switch when creating our `.spec`
    file or running `pyinstaller`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的方法是在创建我们的`.spec`文件或运行`pyinstaller`时使用`--name`开关：
- en: '[PRE66]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This will create `qtictactoe.spec` and set the `name` arguments of `EXE` and
    `COLLECT` to `qtictactoe`, like so:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建`qtictactoe.spec`并将`EXE`和`COLLECT`的`name`参数设置为`qtictactoe`，如下所示：
- en: '[PRE67]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This can, of course, be done manually by editing the `.spec` file as well.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这也可以通过手动编辑`.spec`文件来完成。
- en: Dealing with non-Python files
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理非Python文件
- en: 'Our program runs, but we''re back to the old problem of the `''X''` and `''O''`
    images not showing up. There are two problems here: first, our PNG files aren''t
    being made part of the distribution and, second, the program can''t find them
    even when they are.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序运行了，但我们又回到了`'X'`和`'O'`图像不显示的旧问题。这里有两个问题：首先，我们的PNG文件没有包含在分发中，其次，即使它们包含在分发中，程序也无法找到它们。
- en: 'To deal with the first problem, we have to tell PyInstaller to include our
    files in the `datas` table during the `Analysis` phase of the build. We can do
    that in the command line, like so:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决第一个问题，我们必须告诉PyInstaller在构建的`Analysis`阶段将我们的文件包含在`datas`表中。我们可以在命令行中这样做：
- en: '[PRE68]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `--add-data` argument takes a source path and a destination path separated
    by either a colon (on macOS and Linux) or a semicolon (on Windows). The source
    path is relative to the project root where we're running `pyinstaller` (`QTicTacToe`,
    in this case), and the destination path is relative to the distribution root folder.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`--add-data`参数接受一个源路径和一个目标路径，两者之间用冒号（在macOS和Linux上）或分号（在Windows上）分隔。源路径是相对于我们正在运行`pyinstaller`的项目根目录（在本例中为`QTicTacToe`）的，目标路径是相对于分发根文件夹的。'
- en: 'If we don''t want to make a long, complex command line, we can also update
    the `Analysis` section of the `qtictactoe.spec` file:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想使用长而复杂的命令行，我们还可以更新`qtictactoe.spec`文件的`Analysis`部分：
- en: '[PRE69]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, the source and destination paths are just a tuple inside the `datas` list.
    The source value can also be a pattern such as `qtictactoe/images/*.png`. If you
    run `pyinstaller qtictactoe.spec` with these changes, you should find an `images`
    directory in `dist/qtictactoe`, which contains our PNG files.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，源路径和目标路径只是`datas`列表中的一个元组。源值也可以是一个模式，例如`qtictactoe/images/*.png`。如果您使用这些更改运行`pyinstaller
    qtictactoe.spec`，您应该会在`dist/qtictactoe`中找到一个`images`目录，其中包含我们的PNG文件。
- en: This has solved the first problem with the images, but we still need to solve
    the second. In the *Distributing with setuptools* section, we solved the problem
    of locating our PNG files by using the `__file__` built-in variable. However,
    when you are running from a PyInstaller executable, the value of `__file__` is
    *not* the path to the executable; it's actually a path to a temporary directory
    where the executable unpacks the compressed bytecode. The location of this directory
    changes depending on whether we are in one-file or one-directory mode as well.
    To work around this problem, we'll need to update our code to detect whether the
    program has been made into an executable and, if so, use a different method to
    locate the files.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了图像的第一个问题，但我们仍然需要解决第二个问题。在*使用setuptools进行分发*部分，我们通过使用`__file__`内置变量解决了定位PNG文件的问题。但是，当您从PyInstaller可执行文件运行时，`__file__`的值*不是*可执行文件的路径；它实际上是一个临时目录的路径，可执行文件在其中解压缩字节码。此目录的位置也会根据我们是处于单文件模式还是单目录模式而改变。为了解决这个问题，我们需要更新我们的代码以检测程序是否已制作成可执行文件，并且如果是，则使用不同的方法来定位文件。
- en: 'When we run PyInstaller executables, PyInstaller adds two properties to the
    `sys` module to help us:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行PyInstaller可执行文件时，PyInstaller会向`sys`模块添加两个属性来帮助我们：
- en: The `sys.frozen` property, which is given a value of `True`
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sys.frozen`属性，其值为`True`'
- en: The `sys._MEIPASS` property, which stores the path to the executable directory
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sys._MEIPASS`属性，存储可执行目录的路径'
- en: 'Thus, we can update our code in `board.py` to something like this:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将我们的代码在`board.py`中更新为以下内容：
- en: '[PRE70]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now, when executing from a frozen PyInstaller environment, our code will be
    able to locate the files correctly. Re-run `pyinstaller qtictactoe.spec` and you
    should find that the `X` and `O` graphics display correctly. Hooray!
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在从冻结的PyInstaller环境中执行时，我们的代码将能够正确地定位文件。重新运行`pyinstaller qtictactoe.spec`，您应该会发现`X`和`O`图形正确显示。万岁！
- en: As mentioned before, the far better solution in a PyQt5 application is to use
    the Qt Resource files discussed in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml),
    *Styling Qt Applications*. For non-PyQt programs, the `setuptools` library has
    a tool called `pkg_resources` that might be helpful.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在PyQt5应用程序中更好的解决方案是使用[第6章](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml)中讨论的Qt资源文件，*Styling
    Qt Applications*。对于非PyQt程序，`setuptools`库有一个名为`pkg_resources`的工具可能会有所帮助。
- en: Further debugging
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步调试
- en: If your build continues to have trouble, there are a couple of ways to get more
    information about what's going on.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的构建继续出现问题，有几种方法可以获取更多关于正在进行的情况的信息。
- en: First, make sure your code runs correctly as a Python script. If there is a
    syntax error or other code problem in any of your module files, the distribution
    will be built without them. These omissions will neither halt the build nor be
    mentioned in the command-line output.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，确保您的代码作为Python脚本正确运行。如果在任何模块文件中存在语法错误或其他代码问题，分发将在没有它们的情况下构建。这些遗漏既不会中止构建，也不会在命令行输出中提到。
- en: 'After confirming that, check the build directory for details on what PyInstaller
    is doing. Under `build/projectname/`, you should see a number of files that can
    help you debug, including these:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 确认后，检查构建目录以获取PyInstaller正在执行的详细信息。在`build/projectname/`下，您应该看到一些文件，可以帮助您进行调试，包括这些：
- en: '`warn-projectname.txt`: This contains warnings output by the `Analysis` process.
    Some of these are meaningless (often just failures to locate platform-specific
    libraries that don''t exist on your platform), but if libraries have errors or
    are not being found, those issues will be logged here.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`warn-projectname.txt`：这个文件包含`Analysis`过程输出的警告。其中一些是无意义的（通常只是无法在您的平台上找到特定于平台的库），但如果库有错误或无法找到，这些问题将在这里记录。'
- en: '`.toc` files: These contain the tables of contents created during the phases
    of the build process; for example, `Analysis-00.toc` shows the tables found in
    `Analysis()`. You can examine these to see whether the project''s dependencies
    are being incorrectly identified or pulled from an incorrect location.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.toc`文件：这些文件包含构建过程各阶段创建的目录表；例如，`Analysis-00.toc`显示了`Analysis()`中找到的目录。您可以检查这些文件，看看项目的依赖项是否被错误地识别或从错误的位置提取。'
- en: '`base_library.zip`: This archive should contain Python bytecode files for all
    the pure Python modules used by your application. You can inspect this to see
    whether anything is missing.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base_library.zip`：此存档应包含您的应用程序使用的所有纯Python模块的Python字节码文件。您可以检查这个文件，看看是否有任何遗漏。'
- en: 'If you need more verbose output, you can use the `--log-level` switch to increase
    the detail of the output to `warn-projectname.txt`. A setting of `DEBUG` will
    provide more details:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更详细的输出，可以使用`--log-level`开关来增加输出的详细程度到`warn-projectname.txt`。设置为`DEBUG`将提供更多细节：
- en: '[PRE71]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: More debugging tips can be found at [https://pyinstaller.readthedocs.io/en/latest/when-things-go-wrong.html](https://pyinstaller.readthedocs.io/en/latest/when-things-go-wrong.html).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 更多调试提示可以在[https://pyinstaller.readthedocs.io/en/latest/when-things-go-wrong.html](https://pyinstaller.readthedocs.io/en/latest/when-things-go-wrong.html)找到。
- en: Summary
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to share your projects with others. You learned
    the optimal layout for your project directory to enable you to collaborate with
    other Python coders and Python tools. You learned how to work with `setuptools`
    to make distributable Python packages for sites such as PyPI. Finally, you learned
    how to convert your code into executables using PyInstaller.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何与他人分享您的项目。您学会了使您的项目目录具有最佳布局，以便您可以与其他Python编码人员和Python工具进行协作。您学会了如何使用`setuptools`为诸如PyPI之类的站点制作可分发的Python软件包。最后，您学会了如何使用PyInstaller将您的代码转换为可执行文件。
- en: Congratulations! You have finished this book. By now, you should feel confident
    in your ability to develop a compelling GUI application from scratch using Python
    and PyQt5\. From basic input forms to advanced network, database, and multimedia
    applications, you now have the tools to create and distribute amazing programs.
    Even with all the topics we've covered, there's still much more to discover inside
    PyQt. Keep learning, and make great things!
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经完成了这本书。到目前为止，您应该对使用Python和PyQt5从头开始开发引人入胜的GUI应用程序的能力感到自信。从基本的输入表单到高级的网络、数据库和多媒体应用程序，您现在有了创建和分发惊人程序的工具。即使我们涵盖了所有的主题，PyQt中仍有更多的发现。继续学习，创造伟大的事物！
- en: Questions
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try answering these questions to test your knowledge from this chapter:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试回答这些问题，以测试您从本章中学到的知识：
- en: You have written a PyQt application in a file called `Scan & Print Tool-box.py`.
    You want to convert this into a module-style organization; what change should
    you make?
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已经在一个名为`Scan & Print Tool-box.py`的文件中编写了一个PyQt应用程序。您想将其转换为模块化组织形式；您应该做出什么改变？
- en: Your PyQt5 database application has a set of `.sql` files containing queries
    used by the application. It worked when your app was a single script in the same
    directories as the `.sql` files, but now that you've converted it to a module-style
    organization, the queries can't be found. What should you do?
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的PyQt5数据库应用程序有一组包含应用程序使用的查询的`.sql`文件。当您的应用程序是与`.sql`文件在同一目录中的单个脚本时，它可以正常工作，但是现在您已将其转换为模块化组织形式后，无法找到查询。您应该怎么做？
- en: You're writing a detailed `README.rst` file to document your new application
    before uploading it to a code-sharing site. What characters should be used to
    underline your level 1, 2, and 3 headings, respectively?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将新应用程序上传到代码共享站点之前，您正在编写一个详细的`README.rst`文件来记录您的新应用程序。分别应使用哪些字符来下划线标记您的一级、二级和三级标题？
- en: You're creating a `setup.py` script for your project so that you can upload
    it to PyPI. You would like to include a URL for the project's FAQ page. How can
    you accomplish this?
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您正在为您的项目创建一个`setup.py`脚本，以便您可以将其上传到PyPI。您想要包括项目的常见问题解答页面的URL。您该如何实现这一点？
- en: You have specified `include_package_data=True` in your `setup.py` file, but
    for some reason, the `docs` folder is not being included in your distribution
    package. What's wrong?
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在`setup.py`文件中指定了`include_package_data=True`，但由于某种原因，`docs`文件夹没有包含在您的分发包中。出了什么问题？
- en: You ran `pyinstaller fight_fighter3.py` to package your new game as an executable.
    Something went wrong, though; where can you find a log of the build process?
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您运行了`pyinstaller fight_fighter3.py`来将您的新游戏打包为可执行文件。然而出了些问题；您在哪里可以找到构建过程的日志？
- en: Despite the name, PyInstaller cannot actually generate installer programs or
    packages for your application. Research some options for your platform of choice.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管名称如此，PyInstaller实际上不能生成安装程序或包来安装您的应用程序。请为您选择的平台研究一些选项。
- en: Further reading
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For further information, please refer to the following:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅以下内容：
- en: A tutorial on `ReStructuredText` markup can be found at [http://docutils.sourceforge.net/docs/user/rst/quickstart.html](http://docutils.sourceforge.net/docs/user/rst/quickstart.html).
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`ReStructuredText`标记的教程可以在[http://docutils.sourceforge.net/docs/user/rst/quickstart.html](http://docutils.sourceforge.net/docs/user/rst/quickstart.html)找到。
- en: More information on designing, structuring, documenting, and packaging Python
    GUI applications can be found in this author's first book, *Python GUI programming
    with Tkinter*, available from *Packt Publications*.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于设计、构建、文档化和打包Python GUI应用程序的更多信息可以在作者的第一本书《Python GUI编程与Tkinter》中找到，该书可在Packt
    Publications上获得。
- en: If you're interested in publishing a package to PyPI, see [https://blog.jetbrains.com/pycharm/2017/05/how-to-publish-your-package-on-pypi/](https://blog.jetbrains.com/pycharm/2017/05/how-to-publish-your-package-on-pypi/)
    for a tutorial on the process.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您有兴趣将软件包发布到PyPI，请参阅[https://blog.jetbrains.com/pycharm/2017/05/how-to-publish-your-package-on-pypi/](https://blog.jetbrains.com/pycharm/2017/05/how-to-publish-your-package-on-pypi/)了解发布过程的教程。
- en: A better solution to the problem of including images in a Python library for
    a non-PyQt code is the `pkg_resources` tool provided by `setuptools`. You can
    read about it at [https://setuptools.readthedocs.io/en/latest/pkg_resources.html](https://setuptools.readthedocs.io/en/latest/pkg_resources.html).
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决在非PyQt代码中包含图像的问题的更好方法是`setuptools`提供的`pkg_resources`工具。您可以在[https://setuptools.readthedocs.io/en/latest/pkg_resources.html](https://setuptools.readthedocs.io/en/latest/pkg_resources.html)上了解更多信息。
- en: Advanced usage of PyInstaller is documented in the PyInstaller manual found
    at [https://pyinstaller.readthedocs.io/en/stable/](https://pyinstaller.readthedocs.io/en/stable/).
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyInstaller的高级用法在PyInstaller手册中有详细说明，可在[https://pyinstaller.readthedocs.io/en/stable/](https://pyinstaller.readthedocs.io/en/stable/)找到。
