- en: 12\. Intermediate Calculus with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12.使用Python进行中级微积分
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to solve problems when given equations
    dealing with the change in a variable. In this chapter, you'll use numerical methods
    to model populations and temperatures and use differential equations to calculate
    their past values or predict their future values. You'll learn how to use binary
    search to *guess and check* your way to a very accurate solution when you know
    it's in a specific range of numbers. You'll also model situations where objects
    move and solve for their future positions when given differential equations for
    their velocity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够解决涉及变量变化的方程的问题。在本章中，你将使用数值方法来模拟人口和温度，并使用微分方程来计算它们的过去值或预测它们的未来值。当你知道数字在特定范围内时，你将学会使用二分搜索来*猜测和检查*，以获得非常准确的解决方案。你还将模拟物体移动的情况，并在给定它们的速度微分方程时解决它们的未来位置。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Math students often complain that there's no real-world application for the
    kinds of problems arising in algebra and geometry, such as factoring polynomials
    or bisecting angles, but the same can't be said for differential equations. Using
    the tools, you'll learn about in this chapter, you will be able to model and solve
    real-life problems in physics, electronics, and engineering with differential
    equations. Python is the perfect tool for mathematicians and scientists who want
    to be able to crunch numbers and solve problems but don't want to have to get
    another degree in computer science to do so. Python is one of the most popular
    programming languages due to its ease of use and lack of unnecessary abstraction.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 数学学生经常抱怨代数和几何中出现的问题没有现实世界的应用，比如因式分解多项式或者角的二等分，但对于微分方程却不能这样说。使用本章中将学到的工具，你将能够用微分方程模拟和解决物理、电子和工程中的真实问题。Python是数学家和科学家的完美工具，他们想要进行数字计算和解决问题，但又不想为此再获得计算机科学学位。Python是最受欢迎的编程语言之一，因为它易于使用且没有不必要的抽象。
- en: By the 1600s, mathematicians had modeled the motion of falling objects with
    mathematical equations and had set their sights on the planets in outer space.
    Newton modeled their motion and the equations he came up with referred not only
    to unknown numbers but also the changes in those numbers. For example, his equations
    didn't only contain an unknown angle, but the change in that angle (its angular
    velocity) and even the change in the change in the angle (its acceleration)! There
    were no tools for solving those equations, so he had to invent the tools himself.
    These tools became known as calculus.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到了17世纪，数学家们用数学方程模拟了物体的运动，并把目光投向了外层空间的行星。牛顿模拟了它们的运动，他提出的方程不仅涉及未知数，还涉及这些数字的变化。例如，他的方程不仅包含一个未知角度，还包含这个角度的变化（它的角速度），甚至是角度变化的变化（它的加速度）！当时没有工具来解决这些方程，所以他不得不自己发明这些工具。这些工具后来被称为微积分。
- en: Differential Equations
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微分方程
- en: 'Solving an equation in a math class usually involves an unknown number, *x*.
    The equation hides the value but gives you hints as to how to find the value,
    such as ![1](image/B15968_12_InlineEquation1.png). But to solve a differential
    equation, you''re only given information regarding the derivative of a function,
    and you''re expected to find the function. It could be something as simple as
    the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学课上解方程通常涉及一个未知数*x*。方程隐藏了这个值，但给了你一些提示，告诉你如何找到这个值，比如![1](image/B15968_12_InlineEquation1.png)。但是要解微分方程，你只能得到关于函数的导数的信息，然后期望你找到这个函数。可能是像下面这样简单的东西：
- en: '![Figure 12.1: Finding a function with derivative 2'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1：找到导数为2的函数'
- en: '](image/B15968_12_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_01.jpg)'
- en: 'Figure 12.1: Finding a function with derivative 2'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：找到导数为2的函数
- en: 'This means *find a function whose derivative is 2.* This can also be written
    as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着*找到一个导数为2的函数*。这也可以写成如下形式：
- en: '![Figure 12.2: Alternative way to represent derivative of the function'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2：表示函数导数的另一种方式'
- en: '](image/B15968_12_02.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_02.jpg)'
- en: 'Figure 12.2: Alternative way to represent derivative of the function'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：表示函数导数的另一种方式
- en: By simple integration, we can find functions that work in this equation because
    we know the function *y = 2x* has a derivative of 2\. In fact, many related functions,
    such as *y = 2x + 1*, *y = 2x + 2*, *y = 2x + 3*, and so on, all have a derivative
    of 2\. So, we write a general form, that is, *y = 2x + C*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单的积分，我们可以找到适用于这个方程的函数，因为我们知道函数*y = 2x*的导数是2。事实上，许多相关函数，比如*y = 2x + 1*，*y
    = 2x + 2*，*y = 2x + 3*等等，它们的导数都是2。所以，我们写出一个一般形式，即*y = 2x + C*。
- en: 'Things get more complicated when we don''t have much to go on, like in this
    equation:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们没有太多线索时，事情就变得更加复杂，就像在这个方程中：
- en: '![Figure 12.3: Derivative of a function whose value is the function itself'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3：函数值为函数本身的导数'
- en: '](image/B15968_12_03.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_03.jpg)'
- en: 'Figure 12.3: Derivative of a function whose value is the function itself'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：函数值为函数本身的导数
- en: This is asking for a function whose derivative is the function itself.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是要求一个导数为函数本身的函数。
- en: To understand how differential equations are used, let's start with simple functions,
    and ones involving things in the real world, such as money.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解微分方程是如何使用的，让我们从简单的函数开始，以及涉及到现实世界中的东西，比如金钱。
- en: Interest Calculations
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利息计算
- en: There's a crucial tool in the study of differential equations that originated
    in the study of interest calculations in the middle ages. Let's take a look at
    the following exercise.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 微分方程研究中有一个关键工具起源于中世纪的利息计算研究。让我们来看下面的练习。
- en: 'Exercise 12.01: Calculating Interest'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.01：计算利息
- en: A savings account pays 2% annual interest. If $3,500 is invested, how much money
    is in the account after 5 years?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个储蓄账户每年支付2%的利息。如果投资了3500美元，5年后账户中有多少钱？
- en: 'The formula for simple interest is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 简单利息的公式如下：
- en: '![Figure 12.4: Formula for simple interest'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4：简单利息公式'
- en: '](image/B15968_12_04.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_04.jpg)'
- en: 'Figure 12.4: Formula for simple interest'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：简单利息公式
- en: 'Here, *I* is the interest, *P* is the principal or the original amount invested,
    *r* is the rate of interest or growth, and *t* is the time the amount has been
    invested for. By this formula, the interest earned on the amount is *I = (3500)(0.02)(5)
    = $350*. Follow these steps to complete this exercise:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*I*是利息，*P*是本金或原始投资金额，*r*是利率或增长率，*t*是投资金额已投资的时间。根据这个公式，金额的利息为*I = (3500)(0.02)(5)
    = 350美元*。按照以下步骤完成此练习：
- en: 'This is a good opportunity to start a program that will take in an initial
    amount, interest rate, and time and output the interest earned using the preceding
    formula:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个很好的机会来开始一个程序，它将接受初始金额、利率和时间，并使用前面的公式输出利息收入：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see in the docstring of the `amount` function, it will take a starting
    amount and a rate of growth and return the amount of the investment after the
    given number of years. Let''s see the interest earned in 1-5 years:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您在`amount`函数的文档字符串中所看到的，它将接受一个起始金额和增长率，并返回给定年数后的投资金额。让我们看看1-5年内的利息收入：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here''s the output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But this isn''t really how interest works. A few times every year, we calculate
    the interest earned for that fraction of the year, add it to the principal, and
    the new principal is higher. The next interest calculation is on the higher number,
    hence the name *compound interest*. The formula for the amount after *t* years,
    given *n* compounding per year, is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是利息的真正工作方式。每年几次，我们计算该年份的利息收入，将其加到本金中，新的本金更高。下一次的利息计算是在更高的数字上，因此称为*复利*。给定*每年n次复利*的*t*年后的金额的公式如下：
- en: '![Figure 12.5: Formula to calculate the amount after t years'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5：计算t年后的金额公式'
- en: '](image/B15968_12_05.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_05.jpg)'
- en: 'Figure 12.5: Formula to calculate the amount after t years'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：计算t年后的金额公式
- en: 'Let''s change our `amount` function to the following:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`amount`函数更改为以下内容：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this function, we added the interest earned in the fraction of the year
    given by the number of compounding. If we only compound the interest once a year,
    it looks like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们添加了按复利次数给出的年份的利息收入。如果我们每年只计算一次复利，看起来是这样的：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is what we get:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们得到的：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, at the end of 5 years, we've earned $364, not just $350\. Compounding more
    often, even with the same interest rate, makes the amount grow more quickly. If
    we changed the compounding to 12 per year (compounding monthly), we'd end up with
    $3,867 after 5 years, a little more than compounding annually.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在5年结束时，我们赚了364美元，而不仅仅是350美元。即使利率相同，复利更频繁也会使金额增长更快。如果我们将复利更改为每年12次（每月复利），我们将在5年后得到3867美元，比年复利多一点。
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3dUWz7C.](https://packt.live/3dUWz7C
    )
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3dUWz7C](https://packt.live/3dUWz7C)。
- en: You can also run this example online at [https://packt.live/3iqUKCO.](https://packt.live/3iqUKCO
    )
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3iqUKCO](https://packt.live/3iqUKCO)上在线运行此示例。
- en: 'Exercise 12.02: Calculating Compound Interest – Part 1'
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.02：计算复利-第1部分
- en: '$2,000 is invested in a savings account that earns 5.5% annual interest, compounded
    monthly. How long will it take for the amount to grow to $8,000? Follow these
    steps to work this out:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个年利率为5.5%的储蓄账户中投资了2000美元，按月复利。要将金额增长到8000美元需要多长时间？按照以下步骤来解决这个问题：
- en: 'We''ll print out the first 5 years of the investment using our `amount` function
    from the previous exercise:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用我们从上一个练习中的`amount`函数打印出投资的前5年：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After 5 years, the amount is only $2,631\. To get to $8,000, we''ll have to
    go to 20 or 30 years:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5年后，金额只有2631美元。要达到8000美元，我们必须走20或30年：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sometime between 25 and 30 years, we'll get to $8,000\. The way to get more
    exact is to guess smarter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在25到30年之间的某个时候，我们将达到8000美元。更精确的方法是更聪明地猜测。
- en: 'We''ll cut the range in half and guess higher or lower based on what we get
    out. For example, the average of 25 and 30 years is 27.5, so we enter the following:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将范围减半，并根据我们得到的结果猜测更高或更低。例如，25年和30年的平均值是27.5，因此我们输入以下内容：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, we'd reach $9,000 in 27.5 years. The time to get to $8,000 must be less
    than that.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在27.5年内达到9000美元。达到8000美元的时间必须少于这个时间。
- en: 'We''ll calculate the average of 25 and 27.5 and plug that in:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将计算25和27.5的平均值并将其代入：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is the output:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s write a program to keep doing this until we find our answer. This is
    called a **binary search**. Let''s create a `bin_search` function that will take
    the name of the function we''re using, the lower and upper bounds of the range
    we''re searching over, and the target output—in this case, 8,000—as parameters:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个程序，直到找到答案为止。这称为**二分搜索**。让我们创建一个`bin_search`函数，它将使用我们正在使用的函数的名称，我们正在搜索的范围的下限和上限以及目标输出（在本例中为8000）作为参数：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here''s the critical line. It plugs the average into the function, using all
    the other required parameters, and assigns the output to the `guess` variable.
    We''ll check whether that variable is equal to our target or whether we have to
    guess higher or lower:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是关键的一行。它将平均值插入函数中，使用所有其他必需的参数，并将输出分配给`guess`变量。我们将检查该变量是否等于我们的目标，或者我们是否需要猜测更高或更低：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ll plug the lower and higher ends of our range into our function, as well
    as our target number, to get our approximation:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将我们范围的下限和上限以及我们的目标数字代入我们的函数，以获得我们的近似值：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Looks like we''ll get to $8,000 in **25 years and 4 months**. Let''s check
    that:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看起来我们将在**25年零4个月**内达到8000美元。让我们检查一下：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Sure enough, the balance after that compounding is just over $8,000:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，复利后的余额超过了8000美元：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We'll use the binary search again, but for now, let's use our code to find a
    rather important mathematical constant that comes up often in differential equations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用二分搜索，但现在，让我们使用我们的代码来找到一个在微分方程中经常出现的相当重要的数学常数。
- en: Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3iq95PV.](https://packt.live/3iq95PV
    )
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3iq95PV](https://packt.live/3iq95PV)
- en: You can also run this example online at [https://packt.live/2BpdbHI.](https://packt.live/2BpdbHI
    )
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2BpdbHI](https://packt.live/2BpdbHI)上在线运行此示例
- en: 'Exercise 12.03: Calculating Compound Interest – Part 2'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.03：计算复利-第2部分
- en: How much would you make if you invested $1 at 100% interest for 1 year, compounded
    continuously?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以100%的利率投资$1，连续复利1年，您会赚多少？
- en: 'Remember that the more frequently you compound the interest, the higher the
    final amount will be. How much do you think it will be? $1.50? $2? The principal,
    rate, and time are all 1, but what is the `comps` variable? Follow these steps
    to complete this exercise:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，复利的频率越高，最终金额就越高。您认为会是多少？$1.50？$2？本金、利率和时间都是1，但`comps`变量是什么？按照以下步骤完成这个练习：
- en: 'To approximate compounding continuously, we''ll compound the interest every
    second (*365*24*60*60* times per year):'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了近似连续复利，我们将每秒复利一次（每年*365*24*60*60*次）：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is around $2.72\. That number, 2.71828…, is the number *e*, which is the
    base of natural logarithms. It''s very useful for modeling populations in the
    natural world since animals, plants, and microorganisms don''t wait until the
    end of the month to reproduce—they do so continuously. So, when interest is compounded
    continuously or when a population is growing naturally, we''ll use this formula:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 大约是$2.72。这个数字，2.71828…，是自然对数的底数*e*。它对于模拟自然界中的人口非常有用，因为动物、植物和微生物不会等到月底才繁殖-它们是持续不断地繁殖。因此，当利息连续复利或人口自然增长时，我们将使用这个公式：
- en: '![Figure 12.6: Formula to calculate compound interest'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6：计算复利的公式'
- en: '](image/B15968_12_06.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_06.jpg)'
- en: 'Figure 12.6: Formula to calculate compound interest'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：计算复利的公式
- en: 'Let''s create a function to do this quickly. First, we''ll need to import *e*
    from the `math` module for our continuous compounding:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个函数来快速完成这个任务。首先，我们需要从`math`模块中导入*e*以进行连续复利：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a `pert` function that will plug in the initial amount or population,
    the growth rate, and the time, and return the final amount:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`pert`函数，它将插入初始金额或人口、增长率和时间，并返回最终金额：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We will return to this function throughout this chapter. For now, let's answer
    some more investment questions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中多次使用这个函数。现在，让我们回答更多的投资问题。
- en: Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2D2Q1r0.](https://packt.live/2D2Q1r0
    )
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2D2Q1r0](https://packt.live/2D2Q1r0)
- en: You can also run this example online at [https://packt.live/31G5pDQ.](https://packt.live/31G5pDQ
    )
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/31G5pDQ](https://packt.live/31G5pDQ)上在线运行此示例
- en: 'Exercise 12.04: Calculating Compound Interest – Part 3'
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.04：计算复利-第3部分
- en: 'A person borrows $5,000 at 18% annual interest compounded monthly. How much
    will the person owe after 1 year? Follow these steps to complete this exercise:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人以每月复利的18%年利率借了$5,000。1年后这个人会欠多少钱？按照以下步骤完成这个练习：
- en: 'We can just put it into our function call:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将其放入我们的函数调用中：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For comparison, let's see what would happen if the interest was compounded continuously.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，让我们看看如果利息是连续复利会发生什么。
- en: 'We''ll use our `pert` function to input `P = 5000`, `r = 0.18`, and `t = 1`
    as values:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用我们的`pert`函数输入`P = 5000`，`r = 0.18`和`t = 1`作为值：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The resulting amount is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 得到的金额如下：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/31ES5Qi.](https://packt.live/31ES5Qi
    )
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/31ES5Qi](https://packt.live/31ES5Qi)
- en: You can also run this example online at [https://packt.live/3f5j0s4.](https://packt.live/3f5j0s4
    )
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/3f5j0s4](https://packt.live/3f5j0s4)上在线运行此示例
- en: 'Exercise 12.05: Becoming a Millionaire'
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.05：成为百万富翁
- en: 'How long would it take to become a millionaire if you invested $1,000 at 8%
    annual interest compounded daily? What if the initial amount is $10,000? Follow
    these steps to complete this exercise:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以每日复利8%的年利率投资$1,000，要成为百万富翁需要多长时间？如果初始金额是$10,000呢？按照以下步骤完成这个练习：
- en: 'First, let''s define the `bin_search` function, as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们定义`bin_search`函数，如下所示：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s take some wild guesses and see what we would get if the $1,000 were
    invested for these numbers of years:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们猜一些野生的猜测，看看如果$1,000投资这些年，我们会得到多少：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here''s the output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After 50 years, you still would only have $54,000, not a million. But after
    100 years, you''d have almost 3 million:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 50年后，您仍然只有$54,000，而不是一百万。但是100年后，您将拥有近300万：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here''s the output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The answer must be somewhere between 50 and 100\. Looks like a job for our
    binary search:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 答案必须在50和100之间。看起来是我们二分搜索的任务：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We get this output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This shows that after 86.36 years, we''ll have 1 million dollars. If the initial
    investment is $10,000, then update the `guess` variable in the `bin_search` function:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这表明在86.36年后，我们将拥有100万美元。如果初始投资是$10,000，那么在`bin_search`函数中更新`guess`变量：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here''s how we''ll print out the output we want:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将打印所需输出的方法：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'So, we reach 1 million dollars in somewhere between 50 and 60 years. Let''s
    change `1000` to `10000` in our binary search function and check it:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们在50到60年之间就能达到100万美元。让我们在我们的二分搜索函数中将`1000`改为`10000`并检查一下：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We get this output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Just over 57.57 years to reach a million dollars.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 超过57.57年才能达到一百万美元。
- en: So, we've started off learning about differential equations by studying compound
    interest. An initial amount of money had a rate of interest applied to it at intervals
    of a year, a month, or a day.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们开始学习微分方程是通过研究复利来学习的。一定金额的钱每年、每月或每天都会有利息率。初始金额
- en: Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/31ycoPg.](https://packt.live/31ycoPg
    )
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/31ycoPg](https://packt.live/31ycoPg)
- en: You can also run this example online at [https://packt.live/2NMT9sX.](https://packt.live/2NMT9sX
    )
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2NMT9sX](https://packt.live/2NMT9sX)上在线运行此示例
- en: Now, we'll extend the same reasoning to amounts of people, animals, bacteria,
    and heat, which change constantly, or *continuously*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将同样的推理扩展到人、动物、细菌和热量的数量，这些数量不断变化，或者说是*连续*的。
- en: Population Growth
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 人口增长
- en: 'Differential equations are useful for finding a formula for the population
    of people, animals, and bacteria at a certain time; for example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 微分方程对于找到特定时间的人口、动物和细菌的数量的公式非常有用；例如：
- en: '![Figure 12.7: Differential equation to calculate population at time t'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7：计算时间t的微分方程'
- en: '](image/B15968_12_07.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_07.jpg)'
- en: 'Figure 12.7: Differential equation to calculate population at time t'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：计算时间t的微分方程
- en: 'This differential equation means the rate of change of *y* is proportional
    to *y*, or the population grows proportional to its amount. This is the definition
    of population growth rate: a fraction or percentage of the population. The solution
    is similar to our interest problems involving continuous compounding:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微分方程意味着*y*的变化速率与*y*成比例，或者说人口的增长与其数量成比例。这就是人口增长率的定义：人口的一部分或百分比。解决方案类似于涉及连续复利的利息问题：
- en: '![Figure 12.8: Differential equation to calculate the rate of change'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8：计算变化率的微分方程'
- en: '](image/B15968_12_08.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_08.jpg)'
- en: 'Figure 12.8: Differential equation to calculate the rate of change'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：计算变化率的微分方程
- en: 'Exercise 12.06: Calculating the Population Growth Rate – Part 1'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.06：计算人口增长率-第1部分
- en: 'In the 1980s, the annual population growth rate in Kenya was 4%. At that rate,
    how long would it take for the population to double? Follow these steps to complete
    this exercise:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在1980年代，肯尼亚的年人口增长率为4%。以这个速度，人口翻倍需要多长时间？按照以下步骤完成这个练习：
- en: 'No matter what the starting population, we''re looking for *t*, which makes
    the factor *e*rt equal to 2\. We can use our `pert` function and our binomial
    search function, with a little tweaking:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论初始人口是多少，我们都在寻找使因子*e*rt等于2的*t*。我们可以使用我们的`pert`函数和二项式搜索函数，稍作调整：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''re looking for the time, *t*, that will, with a growth rate of 4%, turn
    our initial population of 1 into 2\. We estimate it will be somewhere between
    1 and 100 years:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在寻找时间*t*，以4%的增长率将我们的初始人口从1增加到2。我们估计这个时间会在1到100年之间：
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can check that with algebra. We take the log of both sides of the equation
    and solve *t*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用代数来验证这一点。我们取方程两边的对数并解出*t*：
- en: '![Figure 12.9: Equation to solve for time (t)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.9：解决时间(t)的方程'
- en: '](image/B15968_12_09.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_09.jpg)'
- en: 'Figure 12.9: Equation to solve for time (t)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：解决时间(t)的方程
- en: 'This means that in just over 17 years, the population of Kenya will have doubled.
    We can check this with our `amount` function. In 1989, the population of Kenya
    was 21,000,000:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着在17年多一点的时间内，肯尼亚的人口将翻倍。我们可以用我们的`amount`函数来验证这一点。1989年，肯尼亚的人口为2100万：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following is the output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Yes, using a million compoundings a year, the population grows to almost 42
    million in 17.3 years.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，每年使用一百万次复利，人口在17.3年内增长到了将近4200万。
- en: In response to this, the Kenyan government made a big push to promote *family
    planning*. Did it work?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对此的回应，肯尼亚政府大力推广*计划生育*。这有效果吗？
- en: Note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2BxsfCT.](https://packt.live/2BxsfCT
    )
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2BxsfCT](https://packt.live/2BxsfCT)
- en: You can also run this example online at [https://packt.live/2Zuoy9c.](https://packt.live/2Zuoy9c
    )
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2Zuoy9c](https://packt.live/2Zuoy9c)上在线运行此示例
- en: 'Exercise 12.07: Calculating the Population Growth Rate – Part 2'
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.07：计算人口增长率-第2部分
- en: In 2010, the population of Kenya was 42.0 million. In 2019, it was 52.5 million.
    What is the population growth rate per year for that range?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，肯尼亚的人口为4200万。到2019年，人口为5250万。该范围的年人口增长率是多少？
- en: Once again, we can use our binary search function to return a growth factor,
    *r*, given the initial population (in millions), the time, *t*, and the target
    population (in millions) after 9 years.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次使用二分搜索函数，返回给定初始人口（以百万计）、时间*t*和9年后的目标人口（以百万计）的增长因子*r*。
- en: 'In the `bin_search` function, change the time to `9`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bin_search`函数中，将时间更改为`9`：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, we''ll find the annual growth rate for those 9 years. We know it''s between
    0 and 2:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将找到这9年的年增长率。我们知道它在0到2之间：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The value that is printed is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出的值如下：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The family planning program must have worked! Kenya reduced its population growth
    rate to 2.5%.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 计划生育项目一定是有效的！肯尼亚将其人口增长率降低到了2.5%。
- en: Note
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3eWKzDW.](https://packt.live/3eWKzDW
    )
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3eWKzDW](https://packt.live/3eWKzDW)
- en: You can also run this example online at [https://packt.live/31EKPUq.](https://packt.live/31EKPUq
    )
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/31EKPUq](https://packt.live/31EKPUq)上在线运行此示例
- en: Half-Life of Radioactive Materials
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放射性材料的半衰期
- en: Much like population problems, half-life problems concern a population, but
    one of atoms of radioactive materials where half the atoms change over time into
    atoms of a different substance. For example, Carbon-14 decays into Nitrogen-14,
    and it takes about 5,730 years for half the carbon to decay. This makes *radiocarbon
    dating* a crucial tool in everything from archaeology to detecting forged artworks.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与人口问题类似，半衰期问题涉及一个群体，但其中一半是放射性材料的原子，其中一半的原子随着时间变成了不同物质的原子。例如，碳-14衰变成氮-14，大约需要5730年才能使一半的碳衰变。这使得*放射性碳测年*成为从考古学到检测伪造艺术品的关键工具。
- en: 'Exercise 12.08: Measuring Radioactive Decay'
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.08：测量放射性衰变
- en: Radium-226 has a half-life of 1,600 years. How much of the radium in a given
    sample will disappear in 800 years?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 镭-226的半衰期为1600年。在给定样本中，800年内将消失多少镭？
- en: 'The differential equation meaning "*the rate of decay of a substance is proportional
    to the amount of the substance*" is expressed like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 意思是“物质的衰变速率与物质的数量成比例”的微分方程表达如下：
- en: '![Figure 12.10: Differential equation for calculating rate of decay of a substance'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.10：用于计算物质衰变速率的微分方程'
- en: '](image/B15968_12_10.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_10.jpg)'
- en: 'Figure 12.10: Differential equation for calculating rate of decay of a substance'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：用于计算物质衰变速率的微分方程
- en: 'The solution is similar to that for our population problems, except that the
    decay factor is negative, since the amount decreases:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案与我们的人口问题类似，只是衰减因子是负的，因为数量减少：
- en: '![Figure 12.11: Calculating rate of change with negative decay factor'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.11：使用负衰变因子计算变化率'
- en: '](image/B15968_12_11.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_11.jpg)'
- en: 'Figure 12.11: Calculating rate of change with negative decay factor'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：使用负衰变因子计算变化率
- en: 'This means the final amount is equal to the initial amount of time, *e*, to
    the product of a decay factor, *r*, and time, *t*. We can use our binary search
    function as if this were a population problem. We''re looking for the growth rate,
    *r*, that cuts our population in half in 1,600 years. Follow these steps to complete
    this exercise:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着最终金额等于时间的初始金额，*e*，乘以衰减因子，*r*，和时间，*t*的乘积。我们可以像解决人口问题一样使用我们的二分搜索函数。我们正在寻找在1,600年内使我们的人口减半的增长率*r*。按照以下步骤完成这个练习：
- en: 'Change *t* in the `guess =` line in the `bin_search` function to `1600`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`bin_search`函数中的`guess =`行中将`t`更改为`1600`：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, search for the growth factor, which we figure is going to be between
    -2 and 0\. Our target amount is ½ of the starting amount:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，搜索增长因子，我们认为它将在-2和0之间。我们的目标金额是起始金额的一半：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following is the output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'That''s the decay factor, *r*, for Radium-226\. All we have to do to find out
    the percentage of the sample left after 800 years is plug that into our `pert`
    function:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是镭-226的衰变因子*r*。我们要做的就是将其插入我们的`pert`函数中，以找出800年后剩下的样本的百分比：
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following is the output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: So, around 71% of the sample remains after 800 years.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，大约71%的样本在800年后仍然存在。
- en: Note
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YSzQ84.](https://packt.live/2YSzQ84
    )
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2YSzQ84](https://packt.live/2YSzQ84)
- en: You can also run this example online at [https://packt.live/2ByUwJj.](https://packt.live/2ByUwJj
    )
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2ByUwJj](https://packt.live/2ByUwJj)上在线运行此示例
- en: 'Exercise 12.09: Measuring the Age of a Historical Artifact'
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.09：测量历史文物的年龄
- en: A sample of cloth is radiocarbon-tested for age. This means the scientists measure
    how much Carbon-14 (half-life 5,730 years) has decayed into a more stable isotope.
    They find the amount of Carbon-14 remaining is 10 times that of Carbon-13\. How
    old is the cloth?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 对一块布进行了放射性碳测年。这意味着科学家们测量了有多少碳-14（半衰期5730年）衰变成了更稳定的同位素。他们发现剩下的碳-14的数量是碳-13的10倍。这块布有多大年龄？
- en: 'If Carbon-14 takes 5,730 years for half its amount to decay, we need to find
    the rate, *r*, for our Pert formula:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果碳-14需要5730年使其数量减半，我们需要找到我们的Pert公式的速率*r*：
- en: '![Figure 12.12: The Pert formula'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.12：Pert公式'
- en: '](image/B15968_12_12.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_12.jpg)'
- en: 'Figure 12.12: The Pert formula'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：Pert公式
- en: 'Follow these steps to complete this exercise:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: 'We use our binary search function to solve *r*:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用我们的二分搜索函数来解决*r*：
- en: '[PRE53]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is the line that''s changed. We put a beginning amount of `1` into the
    `pert` function, *r* will be `avg`, and `5730` will be the target time:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是更改的那一行。如果我们在`pert`函数中放入一个起始金额为`1`，*r*将是`avg`，`5730`将是目标时间：
- en: '[PRE54]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following is the output:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE55]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '*r = -0.000120968*, so our Pert formula becomes as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*r = -0.000120968*，因此我们的Pert公式变为如下：'
- en: '![Figure 12.13: Substituting the new value of r in the Pert formula'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.13：在Pert公式中替换r的新值'
- en: '](image/B15968_12_13.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_13.jpg)'
- en: 'Figure 12.13: Substituting the new value of r in the Pert formula'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：在Pert公式中替换r的新值
- en: 'This means *x* grams of Carbon-14 decayed, and 10x grams, 10 times as much,
    remains. So, the decayed amount is 1/11th or 0.091 of the whole sample. The ending
    amount is 1 – 0.091\. That makes our Pert equation as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着*x*克的碳-14衰变了，剩下的是10x克，是整个样本的10倍。因此，衰变量是整个样本的1/11或0.091。结束金额是1-0.091。这使我们的Pert方程如下：
- en: '![Figure 12.14: Pert equation with ending amount'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.14：带有结束金额的Pert方程'
- en: '](image/B15968_12_14.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_14.jpg)'
- en: 'Figure 12.14: Pert equation with ending amount'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：带有结束金额的Pert方程
- en: 'The only unknown in our equation is *t*, so we''re changing our `bin_search`
    function to guess and check strategically for the correct *t*. Go back to your
    `bin_search` function; the beginning should look like this:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们方程中唯一未知的是*t*，因此我们正在更改我们的`bin_search`函数，以便有策略地猜测和检查正确的*t*。返回到您的`bin_search`函数；开头应该是这样的：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here''s the line we''re changing. We''re plugging in 1 for the original amount,
    the long decimal is our *r*, and the average of our time range is used for the
    time. The target is 0.091 of the sample, and this will keep guessing and averaging
    until it returns the exact number of years to get to the target:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们正在更改的行。我们将1代入原始量，长小数是我们的*r*，时间范围的平均值用于时间。目标是样本的0.091，这将保持猜测和平均值，直到返回确切的年数以达到目标值：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Since it''s a decreasing function, if the guess is less than the target, we''ll
    have overshot it and the `upper` number will be replaced by the average:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于它是一个递减函数，如果猜测小于目标值，我们将会超过目标值，`upper`数字将被替换为平均值：
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Notice we changed the `if guess < target:` line. We''re looking for the number
    of years it''ll take the amount to decay from 1 to 0.91 at the given rate. We
    suspect it''s somewhere between 1 and 100,000 years. The second `print` line is
    just a check that our `pert` function confirms that after 5,730 years, the amount
    left is exactly half the original amount. Here''s the output when we run our code:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，我们更改了`if guess < target:`行。我们正在寻找从1到0.91的衰减量所需的年数，以给定的速率。我们怀疑它在1到100,000年之间。第二个`print`行只是检查我们的`pert`函数确认在5,730年后，剩余量正好是原始量的一半。当我们运行代码时，这是输出：
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: According to our calculations, the cloth is around **780 years** old.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的计算，这块布大约有**780年**的历史。
- en: So, we originally wrote this code to measure the amount of money left in an
    investment that grew at a given rate for a certain time. In this section, we applied
    this to the amount of radioactive material left in an object after decaying at
    a known rate for an unknown amount of time. This is how scientists calculate the
    age of archaeological artifacts.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们最初编写此代码是为了测量投资中剩余的金额，该投资以给定的利率增长一段时间。在本节中，我们将此应用于物体中放射性物质的剩余量，该物质以已知速率衰变，时间未知。这就是科学家计算考古文物年龄的方法。
- en: Note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3eOJJJv.](https://packt.live/3eOJJJv
    )
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3eOJJJv](https://packt.live/3eOJJJv)。
- en: You can also run this example online at [https://packt.live/38mESgn.](https://packt.live/38mESgn
    )
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/38mESgn](https://packt.live/38mESgn)上在线运行此示例。
- en: Next, we'll use the same idea but apply it to the change in the temperature
    of objects such as a cup of coffee or a human body.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用相同的思路，但将其应用于物体的温度变化，比如一杯咖啡或人体的温度。
- en: Newton's Law of Cooling
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 牛顿冷却定律
- en: 'Did you ever wonder how the **Crime Scene Investigator** (**CSI**) with the
    latex gloves on police shows can tell the time of death of the victim? Isaac Newton
    is credited with figuring out that the cooling of substances follows a differential
    equation:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经想过在警察节目中带着乳胶手套的**犯罪现场调查员**（**CSI**）如何判断受害者的死亡时间？艾萨克·牛顿被认为是发现物质冷却遵循微分方程的人：
- en: '![Figure 12.15: Differential equation for rate of change of temperature'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.15：温度变化速率的微分方程'
- en: '](image/B15968_12_15.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_15.jpg)'
- en: 'Figure 12.15: Differential equation for rate of change of temperature'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15：温度变化速率的微分方程
- en: 'See how this differential equation is slightly different than the ones we''ve
    seen before? Instead of the rate of change of the temperature of the substance
    being proportional to the temperature of the substance, this says *"the rate of
    change of the temperature of a substance is proportional to the difference between
    the temperature of the substance and the temperature of the environment."* So,
    if a cup of hot coffee is left in a hot room, its temperature is going to change
    less quickly than if it''s left in a very cold room. Similarly, we know the starting
    temperature of the body of the victim on the police show: 98.6° F.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个微分方程与我们以前看到的微分方程略有不同？这不是物质温度变化速率与物质温度成比例，而是说“物质温度变化速率与物质温度与环境温度之间的差值成比例”。因此，如果一杯热咖啡放在热的房间里，它的温度变化速度会比放在非常冷的房间里慢。同样，我们知道警察节目中受害者的体温起始温度：98.6°F。
- en: 'Exercise 12.10: Calculating the Time of Death'
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.10：计算死亡时间
- en: An investigator arrives at the scene of the crime and measures the temperature
    of the environment and the body. If the environment is 65° and the body is 80°,
    the investigator notes the time and waits an hour. The difference between the
    temperatures of the body and the environment is 15\. An hour later, the environment
    is still 65° and the body has further cooled to 75°. The difference in temperatures
    is now 10°. When did the victim die?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一名调查员到达犯罪现场并测量环境和尸体的温度。如果环境温度为65°，尸体温度为80°，调查员记录时间并等待一小时。尸体温度与环境温度的差为15度。一个小时后，环境温度仍为65°，尸体进一步冷却至75°。温度差现在为10度。受害者是何时死亡的？
- en: 'With this information, she can set up the following equation:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，她可以建立以下方程：
- en: '![Figure 12.16: Equation for calculating the time of death'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.16：计算死亡时间的方程'
- en: '](image/B15968_12_16.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_16.jpg)'
- en: 'Figure 12.16: Equation for calculating the time of death'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16：计算死亡时间的方程
- en: 'Follow these steps to complete this exercise:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成这个练习：
- en: 'We can use our binary search to find out what the decay rate for the temperature
    is. We''ll need to import `e` and make sure we have our `pert` and `average` functions:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用二分搜索来找出温度的衰减率。我们需要导入`e`并确保我们有`pert`和`average`函数：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The first part of our `bin_search` function is the same as before:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`bin_search`函数的第一部分与以前相同：
- en: '[PRE61]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here''s the important change: our original amount (the temperature difference)
    is 15 degrees, and we want to know *r*, the rate of change in our Pert formula:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里的重要变化是：我们的原始量（温度差）为15度，我们想知道*r*，即我们Pert公式中的变化率：
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here''s the output:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'That''s the rate of decay for this situation, so we know the beginning difference
    between the temperature of the body and the environment (98.6 – 65), as well as
    the final difference (10) and the rate of decay. Here''s a graph of the situation:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这种情况的衰减速率，所以我们知道了尸体温度与环境温度之间的初始差异（98.6-65），以及最终差异（10）和衰减速率。这是情况的图表：
- en: '![Figure 12.17: A graph of the cooling body'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.17：冷却体的图表'
- en: '](image/B15968_12_17.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_17.jpg)'
- en: 'Figure 12.17: A graph of the cooling body'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17：冷却体的图表
- en: 'All we need to know is the number of hours it took for that difference to decay
    to 10\. Our equation is as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要知道差异衰减到10所需的小时数。我们的方程如下：
- en: '![Figure 12.18: Number of hours taken for the difference to decay to 10'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.18：差异衰减到10所需的小时数'
- en: '](image/B15968_12_18.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_18.jpg)'
- en: 'Figure 12.18: Number of hours taken for the difference to decay to 10'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18：差异衰减到10所需的小时数
- en: 'We change our binary search function to get the time:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们改变我们的二分搜索函数来获取时间：
- en: '[PRE64]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: But if the time is too low, the difference will be too high. The easiest way
    to get around this is to make the higher *t* the *lower* part of the function
    call and the lower *t* the *upper* end of the range to search.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果时间太短，差异将太大。绕过这个最简单的方法是将更高的*t*作为函数调用的*较低*部分，将较低的*t*作为搜索范围的*上限*。
- en: 'The investigator figures the time has to be between 0 and 5 hours:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调查员推断时间必须在0到5小时之间：
- en: '[PRE65]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The output will be as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下：
- en: '[PRE66]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Almost exactly 3 hours. That looks close to the time when the *y*-value of the
    curve in the preceding graph is 10.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎正好3小时。这看起来接近前图中曲线的*y*值为10的时间。
- en: 'Let''s check that in our `pert` function. Start at a difference of 33.6 degrees
    with *r = -0.4055* and *t = 3.0*. Hopefully, we end up with 10:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在我们的`pert`函数中检查一下。从*r = -0.4055*和*t = 3.0*开始，差异为33.6度。希望最终得到10：
- en: '[PRE67]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The following is the output:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: So, now, when the star detective arrives on the scene at 2:30 a.m., the investigator
    can say, "The time of death was around 11:30 pm."
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在，当明星侦探在凌晨2:30到达现场时，调查员可以说，“死亡时间大约是晚上11:30。”
- en: Note
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/38jN68K.](https://packt.live/38jN68K
    )
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/38jN68K.](https://packt.live/38jN68K )
- en: You can also run this example online at [https://packt.live/3gefegi.](https://packt.live/3gefegi
    )
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/3gefegi.](https://packt.live/3gefegi )上在线运行此示例
- en: 'Exercise 12.11: Calculating the Rate of Change in Temperature'
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.11：计算温度变化的速率
- en: 'A cup of coffee at a perfect temperature of 175° F is left in a 72° room. We
    wait 15 minutes and measure the temperature of the coffee to find it has changed
    to 140°. At this rate, what will its temperature be 1 hour from the start? Follow
    these steps to complete this exercise:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 一杯温度为175°F的咖啡放在一个72°F的房间里。我们等待15分钟，测量咖啡的温度，发现它已经变成了140°F。按照这个速度，从开始算起1小时后它的温度会是多少？按照以下步骤完成这个练习：
- en: 'The difference starts at 103° (175-72). In 0.25 hours, it''s changed to 68°
    (140-72). Now, we can set up an equation:![Figure 12.19: Equation for calculating
    difference in the coffee''s temperature'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 差异从103°（175-72）开始。在0.25小时内，它变为68°（140-72）。现在，我们可以建立一个方程：![图12.19：计算咖啡温度差异的方程
- en: '](image/B15968_12_19.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_19.jpg)'
- en: 'Figure 12.19: Equation for calculating difference in the coffee''s temperature'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19：计算咖啡温度差异的方程
- en: 'We can change our binary search function to reflect this situation. Change
    the `guess=` line in the `bin_search` function to this:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以改变我们的二分搜索函数以反映这种情况。将`guess=`行更改为`bin_search`函数中的以下内容：
- en: '[PRE69]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Run it to find what *r* between -2 and 0 will give us a difference of 68°:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它，找出在-2和0之间的*r*将给我们带来68°的差异：
- en: '[PRE70]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here''s the output:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE71]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'That''s fast! Put that into our Pert formula with *P = 103* and *t=1*:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太快了！将其放入我们的Pert公式中，*P = 103*和*t=1*：
- en: '[PRE72]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The following is the output:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE73]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: That's the difference in 1 hour. If the room is 72°, that means the coffee will
    be *72 + 19.5 = 91.5°*.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这是1小时的差异。如果房间温度为72°，那意味着咖啡将是*72 + 19.5 = 91.5°*。
- en: Note
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3gl5p0i.](https://packt.live/3gl5p0i
    )
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 访问此特定部分的源代码，请参阅[https://packt.live/3gl5p0i.](https://packt.live/3gl5p0i )
- en: You can also run this example online at [https://packt.live/2YTdCmw.](https://packt.live/2YTdCmw
    )
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2YTdCmw.](https://packt.live/2YTdCmw )上在线运行此示例
- en: Mixture Problems
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合问题
- en: 'In algebra, there are word problems where you have to figure out how much material
    you have to add to a mixture to get a certain concentration or amount. In calculus,
    naturally, the problem has to be harder: for example, the mixture is changing;
    material is going into the mixture, and material is going out. You have to find
    out how much mixture or how much of the solvent is present after a specific amount
    of time. Let''s look at the following exercise to better understand this concept.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在代数中，有一些需要计算的文字问题，您必须计算出需要添加多少材料到混合物中才能获得特定的浓度或数量。在微积分中，自然，问题必须更难：例如，混合物正在改变；材料正在进入混合物，材料正在流出。您必须找出在特定时间后有多少混合物或溶剂。让我们看看以下练习，以更好地理解这个概念。
- en: 'Exercise 12.12: Solving Mixture Problems – Part 1'
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.12：解决混合问题-第1部分
- en: A tank contains 82 gallons of brine in which 18 pounds of salt is dissolved.
    Brine containing 3 pounds of dissolved salt per gallon flows into the tank at
    the rate of 5 gallons per minute. The mixture, which is kept uniform by stirring,
    flows out of the tank at a rate of 2 gallons per minute. How much salt is in the
    tank at the end of 39 minutes?
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 一个罐子里含有82加仑的卤水，其中溶解了18磅的盐。每分钟以5加仑的速度流入罐子的卤水中含有每加仑3磅的溶解盐。这种混合物通过搅拌保持均匀，以每分钟2加仑的速度流出罐子。39分钟后罐子里有多少盐？
- en: 'As you can imagine, this kind of problem leads to some complicated differential
    equations, and only after pages of algebra do you get an equation (usually involving
    *e* to some power) into which you can plug the time and get your final amount.
    However, using programming, we can simply start with our given starting solution
    and add and subtract whatever material the problem calls for. It''s a matter of
    keeping track of solution and solute. Follow these steps to complete this exercise:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以想象的，这种问题会导致一些复杂的微分方程，只有经过几页的代数运算，你才能得到一个方程（通常涉及到* e*的某个幂），然后你可以将时间代入并得到最终的数量。然而，使用编程，我们只需从给定的起始溶液开始，并添加和减去问题所需的任何材料。这只是一个跟踪溶液和溶质的问题。按照以下步骤完成这个练习：
- en: 'Let''s create a function to find the salt content after `t` minutes, given
    our initial conditions:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个函数，以找出在`t`分钟后的盐含量，给定我们的初始条件：
- en: '[PRE74]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, every minute, 5 more gallons of brine is being added, containing 15 pounds
    (5 gallons at 3 pounds of salt *per gallon*) of salt:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，每分钟都会添加5加仑的卤水，其中含有15磅（每加仑3磅盐*每加仑*）的盐：
- en: '[PRE75]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, 2 gallons of the brine flows out every minute, but how much salt is in
    it? That requires us to find the concentration of each gallon of brine:![Figure
    12.20: Formula to calculate the concentration of each gallon of brine'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，每分钟流出2加仑的卤水，但其中含有多少盐呢？这要求我们找出每加仑卤水的浓度：![图12.20：计算每加仑卤水浓度的公式
- en: '](image/B15968_12_20.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_20.jpg)'
- en: 'Figure 12.20: Formula to calculate the concentration of each gallon of brine'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20：计算每加仑卤水浓度的公式
- en: 'This can be easily converted into code, as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以很容易地转换为代码，如下所示：
- en: '[PRE76]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'So, the salt leaving the tank every minute will be the number of gallons of
    solution flowing out, times the concentration of salt:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，每分钟离开罐子的盐将是流出的溶液加仑数乘以盐的浓度：
- en: '[PRE77]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'After the loop finishes, we can print out the final amounts of brine and the
    salt:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环结束后，我们可以打印出卤水和盐的最终数量：
- en: '[PRE78]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To solve our problem, we simply run our `salt_content` function with *t=39*:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决我们的问题，我们只需运行我们的`salt_content`函数，*t=39*：
- en: '[PRE79]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The output is as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE80]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: That means we end up with 469 pounds of salt after 39 minutes. That number is
    very close to the analytical solution, but it's not exact. What could we do to
    get more accurate results? Remember, the idea behind *e*, the base of natural
    logarithms, is that it simulates constant change in a value, and we're only calculating
    our changes in our solution once every minute.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在39分钟后，我们最终得到469磅盐。这个数字非常接近解析解，但并不完全相同。我们该怎么做才能得到更准确的结果呢？记住，自然对数的底数*e*的背后思想是模拟值的恒定变化，而我们只是每分钟计算一次我们溶液的变化。
- en: 'Let''s introduce a variable, `frac`, that will let us calculate our changes
    in fractions of a minute:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们引入一个名为`frac`的变量，它将让我们计算分钟的变化：
- en: '[PRE81]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `frac=0.001` value in the parameters means we''ll calculate the changes
    a thousand times per minute. That means we''ll multiply the times we loop by 1,000,
    or 1/`frac`, and we''ll multiply the change in our amounts by `frac`:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数中的`frac=0.001`值表示我们将每分钟计算一千次变化。这意味着我们将循环的次数乘以1,000，或者1/`frac`，我们将我们的数量变化乘以`frac`：
- en: '[PRE82]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The output changes to the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 输出变成了以下内容：
- en: '[PRE83]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 470.7 pounds of salt is even closer to the analytical solution, and using smaller
    fractions of a minute doesn't change the output much.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 470.7磅盐甚至更接近解析解，使用更小的分钟分数并不会改变输出太多。
- en: Note
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2BlX2Tn.](https://packt.live/2BlX2Tn
    )
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2BlX2Tn](https://packt.live/2BlX2Tn)。
- en: You can also run this example online at [https://packt.live/3dSrEcm.](https://packt.live/3dSrEcm
    )
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3dSrEcm](https://packt.live/3dSrEcm)上在线运行此示例。
- en: Let's use this function on other problems.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在其他问题上使用这个函数。
- en: 'Exercise 12.13: Solving Mixture Problems – Part 2'
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.13：解决混合问题-第2部分
- en: 'A tank contains a solution of 10,000 L of brine with a concentration of 1 kg
    of salt per 100 L. Brine with 2 kg of salt per 100 L flows into the tank at a
    rate of 20 L per second. The (uniform) mixture leaves at a rate of 10 L per second.
    Find out how much salt is in the tank in 5 minutes. Follow these steps to complete
    this exercise:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 一个罐子里含有10,000升浓度为每100升1千克盐的卤水溶液。每秒以20升的速度流入罐中含有每100升2千克盐的卤水。混合物（均匀）以每秒10升的速度流出。找出在5分钟内罐中有多少盐。按照以下步骤完成这个练习：
- en: 'So, we need to do a little arithmetic to find out our initial amount of salt,
    but 1 kg of salt per 100 L is 100 kg of salt in 10,000 L, and it''s 0.4 kg of
    salt in 20 L, which is flowing into the tank. Here''s our new function:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们需要进行一些简单的算术运算来找出我们的初始盐量，但是每100升1千克盐是10,000升中的100千克盐，而流入罐中的20升中是0.4千克盐。这是我们的新函数：
- en: '[PRE84]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, let''s call the `salt_content` function:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调用`salt_content`函数：
- en: '[PRE85]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The output when we call the function is as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用函数时，输出如下：
- en: '[PRE86]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: (Remember, our numbers are all in seconds, and we want 5 minutes, hence the
    `5*60` parameter.)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: （记住，我们所有的数字都是以秒为单位的，我们想要5分钟，因此是`5*60`参数。）
- en: The output tells us there's 183 kg of salt in the solution in 5 minutes. This
    is very close to the analytical solution.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 输出告诉我们，在5分钟内溶液中有183千克盐。这非常接近解析解。
- en: 'We can simplify our task by changing the hardcoded numbers to variables, so
    when we have a problem with a different initial amount of brine, for example,
    we can just enter a different number into the function call. We''ll need variables
    for the initial amount of brine (or any solution), the initial amount of solute
    (so far, we''ve been using salt), the velocity of brine in, the velocity of salt
    in, and the velocity of brine out. Here''s how to change the function:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过将硬编码的数字更改为变量来简化我们的任务，因此当我们遇到不同初始卤水量的问题时，例如，我们只需在函数调用中输入不同的数字。我们需要变量来表示初始卤水量（或任何溶液）、溶质的初始量（到目前为止，我们一直在使用盐）、卤水的流入速度、盐的流入速度和卤水的流出速度。以下是如何更改函数的方法：
- en: '[PRE87]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, to solve the last problem, our function call would have more arguments:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要解决最后一个问题，我们的函数调用将有更多的参数：
- en: '[PRE88]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output is as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE89]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: As you can see, the output should be the same as in *step 1*. Let's apply this
    to more problems.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，输出应与*步骤1*中的相同。让我们将其应用到更多问题上。
- en: Note
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3gkTWOd.](https://packt.live/3gkTWOd
    )
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3gkTWOd.](https://packt.live/3gkTWOd )
- en: You can also run this example online at [https://packt.live/3eSWF17.](https://packt.live/3eSWF17
    )
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/3eSWF17.](https://packt.live/3eSWF17 )上在线运行此示例
- en: 'Exercise 12.14: Solving Mixture Problems – Part 3'
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.14：解决混合问题-第3部分
- en: 'A vat contains 100 L of a sugar-water mixture with 900 g of sugar. A sugar-water
    mixture containing 5 g of sugar per L enters the vat at a rate of 2 L per minute.
    Another mixture containing 10 g of sugar per L flows into the vat at a rate of
    1 L per minute. The vat is kept mixed, and the resulting mixture is drained from
    the vat at 3 L per minute. Find the amount of sugar in the vat in 1 hour. Follow
    these steps to complete this exercise:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大桶中含有100升糖水混合物，含有900克糖。每分钟以5克糖每升的速度进入大桶的糖水混合物为2升。另一个含有每升10克糖的混合物以每分钟1升的速度流入大桶。大桶保持混合，所得的混合物以每分钟3升的速度从大桶中排出。在1小时内找出大桶中的糖量。按照以下步骤完成此练习：
- en: 'The only trick here is that the total solution entering is 3 L per minute,
    and the total solute entering is 20 g per minute. Here''s the function call:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里唯一的诀窍是总溶液进入速度为每分钟3升，总溶质进入速度为每分钟20克。以下是函数调用：
- en: '[PRE90]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The output will be as follows:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE91]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The amount of solute is 705 g.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 溶质的量为705克。
- en: Note
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YRWNIl.](https://packt.live/2YRWNIl
    )
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2YRWNIl.](https://packt.live/2YRWNIl )
- en: You can also run this example online at [https://packt.live/2YRWKfD.](https://packt.live/2YRWKfD
    )
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2YRWKfD.](https://packt.live/2YRWKfD )上在线运行此示例
- en: 'Exercise 12.15: Solving Mixture Problems – Part 4'
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.15：解决混合问题-第4部分
- en: What if we added pure water? Would that make it harder or easier? Let's try
    this one.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加纯水会怎样？这会让它更难还是更容易？让我们试试这个。
- en: 'A tank contains 1,200 L of a brine mixture of water and 18 g of salt. Fresh
    water enters the tank at a rate of 15 L per minute and the tank is mixed to remain
    uniform. A pipe drains the mixture at a rate of 10 L per minute. How much salt
    is in the tank after 15 minutes? Follow these steps to complete this exercise:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 一个罐子中含有1200升水和18克盐的卤水混合物。淡水以每分钟15升的速度进入罐子，并且罐子被搅拌以保持均匀。一根管子以每分钟10升的速度排出混合物。15分钟后罐子中有多少盐？按照以下步骤完成此练习：
- en: 'We can use our `salt_content` function, but the `salt in` variable will be
    set to `0`. This makes the following function call:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用我们的`salt_content`函数，但`盐`变量将设置为`0`。这使得以下函数调用：
- en: '[PRE92]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The output for the salt content after 15 minutes is as follows:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 15分钟后的盐含量输出如下：
- en: '[PRE93]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The salt content has decreased from 18 g to 15.9 g.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 盐含量从18克减少到15.9克。
- en: Note
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2ZsLTIs.](https://packt.live/2ZsLTIs
    )
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 访问此特定部分的源代码，请参阅[https://packt.live/2ZsLTIs.](https://packt.live/2ZsLTIs )
- en: You can also run this example online at [https://packt.live/2AnLrT8.](https://packt.live/2AnLrT8
    )
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2AnLrT8.](https://packt.live/2AnLrT8 )上在线运行此示例
- en: So, we've seen several topics from differential equations that normally require
    a lot of algebraic manipulation to find an equation for the situation so that
    (presumably) we can plug in a variable and get the temperature, position, or amount
    we're looking for. Modeling using Python and running simulations as we have has
    saved us a lot of algebra and still got us very accurate answers.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了通常需要大量代数操作才能找到情况的方程的微分方程的几个主题，以便（大概）我们可以插入一个变量并获得所寻找的温度、位置或数量。使用Python进行建模和运行模拟已经为我们节省了大量的代数，并且仍然为我们提供了非常准确的答案。
- en: Euler's Method
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欧拉方法
- en: 'In undergraduate math classes, you''re taught all these algebraic methods for
    taking derivatives and integrals and solving differential equations. We didn''t
    mention Laplace transforms, which are even more complicated ways of solving differential
    equations algebraically. Now, for the dirty secret about differential equations
    they don''t tell you in school, unless you major in engineering: most differential
    equations you come across in real life have *no analytical solution*.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在大学数学课程中，您学习了所有这些代数方法来求导数和积分以及解决微分方程。我们没有提到拉普拉斯变换，这是解决微分方程的更复杂的方法。现在，关于微分方程的肮脏秘密是，除非您主修工程学，否则学校不会告诉您的是，您在现实生活中遇到的大多数微分方程都没有*解析解*。
- en: The good news is there have been numerical methods for avoiding messy algebra
    for hundreds of years, and with the invention of computers, these methods have
    become standard. Even when there is an analytical solution, numerical methods
    can be almost as accurate for practical purposes as the analytical method and
    take a fraction of the time to get a solution.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，数百年来一直有避免混乱代数的数值方法，随着计算机的发明，这些方法已经成为标准。即使存在解析解，数值方法对于实际目的几乎与解析方法一样准确，并且只需花费一小部分时间即可获得解决方案。
- en: 'The idea of Euler''s method is very simple:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 欧拉方法的思想非常简单：
- en: Start at the known point.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从已知点开始。
- en: Calculate the derivative at this point using the differential equation. This
    is the direction the curve is taking at this point.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用微分方程在此点计算导数。这是曲线在此点处的方向。
- en: Move a tiny step in the direction you calculated.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向计算出的方向迈出一小步。
- en: Repeat until you get to the end of the desired range.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复直到达到所需范围的末尾。
- en: 'Exercise 12.16: Solving Differential Equations with Euler''s Method'
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.16：使用欧拉方法解决微分方程
- en: 'You''re given the differential equation ![2](image/B15968_12_InlineEquation4.png).
    You want to know the output of the function *y = f(x)* at a specific value of
    *x*. You''re given one point on the graph: *f(0) = 1*. This means, *"the derivative
    of this function at every point is the y-value of the function at that point."*
    Remember, the derivative is the slope or the direction that point on the graph
    is heading. Euler''s method is to start at the initial value, in this case, at
    (0,1), and calculate the direction to the next point using the differential equation.
    The **Differential Equations** (**DE**) states the slope is the *y*-value, so
    we take a small step in the positive *x*-direction:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 给定微分方程![2](image/B15968_12_InlineEquation4.png)。您想知道在特定值*x*处函数*y=f(x)*的输出。您在图上给出了一个点：*f(0)
    = 1*。这意味着，“在每个点上，这个函数的导数是该点的y值。”请记住，导数是图上的点朝向或方向。欧拉方法是从初始值开始，即在这种情况下，在(0,1)，并使用微分方程计算到下一个点的方向。**微分方程**（**DE**）规定斜率是*y*值，因此我们在正*x*方向上迈出一小步：
- en: '![Figure 12.21: Taking a small step (hopefully) in the right direction'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.21：朝着正确方向迈出小步（希望如此）'
- en: '](image/B15968_12_21.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_21.jpg)'
- en: 'Figure 12.21: Taking a small step (hopefully) in the right direction'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21：朝着正确方向迈出小步（希望如此）
- en: 'The derivative is as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 导数如下：
- en: '![Figure 12.22: Derivative of the function'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.22：函数的导数'
- en: '](image/B15968_12_22.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_22.jpg)'
- en: 'Figure 12.22: Derivative of the function'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22：函数的导数
- en: 'So, *ΔY* becomes the following:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*ΔY*变为以下内容：
- en: '![Figure 12.23: Formula to calculate ΔY'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.23：计算ΔY的公式'
- en: '](image/B15968_12_23.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_23.jpg)'
- en: 'Figure 12.23: Formula to calculate ΔY'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.23：计算ΔY的公式
- en: 'It''s the product of the derivative and the stepsize. To find the next *y*-value,
    we add *ΔY* to the previous *y*-value. At the new point, we repeat this process:
    calculate the slope of the function at this point, multiply by the stepsize, and
    add that to the present *y*-value. Follow these steps:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这是导数和步长的乘积。要找到下一个*y*值，我们将*ΔY*添加到先前的*y*值。在新点上，我们重复这个过程：计算这一点的函数斜率，乘以步长，然后加到当前的*y*值上。按照以下步骤进行：
- en: 'Let''s write a Python function to do that:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个Python函数来做到这一点：
- en: '[PRE94]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'So, we know the initial `x` and `y`. We want to know `y` when `x=2`; the stepsize
    can be ½:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们知道初始的`x`和`y`。我们想知道`x=2`时的`y`；步长可以是½：
- en: '[PRE95]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The following is the output:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE96]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We no longer need the `print` statement inside the `euler` function, so comment
    it out:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不再需要`euler`函数内的`print`语句，因此将其注释掉：
- en: '[PRE97]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The first line is the result of calculating the slope, which is simply the
    *y*-value, 1, multiplying that by the stepsize, ½, and moving up that distance.
    If the derivative had been negative, we''d have moved down. On the second line,
    we multiplied the *y*-value, 1.5, by the stepsize, 0.5, and got 0.75\. We moved
    up from 0.75 to 2.25 and so on. Taking small steps in the x-direction until we
    got to our target x-value, 2, we ended up at a *y*-value of 5.0625\. We no longer
    need to print out each step, but let''s cut the stepsize in half 10 times:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一行是计算斜率的结果，即*y*值1，乘以步长½，然后向上移动该距离。如果导数为负，我们将向下移动。在第二行，我们将*y*值1.5乘以步长0.5，得到0.75。我们从0.75上升到2.25等等。在x方向上采取小步骤，直到达到目标x值2，我们最终得到*y*值5.0625。我们不再需要打印出每一步，但让我们将步长减半10次：
- en: '[PRE98]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The following is the output:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE99]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'So, the smaller the stepsize, the closer we seem to be getting to 7.37\. Here''s
    a graph of the paths of the approximations:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，步长越小，我们似乎越接近7.37。这是近似路径的图形：
- en: '![Figure 12.24: Better approximations with a smaller stepsize'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.24：使用较小的步长获得更好的近似'
- en: '](image/B15968_12_24.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_24.jpg)'
- en: 'Figure 12.24: Better approximations with a smaller stepsize'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24：使用较小的步长获得更好的近似
- en: The fourth curve (the curve to the right) is the path of our approximations
    with stepsize 1\. The third graph has stepsize ½, the second curve ¼, and the
    first curve 1/8\. We choose the ![a](image/B15968_12_InlineEquation2.png) differential
    equation because we know the algebraic solution.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 第四条曲线（右侧的曲线）是我们近似路径的步长为1的路径。第三个图形的步长为½，第二条曲线为¼，第一条曲线为1/8。我们选择![a](image/B15968_12_InlineEquation2.png)微分方程，因为我们知道代数解。
- en: 'When *x* is 2, *e*2 *= 7.389*. Adding the actual curve of *y=e*x (the first
    curve on the left), we can see that the smaller the stepsize, the closer the approximations
    get to the actual curve:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 当*x*为2时，*e*2 *= 7.389*。添加*y=e*x*的实际曲线（左侧的第一条曲线），我们可以看到步长越小，近似值越接近实际曲线：
- en: '![Figure 12.25: The actual curve added to the left side of the first curve'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.25：实际曲线添加到第一条曲线的左侧'
- en: '](image/B15968_12_25.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_25.jpg)'
- en: 'Figure 12.25: The actual curve added to the left side of the first curve'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25：实际曲线添加到第一条曲线的左侧
- en: But the last approximation, with stepsize 0.001953125, took 1,024 steps between
    0 and 2\. It's easy to see why Euler's method wasn't preferred to algebraic methods
    before the invention of the computer.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 但是最后的近似值，步长为0.001953125，需要在0和2之间进行1,024步。很容易理解为什么在计算机发明之前，欧拉方法不如代数方法受欢迎。
- en: Note
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2VEQiaa.](https://packt.live/2VEQiaa
    )
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2VEQiaa](https://packt.live/2VEQiaa)。
- en: You can also run this example online at [https://packt.live/2ByZvtv.](https://packt.live/2ByZvtv
    )
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2ByZvtv](https://packt.live/2ByZvtv)上在线运行此示例。
- en: 'Exercise 12.17: Using Euler''s Method to Evaluate a Function'
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.17：使用欧拉方法评估函数
- en: 'Use Euler''s method and stepsize 0.001 on the **initial value problem** (**IVP**):'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在**初始值问题**（**IVP**）上使用欧拉方法和步长0.001：
- en: '![Figure 12.26: Euler''s method on initial VP'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.26：欧拉方法在初始VP上'
- en: '](image/B15968_12_26.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_26.jpg)'
- en: 'Figure 12.26: Euler''s method on initial VP'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.26：欧拉方法在初始VP上
- en: 'Here, *y(0) = 1* in order to calculate the approximate solution *y(x)* for
    when *x = 0.3*:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*y(0) = 1*，以便计算近似解*y(x)*，当*x=0.3*时：
- en: 'In the `euler` function, enter the differential equation in the `slope=` line:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`euler`函数中，在`slope=`行中输入微分方程：
- en: '[PRE100]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Enter the proper parameters in the function call:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数调用中输入适当的参数：
- en: '[PRE101]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The output should be as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '[PRE102]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This means that by taking tiny steps from our known point (0,1) going in the
    direction specified by the differential equation, we were able to predict that
    1.49 is the approximate *y*-value corresponding to the x-value 0.3.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着通过从我们已知的点(0,1)开始，按微分方程指定的方向迈出微小步骤，我们能够预测1.49是对应于x值0.3的近似*y*值。
- en: Note
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3inHj6S.](https://packt.live/3inHj6S
    )
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3inHj6S.](https://packt.live/3inHj6S )
- en: You can also run this example online at [https://packt.live/2VFLEbF.](https://packt.live/2VFLEbF
    )
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2VFLEbF.](https://packt.live/2VFLEbF )上在线运行此示例
- en: Runge-Kutta Method
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Runge-Kutta方法
- en: Since Euler's method is based only on the derivative at each point, it has the
    problem of always overshooting or undershooting the true curve. Not surprisingly,
    in the centuries since Euler's method was invented, improvements have been made
    to offset its drawbacks. One such improvement is the **Runge-Kutta** (**RK**)
    method, which averages together four approximations, one of which is Euler's method,
    using the beginning of the interval, another using the end of the interval, and
    two other approximations using the midpoint of the interval. When averaged together,
    the approximations at the midpoint are given a higher weight.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Euler方法仅基于每个点的导数，它存在一个问题，即始终超出或低于真实曲线。毫不奇怪，在Euler方法被发明的几个世纪以来，已经对其进行了改进以抵消其缺点。其中一种改进是**Runge-Kutta**（**RK**）方法，它将四个近似值平均在一起，其中之一是Euler方法，使用区间的开始，另一个使用区间的结束，另外两个近似值使用区间的中点。当这些近似值平均在一起时，中点的近似值被赋予更高的权重。
- en: 'Here are the equations when the DE is given, *f(x,y)*, the starting *x* and
    *y*, *x*0 and *y*0, and the step size, *h*:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是当DE给出时的方程，*f(x,y)*，起始*x*和*y*，*x*0和*y*0，以及步长*h*：
- en: '![Figure 12.27: Equations when f(x,y) is given'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.27：给出f(x,y)时的方程'
- en: '](image/B15968_12_27.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_27.jpg)'
- en: 'Figure 12.27: Equations when f(x,y) is given'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.27：给出f(x,y)时的方程
- en: 'For the next *y*, we average together the four preceding approximations, with
    double the weight on *k*2 and *k*3:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个*y*，我们将前面四个近似值平均在一起，*k*2和*k*3的权重加倍：
- en: '![Figure 12.28: Formula for averaging the 4 preceding approximations'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.28：对前4个近似值进行平均的公式'
- en: '](image/B15968_12_28.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_28.jpg)'
- en: 'Figure 12.28: Formula for averaging the 4 preceding approximations'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.28：对前4个近似值进行平均的公式
- en: 'Then, of course, *x* is incremented by *h*:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当然，*x*增加了*h*：
- en: '![Figure 12.29: Incrementing x by h'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.29：将x增加h'
- en: '](image/B15968_12_29.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_29.jpg)'
- en: 'Figure 12.29: Incrementing x by h'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.29：将x增加h
- en: This is a lot to code, but its power is impressive.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一大堆代码，但它的功能令人印象深刻。
- en: 'Exercise 12.18: Implementing the Runge-Kutta Method'
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.18：实现Runge-Kutta方法
- en: 'Use the Runge-Kutta method and stepsize 0.2 on the IVP:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在IVP上使用Runge-Kutta方法和步长0.2：
- en: '![Figure 12.30: Runge Kutta method with stepsize 0.2'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.30：步长为0.2的Runge-Kutta方法'
- en: '](image/B15968_12_30.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_30.jpg)'
- en: 'Figure 12.30: Runge Kutta method with stepsize 0.2'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.30：步长为0.2的Runge-Kutta方法
- en: 'First, we define the differential equation. Let''s call it `deriv(x,y)`:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义微分方程。让我们称之为`deriv(x,y)`：
- en: '[PRE103]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Now, we''ll define the Runge-Kutta method, calling it `rk4`:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将定义Runge-Kutta方法，称之为`rk4`：
- en: '[PRE104]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'When we start at *y(0) = 0* and we want *y(1)* using a stepsize of 0.2, here''s
    what we call:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们从*y(0) = 0*开始，并且我们想要使用步长为0.2来计算*y(1)*时，这就是我们所说的：
- en: '[PRE105]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Our progress is printed out as follows:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的进展如下打印出来：
- en: '[PRE106]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The same problem using the same stepsize, but using Euler''s method, is less
    accurate. In the `euler` function, change the `slope=` line to match the new differential
    equation:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的步长解决相同的问题，但使用Euler方法的准确性较低。在`euler`函数中，将`slope=`行更改为匹配新微分方程：
- en: '[PRE107]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Now, we print out the solution using Euler''s method:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用Euler方法打印出解决方案：
- en: '[PRE108]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The following is the output:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE109]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This isn''t very close to the Runge-Kutta solution. However, the Runge-Kutta
    improvement may have been more useful before computers, because we can simply
    decrease the step size in Euler''s method and get a much better approximation.
    This is the same output for Euler''s method with a stepsize of 0.001:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这与Runge-Kutta解决方案并不十分接近。然而，在计算机出现之前，Runge-Kutta改进可能更有用，因为我们可以简单地减小Euler方法中的步长并获得更好的近似值。这是步长为0.001的Euler方法的相同输出：
- en: '[PRE110]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The following is the output:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE111]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This has been a brief look at the *numerical methods* used to solve equations,
    not by doing algebra but by feeding the starting point into a computer program
    and taking small steps in the direction indicated by the differential equations.
    This is an enormous field of calculus, especially now that free software and programming
    languages, coupled with fast computer processors, make easy work of previously
    laborious calculations.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对用于解方程的*数值方法*的简要介绍，不是通过代数来解决，而是通过将起始点输入计算机程序并按微分方程指示的方向迈出小步来解决。这是微积分的一个庞大领域，特别是现在免费软件和编程语言，再加上快速的计算机处理器，使以前费力的计算变得轻松。
- en: Note
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3eWxF95.](https://packt.live/3eWxF95
    )
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3eWxF95.](https://packt.live/3eWxF95 )
- en: You can also run this example online at [https://packt.live/3dUlkkg.](https://packt.live/3dUlkkg
    )
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3dUlkkg.](https://packt.live/3dUlkkg )上在线运行此示例
- en: Pursuit Curves
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 追踪曲线
- en: A big topic in calculus is the pursuit curve, which is the path traced by an
    agent pursuing a moving target. Since the pursuer moves directly toward its target,
    and then the target moves, this situation leads to all kinds of differential equations.
    The algebra can get very ugly, and that's why calculus professors love the topic.
    However, as we know, differential equations are usually about finding a general
    algebraic solution, that is, a function, not a number. In theory, we then plug
    values into the function to find the location of a particle or the temperature
    of a room at a specific time. Using Python, we skip the algebraic step by modeling
    the situation and finding a numerical solution. What we lose in generality, we
    gain in ease of computation.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分中的一个重要话题是追踪曲线，这是一个代理追逐移动目标所经过的路径。由于追逐者直接朝向目标移动，然后目标移动，这种情况导致了各种微分方程。代数可能会变得非常丑陋，这就是微积分教授喜欢这个话题的原因。然而，正如我们所知，微分方程通常是关于寻找一般代数解的，也就是一个函数，而不是一个数字。理论上，我们可以将值代入函数中，以找到特定时间的粒子位置或房间的温度。使用Python，我们通过对情况进行建模并找到数值解来跳过代数步骤。我们在一般性上失去了一些东西，但在计算的便利性上获得了一些东西。
- en: 'Exercise 12.19: Finding Where the Predator Catches the Prey'
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.19：找到捕食者捕捉猎物的位置
- en: A rabbit starts at (0,0) and runs in the positive *y*-direction at 1 unit per
    second. A fox starts at (20,0) and pursues the rabbit, running 1.5 times as fast
    as the rabbit. At what *y*-value does the fox catch the rabbit?
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 一只兔子从(0,0)开始，以每秒1单位的正*y*方向奔跑。一只狐狸从(20,0)开始追逐兔子，奔跑速度是兔子的1.5倍。狐狸在什么*y*值处追到兔子？
- en: 'Perform the following steps:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'First, we''ll need some functions from the `math` module to measure distance
    and angles:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要从`math`模块中获取一些函数来测量距离和角度：
- en: '[PRE112]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We''ll write a function to measure the distance between the predator''s position
    and the prey''s position using the Pythagorean Theorem:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将编写一个函数，使用毕达哥拉斯定理来测量捕食者位置和猎物位置之间的距离：
- en: '[PRE113]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The key is that the change in *y* over the change in *x* between the locations
    of the prey and the predator represents the tangent of the angle we want. We know
    their locations, so we use the inverse tangent function, called `atan2`, to calculate
    the angle so that the predator points directly at the prey. All we really want
    is to know how much to change the predator''s *x*- and *y*-coordinates for them
    to move 1 unit toward the prey. To turn the predator toward the prey, we need
    to find the angle between the two points, as shown in the following diagram:![Figure
    12.31: The angle between predator and prey'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关键在于猎物和捕食者位置之间*y*的变化与*x*的变化代表我们想要的角度的正切。我们知道它们的位置，因此我们使用反正切函数`atan2`来计算角度，使得捕食者直接指向猎物。我们真正想知道的是如何改变捕食者的*x*和*y*坐标，使其朝着猎物移动1单位。为了使捕食者朝着猎物转向，我们需要找到两点之间的角度，如下图所示：![图12.31：捕食者和猎物之间的角度
- en: '](image/B15968_12_31.jpg)'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_31.jpg)'
- en: 'Figure 12.31: The angle between predator and prey'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.31：捕食者和猎物之间的角度
- en: 'Once we know the change, we can multiply the vector by whatever velocity we
    want:'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们知道变化，我们就可以将向量乘以我们想要的任何速度：
- en: '[PRE114]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: We calculate the change in `x` and `y`, calculate the angle using the `arctangent`
    function, and then we use cosine and sine to find the corresponding changes in
    the predator's *x*- and *y*-coordinates so that it walks one unit toward the prey.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算`x`和`y`的变化，使用`arctangent`函数计算角度，然后我们使用余弦和正弦来找到捕食者*x*和*y*坐标的相应变化，使其朝着猎物走一步。
- en: 'Now, the chase can begin. We start the predator and prey at their stated locations.
    Then, we start a loop where we move the prey one unit (or an increment of that
    for more accuracy):'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，追逐可以开始了。我们将捕食者和猎物放在它们所在的位置。然后，我们开始一个循环，其中我们将猎物移动一单位（或更准确的增量）：
- en: '[PRE115]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Now, we run the chase and print out the *y*-value where the predator catches
    the prey:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们运行追逐并打印出捕食者捕捉猎物的*y*值：
- en: '[PRE116]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The output is as follows:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE117]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This is extremely close to the theoretical value of 24.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常接近理论值24。
- en: Note
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3f6x44Z.](https://packt.live/3f6x44Z
    )
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3f6x44Z.](https://packt.live/3f6x44Z )
- en: You can also run this example online at [https://packt.live/2NO1A7v.](https://packt.live/2NO1A7v
    )
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2NO1A7v.](https://packt.live/2NO1A7v )上在线运行此示例
- en: 'Exercise 12.20: Using Turtles to Visualize Pursuit Curves'
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.20：使用乌龟可视化追踪曲线
- en: 'In this exercise, we''ll visualize the path of the predator and prey, which
    is called the *pursuit curve*. There''s a built-in module in Python, based on
    the virtual turtles of the Logo programming language, that makes it easy to create
    virtual agents that can walk around the screen according to the code we write.
    Follow these steps to complete this exercise:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将可视化捕食者和猎物的路径，这被称为*追踪曲线*。Python中有一个内置模块，基于Logo编程语言的虚拟乌龟，可以根据我们编写的代码轻松创建可以在屏幕上四处走动的虚拟代理。按照以下步骤完成这个练习：
- en: 'First, we import the functions from the `turtle` module:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从`turtle`模块导入函数：
- en: '[PRE118]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'We set up the size of the screen according to the desired lower-left point,
    which we''ll make (-30, -30), and the upper-right point, which we''ll make (40,40):'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们根据所需的左下点设置屏幕的大小，我们将其设置为(-30，-30)，并设置右上点，我们将其设置为(40,40)：
- en: '[PRE119]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Setting up the predator and prey means creating a `Turtle` object and setting
    its color, position, and speed. The turtle leaves paths when it walks, so we tell
    it `penup` to keep it from drawing until it gets to its starting location. Then,
    we tell it `pendown` so that it will start drawing:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置捕食者和猎物意味着创建一个`Turtle`对象并设置其颜色、位置和速度。乌龟在行走时会留下路径，所以我们告诉它`penup`，以防止它在到达起始位置之前绘制。然后，我们告诉它`pendown`，这样它就会开始绘制：
- en: '[PRE120]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'We set up the prey by making the turtle green and giving it the shape of a
    turtle:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过使乌龟变成绿色并赋予它乌龟的形状来设置猎物：
- en: '[PRE121]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The `pursue` function should look familiar, but it has built-in functions to
    calculate the distance and even for pointing at another turtle:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pursue`函数应该看起来很熟悉，但它有内置函数来计算距离，甚至指向另一个乌龟：'
- en: '[PRE122]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'We''ll execute the `pursue` function and then once it prints the output, we''ll
    tell it the program is done so that the graphics window doesn''t freeze:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将执行`pursue`函数，然后一旦它打印输出，我们会告诉程序完成，这样图形窗口就不会冻结：
- en: '[PRE123]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'If you run this, you can watch the chase. Here''s what the final output should
    look like:![Figure 12.32: The path of the predator is a logarithmic curve'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你运行这个，你可以观看追逐。这是最终输出应该看起来像的：![图12.32：捕食者的路径是一个对数曲线
- en: '](image/B15968_12_32.jpg)'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_32.jpg)'
- en: 'Figure 12.32: The path of the predator is a logarithmic curve'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.32：捕食者的路径是一个对数曲线
- en: '**Extension**: Change the prey''s path into a circle. After the line to make
    the prey move forward, add this line:'
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**扩展**：将猎物的路径改为圆形。在使猎物向前移动的行后，添加这行：'
- en: '[PRE124]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'This will make the prey turn left a fraction of a degree every step. But if
    the turn is the same every time, it''ll eventually make a circle. The resulting
    path looks like this:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使猎物每一步左转一小部分度数。但是如果每次转弯都是一样的，最终会形成一个圆。结果路径看起来像这样：
- en: '![Figure 12.33: The pursuit curve when the prey is fleeing in a circular path'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.33：当猎物沿着圆形路径逃离时的追逐曲线'
- en: '](image/B15968_12_33.jpg)'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_33.jpg)'
- en: 'Figure 12.33: The pursuit curve when the prey is fleeing in a circular path'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.33：当猎物沿着圆形路径逃离时的追逐曲线
- en: Note
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3dWHDG6.](https://packt.live/3dWHDG6
    )
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3dWHDG6。](https://packt.live/3dWHDG6 )
- en: This section does not currently have an online interactive example and will
    need to be run locally.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分目前没有在线交互式示例，需要在本地运行。
- en: Position, Velocity, and Acceleration
  id: totrans-553
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置、速度和加速度
- en: Differential equations are often used to study the paths of projectiles, and
    this can be said to be the origin of calculus. Newton invented the tools of calculus
    to solve the differential equations that resulted from his study of the movements
    of the planets and showed that falling objects on Earth are subject to the same
    laws of physics as orbiting planets.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 微分方程经常用于研究抛射体的路径，这可以说是微积分的起源。牛顿发明了微积分工具来解决由他对行星运动的研究得出的微分方程，并且表明地球上的自由落体物体受到与轨道行星相同的物理定律的约束。
- en: 'Exercise 12.21: Calculating the Height of a Projectile above the Ground'
  id: totrans-555
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.21：计算抛射体离地面的高度
- en: 'A ball is thrown upward with an initial velocity of 29 m/s. How long before
    it hits the ground? Follow these steps to complete this exercise:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 一个球以初速度29米/秒向上抛出。它在击中地面之前要多久？按照以下步骤完成这个练习：
- en: 'In algebra class, we''re led to calculate the height of a projectile using
    an equation:![Figure 12.34: Formula to calculate the height of a projectile'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代数课上，我们被引导使用方程来计算抛射体的高度：![图12.34：计算抛射体高度的公式
- en: '](image/B15968_12_34.jpg)'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_34.jpg)'
- en: 'Figure 12.34: Formula to calculate the height of a projectile'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.34：计算抛射体高度的公式
- en: Here, *h*0 is the initial height, *v*0 is the initial upward velocity, *t* is
    the number of seconds elapsed, and *g* is the acceleration due to gravity, around
    32 feet or 9.8 meters per second. But projectiles don't calculate their position
    using equations; they simply travel in the direction their derivative indicates.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*h*0是初始高度，*v*0是初始向上速度，*t*是经过的秒数，*g*是重力加速度，大约32英尺或9.8米每秒。但是抛射体不使用方程来计算它们的位置；它们只是沿着它们的导数指示的方向运动。
- en: 'Let''s model that:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们模拟一下：
- en: '[PRE125]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: So, for the first second, the ball will be thrown up at 29 meters per second
    but will be slowed down by gravity 9.8 meters per second, meaning after a second,
    it's only going *29 – 9.8 = 19.2* meters per second. So, after a second, the ball
    should be 19.2 meters up in the air. We repeat that every second until its height
    is 0.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于第一秒，球将以29米/秒的速度向上抛出，但会受到每秒9.8米的重力减速，这意味着一秒后，它只有*29 - 9.8 = 19.2*米/秒。因此，一秒后，球应该在空中19.2米高。我们每秒重复一次，直到它的高度为0。
- en: 'Here''s what the `height` function should look like:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`height`函数应该是这样的：'
- en: '[PRE126]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The velocity and height are assigned their starting values, *v*0 and *h*0,
    and then the velocity is updated by *g* and the acceleration (due to gravity),
    and then the height, *h*, is updated by the velocity. We repeat our calculation
    every second and check to see when the ball''s height returns to zero:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 速度和高度被分配它们的起始值，*v*0和*h*0，然后速度通过*g*和加速度（由于重力）进行更新，然后高度*h*通过速度进行更新。我们每秒重复计算并检查球的高度何时返回到零：
- en: '[PRE127]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The following is the output:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE128]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'It looks like the ball hits the ground somewhere between 4 and 5 seconds. But
    when we put *t = 5* into the preceding formula, we get the following:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来球在4到5秒之间击中地面。但是当我们将*t = 5*放入前面的公式中时，我们得到以下结果：
- en: '![Figure 12.35: Substituting the values in the formula for calculating the
    height of a projectile'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.35：替换计算抛射体高度公式中的值'
- en: '](image/B15968_12_35.jpg)'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_35.jpg)'
- en: 'Figure 12.35: Substituting the values in the formula for calculating the height
    of a projectile'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.35：替换计算抛射体高度公式中的值
- en: 'After 5 seconds, the ball should still be 22.5 meters in the air. What''s wrong
    with our code? As you should know by now, the ball doesn''t only change its velocity
    once every second. Its velocity is changing constantly. Just like compound interest,
    we need to calculate the new velocity many times a second. That''s easy for Python.
    We''ll just introduce an `inc` variable for the increment in time. Remember that
    this increases the number of times we loop through the calculations, so the `for
    i in range` line changes too. Then, *g* and *v* are multiplied by the increment.
    We''ll recalculate every half a second:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5秒后，球应该仍然在空中22.5米。我们的代码有什么问题？正如您现在应该知道的那样，球不仅每秒改变一次速度。它的速度不断变化。就像复利一样，我们需要每秒计算新的速度。对于Python来说很容易。我们只需引入一个`inc`变量来增加时间。请记住，这会增加我们循环计算的次数，因此`for
    i in range`行也会改变。然后，*g*和*v*乘以增量。我们将每半秒重新计算一次：
- en: '[PRE129]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Run this using the same code to execute:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的代码运行此代码：
- en: '[PRE130]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The output is now as follows:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 输出现在如下：
- en: '[PRE131]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The ball is in the air for longer, and at 5 seconds, it''s 10.3 meters in the
    air. If we make the increment very small, it should get much closer to 22.5 meters
    at 5 seconds. Change `inc` to 0.001, run it again, and you''ll get this output:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 球在空中停留的时间更长，在5秒时，它在空中的高度为10.3米。如果我们使增量非常小，它应该在5秒时更接近22.5米。将“inc”更改为0.001，再次运行，您将获得以下输出：
- en: '[PRE132]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'To answer the question of when the ball hits the ground, we''ll have to do
    a binary search between 5 and 6 seconds. As in previous searches, we use our `bin_search`
    function and change the `guess =` line to reflect the number we''re *guessing*:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要回答球何时触地的问题，我们将不得不在5秒和6秒之间进行二分搜索。与以前的搜索一样，我们使用我们的`bin_search`函数，并更改`guess =`行以反映我们*猜测*的数字：
- en: '[PRE133]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'All we had to change was the `guess =` line with the parameters of the `height`
    function. The last parameter, *t*, is what we''re searching for, so that''s what
    we''re averaging. The binary search function will plug in values between 5 and
    6 and return the value of *t* that returns 0:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要更改`height`函数的参数的`guess =`行。最后一个参数*t*是我们正在搜索的内容，因此我们正在平均。二分搜索函数将在5和6之间插入值，并返回返回0的*t*值：
- en: '[PRE134]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Here''s the output:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE135]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Now, we solve the quadratic equation:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们解决二次方程：
- en: '*29t – 4.9t*2 *= 0*'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '*29t – 4.9t*2 *= 0*'
- en: 'For *t*, we get *t = 0* and *5.9184*. Of course, the height of the ball was
    0 before we threw it, and the second value is very close to what we got. Here''s
    what the graph of the function looks like. Neglecting air resistance, the graph
    of the particle''s height over time follows a parabolic path:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*t*，我们得到*t = 0*和*t = 5.9184*。当然，我们扔出球之前，球的高度为0，第二个值非常接近我们得到的值。函数的图形如下所示。忽略空气阻力，粒子高度随时间的图形遵循抛物线路径：
- en: '![Figure 12.36: The path of a projectile without air resistance'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.36：没有空气阻力的抛射物路径'
- en: '](image/B15968_12_36.jpg)'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_36.jpg)'
- en: 'Figure 12.36: The path of a projectile without air resistance'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.36：没有空气阻力的抛射物路径
- en: This was a test of our code because we had a nice formula to check our output.
    Now, we will move on to harder calculus problems involving velocity and acceleration
    where there isn't a formula to help us check the answers.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对我们代码的测试，因为我们有一个很好的公式来检查我们的输出。现在，我们将继续进行更难的关于速度和加速度的微积分问题，其中没有公式可以帮助我们检查答案。
- en: Note
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2VEAkN4.](https://packt.live/2VEAkN4
    )
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2VEAkN4](https://packt.live/2VEAkN4)。
- en: You can also run this example online at [https://packt.live/2Bzpz7Z.](https://packt.live/2Bzpz7Z
    )
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2Bzpz7Z](https://packt.live/2Bzpz7Z)上在线运行此示例。
- en: An Example of Calculating the Height of a Projectile with Air Resistance
  id: totrans-598
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算带空气阻力的抛射物高度的示例
- en: 'Math students are forced to study particles traveling in perfect parabolic
    paths from algebra through calculus. Unfortunately, that''s not how real particles
    travel. In real life, objects travel through some medium such as air or water
    and are slowed down depending on the density of the medium, their cross-sectional
    area, and other factors. This makes for a complicated equation for the force that''s
    applied to a projectile. In the simplest of terms, *the force on a projectile
    is the acceleration due to gravity and deceleration proportional to the square
    of its velocity*. The equation looks like this:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 数学学生被迫研究从代数到微积分的完美抛物线路径中行进的粒子。不幸的是，这不是真实粒子的行进方式。在现实生活中，物体穿过空气或水等介质，并根据介质的密度、其横截面积和其他因素而减速。这导致了一个复杂的施加在抛射物上的力的方程。简而言之，*抛射物上的力是由于重力加速度和与其速度的平方成比例的减速*。方程如下：
- en: '*F = mg - kv*2'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '*F = mg - kv*2'
- en: With air resistance, we'll need to know the mass, *m*, of the projectile. The
    acceleration due to gravity, *g*, is 9.8 m/s2. The *k* variable is a combination
    of at least three different factors, but the value *k = 0.27* yields realistic
    results for this situation.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 有空气阻力，我们需要知道抛射物的质量*m*。由于重力加速度*g*为9.8 m/s2。变量*k*是至少三个不同因素的组合，但值*k = 0.27*对于这种情况产生了现实结果。
- en: As in the previous exercise, we calculate the acceleration and use it to update
    the velocity. Then, we update the position of the projectile according to the
    velocity.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个练习一样，我们计算加速度并使用它来更新速度。然后，我们根据速度更新抛射物的位置。
- en: 'The force on the projectile is made up of two parts: the usual acceleration
    due to gravity and a drag component. Let''s write a Python function to calculate
    that:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 抛射物上的力由两部分组成：由于重力的通常加速度和阻力分量。让我们编写一个Python函数来计算：
- en: '[PRE136]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Many times, our values are multiplied by `inc`, the increment variable, so that
    we can take smaller steps to get better approximations, as we did before. The
    `gravity` and `drag` variables are taken directly from the force equation. Notice
    that if the velocity is greater than 0, the projectile is traveling upward, so
    the downward force is the sum of the gravity and drag forces. Otherwise, the projectile
    is traveling downward, so the force of gravity is still downward but the drag
    is slowing it down, so we use the difference of the gravity and the drag.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，我们的值都乘以`inc`，增量变量，这样我们可以采取更小的步骤来获得更好的近似值，就像我们以前做的那样。`gravity`和`drag`变量直接来自力的方程。请注意，如果速度大于0，抛射物正在向上运动，因此向下的力是重力和阻力力的总和。否则，抛射物正在向下运动，因此重力的力仍然向下，但阻力正在减速，因此我们使用重力和阻力的差异。
- en: 'Now, we''ll adapt our `height` function from the previous exercise to calculate
    the time it takes for the height to equal 0 and add in a call to our `force` function:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将调整我们在上一个练习中的`height`函数，以计算高度等于0所需的时间，并添加对我们的`force`函数的调用：
- en: '[PRE137]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'It''s the `v -=` line that''s doing the heavy lifting in this function. The
    velocity will be acted on by the downward force. When we run this using *k = 0*,
    we should get the same time and ending velocity as in the previous problem, with
    no air resistance:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，是`v -=`这一行在起重要作用。速度将受到向下的力的影响。当我们使用*k = 0*运行时，我们应该得到与上一个问题中相同的时间和结束速度，没有空气阻力：
- en: '[PRE138]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The output is as follows:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE139]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Yes; in the previous exercise, the projectile took 5.9 seconds to reach the
    ground. When there's no air resistance and the ending height is the same as the
    initial height, the ending velocity will be the same as the initial velocity,
    only in the opposite direction, so –29 m/s.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 是的；在上一个练习中，抛射物需要5.9秒才能到达地面。当没有空气阻力且结束高度与初始高度相同时，结束速度将与初始速度相同，只是方向相反，因此为-29米/秒。
- en: Now, let's put in our more realistic value for *k*, `0.27`, and see how long
    it takes the particle to reach the ground and how fast it will be going. What
    do you predict?
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用更现实的值*k*，`0.27`，看看粒子到达地面需要多长时间，以及它将以多快的速度运行。你有什么预测？
- en: 'Change the `v -=` line in the `height` function to the following:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 将`height`函数中的`v -=`行更改为以下内容：
- en: '[PRE140]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The output when you run the program will be as follows:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行程序时，输出将如下所示：
- en: '[PRE141]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'So, the projectile went up and back down in only 2.2 seconds, and the final
    velocity was –5.9 m/s. If we juxtapose the graphs of the heights of the projectiles
    with and without air resistance, we certainly get a lot less height with air resistance:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，抛射物只用了2.2秒就上升并下降，最终速度为-5.9米/秒。如果我们将具有和没有空气阻力的抛射物的高度图进行对比，我们会发现在有空气阻力的情况下高度要少得多：
- en: '![Figure 12.37: The height of a projectile, with air resistance (the inner
    curve)'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.37：带空气阻力的抛射物的高度（内曲线）'
- en: '](image/B15968_12_37.jpg)'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_37.jpg)'
- en: 'Figure 12.37: The height of a projectile, with air resistance (the inner curve)'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.37：带空气阻力的抛射物的高度（内曲线）
- en: That sure is a lot of resistance. Play around with different values for *k*,
    the constant of drag, to get different ending times and ending velocities. This
    leads us to a very interesting idea in math and science, known as **terminal velocity**,
    when the downward and upward forces on a projectile equal out and it no longer
    accelerates.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是很大的阻力。尝试使用不同的*k*值，即阻力常数，以获得不同的结束时间和结束速度。这引出了数学和科学中一个非常有趣的概念，即**终端速度**，当抛射物上下的力相等时，它不再加速。
- en: 'Exercise 12.22: Calculating the Terminal Velocity'
  id: totrans-623
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.22：计算终端速度
- en: If your projectile started at an initial height of 3,000 meters and jumped out
    of a plane (downward velocity of 0), what velocity would it reach? Would it simply
    continue accelerating until the projectile hits the ground?
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的抛射物从3000米的初始高度开始并从飞机上跳下（向下速度为0），它会达到什么速度？它会简单地继续加速直到抛射物撞击地面吗？
- en: 'Change the mass to 80 kg, an average weight for a human, and *k* to `0.27`.
    Follow these steps to complete this exercise:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 将质量更改为80公斤，这是人类的平均体重，*k*更改为`0.27`。按照以下步骤完成此练习：
- en: Make sure you have your `force` function from the previous example.
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您有来自上一个示例的`force`函数。
- en: 'Change your `height` function so that it looks like this:'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改您的`height`函数，使其看起来像这样：
- en: '[PRE142]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Here''s the important line where we tell the `force` function the mass, the
    value of *k*, and so on:'
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个重要的行，我们在其中告诉`force`函数质量、*k*的值等等：
- en: '[PRE143]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'We go through 500 loops but only print out the velocity every 50th loop. Let''s
    run it with this line:'
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们进行了500次循环，但只在每50次循环时打印出速度。让我们用这行来运行它：
- en: '[PRE144]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'This is the output we receive:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们收到的输出：
- en: '[PRE145]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The velocity starts at 0 and gets more and more negative until it stops decreasing.
    It evens out around 54 m/s (negative because it''s downward), which is around
    120 miles per hour, the terminal velocity for a human body in free fall. Here''s
    a graph of the velocity over time:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 速度从0开始，变得越来越负，直到停止减少。它在大约54米/秒左右稳定下来（为负，因为它向下），这大约是每小时120英里，人体在自由落体中的终端速度。这是随时间变化的速度图：
- en: '![Figure 12.38: The velocity of a body in free fall with air resistance'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.38：带空气阻力的自由落体物体的速度'
- en: '](image/B15968_12_38.jpg)'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_38.jpg)'
- en: 'Figure 12.38: The velocity of a body in free fall with air resistance'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.38：带空气阻力的自由落体物体的速度
- en: Note
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2NNmWBM.](https://packt.live/2NNmWBM
    )
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2NNmWBM。](https://packt.live/2NNmWBM )
- en: You can also run this example online at [https://packt.live/2BUuXCp.](https://packt.live/2BUuXCp
    )
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2BUuXCp](https://packt.live/2BUuXCp)上在线运行此示例。
- en: Now, let's complete an activity to test what we have learned in this chapter.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们完成一个活动，测试我们在本章学到的知识。
- en: 'Activity 12.01: Finding the Velocity and Location of a Particle'
  id: totrans-643
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动12.01：找到粒子的速度和位置
- en: 'The velocity vector of a particle moving in the *x-y* plane has the following
    components:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 在*x-y*平面上移动的粒子的速度矢量具有以下分量：
- en: '![Figure 12.39: Differential equation for the velocity vector of a particle'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.39：粒子速度矢量的微分方程'
- en: '](image/B15968_12_39.jpg)'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_12_39.jpg)'
- en: 'Figure 12.39: Differential equation for the velocity vector of a particle'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.39：粒子速度矢量的微分方程
- en: Find all the times (and coordinates) at which the line tangent to the curve
    is horizontal, and then find the speed of the particle at *t = 1*.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 找到曲线的切线水平的所有时间（和坐标），然后找到*t=1*时粒子的速度。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此活动：
- en: Write functions for *dx/dt* and *dy/dt*.
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写*dx/dt*和*dy/dt*的函数。
- en: Loop through the output to find where the derivative is 0 by finding the values
    where the derivative goes from positive to negative or vice versa. Then, use binary
    search to find more accurate approximations.
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历输出，找到导数为0的位置，找到导数从正变负或反之的值。然后，使用二分搜索找到更精确的近似值。
- en: Create a `position` function and take incremental steps of time using loops,
    changing the position of the particle according to the derivatives (the *change
    in position*) given previously. The function should stop at the desired elapsed
    time and print out the *x-y* coordinates.
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`position`函数，并使用循环按照之前给出的导数（*位置的变化*）来改变粒子的位置，以便在所需的经过时间停止，并打印出*x-y*坐标。
- en: Plug the times you found in *step 2* into the `position` function to find the
    *x-y* coordinates of the particle when the derivative is 0.
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您在*步骤2*中找到的时间插入`position`函数中，以找到导数为0时粒子的*x-y*坐标。
- en: You're asked for the speed of the particle at time *t = 1*. Find the vertical
    and horizontal components of the particle's velocity using the differential equations
    you're given, and also find the hypotenuse of the right triangle created with
    those components acting as the legs.
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您被要求在时间*t=1*时粒子的速度。使用您得到的微分方程找到粒子速度的垂直和水平分量，并找到以这些分量作为腿的直角三角形的斜边。
- en: Note
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 702.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第702页找到。
- en: Summary
  id: totrans-657
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Calculus is a very powerful set of tools for modeling real situations, from
    the transfer of heat to the motion of planets. It has enabled us to calculate
    the rate of change of a function in an instant and the area under complicated
    curves (tasks that seemed impossible using only the tools of algebra and geometry).
    In this chapter, we've been able to deal with the rate of change of a value (the
    derivative) as a value in itself, and we've calculated some very accurate results
    using Python loops and functions. Modeling situations that lead to differential
    equations, such as the paths of projectiles, was what drove the development of
    the first electronic computers.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分是一套非常强大的工具，用于模拟真实情况，从热量传递到行星运动。它使我们能够计算函数在瞬间的变化率和复杂曲线下的面积（这些任务仅使用代数和几何的工具似乎是不可能的）。在本章中，我们能够处理值的变化率（导数）作为一个值本身，并使用Python循环和函数计算出一些非常精确的结果。模拟导致微分方程的情况，比如抛射物的路径，正是推动第一台电子计算机的发展。
- en: Math classes may still emphasize algebraic solutions to equations, even differential
    equations, but as we've seen in this chapter, using a computer is a straightforward
    way to model a real-life situation such as a predator pursuing its prey. We changed
    variables such as the amount of money in an investment, the amount of salt in
    a mixture, and the direction a predator was facing thousands of times, recalculating
    amounts and distances every step, and got very accurate results. Python was the
    perfect tool to set some starting conditions and let the program run until a projectile
    hit the ground or reached a terminal velocity. Python also helped us avoid laborious
    algebraic manipulations and let us *brute force* an answer by creating a simple
    model of a falling object or a predator pursuing its prey. This was *simple* because
    we didn't have to repeat the calculations thousands of times—the computer did.
    Plus, these numerical methods are already used on differential equations that
    have no simple algebraic solution, and they even work on those equations that
    do. Hopefully, this chapter has proven the power of using a computer to model
    and analyze complicated real-world situations.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 数学课程可能仍然强调对方程的代数解，甚至微分方程，但正如我们在本章中所看到的，使用计算机是模拟现实生活情况的一种简单方法，比如捕食者追逐猎物。我们改变了变量，比如投资中的资金量，混合物中的盐量，以及捕食者的朝向，重复计算了数千次，每一步重新计算数量和距离，得到了非常精确的结果。Python是设置一些起始条件并让程序运行直到抛射物击中地面或达到终端速度的完美工具。Python还帮助我们避免了繁琐的代数运算，并让我们通过创建一个简单的模型来*蛮力*得到答案，比如一个下落的物体或一个捕食者追逐猎物。这是*简单*的，因为我们不必重复数千次计算——计算机会做。此外，这些数值方法已经用于没有简单代数解的微分方程，甚至适用于那些有解的方程。希望本章已经证明了使用计算机来模拟和分析复杂的现实情况的力量。
- en: Now, you've learned how to build on Python's loops, variables, conditionals,
    functions, and lists to solve complicated problems in statistics, probability,
    and calculus. You've also learned how to time the execution of your code and plot
    your output. You've used Python's state-of-the-art numerical package, `numpy`,
    to speed up calculations and manipulate arrays for a host of applications. You've
    also seen Python programming being applied to every math topic under the sun,
    and now you'll be able to apply it to any real-life situations you encounter in
    the future.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经学会了如何利用Python的循环、变量、条件、函数和列表来解决统计学、概率论和微积分中的复杂问题。您还学会了如何计时执行代码并绘制输出。您使用了Python的最先进的数值包`numpy`来加速计算并操纵数组，适用于各种应用。您还看到Python编程被应用于太阳下的每一个数学主题，现在您将能够将其应用于未来遇到的任何现实生活情况。
- en: JMK95
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: JMK95
- en: GEA39
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: GEA39
