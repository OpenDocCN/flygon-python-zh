# 哈希和符号表

我们之前看过列表，其中项目按顺序存储并通过索引号访问。索引号对计算机来说很有效。它们是整数，因此它们快速且易于操作。但是，它们并不总是对我们很有效。例如，如果我们有一个地址簿条目，索引号为 56，那个数字并没有告诉我们太多。没有什么可以将特定联系人与编号 56 联系起来。它只是列表中的下一个可用位置。

在本章中，我们将研究一个类似的结构：字典。字典使用关键字而不是索引号。因此，如果该联系人被称为*James*，我们可能会使用关键字*James*来定位该联系人。也就是说，我们不再通过调用*contacts [56]*来访问联系人，而是使用*contacts ["james"]*。

字典通常是使用哈希表构建的。顾名思义，哈希表依赖于一个称为**哈希**的概念。这就是我们将开始讨论的地方。

在本章中，我们将涵盖以下主题：

+   哈希

+   哈希表

+   具有元素的不同函数

# 哈希

哈希是将任意大小的数据转换为固定大小的数据的概念。更具体地说，我们将使用这个概念将字符串（或可能是其他数据类型）转换为整数。这可能听起来比实际复杂，所以让我们看一个例子。我们想要对表达式 `hello world` 进行哈希，也就是说，我们想要得到一个数值，可以说*代表*这个字符串。

通过使用 `ord()` 函数，我们可以得到任何字符的序数值。例如，`ord('f')` 函数返回 102。要得到整个字符串的哈希值，我们可以简单地对字符串中每个字符的序数值求和：

```py
>>> sum(map(ord, 'hello world'))
1116
```

![](img/52c1ad6d-2e2e-45a3-93da-6ce146981c11.jpg)

这很好地运行了。但是，请注意我们可以改变字符串中字符的顺序并得到相同的哈希值：

```py
>>> sum(map(ord, 'world hello'))
1116
```

字符的序数值的总和对于字符串 `gello xorld` 也是相同的，因为 `g` 的序数值比 `h` 小 1，x 的序数值比 `w` 大 1，因此：

```py
>>> sum(map(ord, 'gello xorld'))
1116
```

![](img/e3d188b5-0976-477b-8921-37f6bf72d9e2.jpg)

# 完美的哈希函数

完美的哈希函数是指每个字符串（目前我们只讨论字符串）都保证是唯一的。在实践中，哈希函数通常需要非常快，因此通常不可能创建一个能给每个字符串一个唯一哈希值的函数。相反，我们要接受有时会发生碰撞（两个或更多个字符串具有相同的哈希值），当发生这种情况时，我们需要想出一种解决策略。

与此同时，我们至少可以想出一种避免一些碰撞的方法。例如，我们可以添加一个乘数，使得每个字符的哈希值成为乘数值乘以字符的序数值。随着我们在字符串中的进展，乘数会增加。这在下面的函数中显示：

```py
    def myhash(s): 
        mult = 1 
        hv = 0 
        for ch in s: 
            hv += mult * ord(ch) 
            mult += 1 
        return hv 
```

我们可以在先前使用的字符串上测试这个函数：

```py
    for item in ('hello world', 'world hello', 'gello xorld'): 
        print("{}: {}".format(item, myhash(item))) 
```

运行程序，我们得到以下输出：

```py
% python hashtest.py

hello world: 6736
world hello: 6616
gello xorld: 6742
```

![](img/8414fd29-b1a2-4984-b8d9-df385915fc59.jpg)

请注意，最后一行是将第 2 行和第 3 行的值相乘得到的，例如 104 x 1 等于 104。

这次我们得到了不同的字符串的哈希值。当然，这并不意味着我们有一个完美的哈希。让我们尝试字符串 `ad` 和 `ga`：

```py
% python hashtest.py 
ad: 297
ga: 297
```

在这里，我们仍然得到了两个不同字符串相同的哈希值。正如我们之前所说的，这并不一定是一个问题，但我们需要想出一种解决碰撞的策略。我们很快将会看到这一点，但首先我们将研究哈希表的实现。

# 哈希表

**哈希表**是一种列表形式，其中元素是通过关键字而不是索引号访问的。至少，这是客户端代码将看到的方式。在内部，它将使用我们稍微修改过的哈希函数的版本，以便找到应该插入元素的索引位置。这给了我们快速查找，因为我们使用的是与键的哈希值对应的索引号。

我们首先创建一个类来保存哈希表的项目。这些项目需要有一个键和一个值，因为我们的哈希表是一个键-值存储：

```py
    class HashItem: 
        def __init__(self, key, value): 
            self.key = key 
            self.value = value 
```

这给了我们一种非常简单的存储项目的方式。接下来，我们开始着手处理哈希表类本身。和往常一样，我们从构造函数开始：

```py
    class HashTable: 
        def __init__(self): 
            self.size = 256 
            self.slots = [None for i in range(self.size)] 
            self.count = 0 
```

哈希表使用标准的 Python 列表来存储其元素。我们也可以使用之前开发的链表，但现在我们的重点是理解哈希表，所以我们将使用我们手头上的东西。

我们将哈希表的大小设置为 256 个元素。稍后，我们将研究如何在开始填充哈希表时扩展表的策略。现在，我们初始化一个包含 256 个元素的列表。这些元素通常被称为槽或桶。最后，我们添加一个计数器，用于记录实际哈希表元素的数量：

![](img/3a6bc6fe-7231-4fee-bd5b-6be6fba0a9c1.jpg)

重要的是要注意表的大小和计数之间的区别。表的大小是指表中槽的总数（已使用或未使用）。表的计数，另一方面，只是指填充的槽的数量，或者换句话说，我们已经添加到表中的实际键-值对的数量。

现在，我们将把我们的哈希函数添加到表中。它将类似于我们在哈希函数部分演变的内容，但有一个小小的不同：我们需要确保我们的哈希函数返回一个介于 1 和 256 之间的值（表的大小）。一个很好的方法是返回哈希除以表的大小的余数，因为余数总是一个介于 0 和 255 之间的整数值。

哈希函数只是用于类内部的，我们在名称前面加下划线(`_`)来表示这一点。这是 Python 中用于表示某些内容是内部使用的常规约定：

```py
    def _hash(self, key): 
        mult = 1 
        hv = 0 
        for ch in key: 
            hv += mult * ord(ch) 
            mult += 1 
        return hv % self.size 
```

目前，我们将假设键是字符串。我们将讨论如何稍后使用非字符串键。现在，只需记住`_hash()`函数将生成字符串的哈希值。

# 放置元素

我们使用`put()`函数添加元素到哈希表，并使用`get()`函数检索。首先，我们将看一下`put()`函数的实现。我们首先将键和值嵌入到`HashItem`类中，并计算键的哈希：

```py
    def put(self, key, value): 
        item = HashItem(key, value) 
        h = self._hash(key) 
```

现在我们需要找到一个空槽。我们从与键的哈希值对应的槽开始。如果该槽为空，我们就在那里插入我们的项目。

然而，如果槽不为空并且项目的键与我们当前的键不同，那么我们就会发生冲突。这就是我们需要想办法处理冲突的地方。我们将通过在先前的哈希值上加一，并取除以哈希表的大小的余数来解决这个问题。这是一种线性解决冲突的方法，非常简单：

![](img/22dd9b2d-b701-452b-925e-4208a688ce80.jpg)

```py
    while self.slots[h] is not None: 
        if self.slots[h].key is key: 
            break 
        h = (h + 1) % self.size 
```

我们已经找到了插入点。如果这是一个新元素（即先前包含`None`），那么我们将计数增加一。最后，我们将项目插入到所需位置的列表中：

```py
    if self.slots[h] is None: 
        self.count += 1 
    self.slots[h] = item  
```

# 获取元素

`get()`方法的实现应该返回与键对应的值。我们还必须决定在表中不存在键时该怎么办。我们首先计算键的哈希：

```py
    def get(self, key): 
        h = self._hash(key)
```

现在，我们只需开始在列表中寻找具有我们正在搜索的键的元素，从具有传入键的哈希值的元素开始。如果当前元素不是正确的元素，那么就像在`put()`方法中一样，我们在先前的哈希值上加一，并取除以列表大小的余数。这就成为我们的新索引。如果我们找到包含`None`的元素，我们停止寻找。如果我们找到我们的键，我们返回值：

![](img/6d58b265-70e8-4da9-8a91-370070916d43.jpg)

```py
        while self.slots[h] is not None: 
            if self.slots[h].key is key: 
                return self.slots[h].value 
            h = (h+ 1) % self.size 
```

最后，我们决定如果在表中找不到键要做什么。在这里，我们将选择返回`None`。另一个好的选择可能是引发一个异常：

```py
        return None 
```

# 测试哈希表

为了测试我们的哈希表，我们创建一个`HashTable`，把一些元素放进去，然后尝试检索这些元素。我们还将尝试`get()`一个不存在的键。还记得我们的哈希函数返回相同的哈希值的两个字符串 ad 和 ga 吗？为了确保，我们也把它们放进去，看看冲突是如何正确解决的：

```py
    ht = HashTable() 
    ht.put("good", "eggs") 
    ht.put("better", "ham") 
    ht.put("best", "spam") 
    ht.put("ad", "do not") 
    ht.put("ga", "collide") 

    for key in ("good", "better", "best", "worst", "ad", "ga"): 
        v = ht.get(key) 
        print(v) 
```

运行这个代码返回以下结果：

```py
% python hashtable.py 
eggs
ham
spam
None
do not
collide  
```

如你所见，查找键 worst 返回`None`，因为该键不存在。键`ad`和`ga`也返回它们对应的值，显示它们之间的冲突是如何处理的。

# 使用哈希表的[]

然而，使用`put()`和`get()`方法看起来并不是很好。我们希望能够将我们的哈希表视为一个列表，也就是说，我们希望能够使用`ht["good"]`而不是`ht.get("good")`。这可以很容易地通过特殊方法`__setitem__()`和`__getitem__()`来实现：

```py
    def __setitem__(self, key, value): 
        self.put(key, value) 

    def __getitem__(self, key): 
        return self.get(key) 
```

我们的测试代码现在可以这样写：

```py
    ht = HashTable() 
    ht["good"] = "eggs" 
    ht["better"] = "ham" 
    ht["best"] = "spam" 
    ht["ad"] = "do not" 
    ht["ga"] = "collide" 

    for key in ("good", "better", "best", "worst", "ad", "ga"): 
        v = ht[key] 
        print(v) 

    print("The number of elements is: {}".format(ht.count)) 
```

注意，我们还打印了哈希表中的元素数量。这对我们接下来的讨论很有用。

# 非字符串键

在大多数情况下，只使用字符串作为键更有意义。但是，如果必要，你可以使用任何其他的 Python 类型。如果你创建了自己的类来用作键，你可能需要重写该类的特殊`__hash__()`函数，以便获得可靠的哈希值。

注意，你仍然需要计算哈希值的模运算和哈希表的大小，以获得插槽。这个计算应该发生在哈希表中，而不是在键类中，因为表知道自己的大小（键类不应该知道它所属的表的任何信息）。

# 扩大哈希表

在我们的示例中，哈希表的大小设置为 256。显然，随着我们向列表中添加元素，我们开始填满空插槽。在某个时候，所有的插槽都将被填满，表也将被填满。为了避免这种情况，我们可以在表快要填满时扩大表。

为了做到这一点，我们比较大小和计数。记住`size`保存了插槽的总数，`count`保存了包含元素的插槽的数量？如果`count`等于`size`，那么我们已经填满了表。

哈希表的负载因子给了我们一个指示，表中有多大比例的可用插槽正在被使用。它的定义如下：

![](img/bb6128dd-4fa3-454f-8a3a-e6618c78605b.jpg)

当负载因子接近 1 时，我们需要扩大表格。实际上，我们应该在它达到那里之前就这样做，以避免变得太慢。0.75 可能是一个很好的值，用来扩大表格。

下一个问题是要扩大表多少。一个策略是简单地将表的大小加倍。

# 开放寻址

我们在示例中使用的冲突解决机制，线性探测，是开放寻址策略的一个例子。线性探测非常简单，因为我们在探测之间使用固定的间隔。还有其他的开放寻址策略，但它们都共享一个想法，即有一个插槽数组。当我们想要插入一个键时，我们会检查插槽是否已经有项目。如果有，我们会寻找下一个可用的插槽。

如果我们有一个包含 256 个插槽的哈希表，那么 256 就是哈希中最大的元素数量。此外，随着负载因子的增加，找到新元素的插入点将需要更长的时间。

由于这些限制，我们可能更喜欢使用不同的策略来解决冲突，例如链接。

# 链接

链接是一种解决冲突并避免哈希表中元素数量限制的策略。在链接中，哈希表中的插槽初始化为空列表：

![](img/27c7922b-721c-462c-b364-80c3f9043576.jpg)

当插入元素时，它将被追加到与该元素的哈希值对应的列表中。也就是说，如果您有两个具有相同哈希值 1167 的元素，这两个元素都将被添加到哈希表的插槽 1167 中存在的列表中：

![](img/b0a9e8cd-66ef-4a1f-9d71-426b40f86976.jpg)

上图显示了具有哈希值 51 的条目列表。

然后通过允许多个元素具有相同的哈希值来避免冲突。它还避免了插入的问题，因为负载因子增加时，我们不必寻找插槽。此外，哈希表可以容纳比可用插槽数量更多的值，因为每个插槽都包含一个可以增长的列表。

当然，如果特定插槽有很多项，搜索它们可能会变得非常缓慢，因为我们必须通过列表进行线性搜索，直到找到具有所需键的元素。这可能会减慢检索速度，这并不好，因为哈希表的目的是高效的：

![](img/da74b737-63a5-4d5f-83c0-e1ca96b57b91.jpg)

上图演示了通过列表项进行线性搜索，直到找到匹配项。

我们可以在表插槽中使用另一个允许快速搜索的结构，而不是使用列表。我们已经看过**二叉搜索树**（**BSTs**）。我们可以简单地在每个插槽中放置一个（最初为空的）BST：

![](img/cc74e411-b929-4117-816f-03466949e072.jpg)

插槽 51 包含我们搜索键的 BST。但我们仍然可能会遇到一个问题：根据将项添加到 BST 的顺序，我们可能会得到一个搜索树，其效率与列表一样低。也就是说，树中的每个节点都只有一个子节点。为了避免这种情况，我们需要确保我们的 BST 是自平衡的。

# 符号表

符号表被编译器和解释器用来跟踪已声明的符号及其相关信息。符号表通常使用哈希表构建，因为高效地检索表中的符号很重要。

让我们看一个例子。假设我们有以下 Python 代码：

```py
    name = "Joe" 
    age = 27 
```

这里有两个符号，名称和年龄。它们属于一个命名空间，可以是`__main__`，但如果您将其放在那里，它也可以是模块的名称。每个符号都有一个值；名称的值为`Joe`，年龄的值为`27`。符号表允许编译器或解释器查找这些值。符号名称和年龄成为哈希表中的键。与之关联的所有其他信息，例如值，都成为符号表条目的一部分。

不仅变量是符号，函数和类也是。它们都将被添加到我们的符号表中，因此当需要访问它们中的任何一个时，它们都可以从符号表中访问：

![](img/1d9af336-8933-481d-ac37-6241657bfd7d.jpg)

在 Python 中，每个加载的模块都有自己的符号表。符号表被赋予该模块的名称。这样，模块就充当了命名空间。我们可以有多个名为年龄的符号，只要它们存在于不同的符号表中。要访问其中任何一个，我们通过适当的符号表进行访问：

![](img/c21ded3a-54f5-4e40-ae10-437dec4e39ed.jpg)

# 总结

在本章中，我们已经研究了哈希表。我们研究了如何编写哈希函数将字符串数据转换为整数数据。然后我们看了如何使用哈希键快速高效地查找对应于键的值。

我们还注意到哈希函数并不完美，可能会导致多个字符串具有相同的哈希值。这促使我们研究了冲突解决策略。

我们研究了如何扩展哈希表，以及如何查看表的负载因子，以确定何时扩展哈希表。

在本章的最后一节中，我们学习了符号表，通常使用哈希表构建。符号表允许编译器或解释器查找已定义的符号（变量、函数、类等）并检索有关其所有信息。

在下一章中，我们将讨论图和其他算法。
