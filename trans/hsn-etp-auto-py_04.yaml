- en: Using Python to Manage Network Devices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Python 管理网络设备
- en: Now we have a fair knowledge about how to use and install Python in different
    operating systems and also how to build the network topology using the EVE-NG.
    In this chapter, we will discover how to leverage many network automation libraries,
    used today to automate various network tasks. Python can interact with network
    devices on many layers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对如何在不同操作系统中使用和安装 Python 以及如何使用 EVE-NG 构建网络拓扑有了相当的了解。在本章中，我们将发现如何利用今天用于自动化各种网络任务的许多网络自动化库。Python
    可以在许多层面与网络设备进行交互。
- en: First, it can handle low-level layers with socket programming and `socket` modules,
    which serve as low-level networking interfaces between operating systems that
    run Python and the network device. Also, Python modules provide higher-level interaction
    through telnet, SSH, and API. In this chapter, we will dive deep into how to use
    Python to establish remote connections and execute commands on remote devices
    using telnet and SSH modules.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它可以通过套接字编程和 `socket` 模块处理低级层，这些模块作为运行 Python 的操作系统和网络设备之间的低级网络接口。此外，Python
    模块通过 telnet、SSH 和 API 提供更高级的交互。在本章中，我们将深入探讨如何使用 Python 建立远程连接并使用 telnet 和 SSH
    模块在远程设备上执行命令。
- en: 'The following topics will be covered:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下主题将被涵盖：
- en: Using Python to telnet to devices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 进行 telnet 到设备
- en: Python and SSH
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 和 SSH
- en: Handling IP addresses and networks with `netaddr`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `netaddr` 处理 IP 地址和网络
- en: Network automation sample use cases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络自动化示例用例
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following tools should be installed and available in your environment:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下工具应安装并在您的环境中可用：
- en: Python 2.7.1x
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 2.7.1x
- en: PyCharm Community or Pro Edition
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm 社区版或专业版
- en: EVE-NG topology; please refer to [Chapter 3](part0043.html#190860-9cfcdc5beecd470bbeda046372f0337f), *Setting
    up the Network Lab Environment*, for how to install and configure the emulator
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EVE-NG 拓扑；请参阅[第 3 章](part0043.html#190860-9cfcdc5beecd470bbeda046372f)，*设置网络实验室环境*，了解如何安装和配置模拟器
- en: You can find the full scripts developed in this chapter at the following GitHub
    URL: [https://github.com/TheNetworker/EnterpriseAutomation.git](https://github.com/TheNetworker/EnterpriseAutomation.git).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下 GitHub URL 找到本章中开发的完整脚本：[https://github.com/TheNetworker/EnterpriseAutomation.git](https://github.com/TheNetworker/EnterpriseAutomation.git)。
- en: Python and SSH
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 和 SSH
- en: Unlike telnet, SSH provides a secure channel to exchange data between client
    and server. The tunnel created between the client and the device is encrypted
    with different security mechanisms that make it hard for anyone to decrypt the
    communication. The SSH protocol is the first choice for network engineers who
    need to securely administrate network nodes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与 telnet 不同，SSH 提供了一个安全的通道，用于在客户端和服务器之间交换数据。在客户端和设备之间创建的隧道使用不同的安全机制进行加密，使得任何人都很难解密通信。对于需要安全管理网络节点的网络工程师来说，SSH
    协议是首选。
- en: Python can communicate with network devices using the SSH protocol by utilizing
    a popular library called **Paramiko** that supports authentication, key handling
    (DSA, RSA, ECDSA, and ED25519), and other SSH features such as the `proxy` command
    and SFTP.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python 可以使用 SSH 协议与网络设备通信，利用一个名为 **Paramiko** 的流行库，该库支持认证、密钥处理（DSA、RSA、ECDSA
    和 ED25519）以及其他 SSH 功能，如 `proxy` 命令和 SFTP。
- en: Paramiko module
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Paramiko 模块
- en: The most widely used module for SSH in Python is called `Paramiko` and, as the
    GitHub official page says, the name Paramiko is a combination of the Esperanto
    words for "paranoid" and "friend." The module itself is written and developed
    using Python, though some core functions like crypto depend on the C language.
    You can find out more about the contributors and module history at the official
    GitHub link here: [https://github.com/paramiko/paramiko](https://github.com/paramiko/paramiko).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中最广泛使用的 SSH 模块称为 `Paramiko`，正如 GitHub 官方页面所说，Paramiko 的名称是 "paranoid"
    和 "friend" 这两个世界的组合。该模块本身是使用 Python 编写和开发的，尽管一些核心功能如加密依赖于 C 语言。您可以在官方 GitHub 链接中了解更多有关贡献者和模块历史的信息：[https://github.com/paramiko/paramiko](https://github.com/paramiko/paramiko)。
- en: Module installation
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块安装
- en: 'Open Windows cmd or Linux shell and execute the following command to download
    the latest `paramiko` module from PyPI. It will download additional dependency
    packages such as `cyrptography`, `ipaddress`, and `six` and install them on your
    machine:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Windows cmd 或 Linux shell 并执行以下命令，从 PyPI 下载最新的 `paramiko` 模块。它将下载附加的依赖包，如
    `cyrptography`、`ipaddress` 和 `six`，并在您的计算机上安装它们：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](../images/00066.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00066.jpeg)'
- en: 'You can verify that the installation is done successfully by entering the Python
    shell and importing the `paramiko` module as shown in the following screenshot.
    Python should import it successfully without printing any errors:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过进入 Python shell 并导入 `paramiko` 模块来验证安装是否成功，如下面的屏幕截图所示。Python 应该成功导入它而不打印任何错误：
- en: '![](../images/00067.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00067.jpeg)'
- en: SSH to the network device
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSH 到网络设备
- en: 'As usual, in every Python module, we first need to import it into our Python
    script, then we will create an SSH client by inheriting from `SSHClient()`. After
    that, we will configure the Paramiko to automatically add any unknown host-key
    and trust the connection between you and the server. Then, we will use the `connect`
    function and provide the remote host credentials:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个 Python 模块一样，我们首先需要将其导入到我们的 Python 脚本中，然后我们将通过继承 `SSHClient()` 来创建一个 SSH
    客户端。之后，我们将配置 Paramiko 自动添加任何未知的主机密钥并信任您和服务器之间的连接。然后，我们将使用 `connect` 函数并提供远程主机凭据：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`AutoAddPolicy()` is one of the policies that can be used inside the `set_missing_host_key_policy()`
    function. It''s preferred and acceptable in a lab environment. However, we should
    use a more restrictive policy in a production environment, such as `WarningPolicy()`
    or `RejectPolicy()`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`AutoAddPolicy()` 是可以在 `set_missing_host_key_policy()` 函数内使用的策略之一。在实验室环境中，它是首选且可接受的。然而，在生产环境中，我们应该使用更严格的策略，比如
    `WarningPolicy()` 或 `RejectPolicy()`。'
- en: Finally, the `invoke_shell()` will start the interactive shell session towards
    our SSH server. You can provide additional parameters to it such as the terminal
    type, width, and height.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`invoke_shell()`将启动与我们的SSH服务器的交互式shell会话。您可以向其提供附加参数，如终端类型、宽度和高度。
- en: 'Paramiko connect parameters:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Paramiko连接参数：
- en: '`Look_For_Keys`: By default, it''s `True`, and it will force the Paramiko to
    use the key-pair authentication where the user is using both private and public
    keys to authenticate against the network device. In our case, we will set it to
    `False` as we will use password authentication.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Look_For_Keys`：默认为`True`，它将强制Paramiko使用密钥对身份验证，用户使用私钥和公钥对来对网络设备进行身份验证。在我们的情况下，我们将其设置为`False`，因为我们将使用密码身份验证。'
- en: '`allow_agent paramiko`: It can connect to a local SSH agent OS. This is necessary
    when working with keys; in this case, since authentication is performed using
    a login/password, we will disable it.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allow_agent paramiko`：它可以连接到本地SSH代理操作系统。这在使用密钥时是必要的；在这种情况下，由于使用登录/密码进行身份验证，我们将禁用它。'
- en: 'The final step is to send a series of commands such as `show ip int b` and
    `show arp` to the device terminal and get the output back to our Python shell:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是向设备终端发送一系列命令，如`show ip int b`和`show arp`，并将输出返回到我们的Python shell：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The script output is:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本输出为：
- en: '![](../images/00068.jpeg)It''s preferable to use `time.sleep()`when you need
    to execute commands that will take a long time on a remote device to force Python
    to wait some time till the device generates output and sends it back to python.
    Otherwise, python may return blank output to the user.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00068.jpeg)当您需要在远程设备上执行需要很长时间的命令时，最好使用`time.sleep()`来强制Python等待一段时间，直到设备生成输出并将其发送回Python。否则，Python可能会向用户返回空白输出。'
- en: Netmiko module
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netmiko模块
- en: The `netmiko` module is an enhanced version of paramiko and targets network
    devices specifically. While paramiko is designed to handle SSH connections to
    a device and to check whether the device is a server, printer, or network device,
    Netmiko is designed with network devices in mind and handles SSH connections more
    efficiently. Also, Netmiko supports a wide range of vendors and platforms.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`netmiko`模块是paramiko的增强版本，专门针对网络设备。虽然paramiko旨在处理对设备的SSH连接，并检查设备是服务器、打印机还是网络设备，但Netmiko是专为网络设备设计的，并更有效地处理SSH连接。此外，Netmiko支持广泛的供应商和平台。'
- en: Netmiko is considered a wrapper around paramiko and extends its features with
    many additional enhancements, such as access to vendor-enabled modes directly
    given the enable password, reading configuration from a file and pushing it to
    devices, disabling paging during login, and sending the carriage return `"\n"`
    by default after each command.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Netmiko被认为是paramiko的包装器，并通过许多附加增强功能扩展了其功能，例如直接访问供应商启用模式，读取配置文件并将其推送到设备，登录期间禁用分页，并在每个命令后默认发送回车符`"\n"`。
- en: Vendor support
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 供应商支持
- en: 'Netmiko supports many vendors and regularly adds new vendors to the supported
    list. Following is a list of supported vendors categorized into three groups:
    Regularly tested, Limited testing, and Experimental. You can find the list on
    the module GitHub page at [https://github.com/ktbyers/netmiko#supports](https://github.com/ktbyers/netmiko#supports).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Netmiko支持许多供应商，并定期向受支持的列表中添加新供应商。以下是受支持的供应商列表，分为三组：定期测试，有限测试和实验性。您可以在模块GitHub页面上找到列表[https://github.com/ktbyers/netmiko#supports](https://github.com/ktbyers/netmiko#supports)。
- en: 'The following screenshot shows the number of supported vendors under the Regularly
    tested category:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了定期测试类别下受支持供应商的数量：
- en: '![](../images/00069.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00069.jpeg)'
- en: 'The following screenshot shows the number of supported vendors under the Limited
    testing category:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了有限测试类别下受支持供应商的数量：
- en: '![](../images/00070.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00070.jpeg)'
- en: 'The following screenshot shows the number of supported vendors under the Experimental
    category:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了实验类别下受支持供应商的数量：
- en: '![](../images/00071.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00071.jpeg)'
- en: Installation and verification
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和验证
- en: 'To install `netmiko`, open the Windows cmd or Linux shell and execute the following
    command to get the latest package from PyPI:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`netmiko`，打开Windows cmd或Linux shell，并执行以下命令从PyPI获取最新包：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](../images/00072.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00072.jpeg)'
- en: 'Then import netmiko from the Python shell to make sure the module is correctly
    installed into Python site-packages:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从Python shell导入netmiko，以确保模块已正确安装到Python site-packages中：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using netmiko for SSH
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用netmiko进行SSH
- en: 'Now it''s time to utilize netmiko and see its power for SSHing to network devices
    and executing commands. By default, netmiko handles many operations in the background
    during session establishment, such as adding unknown SSH key hosts, setting the
    terminal type, width, and height, and accessing enable mode when required, then
    disabling paging by running a vendor-specific command. You will need to define
    the devices first in dictionary format and provide five mandatory keys:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候利用netmiko并看到它在SSH到网络设备并执行命令时的强大功能。默认情况下，netmiko在会话建立期间在后台处理许多操作，例如添加未知的SSH密钥主机，设置终端类型、宽度和高度，并在需要时访问启用模式，然后通过运行特定于供应商的命令来禁用分页。您需要首先以字典格式定义设备，并提供五个强制键：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first parameter is `device_type`, and it is used to define the platform
    vendor in order to execute the correct commands. Then, we need the `ip` address
    for SSH. This parameter could be the device hostname if it's already been resolved
    by your DNS, or just the IP address. Then we provide the `username`, `password`,
    and enable-mode password in `secret`. Notice you can use the `getpass()` module
    to hide the passwords and only prompt them during the script execution.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是`device_type`，用于定义平台供应商，以便执行正确的命令。然后，我们需要SSH的`ip`地址。如果已经通过DNS解析了设备主机名，这个参数可以是设备主机名，或者只是IP地址。然后我们提供`username`，`password`，和`secret`中的启用模式密码。请注意，您可以使用`getpass()`模块隐藏密码，并且只在脚本执行期间提示密码。
- en: While the keys order inside the variable is not important, the key's name should
    be exactly the same as provided in the previous example in order for netmiko to
    correctly parse the dictionary and to start to establish a connection to the device.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然变量内的键的顺序并不重要，但键的名称应与前面的示例中提供的完全相同，以便netmiko正确解析字典并开始建立与设备的连接。
- en: 'Next, we will import the `ConnectHandler` function from the netmiko module
    and give it the defined dictionary to start the connection. Since all our devices
    are configured with an enable-mode password, we need to access the enable mode
    by providing `.enable()` to the created connection. We will execute the command
    on the router terminal by using `.send_command()`, which will execute the command
    and return the device output to the variable:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从netmiko模块中导入`ConnectHandler`函数，并给它定义的字典以开始连接。由于我们所有的设备都配置了启用模式密码，我们需要通过提供`.enable()`来访问启用模式到创建的连接。我们将使用`.send_command()`在路由器终端上执行命令，该命令将执行命令并将设备输出返回到变量中：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The script output is:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本输出为：
- en: '![](../images/00073.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00073.jpeg)'
- en: Notice how the output is already cleaned from the device prompt and the command
    that we executed on the device. By default, Netmiko replaces them and generates
    a cleaned output, which could be processed by regular expressions, as we will
    see in the next chapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意输出已经从设备提示和我们在设备上执行的命令中清除。默认情况下，Netmiko会替换它们并生成一个经过清理的输出，可以通过正则表达式进行处理，我们将在下一章中看到。
- en: 'If you need to disable this behavior and want to see the device prompt and
    executed command in the returned output, then you need to provide additional flags
    to `.send_command()` functions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要禁用此行为，并希望在返回的输出中看到设备提示和执行的命令，则需要为`.send_command()`函数提供额外的标志：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `strip_command=False` and `strip_prompt=False` flags tell netmiko to keep
    both the prompt and command and not to replace them. They''re `True` by default
    and you can toggle them if you want:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`strip_command=False`和`strip_prompt=False`标志告诉netmiko保留提示和命令，不要替换它们。它们默认为`True`，如果需要，可以切换它们：'
- en: '![](../images/00074.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00074.jpeg)'
- en: Configuring devices using netmiko
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用netmiko配置设备
- en: 'Netmiko can be used to configure remote devices over SSH. It does that by accessing
    config mode using the `.config` method and then applies the configuration given
    in `list` format. The list itself can be provided inside the Python script or
    read from the file, then converted to a list using the `readlines()` method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Netmiko可以用于通过SSH配置远程设备。它通过使用`.config`方法访问配置模式，然后应用以`list`格式给出的配置来实现这一点。列表本身可以在Python脚本中提供，也可以从文件中读取，然后使用`readlines()`方法转换为列表：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the previous script, we did the same thing that we did before to connect
    to SW2 and enter enable mode, but this time we leveraged another netmiko method
    called `send_config_set()`, which takes the configuration in list format and accesses
    device configuration mode and starts to apply it. We have a simple configuration
    that modifies the `gig0/1` and `gig0/2` and applies trunk configuration on them.
    You can check if the command executed successfully by running `show run` command
    on the device; you should get output similar to the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个脚本中，我们做了与之前连接到SW2并进入启用模式相同的事情，但这次我们利用了另一个netmiko方法，称为`send_config_set()`，它以列表格式接收配置并访问设备配置模式并开始应用。我们有一个简单的配置，修改了`gig0/1`和`gig0/2`，并对它们应用了干线配置。您可以通过在设备上运行`show
    run`命令来检查命令是否成功执行；您应该会得到类似以下的输出：
- en: '![](../images/00075.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00075.jpeg)'
- en: Exception handling in netmiko
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: netmiko中的异常处理
- en: When we design our Python script, we assume that the device is up and running
    and also that the user has provided the correct credentials, which is not always
    the case. Sometimes there's a network connectivity issue between Python and the
    remote device or the user enters the wrong credentials. Usually, python will throw
    an exception if this happens and will exit, which is not the optimum solution.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计Python脚本时，我们假设设备正在运行，并且用户已经提供了正确的凭据，这并不总是情况。有时Python和远程设备之间存在网络连接问题，或者用户输入了错误的凭据。通常，如果发生这种情况，Python会抛出异常并退出，这并不是最佳解决方案。
- en: 'The exception handling module in netmiko, `netmiko.ssh_exception`, provides
    some exception classes that can handle such situations. The first one is `AuthenticationException`,
    and will catch the authentication errors in the remote device. The second class
    is `NetMikoTimeoutException`, which will catch timeouts or any connectivity issues
    between netmiko and the device. What we will need to do is wrap our ConnectHandler()
    method with the try-except clause and catch timeout and authentication exceptions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: netmiko中的异常处理模块`netmiko.ssh_exception`提供了一些可以处理这种情况的异常类。第一个是`AuthenticationException`，将捕获远程设备中的身份验证错误。第二个类是`NetMikoTimeoutException`，将捕获netmiko和设备之间的超时或任何连接问题。我们需要做的是用try-except子句包装我们的ConnectHandler()方法，并捕获超时和身份验证异常：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Device auto detect
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备自动检测
- en: 'Netmiko provides a mechanism that can guess the device type and detect it.
    It uses a combination of SNMP discovery OIDS and executes several show commands
    on the remote console to detect the router operating system and type, based on
    the output string. Then netmiko will load the appropriate driver into the `ConnectHandler()`
    class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Netmiko提供了一种可以猜测设备类型并检测它的机制。它使用SNMP发现OID和在远程控制台上执行几个show命令的组合来检测路由器操作系统和类型，基于输出字符串。然后netmiko将加载适当的驱动程序到`ConnectHandler()`类中：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the previous script:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个脚本中：
- en: The `device_type` inside the device dictionary will be `autodetect`, which will
    tell `netmiko` to wait and not load the driver till the netmiko guesses it.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备字典中的`device_type`将是`autodetect`，这将告诉`netmiko`等待并不加载驱动程序，直到netmiko猜测到它。
- en: Then we instruct the netmiko to perform device detection using the `SSHDetect()`
    class. The class will connect to the device using SSH and will execute some discovery
    commands to define the operating system type. The returned result will be a dictionary,
    and the best match will be assigned to the `device_type` variable using the `autodetect()`
    function.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们指示netmiko使用`SSHDetect()`类执行设备检测。该类将使用SSH连接到设备，并执行一些发现命令来定义操作系统类型。返回的结果将是一个字典，并且最佳匹配将使用`autodetect()`函数分配给`device_type`变量。
- en: You can see all the matching results by printing the `potential_matches`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过打印`potential_matches`来查看所有匹配的结果。
- en: Now we can update the device dictionary and assign the new `device_type` to
    it.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们可以更新设备字典并为其分配新的`device_type`。
- en: Using the telnet protocol in Python
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python中的telnet协议
- en: Telnet is one of the oldest protocols available in the TCP/IP stack. It is used
    primarily to exchange data over an established connection between a server and
    client. It uses TCP port `23` in the server for listening to the incoming connection
    from the client.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet是TCP/IP协议栈中可用的最古老的协议之一。它主要用于在服务器和客户端之间建立的连接上交换数据。它在服务器上使用TCP端口`23`来监听来自客户端的传入连接。
- en: In our case, we will create a Python script that acts as a telnet client, and
    other routers and switches in the topology will act as the telnet server. Python
    comes with a native support for telnet via a library called `telnetlib` so we
    don't need to install it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将创建一个充当telnet客户端的Python脚本，拓扑中的其他路由器和交换机将充当telnet服务器。Python自带了一个名为`telnetlib`的库，因此我们不需要安装它。
- en: After creating the client object by instantiating it from the `Telnet()` class,
    available from the `telnetlib` module, we can use the two important functions
    available inside `telnetlib`, which are `read_until()` (used to read the output)
    and `write()` (used to write on the remote device). Both functions are used to
    interact with the created channel, either by writing or reading the output returned
    from it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从`telnetlib`模块中可用的`Telnet()`类实例化客户端对象后，我们可以使用`telnetlib`中可用的两个重要函数，即`read_until()`（用于读取输出）和`write()`（用于在远程设备上写入）。这两个函数用于与创建的通道进行交互，无论是写入还是读取返回的输出。
- en: Also, it's important to note that reading the channel using `read_until()` will
    clear the buffer and data won't be available for any further reading. So, if you
    read important data and you will process and work on it later, then you need to
    save it as a variable before you continue with your script.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，重要的是要注意，使用`read_until()`读取通道将清除缓冲区，并且数据将不可用于进一步的读取。因此，如果您读取重要数据并且稍后将对其进行处理和处理，那么您需要在继续脚本之前将其保存为变量。
- en: Telnet data is sent in clear text format, so your credentials and password may
    be captured and viewed by anyone performing a man-in-the-middle attack. Some service
    providers and enterprises still use it and integrate it with VPNs and radius/tacacs
    protocols to provide lightweight and secure access.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet数据以明文格式发送，因此您的凭据和密码可能会被执行中间人攻击的任何人捕获和查看。一些服务提供商和企业仍然使用它，并将其与VPN和radius/tacacs协议集成，以提供轻量级和安全的访问。
- en: 'Follow the steps to understand the whole script:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤来理解整个脚本：
- en: 'We will import the `telnetlib` module inside our Python script and define the
    username and passwords in variables, as in the following code snippet:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在Python脚本中导入`telnetlib`模块，并将用户名和密码定义为变量，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will define a variable that establishes the connection with the remote host.
    Note that we won''t provide the username or password during connection establishment;
    we will only provide the IP address of the remote host:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将定义一个变量，用于与远程主机建立连接。请注意，在建立连接期间我们不会提供用户名或密码；我们只会提供远程主机的IP地址：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we will provide the username for the telnet connection by reading the returned
    output from the channel and searching for the `Username:` keyword. Then we write
    our admin username. The same process is used when we need to enter the telnet
    password and enable password:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将通过从通道返回的输出中读取`Username:`关键字并搜索来为telnet连接提供用户名。然后我们写入我们的管理员用户名。当我们需要输入telnet密码和启用密码时，也是使用相同的过程：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It's important to provide the exact keywords that appear in the console when
    you establish the telnet connection or the connection, will enter an infinite
    loop. Then Python script will be timed out with an error.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要提供在建立telnet连接或连接时出现在控制台中的确切关键字，否则连接将进入无限循环。然后Python脚本将因错误而超时。
- en: 'Finally, we will write the `show ip interface brief` command on the channel
    and read till the router prompt `#` to get the output. This should get us the
    interface configuration in the router:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在通道上写入`show ip interface brief`命令，并读取直到路由器提示`#`以获取输出。这应该可以让我们获取路由器中的接口配置：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The full script is:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的脚本如下：
- en: '![](../images/00076.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00076.jpeg)'
- en: 'The script output is:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本输出如下：
- en: '![](../images/00077.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00077.jpeg)'
- en: 'Notice that the output contains the executed command `show ip int b`, and the
    router prompt "R1#" is returned and printed in the `stdout`. We could use built-in
    string functions like `replace()` to clean them from the output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出包含执行的命令`show ip int b`，并且路由器提示“R1＃”被返回并打印在`stdout`中。我们可以使用内置的字符串函数如`replace()`来清除它们的输出：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](../images/00078.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00078.jpeg)'
- en: As you noticed, we provided both the password and enable password as clear text
    inside our script, which is considered a security issue. It's also not good practice
    to hardcode the values inside your Python script. Later, in the next section,
    we will hide the password and design a mechanism to provide credentials during
    script runtime only.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您注意到的，我们在脚本中以明文形式提供了密码和启用密码，这被认为是一个安全问题。在Python脚本中硬编码这些值也不是一个好的做法。稍后在下一节中，我们将隐藏密码并设计一个机制，仅在脚本运行时提供凭据。
- en: Also, if you want to execute commands that span multiple pages in output like
    `show running config` then you will need to disable paging first by sending `terminal
    length 0` after connecting to the device and before sending the command to it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您想要执行跨多个页面的命令输出，比如`show running config`，那么您需要先发送`terminal length 0`来禁用分页，然后再连接到设备并发送命令。
- en: Push configuration using telnetlib
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用telnetlib推送配置
- en: 'In previous section, we looked at a simplified operation of `telnetlib` by
    executing the `show ip int brief`. Now we need to utilize it to push VLAN configuration
    to the four switches in our topology. We could create a VLAN list using the python
    `range()` function and iterate over it to push the VLAN ID to the current switch.
    Notice we defined the switch IP addresses as an item inside the list, and this
    list will be our outer `for` loop. Also, I will use another built-in module called
    `getpass` to hide the password from the console and only provide it when the script
    is running:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们通过执行`show ip int brief`来简化`telnetlib`的操作。现在我们需要利用它来将VLAN配置推送到拓扑中的四个交换机。我们可以使用python的`range()`函数创建一个VLAN列表，并迭代它以将VLAN
    ID推送到当前交换机。请注意，我们将交换机IP地址定义为列表中的一个项目，这个列表将是我们外部的`for`循环。此外，我将使用另一个内置模块称为`getpass`来隐藏控制台中的密码，并且只在脚本运行时提供它：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In our outermost `for` loop, we are iterating over the devices and then, inside
    each iteration (each device), we're generating a vlan range from 300 to 400 and
    pushing them to the current device.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最外层的`for`循环中，我们正在迭代设备，然后在每次迭代（每个设备）中，我们从300到400生成一个vlan范围，并将它们推送到当前设备。
- en: 'The script output is:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本输出为：
- en: '![](../images/00079.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00079.jpeg)'
- en: 'Also, you can check the output from the switch console itself (output is omitted):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以检查交换机控制台本身的输出（输出已省略）：
- en: '![](../images/00080.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00080.jpeg)'
- en: Handling IP addresses and networks with netaddr
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用netaddr处理IP地址和网络
- en: 'Working and manipulating IP addresses is one of the most important tasks for
    network engineers. Python developers provide an amazing library that can understand
    the IP addresses and work on them, called `netaddr`. For example, assume you developed
    an application and part of it is to get the network and broadcast address for
    `129.183.1.55/21`. You can do that easily via two built-in methods inside the
    modules called `network` and `broadcast` respectively:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 处理和操作IP地址是网络工程师最重要的任务之一。Python开发人员提供了一个了不起的库，可以理解IP地址并对其进行操作，称为`netaddr`。例如，假设您开发了一个应用程序，其中的一部分是获取`129.183.1.55/21`的网络和广播地址。您可以通过模块内部的两个内置方法`network`和`broadcast`轻松实现：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In general, netaddr provides support for the following features:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，netaddr提供以下功能的支持：
- en: '**Layer 3 addresses:**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3层地址：**'
- en: IPv4 and IPv6 addresses, subnets, masks, prefixes
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv4和IPv6地址、子网、掩码、前缀
- en: Iterating, slicing, sorting, summarizing, and classifying IP networks
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代、切片、排序、总结和分类IP网络
- en: Dealing with various range formats (CIDR, arbitrary ranges and globs, nmap)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理各种范围格式（CIDR、任意范围和通配符、nmap）
- en: Set-based operations (unions, intersections, and so on) over IP addresses and
    subnets
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于集合的操作（并集、交集等）在IP地址和子网上
- en: Parsing a large variety of different formats and notations
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析各种不同格式和符号
- en: Looking up IANA IP block information
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找IANA IP块信息
- en: Generating DNS reverse lookups
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成DNS反向查找
- en: Supernetting and subnetting
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超网和子网
- en: '**Layer 2 addresses:**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**第2层地址：**'
- en: Representation and manipulation MAC addresses and EUI-64 identifiers
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示和操作MAC地址和EUI-64标识符
- en: Looking up IEEE organisational information (OUI, IAB)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找IEEE组织信息（OUI、IAB）
- en: Generating derived IPv6 addresses
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成派生的IPv6地址
- en: Netaddr installation
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netaddr安装
- en: 'The netaddr module can be installed using pip, as shown in the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: netaddr模块可以使用pip安装，如下所示：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As a verification for successfully installing the module, you could open PyCharm
    or the Python console and import the module after installation. If there is no
    error produced, then the module installed successfully:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 作为成功安装模块的验证，您可以在安装后打开PyCharm或Python控制台，并导入模块。如果没有产生错误，则模块安装成功：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Exploring netaddr methods
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索netaddr方法
- en: The `netaddr` module provides two important methods to define the IP address
    and work on it. The first one is called `IPAddress()` and it's used to define
    a single classful IP address with the default subnet mask. The second method is
    `IPNetwork()` and is used to define classless a IP address with CIDR.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`netaddr`模块提供了两种重要的方法来定义IP地址并对其进行操作。第一个称为`IPAddress()`，用于定义具有默认子网掩码的单个类IP地址。第二种方法是`IPNetwork()`，用于定义具有CIDR的无类别IP地址。'
- en: Both methods take the IP address as a string and return an IP address or IP
    network object for this string. There are many operations that could be executed
    on the returned object. For example, we can check if the IP address is unicast,
    multicast, loopback, private, public, or even valid or not valid. The output of
    the previous operation is either `True` or `False`, which can be used inside Python
    `if` conditions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都将IP地址作为字符串，并返回该字符串的IP地址或IP网络对象。可以对返回的对象执行许多操作。例如，我们可以检查IP地址是单播、多播、环回、私有、公共，甚至是有效还是无效。上述操作的输出要么是`True`，要么是`False`，可以在Python的`if`条件中使用。
- en: 'Also, the module supports comparison operations such as `==`, `<`, and `>`
    to compare two IP addresses, generating the subnets, and it is also possible to
    retrieve the list of supernets that a given IP address or subnet belongs to. Finally,
    the `netaddr` module can generate a full list of valid hosts (excluding the network
    IP and network broadcast):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该模块支持比较操作，如`==`、`<`和`>`来比较两个IP地址，生成子网，还可以检索给定IP地址或子网所属的超网列表。最后，`netaddr`模块可以生成一个完整的有效主机列表（不包括网络IP和网络广播）：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding script first requests the IP address and IP network from the user,
    using the `raw_input()` function, then will call two user methods, `check_ip_address()`
    and `operate_on_ip_network()`, and pass the entered values to them. The first
    function, `check_ip_address()`, will check the IP address entered and try to generate
    a report about IP address attributes, such as whether it is a unicast IP, multicast,
    private, or loopback, and will return the output to the user.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本首先使用`raw_input()`函数从用户那里请求IP地址和IP网络，然后将调用两个用户方法`check_ip_address()`和`operate_on_ip_network()`，并将输入的值传递给它们。第一个函数`check_ip_address()`将检查输入的IP地址并尝试生成有关IP地址属性的报告，例如它是单播IP、多播、私有还是环回，并将输出返回给用户。
- en: The second function `operate_on_ip_network()` takes the IP network and generates
    the network ID, netmask, broadcast, version, information known about this network,
    the IPv6 representation, and finally generates all IP addresses inside this subnet.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数`operate_on_ip_network()`接受IP网络并生成网络ID、子网掩码、广播、版本、已知有关此网络的信息、IPv6表示，最后生成此子网中的所有IP地址。
- en: It's important to notice that `net.info` will work and generate useful information
    only for public IP addresses, not private.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`net.info`仅对公共IP地址有效，而不适用于私有IP地址。
- en: Notice we need to import the `IP Network` and `IP Address` from the `netaddr`
    module before using them.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在使用它们之前，我们需要从`netaddr`模块导入`IP Network`和`IP Address`。
- en: 'The script output is:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本输出如下：
- en: '![](../images/00081.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00081.jpeg)'
- en: Sample use cases
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例用例
- en: As our network becomes bigger and starts to contain many devices from different
    vendors, we need to create modular Python script to automate various tasks in
    it. In the following sections, we will explore three use cases, which could be
    used to collect different information from our network and to lower the time needed
    for troubleshooting a problem, or at least restore the network configuration to
    its last known good state. This will allow network engineers to focus more on
    getting their job done and will provide an automated workflow for the business
    to handle network failure and restoration.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的网络变得越来越大，并开始包含来自不同供应商的许多设备，我们需要创建模块化的Python脚本来自动化其中的各种任务。在接下来的几节中，我们将探讨三种用例，这些用例可以用来从我们的网络中收集不同的信息，并降低故障排除所需的时间，或者至少将网络配置恢复到其上次已知的良好状态。这将使网络工程师更专注于完成他们的工作，并为企业提供处理网络故障和恢复的自动化工作流程。
- en: Backup device configuration
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份设备配置
- en: Backup device configuration is one of the most important tasks for any network
    engineer. In this use case, we will design a sample python script that can be
    used for different vendors and platforms in order to back up the device configuration.
    We will leverage the `netmiko` library to do this task.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 备份设备配置是任何网络工程师的最重要任务之一。在这种用例中，我们将设计一个示例Python脚本，可用于不同的供应商和平台，以备份设备配置。我们将利用`netmiko`库来执行此任务。
- en: The result files should be formatted with the device IP address in them for
    easy access or referencing later. For example, the result file for the SW1 backup
    operation should be `dev_10.10.88.111_.cfg`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 结果文件应该以设备IP地址格式化，以便以后轻松访问或引用。例如，SW1备份操作的结果文件应为`dev_10.10.88.111_.cfg`。
- en: Building the python script
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Python脚本
- en: We will start by defining our switches. We want to back up their configuration
    as a text file and provide the credentials and access details separated by commas.
    This will allow us to use the `split()` function inside the python script to get
    the data and use it inside the `ConnectHandler` function. Also, the file can be
    easily exported and imported from a Microsoft Excel sheet or from any database.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义我们的交换机。我们希望将它们的配置备份为文本文件，并提供由逗号分隔的凭据和访问详细信息。这将使我们能够在Python脚本中使用`split()`函数获取数据，并在`ConnectHandler`函数中使用它。此外，该文件可以轻松地从Microsoft
    Excel表或任何数据库中导出和导入。
- en: 'The file structure is:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 文件结构如下：
- en: '`<device_ipaddress>,<username>,<password>,<enable_password>,<vendor>`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`<device_ipaddress>,<username>,<password>,<enable_password>,<vendor>`'
- en: '![](../images/00082.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00082.jpeg)'
- en: 'Now we will start building our Python script by importing the file inside it,
    using the `with open` clause. We use the `readlines()` on the file to have each
    line as an item inside a list. We will create a `for` loop to iterate over each
    line and use the `split()` function to get the access details separated by commas
    and assign them to variables:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过导入文件并使用`with open`子句来开始构建我们的Python脚本。我们使用文件上的`readlines()`将每一行作为列表中的一个项目。我们将创建一个`for`循环来遍历每一行，并使用`split()`函数来通过逗号分隔访问详细信息并将它们分配给变量：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we need to create a modular and multi-vendor script, we need to have the `if`
    clause check the vendor in each line and assign a correct `device_type` and `backup_command`
    to the current device.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要创建一个模块化和多供应商的脚本，我们需要在每一行中使用`if`子句检查供应商，并为当前设备分配正确的`device_type`和`backup_command`。
- en: 'Moving on, we are now ready to establish the SSH connection to the device and
    execute the backup command on it using the `.send_command()` method available
    inside the `netmiko` module:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们现在准备使用`netmiko`模块中可用的`.send_command()`方法建立与设备的SSH连接并在其上执行备份命令：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the last few statements, we opened a file for writing and made its name contain
    the `ipaddr` variable collected from our text file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后几个语句中，我们打开了一个文件进行写入，并使其名称包含从我们的文本文件中收集的`ipaddr`变量。
- en: 'The script output is:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本输出如下：
- en: '![](../images/00083.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00083.jpeg)'
- en: 'Also, notice the backup configuration files are created in the project home
    directory, and its name contains the IP address of each device:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意备份配置文件是在项目主目录中创建的，其名称包含每个设备的IP地址：
- en: '![](../images/00084.jpeg)You can design a simple cron job on a Linux server
    or schedule a job on a Windows server, which runs the previous python script at
    a specific time. For example, the script could run on a daily basis at midnight
    and store the configuration in the `latest` directory so the team could refer
    to it later.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00084.jpeg)您可以在Linux服务器上设计一个简单的cron作业，或在Windows服务器上安排一个作业，在特定时间运行先前的Python脚本。例如，脚本可以每天午夜运行一次，并将配置存储在`latest`目录中，以便团队以后可以参考。'
- en: Creating your own access terminal
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您自己的访问终端
- en: 'In Python, and programming in general, you are the vendor! You can create any
    code combination and procedures you like in order to serve your needs. In the
    second use case, we will create our own terminal that accesses the router through
    `telnetlib`. By writing a few words in the terminal, it will be translated too
    many commands executed in the network device and return output, which could be
    just printed in the standard output or saved in file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，以及一般的编程中，您就是供应商！您可以创建任何代码组合和程序，以满足您的需求。在第二个用例中，我们将创建我们自己的终端，通过`telnetlib`访问路由器。通过在终端中写入几个单词，它将被翻译成在网络设备中执行的多个命令并返回输出，这些输出可以只打印在标准输出中，也可以保存在文件中：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, we establish a telnet connection to the router and enter the user access
    details till we reach enable mode. Then we create an infinite `while` loop that
    is always `true`, and we expect a command from the user using the `raw_input()`
    built-in function. When the user enters any command, the script will capture it
    and execute it directly to the network device.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们建立一个telnet连接到路由器，并输入用户访问详细信息，直到达到启用模式。然后，我们创建一个始终为`true`的无限`while`循环，并使用内置函数`raw_input()`来期望用户输入命令。当用户输入任何命令时，脚本将捕获它并直接执行到网络设备。
- en: However, if the user enters `health` or `discover` keywords then our terminal
    will be smart enough to execute a series of commands to reflect the desired operation.
    This should be extremely useful in case of network troubleshooting, and you can
    extend it with any daily operation. Imagine that you need to troubleshoot OSPF
    neighbourship problems between two routers. You just need to open your own terminal
    python script that you already taught him few commands needed for troubleshooting,
    and write something like `tshoot_ospf`. Once your script sees this magic keyword
    it will launch a series of multiple commands that print the OSPF neighborship
    status, interfaces of MTU, advertised network under OSPF, and so on till you find
    the issue.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果用户输入了`health`或`discover`关键字，那么我们的终端将足够智能，以执行一系列命令来反映所需的操作。这在网络故障排除的情况下应该非常有用，您可以扩展它以进行任何日常操作。想象一下，您需要在两台路由器之间排除OSPF邻居关系问题。您只需要打开您自己的终端Python脚本，您已经教给它了一些用于故障排除所需的命令，并写入类似于`tshoot_ospf`的内容。一旦您的脚本看到这个魔术关键字，它将启动一系列多个命令，打印OSPF邻居关系状态、MTU接口、在OSPF下广告的网络等，直到找到问题为止。
- en: '**Script output:**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**脚本输出：**'
- en: 'Try the first command in our script by writing `health` in the prompt:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在提示符中写入`health`来尝试我们脚本中的第一个命令：
- en: '![](../images/00085.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00085.jpeg)'
- en: As you can see, the script returns the output of multiple commands executed
    in the device.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，脚本返回了在设备中执行的多个命令的输出。
- en: 'Now try the second supported command, `discover`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试第二个支持的命令，`discover`：
- en: '![](../images/00086.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00086.jpeg)'
- en: This time the script returns the output of discover commands. In later chapters,
    we can parse the returned output and extract the useful information from it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这次脚本返回了发现命令的输出。在后面的章节中，我们可以解析返回的输出并从中提取有用的信息。
- en: Reading data from an Excel sheet
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Excel表中读取数据
- en: Network and IT engineers always use the excel sheet to store information about
    the infrastructure such as IP addresses, the device vendor, and credentials. Python
    support reading the information from an excel sheet and processes it so you can
    use it later during the script.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 网络和IT工程师总是使用Excel表来存储有关基础设施的信息，如IP地址、设备供应商和凭据。Python支持从Excel表中读取信息并处理它，以便您以后在脚本中使用。
- en: In this use case, we will use the **Excel Read** (**xlrd**) module to read the
    `UC3_devices.xlsx` file which contains the hostname, IP, username, password, enable
    password and vendor for our infrastructure and use this information to feed the
    `netmiko` module.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个用例中，我们将使用**Excel Read**（**xlrd**）模块来读取包含我们基础设施的主机名、IP、用户名、密码、启用密码和供应商信息的`UC3_devices.xlsx`文件，并使用这些信息来提供`netmiko`模块。
- en: 'The Excel sheet will be as shown in the following screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Excel表将如下截图所示：
- en: '![](../images/00087.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00087.jpeg)'
- en: 'First we will need to install the `xlrd` module, using `pip` as we will use
    it to read the Microsoft excel sheet:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装`xlrd`模块，使用`pip`，因为我们将使用它来读取Microsoft Excel表：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The XLRD module read the excel workbook and convert the row and columns into
    a matrix. For example, if you need to get the first item on the left, then you
    will need to access row[0][0]. The next item on the right will be row[0][1] and
    so on.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: XLRD模块读取Excel工作簿并将行和列转换为矩阵。例如，如果您需要获取左侧的第一项，那么您将需要访问row[0][0]。右侧的下一个项将是row[0][1]，依此类推。
- en: 'Also, when xlrd reads the sheet, it will increase a special counter called
    `nrows` (number of rows) by one each time it reads a row. Similarly, it will increase
    the `ncols` (number of columns) by one each time it reads the columns so you can
    know the size of your matrix via these two parameters:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当xlrd读取工作表时，它将通过每次读取一行来增加一个名为`nrows`（行数）的特殊计数器。类似地，它将通过每次读取列来增加`ncols`（列数），因此您可以通过这两个参数知道矩阵的大小：
- en: '![](../images/00088.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00088.jpeg)'
- en: You can provide the file path to `xlrd` using the `open_workbook()` function.
    Then you can access your sheet that contains the data either by using `sheet_by_index()`
    or `sheet_by_name()` functions. For our use case, our data is stored in the first
    sheet (index=0), and the file path is stored under the chapter name. Then we will
    iterate over the rows in the sheet and use the `row()` function to access a specific
    row. The returned output is a list, and we can access any item in it using the
    index.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`open_workbook()`函数提供`xlrd`的文件路径。然后，您可以通过使用`sheet_by_index()`或`sheet_by_name()`函数访问包含数据的工作表。对于我们的用例，我们的数据存储在第一个工作表（索引=0）中，并且文件路径存储在章节名称下。然后，我们将遍历工作表中的行，并使用`row()`函数访问特定行。返回的输出是一个列表，我们可以使用索引访问其中的任何项。
- en: 'Python script:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Python脚本：
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: More use cases
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多用例
- en: 'Netmiko could be used to realize many network automation use cases. It could
    be used for uploading, downloading files from remote devices during upgrade, loading
    configuration from Jinja2 templates, accessing terminal servers, accessing end
    devices, and many more. You can find a list of some useful use cases at [https://github.com/ktbyers/pynet/tree/master/presentations/dfwcug/examples](https://github.com/ktbyers/pynet/tree/master/presentations/dfwcug/examples):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Netmiko可以用于实现许多网络自动化用例。它可以用于在升级期间从远程设备上传、下载文件，从Jinja2模板加载配置，访问终端服务器，访问终端设备等等。您可以在[https://github.com/ktbyers/pynet/tree/master/presentations/dfwcug/examples](https://github.com/ktbyers/pynet/tree/master/presentations/dfwcug/examples)找到一些有用的用例列表：
- en: '![](../images/00089.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00089.jpeg)'
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started our practical journey into the network automation
    world with Python. We explored the different tools that are available in python
    to establish a connection to remote nodes with telnet and SSH and executed commands
    on them. Also, we learned how to handle IP addresses and network subnets with
    the help of the `netaddr` module. Finally, we strengthened our knowledge with
    two practical use cases.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了我们的Python网络自动化实践之旅。我们探索了Python中可用的不同工具，以建立与telnet和SSH远程节点的连接，并在其上执行命令。此外，我们学习了如何使用`netaddr`模块处理IP地址和网络子网。最后，我们通过两个实际用例加强了我们的知识。
- en: In the next chapter, we will work on the returned output and start to extract
    useful information from it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理返回的输出并开始从中提取有用的信息。
