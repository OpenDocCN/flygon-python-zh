["```py\n>>> values = [ 5, 3, 1, 7 ]\n```", "```py\n>>> 5 in values\nTrue\n```", "```py\n>>> sorted_value = sorted(values)\n>>> sorted_values\n[ 1, 3, 5, 7 ]\n```", "```py\ndef bisect_search(container, value):\n    index = bisect.bisect_left(container, value)\n    return index < len(container) and container[index] == value\n```", "```py\n>>> bisect_search(sorted_values, 5)\nTrue\n```", "```py\n>>> import timeit\n>>> values = list(range(1000))\n>>> 900 in values\nTrue\n>>> bisect_search(values, 900)\nTrue\n>>> timeit.timeit(lambda: 900 in values)\ntimeit.timeit(lambda: bisect_search(values, 900))\n13.61617108999053\n>>> timeit.timeit(lambda: bisect_search(values, 900))\n0.872136551013682\n```", "```py\n>>> values = [ 1, 3, 5, 7 ]\n>>> bisect.bisect_left(values, 5)\n2\n```", "```py\n>>> bisect.bisect_left(values, 4)\n2\n```", "```py\nclass Person:\n    def __init__(self, name, surname):\n        self.name = name\n        self.surname = surname\n    def __repr__(self):\n        return '<Person: %s %s>' % (self.name, self.surname)\n\npeople = [Person('Derek', 'Zoolander'),\n          Person('Alex', 'Zanardi'),\n          Person('Vito', 'Corleone')\n          Person('Mario', 'Rossi')]\n```", "```py\n>>> sorted_people = sorted(people, key=lambda v: v.name)\n[<Person: Alex Zanardi>, <Person: Derek Zoolander>, \n <Person: Mario Rossi>, <Person: Vito Corleone>]\n```", "```py\n>>> keys = [p.name for p in people]\n>>> bisect_search(keys, 'Alex')\nTrue\n```", "```py\nimport itertools\n\ndef iter_nth(iterable, nth):\n    return next(itertools.islice(iterable, nth, nth+1))\n```", "```py\n>>> values = (x for x in range(10))\n>>> iter_nth(values, 4)\n4\n```", "```py\nnames = [('Alex', 'Zanardi'),\n         ('Julius', 'Caesar'),\n         ('Anakin', 'Skywalker'),\n         ('Joseph', 'Joestar')]\n```", "```py\nimport itertools\n\ndef group_by_key(iterable, key):\n    iterable = sorted(iterable, key=key)\n    return {k: list(g) for k,g in itertools.groupby(iterable, key)}\n```", "```py\n>>> group_by_key(names, lambda v: v[0][0])\n{'A': [('Alex', 'Zanardi'), ('Anakin', 'Skywalker')], \n 'J': [('Julius', 'Caesar'), ('Joseph', 'Joestar')]}\n```", "```py\n>>> sample = [1, 2, 1, 1]\n>>> [(k, list(g)) for k,g in itertools.groupby(sample)]\n[(1, [1]), (2, [2]), (1, [1, 1])]\n```", "```py\n>>> sorted(sample)\n[1, 1, 1, 2]\n```", "```py\n>>> sorted_sample = sorted(sample)\n>>> [(k, list(g)) for k,g in itertools.groupby(sorted_sample)]\n[(1, [1, 1, 1]), (2, [2])]\n```", "```py\nnames = [ 'Sam', 'Axel', 'Aerith' ]\nsurnames = [ 'Fisher', 'Foley', 'Gainsborough' ]\n```", "```py\n>>> people = zip(names, surnames)\n>>> list(people)\n[('Sam', 'Fisher'), ('Axel', 'Foley'), ('Aerith', 'Gainsborough')]\n```", "```py\nvalues = [['a', 'b', 'c'],\n          [1, 2, 3],\n          ['X', 'Y', 'Z']]\n```", "```py\n>>> import itertools\n>>> chained = itertools.chain.from_iterable(values)\n```", "```py\n>>> list(chained)\n['a', 'b', 'c', 1, 2, 3, 'X', 'Y', 'Z']\n```", "```py\nitertools.chain(values[0], values[1], values[2])\n```", "```py\n>>> list(zip(chained, chained, chained))\n[('a', 'b', 'c'), (1, 2, 3), ('X', 'Y', 'Z')]\n```", "```py\n>>> chained = list(chained) \n>>> chained ['a', 'b', 'c', 1, 2, 3, 'X', 'Y', 'Z'] \n>>> ichained = iter(chained) \n>>> list(zip(ichained, ichained, ichained)) [('a', 'b', 'c'), (1, 2, 3), ('X', 'Y', 'Z')]\n```", "```py\n>>> chained = list(chained)\n>>> chained\n['a', 'b', 'c', 1, 2, 3, 'X', 'Y', 'Z']\n>>> list(zip(chained, chained, chained))\n[('a', 'a', 'a'), ('b', 'b', 'b'), ('c', 'c', 'c'), \n (1, 1, 1), (2, 2, 2), (3, 3, 3), \n ('X', 'X', 'X'), ('Y', 'Y', 'Y'), ('Z', 'Z', 'Z')]\n```", "```py\n>>> import itertools\n>>> c = itertools.product(('A', 'B', 'C'), repeat=2)\n>>> list(c)\n[('A', 'A'), ('A', 'B'), ('A', 'C'),\n ('B', 'A'), ('B', 'B'), ('B', 'C'), \n ('C', 'A'), ('C', 'B'), ('C', 'C')]\n```", "```py\n>>> c = itertools.permutations(('A', 'B', 'C'), 2)\n>>> list(c)\n[('A', 'B'), ('A', 'C'), \n ('B', 'A'), ('B', 'C'), \n ('C', 'A'), ('C', 'B')]\n```", "```py\n>>> c = itertools.combinations(('A', 'B', 'C'), 2)\n>>> list(c)\n[('A', 'B'), ('A', 'C'), ('B', 'C')]\n```", "```py\n>>> values = [ 1, 2, 3, 4, 5 ]\n```", "```py\n>>> import functools, operator\n>>> functools.reduce(operator.add, values)\n15\n```", "```py\n>>> import itertools\n>>> list(itertools.accumulate(values, operator.add))\n[1, 3, 6, 10, 15]\n```", "```py\n>>> lines = ['this is the first line',\n...          'then there is one more',\n...          'and finally the last one.']\n>>> functools.reduce(lambda x, y: x + len(y), [0] + lines)\n69\n```", "```py\n>>> dicts = [dict(name='Alessandro'), dict(surname='Molina'),\n...          dict(country='Italy')]\n>>> functools.reduce(lambda d1, d2: {**d1, **d2}, dicts)\n{'name': 'Alessandro', 'surname': 'Molina', 'country': 'Italy'}\n```", "```py\n>>> import operator\n>>> nesty = {'a': {'b': {'c': {'d': {'e': {'f': 'OK'}}}}}}\n>>> functools.reduce(operator.getitem, 'abcdef', nesty)\n'OK'\n```", "```py\nimport functools\n\n@functools.lru_cache(maxsize=None)\ndef fibonacci(n):\n    '''inefficient recursive version of Fibonacci number'''\n    if n > 1:\n        return fibonacci(n-1) + fibonacci(n-2)\n    return n\n```", "```py\nfibonacci_seq = [fibonacci(n) for n in range(100)]\n```", "```py\n>>> print(fibonacci_seq)\n[0, 1, 1, 2, 3, 5, 8, 13, 21 ...\n```", "```py\n>>> import timeit\n>>> timeit.timeit(lambda: [fibonacci(n) for n in range(40)], number=1)\n0.000033469987101\n```", "```py\n>>> timeit.timeit(lambda: [fibonacci(n) for n in range(40)], number=1)\n89.14927123498637\n```", "```py\nimport operator\n\noperators = {\n    '+': operator.add,\n    '-': operator.sub,\n    '*': operator.mul,\n    '/': operator.truediv\n}\n\ndef calculate(expression):\n    parts = expression.split()\n\n    try:\n        result = int(parts[0])\n    except:\n        raise ValueError('First argument of expression must be numberic')\n\n    operator = None\n    for part in parts[1:]:\n        try:\n            num = int(part)\n            if operator is None:\n                raise ValueError('No operator proviede for the numbers')\n        except ValueError:\n            if operator:\n                raise ValueError('operator already provided')\n            operator = operators[part]\n        else:\n            result = operator(result, num)\n            operator = None\n\n    return result\n```", "```py\n>>> print(calculate('5 + 3'))\n8\n>>> print(calculate('1 + 2 + 3'))\n6\n>>> print(calculate('3 * 2 + 4'))\n10\n```", "```py\n>>> import functools, operator\n>>>\n>>> values = range(10)\n>>> mul3 = functools.partial(operator.mul, 3)\n>>> list(map(mul3, values))\n[0, 3, 6, 9, 12, 15, 18, 21, 24, 27]\n```", "```py\nfrom functools import singledispatch\n\n@singledispatch\ndef human_readable(d):\n    raise ValueError('Unsupported argument type %s' % type(d))\n\n@human_readable.register(dict)\ndef human_readable_dict(d):\n    for key, value in d.items():\n        print('{}: {}'.format(key, value))\n\n@human_readable.register(list)\n@human_readable.register(tuple)\ndef human_readable_list(d):\n    for key, value in d:\n        print('{}: {}'.format(key, value))\n```", "```py\n>>> human_readable({'name': 'Tifa', 'surname': 'Lockhart'})\nname: Tifa\nsurname: Lockhart\n\n>>> human_readable([('name', 'Nobuo'), ('surname', 'Uematsu')])\nname: Nobuo\nsurname: Uematsu\n\n>>> human_readable(5)\nTraceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    File \"<stdin>\", line 2, in human_readable\nValueError: Unsupported argument type <class 'int'>\n```", "```py\n>>> human_readable.registry\nmappingproxy({\n    <class 'list'>: <function human_readable_list at 0x10464da60>, \n    <class 'object'>: <function human_readable at 0x10464d6a8>, \n    <class 'dict'>: <function human_readable_dict at 0x10464d950>, \n    <class 'tuple'>: <function human_readable_list at 0x10464da60>\n})\n```", "```py\ndef decorator(f):\n    def _f(*args, **kwargs):\n        return f(*args, **kwargs)\n    return _f\n\n@decorator\ndef sumtwo(a, b):\n    \"\"\"Sums a and b\"\"\"\n    return a + back\n```", "```py\n>>> print(sumtwo.__name__)\n'_f'\n>>> print(sumtwo.__doc__)\nNone\n```", "```py\nfrom functools import wraps\n\ndef decorator(f):\n    @wraps(f)\n    def _f(*args, **kwargs):\n        return f(*args, **kwargs)\n    return _f\n```", "```py\n@decorator\ndef sumthree(a, b):\n    \"\"\"Sums a and b\"\"\"\n    return a + back\n```", "```py\n>>> print(sumthree.__name__)\n'sumthree'\n>>> print(sumthree.__doc__)\n'Sums a and b'\n```", "```py\n>>> import inspect\n>>> inspect.getfullargspec(sumthree)\nFullArgSpec(args=[], varargs='args', varkw='kwargs', defaults=None, \n            kwonlyargs=[], kwonlydefaults=None, annotations={})\n```", "```py\n>>> inspect.getfullargspec(sumthree.__wrapped__)\nFullArgSpec(args=['a', 'b'], varargs=None, varkw=None, defaults=None, \n            kwonlyargs=[], kwonlydefaults=None, annotations={})\n```", "```py\n>>> inspect.signature(sumthree)\n(a, b)\n```", "```py\nclass MyClass(object):\n    @decorator\n    @classmethod\n    def dosum(cls, a, b):\n        return a+b\n```", "```py\n>>> MyClass.dosum(3, 3)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n    return f(*args, **kwargs)\nTypeError: 'classmethod' object is not callable\n```", "```py\nclass MyClass(object):\n    @classmethod\n    @decorator\n    def dosum(cls, a, b):\n        return a+b\n```", "```py\n>>> MyClass.dosum(3, 3)\n6\n```", "```py\n@contextlib.contextmanager\ndef logentrance():\n    print('Enter')\n    yield\n    print('Exit')\n```", "```py\n>>> with logentrance():\n>>>    print('This is inside')\nEnter\nThis is inside\nExit\n```", "```py\n@contextlib.contextmanager\ndef logentrance():\n    print('Enter')\n    try:\n        yield\n    except:\n        print('Exception')\n        raise\n    finally:\n        print('Exit')\n```", "```py\n>>> with logentrance():\n        raise Exception('This is an error')\nEnter\nException\nExit\nTraceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n        raise Exception('This is an error')\nException: This is an error\n```", "```py\n@contextlib.contextmanager\ndef first():\n    print('First')\n    yield\n\n@contextlib.contextmanager\ndef second():\n    print('Second')\n    yield\n```", "```py\n>>> with first(), second():\n>>>     print('Inside')\nFirst\nSecond\nInside\n```", "```py\nfrom contextlib import ExitStack\n\nfor n in range(5):\n    with ExitStack() as stack:\n        stack.enter_context(first())\n        if n % 2 == 0:\n            stack.enter_context(second())\n        print('NUMBER: {}'.format(n))\n```", "```py\nFirst\nSecond\nNUMBER: 0\nFirst\nNUMBER: 1\nFirst\nSecond\nNUMBER: 2\nFirst\nNUMBER: 3\nFirst\nSecond\nNUMBER: 4\n```"]