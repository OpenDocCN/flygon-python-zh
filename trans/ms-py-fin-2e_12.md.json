["```py\nwhile is_main_loop:  # Main game engine loop\n     handle_input_events()\n     update_AI()\n     update_physics()\n     update_game_objects()\n     render_screen()\n     sleep(1/60)  # Assuming a 60 frames-per-second video game rate\n```", "```py\ndef handle_input_events()\n    event = get_latest_event()\n    if event.type == 'UP_KEY_PRESS':\n        move_player_up()\n    elif event.type == 'DOWN_KEY_PRESS':\n        move_player_down()\n```", "```py\nclass TickData(object):\n    \"\"\" Stores a single unit of data \"\"\"\n\n    def __init__(self, timestamp='', symbol='', \n                 open_price=0, close_price=0, total_volume=0):\n        self.symbol = symbol\n        self.timestamp = timestamp\n        self.open_price = open_price\n        self.close_price = close_price\n        self.total_volume = total_volume\n```", "```py\nclass MarketData(object):\n    \"\"\" Stores the most recent tick data for all symbols \"\"\"\n\n    def __init__(self):\n        self.recent_ticks = dict()  # indexed by symbol\n\n    def add_tick_data(self, tick_data):\n        self.recent_ticks[tick_data.symbol] = tick_data\n\n    def get_open_price(self, symbol):\n        return self.get_tick_data(symbol).open_price\n\n    def get_close_price(self, symbol):\n        return self.get_tick_data(symbol).close_price\n\n    def get_tick_data(self, symbol):\n        return self.recent_ticks.get(symbol, TickData())\n\n    def get_timestamp(self, symbol):\n        return self.recent_ticks[symbol].timestamp\n```", "```py\nclass MarketDataSource(object):\n    def __init__(self, symbol, tick_event_handler=None, start='', end=''):\n        self.market_data = MarketData()\n\n        self.symbol = symbol\n        self.tick_event_handler = tick_event_handler\n        self.start, self.end = start, end\n        self.df = None\n```", "```py\ndef fetch_historical_prices(self):\n   import quandl\n\n   # Update your Quandl API key here...\n  QUANDL_API_KEY = 'BCzkk3NDWt7H9yjzx-DY'\n  quandl.ApiConfig.api_key = QUANDL_API_KEY\n   df = quandl.get(self.symbol, start_date=self.start, end_date=self.end)\n   return df\n```", "```py\ndef run(self):\n    if self.df is None:\n        self.df = self.fetch_historical_prices()\n\n    total_ticks = len(self.df)\n    print('Processing total_ticks:', total_ticks)\n\n    for timestamp, row in self.df.iterrows():\n        open_price = row['Open']\n        close_price = row['Close']\n        volume = row['Volume']\n\n        print(timestamp.date(), 'TICK', self.symbol,\n              'open:', open_price,\n              'close:', close_price)\n        tick_data = TickData(timestamp, self.symbol, open_price,\n                            close_price, volume)\n        self.market_data.add_tick_data(tick_data)\n\n        if self.tick_event_handler:\n            self.tick_event_handler(self.market_data)\n```", "```py\nclass Order(object):\n    def __init__(self, timestamp, symbol, \n        qty, is_buy, is_market_order, \n        price=0\n    ):\n        self.timestamp = timestamp\n        self.symbol = symbol\n        self.qty = qty\n        self.price = price\n        self.is_buy = is_buy\n        self.is_market_order = is_market_order\n        self.is_filled = False\n        self.filled_price = 0\n        self.filled_time = None\n        self.filled_qty = 0\n```", "```py\nclass Position(object):\n    def __init__(self, symbol=''):\n        self.symbol = symbol\n        self.buys = self.sells = self.net = 0\n        self.rpnl = 0\n        self.position_value = 0\n```", "```py\ndef on_position_event(self, is_buy, qty, price):\n    if is_buy:\n        self.buys += qty\n    else:\n        self.sells += qty\n\n    self.net = self.buys - self.sells\n    changed_value = qty * price * (-1 if is_buy else 1)\n    self.position_value += changed_value\n\n    if self.net == 0:\n        self.rpnl = self.position_value\n        self.position_value = 0\n```", "```py\ndef calculate_unrealized_pnl(self, price):\n    if self.net == 0:\n        return 0\n\n    market_value = self.net * price\n    upnl = self.position_value + market_value\n    return upnl\n```", "```py\nfrom abc import abstractmethod\n\nclass Strategy:\n    def __init__(self, send_order_event_handler):\n        self.send_order_event_handler = send_order_event_handler\n\n    @abstractmethod\n    def on_tick_event(self, market_data):\n        raise NotImplementedError('Method is required!')\n\n    @abstractmethod\n    def on_position_event(self, positions):\n        raise NotImplementedError('Method is required!')\n\n    def send_market_order(self, symbol, qty, is_buy, timestamp):\n        if self.send_order_event_handler:\n            order = Order(\n                timestamp,\n                symbol,\n                qty,\n                is_buy,\n                is_market_order=True,\n                price=0,\n            )\n            self.send_order_event_handler(order)\n```", "```py\nimport pandas as pd\n\nclass MeanRevertingStrategy(Strategy):\n    def __init__(self, symbol, trade_qty,\n        send_order_event_handler=None, lookback_intervals=20,\n        buy_threshold=-1.5, sell_threshold=1.5\n    ):\n        super(MeanRevertingStrategy, self).__init__(\n            send_order_event_handler)\n\n        self.symbol = symbol\n        self.trade_qty = trade_qty\n        self.lookback_intervals = lookback_intervals\n        self.buy_threshold = buy_threshold\n        self.sell_threshold = sell_threshold\n\n        self.prices = pd.DataFrame()\n        self.is_long = self.is_short = False\n```", "```py\ndef on_position_event(self, positions):\n    position = positions.get(self.symbol)\n\n    self.is_long = position and position.net > 0\n    self.is_short = position and position.net < 0\n```", "```py\ndef on_tick_event(self, market_data):\n    self.store_prices(market_data)\n\n    if len(self.prices) < self.lookback_intervals:\n        return\n\n    self.generate_signals_and_send_order(market_data)\n```", "```py\ndef store_prices(self, market_data):\n    timestamp = market_data.get_timestamp(self.symbol)\n    close_price = market_data.get_close_price(self.symbol)\n    self.prices.loc[timestamp, 'close'] = close_price\n```", "```py\ndef generate_signals_and_send_order(self, market_data):\n    signal_value = self.calculate_z_score()\n    timestamp = market_data.get_timestamp(self.symbol)\n\n    if self.buy_threshold > signal_value and not self.is_long:\n        print(timestamp.date(), 'BUY signal')\n        self.send_market_order(\n            self.symbol, self.trade_qty, True, timestamp)\n    elif self.sell_threshold < signal_value and not self.is_short:\n        print(timestamp.date(), 'SELL signal')\n        self.send_market_order(\n            self.symbol, self.trade_qty, False, timestamp)\n```", "```py\ndef calculate_z_score(self):\n    self.prices = self.prices[-self.lookback_intervals:]\n    returns = self.prices['close'].pct_change().dropna()\n    z_score = ((returns - returns.mean()) / returns.std())[-1]\n    return z_score\n```", "```py\nclass BacktestEngine:\n    def __init__(self, symbol, trade_qty, start='', end=''):\n        self.symbol = symbol\n        self.trade_qty = trade_qty\n        self.market_data_source = MarketDataSource(\n            symbol,\n            tick_event_handler=self.on_tick_event,\n            start=start, end=end\n        )\n\n        self.strategy = None\n        self.unfilled_orders = []\n        self.positions = dict()\n        self.df_rpnl = None\n```", "```py\ndef start(self, **kwargs):\n    print('Backtest started...')\n\n    self.unfilled_orders = []\n    self.positions = dict()\n    self.df_rpnl = pd.DataFrame()\n\n    self.strategy = MeanRevertingStrategy(\n        self.symbol,\n        self.trade_qty,\n        send_order_event_handler=self.on_order_received,\n        **kwargs\n    )\n    self.market_data_source.run()\n\n    print('Backtest completed.')\n```", "```py\ndef on_order_received(self, order):\n    \"\"\" Adds an order to the order book \"\"\"\n    print(\n        order.timestamp.date(),\n        'ORDER',\n        'BUY' if order.is_buy else 'SELL',\n        order.symbol,\n        order.qty\n    )\n    self.unfilled_orders.append(order)\n```", "```py\ndef on_tick_event(self, market_data):\n    self.match_order_book(market_data)\n    self.strategy.on_tick_event(market_data)\n    self.print_position_status(market_data)\n```", "```py\ndef match_order_book(self, market_data):\n    if len(self.unfilled_orders) > 0:\n        self.unfilled_orders = [\n            order for order in self.unfilled_orders\n            if self.match_unfilled_orders(order, market_data)\n        ]\n\ndef match_unfilled_orders(self, order, market_data):\n    symbol = order.symbol\n    timestamp = market_data.get_timestamp(symbol)\n\n    \"\"\" Order is matched and filled \"\"\"\n    if order.is_market_order and timestamp > order.timestamp:\n        open_price = market_data.get_open_price(symbol)\n\n        order.is_filled = True\n        order.filled_timestamp = timestamp\n        order.filled_price = open_price\n\n        self.on_order_filled(\n            symbol, order.qty, order.is_buy,\n            open_price, timestamp\n        )\n        return False\n\n    return True\n```", "```py\ndef on_order_filled(self, symbol, qty, is_buy, filled_price, timestamp):\n    position = self.get_position(symbol)\n    position.on_position_event(is_buy, qty, filled_price)\n    self.df_rpnl.loc[timestamp, \"rpnl\"] = position.rpnl\n\n    self.strategy.on_position_event(self.positions)\n\n    print(\n        timestamp.date(),\n        'FILLED', \"BUY\" if is_buy else \"SELL\",\n        qty, symbol, 'at', filled_price\n    )\n```", "```py\n def get_position(self, symbol):\n    if symbol not in self.positions:\n        self.positions[symbol] = Position(symbol)\n\n    return self.positions[symbol]\n```", "```py\ndef print_position_status(self, market_data):\n    for symbol, position in self.positions.items():\n        close_price = market_data.get_close_price(symbol)\n        timestamp = market_data.get_timestamp(symbol)\n\n        upnl = position.calculate_unrealized_pnl(close_price)\n\n        print(\n            timestamp.date(),\n            'POSITION',\n            'value:%.3f' % position.position_value,\n            'upnl:%.3f' % upnl,\n            'rpnl:%.3f' % position.rpnl\n        )\n```", "```py\nengine = BacktestEngine(\n    'WIKI/AAPL', 1,\n    start='2015-01-01',\n    end='2017-12-31'\n)\n```", "```py\nengine.start(\n    lookback_intervals=20,\n    buy_threshold=-1.5,\n    sell_threshold=1.5\n)\n```", "```py\nBacktest started...\nProcessing total_ticks: 753\n2015-01-02 TICK WIKI/AAPL open: 111.39 close: 109.33\n...\n2015-02-25 TICK WIKI/AAPL open: 131.56 close: 128.79\n2015-02-25 BUY signal\n2015-02-25 ORDER BUY WIKI/AAPL 1\n2015-02-26 TICK WIKI/AAPL open: 128.785 close: 130.415\n2015-02-26 FILLED BUY 1 WIKI/AAPL at 128.785\n2015-02-26 POSITION value:-128.785 upnl:1.630 rpnl:0.000\n2015-02-27 TICK WIKI/AAPL open: 130.0 close: 128.46\n```", "```py\n...\n2015-03-30 TICK WIKI/AAPL open: 124.05 close: 126.37\n2015-03-30 SELL signal\n2015-03-30 ORDER SELL WIKI/AAPL 1\n2015-03-30 POSITION value:-128.785 upnl:-2.415 rpnl:0.000\n2015-03-31 TICK WIKI/AAPL open: 126.09 close: 124.43\n2015-03-31 FILLED SELL 1 WIKI/AAPL at 126.09\n2015-03-31 POSITION value:0.000 upnl:0.000 rpnl:-2.695\n...\n```", "```py\n%matplotlib inline\nimport matplotlib.pyplot as plt\n\nengine.df_rpnl.plot(figsize=(12, 8));\n```", "```py\nTHRESHOLDS = [\n    (-0.5, 0.5),\n    (-1.5, 1.5),\n    (-2.5, 2.0),\n    (-1.5, 2.5),\n]\n```", "```py\n%matplotlib inline import matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(nrows=len(THRESHOLDS)//2, \n    ncols=2, figsize=(12, 8))\nfig.subplots_adjust(hspace=0.4)\nfor i, (buy_threshold, sell_threshold) in enumerate(THRESHOLDS):\n     engine.start(\n         lookback_intervals=20,\n         buy_threshold=buy_threshold,\n         sell_threshold=sell_threshold\n     )\n     df_rpnls = engine.df_rpnl\n     ax = axes[i // 2, i % 2]\n     ax.set_title(\n         'B/S thresholds:(%s,%s)' % \n         (buy_threshold, sell_threshold)\n     )\n     df_rpnls.plot(ax=ax)\n```"]