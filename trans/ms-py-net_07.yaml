- en: Network Monitoring with Python – Part 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行网络监控-第1部分
- en: 'Imagine you get a call at 2:00 a.m. in the morning. The person on the other
    end says: "Hi, we are facing a difficult issue that is impacting production services*.*
    We suspect it might be network-related. Can you check this for us? For this type
    of urgent, open-ended question, what would be the first thing you do?" Most of
    the time, the thing that comes to mind would be: What changed between the time
    when the network was working until something went wrong? Chances are you would
    check your monitoring tool and see if any of the key metrics changed in the last
    few hours. Better yet is if you have received any monitoring alerts from any metric
    baseline deviation.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你在凌晨2点接到一个电话。电话那头的人说：“嗨，我们遇到了一个影响生产服务的困难问题。我们怀疑可能与网络有关。你能帮我们检查一下吗？”对于这种紧急的、开放式的问题，你会做什么？大多数情况下，脑海中浮现的第一件事是：在网络正常运行到出现问题之间发生了什么变化？很可能你会检查你的监控工具，看看最近几个小时内是否有任何关键指标发生了变化。更好的是，如果你收到了任何与指标基线偏差相关的监控警报。
- en: 'Throughout this book, we have been discussing various ways to systematically
    make predictable changes to our network, with the goal of keeping the network
    running as smoothly as possible. However, networks are not static – far from it –
    they are probably one of the most fluid parts of the entire infrastructure. By
    definition, a network connects different parts of the infrastructure together,
    constantly passing traffic back and forth. There are lots of moving parts that
    can cause your network to stop working as expected: hardware failures, software
    with bugs, human mistakes despite their best intentions, and many more. It is
    not a question of whether things would go wrong, but rather a question of when
    and what went wrong when it happens. We need ways to monitor our network to make
    sure it works as expected and hopefully be notified when it does not.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们一直在讨论系统地对网络进行可预测的更改的各种方法，目标是尽可能使网络运行顺畅。然而，网络并不是静态的-远非如此-它们可能是整个基础设施中最流动的部分之一。根据定义，网络连接了基础设施的不同部分，不断地来回传递流量。有很多移动的部分可能导致您的网络停止按预期工作：硬件故障、软件错误、尽管有最好的意图，人为错误，等等。问题不在于事情是否会出错，而在于当它发生时，出了什么问题。我们需要监控我们的网络，以确保它按预期工作，并希望在它不按预期工作时得到通知。
- en: In upcoming two chapters, we will look at various ways to perform network monitoring
    tasks. Many of the tools we have looked at thus far can be tied together or directly
    managed by Python. Like many tools we have looked at, network monitoring has to
    do with two parts. First, we need to know what information the equipment is capable
    of transmitting. Second, we need to identify what useful information we can interpret
    from them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将看一些执行网络监控任务的各种方法。到目前为止，我们看到的许多工具可以通过Python进行绑定或直接管理。和我们看到的许多工具一样，网络监控涉及两个部分。首先，我们需要知道设备能够传输什么信息。其次，我们需要确定我们可以从中解释出什么有用的信息。
- en: 'We will look at a few tools that allow us to monitor the network effectively:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一些工具，让我们能够有效地监控网络：
- en: The **Simple Network Management Protocol** (**SNMP**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单网络管理协议**（**SNMP**）'
- en: Matplotlib and Pygal visualization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matplotlib和Pygal可视化
- en: MRTG and Cacti
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MRTG和Cacti
- en: This list is not exhaustive, and there is certainly no lack of commercial vendors
    in the network monitoring space. The basics of network monitoring that we will
    look at, however, carry well for both open source and commercial tools.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表并不详尽，网络监控领域显然没有缺乏商业供应商。然而，我们将要看的网络监控基础知识对于开源和商业工具都适用。
- en: Lab setup
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验室设置
- en: 'The lab for this chapter is similar to the one in [Chapter 6](30262891-a82e-4bef-aae2-2e8fe530a16f.xhtml),
    *Network Security with Python*, but with this difference: both of the network
    devices are IOSv devices. Here''s an illustration of this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的实验室与[第6章](30262891-a82e-4bef-aae2-2e8fe530a16f.xhtml)中的实验室类似，*使用Python进行网络安全*，但有一个区别：网络设备都是IOSv设备。以下是这一点的说明：
- en: '![](assets/5e51171c-d3e7-46ad-b1bc-1d0afade785a.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5e51171c-d3e7-46ad-b1bc-1d0afade785a.png)'
- en: The two Ubuntu hosts will be used to generate traffic across the network so
    that we can look at some non-zero counters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 两台Ubuntu主机将用于在网络中生成流量，以便我们可以查看一些非零计数器。
- en: SNMP
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SNMP
- en: SNMP is a standardized protocol used to collect and manage devices. Although
    the standard allows you to use SNMP for device management, in my experience, most
    network administrators prefer to keep SNMP as an information collection mechanism
    only. Since SNMP operates on UDP, which is connectionless, and considering the
    relatively weak security mechanism in versions 1 and 2, making device changes
    via SNMP tends to make network operators a bit uneasy. SNMP version 3 has added
    cryptographic security and new concepts and terminologies to the protocol, but
    the way the technology is adapted varies among network device vendors.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP是一种标准化的协议，用于收集和管理设备。尽管该标准允许你使用SNMP进行设备管理，但根据我的经验，大多数网络管理员更喜欢将SNMP仅作为信息收集机制。由于SNMP在UDP上运行，UDP是无连接的，并且考虑到版本1和2中相对较弱的安全机制，通过SNMP进行设备更改往往会让网络运营商感到有些不安。SNMP版本3增加了加密安全性和协议的新概念和术语，但技术的适应方式在网络设备供应商之间存在差异。
- en: 'SNMP is widely used in network monitoring and has been around since 1988 as
    part of RFC 1065\. The operations are straightforward, with the network manager
    sending `GET` and `SET` requests toward the device and the device with the SNMP
    agent responding with the information per request. The most widely adopted standard
    is SNMPv2c, which is defined in RFC 1901 – RFC 1908\. It uses a simple community-based
    security scheme for security. It has also introduced new features, such as the
    ability to get bulk information. The following diagram displays the high-level
    operation for SNMP:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP在网络监控中被广泛使用，自1988年作为RFC 1065的一部分以来一直存在。操作很简单，网络管理器向设备发送`GET`和`SET`请求，设备与SNMP代理响应每个请求的信息。最广泛采用的标准是SNMPv2c，定义在RFC
    1901 - RFC 1908中。它使用简单的基于社区的安全方案进行安全。它还引入了新功能，例如获取批量信息的能力。以下图显示了SNMP的高级操作：
- en: '![](assets/c3503470-34a9-43fc-8986-07ffaa47eb09.png)SNMP operations'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c3503470-34a9-43fc-8986-07ffaa47eb09.png)SNMP操作'
- en: The information residing in the device is structured in the **Management Information
    Base** (**MIB**). The MIB uses a hierarchical namespace containing an **Object
    Identifier** (**OID**), which represents the information that can be read and
    fed back to the requester. When we talk about using SNMP to query device information,
    we are really talking about using the management station to query the specific
    OID that represents the information we are after. There is a common OID structure,
    such as systems and interfaces OID, that is shared among vendors. Besides common
    OID, each vendor can also supply an enterprise-level OID that is specific to them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 设备中的信息存储在**管理信息库**（**MIB**）中。MIB使用包含**对象标识符**（**OID**）的分层命名空间，表示可以读取并反馈给请求者的信息。当我们谈论使用SNMP查询设备信息时，我们实际上是在谈论使用管理站点查询代表我们所需信息的特定OID。有一个常见的OID结构，例如系统和接口OID，这在供应商之间是共享的。除了常见的OID，每个供应商还可以提供特定于他们的企业级OID。
- en: As an operator, you are required to put some effort into consolidating information
    into an OID structure in your environment to retrieve useful information. This
    can sometimes be a tedious process of finding one OID at a time. For example,
    you might be making a request to a device OID and receive a value of 10,000\.
    What is that value? Is that interface traffic? Is it in bytes or bits? Or maybe
    it is a number of packets? How do we know? We will need to consult either the
    standard or the vendor documentation to find out. There are tools that help with
    this process, such as a MIB browser that can provide more metadata to the value.
    But, at least in my experience, constructing an SNMP-based monitoring tool for
    your network can sometimes feel like a cat-and-mouse game of trying to find that
    one missing value.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为操作员，您需要努力将信息整合到环境中的OID结构中，以检索有用的信息。有时这可能是一个繁琐的过程，一次找到一个OID。例如，您可能会向设备OID发出请求，并收到一个值为10,000。那个值是什么？那是接口流量吗？是字节还是位？或者可能是数据包的数量？我们怎么知道？我们需要查阅标准或供应商文档才能找到答案。有一些工具可以帮助这个过程，比如MIB浏览器可以为值提供更多的元数据。但至少在我的经验中，为您的网络构建基于SNMP的监控工具有时会感觉像是一场猫鼠游戏，试图找到那个缺失的值。
- en: 'Some of the main points to take away from the operation are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从操作中可以得出一些要点：
- en: 'The implementation relies heavily on the amount of information the device agent
    can provide. This, in turn, relies on how the vendor treats SNMP: as a core feature
    or an added feature.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施严重依赖设备代理提供的信息量。这又取决于供应商如何对待SNMP：作为核心功能还是附加功能。
- en: SNMP agents generally require CPU cycles from the control plane to return a
    value. Not only is this inefficient for devices with, say, large BGP tables, it
    is also not feasible to use SNMP to query the data at small intervals.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SNMP代理通常需要来自控制平面的CPU周期来返回一个值。这不仅对于具有大型BGP表的设备效率低下，而且在小间隔内使用SNMP查询数据也是不可行的。
- en: The user needs to know the OID in order to query the data.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户需要知道OID才能查询数据。
- en: Since SNMP has been around for a while, my assumption is that you have some
    experience with it already. Let's jump directly into package installation and
    our first SNMP example.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SNMP已经存在一段时间，我假设您已经有了一些经验。让我们直接跳到软件包安装和我们的第一个SNMP示例。
- en: Setup
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: First, let's make sure that we have the SNMP managing device and agent work in
    our setup. The SNMP bundle can be installed on either the hosts (client or server)
    in our lab or the managing device on the management network. As long as the SNMP
    manager has IP reachability to the device and the managed device allows the inbound
    connection, SNMP should work. In production, you should only install the software on
    the management host and only allow SNMP traffic in the control plane.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们确保我们的设置中有SNMP管理设备和代理工作。SNMP捆绑包可以安装在我们实验室中的主机（客户端或服务器）或管理网络上的管理设备上。只要SNMP管理器可以通过IP与设备通信，并且受管设备允许入站连接，SNMP就可以工作。在生产中，您应该只在管理主机上安装软件，并且只允许控制平面中的SNMP流量。
- en: 'In this lab, we have installed SNMP on both the Ubuntu host on the management
    network and the client host in the lab to test security:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们在管理网络上的Ubuntu主机和实验室中的客户端主机上都安装了SNMP以测试安全性：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The next step would be to turn on and configure the SNMP options on the network
    devices, `iosv-1` and `iosv-2`. There are many optional parameters you can configure
    on the network device, such as contact, location, chassis ID, and SNMP packet
    size. The options are device-specific and you should check the documentation on
    your device. For IOSv devices, we will configure an access list to limit only
    the desired host for querying the device as well as tying the access list with
    the SNMP community string. In our case, we will use the word `secret` as the read-only
    community string and `permit_snmp` as the access list name:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是在网络设备`iosv-1`和`iosv-2`上打开和配置SNMP选项。您可以在网络设备上配置许多可选参数，例如联系人、位置、机箱ID和SNMP数据包大小。这些选项是特定于设备的，您应该查看设备的文档。对于IOSv设备，我们将配置一个访问列表，以限制只有所需的主机可以查询设备，并将访问列表与SNMP社区字符串绑定。在我们的情况下，我们将使用`secret`作为只读社区字符串，`permit_snmp`作为访问列表名称。
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The SNMP community string is acting as a shared password between the manager
    and the agent; therefore, it needs to be included any time you want to query the
    device.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP社区字符串充当管理器和代理之间的共享密码；因此，每次要查询设备时都需要包含它。
- en: 'As mentioned earlier in this chapter, finding the right OID is oftentimes half
    of the battle when working with SNMP. We can use tools such as the Cisco IOS MIB
    locator ([http://tools.cisco.com/ITDIT/MIBS/servlet/index](http://tools.cisco.com/ITDIT/MIBS/servlet/index))
    for finding specific OIDs to query. Alternatively, we can just start walking through
    the SNMP tree, starting from the top of Cisco''s enterprise tree at `.1.3.6.1.4.1.9`.
    We will perform the walk to make sure that the SNMP agent and the access-list
    are working:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面提到的，与SNMP一起工作时找到正确的OID往往是战斗的一半。我们可以使用诸如思科IOS MIB定位器（[http://tools.cisco.com/ITDIT/MIBS/servlet/index](http://tools.cisco.com/ITDIT/MIBS/servlet/index)）这样的工具来查找要查询的特定OID。或者，我们可以从Cisco企业树的顶部`.1.3.6.1.4.1.9`开始遍历SNMP树。我们将执行遍历以确保SNMP代理和访问列表正在工作：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can be more specific about the OID we need to query as well:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以更具体地说明我们需要查询的OID：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As a matter of demonstration, what if we type in the wrong value by `1` digit
    from `0` to `1` at the end of the last OID? This is what we would see:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 作为演示，如果我们在最后一个OID的末尾输入错误的值，例如从`0`到`1`的`1`位数，我们会看到这样的情况：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Unlike API calls, there are no useful error codes nor messages; it simply stated
    that the OID does not exist. This can be pretty frustrating at times.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与API调用不同，没有有用的错误代码或消息；它只是简单地说明OID不存在。有时这可能非常令人沮丧。
- en: 'The last thing to check would be the access list we configured will deny unwanted
    SNMP queries. Because we had the `log` keyword for both the permit and deny entries
    in the access-list, only `172.16.1.173` is permitted to query the devices:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要检查的是我们配置的访问列表将拒绝不需要的SNMP查询。因为我们在访问列表的允许和拒绝条目中都使用了`log`关键字，所以只有`172.16.1.173`被允许查询设备：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the biggest challenge in setting up SNMP is to find the right
    OID. Some of the OIDs are defined in standardized MIB-2; others are under the
    enterprise portion of the tree. Vendor documentation is the best bet, though.
    There are a number of tools that can help, such as a MIB browser; you can add
    MIBs (again, provided by the vendors) to the browser and see the description of
    the enterprise-based OIDs. A tool such as Cisco's SNMP Object Navigator ([http://snmp.cloudapps.cisco.com/Support/SNMP/do/BrowseOID.do?local=en](http://snmp.cloudapps.cisco.com/Support/SNMP/do/BrowseOID.do?local=en))
    proves to be very valuable when you need to find the correct OID of the object
    you are looking for.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，设置SNMP的最大挑战是找到正确的OID。一些OID在标准化的MIB-2中定义；其他的在树的企业部分下。尽管如此，供应商文档是最好的选择。有许多工具可以帮助，例如MIB浏览器；您可以将MIBs（同样由供应商提供）添加到浏览器中，并查看基于企业的OID的描述。当您需要找到您正在寻找的对象的正确OID时，像思科的SNMP对象导航器（[http://snmp.cloudapps.cisco.com/Support/SNMP/do/BrowseOID.do?local=en](http://snmp.cloudapps.cisco.com/Support/SNMP/do/BrowseOID.do?local=en)）这样的工具就变得非常有价值。
- en: PySNMP
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PySNMP
- en: PySNMP is a cross-platform, pure Python SNMP engine implementation developed
    by Ilya Etingof ([https://github.com/etingof](https://github.com/etingof)). It
    abstracts a lot of SNMP details for you, as great libraries do, and supports both
    Python 2 and Python 3.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: PySNMP是由Ilya Etingof开发的跨平台、纯Python SNMP引擎实现（[https://github.com/etingof](https://github.com/etingof)）。它为您抽象了许多SNMP细节，正如优秀的库所做的那样，并支持Python
    2和Python 3。
- en: 'PySNMP requires the PyASN1 package. The following is taken from to Wikipedia:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: PySNMP需要PyASN1包。以下内容摘自维基百科：
- en: <q>"ASN.1 is a standard and notation that describes rules and structures for
    representing, encoding, transmitting, and decoding data in telecommunication and
    computer networking."</q>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <q>"ASN.1是一种标准和符号，描述了在电信和计算机网络中表示、编码、传输和解码数据的规则和结构。"</q>
- en: 'PyASN1 conveniently provides a Python wrapper around ASN.1\. Let''s install
    the package first:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: PyASN1方便地提供了一个Python封装器，用于ASN.1。让我们首先安装这个包：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, install the PySNMP package:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，安装PySNMP包：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are using an older version of PySNMP due to the fact that `pysnmp.entity.rfc3413.oneliner`
    was removed starting with version 5.0.0 ([https://github.com/etingof/pysnmp/blob/a93241007b970c458a0233c16ae2ef82dc107290/CHANGES.txt](https://github.com/etingof/pysnmp/blob/a93241007b970c458a0233c16ae2ef82dc107290/CHANGES.txt)).
    If you use `pip` to install the packages, the examples will likely break.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pysnmp.entity.rfc3413.oneliner`从版本5.0.0开始被移除（[https://github.com/etingof/pysnmp/blob/a93241007b970c458a0233c16ae2ef82dc107290/CHANGES.txt](https://github.com/etingof/pysnmp/blob/a93241007b970c458a0233c16ae2ef82dc107290/CHANGES.txt)），我们使用了较旧版本的PySNMP。如果您使用`pip`来安装包，示例可能会出现问题。
- en: 'Let''s look at how to use PySNMP to query the same Cisco contact information
    we used in the previous example. The steps we will take are slightly modified
    versions from the PySNMP example at [http://pysnmp.sourceforge.net/faq/response-values-mib-resolution.html](http://pysnmp.sourceforge.net/faq/response-values-mib-resolution.html).
    We will import the necessary module and create a `CommandGenerator` object first:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用PySNMP来查询与上一个示例中使用的相同的Cisco联系信息。我们将采取的步骤是从[http://pysnmp.sourceforge.net/faq/response-values-mib-resolution.html](http://pysnmp.sourceforge.net/faq/response-values-mib-resolution.html)中的PySNMP示例中略微修改的版本。我们将首先导入必要的模块并创建一个`CommandGenerator`对象：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can perform SNMP using the `getCmd` method. The result is unpacked into
    various variables; of these, we care most about `varBinds`, which contains the
    query result:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`getCmd`方法执行SNMP。结果将被解包为各种变量；其中，我们最关心`varBinds`，其中包含查询结果：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the response values are PyASN1 objects. The `prettyPrint()` method
    will convert some of these values into a human-readable format, but since the
    result in our case was not converted, we will convert it into a string manually.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，响应值是PyASN1对象。`prettyPrint()`方法将一些这些值转换为人类可读的格式，但由于我们的结果没有被转换，我们将手动将其转换为字符串。
- en: 'We can write a script based on the preceding interactive example. We will name
    it `pysnmp_1.py` with error checking. We can also include multiple OIDs in the
    `getCmd()` method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以基于前面的交互式示例编写一个脚本。我们将其命名为`pysnmp_1.py`并进行错误检查。我们还可以在`getCmd()`方法中包含多个OID：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The result will be unpacked and list out the values of the two OIDs:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将被解包并列出两个OID的值：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the following example, we will persist the values we received from the queries
    so that we can perform other functions, such as visualization, with the data.
    For our example, we will use `ifEntry` within the MIB-2 tree for interface-related
    values to be graphed. You can find a number of resources that map out the `ifEntry`
    tree; here is a screenshot of the Cisco SNMP Object Navigator site that we accessed
    previously for `ifEntry`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将持久化我们从查询中收到的值，以便我们可以执行其他功能，比如使用数据进行可视化。在我们的示例中，我们将使用MIB-2树中的`ifEntry`来绘制与接口相关的值。您可以找到许多资源来映射`ifEntry`树；这里是我们之前访问过`ifEntry`的Cisco
    SNMP对象导航器网站的屏幕截图：
- en: '![](assets/dc9b8d4c-afc3-4aa7-8865-02b7faa9572d.png)SNMP ifEntry OID tree'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/dc9b8d4c-afc3-4aa7-8865-02b7faa9572d.png)SNMP ifEntry OID tree'
- en: 'A quick test will illustrate the OID mapping of the interfaces on the device:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速测试将说明设备上接口的OID映射：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From the documentation, we can map the values of `ifInOctets(10)`, `ifInUcastPkts(11)`,
    `ifOutOctets(16)`, and `ifOutUcastPkts(17)` into their respective OID values.
    From a quick check on the CLI and MIB documentation, we can see that the value
    of the `GigabitEthernet0/0` packets output maps to OID `1.3.6.1.2.1.2.2.1.17.1`.
    We will follow the rest of the same process to map out the rest of the OIDs for
    the interface statistics. When checking between CLI and SNMP, keep in mind that
    the values should be close but not exactly the same since there might be some
    traffic on the wire between the time of CLI output and the SNMP query time:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从文档中，我们可以将`ifInOctets(10)`、`ifInUcastPkts(11)`、`ifOutOctets(16)`和`ifOutUcastPkts(17)`的值映射到它们各自的OID值。通过快速检查CLI和MIB文档，我们可以看到`GigabitEthernet0/0`数据包输出的值映射到OID`1.3.6.1.2.1.2.2.1.17.1`。我们将按照相同的过程来映射接口统计的其余OID。在CLI和SNMP之间进行检查时，请记住，值应该接近但不完全相同，因为在CLI输出和SNMP查询时间之间可能有一些流量：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we are in a production environment, we will likely write the results into
    a database. But since this is just an example, we will write the query values
    to a flat file. We will write the `pysnmp_3.py` script for information query and
    write the results to the file. In the script, we have defined various OIDs that
    we need to query:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于生产环境中，我们可能会将结果写入数据库。但由于这只是一个例子，我们将把查询值写入一个平面文件。我们将编写`pysnmp_3.py`脚本来进行信息查询并将结果写入文件。在脚本中，我们已经定义了需要查询的各种OID：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The values were consumed in the `snmp_query()` function, with the `host`, `community`,
    and `oid` as input:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值在`snmp_query()`函数中被使用，输入为`host`、`community`和`oid`：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'All of the values are put in a dictionary with various keys and written to
    a file called `results.txt`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的值都被放在一个带有各种键的字典中，并写入一个名为`results.txt`的文件：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The outcome will be a file with results showing the interface packets represented
    at the time of the query:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个显示查询时接口数据包的文件：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can make this script executable and schedule a `cron` job to be executed
    every five minutes:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使这个脚本可执行，并安排一个`cron`作业每五分钟执行一次：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As mentioned previously, in a production environment, we would put the information
    in a database. For a SQL database, you can use a unique ID as the primary key.
    In a NoSQL database, we might use time as the primary index (or key) because it
    is always unique, followed by various key-value pairs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在生产环境中，我们会将信息放入数据库。对于SQL数据库，您可以使用唯一ID作为主键。在NoSQL数据库中，我们可能会使用时间作为主索引（或键），因为它总是唯一的，然后是各种键值对。
- en: We will wait for the script to be executed a few times for the values to be
    populated. If you are the impatient type, you can shorten the `cron` job interval
    to be one minute. After you see enough values in the `results.txt` file to make
    an interesting graph, we can move on to the next section to see how we can use
    Python to visualize the data.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将等待脚本执行几次，以便值被填充。如果您是不耐烦的类型，可以将`cron`作业间隔缩短为一分钟。在`results.txt`文件中看到足够多的值以制作有趣的图表后，我们可以继续下一节，看看如何使用Python来可视化数据。
- en: Python for data visualization
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于数据可视化的Python
- en: We gather network data for the purpose of gaining insight into our network.
    One of the best ways to know what the data means is to visualize it with graphs.
    This is true for almost all data, but especially true for time series data in
    the context of network monitoring. How much data was transmitted over the network
    in the last week? What is the percentage of the TCP protocol among all of the
    traffic? These are values we can glean from using data-gathering mechanisms, such
    as SNMP, and we can produce visualization graphs with some of the popular Python
    libraries.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收集网络数据是为了深入了解我们的网络。了解数据含义的最佳方法之一是使用图形对其进行可视化。这对于几乎所有数据都是正确的，但特别适用于网络监控的时间序列数据。在过去一周内网络传输了多少数据？TCP协议在所有流量中的百分比是多少？这些都是我们可以通过使用数据收集机制（如SNMP）获得的值，我们可以使用一些流行的Python库生成可视化图形。
- en: In this section, we will use the data we collected from the last section using
    SNMP and use two popular Python libraries, Matplotlib and Pygal, to graph them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用上一节从SNMP收集的数据，并使用两个流行的Python库Matplotlib和Pygal来对其进行图形化。
- en: Matplotlib
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Matplotlib
- en: '**Matplotlib** ([http://matplotlib.org/](http://matplotlib.org/)) is a Python
    2D plotting library for the Python language and its NumPy mathematical extension.
    It can produce publication-quality figures, such as plots, histograms, and bar
    graphs, with a few lines of code.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**Matplotlib** ([http://matplotlib.org/](http://matplotlib.org/))是Python语言及其NumPy数学扩展的2D绘图库。它可以用几行代码生成出版质量的图形，如绘图、直方图和条形图。'
- en: NumPy is an extension of the Python programming language. It is open source
    and widely used in various data science projects. You can learn more about it
    at [https://en.wikipedia.org/wiki/NumPy](https://en.wikipedia.org/wiki/NumPy).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy是Python编程语言的扩展。它是开源的，并广泛用于各种数据科学项目。您可以在[https://en.wikipedia.org/wiki/NumPy](https://en.wikipedia.org/wiki/NumPy)了解更多信息。
- en: Installation
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'The installation can be done using the Linux package management system, depending
    on your distribution:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 安装可以使用Linux软件包管理系统完成，具体取决于您的发行版：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Matplotlib – the first example
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Matplotlib – 第一个示例
- en: For the following examples, the output figures are displayed as the standard
    output by default. During development, it is often easier to try out the code
    initially and produce the graph on the standard output first before finalizing
    the code with a script. If you have been following along with this book via a
    virtual machine, it is recommended that you use the VM window instead of SSH so
    that you can see the graphs. If you do not have access to the standard output,
    you can save the figure and view it after you download it (as you will see soon).
    Note that you will need to set the `$DISPLAY` variable in some of the graphs that
    we will produce in this section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，默认情况下，输出图形会显示为标准输出。在开发过程中，最好先尝试最初的代码，并首先在标准输出上生成图形，然后再用脚本完成代码。如果您一直通过虚拟机跟随本书，建议您使用虚拟机窗口而不是SSH，这样您就可以看到图形。如果您无法访问标准输出，可以保存图形，然后在下载后查看（很快您将看到）。请注意，您需要在本节中的某些图形中设置`$DISPLAY`变量。
- en: 'The following is a screenshot of the Ubuntu desktop used in this chapter''s
    visualization example. As soon as the `plt.show()` command is issued in the Terminal
    window, `Figure 1` will appear on the screen. When you close the figure, you will
    return to the Python shell:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章可视化示例中使用的Ubuntu桌面的屏幕截图。在终端窗口中发出`plt.show()`命令后，`Figure 1`将出现在屏幕上。关闭图形后，您将返回到Python
    shell：
- en: '![](assets/6e2ca222-f974-43d2-aa0c-5cbbe61e2165.png)Matplotlib visualization
    with the Ubuntu desktop'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6e2ca222-f974-43d2-aa0c-5cbbe61e2165.png)使用Ubuntu桌面的Matplotlib可视化'
- en: 'Let''s look at the line graph first. A line graph simply gives two lists of
    numbers that correspond to the *x *axis and *y *axis values:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看折线图。折线图只是给出了两个与*x*轴和*y*轴值对应的数字列表：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The graph will show up as a line graph:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图形将显示为折线图：
- en: '![](assets/a829928b-284f-4292-ab0b-62b334bcba6f.png)Matplotlib line graph'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a829928b-284f-4292-ab0b-62b334bcba6f.png)Matplotlib折线图'
- en: 'Alternatively, if you do not have access to standard output or have saved the
    figure first, you can use the `savefig()` method:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您无法访问标准输出或者首先保存了图形，可以使用`savefig()`方法：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this basic knowledge of graphing plots, we can now graph the results we
    receive from SNMP queries.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些基本的图形绘制知识，我们现在可以绘制从SNMP查询中收到的结果了。
- en: Matplotlib for SNMP results
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于SNMP结果的Matplotlib
- en: 'In our first Matplotlib example, namely `matplotlib_1.py`, we will import the
    *dates* module besides `pyplot`. We will use the `matplotlib.dates` module instead
    of the Python standard library `dates` module. Unlike the Python `dates` module,
    the `mapplotlib.dates` library will convert the date value internally into the
    float type, which is required by Matplotlib:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个Matplotlib示例中，即`matplotlib_1.py`，我们将除了`pyplot`之外还导入*dates*模块。我们将使用`matplotlib.dates`模块而不是Python标准库`dates`模块。与Python`dates`模块不同，`mapplotlib.dates`库将在内部将日期值转换为Matplotlib所需的浮点类型：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Matplotlib provides sophisticated date plotting capabilities; you can find more
    information on this at [http://matplotlib.org/api/dates_api.html](http://matplotlib.org/api/dates_api.html).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib提供了复杂的日期绘图功能；您可以在[http://matplotlib.org/api/dates_api.html](http://matplotlib.org/api/dates_api.html)找到更多信息。
- en: 'In the script, we will create two empty lists, each representing the *x-*axis
    and *y-*axis values. Note that, on line 12, we used the built-in `eval()` Python
    function to read the input as a dictionary instead of a default string:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我们将创建两个空列表，分别表示*x-*轴和*y-*轴的值。请注意，在第12行，我们使用内置的`eval()` Python函数将输入读取为字典，而不是默认的字符串：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to read the *x-*axis value back in a human-readable date format, we
    will need to use the `plot_date()` function instead of `plot()`. We will also
    tweak the size of the figure a bit as well as rotate the value on the *x-*axis
    so that we can read the value in full:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以人类可读的日期格式读取*x-*轴的值，我们需要使用`plot_date()`函数而不是`plot()`。我们还将微调图形的大小，并旋转*x-*轴上的值，以便我们可以完整地读取该值：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The final result will display the Router1 Gig0/0 and Output Unicast Packet,
    as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果将显示Router1 Gig0/0和输出单播数据包，如下所示：
- en: '![](assets/ece57d54-836d-4b3e-86ef-ec605416081c.png)Router1 Matplotlib graph'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/ece57d54-836d-4b3e-86ef-ec605416081c.png)Router1 Matplotlib图'
- en: 'Note that if you prefer a straight line instead of dots, you can use the third
    optional parameter in the `plot_date()` function:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您喜欢直线而不是点，您可以在`plot_date()`函数中使用第三个可选参数：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can repeat the steps for the rest of the values for output octets, input
    unicast packets, and input as individual graphs. However, in our coming example,
    that is, `matplotlib_2.py`, we will show you how to graph multiple values against
    the same time range, as well as additional Matplotlib options.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重复输出八进制、输入单播数据包和输入的步骤作为单独的图形。然而，在我们接下来的例子中，也就是`matplotlib_2.py`中，我们将向您展示如何在相同的时间范围内绘制多个值，以及其他Matplotlib选项。
- en: 'In this case, we will create additional lists and populate the values accordingly:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将创建额外的列表，并相应地填充值：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since we have identical *x-*axis values, we can just add the different *y-*axis
    values to the same graph:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有相同的*x-*轴值，我们可以将不同的*y-*轴值添加到同一图中：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Also, add grid and legend to the graph:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 还要在图中添加网格和图例：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The final result will combine all of the values in a single graph. Note that
    some of the values in the upper-left corner are blocked by the legend. You can
    resize the figure and/or use the pan/zoom option to move around the graph in order
    to see the value:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果将把所有值合并到一个图中。请注意，左上角的一些值被图例挡住了。您可以调整图形的大小和/或使用平移/缩放选项来在图形周围移动，以查看值：
- en: '![](assets/5c6c3d57-899b-402b-b554-c85e94fe3b24.png)Router 1 – Matplotlib multiline
    graph'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5c6c3d57-899b-402b-b554-c85e94fe3b24.png)Router 1 – Matplotlib多线图'
- en: 'There are many more graphing options available in Matplotlib; we are certainly
    not limited to plot graphs. For example, we can use the following mock data to
    graph the percentage of different traffic types that we can see on the wire:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib中有许多其他绘图选项；我们当然不仅限于绘制图形。例如，我们可以使用以下模拟数据来绘制我们在线上看到的不同流量类型的百分比：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding code leads to this pie chart from `plt.show()`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码导致了从`plt.show()`生成的饼图：
- en: '![](assets/6a9328fe-b860-4287-98e2-a56c469da3aa.png)Matplotlib pie chart'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6a9328fe-b860-4287-98e2-a56c469da3aa.png)Matplotlib饼图'
- en: Additional Matplotlib resources
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加的Matplotlib资源
- en: Matplotlib is one of the best Python plotting libraries that is able to produce publication-quality
    figures. Like Python, its aim is to make complex tasks simple. With over 7,550
    stars (and counting) on GitHub, it is also one of the most popular open source
    projects. Its popularity directly translates into faster bug fixes, a friendly
    user community, and general usability. It takes a bit of time to learn the package,
    but it is well worth the effort.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib是最好的Python绘图库之一，能够生成出版质量的图形。与Python一样，它的目标是使复杂的任务变得简单。在GitHub上有超过7550颗星（还在增加），它也是最受欢迎的开源项目之一。它的受欢迎程度直接转化为更快的错误修复、友好的用户社区和通用的可用性。学习这个包需要一点时间，但是非常值得努力。
- en: In this section, we barely scratched the surface of Matplotlib. You'll find
    additional resources at [http://matplotlib.org/2.0.0/index.html](http://matplotlib.org/2.0.0/index.html)
    (the Matplotlib project page) and [https://github.com/matplotlib/matplotlib](https://github.com/matplotlib/matplotlib)
    (the Matplotlib GitHub repository).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们只是浅尝了Matplotlib的表面。您可以在[http://matplotlib.org/2.0.0/index.html](http://matplotlib.org/2.0.0/index.html)（Matplotlib项目页面）和[https://github.com/matplotlib/matplotlib](https://github.com/matplotlib/matplotlib)（Matplotlib
    GitHub存储库）找到更多资源。
- en: 'In the coming section, we will take a look at another popular Python graph
    library: **Pygal**.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看一下另一个流行的Python图形库：**Pygal**。
- en: Pygal
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pygal
- en: Pygal ([http://www.pygal.org/](http://www.pygal.org/)) is a dynamic SVG charting
    library written in Python. The biggest advantage of Pygal, in my opinion, is that
    it produces **Scalable Vector Graphics** (**SVG**) format graphs easily and natively.
    There are many advantages of SVG over other graph formats, but two of the main
    advantages are that it is web browser-friendly and it provides scalability without
    sacrificing image quality. In other words, you can display the resulting image
    in any modern web browser and zoom in and out of the image without losing the
    details of the graph. Did I mention that we can do this in a few lines of Python
    code? How cool is that?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Pygal（[http://www.pygal.org/](http://www.pygal.org/)）是一个用Python编写的动态SVG图表库。在我看来，Pygal的最大优势是它能够轻松本地生成**可伸缩矢量图形**（**SVG**）格式的图形。SVG相对于其他图形格式有许多优势，但其中两个主要优势是它对Web浏览器友好，并且提供了可伸缩性而不会损失图像质量。换句话说，您可以在任何现代Web浏览器中显示生成的图像，并且可以放大和缩小图像，而不会丢失图形的细节。我提到了我们可以在几行Python代码中做到这一点吗？这有多酷？
- en: Installation
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'The installation is done via `pip`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 安装是通过`pip`完成的：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Pygal – the first example
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pygal - 第一个例子
- en: 'Let''s look at the line chart example demonstrated on Pygal''s documentation,
    available at [http://pygal.org/en/stable/documentation/types/line.html](http://pygal.org/en/stable/documentation/types/line.html):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下Pygal文档中演示的线图示例，网址为[http://pygal.org/en/stable/documentation/types/line.html](http://pygal.org/en/stable/documentation/types/line.html)：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, we created a line object with the `x_labels` automatically
    rendered as strings for 11 units. Each of the objects can be added with the label
    and the value in a list format, such as Firefox, Chrome, and IE.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个带有`x_labels`的线对象，自动呈现为11个单位的字符串。每个对象都可以以列表格式添加标签和值，例如Firefox、Chrome和IE。
- en: 'Here''s the resulting graph, as viewed in Firefox:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Firefox中查看的结果图：
- en: '![](assets/29abfeb0-b81b-4751-b7d3-ba3dc6bd8cb5.png)Pygal sample graph'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/29abfeb0-b81b-4751-b7d3-ba3dc6bd8cb5.png)Pygal示例图'
- en: Now that we can see the general usage of Pygal, we can use the same method to
    graph the SNMP results we have in hand. We will do this in the coming section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到Pygal的一般用法，我们可以使用相同的方法来绘制我们手头上的SNMP结果。我们将在接下来的部分中进行这样做。
- en: Pygal for SNMP results
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pygal用于SNMP结果
- en: 'For the Pygal line graph, we can largely follow the same pattern as our Matplotlib
    example, where we create lists of values by reading the file. We no longer need
    to convert the *x-*axis value into an internal float, as we did for Matplotlib;
    however, we do need to convert the numbers in each of the values we would have
    received in the float:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Pygal线图，我们可以大致按照Matplotlib示例的相同模式进行操作，其中我们通过读取文件创建值列表。我们不再需要将*x-*轴值转换为内部浮点数，就像我们为Matplotlib所做的那样；但是，我们确实需要将我们将在浮点数中收到的每个值中的数字转换为浮点数：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can use the same mechanism that we saw to construct the line graph:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们看到的相同机制来构建线图：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The outcome is similar to what we have already seen, but the graph is now in
    an SVG format that can be easily displayed on a web page. It can be viewed from
    a modern web browser:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与我们已经看到的类似，但是图表现在以SVG格式呈现，可以轻松地显示在网页上。它可以在现代Web浏览器中查看：
- en: '![](assets/6e383a39-e3b8-48c9-a6be-6fc05fcf4cb1.png)Router 1—Pygal multiline
    graph'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6e383a39-e3b8-48c9-a6be-6fc05fcf4cb1.png)路由器1—Pygal多线图'
- en: 'Just like Matplotlib, Pygal provides many more options for graphs. For example,
    to graph the pie chart we saw previously in Pygal, we can use the `pygal.Pie()`
    object:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Matplotlib一样，Pygal为图表提供了更多的选项。例如，要在Pygal中绘制我们之前看到的饼图，我们可以使用`pygal.Pie()`对象：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The resulting SVG file would be similar to the PNG generated by Matplotlib:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的SVG文件将类似于Matplotlib生成的PNG：
- en: '![](assets/dd33b69f-99ec-45bb-bc0a-386ee0c65bcf.png)Pygal pie chart'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/dd33b69f-99ec-45bb-bc0a-386ee0c65bcf.png)Pygal饼图'
- en: Additional Pygal resources
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他Pygal资源
- en: 'Pygal provides many more customizable features and graphing capabilities for
    the data you collect from basic network monitoring tools such as SNMP. We demonstrated
    a simple line graph and pie graphs in this section. You can find more information
    about the project here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Pygal为您从基本网络监控工具（如SNMP）收集的数据提供了更多可定制的功能和图形能力。在本节中，我们演示了简单的线图和饼图。您可以在此处找到有关项目的更多信息：
- en: '**Pygal documentation**: [http://www.pygal.org/en/stable/index.html](http://www.pygal.org/en/stable/index.html)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pygal文档**：[http://www.pygal.org/en/stable/index.html](http://www.pygal.org/en/stable/index.html)'
- en: '**Pygal GitHub project page**: [https://github.com/Kozea/pygal](https://github.com/Kozea/pygal)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pygal GitHub项目页面**：[https://github.com/Kozea/pygal](https://github.com/Kozea/pygal)'
- en: In the coming section, we will continue with the SNMP theme of network monitoring
    but with a fully featured network monitoring system called **Cacti**.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将继续使用SNMP主题进行网络监控，但使用一个名为**Cacti**的功能齐全的网络监控系统。
- en: Python for Cacti
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cacti的Python
- en: In my early days working as a junior network engineer at a regional ISP, we
    used the open source cross-platform **Multi Router Traffic Grapher** (**MRTG**),
    ([https://en.wikipedia.org/wiki/Multi_Router_Traffic_Grapher](https://en.wikipedia.org/wiki/Multi_Router_Traffic_Grapher))
    tool to check the traffic load on network links. We relied on the tool almost
    exclusively for traffic monitoring. I was really amazed at how good and useful
    an open source project could be. It was one of the first open source high-level
    network monitoring systems that abstracted the details of SNMP, the database,
    and HTML for network engineers. Then came the **Round-Robin Database Tool** (**RRDtool**),
    ([https://en.wikipedia.org/wiki/RRDtool](https://en.wikipedia.org/wiki/RRDtool)).
    In its first release in 1999, it was referred to as "MRTG Done Right". It had
    greatly improved the database and poller performance in the backend.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我作为地区ISP的初级网络工程师工作的早期，我们使用开源跨平台**多路由器流量图**（**MRTG**）（[https://en.wikipedia.org/wiki/Multi_Router_Traffic_Grapher](https://en.wikipedia.org/wiki/Multi_Router_Traffic_Grapher)）工具来检查网络链路上的流量负载。我们几乎完全依赖于该工具进行流量监控。我真的很惊讶开源项目可以有多好和有用。这是第一个将SNMP、数据库和HTML的细节抽象化为网络工程师的开源高级网络监控系统之一。然后出现了**循环数据库工具**（**RRDtool**）（[https://en.wikipedia.org/wiki/RRDtool](https://en.wikipedia.org/wiki/RRDtool)）。在1999年的首次发布中，它被称为“正确的MRTG”。它极大地改进了后端的数据库和轮询器性能。
- en: Released in 2001, Cacti ([https://en.wikipedia.org/wiki/Cacti_(software)](https://en.wikipedia.org/wiki/Cacti_(software)))
    is an open source web-based network monitoring and graphing tool designed as an
    improved frontend for RRDtool. Because of the heritage of MRTG and RRDtool, you
    will notice a familiar graph layout, templates, and SNMP poller. As a packaged
    tool, the installation and usage will need to stay within the boundary of the
    tool itself. However, Cacti offers the custom data query feature that we can use
    Python for. In this section, we will see how we can use Python as an input method
    for Cacti.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Cacti（[https://en.wikipedia.org/wiki/Cacti_(software)](https://en.wikipedia.org/wiki/Cacti_(software)）于2001年发布，是一个开源的基于Web的网络监控和图形工具，旨在作为RRDtool的改进前端。由于MRTG和RRDtool的传承，您会注意到熟悉的图表布局、模板和SNMP轮询器。作为一个打包工具，安装和使用将需要保持在工具本身的范围内。但是，Cacti提供了我们可以使用Python的自定义数据查询功能。在本节中，我们将看到如何将Python用作Cacti的输入方法。
- en: Installation
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: 'Installation on Ubuntu is straightforward when using APT on the Ubuntu management
    VM:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu上使用APT进行安装非常简单：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It will trigger a series of installation and setup steps, including the MySQL
    database, web server (Apache or lighttpd), and various configuration tasks. Once
    installed, navigate to `http://<ip>/cacti` to get started. The last step is to
    log in with the default username and password (`admin`/`admin`); you will be prompted
    to change the password.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将触发一系列安装和设置步骤，包括MySQL数据库、Web服务器（Apache或lighttpd）和各种配置任务。安装完成后，导航到`http://<ip>/cacti`开始使用。最后一步是使用默认用户名和密码（`admin`/`admin`）登录；您将被提示更改密码。
- en: 'Once you are logged in, you can follow the documentation to add a device and
    associate it with a template. There is a Cisco router premade template that you
    can go with. Cacti has good documentation on [http://docs.cacti.net/](http://docs.cacti.net/)
    for adding a device and creating your first graph, so we will quickly look at
    some screenshots that you can expect to see:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你登录，你可以按照文档添加设备并将其与模板关联。有一个预制的Cisco路由器模板可以使用。Cacti在[http://docs.cacti.net/](http://docs.cacti.net/)上有关于添加设备和创建第一个图形的良好文档，所以我们将快速查看一些你可以期望看到的屏幕截图：
- en: '![](assets/30d73b73-895c-472d-8723-22a9be73d6f3.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/30d73b73-895c-472d-8723-22a9be73d6f3.png)'
- en: 'A sign indicating the SNMP communication is working is when you can see the
    device uptime:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当你能看到设备的正常运行时间时，这是SNMP通信正在工作的一个标志：
- en: '![](assets/fdf75bec-2cb7-4e51-a6c8-87e9cf54ca4d.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fdf75bec-2cb7-4e51-a6c8-87e9cf54ca4d.png)'
- en: 'You can add graphs to the device for interface traffic and other statistics:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为设备添加接口流量和其他统计信息的图形：
- en: '![](assets/d02f3ac0-6883-4358-a3ae-deeebff30af9.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d02f3ac0-6883-4358-a3ae-deeebff30af9.png)'
- en: 'After some time, you will start seeing traffic, as shown here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，你会开始看到流量，如下所示：
- en: '![](assets/4e894e42-b8ca-4140-bf0c-e19f83ebef34.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4e894e42-b8ca-4140-bf0c-e19f83ebef34.png)'
- en: We are now ready to look at how to use Python scripts to extend Cacti's data
    gathering functionality.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备看一下如何使用Python脚本来扩展Cacti的数据收集功能。
- en: Python script as an input source
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python脚本作为输入源
- en: 'There are two documents that we should read before we try to use our Python
    script as an input source:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试将Python脚本作为输入源之前，有两份文档我们应该阅读：
- en: 'Data input methods: [http://www.cacti.net/downloads/docs/html/data_input_methods.html](http://www.cacti.net/downloads/docs/html/data_input_methods.html)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据输入方法：[http://www.cacti.net/downloads/docs/html/data_input_methods.html](http://www.cacti.net/downloads/docs/html/data_input_methods.html)
- en: 'Making your scripts work with Cacti: [http://www.cacti.net/downloads/docs/html/making_scripts_work_with_cacti.html](http://www.cacti.net/downloads/docs/html/making_scripts_work_with_cacti.html)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使你的脚本与Cacti一起工作：[http://www.cacti.net/downloads/docs/html/making_scripts_work_with_cacti.html](http://www.cacti.net/downloads/docs/html/making_scripts_work_with_cacti.html)
- en: 'One might wonder what the use cases for using Python script are as an extension
    for data inputs. One of the use cases would be to provide monitoring to resources
    that do not have a corresponding OID, for example, if we would like to know how
    to graph how many times the access list `permit_snmp` has allowed the host `172.16.1.173`
    for conducting an SNMP query. We know we can see the number of matches via the
    CLI:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有人可能会想知道使用Python脚本作为数据输入扩展的用例是什么。其中一个用例是为那些没有相应OID的资源提供监控，例如，如果我们想知道访问列表`permit_snmp`允许主机`172.16.1.173`进行SNMP查询的次数。我们知道我们可以通过CLI看到匹配的次数：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: However, chances are that there are no OIDs associated with this value (or we
    can just pretend that there are none). This is where we can use an external script
    to produce an output that can be consumed by the Cacti host.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，很可能与这个值没有关联的OID（或者我们可以假装没有）。这就是我们可以使用外部脚本生成一个可以被Cacti主机消耗的输出的地方。
- en: 'We can reuse the Pexpect script we discussed in [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml),
    *Low-Level Network Device Interactions,* `chapter1_1.py`. We will rename it to
    `cacti_1.py`. Everything should be familiar to the original script, except that
    we will execute the CLI command and save the output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用我们在[第2章](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml)中讨论的Pexpect脚本，`chapter1_1.py`。我们将其重命名为`cacti_1.py`。除了执行CLI命令并保存输出之外，一切都应该与原始脚本一样熟悉：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output in its raw form will appear as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 原始形式的输出如下：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will use the `split()` function for the string to only leave the number
    of matches and print them out on standard output in the script:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`split()`函数对字符串进行处理，只留下匹配的次数并在脚本中将其打印到标准输出：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To test this, we can see the number of increments by executing the script a
    number of times:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们可以执行脚本多次来查看增量的数量：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can make the script executable and put it into the default Cacti script
    location:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将脚本设置为可执行，并将其放入默认的Cacti脚本位置：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The Cacti documentation, available at [http://www.cacti.net/downloads/docs/html/how_to.html](http://www.cacti.net/downloads/docs/html/how_to.html),
    provides detailed steps on how to add the script result to the output graph. These steps
    include adding the script as a data input method, adding the input method to a
    data source, and then creating a graph to be viewed:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Cacti文档，可在[http://www.cacti.net/downloads/docs/html/how_to.html](http://www.cacti.net/downloads/docs/html/how_to.html)上找到，提供了如何将脚本结果添加到输出图形的详细步骤。这些步骤包括将脚本添加为数据输入方法，将输入方法添加到数据源，然后创建一个图形进行查看：
- en: '![](assets/76e0529b-8252-41c3-b8c3-ab9f9cd550f3.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/76e0529b-8252-41c3-b8c3-ab9f9cd550f3.png)'
- en: SNMP is a common way to provide network monitoring services to the devices.
    RRDtool with Cacti as the frontend provides a good platform to be used for all
    the network devices via SNMP.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP是提供网络监控服务给设备的常见方式。RRDtool与Cacti作为前端提供了一个良好的平台，可以通过SNMP用于所有的网络设备。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored ways to perform network monitoring via SNMP. We
    configured SNMP-related commands on network devices and used our network management
    VM with SNMP poller to query the devices. We used the PySNMP module to simplify
    and automate our SNMP queries. We also learned how to save the query results in
    a flat file or database to be used for future examples.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了通过SNMP执行网络监控的方法。我们在网络设备上配置了与SNMP相关的命令，并使用了我们的网络管理VM与SNMP轮询程序来查询设备。我们使用了PySNMP模块来简化和自动化我们的SNMP查询。我们还学习了如何将查询结果保存在一个平面文件或数据库中，以便用于将来的示例。
- en: Later in this chapter, we used two different Python visualization packages,
    namely Matplotlib and Pygal, to graph SNMP results. Each package has its distinct
    advantages. Matplotlib is a mature, feature-rich library that is widely used in
    data science projects. Pygal can natively generate SVG format graphs that are
    flexible and web-friendly. We saw how we can generate line and pie graphs that
    are relevant for network monitoring.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们使用了两种不同的Python可视化包，即Matplotlib和Pygal，来绘制SNMP结果的图表。每个包都有其独特的优势。Matplotlib是一个成熟、功能丰富的库，在数据科学项目中被广泛使用。Pygal可以原生生成灵活且适合网络的SVG格式图表。我们看到了如何生成对网络监控相关的折线图和饼图。
- en: Toward the end of this chapter, we looked at an all-inclusive network monitoring
    tool named Cacti. It uses primarily SNMP for network monitoring, but we saw how
    we can use Python scripts as an input source to extend the platform's monitoring
    capabilities when SNMP OID is not available on the remote host.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的末尾，我们看了一个名为Cacti的全面网络监控工具。它主要使用SNMP进行网络监控，但我们看到当远程主机上没有SNMP OID时，我们可以使用Python脚本作为输入源来扩展平台的监控能力。
- en: In [Chapter 8](5f7e76ef-d93a-4689-8054-8be72d41d69b.xhtml), *Network Monitoring
    with Python – Part 2*, we will continue to discuss the tools we can use to monitor
    our networks and gain insight into whether the network is behaving as expected.
    We will look at flow-based monitoring using NetFlow, sFlow, and IPFIX. We will
    also use tools such as Graphviz to visualize our network topology and detect any
    topological changes. Finally, we will use Elasticsearch, Logstash, and Kibana,
    commonly referred to as the ELK stack, to monitor network log data as well as
    other network-related input.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](5f7e76ef-d93a-4689-8054-8be72d41d69b.xhtml)中，《使用Python进行网络监控-第2部分》，我们将继续讨论我们可以使用的工具来监控我们的网络，并了解网络是否表现如预期。我们将研究使用NetFlow、sFlow和IPFIX进行基于流的监控。我们还将使用诸如Graphviz之类的工具来可视化我们的网络拓扑，并检测任何拓扑变化。最后，我们将使用Elasticsearch、Logstash和Kibana，通常被称为ELK堆栈，来监控网络日志数据以及其他与网络相关的输入。
