# 第六章。类和对象的基础知识

在本章中，我们将研究以下配方：

+   使用类封装数据和处理

+   设计具有大量处理的类

+   设计具有少量独特处理的类

+   使用 __slots__ 优化小对象

+   使用更复杂的集合

+   扩展集合-执行统计的列表

+   使用惰性属性

+   使用可设置属性来更新急切属性

# 介绍

计算的目的是处理数据。即使构建像交互式游戏这样的东西，游戏状态和玩家的行动也是数据；处理计算下一个游戏状态和显示更新。

一些游戏可能有相对复杂的内部状态。当我们考虑具有多个玩家和复杂图形的控制台游戏时，会有复杂的实时状态变化。

另一方面，当我们想到像*Craps*这样的赌场游戏时，游戏状态非常简单。可能没有建立点，或者 4、5、6、8、9 或 10 中的一个数字可能是已建立的点。转换相对简单，通常通过在赌场桌上移动标记和筹码来表示。数据包括当前状态、玩家行动和骰子的投掷。处理是游戏规则。

像*Blackjack*这样的游戏在每张牌被接受时有一个稍微复杂的内部状态变化。在手牌可以分开的游戏中，游戏状态可能会变得非常复杂。数据包括当前游戏状态、玩家的命令和从牌堆中抽出的牌。处理由游戏规则定义，这些规则可能会受到任何庄家规则的修改。

在*craps*的情况下，玩家可以下注。有趣的是，玩家的输入对游戏状态没有影响。游戏对象的内部状态完全由骰子的下一次投掷决定。这导致了一个相对容易可视化的类设计。

在本章中，我们将创建实现多个统计公式的类。一开始数学可能有点令人生畏。几乎所有东西都基于一系列值的总和，通常表示为∑ *x*。在许多情况下，这可以使用 Python 的`sum()`函数来实现。

# 使用类封装数据和处理

计算的基本思想是处理数据。当我们编写处理数据的函数时，这一点得到了体现。我们在第三章中已经看到了这一点，*函数定义*。

通常，我们希望有许多与共同数据结构一起工作的相关函数。这个概念是面向对象编程的核心。类定义将包含许多控制对象内部状态的方法。

类定义背后的统一概念通常被概括为分配给类的责任的摘要。我们如何有效地做到这一点？设计类的好方法是什么？

## 准备工作

让我们来看一个简单的、有状态的对象——一对骰子。这是一个模拟*Craps*赌场游戏的应用程序的背景。目标是利用结果的模拟来帮助发明更好的游戏策略。这将使我们在试图击败庄家优势时不会失去真钱。

类定义和类的实例之间有一个重要的区别，称为**对象**。我们将这个想法称为**面向对象编程**。我们的重点是编写类定义。我们的整体应用程序将创建类的实例。从实例的协作中产生的行为是设计过程的总体目标。

大部分设计工作都在类定义上。因此，面向对象编程这个名字可能会误导人。

**新兴行为**的概念是面向对象编程中的一个重要组成部分。我们不指定程序的每个行为。相反，我们将程序分解为对象，并通过对象的类定义对象的状态和行为。编程根据其责任和协作分解为类定义。

对象应该被视为一个东西——一个名词。类的行为应该被视为动词。这给了我们一个提示，关于我们如何可以继续设计有效工作的类。

当与有形的现实世界的事物相关联时，面向对象设计通常更容易理解。模拟一张纸牌的游戏往往比创建实现**抽象数据类型**的软件更容易。

在这个例子中，我们将模拟掷骰子。对于一些游戏，比如赌场游戏*Craps*，会使用两个骰子。我们将定义一个模拟一对骰子的类。为了确保例子是有形的，我们将在模拟赌场游戏的情境中模拟一对骰子。

## 如何做到这一点...

1.  写下简单的句子，描述类的实例做什么。我们可以称这些为问题陈述。专注于简短的句子，并强调名词和动词是至关重要的：

+   *Craps*游戏有两个标准骰子。

+   每个骰子有六个面，点数从一到六。

+   玩家掷骰子。

+   骰子的总和改变了*craps*游戏的状态。然而，这些规则与骰子是分开的。

+   如果两个骰子匹配，这个数字是通过困难方式掷出的。如果两个骰子不匹配，这个数字是容易掷出的。一些赌注取决于这种困难和容易的区别。

1.  识别句子中的所有名词。名词可能标识不同类的对象。这些是**合作者**。例如玩家和游戏。名词也可能标识所讨论对象的属性。例如面和点数。

1.  识别句子中的所有动词。动词通常是所讨论的类的方法。例如，rolled 和 match。有时，它们是其他类的方法。一个例子是改变状态，这适用于*Craps*。

1.  识别任何形容词。形容词是澄清名词的词或短语。在许多情况下，一些形容词显然是对象的属性。在其他情况下，形容词将描述对象之间的关系。在我们的例子中，诸如*骰子的总和*这样的短语就是一个介词短语作为形容词的例子。*骰子的总和*短语修改了名词*骰子*。总和是一对骰子的属性。

1.  用`class`语句开始编写类：

```py
            class Dice: 

    ```

1.  在`__init__`方法中初始化对象的属性：

```py
            def __init__(self): 
                self.faces = None 

    ```

我们将用`self.faces`属性来模拟骰子的内部状态。`self`变量是必需的，以确保我们引用的是类的给定实例的属性。对象由实例变量`self`的值来标识。

我们也可以在这里放一些其他属性。另一种选择是将属性实现为单独的方法。这种设计决策的细节将在本章后面的*使用属性进行惰性属性*中讨论。

1.  根据不同的动词定义对象的方法。在我们的例子中，我们必须定义几种方法：

+   以下是我们如何实现玩家掷骰子的方法：

```py
                        def roll(self): 
                            self.faces = (random.randint(1,6), random.randint(1,6)) 

        ```

通过设置`self.faces`属性来更新骰子的内部状态。同样，`self`变量对于标识要更新的对象是至关重要的。

注意，这个方法改变了对象的内部状态。我们选择不返回一个值。这使得我们的方法有点像 Python 内置的集合类的方法。任何改变对象的方法都不返回一个值。

+   这种方法有助于实现骰子的总和改变了*craps*游戏的状态。游戏是一个独立的对象，但这个方法提供了一个符合句子的总和。

```py
                        def total(self): 
                            return sum(self.faces) 

        ```

这两种方法有助于回答 hardways 和 easyways 的问题。

```py
                        def hardway(self): 
                            return self.faces[0] == self.faces[1] 
                        def easyway(self): 
                            return self.faces[0] != self.faces[1] 

        ```

在赌场游戏中很少有一个具有简单逻辑反义的规则。更常见的是有一个罕见的第三种选择，它有一个非常糟糕的回报规则。在这种情况下，我们可以将`easyway`定义为返回`not self.hardway()`。

以下是使用该类的示例：

1.  首先，我们将用一个固定值来初始化随机数生成器，这样我们就可以得到一个固定的结果序列。这是为这个类创建一个单元测试的一种方式：

```py
     **>>> import random 
          >>> random.seed(1)** 

    ```

1.  我们将创建一个`Dice`对象，`d1`。然后我们可以用`roll()`方法设置它的状态。然后我们将查看`total()`方法来看看掷出了什么。我们可以通过查看`faces`属性来检查状态：

```py
     **>>> from ch06_r01 import Dice 
          >>> d1 = Dice() 
          >>> d1.roll() 
          >>> d1.total() 
          7 
          >>> d1.faces 
          (2, 5)** 

    ```

1.  我们将创建第二个`Dice`对象，`d2`。然后我们可以用`roll()`方法设置它的状态。我们将查看`total()`方法的结果，以及`hardway()`方法。我们可以通过查看`faces`属性来检查状态：

```py
     **>>> d2 = Dice() 
          >>> d2.roll() 
          >>> d2.total() 
          4 
          >>> d2.hardway() 
          False 
          >>> d2.faces 
          (1, 3)** 

    ```

1.  由于这两个对象是`Dice`类的独立实例，对`d2`的更改不会影响`d1`：

```py
     **>>> d1.total() 
          7** 

    ```

## 它是如何工作的...

这里的核心思想是利用语法的普通规则——名词、动词和形容词——作为识别类的基本特征的一种方式。名词代表事物。一个好的描述性句子应该更多地关注有形的、现实世界的事物，而不是想法或抽象概念。

在我们的例子中，骰子是真实的事物。我们尽量避免使用抽象术语，比如随机器或事件生成器。更容易描述真实事物的有形特征，然后找到一个提供一些有形特征的抽象实现。

掷骰子的想法是一个我们可以用方法定义来模拟的物理动作的例子。显然，这个动作改变了对象的状态。在罕见的情况下——36 次中有一次——下一个状态恰好与上一个状态匹配。

形容词经常会引起混淆。以下是形容词操作最常见的方式的描述：

+   一些形容词，比如 first、last、least、most、next、previous 等，会有一个简单的解释。这些可以作为方法的懒惰实现，或作为属性值的急切实现。

+   一些形容词是更复杂的短语，比如*骰子的总和*。这是一个由名词（总和）和介词（of）构成的形容词短语。这也可以被视为一个方法或属性。

+   一些形容词涉及到在我们的软件中出现的其他名词。我们可能会有一个短语，比如*Craps 游戏的状态*，其中*状态*修改另一个对象，*Craps*游戏。这显然只是与骰子本身有关的间接关系。这可能反映了骰子和游戏之间的关系。

+   我们可以在问题陈述中添加一句话，比如*骰子是游戏的一部分*。这可以帮助澄清游戏和骰子之间的关系。例如，介词短语*是...的一部分*总是可以颠倒过来，从另一个对象的角度来创建陈述：例如*游戏包含骰子*。这可以帮助澄清对象之间的关系。

在 Python 中，对象的属性默认是动态的。我们不指定一个固定的属性列表。我们可以在类定义的`__init__()`方法中初始化一些（或全部）属性。由于属性不是静态的，我们在设计上有相当大的灵活性。

## 还有更多...

捕捉内部状态和导致状态改变的方法是良好类设计的第一步。我们可以使用缩写**S.O.L.I.D**总结一些有用的设计原则。：

+   **单一责任原则**：一个类应该有一个明确定义的责任。

+   **开闭原则**：一个类应该对扩展开放-通常通过继承，但对修改关闭。我们应该设计我们的类，以便我们不需要调整代码来添加或更改功能。

+   **里氏替换原则**：我们需要设计继承，使得子类可以替换父类。

+   **接口隔离原则**：在编写问题陈述时，我们希望确保协作类的依赖尽可能少。在许多情况下，这个原则会导致我们将大问题分解为许多小类定义。

+   **依赖反转原则**：一个类直接依赖于其他类并不理想。最好是一个类依赖于一个抽象，而具体的实现类替换抽象类。

目标是创建具有适当行为并遵守设计原则的类。

## 另请参见

+   参见*使用属性进行延迟属性*配方，我们将讨论急切属性和延迟属性之间的选择

+   在第七章 ，*更高级的类设计*，我们将更深入地研究类设计技术

+   参见第十一章 ，*测试*，了解如何为类编写适当的单元测试的方法

# 设计具有大量处理的类

大多数情况下，一个对象将包含定义其内部状态的所有数据。然而，这并不总是正确的。有些情况下，一个类并不真正需要保存数据，而是可以保存处理过程。

这种设计的一些典型例子是统计处理算法，这些算法通常在被分析的数据之外。数据可能在`list`或`Counter`对象中。处理可能是一个单独的类。

当然，在 Python 中，这种处理通常是使用函数实现的。有关更多信息，请参见第三章 ，*函数定义*。在某些语言中，所有代码必须采用类的形式，这会导致一些额外的复杂性。

我们如何设计一个利用 Python 的各种复杂内置集合的类？

## 准备工作

在第四章 ，*内置数据结构-列表、集合、字典*，特别是*使用集合方法和运算符*配方中，我们研究了一种称为**优惠券收集器测试**的统计过程。其概念是每次执行某个过程时，我们保存一个描述该过程的某个方面或参数的优惠券。问题是，在收集完整的优惠券之前，我需要执行多少次该过程？

如果我们根据客户的购买习惯将客户分配到不同的人口统计群体中，我们可能会问在我们看到每个群体的人之前我们需要进行多少次在线销售。如果这些群体的规模大致相同，那么预测在收集完整的优惠券之前我们遇到的平均客户数量是微不足道的。如果这些群体的规模不同，计算在收集完整的优惠券之前的预期时间就会更加复杂。

假设我们使用`Counter`对象收集了数据。有关各种集合的更多信息，请参见第四章 ，*内置数据结构-列表、集合、字典*，特别是*使用集合方法和运算符*和*避免函数参数的可变默认值*配方。在这种情况下，客户分为八个大致相等的类别。

数据看起来是这样的：

```py
    Counter({15: 7, 17: 5, 20: 4, 16: 3, ... etc., 45: 1}) 

```

关键是需要多少次访问才能获得完整的优惠券集。值是需要给定次数的访问次数。在前一行代码中，需要 15 次访问七次。需要 17 次访问五次。这有一个很长的尾巴。有一次，收集完整的八张优惠券需要 45 次单独的访问。

我们想对这个`Counter`进行一些统计。我们有两种整体策略来做到这一点：

+   **扩展**：我们可以扩展`Counter`类定义以添加统计处理。这取决于我们想要引入的处理类型的复杂性。我们将在*扩展集合 - 进行统计的列表*食谱中详细介绍这一点，以及第七章中的*更高级的类设计*。

+   **封装**：我们可以将`Counter`对象封装在另一个类中，该类仅提供我们需要的功能。不过，当我们这样做时，通常需要公开一些额外的方法，这些方法是 Python 的重要部分，但对于我们的应用程序并不重要。我们将在第七章中讨论这一点，*更高级的类设计*。

封装的变体是我们使用统计计算对象来封装内置集合中的对象。这通常会导致一个优雅的解决方案。

我们有两种设计处理的方式。这两种设计选择都适用于整体架构选择：

+   **急切**：这意味着我们将尽快计算统计数据。这些值可以成为类的属性。虽然这可以提高性能，但也意味着对数据收集的任何更改都将使急切计算的值无效。我们必须检查整体上下文，看看是否会发生这种情况。

+   **懒惰**：这意味着我们不会计算任何东西，直到通过方法函数或属性需要。我们将在*使用属性进行延迟属性*食谱中讨论这一点。

这两种设计的基本数学是相同的。唯一的问题是何时进行计算。

我们使用预期值的总和来计算平均值。预期值是值的频率乘以值。平均值*μ*就是这样的：

![准备就绪](img/Image00013.jpg)

在这里，*k*是来自`Counter`的键，*C*，*f[k]*是来自`Counter`的给定键的频率值。

标准差*σ*取决于平均值*μ*。这还涉及计算一系列值的总和，每个值都由频率加权。以下是公式：

![准备就绪](img/Image00014.jpg)

在这里，*k*是来自`Counter`的键，*C*，*f[k]*是来自`Counter`的给定键的频率值。`Counter`中的项目总数是![准备就绪](img/Image00015.jpg)。这是频率的总和。

## 如何做到这一点...

1.  用一个描述性的名称定义类：

```py
            class CounterStatistics: 

    ```

1.  编写`__init__`方法以包括将连接到该对象的对象：

```py
            def __init__(self, raw_counter:Counter): 
                self.raw_counter = raw_counter 

    ```

我们定义了一个方法函数，它以`Counter`对象作为参数值。这个`Counter`对象被保存为`Counter_Statistics`实例的一部分。

1.  初始化可能有用的任何其他本地变量。由于我们将急切地计算值，最急切的可能时间是在创建对象时。我们将写一些尚未定义的函数的引用：

```py
            self.mean = self.compute_mean() 
            self.stddev = self.compute_stddev() 

    ```

我们已经急切地从`Counter`对象计算了平均值和标准差，并将它们保存在两个实例变量中。

1.  为各种值定义所需的方法。这是平均值的计算：

```py
            def compute_mean(self): 
                total, count = 0, 0 
                for value, frequency in self.raw_counter.items(): 
                    total += value*frequency 
                    count += frequency 
                return total/count 

    ```

1.  这是我们如何计算标准差的方法：

```py
            def compute_stddev(self): 
                total, count = 0, 0 
                for value, frequency in self.raw_counter.items(): 
                    total += frequency*(value-self.mean)**2 
                    count += frequency 
                return math.sqrt(total/(count-1)) 

    ```

请注意，这个计算要求首先计算平均值，并且`self.mean`实例变量已经被创建。

此外，这使用了`math.sqrt()`。确保在 Python 文件中添加所需的`import math`语句。

这是我们如何创建一些样本数据的方法：

```py
 **>>> from ch04_r06 import * 
>>> from collections import Counter 
>>> def raw_data(n=8, limit=1000, arrival_function=arrival1): 
...    expected_time = float(expected(n)) 
...    data = samples(limit, arrival_function(n)) 
...    wait_times = Counter(coupon_collector(n, data)) 
...    return wait_times** 

```

我们从`ch04_r06`模块导入了`expected()`、`arrival1()`和`coupon_collector()`等函数。我们还从标准库的`collections`模块导入了`Counter`集合。

我们定义了一个名为`raw_data()`的函数，它将生成一定数量的顾客访问。默认情况下，将会有 1,000 次访问。领域将包括八种不同类别的顾客；每个类别将有相同数量的成员。我们将使用`coupon_collector()`函数来遍历数据，输出收集到完整的八张优惠券所需的访问次数。

然后使用这些数据来组装一个`Counter`对象。这将包括获取完整一套优惠券所需的顾客数量。每个顾客数量还将有一个频率，显示该访问次数发生的频率。

这是我们如何分析`Counter`对象的方法：

```py
 **>>> import random 
>>> from ch06_r02 import CounterStatistics 
>>> random.seed(1) 
>>> data = raw_data() 
>>> stats = CounterStatistics(data) 
>>> print("Mean: {0:.2f}".format(stats.mean)) 
Mean: 20.81 
>>> print("Standard Deviation: {0:.3f}".format(stats.stddev)) 
Standard Deviation: 7.025** 

```

首先，我们导入了`random`模块，以便我们可以选择一个已知的种子值。这样可以更容易地测试和演示应用程序，因为随机数是一致的。我们还从`ch06_r02`模块导入了`CounterStatistics`类。

一旦我们定义了所有的项目，我们就可以将“seed”强制设定为一个已知的值，并生成收集优惠券的测试结果。`raw_data()`函数将会生成一个我们称之为数据的`Counter`对象。

我们将使用`Counter`对象来创建`CounterStatistics`类的一个实例。我们将把这个实例分配给`stats`变量。创建这个实例也将计算一些摘要统计数据。这些值可以作为`stats.mean`属性和`stats.stddev`属性获得。

对于一组八张优惠券，理论平均值是`21.7`次访问以收集所有优惠券。看起来`raw_data()`的结果显示了与随机访问预期相匹配的行为。这有时被称为**零假设**——数据是随机的。

## 它是如何工作的...

这个类封装了两个复杂的算法，但不包括任何改变状态的数据。这种类不需要保留大量数据。相反，设计尽快执行所有计算。

我们为处理编写了一个高级规范，并将其放在`__init__()`方法中。然后我们编写了实现指定处理步骤的方法。我们可以设置所需的属性数量，使其成为一种非常灵活的方法。

这种设计的优点是属性值可以被重复使用。计算成本只需支付一次；每次使用属性值时，无需进一步计算。

这种设计的缺点是，对底层`Counter`对象的更改会使`CounterStatistics`对象过时。通常，当`Counter`不会改变时，我们使用这种设计。该示例创建了一个单一的静态`Counter`，用于创建`CounterStatistics`。

## 还有更多...

如果我们需要有状态的对象，我们可以添加更新方法，可以改变`Counter`对象。例如，我们可以引入一个方法，通过委托工作给相关的`Counter`来添加另一个值。这将把设计模式从计算和收集之间的简单连接转变为对集合的适当封装。

该方法可能如下所示：

```py
    def add(self, value): 
        self.raw_counter[value] += 1 
        self.mean = self.compute_mean() 
        self.stddev = self.compute_stddev() 

```

首先，我们更新了`Counter`的状态。然后，我们重新计算了所有的派生值。这种处理可能会产生巨大的计算开销。需要有一个令人信服的理由，在每次值改变后重新计算均值和标准差。

还有更高效的解决方案。例如，如果我们保存两个中间和一个中间计数，我们可以通过高效地计算平均值和标准差来更新这些和计数。

为此，我们可能有一个看起来像这样的`__init__()`方法：

```py
    def __init__(self, counter:Counter=None): 
        if counter: 
            self.raw_counter = counter 
            self.count = sum(self.raw_counter[k] for k in self.raw_counter) 
            self.sum = sum(self.raw_counter[k]*k for k in self.raw_counter) 
            self.sum2 = sum(self.raw_counter[k]*k**2 for k in self.raw_counter) 
            self.mean = self.sum/self.count 
            self.stddev = math.sqrt((self.sum2-self.sum**2/self.count)/(self.count-1)) 
        else: 
            self.raw_counter = Counter() 
            self.count = 0 
            self.sum = 0 
            self.sum2 = 0 
            self.mean = None 
            self.stddev = None 

```

我们编写了这个方法，可以使用`Counter`或不使用`Counter`。如果没有提供数据，它将从一个空集合开始，并且各种总和的值为零。当计数为零时，均值和标准差没有有意义的值，因此提供`None`。

如果提供了`Counter`，那么将计算`count`，`sum`和平方和。这些可以很容易地进行增量调整，快速重新计算`mean`和标准差。

当添加一个新值时，以下方法将逐渐重新计算各种派生值：

```py
    def add(self, value): 
        self.raw_counter[value] += 1 
        self.count += 1 
        self.sum += value 
        self.sum2 += value**2 
        self.mean = self.sum/self.count 
        if self.count > 1: 
            self.stddev = math.sqrt( 
                (self.sum2-self.sum**2/self.count)/(self.count-1)) 

```

更新`Counter`对象，`count`，`sum`和平方和显然是必要的，以确保`count`，`sum`和平方和值始终与`self.raw_counter`集合匹配。由于我们知道`count`至少必须是`1`，因此均值很容易计算。标准差需要至少两个值，并且是从`sum`和平方和计算的。

这是标准差变体的公式：

![更多内容...](img/Image00016.jpg)

这涉及计算两个总和。一个总和涉及频率乘以值的平方。另一个总和涉及频率和值，总和是平方的。我们用*C*来表示值的总数；这是频率的总和。

## 另请参阅

+   在*扩展集合 - 进行统计的列表*中，我们将看一个不同的设计方法，这些函数用于扩展类定义。

+   我们将在*使用属性进行惰性属性*中看到不同的方法。这种替代方法将使用属性，并根据需要计算属性。

+   在*设计具有少量独特处理的类*中，我们将看一个没有真正处理的类。它作为这个类的完全相反。

# 设计具有少量独特处理的类

在某些情况下，一个对象是相当复杂的数据的容器，但实际上并不对这些数据进行太多处理。事实上，在许多情况下，可以设计一个仅依赖于内置 Python 功能并且不需要任何独特方法函数的类。

在许多情况下，Python 的内置容器类可以几乎覆盖我们的各种用例。小问题是字典或列表的语法不像对象的属性语法那样优雅。

如何创建一个允许我们使用`object.attribute`语法而不是`object['attribute']`的类？

## 准备工作

对于任何类设计，实际上只有两种情况：

+   它是无状态的吗？它包含了许多属性，但从不改变吗？

+   它是有状态的吗？各种属性会发生状态变化吗？

有状态的设计略微更一般。我们总是可以使用有状态的实现，并避免对对象进行任何更改以支持无状态对象。然而，使用真正无状态的对象有一些重要的存储和性能优势。

我们将使用两种类来说明两种设计：

+   **无状态**：我们将定义一个类来描述简单的扑克牌，它有一个等级和一个花色。由于一张牌的等级和花色不会改变，我们将为此创建一个小的无状态类。

+   **有状态**：我们将定义一个类来描述*Blackjack*游戏中玩家当前状态，其中有一个庄家的手，玩家的手，以及一个可选的保险赌注。在每一手中，有许多方面的游戏都在增加。

## 如何做...

我们将先看无状态对象，然后是有状态对象。对于没有方法的有状态对象，我们有两个选择：我们可以使用一个新类，或者我们可以利用一个现有的类。这些选择导致三个小的配方。

### 无状态对象

1.  我们将基于`collections.namedtuple`来构建无状态对象。：

```py
            from collections import namedtuple 

    ```

1.  定义类名，将使用两次：

```py
            Card = namedtuple('Card', 

    ```

1.  定义对象的属性：

```py
            Card = namedtuple('Card', ('rank', 'suit')) 

    ```

这是我们如何使用这个类定义来创建`Card`对象：

```py
 **>>> from collections import namedtuple 
>>> Card = namedtuple('Card', ('rank', 'suit')) 
>>> eight_hearts = Card(rank=8, suit='\N{White Heart Suit}') 
>>> eight_hearts 
Card(rank=8, suit='♡') 
>>> eight_hearts.rank 
8 
>>> eight_hearts.suit 
'♡' 
>>> eight_hearts[0] 
8** 

```

我们已经创建了一个名为`Card`的新类，它有两个属性名称：`rank`和`suit`。在定义类之后，我们可以创建类的实例。我们创建了一个单个的卡片对象`eight_hearts`，它的 rank 是八，suit 是♡。

我们可以使用对象的名称或元组内的位置引用该对象的属性。当我们使用`eight_hearts.rank`或`eight_hearts[0]`时，我们将看到 rank 属性，因为它是在属性名称序列中首先定义的。

这种类定义相对较少见。它具有固定的、定义好的属性集。通常，Python 类定义具有动态属性。此外，对象是不可变的。以下是尝试更改实例属性的示例：

```py
 **>>> eight_hearts.suit = '\N{Black Spade Suit}'  
Traceback (most recent call last): 
  File "/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/doctest.py", line 1318, in __run 
    compileflags, 1), test.globs) 
  File "<doctest default[0]>", line 1, in <module> 
    eight_hearts.suit = '\N{Black Spade Suit}' 
AttributeError: can't set attribute** 

```

我们尝试更改对象的`suit`属性。这引发了一个`AttributeError`异常。

### 使用新类创建有状态对象

1.  定义新类：

```py
            class Player: 
                pass 

    ```

1.  我们已经编写了一个空的类定义。可以使用类似以下的方式轻松创建此类的实例：

```py
            p = Player() 

    ```

然后我们可以使用以下语句向对象添加属性：

```py
    p.stake = 100 

```

虽然这可能效果很好，但通常有助于向类定义添加更多功能。通常，我们会添加方法，包括`__init__()`方法，以初始化对象的实例变量。

### 使用现有类的有状态对象

与其定义一个空类，我们也可以使用标准库中的模块。我们可以使用`argparse`模块或`types`模块来实现这一点：

1.  导入模块。

`argparse`模块包括`Namespace`类，可以用来代替空的类定义：

```py
            from argparse import Namespace
    ```

我们还可以使用`types`模块中的`SimpleNamespace`。它看起来像这样：

```py
            from types import SimpleNamespace 

    ```

1.  将类创建为对`SimpleNamespace`或`Namespace`的引用：

```py
            Player = SimpleNamespace 

    ```

## 工作原理...

这些技术中的任何一种都将定义一个可以具有无限数量属性的类。然而，`SimpleNamespace`比定义我们自己的类具有更灵活的构造函数：

```py
 **>>> from types import SimpleNamespace 
>>> Player = SimpleNamespace 
>>> player_1 = Player(stake=100, hand=[], insurance=None, bet=None) 
>>> player_1.bet = 10 
>>> player_1.stake -= player_1.bet 
>>> player_1.hand.append( eight_hearts ) 
>>> player_1 
namespace(bet=10, hand=[Card(rank=8, suit='♡')], insurance=None, stake=90)** 

```

我们已经创建了一个名为`Player`的新类。我们没有提供属性列表，因为它们是动态的。

当我们构建`player_1`对象时，我们提供了一个要作为该对象一部分创建的属性列表。创建对象后，我们可以对其进行状态更改；我们设置了`player_1.bet`值，更新了`player_1.stake`，还更新了`player_1.hand`。

当我们显示对象时，所有属性都会显示出来。通常，它们以字母顺序提供，这样稍微容易编写单元测试示例。

当我们使用`namedtuple()`函数时，我们正在创建一个类对象。我们提供一个类名作为字符串，以及与元组的位置值相对应的属性名称。结果对象需要分配给一个变量，并且最好确保作为`nametuple()`函数参数提供的类名和变量名相同。

`namedtuple()`创建的类对象与`class`语句创建的类对象是相同类型的类对象。实际上，如果您想要查看源代码，可以使用`print(Card._source)`来查看创建类时使用的确切内容。

`namedtuple`类本质上是一个具有命名属性的元组。与所有其他元组对象一样，它是不可变的——一旦构建，就无法更改。

当我们使用`SimpleNamespace`时，我们使用的是一个几乎没有方法的非常简单的类定义。因为属性通常是动态的，所以这个类允许我们自由地`set`，`get`和`delete`属性。

不是`tuple`的子类或使用`__slots__`（我们将在*使用 __slots__ 优化小对象*中查看的主题）的类非常灵活。还有一些非常高级的技术可以改变属性行为的方式。这些依赖于对 Python 特殊方法名称如何工作的更深入了解。

## 还有更多...

在许多情况下，我们将把应用程序处理分解为两类类定义：

+   **数据-集合和项目**：我们将使用内置的集合类、标准库中的集合，甚至基于`namedtuple()`、`SimpleNamespace`或其他似乎专注于通用数据集合的类定义的项目。

+   **处理**：我们将以与*设计具有大量处理的类*配方中所示的示例类似的方式定义类。这些处理类通常依赖于数据对象。

清晰地将数据与处理分离的想法符合几个 S.O.L.I.D.设计原则。特别是，它使我们的类与单一职责原则、开闭原则和接口隔离原则保持一致。我们可以创建具有狭窄焦点的类，这使得通过子类扩展变得相对简单。

## 另请参阅

+   在*设计具有大量处理的类*配方中，我们将看到一个完全处理而几乎没有数据的类。它充当了这个类的完全相反的极端。

# 使用`__slots__`优化小对象

对象的一般情况允许动态属性集合，每个属性都有动态值。基于`tuple`类的不可变对象有一个特殊情况。我们在*设计具有少量独特处理的类*配方中都看到了这两种情况。

有一个中间地带-一个具有固定数量属性的对象，但属性的值可以改变。通过将类从无限属性集合更改为固定属性集合，我们还可以节省内存和处理时间。

我们如何创建具有固定属性集的优化类？

## 准备工作

让我们来看看在*Blackjack*赌场游戏中一手扑克牌的概念。一手牌有两个部分：

+   牌

+   赌注

两者都具有动态值。但只有这两个东西。通常会获得更多的牌。也可能通过加倍下注来提高赌注。

分牌的想法将创建额外的手牌。每个分牌手是一个独立的对象，具有不同的牌集和独特的赌注。

## 如何做…

在创建类时，我们将利用`__slots__`特殊名称：

1.  定义一个具有描述性名称的类：

```py
            class Hand: 

    ```

1.  定义属性名称列表：

```py
                __slots__ = ('hand', 'bet') 

    ```

这标识了允许该类的实例的唯一两个属性。任何尝试添加其他属性的尝试都将引发`AttributeError`异常。

1.  添加一个初始化方法：

```py
            def __init__(self, bet, hand=None): 
                self.hand= hand or [] 
                self.bet= bet 

    ```

一般来说，每手牌都以赌注开始。然后庄家向手牌发两张初始牌。但在某些情况下，我们可能想要从一系列`Card`实例重新构建一个`Hand`对象。我们使用了`or`运算符的一个特性。如果左侧操作数不是假值（即`None`），那么它就是`or`表达式的值。如果左侧操作数是假值，那么将评估右侧操作数。有关为什么这是必要的更多信息，请参阅第三章中的*设计具有可选参数的函数*配方，*函数定义*。

1.  添加一个更新集合的方法。我们称之为`deal`，因为它用于向`Hand`发牌：

```py
            def deal(self, card): 
                self.hand.append(card) 

    ```

1.  添加一个`__repr__()`方法，以便可以轻松打印：

```py
            def __repr__(self): 
                return "{class_}({bet}, {hand})".format( 
                    class_= self.__class__.__name__, 
                    **vars(self) 
                ) 

    ```

这是我们如何使用这个类来构建一手牌的方法。我们将需要基于*设计具有少量独特处理的类*配方中的示例来定义`Card`类：

```py
 **>>> from ch06_r04 import Card, Hand 
>>> h1 = Hand(2) 
>>> h1.deal(Card(rank=4, suit='♣')) 
>>> h1.deal(Card(rank=8, suit='♡')) 
>>> h1 
Hand(2, [Card(rank=4, suit='♣'), Card(rank=8, suit='♡')])** 

```

我们已经导入了`Card`和`Hand`类的定义。我们创建了一个`Hand`的实例`h1`，赌注是桌面最低赌注的两倍。然后我们通过`Hand`类的`deal()`方法向手牌添加了两张牌。这展示了`h1.hand`值如何被改变。

这个示例还显示了`h1`的实例，以显示赌注和牌的顺序。`__repr__()`方法生成了 Python 语法的输出。

当玩家加倍下注时，我们还可以替换`h1.bet`的值（是的，在显示 12 时这是一个疯狂的事情）：

```py
 **>>> h1.bet *= 2 
>>> h1 
Hand(4, [Card(rank=4, suit='♣'), Card(rank=8, suit='♡')])** 

```

当我们显示`Hand`对象`h1`时，它显示`bet`属性已更改。

当我们尝试创建一个新属性时会发生什么：

```py
 **>>> h1.some_other_attribute = True  
Traceback (most recent call last): 
  File "/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/doctest.py", line 1318, in __run 
    compileflags, 1), test.globs) 
  File "<doctest default[0]>", line 1, in <module> 
    h1.some_other_attribute = True  
AttributeError: 'Hand' object has no attribute 'some_other_attribute'** 

```

我们尝试在`Hand`对象`h1`上创建一个名为`some_other_attribute`的属性。这引发了一个`AttributeError`异常。使用`__slots__`意味着不能向对象添加新属性。

## 工作原理...

当我们创建一个类定义时，行为部分由对象类和`type()`函数定义。隐式地，一个类被分配了一个特殊的`__new__()`方法，用于处理创建新对象所需的内部工作。

Python 有三条基本路径：

+   默认行为会在每个对象中构建一个`__dict__`属性。因为对象的属性被保存在字典中，我们可以自由地添加、更改和删除属性。这种灵活性需要为字典对象使用相对较大的内存。

+   `__slots__`行为避免了`__dict__`属性。因为对象只有`__slots__`序列中命名的属性，我们不能添加或删除属性。我们只能更改已定义属性的值。这种缺乏灵活性意味着每个对象使用的内存更少。

+   `tuple`的子类行为。这些是不可变的对象。创建它们的最简单方法是使用`namedtuple()`。一旦创建，它们就不能被更改。在测量内存使用时，这些是所有对象类中最节俭的。

Python 中很少使用`__slots__`优化。默认的类行为提供了最大的灵活性，并且使得更改类变得容易。然而，在某些情况下，一个大型应用程序可能会受到内存使用量的限制，将一个类切换到`__slots__`可能会显著提高性能。

## 还有更多...

可以调整`__new__()`方法的工作方式，以替换默认的`__dict__`属性为不同类型的字典。这是一种相当高级的技术，因为它暴露了一些更多的类和对象的内部工作。

Python 依赖于元类来创建类的实例。默认的元类是`type`类。这个想法是元类提供了一些功能，用于创建对象。一旦空对象被创建，类的`__init__()`方法将初始化空对象。

通常，元类将提供`__new__()`的定义，也许还有`__prepare__()`，如果有必要自定义命名空间对象。Python 语言参考文档中有一个广泛使用的示例，调整了用于创建类的命名空间。

有关更多详细信息，请参见[`docs.python.org/3/reference/datamodel.html#metaclass-example`](https://docs.python.org/3/reference/datamodel.html#metaclass-example)。

## 另请参阅

+   不可变对象或完全灵活对象的更常见的情况在*设计具有少量独特处理的类*示例中有所涵盖。

# 使用更复杂的集合

Python 有各种各样的内置集合。在第四章中，我们仔细研究了它们。在*选择数据结构*的示例中，我们提供了一种决策树，以帮助从可用选择中找到适当的数据结构。

当我们将标准库整合进来时，我们有更多的选择，也有更多的决策要做。我们如何为我们的问题选择正确的数据结构？

## 准备工作

在将数据放入集合之前，我们需要考虑如何收集数据，以及一旦拥有集合后我们将如何处理它。最重要的问题始终是我们将如何识别集合中的特定项目。我们将看一下一些关键问题，以帮助选择适合我们需求的合适集合。

以下是备选集合的概述。它们在三个模块中。

`collections`模块包含许多内置集合的变体。其中包括以下内容：

+   `deque`：双端队列。它是一个可变序列，具有从每一端推送和弹出的优化。请注意，类名以小写字母开头；这在 Python 中是不典型的。

+   `defaultdict`：可以为缺失的键提供默认值的映射。请注意，类名以小写字母开头；这在 Python 中是不典型的。

+   `Counter`：旨在计算键的出现次数的映射。有时被称为多重集或袋子。

+   `OrderedDict`：保留创建键的顺序的映射。

+   `ChainMap`：将几个字典组合成单个映射的映射。

`heapq`模块包括优先队列实现。这是一种专门的序列，它以排序顺序维护项目。

`bisect`模块包括用于搜索排序列表的方法。这在字典功能和列表功能之间创建了一些重叠。

## 如何做...

有一些问题需要回答，以决定我们是否需要库数据集合而不是内置集合：

1.  结构是否是生产者和消费者之间的缓冲？算法的某些部分是否产生数据项，另一部分是否消耗数据项？

生产者通常会以列表中累积项目，然后消费者从列表中处理项目的一种天真的方法。这种方法往往会构建一个大型的中间数据结构。改变焦点可以交错生产和消费，减少内存使用量。

+   队列用于**先进先出**（**FIFO**）处理。项目从一端插入，从另一端消耗。我们可以使用`list.append()`和`list.pop(0)`来模拟这一过程，尽管`collections.deque`会更有效；我们可以使用`deque.append()`和`deque.popleft()`。

+   栈用于**后进先出**（**LIFO**）处理。项目从同一端插入和消耗。我们可以使用`list.append()`和`list.pop()`来模拟这一过程，尽管`collections.deque`会更有效；我们可以使用`deque.append()`和`deque.pop()`。

+   优先队列（或堆队列）保持队列按某种顺序排序，与到达顺序不同。这通常用于优化工作，包括图搜索算法。我们可以通过使用`list.append()`，`list.sort(key=lambda x:x.priority)`和`list.pop(-1)`来模拟这一过程。由于这涉及每次插入后的排序，效率非常低。使用`heapq`模块要高效得多。

1.  我们希望如何处理字典中缺失的键？

+   引发异常。这是内置`dict`类的工作方式。

+   创建默认项目。这就是`defaultdict`的工作原理。我们必须提供一个返回默认值的函数。常见的例子包括`defaultdict(int)`和`defaultdict(float)`以使用默认值为零。我们还可以使用`defauldict(list)`和`defauldict(set)`来创建字典列表或字典集结构。

+   在某些情况下，我们需要提供不同的文字值作为默认值：

```py
                    lookup = defaultdict(lambda:"N/A") 

    ```

这使用 lambda 对象来定义一个没有名称并始终返回字符串`N/A`的非常小的函数。这将为缺失的键创建一个默认项目`N/A`。

`defaultdict(int)`用于计算项目是如此常见，`Counter`类正好做到了这一点。

1.  我们希望如何处理字典中键的顺序？

+   顺序不重要；我们总是通过键设置和获取项目。这是内置`dict`类的行为。键的排序取决于哈希随机化，因此是不可预测的。

+   我们希望保留插入顺序，同时快速使用它们的键找到项目。`OrderedDict`类提供了这些独特的特性组合。它具有与内置`dict`类相同的接口，但保留了键的插入顺序。

+   我们希望按照正确的顺序对键进行排序。虽然排序列表可以做到这一点，但对于给定的键来说，查找时间相当慢。我们可以使用 bisect 模块来提供对排序列表中项目的快速访问。这需要一个三步算法：

1.  构建列表，可能通过`append()`或`extend()`。

1.  对列表进行排序。`list.sort()`就足够了。

1.  从排序列表中检索，使用`bisect`模块。

1.  我们将如何构建字典？

+   我们有一个简单的算法来创建项目。在这种情况下，内置的 dict 可能就足够了。

+   我们有多个需要合并的字典。这可能发生在读取配置文件时。我们可能有一个单独的配置，一个系统范围的配置，以及一个需要合并的默认应用程序配置。

```py
                        import json 
                        user = json.load('~/app.json') 
                        system = json.load('/etc/app.json') 
                        application = json.load('/opt/app/default.json') 

        ```

1.  我们如何结合这些？

```py
                from collections import ChainMap 
                config = ChainMap(user, system, application) 

    ```

生成的`config`对象将通过各种字典进行顺序搜索。它将在用户、系统和应用程序字典中查找给定的键。

## 它是如何工作的...

数据处理有两个主要的资源约束：

+   存储

+   时间

我们所有的编程都必须遵守这些约束。在大多数情况下，这两者是相互对立的：我们为了减少存储使用而做的任何事情往往会增加处理时间，而我们为了减少处理时间而做的任何事情会增加存储使用。

时间方面通过复杂度度量来形式化。对算法的复杂性进行了相当多的分析：

+   描述为*O*(1)的操作以恒定时间发生。在这种情况下，复杂性不随数据量的增加而改变。对于一些集合，实际的长期平均值几乎是*O*(1)，只有少量例外。列表`append`操作就是一个例子：它们的复杂性都差不多。不过，偶尔在幕后的内存管理操作会增加一些时间。

+   描述为*O*(n)的操作以线性时间发生。随着数据量的增加，成本也会增加。在列表中查找项目具有这种复杂性。在字典中查找项目更接近*O*(1)，因为它的复杂性很低，无论字典有多大，都是（几乎）相同的。

+   描述为*O*(*n* log *n*)的操作增长速度比数据量快。`bisect`模块包括具有这种复杂性的搜索算法。

+   甚至有更糟的情况：一些算法的复杂性是*O(n²)*甚至*O(n!)*。我们希望通过巧妙的设计和更智能的数据结构来避免这些情况。

各种数据结构反映了独特的时间和存储权衡。

## 还有更多...

作为一个具体而极端的例子，让我们来看看在 Web 日志文件中搜索特定事件序列。我们有两种总体设计策略：

+   将所有事件读入类似`file.read().splitlines()`的列表结构中。然后我们可以使用`for`语句来遍历列表，寻找事件的组合。虽然初始读取可能需要一些时间，但搜索会非常快，因为日志都在内存中。

+   从日志文件中读取每个事件。如果事件是模式的一部分，只保存这个事件。我们可以使用`defaultdict`，以 IP 地址作为键，以事件列表作为值。这将需要更长的时间来读取日志，但内存中的结果结构将会小得多。

第一个算法，将所有内容读入内存，通常是非常不切实际的。在大型 Web 服务器上，日志可能涉及数百 GB，甚至是 TB 级别的数据。这是无法容纳在任何计算机内存中的。

第二种方法有许多替代实现：

+   **单个进程**：这里大多数 Python 配方的一般方法假设我们正在创建一个作为单个进程运行的应用程序。

+   **多个进程**：我们可以将逐行搜索扩展为使用`multiprocessing`或`concurrent`包的多进程应用程序。我们将创建一组工作进程，每个进程可以处理可用数据的子集，并将结果返回给组合结果的消费者。在现代多处理器、多核计算机上，这可以非常有效地利用资源。

+   **多个主机**：极端情况需要多个服务器，每个服务器处理数据的一个子集。这需要更复杂的协调来共享结果集。通常，这种处理需要像 Hadoop 这样的框架。

我们经常将大型搜索分解为映射和减少处理。映射阶段对集合中的每个项目应用一些处理或过滤。减少阶段将映射结果组合成摘要或聚合对象。在许多情况下，有一种复杂的**MapReduce**操作层次结构应用于先前 MapReduce 操作的结果。

## 参见

+   在第四章的*选择数据结构*配方中，*内置数据结构 - 列表、集合、字典*，有一组基本的决策，用于选择数据结构

# 扩展集合 - 进行统计的列表

在*设计具有大量处理的类*配方中，我们看了一种区分复杂算法和集合的方法。我们展示了如何将算法和数据封装到单独的类中。

另一种设计策略是将集合扩展到包含有用的算法。

我们如何扩展 Python 的内置集合？

## 准备工作

我们将创建一个复杂的列表，可以计算列表中项目的总和和平均值。这将要求我们的应用程序只将数字放入列表；否则，将会有`ValueError`异常。

## 如何做...

1.  选择一个名称，也可以进行简单的统计。将类定义为内置`list`类的扩展：

```py
            class StatsList(list): 

    ```

这显示了定义内置类的扩展的语法。如果我们提供的主体只包含`pass`语句，那么新的`StatsList`类可以在任何使用`list`类的地方使用。

当我们写这个时，`list`类被称为`StatsList`的超类。

1.  将附加处理定义为新方法。`self`变量将是一个从超类继承了所有属性和方法的对象。这是一个`sum()`方法：

```py
            def sum(self): 
                return sum(v for v in self) 

    ```

我们使用了生成器表达式，以清楚地表明`sum()`函数应用于列表中的每个项目。使用生成器表达式可以让我们非常容易地进行计算或引入过滤器。

1.  这是我们经常应用于列表的另一种方法。这计算项目数：

```py
            def count(self): 
                return sum(1 for v in self) 

    ```

这将计算列表中的项目数。我们选择使用生成器表达式，而不是使用`len()`函数，以防将来想要添加过滤功能。

1.  这是`mean`函数：

```py
                def mean(self): 
                    return self.sum() / self.count() 

    ```

1.  以下是一些附加方法：

```py
            def sum2(self): 
                return sum(v**2 for v in self) 
            def variance(self): 
                return (self.sum2() - self.sum()**2/self.count())/(self.count()-1) 
            def stddev(self): 
                return math.sqrt(self.variance()) 

    ```

`sum2()`方法计算列表中值的平方和。这用于计算方差。然后使用方差来计算列表中值的标准差。

`StatsList`对象继承了`list`对象的所有特性。它通过我们添加的方法进行了扩展。以下是使用此集合的示例：

```py
 **>>> from ch06_r06 import StatsList 
>>> subset1 = StatsList([10, 8, 13, 9, 11]) 
>>> data = StatsList([14, 6, 4, 12, 7, 5]) 
>>> data.extend(subset1)** 

```

我们从对象的文字列表中创建了两个`StatsList`对象。我们使用`extend()`方法来合并这两个对象。以下是结果对象：

```py
 **>>> data 
[14, 6, 4, 12, 7, 5, 10, 8, 13, 9, 11]** 

```

以下是我们如何使用我们在此对象上定义的附加方法：

```py
 **>>> data.mean() 
9.0 
>>> data.variance() 
11.0** 

```

我们展示了`mean()`和`variance()`方法的结果。当然，内置`list`类的所有特性都存在于我们的扩展中：

```py
 **>>> data.sort() 
>>> data[len(data)//2] 
9** 

```

我们使用内置的`sort()`方法，并使用索引功能从列表中提取一个项目。因为值的数量是奇数，这是中位数值。请注意，这会改变`list`对象的顺序。这不是这个算法的最佳实现。

## 它是如何工作的...

类定义的一个基本特征是继承的概念。当我们创建超类-子类关系时，子类继承了超类的所有特性。这有时被称为泛化-特化关系。超类是一个更一般化的类；子类更专业化，因为它添加或修改了特性。

所有内置类都可以扩展以添加特性。在这个例子中，我们添加了一些统计处理，创建了一个特殊类型的列表子类。

两种设计策略之间存在重要的紧张关系：

+   **扩展**：在这种情况下，我们扩展了一个类以添加特性。这些特性与这个单一数据结构紧密结合，我们不能轻易地将它们用于不同类型的序列。

+   **包装**：在设计具有大量处理的类时，我们将处理与集合分开。这会导致在操纵两个对象时更复杂一些。

很难建议其中一个在本质上优于另一个。在许多情况下，我们会发现包装可能具有优势，因为它似乎更符合 S.O.L.I.D.设计原则。然而，总会有一些情况，其中明显适合扩展内置集合。

## 还有更多...

泛化的概念可能导致超类是抽象的。抽象类是不完整的，需要一个子类来扩展它并提供缺失的实现细节。我们不能创建抽象类的实例，因为它会缺少使其有用的特性。

正如我们在第四章的*选择数据结构*配方中所指出的，*内置数据结构-列表、集合、字典*，所有内置集合都有抽象超类。我们可以从一个抽象基类开始设计，而不是从一个具体类开始。

例如，我们可以开始一个类定义如下：

```py
    from collections.abc import Mapping 
    class MyFancyMapping(Mapping): 
    etc. 

```

为了完成这个类，我们需要为许多特殊方法提供实现：

+   `__getitem__()`

+   `__setitem__()`

+   `__delitem__()`

+   `__iter__()`

+   `__len__()`

这些方法中的每一个在抽象类中都是缺失的；它们在`Mapping`类中没有具体的实现。一旦我们为每个方法提供了可行的实现，我们就可以创建新子类的实例。

## 另请参阅

+   在*设计具有大量处理的类*配方中，我们采取了不同的方法。在那个配方中，我们将复杂的算法留在了一个单独的类中。

# 使用属性进行惰性属性

在*设计具有大量处理的类*配方中，我们定义了一个类，它急切地计算了集合中数据的许多属性。那里的想法是尽快计算值，以便属性不会有进一步的计算成本。

我们将这描述为**急切**处理，因为工作尽快完成。另一种方法是**惰性**处理，其中工作尽可能晚地完成。

如果我们有很少使用但计算成本很高的值，我们该怎么做来最小化前期计算，只在真正需要时计算值？

## 准备就绪...

假设我们使用`Counter`对象收集了数据。有关各种集合的更多信息，请参见第四章，*内置数据结构 - 列表、集合、字典*，特别是*使用集合方法和运算符*和*避免函数参数的可变默认值*配方。在这种情况下，客户分为八个大致相等的类别。

数据看起来像这样：

```py
    Counter({15: 7, 17: 5, 20: 4, 16: 3, ... etc., 45: 1}) 

```

在这个集合中，每个键都是获取完整优惠券所需的访问次数。值是发生访问的次数。在我们看到的先前数据中，有七次需要`15`次访问才能获得完整的优惠券。我们可以从样本数据中看到，有五次需要`17`次访问。这有一个长尾。只有一个点，需要`45`次单独访问才能收集到八张优惠券的完整集。

我们想要计算这个`Counter`上的一些统计数据。我们有两种总体策略可以做到这一点：

+   扩展：我们在*扩展集合 - 进行统计的列表*配方中详细介绍了这一点，我们将在第七章中介绍这一点，*更高级的类设计*。

+   包装：我们可以将`Counter`对象包装在另一个类中，该类仅提供我们需要的功能。我们将在第七章中查看这一点，*更高级的类设计*。

包装的常见变体使用具有单独数据收集对象的统计计算对象。这种包装的变体通常会导致优雅的解决方案。

无论我们选择哪种类架构，我们都有两种设计处理的方式：

+   急切：这意味着我们将尽快计算统计数据。这是在*设计具有大量处理的类*配方中采用的方法。

+   懒惰：这意味着在需要通过方法函数或属性时才会计算任何东西。在*扩展集合 - 进行统计的列表*配方中，我们向集合类添加了方法。这些额外的方法是懒惰计算的例子。只有在需要时才计算统计值。

这两种设计的基本数学是相同的。唯一的问题是计算何时完成。

平均值*μ*是这样的：

![准备好...](img/Image00013.jpg)

在这里，*k*是来自`Counter`的键，*C*，*f[k]*是给定键的频率值来自`Counter`。

标准偏差*σ*取决于平均值*μ*。公式如下：

![准备好...](img/Image00014.jpg)

在这里，*k*是来自`Counter`的键，*C*，*f[k]*是给定键的频率值来自`Counter`。计数器中的项目总数是![准备好...](img/Image00015.jpg)。

## 如何做...

1.  定义一个具有描述性名称的类：

```py
            class LazyCounterStatistics: 

    ```

1.  编写初始化方法以包括将连接到该对象的对象：

```py
            def __init__(self, raw_counter:Counter): 
                self.raw_counter = raw_counter 

    ```

我们已经定义了一个方法函数，它以`Counter`对象作为参数值。这个`counter`对象被保存为`Counter_Statistics`实例的一部分。

1.  定义一些有用的辅助方法。每个方法都使用`@property`进行装饰，使其表现得像一个简单的属性：

```py
            @property 
            def sum(self): 
                return sum(f*v for v, f in self.raw_counter.items()) 
            @property 
            def count(self): 
                return sum(f for v, f in self.raw_counter.items()) 

    ```

1.  定义各种值所需的方法。这是平均值的计算。这也是用`@property`装饰的。其他方法可以被引用，就像它们是属性一样，尽管它们是适当的方法函数：

```py
            @property 
            def mean(self): 
                return self.sum / self.count 

    ```

1.  这是我们如何计算标准偏差的方法：

```py
            @property 
            def sum2(self): 
                return sum(f*v**2 for v, f in self.raw_counter.items()) 
            @property 
            def variance(self): 
                return (self.sum2 - self.sum**2/self.count)/(self.count-1) 
            @property 
            def stddev(self): 
                return math.sqrt(self.variance) 

    ```

请注意，我们一直在使用`math.sqrt()`。确保在 Python 文件中添加所需的`import math`语句。

1.  这是我们如何创建一些样本数据的方法：

```py
     **>>> from ch04_r06 import * 
          >>> from collections import Counter 
          >>> def raw_data(n=8, limit=1000, arrival_function=arrival1): 
          ...    expected_time = float(expected(n)) 
          ...    data = samples(limit, arrival_function(n)) 
          ...    wait_times = Counter(coupon_collector(n, data)) 
          ...    return wait_times** 

    ```

我们已经从`ch04_r06`模块导入了`expected()`、`arrival1()`和`coupon_collector()`等函数。我们从标准库`collections`模块导入了`Counter`集合。

我们定义了一个名为`raw_data()`的函数，它将生成一定数量的客户访问。默认情况下，将有 1,000 次访问。域将包括八种不同类别的客户；每个类别将有相等数量的成员。我们将使用`coupon_collector()`函数来遍历数据，发出收集完整八张优惠券所需的访问次数。

然后使用这些数据来组装一个`Counter`对象。这将显示获得完整一套优惠券所需的客户数量。每个客户数量还将显示该访问次数发生的频率。

1.  这是我们如何分析`Counter`对象的方法：

```py
     **>>> import random 
          >>> from ch06_r07 import LazyCounterStatistics 
          >>> random.seed(1)** 

     **>>> data = raw_data() 
          >>> stats = LazyCounterStatistics(data) 
          >>> print("Mean: {0:.2f}".format(stats.mean)) 
          Mean: 20.81** 

     **>>> print("Standard Deviation: {0:.3f}".format(stats.stddev)) 
          Standard Deviation: 7.025** 

    ```

首先，我们导入了`random`模块，以便我们可以选择一个已知的`seed`值。这样做可以更容易地测试和演示应用程序，因为随机数是一致的。我们还从`ch06_r07`模块中导入了`LazyCounterStatistics`类。

一旦我们定义了所有的项目，我们可以强制将种子设为已知值，并生成收集器测试结果。`raw_data()`函数将发出一个`Counter`对象，我们称之为`data`。

我们将使用`Counter`对象来创建`LazyCounterStatistics`类的一个实例。我们将把这个实例分配给`stats`变量。当我们打印`stats.mean`属性和`stats.stddev`属性的值时，方法将被调用来做各种值的适当计算。

对于八张优惠券，理论平均值是 21.7 次访问以收集所有优惠券。看起来`raw_data()`的结果显示了与随机访问预期相匹配的行为。这有时被称为零假设——数据是随机的。

在这种情况下，数据确实是随机的。我们验证了我们的方法。现在我们可以相当有信心地在真实世界的数据上使用这个软件，因为它的行为是正确的。

## 它是如何工作的...

懒惰计算的想法在很少使用值的情况下效果很好。在这个例子中，计数在计算方差和标准差时被计算了两次。

这表明对于懒惰设计的天真看法在某些情况下可能不是最佳的。这是一个很容易修复的问题。我们总是可以创建额外的本地变量来保存中间结果。

为了使这个类看起来像执行急切计算的类，我们使用了`@property`装饰器。这使得一个方法函数看起来像一个属性。这只对没有参数值的方法函数起作用。

在所有情况下，急切计算的属性都可以被懒惰的属性替换。创建急切属性变量的主要原因是为了优化计算成本。在很少使用值的情况下，懒惰的属性可以避免昂贵的计算。

## 还有更多...

有一些情况下，我们可以进一步优化属性，以限制重新计算的数量。这需要仔细分析使用情况，以了解对底层数据的更新模式。

在加载数据并执行分析的情况下，我们可以缓存结果以节省第二次计算它们的成本。

我们可能会这样做：

```py
    def __init__(self, raw_counter:Counter): 
        self.raw_counter = raw_counter 
        self._count = None 
    @property 
    def count(self): 
        if self._count is None: 
            self._count = sum(f for v, f in self.raw_counter.items()) 
        return self._count 

```

这种技术使用一个属性来保存计数计算的副本。这个值可以计算一次，并在需要时无需重新计算地返回。

只有在`raw_counter`对象的状态永远不会改变的情况下，这种优化才有帮助。在更新底层`Counter`的应用程序中，这个缓存值将变得过时。这种应用程序需要在每次更新`Counter`时重新创建`LazyCounterStatistics`。

## 另请参阅...

+   在*设计具有大量处理的类*配方中，我们定义了一个急切计算多个属性的类。这代表了管理计算成本的不同策略。

# 使用可设置的属性来更新急切属性

在之前的几个示例中，我们已经看到了急切和懒惰计算之间的重要区别。请参阅*设计具有大量处理的类*示例，了解急切计算结果并设置对象属性的示例。请参阅*使用属性进行懒惰属性*示例，了解使用属性懒惰地计算结果的方法。

当对象具有状态时，属性值必须在对象的整个生命周期中进行更改。通常使用方法急切地计算属性更改，但这并不是必需的。

对于有状态的对象，我们有以下选择：

+   通过方法设置属性值：

+   急切地计算结果，将结果放在属性中

+   懒惰地计算结果，使用看起来像简单属性的属性

+   通过属性设置值：

+   如果结果是通过属性懒惰地计算的，那么新状态可以反映在这些计算中

如果我们想要使用类似属性的语法来设置值，但又想进行急切计算，我们可以怎么做？

这给了我们另一个变化：我们可以使用属性设置器来使用类似属性的语法。这种方法还可以对结果进行急切的计算。

例如，我们将使用一个外观相当复杂的对象，它有几个属性是从其他属性派生出来的。我们如何急切地计算属性更改的值？

## 准备好

考虑一个表示航程的腿的类。它有三个主要特征——速率、时间和距离。总的来说，可以从其他两个属性的变化中急切地计算任何一个值。

我们可以添加功能，使其变得更加复杂。例如，如果距离是从纬度和经度计算出来的，一般的方法必须稍作修改。如果我们使用特定的点而不是更灵活的距离，那么距离计算可能涉及速率、时间、起点和方位角之类的东西。这涉及到两个相互关联的计算。在这个例子中，我们不会走得那么远；我们将坚持更简单的速率-时间-距离计算。

由于必须设置两个属性才能计算第三个属性，对象将具有相当复杂的内部状态：

+   没有属性被设置：一切都是未知的。

+   已设置一个项目：还不能计算任何东西。

+   已经设置了两个不同的项目：现在可以计算第三个。

之后，最好支持额外的属性更改。基本规则是根据最近的两个不同的更改计算适当的新值：

+   如果速率，*r*，和时间，*t*，是最后更改的两个属性，计算距离，*d*。使用*d = r * t*。

+   如果速率，*r*，和距离，*d*，是最后更改的两个属性，计算时间，*t*。使用*t = d/r*。

+   如果时间，*t*，和距离，*d*，是最后更改的两个属性，计算速率，*r*。使用*r = d/t*。

我们希望对象的行为如下：

```py
    leg_1 = Leg() 
    leg_1.rate = 6.0 # knots 
    leg_1.distance = 35.6 # nautical miles 
    print("Cover {leg.distance:.1f}nm at {leg.rate:.2f}kt = {leg.time:.2f}hr". 
        format(leg=leg_1)) 

```

这有一个明显的优势，即为`leg`对象提供了一个非常简单的接口。应用程序只需设置任何两个属性，计算就会急切地执行，以为剩余的属性提供一个值。

## 如何做...

我们将把这分为两部分。首先是定义可设置属性的概述，然后是如何跟踪状态变化的细节：

1.  定义一个有意义的类名。

1.  提供隐藏属性。这些将被公开为属性：

```py
            class Leg: 
            def __init__(self): 
                self._rate= rate 
                self._time= time 
                self._distance= distance. 

    ```

1.  对于每个可获取的属性，提供一个计算属性值的方法。在许多情况下，这些方法将与隐藏属性并行：

```py
            @property 
            def rate(self): 
                return self._rate 

    ```

1.  对于每个可设置的属性，提供一个设置属性值的方法：

```py
            @rate.setter 
            def rate(self, value): 
                self._rate = value 
                self._calculate('rate') 

    ```

设置方法具有基于获取方法名称的特殊属性装饰器。在这个例子中，`@property`装饰器在`rate()`方法上还创建了一个`rate.setter`装饰器，可以用来定义该属性的设置方法。

注意，getter 和 setter 的方法名称是相同的。`@property`和`@rate.setter`装饰区分了这两个方法。

在这个例子中，我们将值保存到隐藏属性`self._rate`中。然后，如果可能的话，使用`_calculate()`方法急切地计算所有隐藏属性。

1.  这可以重复应用到所有其他属性上。在我们的例子中，时间和距离的代码是相似的：

```py
            @property 
            def time(self): 
                return self._time 
            @time.setter 
            def time(self, value): 
                self._time = value 
                self._calculate('time') 
            @property 
            def distance(self): 
                return self._distance 
            @distance.setter 
            def distance(self, value): 
                self._distance = value 
                self._calculate('distance') 

    ```

跟踪状态更改的细节依赖于`collections.deque`类的一个特性。计算规则可以实现为两个元素的有界队列，其中包含不同的更改。当每个不同的字段被更改时，我们可以将字段名称入队。队列中的两个不同名称是最近更改的最后两个字段；第三个可以通过集合减法从中确定：

1.  导入`deque`类：

```py
            from collections import deque 

    ```

1.  在`__init__()`方法中初始化队列：

```py
            self._changes= deque(maxlen=2) 

    ```

1.  入队每个不同的更改。确定队列中缺少什么，并计算出来：

```py
                def _calculate(self, change): 
                if change not in self._changes: 
                    self._changes.append(change) 
                compute = {'rate', 'time', 'distance'} - set(self._changes) 
                if compute == {'distance'}: 
                    self._distance = self._time * self._rate 
                elif compute == {'time'}: 
                    self._time = self._distance / self._rate 
                elif compute == {'rate'}: 
                    self._rate = self._distance / self._time 

    ```

如果最新的更改尚未在队列中，它将被追加。由于队列有一个有界的大小，最老的项目，即最近更改的项目，将被悄悄地弹出以保持队列大小固定。

可用属性集和最近更改的属性集之间的差异是一个属性名称。这是最近设置的名称；这个值可以从更近设置的其他两个值计算出来。

## 它是如何工作的...

这是因为 Python 实现了一种称为**描述符**的类的属性。描述符类可以有获取值、设置值和删除值的方法。根据上下文，其中一个方法会被隐式使用：

+   当在表达式中使用描述符对象时，将使用`__get__`方法

+   当一个描述符出现在赋值语句的左侧时，将使用`__set__`方法

+   当描述符出现在`del`语句中时，将使用`__delete__`方法

`@property`装饰器做了三件事：

+   修改后面的方法，将其包装成一个描述符对象。后面的方法被修改为描述符的`__get__`方法。在表达式中使用时，它将计算值。

+   添加`method.setter`装饰器。这个装饰器将修改后面的方法成为描述符的`__set__`方法。当名称在赋值语句的左侧使用时，给定的方法将被执行。

+   添加`method.deleter`装饰器。这个装饰器将修改后面的方法成为描述符的`__delete__`方法。当名称在`del`语句中使用时，给定的方法将被执行。

这允许构建一个属性名称，可以用来提供值、设置值，甚至删除值。

## 还有更多...

对这个类还有一些更多的改进。我们将看看两种更高级的初始化和计算技术。

### 初始化

我们可以提供一种正确初始化实例的方法。这个改变使得可以做到以下几点：

```py
 **>>> from ch06_r08 import Leg 
>>> leg_2 = Leg(distance=38.2, time=7) 
>>> round(leg_2.rate, 2) 
5.46 
>>> leg_2.time=6.5 
>>> round(leg_2.rate, 2) 
5.88** 

```

这个例子展示了如何通过帆船规划航行。如果要覆盖的距离是`38.2`海里，目标是在`7`小时内完成，船必须达到`5.46`节的速度。要缩短半个小时的行程需要达到`5.88`节的速度。

为了使其工作，需要更改`__init__()`方法。内部的`dequeue`对象必须立即构建。当设置每个属性时，必须使用内部的`_calculate()`方法来跟踪设置：

```py
    class Leg: 
        def __init__(self, rate=None, time=None, distance=None): 
            self._changes= deque(maxlen=2) 
            self._rate= rate 
            if rate: self._calculate('rate') 
            self._time= time 
            if time: self._calculate('time') 
            self._distance= distance 
            if distance: self._calculate('distance') 

```

首先创建`dequeue`函数。当设置每个单独的字段值时，更改将被记录在更改属性的队列中。如果设置了两个字段，第三个将被计算。

如果设置了所有三个字段，那么最后两个更改——在这种情况下是时间和距离——将计算出`rate`的值。这将覆盖提供的值。

### 计算

目前，各种计算都隐藏在一个`if`语句中。这使得更改变得困难，因为子类将被迫提供整个方法，而不仅仅是提供计算更改。

我们可以使用内省技术来移除`if`语句。整体设计会更好，使用显式计算方法：

```py
    def calc_distance(self): 
        self._distance = self._time * self._rate 
    def calc_time(self): 
        self._time = self._distance / self._rate 
    def calc_rate(self): 
        self._rate = self._distance / self._time 

```

以下版本的`_calculate()`利用了这些方法：

```py
    def _calculate(self, change): 
        if change not in self._changes: 
            self._changes.append(change) 
        compute = {'rate', 'time', 'distance'} - set(self._changes) 
        if len(compute) == 1: 
            name = compute.pop() 
            method = getattr(self, 'calc_'+name) 
            method() 

```

当计算的值是一个单例集合时，使用`pop()`方法从集合中提取该值。在这个字符串前加上`calc_`会得到一个计算所需值的方法的名称。

`getattr()`函数进行查找以找到对象`self`的请求方法，然后将其作为绑定函数进行评估。它可以使用所需的结果更新属性。

将计算重构为单独的方法使得类更容易扩展。现在我们可以创建一个包括修订计算但保留类的整体特性的子类。

## 另请参阅

+   有关使用集合的更多信息，请参阅第四章中的*使用集合方法和运算符*配方，*内置数据结构 - 列表，集合，字典*。

+   `dequeue`实际上是一个针对追加和弹出操作进行了高度优化的列表。请参阅第四章中的*从列表中删除 - 删除，移除，弹出和过滤*配方，*内置数据结构 - 列表，集合，字典*。
