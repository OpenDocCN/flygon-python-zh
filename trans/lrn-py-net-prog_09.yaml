- en: Chapter 9. Applications for the Web
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章 网络应用
- en: In [Chapter 2](ch02.html "Chapter 2. HTTP and Working with the Web"), *HTTP
    and Working with the Web*, we explored the HTTP protocol—the primary protocol
    used by the World Wide Web—and we learned how to use Python as an HTTP client.
    In [Chapter 3](ch03.html "Chapter 3. APIs in Action"), *APIs in Action*, we expanded
    on this and looked at ways to consume web APIs. In this chapter, we'll be turning
    our focus around and looking at how we can use Python to build applications that
    serve responses to HTTP requests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. HTTP和网络工作") *HTTP和网络工作*中，我们探讨了HTTP协议——万维网主要使用的协议，并学习了如何使用Python作为HTTP客户端。在[第3章](ch03.html
    "第3章. API实践") *API实践*中，我们扩展了这一点，并研究了消费Web API的方法。在本章中，我们将把重点转向，看看如何使用Python构建应用程序，以响应HTTP请求。
- en: 'In this chapter, we''ll cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Python web frameworks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python web frameworks
- en: A Python web application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Python网络应用
- en: Hosting Python and WSGI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管Python和WSGI
- en: I should note up front that hosting modern web applications is a very large
    topic, and a complete treatment is well beyond the scope of this book, where we're
    focusing on applying Python code to network problems. Topics such as database
    access, selecting and configuring load balancers and reverse-proxies, containerization,
    and the system administration techniques needed to keep the whole show up and
    running won't be covered here. There are many great resources online though that
    can give you a start, and we'll try to mention as many as we can where relevant,
    as we go along.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该提前指出，托管现代Web应用是一个非常庞大的主题，完整的处理远远超出了本书的范围，我们的重点是将Python代码应用于网络问题。诸如数据库访问、选择和配置负载均衡器和反向代理、容器化以及保持整个系统运行所需的系统管理技术等主题在这里不会涉及。然而，有许多在线资源可以为您提供一个起点，我们将尽量在相关的地方提及尽可能多的资源。
- en: Having said that, the technologies listed above aren't a requirement for creating
    and serving Python-based web applications, they're simply what a service comes
    to require as it reaches scale. As we'll see, there are options for easily manageable
    small-scale application hosting too.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，上述列出的技术并不是创建和提供基于Python的Web应用程序的要求，它们只是在服务达到规模时所需的。正如我们将看到的，对于易于管理的小规模应用程序托管也有选择。
- en: What's in a web server?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web服务器中包含什么？
- en: To understand how we can employ Python in responding to HTTP requests, we need
    to know a bit about what typically needs to occur in order to respond to a request,
    and what tools and patterns already exist to do this.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用Python来响应HTTP请求，我们需要了解一些通常需要发生的事情，以便响应请求，以及已经存在的工具和模式。
- en: 'A basic HTTP request and response might look like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的HTTP请求和响应可能如下所示：
- en: '![What''s in a web server?](graphics/6008OS_09_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Web服务器中包含什么？](graphics/6008OS_09_01.jpg)'
- en: Here our web client sends an HTTP request to a server, where a web server program
    interprets the request, creates a suitable HTTP response, and sends it back. In
    this case, the response body is simply the contents of an HTML file read from,
    with the response headers added by the web server program.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的Web客户端向服务器发送HTTP请求，其中Web服务器程序解释请求，创建适当的HTTP响应，并将其发送回来。在这种情况下，响应主体只是从中读取的HTML文件的内容，响应头由Web服务器程序添加。
- en: 'The web server is responsible for the entire process of responding to the client''s
    request. The basic steps it needs to perform are:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器负责响应客户端请求的整个过程。它需要执行的基本步骤是：
- en: '![What''s in a web server?](graphics/6008OS_09_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Web服务器中包含什么？](graphics/6008OS_09_02.jpg)'
- en: First the web server program needs to accept the TCP connection attempt by the
    client. It then receives the HTTP request from the client over the TCP connection.
    The server needs to keep the TCP connection open while it generates the HTTP response,
    and it uses the connection to send the response back to the client. What the server
    does with the connection after that depends on the HTTP version in use and the
    value of a possible Connection header in the request (see the RFC for full details
    at [http://tools.ietf.org/html/rfc7230#section-6.3](http://tools.ietf.org/html/rfc7230#section-6.3)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Web服务器程序需要接受客户端的TCP连接尝试。然后，它通过TCP连接从客户端接收HTTP请求。服务器需要在生成HTTP响应时保持TCP连接打开，并使用连接将响应发送回客户端。服务器在此之后对连接的处理取决于所使用的HTTP版本以及请求中可能的Connection头的值（有关完整细节，请参阅RFC
    [http://tools.ietf.org/html/rfc7230#section-6.3](http://tools.ietf.org/html/rfc7230#section-6.3)）。
- en: Once the web server has received the request, it parses it, then generates the
    response. When the requested URL maps to a valid resource on the server, the server
    will respond with the resource at that URL. The resource could be a file on disk
    (so-called **static content**), as shown in the diagram of a basic HTTP request
    and response from before, it could be an HTTP redirect, or it could be a dynamically
    generated HTML page. If something goes wrong, or the URL is not valid, then instead
    the response will include a status code in the `4xx` or `5xx` range. Once the
    response is prepared, the server sends it back to the client over the TCP connection.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Web服务器收到请求，它会解析请求，然后生成响应。当请求的URL映射到服务器上的有效资源时，服务器将使用该URL处的资源进行响应。资源可以是磁盘上的文件（所谓的**静态内容**），如前面的基本HTTP请求和响应的图表所示，它可以是一个HTTP重定向，或者它可以是一个动态生成的HTML页面。如果出现问题，或者URL无效，则响应将包含`4xx`或`5xx`范围内的状态代码。准备好响应后，服务器通过TCP连接将其发送回客户端。
- en: In the early days of the Web, when almost all requested resources consisted
    of static files read from disk, web servers could be written in a single language
    and could easily handle all four steps shown in the preceding image. However,
    as more and more dynamic content came into demand, such as shopping baskets and
    database-driven resources such as blogs, wikis, and social media, it was quickly
    found that hard-coding these functionalities into the web server itself was impractical.
    Instead, facilities were built into web servers to allow the invocation of external
    code as part of the page generation process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web的早期，几乎所有请求的资源都是从磁盘读取的静态文件，Web服务器可以用一种语言编写，并且可以轻松处理前面图像中显示的所有四个步骤。然而，随着越来越多的动态内容的需求，例如购物篮和数据库驱动的资源，如博客、维基和社交媒体，很快就发现将这些功能硬编码到Web服务器本身是不切实际的。相反，Web服务器内置了设施，允许调用外部代码作为页面生成过程的一部分。
- en: Hence, web servers could be written in a fast language such as C and could deal
    with the low-level TCP connections, initial parsing and validating of requests,
    and handling static content, but then could invoke external code to handle page
    generation duties when a dynamic response was needed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Web服务器可以用快速的语言（如C语言）编写，并处理低级别的TCP连接、请求的初始解析和验证以及处理静态内容，但在需要动态响应时，可以调用外部代码来处理页面生成任务。
- en: 'This external code is what we commonly refer to when we talk about web applications.
    So the response process duties can be split, as shown in the following figure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个外部代码是我们在谈论Web应用程序时通常指的内容。因此，响应过程的职责可以分为以下几个部分，如下图所示：
- en: '![What''s in a web server?](graphics/6008OS_09_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Web服务器中有什么？](graphics/6008OS_09_03.jpg)'
- en: Web applications can be written in any language that the web server is able
    to invoke, providing great flexibility and allowing higher level languages to
    be used. This can drastically reduce the time it takes to develop a new web service.
    These days there is a great range of languages that can be used to write web applications,
    and Python is no exception.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序可以用Web服务器能够调用的任何语言编写，提供了很大的灵活性，并允许使用更高级别的语言。这可以大大减少开发新Web服务所需的时间。如今有很多语言可以用来编写Web应用程序，Python也不例外。
- en: Python and the Web
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python和Web
- en: Using some of the techniques discussed in this book, in particular [Chapter
    8](ch08.html "Chapter 8. Client and Server Applications"), *Client and Server
    Applications*, it is possible to use Python to write a full web server that handles
    all four of the steps of handling an HTTP request that we listed in the previous
    section. There are several actively developed web servers already in existence
    written in pure Python, including Gunicorn ([http://gunicorn.org](http://gunicorn.org)),
    and CherryPy ([http://www.cherrypy.org](http://www.cherrypy.org)). There is even
    a very basic HTTP server in the standard library http.server module.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本书中讨论的一些技术，特别是[第8章](ch08.html "第8章.客户端和服务器应用程序")中讨论的技术，可以使用Python编写一个完整的Web服务器，处理我们在前一节中列出的处理HTTP请求的四个步骤。已经有几个正在积极开发的Web服务器纯粹用Python编写，包括Gunicorn
    ([http://gunicorn.org](http://gunicorn.org))和CherryPy ([http://www.cherrypy.org](http://www.cherrypy.org))。标准库http.server模块中甚至有一个非常基本的HTTP服务器。
- en: Writing a full HTTP server is not a trivial task and a detailed treatment is
    well beyond the scope of this book. It is also not a very common requirement nowadays,
    primarily due to the prevalence of excellent web servers that are already ready
    to deploy. If you do feel the need to have a crack at this challenge though, I
    would start with looking through the source code of the web servers mentioned
    earlier, looking in more detail at the frameworks listed in [Chapter 8](ch08.html
    "Chapter 8. Client and Server Applications"), *Client and Server Applications*,
    and reading the full HTTP specifications in the relevant RFCs. You may also want
    to read the WSGI specifications, discussed in the WSGI section later on, so as
    to allow the server to act as a host for other Python web applications.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个完整的HTTP服务器并不是一项微不足道的任务，详细的处理远远超出了本书的范围。由于已经准备好部署的优秀Web服务器的普及，这也不是一个非常常见的需求。如果你确实有这个需求，我建议你首先查看前面提到的Web服务器的源代码，更详细地查看[第8章](ch08.html
    "第8章.客户端和服务器应用程序")中列出的框架，*客户端和服务器应用程序*，并阅读相关RFC中的完整HTTP规范。您可能还想阅读WSGI规范，稍后在WSGI部分讨论，以便允许服务器充当其他Python
    Web应用程序的主机。
- en: The much stronger requirement is to build a web service application to generate
    some dynamic content, and to get it up and running quickly. In this situation,
    Python provides us with some excellent options in the form of web frameworks.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 更强的要求是构建一个Web服务应用程序来生成一些动态内容，并快速运行起来。在这种情况下，Python为我们提供了一些优秀的选择，以Web框架的形式。
- en: Web frameworks
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web框架
- en: A web framework is a layer that sits between the web server and our Python code,
    which provides abstractions and streamlined APIs to perform many of the common
    operations of interpreting HTTP requests and generating responses. Ideally, it
    is also structured so that it guides us into employing well-tested patterns for
    good web development. Frameworks for Python web applications are usually written
    in Python, and can be considered part of the web application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Web框架是位于Web服务器和我们的Python代码之间的一层，它提供了抽象和简化的API，用于执行解释HTTP请求和生成响应的许多常见操作。理想情况下，它还应该结构良好，引导我们采用经过良好测试的Web开发模式。Python
    Web应用程序的框架通常是用Python编写的，并且可以被视为Web应用程序的一部分。
- en: 'The basic services a framework provides are:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 框架提供的基本服务包括：
- en: Abstraction of HTTP requests and responses
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP请求和响应的抽象
- en: Management of the URL space (routing)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL空间的管理（路由）
- en: Separation of Python code and markup (templating)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python代码和标记（模板）的分离
- en: 'There are many Python web frameworks in use today, and here''s a non-exhaustive
    list of some popular ones, in no particular order:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 今天有许多Python网络框架在使用，以下是一些流行的框架列表，排名不分先后：
- en: Django ([www.djangoproject.com](http://www.djangoproject.com))
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django（[www.djangoproject.com](http://www.djangoproject.com)）
- en: CherryPy ([www.cherrypy.org](http://www.cherrypy.org))
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CherryPy（[www.cherrypy.org](http://www.cherrypy.org)）
- en: Flask ([flask.pocoo.org](http://flask.pocoo.org))
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask（[flask.pocoo.org](http://flask.pocoo.org)）
- en: Tornado ([www.tornadoweb.org](http://www.tornadoweb.org))
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tornado（[www.tornadoweb.org](http://www.tornadoweb.org)）
- en: TurboGears ([www.turbogears.org](http://www.turbogears.org))
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TurboGears（[www.turbogears.org](http://www.turbogears.org)）
- en: Pyramid ([www.pylonsproject.org](http://www.pylonsproject.org))
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金字塔（[www.pylonsproject.org](http://www.pylonsproject.org)）
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An up-to-date list of frameworks is maintained at [http://wiki.python.org/moin/WebFrameworks](https://wiki.python.org/moin/WebFrameworks)
    and [http://docs.python-guide.org/en/latest/scenarios/web/#frameworks](http://docs.python-guide.org/en/latest/scenarios/web/#frameworks).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 维护有关框架的最新列表[http://wiki.python.org/moin/WebFrameworks](https://wiki.python.org/moin/WebFrameworks)和[http://docs.python-guide.org/en/latest/scenarios/web/#frameworks](http://docs.python-guide.org/en/latest/scenarios/web/#frameworks)。
- en: There are so many frameworks because there are many approaches that can be taken
    to the tasks they perform, and many different opinions about what tasks they should
    even perform.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有这么多框架是因为可以采用许多方法来执行它们执行的任务，并且对于它们甚至应该执行的任务有许多不同的观点。
- en: Some frameworks provide the minimum to quickly build a simple web application.
    These are often called **microframeworks**, the most popular here being Armin
    Ronacher's excellent Flask. Although they may not include the functionality of
    some of the heavyweight frameworks, what they do, they generally do very well,
    and provide hooks to allow easy extension for more complex tasks. This allows
    a fully customizable approach to web application development.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一些框架提供了快速构建简单Web应用程序所需的最低功能。这些通常被称为**微框架**，这里最受欢迎的是Armin Ronacher的出色的Flask。尽管它们可能不包括一些重量级框架的功能，但它们通常做得非常好，并提供了钩子，以便轻松扩展更复杂的任务。这允许完全定制的Web应用程序开发方法。
- en: Other frameworks take a much more batteries-included stance, providing for all
    the common needs of modern web applications. The major contender here is Django,
    which includes everything from templating to form management and database abstraction,
    and even a complete out-of-the-box web-based database admin interface. TurboGears
    provides similar functionality by integrating a core microframework with several
    established packages for the other features.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其他框架采用更多的电池包含方式，为现代Web应用程序的所有常见需求提供支持。这里的主要竞争者是Django，它包括从模板到表单管理和数据库抽象，甚至完整的开箱即用的基于Web的数据库管理界面的所有内容。TurboGears通过将核心微框架与其他功能的几个已建立的软件包集成来提供类似的功能。
- en: Yet other frameworks provide features such as supporting web applications with
    an event-driven architecture, such as Tornado, and CherryPy. Both of these also
    feature their own built-in production quality web servers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他框架提供支持具有事件驱动架构的Web应用程序的功能，例如Tornado和CherryPy。这两者还具有自己内置的生产质量Web服务器。
- en: Choosing a framework can be a tricky decision, and there is no right answer.
    We're going to take a quick look at one of today's most popular frameworks to
    get an idea of the services a framework can offer, then discuss how you might
    approach choosing one.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个框架可能是一个棘手的决定，没有正确的答案。我们将快速浏览今天最流行的框架之一，以了解框架可以提供的服务，然后讨论如何选择一个框架的方法。
- en: Flask – a microframework
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask-微框架
- en: 'To get a taste of working with a Python web framework, we''re going to write
    a small app with Flask. We''ve chosen Flask because it provides a lean interface,
    giving us the features we need while getting out of the way and letting us code.
    Also, it doesn''t require any significant preconfiguration, all we need to do
    is install it, like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了体验使用Python Web框架的感觉，我们将使用Flask编写一个小应用程序。我们选择Flask，因为它提供了一个精简的接口，为我们提供了所需的功能，同时让我们编写代码。而且，它不需要任何重要的预配置，我们需要做的就是安装它，就像这样：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Flask can also be downloaded from the project's homepage at [http://flask.pocoo.org](http://flask.pocoo.org).
    Note that to run Flask under Python 3, you will need Python 3.3 or higher.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Flask也可以从项目的主页[http://flask.pocoo.org](http://flask.pocoo.org)下载。请注意，要在Python
    3下运行Flask，您将需要Python 3.3或更高版本。
- en: 'Now create a project directory, and within the directory create a text file
    called `tinyflaskapp.py`. Our app is going to allow us to browse the docstrings
    for the Python built-in functions. Enter this into `tinyflaskapp.py`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个项目目录，并在目录中创建一个名为`tinyflaskapp.py`的文本文件。我们的应用程序将允许我们浏览Python内置函数的文档字符串。将其输入到`tinyflaskapp.py`中：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code can be found in this book's source code download for this chapter
    within the `1-init` folder.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码可以在本书本章的源代码下载中找到，位于`1-init`文件夹中。
- en: 'Flask includes a development web server, so to try out our application all
    we need to do is run the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Flask包含一个开发Web服务器，因此要尝试我们的应用程序，我们只需要运行以下命令：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can see that the Flask server tells us the IP address and port it's listening
    on. Connect to the URL it displays (in the preceding example this is `http://127.0.0.1:5000/`)
    now in a web browser, and you should see a page with a list of Python built-in
    functions. Clicking on one should display a page showing the function name and
    its docstring.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Flask服务器告诉我们它正在侦听的IP地址和端口。现在在Web浏览器中连接到它显示的URL（在前面的示例中，这是`http://127.0.0.1:5000/`），您应该会看到一个列出Python内置函数的页面。单击其中一个应该显示一个显示函数名称及其文档字符串的页面。
- en: If you want to run the server on another interface or port, you can change the
    `app.run()` call, for example, to `app.run(host='0.0.0.0', port=5001)`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在另一个接口或端口上运行服务器，可以更改`app.run()`调用，例如更改为`app.run(host='0.0.0.0', port=5001)`。
- en: Let's go through our code. From the top, we create our Flask app by creating
    a `Flask` instance, in this case giving it the name of our main module. We then
    set debug mode to active, which provides nice tracebacks in the browser when something
    goes wrong, and also sets the development server to automatically reload code
    changes without needing a restart. Note that debug mode should never be left active
    in a production app! This is because the debugger has an interactive element,
    which allows code to be executed on the server. By default, debug is off, so all
    we need to do is delete the `app.config.debug` line when we put the app into production.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的代码。从顶部开始，我们通过创建一个 `Flask` 实例来创建我们的 Flask 应用，这里给出了我们主要模块的名称。然后我们将调试模式设置为活动状态，在浏览器中出现问题时提供良好的回溯，并且还设置开发服务器以自动重新加载代码更改而无需重新启动。请注意，调试模式永远不应该在生产应用中保持活动状态！这是因为调试器具有交互元素，允许在服务器上执行代码。默认情况下，调试是关闭的，因此当我们将应用投入生产时，我们只需要删除
    `app.config.debug` 行即可。
- en: 'Next we filter the built-in function objects out of the globals and extract
    their docstrings for later use. Now we have the main section of the app, and we
    encounter the first of Flask''s superpowers: URL routing. The heart of a Flask
    app is a set of functions, usually called **views**, that handle requests for
    various parts of our URL space—`index()` and `show_docstring()` are such functions.
    You will see both are preceded by a Flask decorator function, `app.route()`. This
    tells Flask which parts of our URL space the decorated function should handle.
    That is, when a request comes in with a URL that matches a pattern in an `app.route()`
    decorator, the function with the matching decorator is called to handle the request.
    View functions must return a response that Flask can return to the client, but
    more on that in a moment.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将内置的函数对象从全局变量中过滤出来，并提取它们的文档字符串以备后用。现在我们有了应用程序的主要部分，我们遇到了 Flask 的第一个超能力：URL
    路由。一个 Flask 应用的核心是一组函数，通常称为**视图**，它们处理我们 URL 空间的各个部分的请求——`index()` 和 `show_docstring()`
    就是这样的函数。您会看到这两个函数都是由 Flask 装饰器函数 `app.route()` 预先处理的。这告诉 Flask 装饰的函数应该处理我们 URL
    空间的哪些部分。也就是说，当一个请求带有与 `app.route()` 装饰器中的模式匹配的 URL 时，将调用具有匹配装饰器的函数来处理请求。视图函数必须返回
    Flask 可以返回给客户端的响应，但稍后会详细介绍。
- en: The URL pattern for our `index()` function is just the site root, `'/'`, meaning
    that only requests for the root will be handled by `index()`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `index()` 函数的 URL 模式只是站点根目录 `'/'`，这意味着只有对根目录的请求才会由 `index()` 处理。
- en: In `index()`, we just compile our output HTML as a string—first our list of
    links to the functions' pages, then a header—and then we return the string. Flask
    takes the string and creates a response out of it, using the string as the response
    body and adding a few HTTP headers. In particular, for `str` return values, it
    sets `Content-Type` to `text/html`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `index()` 中，我们只需将输出的 HTML 编译为字符串——首先是我们链接到函数页面的列表，然后是一个标题——然后我们返回字符串。Flask
    获取字符串并创建响应，使用字符串作为响应主体，并添加一些 HTTP 头。特别是对于 `str` 返回值，它将 `Content-Type` 设置为 `text/html`。
- en: The `show_docstrings()` view does a similar thing—it returns the name of the
    built-in function we're viewing in an HTML header tag, plus the docstring wrapped
    in a `<pre>` tag (to preserve new lines and whitespace).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`show_docstrings()` 视图也做了类似的事情——它在 HTML 标题标签中返回我们正在查看的内置函数的名称，以及包含在 `<pre>`
    标签中的文档字符串（以保留换行和空格）。'
- en: The interesting part is the `app.route('/functions/<func_name>')` call. Here
    we're declaring that our functions' pages will live in the `functions` directory,
    and we're capturing the name of the requested function using the `<func_name>`
    segment. Flask captures the section of the URL in angle brackets and makes it
    available to our view. We pull it into the view namespace by declaring the `func_name`
    argument for `show_docstring()`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分是 `app.route('/functions/<func_name>')` 的调用。在这里，我们声明我们的函数页面将位于 `functions`
    目录中，并使用 `<func_name>` 段捕获请求的函数名称。Flask 捕获 URL 的尖括号部分，并使其可用于我们的视图。我们通过为 `show_docstring()`
    声明 `func_name` 参数将其引入视图命名空间。
- en: In the view, we check that the name supplied is valid by seeing whether it appears
    in the `docstrings` dict. If it's okay, we build and return the corresponding
    HTML. If it's not okay, then we return a `404 Not Found` response to the client
    by calling Flask's `abort()` function. This function raises a Flask `HTTPException`,
    which if not handled by our application, will cause Flask to generate an error
    page and return it to the client with the corresponding status code (in this case
    404). This is a good way to fail fast when we encounter bad requests.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在视图中，我们通过查看名称是否出现在 `docstrings` 字典中来检查提供的名称是否有效。如果有效，我们构建并返回相应的 HTML。如果无效，我们通过调用
    Flask 的 `abort()` 函数向客户端返回 `404 Not Found` 响应。此函数会引发一个 Flask `HTTPException`，如果我们的应用程序没有处理，Flask
    将生成一个错误页面并将其返回给客户端，同时返回相应的状态码（在本例中为 404）。这是在遇到错误请求时快速失败的好方法。
- en: Templating
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: You can see from our preceding views that even when cheekily omitting the usual
    HTML formalities such as `<DOCTYPE>` and the `<html>` tag to save complexity,
    constructing HTML in Python code is clunky. It's difficult to get a feel for the
    overall page, and it's impossible for designers with no Python knowledge to work
    on the page design. Also, mixing the generation of the presentation code with
    the application logic makes both harder to test.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前的视图中可以看出，即使在调皮地省略了通常的 HTML 正式性，比如 `<DOCTYPE>` 和 `<html>` 标签以节省复杂性，但在 Python
    代码中构建 HTML 仍然很笨拙。很难对整个页面有所感觉，对于没有 Python 知识的设计师来说，无法进行页面设计。此外，将呈现代码的生成与应用逻辑混合在一起会使两者都更难测试。
- en: 'Pretty much all web frameworks solve this problem by employing the template
    idiom. Since the bulk of the HTML is static, the question arises: Why keep it
    in the application code at all? With templates, we extract the HTML entirely into
    separate files. These then comprise HTML code, with the inclusion of some special
    placeholder and logic markup to allow dynamic elements to be inserted.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的Web框架都通过使用模板习语来解决这个问题。由于大部分HTML是静态的，问题就出现了：为什么还要将它保留在应用程序代码中呢？有了模板，我们可以将HTML完全提取到单独的文件中。然后这些文件包括HTML代码，包括一些特殊的占位符和逻辑标记，以允许动态元素被插入。
- en: 'Flask uses another Armin Ronacher creation, the *Jinja2* templating engine,
    for this task. Let''s adapt our application to use templates. In your project
    folder, create a folder called `templates`. In there, create three new text files,
    `base.html`, `index.html`, and `docstring.html`. Fill them out as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Flask使用了Armin Ronacher的另一个作品*Jinja2*模板引擎来完成这项任务。让我们来适应我们的应用程序来使用模板。在你的项目文件夹中，创建一个名为`templates`的文件夹。在里面，创建三个新的文本文件，`base.html`，`index.html`和`docstring.html`。填写它们如下：
- en: 'The `base.html` file will be like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`base.html`文件将是这样的：'
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `index.html` file will be like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`index.html`文件将是这样的：'
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `docstring.html` file will be like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`docstring.html`文件将是这样的：'
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add `render_template` to the `from flask import...` line at the top of `tinyflaskapp.py`,
    then modify your views to look like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tinyflaskapp.py`顶部的`from flask import...`行中添加`render_template`，然后修改你的视图如下：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code can be found in the `2-templates` folder of this chapter's source
    code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以在本章源代码的`2-templates`文件夹中找到。
- en: Notice how the views become much simpler, and the HTML is much more readable
    now? Instead of composing a return string by hand, our views simply call `render_template()`
    and return the result.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到视图变得简单得多，HTML现在更加可读了吗？我们的视图不再手动组合返回字符串，而是简单地调用`render_template()`并返回结果。
- en: So what does `render_template()` do? Well, it looks in the `templates` folder
    for the file supplied as the first argument, reads it, runs any processing instructions
    in the file, then returns the processed HTML as a string. Any keyword arguments
    supplied to `render_template()` are passed to the template and become available
    to its processing instructions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`render_template()`做了什么呢？它会在`templates`文件夹中查找作为第一个参数提供的文件，读取它，运行文件中的任何处理指令，然后将处理后的HTML作为字符串返回。提供给`render_template()`的任何关键字参数都会传递给模板，并在其处理指令中可用。
- en: Looking at the templates, we can see they are mostly HTML, but with some extra
    instructions for Flask, contained in `{{ }}` and `{% %}` tags. The `{{ }}` instructions
    simply substitute the value of the named variable into that point of the HTML.
    So for example the `{{ func_name }}` in `docstrings.html` substitutes the value
    of the `func_name` value we passed to `render_template()`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这些模板，我们可以看到它们大部分是HTML，但是包含一些额外的指令供Flask使用，包含在`{{ }}`和`{% %}`标签中。`{{ }}`指令简单地将命名变量的值替换到HTML的相应位置。所以例如`docstrings.html`中的`{{
    func_name }}`会将我们传递给`render_template()`的`func_name`的值替换进去。
- en: The `{% %}` instructions contain logic and flow control. For example, the `{%
    for func in funcs %}` instruction in `index.html` loops over values in `funcs`
    and repeats the contained HTML for each value.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% %}`指令包含逻辑和流程控制。例如，`index.html`中的`{% for func in funcs %}`指令循环遍历`funcs`中的值，并重复包含的HTML对于每个值。'
- en: Finally, you may have spotted that templates allow **inheritance**. This is
    provided by the `{% block %}` and `{% extends %}` instructions. In `base.html`
    we declare some shared boilerplate HTML, then in the `<body>` tag we just have
    a `{% block body %}` instruction. In `index.html` and `docstring.html`, we don't
    include the boilerplate HTML; instead we `extend` `base.html`, meaning that these
    templates will fill the `block` instructions declared in `base.html`. In both
    `index.html` and `docstring.html`, we declare a `body block`, the contents of
    which Flask inserts into the HTML in `base.html`, replacing the matching `{% block
    body %}` there. Inheritance allows the reuse of common code, and it can cascade
    through as many levels as needed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可能已经注意到模板允许**继承**。这是由`{% block %}`和`{% extends %}`指令提供的。在`base.html`中，我们声明了一些共享的样板HTML，然后在`<body>`标签中我们只有一个`{%
    block body %}`指令。在`index.html`和`docstring.html`中，我们不包括样板HTML；相反我们`extend`了`base.html`，这意味着这些模板将填充在`base.html`中声明的`block`指令。在`index.html`和`docstring.html`中，我们声明了一个`body
    block`，Flask将其内容插入到`base.html`中的HTML中，替换匹配的`{% block body %}`。继承允许共享代码的重用，并且可以级联到任意级别。
- en: There is a lot more functionality available in Jinja2 template instructions;
    check out the template designer documentation for a full list at [http://jinja.pocoo.org/docs/dev/templates/](http://jinja.pocoo.org/docs/dev/templates/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jinja2模板指令中还有更多的功能可用；在[http://jinja.pocoo.org/docs/dev/templates/](http://jinja.pocoo.org/docs/dev/templates)查看模板设计者文档以获取完整列表。
- en: Other templating engines
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他模板引擎
- en: Jinja2 is certainly not the only templating package in existence; you can find
    a maintained list of Python templating engines at [https://wiki.python.org/moin/Templating](https://wiki.python.org/moin/Templating).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2显然不是唯一存在的模板包；你可以在[https://wiki.python.org/moin/Templating](https://wiki.python.org/moin/Templating)找到一个维护的Python模板引擎列表。
- en: Like frameworks, different engines exist because of differing philosophies on
    what makes a good engine. Some feel that logic and presentation should be absolutely
    separate and that flow control and expressions should never be available in templates,
    providing only value substitution mechanisms. Others take the opposite tack and
    allow full Python expressions within template markup. Others, such as Jinja2,
    take a middleground approach. And some engines use different schemes altogether,
    such as XML-based templates or declaring logic via special HTML tag attributes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 像框架一样，存在不同的引擎是因为对于什么是一个好的引擎有不同的哲学观念。有些人认为逻辑和表现应该绝对分开，模板中不应该有流程控制和表达式，只提供值替换机制。其他人则采取相反的方式，允许在模板标记中使用完整的Python表达式。而其他一些引擎则采取中间路线的方式，比如Jinja2。还有一些引擎使用完全不同的方案，比如基于XML的模板或者通过特殊的HTML标签属性声明逻辑。
- en: There isn't a "right" approach; it's best to experiment with a few and see what
    works best for you. Where a framework has its own engine though, like Django,
    or is tightly integrated with an existing engine, like Flask, you'll usually have
    a smoother run sticking with what they supply, if you can.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 没有“正确”的方法；最好尝试一些方法，看看哪种对你最有效。然而，如果一个框架有自己的引擎，比如Django，或者与现有引擎紧密集成，比如Flask，通常最好使用它们提供的内容，如果可以的话，你通常会更顺利。
- en: Adding some style
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一些样式
- en: At the moment, our pages look a little plain. Let's add some style. We'll do
    this by including a static CSS document, but the same approach can be used to
    include images and other static content. The code for this section can be found
    in the `3-style` folder in this chapter's source code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的页面看起来有点单调。让我们添加一些样式。我们将通过包含一个静态CSS文档来实现这一点，但是相同的方法也可以用于包含图像和其他静态内容。本节的代码可以在本章源代码的`3-style`文件夹中找到。
- en: 'First create a new `static` folder in your project folder, and in there create
    a new text file called `style.css.` Save the following to it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在你的项目文件夹中创建一个新的`static`文件夹，在其中创建一个名为`style.css`的新文本文件。将以下内容保存到其中：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next update the `<head>` section of your `base.html` file to look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新你的`base.html`文件的`<head>`部分，使其看起来像这样：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note the third and forth lines in the preceding code—that is the `<link>` tag—should
    be a single line in your code. Try your web application in the browser again and
    notice that it looks (hopefully) a little more up to date.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面代码中的第三行和第四行——即`<link>`标签——应该在你的代码中是一行。再次在浏览器中尝试你的Web应用程序，注意它看起来（希望）更加现代化。
- en: Here we've just added a stylesheet to our boilerplate HTML in `base.html`, adding
    a `<link>` tag pointing to our `static/style.css` file. We use Flask's `url_for()`
    function for this. The `url_for()` function returns paths to named parts of our
    URL space. In this case, it's the special `static` folder, which by default Flask
    looks for in the root of our web application. Another thing we can use `url_for()`
    for is to get the paths of our view functions, for example, `url_for('index')`
    would return `/`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是在`base.html`中的基本HTML中添加了一个样式表，添加了一个指向我们的`static/style.css`文件的`<link>`标签。我们使用Flask的`url_for()`函数来实现这一点。`url_for()`函数返回我们URL空间中命名部分的路径。在这种情况下，它是特殊的`static`文件夹，默认情况下Flask会在我们的Web应用程序的根目录中查找。`url_for()`还可以用于获取我们视图函数的路径，例如，`url_for('index')`会返回`/`。
- en: You can put images and other resources in the `static` folder, and reference
    them in the same way.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将图像和其他资源放在`static`文件夹中，并以相同的方式引用它们。
- en: A note on security
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于安全性的说明
- en: If you're new to web programming, then I strongly recommend you read up on two
    common types of security flaw in web applications. Both are fairly easily avoided
    but can have serious consequences if not addressed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是新手网页编程，我强烈建议你了解网页应用程序中两种常见的安全漏洞。这两种漏洞都相当容易避免，但如果不加以解决，可能会产生严重后果。
- en: XSS
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XSS
- en: The first is **Cross-Site Scripting** (**XSS**). This is where an attacker injects
    malicious script code into a site's HTML, causing a user's browser to carry out
    operations in the security context of that site without the user's knowledge.
    A typical vector is user submitted info being redisplayed to users without proper
    sanitization or escaping.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是**跨站脚本**（**XSS**）。这是攻击者将恶意脚本代码注入到网站的HTML中，导致用户的浏览器在不知情的情况下以该网站的安全上下文执行操作。一个典型的向量是用户提交的信息在没有适当的净化或转义的情况下重新显示给用户。
- en: For example, one method is to trick users into visiting URLs containing carefully
    crafted `GET` parameters. As we saw in [Chapter 2](ch02.html "Chapter 2. HTTP
    and Working with the Web"), *HTTP and* *Working with the Web*, these parameters
    can be used by web servers to generate pages, and sometimes their content is included
    in the HTML of the response page itself. If the server is not careful to replace
    special characters in the URL parameters with their HTML escape codes when displayed,
    an attacker can put executable code, for example Javascript, into URL parameters
    and actually have it executed when that URL is visited. If they can trick a victim
    into visiting that URL, that code will be executed in the user's browser, enabling
    the attacker to potentially perform any action the user could.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个方法是诱使用户访问包含精心制作的`GET`参数的URL。正如我们在[第2章](ch02.html "第2章。HTTP和与Web的工作")中看到的，*HTTP和*
    *与Web的工作*，这些参数可以被Web服务器用来生成页面，有时它们的内容被包含在响应页面的HTML中。如果服务器在显示时不小心用HTML转义代码替换URL参数中的特殊字符，攻击者可以将可执行代码（例如Javascript）放入URL参数中，并在访问该URL时实际执行它。如果他们能够诱使受害者访问该URL，那么该代码将在用户的浏览器中执行，使攻击者有可能执行用户可以执行的任何操作。
- en: The basic XSS prevention is to ensure that any input received from outside the
    web application is escaped properly when returned to the client. Flask is very
    helpful in this regard since it activates Jinja2's auto-escaping feature by default,
    meaning that anything we render via template is automatically protected. Not all
    frameworks have this feature though, and some that do need it to be manually set.
    Also, this only applies in situations where your user-generated content can't
    include markup. In situations like a wiki that allows some markup in user-generated
    content, you need to take much greater care—see the source code download for this
    chapter in the `5-search` folder for an example of this. You should always make
    sure you check out your framework's documentation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的XSS预防措施是确保从Web应用程序外部接收的任何输入在返回给客户端时都得到适当的转义。Flask在这方面非常有帮助，因为它默认激活了Jinja2的自动转义功能，这意味着我们通过模板渲染的任何内容都会自动受到保护。然而，并非所有的框架都具有这个功能，有些框架需要手动设置。此外，这仅适用于用户生成的内容不能包含标记的情况。在允许用户生成内容中包含一些标记的维基等情况下，你需要更加小心——请参阅本章的`5-search`文件夹中的源代码下载以获取示例。你应该始终确保查看你的框架文档。
- en: CSRF
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CSRF
- en: The second form of attack is the **Cross-Site Request Forgery** (**CSRF**).
    In this attack, a site is tricked into carrying out actions in the security context
    of a user, without the user's knowledge or consent. Frequently this is initiated
    by an XSS attack that causes a user's browser to perform an operation on the target
    site while the user is logged in. It should be noted that this can affect sites
    even when a user isn't actively browsing them; sites often clear cookie authentication
    tokens only when a user explicitly logs out, and hence from the site and browser's
    point of view, any request coming from the browser even after the user has stopped
    browsing a site—if they haven't logged out—will be as if the user is still logged
    in.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种攻击形式是**跨站请求伪造**（**CSRF**）。在这种攻击中，网站被欺骗以在用户的安全上下文中执行操作，而用户并不知情或同意。这通常是由XSS攻击引发的，导致用户的浏览器在用户登录的情况下在目标站点上执行操作。需要注意的是，这可能会影响网站，即使用户并没有在主动浏览它们；网站通常只有在用户明确注销时才清除cookie身份验证令牌，因此从网站和浏览器的角度来看，即使用户停止浏览网站后来自浏览器的任何请求，如果他们没有注销，都将被视为用户仍然登录。
- en: One technique to help prevent CSRF attacks is to make potentially abusable operations,
    such as submitting forms, require a one-time nonce value that is only known to
    the server and the client. CRSF attacks often take the form of a pre-composed
    HTTP request, mimicking a user submitting a form or similar. However, if every
    time a server sends a form to a client it includes a different nonce value, then
    the attacker has no way of including this in the pre-composed request, and hence
    the attack attempt can be detected and rejected. This technique is less effective
    against XSS initiated attacks, and attacks where an attacker is eavesdropping
    the HTTP traffic of a browsing session. The former is difficult to completely
    protect against, and the best solution is to ensure XSS vulnerabilities are not
    present in the first place. The latter can be mitigated using HTTPS rather than
    HTTP. See the OWASP pages linked to below for further information.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 防止CSRF攻击的一种技术是使潜在可滥用的操作（例如提交表单）需要一个仅服务器和客户端知道的一次性令牌值。CRSF攻击通常采取预先组合的HTTP请求的形式，模仿用户提交表单或类似操作。然而，如果每次服务器向客户端发送一个表单时都包含一个不同的一次性令牌值，那么攻击者就无法在预先组合的请求中包含这个值，因此攻击尝试可以被检测并拒绝。这种技术对XSS发起的攻击和攻击者窃听浏览会话的HTTP流量的攻击效果较差。前者很难完全防范，最好的解决方案是确保首先不存在XSS漏洞。后者可以通过使用HTTPS而不是HTTP来减轻。有关更多信息，请参阅下面链接的OWASP页面。
- en: 'Different frameworks have different approaches to providing nonce-based CSRF
    protection. Flask doesn''t have this functionality built in, but it is very easy
    to add something, for example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的框架对提供基于一次性令牌的CSRF保护有不同的方法。Flask没有内置此功能，但很容易添加一些内容，例如：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then in templates with forms, just do the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在带有表单的模板中，只需执行以下操作：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is from the Flask site: [http://flask.pocoo.org/snippets/3/](http://flask.pocoo.org/snippets/3/).
    Although this contains some Flask functionality, we haven''t covered, including
    sessions and the `@app.before_request()` decorator, you just need to include the
    above code in your app, and make sure you include a `_` `csrf_token` hidden input
    in every form. An alternative approach is to use the Flask-WTF plugin that provides
    integration with the `WTForms` package, which has built-in CSRF protection.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自Flask网站的：[http://flask.pocoo.org/snippets/3/](http://flask.pocoo.org/snippets/3/)。虽然这包含了一些我们还没有涵盖的Flask功能，包括会话和`@app.before_request()`装饰器，你只需要在你的应用程序中包含上面的代码，并确保在每个表单中包含一个`_`
    `csrf_token`隐藏输入。另一种方法是使用Flask-WTF插件，它提供了与`WTForms`包的集成，该包具有内置的CSRF保护。
- en: Django on the other hand has built-in protection, though you need to enable
    and use it. Other frameworks vary. Always check your chosen framework's documentation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Django具有内置的保护，但您需要启用并使用它。其他框架各不相同。始终检查您选择的框架的文档。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is more information on XSS and CSRF on the Flask and Django sites:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于XSS和CSRF的更多信息，请参阅Flask和Django网站：
- en: '[http://flask.pocoo.org/docs/latest/security/](http://flask.pocoo.org/docs/latest/security/)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://flask.pocoo.org/docs/latest/security/](http://flask.pocoo.org/docs/latest/security/)'
- en: '[https://docs.djangoproject.com/en/1.7/topics/security/](https://docs.djangoproject.com/en/1.7/topics/security/)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.djangoproject.com/en/1.7/topics/security/](https://docs.djangoproject.com/en/1.7/topics/security/)'
- en: 'Also on the OWASP site, there is a repository of all sorts of computer security
    related information:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 同样在OWASP网站上，有一个包含各种与计算机安全相关信息的存储库：
- en: '[https://www.owasp.org/index.php/XSS](https://www.owasp.org/index.php/XSS)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.owasp.org/index.php/XSS](https://www.owasp.org/index.php/XSS)'
- en: '[https://www.owasp.org/index.php/CSRF](https://www.owasp.org/index.php/CSRF)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.owasp.org/index.php/CSRF](https://www.owasp.org/index.php/CSRF)'
- en: Finishing up with frameworks
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束框架
- en: That's as far as we're going to take our dip into Flask, here. There are some
    examples of further adaptations to our application in the downloadable source
    code of this chapter, notably form submission, accessing form values in the request,
    and sessions. The Flask tutorial covers many of these elements in some detail,
    and is well worth checking out [http://flask.pocoo.org/docs/0.10/tutorial/](http://flask.pocoo.org/docs/0.10/tutorial/).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在Flask中的涉足的尽头。在本章的可下载源代码中，有一些进一步适应我们应用程序的示例，特别是表单提交、访问请求中的表单值和会话。Flask教程详细介绍了其中许多元素，非常值得一看[http://flask.pocoo.org/docs/0.10/tutorial/](http://flask.pocoo.org/docs/0.10/tutorial/)。
- en: So that's a taste of what a very basic Python web application can look like.
    There are obviously as many ways to write the same app as there are frameworks
    though, so how do you choose a framework?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是一个非常基本的Python web应用程序的样子。显然，有很多种方式可以编写相同的应用程序，就像有很多框架一样，那么你该如何选择一个框架呢？
- en: Firstly, it helps to have a clear idea of what you're looking to achieve with
    your application. Do you require database interaction? If so, a more integrated
    solution like Django may be quicker to get started with. Will you need a web-based
    data entry or administration interface? Again if so, Django has this out of the
    box.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，明确你的应用程序的目标是有帮助的。你是否需要数据库交互？如果是的话，像Django这样的更集成的解决方案可能更快开始。你是否需要基于网络的数据输入或管理界面？同样，如果是的话，Django已经内置了这个功能。
- en: Next you can look at your environment. Are there already preferred packages
    in your organization for operations you might want to perform, such as database
    access or unit testing? If so, do any frameworks already use these? If not then
    a microframework might be a better option, plugging in your required packages.
    Do you have a preferred operating system or web server for hosting, and which
    frameworks support these? Does your hosting restrict you in terms of Python version,
    database technology, or similar? Also, if you have web designers, do you have
    time to get them up to speed on a complex templating language, or must it be kept
    simple?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你可以看看你的环境。你的组织中是否已经有了一些首选的包，用于你可能想要执行的操作，比如数据库访问或单元测试？如果有，是否有任何框架已经在使用这些？如果没有，那么微框架可能是一个更好的选择，插入你所需的包。你是否有首选的操作系统或网络服务器用于托管，哪些框架支持这些？你的托管是否在Python版本、数据库技术或类似方面限制了你？另外，如果你有网页设计师，你是否有时间让他们熟悉复杂的模板语言，还是必须保持简单？
- en: Answers to these questions can help you narrow down your choices. Then, researching
    the frameworks, asking people who are using them, and trying out a few likely
    looking ones will get you where you need to go.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案可以帮助你缩小选择范围。然后，研究这些框架，询问正在使用它们的人，并尝试一些看起来可能的选择，将会让你达到你需要去的地方。
- en: Having said that, for a general web application that needs some user form submission
    and database access, you can't really go wrong with Django. It really is "batteries
    included", its database model is elegant, and its out-of-the box database administration
    and data entry interface is very powerful and can be a huge timesaver. And for
    simpler applications such as APIs, Flask is also a great choice, coupled with
    SQLAlchemy if database access is needed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，对于一个需要用户表单提交和数据库访问的一般网络应用程序，Django是一个不错的选择。它真的是“电池已包含”，它的数据库模型很优雅，它的开箱即用的数据库管理和数据输入界面非常强大，可以节省大量时间。对于像API这样的简单应用程序，Flask也是一个很好的选择，如果需要数据库访问，可以与SQLAlchemy一起使用。
- en: As I mentioned before, there's no right answer, but there's a lot to be learned
    by exploring what's available and seeing the different approaches that the frameworks
    take.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，没有正确的答案，但通过探索现有的选择，看看框架采用的不同方法，可以学到很多东西。
- en: Of course, once we've got our web application, we need a way to host it. We're
    going to look at some options now.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦我们有了我们的网络应用程序，我们需要一种托管它的方式。我们现在将看一些选项。
- en: Hosting Python web applications
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管Python网络应用程序
- en: As we discussed at the beginning of this chapter, in order to run a Python web
    application, we need a web server to host it. There are many web servers in existence
    today, and you will very likely have heard of several. Popular examples are Apache,
    nginx (pronounced *engine-x*), lhttpd (pronounced *lighty*), and Microsoft's **Internet
    Information Services** (**IIS**).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头讨论的那样，为了运行Python网络应用程序，我们需要一个网络服务器来托管它。今天存在许多网络服务器，你很可能已经听说过几个。流行的例子有Apache、nginx（发音为*engine-x*）、lhttpd（发音为*lighty*）和微软的**Internet
    Information Services**（**IIS**）。
- en: There is a lot of terminology around web servers and various mechanisms they
    can use to invoke Python web applications. We're going to take a very brief tour
    of the history of web applications to help explain some of these concepts.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 关于网络服务器和它们可以使用的各种机制，有很多术语。我们将简要介绍一下网络应用程序的历史，以帮助解释其中一些概念。
- en: CGI
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CGI
- en: In the early days of the Web, web servers would mostly only be required to send
    clients HTML pages, or the occasional image file. As in the earlier figure of
    a HTTP request journey, these static resources would live on the hard disk of
    the server, and the web server's main task would be to accept socket connections
    from clients, map the URL of a request to a local file, and send the file back
    over the socket as an HTTP response.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web的早期，网络服务器主要只需要向客户端发送HTML页面，或偶尔的图像文件。就像之前的HTTP请求旅程图中一样，这些静态资源会存在于服务器的硬盘上，网络服务器的主要任务是接受来自客户端的套接字连接，将请求的URL映射到本地文件，并将文件作为HTTP响应通过套接字发送回去。
- en: However, with the rise of the need for dynamic content, web servers were given
    the ability to generate pages by invoking external programs and scripts, which
    we today call web applications. Web applications originally took the form of scripts
    or compiled executables that lived on disk next to the regular static content
    as part of the published web tree. The web server would be configured so that
    when a client requested these web application files, instead of just reading the
    file and returning it, the web server would launch a new operating system process
    and execute the file, returning the result as the requested HTML web page.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着对动态内容的需求的增加，网络服务器被赋予了通过调用外部程序和脚本来生成页面的能力，这就是我们今天所说的网络应用程序。网络应用程序最初采用脚本或编译后的可执行文件的形式，它们与常规静态内容一样存在于已发布的Web树的磁盘上。网络服务器将被配置，以便当客户端请求这些网络应用程序文件时，网络服务器不仅仅是读取文件并返回它，而是启动一个新的操作系统进程并执行文件，将结果作为请求的HTML网页返回。
- en: 'If we update our HTTP request''s journey from our earlier image, our request''s
    journey would now look something like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更新我们之前图像中的HTTP请求的旅程，我们的请求的旅程现在看起来会是这样的：
- en: '![CGI](graphics/6008OS_09_04.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![CGI](graphics/6008OS_09_04.jpg)'
- en: There obviously needs to be some kind of protocol for the web server and the
    web application to pass the HTTP request and the returned HTML page between them.
    The earliest mechanism for this was called the **Common Gateway Interface** (**CGI**).
    The web server would decompose the request into environment variables, which it
    would add to the environment of the handler program when it was invoked, and pass
    the body of the request, if there was one, to the program via its standard input.
    The program would then simply pipe the HTTP response it generated to its standard
    output, which the web server would catch and return to the client.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Web服务器和Web应用程序之间需要一种协议来传递它们之间的HTTP请求和返回的HTML页面。最早的机制被称为**通用网关接口**（**CGI**）。Web服务器会将请求分解为环境变量，并在调用处理程序时将其添加到环境中，并通过标准输入将请求的主体（如果有的话）传递给程序。然后，程序会简单地将其生成的HTTP响应传输到其标准输出，Web服务器会捕获并返回给客户端。
- en: Due to performance issues however, CGI is slowly falling out of favor these
    days, and writing a Python CGI application is something that should be avoided
    if at all possible.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于性能问题，CGI在今天逐渐不受青睐，如果可能的话，应该避免编写Python CGI应用程序。
- en: Recycling for a better world
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为了更美好的世界而回收利用
- en: CGI works, but the major drawback is that a new process has to be launched for
    each request. Launching processes is expensive in terms of operating system resources,
    and so this approach is very inefficient. Alternatives have been developed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: CGI可以工作，但主要缺点是必须为每个请求启动一个新进程。从操作系统资源的角度来看，启动进程是昂贵的，因此这种方法非常低效。已经开发出了替代方案。
- en: Two approaches became common. The first was to make web servers launch and maintain
    multiple processes at startup, ready to accept new connections— a technique known
    as **pre-forking**. With this technique, there is still a one-process-per- client
    relationship, but the processes are already created when a new client connects,
    improving response time. Also the processes can be reused instead of being re-created
    anew with each connection.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法变得常见。第一种是使Web服务器在启动时启动和维护多个进程，准备接受新连接——这种技术称为**预分叉**。使用这种技术，仍然存在一对一的进程-客户端关系，但是当新客户端连接时，进程已经创建，从而提高了响应时间。此外，可以重复使用进程，而不是在每次连接时重新创建。
- en: Alongside this, web servers were made extensible and bindings were created to
    different languages so that the web application could be embedded within the web
    server processes themselves. The most commonly seen examples of these are the
    various language modules for the Apache web server for languages such as PHP and
    Perl.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Web服务器被制作成可扩展的，并且创建了与不同语言的绑定，以便Web应用程序可以嵌入到Web服务器进程中。最常见的例子是Apache Web服务器的各种语言模块，用于诸如PHP和Perl之类的语言。
- en: 'With pre-forking and web application embedding, our request''s journey might
    look like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过预分叉和Web应用程序嵌入，我们的请求的旅程可能如下所示：
- en: '![Recycling for a better world](graphics/6008OS_09_05.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![为了更美好的世界而回收利用](graphics/6008OS_09_05.jpg)'
- en: Here, the request is transformed by the language binding code, and the request
    our web application sees depends on the design of the binding itself. This approach
    to managing a web application works fairly well for general web loads, and remains
    a popular way to host web applications today. Modern browsers usually also offer
    multithreaded variants, where each process can handle requests using multiple
    threads, one for each client connection, further improving efficiency.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，请求由语言绑定代码转换，我们的Web应用程序看到的请求取决于绑定本身的设计。这种管理Web应用程序的方法对于一般的Web负载效果相当不错，今天仍然是托管Web应用程序的一种流行方式。现代浏览器通常也提供多线程变体，其中每个进程可以使用多个线程处理请求，每个客户端连接使用一个线程，进一步提高效率。
- en: 'The second approach to solving CGI''s performance problems was to hand off
    the management of the web application processes completely to a separate system.
    The separate system would pre-fork and maintain a pool of processes running the
    web application code. Like web server pre-forking, these could be reused for each
    client connection. New protocols were developed to allow the web server to pass
    requests to the external processes, the most notable being FastCGI and SCGI. In
    this situation, our journey would be:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 解决CGI性能问题的第二种方法是将Web应用程序进程的管理完全交给一个单独的系统。这个单独的系统会预先分叉并维护运行Web应用程序代码的进程池。与Web服务器预分叉一样，这些进程可以为每个客户端连接重复使用。开发了新的协议，允许Web服务器将请求传递给外部进程，其中最值得注意的是FastCGI和SCGI。在这种情况下，我们的旅程将是：
- en: '![Recycling for a better world](graphics/6008OS_09_06.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![为了更美好的世界而回收利用](graphics/6008OS_09_06.jpg)'
- en: Again, how the request is transformed and presented to the web application depends
    on the protocol used.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，请求如何转换并呈现给Web应用程序取决于所使用的协议。
- en: Although in practice this is somewhat more complex to configure, it has advantages
    over embedding a copy of the application code in pre-forked web server processes.
    Primarily, the web application process pool can be managed independently of the
    web server process pool, allowing more efficient tuning of both.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在实践中这可能更复杂一些，但它比在预分叉的Web服务器进程中嵌入应用程序代码具有优势。主要是，Web应用程序进程池可以独立于Web服务器进程池进行管理，从而更有效地调整两者。
- en: Event-driven servers
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件驱动服务器
- en: Web client numbers continued to grow though, and the need arose for servers
    to be able to handle very large numbers of simultaneous client connections, numbers
    that proved problematic using the multiprocessing approaches. This spurred the
    development of event-driven web servers, such as *nginx* and *lighttpd*, which
    can handle many thousands of simultaneous connections in a single process. These
    servers also leverage preforking, maintaining a number of event-driven processes
    in line with the number of CPU cores in a machine, and hence making sure the server's
    resources are fully utilized while also receiving the benefits of the event-driven
    architecture.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Web客户端数量继续增长，服务器需要能够处理非常大量的同时客户端连接，这些数字使用多进程方法证明是有问题的。这促使了事件驱动Web服务器的发展，例如*nginx*和*lighttpd*，它们可以在单个进程中处理许多数千个同时连接。这些服务器还利用预分叉，保持与机器中CPU核心数量一致的一些事件驱动进程，从而确保服务器的资源得到充分利用，同时也获得事件驱动架构的好处。
- en: WSGI
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WSGI
- en: 'Python web applications were originally written against these early integration
    protocols: CGI, FastCGI, and a now mostly defunct `mod_python` Apache module.
    This proved troublesome though since Python web applications were tied to the
    protocol or server they had been written for. Moving them to a different server
    or protocol required some reworking of the application code.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Python Web应用程序最初是针对这些早期集成协议编写的：CGI，FastCGI和现在基本上已经废弃的`mod_python` Apache模块。然而，这证明是麻烦的，因为Python
    Web应用程序与它们编写的协议或服务器绑定在一起。将它们移动到不同的服务器或协议需要对应用程序代码进行一些重新工作。
- en: This problem was solved with PEP 333, which defined the **Web Services Gateway
    Interface** (**WSGI**) protocol. This established a common calling convention
    for web servers to invoke web application code, similar to CGI. When web servers
    and web applications both support WSGI, servers and applications can be exchanged
    with ease. WSGI support has been added to many modern web servers and is nowadays
    the main method of hosting Python applications on the Web. It was updated for
    Python 3 in PEP 3333.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题通过PEP 333得到解决，它定义了**Web服务网关接口**（**WSGI**）协议。这为Web服务器调用Web应用程序代码建立了一个类似于CGI的通用调用约定。当Web服务器和Web应用程序都支持WSGI时，服务器和应用程序可以轻松交换。WSGI支持已添加到许多现代Web服务器中，现在是在Web上托管Python应用程序的主要方法。它在PEP
    3333中更新为Python 3。
- en: Many of the web frameworks we discussed earlier support WSGI behind the scenes
    to communicate with their hosting web servers, Flask and Django included. This
    is another big benefit to using such a framework— you get full WSGI compatibility
    for free.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的许多Web框架在幕后支持WSGI与其托管Web服务器进行通信，包括Flask和Django。这是使用这样的框架的另一个重要好处-您可以免费获得完整的WSGI兼容性。
- en: There are two ways a web server can use WSGI to host a web application. Firstly
    it can directly support hosting WSGI applications. Pure Python servers such as
    Gunicorn follow this approach, and they make serving Python web applications very
    easy. This is becoming a very popular way to host Python web applications.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器可以使用WSGI托管Web应用程序的两种方法。首先，它可以直接支持托管WSGI应用程序。纯Python服务器，如Gunicorn，遵循这种方法，它们使得提供Python
    Web应用程序非常容易。这正变得越来越受欢迎。
- en: The second approach is for a non-Python server to use an adapter plugin, such
    as Apache's `mod_wsgi`, or the `mod_wsgi` plugin for nginx.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是非Python服务器使用适配器插件，例如Apache的`mod_wsgi`，或者nginx的`mod_wsgi`插件。
- en: The exception to the WSGI revolution is event-driven servers. WSGI doesn't include
    a mechanism to allow a web application to pass control back to the calling process,
    hence there is no benefit to using an event-driven server with a blocking-IO style
    WSGI web application because as soon as the application blocks, for example, for
    database access, it will block the whole web server process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI革命的例外是事件驱动服务器。WSGI不包括允许Web应用程序将控制权传递回调用进程的机制，因此对于使用阻塞IO风格WSGI Web应用程序来说，使用事件驱动服务器没有好处，因为一旦应用程序阻塞，例如，对于数据库访问，它将阻塞整个Web服务器进程。
- en: Hence, most event-driven frameworks include a production-ready web server—making
    the web application itself event-driven and embedding it in the web server process
    is really the only way to host it. To host web applications with these frameworks,
    check out the framework's documentation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，大多数事件驱动框架包括一个生产就绪的Web服务器-使Web应用程序本身成为事件驱动，并将其嵌入到Web服务器进程中是托管它的唯一方法。要使用这些框架托管Web应用程序，请查看框架的文档。
- en: Hosting in practice
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际托管
- en: So how does this all work in practice? Well as we saw with Flask, many frameworks
    come with their own built-in development web servers. However, these are not recommended
    for use in a production environment as they're generally not designed to be used
    where security and scalability are important.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这在实践中是如何工作的呢？就像我们在Flask中看到的那样，许多框架都配备了自己内置的开发Web服务器。然而，这些不建议在生产环境中使用，因为它们通常不是为了在重视安全性和可伸缩性的环境中使用而设计的。
- en: 'Currently, probably the quickest way to host a Python web application with
    a production quality server is with the Gunicorn server. Using our Flask application
    from earlier, we can get it up and running using just a few steps. First we install
    Gunicorn:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，使用Gunicorn服务器可能是托管Python Web应用程序的生产质量服务器的最快方法。使用我们之前的Flask应用程序，我们可以通过几个步骤将其启动和运行。首先我们安装Gunicorn：
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next we need to slightly modify our Flask app so that it''s use of `__builtins__`
    works correctly under Gunicorn. In your `tinyflaskapp.py` file, find the line:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要稍微修改我们的Flask应用程序，以便在Gunicorn下正确使用`__builtins__`。在您的`tinyflaskapp.py`文件中，找到以下行：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Change it to:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can run Gunicorn. From within your Flask application project folder,
    run the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行Gunicorn。在Flask应用程序项目文件夹中，运行以下命令：
- en: '[PRE14]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will launch the Gunicorn web server, listening on port 5000 on all available
    interfaces and serving our Flask application. If we now visit it in a web browser
    via `http://127.0.0.1:5000`, we should see our documentation index page. There
    are instructions to daemonize Gunicorn, so that it runs in the background and
    starts and stops automatically with the system, available in the documentation
    pages at [http://gunicorn-docs.readthedocs.org/en/latest/deploy.html#monitoring](http://gunicorn-docs.readthedocs.org/en/latest/deploy.html#monitoring).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动Gunicorn Web服务器，在所有可用接口上监听端口5000，并为我们的Flask应用提供服务。如果我们现在通过`http://127.0.0.1:5000`在Web浏览器中访问它，我们应该看到我们的文档索引页面。有关如何使Gunicorn成为守护进程的说明，以便它在后台运行，并且随系统自动启动和停止，可以在文档页面上找到，网址为[http://gunicorn-docs.readthedocs.org/en/latest/deploy.html#monitoring](http://gunicorn-docs.readthedocs.org/en/latest/deploy.html#monitoring)。
- en: Gunicorn uses the pre-fork process model described earlier. You can set the
    number of processes (Gunicorn calls them workers) using the `-w` command line
    option. The 'Design' section of the documentation contains details on determining
    the best number of workers to use, though a good place to start is `(2 x $num_cores)
    + 1`, where `$num_cores` is the number of CPU cores available to Gunicorn.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Gunicorn使用了之前描述的预分叉进程模型。您可以使用`-w`命令行选项设置进程数（Gunicorn称它们为工作进程）。文档的“设计”部分包含有关确定要使用的最佳工作进程数量的详细信息，尽管一个好的起点是`(2
    x $num_cores) + 1`，其中`$num_cores`是可供Gunicorn使用的CPU核心数量。
- en: 'Gunicorn offers two standard worker types: sync and async. The sync type provides
    strictly one-worker-per-client-connection behavior, the async type uses eventlet
    (see [Chapter 8](ch08.html "Chapter 8. Client and Server Applications"), *Client
    and Server Applications*, for details and installation instructions for this library)
    to provide an event-based worker, which can handle multiple connections. The sync
    type is only recommended if you are using Gunicorn behind a reverse proxy (see
    below), as using the sync type to serve directly to the Internet leaves your application
    vulnerable to Denial of Service attacks (see the Design section of the documentation
    for more details). If you are not using a reverse proxy, the async type should
    be used instead. The worker type is set on the command line using the `-k` option.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Gunicorn提供了两种标准的工作类型：同步和异步。同步类型提供严格的每个客户端连接一个工作进程的行为，异步类型使用eventlet（有关此库的详细信息和安装说明，请参见[第8章](ch08.html
    "第8章。客户端和服务器应用程序")，“客户端和服务器应用程序”）来提供基于事件的工作进程，可以处理多个连接。只有在使用反向代理时，才建议使用同步类型，因为使用同步类型直接提供给互联网会使您的应用程序容易受到拒绝服务攻击的影响（有关更多详细信息，请参见文档的设计部分）。如果不使用反向代理，则应改用异步类型。工作类型是使用`-k`选项在命令行上设置的。
- en: One effective way to improve performance and scale further is to employ a fast,
    event-driven web server, such as nginx, as a **reverse proxy** in front of your
    Gunicorn instance. A reverse proxy acts as a first line server for incoming web
    requests. It directly responds to any requests it can determine are erroneous,
    and can also be configured to serve static content in place of our Gunicorn instance.
    However, it is also configured to forward any requests that do require dynamic
    content to our Gunicorn instance so our Python web application can handle them.
    In this way, we get the performance benefits of nginx to deal with the bulk of
    our web traffic, and Gunicorn and our web application can focus on delivering
    just the dynamic pages.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步提高性能并扩展的一种有效方法是使用快速的事件驱动Web服务器，例如nginx，作为我们Gunicorn实例前面的**反向代理**。反向代理充当传入Web请求的第一行服务器。它直接响应任何它确定是错误的请求，并且还可以配置为提供静态内容以替代我们的Gunicorn实例。但是，它还配置为将需要动态内容的任何请求转发到我们的Gunicorn实例，以便我们的Python
    Web应用程序可以处理它们。通过这种方式，我们可以获得nginx处理大部分Web流量的性能优势，而Gunicorn和我们的Web应用程序可以专注于提供动态页面。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Detailed instructions on configuring this reverse proxy configuration can be
    found on the Gunicorn pages at [http://gunicorn-docs.readthedocs.org/en/latest/deploy.html#nginx-configuration](http://gunicorn-docs.readthedocs.org/en/latest/deploy.html#nginx-configuration).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有关配置此反向代理配置的详细说明可以在Gunicorn页面上找到，网址为[http://gunicorn-docs.readthedocs.org/en/latest/deploy.html#nginx-configuration](http://gunicorn-docs.readthedocs.org/en/latest/deploy.html#nginx-configuration)。
- en: 'If you''re more comfortable with Apache, then another effective hosting method
    is Apache with the `mod_wsgi` module. This takes a little more configuring, and
    full instructions can be found at: [https://code.google.com/p/modwsgi/](https://code.google.com/p/modwsgi/).
    `mod_wsgi` defaults to running applications in embedded mode, where the web application
    is hosted in each Apache process, and which results in a setup like the preceding
    pre-forking example. Alternatively it provides a daemon mode, where `mod_wsgi`
    manages a pool of processes external to Apache, similar to the earlier FastCGI
    example. Daemon mode is in fact recommended for stability and memory performance.
    See the `mod_wsgi` quick configuration documentation for instructions on this
    configuration, it can be found at: [https://code.google.com/p/modwsgi/wiki/QuickConfigurationGuide](https://code.google.com/p/modwsgi/wiki/QuickConfigurationGuide).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用Apache，那么另一种有效的托管方法是使用带有`mod_wsgi`模块的Apache。这需要一些更多的配置，完整的说明可以在以下网址找到：[https://code.google.com/p/modwsgi/](https://code.google.com/p/modwsgi/)。`mod_wsgi`默认在嵌入模式下运行应用程序，其中Web应用程序托管在每个Apache进程中，这导致了类似于前面的预分叉示例的设置。或者它提供了一个守护程序模式，其中`mod_wsgi`管理一个外部于Apache的进程池，类似于之前的FastCGI示例。实际上，守护程序模式是出于稳定性和内存性能的考虑而推荐的。有关此配置的说明，请参阅`mod_wsgi`快速配置文档，网址为：[https://code.google.com/p/modwsgi/wiki/QuickConfigurationGuide](https://code.google.com/p/modwsgi/wiki/QuickConfigurationGuide)。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've taken a whistle-stop tour of putting Python applications on the Web. We
    got an overview of web application architectures and their relationship to web
    servers. We looked at the utility of Python web frameworks, noting how they give
    us tools and structure to write better web applications more quickly, and help
    us integrate our applications with web servers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经快速浏览了将Python应用程序放在Web上的过程。我们概述了Web应用程序架构及其与Web服务器的关系。我们看了看Python Web框架的实用性，注意到它们为我们提供了工具和结构，可以更快地编写更好的Web应用程序，并帮助我们将我们的应用程序与Web服务器集成起来。
- en: We wrote a tiny application in the Flask web framework, we saw how it can help
    us elegantly manage our URL space, and how templating engines can help us cleanly
    manage the seperation of application logic and HTML. We also highlighted a couple
    of common potential security vulnerabilities— XSS and CSRF— and looked at some
    basic mitigation techniques.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Flask Web框架中编写了一个小应用程序，看到了它如何帮助我们优雅地管理我们的URL空间，以及模板引擎如何帮助我们清晰地管理应用逻辑和HTML的分离。我们还强调了一些常见的潜在安全漏洞——XSS和CSRF——并介绍了一些基本的缓解技术。
- en: Finally, we discussed web hosting architectures and the various methods that
    can be used to deploy Python web applications to the Web. In particular, WSGI
    is the standard protocol of web server/web application interaction, and Gunicorn
    can be used for rapid deployment and scaled with an nginx reverse proxy. Apache
    with mod_wsgi is also an effective hosting approach.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了Web托管架构以及可以用于将Python Web应用程序部署到Web的各种方法。特别是，WSGI是Web服务器/ Web应用程序交互的标准协议，Gunicorn可用于快速部署，并与nginx反向代理一起扩展。Apache与mod_wsgi也是一种有效的托管方法。
- en: We've covered a lot of ground in this book, and there's still plenty more exploring
    to be done. We hope this book has given you a taste of what's possible and an
    appetite for discovering more, and that this is just the start of your adventures
    in network programming with Python.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们涵盖了很多内容，还有很多探索工作要做。我们希望这本书让你对可能性有所了解，并且渴望发现更多，希望这只是你在使用Python进行网络编程冒险的开始。
