- en: Let Us Begin Our Automation Journey
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们开始我们的自动化之旅
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Creating a virtual environment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建虚拟环境
- en: Installing third-party packages
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装第三方包
- en: Creating strings with formatted values
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建带有格式化值的字符串
- en: Manipulating strings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作字符串
- en: Extracting data from structured strings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从结构化字符串中提取数据
- en: Using a third-party tool—parse
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用第三方工具—parse
- en: Introducing regular expressions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍正则表达式
- en: Going deeper into regular expressions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解正则表达式
- en: Adding command-line arguments
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加命令行参数
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The objective of this chapter is to lay down some of the basic techniques that
    will be useful through this book. The main idea is to be able to create a good
    Python environment to run the automation tasks that will follow, and be able to
    parse text inputs into structured data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是介绍一些基本技术，这些技术将在整本书中都很有用。主要思想是能够创建一个良好的Python环境来运行接下来的自动化任务，并能够将文本输入解析为结构化数据。
- en: Python has a good amount of tools installed by default, but it also makes it
    easy to install third-party tools that can simplify common operations when processing
    texts. In this chapter, we'll see how to import modules from external sources
    and use them to leverage the full potential of Python.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python默认安装了大量工具，但也很容易安装第三方工具，这些工具可以简化处理文本时的常见操作。在本章中，我们将看到如何从外部来源导入模块并使用它们来充分发挥Python的潜力。
- en: The ability to structure input data is critical in any automation task. Most
    of the data that we will process in this book will come from unformatted sources
    such as web pages or text files. As the old computer adage says, *garbage in,
    garbage out*, making the sanitizing of inputs a very important task.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何自动化任务中，结构化输入数据的能力至关重要。本书中大部分将处理的数据来自未格式化的来源，如网页或文本文件。正如古老的计算机格言所说，*垃圾进，垃圾出*，因此对输入进行消毒非常重要。
- en: Creating a virtual environment
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建虚拟环境
- en: As a first step when working with Python, it is a good practice to explicitly define the
    working environment. This helps with detaching from the operative system interpreter
    and environment, and properly defining the dependencies that will be used. Not
    doing so tends to generate chaotic scenarios. Remember, *explicit is better than
    implicit!*
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Python时的第一步是明确定义工作环境。这有助于脱离操作系统解释器和环境，并正确定义将要使用的依赖关系。不这样做往往会产生混乱的情况。记住，*显式优于隐式！*
- en: 'This is especially important in two scenarios:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这在两种情况下尤为重要：
- en: When dealing with multiple projects on the same computer, as they can have different
    dependencies that clash at some point. For example, two versions of the same module
    cannot be installed in the same environment.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一台计算机上处理多个项目时，它们可能具有在某些时候会发生冲突的不同依赖关系。例如，不能在同一环境中安装同一模块的两个版本。
- en: When working on a project that will be used on a different computer, for example,
    developing some code in a personal laptop that will ultimately run in a remote
    server.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发将最终在远程服务器上运行的个人笔记本电脑上开发一些代码等情况下，需要在不同计算机上使用的项目上工作。
- en: A common joke among developers is responding to a bug with *it runs on my machine*, meaning
    that it appears to work on their laptop, but not on the production servers. Although
    a huge number of factors can produce this error, a good practice is to produce
    an automatically replicable environment, reducing uncertainty over what dependencies
    are really being used.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员之间的一个常见笑话是对错误的回应是*它在我的机器上运行*，意思是它似乎在他们的笔记本电脑上工作，但在生产服务器上却不工作。尽管有大量因素可能导致此错误，但一个好的做法是创建一个可以自动复制的环境，减少对实际使用的依赖关系的不确定性。
- en: This is easy to achieve using the `virtualenv` module, which sets up a virtual
    environment, so none of the installed dependencies will be shared with the Python
    version installed on the machine.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`virtualenv`模块很容易实现这一点，它可以设置一个虚拟环境，因此不会与计算机上安装的Python版本共享任何已安装的依赖项。
- en: In Python3, the `virtualenv` tool is installed automatically, which was not
    the case in previous versions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python3中，`virtualenv`工具会自动安装，而在以前的版本中并非如此。
- en: Getting ready
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To create a new virtual environment, do the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的虚拟环境，请执行以下操作：
- en: Go to the main directory that contains the project.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到包含项目的主目录。
- en: 'Type the following command:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This creates a subdirectory called `.venv` that contains the virtual environment.The
    directory containing the virtual environment can be located anywhere. Keeping
    it on the same root keeps it handy, and adding a dot in front of it avoids it
    being displayed when running `ls` or other commands.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`.venv`的子目录，其中包含虚拟环境。包含虚拟环境的目录可以位于任何位置。将其保留在相同的根目录下会很方便，并在其前面加上一个点可以避免在运行`ls`或其他命令时显示它。
- en: 'Before activating the virtual environment, check the version installed in `pip`.
    This is different depending on your operative system, for example, 9.0.3 for MacOS
    High Sierra 10.13.4\. It will be upgraded later. Also check the referenced Python
    interpreter, which will be the main operating system one:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在激活虚拟环境之前，检查`pip`中安装的版本。这取决于您的操作系统，例如，MacOS High Sierra 10.13.4的版本为9.0.3。稍后将对其进行升级。还要检查引用的Python解释器，这将是主要操作系统的解释器：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, your virtual environment is ready to go.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的虚拟环境已准备就绪。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Activate the virtual environment by running this:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令激活虚拟环境：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You'll notice that the prompt will display `(.venv)`, showing that the virtual
    environment is active.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到提示会显示`(.venv)`，表示虚拟环境已激活。
- en: 'Notice that the Python interpreter used is the one inside the virtual environment,
    and not the general operative system one from step 3 of *Getting ready*. Checking
    the location within a virtual environment:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，所使用的Python解释器是虚拟环境中的解释器，而不是*准备就绪*中第3步中的一般操作系统解释器。检查虚拟环境中的位置：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Upgrade the version of `pip` and check the version:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 升级`pip`的版本并检查版本：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Get out of the environment and run `pip` to check the version, which will return
    the previous environment. Check the `pip` version and the Python interpreter to
    show the ones before activating the virtual environment ones, as shown in step
    3 of the *Getting ready* section. Note that they are different pip versions!
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出环境并运行`pip`来检查版本，这将返回之前的环境。检查`pip`版本和Python解释器以显示激活虚拟环境之前的版本，如*准备就绪*部分的第3步所示。请注意，它们是不同的pip版本！
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Notice that inside the virtual environment you can use `python` instead of `python3`,
    although `python3` is available as well. This will use the Python interpreter
    defined in the environment.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在虚拟环境中，您可以使用`python`而不是`python3`，尽管`python3`也可用。这将使用环境中定义的Python解释器。
- en: In some systems like Linux, it's possible that you need to use `python3.7` instead
    of `python3`. Verify that the Python interpreter you're using is 3.7 or higher.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些像Linux这样的系统中，可能需要使用`python3.7`而不是`python3`。验证您正在使用的Python解释器是否为3.7或更高版本。
- en: Inside the virtual environment, step 3 of the *How to do it...* section installs
    the most recent version of `pip`, without affecting the external installation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟环境中，*如何做...*部分的第3步安装了最新版本的`pip`，而不会影响外部安装。
- en: The virtual environment contains all the Python data in the `.venv` directory,
    and the `activate` script points all the environment variables there. The best
    thing about it is that it can be deleted and recreated very easily, removing the
    fear of experimenting in a self-contained sandbox.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境包含`.venv`目录中的所有Python数据，而`activate`脚本指向所有环境变量。最好的是，它可以很容易地被删除和重新创建，消除了在一个封闭的沙盒中进行实验的恐惧。
- en: Remember that the directory name is displayed in the prompt. If you need to
    differentiate the environment, use a descriptive directory name, such as `.my_automate_recipe`, or
    use the `--prompt` option.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，目录名称显示在提示符中。如果需要区分环境，请使用描述性目录名称，例如`.my_automate_recipe`，或使用`--prompt`选项。
- en: There's more...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'To remove a virtual environment, deactivate it and remove the directory:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除虚拟环境，请停用它并删除目录：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `venv` module has more options, which can be shown with the `-h` flag:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`venv`模块有更多选项，可以使用`-h`标志显示：'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A convenient way of dealing with virtual environments, especially if you often have
    to swap between them, is using the  `virtualenvwrapper` module:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 处理虚拟环境的一种便捷方式，特别是如果您经常需要在它们之间切换，就是使用`virtualenvwrapper`模块：
- en: 'To install it, run this:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装它，请运行以下命令：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, add the following variables to your sheet startup script, these normally
    being `.bashrc` or `.bash_profile`. The virtual environments will be installed
    under the `WORKON_HOME` directory instead of the same directory as the project,
    as shown previously:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下变量添加到您的启动脚本中，通常是`.bashrc`或`.bash_profile`。虚拟环境将安装在`WORKON_HOME`目录下，而不是与项目相同的目录下，如前面所示：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Sourcing the startup script or opening a new Terminal will allow you to create
    new virtual environments:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行启动脚本或打开新的终端将允许您创建新的虚拟环境：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For more information, check the documentation of `virtualenvwrapper` at: [https://virtualenvwrapper.readthedocs.io/en/latest/index.html](https://virtualenvwrapper.readthedocs.io/en/latest/index.html).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请查看`virtualenvwrapper`的文档：[https://virtualenvwrapper.readthedocs.io/en/latest/index.html](https://virtualenvwrapper.readthedocs.io/en/latest/index.html)。
- en: Hitting the *Tab* key after `workon` autocompletes with the available environments.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workon`后按下*Tab*键，将自动完成可用的环境。
- en: See also
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Installing third-party packages* recipe
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安装第三方软件包*的步骤'
- en: The *Using a third-party tool—parse* recipe
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用第三方工具—parse*的步骤'
- en: Installing third-party packages
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装第三方软件包
- en: One of the strongest capabilities of Python is the ability to use an impressive
    catalog of third-party packages that cover an amazing amount of ground in different
    areas, from modules specialized in performing numerical operations, machine learning,
    and network communications, to command-line convenience tools, database access,
    image processing, and much more!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Python最强大的功能之一是能够使用一个令人印象深刻的第三方软件包目录，涵盖了不同领域的大量内容，从专门执行数值操作、机器学习和网络通信的模块，到命令行便利工具、数据库访问、图像处理等等！
- en: Most of them are available on the official Python Package Index ([https://pypi.org/](https://pypi.org/)),
    which has more than 130,000 packages ready to use. In this book, we'll install
    some of them, and in general spending a little time researching external tools
    when trying to solve a problem is time well spent. It's very likely that someone
    else has created a tool that solves all, or at least part, of the problem.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 其中大多数都可以在官方Python软件包索引（[https://pypi.org/](https://pypi.org/)）上找到，该索引拥有超过130,000个准备好使用的软件包。在本书中，我们将安装其中一些软件包，并且通常花一点时间研究外部工具来解决问题是值得的。很可能有人已经创建了一个解决问题的工具。
- en: As important as finding and installing a package is keeping track of which packages
    are being used. This greatly helps with **replicability**, meaning the ability
    to start the whole environment from scratch in any situation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与找到并安装软件包一样重要的是跟踪使用了哪些软件包。这对于**可复制性**非常有帮助，意味着能够在任何情况下从头开始启动整个环境。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The starting point is to find a package that will be of use in our project.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 起点是找到一个在我们的项目中有用的软件包。
- en: A great one is `requests`, a module that deals with HTTP requests and is known
    for its easy and intuitive interface, as well as its great documentation. Take
    a look at the documentation, which can be found here: [http://docs.python-requests.org/en/master/](http://docs.python-requests.org/en/master/).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很棒的模块是`requests`，它处理HTTP请求并以其简单直观的界面以及出色的文档而闻名。查看文档，网址为：[http://docs.python-requests.org/en/master/](http://docs.python-requests.org/en/master)。
- en: We'll use `requests` throughout this book when dealing with HTTP connections.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中处理HTTP连接时，我们将使用`requests`。
- en: The next step will be to choose the version to use. In this case, the latest
    (2.18.4, at the time of writing) will be perfect. If the version of the module
    is not specified, by default, it will install the latest version, which can lead
    to inconsistencies in different environments.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是选择要使用的版本。在这种情况下，最新版本（在撰写时为2.18.4）将是完美的。如果未指定模块的版本，默认情况下将安装最新版本，这可能会导致不同环境中的不一致性。
- en: We'll also use the great `delorean` module for time handling (version 1.0.0 [http://delorean.readthedocs.io/en/latest/](http://delorean.readthedocs.io/en/latest/)).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用很棒的`delorean`模块来处理时间（版本1.0.0 [http://delorean.readthedocs.io/en/latest/](http://delorean.readthedocs.io/en/latest/)）。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a `requirements.txt` file in our main directory, which will specify
    all the requirements for our project. Let''s start with `delorean` and `requests`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的主目录中创建一个`requirements.txt`文件，其中将指定项目的所有要求。让我们从`delorean`和`requests`开始：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Install all the requirements with the `pip` command:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pip`命令安装所有要求：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can now use both modules when using the virtual environment:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在使用虚拟环境时可以同时使用这两个模块：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `requirements.txt` file specifies the module and version, and `pip` performs
    a search on [pypi.org](http://pypi.org).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements.txt`文件指定了模块和版本，`pip`在[pypi.org](http://pypi.org)上进行搜索。'
- en: 'Note that creating a new virtual environment from scratch and running the following will
    completely recreate your environment, which makes replicability very straightforward:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从头开始创建一个新的虚拟环境并运行以下操作将完全重新创建您的环境，这使得可复制性非常简单：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that step 2 of the *How to do it...* section automatically installs other
    modules that are dependencies, such as `urllib3`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*如何做...*部分的第2步会自动安装其他依赖模块，例如`urllib3`。
- en: There's more...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If any of the modules need to be changed to a different version because a new
    version is available, change it using requirements and run the `install` command
    again:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要将任何模块更改为不同的版本，因为有新版本可用，可以使用要求进行更改，然后再次运行`install`命令：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is also applicable when a new module needs to be included.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要包含新模块时，这也适用。
- en: 'At any point, the `freeze` command can be used to display all installed modules.
    `freeze` returns the modules in a format compatible with `requirements.txt`, making
    it possible to do this to generate a file with our current environment:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，都可以使用`freeze`命令来显示所有已安装的模块。`freeze`以与`requirements.txt`兼容的格式返回模块，从而可以生成一个包含当前环境的文件：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will include dependencies, so expect a lot more modules in the file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包括依赖项，因此文件中会有更多的模块。
- en: Finding great third-party modules is not easy sometimes. Searching for specific
    functionality can work well, but sometimes there are great modules that are a
    surprise because they do things you never thought of. A great curated list is
    **Awesome Python** ([https://awesome-python.com/](https://awesome-python.com/)),
    which covers a lot of great tools for common Python use cases, such as cryptography,
    database access, date and time handling, and  so on.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有时找到很棒的第三方模块并不容易。搜索特定功能可能效果很好，但有时会有一些出乎意料的很棒的模块，因为它们做了你从未想过的事情。一个很棒的策划列表是**Awesome
    Python**（[https://awesome-python.com/](https://awesome-python.com/)），它涵盖了很多常见Python用例的很棒工具，如加密、数据库访问、日期和时间处理等。
- en: In some cases, installing packages may require additional tools, such as compilers
    or a specific library that supports some functionality (for example, a particular
    database driver). If that's the case, the documentation will normally explain
    the dependencies.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，安装软件包可能需要额外的工具，例如编译器或支持某些功能的特定库（例如特定的数据库驱动程序）。如果是这种情况，文档通常会解释依赖关系。
- en: See also
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a virtual environment* recipe
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建虚拟环境*的步骤'
- en: The *Using a third-party tool—parse* recipe
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用第三方工具—parse*的步骤'
- en: Creating strings with formatted values
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建带有格式化值的字符串
- en: One of the basic abilities when dealing with creating text and documents is
    to be able to properly format the values into structured strings. Python is quite
    smart in presenting good defaults, such as properly rendering a number, but there
    are a lot of options and possibilities.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文本和文档时的基本能力之一是能够将值正确格式化为结构化字符串。Python在提供良好的默认值方面非常聪明，比如正确呈现数字，但是有很多选项和可能性。
- en: We'll discuss some of the common options when creating formatted text with the
    example of a table.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个表格的示例来讨论创建格式化文本时的一些常见选项。
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The main tool to format strings in Python is the `format` method. It works
    with a defined mini-language to render variables this way:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中格式化字符串的主要工具是`format`方法。它使用一个定义的迷你语言以这种方式呈现变量：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `template` is a string that gets interpreted based on the mini-language.
    At its easiest, it replaces the values between curly brackets with the parameters.
    Here are a couple of examples:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`template`是一个基于迷你语言解释的字符串。在最简单的情况下，它会用参数替换大括号之间的值。以下是一些示例：'
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In 95% of cases, this formatting will be all that's required; keeping things
    simple is great! But for complicated times, such as when aligning the strings
    automatically and creating good looking text tables, the mini-language format has
    more options.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在95%的情况下，这种格式化就足够了；保持简单是很好的！但是对于复杂的情况，比如自动对齐字符串和创建漂亮的文本表格时，迷你语言`format`有更多的选项。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Write the following script, `recipe_format_strings_step1.py`, to  print an
    aligned table:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下脚本`recipe_format_strings_step1.py`，以打印一个对齐的表格：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run it to display the following aligned table. Note that `PERCENT` is correctly
    displayed as a percentage:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行它以显示以下对齐的表格。请注意，`PERCENT`正确显示为百分比：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `TEMPLATE` constant contains three columns, each one properly named (`REVENUE`,
    `PROFIT`, `PERCENT`). This makes it more explicit and straightforward to apply
    the template on the format call.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`TEMPLATE`常量包含三列，每一列都有适当的名称（`REVENUE`，`PROFIT`，`PERCENT`）。这使得在格式调用上更加明确和简单。'
- en: 'After the name of the parameter, there''s a colon that separates the format
    definition. Note that all inside the curly brackets. In all columns, the format
    specification sets the width to seven characters and aligns the values to the
    right with the `>` symbol:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数名称之后，有一个冒号，用于分隔格式定义。请注意，所有内容都在花括号内。在所有列中，格式规范将宽度设置为七个字符，并使用`>`符号将值对齐到右侧：
- en: Revenue adds a thousands separator with the `,` symbol—`[{revenue:>7,}]`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收入使用`,`符号添加千位分隔符-`[{revenue:>7,}]`。
- en: Profit adds a `+` sign for positive values. A `-` for negatives is added automatically—`[{profit:>+7}]`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利润为正值添加`+`符号。负值会自动添加`-`-`[{profit:>+7}]`。
- en: Percent displays a percent value, with a precision of two decimal places—`[{percent:>7.2%}]`.
    This is done through 0.2 (precision) and adding a `%` symbol for the percentage.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 百分比显示百分比值，精确到两位小数-`[{percent:>7.2%}]`。这是通过0.2（精度）和添加`%`符号来完成的。
- en: There's more...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You may have also seen the available Python formatting with the `%` operator.
    While it works for simple formatting, it is less flexible than the formated mini-language,
    and it is not recommended for use.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能也已经看到了使用`%`运算符的Python格式。虽然它适用于简单的格式，但它不如格式化的迷你语言灵活，不建议使用。
- en: 'A great new feature since Python 3.6 is to use f-strings, which perform a format
    action using defined variables this way:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 自Python 3.6以来的一个很棒的新功能是使用f-strings，它使用定义的变量执行格式操作：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This simplifies a lot of the code and allows us to create very descriptive and
    readable code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这简化了很多代码，使我们能够创建非常描述性和可读性的代码。
- en: Be careful when using f-strings to ensure that the string is replaced at the
    proper time. A common problem is that the variable defined to be rendered is not
    yet defined. For example, `TEMPLATE`, defined previously, won't be defined as
    an f-string, as `revenue` and the rest of the parameters are not available at
    that point.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用f-strings时要小心，确保字符串在适当的时间被替换。一个常见问题是，定义为呈现的变量尚未定义。例如，先前定义的`TEMPLATE`不会作为f-string定义，因为`revenue`和其他参数在那时不可用。
- en: 'If you need to write a curly bracket, you''ll need to repeat it twice. Note
    that each duplication will be displayed as a single curly bracket, plus a curly
    bracket for the value replacement, making a total of three brackets:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要写大括号，需要重复两次。请注意，每个复制将显示为单个大括号，再加上一个大括号用于值替换，总共三个大括号：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This allows us to create meta templates—templates that produce templates. In
    some cases, that will be useful, but try to limit their use, as they'll get complicated
    very quickly, producing code that will be difficult to read.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够创建元模板-生成模板的模板。在某些情况下，这将很有用，但请尽量限制它们的使用，因为它们会很快变得复杂，产生难以阅读的代码。
- en: The Python Format Specification mini-language has more options than the ones
    shown here.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Python格式规范迷你语言比这里显示的选项更多。
- en: As the language tries to be quite concise, sometimes it can be difficult to
    determine the position of the symbols. You may sometimes ask yourself questions
    like—*Is the `+` symbol before or after than the width parameters.?* Read the
    documentation with care and remember to always include a colon before the format
    specification.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于语言试图非常简洁，有时很难确定符号的位置。有时您可能会问自己问题，比如-`+`符号是在宽度参数之前还是之后。-请仔细阅读文档，并记住在格式规范之前始终包括一个冒号。
- en: Please check the full documentation and examples on the Python website ([https://docs.python.org/3/library/string.html#formatspec](https://docs.python.org/3/library/string.html#formatspec)).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请在Python网站上查看完整的文档和示例（[https://docs.python.org/3/library/string.html#formatspec](https://docs.python.org/3/library/string.html#formatspec)）。
- en: See also
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Template Reports* recipe in [Chapter 5](404a9dc7-22f8-463c-9f95-b480dc17518d.xhtml),
    *Generating Fantastic Reports*
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](404a9dc7-22f8-463c-9f95-b480dc17518d.xhtml)的*生成精彩报告*中的*模板报告*配方
- en: The *Manipulating strings* recipe
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*操作字符串*配方'
- en: Manipulating strings
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作字符串
- en: A basic ability when dealing with text is to be able to properly manipulate
    that text. That means to be able to join it, split it into regular chunks, or
    change it to be uppercase or lowercase. We'll discuss more advanced methods for
    parsing text and separating it later, but in lots of cases it is useful to divide
    a paragraph into lines, sentences, or even words. Other times, words will have
    to have some characters removed or replaced with a canonical version to be able
    to compare it with a determined value.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文本时的基本能力是能够正确地操作该文本。这意味着能够将其连接，分割成常规块，或将其更改为大写或小写。我们将在以后讨论更高级的解析文本和分隔文本的方法，但在许多情况下，将段落分成行、句子甚至单词是有用的。有时，单词将必须删除一些字符或用规范版本替换以便与确定的值进行比较。
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We'll define a basic text to transform it into its main components, and then
    we'll reconstruct it. As an example, a report needs to be transformed into a new
    format to be sent via email.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个基本文本，将其转换为其主要组件，然后重新构造它。例如，需要将报告转换为新格式以通过电子邮件发送。
- en: 'The input format we''ll use in this example will be this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在此示例中使用的输入格式如下：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We need to redact the text to eliminate any references to numbers. It needs
    to be properly formatted by adding a new line after each period, justified with
    80 characters, and transformed into ASCII for compatibility reasons.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编辑文本以消除对数字的任何引用。需要通过在每个句号后添加一个新行来正确格式化它，使其对齐为80个字符，并将其转换为ASCII以确保兼容性。
- en: The text will be stored in the `INPUT_TEXT` variable in the interpreter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 文本将存储在解释器中的`INPUT_TEXT`变量中。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'After entering the text, split it into individual words:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入文本后，将其拆分为单独的单词：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Replace any numerical digits with an `''X''` character:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`'X'`字符替换任何数字：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Transform the text into pure ASCII (note that the name of the company contains
    a letter, `ñ`, which is not ASCII):'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本转换为纯ASCII（请注意，公司名称包含一个不是ASCII的字母`ñ`）：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Group the words into 80-character lines:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将单词分组为80个字符的行：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Format all lines as titles and join them as a single piece of text:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有行格式化为标题并将它们连接为单个文本片段：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Print the result:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印结果：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Each of the steps performs a specific transformation of the text:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每个步骤都对文本执行特定的转换：
- en: The first one splits the text on the default separators, whitespaces, and new
    lines. This splits it into individual words with no lines or multiple spaces for
    separation.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个步骤在默认分隔符、空格和换行符上分割文本。这将它分割成没有行或多个空格用于分隔的单词。
- en: To replace the digits, we go through every character of each word. For each
    one, if it's a digit, an `'X'` is returned instead. This is done with two list
    comprehensions, one to run on the list, and another on each word, replacing only
    if there's a digit—`['X' if w.isdigit() else w for w in word]`. Note that the
    words are joined together again.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了替换数字，我们遍历每个单词的每个字符。对于每个字符，如果它是一个数字，就返回一个`'X'`。这是通过两个列表推导式完成的，一个用于遍历列表，另一个用于每个单词，只有在有数字时才进行替换——`['X'
    if w.isdigit() else w for w in word]`。请注意，这些单词再次连接在一起。
- en: Each of the words is encoded into an ASCII byte sequence and decoded back again
    into the Python string type. Note the use of the `errors` parameter to force the
    replacement of unknown characters such as `ñ`.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个单词都被编码为ASCII字节序列，然后再次解码为Python字符串类型。注意使用`errors`参数来强制替换未知字符，如`ñ`。
- en: The difference between strings and bytes is not very intuitive at first, especially
    if you never have to worry about multiple languages or encoding transformation. In
    Python 3, there's a strong separation between strings (internal Python representation)
    and bytes, so most of the tools applicable to strings won't be available in byte
    objects. Unless you have a good idea of why you need a byte object, always work with
    Python strings. If you need to perform transformations like the one in this task,
    encode and decode in the same line so that you keep your objects in the comfortable realm
    of Python strings. If you are interested in learning more about encodings, you
    can check out this brief article ([https://eli.thegreenplace.net/2012/01/30/the-bytesstr-dichotomy-in-python-3](https://eli.thegreenplace.net/2012/01/30/the-bytesstr-dichotomy-in-python-3))
    and this other longer and more detailed one ([http://www.diveintopython3.net/strings.html](http://www.diveintopython3.net/strings.html)).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串和字节之间的区别一开始并不直观，特别是如果你从来不用担心多种语言或编码转换。在Python 3中，字符串（内部Python表示）和字节之间有很强的分离，因此大多数适用于字符串的工具在字节对象中不可用。除非你很清楚为什么需要一个字节对象，总是使用Python字符串。如果你需要执行像这个任务中的转换，编码和解码在同一行中进行，这样你就可以保持对象在舒适的Python字符串领域。如果你有兴趣了解更多关于编码的信息，你可以查看这篇简短的文章（[https://eli.thegreenplace.net/2012/01/30/the-bytesstr-dichotomy-in-python-3](https://eli.thegreenplace.net/2012/01/30/the-bytesstr-dichotomy-in-python-3)）和这篇更长更详细的文章（[http://www.diveintopython3.net/strings.html](http://www.diveintopython3.net/strings.html)）。
- en: This step first adds an extra newline character (the `\n` character) for all
    words ending with a period. This marks the different paragraphs. After that, it
    creates a line and adds the words one by one. If an extra word will make it go
    over 80 characters, it finishes the line and starts a new one. If the line already
    ends with a new line, it finishes it and starts another one as well. Note that
    there's an extra space added to separate the words.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这一步首先为所有以句号结尾的单词添加一个额外的换行符（`\n`字符）。这标记了不同的段落。之后，它创建一行并逐个添加单词。如果多一个单词会使它超过80个字符，它就结束该行并开始新的一行。如果该行已经以换行符结尾，它也结束并开始另一行。请注意，添加了额外的空格来分隔单词。
- en: Finally, each of the lines is capitalized as a Title (the first letter of each
    word is upper cased) and all the lines are joined through new lines.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，每一行都被大写为标题（每个单词的第一个字母都是大写的），并且所有行都通过换行符连接在一起。
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有...
- en: 'Some other useful operations that can be performed on strings are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对字符串执行的一些其他有用操作如下：
- en: Strings can be sliced like any other list. This means that `'word'[0:2]` will
    return `'wo'`.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串可以像任何其他列表一样切片。这意味着`'word'[0:2]`将返回`'wo'`。
- en: Use `.splitlines()` to separate lines by newline character.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.splitlines()`通过换行符分隔行。
- en: 'There are `.upper()` and `.lower()` methods, which return a copy with all the
    characters set to uppercase or lowercase. Their use is very similar to `.title()`:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有`.upper()`和`.lower()`方法，它们返回一个所有字符都设置为大写或小写的副本。它们的使用非常类似于`.title()`：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For easy replacements (for example, change all `A` to `B` or change `mine` to
    `ours`), use `.replace()`. This method is useful for very simple cases, but replacements
    can get tricky easily. Be careful with the order of replacements to avoid collisions
    and case sensitivity issues. Note the wrong replacement in the following example:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于简单的替换（例如，将所有`A`替换为`B`或将`mine`替换为`ours`），使用`.replace()`。这种方法对于非常简单的情况很有用，但替换很容易变得棘手。注意替换的顺序，以避免冲突和大小写敏感问题。请注意以下示例中错误的替换：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is similar to the issues we'll see with regular expressions matching unexpected
    parts of your code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于我们将在正则表达式中看到的问题，匹配代码的意外部分。
- en: There are more examples to follow later. Refer to the regular expressions recipes
    for more information.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多示例将在后面介绍。有关更多信息，请参阅正则表达式示例。
- en: If you work with multiple languages, or with any kind of non-English input,
    it is very useful to learn the basics of Unicode and encodings. In a nutshell,
    given the vast amount of characters in all the different languages in the world,
    including alphabets not related to the Latin one, such as Chinese or Arabic, there's
    a standard to try and cover all of them so that computers can properly understand
    them. Python 3 greatly improved this situation, making the strings internal objects
    to deal with all of those characters. The encoding that Python uses, and the most
    common and compatible one, is currently UTF-8.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用多种语言，或者任何非英语输入，学习Unicode和编码的基础知识非常有用。简而言之，鉴于世界上所有不同语言中的大量字符，包括与拉丁语无关的字母表，如中文或阿拉伯语，有一个标准来尝试覆盖所有这些字符，以便计算机可以正确理解它们。Python
    3极大地改善了这种情况，使字符串成为内部对象，以处理所有这些字符。Python使用的编码，也是最常见和兼容的编码，目前是UTF-8。
- en: 'A good article to learn about the basics of UTF-8 is this blog post: ([https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/)).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 了解有关UTF-8基础知识的好文章是这篇博文：([https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/))。
- en: Dealing with encodings is still relevant when reading from external files that
    can be encoded in different encodings (for example, CP-1252 or windows-1252, which
    is a common encoding produced by legacy Microsoft systems, or ISO 8859-15, which
    is the industry standard).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 处理编码在从可以使用不同编码的外部文件中读取时仍然很重要（例如CP-1252或windows-1252，这是由传统Microsoft系统生成的常见编码，或ISO
    8859-15，这是行业标准）。
- en: See also
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating strings with formatted values* recipe
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用格式化值创建字符串*食谱'
- en: The *Introducing regular expressions* recipe
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*介绍正则表达式*食谱'
- en: The *Going deeper into regular expressions* recipe
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深入研究正则表达式*食谱'
- en: The *Dealing with Encodings* recipe in [Chapter 4](d628b5e8-8d78-4884-905c-18b393bfcb47.xhtml),
    *Searching and Reading Local Files*
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第4章](d628b5e8-8d78-4884-905c-18b393bfcb47.xhtml)中的*处理编码*食谱，*搜索和读取本地文件*'
- en: Extracting data from structured strings
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从结构化字符串中提取数据
- en: In a lot of automated tasks, we'll need to treat input text that's in a particular
    format and extract the relevant information. For example, a spreadsheet may define
    a percentage in text (such as 37.4%) that we want to retrieve in numerical format
    to apply it later (0.374, as a float).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多自动化任务中，我们需要处理特定格式的输入文本并提取相关信息。例如，电子表格可能以文本形式定义百分比（例如37.4%），我们希望以后以数值格式检索它（0.374，作为浮点数）。
- en: In this recipe, we'll see how to process sale logs that contain inline information
    about a product, such as sold, price, profit, and some other information.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将看到如何处理包含有关产品的内联信息的销售日志，例如已售出、价格、利润和其他一些信息。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Imagine that we need to parse information stored in sales logs. We''ll use
    a sales log with the following structure:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们需要解析存储在销售日志中的信息。我们将使用以下结构的销售日志：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For example, a specific log may look like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，特定的日志可能如下所示：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that the price has a leading zero. All prices will have two digits for
    the dollars, and two for the cents.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，价格有一个前导零。所有价格都将有两位数字的美元，两位数字的美分。
- en: 'We need to activate our virtual environment before we start:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在开始之前激活我们的虚拟环境：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the Python interpreter, make the following imports. Remember to activate
    your `virtualenv`,  as described in the *Creating a virtual environment* recipe:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python解释器中，进行以下导入。记得激活你的`virtualenv`，就像*创建虚拟环境*食谱中描述的那样：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Enter the log to parse:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入要解析的日志：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Split the log into its parts, which are divided by ` -`  (note the space before
    and after the dash). We ignore the `SALE` part as it doesn''t add any relevant
    information:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将日志分割为其部分，这些部分由` -`（注意破折号前后的空格）分隔。我们忽略`SALE`部分，因为它没有添加任何相关信息：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Parse the `timestamp` into a datetime object:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`timestamp`解析为datetime对象：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Parse the `product_id` into a integer:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`product_id`解析为整数：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Parse the price into a `Decimal` type:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将价格解析为`Decimal`类型：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, you have all the values in native Python formats:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您已经拥有了所有本机Python格式的值：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The basic working of this is to isolate each of the elements and then parse
    them in to the proper type. The first step is to split the full log into smaller
    parts. The `-` string is a good divider, as it splits it into four parts—a timestamp
    one, one with just the word `SALE`, the product, and the price.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本的工作是隔离每个元素，然后将它们解析为适当的类型。第一步是将完整的日志分割成较小的部分。`-`字符串是一个很好的分隔符，因为它将其分成四个部分——一个时间戳部分，一个只有`SALE`一词的部分，产品和价格。
- en: In the case of the timestamp, we need to isolate the ISO format, which is in
    brackets in the log. That's why it's stripped off the brackets. We use the `delorean` module (introduced
    earlier) to parse it in to a `datetime` object.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间戳的情况下，我们需要隔离日志中的ISO格式。这就是为什么它被剥离括号。我们使用`delorean`模块（之前介绍过）将其解析为`datetime`对象。
- en: The word `SALE` is ignored. There's no relevant information there.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 单词`SALE`被忽略。那里没有相关信息。
- en: 'To isolate the product ID, we split the product part at the colon. Then, we
    parse the last element as an integer:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了隔离产品ID，我们将产品部分分割为冒号。然后，我们将最后一个元素解析为整数：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To divide the price, we use the dollar sign as a separator, and parse it as
    a `Decimal` character:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分割价格，我们使用美元符号作为分隔符，并将其解析为`Decimal`字符：
- en: '[PRE43]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As described in the next section, do not parse this value into a float type.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如下一节所述，不要将此值解析为浮点类型。
- en: There's more...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'These log elements can be combined together into a single object, helping with
    parsing and aggregating them. For example, we could define a class in Python code
    in the following way:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日志元素可以组合成一个单一对象，有助于解析和聚合它们。例如，我们可以在Python代码中以以下方式定义一个类：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'So, the parsing can be done as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，解析可以按以下方式进行：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Avoid using float types for prices. Floats numbers have precision problems
    that may produce strange errors when aggregating multiple prices, for example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用浮点数类型来表示价格。浮点数存在精度问题，可能在聚合多个价格时产生奇怪的错误，例如：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Try these two options to avoid problems:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这两个选项以避免问题：
- en: '**Use integer cents as the base unit**: This means multiplying currency inputs
    by 100 and transforming them into integers (or whatever fractional unit is correct
    for the currency used). You may still want to change the base when displaying
    them.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用整数分为基本单位**：这意味着将货币输入乘以100，并将其转换为整数（或者正确的分数单位，根据所使用的货币而定）。在显示它们时，您可能仍然希望更改基数。'
- en: '**Parse into the Decimal type**: The `Decimal` type keeps the fixed precision
    and works as you''d expect. You can find further information about the `Decimal`
    type in the Python docs at [https://docs.python.org/3.6/library/decimal.html](https://docs.python.org/3.6/library/decimal.html).'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解析为十进制类型**：`Decimal`类型保持固定精度，并且按预期工作。您可以在Python文档中找到有关`Decimal`类型的更多信息，网址为[https://docs.python.org/3.6/library/decimal.html](https://docs.python.org/3.6/library/decimal.html)。'
- en: If you use the `Decimal` type, parse the results directly into `Decimal` from
    the string. If transforming it first into a float, you can carry the precision
    errors to the new type.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`Decimal`类型，请直接从字符串解析结果为`Decimal`。如果首先将其转换为浮点数，则可能会将精度错误传递给新类型。
- en: See also
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a virtual environment* recipe
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建虚拟环境*食谱'
- en: The *Using a third-party tool—parse* recipe
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用第三方工具—解析*食谱'
- en: The *Introducing regular expressions* recipe
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*介绍正则表达式*食谱'
- en: The *Going deeper into regular expressions* recipe
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深入了解正则表达式*食谱'
- en: Using a third-party tool—parse
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方工具—解析
- en: While manually parsing data, as seen in the previous recipe, works very well
    for small strings, it can be very laborious to tweak the exact formula to work
    with a variety of input. What if the input has an extra dash sometimes? Or it
    has a variable length header depending on the size of one of the fields?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 手动解析数据，如前一篇文章中所示，对于小字符串非常有效，但是要调整确切的公式以适应各种输入可能非常费力。如果输入有时有额外的破折号呢？或者根据某个字段的大小而变化的变长标题呢？
- en: A more advanced option is to use regular expressions, as we'll see in the next
    recipe. But there's a great module in Python called `parse` ([https://github.com/r1chardj0n3s/parse](https://github.com/r1chardj0n3s/parse))
    that allows us to reverse format strings. It is a fantastic tool, that's powerful,
    easy to use, and greatly improves the readability of the code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的选项是使用正则表达式，我们将在下一篇文章中看到。但是Python中有一个名为`parse`的出色模块([https://github.com/r1chardj0n3s/parse](https://github.com/r1chardj0n3s/parse))，它允许我们反转格式字符串。这是一个强大、易于使用的工具，极大地提高了代码的可读性。
- en: Getting ready
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Add the parse module to the `requirements.txt` file in our virtual environment
    and reinstall the dependencies, as shown in the *Creating a virtual environment* recipe.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 将`parse`模块添加到虚拟环境中的`requirements.txt`文件中，并重新安装依赖项，如*创建虚拟环境*食谱中所示。
- en: 'The `requirements.txt` file should look like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements.txt`文件应如下所示：'
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, reinstall the modules in the virtual environment:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在虚拟环境中重新安装模块：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How to do it...
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import the `parse` function:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`parse`函数：
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Define the log to parse, in the same format as in the *Extracting data from
    structured strings* recipe:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义要解析的日志，格式与*从结构化字符串中提取数据*食谱中的格式相同：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Analyze it and describe it as you''ll do when trying to print it, like this:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析它并描述它，就像打印时所做的那样，如下所示：
- en: '[PRE51]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Run `parse` and check the results:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`parse`并检查结果：
- en: '[PRE52]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Note the results are all strings. Define the types to be parsed:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，结果都是字符串。定义要解析的类型：
- en: '[PRE53]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Parse once again:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次解析：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Define a custom type for the price to avoid issues with the float type:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义自定义类型以避免浮点类型的问题：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `parse` module allows us to define a format, such as string, that reverses
    the format method when parsing values. A lot of the concepts that we discussed
    when creating strings applies here—put values in brackets, define the type after
    a colon, and so on.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse`模块允许我们定义一个格式，例如字符串，以便在解析值时反转格式方法。我们在创建字符串时讨论的许多概念也适用于此处—将值放在括号中，在冒号后定义类型等。'
- en: By default, as seen in step 4, the values are parsed as strings. This is a good
    starting point when analyzing text. The values can be parsed into more useful
    native types, as shown in steps 5 and 6 in the *How to do it...* section. Please
    note that while most of the parsing types are the same as the ones in the Python
    Format Specification mini-language, there are some others available, such as `ti`
    for timestamps in ISO format.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如第4步所示，值被解析为字符串。这是分析文本的一个很好的起点。值可以被解析为更有用的本机类型，如*如何做...*部分的第5和第6步所示。请注意，虽然大多数解析类型与Python格式规范迷你语言中的类型相同，但还有其他一些可用，例如用于ISO格式时间戳的`ti`。
- en: If native types are not enough, our own parsing can be defined, as demonstrated
    in step 7 in the *How to do it...* section. Note that the definition of the price
    function gets a string and returns the proper format, in this case a `Decimal`
    type.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本机类型不够用，我们可以定义自己的解析，如*如何做...*部分的第7步所示。请注意，价格函数的定义接收一个字符串并返回正确的格式，本例中为`Decimal`类型。
- en: All the issues about floats and price information described in the *There's
    more* section of the *Extracting data from structured strings* recipe apply here
    as well.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*从结构化字符串中提取数据*食谱的*还有更多*部分中描述的有关浮点数和价格信息的所有问题在这里同样适用。'
- en: There's more...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The timestamp can also be translated into a `delorean` object for consistency.
    Also, `delorean` objects carry over timezone information. Adding the same structure
    as in the previous recipe gives the following object, which is capable of parsing
    logs:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳也可以转换为`delorean`对象以保持一致性。此外，`delorean`对象携带时区信息。添加与上一个示例相同的结构，得到以下对象，可以解析日志：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'So, parsing it returns similar results:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，解析它会返回类似的结果：
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This code is contained in the GitHub file `Chapter01/price_log.py`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码包含在GitHub文件`Chapter01/price_log.py`中。
- en: All `parse` supported types can be found in the documentation at [https://github.com/r1chardj0n3s/parse#format-specification](https://github.com/r1chardj0n3s/parse#format-specification).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`parse`支持的类型都可以在[https://github.com/r1chardj0n3s/parse#format-specification](https://github.com/r1chardj0n3s/parse#format-specification)的文档中找到。
- en: See also
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Extracting data from structured strings* recipe
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从结构化字符串中提取数据*示例'
- en: The *Introducing regular expressions* recipe
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*介绍正则表达式*示例'
- en: The *Going deeper into regular expressions* recipe
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深入了解正则表达式*示例'
- en: Introducing regular expressions
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍正则表达式
- en: A **regular expression**, or **regex**, is a pattern to *match* text. In other
    words, it allows us to define an **abstract string** (typically the definition
    of a structured kind of text) to check with other strings to see if they match
    or not.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**，或**regex**，是一种用于*匹配*文本的模式。换句话说，它允许我们定义一个**抽象字符串**（通常是结构化文本的定义）来检查其他字符串是否匹配。'
- en: It is better to describe them with an example. Think of defining a pattern of
    text as *a word that starts with an uppercase A and contains only lowercase Ns
    and As after that*. The word *Anna* matches it, but *Bob*, *Alice*, and *James *does
    not. The words *Aaan*, *Ana*, *Annnn*, and *Aaaan* will also be matches, but *ANNA* won't.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最好用示例来描述它们。想象一下，定义一个文本模式为“以大写A开头，之后只包含小写N和A的单词”。单词*Anna*符合此模式，但*Bob*、*Alice*和*James*不符合。单词*Aaan*、*Ana*、*Annnn*和*Aaaan*也符合，但*ANNA*不符合。
- en: If this sounds complicated, that's because it is. Regexes can be notoriously
    complicated because they may be incredibly intricate and difficult to follow.
    But they are very useful, because they allow us to perform incredibly powerful
    pattern matching.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来很复杂，那是因为它确实很复杂。正则表达式可能非常复杂，因为它们可能非常复杂且难以理解。但它们非常有用，因为它们允许我们执行非常强大的模式匹配。
- en: 'Some common uses of regexes are as follow:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的一些常见用途如下：
- en: '**Validating input data**: For example, that a phone number is only numbers,
    dashes, and brackets.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证输入数据**：例如，电话号码只包含数字、破折号和括号。'
- en: '**String parsing**: Retrieve data from structured strings, such as logs or
    URLs. This is similar to what''s described in the previous recipe.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串解析**：从结构化字符串（如日志或URL）中检索数据。这与前一个示例中描述的内容类似。'
- en: '**Scrapping**: Find the occurrences of something in a long text. For example,
    find all emails in a web page.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抓取**：在长文本中查找某些内容的出现。例如，在网页中查找所有电子邮件。'
- en: '**Replacement**: Find and replace a word or words with others. For example,
    replace *the owner* with *John Smith*.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**替换**：查找并用其他单词替换一个单词或多个单词。例如，将*the owner*替换为*John Smith*。'
- en: '"Some people, when confronted with a problem, think "I know, I''ll use regular
    expressions." Now they have two problems."'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: “有些人遇到问题时会想到“我知道了，我会使用正则表达式。”现在他们有了两个问题。”
- en: – Jamie Zawinski
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '- Jamie Zawinski'
- en: Regular expressions are at their best when they are kept very simple. In general,
    if there is a specific tool to do it, prefer it over regexes. A very clear example
    of this is HTML parsing; check [Chapter 3](e8536572-46e4-41ec-87b8-7f775fd61e63.xhtml),
    *Building Your First Web Scraping Application,* for better tools to achieve this.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式在保持非常简单时效果最好。一般来说，如果有特定的工具可以做到，最好使用它而不是正则表达式。HTML解析就是一个非常明显的例子；查看[第3章](e8536572-46e4-41ec-87b8-7f775fd61e63.xhtml)，*构建您的第一个网络抓取应用程序*，以了解更好的工具来实现这一点。
- en: Some text editors allow us to search using regexes as well. While most are editors
    aimed at writing code, such as Vim, BBEdit, or Notepad++, they're also present
    in more general tools, such as MS Office, Open Office, or Google Documents. But
    be careful, as the particular syntax may be slightly different.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文本编辑器也允许我们使用正则表达式进行搜索。虽然大多数是针对编写代码的编辑器，如Vim、BBEdit或Notepad++，但它们也存在于更通用的工具中，如MS
    Office、Open Office或Google文档。但要小心，因为特定的语法可能略有不同。
- en: Getting ready
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `python` module to deal with regexes is called `re`. The main function we'll
    cover is `re.search()`, which returns a *match *object with information about
    what matched the pattern.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 处理正则表达式的`python`模块称为`re`。我们将介绍的主要函数是`re.search()`，它返回一个关于匹配模式的*match*对象的信息。
- en: As regex patterns are also defined as strings, we'll differentiate them by prefixing
    them with an *r*, such as `r'pattern'`. This is the Python way of labeling a text
    as raw string literals, meaning that the string within is taken literally, without
    any escaping. This means that a `\` is used as a backslash instead of a sequence.
    For example, without the r prefix, `\n` means newline character.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于正则表达式模式也是字符串，我们将它们区分开来，通过在前面加上*r*来区分它们，例如`r'pattern'`。这是Python标记文本为原始字符串文字的方式，这意味着其中的字符串会被直接接受，不会进行任何转义。这意味着`\`被用作反斜杠，而不是一个序列。例如，没有r前缀，`\n`表示换行符。
- en: Some characters are special, and refer to concepts such as *the end of the string*,
    *any digit*, *any character*, *any whitespace character*, and so on.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 有些字符是特殊的，表示诸如*字符串结尾*、*任何数字*、*任何字符*、*任何空白字符*等概念。
- en: 'The simplest form is just a literal string. For example, the regex pattern
    `r''LOG''` matches the string `''LOGS''`, but not the string `''NOT A MATCH''`.
    If there''s not a match, search returns `None`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的形式只是一个字面字符串。例如，正则表达式模式`r'LOG'`匹配字符串`'LOGS'`，但不匹配字符串`'NOT A MATCH'`。如果没有匹配，搜索返回`None`：
- en: '[PRE58]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How to do it...
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import the `re` module:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`re`模块：
- en: '[PRE59]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, match a pattern that is not at the start of the string:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，匹配不位于字符串开头的模式：
- en: '[PRE60]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Match a pattern that is only at the start of the string. Note the `^` character:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配仅位于字符串开头的模式。注意`^`字符：
- en: '[PRE61]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Match a pattern only at the end of the string. Note the `$` character:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅在字符串末尾匹配模式。请注意`$`字符：
- en: '[PRE62]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Match the word `''thing''` (not excluding `things`), but not `something` or
    `anything`. Note the `\b` at the start of the second pattern:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配单词`'thing'`（不包括`things`），但不匹配`something`或`anything`。请注意第二个模式的开头处的`\b`：
- en: '[PRE63]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Match a pattern that''s only numbers and dashes (for example, a phone number).
    Retrieve the matched string:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配仅为数字和破折号（例如电话号码）的模式。检索匹配的字符串：
- en: '[PRE64]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Match an email address naively:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 天真地匹配电子邮件地址：
- en: '[PRE65]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: How it works...
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `re.search` function matches a pattern, no matter its position in the string.
    As explained previously, this will return `None` if the pattern is not found,
    or a `match` object.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`re.search`函数匹配模式，无论其在字符串中的位置如何。如前所述，如果未找到模式，将返回`None`，或者匹配对象。'
- en: 'The following special characters are used:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下特殊字符：
- en: '`^`: Marks the start of the string'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`：标记字符串的开头'
- en: '`$`: Marks the end of the string'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`：标记字符串的结尾'
- en: '`\b`: Marks the start or end of a word'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\b`：标记单词的开头或结尾'
- en: '`\S`: Marks any character that''s not a whitespace, including special characters'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\S`：标记任何非空白字符，包括特殊字符'
- en: More special characters are shown in the next recipe.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 更多特殊字符将在下一个配方中显示。
- en: In step 6 in the *How to do it...* section, the `r'[0123456789-]+'` pattern is
    composed of two parts. The first one is between square brackets, and matches any
    single character between `0` and `9` (any number) and the dash (`-`) character.
    The `+` sign after that means that this character can be present one or more times.
    This is called a **quantifier** in regexes. This makes a match on any combination
    of numbers and dashes, no matter how long it is.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在*如何做...*部分的第6步中，`r'[0123456789-]+'`模式由两部分组成。第一部分在方括号之间，匹配`0`到`9`之间的任何单个字符（任何数字）和破折号（`-`）字符。之后的`+`表示该字符可以出现一次或多次。这在正则表达式中称为**量词**。这使得可以匹配任何数字和破折号的组合，无论长度如何。
- en: Step 7 again uses the `+` sign to match as many characters as necessary before
    the `@` and again after it. In this case, the character match is `\S`, which matches
    any non-whitespace character.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤7再次使用`+`号匹配尽可能多的字符，然后再次使用`@`。在这种情况下，字符匹配是`\S`，它匹配任何非空白字符。
- en: Please note that the naive pattern for emails described here is *very* naive,
    as it will match invalid emails such as `john@smith@test.com`. A better regex
    for most uses is `r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)"`. You
    can go to [http://emailregex.com/](http://emailregex.com/) for find it and links
    to more information.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此处描述的电子邮件的天真模式非常天真，因为它将匹配无效的电子邮件，例如`john@smith@test.com`。对于大多数用途，更好的正则表达式是`r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)"`。您可以访问[http://emailregex.com/](http://emailregex.com/)查找它并链接到更多信息。
- en: Note that parsing a valid email including corner cases is actually a difficult
    and challenging problem. The previous regex should be fine for most uses covered
    in this book, but in a general framework project such as Django, email validation
    is a very long and very unreadable regex.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，解析包括边缘情况在内的有效电子邮件实际上是一个困难且具有挑战性的问题。前面的正则表达式对于本书涵盖的大多数用途应该都可以，但在诸如Django之类的通用框架项目中，电子邮件验证是一个非常冗长且非常难以阅读的正则表达式。
- en: The resulting matching object returns the position where the matched pattern
    starts and ends (using the `start` and `end` methods), as shown in step 5, which
    splits the string into matched parts, showing the distinction between the two
    matching patterns.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的匹配对象返回匹配模式开始和结束的位置（使用`start`和`end`方法），如步骤5所示，该步骤将字符串拆分为匹配部分，显示两个匹配模式之间的区别。
- en: The difference displayed in step 5 is a very common one. Trying to capture GP
    can end up capturing eg**gp**lant and ba**gp**ipe! Similarly, `things\b` won't
    capture things. Be sure to test and make the proper adjustments, such as capturing
    `\bGP\b` for just the word GP.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤5中显示的差异非常常见。尝试捕获GP可能最终捕获eg**gp**lant和ba**gp**ipe！同样，`things\b`不会捕获things。请务必测试并进行适当的调整，例如捕获`\bGP\b`以获取单词GP。
- en: 'The specific matched pattern can be retrieved by calling `group()`, as shown
    in step 6\. Note that the result will always be a string. It can be further processed
    using any of the methods that we''ve previously seen, such as by splitting the
    phone number into groups by dashes, for example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用`group()`来检索特定匹配的模式，如步骤6所示。请注意，结果始终是一个字符串。可以进一步使用我们之前看到的任何方法进行处理，例如通过破折号将电话号码拆分成组：
- en: '[PRE66]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There's more...
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Dealing with regexes can be difficult and complex. Please allow time to test
    your matches and be sure that they work as you expect in order to avoid nasty
    surprises.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 处理正则表达式可能会很困难和复杂。请花时间测试您的匹配，并确保它们按照您的期望工作，以避免不愉快的惊喜。
- en: 'You can check your regexes interactively with some tools. A good one that''s
    freely available online is [https://regex101.com/](https://regex101.com/), which
    displays each of the elements and explains the regex. Double-check that you''re
    using the Python flavor:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用一些工具进行交互式地检查您的正则表达式。一个很好的免费在线工具是[https://regex101.com/](https://regex101.com/)，它显示每个元素并解释正则表达式。请仔细检查您是否使用了Python风格：
- en: '![](assets/9c4e482e-ec3f-4e68-b39b-b58feebb6c34.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9c4e482e-ec3f-4e68-b39b-b58feebb6c34.png)'
- en: See that the EXPLANATION describes that `\b` matches a word boundary (start
    or end of a word), and that *thing* matches literally these characters.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，解释描述了`\b`匹配单词边界（单词的开头或结尾），以及*thing*字面上匹配这些字符。
- en: Regexes, in some cases, can be very slow, or even produce what's called **regex
    denial-of-service**, a string created to confuse a particular regex so that it
    takes an enormous amount of time, even in the worst case blocking the computer.
    While automating tasks probably won't get you into those problems, keep an eye
    out in case a regex takes too long.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，正则表达式可能非常缓慢，甚至会产生所谓的**正则表达式拒绝服务**，即创建一个字符串以混淆特定的正则表达式，使其花费大量时间，甚至在最坏的情况下阻塞计算机。虽然自动化任务可能不会让您陷入这些问题，但请注意，如果正则表达式花费的时间太长，请留意。
- en: See also
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Extracting data from structured strings* recipe
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从结构化字符串中提取数据*配方'
- en: The *Using a third-party tool—parse* recipe
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用第三方工具—解析*配方'
- en: The *Going deeper into regular expressions* recipe
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*深入了解正则表达式*配方'
- en: Going deeper into regular expressions
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解正则表达式
- en: In this recipe, we'll see more about how to deal with regular expressions. After
    introducing the basics, we will dig a little deeper into pattern elements, introduce
    groups as a better way to retrieve and parse strings, see how to search for multiple
    occurrences of the same string, and deal with longer texts.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将更多地了解如何处理正则表达式。在介绍基础知识之后，我们将深入了解模式元素，引入组作为检索和解析字符串的更好方法，看看如何搜索相同字符串的多个出现，并处理更长的文本。
- en: How to do it...
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import `re`:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`re`：
- en: '[PRE67]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Match a phone pattern as part of a group (in brackets). Note the use of `\d`
    as a special character for *any digit*:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电话模式作为组的一部分进行匹配（在括号中）。注意使用`\d`作为*任何数字*的特殊字符：
- en: '[PRE68]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Compile a pattern and capture a case insensitive pattern with a `yes|no` option:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译一个模式并捕获一个不区分大小写的模式，使用`yes|no`选项：
- en: '[PRE69]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Match all the occurrences of cities and state abbreviations in the text. Note
    that they are separated by a single character and the name of the city always
    starts with an uppercase letter. Only four states are matched for simplicity:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本中匹配所有城市和州的缩写的出现。请注意，它们由一个单个字符分隔，城市的名称始终以大写字母开头。为简单起见，只匹配了四个州：
- en: '[PRE70]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How it works...
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The new special characters that were introduced are as follows. Note that the
    same letter in uppercase or lowercase means the opposite match, for example `\d`
    matches a digit, while `\D` matches a non digit.:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 引入的新特殊字符如下。请注意，大写或小写的相同字母表示相反的匹配，例如`\d`匹配数字，而`\D`匹配非数字。：
- en: '`\d`: Marks any digit (0 to 9).'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\d`：标记任何数字（0到9）。'
- en: '`\s`: Marks any character that''s a whitespace, including tabs and other whitespace
    special characters. Note that this is the reverse of `\S`, introduced in the previous
    recipe**.**'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\s`：标记任何空白字符，包括制表符和其他空白特殊字符。请注意，这与上一个配方中引入的`\S`相反**。**'
- en: '`\w`: Marks any letter (includes digits, but excludes characters such as periods).'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\w`：标记任何字母（包括数字，但不包括句号等字符）。'
- en: '`.`: Marks any character.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.`：标记任何字符。'
- en: 'To define groups, put the defined groups in brackets. Groups can be retrieved
    individually, making them perfect for matching a bigger pattern that contains
    a variable part that we''ll treat later, as demonstrated in step 2\. Note the
    difference with the step 6 pattern in the previous recipe. In this case, the pattern
    is not only the number, but includes the prefix, even if we then extract the number.
    Check out this difference, where there''s a number that''s not the number we want
    to capture:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义组，请将定义的组放在括号中。可以单独检索组，使它们非常适合匹配包含稍后将处理的可变部分的更大模式，如步骤2中所示。请注意与上一个配方中步骤6模式的区别。在这种情况下，模式不仅是数字，而且包括前缀，即使我们随后提取数字。请查看这种差异，其中有一个不是我们想要捕获的数字：
- en: '[PRE71]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Remember that group 0 (`.group()` or  `.group(0)`) is always the whole match.
    The rest of the groups are ordered as they appear.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，第0组（`.group()`或`.group(0)`）始终是整个匹配。其余的组按它们出现的顺序排列。
- en: Patterns can be compiled as well. This saves some time if the pattern needs
    to be matched over and over. To use it that way, compile the pattern and then
    use that object to perform searches, as shown in steps 3 and 4\. Some extra flags
    can be added, such as making the pattern case insensitive.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 模式也可以编译。如果模式需要一遍又一遍地匹配，这样可以节省一些时间。要以这种方式使用它，编译模式，然后使用该对象执行搜索，如步骤3和4所示。可以添加一些额外的标志，例如使模式不区分大小写。
- en: Step 4's pattern requires a little bit of information. It's composed of two
    groups, separated by a single character. The special character `.` means it matches
    everything, in our example a period, a whitespace, and a comma. The second group
    is a straightforward selection of defined options, in this case US state abbreviations.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步的模式需要一点信息。它由两个组成，由一个单个字符分隔。特殊字符`.`表示它匹配一切，例如一个句号、一个空格和一个逗号。第二组是一组明确定义的选项，例如美国州的缩写。
- en: The first group starts with an uppercase letter (`[A-Z]`), and accepts any combination
    of letters or spaces (`[\w\s]+`), but not punctuation marks such as periods or
    commas. This matches the cities, including when composed of more than one word.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组以大写字母（`[A-Z]`）开头，并接受任何字母或空格的组合（`[\w\s]+`），但不接受句号或逗号等标点符号。这匹配城市，包括由多个单词组成的城市。
- en: 'Note that this pattern starts on any uppercase letter and keeps matching until
    finding a state, unless separated by a punctuation mark, which may not be what''s
    expected, for example:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个模式从任何大写字母开始匹配，直到找到一个州，除非被标点符号分隔，这可能不是预期的结果，例如：
- en: '[PRE72]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Step 4 also shows how to find more than one occurrence in a long text. While
    the `.findall()` method exists, it doesn''t return the full match object, while
    `.findalliter()` does. Commonplace now in Python 3, `.findalliter()` returns an
    iterator that can be used in a for loop or list comprehension. Note that `.search()` returns
    only the first occurrence of the pattern, even if more matches appear:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步还展示了如何在长文本中查找多个出现。虽然`.findall()`方法存在，但它不返回完整的匹配对象，而`.findalliter()`则返回。现在在Python
    3中很常见，`.findalliter()`返回一个迭代器，可以在for循环或列表推导中使用。请注意，`.search()`仅返回模式的第一个匹配，即使出现更多匹配：
- en: '[PRE73]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: There's more...
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The special characters can be reversed if they are case swapped. For example,
    the reverse of the ones we used are as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊字符可以反转，如果它们被大小写交换。例如，我们使用的特殊字符的反向如下：
- en: '`\D`: Marks any non-digit'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\D`：标记任何非数字'
- en: '`\W`: Marks any non-letter'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\W`：标记任何非字母'
- en: '`\B`: Marks any character that''s not at the start or end of a word'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\B`：标记任何不在单词开头或结尾的字符'
- en: The most commonly used special characters are typically `\d` (digits) and `\w`
    (letters and digits), as they mark common patterns to search for, and the plus
    sign for one or more.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的特殊字符通常是`\d`（数字）和`\w`（字母和数字），因为它们标记了常见的搜索模式，加号表示一个或多个。
- en: Groups can be assigned names as well. This makes them more explicit at the expense
    of making the group more verbose in the following shape—`(?P<groupname>PATTERN)`.
    Groups can be referred to by name with `.group(groupname)` or by calling `.groupdict()` while
    maintaining its numeric position.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 组也可以分配名称。这样可以使它们更加明确，但会使组变得更冗长，形式如下—`(?P<groupname>PATTERN)`。可以通过名称引用组，使用`.group(groupname)`或通过调用`.groupdict()`来保持其数字位置。
- en: 'For example, the step 4 pattern can be described as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，步骤4的模式可以描述如下：
- en: '[PRE74]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Regular expressions are a very extensive topic. There are whole technical books
    devoted to them and they can be notoriously deep. The Python documentation is
    good to be used as reference ([https://docs.python.org/3/library/re.html](https://docs.python.org/3/library/re.html))
    and to learn more.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一个非常广泛的主题。有整本专门讨论它们的技术书籍，它们可能非常深奥。Python文档是一个很好的参考（[https://docs.python.org/3/library/re.html](https://docs.python.org/3/library/re.html)）并且可以学到更多。
- en: If you feel a little intimidated at the start, it's a perfectly natural feeling. Analyze
    each of the patterns with care, dividing it into different parts, and they will
    start to make sense. Don't be afraid to run a regex interactive analyzer!
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一开始感到有点害怕，这是完全正常的感觉。仔细分析每个模式，将其分成不同的部分，它们将开始变得有意义。不要害怕运行正则表达式交互式分析器！
- en: Regexes can be really powerful and generic, but they may not be the proper tool
    for what you are trying to achieve. We've seen some caveats and patterns that
    have subtleties. As a rule of thumb, if a pattern starts to feel complicated,
    it's time to search for a different tool. Remember the previous recipes as well
    and the options they presented, such as `parse`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式可能非常强大和通用，但它们可能不是您尝试实现的目标的合适工具。我们已经看到了一些细微差别和模式。作为一个经验法则，如果一个模式开始感觉复杂，那么是时候寻找另一个工具了。还记得之前的配方以及它们提供的选项，比如`parse`。
- en: See also
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Introducing regular expressions* recipe
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*介绍正则表达式*配方'
- en: The *Using a third-party tool—parse* recipe
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用第三方工具—parse*配方'
- en: Adding command-line arguments
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加命令行参数
- en: A lot of tasks can be best structured as a command-line interface that accepts
    different parameters to change the way it works, for example, scrapping one web
    page or another. Python includes a powerful `argparse` module in the standard
    library to create rich command-line argument parsing with minimal effort.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 许多任务最好被构造为接受不同参数以改变工作方式的命令行接口，例如，抓取一个网页或另一个网页。Python在标准库中包含了一个强大的`argparse`模块，可以轻松创建丰富的命令行参数解析。
- en: Getting ready
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The basic use of `argparse` in a script can be shown in three steps:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中`argparse`的基本用法可以分为三个步骤：
- en: Define the arguments that your script is going to accept, generating a new parser.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义脚本将接受的参数，生成一个新的解析器。
- en: Call the defined parser, returning an object with all the resulting arguments.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用定义的解析器，返回一个包含所有结果参数的对象。
- en: Use the arguments to call the entry point of your script, which will apply the
    defined behavior.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用参数调用脚本的入口点，这将应用定义的行为。
- en: 'Try to use the following general structure for your scripts:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用以下通用结构编写脚本：
- en: '[PRE75]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `main` function makes it easy to know what the entry point for the code
    is. The section under the `if` statement is only executed if the file is called
    directly, but not if it's imported. We'll follow this for all the steps.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数使得很容易知道代码的入口点。`if`语句下的部分只有在文件直接调用时才会执行，而不是在导入时执行。我们将对所有步骤都遵循这一点。'
- en: How to do it...
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a script that will accept a single integer as a positional argument,
    and will print a hash symbol that amount of times. The `recipe_cli_step1.py` script
    is as follows, but note we are following the structure presented previously, and
    the `main` function is just printing the argument:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个脚本，它将接受一个单个整数作为位置参数，并打印出相应次数的哈希符号。`recipe_cli_step1.py`脚本如下，但请注意我们正在遵循之前介绍的结构，并且`main`函数只是打印参数：
- en: '[PRE76]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Call the script and see how the parameter is presented. Calling the script
    with no arguments displays the automatic help. Use the automatic argument `-h`
    to display the extended help:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用脚本并查看参数的呈现方式。使用无参数调用脚本会显示自动帮助信息。使用自动参数`-h`显示扩展帮助信息：
- en: '[PRE77]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Calling the script with the extra parameters works as expected:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用额外参数调用脚本会按预期工作：
- en: '[PRE78]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Change the script to accept an optional argument for the character to print.
    The default will be `''#''`. The `recipe_cli_step2.py ` script will look like
    this:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改脚本以接受一个可选参数用于打印的字符。默认值将是`'#'`。`recipe_cli_step2.py`脚本将如下所示：
- en: '[PRE79]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The help is updated, and using the `-c` flag allows us to print different characters:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 帮助信息已更新，使用`-c`标志允许我们打印不同的字符：
- en: '[PRE80]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Add a flag that changes the behavior when present. The `recipe_cli_step3.py`
    script is as follows:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个标志，当存在时改变行为。`recipe_cli_step3.py`脚本如下：
- en: '[PRE81]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Calling it uppercases the character if the `-U` flag is added:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果添加了`-U`标志，则调用它会将字符转换为大写：
- en: '[PRE82]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: How it works...
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As described in step 1 in the *How to do it…* section, the arguments are added
    to the parser through `.add_arguments`. Once all arguments are defined, calling
    `parse_args()` returns an object that contains the results (or exits if there's
    an error).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如*如何做...*部分中的步骤1所述，通过`.add_arguments`将参数添加到解析器中。一旦定义了所有参数，调用`parse_args()`将返回一个包含结果的对象（或者如果有错误则退出）。
- en: 'Each argument should add a help description, but their behavior can change
    greatly:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参数都应该添加一个帮助描述，但它们的行为可能会有很大变化：
- en: If an argument starts with a `-`, it is considered an optional parameter, like
    the `-c` argument in step 4\. If not, it's a positional argument, like the `number` argument
    in step 1.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数以`-`开头，则被视为可选参数，就像步骤4中的`-c`参数一样。如果不是，则是位置参数，就像步骤1中的`number`参数一样。
- en: For clarity, always define a default value for optional parameters. It will
    be `None` if you don't, but this may be confusing.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，始终为可选参数定义默认值。如果不这样做，它将是`None`，但这可能会令人困惑。
- en: Remember to always add a help parameter with a description of the parameter;
    help is automatically generated, as shown in step 2.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记得始终添加一个带有参数描述的帮助参数；帮助将自动生成，如步骤2所示。
- en: If a type is present, it will be validated, for example, `number` in step 3\.
    By default, the type will be string.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在类型，将进行验证，例如，在步骤3中的`number`。默认情况下，类型将为字符串。
- en: The actions `store_true` and `store_false` can be used to generate flags, arguments
    that don't require any extra parameters. Set the corresponding default value as
    the opposite Boolean. This is demonstrated in the `U` argument in steps 6 and
    7.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store_true`和`store_false`操作可用于生成标志，不需要任何额外参数的参数。将相应的默认值设置为相反的布尔值。这在步骤6和7中的`U`参数中有所示。'
- en: The name of the property in the `args` object will be, by default, the name
    of the argument (without the dash, if it's present). You can change it with `dest`.
    For example, in step 6, the command-line argument `-U` is described as `uppercase`.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`对象中属性的名称默认情况下将是参数的名称（如果存在破折号，则不包括）。您可以使用`dest`更改它。例如，在步骤6中，命令行参数`-U`被描述为`uppercase`。'
- en: Changing the name of an argument for internal usage is very useful when using
    short arguments, such as single letters. A good command-line interface will use
    `-c`, but internally it's probably a good idea to use a more verbose label, such
    as `configuration_file`. Explicit is better than implicit!
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用短参数（如单个字母）时，更改参数的名称以供内部使用非常有用。一个良好的命令行界面将使用`-c`，但在内部使用更详细的标签，如`configuration_file`可能是一个好主意。显式胜于隐式！
- en: Some arguments can work in coordination with others, as shown in step 3\. Perform
    all required operations to pass the main function as clear and concise parameters.
    For example, in step 3, only two parameters are passed, but one may have been
    modified.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些参数可以与其他参数协同工作，如步骤3所示。执行所有必需的操作，以清晰简洁的参数传递主要函数。例如，在步骤3中，只传递了两个参数，但可能已经修改了一个参数。
- en: There's more...
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can create long arguments as well with double dashes, for example:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用双破折号创建长参数，例如：
- en: '[PRE83]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This will accept both `-v` and `--verbose`, and it will store the name `verbose`.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这将接受`-v`和`--verbose`，并将存储名称`verbose`。
- en: Adding long names is a good way of making the interface more intuitive and easy
    to remember. It's easy to remember after a couple of times that there's a verbose
    option, and it starts with a `v`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 添加长名称是使界面更直观和易于记忆的好方法。几次之后很容易记住有一个冗长的选项，并且以`v`开头。
- en: The main inconvenience when dealing with command-line arguments may be ending
    up with too many of them. This creates confusion. Try to make your arguments as
    independent as possible and not make too many dependencies between them, or handling
    the combinations can be tricky.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 处理命令行参数时的主要不便之处可能是最终拥有太多参数。这会造成混乱。尽量使参数尽可能独立，不要在它们之间建立太多依赖关系，否则处理组合可能会很棘手。
- en: In particular, try to not create more than a couple of positional arguments,
    as they won't have mnemonics. Positional arguments also accept default values,
    but most of the time that won't be the expected behavior.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，尽量不要创建超过一对位置参数，因为它们没有助记符。位置参数也接受默认值，但大多数情况下这不是预期的行为。
- en: For advanced details, check the Python documentation of `argparse` ([https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html)).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 有关详细信息，请查看Python的`argparse`文档（[https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html)）。
- en: See also
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a virtual environment* recipe
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建虚拟环境*食谱'
- en: The *Installing third-party packages* recipe
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安装第三方软件包*食谱'
