- en: Chapter 5. User Inputs and Outputs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章 用户输入和输出
- en: 'In this chapter, we''ll look at the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下示例：
- en: Using features of the print() function
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`print()`函数的特性
- en: Using input() and getpass() for user input
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用input()和getpass()进行用户输入
- en: Debugging with "format".format_map(vars())
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用"format".format_map(vars())进行调试
- en: Using argparse to get command-line input
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用argparse获取命令行输入
- en: Using cmd for creating command-line applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用cmd创建命令行应用程序
- en: Using the OS environment settings
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OS环境设置
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The core value of software is to produce useful output. One simple type of output
    is a text display of some useful result. Python supports this with the `print()`
    function.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 软件的核心价值在于产生有用的输出。一种简单的输出类型是一些有用结果的文本显示。Python通过`print()`函数支持这一点。
- en: The `input()` function has a clear parallel with the `print()` function. The
    `input()` function reads text from a console, allowing us to provide distinct
    values to our programs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`input()`函数与`print()`函数有明显的相似之处。`input()`函数从控制台读取文本，允许我们向程序提供不同的值。'
- en: There are a number of other common ways to provide input. Parsing the command-line
    is also helpful for many applications. We sometimes need to use configuration
    files to provide useful input. Data files and network connections are yet more
    ways to provide input. Each of these is distinct and needs to be looked at separately.
    In this chapter, we'll focus on the fundamentals of `input()` and `print()` .
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他常见的提供输入的方式。解析命令行对于许多应用程序也是有帮助的。有时我们需要使用配置文件来提供有用的输入。数据文件和网络连接是提供输入的更多方式。每种方式都是独特的，需要单独考虑。在本章中，我们将专注于`input()`和`print()`的基础知识。
- en: Using features of the print() function
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`print()`函数的特性
- en: 'In many cases, the `print()` function is the first function we learn. The first
    script is often a variation on the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，`print()`函数是我们学习的第一个函数。第一个脚本通常是以下变体：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We quickly learn that the `print()` function can display multiple values, including
    a helpful space between items.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就学会了`print()`函数可以显示多个值，包括有用的空格。
- en: 'When we write this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们写下这个：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We see that a space is included to separate the two values. Additionally, a
    line break, usually represented by the `\n` character, is printed after the values
    provided in the function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到在两个值之间包括了一个空格。此外，在函数提供的值后打印了一个换行符，通常用`\n`字符表示。
- en: Can we control this formatting? Can we change the extra characters that are
    supplied?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能控制这种格式吗？我们能改变提供的额外字符吗？
- en: It turns out that there are some more things we can do with `print()` .
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 原来我们可以用`print()`做更多的事情。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We have a spreadsheet that is used to record fuel consumption on a large sailboat.
    It has rows that look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个用于记录大帆船燃油消耗的电子表格。它的行看起来像这样：
- en: '| **Date** | **10/25/13** | **10/26/13** | **10/28/13** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: 日期 | 10/25/13 | 10/26/13 | 10/28/13 |
- en: '| **Engine on** | 08:24:00 | 09:12:00 | 13:21:00 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: 发动机开启 | 08:24:00 | 09:12:00 | 13:21:00 |
- en: '| **Fuel height on** | 29 | 27 | 22 |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: 燃油高度 | 29 | 27 | 22 |
- en: '| **Engine off** | 13:15:00 | 18:25:00 | 06:25:00 |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: 发动机关闭 | 13:15:00 | 18:25:00 | 06:25:00 |
- en: '| **Fuel height off** | 27 | 22 | 14 |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: 燃油高度关闭 | 27 | 22 | 14 |
- en: For more information on this data, refer to the *Removing items from a set –
    remove(), pop(), and difference* and *Slicing and dicing a list* recipes in [Chapter
    4](text00048.html#page "Chapter 4. Built-in Data Structures – list, set, dict")
    , *Built-in Data Structures – list, set, dict* . There's no level gauge inside
    the tank. The depth of fuel has to be read through a sight glass on the side of
    the tank, which is why the volume of fuel is stated as a depth. The full depth
    of the tank is about 31 inches, and the volume is about 72 gallons; it's possible
    to convert depth to volume.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些数据的更多信息，请参阅[第4章](text00048.html#page "第4章 内置数据结构 - 列表、集合、字典")中的*从集合中删除项目
    - remove()、pop()和difference*和*对列表进行切片和切块*的示例，*内置数据结构 - 列表、集合、字典*。油箱内没有液位计。燃油的深度必须通过油箱侧面的视镜读取，这就是为什么燃油的容积被陈述为深度。油箱的完整深度约为31英寸，容积约为72加仑；可以将深度转换为容积。
- en: 'Here''s an example of using the CSV data. This function reads the file and
    returns a list of fields built from each row:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用CSV数据的示例。此函数读取文件并返回从每行构建的字段列表：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We used a `pathlib.Path` object to define the location of the raw data. We defined
    a function, `get_fuel_use()` , that will open and read the file at a given path.
    This function creates a list of rows from the source spreadsheet. Each line of
    data is represented as an `OrderedDict` object.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`pathlib.Path`对象来定义原始数据的位置。我们定义了一个名为`get_fuel_use()`的函数，它将打开并读取给定路径的文件。该函数从源电子表格创建了一行行的数据列表。每行数据都表示为一个`OrderedDict`对象。
- en: 'The function starts by creating a `csv.DictReader` object to parse the raw
    data. The reader normally returns a built-in `dict` object, which doesn''t force
    a particular ordering on the keys. To force a particular key order, this function
    uses a generator expression to create an `OrderedDict` object for each row. The
    `fieldnames` attribute of the reader, `rdr` , is used to force the columns into
    a specific order. The generator expression uses a nested pair of loops: one loop
    processes each field of a row and the outer loop processes each row of the data.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先创建一个`csv.DictReader`对象来解析原始数据。读取器通常返回一个内置的`dict`对象，它不会对键强加特定的顺序。为了强制特定的键顺序，该函数使用生成器表达式为每行创建一个`OrderedDict`对象。读取器`rdr`的`fieldnames`属性用于将列强制为特定顺序。生成器表达式使用了一个嵌套的循环对：一个循环处理一行的每个字段，外部循环处理数据的每一行。
- en: The result is a list object that contains the `OrderedDict` objects. This is
    a consistent source of data that we can use for printing. Each row has five fields
    based on the column names in the first row.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含`OrderedDict`对象的列表对象。这是我们可以用于打印的一致的数据源。每行都有基于第一行列名的五个字段。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We have two ways to control the `print()` formatting:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法来控制`print()`的格式：
- en: Set the inter-field separator character, `sep` , which has a space as its default
    value
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置字段间分隔符字符 `sep`，其默认值为一个空格
- en: Set the end-of-line character, `end` , which has the `\n` character as its default
    value
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置行尾字符 `end`，其默认值为 `\n` 字符
- en: We'll show several examples of changing `sep` and `end` . Each is a kind of
    one-step recipe.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示几个更改 `sep` 和 `end` 的示例。每个都是一种一步到位的配方。
- en: 'The default case looks like this. This example has no change to `sep` or `end`
    :'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况如下。这个例子没有改变 `sep` 或 `end`：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When we look at the output, we can see where a space was inserted between each
    item. The `\n` character at the end of each collection of data items means that
    each `print()` function produces a separate line.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看输出时，我们可以看到每个项目之间插入了一个空格。每个数据项集合的末尾的 `\n` 字符意味着每个 `print()` 函数产生一个单独的行。
- en: 'When preparing data, we might want to use a format that''s similar to comma-separated
    values, perhaps using a column separator that''s not a simple comma. Here''s an
    example using  `|` :'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备数据时，我们可能希望使用类似于逗号分隔值的格式，可能使用不是简单逗号的列分隔符。这是一个使用 `|` 的示例：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, we can see that each column has the given separator string. Since
    there were no changes to the `end` setting, each `print()` function produces a
    distinct line of output.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以看到每一列都有给定的分隔符字符串。由于 `end` 设置没有更改，每个 `print()` 函数产生一个不同的输出行。
- en: The most common case seems to be where we want to suppress the separators entirely.
    This gives us a fine degree of control over the output.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的情况似乎是我们想要完全抑制分隔符。这给了我们对输出的精细控制。
- en: 'Here''s how we might change the default punctuation to emphasize the field
    name and value. In this case, we''ve changed the `end` setting:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何改变默认标点以强调字段名称和值。在这种情况下，我们已经更改了 `end` 设置：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since the end string was changed to `,` , each use of the `print()` function
    did not produce a separate line. We didn't get a proper end of line until the
    final `print()` function, which had the default value for `end` .
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于行尾字符串被更改为`,`，每次使用 `print()` 函数都不会产生单独的行。直到最后一个 `print()` 函数，它具有 `end` 的默认值，我们才得到正确的行尾。
- en: Clearly, this technique can get quite complex for anything more sophisticated
    than these simple examples. For something simple, we can tweak the separator or
    ending. For anything more complex, we need to use the `format()` method of a string.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种技术对于比这些简单示例更复杂的任何事情都可能变得非常复杂。对于简单的事情，我们可以调整分隔符或结尾。对于更复杂的事情，我们需要使用字符串的 `format()`
    方法。
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the general case, the `print()` function is a handy wrapper around `stdout.write()`
    . This relationship can be changed, as we'll see next.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般情况下，`print()` 函数是围绕 `stdout.write()` 的一个方便的包装器。这种关系可以被改变，我们将在下面看到。
- en: 'We can imagine that `print()` has a definition something like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象 `print()` 有一个类似于这样的定义：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This provides a hint as to how the the separator string and end string are included
    in the output from the `print()` function. If no value is provided, the default
    values are space and new line. The function iterates through the argument values,
    treating the first value as special because it does not have a separator. This
    approach assures that the separator string, `sep` , appears between values.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了关于分隔符字符串和行尾字符串如何包含在 `print()` 函数输出中的提示。如果没有提供值，则默认值为空格和换行符。该函数通过参数值进行迭代，将第一个值视为特殊值，因为它没有分隔符。这种方法确保分隔符字符串
    `sep` 出现在值之间。
- en: The end of line string, `end` , appears after all of the values. It is always
    written. We can effectively turn it off by setting it to a zero-length string.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 行尾字符串 `end` 出现在所有值之后。它总是被写入。我们可以通过将其设置为空字符串来有效地关闭它。
- en: There's more...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `sys` module defines the two standard output files that are always available:
    `sys.stdout` and `sys.stderr` .'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys` 模块定义了两个始终可用的标准输出文件：`sys.stdout` 和 `sys.stderr`。'
- en: 'We can use the `file=` keyword argument to write to the standard error file
    in addition to the standard output file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `file=` 关键字参数来写入标准错误文件，除了标准输出文件：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've imported the `sys` module so that we have access to the standard error
    file. We used this to write a message that would not be part of the standard output
    stream.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经导入了 `sys` 模块，以便我们可以访问标准错误文件。我们使用它来写入一个不会成为标准输出流的消息。
- en: Generally, we need to be cautious of opening too many output files in a single
    program. The OS limits are usually more than adequate to open many files. However,
    it can become confusing when a program creates a large number of files.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们需要谨慎地在一个程序中打开太多的输出文件。操作系统的限制通常足够打开许多文件。然而，当一个程序创建大量文件时，可能会变得混乱。
- en: 'It often works out nicely to use OS file redirection techniques. A program''s
    primary output can be written to `sys.stdout` ; this is easily redirected at the
    OS level. A user might enter a command line like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，使用操作系统文件重定向技术会很好用。程序的主要输出可以写入 `sys.stdout`；这在操作系统级别很容易重定向。用户可能输入类似这样的命令行：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will provide the `input.dat` file as the input on `sys.stdin` . When the
    Python program writes to `sys.stdout` , the output will be redirected by the OS
    to the `output.dat` object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提供 `input.dat` 文件作为 `sys.stdin` 上的输入。当 Python 程序写入 `sys.stdout` 时，操作系统将输出重定向到
    `output.dat` 对象。
- en: 'In some cases, we need to open additional files. In that case, we might see
    programming like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要打开额外的文件。在这种情况下，我们可能会看到这样的编程：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, we've opened a specific path for output and assigned the open
    file to `target_file` using the `with` statement. We can then use this as the
    `file=` value in a `print()` function to write to this file. Because a file is
    a context manager, leaving the `with` statement means that the file will be closed
    properly and all of the OS resources will be released from the application. All
    file operations should be wrapped in a `with` statement context to ensure that
    the resources are properly released.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们打开了一个特定的输出路径，并使用`with`语句将打开的文件分配给`target_file`。 然后，我们可以将其用作`print()`函数中的`file=`值，以将其写入此文件。
    因为文件是上下文管理器，离开`with`语句意味着文件将被正确关闭，并且所有OS资源将从应用程序中释放。 所有文件操作都应该包装在`with`语句上下文中，以确保资源得到正确释放。
- en: See also
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to the *Debugging with "format".format_map(vars())* recipe
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅*使用"format".format_map(vars())进行调试*配方
- en: For more information on the input data in this example, refer to the *Removing
    items from a set – remove(), pop(), and difference* and *Slicing and dicing a
    list* recipes in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures
    – list, set, dict") , *Built-in Data Structures – list, set, dict*
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关此示例中的输入数据的更多信息，请参阅[第4章](text00048.html#page "第4章。内置数据结构-列表、集合、字典")中的*从集合中删除项目-remove()、pop()和difference*和*切片和切块列表*配方，*内置数据结构-列表、集合、字典*
- en: For more information on file operations in general, refer to [Chapter 9](text00099.html#page
    "Chapter 9. Input/Output, Physical Format, and Logical Layout") , *Input/Output,
    Physical Format, Logical Layout*
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关一般文件操作的更多信息，请参阅[第9章](text00099.html#page "第9章。输入/输出、物理格式和逻辑布局")，*输入/输出、物理格式、逻辑布局*
- en: Using input() and getpass() for user input
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用input()和getpass()进行用户输入
- en: Some Python scripts depend on gathering input from a user. There are several
    ways to do this. One popular technique is to use the console to prompt the user
    for input.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Python脚本依赖于从用户那里收集输入。 有几种方法可以做到这一点。 一种常用的技术是使用控制台提示用户输入。
- en: 'There are two relatively common situations:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种相对常见的情况：
- en: '**Ordinary input** : We use the `input()` function for this. This will provide
    a helpful echo of the characters being entered.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**普通输入**：我们使用`input()`函数。 这将提供正在输入的字符的有用回显。'
- en: '**No echo input** : This is often used for passwords. The characters entered
    aren''t displayed, providing a degree of privacy. We use the `getpass()` function
    in the `getpass` module for this.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无回显输入**：这通常用于密码。 输入的字符不会显示，提供了一定程度的隐私。 我们使用`getpass()`模块中的`getpass()`函数。'
- en: 'The `input()` and `getpass()` functions are just two implementation choices
    for reading from the console. It turns out that getting the string of characters
    is only the first step in processing. We actually have separate tiers of considerations:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`input()`和`getpass()`函数只是从控制台读取的两种实现选择。 结果表明，获取字符的字符串只是处理的第一步。 实际上，我们有单独的考虑层次：'
- en: The initial interaction with the console. This is the basics of writing a prompt
    and reading input. This must correctly handle data as well as keyboard events,
    such as backspace for editing. This may also mean handling end-of-file appropriately.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与控制台的初始交互。 这是编写提示和读取输入的基础。 这必须正确处理数据以及键盘事件，例如用于编辑的退格键。 这也可能意味着适当处理文件结束。
- en: 'Validating the input to see that it belongs in the expected domain of values.
    We might be looking for digits, yes/no values, or days of the week. In most cases,
    there are two parts to the validation tier:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证输入以查看它是否属于预期值域。 我们可能正在寻找数字，是/否值或一周中的某一天。 在大多数情况下，验证层有两个部分：
- en: We check whether the input fits some general domain, for example, numbers.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检查输入是否适合某些一般域，例如数字。
- en: We check whether the input fits some more specific subdomain. For example, this
    might include a check to see if the number is greater than or equal to zero.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检查输入是否适合某些更具体的子域。 例如，这可能包括检查数字是否大于或等于零。
- en: Validating the input in some larger context to ensure that it's consistent with
    other inputs. For example, we can check whether the user's birth date is prior
    to today.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更大的上下文中验证输入，以确保它与其他输入一致。 例如，我们可以检查用户的出生日期是否在今天之前。
- en: Above and beyond these techniques, we'll look at some other approaches in the
    *Using argparse to get command-line input* recipe.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些技术之外，我们将在*使用argparse获取命令行输入*配方中看到一些其他方法。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll look at a technique for reading a complex structure from a person. In
    this case, we'll use the year, month, and day as separate items to create a complete
    date.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一种从人那里读取复杂结构的技术。 在这种情况下，我们将使用年，月和日作为单独的项目来创建完整的日期。
- en: 'Here''s a quick example that omits all of the validation issues:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速的例子，省略了所有验证问题：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This illustrates how easy it is to use the `input()` function. We often need
    to wrap this in additional processing to make it more useful. The calendar is
    complex, and we'd hate to accept February 32 without warning a user that this
    is not a proper date.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了使用`input()`函数有多么容易。 我们经常需要将其包装在额外的处理中，以使其更有用。 日历很复杂，我们不愿意接受2月32日而不警告用户这不是一个正确的日期。
- en: How to do it...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Check whether the input is a password or something equally subject to redaction.
    If so, then use the `getpass.getpass()` function. This means we need to import
    the following function:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查输入是否为密码或同样受到保密的内容。 如果是，则使用`getpass.getpass()`函数。 这意味着我们需要导入以下函数：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Otherwise, if the redacted input is not required, use the `input()` function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果不需要输入，则使用`input()`函数。
- en: Determine which prompt will be used. This might be as simple as `>>>` or something
    more complex. In some cases, we might provide a great deal of contextual information.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定将使用哪个提示。 这可能只是`>>>`或更复杂的东西。 在某些情况下，我们可能会提供大量的上下文信息。
- en: 'In our example, we provided a field name and a hint about the type of data
    expected as a prompt string. The prompt string is the argument to the `input()`
    or `getpass()` function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们提供了一个字段名称和关于预期数据类型的提示作为提示字符串。提示字符串是`input()`或`getpass()`函数的参数：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Determine how to validate each item in isolation. The simplest case is a single
    value with a single rule that covers everything. In more complex cases—like this
    one—each individual element is a number with a range constraint. In a later step,
    we'll look at validating the composite item.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定如何验证每个单独的项目。最简单的情况是一个单一值和一个涵盖所有内容的规则。在更复杂的情况下——比如这个——每个单独的元素都是一个带有范围约束的数字。在后续步骤中，我们将看看如何验证复合项目。
- en: 'We might want to restructure our input to look like this:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可能希望重新构造我们的输入，使其看起来像这样：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This applies two validation rules to the input:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它将两个验证规则应用于输入：
- en: It checks whether the month is a valid integer using the `int()` function
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用`int()`函数检查月份是否是有效的整数
- en: It checks whether the integer is in the range [1, 12] using an `if` statement
    that raises a `ValueError` exception
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用`if`语句检查整数是否在[1, 12]范围内，如果不在范围内则引发`ValueError`异常
- en: Raising an exception for faulty input is generally the simplest approach. It
    allows us the most flexibility. There are other exception classes we might use,
    including defining a customized data validation exception.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于错误的输入引发异常通常是最简单的方法。它允许我们最大的灵活性。我们可能会使用其他异常类，包括定义自定义数据验证异常。
- en: 'Since we''ll use nearly identical loops for each field of a complex object,
    we need to restructure this input and validate the sequence into a separate function.
    We''ll call it `get_integer()` . We''ll look at the details here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将为复杂对象的每个字段使用几乎相同的循环，因此我们需要重新构造此输入并将验证序列转换为一个单独的函数。我们将其称为`get_integer()`。我们将在这里看到详细信息：
- en: 'Validate the composite object. In this case, it also means that our overall
    input needs to be restructured to allow for a retry in the event of bad input:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证复合对象。在这种情况下，这也意味着我们的整体输入需要重新构造，以便在出现错误输入时进行重试：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This overall loop implements the higher level validation of the composite date
    object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个整体循环实现了复合日期对象的高级验证。
- en: Given a year and a month, we can actually determine a slightly more narrow range
    for the number of days. The complexity is that not only do months have different
    numbers of days, varying from 28 to 31, but February has a number of days that
    varies with the type of year.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 给定年份和月份，我们实际上可以确定一个稍微更窄的天数范围。复杂之处在于月份不仅有不同数量的天数，从28到31不等，而且二月的天数还取决于年份的类型。
- en: 'Rather than mimicing the rules, it''s easier to use the `datetime` module to
    compute the first days of two adjacent months, as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与其模仿规则，不如使用`datetime`模块来计算两个相邻月份的第一天，如下所示：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will properly compute the last day of any given month. The algorithm works
    by computing the first day of a given year and month. It then computes the first
    day of the next month. It properly changes the year so that January of `year+1`
    follows December of `year` .
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将正确计算给定月份的最后一天。该算法通过计算给定年份和月份的第一天，然后计算下个月的第一天。它正确地更改年份，以便`year`的一月跟随`year`的十二月。
- en: The number of days between these dates is the number of days in the given month.
    We can use the expression `(day_end_date - day_1_date).days` to extract the number
    of days from the `timedelta` object.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日期之间的天数是给定月份的天数。我们可以使用表达式`(day_end_date - day_1_date).days`从`timedelta`对象中提取天数。
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We need to decompose the input problem into several separate, but closely related
    problems. At the bottom layer is the initial interaction with the user. We identified
    two of the common ways to handle this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将输入问题分解成几个单独但密切相关的问题。在底层是与用户的初始交互。我们确定了两种常见的处理方式：
- en: '`input()` : This prompts and reads simply'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input()`：这只是提示和读取'
- en: '`getpass.getpass()` : This prompts and reads passwords without an echo'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getpass.getpass()`：这会提示并读取密码，而不会回显'
- en: We expect to be able to edit the current line of input using the *Backspace*
    character. In some environments, there is a more sophisticated editor available.
    It's embodied in the Python `readline` module. This module, if present, can add
    a great deal of editing while preparing a line of input. The principle feature
    of this module is an OS-level input history—we can use the up arrow key to recover
    any previous input.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够使用*退格*字符编辑当前输入行。在某些环境中，有一个更复杂的编辑器可用。它体现在Python的`readline`模块中。如果存在该模块，它可以在准备输入行时添加大量编辑。该模块的主要特性是操作系统级的输入历史记录——我们可以使用上箭头键来恢复任何先前的输入。
- en: 'We''ve decomposed the input validation into several tiers to reflect the kind
    of programming required to confirm that the input is valid:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将输入验证分解成几个层次，以反映确认输入是否有效所需的编程类型：
- en: A **general domain** validation should use the simple conversion functions such
    as `int()` or `float()` . These tend to raise exceptions for invalid data. It's
    far simpler to use these conversion functions and handle the exceptions than to
    attempt to write a regular expression that matches valid numeric values.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用域**验证应该使用简单的转换函数，如`int()`或`float()`。这些函数 tend to raise exceptions for invalid
    data.使用这些转换函数并处理异常要简单得多，而不是尝试编写匹配有效数值的正则表达式。'
- en: Our **subdomain** validation must use an `if` statement to determine whether
    values fit any additional constraints, such as ranges, that are imposed. For consistency,
    this should also raise an exception if the data is invalid.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的**子域**验证必须使用`if`语句来确定值是否符合施加的任何其他约束，例如范围。为了保持一致性，如果数据无效，这也应该引发异常。
- en: There are a lot of potential kinds of constraints that might be imposed on values.
    For example, we might want only valid OS process IDs, called PIDs. This requires
    checking the `/proc/<pid>` path on Nanny Linux systems.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会对值施加许多潜在的约束类型。例如，我们可能只想要有效的操作系统进程ID，称为PID。这需要在Nanny Linux系统上检查`/proc/<pid>`路径。
- en: 'For BSD-based systems such as Mac OS X, the `/proc` file system doesn''t exist.
    Instead, something like the following needs to be done to determine if a PID is
    valid:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于BSD的系统，如Mac OS X，`/proc`文件系统不存在。相反，需要执行类似以下的操作来确定PID是否有效：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For Windows, the command would look like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows，命令如下：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Either of these two functions would need to be part of input validation to ensure
    that the user is entering a proper PID value. This can only be applied if the
    primary domain of integers was assured.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数中的任何一个都需要成为输入验证的一部分，以确保用户输入正确的PID值。只有在整数的主要域得到保证时才能应用这一点。
- en: Finally, our overall input function should also raise an exception for invalid
    input. This can vary quite a bit in complexity. We created a simple date object
    in the example. In other cases, we might have to do considerably more processing
    to determine whether a complex input is valid.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的整体输入函数还应该对无效输入引发异常。这可能在复杂性上有很大的变化。在示例中，我们创建了一个简单的日期对象。在其他情况下，我们可能需要进行更多的处理来确定复杂输入是否有效。
- en: There's more...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We have several alternatives for user input that involve slightly different
    approaches. We''ll look at these two topics in detail:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种用户输入的替代方法，涉及略有不同的方法。我们将详细讨论这两个主题：
- en: 'Input string parsing: This will involve simple use of `input()` with clever
    parsing'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入字符串解析：这将涉及对`input()`的简单使用和巧妙的解析
- en: 'Interaction via `cmd` module: This involves a more complex class, and somewhat
    simpler parsing'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`cmd`模块进行交互：这涉及更复杂的类，以及更简单的解析
- en: Input string parsing
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入字符串解析
- en: A simple date value requires three separate fields. A more complex date-time
    that includes a timezone offset from UTC will involve seven separate fields. The
    user experience might be improved by reading and parsing a string rather than
    individual fields.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的日期值需要三个单独的字段。包括与UTC的时区偏移的更复杂的日期时间将涉及七个单独的字段。通过读取和解析字符串而不是单独的字段，用户体验可能会得到改善。
- en: 'For a simple date input, we might use the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的日期输入，我们可以使用以下方法：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We've used the `strptime()` function to parse a time string in a given format.
    We've emphasized the expected date format in the prompt that's provided in the
    `input()` function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`strptime()`函数来解析给定格式的时间字符串。我们在`input()`函数中提供的提示中强调了预期的日期格式。
- en: This style of input requires the user to enter a more complex string. Since
    it's a single string that includes all of the details for a date, many people
    find it as easier and more friendly.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种输入方式要求用户输入更复杂的字符串。由于它是一个包含日期所有细节的单个字符串，许多人发现它更容易和友好。
- en: Note that both techniques—gathering individual fields and processing a complex
    string—depend on the underlying `input()` function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，收集单独字段和处理复杂字符串这两种技术都依赖于底层的`input()`函数。
- en: Interaction via the cmd module
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过cmd模块进行交互
- en: The `cmd` module includes the `Cmd` class that can be used to build an interactive
    interface. This takes a dramatically different approach to the notion of user
    interaction. It does not rely on using `input()` explicitly.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmd`模块包括`Cmd`类，可用于构建交互式界面。这对用户交互的概念采取了截然不同的方法。它不依赖于显式使用`input()`。'
- en: We'll look at this closely in the *Using cmd for creating command-line applications*
    recipe.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*使用cmd创建命令行应用*中仔细研究这一点。
- en: See also
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'In the reference material for the SunOS operating system, which is now owned
    by Oracle, there is a collection of commands that prompt for different kinds of
    user inputs:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在SunOS操作系统的参考资料中，现在由Oracle拥有，有一系列命令提示不同类型的用户输入：
- en: '[https://docs.oracle.com/cd/E19683-01/816-0210/6m6nb7m5d/index.html](https://docs.oracle.com/cd/E19683-01/816-0210/6m6nb7m5d/index.html)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.oracle.com/cd/E19683-01/816-0210/6m6nb7m5d/index.html](https://docs.oracle.com/cd/E19683-01/816-0210/6m6nb7m5d/index.html)'
- en: 'Specifically, all of these commands that begin with `ck` are for gathering
    and validating user input. This could be used to define a module of input validation
    rules:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，所有以`ck`开头的这些命令都是用于收集和验证用户输入的。这可以用来定义输入验证规则的模块：
- en: '`ckdate` : This prompts for and validates a date'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ckdate`：提示并验证日期'
- en: '`ckgid` : This prompts for and validates a group ID'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ckgid`：提示并验证组ID'
- en: '`ckint` : This displays a prompt, verifies, and returns an integer value'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ckint`：显示提示，验证并返回整数值'
- en: '`ckitem` : This builds a menu, prompts for, and returns a menu item'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ckitem`：构建菜单，提示并返回菜单项'
- en: '`ckkeywd` : This prompts for and validates a keyword'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ckkeywd`：提示并验证关键字'
- en: '`ckpath` : This displays a prompt, verifies, and returns a pathname'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ckpath`：显示提示，验证并返回路径名'
- en: '`ckrange` : This prompts for and validates an integer'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ckrange`：提示并验证整数'
- en: '`ckstr` : This displays a prompt, verifies, and returns a string answer'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ckstr`：显示提示，验证并返回字符串答案'
- en: '`cktime` : This displays a prompt, verifies, and returns a time of day'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cktime`：显示提示，验证并返回一天中的时间'
- en: '`ckuid` : This prompts for and validates a user ID'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ckuid`：提示并验证用户ID'
- en: '`ckyorn` : This prompts for and validates yes/no'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ckyorn`：提示并验证是/否'
- en: Debugging with "format".format_map(vars())
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用"format".format_map(vars())进行调试
- en: One of the most important debugging and design tools available in Python is
    the `print()` function. There are some kinds of formatting options available;
    we looked at these in the *Using features of the print() function* recipe.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，最重要的调试和设计工具之一是`print()`函数。有一些格式选项可用；我们在*使用print()函数的特性*中看到了这些。
- en: What if we want more flexible output? We have more flexibility with the `"string".format_map()`
    method. This isn't all. We can couple this with the `vars()` function to create
    something that often leads to a wow!
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更灵活的输出怎么办？使用`"string".format_map()`方法可以提供更多的灵活性。这还不是全部。我们可以将其与`vars()`函数结合使用，创建出令人惊叹的东西！
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s look at a multistep process that involves some moderately complex calculations.
    We''ll compute the mean and standard deviation of some sample data. Given these
    values, we''ll locate all items that are more than one standard deviation above
    the mean:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个涉及一些中等复杂计算的多步过程。我们将计算一些样本数据的平均值和标准差。给定这些值，我们将定位所有比平均值高一个标准差以上的项目：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This calculation has several working variables. The `mean_size` , `std_size`
    , and `sig1` variables all show elements of the final list comprehension that
    filters the `size` list. If the result is confusing or even incorrect, it's helpful
    to know the intermediate steps in the calculation. In this case, because they're
    floating-point values, we often want to round the results so that they're more
    meaningful.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算有几个工作变量。`mean_size`，`std_size`和`sig1`变量都显示了过滤`size`列表的最终列表推导的元素。如果结果令人困惑甚至不正确，了解计算中间步骤是有帮助的。在这种情况下，因为它们是浮点值，我们经常希望四舍五入结果，使其更有意义。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The `vars()` function builds a dictionary structure from a variety of sources.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`vars()`函数从各种来源构建一个字典结构。'
- en: If no arguments are given, then by default, the `vars()` function will expand
    all the local variables. This creates a mapping that can be used with the `format_map()`
    method of a template string.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有给出参数，默认情况下，`vars()`函数将展开所有局部变量。这将创建一个可以与模板字符串的`format_map()`方法一起使用的映射。
- en: 'Using a mapping allows us to inject variables using the variable''s name into
    the format template. It looks as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用映射允许我们将变量的名称插入格式模板中。它看起来像这样：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can put any local variable into the format string. Using `format_map(vars())`
    , we don't need to have a more complex way to pick which variables are going to
    be displayed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任何局部变量放入格式字符串中。使用`format_map(vars())`，我们不需要更复杂的方式来选择要显示的变量。
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `vars()` function builds a dictionary structure from a variety of sources:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`vars()`函数从各种来源构建一个字典结构：'
- en: The `vars()` expression will expand all local variables to create a mapping
    that can be used with the `format_map()` method.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vars()`表达式将展开所有局部变量，以创建一个可以与`format_map()`方法一起使用的映射。'
- en: The `vars(object)` expression will expand all of the items in an object's internal
    `__dict__` attribute. This allows us to expose attributes of class definitions
    and objects. When we look at objects in [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* , we'll see how we
    can leverage this.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vars(object)`表达式将展开对象内部`__dict__`属性中的所有项目。这使我们能够公开类定义和对象的属性。当我们在[第6章](text00070.html#page
    "第6章.类和对象的基础")中查看对象时，我们将看到如何利用这一点。'
- en: The `format_map()` method expects a single argument, which is a mapping. The
    format string uses `{name}` to refer to keys in the mapping. We can use `{name:format}`
    to provide a format specification. We can also use `{name!conversion}` to provide
    a conversion function using the `repr()` , `str()` , or `ascii()` functions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`format_map()`方法期望一个参数，即映射。格式字符串使用`{name}`来引用映射中的键。我们可以使用`{name:format}`来提供格式规范。我们还可以使用`{name!conversion}`来使用`repr()`，`str()`或`ascii()`函数提供转换函数。'
- en: For more background on the formatting options, refer to the *Building complex
    strings with "template".format()* recipe in [Chapter 1](text00014.html#page "Chapter 1. Numbers,
    Strings, and Tuples") , *Numbers, Strings, and Tuples* .
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有关格式选项的更多背景信息，请参考[第1章](text00014.html#page "第1章.数字、字符串和元组")中的*使用"template".format()构建复杂字符串*配方，*数字、字符串和元组*。
- en: There's more...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `format_map(vars())` technique is a simple way to display the values of
    variables. An alternative is to use `format(**vars())` . This alternative can
    give us some additional flexibility.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`format_map(vars())`技术是显示变量值的一种简单方法。另一种方法是使用`format(**vars())`。这种替代方法可以给我们一些额外的灵活性。'
- en: 'For example, we can use this more flexible format to include additional calculations
    that aren''t simply local variables:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用这种更灵活的格式来包括不仅仅是局部变量的额外计算：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We've computed a new value, `sig2` , that appears only inside the formatted
    output.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算了一个新值`sig2`，它只出现在格式化的输出中。
- en: See also
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to the *Building complex strings with "template".format()* recipe in [Chapter
    1](text00014.html#page "Chapter 1. Numbers, Strings, and Tuples") , *Numbers,
    Strings, and Tuples* , for more of the things that can be done with the format()
    method
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考[第1章](text00014.html#page "第1章.数字、字符串和元组")中的*使用"template".format()构建复杂字符串*配方，*数字、字符串和元组*，了解format()方法可以做的更多事情
- en: Refer to the *Using features of the print() function* recipe for other formatting
    options
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关其他格式选项，请参考*使用print()函数的特性*配方
- en: Using argparse to get command-line input
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用argparse获取命令行输入
- en: In some cases, we want to get the user input from the OS command line without
    a lot of interaction. We'd prefer to parse the command-line argument values and
    either perform the processing or report an error.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望从操作系统命令行获取用户输入，而不需要太多交互。我们更希望解析命令行参数值，然后执行处理或报告错误。
- en: 'For example, at the OS level, we might want to run a program like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在操作系统级别，我们可能想要运行这样的程序：
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The OS prompt is `slott$` . We entered a command of `python3 ch05_r04.py` .
    This command had an optional argument, `-r KM` , and two positional arguments
    of `36.12,-86.67` and `33.94,-118.40` .
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统提示符是`slott$`。我们输入了一个命令`python3 ch05_r04.py`。这个命令有一个可选参数`-r KM`，和两个位置参数`36.12,-86.67`和`33.94,-118.40`。
- en: The program parses the command-line arguments and writes the result back to
    the console. This allows for a very simple kind of user interaction. It keeps
    the program very simple. It allows the user to write a shell script to invoke
    the program or merge the program with other Python programs to create a higher
    level program.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序解析命令行参数并将结果写回控制台。这允许一种非常简单的用户交互方式。它使程序非常简单。它允许用户编写一个shell脚本来调用程序或将程序与其他Python程序合并以创建一个更高级的程序。
- en: 'If the user enters something incorrect, the interaction might look like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入了不正确的内容，交互可能会像这样：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: An invalid argument value of `-118asd` leads to an error message. The program
    stopped with an error status code. For the most part, the user can hit the up
    arrow key to get the previous command line back, make a change, and run the program
    again. The interaction is delegated to the OS command line.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无效的参数值“-118asd”导致了一个错误消息。程序以错误状态码停止。在大多数情况下，用户可以按上箭头键获取上一个命令行，进行更改，然后再次运行程序。交互被委托给操作系统命令行。
- en: The name of the program—`ch05_r04` —isn't too informative. We could perhaps
    do better. The positional arguments are two (latitude, longitude) pairs. The output
    shows the distance between the two in the given units.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的名称“ch05_r04”并不是太具有信息性。也许我们可以做得更好。位置参数是两个（纬度，经度）对。输出显示了给定单位下两者之间的距离。
- en: How do we parse argument values from the command line?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从命令行解析参数值？
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The first thing we need to do is to refactor our code to create two separate
    functions:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是重构我们的代码，创建两个单独的函数：
- en: A function to get the arguments from the command line. Owing to the way in which
    the `argparse` module works, this function will almost always return an `argparse.Namespace`
    object.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行获取参数的函数。由于`argparse`模块的工作方式，这个函数几乎总是会返回一个`argparse.Namespace`对象。
- en: A function which does the real work. This function should be designed so that
    it makes no reference to the command-line options in any way. This means it can
    be reused in a variety of contexts.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个执行真正工作的函数。这个函数应该被设计成在任何情况下都不引用命令行选项。这意味着它可以在各种情境中被重复使用。
- en: 'Here''s our *real work* function, `display()` :'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的*真正工作*函数，“display()”：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've imported the core calculation, `haversine()` , from another module. We've
    provided argument values to this function and used `format()` to display the final
    result message.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从另一个模块导入了核心计算“haversine()”。我们为这个函数提供了参数值，并使用“format()”来显示最终的结果消息。
- en: 'We''ve based this on the calculations shown in the examples in the *Picking
    an order for parameters based on partial functions* recipe in [Chapter 3](text00039.html#page
    "Chapter 3. Function Definitions") , *Function Definitions* :'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基于[第3章](text00039.html#page "第3章。函数定义")中的*根据部分函数选择参数顺序*食谱中的示例中显示的计算，*函数定义*：
- en: '![Getting ready](Image00012.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](Image00012.jpg)'
- en: The essential calculation yields the central angle, *c* , between two points,
    given as ( *lat[1]* , *lon[1]* ) and ( *lat[2]* , *lon[2]* ). The angle is measured
    in radians. We convert it into distance by multiplying it by the Earth's mean
    radius in some units. If we multiply the angle *c* by a radius of 3,959 miles,
    we'll get the distance represented by the angle in miles.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 基本计算产生了两点之间的中心角*c*，给定为（*lat[1]*，*lon[1]*）和（*lat[2]*，*lon[2]*）。角度以弧度表示。我们通过将其乘以地球的平均半径来将其转换为距离。如果我们将角度*c*乘以3959英里的半径，我们将得到以英里表示的角度距离。
- en: Note that we expect the distance conversion factor, *r* , to be provided as
    a string. This function will then map the string to an actual floating-point value.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们期望距离转换因子*r*以字符串形式提供。然后，这个函数将字符串映射到实际的浮点值。
- en: For details on the `format()` method, note that we're using a variation on the
    *Debugging with "format".format_map(vars())* recipe.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有关“format()”方法的详细信息，请注意我们正在使用“Debugging with "format".format_map(vars())”食谱的变体。
- en: 'Here''s how the function looks when it''s used inside Python:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当它在Python中使用时，函数的样子如下：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This function has two important design features. The first feature is that it
    avoids references to features of the `argparse.Namespace` object that's created
    by argument parsing. Our goal is to have a function that we can reuse in a number
    of alternative contexts. We need to keep the input and output elements of the
    user interface separate.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有两个重要的设计特点。第一个特点是它避免了对由参数解析创建的`argparse.Namespace`对象的特性的引用。我们的目标是拥有一个可以在许多替代上下文中重复使用的函数。我们需要保持用户界面的输入和输出元素分开。
- en: The second design feature is that this function displays a value computed by
    another function. This is a helpful feature because it lets us decompose the problem.
    We've separated the user experience from the essential calculation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个设计特点是，这个函数显示了另一个函数计算出的值。这是一个有用的特性，因为它让我们分解问题。我们已经将用户体验与基本计算分开。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Define the overall argument parsing function:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义整体参数解析函数：
- en: '[PRE26]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create the `parser` object:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建“解析器”对象：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Add the various types of arguments to the `parser` object. Sometimes this is
    difficult because we're still refining the user experience. It's difficult to
    imagine all the ways in which people will use a program and all of the questions
    they might have.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向“解析器”对象添加各种类型的参数。有时这很困难，因为我们仍在完善用户体验。很难想象人们会如何使用程序以及他们可能会有的所有问题。
- en: 'For our example, we have two mandatory, positional arguments, and an optional
    argument:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们有两个强制的位置参数和一个可选参数：
- en: Point 1 latitude and longitude
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点1的纬度和经度
- en: Point 2 latitude and longitude
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点2的纬度和经度
- en: Optional distance
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选距离
- en: 'We can use Nautical Miles as a handy default so that sailors get the answers
    they need:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用海里作为一个方便的默认值，这样水手们就可以得到他们需要的答案：
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We''ve added two kinds of arguments. The first is the `-r` , argument, which
    starts with `-` to mark it as optional. Sometimes, a `--` is used with a longer
    name. In some cases, we''ll provide both alternatives, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两种类型的参数。第一个是“-r”参数，以“-”开头标记为可选。有时，一个长名称会用“--”表示。在某些情况下，我们将提供这两种选择，如下所示：
- en: '[PRE29]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The action is to store the value which follows the `-r` on the command-line.
    We've listed the three possible choices and provided a default. The parser will
    validate the input and write appropriate errors if the input isn't one of these
    three values.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 动作是存储在命令行上跟在“-r”后面的值。我们列出了三种可能的选择并提供了默认值。解析器将验证输入，如果输入不是这三个值之一，将写入适当的错误。
- en: The mandatory arguments are provided without a `-` prefix. We used an action
    of `store` ; this is the default action and doesn't really need to be stated.
    The function provided as the `type` argument is used to convert the source string
    to an appropriate Python object. This is also the ideal way to validate complex
    input values. We'll look at the `point_type()` validation function int this section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 强制参数不带`-`前缀。我们使用了`store`的操作；这是默认操作，实际上不需要声明。作为`type`参数提供的函数用于将源字符串转换为适当的Python对象。这也是验证复杂输入值的理想方式。我们将在本节中查看`point_type()`验证函数。
- en: 'Evaluate the `parse_args()` method of the parser object created in step 2:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估步骤2中创建的解析器对象的`parse_args()`方法：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: By default, this uses the values from `sys.argv` , which are the command-line
    argument values entered by the user. We can provide an explicit argument if we
    need to modify the user-supplied command-line in some way.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这使用来自`sys.argv`的值，这些值是用户输入的命令行参数值。如果需要以某种方式修改用户提供的命令行，我们可以提供一个显式参数。
- en: 'Here''s the final function:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最终的函数：
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This relies on the `point_type()` validation function. This is needed because
    the default input type is defined by the `str()` function. This assures that the
    values of arguments will be string objects. We've provided the `type` argument
    so that we can inject a type conversion. We might use `type = int` or `type =
    float` to convert to a number.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这依赖于`point_type()`验证函数。这是因为默认输入类型由`str()`函数定义。这确保参数的值将是字符串对象。我们提供了`type`参数，以便我们可以注入类型转换。我们可以使用`type
    = int`或`type = float`进行转换为数字。
- en: 'In our example, we used `point_type()` to convert a string to a ( *latitude*
    , *longitude* ) two-tuple:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用`point_type()`将字符串转换为（*纬度*，*经度*）二元组：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function parses the input values. First, it separates the two values at
    the `,` character. It attempts a floating-point conversion on each part. If the
    `float()` functions both work, we have a valid latitude and longitude that we
    can return as a pair of floating-point values.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数解析输入值。首先，它在`,`字符处分隔两个值。它尝试对每个部分进行浮点转换。如果`float()`函数都有效，则我们有一个有效的纬度和经度，可以将其作为一对浮点值返回。
- en: If anything goes wrong, an exception will be raised. From this exception, we'll
    raise an `ArgumentTypeError` exception. This is used by the `argparse` module
    to report the error to the user.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现任何问题，将引发异常。从这个异常中，我们将引发一个`ArgumentTypeError`异常。这是由`argparse`模块用于向用户报告错误。
- en: 'Here''s the main script that combines the option parser and the output display
    functions:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结合选项解析器和输出显示函数的主要脚本：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This main script does a few things to connect the user inputs to the displayed
    output:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主要脚本做了一些事情，将用户输入连接到显示的输出：
- en: Parse the command-line options. These are all present in the options object.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析命令行选项。这些都存在于选项对象中。
- en: Expand the `p1` and `p2` ( *latitude* , *longitude* ) two-tuples into four individual
    variables.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`p1`和`p2`（*纬度*，*经度*）二元组扩展为四个单独的变量。
- en: Evaluate the `display()` function.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估`display()`函数。
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The argument parser works in three stages:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 参数解析器分为三个阶段：
- en: Define the overall context by creating a parser object as an instance of `ArgumentParser`
    . We can provide information such as the overall program description. We can also
    provide a formatter and other options here.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建`ArgumentParser`的实例作为解析器对象来定义整体上下文。我们可以提供诸如整体程序描述之类的信息。我们还可以在这里提供格式化程序和其他选项。
- en: Add individual arguments with the `add_argument()` method. These can include
    optional arguments as well as required arguments. Each argument can have a number
    of features to provide different kinds of syntax. We'll look at a number of the
    alternatives in the *There's more...* section.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`add_argument()`方法添加单个参数。这些可以包括可选参数以及必需参数。每个参数都可以具有多种功能，以提供不同种类的语法。我们将在*还有更多...*部分中查看一些替代方案。
- en: Parse the actual command-line inputs. The parser's `parse()` method will use
    `sys.argv` automatically. We can provide an explicit value instead of the `sys.argv`
    values. The most common reason for providing an override value is to allow for
    more complete unit testing.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析实际的命令行输入。解析器的`parse()`方法将自动使用`sys.argv`。我们可以提供一个显式值，而不是`sys.argv`的值。提供覆盖值的最常见原因是允许进行更完整的单元测试。
- en: Some simple programs will have a few optional arguments. A more complex program
    may have many optional arguments.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一些简单的程序将具有一些可选参数。更复杂的程序可能有许多可选参数。
- en: 'It''s common to have a filename as a positional argument. When a program reads
    one or more files, the filenames are provided on the command line, as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在位置参数中有一个文件名。当程序读取一个或多个文件时，文件名将在命令行上提供，如下所示：
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We''ve used the Linux shell''s **globbing** feature—the `*.rst` string is expanded
    into a list of all files that match the naming rule. This list of files can be
    processed using an argument defined as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了Linux shell的**globbing**功能——`*.rst`字符串扩展为符合命名规则的所有文件的列表。可以使用以下参数定义的文件列表进行处理：
- en: '[PRE35]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All of the names on the command line that do not start with the `-` character
    will be collected into the `file` value in the object built by the parser.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行上所有不以`-`字符开头的名称都将被收集到解析器构建的对象的`file`值中。
- en: 'We can then use the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用以下内容：
- en: '[PRE36]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will process each file given on the command line.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这将处理命令行中给定的每个文件。
- en: For Windows programs, the shell doesn't glob, and the application must deal
    with filenames that have wild card patterns in them. The Python `glob` module
    can help with this. Also, the `pathlib` module can create `Path` objects, which
    include globbing features.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows程序，shell不进行glob操作，应用程序必须处理其中包含通配符模式的文件名。Python的`glob`模块可以帮助解决这个问题。此外，`pathlib`模块可以创建包括globbing功能的`Path`对象。
- en: We may have to make even more complex argument parsing options. Very complex
    applications may have dozens of individual commands. As an example, look at the
    `git` version-control program; this application uses dozens of separate commands
    such as `git clone` , `git commit` , or `git push` . Each of these commands has
    unique argument parsing requirements. We can use `argparse` to create a complex
    hierarchy of these commands and their distinct sets of arguments.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要进行更复杂的参数解析选项。非常复杂的应用程序可能有数十个单独的命令。例如，看看`git`版本控制程序；该应用程序使用数十个单独的命令，如`git
    clone`，`git commit`或`git push`。每个命令都有独特的参数解析要求。我们可以使用`argparse`来创建这些命令及其不同参数集的复杂层次结构。
- en: There's more...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'What kinds of arguments can we process? There are a lot of argument styles
    in common use. All of these variations are defined using the `add_argument()`
    method of a parser:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以处理什么样的参数？常见的使用中有很多参数样式。所有这些变化都是使用解析器的`add_argument()`方法来定义的：
- en: '**Simple options** : The `-o` or `--option` arguments are often used to enable
    or disable features of a program. These are often implemented with `add_argument()`
    parameters of `action=''store_true'', default=False` . Sometimes the implementation
    is simpler if the application uses `action=''store_false'', default=True` . The
    choice of default value and stored value may simplify the programming, but it
    won''t change the user''s experience.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单选项**：`-o`或`--option`参数通常用于启用或禁用程序的功能。这些通常使用`add_argument()`参数`action=''store_true''，default=False`来实现。有时，如果应用程序使用`action=''store_false''，default=True`，实现会更简单。默认值和存储值的选择可能简化编程，但不会改变用户的体验。'
- en: '**Simple options with non-trivial objects** : The user sees this is as simple
    `-o` or `--option` arguments. We may want to implement this using a more complex
    object that''s not a simple Boolean constant. We can use `action=''store_const'',
    const=some_object, default=another_object` . As modules, classes, and functions
    are also objects, a great deal of sophistication is available here.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带非平凡对象的简单选项**：用户将其视为简单的`-o`或`--option`参数。我们可能希望使用更复杂的对象来实现这一点，而不是简单的布尔常量。我们可以使用`action=''store_const''，const=some_object，default=another_object`。由于模块、类和函数也是对象，因此这里可以使用大量的复杂性。'
- en: '**Options with values** : We showed `-r unit` as an argument that accepted
    the string name for the units to use. We implemented this with an `action=''store''`
    assignment to store the supplied string value. We can also use the `type=function`
    option to provide a function that validates or converts the input into a useful
    form.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带值的选项**：我们展示了`-r unit`作为接受单位名称的字符串的参数。我们使用`action=''store''`来存储提供的字符串值。我们还可以使用`type=function`选项来提供验证或将输入转换为有用形式的函数。'
- en: '**Options that increment a counter** : One common technique is to have a debugging
    log that has multiple levels of detail. We can use `action=''count'', default=0`
    to count the number of times a given argument is present. The user can provide
    `-v` for verbose output and `-vv` for very verbose output. The argument parser
    treats `-vv` as two instances of the `-v` argument, which means that the value
    will increase from the initial value of `0` to `2` .'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加计数器的选项**：一种常见的技术是具有多个详细级别的调试日志。我们可以使用`action=''count''，default=0`来计算给定参数出现的次数。用户可以提供`-v`以获得详细输出，`-vv`以获得非常详细的输出。参数解析器将`-vv`视为`-v`参数的两个实例，这意味着值将从初始值`0`增加到`2`。'
- en: '**Options that accumulate a list** : We might have an option for which the
    user might want to provide more than one value. We could, for example, use a list
    of distance values. We could have an argument definition with `action=''append'',
    default=[]` . This would allow the user to say `-r NM -r KM` to get a display
    in both nautical miles and kilometers. This would require a significant change
    to the `display()` function, of course, to handle multiple units in a collection.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**累积列表的选项**：我们可能有一个选项，用户可能希望提供多个值。例如，我们可以使用一个距离值列表。我们可以使用`action=''append''，default=[]`的参数定义。这将允许用户说`-r
    NM -r KM`以便同时显示海里和公里。当然，这将需要对`display()`函数进行重大更改，以处理集合中的多个单位。'
- en: '**Show the help text** : If we do nothing, then `-h` and `--help` will display
    a help message and exit. This will provide the user with useful information. We
    can disable this or change the argument string, if we need to. This is a widely
    used convention, so it seems best to do nothing so that it''s a feature of our
    program.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示帮助文本**：如果我们什么都不做，那么`-h`和`--help`将显示帮助消息并退出。这将为用户提供有用的信息。如果需要，我们可以禁用此功能或更改参数字符串。这是一个广泛使用的惯例，所以最好什么都不做，这样它就成为我们程序的一个特性。'
- en: '**Show the version number** : It''s common to have `--Version` as an argument
    to display the version number and exit. We implement this with `add_argument("--Version",
    action="version", version="v 3.14")` . We provide an action of `version` and an
    additional keyword argument that sets the version to display.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示版本号**：通常会有`--Version`作为一个参数来显示版本号并退出。我们使用`add_argument("--Version"，action="version"，version="v
    3.14")`来实现这一点。我们提供一个`version`动作和一个额外的关键字参数来设置要显示的版本。'
- en: This covers most of the common cases for command-line argument processing. Generally,
    we'll try to leverage these common styles of arguments when we write our own applications.
    If we strive to use simple, widely used argument styles, our users are somewhat
    more likely to understand how our application works.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了大多数命令行参数处理的常见情况。通常，我们在编写自己的应用程序时会尝试利用这些常见的参数样式。如果我们努力使用简单、广泛使用的参数样式，我们的用户可能更容易理解我们的应用程序的工作方式。
- en: There are a few Linux commands, which have even more complex command-line syntax.
    Some Linux programs, such as `find` or `expr` , have arguments that can't easily
    be processed by `argparse` . For these edge cases, we would need to write our
    own parser using the values of `sys.argv` directly.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些Linux命令，其命令行语法甚至更复杂。一些Linux程序，如`find`或`expr`，具有`argparse`无法轻松处理的参数。对于这些边缘情况，我们需要直接使用`sys.argv`的值编写自己的解析器。
- en: See also
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We looked at how to get interactive user input in the *Using input() and getpass()
    for user input* recipe
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看了如何在*使用input()和getpass()进行用户输入*配方中获得交互式用户输入
- en: We'll look at a way to add even more flexibility to this in the *Using the OS
    environment settings*  recipe
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在*使用OS环境设置*配方中看到如何为此添加更多的灵活性
- en: Using cmd for creating command-line applications
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cmd创建命令行应用程序
- en: There are several ways of creating interactive applications. The *Using input()
    and getpass() for user input* recipe looked at functions such as `input()` and
    `getpass.getpass()` . The *Using* *argparse to get command-line input* recipe
    showed how to use `argparse` to create applications with which a user can interact
    from the OS command line.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种创建交互式应用程序的方法。*使用input()和getpass()进行用户输入*配方查看了诸如`input()`和`getpass.getpass()`之类的函数。*使用argparse获取命令行输入*配方展示了如何使用`argparse`创建可以从操作系统命令行与用户交互的应用程序。
- en: We have a third way to create interactive applications using the `cmd` module.
    This module will prompt the user for input, and then invoke a specific method
    of the class we provide.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有第三种方法来创建交互式应用程序，使用`cmd`模块。该模块将提示用户输入，然后调用我们提供的类的特定方法。
- en: This is related to material in [Chapter 7](text00079.html#page "Chapter 7. More
    Advanced Class Design") , *More Advanced Class Design* . We'll add features to
    a class definition to create a unique subclass.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这与[第7章](text00079.html#page "第7章. 更高级的类设计")中的内容相关，*更高级的类设计*。我们将添加功能到类定义中，以创建一个独特的子类。
- en: 'Here''s how the interaction will look, we''ve marked user input like this:
    "`help` ":'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 交互将如下所示，我们已标记用户输入如下：“`help`”：
- en: '[PRE37]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There's an introductory message from the application. It shows the player's
    starting stake, that is, how much they have to bet. The application displays a
    prompt, `Roulette>` . The user can then enter any of the five available commands.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序有一个介绍性消息。它显示玩家的起始赌注，也就是他们有多少赌注。应用程序显示一个提示，`Roulette>`。用户可以输入五个可用命令中的任何一个。
- en: When we enter `help` as a command, we see a display of the available commands.
    Only two have any documentation. The other three have no further details available.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入`help`作为命令时，我们会看到可用命令的显示。只有两个有任何文档。其他三个没有更多的详细信息可用。
- en: When we enter `help bet` , we see the detailed documentation for the `bet` command.
    The description tells us to provide a bet name from the available six choices
    and a bet amount.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入`help bet`时，我们会看到`bet`命令的详细文档。描述告诉我们要从可用的六个选择中提供一个赌注名称和一个赌注金额。
- en: We create two bets—one on black and one on even. We then enter the `spin` command
    to spin the wheel. This displays the outcome—the number `21` —which is red, high,
    and odd. Both of our bets are losses.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个赌注——一个在黑色上，一个在偶数上。然后我们输入`spin`命令来旋转轮盘。这显示了结果——数字`21`——是红色的，高的，奇数的。我们的两个赌注都输了。
- en: We've omitted a few more interactions that didn't win very much, either. When
    we entered the `done` command, the final stake was shown. If the simulation was
    more detailed, it might also show some aggregate statistics on spins, wins, and
    losses.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了一些没有赢得太多的其他交互。当我们输入`done`命令时，最终的赌注会显示出来。如果模拟更详细，它可能还会显示一些有关旋转、赢和输的汇总统计数据。
- en: Getting ready
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The core feature of the `cmd.Cmd` application is a **read-evaluate-print loop**
    ( **REPL** ). This kind of application works well when there are a large number
    of individual state changes and a large number of commands to make those state
    changes.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmd.Cmd`应用程序的核心特性是**读取-求值-打印循环**（**REPL**）。当有大量单独的状态更改和大量命令来进行这些状态更改时，这种应用程序运行良好。'
- en: 'We''ll use a simple simulation of a subset of the bets in *Roulette* as an
    example. The idea is to allow the user to create one or more bets and then spin
    a simulated *Roulette* wheel. While proper casino *Roulette* has a dizzying array
    of possible bets, we''ll focus on just six:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用*轮盘*中一部分赌注的简单模拟作为示例。想法是允许用户创建一个或多个赌注，然后旋转模拟的*轮盘*。虽然正规的赌场*轮盘*有许多可能的赌注，但我们将只关注其中的六个：
- en: red, black
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红，黑
- en: even, odd
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偶数，奇数
- en: high, low
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高，低
- en: An *American Roulette* wheel has 38 bins. The numbers 1 to 36 are colored red
    and black. There are two other bins, zero and double zero, which are green. These
    two extra bins are defined as neither even nor odd and neither high nor low. There
    are only a few ways to bet on the zeroes, but numerous ways to bet on numbers.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*美式轮盘*有38个箱子。1到36号是红色和黑色的。还有两个箱子，0和00，是绿色的。这两个额外的箱子被定义为既不是偶数也不是奇数，也不是高也不是低。在零上下注的方式很少，但在数字上下注的方式很多。'
- en: We'll represent the *Roulette* wheel using some helper functions that build
    a collection of bins. Each bin will have a string that shows the number and a
    set of bet names that are winners.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一些辅助函数来表示*轮盘*轮，这些函数构建了一个箱子集合。每个箱子都有一个显示数字的字符串和一组赢家的赌注名称。
- en: 'We can define a generic bin with some simple rules to determine which bets
    are in the winning set:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个通用的箱子，使用一些简单的规则来确定哪些赌注属于获胜集合：
- en: '[PRE38]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `roulette_bin()` function returns a two-tuple with the string representation
    for the bin number and a set of three winning propositions.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`roulette_bin()`函数返回一个包含箱子编号的字符串表示和一组三个获胜提议的双元组。'
- en: 'For `0` and `00` , we''ll need something a little different:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`0`和`00`，我们需要一些不同的东西：
- en: '[PRE39]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `zero_bin()` function returns a string bin number and an empty set. The
    `zerozero_bin()` function returns a special string to show that it's `00` , plus
    the empty set to show that none of the defined bets are winners.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`zero_bin()`函数返回一个字符串箱子编号和一个空集。`zerozero_bin()`函数返回一个特殊字符串来显示它是`00`，加上一个空集来显示没有定义的赌注是赢家。'
- en: 'We can combine the results of these three functions to create a complete *Roulette*
    wheel. The whole wheel will be modeled as a list of bin tuples:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以结合这三个函数的结果来创建一个完整的*轮盘*轮。整个轮盘将被建模为一个箱子元组的列表：
- en: '[PRE40]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''ve built a simple list that contains the complete set of bins: a zero,
    a double zero, and the numbers 1 through 36\. We can now use the `random.choice()`
    function to select a bin at random. This will tell us which bets win and which
    bets lose.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建立了一个简单的列表，其中包含完整的一组轮盘号码：一个零，一个双零，以及1到36的数字。现在我们可以使用`random.choice()`函数随机选择一个轮盘号码。这将告诉我们哪些赌注赢了，哪些输了。
- en: How to do it...
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import the cmd module:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入cmd模块：
- en: '[PRE41]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Define an extension to `cmd.Cmd` :'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义对`cmd.Cmd`的扩展：
- en: '[PRE42]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Define any initialization required in the `preloop()` method:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`preloop()`方法中定义所需的任何初始化：
- en: '[PRE43]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This `preloop()` method is evaluated just once when the processing starts. We've
    used this to initialize a dictionary for bets and the player's stake. We also
    created an instance of the wheel collection. The self argument is a requirement
    for methods within a class. For now, it's a simply required syntax. In [Chapter
    6](text00070.html#page "Chapter 6. Basics of Classes and Objects") , *Basics of
    Classes and Objects* , we'll look at this more closely.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理开始时，`preloop()`方法只被评估一次。我们用它来初始化赌注和玩家的赌注的字典。我们还创建了一个轮盘集合的实例。self参数是类内方法的要求。现在，它只是一个简单的必需语法。在[第6章](text00070.html#page
    "第6章。类和对象的基础")中，*类和对象的基础*，我们将更仔细地研究这个问题。
- en: Note that this is indented within the `class` statement.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是在`class`语句内缩进的。
- en: Initialization can also be done in the `__init__()` method. This is a bit more
    complex, though, because we have to use `super()` to ensure that the `Cmd` class
    initialization is done first.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化也可以在`__init__()`方法中完成。不过，这有点复杂，因为我们必须使用`super()`来确保首先完成`Cmd`类的初始化。
- en: 'For each command, create a `do_command()` method. The name of the method will
    be the command, prefixed by `do_` . The user''s input text after the command will
    be provided as an argument value to the method. Here are two examples for the
    `bet` command and the `spin` command:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个命令，创建一个`do_command()`方法。方法的名称将是命令，前缀为`do_`。命令后用户输入的文本将作为参数值提供给方法。以下是`bet`命令和`spin`命令的两个示例：
- en: '[PRE44]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Parse and validate the arguments to each command. The user's input after the
    command will be provided as the value of the first positional argument to the
    method.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析和验证每个命令的参数。命令后用户输入的内容将作为方法的第一个位置参数的值提供。
- en: If the arguments are invalid, the method should print a message and return.
    If the arguments are valid, the method can continue past the validation step.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数无效，方法应该打印一条消息并返回。如果参数有效，方法可以继续通过验证步骤。
- en: For our example, the `spin` command doesn't require any input. We can ignore
    the argument string. To be more complete, we might want to display an error if
    the string is non-empty.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的例子，`spin`命令不需要任何输入。我们可以忽略参数字符串。为了更完整，我们可能希望在字符串非空时显示错误。
- en: The `bet` command, however, does have a bet, which must be one of the six valid
    bet names. We might want to check for duplicate bets. We might also want to check
    for abbreviated bet names. Each of six bets has a unique first letter.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`bet`命令确实有一个赌注，它必须是六个有效的赌注名称之一。我们可能想要检查重复的赌注。我们可能还想要检查缩写的赌注名称。六个赌注中的每一个都有一个独特的首字母。
- en: 'As an extension, a bet can also have an amount. We looked at parsing strings
    in the *String parsing with regular expressions* recipe in [Chapter 1](text00014.html#page
    "Chapter 1. Numbers, Strings, and Tuples") , *Numbers, Strings, and Tuples* .
    For this example, we''ll simply handle the name of the bet:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 作为扩展，赌注也可以有一个金额。我们在[第1章](text00014.html#page "第1章。数字、字符串和元组")中的*使用正则表达式解析字符串*一节中研究了解析字符串的方法。在这个例子中，我们将简单处理赌注的名称：
- en: '[PRE45]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Write the happy path processing for each command. For our example, the `spin`
    command will resolve the bets. The `bet` command will accumulate another bet.
    Here''s the `do_bet()` happy path:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个命令编写顺利路径处理。对于我们的例子，`spin`命令将解决赌注。`bet`命令将累积另一个赌注。这是`do_bet()`的顺利路径：
- en: '[PRE46]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We've added the user's bet to the `self.bets` mapping with the amount. For this
    example, we'll treat all bets as having the same minimal amount.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将用户的赌注添加到`self.bets`映射中，并标明了金额。在这个例子中，我们将所有的赌注都视为具有相同的最小金额。
- en: 'Here''s the `do_spin()` happy path that resolves all of the bets:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`do_spin()`的顺利路径，解决了所有的赌注：
- en: '[PRE47]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, we spun the wheel to get a winning bet. Then, we examined each of the
    player's bets to see which of those match the set of winning bets. If the player's
    bet, `b` , is in the set of winning bets, we'll increase their stake. Otherwise,
    we'll reduce their stake.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们旋转轮盘以获得一个获胜的赌注。然后，我们检查玩家的每个赌注，看看哪些与获胜的赌注匹配。如果玩家的赌注`b`在获胜的赌注集合中，我们将增加他们的赌注。否则，我们将减少他们的赌注。
- en: All of the bets in this example pay 1:1\. If we want to extend the example to
    other kinds of bets, we have to provide proper odds for the various bets.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有的赌注都是1:1。如果我们想要扩展到其他类型的赌注，我们必须为各种赌注提供适当的赔率。
- en: 'Write the main script. This will create an instance of this class and execute
    the `cmdloop()` method:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写主脚本。这将创建该类的一个实例并执行`cmdloop()`方法：
- en: '[PRE48]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We've created an instance of our `Roulette` subclass of `Cmd` . When we execute
    the `cmdloop()` method, the class will write any introductory messages that have
    been provided, write the prompt, and read a command.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`Cmd`子类`Roulette`的一个实例。当我们执行`cmdloop()`方法时，该类将写入任何提供的介绍性消息，写入提示符，并读取命令。
- en: How it works...
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Cmd` module contains a large number of built-in features for displaying
    a prompt, reading input from a user, and then locating the proper method based
    on the user's input.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cmd`模块包含大量内置功能，用于显示提示符，从用户那里读取输入，然后根据用户的输入找到正确的方法。'
- en: For example, when we enter `bet black` , the built-in methods of the `Cmd` superclass
    will strip the first word from the input, `bet` , prefix this with `do_` , and
    then evaluate the method that implements the command.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们输入`bet black`时，`Cmd`超类的内置方法将从输入中剥离第一个单词`bet`，将其前缀为`do_`，然后评估实现该命令的方法。
- en: If there's no `do_bet()` method, the command processor writes an error message.
    This is done automatically, we don't need to write any code at all.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 `do_bet()` 方法，命令处理器将写入错误消息。这是自动完成的，我们不需要编写任何代码。
- en: Since we wrote a `do_bet()` method, this will be invoked. The text after the
    command, `black` in this case, will be provided as the positional argument value.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们编写了一个 `do_bet()` 方法，这将被调用。在这种情况下，命令后的文本 `black` 将作为位置参数值提供。
- en: Some methods, such as `do_help()` , are already part of the application. These
    methods will summarize the other `do_*` methods. When one of our methods has a
    docstring, this can be displayed by the built-in help feature.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方法，如 `do_help()` ，已经是应用程序的一部分。这些方法将总结其他 `do_*` 方法。当我们的方法有文档字符串时，这可以通过内置的帮助功能显示出来。
- en: The `Cmd` class relies on Python's facilities for introspection. An instance
    of the class can examine the method names to locate all of the methods that start
    with `do_` . They're available in a class-level `__dict__` attribute. Introspection
    is an advanced topic, one that will be touched on in [Chapter 7](text00079.html#page
    "Chapter 7. More Advanced Class Design") , *More Advanced Class Design* .
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cmd` 类依赖于Python的内省功能。类的实例可以检查方法名称，以定位所有以 `do_` 开头的方法。它们在类级别的 `__dict__` 属性中可用。内省是一个高级主题，将在[第7章](text00079.html#page
    "第7章。更高级的类设计")中涉及，*更高级的类设计*。'
- en: There's more...
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Cmd` class has a number of additional places where we can add interactive
    features:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cmd` 类有许多其他地方可以添加交互功能：'
- en: We can define `help_*()` methods that become part of the miscellaneous help
    topics.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以定义 `help_*()` 方法，这些方法将成为杂项帮助主题的一部分。
- en: When any of the `do_*` methods return a value, the loop will end. We might want
    to add a `do_quit()` method that has `return True` as it's body. This will end
    the command-processing loop.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任何 `do_*` 方法返回一个值时，循环将结束。我们可能想要添加一个 `do_quit()` 方法，其主体为 `return True`。这将结束命令处理循环。
- en: We might provide a method named `emptyline()` to respond to blank lines. One
    choice is to do nothing quietly. Another common choice is to have a default action
    that's taken when the user doesn't enter a command.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能会提供一个名为 `emptyline()` 的方法来响应空行。一种选择是安静地什么也不做。另一个常见选择是当用户不输入命令时采取默认操作。
- en: The `default()` method is evaluated when the user's input does not match any
    of the `do_*` methods. This might be used for more advanced parsing of the input.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户的输入与任何 `do_*` 方法都不匹配时，将评估 `default()` 方法。这可能用于更高级的输入解析。
- en: The `postloop()` method can be used to do some processing just after the loop
    finishes. This would be a good place to write a summary. This also requires a
    `do_*` method that returns a value—any non-`False` value—to end the command loop.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postloop()` 方法可用于在循环结束后进行一些处理。这将是写总结的好地方。这还需要一个返回值的 `do_*` 方法——任何非 `False`
    值——来结束命令循环。'
- en: 'Also, there are a number of attributes we can set. These are class-level variables
    that would be peers to the method definitions:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以设置许多属性。这些是类级别的变量，将成为方法定义的对等体：
- en: 'The `prompt` attribute is the prompt string to write. For our example, we can
    do the following:'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prompt` 属性是要写的提示字符串。对于我们的示例，我们可以这样做：'
- en: '[PRE49]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `intro` attribute is the introductory message.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intro` 属性是介绍性消息。'
- en: We can tailor the help output by setting `doc_header` , `undoc_header` , `misc_header`
    , and `ruler` attributes. These will all alter how the help output looks.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过设置 `doc_header` 、 `undoc_header` 、 `misc_header` 和 `ruler` 属性来定制帮助输出。这些都将改变帮助输出的外观。
- en: The goal is to be able to create a tidy class that handles user interaction
    in a way that's simple and flexible. This class creates an application that has
    a lot of features in common with Python's REPL. It also has features in common
    with many command-line programs that prompt for user input.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是能够创建一个处理用户交互的整洁类，这种类的方式既简单又灵活。这个类创建了一个应用程序，它与Python的REPL有许多共同特征。它还具有许多命令行程序的特点，这些程序提示用户输入。
- en: One example of these interactive applications is the command-line FTP client
    in Linux. It has a prompt of `ftp>` , and it parses dozens of individual FTP commands.
    Entering `help` will show all of the various internal commands that are part of
    FTP interaction.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这些交互应用程序的一个例子是Linux中的命令行FTP客户端。它有一个提示符 `ftp>` ，并解析数十个单独的FTP命令。输入 `help` 将显示所有属于FTP交互的各种内部命令。
- en: See also
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We'll look at class definitions in [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* , and [Chapter 7](text00079.html#page
    "Chapter 7. More Advanced Class Design") , *More Advanced Class Design*
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在[第6章](text00070.html#page "第6章。类和对象的基础")和[第7章](text00079.html#page "第7章。更高级的类设计")中查看类定义，*类和对象的基础*和*更高级的类设计*。
- en: Using the OS environment settings
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用操作系统环境设置
- en: 'There are several ways to look at the span of time for user inputs:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以查看用户输入的时间跨度：
- en: 'Interactive data: This is provided by the user in a kind of *right now* time
    span.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互数据：这是由用户在一种*现在*时间跨度内提供的。
- en: 'Command-line arguments provided when the program is started: These values often
    span one full execution of a program.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序启动时提供的命令行参数：这些值通常跨越程序的一个完整执行。
- en: 'Environment variables set at the OS level: These can be set at the command
    line, making them almost as interactive as the command that starts an application:'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在操作系统级别设置的环境变量：这些可以在命令行中设置，使它们几乎与启动应用程序的命令一样交互。
- en: They can be configured for a user in a `.bashrc` file or `.profile` file. This
    makes them more persistent and slightly less interactive than the command-line.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以在 `.bashrc` 文件或 `.profile` 文件中为用户配置。这使它们比命令行更持久，稍微不那么交互。
- en: In Windows, there's the **Advanced Settings** option that allows someone to
    set a long-term configuration. These are often inputs to multiple executions of
    a program.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows中，有**高级设置**选项，允许某人设置长期配置。这些通常是多次执行程序的输入。
- en: 'Configuration file settings: These vary widely by application. The idea is
    to edit a file and make these options or arguments available for long periods
    of time. These might apply to multiple users or even to all users. Configuration
    files often have the longest time span.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件设置：这些因应用程序而异。其思想是编辑一个文件，并使这些选项或参数长时间可用。这些可能适用于多个用户，甚至适用于所有用户。配置文件通常具有最长的时间跨度。
- en: In the *Using input() and getpass() for user input* and *Using cmd for creating
    command-line applications* recipes, we looked at interaction with the user. In
    the *Using* *argparse to get command-line input* recipe, we looked at how to handle
    command-line arguments. We'll look at configuration files in [Chapter 13](text00137.html#page
    "Chapter 13. Application Integration") , *Application integration* .
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用input()和getpass()进行用户输入*和*使用cmd创建命令行应用程序*配方中，我们研究了与用户的交互。在*使用argparse获取命令行输入*配方中，我们研究了如何处理命令行参数。我们将在[第13章](text00137.html#page
    "第13章 应用集成")中研究配置文件，*应用集成*。
- en: The environment variables are available through the `os` module. How can we
    have an application's configuration based on these OS-level settings?
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量可通过`os`模块获得。我们如何可以基于这些操作系统级别的设置来配置应用程序？
- en: Getting ready
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We may want to provide information of various types to a program via OS settings.
    There''s a profound limitation here: the OS settings can only be string values.
    This means that many kinds of settings will require some code to parse the value
    and create proper Python objects from the string.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望通过操作系统设置向程序提供各种类型的信息。这里存在一个深刻的限制：操作系统设置只能是字符串值。这意味着许多种设置将需要一些代码来解析值，并从字符串创建适当的Python对象。
- en: When we work with `argparse` to parse command-line arguments, this module can
    do some data conversions for us. When we use `os` to process environment variables;
    we'll have to implement the conversion ourselves.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`argparse`解析命令行参数时，这个模块可以为我们做一些数据转换。当我们使用`os`处理环境变量时，我们将不得不自己实现转换。
- en: In the *Using argparse to get command-line input* recipe, we wrapped the `haversine()`
    function in a simple application that parsed command-line arguments.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用argparse获取命令行输入*配方中，我们将`haversine()`函数包装在一个简单的应用程序中，解析命令行参数。
- en: 'At the OS level, we created a program that worked like this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统级别上，我们创建了一个像这样工作的程序：
- en: '[PRE50]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: After using this for a while, we've found that we're often using nautical miles
    to compute distances from where our boat is anchored. We'd really like to have
    default values for one of the input points as well as the `-r` argument.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用了一段时间后，我们发现我们经常使用海里来计算从我们的船锚定的地方到达的距离。我们真的希望为输入点和`-r`参数之一设置默认值。
- en: Since a boat can be anchored in a variety of places, we need to change the default
    without having to tweak the actual code.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 由于船只可以停泊在各种地方，我们需要更改默认值，而无需调整实际代码。
- en: 'We''ll set set an OS environment variable, `UNITS` , with the distance units.
    We can set another variable, `HOME_PORT` , with the home point. We want to be
    able to do the following:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个名为`UNITS`的操作系统环境变量，其中包含距离单位。我们可以设置另一个变量`HOME_PORT`，其中包含家庭点。我们希望能够执行以下操作：
- en: '[PRE51]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The units and the home point values are provided to the application via the
    OS environment. This can be set in a configuration file so that we can make easy
    changes. It can also be set manually, as shown in the example.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 单位和家庭点值通过操作系统环境提供给应用程序。这可以在配置文件中设置，以便我们可以轻松进行更改。也可以手动设置，如示例所示。
- en: How to do it...
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import the `os` module. The OS environment is available through this module:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`os`模块。操作系统环境可通过此模块获得：
- en: '[PRE52]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Import any other classes or object needed for the application:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入应用程序所需的任何其他类或对象：
- en: '[PRE53]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Define a function that will use the environment values as defaults for optional
    command-line arguments. The default set of arguments to parse come from `sys.argv`
    , so it''s important to also import the `sys` module:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，该函数将使用环境值作为可选命令行参数的默认值。要解析的默认参数集来自`sys.argv`，因此还重要的是要导入`sys`模块：
- en: '[PRE54]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Gather default values from the OS environment settings. This includes any validation
    required:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从操作系统环境设置中收集默认值。这包括任何所需的验证：
- en: '[PRE55]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `sys.exit()` function handles the error processing nicely. It will print
    the message and exit with a non-zero status code.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.exit()`函数很好地处理了错误处理。它将打印消息并以非零状态代码退出。'
- en: 'Create the `parser` attribute. Provide any default values for the relevant
    arguments. This depends on the `argparse` module, which must also be imported:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`parser`属性。为相关参数提供任何默认值。这取决于`argparse`模块，也必须导入：
- en: '[PRE56]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Do any additional validation to ensure that arguments are set properly. In
    this example, it''s possible to have no value for `HOME_PORT` and no value provided
    for the second command-line argument. This requires an `if` statement and a call
    to `sys.exit()` :'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行任何额外的验证以确保参数正确设置。在这个例子中，可能没有为`HOME_PORT`设置值，也没有为第二个命令行参数提供值。这需要一个`if`语句和对`sys.exit()`的调用：
- en: '[PRE57]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Return the `options` object with the set of valid arguments:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回具有一组有效参数的`options`对象：
- en: '[PRE58]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This will allow the `-r` argument and the second point to be completely optional.
    The argument parser will use the configuration information to supply default values
    if these are omitted from the command line.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许`-r`参数和第二个点完全是可选的。如果这些参数从命令行中省略，参数解析器将使用配置信息提供默认值。
- en: Use the *Using argparse to get command-line input* recipe for ways to process
    the options created by the `get_options()` function.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*使用argparse获取命令行输入*配方来处理`get_options()`函数创建的选项的方法。
- en: How it works...
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We've used the OS environment variables to create default values that can be
    overridden by command-line arguments. If the environment variable is set, that
    string is provided as the default to the argument definition. If the environment
    variable is not set, then an application-level default value is used.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用操作系统环境变量创建可以被命令行参数覆盖的默认值。如果环境变量已设置，那么该字符串将作为参数定义的默认值。如果环境变量未设置，则使用应用程序级别的默认值。
- en: In the instance of the `UNITS` variable, the application uses kilometers as
    the default if not, then the OS environment variable is set.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UNITS`变量的情况下，如果未设置操作系统环境变量，则应用程序使用公里作为默认值。
- en: 'This gives us three tiers of interaction:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们三个层次的交互：
- en: We can define a setting in a `.bashrc` file. Alternatively, we can use the Windows
    **Advanced Settings** option to make a change that is persistent. This value will
    be used each time we log in or create a new command window.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在`.bashrc`文件中定义一个设置。或者，我们可以使用Windows的**高级设置**选项来进行持久性更改。这个值将在每次登录或创建新的命令窗口时使用。
- en: We can set the OS environment interactively at the command line. This will last
    as long as our session lasts. When we logout, or close the command window, this
    value will be lost.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在命令行上交互地设置操作系统环境。这将持续到我们的会话结束。当我们注销或关闭命令窗口时，这个值将丢失。
- en: We can provide a unique value through the command-line arguments each time the
    program is run.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过命令行参数每次运行程序时提供一个唯一的值。
- en: Note that there's no built-in or automatic validation of the values retrieved
    from environment variables. We'll need to validate these strings to ensure that
    they're meaningful.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从环境变量中检索的值没有内置或自动验证。我们需要验证这些字符串，以确保它们是有意义的。
- en: Also note that we've repeated the list of valid units in several places. This
    violates the **Don't Repeat Yourself** ( **DRY** ) principle. A global variable
    with this list is a good improvement to make.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们在几个地方重复列出了有效单位的列表。这违反了**不要重复自己**（**DRY**）原则。使用这个列表的全局变量是一个很好的改进。
- en: There's more...
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The *Using argparse to get command-line input* recipe shows a slightly different
    way to handle the default command-line arguments available from `sys.argv` . The
    first of the arguments is the name of the Python application being executed and
    is not often relevant to argument parsing.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用argparse获取命令行输入*示例展示了处理来自`sys.argv`的默认命令行参数的略有不同的方法。第一个参数是正在执行的Python应用程序的名称，通常与参数解析无关。'
- en: 'The value of `sys.argv` will be a list of strings as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.argv`的值将是以下字符串列表：'
- en: '[PRE59]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We have to skip the initial value in `sys.argv[0]` at some point in the processing.
    We have two choices:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在处理过程中的某个时候跳过`sys.argv[0]`中的初始值。我们有两种选择：
- en: In this recipe, we discard the extra item as late as possible in the parsing
    process. The first item is skipped when providing `sys.argv[1:]` to the parser.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们尽可能晚地在解析过程中丢弃多余的项目。当提供`sys.argv[1：]`给解析器时，第一个项目将被跳过。
- en: In the previous example, we discarded the value earlier in the processing. The
    `main()` function used `options = get_options(sys.argv[1:])` to provide the shorter
    list to the parser.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们在处理过程中更早地丢弃了该值。`main()`函数使用`options = get_options(sys.argv[1:])`向解析器提供了更短的列表。
- en: Generally, the only relevant distinction between the two approaches depends
    on the number and complexity of the unit tests. This recipe will require a unit
    test that includes an initial argument string, which will be discarded during
    parsing.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，这两种方法之间唯一相关的区别取决于单元测试的数量和复杂性。这个示例将需要一个包含初始参数字符串的单元测试，在解析过程中将被丢弃。
- en: See also
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We'll look at numerous ways to handle configuration files in [Chapter 13](text00137.html#page
    "Chapter 13. Application Integration") , *Application integration*
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将看到处理配置文件的多种方法在[第13章](text00137.html#page "第13章。应用集成")中，*应用集成*
- en: '![](image/614271.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![](image/614271.jpg)'
