- en: Creating Menus with Menu and Tkinter Dialogs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Menu和Tkinter对话框创建菜单
- en: As an application grows, organizing access to its features becomes increasingly
    important. Traditionally, applications have addressed this with a **menu system**,
    which is typically located at the top of the application window or (on some platforms)
    in a global desktop menu. While these menus are application-specific, certain
    organizational conventions have been developed that we should follow in order
    to make our software user-friendly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，组织对其功能的访问变得越来越重要。传统上，应用程序通过**菜单系统**来解决这个问题，通常位于应用程序窗口的顶部或（在某些平台上）全局桌面菜单中。虽然这些菜单是特定于应用程序的，但已经制定了一些组织惯例，我们应该遵循以使我们的软件更加用户友好。
- en: 'In this chapter, we''re going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Analyzing some reported problems and deciding on a solution
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析一些报告的问题并决定解决方案
- en: Exploring some of Tkinter's dialog classes, and using them for implementing
    common menu functionality
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索一些Tkinter的对话框类，并使用它们来实现常见菜单功能
- en: Learning how to work with Tkinter's Menu widget and using it to create a menu
    for our application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用Tkinter的Menu小部件，并使用它为我们的应用程序创建菜单
- en: Creating some options for our application and saving them to disk
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序创建一些选项并将它们保存到磁盘
- en: Solving problems in our application
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决我们应用程序中的问题
- en: Your boss has brought you the first set of problems that need to be addressed
    in your application. First, in situations where the last reports of the day aren't
    able to be entered until the following day, the hardcoded date string in the filename
    is a problem. The data entry staff need a way to manually choose which file they'll
    be appending to.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您的老板给您带来了需要在您的应用程序中解决的第一组问题。首先，在无法在第二天之前输入当天最后的报告的情况下，文件名中的硬编码日期字符串是一个问题。数据输入人员需要一种手动选择要追加的文件的方法。
- en: Also, the data entry staff have mixed feelings about the auto-populate features
    in the form. Some find it very helpful, but others would really like to see it
    disabled. You'll need a way to allow users to turn this feature on and off.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数据输入人员对表单中的自动填充功能有不同的看法。有些人觉得这非常有帮助，但其他人真的希望看到它被禁用。您需要一种允许用户打开和关闭此功能的方法。
- en: Finally, some users have a hard time noticing the status bar text at the bottom,
    and would like the application to be more conspicuous when it fails to save data
    due to errors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些用户很难注意到底部状态栏的文本，并希望应用程序在由于错误而无法保存数据时更加显眼。
- en: Deciding how to address these problems
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定如何解决这些问题
- en: 'It''s clear you need to implement a way to select a file and toggle the auto-populate
    features of the form. First, you consider just adding controls to the main application
    for both of these, and make this quick mock-up:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，您需要实现一种选择文件和切换表单自动填充功能的方法。首先，您考虑只向主应用程序添加这两个控件，并进行快速的模拟：
- en: '![](assets/b7aaf697-23dc-40a6-8c42-0e8c13ba42d7.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b7aaf697-23dc-40a6-8c42-0e8c13ba42d7.png)'
- en: It doesn't take long for you to realize that this is not a great design, and
    certainly not one that will accommodate growth. Your users don't want to have
    to type a file path and filename blindly into the box, nor do they want a lot
    of extra fields cluttering up the UI.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您很快就会意识到这不是一个很好的设计，当然也不是一个能够适应增长的设计。您的用户不想盲目地在框中输入文件路径和文件名，也不想让很多额外的字段混乱UI。
- en: 'Fortunately, Tkinter offers some tools that will help us to solve these problems:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Tkinter提供了一些工具，可以帮助我们解决这些问题：
- en: '**File dialogs**: Tkinter''s `filedialog` library will help make file selection
    simple'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件对话框**：Tkinter的`filedialog`库将帮助简化文件选择'
- en: '**Error dialogs**: Tkinter''s `messagebox` library will let us display error
    messages more noticeably'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误对话框**：Tkinter的`messagebox`库将让我们更加显眼地显示错误消息'
- en: '**Main menu**: Tkinter''s `Menu` class can help us organize common functionality
    for easy access'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主菜单**：Tkinter的`Menu`类可以帮助我们组织常见功能，以便轻松访问'
- en: Implementing simple Tkinter dialogs
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现简单的Tkinter对话框
- en: The status bar is fine for incidental information that shouldn't interrupt a
    user's workflow, but for errors that prevent work from continuing as expected,
    users should be alerted in a more assertive way. An **error dialog** that halts
    the program until it's acknowledged with a mouse click is fairly assertive and
    seems like a good way to address the issue of users not seeing errors. In order
    to implement these, you'll need to learn about Tkinter's `messagebox` library.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 状态栏适用于不应中断用户工作流程的偶发信息，但对于阻止工作按预期继续的错误，用户应该以更有力的方式受到警告。一个中断程序直到通过鼠标点击确认的**错误对话框**是相当有力的，似乎是解决用户看不到错误的问题的好方法。为了实现这些，您需要了解Tkinter的`messagebox`库。
- en: Tkinter messagebox
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter messagebox
- en: The best way to display simple dialog boxes in Tkinter is by using the `tkinter.messagebox`
    library, which contains several convenient functions that allow you to quickly
    create common dialog types. Each function displays a preset icon and a selection
    of buttons with a message and detail text that you specify, and returns a value
    depending on which button the user clicked.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tkinter中显示简单对话框的最佳方法是使用`tkinter.messagebox`库，其中包含几个方便的函数，允许您快速创建常见的对话框类型。每个函数显示一个预设的图标和一组按钮，带有您指定的消息和详细文本，并根据用户点击的按钮返回一个值。
- en: 'The following table shows some of the `messagebox` functions with their icons
    and return values:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了一些`messagebox`函数及其图标和返回值：
- en: '| **Function** | **Icon** | **Button** / **return value** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **图标** | **按钮** / **返回值** |'
- en: '| `askokcancel` | Question | Ok (`True`), Cancel (`False`) |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `askokcancel` | 问题 | 确定 (`True`), 取消 (`False`) |'
- en: '| `askretrycancel` | Warning | Retry (`True`), Cancel (`False`) |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `askretrycancel` | 警告 | 重试 (`True`), 取消 (`False`) |'
- en: '| `askyesno` | Question | Yes (`True`), No (`False`) |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `askyesno` | 问题 | 是 (`True`), 否 (`False`) |'
- en: '| `askyesnocancel` | Question | Yes (`True`), No (`False`), Cancel (`None`)
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `askyesnocancel` | 问题 | 是 (`True`), 否 (`False`), 取消 (`None`) |'
- en: '| `showerror` | Error | Ok (`ok`) |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `showerror` | 错误 | 确定 (`ok`) |'
- en: '| `showinfo` | Information | Ok (`ok`) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `showinfo` | 信息 | 确定（`ok`） |'
- en: '| `showwarning` | Warning | Ok (`ok`) |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `showwarning` | 警告 | 确定（`ok`） |'
- en: 'We can pass the following three text arguments into any `messagebox` function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将以下三个文本参数传递给任何`messagebox`函数：
- en: '`title`: This argument sets the title of the window, which is displayed in
    the title bar and/or task bar in your desktop environment.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：此参数设置窗口的标题，在您的桌面环境中显示在标题栏和/或任务栏中。'
- en: '`message`: This argument sets the main message of the dialog. It''s usually
    in a heading font and should be kept fairly short.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`：此参数设置对话框的主要消息。通常使用标题字体，应保持相当简短。'
- en: '`detail`: This argument sets the body text of the dialog, which is usually
    displayed in the standard window font.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detail`：此参数设置对话框的正文文本，通常显示在标准窗口字体中。'
- en: 'Here is a basic call to `showinfo()`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对`showinfo()`的基本调用：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In Windows 10, it results in a dialog box (on other platforms, it may look
    a bit different), as shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows 10中，它会导致一个对话框（在其他平台上可能看起来有点不同），如下面的屏幕截图所示：
- en: '![](assets/3ae47462-cc7e-4428-bee7-9a8e23f15ea4.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3ae47462-cc7e-4428-bee7-9a8e23f15ea4.png)'
- en: Tkinter `messagebox` dialog boxes are **modal**, which means that the program
    execution pauses and the rest of the UI is unresponsive while the dialog box is
    open. There is no way to change this, so only use them in situations where it's
    acceptable for the program to pause execution while the box is open.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter的`messagebox`对话框是**模态**的，这意味着程序执行会暂停，而UI的其余部分在对话框打开时无响应。没有办法改变这一点，所以只能在程序暂停执行时使用它们。
- en: 'Let''s create a small example to show the use of the `messagebox` functions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个小例子来展示`messagebox`函数的使用：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To use `messagebox`, we need to import it from Tkinter; you can't simply use
    `tk.messagebox` because it's a submodule and must be explicitly imported.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`messagebox`，我们需要从Tkinter导入它；你不能简单地使用`tk.messagebox`，因为它是一个子模块，必须显式导入。
- en: 'Let''s create a yes-no message box as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个是-否消息框，如下所示：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This creates a dialog with Yes and No buttons; if Yes is clicked, the function
    returns `True`. If No is clicked, the function returns `False` and  the application
    exits.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个带有是和否按钮的对话框；如果点击是，函数返回`True`。如果点击否，函数返回`False`，应用程序退出。
- en: 'In case our user wants to see more boxes, let''s display an information box:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的用户想要看到更多的框，让我们显示一个信息框：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note the difference between the way `message` and `detail` are displayed on
    your platform. On some platforms, there is no difference; on others, `message`
    is large and bold, which is appropriate for short texts. For cross-platform software,
    it's best to use `detail` for extended output.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`message`和`detail`在您的平台上显示方式的不同。在某些平台上，没有区别；在其他平台上，`message`是大而粗体的，这对于短文本是合适的。对于跨平台软件，最好使用`detail`进行扩展输出。
- en: Showing the error dialogs
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示错误对话框
- en: 'Now that you understand how to use `messagebox`, error dialogs should be easy
    to implement. The `Application.on_save()` method already displays errors in the
    status bar; we just need to make this error display in an error message box as
    well by performing the following steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了如何使用`messagebox`，错误对话框应该很容易实现。`Application.on_save()`方法已经在状态栏中显示错误；我们只需要通过以下步骤使此错误显示在错误消息框中：
- en: 'First, we''ll need to import it in `application.py` as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在`application.py`中导入它，如下所示：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, in the `on_save()` method after the check for errors, we''ll set up the
    message for the error dialog. We''ll make a bullet list of the fields with errors
    by joining them with `"\n *"`. Unfortunately, `messagebox` doesn''t support any
    sort of markup, so constructs like bullet lists need to be built manually using
    regular characters, as in the following:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`on_save()`方法中检查错误后，我们将设置错误对话框的消息。我们将通过使用`"\n *"`将错误字段制作成项目符号列表。不幸的是，`messagebox`不支持任何标记，因此需要使用常规字符手动构建类似项目符号列表的结构，如下所示：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can call `showerror()`, just after the call to `status()` as follows:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在`status()`调用之后调用`showerror()`，如下所示：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, open the program and hit Save; you''ll see a dialog box alerting you to
    the errors in the application, as shown in the following screenshot:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开程序并点击保存；您将看到一个对话框，提示应用程序中的错误，如下面的屏幕截图所示：
- en: '![](assets/b7f981fb-dc26-4abf-9ff9-b839d434646d.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b7f981fb-dc26-4abf-9ff9-b839d434646d.png)'
- en: This error should be hard for anyone to miss!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误应该对任何人来说都很难错过！
- en: One shortcoming of the `messagebox` dialogs is that they don't scroll; a long
    error message will create a dialog that may fill (or extend beyond) the screen.
    If this is a potential problem, you'll want to create a custom dialog containing
    a scrollable widget.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`messagebox`对话框的一个缺点是它们不会滚动；长错误消息将创建一个可能填满（或超出）屏幕的对话框。如果这是一个潜在的问题，您将需要创建一个包含可滚动小部件的自定义对话框。'
- en: Designing our menu
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们的菜单
- en: Most applications organize functionality into a hierarchical **menu system**,
    typically displayed at the top of the application or screen (depending on the
    OS). While the organization of this menu varies between operating systems, certain
    items are fairly common across platforms.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序将功能组织成一个分层的**菜单系统**，通常显示在应用程序或屏幕的顶部（取决于操作系统）。虽然这个菜单的组织在操作系统之间有所不同，但某些项目在各个平台上都是相当常见的。
- en: 'Of these common items, our application will need the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些常见项目中，我们的应用程序将需要以下内容：
- en: A file menu containing file operations such as open/save/export, and often an
    option to quit the application. Our users will need this menu to select a file
    and quit the program.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含文件操作（如打开/保存/导出）的文件菜单，通常还有退出应用程序的选项。我们的用户将需要此菜单来选择文件并退出程序。
- en: An options, preferences, or settings menu where users can configure the application.
    We'll need this menu for our toggle settings; we'll call it options for now.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个选项、首选项或设置菜单，用户可以在其中配置应用程序。我们将需要此菜单来进行切换设置；暂时我们将其称为选项。
- en: A help menu, which contains links to help documentation, or, at the very least,
    an about message giving the basic information about the application. We'll implement
    this menu for the about dialog.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助菜单，其中包含指向帮助文档的链接，或者至少包含一个关于应用程序的基本信息的消息。我们将为关于对话框实现这个菜单。
- en: Apple, Microsoft, and the Gnome Project publish guidelines for macOS, Windows,
    and Gnome desktops (used on Linux and BSD), respectively; each set of guidelines
    addresses the layout of menu items specific to that platform.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果、微软和Gnome项目分别发布了macOS、Windows和Gnome桌面（在Linux和BSD上使用）的指南；每套指南都涉及特定平台的菜单布局。
- en: Before we can implement our menu, we'll need to understand how menus work in
    Tkinter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现菜单之前，我们需要了解Tkinter中菜单的工作原理。
- en: Creating menus in Tkinter
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Tkinter中创建菜单
- en: The `tkinter.Menu` widget is used to implement menus in Tkinter applications;
    it's a fairly simple widget that acts as a container for any number of menu items.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkinter.Menu`小部件用于在Tkinter应用程序中实现菜单；它是一个相当简单的小部件，作为任意数量的菜单项的容器。'
- en: 'The menu items can be one of the following five types:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单项可以是以下五种类型之一：
- en: '`command`: These items are labeled buttons that, when clicked, run a callback.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command`：这些项目是带有标签的按钮，当单击时运行回调。'
- en: '`checkbutton`: These items are just like `Checkbutton` in our forms, and can
    be used to toggle `BooleanVar`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkbutton`：这些项目就像我们表单中的`Checkbutton`一样，可以用来切换`BooleanVar`。'
- en: '`radiobutton`: These items are similar to `Checkbutton`, but can be used to
    switch any kind of Tkinter variable between several mutually exclusive options.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`radiobutton`：这些项目类似于`Checkbutton`，但可以用来在几个互斥选项之间切换任何类型的Tkinter变量。'
- en: '`separator`: These items are used to segment the menu into sections.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`separator`：这些项目用于将菜单分成几个部分。'
- en: '`cascade`: These items allow you to add a submenu to the menu. The submenu
    is just another `tkinter.Menu` object.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cascade`：这些项目允许您向菜单添加子菜单。子菜单只是另一个`tkinter.Menu`对象。'
- en: 'Let''s write the following small program to demonstrate the use of Tkinter
    menus:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写以下小程序来演示Tkinter菜单的使用：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This application sets up a label whose text is controlled by a string variable, `main_text`.
    If you run this application, you'll see a simple window that says Hi. Let's start
    adding the menu components.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序设置了一个标签，其文本由字符串变量`main_text`控制。如果您运行此应用程序，您将看到一个简单的窗口，上面写着Hi。让我们开始添加菜单组件。
- en: 'Right above `root.mainloop()`, add the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在`root.mainloop()`的正上方，添加以下代码：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This creates a main menu and then sets it as the main menu of our application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个主菜单，然后将其设置为我们应用程序的主菜单。
- en: 'Currently, that menu is empty, so let''s add an item by adding the following
    code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，该菜单是空的，所以让我们通过添加以下代码来添加一个项目：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We've added a command to quit the application. The `add` method allows us to
    specify an item type and any number of attributes to create a new menu item. In
    the case of a command, we need to at least have a `label` argument specifying
    the text that will show in the menu and a `command` argument pointing to a Python
    callback.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了一个退出应用程序的命令。`add`方法允许我们指定一个项目类型和任意数量的属性来创建一个新的菜单项。对于命令，我们至少需要有一个`label`参数来指定菜单中显示的文本，以及一个指向Python回调的`command`参数。
- en: Some platforms, such as macOS, don't allow a command in the top-level menu.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一些平台，如macOS，不允许在顶级菜单中使用命令。
- en: 'Let''s try creating a submenu as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建一个子菜单，如下所示：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating a submenu is just like creating a menu, except that we specify the
    `parent` menu as the widget's `parent`. Notice the `tearoff` argument; by default,
    submenus in Tkinter are tearable, which means they can be pulled off and moved
    around as independent windows. You don't have to disable this option, but it is
    a rather archaic UI feature that is rarely used on modern platforms. Users will
    likely just find it confusing, so it's best to disable it whenever you create
    submenus.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 创建子菜单就像创建菜单一样，只是我们将`parent`菜单指定为小部件的`parent`。注意`tearoff`参数；在Tkinter中，默认情况下子菜单是可撕下的，这意味着它们可以被拆下并作为独立窗口移动。您不必禁用此选项，但这是一个相当古老的UI功能，在现代平台上很少使用。用户可能会觉得困惑，最好在创建子菜单时禁用它。
- en: 'Add some commands to the menu as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一些命令到菜单中，如下所示：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We're using the `lambda` functions here for convenience, but you can pass any
    Python callable. The `add_command` method used here is simply a shortcut for `add('command')`.
    There are analogous methods for adding other items as well (cascade, separator,
    and so on).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`lambda`函数是为了方便，但您可以传递任何Python可调用的函数。这里使用的`add_command`方法只是`add('command')`的快捷方式。添加其他项目的方法也是类似的（级联，分隔符等）。
- en: 'Let''s use the `add_cascade` method to add our menu back to its `parent` widget
    as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`add_cascade`方法将我们的菜单添加回其`parent`小部件，如下所示：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When adding a submenu to its `parent` menu, we simply have to provide the label
    for the menu and the menu itself.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在将子菜单添加到其`parent`菜单时，我们只需提供菜单的标签和菜单本身。
- en: We can add the  `Checkbutton` and `Radiobutton` widgets to the menu as well.
    To demonstrate this, let's create another submenu to alter the label's appearance.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将`Checkbutton`和`Radiobutton`小部件添加到菜单中。为了演示这一点，让我们创建另一个子菜单来改变标签的外观。
- en: 'First, we need the following setup code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要以下设置代码：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we're just creating variables to store the state of the bold option and
    font size, then a callback method that actually sets the label's font from these
    variables when called. Then, we set up a trace on both variables to call the callback
    whenever their values are changed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是创建变量来存储粗体选项和字体大小的状态，然后创建一个回调方法，当调用时实际上从这些变量设置标签的字体。然后，我们在两个变量上设置了一个跟踪，以便在它们的值发生变化时调用回调。
- en: 'Now, we just need to create the menu options to change the variables by adding
    the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要通过添加以下代码来创建菜单选项来改变变量：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Like a regular `Checkbutton` widget, the `add_checkbutton` method takes `BooleanVar`,
    which is passed to the `variable` argument that will be bound to its checked status.
    Unlike a regular `Checkbutton` widget, use the `label` argument, rather than the
    `text` argument, to assign the label text.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 像普通的“Checkbutton”小部件一样，“add_checkbutton”方法接受“BooleanVar”，它被传递给“variable”参数，该参数将绑定到其选中状态。与普通的“Checkbutton”小部件不同，使用“label”参数而不是“text”参数来分配标签文本。
- en: 'To demonstrate the radio buttons, let''s add a submenu to our submenu, like
    so:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示单选按钮，让我们向我们的子菜单添加一个子菜单，如下所示：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Just as we added a submenu to our main menu, we can add submenus to submenus.
    In theory, you could nest submenus indefinitely, but most UI guidelines discourage
    more than two levels. To create the items for our size menu, we're just iterating
    a generated list of even numbers between 8 and 24; for each one, we add a `radiobutton` item
    with a value equal to that size. Just like with regular `Radiobutton` widgets,
    the variable given in the `variable` argument will be updated with the value given
    in the `value` argument when the button is selected.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在主菜单中添加了一个子菜单一样，我们也可以在子菜单中添加子菜单。理论上，你可以无限嵌套子菜单，但大多数UI指南不鼓励超过两个级别。为了创建我们的大小菜单项，我们只需迭代一个在8和24之间生成的偶数列表；对于每一个，我们都添加一个值等于该大小的“radiobutton”项。就像普通的“Radiobutton”小部件一样，“variable”参数中给定的变量在按钮被选中时将被更新为“value”参数中给定的值。
- en: 'Launch the application and try it out, as shown in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序并尝试一下，如下面的屏幕截图所示：
- en: '![](assets/18dd3562-6645-4d90-84e7-3fd42afc8a8f.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/18dd3562-6645-4d90-84e7-3fd42afc8a8f.png)'
- en: Now that you understand the `Menu` widget, let's add one to our application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了“Menu”小部件，让我们在我们的应用程序中添加一个。
- en: Implementing our application menu
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现我们的应用程序菜单
- en: 'As a major component of the GUI, our menu is clearly a view, and should be
    implemented in the `views.py` file. However, it''s also going to need to set options
    that affect other views (such as the form options we''re implementing now) and
    run functions that affect the application (like quitting). We need to implement
    it in such a way that we keep controller functions in the `Application` class
    but still keep the UI code in `views.py`. Let''s take a look at the following
    steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 作为GUI的一个重要组件，我们的菜单显然是一个视图，并且应该在“views.py”文件中实现。但是，它还需要设置影响其他视图的选项（例如我们现在正在实现的表单选项）并运行影响应用程序的函数（如退出）。我们需要以这样一种方式实现它，即我们将控制器函数保留在“Application”类中，但仍将UI代码保留在“views.py”中。让我们看看以下步骤：
- en: 'Let''s start out by opening `views.py` and creating a `MainMenu` class that
    subclasses `tkinter.Menu`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先打开“views.py”并创建一个继承了“tkinter.Menu”的“MainMenu”类：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our overridden `__init__()` method will take two dictionaries, a `settings`
    dictionary and a `callbacks` dictionary, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写的“__init__()”方法将使用两个字典，“settings”字典和“callbacks”字典，如下所示：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We''ll use these dictionaries to communicate with the controller: `settings`
    will contain Tkinter variables that can be bound to our menu controls, and `callbacks`
    will be controller methods that we can bind to menu commands. Naturally, we''ll
    need to make sure to populate these dictionaries with the expected variables and
    callables in our `Application` object.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些字典与控制器进行通信：“settings”将包含可以绑定到我们菜单控件的Tkinter变量，“callbacks”将是我们可以绑定到菜单命令的控制器方法。当然，我们需要确保在我们的“Application”对象中使用预期的变量和可调用对象来填充这些字典。
- en: 'Now, let''s start creating our submenus, starting with the file menu as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们开始创建我们的子菜单，首先是文件菜单如下：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our first command in the file menu is `Select file...`. Notice the ellipses
    in the label: this indicates to the user that the option will open another window
    that will require further input. We''re setting `command` to a reference from
    our `callbacks` dictionary using the `file->open` key. This function doesn''t
    exist yet; we''ll implement it shortly. Let''s add our next file menu command,
    `file->quit`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们文件菜单中的第一个命令是“选择文件...”。注意标签中的省略号：这向用户表明该选项将打开另一个需要进一步输入的窗口。我们将“command”设置为从我们的“callbacks”字典中使用“file->open”键的引用。这个函数还不存在；我们将很快实现它。让我们添加我们的下一个文件菜单命令，“file->quit”：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once again, we've pointed this command to an as yet undefined function in our
    `callbacks` dictionary. We've also added a separator; since quitting the program
    is a fundamentally different sort of operation from selecting a target file, it
    makes sense to separate them, and you'll see this in most application menus.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将这个命令指向了一个尚未定义的函数，它在我们的“callbacks”字典中。我们还添加了一个分隔符；由于退出程序与选择目标文件是一种根本不同的操作，将它们分开是有意义的，你会在大多数应用程序菜单中看到这一点。
- en: 'This completes the file menu, so we need to add it to the main `menu` object
    as follows:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这完成了文件菜单，所以我们需要将它添加到主“menu”对象中，如下所示：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next submenu we need to create is our `options` menu. Since we only have
    two menu options, we''ll just add them directly to the submenu as `Checkbutton`.
    The option menu looks as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建的下一个子菜单是我们的“选项”菜单。由于我们只有两个菜单选项，我们将直接将它们添加到子菜单中作为“Checkbutton”。选项菜单如下所示：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The variables bound to these `Checkbutton` widgets are in the `settings` dictionary,
    so our `Application` class will populate `settings` with two `BooleanVar` variables:
    `autofill date` and `autofill sheet data`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定到这些“Checkbutton”小部件的变量在“settings”字典中，因此我们的“Application”类将用两个“BooleanVar”变量填充“settings”：“autofill
    date”和“autofill sheet data”。
- en: 'Last of all, we''ll create a `help` menu, featuring an option to show an `About`
    dialog:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个“帮助”菜单，其中包含一个显示“关于”对话框的选项：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our `About` command points to an internal `MainMenu` method called `show_about`,
    which we'll implement next. The `About` dialog is going to be pure UI code with
    no actual application functionality in it, so we can implement it entirely within
    the view.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“关于”命令指向一个名为“show_about”的内部“MainMenu”方法，我们将在下面实现。关于对话框将是纯UI代码，没有实际的应用程序功能，因此我们可以完全在视图中实现它。
- en: Showing an About dialog
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示关于对话框
- en: 'We''ve already seen how to use `messagebox` to create error dialogs. Now, we
    can apply that knowledge to create our `About` box by performing the following
    steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用`messagebox`来创建错误对话框。现在，我们可以应用这些知识来创建我们的`About`框，具体步骤如下：
- en: 'Start a new method definition after `__init__()`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__init__()`之后开始一个新的方法定义：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `About` dialog can show any information you feel is relevant, including
    your contact information, support information, version information, or even the
    entire `README` file. In our case, we''ll keep it fairly short. Let''s specify
    the `message` header text and `detail` body text:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`About`对话框可以显示您认为相关的任何信息，包括您的联系信息、支持信息、版本信息，甚至整个`README`文件。在我们的情况下，我们会保持它相当简短。让我们指定`message`标题文本和`detail`正文文本：'
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We're just using the application name for the header, and a short message about
    our name and who to contact for support for the detail. Feel free to put whatever
    text you wish in your `About` box.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是在标题中使用应用程序名称，然后在详细信息中简要介绍我们的姓名以及联系支持的方式。请随意在您的`About`框中放入任何文本。
- en: There are several ways you can deal with long, multiline strings in Python code;
    the approach used here is to place multiple strings between parenthesis with only
    whitespace between them. Python automatically concatenates strings separated by
    only whitespace, so to Python this looks like a single long string inside a set
    of parentheses. In contrast to other methods, such as triple-quoting, this allows
    you to maintain clean indents and control new lines explicitly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python代码中，有几种处理长的多行字符串的方法；这里使用的方法是在括号之间放置多个字符串，它们之间只有空格。Python会自动连接只有空格分隔的字符串，因此对Python来说，这看起来像是一组括号内的单个长字符串。与其他方法相比，例如三引号，这允许您保持清晰的缩进并明确控制换行。
- en: 'Finally, we need to display our `About` box as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要显示我们的`About`框如下：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, the `showinfo()` function is clearly the most appropriate,
    since we are in fact showing information. This finishes our `show_about()` method
    and our `MainMenu` class. Next, we need to make the necessary modifications to
    `Application` to make it work.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`showinfo()`函数显然是最合适的，因为我们实际上是在显示信息。这完成了我们的`show_about()`方法和我们的`MainMenu`类。接下来，我们需要对`Application`进行必要的修改以使其正常工作。
- en: Adding the menu functionality in the controller
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在控制器中添加菜单功能
- en: Now that our menu class is defined, our `Application` object needs to create
    an instance and add it into the main window. Before we can do that, we'll need
    to define some things that our `MainMenu` class needs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的菜单类已经定义，我们的`Application`对象需要创建一个实例并将其添加到主窗口中。在我们这样做之前，我们需要定义一些`MainMenu`类需要的东西。
- en: 'Remember the following things from the previous section:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一节中记住以下事项：
- en: We need a `settings` dictionary that contains Tkinter variables for our two
    settings options
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个包含我们两个设置选项的Tkinter变量的`settings`字典
- en: We need a `callbacks` dictionary that points to callbacks for `file->select`
    and `file->quit`
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个指向`file->select`和`file->quit`回调的`callbacks`字典
- en: We need the actual functions that implement file selection and quitting
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要实际实现文件选择和退出的函数
- en: Let's define some things that our `MainMenu` class needs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一些`MainMenu`类需要的东西。
- en: 'Open `application.py` and let''s start adding code just before the creation
    of `self.recordform`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`application.py`，让我们在创建`self.recordform`之前开始添加代码：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will be our global settings dictionary that stores the boolean variables
    for our two configuration options. Next, we''ll create the `callbacks` dictionary:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的全局设置字典，用于存储两个配置选项的布尔变量。接下来，我们将创建`callbacks`字典：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we''re pointing our two callbacks to the methods of the `Application` class
    that will implement the functionality. Fortunately for us, Tkinter already implements
    `self.quit`, which does exactly what you''d expect it to do, so we only need to
    implement `on_file_select` ourselves. We will finish up here by creating our `menu`
    object and add it to the application as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的两个回调指向`Application`类的方法，这些方法将实现功能。对我们来说，幸运的是，Tkinter已经实现了`self.quit`，它确实做了您期望它做的事情，因此我们只需要自己实现`on_file_select`。我们将通过创建我们的`menu`对象并将其添加到应用程序来完成这里：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Handling file selection
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件选择
- en: When a user needs to enter a file or directory path, the preferred way to do
    this is to display a dialog containing a miniature file browser, commonly called
    a file dialog. Like most toolkits, Tkinter provides us with dialogs for opening
    files, saving files, and selecting a directory. These are all part of the `filedialog`
    module.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户需要输入文件或目录路径时，首选的方法是显示一个包含迷你文件浏览器的对话框，通常称为文件对话框。与大多数工具包一样，Tkinter为我们提供了用于打开文件、保存文件和选择目录的对话框。这些都是`filedialog`模块的一部分。
- en: Just like `messagebox`, `filedialog` is a Tkinter submodule that needs to be
    explicitly imported to be used. Also like `messagebox`, it contains a set of convenience
    functions that create file dialogs that are appropriate for different scenarios.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`messagebox`一样，`filedialog`是一个Tkinter子模块，需要显式导入才能使用。与`messagebox`一样，它包含一组方便的函数，用于创建适合不同场景的文件对话框。
- en: 'The following table lists the functions, what they return, and their UI features:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了函数、它们的返回值和它们的UI特性：
- en: '| **Function** | **Return value** | **Features** |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **返回值** | **特点** |'
- en: '| `askdirectory` | Directory path as string | Only shows directories, no files
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `askdirectory` | 目录路径字符串 | 仅显示目录，不显示文件 |'
- en: '| `askopenfile` | File handle object | Only allows selection of existing files
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `askopenfile` | 文件句柄对象 | 仅允许选择现有文件 |'
- en: '| `askopenfilename` | File path as string | Only allows selection of existing
    files |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `askopenfilename` | 文件路径字符串 | 仅允许选择现有文件 |'
- en: '| `askopenfilenames` | File paths as list of strings | Like `askopenfilename`,
    but allows multiple selections |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `askopenfilenames` | 字符串列表的文件路径 | 类似于`askopenfilename`，但允许多个选择 |'
- en: '| `askopenfiles` | List of file handle objects | Like `askopenfile`, but allows
    multiple selections |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `askopenfiles` | 文件句柄对象列表 | 类似于`askopenfile`，但允许多个选择 |'
- en: '| `asksaveasfile` | File handle object | Allows creation of new files, prompts
    for confirmation on existing files |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `asksaveasfile` | 文件句柄对象 | 允许创建新文件，在现有文件上进行确认提示 |'
- en: '| `asksaveasfilename` | File path as string | Allows creation of new files,
    prompts for confirmation on existing files |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `asksaveasfilename` | 文件路径字符串 | 允许创建新文件，在现有文件上进行确认提示 |'
- en: 'As you can see, each file selection dialog comes in two versions: one that
    returns a path as a string, and one that returns an open file object.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，每个文件选择对话框都有两个版本：一个返回路径作为字符串，另一个返回打开的文件对象。
- en: 'Each function can take the following common arguments:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都可以使用以下常见参数：
- en: '`title`: This argument specifies the dialog window title.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title`：此参数指定对话框窗口标题。'
- en: '`parent`: This argument specifies the (optional) `parent` widget. The file
    dialog will appear over this widget.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`：此参数指定（可选的）`parent`小部件。文件对话框将出现在此小部件上方。'
- en: '`initialdir`: This argument is the directory in which the file browser should
    start.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialdir`：此参数是文件浏览器应该开始的目录。'
- en: '`filetypes`: This argument is a list of tuples, each with a label and matching
    pattern, which will be used to create files of the filter drop-down type typically
    seen under the filename entry. This is used to filter the visible files to only
    those supported by the application.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filetypes`：此参数是一个元组列表，每个元组都有一个标签和匹配模式，用于创建过滤下拉类型的文件，通常在文件名输入框下方看到。这用于将可见文件过滤为仅由应用程序支持的文件。'
- en: 'The `asksaveasfile` and `asksaveasfilename` methods take the following two
    additional options:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`asksaveasfile`和`asksaveasfilename`方法还接受以下两个附加选项：'
- en: '`initialfile`: This option is a default file path to select'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialfile`：此选项是要选择的默认文件路径'
- en: '`defaultextension`: This option is a file extension string that will be automatically
    appended to the filename if the user doesn''t do it'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultextension`：此选项是一个文件扩展名字符串，如果用户没有这样做，它将自动附加到文件名'
- en: Finally, the methods that return a file object take a `mode` argument that specifies
    the file-open mode; these are the same one- or two-character strings used by Python's
    `open` built-in function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，返回文件对象的方法接受一个指定文件打开模式的`mode`参数；这些是Python的`open`内置函数使用的相同的一到两个字符字符串。
- en: 'Which dialog do we need to use in our application? Let''s consider our needs:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要使用哪个对话框？让我们考虑一下我们的需求：
- en: We need a dialog that allows us to select an existing file
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个对话框，允许我们选择一个现有文件
- en: We also need to be able to create a new file
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要能够创建一个新文件
- en: Since opening the file is the responsibility of the model, we just want to get
    a filename to pass to the model
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于打开文件是模型的责任，我们只想获得一个文件名传递给模型
- en: 'These requirements clearly point to the `asksaveasfilename` function. Let''s
    take a look at the following steps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求清楚地指向了`asksaveasfilename`函数。让我们看看以下步骤：
- en: 'Start a new method on the `Application` object:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Application`对象上启动一个新方法：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The method first asks the user to select a file with a `.csv` extension; using
    the `filetypes` argument, the selection of existing files will be limited to those
    ending in `.csv` or CSV. When the dialog exits, the function will return the path
    to the selected file as a string to `filename`. Somehow, we have to get this path
    to our model.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先要求用户选择一个具有`.csv`扩展名的文件；使用`filetypes`参数，现有文件的选择将被限制为以`.csv`或CSV结尾的文件。对话框退出时，函数将将所选文件的路径作为字符串返回给`filename`。不知何故，我们必须将此路径传递给我们的模型。
- en: Currently, the filename is generated in the `Application` object's `on_save`
    method and passed into the model. We need to move `filename` to a property of
    the `Application` object so that we can override it from our `on_file_select()`
    method.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，文件名是在`Application`对象的`on_save`方法中生成并传递到模型中。我们需要将`filename`移动到`Application`对象的属性中，以便我们可以从我们的`on_file_select()`方法中覆盖它。
- en: 'Back in the `__init__()` method, add the following code line before the `settings`
    and `callbacks` definitions:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`__init__()`方法，在`settings`和`callbacks`定义之前添加以下代码行：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `self.filename` property will keep track of the currently selected save
    file. Previously, we set up our hardcoded filename inside the `on_save()` method;
    there''s no good reason to keep doing this every time `on_save()` is called, particularly
    since we''re only using it if the user hasn''t selected a file otherwise. Instead,
    move those lines from `on_save()` to just above the `self.filename` definition:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`self.filename`属性将跟踪当前选择的保存文件。以前，我们在`on_save()`方法中设置了我们的硬编码文件名；没有理由每次调用`on_save()`时都这样做，特别是因为我们只在用户没有选择文件的情况下使用它。相反，将这些行从`on_save()`移到`self.filename`定义的上方：'
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'With the default filename defined, we can supply it as a default value for `StringVar`.
    The value will be updated by `on_file_select()` whenever the user selects a filename.
    This is accomplished by the following lines at the end of `on_file_select()`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了默认文件名后，我们可以将其作为`StringVar`的默认值提供。每当用户选择文件名时，`on_file_select()`将更新该值。这是通过`on_file_select()`末尾的以下行完成的：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The reason for the `if` statement is that we only want to set a value if a file
    was actually selected by the user. Remember that the file dialogs will return
    `None` if the user cancels the operation; in this case, a user would expect that
    the currently set filename will remain the target.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`if`语句的原因是，我们只想在用户实际选择了文件时才设置一个值。请记住，如果用户取消操作，文件对话框将返回`None`；在这种情况下，用户希望当前设置的文件名仍然是目标。'
- en: Lastly, we need to make our `on_save()` method use this value when it's set
    instead of the hardcoded default.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当设置了这个值时，我们需要让我们的`on_save()`方法使用它，而不是硬编码的默认值。
- en: 'Down in the `on_save()` method, locate the line where `filename` is defined
    and change it to the following line:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`on_save()`方法中，找到定义`filename`的行，并将其更改为以下行：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That completes the code changes to make filename selection work. At this point,
    you should be able to run the application and test out the file selection functionality.
    Save a few records and note that they indeed save to the file you selected.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这完成了代码更改，使文件名选择起作用。此时，您应该能够运行应用程序并测试文件选择功能。保存几条记录并注意它们确实保存到您选择的文件中。
- en: Making our settings work
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使我们的设置生效
- en: While the file saving works, the settings do not. The `settings` menu items
    should work as expected, remaining checked or unchecked, but they don't yet change
    the behavior of the data entry form. Let's make this work.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然文件保存起作用，但设置却没有。`settings`菜单项应该按预期工作，保持选中或取消选中，但它们尚未改变数据输入表单的行为。让我们让它起作用。
- en: 'Recall that both autofill features are implemented in the `DataRecordForm`
    class''s `reset()` method. To use our new settings, we need to give our form access
    to the `settings` dictionary by performing the following steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`DataRecordForm`类的`reset()`方法中实现了两个自动填充功能。为了使用我们的新设置，我们需要通过以下步骤让我们的表单访问`settings`字典：
- en: 'Open `views.py` and update the `DataRecordForm.__init__()` method as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`views.py`并更新`DataRecordForm.__init__()`方法如下：
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We''ve added an additional positional argument, `settings`, and then set that
    to `self.settings` so that all of the methods in the class can access it. Now,
    look at the `reset()` method; currently, the date autofill code is as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个额外的位置参数`settings`，然后将其设置为`self.settings`，以便类中的所有方法都可以访问它。现在，看一下`reset()`方法；目前，日期自动填充代码如下：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We just need to make sure this happens only when `settings[''autofill date'']`
    is `True`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要确保这仅在`settings['autofill date']`为`True`时发生：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Autofilling the sheet data is already under a conditional statement, as you
    can see here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 表格数据的自动填充已经在条件语句下，如下所示：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To make the setting effective, we just need to add another condition to the
    `if` statement:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使设置生效，我们只需要在`if`语句中添加另一个条件：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The last piece of the puzzle is to make sure we're sending our `settings` dictionary
    to `DataRecordForm` when it's created.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分的难题是确保我们在创建`DataRecordForm`时将我们的`settings`字典发送到`DataRecordForm`。
- en: 'Back in the `Application` code, update our call to `DataRecordForm()` to include
    `self.settings` as follows:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`Application`代码，更新我们对`DataRecordForm()`的调用，包括`self.settings`如下：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, if you run the program, you should find that the settings are respected;
    try checking and unchecking them and see what happens after you save a record.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果运行程序，您应该会发现设置得到了尊重；尝试勾选和取消勾选它们，然后保存记录后查看发生了什么。
- en: Persisting settings
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化设置
- en: 'Our settings work, but there''s a major annoyance: they don''t persist between
    sessions. Shut down the application and start it up again, and you''ll see that
    the settings are back to their defaults. It''s not a major problem, but it''s
    a rough edge we shouldn''t leave for our users.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设置有效，但有一个主要的烦恼：它们在会话之间不持久。关闭应用程序并重新启动，您会发现设置恢复为默认值。这不是一个主要问题，但这是一个我们不应该留给用户的粗糙边缘。
- en: Python gives us a variety of ways to persist data in files. We've already experienced
    CSV, which is designed for tabular data; there are other formats designed with
    different capabilities in mind.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了各种将数据持久保存在文件中的方法。我们已经体验过CSV，它是为表格数据设计的；还有其他设计用于不同功能的格式。
- en: 'The following table shows just a few of the options for storing data available
    in the Python standard library:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格仅显示了Python标准库中可用的存储数据选项中的一些选项：
- en: '| **Library** | **Data type** | **Suitable ** | **Benefits** | **Drawbacks**
    |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| **库** | **数据类型** | **适用** | **优点** | **缺点** |'
- en: '| `pickle` | Binary | Any kind of object | Fast, easy, small files | Not safe,
    files aren''t human-readable, whole file has to be read |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `pickle` | 二进制 | 任何类型的对象 | 快速、简单、文件小 | 不安全，文件不易读，必须读取整个文件 |'
- en: '| `configparser` | Text | `key->value` pairs | Fast, easy, human-readable files
    | Can''t handle sequences or complex objects, limited heirarchy |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `configparser` | 文本 | `key->value`对 | 快速、简单、易读的文件 | 无法处理序列或复杂对象，层次有限 |'
- en: '| `json` | Text | Simple values and sequences | Widely used, easy, human-readable
    files | Can''t serialize complex objects without modification |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `json` | 文本 | 简单值和序列 | 广泛使用，易读的文件 | 无法序列化复杂对象而不经修改 |'
- en: '| `xml` | Text | Any kind of Python object | Powerful, flexible, mostly human-readable
    files | Not safe, complex to use, verbose file syntax |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `xml` | 文本 | 任何类型的Python对象 | 强大、灵活、大部分易读的文件 | 不安全，使用复杂，文件语法冗长 |'
- en: '| `sqlite` | Binary | Relational data | Fast and powerful files | Requires
    SQL knowledge, objects must be translated to tables |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `sqlite` | 二进制 | 关系数据 | 快速而强大的文件 | 需要SQL知识，对象必须转换为表 |'
- en: If this weren't enough, there are even more options available in the third-party
    libraries. Almost any of them would be suitable for storing a couple of boolean
    values, so how do we choose?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不够，第三方库中甚至还有更多选项可用。几乎任何一个都适合存储一些布尔值，那么我们该如何选择呢？
- en: SQL and XML are powerful, but far too complex for our simple needs here.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL和XML功能强大，但对于我们这里的简单需求来说太复杂了。
- en: We'd like to stick to a text format in case we need to debug a corrupt settings
    file, so `pickle` is out.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望坚持使用文本格式，以防需要调试损坏的设置文件，因此`pickle`不适用。
- en: '`configparser` would work now, but its inability to handle lists, tuples, and
    dictionaries may be limiting in the future.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configparser`现在可以工作了，但它无法处理列表、元组和字典，这在将来可能会有限制。'
- en: That leaves `json`, which is a good option. While it can't handle every kind
    of Python object, it can handle strings, numbers, and booleans, as well as lists
    and dictionaries. That should cover our configuration needs just fine.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这留下了`json`，这是一个不错的选择。虽然它不能处理每种类型的Python对象，但它可以处理字符串、数字和布尔值，以及列表和字典。这应该可以很好地满足我们的配置需求。
- en: What does it mean when we say that a library is "not safe"? Some data formats
    are designed with powerful capabilities, such as extensibility, linking, or aliasing,
    which parser libraries must implement. Unfortunately, those capabilities can be
    exploited for malicious purposes. For example, the billion laughs XML vulnerability
    combines three XML capabilities to craft a file that, when parsed, expands to
    a massive size (usually causing the program or, in some cases, the system, to
    crash).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说一个库是“不安全”时，这意味着什么？一些数据格式设计有强大的功能，比如可扩展性、链接或别名，解析库必须实现这些功能。不幸的是，这些功能可能被用于恶意目的。例如，十亿次笑XML漏洞结合了三个XML功能，制作了一个文件，当解析时，会扩展到一个巨大的大小（通常导致程序或者在某些情况下，系统崩溃）。
- en: Building a model for settings persistence
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为设置持久性构建模型
- en: As with any kind of data persistence, we need to start by implementing a model.
    As with our `CSVModel` class, the settings model needs to save and load the data,
    as well as define the layout of the settings data.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何数据持久化一样，我们需要先实现一个模型。与我们的`CSVModel`类一样，设置模型需要保存和加载数据，以及定义设置数据的布局。
- en: 'In the `models.py` file, let''s start a new class as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在`models.py`文件中，让我们按照以下方式开始一个新的类：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Just as we did with our `CSVModel` class, we''ll need to define our model''s
    schema:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的`CSVModel`类一样，我们需要定义我们模型的模式：
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `variables` dictionary will store both the schema and the values for each
    item. Each setting has a dictionary listing the data type and default value (we
    could list other attributes here if they are needed, such as minimum, maximum,
    or possible values). The `variables` dictionary will be the data structure we
    save to disk and load from disk to persist the program's settings.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`variables`字典将存储每个项目的模式和值。每个设置都有一个列出数据类型和默认值的字典（如果需要，我们可以在这里列出其他属性，比如最小值、最大值或可能的值）。`variables`字典将是我们保存到磁盘并从磁盘加载以持久化程序设置的数据结构。'
- en: The model needs a location to save the configuration file too, so our constructor
    will take the filename and path as arguments. For now, we'll just provide and
    use reasonable defaults, but in the future we may want to change these.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 模型还需要一个位置来保存配置文件，因此我们的构造函数将以文件名和路径作为参数。现在，我们只提供并使用合理的默认值，但在将来我们可能会想要更改这些值。
- en: We can't just provide a single file path, though; we have different users on
    the same computer who will want to save different settings. We need to make sure
    that the settings are saved in the individual user's home directory rather than
    a single common location.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能只提供一个单一的文件路径；我们在同一台计算机上有不同的用户，他们会想要保存不同的设置。我们需要确保设置保存在各个用户的主目录中，而不是一个单一的公共位置。
- en: 'Therefore, our `__init__()` method is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`__init__()`方法如下：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As users of the Linux or macOS Terminal will know, the `~` symbol is a Unix
    shortcut that points to the user's home directory. Python's `os.path.expanduser()`
    function translates this character into an absolute path (even on Windows), so
    that the file will be saved in the home directory of the user running the program.
    `os.path.join()` appends the filename to the expanded path, giving us a full path
    to a user-specific configuration file.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Linux或macOS终端的用户会知道，`~`符号是Unix的快捷方式，指向用户的主目录。Python的`os.path.expanduser()`函数将这个字符转换为绝对路径（即使在Windows上也是如此），这样文件将被保存在运行程序的用户的主目录中。`os.path.join()`将文件名附加到扩展路径上，给我们一个完整的路径到用户特定的配置文件。
- en: As soon as the model is created, we'll want to load the user's saved options
    from disk. Loading data from disk is a pretty basic model operation that we should
    be able to control outside the class, so we'll make this a public method.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模型被创建，我们就希望从磁盘加载用户保存的选项。从磁盘加载数据是一个非常基本的模型操作，我们应该能够在类外部控制，所以我们将这个方法设为公共方法。
- en: 'We''ll call this method `load()`, and call it here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称这个方法为`load()`，并在这里调用它：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`load()` will expect to find a JSON file containing a dictionary in the same
    format as the `variables` dictionary. It will need to load that data from the
    file and replace its own copy of `variables` from the file copy.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`load()`将期望找到一个包含与`variables`字典相同格式的字典的JSON文件。它将需要从文件中加载数据，并用文件副本替换自己的`variables`副本。'
- en: 'A simplistic implementation is as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的实现如下：
- en: '[PRE44]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `json.loads()` function reads in a JSON string and converts it to a Python
    object, which we're saving directly to our `variables` dictionary. Of course,
    there are some problems with this method. First of all, what happens if the settings
    file doesn't exist? In that case, `open` will throw an exception and the program
    will crash. Not good!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`json.loads()`函数读取JSON字符串并将其转换为Python对象，我们直接保存到我们的`variables`字典中。当然，这种方法也存在一些问题。首先，如果设置文件不存在会发生什么？在这种情况下，`open`会抛出一个异常，程序会崩溃。不好！'
- en: 'So, before we try to open the file, let''s test to see if it exists as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们尝试打开文件之前，让我们测试一下它是否存在，如下所示：
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If the file doesn't exist, the method simply returns and does nothing. It's
    perfectly reasonable for the file not to exist, especially if the user has never
    run the program or edited any of the settings. In this case, the method would
    leave `self.variables` alone and the user would end up with the defaults.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件不存在，该方法将简单地返回并不执行任何操作。文件不存在是完全合理的，特别是如果用户从未运行过程序或编辑过任何设置。在这种情况下，该方法将保持`self.variables`不变，用户将最终使用默认值。
- en: The second problem is that our settings file might exist, but contain no data
    or invalid data (such as keys not present in the `variables` dictionary), resulting
    in a crash. To prevent this, we'll pull in the JSON data to a local variable;
    we'll then update `variables` by asking `raw_values` for only those keys that
    exist in `variables`, providing a default value if they aren't present.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是我们的设置文件可能存在，但不包含任何数据或无效数据（比如`variables`字典中不存在的键），导致程序崩溃。为了防止这种情况，我们将JSON数据拉到一个本地变量中；然后通过询问`raw_values`只获取那些存在于`variables`中的键来更新`variables`，如果它们不存在，则提供一个默认值。
- en: 'The new, safer code is as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 新的、更安全的代码如下：
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Since `variables` is created with default values already in place, we just need
    to ignore `raw_values` if it doesn't have a given key or if the dictionary in
    that key doesn't contain a `values` item.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“variables”已经使用默认值创建，如果“raw_values”没有给定键，或者该键中的字典不包含“values”项，我们只需要忽略“raw_values”。
- en: 'Now that `load()` is written, let''s write a `save()` method to write our values
    to the file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在“load()”已经编写好了，让我们编写一个“save()”方法将我们的值写入文件：
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `json.dumps()` function is the inverse of `loads()`: it takes a Python
    object and returns a JSON string. Saving our `settings` data is as simple as converting
    the `variables` dictionary to a string and writing it to the specified text file.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: “json.dumps()”函数是“loads()”的反函数：它接受一个Python对象并返回一个JSON字符串。保存我们的“settings”数据就像将“variables”字典转换为字符串并将其写入指定的文本文件一样简单。
- en: The final method our model needs is a way for external code to set values; they
    could manipulate `variables` directly, but in the interest of protecting our data
    integrity, we'll do it through a method call. Keeping with Tkinter convention,
    we'll call this method `set()`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型需要的最后一个方法是让外部代码设置值的方法；他们可以直接操作“variables”，但为了保护我们的数据完整性，我们将通过方法调用来实现。遵循Tkinter的惯例，我们将称这个方法为“set()”。
- en: 'A basic implementation of the `set()` method is as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: “set()”方法的基本实现如下：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This simple method just takes a key and value and writes them to the `variables`
    dictionary. Once again, though, this opens up some potential problems; what if
    the value provided isn't valid for the data type? What if the key isn't in our
    `variables` dictionary? This could create a situation that would be hard to debug,
    so our `set()` method should safeguard against this.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的方法只是接受一个键和值，并将它们写入“variables”字典。不过，这又带来了一些潜在的问题；如果提供的值对于数据类型来说不是有效的怎么办？如果键不在我们的“variables”字典中怎么办？这可能会导致难以调试的情况，因此我们的“set()”方法应该防范这种情况。
- en: 'Change the code as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码更改如下：
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: By using the `type` strings that correspond to the names of actual Python types,
    we can match it against the value's type name using `type(value).__name__` (we
    could have used the actual type objects themselves in our `variables` dictionary,
    but those can't be serialized to JSON). Now, an attempt to write an unknown key
    or incorrect variable type will fail.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用与实际Python类型名称相对应的“type”字符串，我们可以使用“type(value).__name__”将其与值的类型名称进行匹配（我们本可以在我们的“variables”字典中使用实际的类型对象，但这些对象无法序列化为JSON）。现在，尝试写入未知键或不正确的变量类型将会失败。
- en: 'However, we shouldn''t let it fail silently; we should immediately raise `ValueError`
    to alert us to the problem as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不应该让它悄悄失败；我们应该立即引发“ValueError”来提醒我们存在问题，如下所示：
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Why raise an exception? If the test fails, it can only mean a bug in the calling
    code. With an exception, we'll know immediately if calling code is sending bad
    requests to our model. Without it, requests would fail silently, leaving a hard-to-find
    bug.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要引发异常？如果测试失败，这只能意味着调用代码中存在错误。通过异常，我们将立即知道调用代码是否向我们的模型发送了错误的请求。如果没有异常，请求将悄悄失败，留下难以发现的错误。
- en: The idea of raising an exception on purpose often seems strange to beginners;
    after all, exceptions are something we're trying to avoid, right? This is true
    in the case of small scripts where we're mainly users of existing modules; when
    writing your own module, however, exceptions are the correct way for your module
    to communicate problems to the code using it. Trying to handle—or worse, silence—bad
    behavior by external calling code will, at best, break modularity; at worst, it
    will create subtle bugs that are difficult to track down.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 故意引发异常的想法对于初学者来说通常似乎很奇怪；毕竟，我们正在尽量避免异常，对吧？对于主要是使用现有模块的小脚本来说，这是正确的；然而，当编写自己的模块时，异常是模块与使用它的代码交流问题的正确方式。试图处理或更糟糕的是消除外部调用代码的不良行为，最好会破坏模块化；在最坏的情况下，它会产生难以追踪的微妙错误。
- en: Using the settings model in our application
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用设置模型
- en: 'Our application needs to load in the settings when it starts, then save them
    automatically whenever they are changed. Currently, the application''s `settings`
    dictionary is created manually, but our model should really be telling it what
    kind of variables to create. Let''s perform the following steps for using the
    `settings` model in our application:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序在启动时需要加载设置，然后在更改设置时自动保存。目前，应用程序的“settings”字典是手动创建的，但是我们的模型应该真正告诉它创建什么样的变量。让我们按照以下步骤在我们的应用程序中使用“settings”模型：
- en: 'Replace the code that defines `Application.settings` with the following code:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换定义“Application.settings”的代码：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First, we create a `settings` model and save it to our `Application` object.
    Then, we're going to run a `load_settings()` method. This method will be responsible
    for setting up the `Application.settings` dictionary based on `settings_model`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个“settings”模型并将其保存到我们的“Application”对象中。然后，我们将运行一个“load_settings()”方法。这个方法将负责根据“settings_model”设置“Application.settings”字典。
- en: 'Now, let''s create `Application.load_settings()`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建“Application.load_settings()”：
- en: '[PRE52]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Our model stores the type and value for each variable, but our application
    needs Tkinter variables. We need a way to translate the model''s representation
    of the data into a structure that `Application` can use. A dictionary provides
    a handy way to do this as follows:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的模型存储了每个变量的类型和值，但我们的应用程序需要Tkinter变量。我们需要一种方法将模型对数据的表示转换为“Application”可以使用的结构。一个字典提供了一个方便的方法来做到这一点，如下所示：
- en: '[PRE53]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Notice that each name matches the type name of a Python built-in function.
    We could add more entries here, but this should cover most of our future needs.
    Now, we can combine this dictionary with the model''s `variables` dictionary to
    construct the `settings` dictionary:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个名称都与Python内置函数的类型名称匹配。我们可以在这里添加更多条目，但这应该涵盖我们未来的大部分需求。现在，我们可以将这个字典与模型的“variables”字典结合起来构建“settings”字典：
- en: '[PRE54]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The main reason for using Tkinter variables here is so that we can trace any
    changes the user makes to the values via the UI and respond immediately. Specifically,
    we want to save our settings whenever the user makes a change as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里使用Tkinter变量的主要原因是，我们可以追踪用户通过UI对值所做的任何更改并立即做出响应。具体来说，我们希望在用户进行更改时立即保存我们的设置，如下所示：
- en: '[PRE55]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Of course, this means we need to write a method called `Application.save_settings()`,
    which will run whenever the values are changed. `Application.load_settings()`
    is complete, so let''s do that next:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，这意味着我们需要编写一个名为“Application.save_settings()”的方法，每当值发生更改时都会运行。“Application.load_settings()”已经完成，所以让我们接着做这个：
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `save_settings()` method just needs to get the data back from `Application.settings`
    to the model and then save it:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “save_settings()”方法只需要从“Application.settings”中获取数据并保存到模型中：
- en: '[PRE57]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It's as simple as looping through `self.settings` and calling our model's `set()`
    method to pull in the values one at a time. Then, we call the model's `save()`
    method.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，只需要循环遍历“self.settings”，并调用我们模型的“set()”方法逐个获取值。然后，我们调用模型的“save()”方法。
- en: Now, you should be able to run the program and observe that the settings are
    saved, even when you close and re-open the application. You'll also find a file
    in your home directory called `abq_settings.json`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你应该能够运行程序并观察到设置被保存了，即使你关闭并重新打开应用程序。你还会在你的主目录中找到一个名为“abq_settings.json”的文件。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, our simple form has taken a big step forward towards being
    a fully-blown application. We've implemented a main menu, option settings that
    are persisted between executions, and an `About` dialog. We've added the ability
    to select a file where records are saved, and improved the visibility of form
    errors with an error dialog. Along the way, you learned about Tkinter menus, file
    dialogs, and message boxes, as well as the various options for persisting data
    in the standard library.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们简单的表单迈出了成为一个完全成熟的应用程序的重要一步。我们实现了一个主菜单，选项设置在执行之间是持久的，并且有一个“关于”对话框。我们增加了选择保存记录的文件的能力，并通过错误对话框改善了表单错误的可见性。在这个过程中，你学到了关于Tkinter菜单、文件对话框和消息框，以及标准库中持久化数据的各种选项。
- en: In the next chapter, we're going to be asked to make the program read and write.
    We'll learn about Tkinter's tree widget, how to switch between main views, and
    how to make our `CSVModel` and `DataRecordForm` classes capable of reading and
    updating existing data.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将被要求让程序读取和写入。我们将学习关于Tkinter的树部件，如何在主视图之间切换，以及如何使我们的“CSVModel”和“DataRecordForm”类能够读取和更新现有数据。
