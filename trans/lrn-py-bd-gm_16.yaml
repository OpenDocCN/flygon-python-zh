- en: Learning Game AI - Building a Bot to Play
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习游戏人工智能-构建一个玩家机器人
- en: –A game developer aims to create a game that is challenging and fun. Despite
    many attempts, many programmers have failed to do this. The main reason for the
    failure of games, is that human players love to be challenged by an artificial
    player in the gameplay. The result of the creation of such artificial players
    is generally referred to as a **non-player character** (**NPC**), or an artificial
    player. While the creation of such a player is fun (only for the programmer),
    it doesn't add any value to the game until and unless we inject some intelligence
    into that artificial player. The process of creating such NPCs and making them
    interact with human players with some degree of awareness and intelligence (closely
    comparable to human intelligence) is called **a****rtificial intelligence** (**AI**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '- 游戏开发人员的目标是创建具有挑战性和乐趣的游戏。尽管许多程序员尝试过，但许多游戏失败的主要原因是，人类玩家喜欢在游戏中受到人工玩家的挑战。创造这样的人工玩家的结果通常被称为**非玩家角色**（**NPC**）或人工玩家。虽然创建这样的玩家很有趣（只对程序员来说），但除非我们为这些人工玩家注入一些智能，否则它不会为游戏增添任何价值。创建这样的NPC并使它们以某种程度的意识和智能（与人类智能相当）与人类玩家互动的过程称为**人工智能**（**AI**）。'
- en: In this chapter, we will create an *intelligent system*, which will be able
    to compete with a human player. The system will be smart enough to make moves
    similar to the moves of the human player. The system will be able to check collisions
    on its own, check the different possible moves, and make the one that is the most
    beneficial. Which move is beneficial will be highly dependent upon the target.
    The target of the artificial player will be defined explicitly by the programmer,
    and will be based on that target—a computer player will be able to make a smart
    move. For example, in the Snake AI game, the target of the computer player is
    to make a move that will lead them closer to the snake food, and in **first-person
    shooter** (**FPS**) games, the target of an artificial player is to approach the
    human player and to start to fire at the human player.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个*智能系统*，该系统将能够与人类玩家竞争。该系统将足够智能，能够进行类似于人类玩家的移动。系统将能够自行检查碰撞，检查不同的可能移动，并进行最有利的移动。哪种移动是有利的将高度依赖于目标。人工玩家的目标将由程序员明确定义，并且基于该目标，计算机玩家将能够做出智能的移动。例如，在蛇AI游戏中，计算机玩家的目标是进行一次移动，使它们更接近蛇食物，而在**第一人称射击**（**FPS**）游戏中，人工玩家的目标是接近人类玩家并开始向人类玩家开火。
- en: 'By the end of this chapter, you will have learned how to create an artificial
    system by defining machine states—ways to define what an artificial player will
    do in any instance. Similarly, we will take the example of Snake AI in order to
    illustrate how intelligence can be added to a computer player. We will create
    different entities for the game characters: the player, the computer, and the
    frog (snake food), and explore the power of object-oriented and modular programming.
    In this chapter, you will mostly find stuff that we have already covered and learn
    how to use it efficiently in order to make productive games.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将学会如何通过定义机器状态来创建一个人工系统，以定义人工玩家在任何情况下会做什么。同样，我们将以蛇AI为例，以说明如何向计算机玩家添加智能。我们将为游戏角色创建不同的实体：玩家、计算机和青蛙（蛇食物），并探索面向对象和模块化编程的强大功能。在本章中，您将主要找到我们已经涵盖的内容，并学会如何有效地使用它以制作有生产力的游戏。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding AI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解人工智能
- en: Starting Snake AI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始蛇AI
- en: Adding a computer player
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加计算机玩家
- en: Adding intelligence to a computer player
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为计算机玩家添加智能
- en: Building the game and frog entities
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建游戏和青蛙实体
- en: Building the surface renderer and handler
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建表面渲染器和处理程序
- en: Possible modifications
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能的修改
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following list of requirements must be acquired in order to work through
    this chapter effectively:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地完成本章，必须获得以下要求清单：
- en: The Pygame editor (IDLE)—version 3.5+ is recommended
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pygame编辑器（IDLE）-建议使用3.5+版本
- en: The PyCharm IDE (refer to [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml),
    *Getting to Know Python – Setting Up Python and the Editor*, for the installation
    procedure)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm IDE（参见[第1章](0ef9574b-5690-454e-971f-85748021018d.xhtml)，*了解Python-设置Python和编辑器*，安装程序）
- en: Assets (snake and frog `.png` files)—available at the GitHub link: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter16](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter16)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资产（蛇和青蛙`.png`文件）-可在GitHub链接获取：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter16](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter16)
- en: 'Check out the following video to see the code in action:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的运行情况：
- en: '[http://bit.ly/2n79HSP](http://bit.ly/2n79HSP)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2n79HSP](http://bit.ly/2n79HSP)'
- en: Understanding AI
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解人工智能
- en: With the advent of numerous algorithms and models, today's game developers make
    use of them in order to create artificial characters, and then make them compete
    with human players. Playing a game passively, and competing with oneself, is not
    fun in real-world games anymore, thus, programmers intentionally set several difficulties
    and states, so that games are more challenging and fun. Among the several methods
    that programmers use, one of the best, and most popular, is making a computer
    compete with human beings. Sounds fun and complicated? The question that begs
    is how is it possible to create such algorithms, which will be able to compete
    with intelligent human beings. The answer is simple. We, as programmers, will
    define several smart moves, which will allow the computer to perform in a similar
    way to how we humans would respond to such situations.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着众多算法和模型的出现，今天的游戏开发者利用它们来创建人工角色，然后让它们与人类玩家竞争。在现实世界的游戏中，被动地玩游戏并与自己竞争已经不再有趣，因此，程序员故意设置了几种难度和状态，使游戏更具挑战性和乐趣。程序员使用的几种方法中，最好且最流行的之一是让计算机与人类竞争。听起来有趣且复杂吗？问题是如何可能创建这样的算法，使其能够与聪明的人类竞争。答案很简单。作为程序员，我们将定义几种聪明的移动，使计算机能够以与人类类似的方式应对这些情况。
- en: While playing games, human beings are smart enough to protect their game characters
    from obstacles and defeat. Thus, in this chapter, our main aim is to provide such
    skills for NPCs. We will use the previously made Snake game ([Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml),
    *Outdo Turtle – Snake Game UI with Pygame*), refine it a little bit, and add a
    computer player to it, which will have some degree of awareness about where the
    food (things that the snake eats) is, and where obstacles are. Speaking literally,
    we are going to define different moves for our computer character, so that it
    will have a life of its own.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩游戏时，人类足够聪明，可以保护他们的游戏角色免受障碍物和失败。因此，在本章中，我们的主要目标是为NPC提供这样的技能。我们将使用之前制作的贪吃蛇游戏（[第11章](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml)，*使用Pygame制作贪吃蛇游戏UI*），稍微完善一下，并为其添加一个具有一定意识的计算机玩家，它将知道食物（蛇吃的东西）在哪里，以及障碍物在哪里。确切地说，我们将为我们的计算机角色定义不同的移动，使其拥有自己的生活。
- en: First of all, recall [Chapter 4](22e1090d-87f1-4dd8-9f82-ff25cd4862e2.xhtml), *Data
    Structures and Functions*. In that chapter, we created a simple tic-tac-toe game,
    and embedded a simple *intelligent* algorithm in it. In that tic-tac-toe game,
    we were able to make a human player compete with the computer. We started by defining
    the models, handled the user events, and then finally added different moves in
    order for the computer to play on its own. We also tested the game, and the computer
    was able to beat the player in some instances. Thus, the basic concepts of AI
    were already learned by us back in [Chapter 4](22e1090d-87f1-4dd8-9f82-ff25cd4862e2.xhtml),
    *Data Structures and Functions*. Nevertheless, in this chapter, we are going to
    dig deeper down into the world of AI, and uncover other cool things about *intelligent
    algorithms*, which can be added into our previously made Snake game.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，回顾一下[第4章](22e1090d-87f1-4dd8-9f82-ff25cd4862e2.xhtml)，*数据结构和函数*。在那一章中，我们创建了一个简单的井字游戏，并在其中嵌入了一个简单的*智能*算法。在那个井字游戏中，我们能够让人类玩家与计算机竞争。我们首先定义了模型，处理了用户事件，然后最终添加了不同的移动，以便计算机自行游戏。我们还测试了游戏，计算机能够在某些情况下击败玩家。因此，我们在[第4章](22e1090d-87f1-4dd8-9f82-ff25cd4862e2.xhtml)，*数据结构和函数*中已经学习了基本的AI概念。然而，在本章中，我们将更深入地探索AI的世界，并揭示关于*智能算法*的其他有趣内容，这些内容可以添加到我们之前制作的贪吃蛇游戏中。
- en: To know how an AI algorithm works, we have to have a fair amount of knowledge
    of state machine charts. A state machine chart (originating generally from the
    *theory of computation*) defines what an NPC must do in different instances. We
    will learn about state machine charts, or animation charts, in the next topic.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解AI算法的工作原理，我们必须对状态机图表有相当多的了解。状态机图表（通常源自*计算理论*）定义了NPC在不同情况下必须做什么。我们将在下一个主题中学习状态机图表或动画图表。
- en: Implementing states
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现状态。
- en: 'The number of states are different for each game, and is highly dependent upon
    the complexity of the game. For instance, in a game such as an FPS, the NPCs,
    or enemies, must have different states: seeking the human player randomly, spawning
    a number of enemies randomly within player positions, shooting the human player,
    and many more. The relation between each of these states is defined by the state
    machine diagram. This diagram (not necessarily pictorial) represents the change
    from one state to another. For example, at what point should the enemy fire at
    the human player? At what distance should a random number of enemies be spawned?'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏的状态数量都不同，这取决于游戏的复杂程度。例如，在像FPS这样的游戏中，NPC或敌人必须有不同的状态：随机寻找人类玩家，在玩家位置随机生成一定数量的敌人，向人类玩家射击等等。每个状态之间的关系由状态机图表定义。这个图表（不一定是图片）代表了从一个状态到另一个状态的转变。例如，敌人在什么时候应该向人类玩家开火？在什么距离应该生成随机数量的敌人？
- en: 'The following diagram represents different states, and when such states must
    be changed from one to another:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表代表不同的状态，以及这些状态何时必须从一个状态改变到另一个状态：
- en: '![](Images/8dc4199a-500c-48da-ab7b-e1879473d42a.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8dc4199a-500c-48da-ab7b-e1879473d42a.png)'
- en: While observing the preceding diagram, you might not find it foreign. We have
    done similar things before, in the case of adding an intelligent computer player
    to the tic-tac-toe game. In the figure, we start with random enemy movement, since
    we don't want each and every enemy to be rendered in the same place. Similarly,
    after enemies are rendered, they are allowed to approach the human player. There
    is no restriction on the movement of enemies. Thus, a simple conditional check
    between the position of the enemy and the human player can be implemented, in
    order to perform vectored movements ([Chapter 10](b6bfaeca-a5ea-4d39-a757-653f2e2be083.xhtml),
    *Upgrading the Snake Game with Turtle*) for the enemies. Similarly, after each
    position change, the position of the enemies is checked against the human player's
    position, and if they are near to each other, then the enemies can begin to fire
    toward the human player.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的图表，你可能会觉得它并不陌生。我们之前在为井字游戏添加智能计算机玩家时做过类似的事情。在图中，我们从随机的敌人移动开始，因为我们不希望每个敌人都在同一个地方渲染。同样，在敌人被渲染后，它们被允许接近人类玩家。敌人的移动没有限制。因此，可以实现敌人位置和人类玩家位置之间的简单条件检查，以执行敌人的矢量移动（[第10章](b6bfaeca-a5ea-4d39-a757-653f2e2be083.xhtml)，*用海龟升级蛇游戏*）。同样，在每次位置改变后，敌人的位置与人类玩家的位置进行检查，如果它们彼此靠近，那么敌人可以开始朝向人类玩家开火。
- en: 'Between every state, there is a check on the steps, which make sure that the
    computer player is intelligent enough to compete with the human player. We can
    observe the following pseudo code, which represents the preceding machine states:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个状态之间，都有一些步骤的检查，以确保计算机玩家足够智能，可以与人类玩家竞争。我们可以观察到以下伪代码，它代表了前述的机器状态：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding pseudo code, each state defines the code, which must be executed
    in order to perform check operations such as `player_movement`, `hits_boundary`,
    and `change_movements`. Furthermore, in the case of approaching the human player,
    the pseudo code looks something like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的伪代码中，每个状态定义了必须执行的代码，以执行诸如`player_movement`、`hits_boundary`和`change_movements`之类的检查操作。此外，在接近人类玩家的情况下，伪代码看起来像下面这样：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding pseudo code is not the actual code, but it provides us with a
    blueprint about what we can expect AI to do for us. In the next topic, we will
    see how we can use our knowledge of pseudo code, and state machines, to create
    different entities for implementing AI in our snake game.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的伪代码并不是实际代码，但它为我们提供了关于我们可以期望AI为我们做什么的蓝图。在下一个主题中，我们将看到如何利用伪代码和状态机的知识，为我们的蛇游戏创建不同的实体。
- en: Starting snake AI
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始蛇AI
- en: 'As discussed in the case of FPS, similar machine states can be used in the
    case of snake AI. The two important states that need to be considered for our
    computer player in the Snake AI game are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如在FPS的情况下讨论的那样，蛇AI的情况下可以使用类似的机器状态。在蛇AI游戏中，我们的计算机玩家需要考虑的两个重要状态如下：
- en: What movements are valid for the computer player?
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机玩家有哪些有效的移动？
- en: What are the crucial stages at which changes from one state to another occur?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个状态转换到另一个状态的关键阶段是什么？
- en: With regard to the preceding points, the first one indicates that whenever the
    computer player approaches the boundary line or wall, the movements of the computer
    player must be changed (making sure it remains within the boundary line), so that
    the computer player can compete with the human player. Secondly, we have to define
    a target for the computer snake player. In the case of FPS, as stated before,
    the main target for the computer enemy, is to find a human player and perform
    a *shooting* operation, but, in snake AI, the computer player has to approach
    the food in the game. The real competition in snake AI, between, the human and
    the computer player, is who can eat the food faster.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的几点，第一点指出，每当计算机玩家接近边界线或墙壁时，必须改变计算机玩家的移动（确保它保持在边界线内），以便计算机玩家可以与人类玩家竞争。其次，我们必须为计算机蛇玩家定义一个目标。在FPS的情况下，如前所述，计算机敌人的主要目标是找到人类玩家并执行*射击*操作，但是在蛇AI中，计算机玩家必须接近游戏中的食物。蛇AI中真正的竞争在于人类和计算机玩家谁能更快地吃到食物。
- en: 'Now that we are aware of the actions that must be defined for the NPC (computer
    player), we can define the entities for the game. Similar to what we did in [Chapter
    11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake Game UI
    with Pygame*, our Snake AI has three major entities, and they are listed as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了必须为NPC（计算机玩家）定义的动作，我们可以为游戏定义实体。与我们在[第11章](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml)中所做的类似，*使用Pygame制作Outdo
    Turtle - 蛇游戏UI*，我们的蛇AI有三个主要实体，它们列举如下：
- en: '**Class** `Player`: It represents the human player, and all actions are related
    to the human—event handling, rendering, and movements.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**`Player`：它代表人类玩家，所有动作都与人类相关——事件处理、渲染和移动。'
- en: '**Class** `Computer`: It represents the computer player (a form of AI). It
    performs actions such as updating the position and updating the target.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**`Computer`：它代表计算机玩家（一种AI形式）。它执行诸如更新位置和更新目标之类的动作。'
- en: '**Class** `Frog`: It represents the food for the game. The aim of the competition
    between the human and the computer is approach to the frog as fast as possible.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**`Frog`：它代表游戏中的食物。人类和计算机之间的竞争目标是尽快接近青蛙。'
- en: 'Besides these three major game entities, there are two remaining game entities
    that define the peripheral tasks, and they are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三个主要的游戏实体之外，还有两个剩余的游戏实体来定义外围任务，它们如下：
- en: '**Class** `Collision`: It represents the class that will have a method in order
    to check whether any entity (the player or the computer) has collided with the
    boundary, or not.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**`Collision`：它代表将具有方法以检查任何实体（玩家或计算机）是否与边界发生碰撞。'
- en: '**Class** `App`: It represents the class that will render the display screen
    and check whether any entity has eaten the frog or not.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**`App`：它代表将渲染显示屏并检查任何实体是否吃掉青蛙的类。'
- en: 'Now, with the help of these entity blueprints, we can start to code. We will
    start by adding a `Player` class, along with the method that can render the player
    and handle its movement. Open your PyCharm editor, create a new project folder
    with a new Python file in it, and add the following code to it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，借助这些实体蓝图，我们可以开始编码。我们将首先添加一个`Player`类，以及可以渲染玩家并处理其移动的方法。打开你的PyCharm编辑器，在其中创建一个新的项目文件夹，然后在其中添加一个新的Python文件，并将以下代码添加到其中：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, every module will be familiar to you, except `operator`.
    When writing programs (especially when checking for collisions between the game
    entity and the boundary wall), it is extremely helpful to use mathematical functions
    in order to perform operations, rather than using mathematical operators directly.
    For instance, if you want to check `if value >= 2`, we can easily do the same
    operations by using the functions that are defined inside the `operator` module.
    In this case, we can call the `ge` method, which represents *greater than equal
    to*: `if ge(value, 2)`. Similar to the `ge` method, we can call different methods
    such as these:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，每个模块对你来说都很熟悉，除了`operator`。在编写程序时（特别是在检查游戏实体与边界墙之间的碰撞时），使用数学函数来执行操作比直接使用数学运算符要非常有帮助。例如，如果要检查`if
    value >= 2`，我们可以通过使用`operator`模块内定义的函数来执行相同的操作。在这种情况下，我们可以调用`ge`方法，它表示*大于等于*：`if
    ge(value, 2)`。类似于`ge`方法，我们可以调用诸如以下的不同方法：
- en: '`gt(a, b)`: to check whether a > b—returns `True` if a > b; otherwise, `False`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gt(a, b)`: 检查a > b—如果a > b则返回`True`；否则返回`False`'
- en: '`lt(a, b)`**:** to check whether a < b—returns `True` if a < b; otherwise,
    `False`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lt(a, b)`**:** 检查a < b—如果a < b则返回`True`；否则返回`False`'
- en: '`le(a, b)`: to check whether a <= b—returns `True` if a <= b; otherwise, `False`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`le(a, b)`: 检查a <= b—如果a <= b则返回`True`；否则返回`False`'
- en: '`eq(a, b)`: to check whether a == b—returns `True` if a == b; otherwise, `False`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eq(a, b)`: 检查a == b—如果a == b则返回`True`；否则返回`False`'
- en: 'Now that you have imported the necessary modules, let''s get to the fun stuff,
    by creating the `Player` class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经导入了必要的模块，让我们开始有趣的事情，创建`Player`类：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we started defining class attributes: (`x`, `y`) represents
    the initial snake position, `size` represents the step size of the snake block,
    `direction` (value ranges from 0 to 4) represents the current direction in which
    the snake is moving, and `length` is the original length of the snake. The value
    of the attribute named `direction` will range from 0 to 3, where 0 represents
    that the snake is moving *right*, 1 represents that the snake is moving *left*,
    and similarly, 2 and 3 are for the *up* and *down* directions, respectively.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们开始定义类属性：(`x`，`y`)代表蛇的初始位置，`size`代表蛇块的步长，`direction`（值范围从0到4）代表蛇移动的当前方向，`length`是蛇的原始长度。名为`direction`的属性的值将在0到3之间变化，其中0表示蛇向*右*移动，1表示蛇向*左*移动，类似地，2和3分别表示*上*和*下*方向。
- en: The next two class attributes are `MaxMoveAllow` and `update`. These two attributes
    will be used in the function named `updateMove` (shown in the following code),
    and they make sure that the player is not allowed to make a movement of the snake
    more than twice. It may well be case that the player might enter more than two
    arrow keys at once, but if all the effects or arrow keys are reflected at once,
    the snake will move incongruously. To omit this, we have defined the `maxMoveAllowed`
    variable, in order to ensure that, at most, two arrow key presses are handled
    at once.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个类属性是`MaxMoveAllow`和`update`。这两个属性将在名为`updateMove`的函数中使用（在下面的代码中显示），它们确保玩家不被允许使蛇移动超过两次。玩家可能会一次输入多于两个箭头键，但如果所有效果或箭头键同时反映，蛇将移动不协调。为了避免这种情况，我们定义了`maxMoveAllowed`变量，以确保最多同时处理两次箭头键按下。
- en: Similarly, we have defined the constructor inside the class, which performs
    the initialization of the class attributes. It is not limited to that—after rendering
    the snake player in a random position (done by the `for` loop), we have written
    a statement that ensures that there are no collisions at the beginning of the
    game (the highlighted part). The code implies that the position between each block
    of the snake and the other blocks must be three units apart. If you change the
    value of `self.x[0] = 2*44 to self.x[0] = 1 *44`, then a collision will happen
    between the snake head and its. Thus, to ensure that there is no collision at
    the beginning (before the players start to play), we have to provide a specific
    positional gap between the blocks.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们在类内部定义了构造函数，用于执行类属性的初始化。在渲染蛇玩家在随机位置之后（通过`for`循环完成），我们编写了一条语句，确保在游戏开始时没有碰撞（高亮部分）。代码暗示了蛇的每个方块之间的位置必须相隔三个单位。如果将`self.x[0]
    = 2*44`的值更改为`self.x[0] = 1 *44`，那么蛇头和其之间将发生碰撞。因此，为了确保在游戏开始时（玩家开始玩之前）没有碰撞，我们必须在方块之间提供特定的位置间隔。
- en: 'Now, let''s use the `MaxMoveAllow` and `updateMove` attributes to create the
    `update` function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`MaxMoveAllow`和`updateMove`属性来创建`update`函数：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code will not be foreign to you. You have seen such logic many
    times before (in [Chapter 6](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml), *Object-Oriented
    Programming*, and in [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo
    Turtle – Snake Game UI with Pygame*, while handling the snake position). To recapitulate,
    the preceding line of code changes the current position of the human player to
    a new one, based on which arrow key is pressed. You can see in the code that we
    have not handled any arrow keys (we will do this in the `App` class afterward),
    but we have created an attribute named `direction`, which can track which key
    has been pressed. If `direction` is equal to `0`, it means that the right arrow
    key has been pressed, thus, we increase the *x*-position with the block size.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码对你来说并不陌生。你以前多次见过这样的逻辑（在[第6章](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml)，“面向对象编程”中，以及[第11章](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml)，“用Pygame制作贪吃蛇游戏UI”中，处理蛇的位置时）。简而言之，前面的代码行改变了人类玩家的当前位置，根据按下的箭头键。你可以在代码中看到，我们还没有处理任何箭头键（我们将在`App`类中处理），但我们已经创建了一个名为`direction`的属性，它可以跟踪哪个键被按下。如果`direction`等于`0`，这意味着右箭头键被按下，因此我们增加*x*位置与块大小。
- en: Similarly, if `direction` is `1`, we change the *x* positional value, by decrementing
    it with a block size of `44`, which means that the snake will move toward the
    negative *x*-axis. (This information is not new; a detailed discussion can be
    found in [Chapter 9](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml), *Data Model
    Implementation.*)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果`direction`是`1`，我们通过减去块大小`44`来改变*x*位置值，这意味着蛇将朝负*x*轴移动。（这不是新信息；可以在[第9章](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml)，“数据模型实现”中找到详细讨论。）
- en: 'Now, in order to make sure that each `direction` attribute is associated with
    a value ranging from 0 to 3; we will create functions for each of them, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了确保每个`direction`属性与值0到3相关联，我们将为每个创建函数，如下所示：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Observing the preceding code, you might have noticed the importance of the
    `direction` attribute. Each movement has an associated value that can be used
    when handling user events with the `pygame` module (we will discuss this later
    in the chapter). But, for now, just have a look at the `draw` function, which
    takes the arguments of `surface` and `image` of the snake (human player), and
    blits them accordingly. You might have a question such as: instead of using the
    `direction` attribute to handle user events, why don''t we use a traditional approach
    (which we have been doing since [Chapter 8](44d5dc31-eee7-41f7-8f28-755fb5794439.xhtml),
    *Turtle Class – Drawing on the Screen*)? The question is valid, and obviously
    you can do it in that way, too, but there are major drawbacks to implementing
    such code in the case of Snake AI. Since Snake AI has two main players or game
    entities (the human being and the computer), each of them must have movements
    that are independent of one another. Thus, using traditional approaches for handling
    events differently for each entity would be both tedious and lengthy. A better
    option would be to use one attribute to track which key has been pressed, and
    handle it uniquely for each player, which we are going to do, in this case, using
    the `direction` attribute.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 观察前面的代码，你可能已经注意到`direction`属性的重要性。每个移动都有一个相关联的值，可以在处理用户事件时使用`pygame`模块（我们将在本章后面讨论）。但是，现在只需看一下`draw`函数，它接受蛇（人类玩家）的`surface`和`image`作为参数，并相应地进行blits。你可能会有这样的问题：为什么不使用传统方法（自[第8章](44d5dc31-eee7-41f7-8f28-755fb5794439.xhtml)，“Turtle
    Class – Drawing on the Screen”以来一直在使用的方法）来处理用户事件，而是使用`direction`属性？这个问题是合理的，显然你也可以以这种方式做，但在Snake
    AI的情况下，实施这样的代码存在重大缺点。由于Snake AI有两个主要玩家或游戏实体（人类和计算机），它们每个都必须有独立的移动。因此，对每个实体使用传统方法处理事件将会很繁琐和冗长。更好的选择是使用一个属性来跟踪哪个键被按下，并为每个玩家独特地处理它，这正是我们将要做的，使用`direction`属性。
- en: Now that we are done with the main human player, we will reach out to the computer
    player. We will start writing code for the `Computers` class, which will handle
    the moves that the computer makes, in the next topic.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了主要的人类玩家，我们将转向计算机玩家。我们将开始为`Computers`类编写代码，它将在下一个主题中处理计算机的移动。
- en: Adding a computer player
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加计算机玩家
- en: Finally, we are in the main part of our chapter—the meaty part—it is easier
    to add the computer snake character into the game. As with the appearance, the
    movement handling technique of the computer must resemble the human player. We
    can reuse the code that was written inside the `Player` class. The only the thing
    that must differ from the `Player` class is the *target*. In the case of the human
    player, the target is not defined, since the target of movement is implemented
    by the player's mind. For example, the human player can play the game effectively
    by controlling its snake movement in the direction of the snake food. If the snake
    food is on the left, then there is no way that the human player will press the
    right arrow key and move the snake in the opposite direction. But, the computer
    is not smart enough to think of the best way to win the game on its own. Thus,
    we have to explicitly specify the target for the computer player. This technique
    of specifying the target for an individual player/system will result in an intelligent
    system, and its application ranges widely—from games to robotics.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了本章的主要部分——重点部分——将计算机蛇角色添加到游戏中变得更容易。与外观一样，计算机的移动处理技术必须类似于人类玩家。我们可以重用`Player`类中编写的代码。唯一不同的是`Player`类的*目标*。对于人类玩家，目标未定义，因为移动的目标由玩家的思想实现。例如，人类玩家可以通过控制蛇的移动方向来有效地玩游戏。如果蛇食物在左边，那么人类玩家不会按右箭头键，使蛇朝相反方向移动。但是，计算机不够聪明，无法自行考虑赢得游戏的最佳方式。因此，我们必须明确指定计算机玩家的目标。为个别玩家/系统指定目标的技术将导致智能系统，并且其应用范围广泛——从游戏到机器人。
- en: 'For now, let''s replicate the code that was written inside the `Player` class
    and add it to the new class, which is named `Computer`. The following code represents
    the creation of the `Computer` class, along with its constructor:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们复制写在`Player`类内部的代码，并将其添加到名为`Computer`的新类中。以下代码表示了`Computer`类的创建，以及它的构造函数：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Similar to the `Player` class, it has four attributes, with `direction` specified
    with an initial value of `0`, which means that before the computer actually starts
    to play, the snake will be automatically moving in the right (positive *x*-axis)
    direction. Furthermore, everything that is initialized within the constructor
    is similar to the `Player` class, except the highlighted part of the code. The
    last line of the code has `y[0]`, which started from `4 *44`. Recalling the same
    part of code in the case of the human player, it was `2*44`, which represents
    the column position. Writing this code, we are implying that there must not be
    a collision between the human player snake and the computer player snake at the
    beginning of the game. But, the value of `x[0]` is the same, because we want each
    of the snakes to start within the same row, but not in the same column. By doing
    this, we omit their collision, and each player's snake will be rendered properly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Player`类类似，它有四个属性，其中`direction`的初始值为`0`，这意味着在计算机实际开始玩之前，蛇将自动向右（正*x*轴）方向移动。此外，构造函数中初始化的所有内容都与`Player`类相似，除了代码的突出部分。代码的最后一行是`y[0]`，它从`4*44`开始。回想一下在人类玩家的情况下，代码的相同部分是`2*44`，表示列位置。编写这段代码，我们暗示游戏开始时人类玩家蛇和计算机玩家蛇之间不应该发生碰撞。但是，`x[0]`的值是相同的，因为我们希望每条蛇都从同一行开始，但不在同一列。通过这样做，我们避免了它们的碰撞，并且每个玩家的蛇将被正确渲染。
- en: 'Similarly, we have to add the `update` method, which will reflect the changes
    in the *x*, *y* position of the computer snake, based on the `direction` attribute.
    Th following code represents the `update` method, which will make sure that the
    snake computer is limited to using a combination of only two arrow key movements
    at one time:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们必须添加`update`方法，它将根据`direction`属性反映计算机蛇的*x*、*y*位置的变化。以下代码表示了`update`方法，它将确保计算机蛇只能同时使用两个箭头键移动的组合：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code is similar to the `Player` class, so I won''t bother explaining
    it. You can refer to the `update` function of the `Player` class to see how this
    method works. Similar to the `Player` class, we have to add four methods that
    will change value of the `direction` variable accordingly:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与`Player`类类似，所以我不会费心解释它。您可以参考`Player`类的`update`函数，了解这个方法是如何工作的。与`Player`类类似，我们必须添加四个方法，这些方法将相应地改变`direction`变量的值：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code that is written will be able to update the *direction* of the computer
    player, but it is not enough to make a smart move. Let's say, if the snake food
    is on the right-hand side, the code that has been written up till now won't be
    able to track the position of the food, and thus, the computer snake might go
    to the opposite place. Thus, we have to explicitly specify that the computer player
    will move in such a direction, which is close to the position of the snake food.
    We will cover this in the next topic.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 编写的代码将能够更新计算机玩家的*direction*，但这还不足以做出聪明的移动。比如，如果蛇食在右侧，到目前为止编写的代码将无法跟踪食物的位置，因此计算机蛇可能会去相反的地方。因此，我们必须明确指定计算机玩家将朝着靠近蛇食的位置移动。我们将在下一个主题中介绍这一点。
- en: Adding intelligence to a computer player
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为计算机玩家添加智能
- en: Up till now, two game entities have been defined, and both of them handle the
    players' movements. Unlike the `Player` class, another game entity (the computer
    player) is not going to decide its next move on its own. Thus, we have to explicitly
    enjoin the computer player to make a move that would take the snake closer to
    the snake food. By doing this, there will be immense competition between the computer
    player and the human player. This looks quite complex to implement; however, the
    idea still remains the same, as discussed earlier, along with the machine state
    diagram.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，已经定义了两个游戏实体，它们都处理玩家的移动。与`Player`类不同，另一个游戏实体（计算机玩家）不会自行决定下一步的移动。因此，我们必须明确要求计算机玩家做出一步将蛇靠近食物的移动。通过这样做，计算机玩家和人类玩家之间将会有巨大的竞争。这看起来实现起来相当复杂；然而，这个想法仍然保持不变，正如之前讨论的那样，以及机器状态图。
- en: 'Going through the machine state diagram, the AI player must accommodate two
    things:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过机器状态图，AI玩家必须考虑两件事：
- en: Check the position of the snake food, and make a move in order to get closer
    to it.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查蛇食的位置，并采取行动以靠近它。
- en: Check the current position of the snake, and make sure it that doesn't hit the
    boundary wall.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查蛇的当前位置，并确保它不会撞到边界墙。
- en: 'The first step will be implemented as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步将实现如下：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding line of code, we called different previously made methods,
    such as `moveLeft()`, `moveRight()`, and so on. These methods will cause the snake
    to move as indicated by the `direction` attribute value. The `target()` method
    takes two arguments: `food_x` and `food_y`, which compositely refer to the position
    of the snake food. The operators, `gt` and `lt`, are used to perform comparison
    operations with the snake *x*-head and *y*-head positions. For instance, if the
    snake food is on the negative *x*-axis, then a comparison is made between the
    *x*-position of the snake and the *x*-position of the food (`gt(self.x[0], food_x)`).
    It is obvious that `food_x` is on the negative *x*-axis, which means that the
    snake *x*-position is greater, thus, `moveLeft()` is called. As the signature
    of the method suggests, we are going to make a turn, and move the computer player
    snake toward the negative *x*-axis. Similar comparisons are done for each (*x*,
    *y*) position of the food, and each time a different method is called, so that
    we can lead the computer player toward the snake food.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，我们调用了不同的先前创建的方法，如`moveLeft()`，`moveRight()`等。这些方法将导致蛇根据`direction`属性值移动。`target()`方法接受两个参数：`food_x`和`food_y`，它们组合地指代蛇食物的位置。操作符`gt`和`lt`用于执行与蛇的*x*-head和*y*-head位置的比较操作。例如，如果蛇食物在负*x*-轴上，那么将对蛇的*x*-位置和食物的*x*-位置进行比较（`gt(self.x[0],
    food_x)`）。显然，`food_x`在负*x*-轴上，这意味着蛇的*x*-位置更大，因此调用`moveLeft()`。正如方法的签名所暗示的，我们将转向，并将计算机玩家蛇朝着负*x*-轴移动。对食物的每个(*x*,
    *y*)位置进行类似的比较，每次调用不同的方法，以便我们可以引导计算机玩家朝着蛇食物移动。
- en: Now that we have added the simple computer player, which is able to pass through
    multiple obstacles, let's add the `Frog` and `Collision` classes in the next topic.
    The `Frog` class is responsible for rendering the frog (the snake food) on the
    screen at random positions, and `Collision` will check whether there is a collision
    between the snakes, and/or between a snake and the boundary wall.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了简单的计算机玩家，它能够通过多个障碍物，让我们在下一个主题中添加`Frog`和`Collision`类。`Frog`类负责在屏幕上随机位置渲染青蛙（蛇的食物），`Collision`将检查蛇之间是否发生碰撞，或者蛇与边界墙之间是否发生碰撞。
- en: Building the game and frog entities
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建游戏和青蛙实体
- en: As previously mentioned, we are going to add two more classes into our code
    in this topic. Each of these classes serve different purposes in our Snake AI.
    The `Game` entity will check whether there is any sort of collision, by checking
    the argument that is passed to their member methods. In the case of the `Game`
    entity, we will define a simple, yet powerful method, named `checkCollision()`,
    which will return a Boolean of either `True` or `False`, based on the collision.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将在本主题中向我们的代码中添加另外两个类。这些类在我们的Snake AI中有不同的用途。`Game`实体将通过检查传递给它们的成员方法的参数来检查是否发生任何碰撞。对于`Game`实体，我们将定义一个简单但强大的方法，名为`checkCollision()`，它将根据碰撞返回`True`或`False`的布尔值。
- en: 'The following code represents the `Game` class and its member method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示`Game`类及其成员方法：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The call to the `checkCollision()` method will be done inside the main class
    (which will be defined in a moment). But, the important thing that you will notice
    is that the argument that is passed (the *x* and *y* values), will be the current
    position of the snake, from which this method will be called. Let's say you make
    an instance of the `Game` class, and pass the (`x1`, `y1`, `x2`, and `y2`) positional
    values of the human player. In doing so, you are calling the `checkCollision`
    method for the human players. The conditional statements check whether the positional
    value of a snake is the same as the boundary wall, or not. If yes, it will return
    `True`; otherwise, it will return `False`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对`checkCollision()`方法的调用将在主类中进行（稍后将定义）。但是，你会注意到传递的参数（*x*和*y*值）将是蛇的当前位置，从中调用此方法。假设你创建了`Game`类的一个实例，并传递了人类玩家的（`x1`，`y1`，`x2`和`y2`）位置值。这样做，你就是在为人类玩家调用`checkCollision`方法。条件语句将检查蛇的位置值是否与边界墙相同。如果是，它将返回`True`；否则，它将返回`False`。
- en: 'The next important game entity is `Frog`. This class renders the image of `Frog`
    in a random position, after each time it gets eaten by any player (the human or
    the computer). The following code represents the declaration of the `Frog` class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来重要的游戏实体是`Frog`。这个类在随机位置渲染`Frog`的图像，每次被任何玩家（人类或计算机）吃掉后都会重新渲染。以下代码表示了`Frog`类的声明：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we have defined the *x*-position, the *y*-position, and
    the `draw` method in order to render the frog image. The call to this method will
    be made by creating `Frog` from the main class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们定义了*x*-位置、*y*-位置和`draw`方法，以便渲染青蛙图像。通过创建`Frog`类来调用这个方法。
- en: 'In the next topic, we will wrap up our program by creating and implementing
    one last entity: the main `App` entity. This will be the central director of our
    game.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将通过创建和实现最后一个实体：主`App`实体来完成我们的程序。这将是我们游戏的中央指挥官。
- en: Building the surface renderer and handler
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建表面渲染器和处理程序
- en: 'To begin, let''s recap what we have done so far. We started to write the code
    by defining two major game entities: `Player` and `Computer`. Both of these entities
    were quite similar in terms of actions and rendering methods, except an extra
    `target()` method was introduced within the `Computer` class, in order to make
    sure that the computer player is smart enough to compete with the human player.
    Similarly, we declared two more entities: `Game` and `Frog`. These two classes
    provide the backend facility for the Snake AI, such as adding collision logic,
    and checking the position for the snake food to be rendered in. We have created
    multiple methods within these different entities, but we have never made instances/objects
    out of them. Such instances can be created from the main single class, which we
    are going to implement now. I am going to call this class the `App` class.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下我们到目前为止所做的事情。我们开始编写代码，定义了两个主要的游戏实体：`Player`和`Computer`。这两个实体在行为和渲染方法方面都非常相似，只是在`Computer`类中引入了额外的`target()`方法，以确保计算机玩家足够聪明，能够与人类玩家竞争。同样，我们声明了另外两个实体：`Game`和`Frog`。这两个类为贪吃蛇AI提供了后端功能，比如添加碰撞逻辑，以及检查蛇食物应该渲染的位置。我们在这些不同的实体中创建了多个方法，但我们从未创建过实例/对象。这些实例可以从主要的单一类中创建，我们现在要实现这个类。我将称这个类为`App`类。
- en: 'Look at the following snippet in order to write the code for the `App` class:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码片段，以便为`App`类编写代码：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code defines some attributes, such as `Height` and `Width`, for
    the games console. Similarly, it has a constructor, which initializes the different
    class attributes, along with creating the `Player`, `Frog`, and `Computer` instances.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码定义了一些属性，比如游戏控制台的`Height`和`Width`。同样，它有一个构造函数，用于初始化不同的类属性，以及创建`Player`、`Frog`和`Computer`实例。
- en: 'Next up, is to load the image from the computer and add it to the Python project
    (refer to [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle
    – Snake Game UI with Pygame*, to learn more about the `load` method). The assets
    of the game, such as the snake body and food, are available at this GitHub link:
    [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter16](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter16).
    But, you can also create your own, and experiment with it. I have taught you how
    to create a transparent sprite using GIMP and a simple paint application before,
    in [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake
    Game UI with Pygame*. Try to recap those concepts, and it try on your own. For
    now, I am going to load two images into the Python project.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，要从计算机加载图像并将其添加到Python项目中（参考[第11章](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml)，*使用Pygame创建Outdo
    Turtle-贪吃蛇游戏UI*，了解更多关于`load`方法的信息）。游戏的资源，比如蛇身和食物，可以在这个GitHub链接上找到：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter16](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter16)。但是，你也可以自己创建并进行实验。我之前在[第11章](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml)，*使用Pygame创建Outdo
    Turtle-贪吃蛇游戏UI*中教过你如何使用GIMP和简单的绘图应用程序创建透明精灵。试着回顾一下这些概念，并自己尝试一下。现在，我要将两个图像加载到Python项目中。
- en: It is better to use a .png file for sprites, and don't create a filename with
    a numeric value in it. For example, a filename for the snake body that is named
    `snake12.png` is not valid. The filename should be given without numeric values.
    Similarly, make sure that you add those `.png` files within the Python project
    folder. Revisit [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo
    Turtle – Snake Game UI with Pygame*, to check how an image is loaded with PyCharm
    into the Python project.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用.png文件作为精灵，并且不要在文件名中包含数字值。例如，名为`snake12.png`的蛇身文件名是无效的。文件名应该不包含数字值。同样，确保将这些`.png`文件添加到Python项目文件夹中。回顾一下[第11章](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml)，*使用Pygame创建Outdo
    Turtle-贪吃蛇游戏UI*，查看如何将图像加载到Python项目中。
- en: 'The following code will load two image files into the Python project:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将加载两个图像文件到Python项目中：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding line of code, we created a `surface` object using the `pygame.display`
    module. Then, we loaded two images—`snake.png` and `frog-main.png`—into the Python
    project. The `convert()` method will change the pixel formatting of the rendered
    object, so that it works perfectly on any surface.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，我们使用`pygame.display`模块创建了一个`surface`对象。然后，我们将两个图像——`snake.png`和`frog-main.png`——加载到Python项目中。`convert()`方法将改变渲染对象的像素格式，使其在任何表面上都能完美工作。
- en: 'Similarly, if a game has events, and it interacts with the user, then the `on_event`
    method must be implemented:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果一个游戏有事件，并且与用户交互，那么必须实现`on_event`方法：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, let''s define the `main` function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们定义`main`函数：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding function, we called the `target` method to make sure that the
    computer player is able to use the capabilities that have been defined inside
    it. As discussed before, the `target()` method takes the *x*, *y* coordinates
    of the food and the computer makes a decision to move closer to the food. Similarly,
    the `update` method of both the `Player` and `Computer` classes is called.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的函数中，我们调用了`target`方法，以确保计算机玩家能够使用其中定义的功能。如前所述，`target()`方法接受食物的*x*、*y*坐标，计算机会决定靠近食物。同样，调用了`Player`和`Computer`类的`update`方法。
- en: 'Now let''s define the `renderer()` method. This method will draw the snakes
    and the food onto the game surface. This is done using the `pygame` and `draw`
    modules:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义`renderer()`方法。这个方法将把蛇和食物绘制到游戏表面上。这是使用`pygame`和`draw`模块完成的：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you feel that you do not understand the workings of the `renderer()` method,
    go to [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle
    – Snake Game UI with Pygame*. In summary, this method will draw different objects
    (`image_surf` and `Frog_surf`) onto the game screen.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得你不理解`renderer()`方法的工作原理，去[第11章](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml)，*使用Pygame创建Outdo
    Turtle-贪吃蛇游戏UI*。简而言之，这个方法将不同的对象（`image_surf`和`Frog_surf`）绘制到游戏屏幕上。
- en: 'Finally, let''s create a `handler` method. This method will handle the user
    events. Different methods, such as `moveUp()`, `moveDown()`, `moveLeft()`, and
    `moveRight()` will be called, based upon the arrow keys that are pressed by the
    user. These four methods are created within both the `Player` and `Computer` entities.
    The following code defines the `handler` method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个`handler`方法。这个方法将处理用户事件。根据用户按下的箭头键，将调用不同的方法，比如`moveUp()`、`moveDown()`、`moveLeft()`和`moveRight()`。这四个方法都在`Player`和`Computer`实体中创建。以下代码定义了`handler`方法：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding `handler` method has been created so many times before (we saw
    both advanced and easy methods), and this one is the easiest one. We used the
    `pygame` module to listen to incoming key events and handled them accordingly,
    by calling different methods. For example, when the user pressed the down arrow
    key, the `moveDown()` method was called. The last `sleep` method will embed the
    timer, so that there is a difference between two successive key events.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`handler`方法已经被创建了很多次（我们看到了高级和简单的方法），这个是最简单的一个。我们使用了`pygame`模块来监听传入的按键事件，并根据需要处理它们，通过调用不同的方法。例如，当用户按下向下箭头键时，就会调用`moveDown()`方法。最后的`sleep`方法将嵌入计时器，以便在两次连续的按键事件之间有所区别。
- en: 'Finally, let''s call this `handler` method:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们调用这个`handler`方法：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s run our game and observe the output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行游戏并观察输出：
- en: '![](Images/d6ac8fdd-419c-4f70-911f-1a8a03bde72f.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d6ac8fdd-419c-4f70-911f-1a8a03bde72f.png)'
- en: 'As expected, there are several things that must be added to this game, including:
    what happens when the human player and the computer player eat the food, and what
    happens when the snake collides with itself? If you have followed the book throughout,
    properly, this should be a piece of cake for you. We have added this same logic
    multiple times (in [Chapter 7](2d97aa5e-7fdd-459d-9c73-626e29c3a0ed.xhtml), *List
    Comprehension and Properties*; [Chapter 10](b6bfaeca-a5ea-4d39-a757-653f2e2be083.xhtml),
    *Upgrading the Snake Game with Turtle*; and [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo
    Turtle – Snake Game UI with Pygame*). But apart from that logic, focus on the
    two alike snakes: one must be moving with human player actions, and the other
    independently. The computer snake was aware of the collision with the boundary
    wall and the position of the food. As soon as you run your game, the computer
    player will react instantaneously, and will try to make a smart move, before the
    human does. This is the application of AI in the real-world gaming industry. Although
    you might think that the Snake AI example is simpler, in the real world, AI is
    also all about the machine acting independently, regardless of how complex the
    algorithm is.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，这个游戏还需要添加一些东西，包括：当人类玩家和电脑玩家吃到食物时会发生什么，以及蛇与自身碰撞时会发生什么？如果你一直正确地跟随本书，这对你来说应该是小菜一碟。我们已经多次添加了相同的逻辑（在[第7章](2d97aa5e-7fdd-459d-9c73-626e29c3a0ed.xhtml)，*列表推导和属性*；[第10章](b6bfaeca-a5ea-4d39-a757-653f2e2be083.xhtml)，*用海龟升级蛇游戏*；和[第11章](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml)，*用Pygame超越海龟-蛇游戏UI*）。但除了这个逻辑，还要关注两条相似的蛇：一条必须根据人类玩家的行动移动，另一条则独立移动。计算机蛇知道与边界墙的碰撞和食物的位置。一旦你运行游戏，计算机玩家将立即做出反应，并试图做出聪明的移动，早于人类玩家。这就是在现实游戏行业中应用人工智能。虽然你可能认为蛇AI示例更简单，但在现实世界中，AI也是关于机器独立行动，无论算法有多复杂。
- en: But, there are several tweaks that must be made within the game, which will
    be covered in the next topic—*Possible modifications*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，游戏中必须进行一些调整，这将在下一个主题“可能的修改”中进行讨论。
- en: Game testing and possible modifications
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏测试和可能的修改
- en: 'First of all, I suggest that you look back and observe the part where we defined
    the `Game` class. We defined the `checkCollision()` method inside it. This method
    can be used for multiple purposes: firstly, to check whether a player collides
    with the snake food; and secondly, to check whether a player collides with the
    boundary wall, or not. You must have a *gotcha* moment at this time. [Chapter
    7](2d97aa5e-7fdd-459d-9c73-626e29c3a0ed.xhtml), *List Comprehension and Properties*, to
    [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake
    Game UI with Pygame*, was all about using this technique to implement the collision
    principle, which states that, *If the (x, y) position of food objects is same
    with the (x, y) coordinates of any player, there is said to be a collision.*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我建议你回头观察我们定义`Game`类的部分。我们在其中定义了`checkCollision()`方法。这个方法可以用于多种目的：首先，检查玩家是否与蛇食物发生碰撞；其次，检查玩家是否与边界墙发生碰撞。这个时候你一定会有一个“恍然大悟”的时刻。[第7章](2d97aa5e-7fdd-459d-9c73-626e29c3a0ed.xhtml)，*列表推导和属性*，到[第11章](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml)，*用Pygame超越海龟-蛇游戏UI*，都是关于使用这种技术来实现碰撞原理的，即*如果食物对象的（x，y）位置与任何玩家的（x，y）坐标相同，则称为发生碰撞*。
- en: 'Let''s add code that will check whether any player has collided with the food
    or not:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加代码来检查任何玩家是否与食物发生了碰撞：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similarly, let''s use the same function to check whether the human player''s
    snake has hit the boundary wall or not. You might think that you need to check
    this in the case of the computer player too, but that is useless, because the
    `target` method that was defined in the `Computer` class will not let this happen.
    In other words, the computer player will never hit the boundary wall, thus, checking
    whether a collision happened or not is useless. But, in the case of the human
    player, we will check it using the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们使用相同的函数来检查人类玩家的蛇是否撞到了边界墙。你可能认为在计算机玩家的情况下也需要检查这一点，但这是没有意义的，因为在`Computer`类中定义的`target`方法不会让这种情况发生。换句话说，计算机玩家永远不会撞到边界墙，因此检查是否发生碰撞是没有意义的。但是，在人类玩家的情况下，我们将使用以下代码进行检查：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will end this topic right here, but you can make this game even more appealing
    by adding a g*ame over* screen, which we learned how to create using `pygame` back
    in [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake
    Game UI with Pygame*. Instead of the last `pass` statement, you can create a surface
    and render a font with a label in it, in order to create such a game over screen.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里结束这个话题，但是您可以通过添加一个游戏结束屏幕使这个游戏更具吸引力，我们已经学会了如何使用`pygame`在[第11章](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml)中创建。您可以创建一个表面并在其中渲染一个带有标签的字体，以创建这样一个游戏结束屏幕，而不是最后的`pass`语句。
- en: 'But, before wrapping up this chapter, let''s look at the final output of our
    game:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在结束本章之前，让我们来看看我们游戏的最终输出：
- en: '![](Images/2c8da6fd-a322-4771-9da9-f4c1773a3e55.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2c8da6fd-a322-4771-9da9-f4c1773a3e55.png)'
- en: 'Another thing that you might notice in the game is that the computer player''s
    snake *length* is constant, even if it eats the food. I did this intentionally,
    so that my game screen wouldn''t be polluted too much. But, if you want to increase
    the computer player''s snake length (every time the snake eats the food), you
    can add a statement after the computer player snake eats the frog:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中您可能注意到的另一件事是，计算机玩家的蛇*长度*是恒定的，即使它吃了食物。我故意这样做，以免我的游戏屏幕被污染太多。但是，如果您想增加计算机玩家的蛇长度（每次蛇吃食物时），您可以在计算机玩家蛇吃青蛙后添加一个语句：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we have come to the end of this chapter. We have learned different
    things, as well as revising old ones. The concepts that are associated with AI
    are vast; we have just attempted to touch the surface. You can find other implications
    of AI in the game using Python by heading to this URL: [https://www.pygame.org/tags/ai](https://www.pygame.org/tags/ai).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了本章的结束。我们学到了不同的东西，也复习了旧知识。与人工智能相关的概念是广泛的；我们只是尝试触及表面。您可以通过访问以下网址找到使用Python在游戏中的其他AI含义：[https://www.pygame.org/tags/ai](https://www.pygame.org/tags/ai)。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the basic way of implementing AI in our game. Nonetheless,
    the workings of AI depend heavily on rewarding the intelligent system for its
    each and every move. We used a machine state diagram to define the possible states
    for our computer player, and used it to perform different actions for each entity.
    We employed different programming paradigms in this single chapter; in fact, it
    was a recap of everything that we have learned so far, in addition to employing
    smart algorithms for NPCs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在游戏中实现AI的基本方法。然而，AI的工作方式在很大程度上取决于奖励智能系统的每一步。我们使用了机器状态图来定义计算机玩家的可能状态，并用它来执行每个实体的不同动作。在这一章中，我们采用了不同的编程范式；事实上，这是对我们迄今为止学到的一切的回顾，另外还使用了智能算法来处理NPC。
- en: For each defined entity, we made a class, and employed an object-oriented paradigm
    such as the encapsulation and model, based on properties and methods. Furthermore,
    we defined different classes such as `Frog` and `Game` in order to implement the
    logic for collisions. The reason for making separate classes for implementing
    single logic is because these methods should be called by each game entity (`Player`
    and `Computer`) independently. You could infer it as multi-inheritance. The main
    aim of this book was to make the reader understand how a gaming bot can be created
    with Python. Furthermore, to some extent, the aim was to revise all the programming
    paradigms that we have learned throughout the book, in a single chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个定义的实体，我们都创建了一个类，并采用了基于属性和方法的封装和模型的面向对象范式。此外，我们定义了不同的类，如`Frog`和`Game`，以实现碰撞的逻辑。为了实现单一逻辑，我们为每个游戏实体（`Player`和`Computer`）创建了单独的类。您可以将其理解为多重继承。本书的主要目的是让读者了解如何使用Python创建游戏机器人。此外，某种程度上，目的是在单一章节中复习我们在整本书中学到的所有编程范式。
- en: As the old adage says: *Known is a drop. Unknown is an Ocean*. I hope you are
    still yearning to learn more about Python. I suggest you brush up on your basic
    programming skills and experiment more often, which will surely lead you to your
    dream job of becoming a game developer. The gaming industry is huge, and having
    knowledge of Python will make a difference. Python is a beautiful language, thus,
    you will be incentivized to learn it more deeply, and this book will be the first
    of many steps that you will take in order to become an expert in Python.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如古谚所说：*已知乃一滴，未知则是海洋*。我希望您仍然渴望更多地了解Python。我建议您加强基本的编程技能并经常进行实验，这将确实帮助您实现成为游戏开发人员的梦想工作。游戏行业是巨大的，掌握Python知识将会产生巨大影响。Python是一种美丽的语言，因此您将受到更深入学习的激励，而这本书将是您迈向成为Python专家的第一步。
