- en: Network Security with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行网络安全
- en: In my opinion, network security is a tricky topic to write about. The reason
    is not a technical one, but rather to do with setting up the right scope. The
    boundaries of network security are so wide that they touch all seven layers of
    the OSI model. From layer 1 of wiretapping to layer 4 of the transport protocol
    vulnerability, to layer 7 of man-in-the-middle spoofing, network security is everywhere.
    The issue is exacerbated by all the newly discovered vulnerabilities, which sometimes
    seem to be at a daily rate. This does not even include the human social engineering
    aspect of network security.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，网络安全是一个难以撰写的话题。原因不是技术上的，而是与设定正确的范围有关。网络安全的边界如此之广，以至于它们触及OSI模型的所有七层。从窃听的第1层到传输协议漏洞的第4层，再到中间人欺骗的第7层，网络安全无处不在。问题加剧了所有新发现的漏洞，有时似乎以每日的速度出现。这甚至没有包括网络安全的人为社会工程方面。
- en: As such, in this chapter, I would like to set the scope for what we will discuss.
    As we have been doing up to this point, we will primarily focus on using Python
    for network device security at OSI layers 3 and 4\. We will look at Python tools
    that we can use to manage individual network devices for security purposes, as
    well as using Python as a glue to connect different components. Hopefully, we
    can treat network security with a holistic view by using Python in different OSI
    layers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我想设定我们将讨论的范围。与迄今为止一样，我们将主要专注于使用Python来处理OSI第3和第4层的网络设备安全。我们将研究可以用于管理个别网络设备以实现安全目的的Python工具，以及使用Python作为连接不同组件的粘合剂。希望我们可以通过在不同的OSI层中使用Python来全面地处理网络安全。
- en: 'In this chapter, we will take a look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下主题：
- en: The lab setup
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验室设置
- en: Python Scapy for security testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python Scapy用于安全测试
- en: Access lists
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问列表
- en: Forensic analysis with Syslog and UFW using Python
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python进行Syslog和UFW的取证分析
- en: Other tools, such as a MAC address filter list, private VLAN, and Python IP
    table binding
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他工具，如MAC地址过滤列表、私有VLAN和Python IP表绑定。
- en: The lab setup
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验室设置
- en: The devices being used in this chapter are a bit different from the previous
    chapters. In the previous chapters, we were isolating a particular device by focusing
    on the topic at hand. For this chapter, we will use a few more devices in our
    lab in order to illustrate the function of the tools that we will be using. The
    connectivity and operating system information are important as they have ramifications
    regarding the security tools that we will show later in this chapter. For example,
    if we want to apply an access list to protect the server, we need to know what
    the topology looks like and which direction the client is making their connections
    from. The Ubuntu host connections are a bit different than what we have seen so
    far, so please make reference back to this lab section when you see the example
    later if needed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的设备与之前的章节有些不同。在之前的章节中，我们通过专注于手头的主题来隔离特定的设备。对于本章，我们将在我们的实验室中使用更多的设备，以便说明我们将使用的工具的功能。连接和操作系统信息很重要，因为它们对我们稍后将展示的安全工具产生影响。例如，如果我们想应用访问列表来保护服务器，我们需要知道拓扑图是什么样的，客户端的连接方向是什么。Ubuntu主机的连接与我们迄今为止看到的有些不同，因此如果需要，当您稍后看到示例时，请参考本实验室部分。
- en: 'We will be using the same Cisco VIRL tool with four nodes: two hosts and two
    network devices. If you need a refresher on Cisco VIRL, feel free to go back to
    [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml), *Low-Level Network Device
    Interactions,* where we first introduced the tool:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的Cisco VIRL工具，其中包括四个节点：两个主机和两个网络设备。如果您需要关于Cisco VIRL的复习，请随时返回到[第2章](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml)，*低级网络设备交互*，我们在那里首次介绍了这个工具：
- en: '![](assets/620c32a2-6ce0-471f-a165-264f14e09454.png)Lab topologyThe IP addresses
    listed will be different in your own lab. They are listed here for an easy reference
    for the rest of the chapter.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/620c32a2-6ce0-471f-a165-264f14e09454.png)实验拓扑图列出的IP地址在您自己的实验室中将是不同的。它们在这里列出，以便在本章的其余部分中进行简单参考。'
- en: 'As illustrated, we will rename the host on the top as the client and the bottom
    host as the server. This is analogous to an internet client trying to access a
    corporate server within our network. We will again use the Shared flat network
    option for the management network to access the devices for the out-of-band management:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，我们将把顶部的主机重命名为客户端，底部的主机重命名为服务器。这类似于互联网客户端试图在我们的网络中访问公司服务器。我们将再次使用共享平面网络选项来访问设备进行带外管理：
- en: '![](assets/2365022c-82e9-4928-ab1e-620b2e95b72c.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2365022c-82e9-4928-ab1e-620b2e95b72c.png)'
- en: 'For the two switches, I will choose **Open Shortest Path First** (**OSPF**)
    as `IGP` and put both the devices in area `0`. By default, `BGP` is turned on
    and both the devices are using AS 1\. From the configuration auto generation,
    the interfaces connected to the Ubuntu hosts are put into OSPF area `1`, so they
    will show up as inter-area routes. The NX-OSv configurations are shown here and
    the IOSv configuration and output are similar:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个交换机，我将选择**开放最短路径优先**（**OSPF**）作为`IGP`，并将两个设备放入区域`0`。默认情况下，`BGP`已打开，并且两个设备都使用AS
    1。从配置自动生成中，连接到Ubuntu主机的接口被放入OSPF区域`1`，因此它们将显示为区间路由。NX-OSv的配置如下所示，IOSv的配置和输出类似：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The OSPF neighbor and the BGP output for NX-OSv are shown here, and the IOSv
    output is similar:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: OSPF邻居和NX-OSv的BGP输出如下所示，IOSv的输出类似：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The hosts in our network are running Ubuntu 14.04, similar to the Ubuntu VM
    16.04 that we have been using up to this point:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们网络中的主机正在运行Ubuntu 14.04，与迄今为止我们一直在使用的Ubuntu VM 16.04类似：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On both of the Ubuntu hosts, there are two network interfaces, `eth0` and `eth1`.
    `eth0` connects to the management network (`172.16.1.0/24`) while `eth1` connects
    to the network devices (`10.0.0.x/30`). The routes to the device loopback are
    directly connected to the network block, and the remote host network is statically
    routed to `eth1` with the default route going toward the management network:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在两台Ubuntu主机上，有两个网络接口，`eth0`和`eth1`。`eth0`连接到管理网络（`172.16.1.0/24`），而`eth1`连接到网络设备（`10.0.0.x/30`）。设备环回的路由直接连接到网络块，远程主机网络通过默认路由静态路由到`eth1`：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To verify the client-to-server path, let''s ping and trace the route to make
    sure that traffic between our hosts is going through the network devices instead
    of the default route:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证客户端到服务器的路径，让我们ping和跟踪路由，确保我们的主机之间的流量通过网络设备而不是默认路由：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Great! We have our lab; we are now ready to look at some security tools and
    measures using Python.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们有了实验室，现在准备使用Python来查看一些安全工具和措施。
- en: Python Scapy
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python Scapy
- en: Scapy ([https://scapy.net](https://scapy.net/)) is a powerful Python-based interactive
    packet crafting program. Outside of some expensive commercial programs, very few
    tools can do what Scapy can do, to my knowledge. It is one of my favorite tools
    in Python.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy（[https://scapy.net](https://scapy.net/)）是一个功能强大的基于Python的交互式数据包构建程序。除了一些昂贵的商业程序外，据我所知，很少有工具可以做到Scapy所能做的。这是我在Python中最喜欢的工具之一。
- en: 'The main advantage of Scapy is that it allows you to craft your own packet
    from the very basic level. In the words of Scapy''s creator:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy的主要优势在于它允许您从非常基本的级别构建自己的数据包。用Scapy的创作者的话来说：
- en: '"Scapy is a powerful interactive packet manipulation program. It is able to
    forge or decode packets of a wide number of protocols, send them on the wire,
    capture them, match requests and replies, and much more.... with most other tools,
    you won''t build something the author did not imagine. These tools have been built
    for a specific goal and can''t deviate much from it."'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: “Scapy是一个功能强大的交互式数据包操作程序。它能够伪造或解码大量协议的数据包，将它们发送到网络上，捕获它们，匹配请求和响应，等等……与大多数其他工具不同，您不会构建作者没有想象到的东西。这些工具是为了特定的目标而构建的，不能偏离太多。”
- en: Let's take a look at the tool.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个工具。
- en: Installing Scapy
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Scapy
- en: At the time of writing, Scapy 2.3.1 supported Python 2.7\. Unfortunately, there
    were a few misfires regarding Python 3 support for Scapy and it is still relatively
    new for Scapy 2.3.3\. For your environment, please feel free to try out Python
    3 with version 2.3.3 and later. In this chapter, we will use Scapy 2.3.1 with
    Python 2.7\. See the information sidebar if you would like to learn more about
    the reason behind the choice.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Scapy 2.3.1支持Python 2.7。不幸的是，关于Scapy对Python 3的支持出现了一些问题，对于Scapy 2.3.3来说，这仍然是相对较新的。对于您的环境，请随时尝试使用版本2.3.3及更高版本的Python
    3。在本章中，我们将使用Python 2.7的Scapy 2.3.1。如果您想了解选择背后的原因，请参阅信息侧栏。
- en: The long story for Python 3 support in Scapy is that there was an independent
    fork of Scapy from version 2.2.0 in 2015, aimed at supporting only Python 3\.
    The project was named `Scapy3k`. The fork diverged from the main Scapy code base.
    If you read the first edition of this book, that was the information provided
    at the time of writing. There were confusions surrounding `python3-scapy` on PyPI
    and the official support of the Scapy code base. Our main purpose was to learn
    about Scapy in this chapter, and so therefore I made the choice to use an older,
    Python 2-based Scapy version.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Scapy在Python 3中的支持的长篇故事是，2015年有一个独立的Scapy分支，旨在仅支持Python 3。该项目被命名为`Scapy3k`。该分支与主要的Scapy代码库分道扬镳。如果您阅读本书的第一版，那是写作时提供的信息。关于PyPI上的`python3-scapy`和Scapy代码库的官方支持存在混淆。我们的主要目的是在本章中了解Scapy，因此我选择使用较旧的基于Python
    2的Scapy版本。
- en: 'In our lab, since we are crafting packet sources from the client to the destination
    server, Scapy needs to be installed on the client:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实验室中，由于我们正在从客户端向目标服务器构建数据包源，因此需要在客户端上安装Scapy：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is a quick test to make sure that the packages have been installed correctly:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速测试，以确保软件包已正确安装：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Interactive examples
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式示例
- en: 'In our first example, we will craft an **Internet Control Message Protocol**
    (**ICMP**) packet on the client and send it to the server. On the server side,
    we will use `tcpdump` with a host filter to see the packet coming in:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，我们将在客户端上构建一个**Internet控制消息协议**（**ICMP**）数据包，并将其发送到服务器。在服务器端，我们将使用`tcpdump`和主机过滤器来查看传入的数据包：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, it is very simple to craft a packet from Scapy. Scapy allows
    you to build the packet layer by layer using the slash (`/`) as the separator.
    The `send` function operates at the layer 3 level, which takes care of routing
    and layer 2 for you. There is also a `sendp()` alternative that operates at layer
    2, which means you will need to specify the interface and link layer protocol.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，使用Scapy构建数据包非常简单。Scapy允许您使用斜杠（`/`）作为分隔符逐层构建数据包。`send`函数在第3层级别操作，负责路由和第2层级别。还有一个`sendp()`替代方案，它在第2层级别操作，这意味着您需要指定接口和链路层协议。
- en: 'Let''s look at capturing the returned packet by using the send-request (`sr`)
    function. We are using a special variation of `sr`, called `sr1`, which only returns
    one packet that answers from the packet sent:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用发送请求（`sr`）函数来捕获返回的数据包。我们使用`sr`的特殊变体，称为`sr1`，它只返回一个回答发送的数据包：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'One thing to note is that the `sr()` function itself returns a tuple containing
    answered and unanswered lists:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，`sr()`函数本身返回一个包含已回答和未回答列表的元组：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we were to only take a look at the answered packet list, we can see it is
    another tuple containing the packet that we have sent as well as the returned
    packet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只看已回答的数据包列表，我们可以看到它是另一个包含我们发送的数据包以及返回的数据包的元组：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Scapy also provides a layer 7 construct as well, such as a `DNS` query. In
    the following example, we are querying an open DNS server for the resolution of
    `www.google.com`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy还提供了一个第7层的构造，比如`DNS`查询。在下面的例子中，我们正在查询一个开放的DNS服务器来解析`www.google.com`：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Sniffing
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嗅探
- en: 'Scapy can also be used to easily capture packets on the wire:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy还可以用于轻松捕获网络上的数据包：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can look at the packets in some more detail, including the raw format:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更详细地查看数据包，包括原始格式：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have seen the basic workings of Scapy. Let's move on and see how we can use
    Scapy for some of the common security testings.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Scapy的基本工作原理。让我们继续看看如何使用Scapy进行一些常见的安全测试。
- en: The TCP port scan
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP端口扫描
- en: The first step for any potential hackers is almost always trying to learn which
    service is open on the network, so they can concentrate their effort on the attack.
    Of course, we need to open certain ports in order to service our customer; that
    is part of the risk we need to accept. But we should also close any other open
    port that needlessly expose a larger attack surface. We can use Scapy to do a
    simple TCP open port scan to scan our own host.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 任何潜在黑客的第一步几乎总是尝试了解网络上开放的服务，这样他们就可以集中精力进行攻击。当然，我们需要打开某些端口以为客户提供服务；这是我们需要接受的风险的一部分。但我们还应该关闭任何不必要暴露更大攻击面的其他开放端口。我们可以使用Scapy对我们自己的主机进行简单的TCP开放端口扫描。
- en: 'We can send a `SYN` packet and see whether the server will return with `SYN-ACK`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以发送一个`SYN`数据包，看服务器是否会返回`SYN-ACK`：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that, in the output here, the server is responding with a `RESET+ACK`
    for TCP port `23`. However, TCP port `22` (SSH) is open; therefore, a `SYN-ACK`
    is returned:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这里的输出中，服务器对TCP端口`23`响应了`RESET+ACK`。然而，TCP端口`22`（SSH）是开放的；因此返回了`SYN-ACK`：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also scan a range of destination ports from `20` to `22`; note that
    we are using `sr()` for send-receive instead of the `sr1()` send-receive-one-packet
    variant:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以扫描从`20`到`22`的一系列目标端口；请注意，我们使用`sr()`进行发送-接收，而不是`sr1()`发送-接收一个数据包的变体：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can also specify a destination network instead of a single host. As you
    can see from the `10.0.0.8/29` block, hosts `10.0.0.9`, `10.0.0.13`, and `10.0.0.14`
    returned with `SA`, which corresponds to the two network devices and the host:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定目标网络而不是单个主机。从`10.0.0.8/29`块中可以看到，主机`10.0.0.9`、`10.0.0.13`和`10.0.0.14`返回了`SA`，这对应于两个网络设备和主机：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Based on what we have learned so far, we can make a simple script for reusability,
    `scapy_tcp_scan_1.py`. We start with the suggested importing of `scapy` and the
    `sys` module for taking in arguments:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们迄今为止学到的知识，我们可以编写一个简单的可重用脚本`scapy_tcp_scan_1.py`。我们从建议的导入`scapy`和`sys`模块开始，用于接收参数：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `tcp_scan()` function is similar to what we have seen up to this point:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`tcp_scan()`函数与我们到目前为止看到的类似：'
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can then acquire the input from arguments, and then call the `tcp_scan()`
    function in `main()`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以从参数中获取输入，然后在`main()`中调用`tcp_scan()`函数：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Remember that access to the low-level network requires root access; therefore,
    our script needs to be executed as `sudo`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，访问低级网络需要root访问权限；因此，我们的脚本需要以`sudo`执行：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This was a relatively lengthy example of the TCP scan script, which demonstrated
    the power of crafting your own packet with Scapy. We tested out the steps in the
    interactive shell and finalized the usage with a simple script. Let's look at
    some more examples of Scapy's usage for security testing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对较长的TCP扫描脚本示例，演示了使用Scapy构建自己的数据包的能力。我们在交互式shell中测试了这些步骤，并用一个简单的脚本完成了使用。让我们看看Scapy在安全测试中的一些更多用法。
- en: The ping collection
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ping集合
- en: Let's say our network contains a mix of Windows, Unix, and Linux machines with
    users adding their own **Bring Your Own Device** (**BYOD**); they may or may not
    support an ICMP ping. We can now construct a file with three types of common pings
    for our network, the ICMP, TCP, and UDP pings, in `scapy_ping_collection.py`*:*
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的网络包含Windows、Unix和Linux机器的混合，用户添加了自己的**自带设备**（**BYOD**）；他们可能支持也可能不支持ICMP
    ping。我们现在可以构建一个文件，其中包含我们网络中三种常见ping的ICMP、TCP和UDP ping，在`scapy_ping_collection.py`中*：*
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this example, we will also use `summary()` and `sprintf()` for the output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还将使用`summary()`和`sprintf()`进行输出：
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you were wondering why there is a lambda in the preceding `answer_summary()`
    function, it is a way to create a small anonymous function. Basically, it is a
    function without a name. More information on it can be found at [https://docs.python.org/3.5/tutorial/controlflow.html#lambda-expressions](https://docs.python.org/3.5/tutorial/controlflow.html#lambda-expressions).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么在前面的`answer_summary()`函数中有一个lambda，那是一种创建小型匿名函数的方法。基本上，它是一个没有名字的函数。关于它的更多信息可以在[https://docs.python.org/3.5/tutorial/controlflow.html#lambda-expressions](https://docs.python.org/3.5/tutorial/controlflow.html#lambda-expressions)找到。
- en: 'We can then execute all three types of pings on the network in one script:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在一个脚本中执行网络上的三种ping类型：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At this point, hopefully, you will agree with me that, by having the ability
    to construct your own packet, you can be in charge of the type of operations and
    tests that you would like to run.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，希望你会同意我的观点，通过拥有构建自己的数据包的能力，你可以控制你想要运行的操作和测试的类型。
- en: Common attacks
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见攻击
- en: In this example, let's look at how we can construct our packet to conduct some
    of the classic attacks, such as *Ping of Death* ([https://en.wikipedia.org/wiki/Ping_of_death](https://en.wikipedia.org/wiki/Ping_of_death))
    and *Land Attack* ([https://en.wikipedia.org/wiki/Denial-of-service_attack](https://en.wikipedia.org/wiki/Denial-of-service_attack)).
    This is perhaps the network penetration tests that you previously had to pay for
    with a similar commercial software. With Scapy, you can conduct the test while
    maintaining full control as well as adding more tests in the future.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们看看如何构造我们的数据包来进行一些经典攻击，比如*Ping of Death* ([https://en.wikipedia.org/wiki/Ping_of_death](https://en.wikipedia.org/wiki/Ping_of_death))
    和 *Land Attack* ([https://en.wikipedia.org/wiki/Denial-of-service_attack](https://en.wikipedia.org/wiki/Denial-of-service_attack))。这可能是您以前必须使用类似的商业软件付费的网络渗透测试。使用Scapy，您可以在保持完全控制的同时进行测试，并在将来添加更多测试。
- en: 'The first attack basically sends the destination host with a bogus IP header,
    such as the length of 2 and the IP version 3:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次攻击基本上发送了一个带有虚假IP头的目标主机，例如长度为2和IP版本3：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `ping_of_death_attack` consists of the regular ICMP packet with a payload
    bigger than 65,535 bytes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`ping_of_death_attack`由常规的ICMP数据包组成，其负载大于65,535字节：'
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `land_attack` wants to redirect the client response back to the client
    itself and exhausts the host''s resources:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`land_attack`想要将客户端响应重定向回客户端本身，并耗尽主机的资源：'
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These are pretty old vulnerabilities or classic attacks that the modern operating
    system is no longer susceptible to. For our Ubuntu 14.04 host, none of the preceding
    attacks will bring it down. However, as more security issues are being discovered,
    Scapy is a great tool to start tests against our own network and host without
    having to wait for the impacted vendor to give you a validation tool. This is
    especially true for the zero-day (published without prior notification) attacks
    that seem to be more and more common on the internet.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '这些都是相当古老的漏洞或经典攻击，现代操作系统不再容易受到攻击。对于我们的Ubuntu 14.04主机，前面提到的攻击都不会使其崩溃。然而，随着发现更多安全问题，Scapy是一个很好的工具，可以开始对我们自己的网络和主机进行测试，而不必等待受影响的供应商提供验证工具。这对于零日（未经事先通知发布的）攻击似乎在互联网上变得越来越常见尤其如此。 '
- en: Scapy resources
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scapy资源
- en: We have spent quite a bit of effort working with Scapy in this chapter. This
    is partially due to how highly I personally think of the tool. I hope you agree
    with me that Scapy is a great tool to keep in your toolset as a network engineer.
    The best part about Scapy is that it is constantly being developed with an engaged
    community of users.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中花了相当多的精力来使用Scapy。这在一定程度上是因为我个人对这个工具的高度评价。我希望你同意Scapy是网络工程师工具箱中必备的伟大工具。Scapy最好的部分是它在一个积极参与的用户社区的不断发展。
- en: I would highly recommend at least going through the Scapy tutorial at [http://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial](http://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial),
    as well as any of the documentation that is of interest to you.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议至少阅读Scapy教程 [http://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial](http://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial)，以及您感兴趣的任何文档。
- en: Access lists
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问列表
- en: The network access lists are usually the first line of defense against outside
    intrusions and attacks. Generally speaking, routers and switches process packets
    at a much faster rate than servers, because they utilize hardware such as **Ternary
    Content-Addressable Memory** (**TCAM**). They do not need to see the application
    layer information, rather they just examine the layer 3 and layer 4 information,
    and decide whether the packets can be forwarded on or not. Therefore, we generally
    utilize network device access lists as the first step in safeguarding our network
    resources.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 网络访问列表通常是防范外部入侵和攻击的第一道防线。一般来说，路由器和交换机的数据包处理速度要比服务器快得多，因为它们利用硬件，如**三态内容可寻址存储器**（**TCAM**）。它们不需要查看应用层信息，而只需检查第3层和第4层信息，并决定是否可以转发数据包。因此，我们通常将网络设备访问列表用作保护网络资源的第一步。
- en: As a rule of thumb, we want to place access lists as close to the source (client)
    as possible. Inherently, we also trust the inside host and distrust the clients
    outside of our network boundary. The access list is therefore usually placed on
    the inbound direction on the external facing network interface(s). In our lab
    scenario, this means we will place an inbound access list at Ethernet2/2 that
    is directly connected to the client host.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，我们希望将访问列表尽可能靠近源（客户端）。因此，我们也相信内部主机，不信任我们网络边界之外的客户端。因此，访问列表通常放置在外部网络接口的入站方向上。在我们的实验场景中，这意味着我们将在直接连接到客户端主机的Ethernet2/2上放置一个入站访问列表。
- en: 'If you are unsure of the direction and placement of the access list, a few
    points might help here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定访问列表的方向和位置，以下几点可能会有所帮助：
- en: Think of the access list from the perspective of the network device
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网络设备的角度考虑访问列表
- en: 'Simplify the packets in terms of just source and destination IP and use one
    host as an example:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化数据包，只涉及源和目的地IP，并以一个主机为例：
- en: In our lab, traffic from our server will have a source IP of `10.0.0.14` with
    the destination IP of `10.0.0.10`
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的实验室中，来自我们服务器的流量将具有源IP`10.0.0.14`和目的IP`10.0.0.10`
- en: The traffic from the client will have a source IP of `10.10.10.10` and the destination
    IP of `10.0.0.14`
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自客户端的流量将具有源IP`10.10.10.10`和目的IP`10.0.0.14`
- en: 'Obviously, every network is different and how the access list should be constructed
    depends on the services provided by your server. But as an inbound border access
    list, you should do the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，每个网络都是不同的，访问列表的构建方式取决于服务器提供的服务。但作为入站边界访问列表，您应该执行以下操作：
- en: Deny RFC 3030 special-use address sources, such as `127.0.0.0/8`
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝RFC 3030特殊使用地址源，如`127.0.0.0/8`
- en: Deny RFC 1918 space, such as `10.0.0.0/8`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝RFC 1918空间，如`10.0.0.0/8`
- en: Deny our own space as the source IP; in this case, `10.0.0.12/30`
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝我们自己的空间作为源IP；在这种情况下，`10.0.0.12/30`
- en: Permit inbound TCP port `22` (SSH) and `80` (HTTP) to host `10.0.0.14`
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许入站TCP端口`22`（SSH）和`80`（HTTP）到主机`10.0.0.14`
- en: Deny everything else
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝其他所有内容
- en: Implementing access lists with Ansible
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible实现访问列表
- en: 'The easiest way to implement this access list would be to use Ansible. We have
    already looked at Ansible in the last two chapters, but it is worth repeating
    the advantages of using Ansible in this scenario:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此访问列表的最简单方法是使用Ansible。我们在过去的两章中已经看过Ansible，但值得重申在这种情况下使用Ansible的优势：
- en: '**Easier management**: For a long access list, we are able to utilize the `include`
    statement to break it into more manageable pieces. The smaller pieces can then
    be managed by other teams or service owners.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更容易管理**：对于长访问列表，我们可以利用`include`语句将其分解为更易管理的部分。然后其他团队或服务所有者可以管理这些较小的部分。'
- en: '**Idempotency**: We can schedule the playbook at a regular interval and only
    the necessary changes will be made.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**幂等性**：我们可以定期安排playbook，并且只会进行必要的更改。'
- en: '**Each task is explicit**: We can separate the construct of the entries as
    well as apply the access list to the proper interface.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个任务都是明确的**：我们可以分开构造条目以及将访问列表应用到正确的接口。'
- en: '**Reusability**: In the future, if we add additional external-facing interfaces,
    we just need to add the device to the list of devices for the access list.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：将来，如果我们添加额外的面向外部的接口，我们只需要将设备添加到访问列表的设备列表中。'
- en: '**Extensible**: You will notice that we can use the same playbook for constructing
    the access list and apply it to the right interface. We can start small and expand
    to separate playbooks in the future as needed.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：您会注意到我们可以使用相同的playbook来构建访问列表并将其应用到正确的接口。我们可以从小处开始，根据需要在将来扩展到单独的playbook。'
- en: 'The host file is pretty standard. For simplicity, we are putting the host variables
    directly in the inventory file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 主机文件非常标准。为简单起见，我们直接将主机变量放在清单文件中：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will declare the variables in the playbook for the time being:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时将在playbook中声明变量：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To save space, we will illustrate denying the RFC 1918 space only. Implementing
    the denial of RFC 3030 and our own space will be identical to the steps used for
    the RFC 1918 space. Note that we did not deny `10.0.0.0/8` in our playbook, because
    our configuration currently uses the `10.0.0.0` network for addressing. Of course,
    we could perform the single host permit first and deny `10.0.0.0/8` in a later
    entry, but in this example, we just choose to omit it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，我们将仅说明拒绝RFC 1918空间。实施拒绝RFC 3030和我们自己的空间将与用于RFC 1918空间的步骤相同。请注意，我们在playbook中没有拒绝`10.0.0.0/8`，因为我们当前的配置使用了`10.0.0.0`网络进行寻址。当然，我们可以首先执行单个主机许可，然后在以后的条目中拒绝`10.0.0.0/8`，但在这个例子中，我们选择忽略它：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that we are allowing the established connection sourcing from the server
    inside to be allowed back in. We use the final explicit `deny ip any any` statement
    as a high sequence number (`1000`), so we can insert any new entries later on.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们允许来自内部服务器的已建立连接返回。我们使用最终的显式`deny ip any any`语句作为高序号（`1000`），因此我们可以随后插入任何新条目。
- en: 'We can then apply the access list to the right interface:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将访问列表应用到正确的接口上：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The access list on VIRL NX-OSv is only supported on the management interface.
    You will see this warning: Warning: ACL may not behave as expected since only
    management interface is supported if you configure this `ACL` via the CLI. This
    warning is okay, as our purpose is only to demonstrate the configuration automation
    of the access list.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: VIRL NX-OSv上的访问列表仅支持管理接口。您将看到此警告：警告：ACL可能不会按预期行为，因为只支持管理接口，如果您通过CLI配置此`ACL`。这个警告没问题，因为我们的目的只是演示访问列表的配置自动化。
- en: This might seem to be a lot of work for a single access list. For an experienced
    engineer, using Ansible to do this task will take longer than just logging in
    to the device and configuring the access list. However, remember that this playbook
    can be reused many times in the future, so it will save you time in the long run.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个访问列表来说，这可能看起来是很多工作。对于有经验的工程师来说，使用Ansible执行此任务将比只是登录设备并配置访问列表需要更长的时间。但是，请记住，这个playbook可以在将来多次重复使用，因此从长远来看可以节省时间。
- en: It is my experience that often, for a long access list, a few entries will be
    for one service, a few entries will be for another, and so on. The access lists
    tend to grow organically over time, and it becomes very hard to keep track of
    the origin and purpose of each entry. The fact that we can break them apart makes
    management of a long access list much simpler.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，通常情况下，长访问列表中的一些条目将用于一个服务，另一些条目将用于另一个服务，依此类推。访问列表往往会随着时间的推移而有机地增长，很难跟踪每个条目的来源和目的。我们可以将它们分开，从而使长访问列表的管理变得更简单。
- en: MAC access lists
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MAC访问列表
- en: In the case where you have an L2 environment or where you are using non-IP protocols
    on Ethernet interfaces, you can still use a MAC address access list to allow or
    deny hosts based on MAC addresses. The steps are similar to the IP access list
    but the match will be based on MAC addresses. Recall that for MAC addresses, or
    physical addresses, the first six hexadecimal symbols belong to an **Organizationally
    Unique Identifier** (**OUI**). So, we can use the same access list matching pattern
    to deny a certain group of hosts.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在L2环境或在以太网接口上使用非IP协议的情况下，您仍然可以使用MAC地址访问列表来允许或拒绝基于MAC地址的主机。步骤与IP访问列表类似，但匹配将基于MAC地址。请记住，对于MAC地址或物理地址，前六个十六进制符号属于**组织唯一标识符**（**OUI**）。因此，我们可以使用相同的访问列表匹配模式来拒绝某个主机组。
- en: We are testing this on IOSv with the `ios_config` module. For older Ansible
    versions, the change will be pushed out every single time the playbook is executed.
    For newer Ansible versions, the control node will check for change first and only
    make changes when needed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`ios_config`模块在IOSv上进行测试。对于较旧的Ansible版本，更改将在每次执行playbook时推送出去。对于较新的Ansible版本，控制节点将首先检查更改，并且只在需要时进行更改。
- en: 'The host file and the top portion of the playbook are similar to the IP access
    list; the `tasks` portion is where the different modules and arguments are used:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 主机文件和playbook的顶部部分与IP访问列表类似；`tasks`部分是使用不同模块和参数的地方：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As more virtual networks become popular, the L3 information sometimes becomes
    transparent to the underlying virtual links. In these scenarios, the MAC access
    list becomes a good option if you need to restrict access to those links.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 随着越来越多的虚拟网络变得流行，L3信息有时对底层虚拟链接变得透明。在这些情况下，如果您需要限制对这些链接的访问，MAC访问列表成为一个很好的选择。
- en: The Syslog search
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Syslog搜索
- en: There are plenty of documented network security breaches that took place over
    an extended period of time. In these slow breaches, quite often, we saw signs
    and traces in logs indicating that there were suspicious activities. These can
    be found in both server and network device logs. The activities were not detected,
    not because there was a lack of information, but rather because there was too
    much information. The critical information that we were looking for is usually
    buried deep in a mountain of information that is hard to sort out.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量记录的网络安全漏洞发生在较长的时间内。在这些缓慢的漏洞中，我们经常看到日志中有可疑活动的迹象。这些迹象可以在服务器和网络设备的日志中找到。这些活动之所以没有被检测到，不是因为信息不足，而是因为信息太多。我们正在寻找的关键信息通常深藏在难以整理的大量信息中。
- en: Besides Syslog, **Uncomplicated Firewall** (**UFW**) is another great source
    of log information for servers. It is a frontend to iptables, which is a server
    firewall. UFW makes managing firewall rules very simple and logs a good amount
    of information. See the *Other tools* section for more information on UFW.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Syslog，**Uncomplicated Firewall**（**UFW**）是服务器日志信息的另一个很好的来源。它是iptables的前端，是一个服务器防火墙。UFW使管理防火墙规则变得非常简单，并记录了大量信息。有关UFW的更多信息，请参阅*其他工具*部分。
- en: In this section, we will try to use Python to search through the Syslog text
    in order to detect the activities that we were looking for. Of course, the exact
    terms that we will search for depend on the device we are using. For example,
    Cisco provides a list of messages to look for in Syslog for any the access list
    violation logging. It is available at [http://www.cisco.com/c/en/us/about/security-center/identify-incidents-via-syslog.html](http://www.cisco.com/c/en/us/about/security-center/identify-incidents-via-syslog.html).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将尝试使用Python搜索Syslog文本，以便检测我们正在寻找的活动。当然，我们将搜索的确切术语取决于我们使用的设备。例如，思科提供了一个在Syslog中查找任何访问列表违规日志的消息列表。它可以在[http://www.cisco.com/c/en/us/about/security-center/identify-incidents-via-syslog.html](http://www.cisco.com/c/en/us/about/security-center/identify-incidents-via-syslog.html)上找到。
- en: For more understanding of access control list logging, go to [http://www.cisco.com/c/en/us/about/security-center/access-control-list-logging.html](http://www.cisco.com/c/en/us/about/security-center/access-control-list-logging.html).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地理解访问控制列表日志记录，请访问[http://www.cisco.com/c/en/us/about/security-center/access-control-list-logging.html](http://www.cisco.com/c/en/us/about/security-center/access-control-list-logging.html)。
- en: 'For our exercise, we will use a Nexus switch anonymized syslog file containing
    about 65,000 lines of log messages this file is included in the accommodated book
    GitHub repository for you:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的练习，我们将使用一个包含大约65,000行日志消息的Nexus交换机匿名Syslog文件，该文件已包含在适应书籍GitHub存储库中供您使用：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We have inserted some Syslog messages from the Cisco documentation ([http://www.cisco.com/c/en/us/support/docs/switches/nexus-7000-series-switches/118907-configure-nx7k-00.html](http://www.cisco.com/c/en/us/support/docs/switches/nexus-7000-series-switches/118907-configure-nx7k-00.html) )
    as the log message that we should be looking for:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经插入了一些来自思科文档（[http://www.cisco.com/c/en/us/support/docs/switches/nexus-7000-series-switches/118907-configure-nx7k-00.html](http://www.cisco.com/c/en/us/support/docs/switches/nexus-7000-series-switches/118907-configure-nx7k-00.html) ）的Syslog消息作为我们应该寻找的日志消息：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We will be using simple examples with regular expressions. If you are already
    familiar with the regular expression in Python, feel free to skip the rest of
    the section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用简单的正则表达式示例。如果您已经熟悉Python中的正则表达式，请随时跳过本节的其余部分。
- en: Searching with the RE module
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RE模块进行搜索
- en: 'For our first search, we will simply use the regular expression module to look
    for the terms we are looking for. We will use a simple loop to the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个搜索，我们将简单地使用正则表达式模块来查找我们正在寻找的术语。我们将使用一个简单的循环来进行以下操作：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result took about 6/100 of a second to search through the log file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索日志文件大约花了6/100秒的时间：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It is recommended to compile the search term for a more efficient search. It
    will not impact us much since the script is already pretty fast. In fact, the
    Python interpretative nature might actually make it slower. However, it will make
    a difference when we search through a larger text body, so let''s make the change:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 建议编译搜索术语以进行更有效的搜索。这不会对我们产生太大影响，因为脚本已经非常快速。实际上，Python的解释性特性可能会使其变慢。但是，当我们搜索更大的文本主体时，这将产生影响，所以让我们做出改变：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The timing result is actually slower:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 时间结果实际上更慢：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s expand the example a bit. Assuming we have several files and multiple
    terms to search through, we will copy the original file to a new file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展一下这个例子。假设我们有几个文件和多个要搜索的术语，我们将把原始文件复制到一个新文件中：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will also include searching for the `PAM: Authentication failure` term.
    We will add another loop to search both the files:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还将包括搜索`PAM: Authentication failure`术语。我们将添加另一个循环来搜索这两个文件：'
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can now see the difference in performance by expanding our search terms
    and the number of messages:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展我们的搜索术语和消息数量，我们现在可以看到性能上的差异：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Of course, when it comes to performance tuning, it is a never-ending, impossible
    race to zero, and the performance sometimes depends on the hardware you are using.
    But the important point is to regularly perform audits of your log files using
    Python, so you can catch the early signals of any potential breach.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及性能调优时，这是一个永无止境的、不可能达到零的竞赛，性能有时取决于您使用的硬件。但重要的是定期使用Python对日志文件进行审计，这样您就可以捕捉到任何潜在违规的早期信号。
- en: Other tools
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他工具
- en: There are other network security tools that we can use and automate with Python.
    Let's take a look at a few of them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他网络安全工具可以使用Python进行自动化。让我们看看其中一些。
- en: Private VLANs
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有VLAN
- en: '**Virtual Local Area Networks** (**VLANs**) have been around for a long time.
    They are essentially a broadcast domain where all hosts can be connected to a
    single switch, but are partitioned out to different domains, so we can separate
    the hosts out according to which host can see others via broadcasts. Let''s look
    at an mapped based on IP subnets. For example, in an enterprise building, I would
    likely see one IP subnet per physical floor: `192.168.1.0/24` for the first floor,
    `192.168.2.0/24` for the second floor, and so on. In this pattern, we use a 1/24
    block for each floor. This gives a clear delineation of my physical network as
    well as my logical network. A host wanting to communicate beyond its own subnet
    will need to traverse through its layer 3 gateway, where I can use an access list
    to enforce security.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟局域网**（**VLANs**）已经存在很长时间了。它们本质上是一个广播域，所有主机都可以连接到一个交换机，但被划分到不同的域，所以我们可以根据哪个主机可以通过广播看到其他主机来分隔主机。让我们看一个基于IP子网的映射。例如，在企业大楼中，我可能会看到每个物理楼层一个IP子网：第一层的`192.168.1.0/24`，第二层的`192.168.2.0/24`，依此类推。在这种模式下，我们为每个楼层使用1/24块。这清晰地划分了我的物理网络和逻辑网络。想要与自己的子网之外通信的主机将需要通过其第3层网关，我可以使用访问列表来强制执行安全性。'
- en: What happens when different departments reside on the same floor? Perhaps the
    finance and sales teams are both on the second floor, and I would not want the
    sales team's hosts in the same broadcast domain as the finance team's. I can break
    the subnet down further, but that might become tedious and break the standard
    subnet scheme that was previously set up. This is where a private VLAN can help.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当不同部门位于同一楼层时会发生什么？也许财务和销售团队都在二楼，我不希望销售团队的主机与财务团队的主机在同一个广播域中。我可以进一步分割子网，但这可能变得乏味，并且会破坏先前设置的标准子网方案。这就是私有VLAN可以帮助的地方。
- en: 'The private VLAN essentially breaks up the existing VLAN into sub-VLANs. There
    are three categories within a private VLAN:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 私有VLAN本质上将现有的VLAN分成子VLAN。私有VLAN中有三个类别：
- en: '**The Promiscuous (P) port**: This port is allowed to send and receive layer
    2 frames from any other port on the VLAN; this usually belongs to the port connecting
    to the layer 3 router'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混杂（P）端口**：此端口允许从VLAN上的任何其他端口发送和接收第2层帧；这通常属于连接到第3层路由器的端口'
- en: '**The Isolated (I) port**: This port is only allowed to communicate with P
    ports, and they are typically connected to hosts when you do not want it to communicate
    with other hosts in the same VLAN'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离（I）端口**：此端口只允许与P端口通信，并且它们通常连接到主机，当您不希望它与同一VLAN中的其他主机通信时'
- en: '**The Community (C) port**: This port is allowed to communicate with other
    C ports in the same community and P ports'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区（C）端口**：此端口允许与同一社区中的其他C端口和P端口通信'
- en: We can again use Ansible or any of the other Python scripts introduced so far
    to accomplish this task. By now, we should have enough practice and confidence
    to implement this feature via automation, so I will not repeat the steps here.
    Being aware of the private VLAN feature would come in handy at times when you
    need to isolate ports even further in an L2 VLAN.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次使用Ansible或迄今为止介绍的任何其他Python脚本来完成这项任务。到目前为止，我们应该有足够的练习和信心通过自动化来实现这个功能，所以我不会在这里重复步骤。在需要进一步隔离L2
    VLAN中的端口时，了解私有VLAN功能将会很有用。
- en: UFW with Python
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python的UFW
- en: 'We briefly mentioned UFW as the frontend for iptables on Ubuntu hosts. Here
    is a quick overview:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要提到了UFW作为Ubuntu主机上iptables的前端。以下是一个快速概述：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can see the status of UFW:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看UFW的状态：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As you can see, the advantage of UFW is a simple interface to construct otherwise
    complicated IP table rules. There are several Python-related tools we can use
    with UFW to make things even simpler:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，UFW的优势在于提供一个简单的界面来构建否则复杂的IP表规则。有几个与UFW相关的Python工具可以使事情变得更简单：
- en: We can use the Ansible UFW module to streamline our operations. More information
    is available at [http://docs.ansible.com/ansible/ufw_module.html](http://docs.ansible.com/ansible/ufw_module.html).
    Because Ansible is written in Python, we can go further and examine what is inside
    the Python module source code. More information is available at [https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/system/ufw.py.](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/system/ufw.py)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用Ansible UFW模块来简化我们的操作。更多信息请访问[http://docs.ansible.com/ansible/ufw_module.html](http://docs.ansible.com/ansible/ufw_module.html)。因为Ansible是用Python编写的，我们可以进一步检查Python模块源代码中的内容。更多信息请访问[https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/system/ufw.py.](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/system/ufw.py)
- en: There are Python wrapper modules around UFW as an API (visit [https://gitlab.com/dhj/easyufw](https://gitlab.com/dhj/easyufw)).
    This can make integration easier if you need to dynamically modify UFW rules based
    on certain events.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有Python包装器模块围绕UFW作为API（访问[https://gitlab.com/dhj/easyufw](https://gitlab.com/dhj/easyufw)）。如果您需要根据某些事件动态修改UFW规则，这可以使集成变得更容易。
- en: UFW itself is written in Python.Therefore, you can use the existing Python knowledge
    if you ever need to extend the current command sets. More information is available
    at [https://launchpad.net/ufw](https://launchpad.net/ufw).
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UFW本身是用Python编写的。因此，如果您需要扩展当前的命令集，可以使用现有的Python知识。更多信息请访问[https://launchpad.net/ufw](https://launchpad.net/ufw)。
- en: UFW proves to be a good tool to safeguard your network server.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: UFW被证明是保护您的网络服务器的好工具。
- en: Further reading
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Python is a very common language used in many of the security-related fields.
    A few of the books I would recommend are listed as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Python是许多安全相关领域中常用的语言。我推荐的一些书籍如下：
- en: '**Violent Python**: A cookbook for hackers, forensic analysts, penetration
    testers, and security engineers by T.J. O''Connor (ISBN-10: 1597499579)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暴力Python**：T.J. O''Connor编写的黑客、取证分析师、渗透测试人员和安全工程师的食谱（ISBN-10：1597499579）'
- en: '**Black Hat Python**: Python programming for hackers and pentesters by Justin
    Seitz (ISBN-10: 1593275900)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黑帽Python**：Justin Seitz编写的黑客和渗透测试人员的Python编程（ISBN-10：1593275900）'
- en: I have personally used Python extensively in our research work on **Distributed
    Denial of Service** (**DDoS**) at A10 Networks. If you are interested in learning
    more, the guide can be downloaded for free at [https://www.a10networks.com/resources/ebooks/distributed-denial-service-ddos](https://www.a10networks.com/resources/ebooks/distributed-denial-service-ddos).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人在A10 Networks的**分布式拒绝服务**（**DDoS**）研究工作中广泛使用Python。如果您有兴趣了解更多信息，可以免费下载指南：[https://www.a10networks.com/resources/ebooks/distributed-denial-service-ddos](https://www.a10networks.com/resources/ebooks/distributed-denial-service-ddos)。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at network security with Python. We used the Cisco
    VIRL tool to set up our lab with both hosts and network devices, consisting of
    NX-OSv and IOSv types. We took a tour around Scapy, which allows us to construct
    packets from the ground up. Scapy can be used in the interactive mode for quick
    testing. Once completed in interactive mode, we can put the steps into a file
    for more scalable testing. It can be used to perform various network penetration
    testing for known vulnerabilities.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用Python进行了网络安全研究。我们使用Cisco VIRL工具在实验室中设置了主机和网络设备，包括NX-OSv和IOSv类型。我们对Scapy进行了介绍，它允许我们从头开始构建数据包。Scapy可以在交互模式下进行快速测试。在交互模式完成后，我们可以将步骤放入文件进行更可扩展的测试。它可以用于执行已知漏洞的各种网络渗透测试。
- en: We also looked at how we can use both an IP access list as well as a MAC access
    list to protect our network. They are usually the first line of defense in our
    network protection. Using Ansible, we are able to deploy access lists consistently
    and quickly to multiple devices.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了如何使用IP访问列表和MAC访问列表来保护我们的网络。它们通常是我们网络保护的第一道防线。使用Ansible，我们能够一致快速地部署访问列表到多个设备。
- en: Syslog and other log files contain useful information that we should regularly
    comb through to detect any early signs of a breach. Using Python regular expressions,
    we can systematically search for known log entries that can point us to security
    events that require our attention. Besides the tools we have discussed, private
    VLAN and UFW are among some other useful tools that we can use for more security
    protection.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Syslog和其他日志文件包含有用的信息，我们应该定期查看以检测任何早期入侵的迹象。使用Python正则表达式，我们可以系统地搜索已知的日志条目，这些条目可以指引我们注意的安全事件。除了我们讨论过的工具之外，私有VLAN和UFW是我们可以用于更多安全保护的其他一些有用工具。
- en: In [Chapter 7](bfb06aa0-1deb-4432-80ae-f15e3644fa54.xhtml), *Network Monitoring
    with Python – Part 1*, we will look at how to use Python for network monitoring.
    Monitoring allows us to know what is happening in our network and the state of
    the network.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](bfb06aa0-1deb-4432-80ae-f15e3644fa54.xhtml)中，*使用Python进行网络监控-第1部分*，我们将看看如何使用Python进行网络监控。监控可以让我们了解网络中正在发生的事情以及网络的状态。
