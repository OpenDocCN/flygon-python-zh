- en: Themed Widgets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题小部件
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Replacing basic widget classes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换基本的小部件类
- en: Creating an editable drop-down with Combobox
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Combobox创建可编辑的下拉菜单
- en: Using the Treeview widget
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Treeview小部件
- en: Populating nested items in a Treeview
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Treeview中填充嵌套项目
- en: Displaying tabbable panes with Notebook
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Notebook显示可切换的窗格
- en: Applying Ttk styling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用Ttk样式
- en: Creating a datepicker widget
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建日期选择器小部件
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Tk-themed widgets are a separate collection of Tk widgets, which have a native
    look and feel, and their style can be highly customized using a specific API.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Tk主题小部件是Tk小部件的一个单独集合，具有本机外观和感觉，并且它们的样式可以使用特定的API进行高度定制。
- en: These classes are defined in the `tkinter.ttk` module. Apart from defining new
    widgets such as Treeview and Notebook, this module redefines the implementation
    of classic Tk widgets such as Button, Label, and Frame.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类在`tkinter.ttk`模块中定义。除了定义新的小部件，如Treeview和Notebook，这个模块还重新定义了经典Tk小部件的实现，如Button、Label和Frame。
- en: In this chapter, we will cover not only how to change our application Tk widgets
    for themed widgets, but also how to style them and use the new widget classes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将不仅涵盖如何将应用程序Tk小部件更改为主题小部件，还将涵盖如何对其进行样式设置和使用新的小部件类。
- en: The themed Tk widget set was introduced in Tk 8.5, which should not be a problem
    since Python 3.6 installers let you include version 8.6 of the Tcl/Tk interpreter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 主题Tk小部件集是在Tk 8.5中引入的，这不应该是一个问题，因为Python 3.6安装程序可以让您包含Tcl/Tk解释器的8.6版本。
- en: 'However, you can verify it on any platform by running `python -m tkinter` from
    the command line, which starts the following program that outputs the Tcl/Tk version:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以通过在命令行中运行`python -m tkinter`来验证任何平台，这将启动以下程序，输出Tcl/Tk版本：
- en: '![](images/5e1aac09-b958-416e-aaaa-3a752a2ff65f.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](images/5e1aac09-b958-416e-aaaa-3a752a2ff65f.png)'
- en: Replacing basic widget classes
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换基本的小部件类
- en: As a first approach to themed Tkinter classes, we will take a look at how to
    use the same widgets (Buttons, Labels, Entries, and so on) from this different
    module, keeping the same behavior in our application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用主题Tkinter类的第一种方法，我们将看看如何从这个不同的模块中使用相同的小部件（按钮、标签、输入框等），在我们的应用程序中保持相同的行为。
- en: Although this will not give us the full potential of their styling capabilities,
    we can easily appreciate the visual variations that bring the native look and
    feel of themed widgets.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这不会充分发挥其样式能力，但我们可以轻松欣赏到带来主题小部件本机外观和感觉的视觉变化。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In the following screenshot, you can note the differences between a GUI with
    themed widgets and the same window using standard Tkinter widgets:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以注意到带有主题小部件的GUI和使用标准Tkinter小部件的相同窗口之间的差异：
- en: '![](images/64a181c4-fef7-4ef4-ab23-4d4a70afe4ed.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](images/64a181c4-fef7-4ef4-ab23-4d4a70afe4ed.png)'
- en: We will build the application shown in the first window, but we will also learn
    how to easily switch between both styles.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建第一个窗口中显示的应用程序，但我们还将学习如何轻松地在两种样式之间切换。
- en: Note that this is highly platform dependent. In this case, the themed variation
    corresponds to how themed widgets look on Windows 10.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这高度依赖于平台。在这种情况下，主题变化对应于Windows 10上主题小部件的外观。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'To start using themed widgets, all you need is to import the `tkinter.ttk`
    module and use the widgets defined there in your Tkinter application as usual:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用主题小部件，您只需要导入`tkinter.ttk`模块，并像往常一样在您的Tkinter应用程序中使用那里定义的小部件：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In case you want to run the same program with regular Tkinter widgets, replace
    all `ttk.` occurrences with `tk.`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要使用常规的Tkinter小部件运行相同的程序，请将所有`ttk.`出现替换为`tk.`。
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A common way to start using themed widgets is to import the `tkinter.ttk` module
    using the `import ... as` syntax. Thus, we can easily identify standard widgets
    with the `tk` name and themed widget with the `ttk` name:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用主题小部件的常见方法是使用`import ... as`语法导入`tkinter.ttk`模块。因此，我们可以轻松地用`tk`名称标识标准小部件，用`ttk`名称标识主题小部件：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you might have noticed in the preceding code, replacing widgets from the
    `tkinter` module with their equivalents from `tkinter.ttk` is as easy as changing
    the alias name:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，在前面的代码中，将`tkinter`模块中的小部件替换为`tkinter.ttk`中的等效小部件就像更改别名一样简单：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our example, we did so for the `ttk.Frame`, `ttk.Label`, `ttk.Entry`, `ttk.LabelFrame`,
    and `ttk.Radiobutton` widgets. These classes accept almost the same basic options
    as their standard Tkinter equivalents; indeed, they actually are their subclasses.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们为`ttk.Frame`、`ttk.Label`、`ttk.Entry`、`ttk.LabelFrame`和`ttk.Radiobutton`小部件这样做。这些类接受的基本选项几乎与它们的标准Tkinter等效类相同；事实上，它们实际上是它们的子类。
- en: However, this translation is simple because we are not porting any styling options,
    such as `foreground` or `background`. In themed widgets, these keywords are used
    separately through the `ttk.Style` class, which we will cover in another recipe.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个翻译很简单，因为我们没有移植任何样式选项，比如`foreground`或`background`。在主题小部件中，这些关键字通过`ttk.Style`类分别使用，我们将在另一个食谱中介绍。
- en: See also
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Applying Ttk styling* recipe
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用Ttk样式*食谱'
- en: Creating an editable drop-down with Combobox
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Combobox创建可编辑的下拉菜单
- en: Drop-down lists are a succinct way of choosing a value by vertically displaying
    a list of values only when needed. This is also common to let users input another
    option that is not present in the list.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下拉列表是一种简洁的方式，通过垂直显示数值列表来选择数值，只有在需要时才显示。这也是让用户输入列表中不存在的另一个选项的常见方式。
- en: This functionality is combined in the `ttk.Combobox` class, which takes the
    native look and feel of your platform drop-downs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能结合在`ttk.Combobox`类中，它采用您平台下拉菜单的本机外观和感觉。
- en: Getting ready
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Our next application will consist of a simple drop-down entry with a couple
    of buttons to confirm the selection or clear its contents.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个应用程序将包括一个简单的下拉输入框，带有一对按钮来确认选择或清除其内容。
- en: 'If one of the predefined values is selected or the Submit button is clicked,
    the current Combobox value is printed in the standard output, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择了预定义的值之一或单击了提交按钮，则当前Combobox值将以以下方式打印在标准输出中：
- en: '![](images/90f6db52-c463-4a4c-bde6-1aeaf09dff48.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](images/90f6db52-c463-4a4c-bde6-1aeaf09dff48.png)'
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Our application creates a `ttk.Combobox` instance during its initialization,
    passing a predefined sequence of values that can be selected in the drop-down
    list:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序在初始化期间创建了一个`ttk.Combobox`实例，传递了一个预定义的数值序列，可以在下拉列表中进行选择：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As usual, the `ttk.Combobox` widget is added to our application by passing the
    `Tk` instance as the first parameter to its constructor. The `values` option specifies
    the list of selectable choices that are displayed when the drop-down arrow is
    clicked.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，通过将`Tk`实例作为其构造函数的第一个参数传递给我们的应用程序，我们将`ttk.Combobox`小部件添加到应用程序中。`values`选项指定了在单击下拉箭头时显示的可选择选项列表。
- en: 'We bind the `"<<ComboboxSelected>>"` virtual event that is generated when one
    of the choices from the list of values is selected:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绑定了`"<<ComboboxSelected>>"`虚拟事件，当从值列表中选择一个选项时生成该事件：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The same method is invoked when you click on the `Submit` button, so it receives
    a value input by the user.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当单击`提交`按钮时，也会调用相同的方法，因此它会接收用户输入的值。
- en: We defined that `display_color()` takes a variable list of arguments using the
    `*` syntax to safely handle optional arguments. This happens because an event
    is passed to it when invoked through event binding, but it does not receive any
    parameters when invoked from the button callback.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义`display_color()`使用`*`语法接受可选参数列表。这是因为当通过事件绑定调用它时，会传递一个事件给它，但当从按钮回调中调用它时，不会接收任何参数。
- en: 'Within this method, we retrieve the current Combobox value via its `get()`
    method and print it in the standard output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们通过其`get()`方法检索当前Combobox值，并将其打印在标准输出中：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, `clear_color()` clears the contents of the Combobox by calling its
    `set()` method with the empty string:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`clear_color()`通过调用其`set()`方法并传递空字符串来清除Combobox的内容：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With these methods, we have explored how to interact with the current selection
    of a Combobox instance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些方法，我们已经探讨了如何与Combobox实例的当前选择进行交互。
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `ttk.Combobox` class extends `ttk.Entry`, which in turn extends the `Entry`
    class from the `tkinter` module.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`ttk.Combobox`类扩展了`ttk.Entry`，后者又扩展了`tkinter`模块中的`Entry`类。'
- en: 'This means that we could also use the methods that we have already covered
    from the `Entry` class if needed:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果需要，我们也可以使用我们已经介绍的`Entry`类的方法：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code is more straightforward than `combobox.set("Add this at
    the beginning: " + combobox.get())`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '前面的代码比`combobox.set("Add this at the beginning: " + combobox.get())`更简单。'
- en: Using the Treeview widget
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Treeview小部件
- en: In this recipe, we will introduce the `ttk.Treeview` class, a versatile widget
    that lets us display information in both tabular and hierarchical structures.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将介绍`ttk.Treeview`类，这是一个多功能的小部件，可以让我们以表格和分层结构显示信息。
- en: Each item added to the `ttk.Treeview` class is divided into one or more columns,
    where the first one may contain text and an icon and serves to indicate whether
    the item can be expanded and show more nested items. The rest of the columns contain
    the values that we want to display for each row.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到`ttk.Treeview`类的每个项目都分成一个或多个列，其中第一列可能包含文本和图标，并用于指示项目是否可以展开并显示更多嵌套项目。其余的列包含我们想要为每一行显示的值。
- en: The first row of the `ttk.Treeview` class is composed of headings that identify
    each column by its name and can be optionally hidden.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`ttk.Treeview`类的第一行由标题组成，通过其名称标识每一列，并可以选择性地隐藏。'
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好了
- en: 'Using `ttk.Treeview`, we will tabulate the information of a list of contacts
    stored in a CSV file, similar to what we previously did in [Chapter 5](89c88c96-63a6-42bf-ad7a-ed1dd71e0865.xhtml),
    *Object-Oriented Programming and MVC*:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ttk.Treeview`，我们将对存储在CSV文件中的联系人列表的信息进行制表，类似于我们在[第5章](89c88c96-63a6-42bf-ad7a-ed1dd71e0865.xhtml)中所做的*面向对象编程和MVC*：
- en: '![](images/5d623144-43ad-44ef-b852-aa63a1428d0b.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](images/5d623144-43ad-44ef-b852-aa63a1428d0b.png)'
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'We will create a `ttk.Treeview` widget with three columns that hold the fields
    of each contact: one for its last name, another one for its first name, and the
    last one for its email address.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`ttk.Treeview`小部件，其中包含三列，分别用于每个联系人的字段：一个用于姓，另一个用于名，最后一个用于电子邮件地址。
- en: 'Contacts are loaded from a CSV file using the `csv` module, and then we add
    the binding for the `"<<TreeviewSelect>>"` virtual element, which is generated
    when one or more items are selected:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 联系人是使用`csv`模块从CSV文件中加载的，然后我们为`"<<TreeviewSelect>>"`虚拟元素添加了绑定，当选择一个或多个项目时生成该元素：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you run this program, each time you select a contact, its details will be
    printed in the standard output as a way to illustrate how to retrieve the data
    of a selected row.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此程序，每次选择一个联系人，其详细信息都将以标准输出的方式打印出来，以说明如何检索所选行的数据。
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To create a `ttk.Treeview` with multiple columns, we need to indicate the identifiers
    of each one with the `columns` option. Then, we can configure the header text
    by calling the `heading()` method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个具有多列的`ttk.Treeview`，我们需要使用`columns`选项指定每个列的标识符。然后，我们可以通过调用`heading()`方法来配置标题文本。
- en: We used identifiers `#1`, `#2`, and `#3` since the first column, which contains
    the expandable icon and text, is always generated with the `#0` identifier.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用标识符`#1`、`#2`和`#3`，因为第一列始终使用`#0`标识符生成，其中包含可展开的图标和文本。
- en: Also we passed the `"headings"` value to the `show` option to indicate that
    we want to hide the `#0` column, because there will not be nested items.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`"headings"`值传递给`show`选项，以指示我们要隐藏`#0`列，因为不会有嵌套项目。
- en: 'The following values are valid for the `show` option:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`show`选项的有效值如下：'
- en: '`"tree"`: Displays column `#0`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"tree"`：显示列`#0`'
- en: '`"headings"`: Displays the header row'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"headings"`：显示标题行'
- en: '`"tree headings"`: Displays both column `#0` and the header row—this is the
    default value'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"tree headings"`：显示列`#0`和标题行—这是默认值'
- en: '`""`: Does not display column `#0` or the header row'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`""`：不显示列`#0`或标题行'
- en: 'After this, we attached a vertical scroll bar to our `ttk.Treeview` widget:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将垂直滚动条附加到我们的`ttk.Treeview`小部件：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To load the contacts into the table, we process the file with the `reader()`
    function from the `csv` module, and the row read in each iteration is added to
    `ttk.Treeview`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要将联系人加载到表中，我们使用`csv`模块的`reader()`函数处理文件，并在每次迭代中读取的行添加到`ttk.Treeview`中。
- en: This is done by calling the `insert()` method, which receives the parent node
    and the position to place the item.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过调用`insert()`方法来完成的，该方法接收父节点和放置项目的位置。
- en: Since all contacts are shown as top-level items, we pass an empty string as
    the first parameter and the `END` constant to indicate that each new item is inserted
    at the last position.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有联系人都显示为顶级项目，因此我们将空字符串作为第一个参数传递，并将`END`常量传递以指示每个新项目插入到最后位置。
- en: 'You can optionally provide some keyword arguments to the `insert()` method.
    Here, we specified the `values` option, which takes the sequence of values that
    is displayed in each column of the Treeview:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择为`insert()`方法提供一些关键字参数。在这里，我们指定了`values`选项，该选项接受在Treeview的每一列中显示的值序列：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `<<TreeviewSelect>>` event is the virtual event generated when the user
    selects one or more items from the table. Within the `print_selection()` handler,
    we retrieve the current selection by calling the `selection()` method, and for
    each result, we will perform the following steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`<<TreeviewSelect>>`事件是用户从表中选择一个或多个项目时生成的虚拟事件。在`print_selection()`处理程序中，我们通过调用`selection()`方法检索当前选择，对于每个结果，我们将执行以下步骤：'
- en: With the `item()` method, we get the dictionary of options and values of the
    selected item
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`item()`方法，我们可以获取所选项目的选项和值的字典
- en: We retrieve the first three values from the `item` dictionary, which correspond
    to the last name, first name, and email of the contact
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`item`字典中检索前三个值，这些值对应于联系人的姓氏、名字和电子邮件
- en: 'The values are formatted and printed into the standard output:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值被格式化并打印到标准输出：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There's more...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: So far, we have covered some basic aspects of the `ttk.Treeview` class since
    we are using it as a regular table. However, it is also possible to extend our
    existing application with more advanced features.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了`ttk.Treeview`类的一些基本方面，因为我们将其用作常规表。但是，还可以通过更高级的功能扩展我们现有的应用程序。
- en: Using tags in Treeview items
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Treeview项目中使用标签
- en: Tags are available for `ttk.Treeview` items, so it is possible to bind event
    sequences for specific rows of our `contacts` table.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`ttk.Treeview`项目可用标签，因此可以为`contacts`表的特定行绑定事件序列。'
- en: Let's suppose that we want to open a new window to write an email to a contact
    when we double-click on it; however, this should only work for records where the
    email field is filled in.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望在双击时打开一个新窗口以给联系人写电子邮件；但是，这仅适用于填写了电子邮件字段的记录。
- en: 'We can easily implement this by conditionally adding a tag to the items while
    inserting them, and then calling `tag_bind()` on the widget instance with the
    `"<Double-Button-1>"` sequence—here we simply refer to the implementation of the
    `send_email_to_contact()` handler function by its name:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在插入项目时有条件地向其添加标签，然后在小部件实例上使用`"<Double-Button-1>"`序列调用`tag_bind()`来轻松实现这一点——这里我们只是通过其名称引用`send_email_to_contact()`处理程序函数的实现：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Similar to what happens when binding events to `Canvas` items, always remember
    to add the tagged items to `ttk.Treeview` before calling `tag_bind()`, because
    the bindings are only added to existing matching items.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与将事件绑定到`Canvas`项目时发生的情况类似，始终记住在调用`tag_bind()`之前将带有标签的项目添加到`ttk.Treeview`中，因为绑定仅添加到现有的匹配项目。
- en: See also
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Populating nested items in a Treeview* recipe
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Treeview中填充嵌套项目*食谱'
- en: Populating nested items in a Treeview
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Treeview中填充嵌套项目
- en: While `ttk.Treeview` can be used as a regular table, it may also contain hierarchical
    structures. This is shown as a tree where items can be expanded to see more nodes
    of the hierarchy.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ttk.Treeview`可以用作常规表，但它也可能包含分层结构。这显示为树，其中的项目可以展开以查看层次结构的更多节点。
- en: This is useful to display the results of recursive calls and several levels
    of nested items. In this recipe, we will take a look at a common scenario that
    fits with this kind of structure.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于显示递归调用的结果和多层嵌套项目非常有用。在此食谱中，我们将研究适合这种结构的常见场景。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To illustrate how to recursively add items in a `ttk.Treeview` widget, we will
    create a basic filesystem browser. Expandable nodes will represent folders, and
    once opened, they will show the files and folders that they contain:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何在`ttk.Treeview`小部件中递归添加项目，我们将创建一个基本的文件系统浏览器。可展开的节点将表示文件夹，一旦打开，它们将显示它们包含的文件和文件夹：
- en: '![](images/9bd56ff2-7170-4c16-821d-af9d1f31e0ca.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](images/9bd56ff2-7170-4c16-821d-af9d1f31e0ca.png)'
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The tree will be initially populated by the `populate_node()` method, which
    lists the entries in the current directory. If an entry is a directory, it also
    adds an empty child to show it as an expandable node.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 树将最初由`populate_node()`方法填充，该方法列出当前目录中的条目。如果条目是目录，则还会添加一个空子项以显示它作为可展开节点。
- en: 'When a node that represents a directory is opened, it lazily loads the contents
    of the directory by calling `populate_node()` again. This time, instead of adding
    the items as top-level nodes, they are nested inside the opened node:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 打开表示目录的节点时，它会通过再次调用`populate_node()`来延迟加载目录的内容。这次，不是将项目添加为顶级节点，而是将它们嵌套在打开的节点内部：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you run the preceding example, it will display the filesystem hierarchy
    from the directory where the script is located, but you can explicitly set the
    directory you want via the `path` argument of the `App` constructor.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行上述示例时，它将显示脚本所在目录的文件系统层次结构，但您可以通过`App`构造函数的`path`参数明确设置所需的目录。
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: In this example, we will use the `os` module, which is part of the Python Standard
    Library and provides a portable way of performing operating system calls.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用`os`模块，它是Python标准库的一部分，提供了执行操作系统调用的便携方式。
- en: 'The first use of the `os` module is the translation of the initial path of
    the tree to an absolute path, as well as initializing the `nodes` dictionary,
    which will store the correspondence between expandable items and the path of the
    directories they represent:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`模块的第一个用途是将树的初始路径转换为绝对路径，以及初始化`nodes`字典，它将存储可展开项和它们表示的目录路径之间的对应关系：'
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For instance, `os.path.abspath(".")` will return the absolute version of the
    pathname you run the script from. We prefer this approach to using relative paths,
    because this saves us from any confusion when working with paths in our application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`os.path.abspath(".")`将返回你从脚本运行的路径的绝对版本。我们更喜欢这种方法而不是使用相对路径，因为这样可以避免在应用程序中处理路径时出现混淆。
- en: 'Now, we initialize the `ttk.Treeview` instance with a vertical and horizontal
    scroll bar. The `text` of the icon heading will be the absolute path we calculated
    earlier:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用垂直和水平滚动条初始化`ttk.Treeview`实例。图标标题的`text`将是我们之前计算的绝对路径：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then, we place the widgets using the Grid geometry manager and also make the
    `ttk.Treeview` instance automatically resizable both horizontally and vertically.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用Grid布局管理器放置小部件，并使`ttk.Treeview`实例在水平和垂直方向上自动调整大小。
- en: 'After this, we bind the `"<<TreeviewOpen>>"` virtual event, which is generated
    when an expandable item is opened to the `open_node()` handler and call `populate_node()`
    to load the entries of the specified directory:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们绑定了`"<<TreeviewOpen>>"`虚拟事件，当展开项时生成，调用`open_node()`处理程序并调用`populate_node()`加载指定目录的条目：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the first call to this method is made with the empty string as the
    parent directory, which means that they do not have any parent and are displayed
    as top-level items.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一次调用此方法时，父目录为空字符串，这意味着它们没有任何父项，并显示为顶级项。
- en: 'Within the `populate_node()` method, we list the names of the directory entries
    by invoking `os.listdir()`. For each entry name, we perform the following actions:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`populate_node()`方法中，我们通过调用`os.listdir()`列出目录条目的名称。对于每个条目名称，我们执行以下操作：
- en: We calculate the absolute path of the entry. On UNIX-like systems, this is achieved
    by concatenating the strings with a slash, but Windows uses backslashes instead.
    Thanks to the `os.path.join()` method, we can safely join the paths without worrying
    about platform-dependent details.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算条目的绝对路径。在类UNIX系统上，这是通过用斜杠连接字符串来实现的，但Windows使用反斜杠。由于`os.path.join()`方法，我们可以安全地连接路径，而不必担心平台相关的细节。
- en: We insert the `entry` string as the last child of the indicated `parent` node.
    We always set that nodes to be initially closed, because we want to lazy load
    the nested items only when needed.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`entry`字符串插入到指定的`parent`节点的最后一个子项中。我们总是将节点初始设置为关闭，因为我们希望仅在需要时延迟加载嵌套项。
- en: 'If the entry absolute path is a directory, we add the correspondence between
    the node and the path in the `nodes` attribute and insert an empty child that
    allows the item to be expanded:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果条目的绝对路径是一个目录，我们在`nodes`属性中添加节点和路径之间的对应关系，并插入一个空的子项，允许该项展开：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When an expandable item is clicked, the `open_node()` handler retrieves the
    selected item by calling the `focus()` method of the `ttk.Treeview` instance.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当单击可展开项时，`open_node()`处理程序通过调用`ttk.Treeview`实例的`focus()`方法检索所选项。
- en: This item identifier is used to get the absolute path previously added to the
    `nodes` attribute. To avoid raising `KeyError` if the node does not exist within
    the dictionary, we used its `pop()` method, which returns the second parameter
    as a default value—in our case, `False`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此项标识符用于获取先前添加到`nodes`属性的绝对路径。为了避免在字典中节点不存在时引发`KeyError`，我们使用了它的`pop()`方法，它将第二个参数作为默认值返回——在我们的例子中是`False`。
- en: If the node exists, we clear the "fake" item of the expandable node. Calling
    `self.tree.get_children(item)` returns the identifiers of the children for `item`,
    and then they are deleted by invoking `self.tree.delete(children)`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点存在，我们清除可展开节点的“虚假”项。调用`self.tree.get_children(item)`返回`item`的子项的标识符，然后通过调用`self.tree.delete(children)`来删除它们。
- en: 'Once the item is cleared, we add the "real" children entries by calling `populate_node()`
    with `item` as their parent:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦清除了该项，我们通过使用`item`作为父项调用`populate_node()`来添加“真实”的子项：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Displaying tabbable panes with Notebook
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示带有Notebook的选项卡窗格
- en: The `ttk.Notebook` class is another of the new widget types introduced in the
    `ttk` module. It allows you to add many views of your application in the same
    window area, letting you choose the one that should be displayed by clicking on
    the tab associated to each view.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`ttk.Notebook`类是`ttk`模块中引入的另一种新的小部件类型。它允许您在同一窗口区域中添加许多应用程序视图，让您通过单击与每个视图关联的选项卡来选择应该显示的视图。'
- en: Tabbed panels are a good way to reuse the same portion of your GUI if the contents
    of multiple regions do not need to be shown at the same time.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 选项卡面板是重用GUI相同部分的好方法，如果多个区域的内容不需要同时显示。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The following application shows some to-do lists divided into tabs by category—lists
    are displayed with read-only data to simplify the example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下应用程序显示了一些按类别分隔的待办事项列表，列表显示为只读数据，以简化示例：
- en: '![](images/de95909e-d3ee-4c23-9283-94af0b2928d9.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](images/de95909e-d3ee-4c23-9283-94af0b2928d9.png)'
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'We instantiate the `ttk.Notebook` with a fixed size, and then loop over a dictionary
    with some predefined data that will serve to create the tabs and add some labels
    to each region:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用固定大小实例化`ttk.Notebook`，然后循环遍历具有一些预定义数据的字典，这些数据将用于创建选项卡并向每个区域添加一些标签：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Every time you click on a tab, the label at the bottom of the window updates
    its contents, showing the name of the current tab.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每次单击选项卡时，窗口底部的标签都会更新其内容，显示当前选项卡的名称。
- en: How it works...
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our `ttk.Notebook` widget is created with a specific width and height, as well
    as an external padding.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ttk.Notebook`小部件具有特定的宽度和高度，以及外部填充。
- en: 'Each key from the `todos` dictionary is used as the name of a tab, and the
    list of values is added as labels to `ttk.Frame`, which represents the window
    region:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`todos`字典中的每个键都用作选项卡的名称，并且值列表被添加为标签到`ttk.Frame`，它代表窗口区域：'
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After this, we call `enable_traversal()` on the `ttk.Notebook` widget. This
    allows users to switch tabs back and forth between tab panels using *Ctrl* + *Shift*
    + *Tab* and *Ctrl* + *Tab*, respectively.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们在`ttk.Notebook`小部件上调用`enable_traversal()`。这允许用户使用*Ctrl* + *Shift* + *Tab*和*Ctrl*
    + *Tab*在选项卡面板之间来回切换选项卡。
- en: It also enables switching into a specific tab by pressing *Alt* and the underlined
    character, that is, *Alt* + *H* for the `Home` tab, *Alt* + *W* for the `Work`
    tab, and *Alt* + *V* for the `Vacation` tab.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以通过按下*Alt*和下划线字符来切换到特定的选项卡，即*Alt* + *H*代表`Home`选项卡，*Alt* + *W*代表`Work`选项卡，*Alt*
    + *V*代表`Vacation`选项卡。
- en: 'The `"<<NotebookTabChanged>>"` virtual event is generated when the tab selection
    changes, and we bind it to the `select_tab()` method. Note that this event is
    automatically raised when Tkinter adds a tab to `ttk.Notebook`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当选项卡选择更改时，生成`"<<NotebookTabChanged>>"`虚拟事件，并将其绑定到`select_tab()`方法。请注意，当Tkinter添加一个选项卡到`ttk.Notebook`时，此事件会自动触发：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we pack the items, it is not necessary to place the `ttk.Notebook` child
    windows since it is internally done by the `ttk.Notebook` call to the geometry
    manager:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打包项目时，不需要放置`ttk.Notebook`子窗口，因为`ttk.Notebook`调用几何管理器内部完成了这一点：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There's more...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you want to retrieve the current displayed child of the `ttk.Notebook`, you
    do not need to use any extra data structures to map the tab index with the widget
    window.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要检索`ttk.Notebook`当前显示的子窗口，您不需要使用任何额外的数据结构来将选项卡索引与小部件窗口进行映射。
- en: 'Tkinter''s `nametowidget()` method is available from all widget classes, so
    you can easily get the widget object that corresponds to a widget name:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter的`nametowidget()`方法可从所有小部件类中使用，因此您可以轻松获取与小部件名称对应的小部件对象：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Applying Ttk styling
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用Ttk样式
- en: As we mentioned in the first recipe of this chapter, themed widgets have a specific
    API to customize their appearance. We cannot directly set options, such as the
    foreground color or the internal padding, because these values are set via the
    `ttk.Style` class.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章的第一个配方中提到的，主题小部件具有特定的API来自定义它们的外观。我们不能直接设置选项，例如前景色或内部填充，因为这些值是通过`ttk.Style`类设置的。
- en: In this recipe, we will cover how to modify the widgets from the first recipe
    to add some styling options.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将介绍如何修改第一个配方中的小部件以添加一些样式选项。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To add some default settings, we will simply need a `ttk.Style` object, which
    offers the following methods:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加一些默认设置，我们只需要一个`ttk.Style`对象，它提供以下方法：
- en: '`configure(style, opts)`: Changes the appearance `opts` for a widget `style`.
    Here is where we set options such as the foreground color, padding, and relief.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configure(style, opts)`: 更改小部件`style`的外观`opts`。在这里，我们设置诸如前景色、填充和浮雕等选项。'
- en: '`map(style, query)`: Changes the dynamic appearance for a widget `style`. The
    argument `query` is a keywords argument where each key is a styling option, and
    values are lists of tuples of the `(state, value)` form, meaning that the value
    of the option is determined by its current state.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map(style, query)`: 更改小部件`style`的动态外观。参数`query`是一个关键字参数，其中每个键都是样式选项，值是`(state,
    value)`形式的元组列表，表示选项的值由其当前状态确定。'
- en: 'For instance, we have marked the following examples of both situations:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们已经标记了以下两种情况的示例：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, every `ttk.Label` is displayed with a padding of `10`, and the `ttk.Button`
    has a dynamic styling: gray foreground and white background when the state is
    `pressed`, and white foreground and gray background if the state is `active`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个`ttk.Label`显示为`10`的填充，`ttk.Button`具有动态样式：当状态为`pressed`时，灰色前景和白色背景，当状态为`active`时，白色前景和灰色背景。
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Building `ttk.Style` for our applications is quite straightforward—we only need
    to create an instance with our parent widget as its first parameter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的应用程序构建`ttk.Style`非常简单——我们只需要使用我们的父小部件作为它的第一个参数创建一个实例。
- en: 'Then, we can set the default styling options for our themed widgets, using
    an uppercase `T` plus the widget name: `TButton` for `ttk.Button`, `TLabel` for
    `ttk.Label`, and so on. However, there are some exceptions, so it is recommended
    that you check on the Python interpreter the classname by calling the `winfo_class()`
    method on the widget instance.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为我们的主题小部件设置默认样式选项，使用大写的`T`加上小部件名称：`TButton`代表`ttk.Button`，`TLabel`代表`ttk.Label`，依此类推。然而，也有一些例外，因此建议您在Python解释器上调用小部件实例的`winfo_class()`方法来检查类名。
- en: 'We can also add a prefix to identify a style that we do not want to use by
    default, but explicitly set it to some specific widgets:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加前缀来标识我们不想默认使用的样式，但明确地将其设置为某些特定的小部件：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Creating a datepicker widget
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建日期选择器小部件
- en: If we want to let users input a date into our application, we might add a text
    entry that forces them to write a string with a valid date format. Another solution
    would be adding several numeric entries for the day, month, and year, but this
    would also require some validations.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让用户在我们的应用程序中输入日期，我们可以添加一个文本输入，强制他们编写一个带有有效日期格式的字符串。另一种解决方案是添加几个数字输入，用于日期、月份和年份，但这也需要一些验证。
- en: Unlike other GUI frameworks, Tkinter does not include a class for this purpose;
    however, we can opt to apply our knowledge of themed widgets to build a Calendar
    widget.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他GUI框架不同，Tkinter不包括一个专门用于此目的的类；然而，我们可以选择应用我们对主题小部件的知识来构建一个日历小部件。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this recipe, we will explain a step-by-step implementation of a datepicker
    widget made with Ttk widgets and features:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将逐步解释使用Ttk小部件和功能制作日期选择器小部件的实现：
- en: '![](images/2af6aa0e-0480-4c96-b406-d51e96c7d0f1.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](images/2af6aa0e-0480-4c96-b406-d51e96c7d0f1.png)'
- en: This is a refactored version of [http://svn.python.org/projects/sandbox/trunk/ttk-gsoc/samples/ttkcalendar.py](http://svn.python.org/projects/sandbox/trunk/ttk-gsoc/samples/ttkcalendar.py)
    and does not require any external packages.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 [http://svn.python.org/projects/sandbox/trunk/ttk-gsoc/samples/ttkcalendar.py](http://svn.python.org/projects/sandbox/trunk/ttk-gsoc/samples/ttkcalendar.py)
    的重构版本，不需要任何外部包。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Apart from the `tkinter` modules, we will also need the `calendar` and `datetime`
    modules from the Standard Library. They will help us to model and interact with
    the data held by the widget.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `tkinter` 模块，我们还需要标准库中的 `calendar` 和 `datetime` 模块。它们将帮助我们对小部件中保存的数据进行建模和交互。
- en: 'The widget header displays a couple of arrows to move the current month back
    and forth, based on Ttk styling options. The main body of the widget consists
    of a `ttk.Treeview` table, with a `Canvas` instance that highlights the selected
    date cell:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件标题显示了一对箭头，根据 Ttk 样式选项来前后移动当前月份。小部件的主体由一个 `ttk.Treeview` 表格组成，其中包含一个 `Canvas`
    实例来突出显示所选日期单元格：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Our `TtkCalendar` class can be customized by passing some options as keyword
    arguments. They are retrieved during its initialization, with some default values
    in case they are not present; for example, if the current date is used for initial
    year and month of our calendar:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `TtkCalendar` 类可以通过传递一些选项作为关键字参数来进行自定义。它们在初始化时被检索出来，并在没有提供的情况下使用一些默认值；例如，如果当前日期用于日历的初始年份和月份：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we define some attributes to store date information:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一些属性来存储日期信息：
- en: '`selected`: Holds the value of the selected date'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`selected`：保存所选日期的值'
- en: '`date`: The date that represents the current month displayed on the calendar'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`：表示在日历上显示的当前月份的日期'
- en: '`calendar`: A Gregorian calendar with information on weeks and month names'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calendar`：具有周和月份名称信息的公历日历'
- en: The visual parts of the widget are internally instantiated in the `create_header()`
    and `create_table()` methods, which we will cover later.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件的可视部分在 `create_header()` 和 `create_table()` 方法中内部实例化，稍后我们将对其进行介绍。
- en: We also used a `tkfont.Font` instance to help us to measure the font size.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一个 `tkfont.Font` 实例来帮助我们测量字体大小。
- en: 'Once these attributes are initialized, the visual parts of the calendar are
    arranged by calling the `build_calendar()` method:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些属性被初始化，通过调用 `build_calendar()` 方法来安排日历的可视部分：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `create_header()` method uses `ttk.Style` to display the arrows to move
    the month back and forth. It returns the label that shows the name of the current
    month:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_header()` 方法使用 `ttk.Style` 来显示箭头以前后移动月份。它返回显示当前月份名称的标签：'
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `move_month()` callback hides the current selection highlighted with the
    canvas field and adds the specified `offset` to the current month to set the `date`
    attribute with the previous or next month. Then, the calendar is redrawn again,
    showing the days of the new month:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`move_month()` 回调隐藏了用画布字段突出显示的当前选择，并将指定的 `offset` 添加到当前月份以设置 `date` 属性为上一个或下一个月份。然后，日历再次重绘，显示新月份的日期：'
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The calendar body is created within `create_table()` using a `ttk.Treeview`
    widget, which displays each week of the current month in a row:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 日历主体是在 `create_table()` 中使用 `ttk.Treeview` 小部件创建的，它在一行中显示当前月份的每周：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The canvas that highlights the selection is instantiated within the `create_canvas()`
    method. Since it adjusts its size depending on the selected item dimensions, it
    also hides itself if the window is resized:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `create_canvas()` 方法中实例化了突出显示选择的画布。由于它根据所选项的尺寸调整其大小，因此如果窗口被调整大小，它也会隐藏自己：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The calendar is built by iterating over the weeks and item positions of the
    `ttk.Treeview` table. With the `zip_longest()` function from the `itertools` module,
    we iterate over the collection that contains most items and leave the missing
    days with an empty string:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过迭代 `ttk.Treeview` 表格的周和项目位置来构建日历。使用 `itertools` 模块中的 `zip_longest()` 函数，我们遍历包含大多数项目的集合，并将缺少的日期留空字符串：
- en: '![](images/92fb9a31-6eb8-431c-8244-13316aa52fde.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](images/92fb9a31-6eb8-431c-8244-13316aa52fde.png)'
- en: 'This behavior is important for the first and last week of each month, because
    this is where we usually find these empty spots:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为对每个月的第一周和最后一周很重要，因为这通常是我们找到这些空白位置的地方：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When you click on a table item, the `pressed()` event handler sets the selection
    if the item exists, and redisplays the canvas to highlight the selection:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当您单击表项时，`pressed()` 事件处理程序如果该项存在则设置选择，并重新显示画布以突出显示选择：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `show_selection()` method places the canvas on the bounding box that contains
    the selection, measuring the text size so it fits on top of it:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`show_selection()` 方法将画布放置在包含选择的边界框上，测量文本大小以使其适合其上方：'
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, the `selection` property makes it possible to get the selected date
    as a `datetime.date` object. It is not directly used in our example, but it forms
    part of the API to work with the `TtkCalendar` class:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`selection` 属性使得可以将所选日期作为 `datetime.date` 对象获取。在我们的示例中没有直接使用它，但它是与 `TtkCalendar`
    类一起使用的 API 的一部分：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: See also
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using the Treeview widget* recipe
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Treeview 小部件* 配方'
- en: The *Applying Ttk styling* recipe
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用 Ttk 样式* 配方'
