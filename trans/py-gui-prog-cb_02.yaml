- en: Chapter 2. Layout Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。布局管理
- en: 'In this chapter we will lay out our GUI using Python 3:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Python 3来布局我们的GUI：
- en: Arranging several labels within a label frame widget
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标签框架小部件内排列几个标签
- en: Using padding to add space around widgets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用填充在小部件周围添加空间
- en: How widgets dynamically expand the GUI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件如何动态扩展GUI
- en: Aligning the GUI widgets by embedding frames within frames
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在框架内嵌套框架来对齐GUI小部件
- en: Creating menu bars
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建菜单栏
- en: Creating tabbed widgets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建选项卡小部件
- en: Using the grid layout manager
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网格布局管理器
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will explore how to arrange widgets within widgets to create
    our Python GUI. Learning the fundamentals of GUI layout design will enable us
    to create great looking GUIs. There are certain techniques that will help us to
    achieve this layout design.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将探讨如何在小部件内部排列小部件，以创建我们的Python GUI。学习GUI布局设计的基础知识将使我们能够创建外观出色的GUI。有一些技术将帮助我们实现这种布局设计。
- en: The grid layout manager is one of the most important layout tools built into
    tkinter that we will be using.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 网格布局管理器是内置在tkinter中的最重要的布局工具之一，我们将使用它。
- en: We can very easily create menu bars, tabbed controls (aka Notebooks), and many
    more widgets using tk.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地使用tk来创建菜单栏，选项卡控件（又名Notebooks）以及许多其他小部件。
- en: One widget that is missing out of the box from tk is a status bar.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: tk中默认缺少的一个小部件是状态栏。
- en: In this chapter, we will not bother to hand-craft this widget, but it can be
    done.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将不费力地手工制作这个小部件，但这是可以做到的。
- en: Arranging several labels within a label frame widget
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在标签框架小部件内排列几个标签
- en: The `LabelFrame` widget allows us to design our GUI in an organized fashion.
    We are still using the grid layout manager as our main layout design tool, yet
    by using `LabelFrame` widgets we get much more control over our GUI design.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`LabelFrame`小部件允许我们以有组织的方式设计我们的GUI。我们仍然使用网格布局管理器作为我们的主要布局设计工具，但通过使用`LabelFrame`小部件，我们可以更好地控制GUI设计。'
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are starting to add more and more widgets to our GUI, and we will make the
    GUI fully functional in the coming recipes. Here, we are starting to use the `LabelFrame`
    widget. We will reuse the GUI from the last recipe of the previous chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始向我们的GUI添加越来越多的小部件，并且我们将在接下来的示例中使GUI完全功能。在这里，我们开始使用`LabelFrame`小部件。我们将重用上一章最后一个示例中的GUI。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Add the following code just above the main event loop towards the bottom of
    the Python module:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python模块的底部朝向主事件循环上方添加以下代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![How to do it...](graphics/B04829_02_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_02_01.jpg)'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can easily align the labels vertically by changing our code, as shown next.
    Note that the only change we had to make was in the column and row numberings.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改我们的代码，我们可以轻松地垂直对齐标签，如下所示。请注意，我们唯一需要更改的是列和行编号。
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![How to do it...](graphics/B04829_02_01_1.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_02_01_1.jpg)'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Comment # 1: Here, we will create our first ttk LabelFrame widget and give
    the frame a name. The parent container is `win`, our main window.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注释＃1：在这里，我们将创建我们的第一个ttk LabelFrame小部件并为框架命名。父容器是`win`，即我们的主窗口。
- en: 'The three lines following comment # 2 create label names and place them in
    the LabelFrame. We are using the important grid layout tool to arrange the labels
    within the LabelFrame. The column and row properties of this layout manager give
    us the power to control our GUI layout.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释＃2之后的三行代码创建标签名称并将它们放置在LabelFrame中。我们使用重要的网格布局工具来排列LabelFrame内的标签。此布局管理器的列和行属性赋予我们控制GUI布局的能力。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The parent of our labels is the LabelFrame, not the `win` instance variable
    of the main window. We can see the beginning of a layout hierarchy here.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们标签的父级是LabelFrame，而不是主窗口的`win`实例变量。我们可以在这里看到布局层次的开始。
- en: 'The highlighted comment # 3 shows how easy it is to change our layout via the
    column and row properties. Note how we change the column to 0, and how we layer
    our labels vertically by numbering the row values sequentially.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的注释＃3显示了通过列和行属性轻松更改布局的方法。请注意，我们如何将列更改为0，并且如何通过按顺序编号行值来垂直叠加我们的标签。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The name ttk stands for "themed tk". The tk-themed widget set was introduced
    in Tk 8.5.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ttk的名称代表“主题tk”。tk-themed小部件集是在Tk 8.5中引入的。
- en: There's more...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In a recipe later in this chapter, we will embed LabelFrame(s) within LabelFrame(s),
    nesting them to control our GUI layout.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面的一个示例中，我们将嵌套LabelFrame(s)在LabelFrame(s)中，以控制我们的GUI布局。
- en: Using padding to add space around widgets
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用填充在小部件周围添加空间
- en: Our GUI is being created nicely. Next, we will improve the visual aspects of
    our widgets by adding a little space around them, so they can breathe...
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的GUI正在很好地创建。接下来，我们将通过在它们周围添加一点空间来改善我们小部件的视觉效果，以便它们可以呼吸...
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: While tkinter might have had a reputation for creating ugly GUIs, this has dramatically
    changed since version 8.5, which ships with Python 3.4.x. You just have to know
    how to use the tools and techniques that are available. That's what we will do
    next.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管tkinter可能曾经以创建丑陋的GUI而闻名，但自8.5版本以来（随Python 3.4.x一起发布），这种情况发生了显著变化。您只需要知道如何使用可用的工具和技术。这就是我们接下来要做的。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The procedural way of adding spacing around widgets is shown first, and then
    we will use a loop to achieve the same thing in a much better way.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先展示了围绕小部件添加间距的程序化方法，然后我们将使用循环以更好的方式实现相同的效果。
- en: Our LabelFrame looks a bit tight as it blends into the main window towards the
    bottom. Let's fix this now.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的LabelFrame看起来有点紧凑，因为它与主窗口向底部融合在一起。让我们现在来修复这个问题。
- en: 'Modify the following line of code by adding `padx` and `pady`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加`padx`和`pady`修改以下代码行：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And now our LabelFrame got some breathing space:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的LabelFrame有了一些空间：
- en: '![How to do it...](graphics/B04829_02_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_02_02.jpg)'
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In tkinter, adding space horizontally and vertically is done by using the built-in
    properties named `padx` and `pady`. These can be used to add space around many
    widgets, improving horizontal and vertical alignments, respectively. We hard-coded
    20 pixels of space to the left and right of the LabelFrame, and we added 40 pixels
    to the top and bottom of the frame. Now our LabelFrame stands out more than it
    did before.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在tkinter中，通过使用名为`padx`和`pady`的内置属性来水平和垂直地添加空间。这些属性可以用于在许多小部件周围添加空间，分别改善水平和垂直对齐。我们在LabelFrame的左右两侧硬编码了20像素的空间，并在框架的顶部和底部添加了40像素。现在我们的LabelFrame比以前更加突出。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The screenshot above only shows the relevant change.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的屏幕截图只显示了相关的更改。
- en: 'We can use a loop to add space around the labels contained within the LabelFrame:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用循环在LabelFrame内包含的标签周围添加空间：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now the labels within the LabelFrame widget have some space around them too:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在LabelFrame小部件内的标签周围也有一些空间：
- en: '![How it works...](graphics/B04829_02_02_1.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B04829_02_02_1.jpg)'
- en: The `grid_configure()` function enables us to modify the UI elements before
    the main loop displays them. So, instead of hard-coding values when we first create
    a widget, we can work on our layout and then arrange spacing towards the end of
    our file, just before the GUI is being created. This is a neat technique to know.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`grid_configure()`函数使我们能够在主循环显示UI元素之前修改它们。因此，我们可以在首次创建小部件时，而不是硬编码数值，可以在文件末尾的布局中工作，然后在创建GUI之前进行间距调整。这是一个不错的技巧。'
- en: The `winfo_children()` function returns a list of all the children belonging
    to the `labelsFrame` variable. This enables us to loop through them and assign
    the padding to each label.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`winfo_children()`函数返回属于`labelsFrame`变量的所有子项的列表。这使我们能够循环遍历它们并为每个标签分配填充。'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One thing to notice is that the spacing to the right of the labels is not really
    visible. This is because the title of the LabelFrame is longer than the names
    of the labels. We can experiment with this by making the names of the labels longer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意的一件事是标签右侧的间距实际上并不明显。这是因为LabelFrame的标题比标签的名称长。我们可以通过使标签的名称更长来进行实验。
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now our GUI looks like the following. Note how there is now some space added
    to the right of the long label next to the dots. The last dot does not touch the
    LabelFrame, which it would without the added space.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的GUI看起来像下面这样。请注意，现在在长标签旁边的右侧添加了一些空间。最后一个点没有触及LabelFrame，如果没有添加的空间，它就会触及。
- en: '![How it works...](graphics/B04829_02_02_2.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B04829_02_02_2.jpg)'
- en: We can also remove the name of the LabelFrame to see the effect `padx` has on
    positioning our labels.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以删除LabelFrame的名称，以查看`padx`对定位我们的标签的影响。
- en: '![How it works...](graphics/B04829_02_02_3.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B04829_02_02_3.jpg)'
- en: How widgets dynamically expand the GUI
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小部件如何动态扩展GUI
- en: You probably noticed in previous screenshots and by running the code that widgets
    have a capability to extend themselves to the space they need to visually display
    their text.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到在之前的屏幕截图中，并通过运行代码，小部件具有扩展自身以视觉显示其文本所需的能力。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Java introduced the concept of dynamic GUI layout management. In comparison,
    visual development IDEs like VS.NET lay out the GUI in a visual manner, and are
    basically hard-coding the x and y coordinates of UI elements.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Java引入了动态GUI布局管理的概念。相比之下，像VS.NET这样的可视化开发IDE以可视化方式布局GUI，并且基本上是在硬编码UI元素的x和y坐标。
- en: Using `tkinter`, this dynamic capability creates both an advantage and a little
    bit of a challenge, because sometimes our GUI dynamically expands when we would
    prefer it rather not to be so dynamic! Well, we are dynamic Python programmers,
    so we can figure out how to make the best use of this fantastic behavior!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`tkinter`，这种动态能力既带来了优势，也带来了一点挑战，因为有时我们的GUI会在我们不希望它太动态时动态扩展！好吧，我们是动态的Python程序员，所以我们可以想出如何最好地利用这种奇妙的行为！
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: At the beginning of the previous recipe we added a label frame widget. This
    moved some of our controls to the center of column 0\. We might not wish this
    modification to our GUI layout. Next, we will explore some ways to fix this.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇食谱的开头，我们添加了一个标签框小部件。这将一些控件移动到第0列的中心。我们可能不希望这种修改影响我们的GUI布局。接下来，我们将探讨一些修复这个问题的方法。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let us first become aware of the subtle details that are going on in our GUI
    layout, in order to understand it better.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先注意一下GUI布局中正在发生的微妙细节，以更好地理解它。
- en: We are using the grid layout manager widget and it lays out our widgets in a
    zero-based grid.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用网格布局管理器小部件，并且它以从零开始的网格布局排列我们的小部件。
- en: '| Row 0; Col 0 | Row 0; Col 1 | Row 0; Col 2 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 第0行；第0列 | 第0行；第1列 | 第0行；第2列 |'
- en: '| Row 1; Col 0 | Row 1; Col 1 | Row 1; Col 2 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 第1行；第0列 | 第1行；第1列 | 第1行；第2列 |'
- en: Using the grid layout manager, what is happening is that the width of any given
    column is determined by the longest name or widget in that column. This affects
    all rows.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用网格布局管理器时，任何给定列的宽度由该列中最长的名称或小部件确定。这会影响所有行。
- en: By adding our LabelFrame widget and giving it a title that is longer than some
    hard-coded size widget like the top-left label and the text entry below it, we
    dynamically move those widgets to the center of column 0, adding space to the
    left and right sides of those widgets.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加LabelFrame小部件并给它一个比某些硬编码大小小部件（如左上角的标签和下面的文本输入）更长的标题，我们动态地将这些小部件移动到第0列的中心，并在这些小部件的左右两侧添加空间。
- en: Incidentally, because we used the sticky property for the Checkbutton and ScrolledText
    widgets, those remain attached to the left side of the frame.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，因为我们为Checkbutton和ScrolledText小部件使用了sticky属性，它们仍然附着在框架的左侧。
- en: 'Let''s look in more detail at the screenshot from the first recipe of this
    chapter:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地查看本章第一个示例的屏幕截图：
- en: '![How to do it...](graphics/B04829_02_02_4.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_02_02_4.jpg)'
- en: 'We added the following code to create the LabelFrame and then placed labels
    into this frame:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了以下代码来创建LabelFrame，然后将标签放入此框架中：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Since the text property of the LabelFrame, which is displayed as the title of
    the LabelFrame, is longer than both our **Enter a name:** label and the textbox
    entry below it, those two widgets are dynamically centered with the new width
    of column 0.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于LabelFrame的text属性（显示为LabelFrame的标题）比我们的**Enter a name:**标签和下面的文本框条目都长，这两个小部件会动态地居中于列0的新宽度。
- en: The Checkbutton and Radiobutton widgets in column 0 did not get centered because
    we used the `sticky=tk.W` property when we created those widgets.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列0中的Checkbutton和Radiobutton小部件没有居中，因为我们在创建这些小部件时使用了`sticky=tk.W`属性。
- en: For the ScrolledText widget we used `sticky=tk.WE,` which binds the widget to
    both the west (aka left) and east (aka right) side of the frame.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ScrolledText小部件，我们使用了`sticky=tk.WE`，这将小部件绑定到框架的西（即左）和东（即右）两侧。
- en: Let's remove the sticky property from the ScrolledText widget and observe the
    effect this change has.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从ScrolledText小部件中删除sticky属性，并观察这个改变的影响。
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now our GUI has new space around the ScrolledText widget both on the left and
    right sides. Because we used the `columnspan=3` property, our ScrolledText widget
    still spans all three columns.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的GUI在ScrolledText小部件的左侧和右侧都有新的空间。因为我们使用了`columnspan=3`属性，我们的ScrolledText小部件仍然跨越了所有三列。
- en: '![How to do it...](graphics/B04829_02_02_5.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_02_02_5.jpg)'
- en: If we remove `columnspan=3`, we get the following GUI, which is not what we
    want. Now our ScrolledText only occupies column 0, and, because of its size, it
    stretches the layout.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移除`columnspan=3`，我们会得到以下GUI，这不是我们想要的。现在我们的ScrolledText只占据列0，并且由于其大小，它拉伸了布局。
- en: '![How to do it...](graphics/B04829_02_02_6.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_02_02_6.jpg)'
- en: One way to get our layout back to where we were before adding the LabelFrame
    is to adjust the grid column position. Change the column value from 0 to 1.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的布局恢复到添加LabelFrame之前的方法之一是调整网格列位置。将列值从0更改为1。
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now our GUI looks like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的GUI看起来像这样：
- en: '![How to do it...](graphics/B04829_02_03.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_02_03.jpg)'
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Because we are still using individual widgets, our layout can get messed up.
    By moving the column value of the LabelFrame from 0 to 1, we were able to get
    the controls back to where they used to be and where we prefer them to be. At
    least the left-most label, text, checkbox, scrolledtext, and radio button widgets
    are now located where we intended them to be. The second label and text `Entry`
    located in column 1 have aligned themselves to the center of the length of the
    **Labels in a Frame** widget, so we basically moved our alignment challenge one
    column to the right. It is not so visible because the size of the **Choose a number:**
    label is almost the same as the size of the **Labels in a Frame** title, and so
    the column width was already close to the new width generated by the LabelFrame.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们仍在使用单独的小部件，所以我们的布局可能会混乱。通过将LabelFrame的列值从0移动到1，我们能够将控件放回到它们原来的位置，也是我们喜欢它们的位置。至少最左边的标签、文本、复选框、滚动文本和单选按钮小部件现在位于我们打算的位置。第二个标签和文本“Entry”位于列1，它们自己对齐到了**Labels
    in a Frame**小部件的长度中心，所以我们基本上将我们的对齐挑战移到了右边一列。这不太明显，因为**Choose a number:**标签的大小几乎与**Labels
    in a Frame**标题的大小相同，因此列宽已经接近LabelFrame生成的新宽度。
- en: There's more...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the next recipe, we will embed frames within frames to avoid the accidental
    misalignment of widgets we just experienced in this recipe.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个教程中，我们将嵌入框架以避免我们在本教程中刚刚经历的小部件意外错位。
- en: Aligning the GUI widgets by embedding frames within frames
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过嵌入框架来对齐GUI小部件
- en: We have much better control of our GUI layout if we embed frames within frames.
    This is what we will do in this recipe.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在框架中嵌入框架，我们将更好地控制GUI布局。这就是我们将在本教程中做的事情。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The dynamic behavior of Python and its GUI modules can create a little bit of
    a challenge to really get our GUI looking the way we want. Here we will embed
    frames within frames to get more control of our layout. This will establish a
    stronger hierarchy among the different UI elements, making the visual appearance
    easier to achieve.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Python及其GUI模块的动态行为可能会对我们真正想要的GUI外观造成一些挑战。在这里，我们将嵌入框架以获得对布局的更多控制。这将在不同UI元素之间建立更强的层次结构，使视觉外观更容易实现。
- en: We will continue to use the GUI we created in the previous recipe.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用我们在上一个教程中创建的GUI。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Here, we will create a top-level frame that will contain other frames and widgets.
    This will help us to get our GUI layout just the way we want.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个顶级框架，其中将包含其他框架和小部件。这将帮助我们将GUI布局调整到我们想要的样子。
- en: In order to do so, we will have to embed our current controls within a central
    ttk.LabelFrame. This ttk.LabelFrame is a child of the main parent window and all
    controls will be children of this ttk.LabelFrame.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将不得不将我们当前的控件嵌入到一个中央ttk.LabelFrame中。这个ttk.LabelFrame是主父窗口的子窗口，所有控件都是这个ttk.LabelFrame的子控件。
- en: Up to this point in our recipes, we have assigned all widgets to our main GUI
    frame directly. Now we will only assign our LabelFrame to our main window, and
    after that, we will make this LabelFrame the parent container for all the widgets.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的教程中到目前为止，我们已经直接将所有小部件分配给了我们的主GUI框架。现在我们将只将我们的LabelFrame分配给我们的主窗口，之后，我们将使这个LabelFrame成为所有小部件的父容器。
- en: 'This creates the following hierarchy in our GUI layout:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这在我们的GUI布局中创建了以下层次结构：
- en: '![How to do it...](graphics/B04829_02_30.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_02_30.jpg)'
- en: In this diagram, **win** is the variable that references our main GUI tkinter
    window frame; **monty** is the variable that references our LabelFrame and is
    a child of the main window frame (**win**); and **aLabel** and all other widgets
    are now placed into the LabelFrame container (**monty**).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，**win**是指我们的主GUI tkinter窗口框架的变量；**monty**是指我们的LabelFrame的变量，并且是主窗口框架（**win**）的子窗口；**aLabel**和所有其他小部件现在都放置在LabelFrame容器（**monty**）中。
- en: 'Add the following code towards the top of our Python module (see comment #
    1):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Python模块顶部添加以下代码（参见注释＃1）：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we will modify all the following controls to use `monty` as the parent,
    replacing `win`. Here is an example of how to do this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改所有以下控件，使用`monty`作为父控件，替换`win`。以下是如何做到这一点的示例：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![How to do it...](graphics/B04829_02_04.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到...](graphics/B04829_02_04.jpg)'
- en: 'Note how all the widgets are now contained in the **Monty Python** LabelFrame,
    which surrounds all of them with a barely visible thin line. Next, we can reset
    the **Labels in a Frame** widget to the left without messing up our GUI layout:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在所有的小部件都包含在**Monty Python** LabelFrame中，它用几乎看不见的细线将它们全部包围起来。接下来，我们可以重置**Labels
    in a Frame**小部件到左侧，而不会弄乱我们的GUI布局：
- en: '![How to do it...](graphics/B04829_02_04_1.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到...](graphics/B04829_02_04_1.jpg)'
- en: Oops - maybe not. While our frame within another frame aligned nicely to the
    left, it again pushed our top widgets into the center (a default).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀-也许不是。虽然我们在另一个框架中的框架很好地对齐到了左侧，但它又把我们的顶部小部件推到了中间（默认）。
- en: In order to align them to the left, we have to force our GUI layout by using
    the `sticky` property. By assigning it "W" (West), we can control the widget to
    be left-aligned.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将它们对齐到左侧，我们必须使用`sticky`属性来强制我们的GUI布局。通过将其分配为"W"（西），我们可以控制小部件左对齐。
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![How to do it...](graphics/B04829_02_04_2.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到...](graphics/B04829_02_04_2.jpg)'
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Note how we aligned the label, but not the text box below it. We have to use
    the `sticky` property for all the controls we want to left-align. We can do that
    in a loop, using the `winfo_children()` and `grid_configure(sticky='W')` properties,
    as we did before in recipe 2 of this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们对齐了标签，但没有对下面的文本框进行对齐。我们必须使用`sticky`属性来左对齐我们想要左对齐的所有控件。我们可以在一个循环中做到这一点，使用`winfo_children()`和`grid_configure(sticky='W')`属性，就像我们在本章的第2个配方中做的那样。
- en: The `winfo_children()` function returns a list of all the children belonging
    to the parent. This enables us to loop through all of the widgets and change their
    properties.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`winfo_children()`函数返回属于父控件的所有子控件的列表。这使我们能够循环遍历所有小部件并更改它们的属性。'
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Using tkinter to force left, right, top, bottom the naming is very similar
    to Java: west, east, north and south, abbreviated to: "W" and so on. We can also
    use the following syntax: tk.W instead of "W".'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用tkinter来强制左、右、上、下的命名与Java非常相似：west、east、north和south，缩写为："W"等等。我们还可以使用以下语法：tk.W而不是"W"。
- en: 'In a previous recipe, we combined both "W" and "E" to make our ScrolledText
    widget attach itself both to the left and right sides of its container using "WE".
    We can add more combinations: "NSE" will stretch our widget to the top, bottom
    and right side. If we have only one widget in our form, for example a button,
    we can make it fill in the entire frame by using all options: "NSWE". We can also
    use tuple syntax: `sticky=(tk.N, tk.S, tk.W, tk.E)`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的配方中，我们将"W"和"E"组合在一起，使我们的ScrolledText小部件使用"WE"附加到其容器的左侧和右侧。我们可以添加更多的组合："NSE"将使我们的小部件拉伸到顶部、底部和右侧。如果我们的表单中只有一个小部件，例如一个按钮，我们可以使用所有选项使其填满整个框架："NSWE"。我们还可以使用元组语法：`sticky=(tk.N,
    tk.S, tk.W, tk.E)`。
- en: Let's change the very long label back and align the entry in column 0 to the
    left.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把非常长的标签改回来，并将条目对齐到第0列的左侧。
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![How it works...](graphics/B04829_02_04_3.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B04829_02_04_3.jpg)'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to separate the influence that the length of our **Labels in a Frame**
    LabelFrame has on the rest of our GUI layout, we must not place this LabelFrame
    into the same LabelFrame as the other widgets. Instead we assign it directly to
    the main GUI form (`win`).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分离我们的**Labels in a Frame** LabelFrame对我们的GUI布局的影响，我们不能将这个LabelFrame放入与其他小部件相同的LabelFrame中。相反，我们直接将它分配给主GUI表单（`win`）。
- en: We will do this in later chapters.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以后的章节中做到这一点。
- en: Creating menu bars
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建菜单栏
- en: In this recipe, we will add a menu bar to our main window, add menus to the
    menu bar, and then add menu items to the menus.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将向我们的主窗口添加一个菜单栏，向菜单栏添加菜单，然后向菜单添加菜单项。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start by learning the techniques of how to add a menu bar, several menus
    and a few menu items to show the principle of how to do it. Clicking on a menu
    item will have no effect. Next, we will add functionality to the menu items, for
    example, closing the main window when clicking the **Exit** menu item and displaying
    a **Help** | **About** dialog.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习如何添加菜单栏、几个菜单和一些菜单项的技巧，以展示如何做到这一点的原则。单击菜单项将不会产生任何效果。接下来，我们将为菜单项添加功能，例如，单击**Exit**菜单项时关闭主窗口，并显示**Help**
    | **About**对话框。
- en: We are continuing to extend the GUI we created in the current and previous chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续扩展我们在当前和上一章中创建的GUI。
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'First, we have to import the `Menu` class from `tkinter`. Add the following
    line of code to the top of the Python module, where the import statements live:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，我们必须从`tkinter`中导入`Menu`类。在Python模块的顶部添加以下代码，即导入语句所在的地方： '
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we will create the menu bar. Add the following code towards the bottom
    of the module, just above where we create the main event loop:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建菜单栏。在模块的底部添加以下代码，就在我们创建主事件循环的地方上面：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we add a menu to the bar and also assign a menu item to the menu.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在菜单栏中添加一个菜单，并将一个菜单项分配给菜单。
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Running this code adds a menu bar, with a menu, which has a menu item.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将添加一个菜单栏，其中有一个菜单，其中有一个菜单项。
- en: '![How to do it...](graphics/B04829_02_05.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到...](graphics/B04829_02_05.jpg)'
- en: Next, we add a second menu item to the first menu we added to the menu bar.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在我们添加到菜单栏的第一个菜单中添加第二个菜单项。
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![How to do it...](graphics/B04829_02_05_1.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到...](graphics/B04829_02_05_1.jpg)'
- en: We can add a separator line between the MenuItems by adding the following line
    of code (# 4) in between the existing MenuItems.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在现有的MenuItems之间添加以下代码（＃4）来添加一个分隔线。
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![How to do it...](graphics/B04829_02_05_2.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到...](graphics/B04829_02_05_2.jpg)'
- en: By passing in the property `tearoff` to the constructor of the menu, we can
    remove the first dashed line that, by default, appears above the first MenuItem
    in a menu.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`tearoff`属性传递给菜单的构造函数，我们可以删除默认情况下出现在菜单中第一个MenuItem上方的第一条虚线。
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![How to do it...](graphics/B04829_02_05_3.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_02_05_3.jpg)'
- en: We will add a second menu, which will be horizontally placed to the right of
    the first menu. We will give it one MenuItem, which we name `About`, and, in order
    for this to work, we have to add this second menu to the MenuBar.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加第二个菜单，它将水平放置在第一个菜单的右侧。我们将给它一个菜单项，我们将其命名为`关于`，为了使其工作，我们必须将这第二个菜单添加到菜单栏。
- en: '**File** and **Help** | **About** are very common Windows GUI layouts that
    we are all familiar with, and we can create those same menus using Python and
    tkinter.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件**和**帮助** | **关于**是非常常见的Windows GUI布局，我们都很熟悉，我们可以使用Python和tkinter创建相同的菜单。'
- en: The order of creation and the naming of menu, menu item, and menu bar might
    at first be a little bit confusing, but, once we get used to how tkinter requires
    us to code it, this actually becomes fun.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单的创建顺序和命名可能一开始有点令人困惑，但一旦我们习惯了tkinter要求我们如何编码，这实际上变得有趣起来。
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![How to do it...](graphics/B04829_02_05_4.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_02_05_4.jpg)'
- en: 'At this point, our GUI has a MenuBar and two menus that contain some MenuItems.
    Clicking on them does not do much, until we add some commands. That''s what we
    will do next. Add the following code above the creation of the MenuBar:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的GUI有一个菜单栏和两个包含一些菜单项的菜单。单击它们并没有太多作用，直到我们添加一些命令。这就是我们接下来要做的。在创建菜单栏之前添加以下代码：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we bind the **File** | **Exit** MenuItem to this function by adding the
    following command to the MenuItem:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将**文件** | **退出**菜单项绑定到这个函数，方法是在菜单项中添加以下命令：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, when we click the `Exit` MenuItem, our application will indeed exit.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们点击`退出`菜单项时，我们的应用程序确实会退出。
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In comment # 1, we are calling the `tkinter` constructor of the menu and assigning
    the menu to our main GUI window. We save a reference in the instance variable
    named `menuBar` and, in the following line of code, we use this instance to configure
    our GUI to use `menuBar` as our menu.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释＃1中，我们调用了菜单的`tkinter`构造函数，并将菜单分配给我们的主GUI窗口。我们在实例变量中保存了一个名为`menuBar`的引用，并在下一行代码中，我们使用这个实例来配置我们的GUI，以使用`menuBar`作为我们的菜单。
- en: 'Comment # 2 shows how we first add a MenuItem and then create a menu. This
    seems to be unintuitive, but this is how tkinter works. The `add_cascade()` method
    aligns the MenuItems one below the other, in a vertical layout.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注释＃2显示了我们首先添加一个菜单项，然后创建一个菜单。这似乎有点不直观，但这就是tkinter的工作原理。`add_cascade()`方法将菜单项垂直布局在一起。
- en: 'Comment # 3 shows how to add a second MenuItem to the menu.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注释＃3显示了如何向菜单添加第二个菜单项。
- en: 'In comment # 4, we are adding a separator line between the two MenuItems. This
    is usually used to group related MenuItems and separate them from less related
    items (hence the name).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释＃4中，我们在两个菜单项之间添加了一个分隔线。这通常用于将相关的菜单项分组并将它们与不太相关的项目分开（因此得名）。
- en: 'Comment # 5 disables the tearoff dashed line to make our menu look much better.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注释＃5禁用了虚线以使我们的菜单看起来更好。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Without disabling this default feature, the user can "tear off" the menu from
    the main window. I find this capability to be of little value. Feel free to play
    around with it by double-clicking the dashed line (before disabling this feature).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在不禁用此默认功能的情况下，用户可以从主窗口“撕下”菜单。我发现这种功能价值不大。随意双击虚线（在禁用此功能之前）进行尝试。
- en: If you are using a Mac, this feature might not be enabled, so you do not have
    to worry about it at all.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Mac，这个功能可能没有启用，所以您根本不用担心。
- en: '![How it works...](graphics/B04829_02_05_5.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](graphics/B04829_02_05_5.jpg)'
- en: 'Comment # 6 shows you how to add a second menu to the MenuBar. We can keep
    on adding menus by using this technique.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注释＃6向您展示了如何向菜单栏添加第二个菜单。我们可以继续使用这种技术添加菜单。
- en: 'Comment # 7 creates a function to quit our GUI application cleanly. This is
    the recommended Pythonic way to end the main event loop.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注释＃7创建了一个函数来干净地退出我们的GUI应用程序。这是结束主事件循环的推荐Pythonic方式。
- en: 'In # 8 we bind the function we created in # 7 to the MenuItem, using the `tkinter`
    command property. Whenever we want our MenuItems to actually do something, we
    have to bind each of them to a function.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在＃8中，我们将在＃7中创建的函数绑定到菜单项，使用`tkinter`命令属性。每当我们想要我们的菜单项实际执行某些操作时，我们必须将它们中的每一个绑定到一个函数。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are using a recommended Python naming convention by preceding our quit function
    with one single underscore, to indicate that this is a private function not to
    be called by clients of our code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了推荐的Python命名约定，通过在退出函数之前加上一个下划线，以表示这是一个私有函数，不应该由我们代码的客户端调用。
- en: There's more…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We will add the **Help** | **About** functionality in the next chapter, which
    introduces message boxes and much more.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将添加**帮助** | **关于**功能，介绍消息框等等。
- en: Creating tabbed widgets
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建选项卡小部件
- en: In this recipe, we will create tabbed widgets to further organize our expanding
    GUI written in tkinter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建选项卡小部件，以进一步组织我们在tkinter中编写的扩展GUI。
- en: Getting ready
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to improve our Python GUI using tabs, we will start at the beginning,
    using the minimum amount of code necessary. In the following recipes, we will
    add widgets from previous recipes and place them into this new tabbed layout.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进我们的Python GUI，我们将从头开始，使用最少量的代码。在接下来的配方中，我们将从以前的配方中添加小部件，并将它们放入这个新的选项卡布局中。
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new Python module and place the following code into this module:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的Python模块，并将以下代码放入该模块：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This creates the following GUI:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了以下GUI：
- en: '![How to do it...](graphics/B04829_02_06.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_02_06.jpg)'
- en: While not amazingly impressive as of yet, this widget adds another very powerful
    tool to our GUI design toolkit. It comes with its own limitations in the minimalist
    example above (for example, we cannot reposition the GUI nor does it show the
    entire GUI title).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管目前还不是非常令人印象深刻，但这个小部件为我们的GUI设计工具包增加了另一个非常强大的工具。它在上面的极简示例中有自己的限制（例如，我们无法重新定位GUI，也不显示整个GUI标题）。
- en: While in previous recipes, we used the grid layout manager for simpler GUIs,
    we can use a simpler layout manager and "pack" is one of them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的示例中，我们使用网格布局管理器来创建更简单的GUI，我们可以使用更简单的布局管理器之一，“pack”是其中之一。
- en: In the preceding code, we "pack" tabControl ttk.Notebook into the main GUI form
    expanding the notebook tabbed control to fill in all sides.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们将tabControl ttk.Notebook“pack”到主GUI表单中，扩展选项卡控件以填充所有边缘。
- en: '![How to do it...](graphics/B04829_02_06_0.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_02_06_0.jpg)'
- en: We can add a second tab to our control and click between them.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向我们的控件添加第二个选项卡并在它们之间切换。
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now we have two tabs. Click on **Tab 2** to give it the focus.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个标签。单击**Tab 2**以使其获得焦点。
- en: '![How to do it...](graphics/B04829_02_06_1.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_02_06_1.jpg)'
- en: We would really like to see our windows title. So, to do this, we have to add
    a widget to one of our tabs. The widget has to be wide enough to expand our GUI
    dynamically to display our window title. We are adding Ole Monty back, together
    with his children.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的很想看到我们的窗口标题。因此，为了做到这一点，我们必须向我们的选项卡中添加一个小部件。该小部件必须足够宽，以动态扩展我们的GUI以显示我们的窗口标题。我们正在将Ole
    Monty和他的孩子们重新添加。
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now we got our **Monty Python** inside **Tab1**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在**Tab1**中有我们的**Monty Python**。
- en: '![How to do it...](graphics/B04829_02_06_2.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_02_06_2.jpg)'
- en: We can keep placing all the widgets we have created so far into our newly created
    tab controls.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续将到目前为止创建的所有小部件放入我们新创建的选项卡控件中。
- en: '![How to do it...](graphics/B04829_02_06_3.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_02_06_3.jpg)'
- en: 'Now all the widgets reside inside **Tab1**. Let''s move some to **Tab2**. First,
    we create a second LabelFrame to be the container of our widgets relocating to
    **Tab2**:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的小部件都驻留在**Tab1**中。让我们将一些移动到**Tab2**。首先，我们创建第二个LabelFrame，作为我们将移动到**Tab2**的小部件的容器：
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we move the check and radio buttons to **Tab2**, by specifying the new
    parent container, which is a new variable we name `monty2`. Here is an example
    which we apply to all controls that relocate to **Tab2**:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过指定新的父容器`monty2`，将复选框和单选按钮移动到**Tab2**。以下是一个示例，我们将其应用于所有移动到**Tab2**的控件：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When we run the code, our GUI now looks different. **Tab1** has less widgets
    than it had before when it contained all of our previously created widgets.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，我们的GUI现在看起来不同了。**Tab1**的小部件比以前少了，当它包含我们以前创建的所有小部件时。
- en: '![How to do it...](graphics/B04829_02_06_4.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_02_06_4.jpg)'
- en: We can now click **Tab 2** and see our relocated widgets.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以单击**Tab 2**并查看我们移动的小部件。
- en: '![How to do it...](graphics/B04829_02_06_5.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_02_06_5.jpg)'
- en: Clicking the relocated Radiobutton(s) no longer has any effect, so we will change
    their actions to rename the text property, which is the title of the LabelFrame
    widget, to the name the Radiobuttons display. When we click the **Gold** Radiobutton,
    we no longer set the background of the frame to the color gold but here replace
    the LabelFrame text title instead. Python "The Snake" now becomes "Gold".
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 单击移动的Radiobutton(s)不再产生任何效果，因此我们将更改它们的操作以重命名文本属性，这是LabelFrame小部件的标题，以显示Radiobuttons的名称。当我们单击**Gold**
    Radiobutton时，我们不再将框架的背景设置为金色，而是在这里替换LabelFrame文本标题。Python“ The Snake”现在变成“Gold”。
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, selecting any of the RadioButton widgets results in changing the name of
    the LabelFrame.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择任何RadioButton小部件都会导致更改LabelFrame的名称。
- en: '![How to do it...](graphics/B04829_02_06_6.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_02_06_6.jpg)'
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: After creating a second tab, we moved some of the widgets that originally resided
    in **Tab1** to **Tab2**. Adding tabs is another excellent way to organize our
    ever-increasing GUI. This is one very nice way to handle complexity in our GUI
    design. We can arrange widgets in groups where they naturally belong, and free
    our users from clutter by using tabs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 创建第二个选项卡后，我们将一些最初驻留在**Tab1**中的小部件移动到**Tab2**。添加选项卡是组织我们不断增加的GUI的另一种绝佳方式。这是处理GUI设计中复杂性的一种非常好的方式。我们可以将小部件分组放置在它们自然属于的组中，并通过使用选项卡使我们的用户摆脱混乱。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In `tkinter`, creating tabs is done via the `Notebook` widget, which is the
    tool that allows us to add tabbed controls. The tkinter notebook widget, like
    so many other widgets, comes with additional properties that we can use and configure.
    An excellent place to start exploring additional capabilities of the tkinter widgets
    at our disposal is the official website: [https://docs.python.org/3.1/library/tkinter.ttk.html#notebook](https://docs.python.org/3.1/library/tkinter.ttk.html#notebook)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tkinter`中，通过`Notebook`小部件创建选项卡是通过`Notebook`小部件完成的，这是允许我们添加选项卡控件的工具。 tkinter笔记本小部件，就像许多其他小部件一样，具有我们可以使用和配置的附加属性。探索我们可以使用的tkinter小部件的其他功能的绝佳起点是官方网站：[https://docs.python.org/3.1/library/tkinter.ttk.html#notebook](https://docs.python.org/3.1/library/tkinter.ttk.html#notebook)
- en: Using the grid layout manager
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网格布局管理器
- en: The grid layout manager is one of the most useful layout tools at our disposal.
    We have already used it in many recipes because it is just so powerful.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 网格布局管理器是我们可以使用的最有用的布局工具之一。我们已经在许多示例中使用了它，因为它非常强大。
- en: Getting ready…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作...
- en: In this recipe, we will review some of the techniques of the grid layout manager.
    We have used them already and here we will explore them further.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将回顾一些网格布局管理器的技术。我们已经使用过它们，在这里我们将进一步探讨它们。
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this chapter, we have created rows and columns, which truly is a database
    approach to GUI design (MS Excel does the same). We hard-coded the first four
    rows but then we forgot to give the next row a specification of where we wish
    it to reside.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经创建了行和列，这实际上是GUI设计的数据库方法（MS Excel也是如此）。我们硬编码了前四行，但然后忘记了给下一行一个我们希望它驻留的位置的规范。
- en: Tkinter did fill this in for us without us even noticing.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter在我们不知不觉中为我们填充了这个。
- en: 'Here is what we did in our code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在代码中所做的：
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Tkinter automatically adds the missing row (emphasized in comment # 1) where
    we did not specify any particular row. We might not realize this.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter自动添加了我们没有指定任何特定行的缺失行（在注释＃1中强调）。我们可能没有意识到这一点。
- en: We laid out the checkbuttons on row 4 then we "forgot" to specify the row for
    our ScrolledText widget, which we reference via the scr variable and then we added
    the Radiobutton widgets to be laid out in row 6.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将复选框布置在第4行，然后“忘记”为我们的ScrolledText小部件指定行，我们通过scr变量引用它，然后我们添加了要布置在第6行的Radiobutton小部件。
- en: This works nicely because tkinter automatically incremented the row position
    for our ScrolledText widget to use the next highest row number, which was row
    5.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好用，因为tkinter自动递增了我们的ScrolledText小部件的行位置，以使用下一个最高的行号，即第5行。
- en: Looking at our code and not realizing that we "forgot" to explicitly position
    our ScrolledText widget to row 5, we might think nothing resides there.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我们的代码，没有意识到我们“忘记”将我们的ScrolledText小部件明确定位到第5行，我们可能会认为那里什么都没有。
- en: So, we might try the following.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以尝试以下操作。
- en: 'If we set the variable `curRad` to use row 5, we might get an unpleasant surprise:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将变量`curRad`设置为使用第5行，我们可能会得到一个不愉快的惊喜：
- en: '![How to do it...](graphics/B04829_02_07.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_02_07.jpg)'
- en: How it works...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Note how our row of RadioButton(s) suddenly ended up in the middle of our ScrolledText
    widget! This is definitely not what we intended our GUI to look like!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的RadioButton(s)行突然出现在我们的ScrolledText小部件的中间！这绝对不是我们想要的GUI样式！
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we forget to explicitly specify the row number, by default, `tkinter` will
    use the next available row.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记显式指定行号，默认情况下，`tkinter`将使用下一个可用的行。
- en: 'We also used the `columnspan` property to make sure our widgets did not get
    limited to just one column. Here is how we made sure that our ScrolledText widget
    spans all the columns of our GUI:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`columnspan`属性来确保我们的小部件不会被限制在一列。以下是我们如何确保我们的ScrolledText小部件跨越GUI的所有列：
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
