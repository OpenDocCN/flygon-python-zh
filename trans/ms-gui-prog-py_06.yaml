- en: Creating Data Interfaces with Model-View Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模型-视图类创建数据接口
- en: The vast majority of application software is built to view and manipulate organized
    data. Even in applications that aren't explicitly *database applications*, there's
    often a need to interact with collections of data on a smaller scale, such as
    populating a combobox with options or displaying a hierarchy of settings. Without
    some sort of organizational paradigm, interactions between a GUI and a set of
    data can quickly become a nightmare of spaghetti code. The **m****odel-view**
    pattern is one such paradigm.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 绝大多数应用软件都是用来查看和操作组织好的数据。即使在不是显式*数据库应用程序*的应用程序中，通常也需要以较小的规模与数据集进行交互，比如用选项填充组合框或显示一系列设置。如果没有某种组织范式，GUI和一组数据之间的交互很快就会变成一团乱麻的代码噩梦。**模型-视图**模式就是这样一种范式。
- en: 'In this chapter, we''re going to learn about Qt''s model-view widgets and how
    we can use them to work elegantly with data in our applications. We''ll cover
    the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Qt的模型-视图小部件以及如何在应用程序中优雅地处理数据。我们将涵盖以下主题：
- en: Understanding model-view design
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模型-视图设计
- en: Models and views in PyQt
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyQt中的模型和视图
- en: Building a **comma-separated values** (**CSV**) editor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个**逗号分隔值**（**CSV**）编辑器
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter has the same technical requirements as the previous chapters. You
    might also wish to have the example code from [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter05](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter05).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章具有与前几章相同的技术要求。您可能还希望从[https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter05](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter05)获取示例代码。
- en: You will also need one or two CSV files to use with our CSV editor. These can
    be made in any spreadsheet program and should be created with column headers as
    the first row.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一个或两个CSV文件来使用我们的CSV编辑器。这些可以在任何电子表格程序中制作，并且应该以列标题作为第一行创建。
- en: Check out the following video to see the code in action: [http://bit.ly/2M66bnv](http://bit.ly/2M66bnv)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码是如何运行的：[http://bit.ly/2M66bnv](http://bit.ly/2M66bnv)
- en: Understanding model-view design
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模型-视图设计
- en: Model-view is a software application design paradigm that implements **separation
    of concerns**. It is based on the venerable **Model-View-Controller** (**MVC**)
    pattern but differs in that the controller and view are combined into one component.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图是一种实现**关注点分离**的软件应用设计范式。它基于古老的**模型-视图-控制器**（**MVC**）模式，但不同之处在于控制器和视图被合并成一个组件。
- en: In model-view design, the **model** is the component that holds the application
    data and contains the logic for retrieving, storing, and manipulating data. The
    **view** component presents the data to the user and provides an interface for
    entering and manipulating data. By separating these components of the application,
    we keep their interdependency to a minimum, making them much easier to reuse or
    refactor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型-视图设计中，**模型**是保存应用程序数据并包含检索、存储和操作数据逻辑的组件。**视图**组件向用户呈现数据，并提供输入和操作数据的界面。通过将应用程序的这些组件分离，我们将它们的相互依赖性降到最低，使它们更容易重用或重构。
- en: 'Let''s go through a simple example to illustrate this process. Starting with
    the application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow*, let''s build a simple text-file editor:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子来说明这个过程。从[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)的应用程序模板开始，*使用QMainWindow构建应用程序*，让我们构建一个简单的文本文件编辑器：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a simple form with a line edit for the filename, a text edit for the
    content, and a Save button that calls a  `save()`  method.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的表单，包括一个用于文件名的行编辑，一个用于内容的文本编辑和一个调用`save()`方法的保存按钮。
- en: 'Let''s create the `save()` method as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建以下`save()`方法：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This method checks whether there is a filename entered in the line edit, makes
    sure the filename doesn't already exist (so you don't overwrite an important file
    while testing this code!), then attempts to save it. If there is an error of any
    kind, the method displays a `QMessageBox` instance to report the error.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法检查是否在行编辑中输入了文件名，确保文件名不存在（这样你就不会在测试这段代码时覆盖重要文件！），然后尝试保存它。如果出现任何错误，该方法将显示一个`QMessageBox`实例来报告错误。
- en: This application works but lacks a clean separation of model and view. The same
    method that writes the file to disk also displays error boxes and calls input
    widget methods. If we were going to expand this application to any degree, the
    `save()` method would quickly become a maze of presentation logic mixed with data-handling
    logic.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序可以工作，但缺乏清晰的模型和视图分离。将文件写入磁盘的同一个方法也显示错误框并调用输入小部件方法。如果我们要扩展这个应用程序到任何程度，`save()`方法很快就会变成一个混合了数据处理逻辑和呈现逻辑的迷宫。
- en: Let's rewrite this application with separate `Model` and `View` classes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用单独的`Model`和`View`类重写这个应用程序。
- en: 'Starting with a clean copy of the application template, let''s create our `Model`
    class:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序模板的干净副本开始，让我们创建我们的`Model`类：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We''ve built our model by subclassing `QObject`. Models should have no involvement
    in displaying the GUI, so there''s no need to base it on `QWidget` classes. However,
    as the model will use signals and slots to communicate, we''re using  `QObject`
    as a base class. The model implements our `save()` method from the previous example,
    but with two changes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过子类化`QObject`来构建我们的模型。模型不应参与显示GUI，因此不需要基于`QWidget`类。然而，由于模型将使用信号和槽进行通信，我们使用`QObject`作为基类。模型实现了我们在前面示例中的`save()`方法，但有两个变化：
- en: First, it expects user data to be passed in as arguments, having no knowledge
    of the widgets this data came from
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它期望用户数据作为参数传入，不知道这些数据来自哪些小部件
- en: Second, it merely emits a Qt signal when an error is encountered, rather than
    taking any GUI-specific actions
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，当遇到错误时，它仅仅发出一个Qt信号，而不采取任何特定于GUI的操作
- en: 'Next, let''s create our `View` class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建我们的`View`类：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This class contains the same fields and field layout definitions as before.
    This time, however, rather than calling `save()`, our Save button is connected
    to a `submit()` callback that gathers the form data and emits it using a signal.
    We've also added a `show_error()` method that will display errors.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包含与之前相同的字段和字段布局定义。然而，这一次，我们的保存按钮不再调用`save()`，而是连接到一个`submit()`回调，该回调收集表单数据并使用信号发射它。我们还添加了一个`show_error()`方法来显示错误。
- en: 'In our `MainWindow.__init__()` method, we''ll bring the model and view together:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`MainWindow.__init__()`方法中，我们将模型和视图结合在一起：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we create an instance of the `View` class and the `Model` class and connect
    their signals and slots.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建`View`类的一个实例和`Model`类，并连接它们的信号和插槽。
- en: 'At this point, the model-view version of our code works identically to our
    original version, but with more code involved. You might well ask, what''s the
    point? If this application was destined never to be more than it is, there might
    not be a point. However, applications tend to expand in functionality and, often,
    other applications need to reuse the same code. Consider these scenarios:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的代码的模型视图版本的工作方式与我们的原始版本完全相同，但涉及更多的代码。你可能会问，这有什么意义？如果这个应用程序注定永远不会超出它现在的状态，那可能没有意义。然而，应用程序往往会在功能上扩展，并且通常其他应用程序需要重用相同的代码。考虑以下情况：
- en: You want to provide an alternative editing form, perhaps console-based or with
    more editing features
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想提供另一种编辑形式，也许是基于控制台的，或者具有更多的编辑功能
- en: You want to provide the option of saving to a database instead of a text file
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你想提供将内容保存到数据库而不是文本文件的选项
- en: You're creating another application that also saves text content to files
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你正在创建另一个也将文本内容保存到文件的应用程序
- en: In each of these situations, using the model-view pattern means that we don't
    have to start from scratch. In the first case, for example, we don't need to rewrite
    any file-saving code; we just need to create the user-facing code that emits the
    same `submitted` signal. As your code expands and your applications become more
    complex, this separation of concerns will help you maintain order.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，使用模型视图模式意味着我们不必从头开始。例如，在第一种情况下，我们不需要重写任何保存文件的代码；我们只需要创建用户界面代码，发射相同的`submitted`信号。随着你的代码扩展和你的应用程序变得更加复杂，这种关注点的分离将帮助你保持秩序。
- en: Models and views in PyQt
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyQt中的模型和视图
- en: The model-view pattern is not only useful in the design of large applications,
    but also on a smaller scale with widgets that contain data. Copy the application
    template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml), *Building
    Applications with QMainWindow*, and let's look at a simple example of how model-view
    works on the widget level.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 模型视图模式不仅在设计大型应用程序时有用，而且在包含数据的小部件上也同样有用。从[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)中复制应用程序模板，*使用QMainWindow构建应用程序*，让我们看一个模型视图在小部件级别上是如何工作的简单示例。
- en: 'In the `MainWindow` class, create a list of items and add them to both the 
    `QListWidget` and `QComboBox` objects:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainWindow`类中，创建一个项目列表，并将它们添加到`QListWidget`和`QComboBox`对象中：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because both widgets were initialized with the same list, both contain the
    same items. Now, let''s make the list widget items editable:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这两个小部件都是用相同的列表初始化的，所以它们都包含相同的项目。现在，让我们使列表小部件的项目可编辑：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By iterating through the items in the list widget and setting the `Qt.ItemIsEditable`
    flag on each one, the widget becomes editable and we can alter the text of the
    items. Run the application and try editing the items in the list widget. Even
    though you've altered the items in the list widget, the combobox items remain
    unchanged. Each widget has its own internal list model, which stores a copy of
    the items that were originally passed in. Altering the items in one copy of the
    list has no effect on the other copy.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过迭代列表小部件中的项目，并在每个项目上设置`Qt.ItemIsEditable`标志，小部件变得可编辑，我们可以改变项目的文本。运行应用程序，尝试编辑列表小部件中的项目。即使你改变了列表小部件中的项目，组合框中的项目仍然保持不变。每个小部件都有自己的内部列表模型，它存储了最初传入的项目的副本。在一个列表的副本中改变项目对另一个副本没有影响。
- en: How might we keep these two lists in sync? We could connect some signals and
    slots or add class methods to do it, but Qt provides a better way.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何保持这两个列表同步？我们可以连接一些信号和插槽，或者添加类方法来做到这一点，但Qt提供了更好的方法。
- en: '`QListWidget` is actually a combination of two other Qt classes: `QListView`
    and `QStringListModel`. As the names imply, these are model-view classes. We can
    use those classes directly to build our own list widget with a discrete model
    and view:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`QListWidget`实际上是另外两个Qt类的组合：`QListView`和`QStringListModel`。正如名称所示，这些都是模型视图类。我们可以直接使用这些类来构建我们自己的带有离散模型和视图的列表小部件：'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We simply create our model class, initializing it with our list of strings,
    then create the view class. Finally, we connect the two using the view's `setModel()`
    method.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单地创建我们的模型类，用我们的字符串列表初始化它，然后创建视图类。最后，我们使用视图的`setModel()`方法连接两者。
- en: '`QComboBox` doesn''t have analogous model-view classes, but is nonetheless
    internally a model-view widget and has the capability to use an external model.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`QComboBox`没有类似的模型视图类，但它仍然在内部是一个模型视图小部件，并且具有使用外部模型的能力。'
- en: 'So, we can pass our `QStringListModel` to it using `setModel()`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用`setModel()`将我们的`QStringListModel`传递给它：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Add those widgets to your layout and try running the program again. This time,
    you'll see that edits to `QListView` are immediately available in the combobox,
    because the changes you are making are being written to the `QStringModel` object,
    which both widgets consult for item data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些小部件添加到布局中，然后再次运行程序。这一次，你会发现对`QListView`的编辑立即在组合框中可用，因为你所做的更改被写入了`QStringModel`对象，这两个小部件都会查询项目数据。
- en: '`QTableWidget` and `QTreeWidget` also have analogous view classes: `QTableView`
    and `QTreeView`. However, there are no ready-made model classes that we can use
    with these views. Instead, we have to create our own custom model classes by subclassing
    `QAbstractTableModel` and `QAbstractTreeModel`, respectively.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTableWidget`和`QTreeWidget`也有类似的视图类：`QTableView`和`QTreeView`。然而，没有现成的模型类可以与这些视图一起使用。相反，我们必须通过分别继承`QAbstractTableModel`和`QAbstractTreeModel`来创建自己的自定义模型类。'
- en: In the next section, we'll go through how to create and use a custom model class
    by building our own CSV editor.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过构建自己的CSV编辑器来介绍如何创建和使用自定义模型类。
- en: Building a CSV editor
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建CSV编辑器
- en: The **comma-separated values** (**CSV**) is a plain-text format for storing
    tabular data. Any spreadsheet program can export to CSV, or you can make your
    own by hand in a text editor. Our program will be designed in such a way that
    it will open any arbitrary CSV file and display the data in  `QTableView`. It
    is common to use the first row of a CSV to hold column headers, so our application
    will assume this and make that row immutable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号分隔值（CSV）是一种存储表格数据的纯文本格式。任何电子表格程序都可以导出为CSV，或者您可以在文本编辑器中手动创建。我们的程序将被设计成可以打开任意的CSV文件并在`QTableView`中显示数据。通常在CSV的第一行用于保存列标题，因此我们的应用程序将假定这一点并使该行不可变。
- en: Creating a table model
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表格模型
- en: When developing a data-driven model-view application, the model is usually the
    best place to begin as this is where the most complex code will be found. Once
    we've put this backend in place, implementing the frontend is fairly trivial.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发数据驱动的模型-视图应用程序时，模型通常是最好的起点，因为这里是最复杂的代码。一旦我们把这个后端放在适当的位置，实现前端就相当简单了。
- en: In this case, we need to design a model that can read and write CSV data. Copy
    the application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications* *with* *QMainWindow*, and add an import at the top for
    the Python `csv` library.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们需要设计一个可以读取和写入CSV数据的模型。从[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)的应用程序模板中复制应用程序模板，*使用*
    *QMainWindow*，并在顶部添加Python `csv`库的导入。
- en: 'Now, let''s start building our model by subclassing `QAbstractTableModel`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过继承`QAbstractTableModel`来开始构建我们的模型：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our model will take the name of a CSV file as an argument, and will immediately
    open the file and read it into memory (not a great strategy for large files, but
    this is only an example program). We'll assume the first row is a header row,
    and retrieve it using the `next()` function before pulling the rest of the rows
    into the model's `_data` property.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型将以CSV文件的名称作为参数，并立即打开文件并将其读入内存（对于大文件来说不是一个很好的策略，但这只是一个示例程序）。我们将假定第一行是标题行，并在将其余行放入模型的`_data`属性之前使用`next()`函数检索它。
- en: Implementing read capabilities
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现读取功能
- en: 'To create instances of our model to display data in a view, we need to implement
    three methods:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的模型的实例以在视图中显示数据，我们需要实现三种方法：
- en: '`rowCount()`, which must return the total number of rows in the table'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rowCount()`，必须返回表中的总行数'
- en: '`columnCount()`, which must return the total number of columns in the table'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`columnCount()`，必须返回表中的总列数'
- en: '`data()`, which is used to request data from the model'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data()`用于从模型请求数据'
- en: '`rowCount()` and `columnCount()` are easy enough in this case:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`rowCount()`和`columnCount()`都很容易：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The row count is just the length of the `_data` property, and the column count
    can be had by taking the length of the `_headers` property. Both functions are
    required to take a `parent` argument, but in this case, it is not used as it refers
    to the parent node, which is applicable only in hierarchical data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 行数只是`_data`属性的长度，列数可以通过获取`_headers`属性的长度来获得。这两个函数都需要一个`parent`参数，但在这种情况下，它没有被使用，因为它是指父节点，只有在分层数据中才适用。
- en: 'The last required method is `data()`, which requires more explanation; `data()`
    looks like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个必需的方法是`data()`，需要更多解释；`data()`看起来像这样：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The purpose of `data()` is to return the data in a single cell of the table
    given the arguments `index` and `role`. Now, `index` is an instance of the `QModelIndex`
    class, which describes the location of a single node in a list, table, or tree
    structure. Every `QModelIndex` contains the following properties:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`data()`的目的是根据`index`和`role`参数返回表格中单个单元格的数据。现在，`index`是`QModelIndex`类的一个实例，它描述了列表、表格或树结构中单个节点的位置。每个`QModelIndex`包含以下属性：'
- en: A `row` number
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`row`号'
- en: A `column` number
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`column`号'
- en: A `parent` model index
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`模型索引'
- en: In the case of a table model such as ours, we are interested in the `row` and
    `column` properties, which indicate the table row and column of the data cell
    we want. If we were dealing with hierarchical data, we'd also want the `parent`
    property, which would be the index of the parent node. If this were a list, we'd
    only care about `row`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这种表格模型的情况下，我们对`row`和`column`属性感兴趣，它们指示我们想要的数据单元的表行和列。如果我们处理分层数据，我们还需要`parent`属性，它将是父节点的索引。如果这是一个列表，我们只关心`row`。
- en: '`role` is a constant from the `QtCore.Qt.ItemDataRole` enum. When a view requests
    data from a model, it passes a `role` value so that the model can return the data
    or metadata appropriate to the context for which it is being requested. For example,
    if the view makes a request using the `EditRole` role, the model should return
    data suitable for editing. If the view requests with the `DecorationRole` role,
    the model should return an icon appropriate to the cell.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`role`是`QtCore.Qt.ItemDataRole`枚举中的一个常量。当视图从模型请求数据时，它传递一个`role`值，以便模型可以返回适合请求上下文的数据或元数据。例如，如果视图使用`EditRole`角色进行请求，模型应返回适合编辑的数据。如果视图使用`DecorationRole`角色进行请求，模型应返回适合单元格的图标。'
- en: If there is no data to be returned for a particular role, `data()` should return
    nothing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有特定角色的数据需要返回，`data()`应该返回空。
- en: In this case, we're only interested in displaying the data, which is represented
    by the `DisplayRole` role. To actually return the data, we need to get the index's
    row and column and use that to pull the appropriate row and column from our CSV
    data.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只对`DisplayRole`角色感兴趣。要实际返回数据，我们需要获取索引的行和列，然后使用它来从我们的CSV数据中提取适当的行和列。
- en: At this point, we have a minimally functional, read-only CSV model, but there
    is more we can add.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们有一个最小功能的只读CSV模型，但我们可以添加更多内容。
- en: Adding headers and sorting
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加标题和排序
- en: Being able to return the data is only one piece of a model's functionality.
    Models also need to be able to provide other information, such as the names of
    the column headers or the appropriate method for sorting the data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 能够返回数据只是模型功能的一部分。模型还需要能够提供其他信息，例如列标题的名称或排序数据的适当方法。
- en: 'To implement header data in our model, we need to create a `headerData()` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的模型中实现标题数据，我们需要创建一个`headerData()`方法：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`headerData()` returns data on a single header given three pieces of information—the
    **section**, **orientation**, and **role**.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`headerData()`根据三个信息——**section**、**orientation**和**role**返回单个标题的数据。'
- en: Headers can be either vertical or horizontal as determined by the orientation
    argument, which is specified as either the `QtCore.Qt.Horizontal` or `QtCore.Qt.Vertical`
    constant.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 标题可以是垂直的或水平的，由方向参数确定，该参数指定为`QtCore.Qt.Horizontal`或`QtCore.Qt.Vertical`常量。
- en: The section is an integer that indicates either the column number (for horizontal
    headers) or row number (for vertical headers).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 该部分是一个整数，指示列号（对于水平标题）或行号（对于垂直标题）。
- en: The role argument, as in the `data()` method, indicates the context for which
    the data needs to be returned.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如`data()`方法中的角色参数一样，指示需要返回数据的上下文。
- en: In our case, we're only interested in showing horizontal headers for the `DisplayRole`
    role. Unlike the `data()` method, the parent class method has some default logic
    and return values, so in any other case, we want to return the result of `super().headerData()`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们只对`DisplayRole`角色显示水平标题。与`data()`方法不同，父类方法具有一些默认逻辑和返回值，因此在任何其他情况下，我们希望返回`super().headerData()`的结果。
- en: 'If we want to be able to sort our data, we need to implement a `sort()` method,
    which will look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要对数据进行排序，我们需要实现一个`sort()`方法，它看起来像这样：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`sort()` takes a `column` number and `order`, which is either `QtCore.Qt.DescendingOrder`
    or `QtCore.Qt.AscendingOrder`, and the aim of this method is to sort the data
    accordingly. In this case, we''re using Python''s `list.sort()` method to sort
    our data in place, using the `column` argument to determine which column of each
    row will be returned for sorting. If descending order is requested, we''ll use
    `reverse()` to change the ordering accordingly.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()`接受一个`column`号和`order`，它可以是`QtCore.Qt.DescendingOrder`或`QtCore.Qt.AscendingOrder`，该方法的目的是相应地对数据进行排序。在这种情况下，我们使用Python的`list.sort()`方法来就地对数据进行排序，使用`column`参数来确定每行的哪一列将被返回进行排序。如果请求降序排序，我们将使用`reverse()`来相应地改变排序顺序。'
- en: '`sort()` must also emit two signals:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()`还必须发出两个信号：'
- en: '`layoutAboutToBeChanged` must be emitted before any sorting happens internally.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内部进行任何排序之前，必须发出`layoutAboutToBeChanged`信号。
- en: '`layoutChanged` must be emitted after the sorting is finished.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在排序完成后，必须发出`layoutChanged`信号。
- en: These two signals are used by the views to redraw themselves appropriately,
    so it is important to remember to emit them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个信号被视图用来适当地重绘自己，因此重要的是要记得发出它们。
- en: Implementing write capabilities
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现写入功能
- en: 'Our model is read-only at this point, but because we''re implementing a CSV
    editor, we need to implement writing data. To begin with, we need to override
    some methods to enable editing of existing data rows: `flags()` and `setData()`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模型目前是只读的，但因为我们正在实现CSV编辑器，我们需要实现写入数据。首先，我们需要重写一些方法以启用对现有数据行的编辑：`flags()`和`setData()`。
- en: '`flags()` takes a `QModelIndex` value and returns a set of `QtCore.Qt.ItemFlag`
    constants for the item at the given index. These flags are used to indicate whether
    the item can be selected, dragged, dropped, checked, or—most interesting to us—edited.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`flags()`接受一个`QModelIndex`值，并为给定索引处的项目返回一组`QtCore.Qt.ItemFlag`常量。这些标志用于指示项目是否可以被选择、拖放、检查，或者——对我们来说最有趣的是——编辑。'
- en: 'Our method looks like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法如下：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we're adding the `ItemIsEditable` flag to the list of flags returned by
    the parent class's `flags()` method, indicating that the item is editable. If
    we wanted to implement logic to make only certain cells editable under certain
    conditions, we could do that in this method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`ItemIsEditable`标志添加到父类`flags()`方法返回的标志列表中，指示该项目是可编辑的。如果我们想要实现逻辑，在某些条件下只使某些单元格可编辑，我们可以在这个方法中实现。
- en: 'For example, if we had a list of read-only indexes stored in `self.readonly_indexes`
    , we could write this method as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个存储在`self.readonly_indexes`中的只读索引列表，我们可以编写以下方法：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For our application, though, we want every cell to be editable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于我们的应用程序，我们希望每个单元格都是可编辑的。
- en: 'Now that all items in the model are marked as editable, we need to tell our
    model how to actually edit them. This is defined in the `setData()` method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模型中的所有项目都标记为可编辑，我们需要告诉我们的模型如何实际编辑它们。这在`setData()`方法中定义：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `setData()` method takes the index of the item to be set, the value to set
    it to, and an item role. This method must take on the task of setting the data
    and then return a Boolean value indicating whether or not the data were successfully
    changed. We only want to do this if the index is valid and the role is `EditRole`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`setData()`方法接受要设置的项目的索引、要设置的值和项目角色。此方法必须承担设置数据的任务，然后返回一个布尔值，指示数据是否成功更改。只有在索引有效且角色为`EditRole`时，我们才希望这样做。'
- en: 'If the data are changed, `setData()` must also emit the `dataChanged` signal.
    This signal is emitted whenever an item or group of items is updated with regard
    to any role, and so carries with it three pieces of information: the top-leftmost
    index that was changed, the bottom-rightmost index that was changed, and a list
    of the roles for each index. In our case, we''re only changing one cell so we
    can pass our index for both ends of the cell range, and a list with a single role
    in it.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据发生变化，`setData()`也必须发出`dataChanged`信号。每当项目或一组项目与任何角色相关的更新时，都会发出此信号，因此携带了三个信息：被更改的最左上角的索引，被更改的最右下角的索引，以及每个索引的角色列表。在我们的情况下，我们只改变一个单元格，所以我们可以传递我们的索引作为单元格范围的两端，以及一个包含单个角色的列表。
- en: 'There''s one more small change to the `data()` method that isn''t required
    but will make things easier for the user. Go back and edit the method as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`data()`方法还有一个小改变，虽然不是必需的，但会让用户更容易操作。回去编辑该方法如下：'
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When a table cell is selected for editing, `data()` will be called with the
    `EditRole` role. Before this change, `data()` would return `None` when called
    with that role and, as a result, the data in the cell will disappear as soon as
    the cell is selected. By returning the data for `EditRole` as well, the user will
    have access to the existing data for editing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择表格单元格进行编辑时，将使用`EditRole`角色调用`data()`。在这个改变之前，当使用该角色调用`data()`时，`data()`会返回`None`，结果，单元格中的数据将在选择单元格时消失。通过返回`EditRole`的数据，用户将可以访问现有数据进行编辑。
- en: 'We have now implemented the editing of existing cells, but to make our model
    completely editable we need to implement the insertion and removal of rows. We
    can do this by overriding two more methods: `insertRows()` and `removeRows()`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了对现有单元格的编辑，但为了使我们的模型完全可编辑，我们需要实现插入和删除行。我们可以通过重写另外两个方法来实现这一点：`insertRows()`和`removeRows()`。
- en: 'The `insertRows()` method looks like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertRows()`方法如下：'
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The method takes the *position* where the insertion starts, the number of *rows*
    to be inserted, and the parent node index (used with hierarchical data).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受插入开始的*位置*，要插入的*行数*以及父节点索引（与分层数据一起使用）。
- en: 'Inside the method, we must put our logic between calls to `beginInsertRows()`
    and `endInsertRows()`. The `beginInsertRows()` method prepares the underlying
    object for modification, and requires three arguments:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在该方法内部，我们必须在调用`beginInsertRows()`和`endInsertRows()`之间放置我们的逻辑。`beginInsertRows()`方法准备了底层对象进行修改，并需要三个参数：
- en: The `ModelIndex` object of the parent node, which is an empty `QModelIndex`
    for tabular data
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父节点的`ModelIndex`对象，对于表格数据来说是一个空的`QModelIndex`
- en: The position where row insertion will start
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行插入将开始的位置
- en: The position where row insertion will end
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行插入将结束的位置
- en: We can calculate all this from the start position and the number of rows passed
    into the method. Once we've taken care of that, we can generate a number of rows
    (in the form of lists of empty strings the same length as our header list) and
    insert them into `self._data` at the proper index.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据传入方法的起始位置和行数来计算所有这些。一旦我们处理了这个问题，我们就可以生成一些行（以空字符串列表的形式，长度与我们的标题列表相同），并将它们插入到`self._data`中的适当索引位置。
- en: After the rows are inserted, we call `endInsertRows()`, which takes no arguments.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入行后，我们调用`endInsertRows()`，它不带任何参数。
- en: 'The `removeRows()` method is very similar:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeRows()`方法非常相似：'
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once again, we need to call `beginRemoveRows()` before editing the data and
    `endRemoveRows()` after editing, just as we did for insertion. If we wanted to
    allow editing of the column structure, we could override the `insertColumns()`
    and `removeColumns()` methods, which work essentially the same way as the row
    methods. For now, we'll just stick to row editing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要在编辑数据之前调用`beginRemoveRows()`，在编辑后调用`endRemoveRows()`，就像我们对插入一样。如果我们想允许编辑列结构，我们可以重写`insertColumns()`和`removeColumns()`方法，它们的工作方式与行方法基本相同。现在，我们只会坚持行编辑。
- en: 'At this point, our model is fully editable, but we''ll add one more method
    that we can call to flush the data to disk, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的模型是完全可编辑的，但我们将添加一个方法，以便将数据刷新到磁盘，如下所示：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This method simply opens our file and writes in the headers and all data rows
    using the Python `csv` library.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法只是打开我们的文件，并使用Python的`csv`库写入标题和所有数据行。
- en: Using the model in a view
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在视图中使用模型
- en: Now that our model is ready to use, let's flesh out the rest of the application
    to demonstrate how to use it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的模型已经准备好使用了，让我们充实应用程序的其余部分，以演示如何使用它。
- en: 'To begin with, we need to create a `QTableView` widget and add it to our `MainWindow`
    :'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个`QTableView`小部件，并将其添加到我们的`MainWindow`中：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, we don't have to do much to make the `QTableView` widget work
    with the model. Because we implemented `sort()` in the model, we'll enable sorting,
    but otherwise, it doesn't require much configuration.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们不需要做太多工作来使`QTableView`小部件与模型一起工作。因为我们在模型中实现了`sort()`，我们将启用排序，但除此之外，它不需要太多配置。
- en: 'Of course, to see any data, we need to assign a model to the view; and in order
    to create a model, we need a file. Let''s create a callback to get one:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要查看任何数据，我们需要将模型分配给视图；为了创建一个模型，我们需要一个文件。让我们创建一个回调来获取一个：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our method uses a `QFileDialog` class to query the user for a CSV file to open.
    If one is chosen, it uses the CSV file to create an instance of our model class.
    The model class is then assigned to the view using the `setModel()` accessor method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法使用`QFileDialog`类来询问用户要打开的CSV文件。如果选择了一个文件，它将使用CSV文件来创建我们模型类的一个实例。然后使用`setModel()`访问方法将模型类分配给视图。
- en: 'Back in `MainWindow.__init__()`, let''s create a main menu for the application
    and add an `''Open''` action:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`MainWindow.__init__()`，让我们为应用程序创建一个主菜单，并添加一个“打开”操作：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you run the script now, you should be able to open a file by going to File | Open
    and selecting a valid CSV. You should be able to view and even edit the data,
    and the data should sort by column if you click a header cell.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行脚本，您应该能够通过转到“文件|打开”并选择有效的CSV文件来打开文件。您应该能够查看甚至编辑数据，并且如果单击标题单元格，数据应该按列排序。
- en: 'Next, let''s add the user interface components that will allow us to save our
    file. To begin, create a menu item that calls a `MainWindow` method called `save_file()`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加用户界面组件，以便保存我们的文件。首先，创建一个调用`MainWindow`方法`save_file()`的菜单项：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s create our `save_file()` method to actually save the file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的`save_file()`方法来实际保存文件：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To save the file, all we really need to do is call the model's `save_data()`
    method. However, we can't connect our menu item directly to that method, because
    the model doesn't exist until a file is actually loaded. This wrapper method allows
    us to create a menu option without a model.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存文件，我们实际上只需要调用模型的`save_data()`方法。但是，我们不能直接将菜单项连接到该方法，因为在实际加载文件之前模型不存在。这个包装方法允许我们创建一个没有模型的菜单选项。
- en: 'The last piece of functionality we want to connect is the ability to insert
    and remove rows. In a spreadsheet, it is often useful to be able to insert rows
    either above or below the selected row. So, let''s create callbacks in `MainWindow`
    that do just that:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要连接的最后一个功能是能够插入和删除行。在电子表格中，能够在所选行的上方或下方插入行通常是有用的。因此，让我们在`MainWindow`中创建回调来实现这一点：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In both methods, we're getting a list of the selected cells by calling the table
    view's `selectedIndexes()` method. These lists are sorted from upper-leftmost
    cells to lower-rightmost cells. So, for inserting above, we retrieve the row of
    the first index in the list (or 0 if the list is empty). For inserting below,
    we retrieve the row of the last index in the list (or the last index in the table
    if the list is empty). Finally, in both methods, we use the model's `insertRows()`
    method to insert one row to the appropriate location.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种方法中，我们通过调用表视图的`selectedIndexes()`方法来获取所选单元格的列表。这些列表从左上角的单元格到右下角的单元格排序。因此，对于插入上方，我们检索列表中第一个索引的行（如果列表为空，则为0）。对于插入下方，我们检索列表中最后一个索引的行（如果列表为空，则为表中的最后一个索引）。最后，在这两种方法中，我们使用模型的`insertRows()`方法将一行插入到适当的位置。
- en: 'Removing rows is similar, as shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 删除行类似，如下所示：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This time we only act if there is an active selection, and use the model's `removeRows()`
    method to remove the first selected row.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们只在有活动选择时才采取行动，并使用模型的`removeRows()`方法来删除第一个选定的行。
- en: 'To make these callbacks available to the user, let''s add an `''Edit''` menu
    back in `MainWindow` :'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些回调对用户可用，让我们在`MainWindow`中添加一个“编辑”菜单：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: At this point, try loading up a CSV file. You should be able to insert and remove
    rows in your table, edit fields, and save the result. Congratulations, you've
    created a CSV editor!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，请尝试加载CSV文件。您应该能够在表中插入和删除行，编辑字段并保存结果。恭喜，您已经创建了一个CSV编辑器！
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about model-view programming. You learned about
    using models with regular widgets and about the special model-view classes in
    Qt. You created a custom table model and rapidly built a CSV editor by exploiting
    the power of model-view classes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了模型视图编程。您学习了如何在常规小部件中使用模型，以及如何在Qt中使用特殊的模型视图类。您创建了一个自定义表模型，并通过利用模型视图类的功能快速构建了一个CSV编辑器。
- en: We will learn more advanced model-view concepts, including delegates and data
    mapping in [Chapter 9](af85c1e5-39e9-47fd-a999-16f2728fe464.xhtml), *Exploring
    SQL with QtSQL*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习更高级的模型视图概念，包括委托和数据映射在[第9章](af85c1e5-39e9-47fd-a999-16f2728fe464.xhtml)中，*使用QtSQL探索SQL*。
- en: In the next chapter, you'll learn about styling your PyQt applications. We'll
    dress up our drab forms with images, dynamic icons, fancy fonts, and colors, and
    we'll learn multiple approaches for controlling the overall look and feel of your
    Qt GUIs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何为您的PyQt应用程序设置样式。我们将使用图像、动态图标、花哨的字体和颜色来装扮我们的单调表单，并学习控制Qt GUI整体外观和感觉的多种方法。
- en: Questions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些问题来测试您从本章中学到的知识：
- en: Assuming we have a well-designed model-view application, is the following code
    part of a model or a view?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个设计良好的模型视图应用程序，以下代码是模型还是视图的一部分？
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Can you name at least two things that a model should never do and two things
    that a view should never do?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能否至少说出模型不应该做的两件事和视图不应该做的两件事？
- en: '`QAbstractTableModel` and `QAbstractTreeModel` both have *Abstract* in the
    name. What does *Abstract* mean in this context? Does it mean something different
    in C++ from what it means in Python?'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`QAbstractTableModel`和`QAbstractTreeModel`都在名称中有*Abstract*。在这种情况下，*Abstract*在这里是什么意思？在C++中，它的意思是否与Python中的意思不同？'
- en: 'Which model type—list, table, or tree—would best suit the following collections
    of data:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种模型类型——列表、表格或树——最适合以下数据集：
- en: The user's recent files
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户最近的文件
- en: A Windows registry hive
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows注册表
- en: Linux `syslog` records
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux `syslog`记录
- en: Blog entries
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 博客文章
- en: Personal salutations (for example, Mr., Mrs., or Dr.)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人称谓（例如，先生，夫人或博士）
- en: Distributed version control history
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式版本控制历史
- en: Why is the following code failing?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么以下代码失败了？
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Your table model isn't working quite right when inserting columns. What is wrong
    with your `insertColumns()` method?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当插入列时，您的表模型工作不正常。您的`insertColumns()`方法有什么问题？
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You would like your views to display the item data as a tooltip when hovered.
    How would you accomplish this?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当悬停时，您希望您的视图显示项目数据作为工具提示。您将如何实现这一点？
- en: Further reading
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You might want to check out the following resources:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望查看以下资源：
- en: The Qt documentation on model-view programming at [https://doc.qt.io/qt-5/model-view-programming.html](https://doc.qt.io/qt-5/model-view-programming.html)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关模型视图编程的Qt文档在[https://doc.qt.io/qt-5/model-view-programming.html](https://doc.qt.io/qt-5/model-view-programming.html)
- en: Martin Fowler presents an overview of **Model View Controller** (**MVC**) and
    related patterns at [https://martinfowler.com/eaaDev/uiArchs.html](https://martinfowler.com/eaaDev/uiArchs.html)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马丁·福勒在[https://martinfowler.com/eaaDev/uiArchs.html](https://martinfowler.com/eaaDev/uiArchs.html)上介绍了**模型-视图-控制器**（**MVC**）及相关模式的概述。
