- en: Hashing and Symbol Tables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希和符号表
- en: We have previously looked at **arrays** and **lists**, where items are stored
    in sequence and accessed by index number. Index numbers work well for computers.
    They are integers so they are fast and easy to manipulate. However, they don't
    always work so well for us. For example, if we have an address book entry, let's
    say at index number 56, that number doesn't tell us much. There is nothing to
    link a particular contact with number 56\. It is difficult to retrieve an entry
    from the list using the index value.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经看过**数组**和**列表**，其中项目按顺序存储并通过索引号访问。索引号对计算机来说很有效。它们是整数，因此快速且易于操作。但是，它们并不总是对我们很有效。例如，如果我们有一个地址簿条目，比如在索引号56处，那个数字并没有告诉我们太多。没有任何东西将特定联系人与数字56联系起来。使用索引值从列表中检索条目是困难的。
- en: 'In this chapter, we are going to look at a data structure that is better suited
    to this kind of problem: a dictionary. A dictionary uses a keyword instead of
    an index number, and it stores data in `(key, value)` pairs. So, if that contact
    was called *James*, we would probably use the keyword *James* to locate the contact.
    That is, instead of accessing the contact by calling *contacts [56]*, we would
    use *contacts* `james`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究一种更适合这种问题的数据结构：字典。字典使用关键字而不是索引号，并以`（键，值）`对的形式存储数据。因此，如果该联系人被称为*James*，我们可能会使用关键字*James*来定位联系人。也就是说，我们不会通过调用*contacts
    [56]*来访问联系人，而是使用*contacts* `james`。
- en: Dictionaries are a widely used data structure, often built using hash tables.
    As the name suggests, hash tables rely on a concept called **hashing**. A hash
    table data structure stores the data in `key/value` pairs, where keys are obtained
    by applying a hash function to it. It stores the data in a very efficient way
    so that retrieval can be very fast. We will discuss all the related issues in
    this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是一种广泛使用的数据结构，通常使用哈希表构建。顾名思义，哈希表依赖于一种称为**哈希**的概念。哈希表数据结构以`键/值`对的方式存储数据，其中键是通过应用哈希函数获得的。它以非常高效的方式存储数据，因此检索速度非常快。我们将在本章讨论所有相关问题。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章涵盖以下主题：
- en: Hashing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希
- en: Hash tables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表
- en: Different functions with elements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的元素功能
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: There is no additional technical requirement, except for the fact that Python
    needs to be installed on the system. Here is the GitHub link for the source code
    discussed in this chapter: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter07).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了需要在系统上安装Python之外，没有其他技术要求。这是本章讨论的源代码的GitHub链接：[https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter07)。
- en: Hashing
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希
- en: Hashing is a concept in which, when we give data of an arbitrary size to a function, we
    get a small simplified value. This function is called a **hash function**. Hashing
    uses a hash function that maps the given data to another range of data, so that
    a new range of data can be used as an index in the hash table. More specifically,
    we will use hashing to convert strings into integers. In our discussions in this
    chapter, we are using strings to convert into integers, however, it can be any
    other data type which can be converted into integers. Let's look at an example
    to better understand the concept. We want to hash the expression `hello world`,
    that is, we want to get a numeric value that we could say *represents* the string.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是一个概念，当我们将任意大小的数据提供给函数时，我们会得到一个简化的小值。这个函数称为**哈希函数**。哈希使用一个哈希函数将给定的数据映射到另一个数据范围，以便新的数据范围可以用作哈希表中的索引。更具体地说，我们将使用哈希将字符串转换为整数。在本章的讨论中，我们使用字符串转换为整数，但它可以是任何其他可以转换为整数的数据类型。让我们看一个例子来更好地理解这个概念。我们想要对表达式`hello
    world`进行哈希，也就是说，我们想要得到一个数值，我们可以说*代表*该字符串。
- en: 'We can obtain the unique ordinal value of any character by using the `ord()`
    function. For example, the `ord(''f'')` function gives 102\. Further, to get the
    hash of the whole string, we could just sum the ordinal numbers of each character
    in the string. See the following code snippet:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ord（）`函数获得任何字符的唯一序数值。例如，`ord（'f'）`函数给出102。此外，要获得整个字符串的哈希值，我们只需对字符串中每个字符的序数进行求和。请参阅以下代码片段：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The obtained numeric value, `1116`, for the whole `hello world` string is called
    the **hash of the string**. Consider the following diagram to see the ordinal
    value of each character in the string that results in the hash value `1116`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整个`hello world`字符串获得的数值`1116`称为**字符串的哈希**。请参考以下图表，以查看导致哈希值`1116`的字符串中每个字符的序数值：
- en: '![](Images/12710178-03f0-4efd-8f50-b84231ea4f63.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12710178-03f0-4efd-8f50-b84231ea4f63.png)'
- en: 'The preceding approach is used to obtain the hash value for a given string
    and seems to work fine. However, note that we could change the order of the characters
    in the string and we would have got the same hash; see the following code snippet
    where we get the same hash value for the `world hello` string:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法用于获得给定字符串的哈希值，并且似乎运行良好。但是，请注意，我们可以更改字符串中字符的顺序，我们仍然会得到相同的哈希值；请参阅以下代码片段，我们对`world
    hello`字符串获得相同的哈希值：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Again, there would be the same hash value for the `gello xorld` string, as
    the sum of the ordinal values of the characters for this string would be the same
    since `g` has an ordinal value that is one less than that of `h`, and `x` has
    an ordinal value that is one greater than that of `w`. See the following code
    snippet:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于`gello xorld`字符串，哈希值将是相同的，因为该字符串的字符的序数值之和将是相同的，因为`g`的序数值比`h`小1，`x`的序数值比`w`大1。请参阅以下代码片段：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Look at the following diagram, where we can observe that the hash value for
    this string is again, `1116`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的图表，我们可以观察到该字符串的哈希值再次为`1116`：
- en: '![](Images/623ed462-1cfe-4b45-b619-692367501b52.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/623ed462-1cfe-4b45-b619-692367501b52.png)'
- en: Perfect hashing functions
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完美哈希函数
- en: A **perfect hashing function** is the one by which we get a unique hash value
    for a given string (it can be any data type, here it is a string as we are limiting
    the discussion to strings for now). In practice, most of the hashing functions
    are imperfect and face collisions. This means that a hash function gives the same
    hash value to more than one string; that is undesirable because a perfect hash
    function should return a unique hash value to a string. Normally, hashing functions
    need to be very fast, so trying to create a function that gives us a unique hash
    value for each string is normally not possible. Hence, we accept this fact and
    we know that we may get some collisions, that is, two or more strings may have
    the same hash value. Therefore, we try to find a strategy to resolve the collisions
    rather than trying to find a perfect hash function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**完美哈希函数**是指我们为给定字符串（它可以是任何数据类型，这里我们现在限制讨论为字符串）得到唯一的哈希值。实际上，大多数哈希函数都是不完美的，并且会发生冲突。这意味着哈希函数给一个以上的字符串返回相同的哈希值；这是不希望的，因为完美哈希函数应该为一个字符串返回唯一的哈希值。通常，哈希函数需要非常快速，因此通常不可能创建一个为每个字符串返回唯一哈希值的函数。因此，我们接受这一事实，并且知道我们可能会遇到一些冲突，也就是说，两个或更多个字符串可能具有相同的哈希值。因此，我们尝试找到一种解决冲突的策略，而不是试图找到一个完美的哈希函数。'
- en: 'To avoid the collisions of the previous example, we could, for example, add
    a multiplier, so that the ordinal value of each character is multiplied by a value
    that continuously increases as we progress in the string. Next, the hash value
    of the string is obtained by adding the multiplied ordinal value of each character.
    To better understand the concept, refer to the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免前面示例中的冲突，我们可以例如添加一个乘数，使得每个字符的序数值乘以一个随着字符串进展而不断增加的值。接下来，通过添加每个字符的乘以序数值来获得字符串的哈希值。为了更好地理解这个概念，请参考以下图表：
- en: '![](Images/a488b9e9-4cb8-4039-8c67-4954d1527d26.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a488b9e9-4cb8-4039-8c67-4954d1527d26.png)'
- en: In the preceding diagram, the ordinal value of each character is progressively
    multiplied by a number. Note that the last row is the result of multiplying the
    values; row two has the ordinal values of each character; row three shows the
    multiplier value; and, in row four, we get values by multiplying the values of
    row two and three so that `104 x 1` equals `104`. Finally, we add all of these
    multiplied values to get the hash value of the `hello world` string, that is, `6736`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，每个字符的序数值逐渐乘以一个数字。请注意，最后一行是值的乘积结果；第二行是每个字符的序数值；第三行显示乘数值；第四行通过将第二行和第三行的值相乘得到值，因此
    `104 x 1` 等于 `104`。最后，我们将所有这些乘积值相加，得到 `hello world` 字符串的哈希值，即 `6736`。
- en: 'The implementation of this concept is shown in the following function:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念的实现如下函数所示：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can test this function on the strings that we used earlier, shown as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在下面显示的字符串上测试这个函数：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running this program, we get the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序，我们得到以下输出：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can see that, this time, we get different hash values for these three strings.
    Still, this is not a perfect hash. Let''s try the strings, `ad` and `ga`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这一次对这三个字符串得到了不同的哈希值。但是，这并不是一个完美的哈希。让我们尝试字符串 `ad` 和 `ga`：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We still get the same hash value for two different strings. Therefore, we need
    to devise a strategy for resolving such collisions. We shall look at that shortly,
    but first, we will study an implementation of a hash table.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然得到两个不同字符串相同的哈希值。因此，我们需要制定一种解决这种冲突的策略。我们很快将看到这一点，但首先，我们将学习哈希表的实现。
- en: Hash tables
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希表
- en: A** hash table** is a data structure where elements are accessed by a keyword
    rather than an index number, unlike in **lists** and **arrays**. In this data
    structure, the data items are stored in key/value pairs similar to dictionaries.
    A hash table uses a hashing function in order to find an index position where
    an element should be stored and retrieved. This gives us fast lookups since we
    are using an index number that corresponds to the hash value of the key.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希表**是一种数据结构，其中元素是通过关键字而不是索引号访问的，不同于**列表**和**数组**。在这种数据结构中，数据项以类似于字典的键/值对的形式存储。哈希表使用哈希函数来找到应该存储和检索元素的索引位置。这使我们能够快速查找，因为我们使用与键的哈希值对应的索引号。'
- en: 'Each position in the hash table data structure is often called a **slot** or
    **bucket** andcan store an element. So, each data item in the form of `(key, value)` pairs
    would be stored in the hash table at a position that is decided by the hash value
    of the data. For example, the hashing function maps the input string names to
    a hash value; the `hello world` string is mapped to a hash value of 92, which
    finds a slot position in the hash table. Consider the following diagram:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表数据结构中的每个位置通常称为**槽**或**桶**，可以存储一个元素。因此，形式为 `(key, value)` 的每个数据项将存储在哈希表中由数据的哈希值决定的位置上。例如，哈希函数将输入字符串名称映射到哈希值；`hello
    world` 字符串被映射到哈希值 92，找到哈希表中的一个槽位置。考虑以下图表：
- en: '![](Images/b737f679-af81-47f6-ada2-c7beb23d6de8.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b737f679-af81-47f6-ada2-c7beb23d6de8.png)'
- en: 'To implement the hash table, we start by creating a class to hold hash table
    items. These need to have a key and a value since our hash table is a `{key-value}`
    store:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现哈希表，我们首先创建一个类来保存哈希表项。这些项需要有一个键和一个值，因为我们的哈希表是一个 `{key-value}` 存储：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This gives us a very simple way to store items. Next, we start working on the
    hash table class itself. As usual, we start off with a constructor:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一种非常简单的存储项的方法。接下来，我们开始研究哈希表类本身。像往常一样，我们从构造函数开始：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The hash table uses a standard Python list to store its elements. Let''s set
    the size of the hash table to 256 elements to start with. Later, we will look
    at strategies for how to grow the hash table as we begin filling it up. We will
    now initialize a list containing 256 elements in the code. These are the positions
    where the elements are to be stored—the slots or buckets. So, we have 256 slots
    to store elements in the hash table. Finally, we add a counter for the number
    of actual hash table elements we have:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表使用标准的Python列表来存储其元素。让我们将哈希表的大小设置为256个元素。稍后，我们将研究如何在开始填充哈希表时扩展哈希表的策略。我们现在将在代码中初始化一个包含256个元素的列表。这些是要存储元素的位置——插槽或桶。因此，我们有256个插槽来存储哈希表中的元素。最后，我们添加一个计数器，用于记录实际哈希表元素的数量：
- en: '![](Images/c5ea5ffe-6a97-4132-837e-830e98b472c1.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c5ea5ffe-6a97-4132-837e-830e98b472c1.png)'
- en: It is important to note the difference between the size and count of a table. The
    size of a table refers to the total number of slots in the table (used or unused).
    The count of the table refers to the number of slots that are filled, meaning
    the number of actual `(key-value)` pairs that have been added to the table.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意表的大小和计数之间的区别。表的大小是指表中插槽的总数（已使用或未使用）。表的计数是指填充的插槽的数量，也就是已添加到表中的实际（键-值）对的数量。
- en: Now, we have to decide on adding our hashing function to the table. We can use
    the same hash function that returns the sum of ordinal values for each character
    in the strings with a slight change. Since our hash table has 256 slots, that
    means we need a hashing function that returns a value in the range of 1 to 256
    (the size of the table). A good way of doing it is to return the remainder of
    dividing the hash value by the size of the table since the remainder would surely
    be an integer value between 0 and 255.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要决定将我们的哈希函数添加到表中。我们可以使用相同的哈希函数，它返回字符串中每个字符的序数值的总和，稍作修改。由于我们的哈希表有256个插槽，这意味着我们需要一个返回1到256范围内的值的哈希函数（表的大小）。一个很好的方法是返回哈希值除以表的大小的余数，因为余数肯定是0到255之间的整数值。
- en: 'As the hashing function is only meant to be used internally by the class, we
    put an underscore (`_`) at the beginning of the name to indicate this. This is
    a normal Python convention for indicating that something is meant for internal
    use. Here is the implementation of the `hash` function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数只是用于类内部的，所以我们在名称前面加下划线（`_`）来表示这一点。这是Python中用来表示某些东西是内部使用的正常约定。这是`hash`函数的实现：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For the time being, we are going to assume that keys are strings. We shall discuss
    how one can use non-string keys later. For now, the `_hash()` function is going
    to generate the hash value for a string.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们假设键是字符串。我们将讨论如何稍后使用非字符串键。现在，`_hash()`函数将为字符串生成哈希值。
- en: Storing elements in a hash table
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在哈希表中存储元素
- en: To store the elements in the hash table, we add them to the table with the `put()`
    function and retrieve them with the `get()` function. First, we will look at the
    implementation of the `put()` function. We start by embedding the key and the
    value into the `HashItem` class and then compute the hash value of the key.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要将元素存储在哈希表中，我们使用`put()`函数将它们添加到表中，并使用`get()`函数检索它们。首先，我们将看一下`put()`函数的实现。我们首先将键和值嵌入`HashItem`类中，然后计算键的哈希值。
- en: 'Here is the implementation of the `put` function to store the elements in the
    hash table:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`put`函数的实现，用于将元素存储在哈希表中：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once we know the hash value of the key, it will be used to find the position
    where the element should be stored in the hash table. Hence, we need to find an
    empty slot. We start at the slot that corresponds to the hash value of the key.
    If that slot is empty, we insert our item there.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道键的哈希值，它将被用来找到元素应该存储在哈希表中的位置。因此，我们需要找到一个空插槽。我们从与键的哈希值对应的插槽开始。如果该插槽为空，我们就在那里插入我们的项。
- en: However, if the slot is not empty and the key of the item is not the same as
    our current key, then we have a collision. It means that we have a hash value
    for the item that is the same as some previously stored item in the table. This
    is where we need to figure out a way to handle a conflict.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果插槽不为空，并且项的键与当前键不同，那么我们就会发生冲突。这意味着我们有一个项的哈希值与表中先前存储的某个项相同。这就是我们需要想出一种处理冲突的方法的地方。
- en: 'For example, in the following diagram, the **hello world** key string is already
    stored in the table, and there is a collision when a new string, `world hello`, gets
    the same hash value of `92`. Take a look at the following diagram:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的图表中，**hello world**键字符串已经存储在表中，当一个新的字符串`world hello`得到相同的哈希值`92`时，就会发生冲突。看一下下面的图表：
- en: '![](Images/6fc3a488-d225-45a8-aaec-63afa11aa0df.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6fc3a488-d225-45a8-aaec-63afa11aa0df.png)'
- en: One way of resolving this kind of collision is to find another free slot from
    the position of the collision; this collision resolution process is called **open
    addressing**. We can do this by linearly looking for the next available slot by
    adding `1` to the previous hash value where we get the collision. We can resolve
    this conflict by adding `1` to the sum of the ordinal values of each character
    in the key string, which is further divided by the size of the hash table to obtain
    the hash value. This systematic way of visiting each slot is a linear way of resolving
    collisions and is called **linear probing**.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这种冲突的一种方法是从冲突的位置找到另一个空插槽；这种冲突解决过程称为**开放寻址**。我们可以通过线性地查找下一个可用插槽来解决这个问题，方法是在发生冲突的前一个哈希值上加`1`。我们可以通过将键字符串中每个字符的序数值的总和加`1`来解决这个冲突，然后再除以哈希表的大小来获得哈希值。这种系统化的访问每个插槽的方式是解决冲突的线性方式，称为**线性探测**。
- en: 'Let''s consider an example as shown in the following diagram to better understand
    how we resolve this collision. The hash value for the `eggs` key string is `51`.
    Now, there is a collision because we have already used this location to store
    data. Therefore, we add `1` in the hash value that is computed by the sum of the
    ordinal values of each character of the string to resolve the collision. Hence,
    we obtain a new hash value for this key string to store the data—location `52`.
    See the following diagram and code snippet for this implementation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，如下图所示，以更好地理解我们如何解决这个冲突。密钥字符串“eggs”的哈希值是51。现在，由于我们已经使用了这个位置来存储数据，所以发生了冲突。因此，我们在哈希值中添加1，这是由字符串的每个字符的序数值的总和计算出来的，以解决冲突。因此，我们获得了这个密钥字符串的新哈希值来存储数据——位置52。请参见以下图表和代码片段以进行此实现：
- en: '![](Images/343bdb1c-ac38-4fc1-a624-10dfbab473ec.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/343bdb1c-ac38-4fc1-a624-10dfbab473ec.png)'
- en: 'Now, consider the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下代码：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code is to check whether the slot is empty, then get the new
    hash value using the method described. If the slot is empty, to store the new
    element (that means the slot contained `None` previously), then we increase the
    count by one. Finally, we insert the item into the list at the required position:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是用来检查槽是否为空，然后使用描述的方法获取新的哈希值。如果槽为空（这意味着槽以前包含`None`），则我们将计数增加一。最后，我们将项目插入到所需位置的列表中：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Retrieving elements from the hash table
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从哈希表中检索元素
- en: To retrieve the elements from the hash table, the value stored corresponding
    to the key would be returned. Here, we will discuss the implementation of the
    retrieval method—the `get()` method. This method would return the value stored
    in the table corresponding to the given key.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要从哈希表中检索元素，将返回与密钥对应的存储值。在这里，我们将讨论检索方法的实现——`get()`方法。此方法将返回与给定密钥对应的表中存储的值。
- en: First of all, we compute the hash of the given key corresponding to the value
    that is to be retrieved.  Once we have the hash value of the key, we look up the
    hash table at the position of the hash value. If the key item is matched with
    the stored key value at that location, the corresponding `value` is retrieved.
    If that does not match, then we add `1` to the sum of the ordinal values of all
    the characters in the string, similar to what we did at the time of storing the
    data, and we look at the newly obtained hash value. We keep looking until we get
    our key element or we check all the slots in the hash table.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算要检索的密钥的哈希值对应的值。一旦我们有了密钥的哈希值，我们就在哈希表的哈希值位置查找。如果密钥项与该位置处存储的密钥值匹配，则检索相应的`value`。如果不匹配，那么我们将1添加到字符串中所有字符的序数值的总和，类似于我们在存储数据时所做的操作，然后查看新获得的哈希值。我们继续查找，直到找到我们的密钥元素或者检查了哈希表中的所有槽。
- en: 'Consider an example to understand the concept in the following diagram in four
    steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子来理解以下图表中的概念，分为四步：
- en: We compute the hash value for the given key string, `"egg"`, which turns out
    to be `51`. Then, we compare this key with the stored key value at location `51`,
    but it does not match.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们计算给定密钥字符串“egg”的哈希值，结果为51。然后，我们将此密钥与位置51处存储的密钥值进行比较，但不匹配。
- en: As the key does not match, we compute a new hash value.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于密钥不匹配，我们计算一个新的哈希值。
- en: We look up the key at the location of the newly created hash value, which is
    `52`; we compare the key string with the stored key value and, here, it matches,
    as shown in the following diagram.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们查找新创建的哈希值位置52处的密钥；我们将密钥字符串与存储的密钥值进行比较，这里匹配，如下图所示。
- en: 'The stored value is returned corresponding to this key value in the hash table.
    See the following diagram:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在哈希表中返回与此密钥值对应的存储值。请参见以下图表：
- en: '![](Images/a5db02a4-57a6-4528-ab70-45ebc3299844.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a5db02a4-57a6-4528-ab70-45ebc3299844.png)'
- en: 'To implement this retrieval method that is, the `get()` method, we start by
    calculating the hash of the key. Next, we look up at the computed hash value in
    the table. If there is a match, we return the corresponding stored value. Otherwise,
    we keep looking at the new hash value location computed as described. Here is
    the implementation of the `get()` method:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个检索方法，即`get()`方法，我们首先计算密钥的哈希值。接下来，我们在表中查找计算出的哈希值。如果匹配，则返回相应的存储值。否则，我们继续查看描述的计算出的新哈希值位置。以下是`get()`方法的实现：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, we return `None` if the key was not found in the table. Another good
    alternative may be to raise an exception in case the key does not exist in the
    table.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果在表中找不到密钥，则返回“None”。另一个很好的选择可能是在表中不存在密钥的情况下引发异常。
- en: Testing the hash table
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试哈希表
- en: 'To test our hash table, we create `HashTable` and store a few elements in it,
    then try to retrieve them. We will also try to `get()` a key that does not exist.
    We also use the two strings, `ad` and `ga`, which had the collision and returned
    the same hash value by our hashing function. To properly evaluate the work of
    the hash table, we throw this collision as well, just to see that the collision
    is properly resolved. See the example code, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的哈希表，我们创建`HashTable`并将一些元素存储在其中，然后尝试检索它们。我们还将尝试`get()`一个不存在的密钥。我们还使用了两个字符串“ad”和“ga”，它们发生了冲突，并且由我们的哈希函数返回了相同的哈希值。为了正确评估哈希表的工作，我们也会处理这个冲突，只是为了看到冲突是如何正确解决的。请参见以下示例代码：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running the preceding code returns the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码返回以下结果：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, looking up the `worst` key returns `None`, since the key does
    not exist. The `ad` and `ga` keys also return their corresponding values, showing
    that the collision between them is properly handled.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，查找“worst”密钥返回“None”，因为密钥不存在。`ad`和`ga`密钥也返回它们对应的值，显示它们之间的冲突得到了正确处理。
- en: Using [] with the hash table
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用[]与哈希表
- en: Using the `put()` and `get()` methods doesn't look very convenient to use. However,
    we would have preferred to be able to treat our hash table as a list, as it would
    be easier to use. For example, we would like to be able to use `ht["good"]` instead
    of `ht.get("good")` for the retrieval of elements from the table.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`put()`和`get()`方法看起来并不方便。然而，我们更希望能够将我们的哈希表视为列表，因为这样会更容易使用。例如，我们希望能够使用`ht["good"]`而不是`ht.get("good")`来从表中检索元素。
- en: 'This can be easily done with the special methods, `__setitem__()` and `__getitem__()`.
    See the following code for this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以很容易地通过特殊方法`__setitem__()`和`__getitem__()`来完成。请参阅以下代码：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, our test code would be like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的测试代码将会是这样的：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that we also print the number of elements already stored in the hash
    table using the `count` variable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还打印了已存储在哈希表中的元素数量，使用`count`变量。
- en: Non-string keys
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非字符串键
- en: In most cases in real-time applications, generally, we need to use strings for
    the keys. However, if necessary, you could use any other Python types. If you
    create your own class that you want to use as a key, you will need to override
    the special `__hash__()` function for that class, so that you get reliable hash
    values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时应用中，通常我们需要使用字符串作为键。然而，如果有必要，您可以使用任何其他Python类型。如果您创建自己的类并希望将其用作键，您需要重写该类的特殊`__hash__()`函数，以便获得可靠的哈希值。
- en: Note that you would still have to calculate the modulo (`%`) of the hash value
    and the size of the hash table to get the slot. That calculation should happen
    in the hash table and not in the key class since the table knows its own size
    (the key class should not know anything about the table that it belongs to).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您仍然需要计算哈希值的模运算(`%`)和哈希表的大小以获取插槽。这个计算应该在哈希表中进行，而不是在键类中，因为表知道自己的大小（键类不应该知道它所属的表的任何信息）。
- en: Growing a hash table
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩大哈希表
- en: In our example, we fixed the hash table size to 256\. It is obvious that, when
    we add the elements to the hash table, we would begin to fill up the empty slots,
    and at some point, all of the slots would be filled up and the hash table will
    be full. To avoid such a situation, we can grow the size of the table when it
    is starting to get full.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将哈希表的大小固定为256。很明显，当我们向哈希表添加元素时，我们将开始填满空插槽，而在某个时刻，所有插槽都将被填满，哈希表将变满。为了避免这种情况，我们可以在表开始变满时扩大表的大小。
- en: 'To grow the size of the hash table, we compare the size and the count in the
    table. `size` is the total number of the slots and `count` denotes the number
    of slots that contains elements. So, if `count` is equal to `size`, that means
    we have filled up the table. The load factor of the hash table is generally used
    to expand the size of the table; that gives us an indication of how many available
    slots of the table have been used. The load factor of the hash table is computed
    by dividing the number of **used** slots by the **total** number of slots in the
    table. It is defined as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩大哈希表的大小，我们比较表中的大小和计数。`size`是插槽的总数，`count`表示包含元素的插槽的数量。因此，如果`count`等于`size`，这意味着我们已经填满了表。哈希表的负载因子通常用于扩展表的大小；这给了我们一个关于表中有多少可用插槽被使用的指示。哈希表的负载因子通过将表中**已使用**的插槽数量除以表中的**总**插槽数量来计算。它的定义如下：
- en: '![](Images/ee3e4e63-871f-4f89-9bfe-83df85d4fe6a.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ee3e4e63-871f-4f89-9bfe-83df85d4fe6a.png)'
- en: As the load factor value approaches 1, it means that the table is going to be
    filled, and we need to grow the size of the table. It is better to grow the size
    of the table before it gets almost full, as the retrieval of elements from the
    table becomes slow when the table fills up. A value of 0.75 for the load factor
    may be a good value to grow the size of the table.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当负载因子接近1时，这意味着表即将被填满，我们需要扩大表的大小。最好在表几乎填满之前扩大表的大小，因为当表填满时，从表中检索元素会变慢。负载因子为0.75可能是一个不错的值，用来扩大表的大小。
- en: The next question is how much we should increase the size of the table. One
    strategy would be to simply double the size of the table.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是我们应该将表的大小增加多少。一种策略是简单地将表的大小加倍。
- en: Open addressing
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放寻址
- en: The collision resolution mechanism we used in our example was linear probing,
    which is an example of an open addressing strategy. Linear probing is simple since
    we use a fixed number of slots. There are other open addressing strategies as
    well, however, they all share the idea that there is an array of slots. When we
    want to insert a key, we check whether the slot already has an item or not. If
    it does, we look for the next available slot.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例中使用的冲突解决机制是线性探测，这是一种开放寻址策略的例子。线性探测很简单，因为我们使用了固定数量的插槽。还有其他开放寻址策略，它们都共享一个思想，即存在一个插槽数组。当我们想要插入一个键时，我们会检查插槽是否已经有项目。如果有，我们会寻找下一个可用的插槽。
- en: If we have a hash table that contains 256 slots, then 256 is the maximum number
    of elements in that hash. Moreover, as the load factor increases, it will take
    longer to find the insertion point for the new element.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个包含256个插槽的哈希表，那么256就是哈希表中元素的最大数量。此外，随着负载因子的增加，查找新元素的插入点将需要更长的时间。
- en: Because of these limitations, we may prefer to use a different strategy to resolve
    collisions, such as chaining.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些限制，我们可能更喜欢使用不同的策略来解决冲突，比如链接法。
- en: Chaining
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接法
- en: 'Chaining is another method to handle the problem of collision in hash tables.
    It solves this problem by allowing each slot in the hash table to store a reference
    to many items at the position of a collision. So, at the index of a collision,
    we are allowed to store many items in the hash table. Observe the following diagram—there
    is a collision for the strings, **hello world** and **world hello**. In the case
    of chaining, both items are allowed to store at the location of the **92** hash
    value using a **list**. Here is the example diagram to show collision resolution
    using chaining:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 链接是处理哈希表中冲突问题的另一种方法。它通过允许哈希表中的每个插槽存储在冲突位置的多个项目的引用来解决这个问题。因此，在冲突的索引处，我们可以在哈希表中存储多个项目。观察以下图表——字符串**hello
    world**和**world hello**发生冲突。在链接的情况下，这两个项目都被允许存储在哈希值为**92**的位置上，使用一个**列表**。以下是用于显示使用链接解决冲突的示例图表：
- en: '![](Images/46886635-c11e-45e1-bc94-291c680dc461.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/46886635-c11e-45e1-bc94-291c680dc461.png)'
- en: 'In chaining, the slots in the hash table are initialized with empty lists:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接中，哈希表中的插槽被初始化为空列表：
- en: '![](Images/3518632e-5693-470a-87b0-0e6428fe8e49.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3518632e-5693-470a-87b0-0e6428fe8e49.png)'
- en: 'When an element is inserted, it will be appended to the list that corresponds
    to that element''s hash value. That is, if you have two elements that both have
    a hash value of `1075`, both of these elements would be added to the list that
    exists in the `1075%256=51` slot of the hash table:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当插入一个元素时，它将被追加到与该元素的哈希值对应的列表中。也就是说，如果您有两个具有哈希值`1075`的元素，这两个元素都将被添加到哈希表的`1075%256=51`插槽中存在的列表中：
- en: '![](Images/d4084896-ca8c-4213-8e75-455df499452e.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d4084896-ca8c-4213-8e75-455df499452e.png)'
- en: The preceding diagram shows a list of entries with hash value `51`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了具有哈希值`51`的条目列表。
- en: Chaining then avoids conflict by allowing multiple elements to have the same
    hash value. Hence, there is no limit on the number of elements that can be stored
    in a hash table, whereas, in the case of linear probing, we had to fix the size
    of the table, which we need to later grow when the table is filled up, depending
    upon the load factor. Moreover, the hash table can hold more values than the number
    of available slots, since each slot holds a list that can grow.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过链接避免冲突，允许多个元素具有相同的哈希值。因此，哈希表中可以存储的元素数量没有限制，而在线性探测的情况下，我们必须固定表的大小，当表填满时需要后续增长，这取决于负载因子。此外，哈希表可以容纳比可用插槽数量更多的值，因为每个插槽都包含一个可以增长的列表。
- en: 'However, there is a problem in chaining—it becomes inefficient when a list
    grows at a particular hash value location. As a particular slot has many items,
    searching them can get very slow since we have to do a linear search through the
    list until we find the element that has the key we want. This can slow down retrieval,
    which is not good, since hash tables are meant to be efficient. The following
    diagram demonstrates a linear search through list items until we find a match:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在链接中存在一个问题——当列表在特定的哈希值位置增长时，它变得低效。由于特定插槽有许多项目，搜索它们可能会变得非常缓慢，因为我们必须通过列表进行线性搜索，直到找到具有我们想要的键的元素。这可能会减慢检索速度，这是不好的，因为哈希表的目的是高效的。以下图表演示了通过列表项进行线性搜索，直到找到匹配项：
- en: '![](Images/c8def2e4-1a3e-4b25-ba26-fbad0abbafbb.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c8def2e4-1a3e-4b25-ba26-fbad0abbafbb.png)'
- en: So, there is a problem of slow retrieval of items when a particular position
    in a hash table has many entries. This problem can be resolved using another data
    structure in place of using a list that can perform fast searching and retrieval.
    There is a nice choice of using **binary search trees** (**BSTs**), which provide
    fast retrieval, as we discussed in the previous chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当哈希表中的特定位置具有许多条目时，检索项目的速度会变慢。可以通过在使用列表的位置上使用另一个数据结构来解决这个问题，该数据结构可以执行快速搜索和检索。使用**二叉搜索树**（**BSTs**）是一个不错的选择，因为它提供了快速检索，正如我们在前一章中讨论的那样。
- en: 'We could simply put an (initially empty) BST in each slot as shown in the following
    diagram:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地在每个插槽中放置一个（最初为空的）BST，如下图所示：
- en: '![](Images/f33540e3-5074-4d55-9b5b-2ce497987b10.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f33540e3-5074-4d55-9b5b-2ce497987b10.png)'
- en: In the preceding diagram, the `51` slot holds a BST, which we use to store and
    retrieve the data items. But we would still have a potential problem—depending
    on the order in which the items were added to the BST, we could end up with a
    search tree that is as inefficient as a list. That is, each node in the tree has
    exactly one child. To avoid this, we would need to ensure that our BST is self-balancing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，`51`插槽包含一个BST，我们使用它来存储和检索数据项。但我们仍然可能会遇到一个潜在的问题——根据将项目添加到BST的顺序，我们可能会得到一个与列表一样低效的搜索树。也就是说，树中的每个节点都只有一个子节点。为了避免这种情况，我们需要确保我们的BST是自平衡的。
- en: Symbol tables
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符号表
- en: Symbol tables are used by compilers and interpreters to keep track of the symbols
    that have been declared and to keep information about them. Symbol tables are
    often built using hash tables since it is important to efficiently retrieve a
    symbol from the table.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 符号表由编译器和解释器使用，用于跟踪已声明的符号并保留有关它们的信息。符号表通常使用哈希表构建，因为从表中高效地检索符号很重要。
- en: 'Let''s look at an example. Suppose we have the following Python code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。假设我们有以下Python代码：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we have two symbols, `name` and `age`. They belong to a namespace, which
    could be `__main__`, but it could also be the name of a module if you placed it
    there. Each symbol has a `value`; for example, the `name` symbol has the value, `Joe`, and
    the `age` symbol has the value, `27`. A symbol table allows the compiler or the
    interpreter to look up these values. So, the `name` and `age` symbols become keys
    in the hash table. All of the other information associated with them become the
    `value` of the symbol table entry.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个符号，`name`和`age`。它们属于一个命名空间，可以是`__main__`，但如果您将其放在那里，它也可以是模块的名称。每个符号都有一个`value`；例如，`name`符号的值是`Joe`，`age`符号的值是`27`。符号表允许编译器或解释器查找这些值。因此，`name`和`age`符号成为哈希表中的键。与它们关联的所有其他信息成为符号表条目的`value`。
- en: 'It''s not only variables that are symbols, but functions and classes are also
    treated as symbols, and they will also be added to the symbol table so that, when
    any one of them needs to be accessed, they are accessible from the symbol table.
    For example, the `greet()` function and two variables are stored in the symbol
    table in the following diagram:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅变量是符号，函数和类也被视为符号，并且它们也将被添加到符号表中，以便在需要访问它们时，可以从符号表中访问。例如，`greet()`函数和两个变量存储在以下图表中的符号表中：
- en: '![](Images/58c18771-70c0-454c-91fc-514e05854547.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/58c18771-70c0-454c-91fc-514e05854547.png)'
- en: 'In Python, each module that is loaded has its own symbol table. The symbol
    table is given the name of that module. This way, modules act as namespaces. We
    can have multiple symbols of the same name as long as they exist in different
    symbol tables, and we can access them through the appropriate symbol table. See
    the following example, showing multiple symbol tables in a program:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '在Python中，每个加载的模块都有自己的符号表。符号表以该模块的名称命名。这样，模块就充当了命名空间。只要它们存在于不同的符号表中，我们可以拥有相同名称的多个符号，并且可以通过适当的符号表访问它们。请参见以下示例，显示程序中的多个符号表： '
- en: '![](Images/161c04e4-7336-4910-8a73-47ec4d89feba.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/161c04e4-7336-4910-8a73-47ec4d89feba.png)'
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at hash tables. We looked at how to write a hashing
    function to turn string data into integer data. Then, we looked at how we can
    use hashed keys to quickly and efficiently look up the value that corresponds
    to a key.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了哈希表。我们研究了如何编写一个哈希函数将字符串数据转换为整数数据。然后，我们研究了如何使用哈希键快速高效地查找与键对应的值。
- en: Further, we looked at the difficulties in the implementation of hash tables
    due to collisions in hash values. This led us to look at collision resolution
    strategies, so we discussed two important collision resolution methods, which
    are linear probing and chaining.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们还研究了哈希表实现中由于哈希值冲突而产生的困难。这导致我们研究了冲突解决策略，因此我们讨论了两种重要的冲突解决方法，即线性探测和链表法。
- en: In the last section of this chapter, we studied symbol tables, which are often built
    using hash tables. Symbol tables allow a compiler or an interpreter to look up
    a symbol (such as a variable, function, or class) that has been defined and retrieve
    all information about it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节中，我们研究了符号表，它们通常是使用哈希表构建的。符号表允许编译器或解释器查找已定义的符号（如变量、函数或类）并检索有关它们的所有信息。
- en: In the next chapter, we will talk about graphs and other algorithms.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论图和其他算法。
