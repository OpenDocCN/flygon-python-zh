["```py\nimport socket\n\nHOST = ''\nPORT = 4040\n\ndef create_listen_socket(host, port):\n    \"\"\" Setup the sockets our server will receive connection requests on \"\"\"\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    sock.bind((host, port))\n    sock.listen(100)\n    return sock\n\ndef recv_msg(sock):\n    \"\"\" Wait for data to arrive on the socket, then parse into messages using b'\\0' as message delimiter \"\"\"\n    data = bytearray()\n    msg = ''\n    # Repeatedly read 4096 bytes off the socket, storing the bytes\n    # in data until we see a delimiter\n    while not msg:\n        recvd = sock.recv(4096)\n        if not recvd:\n            # Socket has been closed prematurely\n            raise ConnectionError()\n        data = data + recvd\n        if b'\\0' in recvd:\n            # we know from our protocol rules that we only send\n            # one message per connection, so b'\\0' will always be\n            # the last character\n            msg = data.rstrip(b'\\0')\n    msg = msg.decode('utf-8')\n    return msg\n\ndef prep_msg(msg):\n    \"\"\" Prepare a string to be sent as a message \"\"\"\n    msg += '\\0'\n    return msg.encode('utf-8')\n\ndef send_msg(sock, msg):\n    \"\"\" Send a string over a socket, preparing it first \"\"\"\n    data = prep_msg(msg)\n    sock.sendall(data)\n```", "```py\nimport tincanchat\n\nHOST = tincanchat.HOST\nPORT = tincanchat.PORT\n\ndef handle_client(sock, addr):\n    \"\"\" Receive data from the client via sock and echo it back \"\"\"\n    try:\n        msg = tincanchat.recv_msg(sock)  # Blocks until received\n                                         # complete message\n        print('{}: {}'.format(addr, msg))\n        tincanchat.send_msg(sock, msg)  # Blocks until sent\n    except (ConnectionError, BrokenPipeError):\n        print('Socket error')\n    finally:\n        print('Closed connection to {}'.format(addr))\n        sock.close()\n\nif __name__ == '__main__':\n    listen_sock = tincanchat.create_listen_socket(HOST, PORT)\n    addr = listen_sock.getsockname()\n    print('Listening on {}'.format(addr))\n\n    while True:\n        client_sock, addr = listen_sock.accept()\n        print('Connection from {}'.format(addr))\n        handle_client(client_sock, addr)\n```", "```py\nimport sys, socket\nimport tincanchat\n\nHOST = sys.argv[-1] if len(sys.argv) > 1 else '127.0.0.1'\nPORT = tincanchat.PORT\n\nif __name__ == '__main__':\n    while True:\n        try:\n            sock = socket.socket(socket.AF_INET,\n                                 socket.SOCK_STREAM)\n            sock.connect((HOST, PORT))\n            print('\\nConnected to {}:{}'.format(HOST, PORT))\n            print(\"Type message, enter to send, 'q' to quit\")\n            msg = input()\n            if msg == 'q': break\n            tincanchat.send_msg(sock, msg)  # Blocks until sent\n            print('Sent message: {}'.format(msg))\n            msg = tincanchat.recv_msg(sock)  # Block until\n                                             # received complete\n                                             # message\n            print('Received echo: ' + msg)\n        except ConnectionError:\n            print('Socket error')\n            break\n        finally:\n            sock.close()\n            print('Closed connection to server\\n')\n```", "```py\n**$ python 1.1-echo_server-uni.py**\n**Listening on ('0.0.0.0', 4040)**\n\n```", "```py\n**$ python 1.2-echo_client.py 192.168.0.7**\n**Type message, enter to send, 'q' to quit**\n\n```", "```py\n**Type message, enter to send. 'q' to quit**\n**hello world**\n**Sent message: hello world**\n**Received echo: hello world**\n**Closed connection to server**\n\n```", "```py\n**Type message, enter to send. 'q' to quit**\n**hello world**\n**Sent message: hello world**\n\n```", "```py\nimport threading\nimport tincanchat\n\nHOST = tincanchat.HOST\nPORT = tincanchat.PORT\n\ndef handle_client(sock, addr):\n    \"\"\" Receive one message and echo it back to client, then close\n        socket \"\"\"\n    try:\n        msg = tincanchat.recv_msg(sock)  # blocks until received\n                                         # complete message\n        msg = '{}: {}'.format(addr, msg)\n        print(msg)\n        tincanchat.send_msg(sock, msg)  # blocks until sent\n    except (ConnectionError, BrokenPipeError):\n        print('Socket error')\n    finally:\n        print('Closed connection to {}'.format(addr))\n        sock.close()\n\nif __name__ == '__main__':\n    listen_sock = tincanchat.create_listen_socket(HOST, PORT)\n    addr = listen_sock.getsockname()\n    print('Listening on {}'.format(addr))\n\n    while True:\n        client_sock,addr = listen_sock.accept()\n        # Thread will run function handle_client() autonomously\n        # and concurrently to this while loop\n        thread = threading.Thread(target=handle_client,\n                                  args=[client_sock, addr],\n                                  daemon=True)\n        thread.start()\n        print('Connection from {}'.format(addr))\n```", "```py\ncaerphilly,\nillchester,\nbrie\n```", "```py\ncaerphilly**\\0**illchester**\\0**brie**\\0**\n\n```", "```py\nrecv 1: caerphil\nrecv 2: ly**\\0**illches\nrecv 3: ter**\\0**brie**\\0**\n\n```", "```py\ndef parse_recvd_data(data):\n    \"\"\" Break up raw received data into messages, delimited\n        by null byte \"\"\"\n    parts = data.split(b'\\0')\n    msgs = parts[:-1]\n    rest = parts[-1]\n    return (msgs, rest)\n\ndef recv_msgs(sock, data=bytes()):\n    \"\"\" Receive data and break into complete messages on null byte\n       delimiter. Block until at least one message received, then\n       return received messages \"\"\"\n    msgs = []\n    while not msgs:\n        recvd = sock.recv(4096)\n        if not recvd:\n            raise ConnectionError()\n        data = data + recvd\n        (msgs, rest) = parse_recvd_data(data)\n    msgs = [msg.decode('utf-8') for msg in msgs]\n    return (msgs, rest)\n```", "```py\nimport threading, queue\nimport tincanchat\n\nHOST = tincanchat.HOST\nPORT = tincanchat.PORT\n\nsend_queues = {}\nlock = threading.Lock()\n\ndef handle_client_recv(sock, addr):\n    \"\"\" Receive messages from client and broadcast them to\n        other clients until client disconnects \"\"\"\n    rest = bytes()\n    while True:\n        try:\n            (msgs, rest) = tincanchat.recv_msgs(sock, rest)\n        except (EOFError, ConnectionError):\n            handle_disconnect(sock, addr)\n            break\n        for msg in msgs:\n            msg = '{}: {}'.format(addr, msg)\n            print(msg)\n            broadcast_msg(msg)\n\ndef handle_client_send(sock, q, addr):\n    \"\"\" Monitor queue for new messages, send them to client as\n        they arrive \"\"\"\n    while True:\n        msg = q.get()\n        if msg == None: break\n        try:\n            tincanchat.send_msg(sock, msg)\n        except (ConnectionError, BrokenPipe):\n            handle_disconnect(sock, addr)\n            break\n\ndef broadcast_msg(msg):\n    \"\"\" Add message to each connected client's send queue \"\"\"\n    with lock:\n        for q in send_queues.values():\n            q.put(msg)\n\ndef handle_disconnect(sock, addr):\n    \"\"\" Ensure queue is cleaned up and socket closed when a client\n        disconnects \"\"\"\n    fd = sock.fileno()\n    with lock:\n        # Get send queue for this client\n        q = send_queues.get(fd, None)\n    # If we find a queue then this disconnect has not yet\n    # been handled\n    if q:\n        q.put(None)\n        del send_queues[fd]\n        addr = sock.getpeername()\n        print('Client {} disconnected'.format(addr))\n        sock.close()\n\nif __name__ == '__main__':\n    listen_sock = tincanchat.create_listen_socket(HOST, PORT)\n    addr = listen_sock.getsockname()\n    print('Listening on {}'.format(addr))\n\n    while True:\n        client_sock,addr = listen_sock.accept()\n        q = queue.Queue()\n        with lock:\n            send_queues[client_sock.fileno()] = q\n        recv_thread = threading.Thread(target=handle_client_recv,\n                                       args=[client_sock, addr],\n                                       daemon=True)\n        send_thread = threading.Thread(target=handle_client_send,\n                                       args=[client_sock, q,\n                                             addr],\n                                       daemon=True)\n        recv_thread.start()\n        send_thread.start()\n        print('Connection from {}'.format(addr))\n```", "```py\nimport sys, socket, threading\nimport tincanchat\n\nHOST = sys.argv[-1] if len(sys.argv) > 1 else '127.0.0.1'\nPORT = tincanchat.PORT\n\ndef handle_input(sock):\n    \"\"\" Prompt user for message and send it to server \"\"\"    \n    print(\"Type messages, enter to send. 'q' to quit\")\n    while True:\n        msg = input()  # Blocks\n        if msg == 'q':\n            sock.shutdown(socket.SHUT_RDWR)\n            sock.close()\n            break\n        try:\n            tincanchat.send_msg(sock, msg)  # Blocks until sent\n        except (BrokenPipeError, ConnectionError):\n            break\n\nif __name__ == '__main__':\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((HOST, PORT))\n    print('Connected to {}:{}'.format(HOST, PORT))\n\n    # Create thread for handling user input and message sending\n    thread = threading.Thread(target=handle_input,\n                              args=[sock],\n                              daemon=True)\n    thread.start()\n    rest = bytes()\n    addr = sock.getsockname()\n    # Loop indefinitely to receive messages from server\n    while True:\n        try:\n            # blocks\n            (msgs, rest) = tincanchat.recv_msgs(sock, rest)\n            for msg in msgs:\n                print(msg)\n        except ConnectionError:\n            print('Connection to server closed')\n            sock.close()\n            break\n```", "```py\nimport select\nimport tincanchat\nfrom types import SimpleNamespace\nfrom collections import deque\n\nHOST = tincanchat.HOST\nPORT = tincanchat.PORT\nclients = {}\n\ndef create_client(sock):\n    \"\"\" Return an object representing a client \"\"\"\n    return SimpleNamespace(\n                    sock=sock,\n                    rest=bytes(),\n                    send_queue=deque())\n\ndef broadcast_msg(msg):\n    \"\"\" Add message to all connected clients' queues \"\"\"\n    data = tincanchat.prep_msg(msg)\n    for client in clients.values():\n        client.send_queue.append(data)\n        poll.register(client.sock, select.POLLOUT)\n\nif __name__ == '__main__':\n    listen_sock = tincanchat.create_listen_socket(HOST, PORT)\n    poll = select.poll()\n    poll.register(listen_sock, select.POLLIN)\n    addr = listen_sock.getsockname()\n    print('Listening on {}'.format(addr))\n\n    # This is the event loop. Loop indefinitely, processing events\n    # on all sockets when they occur\n    while True:\n        # Iterate over all sockets with events\n        for fd, event in poll.poll():\n            # clear-up a closed socket\n            if event & (select.POLLHUP | \n                        select.POLLERR |\n                        select.POLLNVAL):\n                poll.unregister(fd)\n                del clients[fd]\n\n            # Accept new connection, add client to clients dict\n            elif fd == listen_sock.fileno():\n                client_sock,addr = listen_sock.accept()\n                client_sock.setblocking(False)\n                fd = client_sock.fileno()\n                clients[fd] = create_client(client_sock)\n                poll.register(fd, select.POLLIN)\n                print('Connection from {}'.format(addr))\n\n            # Handle received data on socket\n            elif event & select.POLLIN:\n                client = clients[fd]\n                addr = client.sock.getpeername()\n                recvd = client.sock.recv(4096)\n                if not recvd:\n                    # the client state will get cleaned up in the\n                    # next iteration of the event loop, as close()\n                    # sets the socket to POLLNVAL\n                    client.sock.close()\n                    print('Client {} disconnected'.format(addr))\n                    continue\n                data = client.rest + recvd\n                (msgs, client.rest) = \\\n                                tincanchat.parse_recvd_data(data)\n                # If we have any messages, broadcast them to all\n                # clients\n                for msg in msgs:\n                    msg = '{}: {}'.format(addr, msg)\n                    print(msg)\n                    broadcast_msg(msg)\n\n            # Send message to ready client\n            elif event & select.POLLOUT:\n                client = clients[fd]\n                data = client.send_queue.popleft()\n                sent = client.sock.send(data)\n                if sent < len(data):\n                    client.sends.appendleft(data[sent:])\n                if not client.send_queue:\n                    poll.modify(client.sock, select.POLLIN)\n```", "```py\nclass Client:\n  pass\nclient = Client()\n```", "```py\n**$ pip install eventlet**\n**Downloading/unpacking eventlet**\n\n```", "```py\nimport eventlet\nimport eventlet.queue as queue\nimport tincanchat\n\nHOST = tincanchat.HOST\nPORT = tincanchat.PORT\nsend_queues = {}\n\ndef handle_client_recv(sock, addr):\n    \"\"\" Receive messages from client and broadcast them to\n        other clients until client disconnects \"\"\"\n    rest = bytes()\n    while True:\n        try:\n            (msgs, rest) = tincanchat.recv_msgs(sock)\n        except (EOFError, ConnectionError):\n            handle_disconnect(sock, addr)\n            break\n        for msg in msgs:\n            msg = '{}: {}'.format(addr, msg)\n            print(msg)\n            broadcast_msg(msg)\n\ndef handle_client_send(sock, q, addr):\n    \"\"\" Monitor queue for new messages, send them to client as\n        they arrive \"\"\"\n    while True:\n        msg = q.get()\n        if msg == None: break\n        try:\n            tincanchat.send_msg(sock, msg)\n        except (ConnectionError, BrokenPipe):\n            handle_disconnect(sock, addr)\n            break\n\ndef broadcast_msg(msg):\n    \"\"\" Add message to each connected client's send queue \"\"\"\n    for q in send_queues.values():\n        q.put(msg)\n\ndef handle_disconnect(sock, addr):\n    \"\"\" Ensure queue is cleaned up and socket closed when a client\n        disconnects \"\"\"\n    fd = sock.fileno()\n    # Get send queue for this client\n    q = send_queues.get(fd, None)\n    # If we find a queue then this disconnect has not yet\n    # been handled\n    if q:\n        q.put(None)\n        del send_queues[fd]\n        addr = sock.getpeername()\n        print('Client {} disconnected'.format(addr))\n        sock.close()\n\nif __name__ == '__main__':\n    server = eventlet.listen((HOST, PORT))\n    addr = server.getsockname()\n    print('Listening on {}'.format(addr))\n\n    while True:\n        client_sock,addr = server.accept()\n        q = queue.Queue()\n        send_queues[client_sock.fileno()] = q\n        eventlet.spawn_n(handle_client_recv,\n                         client_sock,\n                         addr)\n        eventlet.spawn_n(handle_client_send,\n                         client_sock,\n                         q,\n                         addr)\n        print('Connection from {}'.format(addr))\n```", "```py\nimport asyncio\nimport tincanchat\n\nHOST = tincanchat.HOST\nPORT = tincanchat.PORT\nclients = []\n\nclass ChatServerProtocol(asyncio.Protocol):\n  \"\"\" Each instance of class represents a client and the socket \n       connection to it. \"\"\"\n\n    def connection_made(self, transport):\n        \"\"\" Called on instantiation, when new client connects \"\"\"\n           self.transport = transport\n        self.addr = transport.get_extra_info('peername')\n        self._rest = b''\n        clients.append(self)\n        print('Connection from {}'.format(self.addr))\n\n    def data_received(self, data):\n        \"\"\" Handle data as it's received. Broadcast complete\n        messages to all other clients \"\"\"\n        data = self._rest + data\n        (msgs, rest) = tincanchat.parse_recvd_data(data)\n        self._rest = rest\n        for msg in msgs:\n            msg = msg.decode('utf-8')\n            msg = '{}: {}'.format(self.addr, msg)\n            print(msg)\n            msg = tincanchat.prep_msg(msg)\n            for client in clients:\n                client.transport.write(msg)  # <-- non-blocking\n\n    def connection_lost(self, ex):\n        \"\"\" Called on client disconnect. Clean up client state \"\"\"\n        print('Client {} disconnected'.format(self.addr))\n        clients.remove(self)\n\nif __name__ == '__main__':\n    loop = asyncio.get_event_loop()\n    # Create server and initialize on the event loop\n    coroutine = loop.create_server(ChatServerProtocol,\n                                  host=HOST,\n                                  port=PORT)\n    server = loop.run_until_complete(coroutine)\n    # print listening socket info\n    for socket in server.sockets:\n        addr = socket.getsockname()\n        print('Listening on {}'.format(addr))\n    # Run the loop to process client connections\n    loop.run_forever()\n```"]