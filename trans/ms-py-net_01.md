# TCP/IP 协议套件和 Python 的回顾

欢迎来到网络工程的新时代。18 年前，也就是在千禧年之交，我开始担任网络工程师时，这个角色与其他技术角色有着明显的不同。网络工程师主要具有领域特定的知识，用于管理和操作局域网和广域网，偶尔会涉足系统管理，但没有写代码或理解编程概念的期望。现在情况已经不同了。多年来，DevOps 和软件定义网络（SDN）运动等因素显著地模糊了网络工程师、系统工程师和开发人员之间的界限。

您拿起这本书的事实表明您可能已经是网络 DevOps 的采用者，或者您正在考虑走这条路。也许您已经作为网络工程师工作了多年，就像我一样，想知道 Python 编程语言的热度是怎么回事。或者您可能已经精通 Python，但想知道它在网络工程中的应用。如果您属于这些人群，或者只是对网络工程领域中的 Python 感到好奇，我相信这本书适合您：

![](img/dce15e34-48e7-47b4-91ef-fb54268aa5f0.png)Python 和网络工程的交集

已经有很多深入探讨网络工程和 Python 主题的书籍。我不打算在本书中重复他们的努力。相反，本书假设您有一些管理网络的实际经验，以及对网络协议和 Python 语言的基本理解。您不需要成为 Python 或网络工程的专家，但应该发现本章中的概念构成了一个概括性的回顾。本章的其余部分应该设定了对先前知识的期望水平，以便从本书中获得最大的收获。如果您想复习本章的内容，有很多免费或低成本的资源可以帮助您迅速掌握。我建议使用免费的可汗学院（[`www.khanacademy.org/)`](https://www.khanacademy.org/)和 Python 教程：[`www.python.org/.`](https://www.python.org/)

本章将快速介绍相关的网络主题。根据我在这个领域工作的经验，一个典型的网络工程师或开发人员可能不记得确切的 TCP 状态机来完成他们的日常任务（我知道我不记得），但他们会熟悉 OSI 模型的基础知识、TCP 和 UDP 的操作、不同的 IP 头字段以及其他基本概念。

我们还将对 Python 语言进行高层次的概述；对于那些不是每天都用 Python 编码的读者来说，这足够让他们在本书的其余部分有所准备。

具体来说，我们将涵盖以下主题：

+   互联网概述

+   OSI 和客户端-服务器模型

+   TCP、UDP 和 IP 协议套件

+   Python 语法、类型、运算符和循环

+   使用函数、类和包扩展 Python

当然，本章中提供的信息并不是详尽无遗的；请查看参考资料以获取更多信息。

# 互联网概述

什么是互联网？这个看似简单的问题可能会因你的背景而得到不同的答案。互联网对不同的人意味着不同的东西；年轻人、老年人、学生、教师、商人、诗人，都可能对这个问题给出不同的答案。

对于网络工程师来说，互联网是一个全球计算机网络，由一系列互联网络连接大大小小的网络。换句话说，它是一个没有集中所有者的网络。以您的家庭网络为例。它可能由家用以太网交换机和无线接入点组成，将您的智能手机、平板电脑、计算机和电视连接在一起，以便设备之间进行通信。这就是您的**局域网**（**LAN**）。当您的家庭网络需要与外部世界通信时，它会将信息从您的 LAN 传递到一个更大的网络，通常称为**互联网服务提供商**（**ISP**）。您的 ISP 通常由边缘节点组成，这些节点将流量聚合到其核心网络中。核心网络的功能是通过更高速的网络连接这些边缘网络。在特定的边缘节点，您的 ISP 连接到其他 ISP，以适当地将您的流量传递到目的地。从目的地返回到您的家用计算机、平板电脑或智能手机的路径可能会或可能不会沿着同样的路径穿过所有这些网络返回到您的设备，而源和目的地保持不变。

让我们来看看构成这个网络之网的组件。

# 服务器、主机和网络组件

**主机**是网络上的终端节点，与其他节点进行通信。在今天的世界中，主机可以是传统计算机，也可以是您的智能手机、平板电脑或电视。随着**物联网**（**IoT**）的兴起，主机的广义定义可以扩展到包括 IP 摄像机、电视机顶盒以及我们在农业、农场、汽车等领域使用的越来越多类型的传感器。随着连接到互联网的主机数量的激增，所有这些主机都需要被寻址、路由和管理。对适当的网络需求从未如此迫切。

我们在互联网上大部分时间都是在请求服务。这可能是查看网页，发送或接收电子邮件，传输文件等。这些服务是由**服务器**提供的。顾名思义，服务器为多个节点提供服务，并且通常具有更高级别的硬件规格。在某种程度上，服务器是网络上提供额外功能的特殊超级节点。我们将在客户端-服务器模型部分稍后讨论服务器。

如果您将服务器和主机视为城市和城镇，**网络组件**就是连接它们的道路和高速公路。事实上，在描述跨越全球传输不断增加的比特和字节的网络组件时，信息高速公路这个术语就会浮现在脑海中。在我们稍后将要看到的 OSI 模型中，这些网络组件是第一到第三层设备。它们是第二和第三层的路由器和交换机，用于指导流量，以及第一层的传输设备，如光纤电缆、同轴电缆、双绞铜线和一些 DWDM 设备，等等。

总的来说，主机、服务器和网络组件构成了我们今天所知的互联网。

# 数据中心的崛起

在上一节中，我们看到了服务器、主机和网络组件在互联网中扮演的不同角色。由于服务器需要更高的硬件容量，它们通常被放在一个中央位置，以便更有效地进行管理。我们经常将这些位置称为数据中心。

# 企业数据中心

在典型的企业中，公司通常需要内部工具，如电子邮件、文档存储、销售跟踪、订购、人力资源工具和知识共享内部网。这些服务转化为文件和邮件服务器、数据库服务器和 Web 服务器。与用户计算机不同，这些通常是需要大量电力、冷却和网络连接的高端计算机。硬件的副产品也是它们产生的噪音量。它们通常被放置在企业的中心位置，称为主配线架（MDF），以提供必要的电力供应、电力冗余、冷却和网络连接。

为了连接到 MDF，用户的流量通常会在距离用户更近的位置进行聚合，有时被称为中间分配框架（IDF），然后再捆绑并连接到 MDF。 IDF-MDF 的分布通常遵循企业建筑或校园的物理布局。例如，每个楼层可以包括一个 IDF，它会聚合到另一楼层的 MDF。如果企业由多栋建筑组成，可以通过将建筑的流量组合起来，然后连接到企业数据中心来进一步进行聚合。

企业数据中心通常遵循三层网络设计。这些层是接入层、分发层和核心层。接入层类似于每个用户连接的端口，IDF 可以被视为分发层，而核心层包括与 MDF 和企业数据中心的连接。当然，这是企业网络的概括，因为其中一些网络将不会遵循相同的模型。

# 云数据中心

随着云计算和软件或基础设施即服务的兴起，云提供商建立的数据中心规模庞大。由于它们所容纳的服务器数量，它们通常对电力、冷却、网络速度和供电需求远远高于任何企业数据中心。即使在云提供商数据中心工作多年后，每次我访问云提供商数据中心时，我仍然对它们的规模感到惊讶。事实上，云数据中心如此庞大且耗电量巨大，它们通常建在靠近发电厂的地方，以获得最便宜的电力费率，而在输电过程中不会损失太多效率。它们的冷却需求如此之大，有些被迫在建造数据中心时寻求创意，选择建在通常气候寒冷的地方，这样他们就可以在需要时打开门窗，保持服务器以安全温度运行。任何搜索引擎都可以给出一些惊人的数字，涉及为亚马逊、微软、谷歌和 Facebook 等公司建造和管理云数据中心的科学：

犹他数据中心（来源：https://en.wikipedia.org/wiki/Utah_Data_Center）

在云提供商的规模下，它们需要提供的服务通常不具备成本效益，或者无法合理地容纳在单个服务器中。它们分布在一群服务器之间，有时跨越许多不同的机架，以提供冗余和灵活性给服务所有者。延迟和冗余要求对网络施加了巨大的压力。互连的数量相当于网络设备的爆炸性增长；这意味着这些网络设备需要被装架、配置和管理的次数。典型的网络设计是多级 CLOS 网络：

CLOS 网络

在某种程度上，云数据中心是网络自动化成为速度和可靠性的必要性的地方。如果我们按照传统的方式通过终端和命令行界面管理网络设备，所需的工程小时数将不允许服务在合理的时间内可用。更不用说人类的重复是容易出错、低效和工程人才的可怕浪费。

云数据中心是我多年前开始使用 Python 进行网络自动化的地方，自那以后我就再也没有回头过。

# 边缘数据中心

如果我们在数据中心级别有足够的计算能力，为什么还要将任何东西放在数据中心之外呢？来自世界各地的客户的所有连接都可以路由回提供服务的数据中心服务器，我们就可以结束一天了，对吗？当然，答案取决于用例。将请求和会话从客户端一直路由到大型数据中心的最大限制是传输中引入的延迟。换句话说，大延迟是网络成为瓶颈的地方。延迟数字永远不会为零：即使光在真空中传播得很快，物理传输也需要时间。在现实世界中，当数据包穿过多个网络时，有时还穿过海底电缆、慢速卫星链路、3G 或 4G 蜂窝链路或 Wi-Fi 连接时，延迟会比真空中的光要高得多。

解决方案？减少终端用户穿越的网络数量。尽可能与用户在用户进入您的网络的边缘处紧密连接，并在边缘位置放置足够的资源来提供服务。让我们花一分钟想象一下，您正在构建下一代视频流媒体服务。为了提高顾客对流畅播放的满意度，您会希望将视频服务器尽可能靠近客户，要么在客户的 ISP 内部，要么非常靠近客户的 ISP。此外，视频服务器农场的上游不仅连接到一个或两个 ISP，而是连接到我可以连接的所有 ISP，以减少跳数。所有连接都将具有所需的带宽，以在高峰时段减少延迟。这种需求催生了大型 ISP 和内容提供商的对等交换边缘数据中心。即使网络设备的数量不像云数据中心那样多，它们也可以从网络自动化中受益，因为网络自动化带来了增加的可靠性、安全性和可见性。

我们将在本书的后面章节中涵盖安全性和可见性。

# OSI 模型

没有网络书籍是完整的，没有先讨论**开放系统互连**（**OSI**）模型。该模型是一个概念模型，将电信功能组件化为不同的层。该模型定义了七个层，每个层都独立地位于另一个层的顶部，只要它们遵循定义的结构和特征。例如，在网络层，IP 可以位于不同类型的数据链路层的顶部，如以太网或帧中继。OSI 参考模型是将不同和多样的技术规范化为一组人们可以达成一致的共同语言的好方法。这大大减少了在各自层上工作的各方的范围，并允许他们深入研究特定任务，而不用太担心兼容性。

![](img/762c9bbe-cd1f-4546-a2a7-2725a7caa3e9.png)OSI 模型

OSI 模型最初是在 20 世纪 70 年代后期进行研究的，后来由**国际标准化组织**（**ISO**）和现在被称为**国际电信联盟**（**ITU-T**）的**电信标准化部门**联合出版。它被广泛接受，并在引入电信新主题时通常被引用。

在 OSI 模型开发的同时期，互联网正在形成。原始设计者使用的参考模型通常被称为 TCP/IP 模型。传输控制协议（TCP）和互联网协议（IP）是最初包含在设计中的协议套件。这在某种程度上类似于 OSI 模型，因为它们将端到端数据通信分为抽象层。不同的是，该模型将 OSI 模型中的第 5 至 7 层合并为应用层，而物理层和数据链路层合并为链路层。

互联网协议套件

OSI 和 TCP/IP 模型都对提供端到端数据通信的标准很有用。然而，大部分时间我们将更多地参考 TCP/IP 模型，因为互联网就是建立在这个模型上的。当我们讨论即将到来的章节中的 Web 框架时，我们将指定 OSI 模型。

# 客户端-服务器模型

参考模型展示了数据在两个节点之间进行通信的标准方式。当然，到现在为止，我们都知道，并非所有节点都是平等的。即使在 DARPA 网络的早期，也有工作站节点，也有目的是向其他节点提供内容的节点。这些服务器节点通常具有更高的硬件规格，并由工程师更密切地管理。由于这些节点向其他节点提供资源和服务，它们通常被称为服务器。服务器通常处于空闲状态，等待客户端发起对其资源的请求。这种由客户端请求的分布式资源模型被称为客户端-服务器模型。

为什么这很重要？如果你仔细想一想，客户端-服务器模型凸显了网络的重要性。没有它，网络互连的需求其实并不是很大。正是客户端向服务器传输比特和字节的需求，突显了网络工程的重要性。当然，我们都知道，最大的网络——互联网，一直在改变我们所有人的生活，并持续不断地这样做。

你可能会问，每个节点如何确定每次需要相互通信时的时间、速度、源和目的地？这就引出了网络协议。

# 网络协议套件

在计算机网络的早期，协议是专有的，并由设计连接方法的公司严格控制。如果您在主机中使用 Novell 的 IPX/SPX 协议，您将无法与苹果的 AppleTalk 主机进行通信，反之亦然。这些专有协议套件通常与 OSI 参考模型具有类似的层，并遵循客户端-服务器通信方法。它们通常在局域网（LAN）中运行良好，这些局域网是封闭的，无需与外部世界通信。当流量需要移动到本地局域网之外时，通常会使用互联网设备，如路由器，来将一个协议转换为另一个协议。例如，路由器连接 AppleTalk 网络到基于 IP 的网络。翻译通常不完美，但由于在早期大部分通信发生在局域网内，这是可以接受的。

然而，随着对局域网之外的互联网通信需求的增加，标准化网络协议套件的需求变得更加迫切。专有协议最终让位于 TCP、UDP 和 IP 的标准化协议套件，这极大地增强了一个网络与另一个网络进行通信的能力。互联网，所有网络中最伟大的网络，依赖这些协议来正常运行。在接下来的几节中，我们将看一下每个协议套件。

# 传输控制协议

**传输控制协议**（**TCP**）是今天互联网上使用的主要协议之一。如果您打开过网页或发送过电子邮件，您就已经接触过 TCP 协议。该协议位于 OSI 模型的第 4 层，负责以可靠和经过错误检查的方式在两个节点之间传递数据段。TCP 由一个包括源端口、目的端口、序列号、确认号、控制标志和校验和在内的 160 位标头组成：

![](img/c505f800-db13-46d6-b706-c5c3bf1f94e8.png)TCP 标头

# TCP 的功能和特性

TCP 使用数据报套接字或端口来建立主机之间的通信。称为**Internet Assigned Numbers Authority**（**IANA**）的标准机构指定了知名端口，以指示特定服务，例如端口`80`用于 HTTP（web），端口`25`用于 SMTP（邮件）。在客户端-服务器模型中，服务器通常在这些知名端口之一上监听，以便接收来自客户端的通信请求。TCP 连接由操作系统通过表示连接的本地端点的套接字来管理。

协议操作由一个状态机组成，其中状态机需要跟踪何时正在监听传入连接，以及在通信会话期间释放资源。每个 TCP 连接都经历一系列状态，如`Listen`，`SYN-SENT`，`SYN-RECEIVED`，`ESTABLISHED`，`FIN-WAIT`，`CLOSE-WAIT`，`CLOSING`，`LAST-ACK`，`TIME-WAIT`和`CLOSED`。

# TCP 消息和数据传输

TCP 和**用户数据报协议**（**UDP**）之间最大的区别是，TCP 以有序和可靠的方式传输数据。操作保证传递通常被称为 TCP 是一种面向连接的协议。它通过首先建立三次握手来同步发送方和接收方之间的序列号`SYN`，`SYN-ACK`和`ACK`来实现这一点。

确认用于跟踪对话中的后续段。最后，在对话结束时，一方将发送一个`FIN`消息，另一方将`ACK`这个`FIN`消息，并发送自己的`FIN`消息。`FIN`发起方然后将`ACK`收到的`FIN`消息。

正如许多我们曾经排查过 TCP 连接的人所能告诉你的那样，这个操作可能会变得非常复杂。大多数情况下，这个操作只是在后台默默地进行。

关于 TCP 协议可以写一整本书；事实上，已经有许多优秀的书籍写就了这个协议。

由于本节是一个快速概述，如果感兴趣，可以使用 TCP/IP 指南（[`www.tcpipguide.com/`](http://www.tcpipguide.com/)）这个优秀的免费资源来深入了解这个主题。

# 用户数据报协议

**用户数据报协议**（**UDP**）也是互联网协议套件的核心成员之一。与 TCP 一样，它在 OSI 模型的第 4 层上运行，负责在应用程序和 IP 层之间传递数据段。与 TCP 不同的是，UDP 的标头只有 64 位，其中只包括源端口、目的端口、长度和校验和。轻量级的标头使其非常适合那些更喜欢快速数据传递而不需要在两个主机之间建立会话或需要可靠数据传递的应用程序。也许在今天快速的互联网连接下很难想象，但在 X.21 和帧中继链路的早期，额外的标头对传输速度产生了很大影响。尽管速度差异同样重要，但与 TCP 一样，不必维护各种状态也节省了两个端点的计算机资源：

![](img/3ef8b6dc-c13e-4091-b48b-a9f5a882a35a.png)UDP 标头

您可能会想为什么在现代时代还要使用 UDP；考虑到可靠传输的缺乏，我们难道不希望所有连接都是可靠且无错误的吗？如果考虑多媒体视频流或 Skype 通话，这些应用程序受益于轻量级标头，因为应用程序只是希望尽快传递数据报。您还可以考虑基于 UDP 协议的快速 DNS 查找过程。当您在浏览器中输入的地址被转换为计算机可理解的地址时，用户将受益于轻量级过程，因为这必须在您从您喜爱的网站接收到第一个比特之前发生。

再次强调，本节对 UDP 的主题并不充分，鼓励读者通过各种资源探索该主题，如果您对学习更多关于 UDP 感兴趣的话。

# 互联网协议

正如网络工程师所说，他们活在**互联网协议**（IP）层，这是 OSI 模型的第 3 层。**IP**的工作是在终端节点之间进行寻址和路由等。IP 的寻址可能是它最重要的工作。地址空间分为两部分：网络部分和主机部分。子网掩码用于指示网络地址中的网络部分和主机部分，通过将网络部分与 1 匹配，主机部分与 0 匹配。IPv4 和后来的 IPv6 都以点分表示法表示地址，例如`192.168.0.1`。子网掩码可以以点分表示法（`255.255.255.0`）或使用斜杠表示应考虑的网络位数（/24）：

![](img/86dd4756-3682-4a2d-89e9-5e8cd3eeae43.png)IPv4 头部

IPv6 头部是 IPv4 的 IP 头部的下一代，具有固定部分和各种扩展标头：

![](img/04eb0dd0-5fb9-4c7b-8dbf-deac8eb97cdb.png)IPv6 固定头部

固定头部中的**下一个标头**字段可以指示后续携带附加信息的扩展标头。扩展标头可以包括路由和分段信息。尽管协议设计者希望从 IPv4 转移到 IPv6，但今天的互联网仍然主要使用 IPv4 进行寻址，部分服务提供商网络内部使用 IPv6 进行寻址。

# IP NAT 和安全

**网络地址转换**（**NAT**）通常用于将一系列私有 IPv4 地址转换为公共可路由的 IPv4 地址。但它也可以意味着 IPv4 到 IPv6 之间的转换，例如在运营商边缘使用 IPv6 内部网络需要转换为 IPv4 时。有时也出于安全原因使用 NAT6 到 6。

安全是一个持续的过程，整合了网络的所有方面，包括自动化和 Python。本书旨在使用 Python 帮助您管理网络；安全将作为本书后续章节的一部分进行讨论，例如使用 SSHv2 替代 telnet。我们还将探讨如何使用 Python 和其他工具来获得网络的可见性。

# IP 路由概念

在我看来，IP 路由是指让两个端点之间的中间设备根据 IP 头部传输数据包。对于所有通过互联网进行的通信，数据包将通过各种中间设备传输。如前所述，中间设备包括路由器、交换机、光学设备和其他不会检查网络和传输层以外内容的设备。用一种道路旅行的类比来说，你可能会从加利福尼亚州的圣迭戈市到华盛顿州的西雅图市旅行。IP 源地址类似于圣迭戈，目的地 IP 地址可以被视为西雅图。在你的旅行中，你会经过许多不同的中间地点，比如洛杉矶、旧金山和波特兰；这些可以被视为源地址和目的地之间的路由器和交换机。

为什么这很重要？在某种程度上，这本书是关于管理和优化这些中间设备。在跨越多个美式橄榄球场大小的超大数据中心时代，高效、灵活、可靠和具有成本效益的网络管理方式成为公司的竞争优势的重要点。在未来的章节中，我们将深入探讨如何使用 Python 编程有效地管理网络。

# Python 语言概述

简而言之，这本书是关于如何使用 Python 使我们的网络工程生活更轻松。但是 Python 是什么，为什么它是许多 DevOps 工程师的首选语言呢？用 Python 基金会执行摘要的话来说：

“Python 是一种解释型、面向对象的高级编程语言，具有动态语义。它的高级内置数据结构，结合动态类型和动态绑定，使其非常适合快速应用程序开发，以及作为脚本或粘合语言来连接现有组件。Python 的简单、易学的语法强调可读性，因此降低了程序维护的成本。”

如果你对编程还比较陌生，前面提到的面向对象、动态语义可能对你来说意义不大。但我认为我们都可以同意，对于快速应用程序开发来说，简单易学的语法听起来是一件好事。作为一种解释型语言，Python 意味着不需要编译过程，因此编写、测试和编辑 Python 程序的时间大大缩短。对于简单的脚本，如果你的脚本出错，通常只需要一个`print`语句就可以调试出问题所在。使用解释器还意味着 Python 很容易移植到不同类型的操作系统，比如 Windows 和 Linux，一个在一个操作系统上编写的 Python 程序可以在另一个操作系统上使用。

面向对象的特性鼓励通过将大型程序分解为简单可重用的对象来实现代码重用，以及其他可重用的格式，如函数、模块和包。事实上，所有的 Python 文件都是可以被重用或导入到另一个 Python 程序中的模块。这使得工程师之间可以轻松共享程序，并鼓励代码重用。Python 还有一个“电池包含在内”的口号，这意味着对于常见的任务，你不需要下载任何额外的包。为了在不使代码过于臃肿的情况下实现这一点，当你安装 Python 解释器时，一组标准库会被安装。对于常见的任务，比如正则表达式、数学函数和 JSON 解码，你只需要使用`import`语句，解释器就会将这些函数移入你的程序中。这是我认为 Python 语言的一个杀手功能。

最后，Python 代码可以从几行代码的相对小型脚本开始，并逐渐发展成一个完整的生产系统，对于网络工程师来说非常方便。正如我们许多人所知，网络通常是在没有总体规划的情况下有机地发展的。一种可以随着网络规模增长的语言是非常宝贵的。您可能会惊讶地看到，许多前沿公司（使用 Python 的组织）正在使用被许多人认为是脚本语言的语言来开发完整的生产系统。

如果您曾经在需要在不同的供应商平台上工作时不得不切换，比如 Cisco IOS 和 Juniper Junos，您就知道在尝试完成相同任务时切换语法和用法是多么痛苦。由于 Python 足够灵活，可以用于大型和小型程序，因此没有这种上下文切换，因为它只是 Python。

在本章的其余部分，我们将对 Python 语言进行高层次的介绍，以便稍作复习。如果您已经熟悉基础知识，可以快速浏览或跳过本章的其余部分。

# Python 版本

许多读者已经意识到，Python 在过去几年中一直在从 Python 2 过渡到 Python 3。 Python 3 于 2008 年发布，已经有 10 多年的历史，最近发布了 3.7 版本。不幸的是，Python 3 与 Python 2 不兼容。在撰写本书第二版时，即 2018 年中期，Python 社区基本上已经转向 Python 3。最新的 Python 2.x 版本 2.7 是在 2010 年中期发布的，已经有 6 年多的历史了。幸运的是，两个版本可以在同一台机器上共存。我个人在命令提示符中输入 Python 时使用 Python 2 作为默认解释器，需要使用 Python 3 时则使用 Python 3。关于调用 Python 解释器的更多信息将在下一节中给出，但这里有一个在 Ubuntu Linux 机器上调用 Python 2 和 Python 3 的示例：

```py
$ python
Python 2.7.12 (default, Dec 4 2017, 14:50:18)
[GCC 5.4.0 20160609] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> exit() 
```

```py
$ python3
Python 3.5.2 (default, Nov 23 2017, 16:37:01)
[GCC 5.4.0 20160609] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> exit() 
```

随着 2.7 版本的终止生命周期，大多数 Python 框架现在支持 Python 3。Python 3 还有许多很好的特性，比如异步 I/O，在需要优化我们的代码时可以利用这些特性。本书的代码示例将使用 Python 3，除非另有说明。我们还将尽量在适用时指出 Python 2 和 Python 3 之间的区别。

如果特定的库或框架更适合 Python 2，比如 Ansible（请参阅以下信息），我们将指出并使用 Python 2。

在撰写本文时，Ansible 2.5 及以上版本支持 Python 3。在 2.5 之前，Python 3 支持被视为技术预览。鉴于相对较新的支持性，许多社区模块仍然需要迁移到 Python 3。有关 Ansible 和 Python 3 的更多信息，请参阅[`docs.ansible.com/ansible/2.5/dev_guide/developing_python_3.html`](https://docs.ansible.com/ansible/2.5/dev_guide/developing_python_3.html)。

# 操作系统

如前所述，Python 是跨平台的。Python 程序可以在 Windows、Mac 和 Linux 上运行。实际上，在需要确保跨平台兼容性时需要注意一些细节，比如在 Windows 文件名中反斜杠的微妙差异。由于本书是为 DevOps、系统和网络工程师编写的，Linux 是预期受众的首选平台，特别是在生产环境中。本书中的代码将在 Linux Ubuntu 16.06 LTS 机器上进行测试。我也会尽力确保代码在 Windows 和 MacOS 平台上运行相同。

如果您对操作系统的详细信息感兴趣，它们如下：

```py
$ uname -a
Linux packt-network-python 4.13.0-45-generic #50~16.04.1-Ubuntu SMP Wed May 30 11:18:27 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux 
```

# 运行 Python 程序

Python 程序由解释器执行，这意味着代码通过解释器传递给底层操作系统执行，并显示结果。Python 开发社区有几种不同的解释器实现，例如 IronPython 和 Jython。在本书中，我们将使用今天最常用的 Python 解释器，即 CPython。在本书中提到 Python 时，我们指的是 CPython，除非另有说明。

您可以使用 Python 的交互式提示符来使用 Python 的一种方式。当您想要快速测试一段 Python 代码或概念而不写整个程序时，这是很有用的。通常只需输入`Python`关键字即可：

```py
Python 3.5.2 (default, Nov 17 2016, 17:05:23)
[GCC 5.4.0 20160609] on linux
Type "help", "copyright", "credits" or "license" for 
more information.
>>> print("hello world")
hello world
>>>
```

在 Python 3 中，`print`语句是一个函数；因此，它需要括号。在 Python 2 中，您可以省略括号。

交互模式是 Python 最有用的功能之一。在交互式 shell 中，您可以输入任何有效的语句或语句序列，并立即得到结果。我通常用它来探索我不熟悉的功能或库。谈论即时满足！

在 Windows 上，如果没有收到 Python shell 提示符，则可能没有将程序添加到系统搜索路径中。最新的 Windows Python 安装程序提供了一个复选框，用于将 Python 添加到系统路径中；确保已经选中。或者您可以通过转到环境设置手动将程序添加到路径中。

然而，运行 Python 程序的更常见的方法是保存您的 Python 文件，并在之后通过解释器运行它。这将使您免于在交互式 shell 中一遍又一遍地输入相同的语句。Python 文件只是通常以`.py`扩展名保存的普通文本文件。在*Nix 世界中，您还可以在顶部添加**shebang**（`#!`）行，以指定将用于运行文件的解释器。`#`字符可用于指定不会被解释器执行的注释。以下文件`helloworld.py`包含以下语句：

```py
# This is a comment
print("hello world") 
```

可以按照以下方式执行：

```py
$ python helloworld.py
hello world
$
```

# Python 内置类型

Python 在解释器中内置了几种标准类型：

+   **None**：`Null`对象

+   **数值**：`int`、`long`、`float`、`complex`和`bool`（带有`True`或`False`值的`int`子类）

+   **序列**：`str`、list、tuple 和 range

+   **映射**：`dict`

+   **集合**：`set`和`frozenset`

# None 类型

`None`类型表示没有值的对象。在不明确返回任何内容的函数中返回`None`类型。`None`类型也用于函数参数，如果调用者没有传入实际值，则会出错。

# 数值

Python 数值对象基本上是数字。除了布尔值外，`int`、`long`、`float`和`complex`这些数值类型都是有符号的，这意味着它们可以是正数或负数。布尔值是整数的一个子类，可以是两个值之一：`True`为`1`，`False`为`0`。其余的数值类型是通过它们能够准确表示数字的方式来区分的；例如，`int`是具有有限范围的整数，而`long`是具有无限范围的整数。浮点数是使用机器上的双精度表示（64 位）的数字。

# 序列

序列是具有非负整数索引的对象的有序集合。在本节和接下来的几节中，我们将使用交互式解释器来说明不同的类型。请随时在您自己的计算机上输入。

有时人们会感到惊讶，`string`实际上是一个序列类型。但是如果你仔细看，字符串是一系列字符组合在一起。字符串可以用单引号、双引号或三引号括起来。请注意，在以下示例中，引号必须匹配，三引号允许字符串跨越不同的行：

```py
>>> a = "networking is fun"
>>> b = 'DevOps is fun too'
>>> c = """what about coding?
... super fun!"""
>>>
```

另外两种常用的序列类型是列表和元组。列表是任意对象的序列。列表可以通过将对象括在方括号中创建。就像字符串一样，列表由从零开始的非零整数索引。通过引用索引号检索列表的值：

```py
>>> vendors = ["Cisco", "Arista", "Juniper"]
>>> vendors[0]
'Cisco'
>>> vendors[1]
'Arista'
>>> vendors[2]
'Juniper'
```

元组类似于列表，通过括号括起的值创建。与列表一样，可以通过引用其索引号来检索元组中的值。与列表不同的是，创建后不能修改值：

```py
>>> datacenters = ("SJC1", "LAX1", "SFO1")
>>> datacenters[0]
'SJC1'
>>> datacenters[1]
'LAX1'
>>> datacenters[2]
'SFO1' 
```

所有序列类型都有一些共同的操作，例如按索引返回元素以及切片：

```py
>>> a
'networking is fun'
>>> a[1]
'e'
>>> vendors
['Cisco', 'Arista', 'Juniper']
>>> vendors[1]
'Arista'
>>> datacenters
('SJC1', 'LAX1', 'SFO1')
>>> datacenters[1]
'LAX1'
>>>
>>> a[0:2]
'ne'
>>> vendors[0:2]
['Cisco', 'Arista']
>>> datacenters[0:2]
('SJC1', 'LAX1')
>>>
```

记住索引从`0`开始。因此，`1`的索引实际上是序列中的第二个元素。

还有一些常见的函数可以应用于序列类型，例如检查元素数量和最小值和最大值：

```py
>>> len(a)
17
>>> len(vendors)
3
>>> len(datacenters)
3
>>>
>>> b = [1, 2, 3, 4, 5]
>>> min(b)
1
>>> max(b)
5
```

毫不奇怪，还有各种方法仅适用于字符串。值得注意的是，这些方法不会修改基础字符串数据本身，并始终返回一个新的字符串。如果您想使用新值，您需要捕获返回值并将其分配给不同的变量：

```py
>>> a
'networking is fun'
>>> a.capitalize()
'Networking is fun'
>>> a.upper()
'NETWORKING IS FUN'
>>> a
'networking is fun'
>>> b = a.upper()
>>> b
'NETWORKING IS FUN'
>>> a.split()
['networking', 'is', 'fun']
>>> a
'networking is fun'
>>> b = a.split()
>>> b
['networking', 'is', 'fun']
>>>
```

以下是列表的一些常用方法。在将多个项目放在一起并逐个迭代它们方面，列表是一种非常有用的结构。例如，我们可以制作一个数据中心脊柱交换机的列表，并通过逐个迭代它们来应用相同的访问列表。由于列表的值可以在创建后修改（与元组不同），因此我们还可以在程序中扩展和对比现有列表：

```py
>>> routers = ['r1', 'r2', 'r3', 'r4', 'r5']
>>> routers.append('r6')
>>> routers
['r1', 'r2', 'r3', 'r4', 'r5', 'r6']
>>> routers.insert(2, 'r100')
>>> routers
['r1', 'r2', 'r100', 'r3', 'r4', 'r5', 'r6']
>>> routers.pop(1)
'r2'
>>> routers
['r1', 'r100', 'r3', 'r4', 'r5', 'r6']
```

# 映射

Python 提供了一种映射类型，称为**字典**。字典是我认为的穷人的数据库，因为它包含可以由键索引的对象。在其他语言中，这通常被称为关联数组或哈希表。如果您在其他语言中使用过类似字典的对象，您将知道这是一种强大的类型，因为您可以使用可读的键引用对象。对于试图维护和排除代码的可怜家伙来说，这个键将更有意义。几个月后，您编写代码并在凌晨 2 点排除故障时，这个家伙可能就是您。字典值中的对象也可以是另一种数据类型，比如列表。您可以用大括号创建一个字典：

```py
>>> datacenter1 = {'spines': ['r1', 'r2', 'r3', 'r4']}
>>> datacenter1['leafs'] = ['l1', 'l2', 'l3', 'l4']
>>> datacenter1
{'leafs': ['l1', 'l2', 'l3', 'l4'], 'spines': ['r1',  
'r2', 'r3', 'r4']}
>>> datacenter1['spines']
['r1', 'r2', 'r3', 'r4']
>>> datacenter1['leafs']
['l1', 'l2', 'l3', 'l4']
```

# 集合

**集合**用于包含无序的对象集合。与列表和元组不同，集合是无序的，不能通过数字索引。但是有一个特点使集合成为有用的：集合的元素永远不会重复。想象一下，您有一个需要放入访问列表中的 IP 列表。这个 IP 列表中唯一的问题是它们充满了重复项。现在，想象一下，您需要使用多少行代码来循环遍历 IP 列表，逐个筛选出唯一的项。然而，内置的集合类型只需要一行代码就可以消除重复的条目。老实说，我并不经常使用集合，但是当我需要它时，我总是非常感激它的存在。一旦创建了集合，它们可以使用并集、交集和差集进行比较：

```py
>>> a = "hello"
>>> set(a)
{'h', 'l', 'o', 'e'}
>>> b = set([1, 1, 2, 2, 3, 3, 4, 4])
>>> b
{1, 2, 3, 4}
>>> b.add(5)
>>> b
{1, 2, 3, 4, 5}
>>> b.update(['a', 'a', 'b', 'b'])
>>> b
{1, 2, 3, 4, 5, 'b', 'a'}
>>> a = set([1, 2, 3, 4, 5])
>>> b = set([4, 5, 6, 7, 8])
>>> a.intersection(b)
{4, 5}
>>> a.union(b)
{1, 2, 3, 4, 5, 6, 7, 8}
>>> 1 *
{1, 2, 3}
>>>
```

# Python 运算符

Python 有一些数字运算符，你会期望的；请注意截断除法（`//`，也称为**地板除法**）将结果截断为整数和浮点数，并返回整数值。取模（`%`）运算符返回除法中的余数值：

```py
>>> 1 + 2
3
>>> 2 - 1
1
>>> 1 * 5
5
>>> 5 / 1
5.0
>>> 5 // 2
2
>>> 5 % 2
1
```

还有比较运算符。请注意，双等号用于比较，单等号用于变量赋值：

```py
>>> a = 1
>>> b = 2
>>> a == b
False
>>> a > b
False
>>> a < b
True
>>> a <= b
True 
```

我们还可以使用两个常见的成员运算符来查看对象是否在序列类型中：

```py
>>> a = 'hello world'
>>> 'h' in a
True
>>> 'z' in a
False
>>> 'h' not in a
False
>>> 'z' not in a
True
```

# Python 控制流工具

`if`、`else`和`elif`语句控制条件代码的执行。正如你所期望的，条件语句的格式如下：

```py
if expression:
  do something
elif expression:
  do something if the expression meets
elif expression:
  do something if the expression meets
...
else:
  statement
```

这是一个简单的例子：

```py
>>> a = 10
>>> if a > 1:
...   print("a is larger than 1")
... elif a < 1:
...   print("a is smaller than 1")
... else:
...   print("a is equal to 1")
...
a is larger than 1
>>>
```

`while`循环将继续执行，直到条件为`false`，所以如果你不想继续执行（并且崩溃你的进程），请小心：

```py
while expression:
  do something
```

```py
>>> a = 10
>>> b = 1
>>> while b < a:
...   print(b)
...   b += 1
...
1
2
3
4
5
6
7
8
9
```

`for`循环适用于任何支持迭代的对象；这意味着所有内置的序列类型，如列表、元组和字符串，都可以在`for`循环中使用。下面`for`循环中的字母`i`是一个迭代变量，所以你通常可以在代码的上下文中选择一个有意义的东西：

```py
for i in sequence:
  do something
```

```py
>>> a = [100, 200, 300, 400]
>>> for number in a:
...   print(number)
...
100
200
300
400
```

你还可以创建自己的对象，支持迭代器协议，并能够为这个对象使用`for`循环。

构建这样一个对象超出了本章的范围，但这是有用的知识；你可以在[`docs.python.org/3/c-api/iter.html`](https://docs.python.org/3/c-api/iter.html)上阅读更多关于它的内容。

# Python 函数

大多数情况下，当你发现自己在复制和粘贴一些代码片段时，你应该将它们分解成一个自包含的函数块。这种做法可以实现更好的模块化，更容易维护，并允许代码重用。Python 函数是使用`def`关键字定义的，后面跟着函数名和函数参数。函数的主体由要执行的 Python 语句组成。在函数的末尾，你可以选择向函数调用者返回一个值，或者默认情况下，如果你没有指定返回值，它将返回`None`对象：

```py
def name(parameter1, parameter2):
  statements
  return value
```

在接下来的章节中，我们将看到更多的函数示例，所以这里是一个快速的例子：

```py
>>> def subtract(a, b):
...   c = a - b
...   return c
...
>>> result = subtract(10, 5)
>>> result
5
>>>
```

# Python 类

Python 是一种**面向对象编程**（**OOP**）语言。Python 创建对象的方式是使用`class`关键字。Python 对象通常是函数（方法）、变量和属性（属性）的集合。一旦类被定义，你就可以创建这样一个类的实例。类作为后续实例的蓝图。

OOP 的主题超出了本章的范围，所以这里是一个`router`对象定义的简单例子：

```py
>>> class router(object):
...   def __init__(self, name, interface_number,
vendor):
...     self.name = name
...     self.interface_number = interface_number
...     self.vendor = vendor
...
>>>
```

一旦定义，你就可以创建任意数量的该类的实例：

```py
>>> r1 = router("SFO1-R1", 64, "Cisco")
>>> r1.name
'SFO1-R1'
>>> r1.interface_number
64
>>> r1.vendor
'Cisco'
>>>
>>> r2 = router("LAX-R2", 32, "Juniper")
>>> r2.name
'LAX-R2'
>>> r2.interface_number
32
>>> r2.vendor
'Juniper'
>>>
```

当然，Python 对象和 OOP 还有很多内容。我们将在以后的章节中看到更多的例子。

# Python 模块和包

任何 Python 源文件都可以用作模块，你在该源文件中定义的任何函数和类都可以被重用。要加载代码，引用模块的文件需要使用`import`关键字。当文件被导入时会发生三件事：

1.  文件为源文件中定义的对象创建了一个新的命名空间

1.  调用者执行模块中包含的所有代码

1.  文件在调用者内创建一个指向被导入模块的名称。名称与模块的名称匹配

还记得你在交互式 shell 中定义的`subtract()`函数吗？为了重用这个函数，我们可以把它放到一个名为`subtract.py`的文件中：

```py
def subtract(a, b):
  c = a - b
  return c
```

在`subtract.py`的同一目录中的文件中，你可以启动 Python 解释器并导入这个函数：

```py
Python 2.7.12 (default, Nov 19 2016, 06:48:10)
[GCC 5.4.0 20160609] on linux2
Type "help", "copyright", "credits" or "license" for  
more information.
>>> import subtract
>>> result = subtract.subtract(10, 5)
>>> result
5
```

这是因为默认情况下，Python 首先会在当前目录中搜索可用的模块。如果你在不同的目录中，你可以使用`sys`模块和`sys.path`手动添加搜索路径位置。还记得我们之前提到的标准库吗？你猜对了，那些只是作为模块使用的 Python 文件。

包允许将一组模块组合在一起。这进一步将 Python 模块组织成更具命名空间保护的可重用性。包是通过创建一个希望用作命名空间的名称的目录来定义的，然后可以将模块源文件放在该目录下。为了让 Python 将其识别为 Python 包，只需在该目录中创建一个`__init__.py`文件。在与`subtract.py`文件相同的示例中，如果你创建一个名为`math_stuff`的目录并创建一个`__init__.py`文件：

```py
echou@pythonicNeteng:~/Master_Python_Networking/
Chapter1$ mkdir math_stuff
echou@pythonicNeteng:~/Master_Python_Networking/
Chapter1$ touch math_stuff/__init__.py
echou@pythonicNeteng:~/Master_Python_Networking/
Chapter1$ tree .
.
├── helloworld.py
└── math_stuff
 ├── __init__.py
 └── subtract.py

1 directory, 3 files
echou@pythonicNeteng:~/Master_Python_Networking/
Chapter1$
```

现在你将引用模块时需要包括包名：

```py
>>> from math_stuff.subtract import subtract
>>> result = subtract(10, 5)
>>> result
5
>>>
```

正如你所看到的，模块和包是组织大型代码文件并使共享 Python 代码变得更加容易的好方法。

# 总结

在本章中，我们介绍了 OSI 模型并回顾了网络协议套件，如 TCP、UDP 和 IP。它们作为处理任意两个主机之间的寻址和通信协商的层。这些协议在设计时考虑了可扩展性，并且基本上没有从其原始设计中改变。考虑到互联网的爆炸性增长，这是相当了不起的成就。

我们还快速回顾了 Python 语言，包括内置类型、运算符、控制流、函数、类、模块和包。Python 是一种功能强大、适合生产的语言，同时也很容易阅读。这使得 Python 成为网络自动化的理想选择。网络工程师可以利用 Python 从简单的脚本开始，逐渐转向其他高级特性。

在第二章中，*低级网络设备交互*，我们将开始学习如何使用 Python 与网络设备进行编程交互。
