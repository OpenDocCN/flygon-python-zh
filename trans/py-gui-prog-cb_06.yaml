- en: Chapter 6. Threads and Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。线程和网络
- en: In this chapter, we will create threads, queues, and TCP/IP sockets using Python
    3.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Python 3创建线程、队列和TCP/IP套接字。
- en: How to create multiple threads
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建多个线程
- en: Starting a thread
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动一个线程
- en: Stopping a thread
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止一个线程
- en: How to use queues
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用队列
- en: Passing queues among different modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同模块之间传递队列
- en: Using dialog widgets to copy files to your network
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对话框小部件将文件复制到您的网络
- en: Using TCP/IP to communicate via networks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TCP/IP通过网络进行通信
- en: Using URLOpen to read data from websites
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用URLOpen从网站读取数据
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will extend the functionality of our Python GUI using threads,
    queues, and network connections.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用线程、队列和网络连接扩展我们的Python GUI的功能。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A tkinter GUI is single-threaded. Every function that involves sleep or wait
    time has to be called in a separate thread, otherwise the tkinter GUI freezes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: tkinter GUI是单线程的。每个涉及休眠或等待时间的函数都必须在单独的线程中调用，否则tkinter GUI会冻结。
- en: When we run our Python GUI in Windows Task Manager, we can see that a new `python.exe`
    process has been launched.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Windows任务管理器中运行我们的Python GUI时，我们可以看到一个新的`python.exe`进程已经启动。
- en: When we give our Python GUI a `.pyw` extension, then the process created will
    be `python.pyw`, as can be seen in Task Manager.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们给我们的Python GUI一个`.pyw`扩展名时，然后创建的进程将是`python.pyw`，可以在任务管理器中看到。
- en: When a process is created, the process automatically creates a main thread to
    run our application. This is called a single-threaded application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个进程时，该进程会自动创建一个主线程来运行我们的应用程序。这被称为单线程应用程序。
- en: For our Python GUI, a single-threaded application will lead to our GUI becoming
    frozen as soon as we call a longer-running task such as clicking a button that
    has a sleep of a few seconds.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的Python GUI，单线程应用程序将导致我们的GUI在调用较长时间的任务时变得冻结，比如点击一个有几秒钟休眠的按钮。
- en: In order to keep our GUI responsive we have to use multi-threading, and this
    is what we will study in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的GUI响应，我们必须使用多线程，这就是我们将在本章中学习的内容。
- en: We can also create multiple processes by creating multiple instances of our
    Python GUI, as can be seen in Task Manager.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过创建多个Python GUI的实例来创建多个进程，可以在任务管理器中看到。
- en: Processes are isolated by design from each other and do not share common data.
    In order to communicate between separate processes we would have to use **Inter-Process-Communication**
    (**IPC**), which is an advanced technique.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 进程在设计上是相互隔离的，彼此不共享公共数据。为了在不同进程之间进行通信，我们必须使用**进程间通信**（**IPC**），这是一种高级技术。
- en: Threads, on the other hand, do share common data, code, and files, which makes
    communication between threads within the same process much easier than when using
    IPC.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，线程确实共享公共数据、代码和文件，这使得在同一进程内的线程之间的通信比使用IPC更容易。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A great explanation of threads can be found at: [https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关于线程的很好的解释可以在这里找到：[https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html](https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html)
- en: In this chapter, we will learn how to keep our Python GUI responsive and not
    to freeze.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何保持我们的Python GUI响应，并且不会冻结。
- en: How to create multiple threads
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何创建多个线程
- en: We will create multiple threads using Python. This is necessary in order to
    keep our GUI responsive.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python创建多个线程。这是为了保持我们的GUI响应而必要的。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A thread is like weaving a fabric made out of yarn and is nothing to be afraid
    of.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 线程就像编织由纱线制成的织物，没有什么可害怕的。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Multiple threads run within the same computer process memory space. There is
    no need for Inter-Process-Communication (aka IPC), which would complicate our
    code. In this recipe, we will avoid IPC by using threads.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 多个线程在同一计算机进程内存空间内运行。不需要进程间通信（IPC），这会使我们的代码变得复杂。在本节中，我们将通过使用线程来避免IPC。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First we will increase the size of our `ScrolledText` widget, making it larger.
    Let's increase `scrolW` to 40 and `scrolH` to 10.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将增加我们的`ScrolledText`小部件的大小，使其更大。让我们将`scrolW`增加到40，`scrolH`增加到10。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When we now run the resulting GUI, the `Spinbox` widget is center-aligned in
    relation to the `Entry` widget above it, which does not look good. We'll change
    this by left-aligning the widget.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在运行结果的GUI时，`Spinbox`小部件相对于其上方的`Entry`小部件是居中对齐的，这看起来不好。我们将通过左对齐小部件来改变这一点。
- en: Add `sticky='W'` to the `grid` control to left-align the `Spinbox` widget.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`grid`控件中添加`sticky='W'`，以左对齐`Spinbox`小部件。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The GUI could still look better, so next, we will increase the size of the `Entry`
    widget to get a more balanced GUI layout.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: GUI可能看起来还不错，所以下一步，我们将增加`Entry`小部件的大小，以获得更平衡的GUI布局。
- en: 'Increase the width to 24, as shown in the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将宽度增加到24，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let us also slightly increase the width of the `Combobox` to 14.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也稍微增加`Combobox`的宽度到14。
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Running the modified and improved code results in a larger GUI, which we will
    use for this and the following recipes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 运行修改和改进的代码会导致一个更大的GUI，我们将在本节和下一节中使用它。
- en: '![How to do it...](graphics/B04829_06_01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_01.jpg)'
- en: In order to create and use threads in Python, we have to import the `Thread`
    class from the threading module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python中创建和使用线程，我们必须从threading模块中导入`Thread`类。
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's add a method to be created in a thread to our `OOP` class.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`OOP`类中添加一个在线程中创建的方法。
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can now call our threaded method in the code, saving the instance in a variable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在代码中调用我们的线程方法，将实例保存在一个变量中。
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now we have a method that is threaded, but when we run the code, nothing gets
    printed to the console!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个线程化的方法，但当我们运行代码时，控制台上什么都没有打印出来！
- en: We have to start the `Thread` first before it can run and the next recipe will
    show us how to do this.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须先启动`Thread`，然后它才能运行，下一节将向我们展示如何做到这一点。
- en: However, setting a breakpoint after the GUI main event loop proves that we did
    indeed create a `Thread` object, as can been seen in the Eclipse IDE Debugger.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在GUI主事件循环之后设置断点证明我们确实创建了一个`Thread`对象，这可以在Eclipse IDE调试器中看到。
- en: '![How to do it...](graphics/B04829_06_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_02.jpg)'
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we prepared our GUI to use threads by first increasing the GUI
    size, so we could better see the results printed to the `ScrolledText` widget.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们首先增加了GUI的大小，以便更好地看到打印到`ScrolledText`小部件中的结果，为了准备使用线程。
- en: We then imported the `Thread` class from the Python `threading` module.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从Python的`threading`模块中导入了`Thread`类。
- en: After that, we created a method that we call in a thread from within our GUI.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建了一个在GUI内部从线程中调用的方法。
- en: Starting a thread
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动线程
- en: This recipe will show us how to start a thread. It will also demonstrate why
    threads are necessary to keep our GUI responsive during long-running tasks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向我们展示如何启动一个线程。它还将演示为什么线程在长时间运行的任务期间保持我们的GUI响应是必要的。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's first see what happens when we call a function or method of our GUI that
    has some sleep associated with it without using threads.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看当我们调用一个带有一些休眠的函数或方法时会发生什么，而不使用线程。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are using a sleep here to simulate a real-world application that might have
    to wait for a web server or database to respond or a large file transfer or complex
    computation to complete its task.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用休眠来模拟一个现实世界的应用程序，该应用程序可能需要等待Web服务器或数据库响应，或者大文件传输或复杂计算完成其任务。
- en: The sleep is a very realistic place-holder and shows the principle involved.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 休眠是一个非常现实的占位符，并展示了涉及的原则。
- en: Adding a loop into our button callback method with some sleep time results in
    our GUI becoming unresponsive and, when we try to close the GUI, things get even
    worse.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的按钮回调方法中添加一个循环和一些休眠时间会导致我们的GUI变得无响应，当我们尝试关闭GUI时，情况变得更糟。
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Getting ready](graphics/B04829_06_03.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](graphics/B04829_06_03.jpg)'
- en: If we wait long enough, the method will eventually complete but during this
    time none of our GUI widgets respond to click events. We solve this problem by
    using threads.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们等待足够长的时间，方法最终会完成，但在此期间，我们的GUI小部件都不会响应点击事件。我们通过使用线程来解决这个问题。
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the previous recipe, we created a method to be run in a thread, but so far,
    the thread has not run!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中，我们创建了一个要在线程中运行的方法，但到目前为止，线程还没有运行！
- en: Unlike regular Python functions and methods, we have to `start` a method that
    is going to be run in its own thread!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规的Python函数和方法不同，我们必须`start`一个将在自己的线程中运行的方法！
- en: This is what we will do next.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们接下来要做的事情。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, let's move the creation of the thread into its own method and then call
    this method from the button callback method.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将线程的创建移到它自己的方法中，然后从按钮回调方法中调用这个方法。
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Clicking the button now results in the `createThread` method being called which,
    in turn, calls the `methodInAThread` method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击按钮会导致调用`createThread`方法，然后调用`methodInAThread`方法。
- en: First, we create a thread and target it at a method. Next, we start the thread
    that will run the targeted method in a new thread.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个线程并将其目标定位到一个方法。接下来，我们启动线程，该线程将在一个新线程中运行目标方法。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The GUI itself runs in its own thread, which is the main thread of the application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: GUI本身运行在它自己的线程中，这是应用程序的主线程。
- en: '![How to do it...](graphics/B04829_06_04.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_04.jpg)'
- en: We can print out the instance of the thread.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印出线程的实例。
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Clicking the button now creates the following printout:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在点击按钮会创建以下输出：
- en: '![How to do it...](graphics/B04829_06_05.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_05.jpg)'
- en: When we click the button several times, we can see that each thread gets assigned
    a unique name and ID.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击按钮多次时，我们可以看到每个线程都被分配了一个唯一的名称和ID。
- en: '![How to do it...](graphics/B04829_06_06.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_06.jpg)'
- en: Let's now move our code with the `sleep` in a loop into the `methodInAThread`
    method to verify that threads really do solve our problem.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将带有`sleep`的循环代码移到`methodInAThread`方法中，以验证线程确实解决了我们的问题。
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When clicking the button, while the numbers are being printed into the `ScrolledText`
    widget with a five second delay, we can click around anywhere in our GUI, switch
    tabs, and so on. Our GUI has become responsive again because we are using threads!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击按钮时，数字被打印到`ScrolledText`小部件中，间隔五秒，我们可以在GUI的任何地方点击，切换标签等。我们的GUI再次变得响应，因为我们正在使用线程！
- en: '![How to do it...](graphics/B04829_06_07.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_07.jpg)'
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we called methods of our GUI class in their own threads and
    learned that we have to start the threads. Otherwise, the thread gets created
    but just sits there waiting for us to run its target method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们在它们自己的线程中调用了GUI类的方法，并学会了我们必须启动这些线程。否则，线程会被创建，但只是坐在那里等待我们运行它的目标方法。
- en: We noticed that each thread gets assigned a unique name and ID.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到每个线程都被分配了一个唯一的名称和ID。
- en: We simulated long-running tasks by inserting a `sleep` statement into our code,
    which showed us that threads can indeed solve our problem.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在代码中插入`sleep`语句来模拟长时间运行的任务，这向我们表明线程确实可以解决我们的问题。
- en: Stopping a thread
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止线程
- en: We have to start a thread to actually make it do something by calling the `start()`
    method, so, intuitively, we would expect there to be a matching `stop()` method,
    but there is no such thing. In this recipe, we will learn how to run a thread
    as a background task, which is called a daemon. When closing the main thread,
    which is our GUI, all daemons will automatically be stopped as well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须启动一个线程来通过调用`start()`方法实际让它做一些事情，因此，直觉上，我们会期望有一个匹配的`stop()`方法，但实际上并没有这样的方法。在这个配方中，我们将学习如何将线程作为后台任务运行，这被称为守护线程。当关闭主线程，也就是我们的GUI时，所有守护线程也将自动停止。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: When we call methods in a thread, we can also pass arguments and keyword arguments
    to the method. We start this recipe by doing exactly that.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在线程中调用方法时，我们也可以向方法传递参数和关键字参数。我们首先通过这种方式开始这个示例。
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: By adding `args=[8]` to the thread constructor and modifying the targeted method
    to expect arguments, we can pass arguments to threaded methods. The parameter
    to `args` has to be a sequence, so we will wrap our number in a Python list.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在线程构造函数中添加`args=[8]`并修改目标方法以期望参数，我们可以向线程方法传递参数。`args`的参数必须是一个序列，所以我们将我们的数字包装在Python列表中。
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the following code, `runT` is a local variable which we only access within
    the scope of the method inside of which we created `runT`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，`runT`是一个局部变量，我们只能在创建`runT`的方法的范围内访问它。
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By turning the local variable into a member, we can then check if the thread
    is still running by calling `isAlive` on it from another method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将局部变量转换为成员变量，我们可以在另一个方法中调用`isAlive`来检查线程是否仍在运行。
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we have elevated our local `runT` variable to a member
    of our class. What this does is enable us to assess the `self.runT` variable from
    any method in our class.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将我们的局部变量`runT`提升为我们类的成员。这样做的效果是使我们能够从我们类的任何方法中评估`self.runT`变量。
- en: 'This is achieved like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过以下方式实现的：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we click the button and then exit the GUI, we can see that the print statement
    in the `createThread` method was printed, but we do not see the second print statement
    from `methodInAThread`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们单击按钮然后退出GUI时，我们可以看到`createThread`方法中的打印语句被打印出来，但我们看不到`methodInAThread`的第二个打印语句。
- en: Instead, we get a RuntimeError.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们会得到一个运行时错误。
- en: '![How to do it...](graphics/B04829_06_08.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_08.jpg)'
- en: Threads are expected to finish their assigned task so when we close the GUI
    while the thread has not completed, Python tells us that the thread we started
    is not in the main event loop.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 线程预期完成其分配的任务，因此当我们在线程尚未完成时关闭GUI时，Python告诉我们我们启动的线程不在主事件循环中。
- en: We can solve this by turning the thread into a daemon, which will then execute
    as a background task.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将线程转换为守护程序来解决这个问题，然后它将作为后台任务执行。
- en: What this gives us is that, as soon as we close our GUI, which is our main thread
    starting other threads, the daemon threads will cleanly exit.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们的是，一旦我们关闭我们的GUI，也就是我们的主线程启动其他线程，守护线程将干净地退出。
- en: We can do this by calling the `setDaemon(True)` method on the thread before
    we start the thread.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在启动线程之前调用`setDaemon(True)`方法来实现这一点。
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When we now click the button and exit our GUI while the thread has not yet completed
    its assigned task, we no longer get any errors.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在单击按钮并在线程尚未完成其分配的任务时退出我们的GUI时，我们不再收到任何错误。
- en: '![How to do it...](graphics/B04829_06_09.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_09.jpg)'
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: While there is a start method to make threads run, surprisingly there is not
    really an equivalent stop method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一个启动线程运行的方法，但令人惊讶的是，实际上并没有一个等效的停止方法。
- en: In this recipe, we are running a method in a thread, which prints numbers to
    our `ScrolledText` widget.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们正在一个线程中运行一个方法，该方法将数字打印到我们的`ScrolledText`小部件中。
- en: When we exit our GUI, we are no longer interested in the thread that used to
    print to our widget, so, by turning the thread into a background daemon, we can
    exit our GUI cleanly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们退出GUI时，我们不再对曾经向我们的小部件打印的线程感兴趣，因此，通过将线程转换为后台守护程序，我们可以干净地退出GUI。
- en: How to use queues
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用队列
- en: A Python queue is a data structure that implements the first-in-first-out paradigm,
    basically working like a pipe. You shovel something into the pipe on one side
    and it falls out on the other side of the pipe.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Python队列是一种实现先进先出范例的数据结构，基本上就像一个管道一样工作。你把东西塞进管道的一端，它就从管道的另一端掉出来。
- en: The main difference between this queue shoveling, and shoveling mud into physical
    pipes is that, in Python queues, things do not get mixed up. You put one unit
    in, and that unit comes back out on the other side. Next, you place another unit
    in (say, for example, an instance of a class), and this entire unit will come
    back out on the other end as one integral piece.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种队列填充和填充泥浆到物理管道的主要区别在于，在Python队列中，事情不会混在一起。你放一个单位进去，那个单位就会从另一边出来。接下来，你放另一个单位进去（比如，例如，一个类的实例），整个单位将作为一个完整的整体从另一端出来。
- en: It comes back out at the other end in the exact order we inserted code into
    the queue.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 它以我们插入代码到队列的确切顺序从另一端出来。
- en: Note
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A queue is not a stack where we push and pop data. A stack is a last-in-first-out
    (LIFO) data structure.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 队列不是一个我们推送和弹出数据的堆栈。堆栈是一个后进先出（LIFO）的数据结构。
- en: Queues are containers that hold data being fed into the queue from potentially
    different data sources. We can have different clients providing data to the queue
    whenever those clients have data available. Whichever client is ready to send
    data to our queue sends it, and we can then display this data in a widget or send
    it forward to other modules.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是容器，用于保存从潜在不同数据源输入队列的数据。我们可以有不同的客户端在有数据可用时向队列提供数据。无论哪个客户端准备好向我们的队列发送数据，我们都可以显示这些数据在小部件中或将其转发到其他模块。
- en: Using multiple threads to complete assigned tasks in a queue is very useful
    when receiving the final results of the processing and displaying them. The data
    is inserted at one end of the queue and then comes out of the other end in an
    ordered fashion, First-In-First-Out (FIFO).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在队列中使用多个线程完成分配的任务在接收处理的最终结果并显示它们时非常有用。数据被插入到队列的一端，然后以有序的方式从另一端出来，先进先出（FIFO）。
- en: Our GUI might have five different button widgets that each kick off different
    tasks that we want to display in our GUI in a widget (for example, a ScrolledText
    widget).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的GUI可能有五个不同的按钮小部件，每个按钮小部件都会启动我们想要在小部件中显示的不同任务（例如，一个ScrolledText小部件）。
- en: These five different tasks take a different amount of time to complete.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个不同的任务完成所需的时间不同。
- en: Whenever a task has completed, we immediately need to know this and display
    this information in our GUI.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个任务完成时，我们立即需要知道这一点，并在我们的GUI中显示这些信息。
- en: By creating a shared Python queue and having the five tasks write their results
    to this queue, we can display the result of whatever task has been completed immediately
    using a FIFO approach.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个共享的Python队列，并让五个任务将它们的结果写入这个队列，我们可以使用FIFO方法立即显示已完成的任务的结果。
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As our GUI is ever increasing in its functionality and usefulness, it starts
    to talk to networks, processes, and websites, and will eventually have to wait
    for data to be made available for the GUI to represent.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的GUI在功能和实用性上不断增加，它开始与网络、进程和网站进行通信，并最终必须等待数据可用于GUI表示。
- en: Creating queues in Python solves the problem of waiting for data to be displayed
    inside our GUI.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中创建队列解决了等待数据在我们的GUI中显示的问题。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In order to create queues in Python, we have to import the `Queue` class from
    the `queue` module. Add the following statement towards the top of our GUI module:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python中创建队列，我们必须从“queue”模块导入“Queue”类。在我们的GUI模块的顶部添加以下语句：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That gets us started.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们开始了。
- en: Next, we create a queue instance.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个队列实例。
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding code we create a local `Queue` instance that is only accessible
    within this method. If we wish to access this queue from other places, we have
    to turn it into a member of our class by using the `self` keyword which binds
    the local variable to the entire class, making it available from any other method
    within our class. In Python, we often create class instance variables in the `__init__(self)`
    method but Python is very pragmatic and enables us to create those member variables
    anywhere in the code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个本地的“队列”实例，只能在这个方法中访问。如果我们希望从其他地方访问这个队列，我们必须使用“self”关键字将其转换为我们的类的成员，这将本地变量绑定到整个类，使其可以在类中的任何其他方法中使用。在Python中，我们经常在“__init__(self)”方法中创建类实例变量，但Python非常实用，使我们能够在代码中的任何地方创建这些成员变量。
- en: Now we have an instance of a queue. We can prove that this works by printing
    it out.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个队列的实例。我们可以通过打印它来证明它有效。
- en: '![How to do it...](graphics/B04829_06_10.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_10.jpg)'
- en: In order to put data into the queue, we use the `put` command. In order to get
    data out of the queue, we use the `get` command.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据放入队列，我们使用“put”命令。为了从队列中取出数据，我们使用“get”命令。
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running the modified code results in the message first being placed in the `Queue`,
    and then being taken out of the `Queue`, and then printed to the console.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 运行修改后的代码会导致消息首先被放入“队列”，然后被从“队列”中取出，并打印到控制台。
- en: '![How to do it...](graphics/B04829_06_11.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_11.jpg)'
- en: We can place many messages into the queue.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将许多消息放入队列。
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have placed 10 messages into the `Queue`, but we are only getting the first
    one out. The other messages are still inside of the `Queue`, waiting to be taken
    out in a FIFO fashion.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将10条消息放入了“队列”，但我们只取出了第一条。其他消息仍然在“队列”内，等待以FIFO方式取出。
- en: '![How to do it...](graphics/B04829_06_12.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_12.jpg)'
- en: In order to get all messages that have been placed into a `Queue` out, we can
    create an endless loop.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了取出放入“队列”的所有消息，我们可以创建一个无限循环。
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![How to do it...](graphics/B04829_06_13.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_13.jpg)'
- en: While this code works, unfortunately it freezes our GUI. In order to fix this,
    we have to call the method in its own thread, as we did in previous recipes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码有效，但不幸的是它冻结了我们的GUI。为了解决这个问题，我们必须在自己的线程中调用该方法，就像我们在之前的示例中所做的那样。
- en: 'Let''s run our method in a thread and tie it to the button event:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个线程中运行我们的方法，并将其绑定到按钮事件：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we now click the action `Button`, we no longer get an extraneous pop-up
    window and the code works.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在点击“按钮”时，我们不再会得到一个多余的弹出窗口，代码也能正常工作。
- en: '![How to do it...](graphics/B04829_06_14.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_14.jpg)'
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have created a `Queue`, placed messages into one side of the `Queue` in a
    first-in-first-out (aka FIFO) fashion. We got the messages out of the `Queue`
    and then printed them to the console (stdout).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个“队列”，以FIFO（先进先出）的方式将消息放入队列的一侧。我们从“队列”中取出消息，然后将其打印到控制台（stdout）。
- en: We realized that we have to call the method in its own `Thread`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们意识到我们必须在自己的“线程”中调用该方法。
- en: Passing queues among different modules
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同模块之间传递队列
- en: In this recipe, we will pass `Queues` around different modules. As our GUI code
    increases in complexity, we want to separate the GUI components from the business
    logic, separating them out into different modules.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将在不同的模块之间传递“队列”。随着我们的GUI代码变得越来越复杂，我们希望将GUI组件与业务逻辑分离，将它们分离到不同的模块中。
- en: Modularization gives us code reuse and also makes the code more readable.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化使我们可以重用代码，并使代码更易读。
- en: Once the data to be displayed in our GUI comes from different data sources,
    we will face latency issues, which is what `Queues` solve. By passing instances
    of `Queues` among different Python modules, we are separating the different concerns
    of the modules' functionalities.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦要在我们的GUI中显示的数据来自不同的数据源，我们将面临延迟问题，这就是“队列”解决的问题。通过在不同的Python模块之间传递“队列”的实例，我们正在分离模块功能的不同关注点。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The GUI code ideally would only be concerned with creating and displaying widgets.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: GUI代码理想情况下只关注创建和显示小部件。
- en: The business logic modules' job is to only do the business logic.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑模块的工作只是执行业务逻辑。
- en: We have to combine the two elements, ideally using as few relations among the
    different modules, reducing code interdependence.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将这两个元素结合起来，理想情况下在不同模块之间尽可能少地使用关系，减少代码的相互依赖。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The coding principle of avoiding unnecessary dependencies is usually called
    "loose coupling".
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 避免不必要依赖的编码原则通常被称为“松耦合”。
- en: In order to understand the significance of loose coupling, we can draw some
    boxes on a whiteboard or a piece of paper. One box represents our GUI class and
    code, while the other boxes represent business logic, databases, and so on.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解松散耦合的重要性，我们可以在白板或纸上画一些框。一个框代表我们的GUI类和代码，而其他框代表业务逻辑、数据库等。
- en: Next, we draw lines between the boxes, graphing out the interdependencies between
    those boxes which are our Python modules.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在框之间画线，绘制出这些框之间的相互依赖关系，这些框是我们的Python模块。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The fewer lines we have between our Python boxes, the more loosely-coupled our
    design is.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Python框之间的行数越少，我们的设计就越松散耦合。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the previous recipe, we have started to use `Queues`. In this recipe we will
    pass instances of a `Queue` from our main GUI thread to other Python modules,
    which will enable us to write to the `ScrolledText` widget from another module
    while keeping our GUI responsive.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们已经开始使用`Queues`。在这个示例中，我们将从我们的主GUI线程传递`Queue`的实例到其他Python模块，这将使我们能够从另一个模块向`ScrolledText`小部件写入内容，同时保持我们的GUI响应。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, we create a new Python module in our project. Let's call it `Queues.py`.
    We'll place a function into it (no OOP necessary yet) and pass it an instance
    of the queue.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的项目中创建一个新的Python模块。让我们称之为`Queues.py`。我们将在其中放置一个函数（暂时不需要OOP），并将队列的一个实例传递给它。
- en: We also pass a self-reference of the class that creates the GUI form and widgets,
    which enables us to use all of the GUI methods from another Python module.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还传递了创建GUI表单和小部件的类的自引用，这使我们能够从另一个Python模块中使用所有GUI方法。
- en: We do this in the button callback.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在按钮回调中这样做。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is the magic of OOP. In the middle of a class, we pass ourselves into a
    function we are calling from within the class, using the `self` keyword.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是面向对象编程的魔力。在类的中间，我们将自己传递给类内部调用的函数，使用`self`关键字。
- en: The code now looks like this.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码看起来像这样。
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The imported module contains the function we are calling,
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 导入的模块包含我们正在调用的函数，
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have commented out the call to `createThread` in the button callback because
    we are now calling it from our new module.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在按钮回调中注释掉了对`createThread`的调用，因为我们现在是从我们的新模块中调用它。
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By passing in a self-reference from the class instance to the function the class
    is calling in another module, we now have access to all of our GUI elements from
    other Python modules.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从类实例向另一个模块中的函数传递自引用，我们现在可以从其他Python模块访问所有GUI元素。
- en: Running the code creates the following result.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会创建以下结果。
- en: '![How to do it...](graphics/B04829_06_15.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_15.jpg)'
- en: Next, we will create the `Queue` as a member of our class, placing a reference
    to it in the `__init__` method of the class.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`Queue`作为我们类的成员，并将对它的引用放在类的`__init__`方法中。
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now we can put messages into the queue from our new module by simply using the
    passed-in class reference to our GUI.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过简单地使用传入的类引用将消息放入队列中。
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `createThread` method in our GUI code now only reads from the queue, which
    got filled in by the business logic residing in our new module, which has separated
    the logic from our GUI module.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们GUI代码中的`createThread`方法现在只从队列中读取数据，这些数据是由我们新模块中的业务逻辑填充的，这样就将逻辑与我们的GUI模块分离开来了。
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Running our modified code creates the same results. We have not broken anything
    (yet)!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们修改后的代码会产生相同的结果。我们没有破坏任何东西（至少目前没有）！
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to separate the GUI widgets from the functionality that expresses the
    business logic, we created a class, made a queue a member of this class and, by
    passing an instance of the class into a function residing in a different Python
    module, we now have access to all of the GUI widgets as well as the `Queue`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将GUI小部件与表达业务逻辑的功能分开，我们创建了一个类，将队列作为这个类的成员，并通过将类的实例传递到不同Python模块中的函数中，我们现在可以访问所有GUI小部件以及`Queue`。
- en: This recipe is an example of when it makes sense to program in OOP.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是一个使用面向对象编程的合理情况的例子。
- en: Using dialog widgets to copy files to your network
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对话框小部件将文件复制到您的网络
- en: This recipe shows us how to copy files from your local hard drive to a network
    location.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例向我们展示了如何将文件从本地硬盘复制到网络位置。
- en: We will do this by using one of Python's tkinter built-in dialogs, which enables
    us to browse our hard drive. We can then select a file to be copied.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python的tkinter内置对话框之一，这使我们能够浏览我们的硬盘。然后我们可以选择要复制的文件。
- en: This recipe also shows us how to make `Entry` widgets read-only and to default
    our `Entry` to a specified location, which speeds up the browsing of our hard
    drive.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例还向我们展示了如何使`Entry`小部件只读，并将我们的`Entry`默认设置为指定位置，这样可以加快浏览我们的硬盘的速度。
- en: Getting ready
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will extend **Tab 2** of the GUI we have been building in previous recipes.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展我们在之前示例中构建的GUI的**Tab 2**。
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Add the following code to our GUI in the `def createWidgets(self)` method towards
    the bottom where we created Tab Control 2.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到我们的GUI中`def createWidgets(self)`方法中，放在我们创建Tab Control 2的底部。
- en: The parent of the new widget frame is `tab2`, which we have created at the very
    beginning of the `createWidgets()` method. As long as you place the code shown
    as follows physically below the creation of `tab2`, it will work.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 新小部件框的父级是`tab2`，我们在`createWidgets()`方法的开头创建了它。只要您将下面显示的代码放在`tab2`的创建物理下方，它就会起作用。
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will add two buttons and two entries to **Tab 2** of our GUI.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的GUI的**Tab 2**中添加两个按钮和两个输入。
- en: We are not yet implementing the functionality of our button callback function.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有实现按钮回调函数的功能。
- en: 'Running the code creates the following GUI:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会创建以下GUI：
- en: '![How to do it...](graphics/B04829_06_16.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_16.jpg)'
- en: Clicking the **Browse to File…** button currently prints to the console.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**浏览文件...**按钮目前会在控制台上打印。
- en: '![How to do it...](graphics/B04829_06_17.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_17.jpg)'
- en: We can use tkinter's built-in file dialogs so let's add the following `import`
    statements to the top of our Python GUI module.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用tkinter的内置文件对话框，所以让我们在我们的Python GUI模块的顶部添加以下`import`语句。
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can now use the dialogs in our code. Instead of hard-coding a path, we can
    use Python's os module to find the full path to where our GUI module resides.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在我们的代码中使用对话框。我们可以使用Python的os模块来查找GUI模块所在的完整路径，而不是硬编码路径。
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Clicking the browse button now opens up the `askopenfilename` dialog.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 单击浏览按钮现在会打开`askopenfilename`对话框。
- en: '![How to do it...](graphics/B04829_06_18.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_18.jpg)'
- en: We can now open a file in this directory or browse to a different directory.
    After selecting a file and clicking the **Open** button in the dialog, we will
    save the full path to the file in the `fName` local variable.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在这个目录中打开一个文件，或者浏览到另一个目录。在对话框中选择一个文件并单击**打开**按钮后，我们将保存文件的完整路径在`fName`本地变量中。
- en: It would be nice if, when we opened our Python `askopenfilename` dialog widget,
    we would automatically default to a directory so that we would not have to browse
    all the way to where we were looking for a particular file to be opened.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开我们的Python `askopenfilename`对话框小部件时，能够自动默认到一个目录，这将是很好的，这样我们就不必一直浏览到我们正在寻找的特定文件要打开的地方。
- en: It is best to demonstrate how to do this by going back to our GUI **Tab 1**,
    which is what we will do next.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最好通过回到我们的GUI **Tab 1**来演示如何做到这一点，这就是我们接下来要做的。
- en: We can default values into Entry widgets. Back on our **Tab 1**, this is very
    easy. All we have to do is add the following two lines of code to the creation
    of the `Entry` widget.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将默认值输入到Entry小部件中。回到我们的**Tab 1**，这非常容易。我们只需要在创建`Entry`小部件时添加以下两行代码即可。
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When we now run the GUI, the `nameEntered` Entry has a default value.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在运行GUI时，`nameEntered`输入框有一个默认值。
- en: '![How to do it...](graphics/B04829_06_19.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_19.jpg)'
- en: We can get the full path to the module we are using with the following Python
    syntax and then we can create a new subfolder just below it. We can do this as
    a module level global, or we can create the subfolder within a method.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下Python语法获取我们正在使用的模块的完整路径，然后我们可以在其下创建一个新的子文件夹。我们可以将其作为模块级全局变量，或者我们可以在方法中创建子文件夹。
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We are setting defaults for both entry widgets and, after setting them, we make
    the local file entry widget read-only.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为两个输入小部件设置默认值，并在设置它们后，将本地文件输入小部件设置为只读。
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This order is important. We have to first populate the entry before we make
    it read-only.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个顺序很重要。我们必须先填充输入框，然后再将其设置为只读。
- en: We are also selecting **Tab 2** before calling the main event loop and no longer
    set the focus into the `Entry` of **Tab 1**. Calling `select` on our tkinter `notebook`
    is zero-based so by passing in the value of 1 we select **Tab 2**…
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用主事件循环之前，我们还选择**Tab 2**，不再将焦点设置到**Tab 1**的`Entry`中。在我们的tkinter `notebook`上调用`select`是从零开始的，所以通过传入值1，我们选择**Tab
    2**...
- en: '[PRE33]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![How to do it...](graphics/B04829_06_20.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_20.jpg)'
- en: As we are not all on the same network, this recipe will use the local hard drive
    as an example for a network.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不都在同一个网络上，这个示例将使用本地硬盘作为网络的示例。
- en: A UNC path is a Universal Naming Convention and what this means is that we can
    access a server on our network by using double backslashes to access a network
    server instead of the typical `C:\` when we access our local hard drive on a Windows
    PC.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: UNC路径是通用命名约定，这意味着我们可以通过双反斜杠访问网络服务器，而不是在访问Windows PC上的本地硬盘时使用典型的`C:\`。
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You just have to use the UNC and replace `C:\` with `\\<server name> \<folder>\`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要使用UNC，并用`\\<server name> \<folder>\`替换`C:\`。
- en: This example can be used to back up our code to a backup directory, which we
    can create if it does not exist by using `os.makedirs`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以用来将我们的代码备份到一个备份目录，如果不存在，我们可以使用`os.makedirs`来创建它。
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After selecting a file to copy to somewhere else, we import the Python `shutil`
    module. We need the full path to the source of the file to be copied, a network
    or local directory path, and then we append the file name to the path where we
    are going to copy it, using `shutil.copy`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择要复制到其他地方的文件后，我们导入Python的`shutil`模块。我们需要文件源的完整路径，一个网络或本地目录路径，然后我们使用`shutil.copy`将文件名附加到我们将要复制的路径上。
- en: Note
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Shutil is short-hand notation for shell utility.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Shutil是shell utility的简写。
- en: We also give feedback to the user via a message box to indicate whether the
    copying succeeded or failed. In order to do this, import `messagebox` and rename
    it `mBox`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过消息框向用户提供反馈，指示复制是否成功或失败。为了做到这一点，导入`messagebox`并将其重命名为`mBox`。
- en: In the following code, we will mix two different approaches of where to place
    our import statements. In Python, we have some flexibility that other languages
    do not provide.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将混合两种不同的方法来放置我们的导入语句。在Python中，我们有一些其他语言不提供的灵活性。
- en: We typically place all of the import statements towards the very top of each
    of our Python modules so that it is clear which modules we are importing.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将所有的导入语句放在每个Python模块的顶部，这样可以清楚地看出我们正在导入哪些模块。
- en: At the same time, a modern coding approach is to place the creation of variables
    close to the function or method where they are first being used.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，现代编码方法是将变量的创建放在首次使用它们的函数或方法附近。
- en: In the following code, we import the message box at the top of our Python module,
    but then we also import the shutil Python module in a function.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们在Python模块的顶部导入了消息框，然后在一个函数中也导入了shutil Python模块。
- en: Why would we wish to do this?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要这样做呢？
- en: Does this even work?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会起作用吗？
- en: The answer is, yes, it does work, and we are placing this import statement into
    a function because this is the only place in our code where we actually do need
    this module.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，是的，它确实有效，我们将这个导入语句放在一个函数中，因为这是我们的代码中唯一需要这个模块的地方。
- en: If we never call this method, then we will never import the module this method
    requires.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从不调用这个方法，那么我们将永远不会导入这个方法所需的模块。
- en: In a sense, you can view this technique as the lazy initialization design pattern.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，您可以将这种技术视为惰性初始化设计模式。
- en: If we don't need it, we don't import it until we really do require it in our
    Python code.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要它，我们就不会在Python代码中导入它，直到我们真正需要它。
- en: The idea here is that our entire code might require, let's say, twenty different
    modules. At runtime, which modules are really needed depends upon the user interaction.
    If we never call the `copyFile()` function then there is no need to import `shutil`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是，我们的整个代码可能需要，比如说，二十个不同的模块。在运行时，真正需要哪些模块取决于用户的交互。如果我们从未调用`copyFile()`函数，那么就没有必要导入`shutil`。
- en: Once we click the button that invokes the `copyFile()` function in this function,
    we import the required module.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们点击调用`copyFile()`函数的按钮，在这个函数中，我们就导入了所需的模块。
- en: '[PRE35]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When we now run our GUI and browse to a file and click copy, the file is copied
    to the location we specified in our `Entry` widget.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在运行我们的GUI并浏览到一个文件并点击复制时，文件将被复制到我们在`Entry`小部件中指定的位置。
- en: '![How to do it...](graphics/B04829_06_21.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_21.jpg)'
- en: If the file does not exist or we forgot to browse to a file and are trying to
    copy the entire parent folder, the code will let us know this as well because
    we are using Python's built-in exception handling capabilities.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件不存在，或者我们忘记浏览文件并尝试复制整个父文件夹，代码也会让我们知道，因为我们使用了Python的内置异常处理能力。
- en: '![How to do it...](graphics/B04829_06_22.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_06_22.jpg)'
- en: How it works...
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We are copying files from our local hard drive to a network by using the Python
    shell utility. As most of us are not connected to the same local area network,
    we simulate the copying by backing up our code to a different local folder.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Python shell实用程序将文件从本地硬盘复制到网络。由于大多数人都没有连接到相同的局域网，我们通过将代码备份到不同的本地文件夹来模拟复制。
- en: We are using one of tkinter's dialog controls and, by defaulting directory paths,
    we can increase our efficiency in copying files.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用tkinter的对话框控件，并且通过默认目录路径，我们可以提高复制文件的效率。
- en: Using TCP/IP to communicate via networks
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TCP/IP通过网络进行通信
- en: This recipe shows you how to use sockets to communicate via TCP/IP. In order
    to achieve this, we need both an IP address and a port number.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例向您展示了如何使用套接字通过TCP/IP进行通信。为了实现这一点，我们需要IP地址和端口号。
- en: In order to keep things simple and independent of the ever-changing internet
    IP addresses, we will create our own local TCP/IP server and, as a client, learn
    how to connect to it and read data from a TCP/IP connection.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单并独立于不断变化的互联网IP地址，我们将创建自己的本地TCP/IP服务器，并作为客户端，学习如何连接到它并从TCP/IP连接中读取数据。
- en: We will integrate this networking capability into our GUI by using the queues
    we created in previous recipes.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用我们在以前的示例中创建的队列，将这种网络功能集成到我们的GUI中。
- en: Getting ready
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a new Python module, which will be the TCP server.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的Python模块，它将是TCP服务器。
- en: How to do it...
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: One way to implement a TCP server in Python is to inherit from the `socketserver`
    module. We subclass `BaseRequestHandler` and then override the inherited `handle`
    method. In very few lines of Python code, we can implement a TCP server module.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中实现TCP服务器的一种方法是从`socketserver`模块继承。我们子类化`BaseRequestHandler`，然后覆盖继承的`handle`方法。在很少的Python代码行中，我们可以实现一个TCP服务器模块。
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We are passing in our `RequestHandler` class into a `TCPServer` initializer.
    The empty single quotes are a short cut for passing in localhost, which is our
    own PC. This is the IP address of 127.0.0.1\. The second item in the tuple is
    the port number. We can choose any port number that is not in use on our local
    PC.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的`RequestHandler`类传递给`TCPServer`初始化程序。空的单引号是传递本地主机的快捷方式，这是我们自己的PC。这是IP地址127.0.0.1的IP地址。元组中的第二项是端口号。我们可以选择任何在本地PC上未使用的端口号。
- en: We just have to make sure that we are using the same port on the client side
    of the TCP connection, otherwise we would not be able to connect to the server.
    Of course, we have to start the server first before clients can connect to it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要确保在TCP连接的客户端端口上使用相同的端口，否则我们将无法连接到服务器。当然，在客户端可以连接到服务器之前，我们必须先启动服务器。
- en: We will modify our `Queues.py` module to become the TCP client.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改我们的`Queues.py`模块，使其成为TCP客户端。
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is all the code we need to talk to the TCP server. In this example, we
    are simply sending some bytes to the server and the server sends them back, prepending
    some strings before returning the response.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们与TCP服务器通信所需的所有代码。在这个例子中，我们只是向服务器发送一些字节，服务器将它们发送回来，并在返回响应之前添加一些字符串。
- en: Note
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This shows the principle of how TCP communications via networks work.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了TCP通过网络进行通信的原理。
- en: Once we know how to connect to a remote server via TCP/IP, we will use whatever
    commands are designed by the protocol of the program we are interested in communicating
    with. The first step is to connect before we can send commands to specific applications
    residing on a server.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道如何通过TCP/IP连接到远程服务器，我们将使用由我们感兴趣的通信程序的协议设计的任何命令。第一步是在我们可以向驻留在服务器上的特定应用程序发送命令之前进行连接。
- en: In the `writeToScrol` function, we will use the same loop as before but now
    we will send the messages to the TCP server. The server modifies the received
    message and then sends it back to us. Next, we place it into the GUI member queue
    which, as in previous recipes, runs in its own `Thread`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在`writeToScrol`函数中，我们将使用与以前相同的循环，但现在我们将把消息发送到TCP服务器。服务器修改接收到的消息，然后将其发送回给我们。接下来，我们将其放入GUI成员队列中，就像以前的示例一样，在其自己的`Thread`中运行。
- en: Note
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Python 3, we have to send strings over sockets in binary format. Adding the
    integer index now becomes a little bit convoluted as we have to cast it to a string,
    encode it, and then cast the encoded string into bytes!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3中，我们必须以二进制格式通过套接字发送字符串。现在添加整数索引变得有点复杂，因为我们必须将其转换为字符串，对其进行编码，然后将编码后的字符串转换为字节！
- en: '[PRE38]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note the `b` before the string and then, well, all the rest of the required
    casting…
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意字符串前面的`b`，然后，嗯，所有其他所需的转换...
- en: We are starting the TCP server in its own thread in the initializer of the OOP
    class.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在OOP类的初始化程序中启动TCP服务器的线程。
- en: '[PRE39]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Clicking the **Click Me!** button on **Tab 1** now creates the following output
    in our `ScrolledText` widget, as well as on the console, and the response, due
    to using `Threads`, is very fast.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在**Tab 1**上单击**Click Me!**按钮将在我们的`ScrolledText`小部件中创建以下输出，以及在控制台上，由于使用`Threads`，响应非常快。
- en: '![How to do it...](graphics/B04829_06_23.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_06_23.jpg)'
- en: How it works...
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created a TCP server to simulate connecting to a server in our local area
    network or on the Internet. We turned our queues module into a TCP client. We
    are running both the queue and the server in their own background thread, which
    keeps our GUI very responsive.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个TCP服务器来模拟连接到本地区域网络或互联网上的服务器。我们将我们的队列模块转换为TCP客户端。我们在它们自己的后台线程中运行队列和服务器，这样我们的GUI非常响应。
- en: Using URLOpen to read data from websites
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用URLOpen从网站读取数据
- en: This recipe shows how we can easily read entire webpages by using Python's built-in
    modules. We will display the webpage data first in its raw format and then decode
    it, and then we will display it in our GUI.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了我们如何使用Python的内置模块轻松读取整个网页。我们将首先以原始格式显示网页数据，然后解码它，然后在我们的GUI中显示它。
- en: Getting ready
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will read the data from a webpage and then display it in the `ScrolledText`
    widget of our GUI.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从网页中读取数据，然后在我们的GUI的`ScrolledText`小部件中显示它。
- en: How to do it...
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, we create a new Python module and name it `URL.py`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的Python模块并命名为`URL.py`。
- en: We then import the required functionality to read webpages using Python.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们导入所需的功能来使用Python读取网页。
- en: We can do this in very few lines of code.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用很少的代码来做到这一点。
- en: We are wrapping our code in a `try…except` block similar to Java and C#. This
    is a modern approach to coding which Python supports.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的代码包装在一个类似于Java和C#的`try…except`块中。这是Python支持的一种现代编码方法。
- en: Whenever we have code that might not complete we can experiment with this code
    and, if it works, all is fine.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们有可能不完整的代码时，我们可以尝试这段代码，如果成功，一切都很好。
- en: If the block of code in the `try…except` block does not work, the Python interpreter
    will throw one of several possible exceptions, which we then can catch. Once we
    have caught the exception we can decide what to do next.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`try…except`块中的代码块不起作用，Python解释器将抛出几种可能的异常，然后我们可以捕获。一旦我们捕获了异常，我们就可以决定接下来要做什么。
- en: There is a hierarchy of exceptions in Python and we can also create our own
    classes that inherit from and extend the Python exception classes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有一系列的异常，我们还可以创建自己的类，继承并扩展Python异常类。
- en: In the code shown as follows, we are mainly concerned that the URL we are trying
    to open might not be available and so we wrap our code within a `try…except` code
    block.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面显示的代码中，我们主要关注我们尝试打开的URL可能不可用，因此我们将我们的代码包装在`try…except`代码块中。
- en: If the code succeeds in opening the requested URL, all is fine.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码成功打开所请求的URL，一切都很好。
- en: If it fails, maybe because our internet connection is down, we fall into the
    exception part of the code and print out that an exception has occurred.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果失败，可能是因为我们的互联网连接断开了，我们就会进入代码的异常部分，并打印出发生异常的信息。
- en: Note
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about Python exception handling at [https://docs.python.org/3.4/library/exceptions.html](https://docs.python.org/3.4/library/exceptions.html).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.python.org/3.4/library/exceptions.html](https://docs.python.org/3.4/library/exceptions.html)了解更多关于Python异常处理的信息。
- en: '[PRE40]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: By calling `urlopen` on the official Python website, we get the entire data
    as one long string.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在官方Python网站上调用`urlopen`，我们得到整个数据作为一个长字符串。
- en: The first print statement prints this long string out to the console.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个打印语句将这个长字符串打印到控制台上。
- en: We then call `decode` on the result and this time we get a little over 1,000
    lines of web data, including some whitespace.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对结果调用`decode`，这次我们得到了一千多行的网页数据，包括一些空白。
- en: We are also printing out the type of calling `urlopen`, which is an `http.client.HTTPResponse`
    object. Actually, we are printing it out first.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还打印调用`urlopen`的类型，它是一个`http.client.HTTPResponse`对象。实际上，我们首先打印出来。
- en: '![How to do it...](graphics/B04829_06_24.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_06_24.jpg)'
- en: Here is the official Python webpage we just read. If you are a web developer,
    you probably have some good ideas what to do with the parsed data.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们刚刚读取的官方Python网页。如果您是Web开发人员，您可能对如何处理解析数据有一些好主意。
- en: '![How to do it...](graphics/B04829_06_25.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_06_25.jpg)'
- en: We next display this data in our GUI inside the `ScrolledText` widget. In order
    to do so, we have to connect our new module to read the data from the webpage
    to our GUI.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在我们的GUI中的`ScrolledText`小部件中显示这些数据。为了这样做，我们必须将我们的新模块连接到我们的GUI，从网页中读取数据。
- en: In order to do this, we need a reference to our GUI, and one way to do this
    is by tying our new module to the **Tab 1** button callback.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要一个对我们GUI的引用，而一种方法是通过将我们的新模块绑定到**Tab 1**按钮回调。
- en: We can return the decoded HTML data from the Python webpage to the `Button`
    widget, which we can then place in the `ScrolledText` control.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将从Python网页解码的HTML数据返回给`Button`小部件，然后将其放在`ScrolledText`控件中。
- en: So, let's turn our code into a function and return the data to the calling code.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将我们的代码转换为一个函数，并将数据返回给调用代码。
- en: '[PRE41]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can now write the data in our `button` callback method to the `ScrolledText`
    control by first importing the new module and then inserting the data into the
    widget. We also give it some sleep after the call to `writeToScrol`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过首先导入新模块，然后将数据插入到小部件中，在我们的`button`回调方法中写入数据到`ScrolledText`控件。在调用`writeToScrol`之后，我们还给它一些休眠时间。
- en: '[PRE42]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The HTML data is now displayed in our GUI widget.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: HTML数据现在显示在我们的GUI小部件中。
- en: '![How to do it...](graphics/B04829_06_26.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_06_26.jpg)'
- en: How it works...
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We create a new module to separate the code that gets the data from a webpage
    from our GUI code. This is always a good thing to do. We read in the webpage data
    and then return it to the calling code after decoding it. We then use the button
    callback function to place the returned data in the `ScrolledText` control.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新模块，将从网页获取数据的代码与我们的GUI代码分离。这总是一个好主意。我们读取网页数据，然后解码后返回给调用代码。然后我们使用按钮回调函数将返回的数据放入“ScrolledText”控件中。
- en: This chapter introduced us to some advanced Python programming concepts, which
    we combined to produce a functional GUI program.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了一些高级的Python编程概念，我们将它们结合起来，制作出一个功能性的GUI程序。
