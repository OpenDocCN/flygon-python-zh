["```py\n          python3.8 -m pip install numpy scipy matplotlib nashpy\n\n```", "```py\nimport numpy as np\nfrom scipy import optimize\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n```", "```py\nA = np.array([\n    [2, 1],   # 2*x0 + x1 <= 6\n    [-1, -1]  # -x0 - x1 <= -4\n])\nb = np.array([6, -4])\nx0_bounds = (-3, 14) # -3 <= x0 <= 14\nx1_bounds = (2, 12)  # 2 <= x1 <= 12\nc = np.array([1, 5])\n```", "```py\ndef func(x):\n    return np.tensordot(c, x, axes=1)\n```", "```py\nfig = plt.figure()\nax = fig.add_subplot(projection=\"3d\")\nax.set(xlabel=\"x0\", ylabel=\"x1\", zlabel=\"func\")\nax.set_title(\"Values in Feasible region\")\n```", "```py\nX0 = np.linspace(*x0_bounds)\nX1 = np.linspace(*x1_bounds)\nx0, x1 = np.meshgrid(X0, X1)\nz = func([x0, x1])\nax.plot_surface(x0, x1, z, alpha=0.3)\n```", "```py\nY = (b[0] - A[0, 0]*X0) / A[0, 1]\nI = np.logical_and(Y >= x1_bounds[0], Y <= x1_bounds[1])\nax.plot(X0[I], Y[I], func([X0[I], Y[I]]), \"r\", lw=1.5)\n```", "```py\nY = (b[1] - A[1, 0]*X0) / A[1, 1]\nI = np.logical_and(Y >= x1_bounds[0], Y <= x1_bounds[1])\nax.plot(X0[I], Y[I], func([X0[I], Y[I]]), \"r\", lw=1.5)\n```", "```py\nB = np.tensordot(A, np.array([x0, x1]), axes=1)\nII = np.logical_and(B[0, ...] <= b[0], B[1, ...] <= b[1]) \nax.plot_trisurf(x0[II], x1[II], z[II], color=\"b\", alpha=0.5)\n```", "```py\nres = optimize.linprog(c, A_ub=A, b_ub=b, bounds=\n    (x0_bounds, x1_bounds))\nprint(res)\n```", "```py\nax.plot([res.x[0]], [res.x[1]], [res.fun], \"k*\")\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom scipy import optimize\n```", "```py\ndef func(x):\n    return ((x[0] - 0.5)**2 + (x[1] + 0.5)**2)*\n       np.cos(0.5*x[0]*x[1])\n```", "```py\nx_r = np.linspace(-1, 1)\ny_r = np.linspace(-2, 2)\nx, y = np.meshgrid(x_r, y_r)\n```", "```py\nz = func([x, y])\n```", "```py\nfig = plt.figure(tight_layout=True)\nax = fig.add_subplot(projection=\"3d\")\nax.tick_params(axis=\"both\", which=\"major\", labelsize=9)\nax.set(xlabel=\"x\", ylabel=\"y\", zlabel=\"z\")\nax.set_title(\"Objective function\")\n```", "```py\nax.plot_surface(x, y, z, alpha=0.7)\n```", "```py\nx0 = np.array([-0.5, 1.0])\nax.plot([x0[0]], [x0[1]], func(x0), \"r*\")\n```", "```py\nresult = optimize.minimize(func, x0, tol=1e-6, method=\n    \"Nelder-Mead\")\nprint(result)\n```", "```py\nax.plot([result.x[0]], [result.x[1]], [result.fun], \"r*\")\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n```", "```py\ndef descend(func, x0, grad, bounds, tol=1e-8, max_iter=100):\n```", "```py\nxn = x0\nxnm1 = np.inf\ngrad_xn = grad(x0)\n```", "```py\nfor i in range(max_iter):\n    if np.linalg.norm(xn - xnm1) < tol:\n        break\n```", "```py\ndirection = -grad_xn\n```", "```py\nxnm1 = xn\nxn = xn + 0.2*direction\n```", "```py\ngrad_xn = grad(xn)\nyield i, xn, func(xn), grad_xn\n```", "```py\ndef func(x):\n    return ((x[0] - 0.5)**2 + (x[1] + 0.5)**2)*np.cos(0.5*x[0]*x[1])\n```", "```py\nx_r = np.linspace(-1, 1)\ny_r = np.linspace(-2, 2)\nx, y = np.meshgrid(x_r, y_r)\n```", "```py\nz = func([x, y])\n```", "```py\nsurf_fig = plt.figure(tight_layout=True)\nsurf_ax = surf_fig.add_subplot(projection=\"3d\")\nsurf_ax.tick_params(axis=\"both\", which=\"major\", labelsize=9)\nsurf_ax.set(xlabel=\"x\", ylabel=\"y\", zlabel=\"z\")\nsurf_ax.set_title(\"Objective function\")\nsurf_ax.plot_surface(x, y, z, alpha=0.7)\n```", "```py\nx0 = np.array([-0.8, 1.3])\nsurf_ax.plot([x0[0]], [x0[1]], func(x0), \"r*\")\n```", "```py\ndef grad(x):\n    c1 = x[0]**2 - x[0] + x[1]**2 + x[1] + 0.5\n    cos_t = np.cos(0.5*x[0]*x[1])\n    sin_t = np.sin(0.5*x[0]*x[1])\n    return np.array([\n        (2*x[0]-1)*cos_t - 0.5*x[1]*c1*sin_t,\n        (2*x[1]+1)*cos_t - 0.5*x[0]*c1*sin_t\n    ])\n```", "```py\ncont_fig, cont_ax = plt.subplots()\ncont_ax.set(xlabel=\"x\", ylabel=\"y\")\ncont_ax.set_title(\"Contour plot with iterates\")\ncont_ax.contour(x, y, z, levels=30)\n```", "```py\nbounds = ((-1, 1), (-2, 2))\n```", "```py\nxnm1 = x0\nfor i, xn, fxn, grad_xn in descend(func, x0, grad, bounds):\n    cont_ax.plot([xnm1[0], xn[0]], [xnm1[1], xn[1]], \"k*--\")\n    xnm1, grad_xnm1 = xn, grad_xn\n```", "```py\nprint(f\"iterations={i}\")\nprint(f\"min val at {xn}\")\nprint(f\"min func value = {fxn}\")\n```", "```py\niterations=37\nmin val at [ 0.49999999 -0.49999999]\nmin func value = 2.1287163880894953e-16\n```", "```py\nalphas = np.array([\n        (bounds[0][0] - xn[0]) / direction[0], # x lower\n        (bounds[1][0] - xn[1]) / direction[1], # y lower\n        (bounds[0][1] - xn[0]) / direction[0], # x upper\n        (bounds[1][1] - xn[1]) / direction[1] # y upper\n])\n\nalpha_max = alphas[alphas >= 0].min()\nalpha_min = alphas[alphas < 0].max()\nresult = minimize_scalar(lambda t: func(xn + t*direction), \n        method=\"bounded\", bounds=(alpha_min, alpha_max))\namount = result.x\n```", "```py\nxn = xn + amount * direction\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\n```", "```py\nfrom numy.random import default_rng\nrng = default_rng(12345)\n```", "```py\nfrom scipy.optimize import curve_fit\n```", "```py\nSIZE = 100\nx_data = rng.uniform(-3.0, 3.0, size=SIZE)\nnoise = rng.normal(0.0, 0.8, size=SIZE)\ny_data = 2.0*x_data**2 - 4*x_data + noise\n```", "```py\nfig, ax = plt.subplots()\nax.scatter(x_data, y_data)\nax.set(xlabel=\"x\", ylabel=\"y\", title=\"Scatter plot of sample data\")\n```", "```py\ndef func(x, a, b, c):\n    return a*x**2 + b*x + c\n```", "```py\ncoeffs, _ = curve_fit(func, x_data, y_data)\nprint(coeffs)\n# [ 1.99611157 -3.97522213 0.04546998]\n```", "```py\nx = np.linspace(-3.0, 3.0, SIZE)\ny = func(x, coeffs[0], coeffs[1], coeffs[2])\nax.plot(x, y, \"k--\")\n```", "```py\ndef func(params, x, y):\n    return y - (params[0]*x**2 + params[1]*x + params[2])\n```", "```py\nresults = least_squares(func, [1, 0, 0], args=(x_data, y_data))\n```", "```py\nimport numpy as np\nimport nashpy as nash\n```", "```py\nyou = np.array([[1, 3], [1, 4]])\ncolleague = np.array([[3, 2], [2, 2]])\n```", "```py\ndilemma = nash.Game(you, colleague)\n```", "```py\nprint(dilemma[[1, 0], [1, 0]])  # [1 3]\nprint(dilemma[[1, 0], [0, 1]])  # [3 2]\nprint(dilemma[[0, 1], [1, 0]])  # [1 2]\nprint(dilemma[[0, 1], [0, 1]])  # [4 2]\n```", "```py\nprint(dilemma[[0.1, 0.9], [0.5, 0.5]]) # [2.45 2.05]\n```", "```py\nimport numpy as np\nimport nashpy as nash\n```", "```py\nrps_p1 = np.array([\n    [ 0, -1,  1],  # rock payoff\n    [ 1,  0, -1],   # paper payoff\n    [-1,  1,  0]   # scissors payoff\n])\n```", "```py\nrps_p2 = rps_p1.transpose()\n```", "```py\nrock_paper_scissors = nash.Game(rps_p1, rps_p2)\n```", "```py\nequilibria = rock_paper_scissors.support_enumeration()\n```", "```py\nfor p1, p2 in equilibria:\n    print(\"Player 1\", p1)\n    print(\"Player 2\", p2)\n```", "```py\nPlayer 1 [0.33333333 0.33333333 0.33333333]\nPlayer 2 [0.33333333 0.33333333 0.33333333]\n```"]