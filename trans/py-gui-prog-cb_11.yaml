- en: Chapter 11. Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。最佳实践
- en: In this chapter, we will explore best practices related to our Python GUI.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨与Python GUI相关的最佳实践。
- en: Avoiding spaghetti code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免意大利面代码
- en: Using __init__ to connect modules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用__init__连接模块
- en: Mixing fall-down and OOP coding
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合下降和OOP编码
- en: Using a code naming convention
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码命名约定
- en: When not to use OOP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时不使用OOP
- en: How to use design patterns successfully
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功使用设计模式的方法
- en: Avoiding complexity
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免复杂性
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will explore different best practices that can help us to
    build our GUI in an efficient way and keep it both maintainable and extendible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨可以帮助我们以高效的方式构建GUI并使其易于维护和扩展的不同最佳实践。
- en: These best practices will also help us to debug our GUI to get it just the way
    we want it to be.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些最佳实践也将帮助我们调试GUI，使其成为我们想要的样子。
- en: Avoiding spaghetti code
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免意大利面代码
- en: In this recipe, we will explore a typical way to create spaghetti code and then
    we will see a much better way of how to avoid such code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探讨创建意大利面代码的典型方式，然后我们将看到如何避免这样的代码的更好方式。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Spaghetti code is code in which a lot of functionality is intertangled.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码是一种功能交织在一起的代码。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will create a new, simple GUI written in Python using the tkinter built-in
    Python library.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用内置的Python库tkinter来创建一个新的简单GUI。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Having searched online and read the documentation, we might start by writing
    the following code to create our GUI:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在网上搜索并阅读文档后，我们可能会开始编写以下代码来创建我们的GUI：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running the preceding code results in the following GUI:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码会产生以下GUI：
- en: '![How to do it...](graphics/B04829_11_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_01.jpg)'
- en: 'This is not quite the GUI we intended. We wanted it to look something more
    like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是我们打算的GUI。我们希望它看起来更像这样：
- en: '![How to do it...](graphics/B04829_11_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_02.jpg)'
- en: While the spaghetti code created a GUI, the code is very hard to debug because
    there is so much confusion in the code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然意大利面代码创建了一个GUI，但代码非常难以调试，因为代码中有很多混乱。
- en: 'The following is the code that produces the desired GUI:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是产生所需GUI的代码：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we compared spaghetti code to good code. Good code has many
    advantages over the spaghetti code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将意大利面代码与良好的代码进行了比较。良好的代码比意大利面代码有很多优势。
- en: It has clearly commented sections.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它有清晰的注释部分。
- en: 'Spaghetti code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Good code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It has a natural flow that follows how the widgets get laid out in the GUI main
    form.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有自然的流程，遵循小部件在GUI主窗体中的布局方式。
- en: In the spaghetti code, the bottom LabelFrame gets created before the top LabelFrame
    and it is intermixed with an import statement and some widget creation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在意大利面代码中，底部的LabelFrame在顶部的LabelFrame之前创建，并且与导入语句和一些小部件创建混合在一起。
- en: 'Spaghetti code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Good code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It does not contain unnecessary variable assignments and neither does it have
    a `print` function that does not do the debugging one might expect it to do when
    reading the code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它不包含不必要的变量赋值，也没有`print`函数，当阅读代码时，它不会做人们期望的调试。
- en: 'Spaghetti code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Good code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码：
- en: Has none of the above.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 没有上述任何一种。
- en: The `import` statements only import the required modules. They are not cluttered
    throughout the code. There are no duplicate `import` statements. There is no `import
    *` statement.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句只导入所需的模块。它们不会在整个代码中混乱。没有重复的`import`语句。没有`import *`语句。'
- en: 'Spaghetti code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Good code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The chosen variable names are quite meaningful. There are no unnecessary `if`
    statements that use the number `1` instead of `True`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的变量名相当有意义。没有不必要使用数字`1`而不是`True`的`if`语句。
- en: 'Spaghetti code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Good code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We did not lose the intended window title and our check button ended up in the
    correct position. We also made the `LabelFrame` surrounding the check button visible.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有失去预期的窗口标题，我们的复选框最终出现在正确的位置。我们还使包围复选框的“LabelFrame”可见。
- en: 'Spaghetti code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码：
- en: We lost both the window title and did not display the top `LabelFrame`. The
    check button ended up in the wrong place.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们失去了窗口标题，也没有显示顶部的“LabelFrame”。复选框最终出现在错误的位置。
- en: 'Good code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using __init__ to connect modules
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用__init__连接模块
- en: When we create a new Python project using the PyDev plugin for the Eclipse IDE,
    it automatically creates a `__init__.py` module. We can also create it ourselves
    manually when not using Eclipse.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Eclipse IDE的PyDev插件创建一个新的Python项目时，它会自动创建一个`__init__.py`模块。当不使用Eclipse时，我们也可以手动创建它。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `__init__.py` module is usually empty and then has a size of 0 kilobytes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py`模块通常是空的，然后大小为0千字节。'
- en: We can use this usually empty module to connect different Python modules by
    entering code into it. This recipe will show how to do this.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个通常为空的模块来连接不同的Python模块，通过在其中输入代码。这个配方将展示如何做到这一点。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will create a new GUI similar to the one we created in the previous recipe.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个类似于我们在上一个配方中创建的GUI的新GUI。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: As our project becomes larger and larger, we naturally break it out into several
    Python modules. Using a modern IDE such as Eclipse, it is surprisingly complicated
    to find modules that are located in different subfolders either above or below
    the code that needs to import it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的项目变得越来越大，我们自然地将其拆分为几个Python模块。使用现代IDE（如Eclipse）时，惊人地复杂，找到位于不同子文件夹中的模块，无论是在需要导入它的代码的上方还是下方。
- en: One practical way to get around this limitation is to use the `__init__.py`
    module.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过这个限制的一个实际方法是使用`__init__.py`模块。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Eclipse, we can set the Eclipse internal project environment to certain folders
    and our Python code will find it. But outside of Eclipse, for example when running
    from a command window, there is sometimes a mismatch in the Python module import
    mechanism and the code will not run.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse中，我们可以将Eclipse内部项目环境设置为某些文件夹，我们的Python代码将找到它。但是在Eclipse之外，例如在命令窗口中运行时，Python模块导入机制有时会不匹配，代码将无法运行。
- en: Here is a screenshot of the empty `__init__.py` module, which appears not with
    the name `__init__` but with the name of the PyDev package it belongs to when
    opened in the Eclipse code editor. The "1" on the left side of the code editor
    is the line number and not any code written in this module. There is absolutely
    no code in this empty `__init__.py` module.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个空的`__init__.py`模块的截图，当在Eclipse代码编辑器中打开时，它的名称不是`__init__`，而是属于的PyDev包的名称。代码编辑器左侧的“1”是行号，而不是在这个模块中编写的任何代码。这个空的`__init__.py`模块中绝对没有代码。
- en: '![How to do it...](graphics/B04829_11_03.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_03.jpg)'
- en: This file is empty, but it does exist.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件是空的，但它确实存在。
- en: '![How to do it...](graphics/B04829_11_04.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_04.jpg)'
- en: When we run the following code and click the `clickMe Button`, we get the result
    shown following the code. This is a regular Python module that does not yet use
    the `__init__.py` module.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行以下代码并点击`clickMe Button`时，我们会得到代码后面显示的结果。这是一个常规的Python模块，尚未使用`__init__.py`模块。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The __`init__.py` module is not the same as the `__init__(self)` method of a
    Python class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py`模块与Python类的`__init__(self)`方法不同。'
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![How to do it...](graphics/B04829_11_05.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_05.jpg)'
- en: 'In the preceding code, we created the following function, which imports Python''s
    message box and then uses it to display the message box window:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了以下函数，它导入Python的消息框，然后使用它来显示消息框窗口：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we move the `clickMe()` message box code into a nested directory folder
    and try to `import` it into our GUI module, we run into some problems.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`clickMe()`消息框代码移动到嵌套的目录文件夹中，并尝试将其`import`到我们的GUI模块中时，我们遇到了一些问题。
- en: We have created three sub-folders below where our Python module lives. We then
    placed the `clickMe()` message box code into a new Python module, which we named
    `MessageBox.py`. This module lives in `Folder3`, three levels below where our
    Python module lives.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Python模块所在的位置下创建了三个子文件夹。然后，我们将`clickMe()`消息框代码放入一个新的Python模块中，我们将其命名为`MessageBox.py`。这个模块位于`Folder3`中，比我们的Python模块所在的位置低三级。
- en: We need to import this `MessageBox.py` module in order to use the `clickMe()`
    function that this module contains.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入`MessageBox.py`模块，以便使用这个模块包含的`clickMe()`函数。
- en: At first, it appears to work because it seems we can import the new nested module
    as we are not getting any errors or warnings from the Eclipse IDE.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，它似乎可以工作，因为似乎我们可以导入新的嵌套模块，因为我们没有从Eclipse IDE中得到任何错误或警告。
- en: 'We are using Python''s relative import syntax:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Python的相对导入语法：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This can be seen in the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在以下截图中看到：
- en: '![How to do it...](graphics/B04829_11_06.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_06.jpg)'
- en: 'We have deleted the local `clickMe()` function and now our callback should
    use the imported `clickMe()` function, but it is not working as expected. Instead
    of the expected popup window, we get an import system error when we run the code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经删除了本地的`clickMe()`函数，现在我们的回调应该使用导入的`clickMe()`函数，但它并没有按预期工作。我们运行代码时，没有得到预期的弹出窗口，而是得到了一个导入系统错误：
- en: '![How to do it...](graphics/B04829_11_07.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_07.jpg)'
- en: We can add the subfolder where our new function lives as an external library
    in Eclipse by going to the PyDev Project properties and adding ourselves as an
    external library. This does not seem very intuitive, but it does work.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过转到PyDev项目属性并将自己添加为外部库，在Eclipse中将包含新函数的子文件夹作为外部库。这似乎并不直观，但它确实有效。
- en: '![How to do it...](graphics/B04829_11_08.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_08.jpg)'
- en: When we now comment out the folder structure and, instead, directly import the
    function from the module which is nested to three levels, the code works as expected.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们注释掉文件夹结构，并直接从嵌套到三个级别的模块中导入函数时，代码会按预期工作。
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This function displays a different text in a message box:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在消息框中显示不同的文本：
- en: '![How to do it...](graphics/B04829_11_09.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_09.jpg)'
- en: A better way to achieve the same result is to use Python's built-in `__init__.py`
    module.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相同结果的更好方法是使用Python内置的`__init__.py`模块。
- en: After deleting the previously Eclipse-specific external library dependency,
    we can now use this module directly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 删除之前特定于Eclipse的外部库依赖后，我们现在可以直接使用这个模块。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code we place into this module runs before all of our other code if we import
    the `__init__.py` module into our program, as of Python 3.4.3.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将代码放入这个模块中，如果我们将`__init__.py`模块导入到我们的程序中，它将在我们的所有其他代码之前运行，截至Python 3.4.3。
- en: Ignore the PyDev Unresolved Import (red circle with a cross) error. This `import`
    is necessary; it makes our code run and the entire Python importing mechanism
    work.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略PyDev未解析的导入（带有红色圈和交叉）错误。这个`import`是必要的；它使我们的代码运行，并且整个Python导入机制工作。
- en: '![How to do it...](graphics/B04829_11_10.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_10.jpg)'
- en: After importing the `__init__.py` module into our program, we can use it. The
    first test to check if it works is to code a print statement into this module.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将`__init__.py`模块导入到我们的程序后，我们可以使用它。检查它是否工作的第一个测试是在这个模块中编写一个打印语句。
- en: '![How to do it...](graphics/B04829_11_11.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_11.jpg)'
- en: 'By adding the following code, we can find out programmatically where we are
    located:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加以下代码，我们可以以编程方式找出我们的位置：
- en: '![How to do it...](graphics/B04829_11_12.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_12.jpg)'
- en: 'Now, we can initialize our Python search path from within this `__init__.py`
    module by adding the following code to the same `__init__.py` module:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过向相同的`__init__.py`模块添加以下代码来从内部初始化我们的Python搜索路径：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When we now run our GUI code, we get the same expected windows, but we have
    removed our dependency on the Eclipse `PYTHONPATH` variable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在运行我们的GUI代码时，我们得到了相同预期的窗口，但我们已经移除了对Eclipse `PYTHONPATH`变量的依赖。
- en: Now we can successfully run the same code outside of the Eclipse PyDev plugin.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以成功地在Eclipse PyDev插件之外运行相同的代码。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Our code has become more Pythonic.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码变得更加Pythonic。
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we discovered a limitation of using the PyDev plugin, which
    comes free with the wonderful and free Eclipse IDE.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们发现了使用PyDev插件的局限性，这个插件是免费的，与出色的免费Eclipse IDE一起提供。
- en: We first found a workaround in the Eclipse IDE, and next, we became independent
    from this IDE by becoming Pythonic.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在Eclipse IDE中找到了一个解决方法，然后通过变得Pythonic而独立于这个IDE。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using pure Python is usually the best way to go.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用纯Python是最好的方法。
- en: Mixing fall-down and OOP coding
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合下降和面向对象编码
- en: Python is an object-oriented programming language yet it does not always make
    sense to use OOP. For simple scripting tasks, the legacy waterfall coding style
    is still appropriate.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种面向对象的编程语言，但并不总是使用OOP是有意义的。对于简单的脚本任务，传统的瀑布式编码风格仍然是合适的。
- en: In this recipe, we will create a new GUI that mixes both the fall-down coding
    style with the more modern OOP coding style.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个新的GUI，将下降式编码风格与更现代的OOP编码风格混合在一起。
- en: We will create an OOP-style class that will display a tooltip when we hover
    the mouse over a widget in a Python GUI that we will create using a waterfall
    style.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个OOP风格的类，当我们在Python GUI中使用瀑布样式创建小部件时，它将在鼠标悬停在小部件上时显示工具提示。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Fall-down and waterfall coding styles are the same. It means that we have to
    physically place code above code before we can call it from the code below. In
    this paradigm, the code literally falls down from the top of our program to the
    bottom of our program when we execute the code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下降和瀑布式编码风格是相同的。这意味着我们必须在调用下面的代码之前将代码物理放置在上面的代码之上。在这种范式中，当我们执行代码时，代码从程序的顶部字面上下降到程序的底部。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will create a GUI using tkinter, which is similar to the
    GUI we created in the first chapter of this book.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用tkinter创建一个GUI，这类似于我们在本书第一章中创建的GUI。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In Python, we can bind functions to classes by turning them into methods using
    the `self` keyword. This is a truly wonderful capability of Python and it allows
    us to create large systems that are understandable and maintainable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以通过使用`self`关键字将函数绑定到类，将它们转换为方法。这是Python的一个真正美妙的能力，它允许我们创建可理解和可维护的大型系统。
- en: Sometimes, when we only write short scripts, OOP does not make sense because
    we find ourselves prepending a lot of variables with the `self` keyword and the
    code gets unnecessarily large when it does not need to be.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当我们只编写简短的脚本时，使用OOP并没有意义，因为我们发现自己不得不用`self`关键字大量添加变量，当代码不需要时，代码会变得不必要地庞大。
- en: Let's first create a Python GUI using tkinter and code it in the waterfall style.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用tkinter创建一个Python GUI，并以瀑布式编码风格编写它。
- en: 'The following code creates the GUI:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了GUI：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we run the code, we get the GUI and it looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，我们得到了GUI，它看起来像这样：
- en: '![How to do it...](graphics/B04829_11_13.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_13.jpg)'
- en: We can improve our Python GUI by adding tooltips. The best way to do this is
    to isolate the code that creates the tooltip functionality from our GUI.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加工具提示来改进我们的Python GUI。这样做的最佳方式是将创建工具提示功能的代码与我们的GUI隔离开来。
- en: We do this by creating a separate class that has the tooltip functionality,
    and then we create an instance of this class in the same Python module that creates
    our GUI.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个具有工具提示功能的单独类来实现这一点，然后在创建GUI的同一Python模块中创建这个类的实例。
- en: Using Python, there is no need to place our `ToolTip` class into a separate
    module. We can place it just above the procedural code and then call it from below
    this code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python，我们不需要将我们的`ToolTip`类放入一个单独的模块中。我们可以将它放在过程化代码的上面，然后从这段代码下面调用它。
- en: 'The code now looks like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在看起来像这样：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running the code creates tooltips for our widgets when we hover the mouse over
    them.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会在我们悬停鼠标在小部件上时为它们创建工具提示。
- en: '![How to do it...](graphics/B04829_11_14.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_14.jpg)'
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a Python GUI in a procedural way, and later, we added
    a class to the top of the module.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们以过程化的方式创建了一个Python GUI，然后在模块的顶部添加了一个类。
- en: We can very easily mix and match both procedural and OOP programming in the
    same Python module.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地在同一个Python模块中混合和匹配过程化和OOP编程。
- en: Using a code naming convention
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代码命名约定
- en: The previous recipes in this book have not used a structured code naming convention.
    This recipe will show you the value of adhering to a code naming scheme because
    it helps us to find the code we want to extend, as well as reminds us of the design
    of our program.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中以前的示例没有使用结构化的代码命名约定。这个示例将向您展示遵循代码命名方案的价值，因为它帮助我们找到我们想要扩展的代码，并提醒我们程序的设计。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will look at the Python module names from the first chapter
    of this book and compare them to better naming conventions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将查看本书第一章中的Python模块名称，并将它们与更好的命名约定进行比较。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In the first chapter of this book, we created our first Python GUI. We improved
    our GUI by incrementing the different code module names via sequential numbers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一章中，我们创建了我们的第一个Python GUI。我们通过逐步增加不同的代码模块名称来改进我们的GUI。
- en: 'It looked like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样：
- en: '![How to do it...](graphics/B04829_11_15.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_15.jpg)'
- en: While this is a typical way to code, it does not provide much meaning. When
    we write our Python code during development, it is very easy to increment numbers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一种典型的编码方式，但它并没有提供太多的意义。当我们在开发过程中编写Python代码时，很容易递增数字。
- en: Later, coming back to this code, we don't have much of an idea which Python
    module provides which functionality, and sometimes, our last incremented modules
    are not as good as earlier versions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后回到这段代码时，我们不太清楚哪个Python模块提供了哪些功能，有时，我们最后增加的模块不如之前的版本好。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A clear naming convention does help.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰的命名约定确实有所帮助。
- en: We can compare the module names from [Chapter 1](ch01.html "Chapter 1. Creating
    the GUI Form and Adding Widgets"), *Creating the GUI Form and Adding Widgets*,
    to the names from [Chapter 8](ch08.html "Chapter 8. Internationalization and Testing"),
    *Internationalization and Testing*, which are much more meaningful.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将[第1章](ch01.html "第1章。创建GUI表单并添加小部件")中的模块名称与[第8章](ch08.html "第8章。国际化和测试")中的模块名称进行比较，后者更有意义。
- en: '![How to do it...](graphics/B04829_11_16.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_11_16.jpg)'
- en: While not perfect, the names chosen for the different Python modules, indicate
    what each module's responsibility is. When we want to add more unit tests, it
    is clear in which module they reside.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不完美，但为不同的Python模块选择的名称表明了每个模块的责任。当我们想要添加更多单元测试时，清楚地知道它们位于哪个模块中。
- en: 'The following is another example of how to use a code naming convention to
    create a GUI in Python:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另一个示例，演示如何使用代码命名约定在Python中创建GUI：
- en: '![How to do it...](graphics/B04829_11_17.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_11_17.jpg)'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Replace the word `PRODUCT` with the product you are currently working on.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将单词`PRODUCT`替换为您当前正在开发的产品。
- en: The entire application is a GUI. All parts are connected. The `DEBUG.py` module
    is only used for debugging our code. The main function to invoke the GUI has its
    name reversed when compared to all of the other modules. It starts with `Gui`
    and ends in a `.pyw` extension.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序都是一个GUI。所有部分都是相互连接的。`DEBUG.py`模块仅用于调试我们的代码。调用GUI的主要函数在与所有其他模块相比时，其名称是颠倒的。它以`Gui`开头，并以`.pyw`扩展名结尾。
- en: It is the only Python module that has this extension name.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 它是唯一具有这个扩展名的Python模块。
- en: From this naming convention, if you are familiar enough with Python, it will
    be obvious that, in order to run this GUI, you double-click the `Gui_PRODUCT.pyw`
    module.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个命名约定，如果您对Python足够熟悉，很明显，要运行这个GUI，您需要双击`Gui_PRODUCT.pyw`模块。
- en: All other Python modules contain functionality to supply to the GUI as well
    as execute the underlying business logic to fulfil the purpose this GUI addresses.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他Python模块都包含为GUI提供功能并执行底层业务逻辑以实现此GUI目的的功能。
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Naming conventions for Python code modules are a great help in keeping us efficient
    and remembering our original design. When we need to debug and fix a defect or
    add new functionality, they are the first resource to look at.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码模块的命名约定对于保持高效并记住我们最初的设计非常有帮助。当我们需要调试和修复缺陷或添加新功能时，它们是首要资源。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Incrementing module names by numbers is not very meaningful and eventually wastes
    development time.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过数字递增模块名称并不是非常有意义，最终会浪费开发时间。
- en: On the other hand, naming Python variables is more of a free form. Python infers
    types, so we do not have to specify that a variable will be of type `<list>` (it
    might not be or actually, later in the code, it might become a different type).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，命名Python变量更像是自由形式。Python推断类型，因此我们不必指定变量将是`<list>`类型（它可能不是，或者实际上，在代码的后面部分，它可能会变成不同的类型）。
- en: A good idea for naming variables is to make them descriptive and it is also
    a good idea not to abbreviate too much.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为变量命名的一个好主意是使它们具有描述性，并且不要缩写得太多。
- en: If we wish to point out that a certain variable is designed to be of type `<list>`,
    then it is much more intuitive to use the full word `list` instead of `lst`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望指出某个变量设计为`<list>`类型，则使用完整单词`list`比使用`lst`更直观。
- en: It is similar for `number` instead of `num`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这与使用`number`而不是`num`类似。
- en: 'While it is a good idea to have very descriptive names for variables, sometimes
    that can get too long. In Apple''s Objective-C language, some variable and function
    names are extreme: `thisIsAMethodThatDoesThisAndThatAndAlsoThatIfYouPassInNIntegers:1:2:3`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在为变量命名时，使用非常描述性的名称是一个好主意，但有时可能会太长。在苹果的Objective-C语言中，一些变量和函数名字非常极端：`thisIsAMethodThatDoesThisAndThatAndAlsoThatIfYouPassInNIntegers:1:2:3`
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use common sense when naming variables, methods, and functions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在为变量、方法和函数命名时要遵循常识。
- en: When not to use OOP
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时不使用面向对象编程
- en: Python comes built-in with object-oriented programming capabilities, but at
    the same time, we can write scripts that do not need to use OOP.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Python内置了面向对象编程的能力，但与此同时，我们也可以编写不需要使用面向对象编程的脚本。
- en: For some tasks, OOP does not make sense.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些任务，面向对象编程是没有意义的。
- en: This recipe will show when not to use OOP.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将展示何时不使用面向对象编程。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will create a Python GUI similar to previous recipes. We
    will compare the OOP code to the non-OOP alternative way of programming.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个类似于之前示例的Python GUI。我们将比较面向对象编程的代码和非面向对象的替代编程方式。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s first create a new GUI using **OOP** methodology. The following code
    will create the GUI displayed below the code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用**OOP**方法创建一个新的GUI。以下代码将创建下面代码中显示的GUI：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![How to do it...](graphics/B04829_11_18.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_11_18.jpg)'
- en: We can achieve the same GUI without using an OOP approach by restructuring our
    code slightly. First, we remove the `OOP` class and its `__init__` method.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过稍微重构我们的代码来实现相同的GUI，而不使用面向对象的方法。首先，我们移除`OOP`类及其`__init__`方法。
- en: Next, we move all methods to the left and remove the `self` class reference
    which turns them into unbound functions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将所有方法移到左侧，并移除`self`类引用，将它们转换为未绑定的函数。
- en: We also remove any other `self` references our previous code had. Then, we move
    the `createWidgets` function call below the point of the function's declaration.
    We place it just above the `mainloop` call.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还删除了先前代码中的任何其他`self`引用。然后，我们将`createWidgets`函数调用移动到函数声明点下方。我们将它放在`mainloop`调用的正上方。
- en: In the end, we achieve the same GUI but without using OOP.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们实现了相同的GUI，但没有使用OOP。
- en: 'The refactored code is shown as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的代码如下所示：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Python enables us to use OOP when it makes sense. Other languages such as Java
    and C# force us to always use the OOP approach to coding. In this recipe, we explored
    a situation when it did not make sense to use OOP.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Python使我们能够在有意义的时候使用OOP。其他语言如Java和C#强制我们始终使用OOP方法进行编码。在这个示例中，我们探讨了一个不适合使用OOP的情况。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The OOP approach will be more extendible if the codebase grows but, if it's
    certain that it is the only code that's needed then there's no need to go through
    OOP.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码库增长，OOP方法将更具扩展性，但是如果确定只需要这个代码，那么就没有必要经过OOP。
- en: How to use design patterns successfully
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成功使用设计模式的方法
- en: In this recipe, we will create widgets for our Python GUI by using the factory
    design pattern.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用工厂设计模式为我们的Python GUI创建小部件。
- en: In previous recipes, we created our widgets either manually one at a time or
    dynamically in a loop.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的示例中，我们要么手动创建小部件，要么在循环中动态创建小部件。
- en: Using the factory design pattern, we will use the factory to create our widgets.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工厂设计模式，我们将使用工厂来创建我们的小部件。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a Python GUI which has three buttons each having different styles.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个Python GUI，其中有三个按钮，每个按钮都有不同的样式。
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Towards the top of our Python GUI module, just below the import statements,
    we create several classes:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Python GUI模块顶部，在导入语句的下方，我们创建了几个类：
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We create a base class which our different button style classes inherit from
    and in which each of them overrides the `relief` and `foreground` configuration
    properties. All subclasses inherit the `getButtonConfig` method from this base
    class. This method returns a tuple.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个基类，我们的不同按钮样式类都继承自该基类，并且每个类都覆盖了`relief`和`foreground`配置属性。所有子类都从这个基类继承`getButtonConfig`方法。该方法返回一个元组。
- en: We also create a button factory class and a list that holds the names of our
    button subclasses. We name the list `buttonTypes` as our factory will create different
    types of buttons.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个按钮工厂类和一个保存我们按钮子类名称的列表。我们将列表命名为`buttonTypes`，因为我们的工厂将创建不同类型的按钮。
- en: Further down in the module we create the button widgets, using the same `buttonTypes`
    list.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块的下方，我们使用相同的`buttonTypes`列表创建按钮小部件。
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we create an instance of the button factory and then we use our factory
    to create our buttons.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个按钮工厂的实例，然后我们使用我们的工厂来创建我们的按钮。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The items in the `buttonTypes` list are the names of our subclasses.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`buttonTypes`列表中的项目是我们子类的名称。'
- en: We invoke the `createButton` method and then immediately call the `getButtonConfig`
    method of the base class and retrieve the configuration properties using dot notation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`createButton`方法，然后立即调用基类的`getButtonConfig`方法，并使用点表示法检索配置属性。
- en: 'When we run the entire code, we get the following Python tkinter GUI:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行整个代码时，我们会得到以下Python tkinter GUI：
- en: '![How to do it...](graphics/B04829_11_19.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_19.jpg)'
- en: We can see that our Python GUI factory did indeed create different buttons,
    each having a different style. They differ in the color of their text and in their
    relief property.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的Python GUI工厂确实创建了不同的按钮，每个按钮都有不同的样式。它们在文本颜色和relief属性上有所不同。
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we used the factory design pattern to create several widgets
    that have different styles. We can easily use this design pattern to create entire
    GUIs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用工厂设计模式创建了几个具有不同样式的小部件。我们可以轻松地使用这种设计模式来创建整个GUI。
- en: Design patterns are a very exciting tool in our software development toolbox.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是我们软件开发工具箱中非常令人兴奋的工具。
- en: Avoiding complexity
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免复杂性
- en: In this recipe, we will extend our Python GUI and learn ways to handle the ever-increasing
    complexity of our software development efforts.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将扩展我们的Python GUI，并学习处理软件开发工作不断增加的复杂性的方法。
- en: Our co-workers and clients love the GUIs we create in Python and ask for more
    and more features to add to our GUI.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的同事和客户喜欢我们用Python创建的GUI，并要求为我们的GUI添加越来越多的功能。
- en: This increases complexity and can easily ruin our original nice design.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这增加了复杂性，很容易破坏我们最初的良好设计。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a new Python GUI similar to those in previous recipes and will
    add many features to it in the form of widgets.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个类似于之前示例中的新Python GUI，并将以小部件的形式添加许多功能。
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will start with a Python GUI that has two tabs and looks like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个具有两个选项卡并且看起来像这样的Python GUI开始：
- en: '![How to do it...](graphics/B04829_11_20.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_20.jpg)'
- en: The first new feature request we receive is to add functionality to **Tab 1**,
    which clears the `scrolledtext` widget.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到的第一个新功能请求是为**Tab 1**添加功能，清除`scrolledtext`小部件。
- en: Easy enough. We just add another button to **Tab 1**.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 足够简单。我们只需在**Tab 1**中添加另一个按钮。
- en: '[PRE23]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We also have to create the callback method to add the desired functionality,
    which we define towards the top of our class and outside the method that creates
    our widgets.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须创建回调方法以添加所需的功能，我们在类的顶部定义它，并在创建小部件的方法之外。
- en: '[PRE24]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now our GUI has a new button and, when we click it, we clear the text of the
    `ScrolledText` widget.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的GUI有一个新按钮，当我们点击它时，我们清除`ScrolledText`小部件的文本。
- en: '![How to do it...](graphics/B04829_11_21.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_21.jpg)'
- en: In order to add this functionality, we had to add code in two places in the
    same Python module.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加这个功能，我们不得不在同一个Python模块中的两个地方添加代码。
- en: We inserted the new button in the `createWidgets` method (not shown) and then
    we created a new callback method, which our new button calls when it is clicked.
    We placed this code just below the callback of our first button.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`createWidgets`方法中插入了新按钮（未显示），然后我们创建了一个新的回调方法，当我们的新按钮被点击时调用。我们将这段代码放在第一个按钮的回调之下。
- en: Our next feature request is to add more functionality. The business logic is
    encapsulated in another Python module. We invoke this new functionality by adding
    three more buttons to **Tab 1**. We use a loop to do this.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个功能请求是添加更多功能。业务逻辑封装在另一个Python模块中。我们通过向**Tab 1**添加三个按钮来调用这个新功能。我们使用循环来实现这一点。
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our GUI now looks like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的GUI现在看起来是这样的：
- en: '![How to do it...](graphics/B04829_11_22.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_22.jpg)'
- en: 'Next, our customers ask for more features and we use the same approach. Our
    GUI now looks as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的客户要求更多功能，我们使用相同的方法。我们的GUI现在看起来是这样的：
- en: '![How to do it...](graphics/B04829_11_23.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_23.jpg)'
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is not too bad. When we get new feature requests for another 50 new features,
    we start to wonder if our approach is still the best approach to use…
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不太糟糕。当我们为另外50个新功能请求时，我们开始怀疑我们的方法是否仍然是最好的方法...
- en: One way to handle the ever-increasing complexity our GUI has to handle is by
    adding tabs. By adding more tabs and placing related features into their own tab,
    we get control of the complexity and make our GUI more intuitive.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 处理我们的GUI必须处理的不断增加的复杂性的一种方法是添加选项卡。通过添加更多的选项卡，并将相关功能放入自己的选项卡中，我们可以控制复杂性，并使我们的GUI更直观。
- en: 'Here is the code that creates our new **Tab 3** and, below it, is our new Python
    GUI:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建我们的新**Tab 3**的代码，下面是我们的新Python GUI：
- en: '[PRE26]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![How to do it...](graphics/B04829_11_24.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_11_24.jpg)'
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we added several new widgets to our GUI in order to add more
    functionality to our Python GUI. We saw how more and more new feature requests
    easily got our nice GUI design into a state where it became less clear how to
    use the GUI.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们向我们的GUI添加了几个新的小部件，以便为我们的Python GUI添加更多功能。我们看到，越来越多的新功能请求很容易使我们精美的GUI设计变得不太清楚如何使用GUI。
- en: Note
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Suddenly, widgets took over the world…
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 突然间，小部件占据了世界...
- en: We saw how to handle complexity by modularizing our GUI by breaking large features
    into smaller pieces and arranging them in functionally-related areas using tabs.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何通过将大功能分解为较小的部分，并将它们安排在功能相关的区域中，通过模块化我们的GUI来处理复杂性。
- en: While complexity has many aspects, modularizing and refactoring code is usually
    a very good approach to handling software code complexity.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管复杂性有许多方面，但模块化和重构代码通常是处理软件代码复杂性的非常好的方法。
- en: Note
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In programming, at certain times, we run into a wall and get stuck. We keep
    banging our head against this wall but nothing happens.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，有时候我们会遇到障碍，陷入困境。我们不断地撞击这堵墙，但什么也没有发生。
- en: Sometimes we feel like we want to give up.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们觉得想要放弃。
- en: However, miracles do happen…
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，奇迹确实会发生...
- en: If we keep on banging against this wall, at a certain moment in time, the wall
    will collapse and the road will be open.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续撞击这堵墙，在某个时刻，这堵墙将倒塌，道路将会开放。
- en: At that point in time, we can make a positive dent in the software universe.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个时候，我们可以在软件宇宙中留下积极的印记。
