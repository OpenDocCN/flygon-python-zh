["```py\nimport sys\nprint \"This is the name of the script:\",sys.argv[0]\nprint \"The number of arguments is: \",len(sys.argv)\nprint \"The arguments are:\",str(sys.argv)\nprint \"The first argument is \",sys.argv[1]\n```", "```py\n$ python sys_arguments.py one two three\n```", "```py\nimport sys\nimport os\n\nif len(sys.argv) == 2:\n    filename = sys.argv[1]\n    if not os.path.isfile(filename):\n        print '[-] ' + filename + ' does not exist.'\n        exit(0)\nif not os.access(filename, os.R_OK):\n        print '[-] ' + filename + ' access denied.'\n        exit(0)\n```", "```py\nimport os\npwd = os.getcwd()\nlist_directory = os.listdir(pwd)\nfor directory in list_directory:\n    print directory\n```", "```py\nimport os\nfor root,dirs,files in os.walk(\".\",topdown=False):\n    for name in files:\n        print(os.path.join(root,name))\n    for name in dirs:\n        print name\n```", "```py\nimport os\nimport platform\noperating_system = platform.system()\nprint operating_system\nif (operating_system == \"Windows\"):\n    ping_command = \"ping -n 1 127.0.0.1\"\nelif (operating_system == \"Linux\"):\n    ping_command = \"ping -c 1 127.0.0.1\"\nelse :\n    ping_command = \"ping -c 1 127.0.0.1\"\nprint ping_command\n```", "```py\nimport os\nimport subprocess\n# using system\nos.system(\"ls -la\")\n# using subprocess\nsubprocess.call([\"ls\", \"-la\"])\n```", "```py\n>> subprocess.call(\"cls\", shell=True)\n```", "```py\n>>> p = subprocess.Popen([\"python\", \"--version\"])\n>>> p.terminate()\n```", "```py\n#!/usr/bin/env python\nfrom subprocess import Popen, PIPE\nimport sys\nimport argparse\nparser = argparse.ArgumentParser(description='Ping Scan Network')\n\n# Main arguments\nparser.add_argument(\"-network\", dest=\"network\", help=\"NetWork segment[For example 192.168.56]\", required=True)\nparser.add_argument(\"-machines\", dest=\"machines\", help=\"Machines number\",type=int, required=True)\n\nparsed_args = parser.parse_args()    \nfor ip in range(1,parsed_args.machines+1):\n    ipAddress = parsed_args.network +'.' + str(ip)\n    print \"Scanning %s \" %(ipAddress)\n    if sys.platform.startswith('linux'):\n    # Linux\n        subprocess = Popen(['/bin/ping', '-c 1 ', ipAddress], stdin=PIPE, stdout=PIPE, stderr=PIPE)\n    elif sys.platform.startswith('win'):\n    # Windows\n        subprocess = Popen(['ping', ipAddress], stdin=PIPE, stdout=PIPE, stderr=PIPE)\nstdout, stderr= subprocess.communicate(input=None)\nprint stdout\nif \"Lost = 0\" in stdout or \"bytes from \" in stdout:\n    print \"The Ip Address %s has responded with a ECHO_REPLY!\" %(stdout.split()[1])\n```", "```py\npython PingScanNetWork.py -network 192.168.56 -machines 1\n```", "```py\nimport os\n # you can change the \"/\" to a directory of your choice\n for file in os.walk(\"/\"):\n    print(file)\n```", "```py\n >>> import os\n >>> os.path.isfile(\"/\")\n False\n >>> os.path.isfile(\"./main.py\")\n True\n```", "```py\n >>> import os\n >>> os.path.exists(\"./main.py\")\n True\n >>> os.path.exists(\"./not_exists.py\")\n False\n```", "```py\n >>> if not os.path.exists('my_dir'):\n >>>    os.makedirs('my_dir')\n```", "```py\nif not os.path.exists('my_dir'):\n    try:\n        os.makedirs('my_dir')\n    except OSError as e:\n       print e\n```", "```py\n>>> my_file=open(\"file.txt\",\"r\u201d)\n```", "```py\n>>> for line in file:\n>>>  print line\n```", "```py\n>>> with open(\"somefile.txt\", \"r\") as file:\n>>> for line in file:\n>>> print line\n```", "```py\ndef main():\n    with open('test.txt', 'w') as file:\n        file.write(\"this is a test file\")\n\n if __name__ == '__main__':\n    main()\n```", "```py\n>>> with open('test.txt', 'r') as file:\n>>>    for line in file:\n>>>        print(line)\n```", "```py\ndef main():\n    try:\n        with open('test.txt', 'w') as file:\n            file.write(\"this is a test file\")\n    except IOError as e:\n        print(\"Exception caught: Unable to write to file\", e)\n    except Exception as e:\n        print(\"Another error occurred \", e)\n    else:\n        print(\"File written to successfully\")\n\nif __name__ == '__main__':\n    main()\n```", "```py\nimport thread\nimport time\n\nnum_threads = 4\n\ndef thread_message(message):\n  global num_threads\n  num_threads -= 1\n  print('Message from thread %s\\n' %message)\n\nwhile num_threads > 0:\n  print \"I am the %s thread\" %num_threads\n  thread.start_new_thread(thread_message,(\"I am the %s thread\" %num_threads,))\n  time.sleep(0.1)\n```", "```py\n# Python Thread class Constructor\n def __init__(self, group=None, target=None, name=None, args=(), kwargs=None, verbose=None):\n```", "```py\nimport threading\n\ndef myTask():\n    print(\"Hello World: {}\".format(threading.current_thread()))\n\n # We create our first thread and pass in our myTask function\n myFirstThread = threading.Thread(target=myTask)\n # We start out thread\n myFirstThread.start()\n```", "```py\nimport threading\n\nclass MyThread(threading.Thread):\n\n    def __init__ (self, message):\n        threading.Thread.__init__(self)\n        self.message = message\n\n    def run(self):\n        print self.message\n\nthreads = []\nfor num in range(0, 5):\n    thread = MyThread(\"I am the \"+str(num)+\" thread\")\n    thread.name = num\n    thread.start()\n```", "```py\nimport threading\n\nclass thread_message(threading.Thread):\n    def __init__ (self, message):\n         threading.Thread.__init__(self)\n         self.message = message\n\n    def run(self):\n         print self.message\n\nthreads = []\nfor num in range(0, 10):\n thread = thread_message(\"I am the \"+str(num)+\" thread\")\n thread.start()\n threads.append(thread)\n\n# wait for all threads to complete by entering them\nfor thread in threads:\n thread.join()\n```", "```py\nimport threading\nclass ThreadWorker(threading.Thread):\n    # Our workers constructor\n    def __init__(self):\n        super(ThreadWorker, self).__init__()\n    def run(self):\n        for i in range(10):\n           print(i)\n```", "```py\nimport threading\nfrom ThreadWorker import ThreadWorker \ndef main():\n    # This initializes ''thread'' as an instance of our Worker Thread\n   thread = ThreadWorker()\n    # This is the code needed to run our thread\n    thread.start()\n\nif __name__ == \"__main__\":  \n    main()\n```", "```py\nexecutor = ThreadPoolExecutor(max_workers=5)\n```", "```py\n#python 3\nfrom concurrent.futures import ThreadPoolExecutor\nimport threading\nimport random\n\ndef view_thread():\n print(\"Executing Thread\")\n print(\"Accesing thread : {}\".format(threading.get_ident()))\n print(\"Thread Executed {}\".format(threading.current_thread()))\n\ndef main():\n executor = ThreadPoolExecutor(max_workers=3)\n thread1 = executor.submit(view_thread)\n thread1 = executor.submit(view_thread)\n thread3 = executor.submit(view_thread)\n\nif __name__ == '__main__':\n main()\n\n```", "```py\nfrom concurrent.futures import ThreadPoolExecutor\n\ndef message(message):\n print(\"Processing {}\".format(message))\n\ndef main():\n print(\"Starting ThreadPoolExecutor\")\n with ThreadPoolExecutor(max_workers=2) as executor:\n   future = executor.submit(message, (\"message 1\"))\n   future = executor.submit(message, (\"message 2\"))\n print(\"All messages complete\")\n\nif __name__ == '__main__':\n main()\n```", "```py\nfrom aiohttp import web\nimport socketio\n\nsocket_io = socketio.AsyncServer()\napp = web.Application()\nsocket_io.attach(app)\n\nasync def index(request):\n        return web.Response(text='Hello world from socketio' content_type='text/html')\n\n# You will receive the new messages and send them by socket\n@socket_io.on('message')\ndef print_message(sid, message):\n    print(\"Socket ID: \" , sid)\n    print(message)\n\napp.router.add_get('/', index)\n\nif __name__ == '__main__':\n    web.run_app(app)\n```"]