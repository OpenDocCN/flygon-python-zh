["```py\n            class Dice: \n\n    ```", "```py\n            def __init__(self): \n                self.faces = None \n\n    ```", "```py\n                        def roll(self): \n                            self.faces = (random.randint(1,6), random.randint(1,6)) \n\n        ```", "```py\n                        def total(self): \n                            return sum(self.faces) \n\n        ```", "```py\n                        def hardway(self): \n                            return self.faces[0] == self.faces[1] \n                        def easyway(self): \n                            return self.faces[0] != self.faces[1] \n\n        ```", "```py\n     **>>> import random \n          >>> random.seed(1)** \n\n    ```", "```py\n     **>>> from ch06_r01 import Dice \n          >>> d1 = Dice() \n          >>> d1.roll() \n          >>> d1.total() \n          7 \n          >>> d1.faces \n          (2, 5)** \n\n    ```", "```py\n     **>>> d2 = Dice() \n          >>> d2.roll() \n          >>> d2.total() \n          4 \n          >>> d2.hardway() \n          False \n          >>> d2.faces \n          (1, 3)** \n\n    ```", "```py\n     **>>> d1.total() \n          7** \n\n    ```", "```py\n    Counter({15: 7, 17: 5, 20: 4, 16: 3, ... etc., 45: 1}) \n\n```", "```py\n            class CounterStatistics: \n\n    ```", "```py\n            def __init__(self, raw_counter:Counter): \n                self.raw_counter = raw_counter \n\n    ```", "```py\n            self.mean = self.compute_mean() \n            self.stddev = self.compute_stddev() \n\n    ```", "```py\n            def compute_mean(self): \n                total, count = 0, 0 \n                for value, frequency in self.raw_counter.items(): \n                    total += value*frequency \n                    count += frequency \n                return total/count \n\n    ```", "```py\n            def compute_stddev(self): \n                total, count = 0, 0 \n                for value, frequency in self.raw_counter.items(): \n                    total += frequency*(value-self.mean)**2 \n                    count += frequency \n                return math.sqrt(total/(count-1)) \n\n    ```", "```py\n **>>> from ch04_r06 import * \n>>> from collections import Counter \n>>> def raw_data(n=8, limit=1000, arrival_function=arrival1): \n...    expected_time = float(expected(n)) \n...    data = samples(limit, arrival_function(n)) \n...    wait_times = Counter(coupon_collector(n, data)) \n...    return wait_times** \n\n```", "```py\n **>>> import random \n>>> from ch06_r02 import CounterStatistics \n>>> random.seed(1) \n>>> data = raw_data() \n>>> stats = CounterStatistics(data) \n>>> print(\"Mean: {0:.2f}\".format(stats.mean)) \nMean: 20.81 \n>>> print(\"Standard Deviation: {0:.3f}\".format(stats.stddev)) \nStandard Deviation: 7.025** \n\n```", "```py\n    def add(self, value): \n        self.raw_counter[value] += 1 \n        self.mean = self.compute_mean() \n        self.stddev = self.compute_stddev() \n\n```", "```py\n    def __init__(self, counter:Counter=None): \n        if counter: \n            self.raw_counter = counter \n            self.count = sum(self.raw_counter[k] for k in self.raw_counter) \n            self.sum = sum(self.raw_counter[k]*k for k in self.raw_counter) \n            self.sum2 = sum(self.raw_counter[k]*k**2 for k in self.raw_counter) \n            self.mean = self.sum/self.count \n            self.stddev = math.sqrt((self.sum2-self.sum**2/self.count)/(self.count-1)) \n        else: \n            self.raw_counter = Counter() \n            self.count = 0 \n            self.sum = 0 \n            self.sum2 = 0 \n            self.mean = None \n            self.stddev = None \n\n```", "```py\n    def add(self, value): \n        self.raw_counter[value] += 1 \n        self.count += 1 \n        self.sum += value \n        self.sum2 += value**2 \n        self.mean = self.sum/self.count \n        if self.count > 1: \n            self.stddev = math.sqrt( \n                (self.sum2-self.sum**2/self.count)/(self.count-1)) \n\n```", "```py\n            from collections import namedtuple \n\n    ```", "```py\n            Card = namedtuple('Card', \n\n    ```", "```py\n            Card = namedtuple('Card', ('rank', 'suit')) \n\n    ```", "```py\n **>>> from collections import namedtuple \n>>> Card = namedtuple('Card', ('rank', 'suit')) \n>>> eight_hearts = Card(rank=8, suit='\\N{White Heart Suit}') \n>>> eight_hearts \nCard(rank=8, suit='\u2661') \n>>> eight_hearts.rank \n8 \n>>> eight_hearts.suit \n'\u2661' \n>>> eight_hearts[0] \n8** \n\n```", "```py\n **>>> eight_hearts.suit = '\\N{Black Spade Suit}'  \nTraceback (most recent call last): \n  File \"/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/doctest.py\", line 1318, in __run \n    compileflags, 1), test.globs) \n  File \"<doctest default[0]>\", line 1, in <module> \n    eight_hearts.suit = '\\N{Black Spade Suit}' \nAttributeError: can't set attribute** \n\n```", "```py\n            class Player: \n                pass \n\n    ```", "```py\n            p = Player() \n\n    ```", "```py\n    p.stake = 100 \n\n```", "```py\n            from argparse import Namespace\n    ```", "```py\n            from types import SimpleNamespace \n\n    ```", "```py\n            Player = SimpleNamespace \n\n    ```", "```py\n **>>> from types import SimpleNamespace \n>>> Player = SimpleNamespace \n>>> player_1 = Player(stake=100, hand=[], insurance=None, bet=None) \n>>> player_1.bet = 10 \n>>> player_1.stake -= player_1.bet \n>>> player_1.hand.append( eight_hearts ) \n>>> player_1 \nnamespace(bet=10, hand=[Card(rank=8, suit='\u2661')], insurance=None, stake=90)** \n\n```", "```py\n            class Hand: \n\n    ```", "```py\n                __slots__ = ('hand', 'bet') \n\n    ```", "```py\n            def __init__(self, bet, hand=None): \n                self.hand= hand or [] \n                self.bet= bet \n\n    ```", "```py\n            def deal(self, card): \n                self.hand.append(card) \n\n    ```", "```py\n            def __repr__(self): \n                return \"{class_}({bet}, {hand})\".format( \n                    class_= self.__class__.__name__, \n                    **vars(self) \n                ) \n\n    ```", "```py\n **>>> from ch06_r04 import Card, Hand \n>>> h1 = Hand(2) \n>>> h1.deal(Card(rank=4, suit='\u2663')) \n>>> h1.deal(Card(rank=8, suit='\u2661')) \n>>> h1 \nHand(2, [Card(rank=4, suit='\u2663'), Card(rank=8, suit='\u2661')])** \n\n```", "```py\n **>>> h1.bet *= 2 \n>>> h1 \nHand(4, [Card(rank=4, suit='\u2663'), Card(rank=8, suit='\u2661')])** \n\n```", "```py\n **>>> h1.some_other_attribute = True  \nTraceback (most recent call last): \n  File \"/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/doctest.py\", line 1318, in __run \n    compileflags, 1), test.globs) \n  File \"<doctest default[0]>\", line 1, in <module> \n    h1.some_other_attribute = True  \nAttributeError: 'Hand' object has no attribute 'some_other_attribute'** \n\n```", "```py\n                    lookup = defaultdict(lambda:\"N/A\") \n\n    ```", "```py\n                        import json \n                        user = json.load('~/app.json') \n                        system = json.load('/etc/app.json') \n                        application = json.load('/opt/app/default.json') \n\n        ```", "```py\n                from collections import ChainMap \n                config = ChainMap(user, system, application) \n\n    ```", "```py\n            class StatsList(list): \n\n    ```", "```py\n            def sum(self): \n                return sum(v for v in self) \n\n    ```", "```py\n            def count(self): \n                return sum(1 for v in self) \n\n    ```", "```py\n                def mean(self): \n                    return self.sum() / self.count() \n\n    ```", "```py\n            def sum2(self): \n                return sum(v**2 for v in self) \n            def variance(self): \n                return (self.sum2() - self.sum()**2/self.count())/(self.count()-1) \n            def stddev(self): \n                return math.sqrt(self.variance()) \n\n    ```", "```py\n **>>> from ch06_r06 import StatsList \n>>> subset1 = StatsList([10, 8, 13, 9, 11]) \n>>> data = StatsList([14, 6, 4, 12, 7, 5]) \n>>> data.extend(subset1)** \n\n```", "```py\n **>>> data \n[14, 6, 4, 12, 7, 5, 10, 8, 13, 9, 11]** \n\n```", "```py\n **>>> data.mean() \n9.0 \n>>> data.variance() \n11.0** \n\n```", "```py\n **>>> data.sort() \n>>> data[len(data)//2] \n9** \n\n```", "```py\n    from collections.abc import Mapping \n    class MyFancyMapping(Mapping): \n    etc. \n\n```", "```py\n    Counter({15: 7, 17: 5, 20: 4, 16: 3, ... etc., 45: 1}) \n\n```", "```py\n            class LazyCounterStatistics: \n\n    ```", "```py\n            def __init__(self, raw_counter:Counter): \n                self.raw_counter = raw_counter \n\n    ```", "```py\n            @property \n            def sum(self): \n                return sum(f*v for v, f in self.raw_counter.items()) \n            @property \n            def count(self): \n                return sum(f for v, f in self.raw_counter.items()) \n\n    ```", "```py\n            @property \n            def mean(self): \n                return self.sum / self.count \n\n    ```", "```py\n            @property \n            def sum2(self): \n                return sum(f*v**2 for v, f in self.raw_counter.items()) \n            @property \n            def variance(self): \n                return (self.sum2 - self.sum**2/self.count)/(self.count-1) \n            @property \n            def stddev(self): \n                return math.sqrt(self.variance) \n\n    ```", "```py\n     **>>> from ch04_r06 import * \n          >>> from collections import Counter \n          >>> def raw_data(n=8, limit=1000, arrival_function=arrival1): \n          ...    expected_time = float(expected(n)) \n          ...    data = samples(limit, arrival_function(n)) \n          ...    wait_times = Counter(coupon_collector(n, data)) \n          ...    return wait_times** \n\n    ```", "```py\n     **>>> import random \n          >>> from ch06_r07 import LazyCounterStatistics \n          >>> random.seed(1)** \n\n     **>>> data = raw_data() \n          >>> stats = LazyCounterStatistics(data) \n          >>> print(\"Mean: {0:.2f}\".format(stats.mean)) \n          Mean: 20.81** \n\n     **>>> print(\"Standard Deviation: {0:.3f}\".format(stats.stddev)) \n          Standard Deviation: 7.025** \n\n    ```", "```py\n    def __init__(self, raw_counter:Counter): \n        self.raw_counter = raw_counter \n        self._count = None \n    @property \n    def count(self): \n        if self._count is None: \n            self._count = sum(f for v, f in self.raw_counter.items()) \n        return self._count \n\n```", "```py\n    leg_1 = Leg() \n    leg_1.rate = 6.0 # knots \n    leg_1.distance = 35.6 # nautical miles \n    print(\"Cover {leg.distance:.1f}nm at {leg.rate:.2f}kt = {leg.time:.2f}hr\". \n        format(leg=leg_1)) \n\n```", "```py\n            class Leg: \n            def __init__(self): \n                self._rate= rate \n                self._time= time \n                self._distance= distance. \n\n    ```", "```py\n            @property \n            def rate(self): \n                return self._rate \n\n    ```", "```py\n            @rate.setter \n            def rate(self, value): \n                self._rate = value \n                self._calculate('rate') \n\n    ```", "```py\n            @property \n            def time(self): \n                return self._time \n            @time.setter \n            def time(self, value): \n                self._time = value \n                self._calculate('time') \n            @property \n            def distance(self): \n                return self._distance \n            @distance.setter \n            def distance(self, value): \n                self._distance = value \n                self._calculate('distance') \n\n    ```", "```py\n            from collections import deque \n\n    ```", "```py\n            self._changes= deque(maxlen=2) \n\n    ```", "```py\n                def _calculate(self, change): \n                if change not in self._changes: \n                    self._changes.append(change) \n                compute = {'rate', 'time', 'distance'} - set(self._changes) \n                if compute == {'distance'}: \n                    self._distance = self._time * self._rate \n                elif compute == {'time'}: \n                    self._time = self._distance / self._rate \n                elif compute == {'rate'}: \n                    self._rate = self._distance / self._time \n\n    ```", "```py\n **>>> from ch06_r08 import Leg \n>>> leg_2 = Leg(distance=38.2, time=7) \n>>> round(leg_2.rate, 2) \n5.46 \n>>> leg_2.time=6.5 \n>>> round(leg_2.rate, 2) \n5.88** \n\n```", "```py\n    class Leg: \n        def __init__(self, rate=None, time=None, distance=None): \n            self._changes= deque(maxlen=2) \n            self._rate= rate \n            if rate: self._calculate('rate') \n            self._time= time \n            if time: self._calculate('time') \n            self._distance= distance \n            if distance: self._calculate('distance') \n\n```", "```py\n    def calc_distance(self): \n        self._distance = self._time * self._rate \n    def calc_time(self): \n        self._time = self._distance / self._rate \n    def calc_rate(self): \n        self._rate = self._distance / self._time \n\n```", "```py\n    def _calculate(self, change): \n        if change not in self._changes: \n            self._changes.append(change) \n        compute = {'rate', 'time', 'distance'} - set(self._changes) \n        if len(compute) == 1: \n            name = compute.pop() \n            method = getattr(self, 'calc_'+name) \n            method() \n\n```"]