["```py\nsudo apt-get update && sudo apt-get -y upgrade \nsudo apt-get install python-pip git autoconf automake autopoint libtool pkg-config  \n```", "```py\npip install tabulate==0.7.7\n```", "```py\npip install pytsk3==20170802\n```", "```py\n./synclibs.sh \n./autogen.sh \nsudo python setup.py build \nsudo python setup.py install \n```", "```py\nfrom __future__ import print_function\nimport argparse\nimport os\nimport pytsk3\nimport pyewf\nimport sys\nfrom tabulate import tabulate\n```", "```py\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(\n        description=__description__,\n        epilog=\"Developed by {} on {}\".format(\n            \", \".join(__authors__), __date__)\n    )\n    parser.add_argument(\"EVIDENCE_FILE\", help=\"Evidence file path\")\n    parser.add_argument(\"TYPE\",\n                        help=\"Type of evidence: raw (dd) or EWF (E01)\",\n                        choices=(\"raw\", \"ewf\"))\n    parser.add_argument(\"-o\", \"--offset\",\n                        help=\"Partition byte offset\", type=int)\n    args = parser.parse_args()\n\n    if os.path.exists(args.EVIDENCE_FILE) and \\\n            os.path.isfile(args.EVIDENCE_FILE):\n        main(args.EVIDENCE_FILE, args.TYPE, args.offset)\n    else:\n        print(\"[-] Supplied input file {} does not exist or is not a \"\n              \"file\".format(args.EVIDENCE_FILE))\n        sys.exit(1)\n```", "```py\ndef main(image, img_type, offset):\n    print(\"[+] Opening {}\".format(image))\n    if img_type == \"ewf\":\n        try:\n            filenames = pyewf.glob(image)\n        except IOError:\n            _, e, _ = sys.exc_info()\n            print(\"[-] Invalid EWF format:\\n {}\".format(e))\n            sys.exit(2)\n        ewf_handle = pyewf.handle()\n        ewf_handle.open(filenames)\n```", "```py\n        # Open PYTSK3 handle on EWF Image\n        img_info = EWFImgInfo(ewf_handle)\n    else:\n        img_info = pytsk3.Img_Info(image)\n```", "```py\nclass EWFImgInfo(pytsk3.Img_Info):\n    def __init__(self, ewf_handle):\n        self._ewf_handle = ewf_handle\n        super(EWFImgInfo, self).__init__(url=\"\",\n                                         type=pytsk3.TSK_IMG_TYPE_EXTERNAL)\n\n    def close(self):\n        self._ewf_handle.close()\n\n    def read(self, offset, size):\n        self._ewf_handle.seek(offset)\n        return self._ewf_handle.read(size)\n\n    def get_size(self):\n        return self._ewf_handle.get_media_size()\n```", "```py\n    # Get Filesystem Handle\n    try:\n        fs = pytsk3.FS_Info(img_info, offset)\n    except IOError:\n        _, e, _ = sys.exc_info()\n        print(\"[-] Unable to open FS:\\n {}\".format(e))\n        exit()\n```", "```py\n    root_dir = fs.open_dir(path=\"/\")\n    table = [[\"Name\", \"Type\", \"Size\", \"Create Date\", \"Modify Date\"]]\n    for f in root_dir:\n        name = f.info.name.name\n        if f.info.meta.type == pytsk3.TSK_FS_META_TYPE_DIR:\n            f_type = \"DIR\"\n        else:\n            f_type = \"FILE\"\n        size = f.info.meta.size\n        create = f.info.meta.crtime\n        modify = f.info.meta.mtime\n        table.append([name, f_type, size, create, modify])\n    print(tabulate(table, headers=\"firstrow\"))\n```", "```py\nfrom __future__ import print_function\nimport argparse\nimport os\nimport pytsk3\nimport pyewf\nimport sys\nfrom tabulate import tabulate\n```", "```py\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(\n        description=__description__,\n        epilog=\"Developed by {} on {}\".format(\n            \", \".join(__authors__), __date__)\n    )\n    parser.add_argument(\"EVIDENCE_FILE\", help=\"Evidence file path\")\n    parser.add_argument(\"TYPE\", help=\"Type of Evidence\",\n                        choices=(\"raw\", \"ewf\"))\n    parser.add_argument(\"-p\", help=\"Partition Type\",\n                        choices=(\"DOS\", \"GPT\", \"MAC\", \"SUN\"))\n    args = parser.parse_args()\n\n    if os.path.exists(args.EVIDENCE_FILE) and \\\n            os.path.isfile(args.EVIDENCE_FILE):\n        main(args.EVIDENCE_FILE, args.TYPE, args.p)\n    else:\n        print(\"[-] Supplied input file {} does not exist or is not a \"\n              \"file\".format(args.EVIDENCE_FILE))\n        sys.exit(1)\n```", "```py\ndef main(image, img_type, part_type):\n    print(\"[+] Opening {}\".format(image))\n    if img_type == \"ewf\":\n        try:\n            filenames = pyewf.glob(image)\n        except IOError:\n            print(\"[-] Invalid EWF format:\\n {}\".format(e))\n            sys.exit(2)\n\n        ewf_handle = pyewf.handle()\n        ewf_handle.open(filenames)\n        e01_metadata(ewf_handle)\n\n        # Open PYTSK3 handle on EWF Image\n        img_info = EWFImgInfo(ewf_handle)\n    else:\n        img_info = pytsk3.Img_Info(image)\n```", "```py\ndef e01_metadata(e01_image):\n    print(\"\\nEWF Acquisition Metadata\")\n    print(\"-\" * 20)\n    headers = e01_image.get_header_values()\n    hashes = e01_image.get_hash_values()\n    for k in headers:\n        print(\"{}: {}\".format(k, headers[k]))\n    for h in hashes:\n        print(\"Acquisition {}: {}\".format(h, hashes[h]))\n    print(\"Bytes per Sector: {}\".format(e01_image.bytes_per_sector))\n    print(\"Number of Sectors: {}\".format(\n        e01_image.get_number_of_sectors()))\n    print(\"Total Size: {}\".format(e01_image.get_media_size()))\n```", "```py\n    try:\n        if part_type is not None:\n            attr_id = getattr(pytsk3, \"TSK_VS_TYPE_\" + part_type)\n            volume = pytsk3.Volume_Info(img_info, attr_id)\n        else:\n            volume = pytsk3.Volume_Info(img_info)\n    except IOError:\n        _, e, _ = sys.exc_info()\n        print(\"[-] Unable to read partition table:\\n {}\".format(e))\n        sys.exit(3)\n    part_metadata(volume)\n```", "```py\ndef part_metadata(vol):\n    table = [[\"Index\", \"Type\", \"Offset Start (Sectors)\",\n              \"Length (Sectors)\"]]\n    for part in vol:\n        table.append([part.addr, part.desc.decode(\"utf-8\"), part.start,\n                      part.len])\n    print(\"\\n Partition Metadata\")\n    print(\"-\" * 20)\n    print(tabulate(table, headers=\"firstrow\"))\n```", "```py\nfrom __future__ import print_function\nimport argparse\nimport csv\nfrom datetime import datetime\nimport os\nimport pytsk3\nimport pyewf\nimport sys\n```", "```py\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(\n        description=__description__,\n        epilog=\"Developed by {} on {}\".format(\n            \", \".join(__authors__), __date__)\n    )\n    parser.add_argument(\"EVIDENCE_FILE\", help=\"Evidence file path\")\n    parser.add_argument(\"TYPE\", help=\"Type of Evidence\",\n                        choices=(\"raw\", \"ewf\"))\n    parser.add_argument(\"OUTPUT_CSV\", \n                        help=\"Output CSV with lookup results\")\n    parser.add_argument(\"-p\", help=\"Partition Type\",\n                        choices=(\"DOS\", \"GPT\", \"MAC\", \"SUN\"))\n    args = parser.parse_args()\n\n    directory = os.path.dirname(args.OUTPUT_CSV)\n    if not os.path.exists(directory) and directory != \"\":\n        os.makedirs(directory)\n```", "```py\n    if os.path.exists(args.EVIDENCE_FILE) and \\\n            os.path.isfile(args.EVIDENCE_FILE):\n        main(args.EVIDENCE_FILE, args.TYPE, args.OUTPUT_CSV, args.p)\n    else:\n        print(\"[-] Supplied input file {} does not exist or is not a \"\n              \"file\".format(args.EVIDENCE_FILE))\n        sys.exit(1)\n```", "```py\ndef main(image, img_type, output, part_type):\n    volume = None\n    print(\"[+] Opening {}\".format(image))\n    if img_type == \"ewf\":\n        try:\n            filenames = pyewf.glob(image)\n        except IOError:\n            _, e, _ = sys.exc_info()\n            print(\"[-] Invalid EWF format:\\n {}\".format(e))\n            sys.exit(2)\n\n        ewf_handle = pyewf.handle()\n        ewf_handle.open(filenames)\n\n        # Open PYTSK3 handle on EWF Image\n        img_info = EWFImgInfo(ewf_handle)\n    else:\n        img_info = pytsk3.Img_Info(image)\n```", "```py\n    try:\n        if part_type is not None:\n            attr_id = getattr(pytsk3, \"TSK_VS_TYPE_\" + part_type)\n            volume = pytsk3.Volume_Info(img_info, attr_id)\n        else:\n            volume = pytsk3.Volume_Info(img_info)\n    except IOError:\n        _, e, _ = sys.exc_info()\n        print(\"[-] Unable to read partition table:\\n {}\".format(e))\n\n    open_fs(volume, img_info, output)\n```", "```py\ndef open_fs(vol, img, output):\n    print(\"[+] Recursing through files..\")\n    recursed_data = []\n    # Open FS and Recurse\n    if vol is not None:\n        for part in vol:\n            if part.len > 2048 and \"Unallocated\" not in part.desc and \\\n                    \"Extended\" not in part.desc and \\\n                    \"Primary Table\" not in part.desc:\n                try:\n                    fs = pytsk3.FS_Info(\n                        img, offset=part.start * vol.info.block_size)\n                except IOError:\n                    _, e, _ = sys.exc_info()\n                    print(\"[-] Unable to open FS:\\n {}\".format(e))\n                root = fs.open_dir(path=\"/\")\n                data = recurse_files(part.addr, fs, root, [], [], [\"\"])\n                recursed_data.append(data)\n```", "```py\n    else:\n        try:\n            fs = pytsk3.FS_Info(img)\n        except IOError:\n            _, e, _ = sys.exc_info()\n            print(\"[-] Unable to open FS:\\n {}\".format(e))\n        root = fs.open_dir(path=\"/\")\n        data = recurse_files(1, fs, root, [], [], [\"\"])\n        recursed_data.append(data)\n    write_csv(recursed_data, output)\n```", "```py\ndef recurse_files(part, fs, root_dir, dirs, data, parent):\n    dirs.append(root_dir.info.fs_file.meta.addr)\n    for fs_object in root_dir:\n        # Skip \".\", \"..\" or directory entries without a name.\n        if not hasattr(fs_object, \"info\") or \\\n                not hasattr(fs_object.info, \"name\") or \\\n                not hasattr(fs_object.info.name, \"name\") or \\\n                fs_object.info.name.name in [\".\", \"..\"]:\n            continue\n```", "```py\n        try:\n            file_name = fs_object.info.name.name\n            file_path = \"{}/{}\".format(\n                \"/\".join(parent), fs_object.info.name.name)\n            try:\n                if fs_object.info.meta.type == pytsk3.TSK_FS_META_TYPE_DIR:\n                    f_type = \"DIR\"\n                    file_ext = \"\"\n                else:\n                    f_type = \"FILE\"\n                    if \".\" in file_name:\n                        file_ext = file_name.rsplit(\".\")[-1].lower()\n                    else:\n                        file_ext = \"\"\n            except AttributeError:\n                continue\n```", "```py\n            size = fs_object.info.meta.size\n            create = convert_time(fs_object.info.meta.crtime)\n            change = convert_time(fs_object.info.meta.ctime)\n            modify = convert_time(fs_object.info.meta.mtime)\n            data.append([\"PARTITION {}\".format(part), file_name, file_ext,\n                         f_type, create, change, modify, size, file_path])\n```", "```py\n            if f_type == \"DIR\":\n                parent.append(fs_object.info.name.name)\n                sub_directory = fs_object.as_directory()\n                inode = fs_object.info.meta.addr\n\n                # This ensures that we don't recurse into a directory\n                # above the current level and thus avoid circular loops.\n                if inode not in dirs:\n                    recurse_files(part, fs, sub_directory, dirs, data,\n                                  parent)\n                parent.pop(-1)\n\n        except IOError:\n            pass\n    dirs.pop(-1)\n    return data\n```", "```py\ndef convert_time(ts):\n    if str(ts) == \"0\":\n        return \"\"\n    return datetime.utcfromtimestamp(ts)\n```", "```py\ndef write_csv(data, output):\n    if data == []:\n        print(\"[-] No output results to write\")\n        sys.exit(3)\n\n    print(\"[+] Writing output to {}\".format(output))\n    with open(output, \"wb\") as csvfile:\n        csv_writer = csv.writer(csvfile)\n        headers = [\"Partition\", \"File\", \"File Ext\", \"File Type\",\n                   \"Create Date\", \"Modify Date\", \"Change Date\", \"Size\",\n                   \"File Path\"]\n        csv_writer.writerow(headers)\n        for result_list in data:\n            csv_writer.writerows(result_list)\n```", "```py\nfrom __future__ import print_function\nimport argparse\nimport csv\nimport os\nimport pytsk3\nimport pyewf\nimport sys\n```", "```py\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(\n        description=__description__,\n        epilog=\"Developed by {} on {}\".format(\n            \", \".join(__authors__), __date__)\n    )\n    parser.add_argument(\"EVIDENCE_FILE\", help=\"Evidence file path\")\n    parser.add_argument(\"TYPE\", help=\"Type of Evidence\",\n                        choices=(\"raw\", \"ewf\"))\n    parser.add_argument(\"EXT\",\n                        help=\"Comma-delimited file extensions to extract\")\n    parser.add_argument(\"OUTPUT_DIR\", help=\"Output Directory\")\n    parser.add_argument(\"-p\", help=\"Partition Type\",\n                        choices=(\"DOS\", \"GPT\", \"MAC\", \"SUN\"))\n    args = parser.parse_args()\n```", "```py\n    if not os.path.exists(args.OUTPUT_DIR):\n        os.makedirs(args.OUTPUT_DIR)\n\n    if os.path.exists(args.EVIDENCE_FILE) and \\\n            os.path.isfile(args.EVIDENCE_FILE):\n        main(args.EVIDENCE_FILE, args.TYPE, args.EXT, args.OUTPUT_DIR,\n             args.p)\n    else:\n        print(\"[-] Supplied input file {} does not exist or is not a \"\n              \"file\".format(args.EVIDENCE_FILE))\n        sys.exit(1)\n```", "```py\ndef main(image, img_type, ext, output, part_type):\n    volume = None\n    print(\"[+] Opening {}\".format(image))\n    if img_type == \"ewf\":\n        try:\n            filenames = pyewf.glob(image)\n        except IOError:\n            _, e, _ = sys.exc_info()\n            print(\"[-] Invalid EWF format:\\n {}\".format(e))\n            sys.exit(2)\n\n        ewf_handle = pyewf.handle()\n        ewf_handle.open(filenames)\n\n        # Open PYTSK3 handle on EWF Image\n        img_info = EWFImgInfo(ewf_handle)\n    else:\n        img_info = pytsk3.Img_Info(image)\n\n    try:\n        if part_type is not None:\n            attr_id = getattr(pytsk3, \"TSK_VS_TYPE_\" + part_type)\n            volume = pytsk3.Volume_Info(img_info, attr_id)\n        else:\n            volume = pytsk3.Volume_Info(img_info)\n    except IOError:\n        _, e, _ = sys.exc_info()\n        print(\"[-] Unable to read partition table:\\n {}\".format(e))\n\n    open_fs(volume, img_info, ext, output)\n```", "```py\ndef open_fs(vol, img, ext, output):\n    # Open FS and Recurse\n    print(\"[+] Recursing through files and writing file extension matches \"\n          \"to output directory\")\n    if vol is not None:\n        for part in vol:\n            if part.len > 2048 and \"Unallocated\" not in part.desc \\\n                    and \"Extended\" not in part.desc \\\n                    and \"Primary Table\" not in part.desc:\n                try:\n                    fs = pytsk3.FS_Info(\n                        img, offset=part.start * vol.info.block_size)\n                except IOError:\n                    _, e, _ = sys.exc_info()\n                    print(\"[-] Unable to open FS:\\n {}\".format(e))\n                root = fs.open_dir(path=\"/\")\n                recurse_files(part.addr, fs, root, [], [\"\"], ext, output)\n    else:\n        try:\n            fs = pytsk3.FS_Info(img)\n        except IOError:\n            _, e, _ = sys.exc_info()\n            print(\"[-] Unable to open FS:\\n {}\".format(e))\n        root = fs.open_dir(path=\"/\")\n        recurse_files(1, fs, root, [], [\"\"], ext, output)\n```", "```py\ndef recurse_files(part, fs, root_dir, dirs, parent, ext, output):\n    extensions = [x.strip().lower() for x in ext.split(',')]\n    dirs.append(root_dir.info.fs_file.meta.addr)\n    for fs_object in root_dir:\n        # Skip \".\", \"..\" or directory entries without a name.\n        if not hasattr(fs_object, \"info\") or \\\n                not hasattr(fs_object.info, \"name\") or \\\n                not hasattr(fs_object.info.name, \"name\") or \\\n                fs_object.info.name.name in [\".\", \"..\"]:\n            continue\n        try:\n            file_name = fs_object.info.name.name\n            file_path = \"{}/{}\".format(\"/\".join(parent),\n                                       fs_object.info.name.name)\n            try:\n                if fs_object.info.meta.type == pytsk3.TSK_FS_META_TYPE_DIR:\n                    f_type = \"DIR\"\n                    file_ext = \"\"\n                else:\n                    f_type = \"FILE\"\n                    if \".\" in file_name:\n                        file_ext = file_name.rsplit(\".\")[-1].lower()\n                    else:\n                        file_ext = \"\"\n            except AttributeError:\n                continue\n```", "```py\n            if file_ext.strip() in extensions:\n                print(\"{}\".format(file_path))\n                file_writer(fs_object, file_name, file_ext, file_path,\n                            output)\n            if f_type == \"DIR\":\n                parent.append(fs_object.info.name.name)\n                sub_directory = fs_object.as_directory()\n                inode = fs_object.info.meta.addr\n                if inode not in dirs:\n                    recurse_files(part, fs, sub_directory, dirs,\n                                  parent, ext, output)\n                    parent.pop(-1)\n        except IOError:\n            pass\n    dirs.pop(-1)\n```", "```py\ndef file_writer(fs_object, name, ext, path, output):\n    output_dir = os.path.join(output, ext,\n                              os.path.dirname(path.lstrip(\"//\")))\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n    with open(os.path.join(output_dir, name), \"w\") as outfile:\n        outfile.write(fs_object.read_random(0, fs_object.info.meta.size))\n```", "```py\nfrom __future__ import print_function\nimport argparse\nimport csv\nimport hashlib\nimport os\nimport pytsk3\nimport pyewf\nimport sys\nfrom tqdm import tqdm\n```", "```py\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(\n        description=__description__,\n        epilog=\"Developed by {} on {}\".format(\n            \", \".join(__authors__), __date__)\n    )\n    parser.add_argument(\"EVIDENCE_FILE\", help=\"Evidence file path\")\n    parser.add_argument(\"TYPE\", help=\"Type of Evidence\",\n                        choices=(\"raw\", \"ewf\"))\n    parser.add_argument(\"HASH_LIST\",\n                        help=\"Filepath to Newline-delimited list of \"\n                             \"hashes (either MD5, SHA1, or SHA-256)\")\n    parser.add_argument(\"-p\", help=\"Partition Type\",\n                        choices=(\"DOS\", \"GPT\", \"MAC\", \"SUN\"))\n    parser.add_argument(\"-t\", type=int,\n                        help=\"Total number of files, for the progress bar\")\n    args = parser.parse_args()\n```", "```py\n    if os.path.exists(args.EVIDENCE_FILE) and \\\n            os.path.isfile(args.EVIDENCE_FILE) and \\\n            os.path.exists(args.HASH_LIST) and \\\n            os.path.isfile(args.HASH_LIST):\n        main(args.EVIDENCE_FILE, args.TYPE, args.HASH_LIST, args.p, args.t)\n    else:\n        print(\"[-] Supplied input file {} does not exist or is not a \"\n              \"file\".format(args.EVIDENCE_FILE))\n        sys.exit(1)\n```", "```py\ndef main(image, img_type, hashes, part_type, pbar_total=0):\n    hash_list, hash_type = read_hashes(hashes)\n    volume = None\n    print(\"[+] Opening {}\".format(image))\n    if img_type == \"ewf\":\n        try:\n            filenames = pyewf.glob(image)\n        except IOError:\n            _, e, _ = sys.exc_info()\n            print(\"[-] Invalid EWF format:\\n {}\".format(e))\n            sys.exit(2)\n\n        ewf_handle = pyewf.handle()\n        ewf_handle.open(filenames)\n\n        # Open PYTSK3 handle on EWF Image\n        img_info = EWFImgInfo(ewf_handle)\n    else:\n        img_info = pytsk3.Img_Info(image)\n\n    try:\n        if part_type is not None:\n            attr_id = getattr(pytsk3, \"TSK_VS_TYPE_\" + part_type)\n            volume = pytsk3.Volume_Info(img_info, attr_id)\n        else:\n            volume = pytsk3.Volume_Info(img_info)\n    except IOError:\n        _, e, _ = sys.exc_info()\n        print(\"[-] Unable to read partition table:\\n {}\".format(e))\n\n    open_fs(volume, img_info, hash_list, hash_type, pbar_total)\n```", "```py\ndef read_hashes(hashes):\n    hash_list = []\n    hash_type = None\n    with open(hashes) as infile:\n        for line in infile:\n            if hash_type is None:\n                if len(line.strip()) == 32:\n                    hash_type = \"md5\"\n                elif len(line.strip()) == 40:\n                    hash_type == \"sha1\"\n                elif len(line.strip()) == 64:\n                    hash_type == \"sha256\"\n            hash_list.append(line.strip().lower())\n    if hash_type is None:\n        print(\"[-] No valid hashes identified in {}\".format(hashes))\n        sys.exit(3)\n\n    return hash_list, hash_type\n```", "```py\ndef open_fs(vol, img, hashes, hash_type, pbar_total=0):\n    # Open FS and Recurse\n    print(\"[+] Recursing through and hashing files\")\n    pbar = tqdm(desc=\"Hashing\", unit=\" files\",\n                unit_scale=True, total=pbar_total)\n    if vol is not None:\n        for part in vol:\n            if part.len > 2048 and \"Unallocated\" not in part.desc and \\\n                    \"Extended\" not in part.desc and \\\n                    \"Primary Table\" not in part.desc:\n                try:\n                    fs = pytsk3.FS_Info(\n                        img, offset=part.start * vol.info.block_size)\n                except IOError:\n                    _, e, _ = sys.exc_info()\n                    print(\"[-] Unable to open FS:\\n {}\".format(e))\n                root = fs.open_dir(path=\"/\")\n                recurse_files(part.addr, fs, root, [], [\"\"], hashes,\n                              hash_type, pbar)\n    else:\n        try:\n            fs = pytsk3.FS_Info(img)\n        except IOError:\n            _, e, _ = sys.exc_info()\n            print(\"[-] Unable to open FS:\\n {}\".format(e))\n        root = fs.open_dir(path=\"/\")\n        recurse_files(1, fs, root, [], [\"\"], hashes, hash_type, pbar)\n    pbar.close()\n```", "```py\ndef recurse_files(part, fs, root_dir, dirs, parent, hashes,\n                  hash_type, pbar):\n    dirs.append(root_dir.info.fs_file.meta.addr)\n    for fs_object in root_dir:\n        # Skip \".\", \"..\" or directory entries without a name.\n        if not hasattr(fs_object, \"info\") or \\\n                not hasattr(fs_object.info, \"name\") or \\\n                not hasattr(fs_object.info.name, \"name\") or \\\n                fs_object.info.name.name in [\".\", \"..\"]:\n            continue\n        try:\n            file_path = \"{}/{}\".format(\"/\".join(parent),\n                                       fs_object.info.name.name)\n```", "```py\n            if getattr(fs_object.info.meta, \"type\", None) == \\\n                    pytsk3.TSK_FS_META_TYPE_DIR:\n                parent.append(fs_object.info.name.name)\n                sub_directory = fs_object.as_directory()\n                inode = fs_object.info.meta.addr\n\n                # This ensures that we don't recurse into a directory\n                # above the current level and thus avoid circular loops.\n                if inode not in dirs:\n                    recurse_files(part, fs, sub_directory, dirs,\n                                  parent, hashes, hash_type, pbar)\n                    parent.pop(-1)\n            else:\n                hash_file(fs_object, file_path, hashes, hash_type, pbar)\n\n        except IOError:\n            pass\n    dirs.pop(-1)\n```", "```py\ndef hash_file(fs_object, path, hashes, hash_type, pbar):\n    if hash_type == \"md5\":\n        hash_obj = hashlib.md5()\n    elif hash_type == \"sha1\":\n        hash_obj = hashlib.sha1()\n    elif hash_type == \"sha256\":\n        hash_obj = hashlib.sha256()\n    f_size = getattr(fs_object.info.meta, \"size\", 0)\n    pbar.set_postfix(File_Size=\"{:.2f}MB\".format(f_size / 1024.0 / 1024))\n    hash_obj.update(fs_object.read_random(0, f_size))\n    hash_digest = hash_obj.hexdigest()\n    pbar.update()\n\n    if hash_digest in hashes:\n        pbar.write(\"[*] MATCH: {}\\n{}\".format(path, hash_digest))\n```"]