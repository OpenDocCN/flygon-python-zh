# 引入pytest

自动化测试被认为是生产高质量软件的不可或缺的工具和方法。测试应该是每个专业软件开发人员工具箱的一部分，但与此同时，许多人认为这是工作中无聊和重复的部分。但当您使用pytest作为测试框架时，情况就不一样了。

本书将向您介绍各种关键功能，并教您如何从第一章开始有效地使用pytest进行日常编码任务，重点是让您尽快提高生产力。编写测试应该成为一种乐趣，而不是工作中无聊的部分。

我们将首先看一下自动化测试的重要性。我还会试图说服您，这不是因为这是正确的事情，所以您应该拥有它。自动化测试是您希望拥有的东西，因为它会让您的工作变得更加轻松和愉快。我们将简要介绍Python的标准`unittest`模块，并介绍pytest以及为什么它具有更多的功能，同时使用起来非常简单。然后，我们将介绍如何编写测试，如何将它们组织成类和目录，以及如何有效地使用pytest的命令行。然后，我们将看一下如何使用标记来控制跳过测试或期望测试失败，如何利用自定义标记，以及如何使用相同的测试代码参数化来测试多个输入，以避免复制/粘贴代码。这将帮助我们学习如何使用pytest最受欢迎的功能之一：fixture来管理和重用测试资源和环境。之后，我们将介绍pytest提供的一些更受欢迎和有用的插件。最后，我们将探讨如何逐步将基于`unittest`的测试套件转换为pytest风格，以便在现有代码库中充分利用其许多优势。

在本章中，我们将快速了解为什么我们应该进行测试，内置的`unittest`模块以及pytest的概述。以下内容将被涵盖：

+   为什么要花时间编写测试？

+   快速了解`unittest`模块

+   为什么选择pytest？

让我们先退一步，思考为什么编写测试被认为是如此重要。

# 为什么要花时间编写测试？

手动测试程序是自然的；编写自动化测试则不是。

程序员在学习编码或尝试新技术和库时使用各种技术。编写短小的代码片段，跟随教程，使用REPL玩耍，甚至使用Jupyter（[http://jupyter.org/](http://jupyter.org/)）。通常，这涉及手动验证所学内容的结果，使用打印语句或绘制图形。这是一种简单、自然且完全有效的学习新知识的方式。

然而，这种模式不应该延续到专业软件开发中。专业软件并不简单；相反，它通常非常复杂。根据系统设计的好坏，各个部分可能以奇怪的方式交织在一起，新功能的添加可能会破坏系统的另一个看似无关的部分。修复一个错误可能会导致另一个错误在其他地方出现。

如何确保新功能正常工作或错误已经被彻底解决？同样重要的是，如何确保通过修复或引入新功能，系统的另一部分不会被破坏？

答案是通过拥有一套健康和全面的自动化测试，也称为测试套件。

测试套件简单来说就是测试您的代码的代码。通常，它们会创建一个或多个必要的资源，并调用要测试的应用程序代码。然后，他们断言结果是否符合预期。除了在开发人员的机器上执行外，在大多数现代设置中，它们会被连续运行，例如每小时或每次提交，由像Jenkins这样的自动化系统运行。因此，为一段代码添加测试意味着从现在开始，它将在添加功能和修复错误时一遍又一遍地进行测试。

拥有自动化测试意味着您可以对程序进行更改，并立即查看这些更改是否破坏了系统的某个部分，作为开发人员的安全网。拥有一个良好的测试套件非常令人振奋：您不再害怕改进8年前编写的代码，如果犯了任何错误，测试套件会告诉您。您可以添加一个新功能，并确信它不会破坏您没有预料到的系统的其他部分。能够有信心地将一个大型库从Python 2转换为3，或进行大规模的重构，是绝对必要的。通过添加一个或多个自动化测试来重现一个bug，并证明您已经修复了它，您可以确保这个bug不会在以后的重构或其他编码错误中再次出现。

一旦你习惯了享受测试套件作为安全网的好处，你甚至可能决定为你依赖的API编写测试，但知道开发人员没有测试：能够向原始开发人员提供失败的测试来证明他们的新版本是导致错误的原因，而不是你的代码，这是一个罕见的职业骄傲时刻。

拥有一个写得很好、深入的测试套件将使您能够放心地进行任何大小的更改，并帮助您晚上睡得更好。

# 快速查看unittest模块

Python自带内置的`unittest`模块，这是一个基于Java的单元测试框架JUnit编写自动化测试的框架。您可以通过从`unittest.TestCase`继承并定义以`test`开头的方法来创建测试。以下是使用`unittest`的典型最小测试用例的示例：

```py
    import unittest
    from fibo import fibonacci

    class Test(unittest.TestCase):

        def test_fibo(self):
            result = fibonacci(4)
            self.assertEqual(result, 3)

    if __name__ == '__main__':
        unittest.main()
```

这个例子的重点是展示测试本身，而不是被测试的代码，所以我们将使用一个简单的`fibonacci`函数。斐波那契数列是一个无限的正整数序列，其中序列中的下一个数字是通过将前两个数字相加得到的。以下是前11个数字：

```py
1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
```

我们的`fibonacci`函数接收斐波那契数列的`index`，实时计算值并返回它。

为了确保函数按预期工作，我们使用我们知道正确答案的值来调用它（斐波那契数列的第四个元素是3），然后调用`self.assertEqual(a, b)`方法来检查`a`和`b`是否相等。如果函数有bug并且没有返回预期的结果，当我们执行它时，框架会告诉我们：

```py
 λ python3 -m venv .env
  source .env/bin/activate
 F
 ======================================================================
 FAIL: test_fibo (__main__.Test)
 ----------------------------------------------------------------------
 Traceback (most recent call last):
 File "test_fibo.py", line 8, in test_fibo
 self.assertEqual(result, 3)
 AssertionError: 5 != 3

 ----------------------------------------------------------------------
 Ran 1 test in 0.000s

 FAILED (failures=1)
```

我们的`fibonacci`函数似乎有一个bug，写它的人忘记了对于`n=0`应该返回`0`。修复函数并再次运行测试显示函数现在是正确的：

```py

    λ python test_fibo.py
 .
 ----------------------------------------------------------------------
 Ran 1 test in 0.000s

 OK
```

这很好，当然是朝着正确的方向迈出的一步。但请注意，为了编写这个非常简单的检查，我们必须做一些与检查本身无关的事情：

1.  导入`unittest`

1.  创建一个从`unittest.TestCase`继承的类

1.  使用`self.assertEqual()`进行检查；有很多`self.assert*`方法应该用于所有情况，比如`self.assertGreaterEqual`（用于≥比较），`self.assertLess`（用于<比较），`self.assertAlmostEqual`（用于浮点数比较），`self.assertMultiLineEqual()`（用于多行字符串比较），等等

上述内容感觉像是不必要的样板文件，虽然这当然不是世界末日，但有些人觉得这段代码不符合Pythonic的风格；代码只是为了迎合框架而编写的。

此外，`unittest`框架在帮助您编写真实世界的测试方面并没有提供太多内置功能。需要临时目录吗？您需要自己创建并在之后清理。需要连接到PostgreSQL数据库来测试Flask应用程序？您需要编写支持代码来连接到数据库，创建所需的表，并在测试结束时进行清理。需要在测试之间共享实用程序测试函数和资源吗？您需要创建基类并通过子类化重用它们，在大型代码库中可能会演变成多重继承。一些框架提供自己的`unittest`支持代码（例如Django，[https://www.djangoproject.com/](https://www.djangoproject.com/)），但这些框架很少。

# 为什么选择pytest？

Pytest是一个成熟且功能齐全的测试框架，从小型测试到应用程序和库的大规模功能测试。

Pytest很容易上手。要编写测试，您不需要类；您可以编写以`test`开头并使用Python内置的`assert`语句的简单函数：

```py
    from fibo import fibonacci

    def test_fibo():
        assert fibonacci(4) == 3
```

就是这样。您导入您的代码，编写一个函数，并使用普通的assert调用来确保它们按您的期望工作：无需创建子类并使用各种`self.assert*`方法来进行测试。而美妙的是，当断言失败时，它还提供了有用的输出：

```py
 λ pytest test_fibo2.py -q
 F                                                              [100%]
 ============================= FAILURES ==============================
 _____________________________ test_fibo _____________________________

 def test_fibo():
 >       assert fibonacci(4) == 3
 E       assert 5 == 3
 E        + where 5 = fibonacci(4)

 test_fibo2.py:4: AssertionError
 1 failed in 0.03 seconds
```

请注意，表达式中涉及的值和周围的代码都会显示出来，以便更容易理解错误。

Pytest不仅使编写测试变得**简单**，它还有许多**命令行选项来提高生产力**，比如仅运行最后失败的测试，或者按名称或特殊标记运行特定组的测试。

创建和管理测试资源是经常被忽视的重要方面，通常在教程或测试框架的概述中被忽略。真实应用程序的测试通常需要复杂的设置，比如启动后台工作程序，填充数据库或初始化GUI。使用pytest，这些复杂的测试资源可以通过一个称为**fixtures**的强大机制来管理。fixtures使用简单，但同时非常强大，许多人称之为*pytest的杀手功能*。它们将在[第4章](bf8b3438-83e6-4ce5-9df4-4da086636ef7.xhtml)中详细介绍，*Fixtures*。

定制很重要，pytest通过定义一个非常强大的**插件**系统进一步发展。插件可以改变测试运行的多个方面，从测试的执行方式到提供新的fixtures和功能，以便轻松测试许多类型的应用程序和框架。有一些插件每次以随机顺序执行测试，以确保测试不会改变可能影响其他测试的全局状态，有一些插件多次重复执行失败的测试以排除不稳定的行为，有一些插件在测试运行结束时显示失败，而不仅仅是在最后显示，还有一些插件在多个CPU上执行测试以加快测试套件的速度。还有一些插件在测试Django、Flask、Twisted和Qt应用程序时非常有用，还有一些插件用于使用Selenium进行Web应用程序的验收测试。外部插件的数量真的令人震惊：在撰写本文时，有超过500个pytest插件可供安装和立即使用（[http://plugincompat.herokuapp.com/](http://plugincompat.herokuapp.com/)）。

总结pytest：

+   您可以使用普通的`assert`语句来编写您的检查，并进行详细的报告

+   pytest具有自动测试发现功能

+   它有fixtures来管理测试资源

+   它有许多插件，可以扩展其内置功能，并帮助测试大量的框架和应用程序

+   它可以直接运行基于`unittest`的测试套件，无需任何修改，因此您可以逐渐迁移现有的测试套件

因此，许多人认为pytest是在Python中编写测试的一种Pythonic方法。它使编写简单的测试变得容易，并且足够强大，可以编写非常复杂的功能测试。然而，更重要的是，pytest让测试变得有趣。

使用pytest编写自动化测试，并享受它们的诸多好处，将会变得自然而然。

# 摘要

在本章中，我们介绍了为什么编写测试对于生产高质量软件以及让您有信心引入变化是重要的。之后，我们看了一下内置的`unittest`模块以及如何使用它来编写测试。最后，我们简要介绍了pytest，发现了使用它编写测试是多么简单，看了它的主要特点，还看了大量覆盖各种用例和框架的第三方插件。

在下一章中，我们将学习如何安装pytest，如何编写简单的测试，如何更好地将它们组织到项目的文件和目录中，以及如何有效地使用命令行。
