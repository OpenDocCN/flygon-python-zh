- en: Making a Robotic Arm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作机械臂
- en: Finally, we are where most of us have wanted to be since the start of this book.
    Making a robotic arm! In this chapter, we will learn the concepts behind the working
    of a robotic arm. Undoubtedly, we will also be making a robotic arm for our personal
    use as well that can do limitless things for us.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们终于到达了大多数人自本书开始以来就想要到达的地方。制作一个机械臂！在本章中，我们将学习机械臂工作背后的概念。毫无疑问，我们也将制作一个用于个人使用的机械臂，它可以为我们做无限的事情。
- en: Basics of a robotic arm
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机械臂的基础
- en: If you see a human body, then one of the most distinctive parts that makes us
    able to be different than most other species is the arm. It is the part of the
    body that we use to do most of the work.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到一个人体，那么使我们能够与大多数其他物种不同的最显著的部分之一就是手臂。这是我们用来做大部分工作的身体部分。
- en: The human arm is a very complex mechanism of joints and muscles that work in
    tandem to give it the dexterity that we know it for. Take an example of our shoulder
    joint. If you pay attention, then you will notice that it has the ability to move
    up and down, right and left, and even rotate on its own axis, and all this while
    it just has one single joint, which we know as a ball joint.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 人类的手臂是一个由关节和肌肉组成的非常复杂的机制，它们协同工作以赋予它我们所知道的灵巧性。以我们的肩关节为例。如果你注意观察，你会注意到它有能力向上、向下、向右、向左移动，甚至可以在自己的轴线上旋转，而这一切只是因为它只有一个单一的关节，我们称之为球关节。
- en: When we talk about a robotic arm on a robot, we are undoubtedly talking about
    a complex arrangement of actuators with the body, otherwise known as a chassis,
    to get the desired motion in a three-dimensional space.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论机器人上的机械臂时，我们无疑是在谈论一种复杂的安排，它由执行器和身体（也称为底盘）组成，以在三维空间中获得所需的运动。
- en: Now, let's understand some of the basic parts of any robotic arm. The first
    parts are the actuators. We can use motors to control the robotic arm; however,
    as we have studied earlier, using the motors we have used before will not be the
    ideal solution for it as it cannot hold its position neither does it have a feedback
    mechanism. So we are left with only one option, that is, to use servo motors.
    As we know, they have a handful of torque and have the ability to know where it
    is and to hold its position for as long as we want.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解一些机械臂的基本部件。第一部分是执行器。我们可以使用电机来控制机械臂；然而，正如我们之前学过的，使用之前使用过的电机不是它的理想解决方案，因为它既不能保持位置，也没有反馈机制。因此，我们只剩下一个选择，那就是使用舵机。正如我们所知，它们有大量的扭矩，并且有能力知道它在哪里，并且可以保持其位置，只要我们想要。
- en: The second part of the robot is the chassis, that is, the part that holds all
    the motors together and provides structural support to the robot. This has to
    be made in such a way that it provides motion in all the desirable axis to any
    given joint. This is important as a single servo can only provide motion in one
    single axis. However, there are multiple places in which complex arrangement can
    be used to make the robot traverse in multiple axes. Also, the chassis should
    be rigid, which is extremely important. As we all know, all the material on this
    planet have certain level of flexibility. Also, the construction of the material
    depends on how noncompliant the material would be. This serves a very important
    purpose of repeatability.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人的第二部分是底盘，也就是将所有电机固定在一起并为机器人提供结构支持的部分。这必须以这样的方式制作，以便为任何给定的关节提供所有理想轴线的运动。这很重要，因为单个舵机只能在一个单一轴线上提供运动。然而，有多个地方可以使用复杂的安排使机器人在多个轴线上移动。此外，底盘应该是坚固的，这非常重要。正如我们所知，地球上的所有材料都具有一定程度的柔韧性。材料的构造也取决于材料的不服从性。这对于重复性非常重要。
- en: Now, what is repeatability? As you might have seen in industries or any manufacturing
    units, the robots are installed and they do the same task over and over again.
    This is possible as the robots are programmed to perform a specific set of functions
    under specific circumstances. Now, let's say that the chassis of the robot is
    not rigid. In such a case, even if the servos are 100% precise and get to the
    exact same position over and over again, still the robot may actually differ from
    its actual goal position. This happens as there may be some flexibility in the
    chassis, which is why the final position may differ. Hence, a right chassis is
    a must. It becomes even more important when we are talking about large robots,
    as even the slightest of deformation can lead to a very large change in the final
    position of the arm.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，什么是重复性？你可能在工业或任何制造单位中看到，机器人被安装并一遍又一遍地执行相同的任务。这是可能的，因为机器人被编程执行一组特定的功能在特定的情况下。现在，假设机器人的底盘不是坚固的。在这种情况下，即使舵机是100%精确并且一遍又一遍地到达完全相同的位置，机器人仍然可能与其实际目标位置不同。这是因为底盘可能有一定的柔韧性，这就是为什么最终位置可能会有所不同。因此，正确的底盘是必不可少的。当我们谈论大型机器人时，这变得更加重要，因为即使最轻微的变形也可能导致机械臂最终位置的非常大的变化。
- en: One very common terminology which we use while talking about the robot arm is
    the end effector. This is basically the end of the robot arm, which will be doing
    all the final work for us. End effector in the case of a real human arm can be
    considered the hand. This is at the top of the arm and all the movement of the
    arm is basically to articulate the position of the hand in a three-dimensional
    space. Also, it is the hand that picks up the objects or does the necessary physical
    action. Hence, the term end effector.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在谈论机器人手臂时经常使用的一个术语是末端执行器。这基本上是机器人手臂的末端，它将为我们做所有最终的工作。在真实的人类手臂的情况下，末端执行器可以被认为是手。这位于手臂的顶部，手臂的所有运动基本上是为了在三维空间中表达手的位置。此外，正是手拿起物体或进行必要的物理动作。因此，术语末端执行器。
- en: Now, as the robotic arm is moving in a three dimensional space, it becomes a
    real big problem to define the axis in which the motion is happening. Hence, instead
    of using the axis to define the motion, we generally use the type of motion being
    performed, which gives us a realistic idea of what the motion is and in which
    axis it may be on. To analyze the motion, we use the concept of **Yaw Pitch and
    Roll** (**YPR**).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于机械臂在三维空间中移动，定义运动发生的轴成为一个真正的大问题。因此，我们通常使用正在执行的运动类型来定义运动，这给我们一个关于运动是什么以及在哪个轴上的现实想法。为了分析运动，我们使用**偏航、俯仰和翻滚**（**YPR**）的概念。
- en: '![](Images/3627647f-ae6b-419e-a164-3f5eaa509cf8.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3627647f-ae6b-419e-a164-3f5eaa509cf8.png)'
- en: The preceding diagram will clear most of the doubts about YPR. This concept
    is generally used in aircrafts; however, it is an essential part of a robotic
    hand as well. So, as you can see from the preceding figure, when the nose of the
    plane goes up or down, it will be considered as pitch movement. Similarly, if
    the aircraft changes the heading, then the **Yaw** can be considered to change
    accordingly—the **Yaw** is nothing but the movement of aircraft in the *y* axis.
    Finally, we have something called **Roll**. It is used to understand the angel
    of rotation. As you can see, all these three entities are independent to each
    other and chasing any of it will not have any effect on the other. This concept
    is also useful as no matter what the orientation of the aircraft is, the YPR would
    still be unchanged and very much understandable. Hence, we take this concept straight
    from the aircraft directly to our robots.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表将清除关于YPR的大部分疑惑。这个概念通常用于飞机；然而，它也是机械手的一个重要部分。因此，正如您可以从前面的图表中看到的，当飞机的机头上下移动时，它将被视为俯仰运动。同样，如果飞机改变航向，那么**偏航**也可以相应地改变——**偏航**只是飞机在*y*轴上的运动。最后，我们有一个叫做**翻滚**的东西。它用于理解旋转的角度。正如您所看到的，所有这三个实体是彼此独立的，追逐其中任何一个都不会对其他产生影响。这个概念也很有用，因为无论飞机的方向如何，YPR仍然保持不变，非常容易理解。因此，我们直接从飞机上将这个概念引入到我们的机器人中。
- en: Finally, how can we forget about the processing unit? It is the unit that commands
    all the actuators and does the coordination and the decision making. This processing
    unit in our case is Raspberry Pi, which will command all the actuators. All of
    these preceding components make up a robotic arm.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们怎么能忘记处理单元呢？它是命令所有执行器并进行协调和决策的单元。在我们的情况下，这个处理单元是树莓派，它将命令所有执行器。所有这些前述的组件构成了一个机械臂。
- en: Degrees of freedom
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自由度
- en: Not every robotic arm is the same. They have different load ratings, that is,
    the maximum load that the end effector can take, the speed and reach, that is,
    how far the end effector can reach. However, one very important part of a robotic
    arm is the number of motors it has. So, for every axis, you need at least one
    motor to make the robot traverse in that axis. For example, a human arm has three-dimensional
    freedom in the shoulder joint. Hence, to mimic that joint, you will need a motor
    for every axis, that is, a minimum of three motors are required for the arm to
    move in all the three axis, independently. Similarly, when we talk about the elbow
    joint of our hand, it can only traverse in two dimensions. That is the closing
    and opening of the arm and the finally the rotation of the arm—the elbow does
    not move in the third dimension. Hence, to replicate its motion, we need at least
    two motors, so that we an move the robot in the *w* axis.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个机械臂都相同。它们具有不同的负载评级，即末端执行器可以承受的最大负载，速度和范围，即末端执行器可以达到的距离。然而，机械臂非常重要的一部分是它所拥有的电机数量。因此，对于每个轴，您至少需要一个电机来使机器人在该轴上移动。例如，人类手臂在肩关节具有三维自由度。因此，为了模仿该关节，您将需要每个轴的电机，也就是说，至少需要三个电机才能使手臂在所有三个轴上独立移动。同样，当我们谈论手肘关节时，它只能在两个维度上移动。也就是手臂的张合和最终手臂的旋转，手肘不在第三维度上移动。因此，为了复制它的运动，我们至少需要两个电机，这样我们就可以在*w*轴上移动机器人。
- en: From what we have understood so far, we can safely assume that the more the
    number of motors, the more dexterous the robot would also be. This is mostly the
    case; however, you may use multiple motors to make the robot turn in a single
    axis itself. In such a scenario, the basic concept of counting the number of actuators
    to determine the dexterity of the robot will not work. So how do we determine
    how dexterous the robot is?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们目前所了解的，我们可以安全地假设电机数量越多，机器人的灵巧性也越高。这在大多数情况下是成立的；然而，您可能使用多个电机使机器人在单个轴上旋转。在这种情况下，通过计算执行器数量来确定机器人的灵巧性的基本概念将不起作用。那么我们如何确定机器人的灵巧性呢？
- en: We have a concept called **degrees of freedom** (**DOF**). If I go by the standard
    definition, then I can be very sure that you will be left confused as to what
    it actually means. If you are not convinced, then try finding out on Google yourself.
    A DOF, in very simple and plain English, is a joint that can independently move
    on any given axis. So, for example, if we are talking about a shoulder joint,
    then we have movement in all the three axis. Hence, the degrees of freedom would
    be three. Now, let's take into consideration the elbow joint of our arm. As it
    can only move in pitch and roll, hence there are two DOFs that we end up with.
    If we connect the shoulder joint with the elbow joint, then the DOF will be added
    up and the whole system would be called to have six DOFs. Keep in mind that this
    definition is a very simplified one. There are multiple complexities that you
    will encounter should you choose to dig deeper.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个叫做**自由度**（**DOF**）的概念。如果按照标准定义，我可以非常肯定地说你会对它的实际含义感到困惑。如果你不相信，那就自己去Google上找找看。用非常简单和平实的英语来说，自由度是指关节可以在任何给定的轴上独立移动。所以，例如，如果我们谈论肩关节，那么我们在所有三个轴上都有运动。因此，自由度就是三。现在，让我们考虑一下我们手臂的肘关节。因为它只能在俯仰和滚动中移动，所以我们最终得到两个自由度。如果我们把肩关节和肘关节连接起来，那么自由度就会增加，整个系统将被称为具有六个自由度。请记住，这个定义是非常简化的。如果你选择深入挖掘，你会遇到多种复杂性。
- en: Now, most of the robotic arms that you will encounter would be having close
    to six DOFs. Though you may say that it is less than what human arms have, in
    practicality, it does most of the work and obviously having less DOFs means less
    number of motors leading to lower cost and obviously lower complexity in programming.
    Hence, we try to use as few DOFs as possible.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会遇到的大多数机械臂都有接近六个自由度。虽然你可能会说这比人类的手臂少，但实际上，它完成了大部分工作，显然自由度较少意味着更少的电机数量，从而降低成本，显然编程复杂性也更低。因此，我们尽量使用尽可能少的自由度。
- en: '![](Images/a2bb6d91-ba4e-46da-ab66-3d9495652574.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a2bb6d91-ba4e-46da-ab66-3d9495652574.png)'
- en: Now, in the preceding diagram, you can see a typical robotic arm which has six
    DOFs. The base actuator marked by number **1** gives the freedom of rolling and
    altering the pitch. The elbow actuators marked by number **2** add only one DOF
    of the pitch to the robot. Furthermore, joint number **3** is has the ability
    to travel in **Pitch & Roll**. Finally, we have the end actuator as the gripper
    here; the gripper in itself has one DOF. So, cumulatively, we can say that the
    robot is a six-DOF robot.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在前面的图表中，你可以看到一个典型的机械臂，它有六个自由度。编号为**1**的基本执行器提供了滚动和改变俯仰的自由度。编号为**2**的肘部执行器只为机器人增加了一个俯仰的自由度。此外，第**3**关节有能力在**俯仰和滚动**中移动。最后，我们在这里有末端执行器作为夹具；夹具本身有一个自由度。因此，总体上，我们可以说这个机器人是一个六自由度的机器人。
- en: Power house
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动力源
- en: There is one unit that we have been using in all our projects, but I want to
    emphasize on it in this chapter. This unit is the power unit. The reason we are
    talking about it is because in this chapter we will be controlling multiple servos.
    When we are talking about multiple servos, naturally we will be talking about
    a lot of power consumption. In the robot arm, we have six servo motors. Now, depending
    upon the make and model of the motor, the power consumption will vary. But keeping
    yourself on a safer side and assuming every servo's power consumption to be around
    1 amp would be a good idea. Most of the power supply you would be using might
    not be able to give you this much of burst current. So what should we do?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们所有的项目中，我们一直在使用一个单位，但我想在这一章中强调一下。这个单位是功率单位。我们谈论它的原因是因为在这一章中我们将控制多个舵机。当我们谈论多个舵机时，自然我们将谈论大量的功耗。在机械臂中，我们有六个舵机电机。现在，根据电机的品牌和型号，功耗会有所不同。但是为了保险起见，假设每个舵机的功耗约为1安培是个好主意。你可能使用的大多数电源可能无法提供这么多的突发电流。那么我们该怎么办呢？
- en: We can take the easy approach of taking a higher power output. But, instead,
    we can take the unconventional route. We can have a battery that can deliver this
    much of power when needed. But, the question is, will any battery solve our purpose?
    Obviously, the answer would be no.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取更高功率输出的简单方法。但是，相反，我们可以采取非常规的途径。我们可以有一个电池，在需要时可以提供这么多的功率。但问题是，任何电池都能满足我们的目的吗？显然，答案是否定的。
- en: 'There are multiple types of batteries that exist. These batteries can be distinguished
    based on the following parameters:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种类型的电池。这些电池可以根据以下参数进行区分：
- en: Voltage
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电压
- en: Capacity
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容量
- en: Power to weight ratio
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功率重量比
- en: Maximum charge and discharge rate
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大充电和放电速率
- en: Chemical composition
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 化学成分
- en: These are covered in detail in the upcoming subsections.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将在接下来的小节中详细介绍。
- en: Voltage
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电压
- en: Voltage is the overall potential difference that the battery can create. Every
    battery has a specific voltage that it delivers. One thing to remember is that
    this voltage will vary slightly based on the charge condition of the battery.
    That is, when a 12V battery is fully charged, it may be giving an output of 12.6V.
    However, when it gets fully discharged, it may reach up to 11.4V. So, what battery
    voltage means is the nominal voltage that the battery would be providing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 电压是电池可以产生的总体电位差。每个电池都有它提供的特定电压。要记住的一件事是，这个电压会根据电池的充电状态略有变化。也就是说，当一个12V的电池充满电时，它可能会输出12.6V。然而，当它完全放电时，可能会降到11.4V。因此，电池电压的意思是电池将提供的名义电压。
- en: Capacity
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容量
- en: Now, the second parameter is the capacity. Generally, when you buy a battery,
    you will see its capacity in **milliampere hour** (**mAh**) or in **ampere hours**
    (**Ah**). This is a very simple term. Let me explain this term to you using an
    example. Let's say you have a battery with a capacity of 5 Ah. Now, if I draw
    5 amperes continuously for 1 hour, then the battery will be completely discharged.
    On the contrary, if I draw 10 amperes continuously, then the battery will be discharged
    in half an hour. With this, we can also derive the overall power that the battery
    has using the following simple formula: *Overall Power in Watts* = *Nominal Voltage
    of Battery x Overall battery capacity of battery in amperes*
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第二个参数是容量。通常，当你购买电池时，你会看到它的容量以毫安时（mAh）或安时（Ah）为单位。这是一个非常简单的术语。让我用一个例子来解释这个术语给你。假设你有一个容量为5Ah的电池。现在，如果我连续绘制5安培1小时，那么电池将完全放电。相反，如果我连续绘制10安培，那么电池将在半小时内放电。通过这个，我们还可以使用以下简单的公式推导出电池的总功率：*电池的总功率=电池的标称电压x电池的总容量*
- en: Hence, if you have a battery of 12V, which has a capacity of 10 Ah, then the
    overall capacity in watts will be 120 watts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你有一个12V的电池，其容量为10Ah，那么总容量将是120瓦特。
- en: Power-to-weight ratio
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功率重量比
- en: Weight plays a very crucial role in robotics and if we increase the weight of
    the robot, then the force required to move it can exponentially go up. Hence,
    the concept of power to weight ratio comes into play. We always prefer a battery,
    which is extremely lightweight and delivers a large sum of power in respect to
    the weight. The equation for the power-to-weight ratio can be defined as follows: *Power
    to weight ratio in watt hour/kg* = *Maximum Power in watts / Overall weight of
    battery in kg.*
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重量在机器人技术中扮演着非常关键的角色，如果我们增加机器人的重量，那么移动它所需的力量可能会呈指数级增长。因此，功率重量比的概念就出现了。我们总是更喜欢一个极轻的电池，它在重量方面提供了大量的功率。功率重量比的方程可以定义如下：*每公斤瓦时的功率重量比=瓦特的最大功率/电池的总重量*
- en: Now, let's say a battery is providing a power of 500 watts and the weight is
    5 kg, then the power to weight ratio will be 100 Wh/kg. The higher the power to
    weight ratio, the better the battery is.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设一个电池提供了500瓦的功率，重量为5公斤，那么功率重量比将是100瓦时/公斤。功率重量比越高，电池就越好。
- en: Maximum charge and discharge rate
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最大充电和放电速率
- en: This is perhaps one of the most crucial parts of the battery. Often the batteries
    are capable of running the robot for a span of 1 hour. However, the power consumption
    of robots is not constant. Let's say for 90% of the time, our robotic arm is consuming
    2 amperes of power, so the battery capacity is of 2 Ah. However, at some points
    of time during the operation, the robot needs all the motors to work on peak power.
    The peak power consumption of the robot is around 6 amperes. Now, the question
    is, will the battery of 2 Ah be able to provide 6 amperes power to the robot?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是电池中最关键的部分之一。通常，电池能够让机器人运行1小时。然而，机器人的功耗并不是恒定的。假设在90%的时间里，我们的机械臂消耗2安培的功率，所以电池容量为2Ah。然而，在操作过程中的某些时刻，机器人需要所有电机以最大功率工作。机器人的峰值功耗约为6安培。现在，问题是，2Ah的电池能否为机器人提供6安培的功率？
- en: This is a very practical challenge. You may say, it is better to go with a battery
    that is much bigger than a 2 Ah battery. But, as you know, it will increase the
    weight phenomenally. So what's the solution?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常实际的挑战。你可能会说，最好选择一个比2Ah电池大得多的电池。但是，正如你所知，这将显著增加重量。那么解决方案是什么呢？
- en: There is something called peak discharge current. This is denoted by *C* rating.
    So, if our battery is of 1 C rating then a 2 Ah battery will only be able to give
    us a maximum of 2 Ah of power supply at any given time. However, if the battery
    is of 10 C rating, then it should be able to provide a burst power supply of up
    to 20 amperes. These days, you can find batteries that can give a burst power
    supply of up to 100 C or even more. The reason we have this is because the peak
    power consumption of robots can be exponentially higher than their constant power
    consumption. If, at any point, the battery is not able to pull ample amount of
    power, then the robot would behave erroneously and can even shut down.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个叫做峰值放电电流的东西。这由*C*评级表示。因此，如果我们的电池是1C评级，那么2Ah的电池一次只能提供最多2Ah的电源。然而，如果电池是10C评级，那么它应该能够提供高达20安培的突发电源。如今，你可以找到可以提供高达100C甚至更高的突发电源的电池。我们之所以有这个是因为机器人的峰值功耗可能比它们的恒定功耗高得多。如果在任何时候，电池无法提供足够的电力，那么机器人将表现异常，甚至可能关闭。
- en: The second part of this story is the charge rating. This is the maximum charge
    current that you can provide to the battery. It is also denoted by the same C
    rating. So, if the C rating is 0.5, then you can provide a max of 1 ampere of
    charge to a 2 Ah battery.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '这个故事的第二部分是充电评级。这是你可以提供给电池的最大充电电流。它也由相同的C评级表示。因此，如果C评级为0.5，那么你可以为2Ah的电池提供最大1安培的充电。 '
- en: In other words, the fastest you can charge a battery would be in 2 hours.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你可以给电池充电的最快速度是2小时。
- en: Chemical composition
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 化学成分
- en: 'There are different types of batteries that you can find on the market these
    are broadly segregated by their chemical composition. All of these batteries have
    their own pros and cons. Hence, we cannot say that one is better than the other.
    It is always a trade-off between various factors. The following is a list of batteries
    you can find on the market along with their pros and cons:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有不同类型的电池，它们通常根据其化学成分进行广泛分类。所有这些电池都有各自的优缺点。因此，我们不能说哪一个比另一个更好。这总是在各种因素之间进行权衡。以下是市场上可以找到的电池列表，以及它们的优缺点：
- en: '| **Battery** | **Peak power output** | **Power-to-weight ratio** | **Price**
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **电池** | **峰值功率输出** | **功率重量比** | **价格** |'
- en: '| Wet cell | Low | Extremely low | Cheapest |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 湿电池 | 低 | 极低 | 最便宜 |'
- en: '| Nickel metal hydride | Medium | Low | Cheap |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 镍氢电池 | 中等 | 低 | 便宜 |'
- en: '| Lithium ion | High | Good | High |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 锂离子 | 高 | 好 | 高 |'
- en: '| Lithium polymer | Extremely high | Extremely good | Extremely high |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 锂聚合物 | 极高 | 极好 | 极高 |'
- en: As you can see from this table, the peak power output is something which we
    highly want and so is the good power-to-weight ratio; hence, spending a good amount
    of money on a lithium polymer battery makes sense.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个表中可以看出，峰值功率输出是我们非常想要的，良好的功率重量比也是如此；因此，在锂聚合物电池上花费一定的金额是有道理的。
- en: These batteries, at a minimum, have a 20 C rating with a power-to-weight ratio
    around five times higher than the normal wet cell batteries. However, they can
    be up to 10 times more expensive than the normal wet cell batteries.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些电池，至少具有20C的额定值，功率重量比约为普通湿电池的五倍。然而，它们的价格可能是普通湿电池的10倍。
- en: Now we know which batteries to choose for those higher current requirements.
    A lithium polymer battery of 11.1V and 2200 mAh will not cost you more than $20
    and will provide you with immense power that you may never need. So, we have the
    power supply issue sorted. Now it's time to go ahead and make the robotic hand
    operational.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了为这些更高电流要求选择哪些电池。一块11.1V和2200毫安时的锂聚合物电池不会花费你超过20美元，并且将为你提供你可能永远不需要的巨大功率。所以，我们已经解决了电源供应问题。现在是时候继续使机械手运行了。
- en: Finding the limits
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找极限
- en: The robotic arm kit is a fairly easy one to procure from eBay or Amazon. This
    is not very difficult to assemble and will require a few hours to prepare. Some
    of the robotic arm kits might not ship with servo motors, in which case, you may
    have to order it separately. I would say go for the kit that comes bundled with
    the servos, as there can be compatibility issues if you choose to order servos
    separately.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 机械臂套件在eBay或亚马逊上相对容易获得。这并不难组装，需要几个小时来准备。一些机械臂套件可能不会随舵机一起发货，如果是这样，你可能需要单独订购。我建议选择与舵机捆绑在一起的套件，因为如果你选择单独订购舵机，可能会出现兼容性问题。
- en: 'As you know, these servos will work using PWM and it''s not hard to control
    them either. So, let''s go straight onto it and see what we can do. Once you have
    assembled the robotic arm kit, connect the wires of the servos as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，这些舵机将使用PWM工作，控制它们也不难。所以，让我们直接开始并看看我们能做些什么。一旦你组装好了机械臂套件，将舵机的线连接如下：
- en: '![](Images/3a2a8a1f-c77f-4279-b01b-093d65b5da18.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3a2a8a1f-c77f-4279-b01b-093d65b5da18.png)'
- en: 'Now, firstly, we need to know what are the maximum physical limits of every
    single servo connected on our robot. There are various techniques to do that.
    The very basic one is to measure it physically. This method can be good but you
    won''t be able to ever utilize the full potential of the servo motor as you would
    be having some degree of error in measuring. Hence, the value you put in the servo
    will be slightly less than what you think it can go to. The second method is by
    manually feeding the data and finding out the exact angle. So, let''s go ahead
    with the second way of doing things and upload the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，首先，我们需要知道我们机器人上连接的每个舵机的最大物理极限是什么。有各种各样的技术可以做到这一点。最基本的方法是进行物理测量。这种方法可能很好，但你将无法充分利用舵机电机的全部潜力，因为在测量时会有一定程度的误差。因此，你放入舵机的值将略小于你认为它可以达到的值。第二种方法是手动输入数据并找出确切的角度。所以，让我们继续用第二种方法做事情，并上传以下代码：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let's see what this code is doing. This code may look pretty elaborate,
    but what it is doing is extremely simple.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这段代码在做什么。这段代码看起来可能相当复杂，但它所做的事情非常简单。
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the preceding line of code, we are printing the statement for the user
    `select servo from 1-6`. When the user enters a value of the servo, this value
    gets stored in a variable `j`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码行，我们正在为用户打印`从1-6选择舵机`的语句。当用户输入舵机的值时，这个值被存储在一个名为`j`的变量中：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This `if` condition here checks for the value of `j`. If in this line, `j=1`,
    then it will run the code corresponding to the servo number `1`. Inside this code,
    the first line will print `select value to rotate`. Once this is done, the program
    will then wait for user input. Once the user inputs any value, then it will be
    stored in a variable called `I`. Thereafter, using the `cvt_angle(i)` function, the
    value which the user has input into the system will be converted to its corresponding
    duty cycle value. This duty cycle value will be fetched to the `pwm1.ChangeDutyCycle()` argument
    thereby giving the robot that very certain angle in the particular joint that
    you want. Due to the `time.sleep(2)` function, the servo will wait to go over
    to the next line. Thereafter, we are using the line `pwm1.ChangeDutyCycle(cvt_angle(90))`,
    which will bring it back to 90 degrees.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`if`条件检查`j`的值。如果在这一行中，`j=1`，那么它将运行与舵机编号`1`对应的代码。在这段代码中，第一行将打印`选择要旋转的值`。完成后，程序将等待用户输入。一旦用户输入任何值，它将被存储在一个名为`I`的变量中。然后，使用`cvt_angle(i)`函数，用户输入的值将被转换为相应的占空比值。这个占空比值将被获取到`pwm1.ChangeDutyCycle()`参数中，从而给予机器人你想要的特定关节角度。由于`time.sleep(2)`函数，舵机将等待到下一行。之后，我们使用`pwm1.ChangeDutyCycle(cvt_angle(90))`这一行，这将把它带回到90度。
- en: You may ask, why are we doing this? This is for a very important reason. Let's
    say you have given it a command to go beyond its physical limit. If that's the
    case, then the servo will keep on trying to move in that direction no matter what. However,
    due to the physical constrain, it will not be able to go ahead. Once this happens,
    then, within a few seconds, you will see blue smoke coming out of your servo indicating
    its death. The problem is that making such type of errors is very easy and the
    loss is quite noticeable. Hence, to prevent this, we quickly bring it back to
    the central position where it does not have any possibility of burning up.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么我们要这样做？这是一个非常重要的原因。假设您已经给它一个超出其物理极限的命令。如果是这种情况，那么舵机将继续尝试朝那个方向移动，不管发生什么。然而，由于物理限制，它将无法继续前进。一旦发生这种情况，然后在几秒钟内，您将看到蓝烟从舵机中冒出，表明它的损坏。问题在于，制造这种类型的错误非常容易，损失是非常明显的。因此，为了防止这种情况，我们迅速将其带回到中心位置，这样它就不会有任何烧毁的可能性。
- en: Now, as per the preceding code, the same is done for servos 1-6 through the
    robot. Now that you know what is happening, it's time to take a pen and a paper
    and start giving servos the angular values. Do remember that the final goal of
    this code is to find out the maximum limits. So, let's start doing it starting
    from 90 degrees onwards. Give it a value on either side and not down until which
    value you can take it. Make a list on a paper as we will require it for our next
    code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根据前面的代码，通过机器人对舵机1-6执行相同的操作。现在你知道发生了什么，是时候拿起笔和纸开始给舵机赋予角度值了。请记住，这段代码的最终目标是找出最大限制。因此，让我们从90度开始做起。在每一侧给它一个值，直到你能够接受的值。在纸上列出清单，因为我们将需要它用于下一段代码。
- en: Making the robot safe
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使机器人安全
- en: In the previous part of the chapter, with our multiple attempts, we have been
    able to find the maximum positions for each of the servos. Now it's time to use
    these values. In this chapter, we will be programming the servos for what its
    absolute maximums are. In this program, we will make sure that servos will never
    need to travel even a degree beyond the defined parameters on both the sides.
    If the user gives a value beyond it, then it will simply choose to ignore the
    user inputs instead of causing self damage.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前一部分中，通过我们的多次尝试，我们已经能够找到每个舵机的最大位置。现在是时候使用这些值了。在本章中，我们将为舵机编程其绝对最大值。在这个程序中，我们将确保舵机永远不需要超出两侧的定义参数。如果用户给出超出它的值，那么它将选择忽略用户输入，而不是造成自身损坏。
- en: 'So, let''s see how to get it done. There are some parts of this program, where
    the numeric values have been bold. These are the values that you need to replace
    with the values which we have noted in the previous section of this chapter. For
    example, for servo 1, the values noted down are `23` and `170` as the maximum
    values for either side. Hence, the change in the code will be from `if a[0] <
    160 and a[0] > 30` to `ifa[0] < 170 and a[0] > 23`. Similarly, for every servo,
    the same procedure has to be followed:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看如何完成它。在程序的某些部分，数字值已经用粗体标出。这些是您需要用本章前面记录的值替换的值。例如，对于舵机1，记录下的值是`23`和`170`，作为每一侧的最大值。因此，代码的更改将从`if
    a[0] < 160 and a[0] > 30`变为`ifa[0] < 170 and a[0] > 23`。同样，对于每个舵机，必须遵循相同的程序：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, in this code, we have done something very rudimentary. You can safely say
    that all we have done is put the `ChangeDutyCycle()` function inside an `if` statement.
    This `if` statement will govern whether the servo will move or stay still in its
    own position. To some, it may seem very naive to have this program in a special
    section. But, trust me, it is not. This statement will now be used as a part of
    every program from here on. All the code written for the movement of the servos
    will have to check the final values going to the servos through this `if` statement;
    hence, a basic visualization of code is extremely necessary.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这段代码中，我们做了一些非常基础的事情。您可以放心地说，我们所做的一切就是将`ChangeDutyCycle()`函数放在一个`if`语句中。这个`if`语句将决定舵机是移动还是保持在原位。对一些人来说，将这个程序放在一个特殊的部分似乎很天真。但是，请相信我，不是这样的。这个语句现在将作为以后每个程序的一部分。为了检查通过这个`if`语句传递给舵机的最终值，必须检查为舵机移动编写的所有代码；因此，对代码的基本可视化是非常必要的。
- en: Now that the explanation is done, it's time for you to give different commands
    and see whether they are working within the safe working limits.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在解释完毕，是时候给出不同的命令并查看它们是否在安全工作限制内工作了。
- en: Programming multiple frames
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写多个帧
- en: In the previous chapter, we have learned the basics of how to make sure that
    the robot is working under safe limits. In this chapter, we will be looking at
    how a robot can be made to do different activities at a click of a button, instead
    of typing the values one by one.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经学习了如何确保机器人在安全限制下工作的基础知识。在本章中，我们将看看如何使机器人能够在点击按钮的同时执行不同的活动，而不是逐个输入值。
- en: To do this, we will need to understand some advanced concepts of motion. Whenever
    you watch any video or play any video games, then you must have come across the
    term **frames per second** (**FPS**). If you haven't heard this term, then let
    me explain it for you. Every video made right now is actually made by still images.
    These still images are captured by cameras that click 25-30 times in a second.
    When these images are played back on the screen at the same rate at which they
    are captured, it forms a smooth video.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要了解一些高级运动概念。每当您观看任何视频或玩任何视频游戏时，您一定会遇到“每秒帧数”（FPS）这个术语。如果您还没有听说过这个术语，那么让我为您解释一下。现在制作的每个视频实际上都是由静止图像制成的。这些静止图像是由摄像机捕捉的，每秒点击25-30次。当这些图像以与它们被捕捉的速率相同的速率在屏幕上播放时，它形成了一个平滑的视频。
- en: Similarly, in robots, we do have the concept of frames. These frames, however,
    are not images but instead multiple steps that the robot has to follow to achieve
    a specific motion. In a simple robotic program, there could be simply two frames,
    that is, the initial frame and the final frame. These two frames will correspond
    to the initial position or the final position.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在机器人中，我们也有帧的概念。然而，这些帧不是图像，而是机器人必须遵循的多个步骤。在一个简单的机器人程序中，可能只有两个帧，即初始帧和最终帧。这两个帧将对应于初始位置或最终位置。
- en: However, in the real world, this is not always possible, as whenever the robot
    goes directly from the initial position to the final position, it tends a specific
    path with a specific curvature. However, there can be obstacles in that path or
    this path would not be desired as the path that needs to be followed could be
    a different one. Hence, we need frames. These frames not only define the robot's
    motion from the initial position to the final position, but also break down the
    transition from these two positions into multiple steps making the robot follow
    the desired path.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在现实世界中，这并不总是可能的，因为当机器人直接从初始位置到最终位置时，它会沿着特定的路径运动，并具有特定的曲率。然而，在这条路径上可能会有障碍物，或者这条路径可能不是所需的，因为需要遵循的路径可能是另一条。因此，我们需要帧。这些帧不仅定义了机器人从初始位置到最终位置的运动，而且将这两个位置之间的过渡分解为多个步骤，使机器人遵循所需的路径。
- en: This can be referred as frame programming, which we will cover in this chapter.
    One thing to keep in mind is that more the number of frames, smoother will be
    the functioning of the robot. Do you remember the CCTV footage we saw? We could
    say it's not smooth and has a lot of jerkiness. This is due to the low frame rate
    of the CCTV camera. Instead of working on 30 FPS, they work on 15 FPS. This is
    done to reduce the storage space of the video. However, if you see the latest
    videos, there are some games and videos with much higher frame rate than normal.
    Some of our latest camera works on 60 FPS, making the video even smoother and
    enjoyable to watch. The same will be the case with the robot. The more the number
    of frames, the smoother and controlled the motion would be. However, make sure
    you don't go into overkill.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以被称为帧编程，在本章中我们将介绍。要记住的一件事是，帧数越多，机器人的运行就越平稳。你还记得我们看到的闭路电视录像吗？我们可以说它不够平滑，而且有很多抖动。这是由于闭路电视摄像头的低帧率造成的。它们不是以30FPS工作，而是以15FPS工作。这是为了减少视频的存储空间。然而，如果你看到最新的视频，有一些游戏和视频的帧率比正常的要高得多。我们最新的摄像头有60FPS的工作，使视频更加平滑和愉快。机器人也是如此。帧数越多，运动就越平滑和可控。但是，请确保不要过度使用。
- en: 'Now, to move from one position to another, we will have to put the values of
    the angles of every single servos in the very beginning. Once fetched, it will
    automatically start to execute these values one by one. To do this, go ahead and
    write the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要从一个位置移动到另一个位置，我们将不得不在一开始就放入每个舵机的角度值。一旦获取，它将自动开始逐个执行这些值。为此，请继续编写以下代码：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this program, you can see that we have replicated the previous program with
    some very minor changes. So, let''s see what these changes are:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，你可以看到我们复制了以前的程序并进行了一些非常小的改动。所以，让我们看看这些改动是什么：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we are taking the input values for each servo and storing it in a different
    list. For servo 1, the list `a` will be used; similarly, `b` will be used for
    servo 2, and so on until `f`. In the preceding lines of code, the robot will prompt
    the user to fill in the six frame values for `motor 1`. Then, it will ask six
    values for `motor 2` and similarly until `motor 6`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在为每个舵机获取输入值并将其存储在不同的列表中。对于舵机1，将使用列表`a`；类似地，对于舵机2，将使用`b`，依此类推直到`f`。在代码的前面几行中，机器人将提示用户填写`电机1`的六个帧值。然后，它将要求`电机2`的六个值，以此类推直到`电机6`。
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The entire program for giving PWM to the servo is concentrated in this for loop.
    This loop will check the value of `i` and increment it every time. The value of
    `i` will start from `1` and the loop will run and increment the value of `i` until
    it reaches `6`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 给舵机提供PWM的整个程序都集中在这个for循环中。这个循环将检查`i`的值并每次递增。`i`的值将从`1`开始，循环将运行并递增`i`的值直到达到`6`。
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this line of the program, the value contained in the list is headed based
    on the value of `1`. So, for the first time it will read the value of `a[1]`,
    which will correspond to the first value of the list `a[]`. This value should
    be between the safe working limits, hence the `if` loop. If it is within safe
    working limits, then the program in the `if` condition will work, else it won''t.
    Inside the `if` loop, we have a simple statement: `pwm1.ChangeDutyCycle(cvt_angle(a[I]))`.
    This will simply take the value of `a[1]` and convert it into the corresponding
    PWM value and fetch it to the `ChangeDutyCycle()` function, which will change
    the PWM for servo 1.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的这一行中，列表中包含的值是基于`1`的值进行排序的。因此，第一次它将读取`a[1]`的值，这将对应于列表`a[]`的第一个值。这个值应该在安全工作范围内，因此使用`if`循环。如果在安全工作范围内，那么`if`条件中的程序将执行，否则不会执行。在`if`循环内，我们有一个简单的语句：`pwm1.ChangeDutyCycle(cvt_angle(a[I]))`。这将简单地取`a[1]`的值并将其转换为相应的PWM值，并将其提取到`ChangeDutyCycle()`函数中，这将改变舵机1的PWM。
- en: A similar program is made for the rest of the servos as well going on from servo
    1 to servo 6\. Hence, all of these will read the values of their corresponding
    list one by one and change the angle of the servo the way the user has programmed
    it. Furthermore, as the loop gets executed, the value of `i` will increase, hence
    making the program read the different values fetched in the list. Every value
    of the servo in the list will correspond to a different frame, hence parsing the
    robot through it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其余的舵机也制作了类似的程序，从舵机1到舵机6。因此，所有这些都将逐一读取其对应列表中的值，并根据用户编程的方式改变舵机的角度。此外，随着循环的执行，`i`的值将增加，从而使程序读取列表中提取的不同值。列表中舵机的每个值将对应一个不同的帧，从而使机器人通过它。
- en: So go ahead and have some fun making your robot do some awesome moves. Just
    take care that you be gentle to it!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所以继续玩一些有趣的东西，让你的机器人做一些很棒的动作。只要小心对待它！
- en: Speed control
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 速度控制
- en: It's amazing to have made a robotic arm so easily, and with just a bit of code,
    we are now able to control it the way we want. However, there is one problem you
    might have noticed, that is, the robot is moving the way we want but not at the
    speed at which we want it to move. This is a very common problem while using the
    digital PWM-based servos.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 能够如此轻松地制作一个机械臂真是太神奇了，只需一点点代码，我们现在就能够按照自己的意愿来控制它。然而，你可能已经注意到了一个问题，那就是，机器人按照我们的意愿移动，但速度不是我们想要的。这是在使用基于数字PWM的舵机时非常常见的问题。
- en: These servos do not have a built-in speed control. Their control system is programmed
    to move the servo as fast as they can to reach the goal position. Hence, to control
    the speed, we will have to play with the program itself and give it a smooth linear
    progression.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些舵机没有内置的速度控制。它们的控制系统被编程为尽可能快地移动舵机以达到目标位置。因此，要控制速度，我们必须对程序本身进行调整，并给它一个平稳的线性进展。
- en: 'The speed control can be done through a few different techniques. So, without
    much talking, let''s go and see the code. Before you write it, read it and go
    through the code once and then see the following explanation to it. Thereafter,
    you will have a better idea of what we are doing. This will make writing the code
    faster and easier. So, let''s take a look at it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 速度控制可以通过几种不同的技术来实现。所以，不多说了，让我们去看看代码。在你编写代码之前，先读一遍，然后看一下下面的解释。之后，你会更清楚我们在做什么。这将使编写代码更快、更容易。所以，让我们来看看：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this program, there are quite a few things. We should go through them one
    by one to have an understanding of it. So, let''s see what we are doing:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，有很多东西。我们应该逐一了解它们。所以，让我们看看我们在做什么：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we have defined six new variables with the name `prev0` to `prev5` and
    all of them have been allowed a value of `90`. The term `prev` here stands for
    previous, so this will be there to indicate the previous value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了六个新变量，名称为`prev0`到`prev5`，它们都被赋予了值`90`。这里的术语`prev`代表之前的值，因此它将指示先前的值。
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After the code line `for i in range 6`, we have the preceding line of code,
    which is basically checking the value of `a[i]` with `prev0`. Similarly, it is
    checking the values of `b[i]` with `prev1` and so on. Until the time all of these
    are not true the `while` loop will be true and will loop the program inside it
    until the condition is not false. That is, all the `prev` values are exactly equal
    to the values of the corresponding values of the list.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码行`for i in range 6`之后，我们有前面的代码行，基本上是检查`a[i]`的值与`prev0`的值。类似地，它正在检查`b[i]`的值与`prev1`的值，依此类推。直到所有这些条件都成立，`while`循环将为真，并在其中循环程序，直到条件不再为假。也就是说，所有的`prev`值恰好等于列表相应值的值。
- en: 'Again, this may seem a little odd to you, but, trust me, it will be quite useful,
    which we will see in a while:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这对你可能有点奇怪，但相信我，它会非常有用，我们一会儿会看到：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, here comes the real deal. This is the main program that will control the
    speed of the servo. In this, the first line is simple; it will check whether the
    value given to it is valid, that is, between the safe limits. Once that is done,
    it will then check whether the value of `a[Ii]` is less than or greater than the
    previous value. If it is greater than `a[i]`, then it will take in the previous
    value and decrement it with the speed specified by the user. If it is less than
    the value of `a[i]`, then it will increment the previous value with the speed
    specified.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，真正的问题来了。这是将控制舵机速度的主程序。在这个程序中，第一行很简单；它将检查给定的值是否有效，也就是在安全极限之间。一旦完成，它将检查`a[Ii]`的值是否小于或大于先前的值。如果大于`a[i]`的值，那么它将采用先前的值，并用用户指定的速度递减。如果小于`a[i]`的值，那么它将用指定的速度递增先前的值。
- en: So, if you look at it, the code is simply incrementing or decrementing the previous
    value every time the `while` loop is running. Now, the `while` loop will run until
    the value of `prev` is equal to the corresponding list value. That is, the loop
    will keep incrementing the value until it reaches the specified position.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你看一下，代码只是在`while`循环运行时每次递增或递减先前的值。现在，`while`循环将一直运行，直到`prev`的值等于相应列表值。也就是说，循环将一直递增值，直到达到指定位置。
- en: Hence, lower the value of the speed, lower will be the increments every single
    time, thereby slowing down the speed all together.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，速度值越低，每次递增的值就越低，从而整体减慢速度。
- en: This is the same process which will happen for all other servos as well. It
    may sound very complicated, but it is not! Programming is easy and will continue
    to remain easy each time you break it down into small pieces and understand them
    one by one!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程对所有其他舵机也是一样的。听起来可能很复杂，但实际上并不是！编程很容易，每次你把它分解成小块并逐一理解时，它都会继续保持简单！
- en: Summary
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have understood the basics of robotic arm, its power source,
    and its programming. With a very simple program, we were able to find out the
    limits of the servos and then apply these limits to make sure the servo did not
    damage itself. We got a basic idea of what frames are and did some programming
    based on frames. Finally, we also went ahead and controlled the speed of the servo
    using our very own program on a basic level.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了机械臂的基础知识、其电源和其编程。通过一个非常简单的程序，我们能够找出舵机的极限，然后应用这些极限以确保舵机不会损坏自己。我们对框架有了一个基本的概念，并根据框架进行了一些编程。最后，我们还继续控制了舵机的速度，使用了我们自己的基本级别的程序。
