["```py\nfrom email.header import Header\nfrom email.mime.text import MIMEText\nfrom email.utils import parseaddr, formataddr\nfrom smtplib import SMTP\n\nclass EmailSender:\n    def __init__(self, host=\"localhost\", port=25, login=\"\", password=\"\"):\n        self._host = host\n        self._port = int(port)\n        self._login = login\n        self._password = password\n\n    def send(self, sender, recipient, subject, body):\n        header_charset = 'UTF-8'\n        body_charset = 'UTF-8'\n\n        sender_name, sender_addr = parseaddr(sender)\n        recipient_name, recipient_addr = parseaddr(recipient)\n\n        sender_name = str(Header(sender_name, header_charset))\n        recipient_name = str(Header(recipient_name, header_charset))\n\n        msg = MIMEText(body.encode(body_charset), 'plain', body_charset)\n        msg['From'] = formataddr((sender_name, sender_addr))\n        msg['To'] = formataddr((recipient_name, recipient_addr))\n        msg['Subject'] = Header(subject, header_charset)\n\n        smtp = SMTP(self._host, self._port)\n        try:\n            smtp.starttls()\n        except:\n            pass\n        smtp.login(self._login, self._password)\n        smtp.sendmail(sender, recipient, msg.as_string())\n        smtp.quit()\n```", "```py\nes = EmailSender('mail.myserver.it', \n                 login='amol@myserver.it', \n                 password='mymailpassword')\nes.send(sender='Sender <no-reply@senders.net>', \n        recipient='amol@myserver.it',\n        subject='Hello my friend!',\n        body='''Here is a little email for you''')\n```", "```py\nclass EmailSender:\n    def __init__(self, host=\"localhost\", port=25, login=\"\", password=\"\"):\n        self._host = host\n        self._port = int(port)\n        self._login = login\n        self._password = password\n```", "```py\ndef send(self, sender, recipient, subject, body):\n```", "```py\nsender_name, sender_addr = parseaddr(sender)\nrecipient_name, recipient_addr = parseaddr(recipient)\n```", "```py\nsender_name = str(Header(sender_name, header_charset))\nrecipient_name = str(Header(recipient_name, header_charset))\n```", "```py\nmsg['From'] = formataddr((sender_name, sender_addr))\nmsg['To'] = formataddr((recipient_name, recipient_addr))\n```", "```py\nmsg['Subject'] = Header(subject, header_charset)\n```", "```py\nmsg = MIMEText(body.encode(body_charset), 'plain', body_charset)\n```", "```py\nsmtp = SMTP(self._host, self._port)\n```", "```py\ntry:\n    smtp.starttls()\nexcept:\n    pass\n```", "```py\nsmtp.login(self._login, self._password)\nsmtp.sendmail(sender, recipient, msg.as_string())\nsmtp.quit()\n```", "```py\nes.send(sender='Sender <no-reply@senders.net>', \n        recipient='amol@myserver.it',\n        subject='Have some japanese here: \u00e3\u201c\u00e3\u201a\u201c\u00e3\u00ab\u00e3\u00a1\u00e3\u00af',\n        body='''And some chinese here! \u00e4\u00bd \u00e5\u00a5\u00bd''')\n```", "```py\nimport imaplib\nimport re\nfrom email.parser import BytesParser\n\nclass IMAPReader:\n    ENCODING = 'utf-8'\n    LIST_PATTERN = re.compile(\n        r'\\((?P<flags>.*?)\\) \"(?P<delimiter>.*)\" (?P<name>.*)'\n    )\n\n    def __init__(self, host, username, password, ssl=True):\n        if ssl:\n            self._imap = imaplib.IMAP4_SSL(host)\n        else:\n            self._imap = imaplib.IMAP4(host)\n        self._imap.login(username, password)\n\n    def folders(self):\n        \"\"\"Retrieve list of IMAP folders\"\"\"\n        resp, lines = self._imap.list()\n        if resp != 'OK':\n            raise Exception(resp)\n\n        entries = []\n        for line in lines:\n            flags, _, name = self.LIST_PATTERN.match(\n                line.decode(self.ENCODING)\n            ).groups()\n            entries.append(dict(\n                flags=flags,\n                name=name.strip('\"')\n            ))\n        return entries\n\n    def messages(self, folder, limit=10, peek=True):\n        \"\"\"Return ``limit`` messages from ``folder``\n\n        peek=False will also fetch message body\n        \"\"\"\n        resp, count = self._imap.select('\"%s\"' % folder, readonly=True)\n        if resp != 'OK':\n            raise Exception(resp)\n\n        last_message_id = int(count[0])\n        msg_ids = range(last_message_id, last_message_id-limit, -1)\n\n        mode = '(BODY.PEEK[HEADER])' if peek else '(RFC822)'\n\n        messages = []\n        for msg_id in msg_ids:\n            resp, msg = self._imap.fetch(str(msg_id), mode)\n            msg = msg[0][-1]\n\n            messages.append(BytesParser().parsebytes(msg))\n            if len(messages) >= limit:\n                break\n        return messages\n\n    def get_message_body(self, message):\n        \"\"\"Given a message for which the body was fetched, returns it\"\"\"\n        body = []\n        if message.is_multipart():\n            for payload in message.get_payload():\n                body.append(payload.get_payload())\n        else:\n            body.append(message.get_payload())\n        return body\n\n    def close(self):\n        \"\"\"Close connection to IMAP server\"\"\"\n        self._imap.close()\n```", "```py\nmails = IMAPReader('imap.gmail.com', \n                   YOUR_EMAIL, YOUR_PASSWORD,\n                   ssl=True)\n\nfolders = mails.folders()\nfor msg in mails.messages('INBOX', limit=2, peek=True):\n    print(msg['Date'], msg['Subject'])\n```", "```py\nFri, 8 Jun 2018 00:07:16 +0200 Hello Python CookBook!\nThu, 7 Jun 2018 08:21:11 -0400 SSL and turbogears.org\n```", "```py\ndef __init__(self, host, username, password, ssl=True):\n    if ssl:\n        self._imap = imaplib.IMAP4_SSL(host)\n    else:\n        self._imap = imaplib.IMAP4(host)\n    self._imap.login(username, password)\n```", "```py\ndef folders(self):\n    \"\"\"Retrieve list of IMAP folders\"\"\"\n```", "```py\nresp, lines = self._imap.list()\nif resp != 'OK':\n    raise Exception(resp)\n```", "```py\nLIST_PATTERN = re.compile(\n    r'\\((?P<flags>.*?)\\) \"(?P<delimiter>.*)\" (?P<name>.*)'\n)\n```", "```py\nentries = []\nfor line in lines:\n    flags, _, name = self.LIST_PATTERN.match(\n        line.decode(self.ENCODING)\n    ).groups()\n    entries.append(dict(\n        flags=flags,\n        name=name.strip('\"')\n    ))\nreturn entries\n```", "```py\ndef messages(self, folder, limit=10, peek=True):\n    \"\"\"Return ``limit`` messages from ``folder``\n\n    peek=False will also fetch message body\n    \"\"\"\n```", "```py\nresp, count = self._imap.select('\"%s\"' % folder, readonly=True)\nif resp != 'OK':\n    raise Exception(resp)\n```", "```py\nlast_message_id = int(count[0])\nmsg_ids = range(last_message_id, last_message_id-limit, -1)\n```", "```py\nmode = '(BODY.PEEK[HEADER])' if peek else '(RFC822)'\n```", "```py\nresp, msg = self._imap.fetch(str(msg_id), mode)\n```", "```py\nmsg = msg[0][-1]\n```", "```py\nBytesParser().parsebytes(msg)\n```", "```py\nmessages = []\nfor msg_id in msg_ids:\n    resp, msg = self._imap.fetch(str(msg_id), mode)\n    msg = msg[0][-1]\n\n    messages.append(BytesParser().parsebytes(msg))\n    if len(messages) >= limit:\n        break\nreturn messages\n```", "```py\ndef get_message_body(self, message):\n    \"\"\"Given a message for which the body was fetched, returns it\"\"\"\n    body = []\n    if message.is_multipart():\n        for payload in message.get_payload():\n            body.append(payload.get_payload())\n    else:\n        body.append(message.get_payload())\n    return body\n```", "```py\nimport ftplib\n\nclass FTPCLient:\n    def __init__(self, host, username='', password=''):\n        self._client = ftplib.FTP_TLS(timeout=10)\n        self._client.connect(host)\n\n        # enable TLS\n        try:\n            self._client.auth()\n        except ftplib.error_perm:\n            # TLS authentication not supported\n            # fallback to a plain FTP client\n            self._client.close()\n            self._client = ftplib.FTP(timeout=10)\n            self._client.connect(host)\n\n        self._client.login(username, password)\n\n        if hasattr(self._client, 'prot_p'):\n            self._client.prot_p()\n\n    def cwd(self, directory):\n        \"\"\"Enter directory\"\"\"\n        self._client.cwd(directory)\n\n    def dir(self):\n        \"\"\"Returns list of files in current directory.\n\n        Each entry is returned as a tuple of two elements,\n        first element is the filename, the second are the\n        properties of that file.\n        \"\"\"\n        entries = []\n        for idx, f in enumerate(self._client.mlsd()):\n            if idx == 0:\n                # First entry is current path\n                continue\n            if f[0] in ('..', '.'):\n                continue\n            entries.append(f)\n        return entries\n\n    def download(self, remotefile, localfile):\n        \"\"\"Download remotefile into localfile\"\"\"\n        with open(localfile, 'wb') as f:\n            self._client.retrbinary('RETR %s' % remotefile, f.write)\n\n    def upload(self, localfile, remotefile):\n        \"\"\"Upload localfile to remotefile\"\"\"\n        with open(localfile, 'rb') as f:\n            self._client.storbinary('STOR %s' % remotefile, f)\n\n    def close(self):\n        self._client.close()\n```", "```py\nwith open('/tmp/hello.txt', 'w+') as f:\n    f.write('Hello World!')\n\ncli = FTPCLient('localhost', username=USERNAME, password=PASSWORD)\ncli.upload('/tmp/hello.txt', 'hellofile.txt')    \ncli.download('hellofile.txt', '/tmp/hello2.txt')\n\nwith open('/tmp/hello2.txt') as f:\n    print(f.read())\n```", "```py\ndef __init__(self, host, username='', password=''):\n    self._client = ftplib.FTP_TLS(timeout=10)\n    self._client.connect(host)\n\n    # enable TLS\n    try:\n        self._client.auth()\n    except ftplib.error_perm:\n        # TLS authentication not supported\n        # fallback to a plain FTP client\n        self._client.close()\n        self._client = ftplib.FTP(timeout=10)\n        self._client.connect(host)\n\n    self._client.login(username, password)\n\n    if hasattr(self._client, 'prot_p'):\n        self._client.prot_p()\n```", "```py\ndef cwd(self, directory):\n    \"\"\"Enter directory\"\"\"\n    self._client.cwd(directory)\n```", "```py\ndef dir(self):\n    \"\"\"Returns list of files in current directory.\n\n    Each entry is returned as a tuple of two elements,\n    first element is the filename, the second are the\n    properties of that file.\n    \"\"\"\n    entries = []\n    for idx, f in enumerate(self._client.mlsd()):\n        if idx == 0:\n            # First entry is current path\n            continue\n        if f[0] in ('..', '.'):\n            continue\n        entries.append(f)\n    return entries\n```", "```py\n('Desktop', {'perm': 'ceflmp', \n             'unique': 'BAAAAT79CAAAAAAA', \n             'modify': '20180522213143', \n             'type': 'dir'})\n```", "```py\ndef download(self, remotefile, localfile):\n    \"\"\"Download remotefile into localfile\"\"\"\n    with open(localfile, 'wb') as f:\n        self._client.retrbinary('RETR %s' % remotefile, f.write)\n\ndef upload(self, localfile, remotefile):\n    \"\"\"Upload localfile to remotefile\"\"\"\n    with open(localfile, 'rb') as f:\n        self._client.storbinary('STOR %s' % remotefile, f)\n```", "```py\nimport socket\nimport threading\nimport socketserver\n\nclass EchoServer:\n    def __init__(self, host='0.0.0.0', port=9800):\n        self._host = host\n        self._port = port\n        self._server = ThreadedTCPServer((host, port), EchoRequestHandler)\n        self._thread = threading.Thread(target=self._server.serve_forever)\n        self._thread.daemon = True\n\n    def start(self):\n        if self._thread.is_alive():\n            # Already serving\n            return\n\n        print('Serving on %s:%s' % (self._host, self._port))\n        self._thread.start()\n\n    def stop(self):\n        self._server.shutdown()\n        self._server.server_close()\n\nclass ThreadedTCPServer(socketserver.ThreadingMixIn, \n                        socketserver.TCPServer):\n    allow_reuse_address = True\n\nclass EchoRequestHandler(socketserver.BaseRequestHandler):\n    MAX_MESSAGE_SIZE = 2**16  # 65k\n    MESSAGE_HEADER_LEN = len(str(MAX_MESSAGE_SIZE))\n\n    @classmethod\n    def recv_message(cls, socket):\n        data_size = int(socket.recv(cls.MESSAGE_HEADER_LEN))\n        data = socket.recv(data_size)\n        return data\n\n    @classmethod\n    def prepare_message(cls, message):\n        if len(message) > cls.MAX_MESSAGE_SIZE:\n            raise ValueError('Message too big'\n\n        message_size = str(len(message)).encode('ascii')\n        message_size = message_size.zfill(cls.MESSAGE_HEADER_LEN)\n        return message_size + message\n\n    def handle(self):\n        message = self.recv_message(self.request)\n        self.request.sendall(self.prepare_message(b'ECHO: %s' % message))\n```", "```py\ndef send_message_to_server(ip, port, message):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((ip, port))\n    try:\n        message = EchoRequestHandler.prepare_message(message)\n        sock.sendall(message)\n        response = EchoRequestHandler.recv_message(sock)\n        print(\"ANSWER: {}\".format(response))\n    finally:\n        sock.close()\n```", "```py\nserver = EchoServer()\nserver.start()\n\nsend_message_to_server('localhost', server._port, b\"Hello World 1\")\nsend_message_to_server('localhost', server._port, b\"Hello World 2\")\nsend_message_to_server('localhost', server._port, b\"Hello World 3\")\n\nserver.stop()\n```", "```py\nServing on 0.0.0.0:9800\nANSWER: b'ECHO: Hello World 1'\nANSWER: b'ECHO: Hello World 2'\nANSWER: b'ECHO: Hello World 3'\n```", "```py\nclass EchoServer:\n    def __init__(self, host='0.0.0.0', port=9800):\n        self._host = host\n        self._port = port\n        self._server = ThreadedTCPServer((host, port), EchoRequestHandler)\n        self._thread = threading.Thread(target=self._server.serve_forever)\n        self._thread.daemon = True\n\n    def start(self):\n        if self._thread.is_alive():\n            # Already serving\n            return\n\n        print('Serving on %s:%s' % (self._host, self._port))\n        self._thread.start()\n\n    def stop(self):\n        self._server.shutdown()\n        self._server.server_close()\n```", "```py\n@classmethod\ndef recv_message(cls, socket):\n    data_size = int(socket.recv(cls.MESSAGE_HEADER_LEN))\n    data = socket.recv(data_size)\n    return data\n```", "```py\nMAX_MESSAGE_SIZE = 2**16  # 65k\nMESSAGE_HEADER_LEN = len(str(MAX_MESSAGE_SIZE))\n```", "```py\ndef handle(self):\n    message = self.recv_message(self.request)\n    self.request.sendall(self.prepare_message(b'ECHO: %s' % message))\n```", "```py\n@classmethod\ndef prepare_message(cls, message):\n    if len(message) > cls.MAX_MESSAGE_SIZE:\n        raise ValueError('Message too big'\n\n    message_size = str(len(message)).encode('ascii')\n    message_size = message_size.zfill(cls.MESSAGE_HEADER_LEN)\n    return message_size + message\n```", "```py\nmessage_size = str(len(message)).encode('ascii')\n```", "```py\nmessage_size = message_size.zfill(cls.MESSAGE_HEADER_LEN)\n```", "```py\ndef send_message_to_server(ip, port, message):\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((ip, port))\n    try:\n        message = EchoRequestHandler.prepare_message(message)\n        sock.sendall(message)\n        response = EchoRequestHandler.recv_message(sock)\n        print(\"ANSWER: {}\".format(response))\n    finally:\n        sock.close()\n```", "```py\nimport asyncio\n\nclass EchoServer:\n    MAX_MESSAGE_SIZE = 2**16  # 65k\n    MESSAGE_HEADER_LEN = len(str(MAX_MESSAGE_SIZE))\n\n    def __init__(self, host='0.0.0.0', port=9800):\n        self._host = host\n        self._port = port\n        self._server = None\n\n    def serve(self, loop):\n        coro = asyncio.start_server(self.handle, self._host, self._port,\n                                    loop=loop)\n        self._server = loop.run_until_complete(coro)\n        print('Serving on %s:%s' % (self._host, self._port))\n        loop.run_until_complete(self._server.wait_closed())\n        print('Done')\n\n    @property\n    def started(self):\n        return self._server is not None and self._server.sockets\n\n    def stop(self):\n        print('Stopping...')\n        self._server.close()\n\n    async def handle(self, reader, writer):\n        data = await self.recv_message(reader)\n        await self.send_message(writer, b'ECHO: %s' % data)\n        # Signal we finished handling this request\n        # or the server will hang.\n        writer.close()\n\n    @classmethod\n    async def recv_message(cls, socket):\n        data_size = int(await socket.read(cls.MESSAGE_HEADER_LEN))\n        data = await socket.read(data_size)\n        return data\n\n    @classmethod\n    async def send_message(cls, socket, message):\n        if len(message) > cls.MAX_MESSAGE_SIZE:\n            raise ValueError('Message too big')\n\n        message_size = str(len(message)).encode('ascii')\n        message_size = message_size.zfill(cls.MESSAGE_HEADER_LEN)\n        data = message_size + message\n\n        socket.write(data)\n        await socket.drain()\n```", "```py\nimport socket\n\ndef send_message_to_server(ip, port, message):\n    def _recv_message(socket):\n        data_size = int(socket.recv(EchoServer.MESSAGE_HEADER_LEN))\n        data = socket.recv(data_size)\n        return data\n\n    def _prepare_message(message):\n        if len(message) > EchoServer.MAX_MESSAGE_SIZE:\n            raise ValueError('Message too big')\n\n        message_size = str(len(message)).encode('ascii')\n        message_size = message_size.zfill(EchoServer.MESSAGE_HEADER_LEN)\n        return message_size + message\n\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect((ip, port))\n    try:\n        sock.sendall(_prepare_message(message))\n        response = _recv_message(sock)\n        print(\"ANSWER: {}\".format(response))\n    finally:\n        sock.close()\n```", "```py\nserver = EchoServer()\ndef serve_for_3_seconds():\n    loop = asyncio.new_event_loop()\n    asyncio.set_event_loop(loop)\n    loop.call_later(3, server.stop)\n    server.serve(loop)\n    loop.close()\n\nimport threading\nserver_thread = threading.Thread(target=serve_for_3_seconds)\nserver_thread.start()\n```", "```py\nwhile not server.started:\n    pass\n\nsend_message_to_server('localhost', server._port, b\"Hello World 1\")\nsend_message_to_server('localhost', server._port, b\"Hello World 2\")\nsend_message_to_server('localhost', server._port, b\"Hello World 3\")\n```", "```py\nserver_thread.join()\n```", "```py\nServing on 0.0.0.0:9800\nANSWER: b'ECHO: Hello World 1'\nANSWER: b'ECHO: Hello World 2'\nANSWER: b'ECHO: Hello World 3'\nStopping...\nDone \n```", "```py\ndef serve(self, loop):\n    coro = asyncio.start_server(self.handle, self._host, self._port,\n                                loop=loop)\n    self._server = loop.run_until_complete(coro)\n    print('Serving on %s:%s' % (self._host, self._port))\n    loop.run_until_complete(self._server.wait_closed())\n    print('Done')\n```", "```py\nasync def handle(self, reader, writer):\n    data = await self.recv_message(reader)\n    await self.send_message(writer, b'ECHO: %s' % data)\n    # Signal we finished handling this request\n    # or the server will hang.\n    writer.close()\n```", "```py\n@classmethod\nasync def recv_message(cls, socket):\n    data_size = int(await socket.read(cls.MESSAGE_HEADER_LEN))\n    data = await socket.read(data_size)\n    return data\n```", "```py\nsocket.write(data)\nawait socket.drain()\n```", "```py\nimport xmlrpc.server\n\nclass XMLRPCServices:\n    class ExposedServices:\n        pass\n\n    def __init__(self, **services):\n        self.services = self.ExposedServices()\n        for name, service in services.items():\n            setattr(self.services, name, service)\n\n    def serve(self, host='localhost', port=8000):\n        print('Serving XML-RPC on {}:{}'.format(host, port))\n        self.server = xmlrpc.server.SimpleXMLRPCServer((host, port))\n        self.server.register_introspection_functions()\n        self.server.register_instance(self.services, \n                                      allow_dotted_names=True)\n        self.server.serve_forever()\n\n    def stop(self):\n        self.server.shutdown()\n        self.server.server_close()\n```", "```py\nclass MathServices:\n    def double(self, v):\n        return v**2\n\nclass TimeServices:\n    def currentTime(self):\n        import datetime\n        return datetime.datetime.utcnow()\n```", "```py\nxmlrpcserver = XMLRPCServices(math=MathServices(),\n                              time=TimeServices())\n\nimport threading\nserver_thread = threading.Thread(target=xmlrpcserver.serve)\nserver_thread.start()\n\nfrom xmlrpc.client import ServerProxy\nclient = ServerProxy(\"http://localhost:8000\")\nprint(\n    client.time.currentTime()\n)\n\nxmlrpcserver.stop()\nserver_thread.join()\n```", "```py\nServing XML-RPC on localhost:8000\n127.0.0.1 - - [10/Jun/2018 23:41:25] \"POST /RPC2 HTTP/1.1\" 200 -\n20180610T21:41:25\n```", "```py\nxmlrpcserver = XMLRPCServices(math=MathServices(),\n                              time=TimeServices())\n```", "```py\ndef __init__(self, **services):\n    self.services = self.ExposedServices()\n    for name, service in services.items():\n        setattr(self.services, name, service)\n```", "```py\ndef serve(self, host='localhost', port=8000):\n    print('Serving XML-RPC on {}:{}'.format(host, port))\n    self.server = xmlrpc.server.SimpleXMLRPCServer((host, port))\n    self.server.register_introspection_functions()\n    self.server.register_instance(self.services, \n                                  allow_dotted_names=True)\n    self.server.serve_forever()\n```", "```py\nself.server.register_instance(self.services, \n                              allow_dotted_names=True)\n```", "```py\nself.server.register_introspection_functions()\n```", "```py\nself.server.serve_forever()\n```", "```py\ndef stop(self):\n    self.server.shutdown()\n    self.server.server_close()\n```", "```py\nxmlrpcserver = XMLRPCServices(math=MathServices(),\n                              time=TimeServices())\nxmlrpcserver.serve()\n```", "```py\nclient = ServerProxy(\"http://localhost:8000\")\n```", "```py\nclient.time.currentTime()\n```", "```py\nclient.time.currentTime()\n```", "```py\nclient.time.currentTime.im_func.func_globals.keys()\n```", "```py\nclient.time.currentTime.im_func.func_globals.get('varname')\n```"]