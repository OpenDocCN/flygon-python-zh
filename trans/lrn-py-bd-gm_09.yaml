- en: Data Model Implementation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据模型实现
- en: Games are a medium that try to emulate, or at least simulate, real-world environments
    through the use of interplay, where players use motions and movements in order
    to control the game characters. As we know, there are a variety of ways in which
    players can interact with the game, mostly with input devices such as a keyboard,
    a mouse, or a joystick. In order to translate these input signals into meaningful
    information, we need to address the signals with corresponding actions. In most
    games, we use keyboard keys to make movements for the game character, but internally,
    the signals are handled by mathematical objects called vectors. This is extremely
    important for any game, regardless of how the graphics appear, as it causes players
    to create actions and address them with appropriate reactions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏是一种通过互动来模拟或至少模拟真实世界环境的媒介，玩家通过动作和移动来控制游戏角色。我们知道，玩家可以用键盘、鼠标或操纵杆等输入设备与游戏进行互动的方式有很多种。为了将这些输入信号转化为有意义的信息，我们需要用相应的动作来处理这些信号。在大多数游戏中，我们使用键盘按键来移动游戏角色，但在内部，这些信号是由称为向量的数学对象处理的。这对于任何游戏来说都非常重要，无论图形看起来如何，因为它导致玩家产生动作并用适当的反应来处理它们。
- en: In this chapter, we will be introduced to 2D vectors—ways of manipulating the
    positions of game characters. The change in the coordinates of vectors (*x*, *y*)
    represents the movement that's specified by the game player. This chapter will
    be life-changing for any programming beginner as this will teach us how to use
    mathematical concepts such as addition, subtraction, multiplication, rotation,
    and reflection with a programming paradigm, which we know as data model implementation.
    The end goal of this chapter is to make you familiar with the concept of operator
    overloading using Python, the usage of Python built-in methods in order to manipulate
    vectored positions, and the implementation of data models or magic functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍二维向量——操纵游戏角色位置的方法。向量坐标（*x*，*y*）的变化代表了游戏玩家指定的移动。对于任何编程初学者来说，本章将是改变生活的，因为它将教会我们如何使用数学概念，如加法、减法、乘法、旋转和反射，以及数据模型实现这样的编程范式。本章的最终目标是让您熟悉使用Python进行运算符重载的概念，使用Python内置方法来操纵向量位置，以及实现数据模型或魔术函数。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Overview of operator overloading
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符重载概述
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术要求
- en: Dealing with 2D vectors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理二维向量
- en: Data model for vectored motion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向量运动的数据模型
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter will give us a roller coaster ride of Python''s simple, yet powerful,
    concept of operator overloading. Therefore, you are expected to be equipped with
    the following tools:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带领我们体验Python简单而强大的运算符重载概念。因此，您需要具备以下工具：
- en: Python 3.5 or newer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.5或更新版本
- en: Python IDLE (Python's inbuilt IDE)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python IDLE（Python内置的IDE）
- en: A text editor
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器
- en: A web browser
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络浏览器
- en: The files for this chapter can be found here: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter09](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter09)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的文件可以在这里找到：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter09](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter09)
- en: 'Check out the following video to see the code in action:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频以查看代码的运行情况：
- en: '[http://bit.ly/2psS6pd](http://bit.ly/2psS6pd)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2psS6pd](http://bit.ly/2psS6pd)'
- en: Understanding operator overloading
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解运算符重载
- en: This is a new concept, and may be ambiguous to naive programmers, but it is
    obligatory to have this knowledge. In the programming nomenclature, everything
    that is defined with a programming language has a specific usage. For example,
    we cannot use the `sum()` method to find the difference between elements. We can
    extend the meaning of any operation beyond its normal usage or predefined operational
    usage. Take a simple example of an addition (+) operator; this operator can be
    used to add simple integers, concatenate two independent strings, and even merge
    the two lists. This is possible because the addition operator is overloaded in
    different classes, that is, it has different implementations defined in the string
    and integer classes. This is the power of operator overloading.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个新概念，对于初学者来说可能会有些模糊，但有必要了解这一知识。在编程术语中，用编程语言定义的一切都有特定的用途。例如，我们不能使用`sum()`方法来找到元素之间的差异。我们可以扩展任何操作的含义超出其正常用法或预定义的操作用法。以加法（+）运算符为例；这个运算符可以用来添加简单的整数，连接两个独立的字符串，甚至合并两个列表。这是因为加法运算符在不同的类中被重载，也就是说，在字符串和整数类中定义了不同的实现。这就是运算符重载的威力。
- en: 'Another factor that must be kept in mind is that the same function or built-in
    operator depicts different behaviors for the objects of several classes, as shown
    in the following example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要记住的一点是，相同的函数或内置运算符对于多个类的对象具有不同的行为，如下例所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Several methods support operator overloading; these are known as data models,
    or sometimes, magic methods. They are called so because these special methods
    extend the functionality of methods, which in turn adds magic to our classes.
    These data models should not be invoked by us; rather it happens internally from
    the classes. For example, when we perform an addition operation with the `+` operator,
    the Python parser internally invokes the `__add__()` method. Different built-in
    classes of Python such as `str`, `int`, `list`, and many more, have different
    internally defined magic functions. We can print the list of magic functions that
    are dedicated to a particular class using the `dir` function. For example, the
    following list indicates several methods and attributes that are defined in the
    `str` class:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法支持运算符重载；这些被称为数据模型，有时也被称为魔术方法。之所以这样称呼，是因为这些特殊方法扩展了方法的功能，从而为我们的类增添了魔力。这些数据模型不应该由我们调用；而是在类内部自动发生。例如，当我们使用`+`运算符执行加法操作时，Python解析器内部调用`__add__()`方法。Python的不同内置类，如`str`、`int`、`list`等，都有不同的内部定义的魔术函数。我们可以使用`dir`函数打印专门用于特定类的魔术函数列表。例如，以下列表指示了`str`类中定义的几种方法和属性：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As shown in the preceding list of methods and attributes of the `str` class,
    we can observe several methods that start and end with a double underscore. For
    example, the `__add__()` method is used to concatenate two strings using the `+` operator:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的`str`类的方法和属性列表所示，我们可以观察到几个以双下划线开头和结尾的方法。例如，`__add__()`方法用于使用`+`运算符连接两个字符串：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, we can see that the `__add__()` function works in
    a similar way as `+`. These data models are meant to be used to extend the predefined
    meaning with overloaded behavior. Based on mathematical canonization, we normally
    use operators such as `+`, `-`, `/`, and `*` with numeric objects. However, with
    the overloading technique, we use the same operator for multiple objects, such
    as strings and lists. We can conclude that the addition operator (`+`) is overloaded.
    Similarly, different data models are defined by Python for different operators,
    that is, `__sub__()` for the `-` operator, `__mul__()` for the `*` operator, and
    `__div__()` for the `/` operator.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们可以看到`__add__()`函数的工作方式与`+`类似。这些数据模型旨在用于扩展具有重载行为的预定义含义。根据数学规范，我们通常使用`+`、`-`、`/`和`*`等运算符与数字对象一起使用。然而，通过重载技术，我们可以使用相同的运算符来处理多个对象，如字符串和列表。我们可以得出结论，加法运算符（`+`）被重载。同样，Python为不同的运算符定义了不同的数据模型，即`__sub__()`用于`-`运算符，`__mul__()`用于`*`运算符，`__div__()`用于`/`运算符。
- en: Now that we have learned how to use data models in the most basic form of an
    add function, we will implement some examples of custom-made classes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何在最基本的形式中使用数据模型来实现add函数，我们将实现一些自定义类的示例。
- en: Using data models in custom classes
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在自定义类中使用数据模型
- en: 'Now that we know how to implement the `__add__()` magic function with various
    data types such as integer and string, let''s observe how it can be used in custom-made
    (user-defined) Python classes. We will consider the following example to illustrate
    the usage of data models in our custom class:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用`__add__()`魔术函数与整数和字符串等各种数据类型一起使用，让我们观察它如何在自定义（用户定义的）Python类中使用。我们将考虑以下示例来说明数据模型在我们的自定义类中的用法：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will make the objects of the preceding class with the following code. This
    code is executed in the Python shell:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下代码创建前面类的对象。此代码在Python shell中执行：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As expected, we get an error saying unsupported operands for different types,
    which implies that the `+` operator is not functional for adding the objects of
    custom classes. As mentioned previously, to solve such problems, we can use operator
    overloading. We can explicitly define such special methods inside our class in
    order to make objects compatible with built-in methods and operators. For example,
    in the case of the addition operation, we have to define the `__add__()` method
    explicitly inside the class, which looks something like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们得到一个错误，说不支持不同类型的操作数，这意味着`+`运算符对于添加自定义类的对象是不起作用的。如前所述，为了解决这类问题，我们可以使用运算符重载。我们可以在我们的类中显式定义这些特殊方法，以使对象与内置方法和运算符兼容。例如，在加法操作的情况下，我们必须在类内部显式定义`__add__()`方法，看起来像这样：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s check whether this works by making different objects of the `Base` class:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建`Base`类的不同对象来检查这是否有效：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Thus, the magic function, or the `__add__()` data model, is overridden, which
    successfully performs the addition operation between two integers and two strings.
    We can also check this for other data objects such as lists and tuples. Now, we
    can clearly predict the pattern; if we want to overload any mathematical operator
    and implement it differently in our custom-made classes, we have to define data
    models in our classes. I hope you get the idea! Now, we can predict the `__mul__()` pattern
    so that we can perform multiplication between different objects, `__sub__()` to
    perform subtraction, and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，魔术函数，或者`__add__()`数据模型被重写，成功地在两个整数和两个字符串之间执行了加法操作。我们也可以检查其他数据对象，如列表和元组。现在，我们可以清楚地预测模式；如果我们想要重载任何数学运算符并在我们的自定义类中以不同的方式实现它，我们必须在我们的类中定义数据模型。希望你明白了！现在，我们可以预测`__mul__()`模式，以便我们可以在不同对象之间执行乘法，`__sub__()`执行减法，等等。
- en: Let's observe another powerful, yet less frequently used, magic method of Python,
    before actually learning about the importance of using these magic functions.
    Let's talk about the `__new__()` data model. You can easily observe the working
    of these methods; just remove the underscore and parentheses that surround the
    method name and you will come up with the `new` keyword. If you have a programming
    background from any high-level language such as Java and C#, you will already
    understand my point. For those who are new to the concept of the `new` keyword,
    this operator is used to create instances of the classes. For example, in Python,
    we have `object = class_name()`, while in Java, we have `object = new class_name()`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际学习使用这些魔术函数的重要性之前，让我们先观察Python中另一个强大但不太常用的魔术方法，即`__new__()`数据模型。你可以轻松观察这些方法的工作方式；只需删除方法名称周围的下划线和括号，你就会得到`new`关键字。如果你有来自Java和C#等高级语言的编程背景，你可能已经理解我的观点。对于那些对`new`关键字的概念还不熟悉的人，这个操作符用于创建类的实例。例如，在Python中，我们有`object
    = class_name()`，而在Java中，我们有`object = new class_name()`。
- en: 'Thus, the `__new__()` magic method is the first method to be called while creating
    objects of classes—even before the `__init__()` constructor is called—and it is
    called implicitly. The `__new__()` method is responsible for creating new objects,
    and it returns the object that''s initialized using the constructor''s `__init__()`
    method. Do you remember, in object-oriented chapter, we referred to the `__init__()`
    method as a special method, which is, in fact, a magic method. Let''s consider
    the following example to learn about the `__new__()` magic method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`__new__()`魔术方法是在创建类的对象时调用的第一个方法，甚至在调用`__init__()`构造函数之前就调用了它，并且是隐式调用的。`__new__()`方法负责创建新对象，并返回使用构造函数的`__init__()`方法初始化的对象。你还记得，在面向对象的章节中，我们将`__init__()`方法称为特殊方法，实际上是一个魔术方法。让我们考虑以下示例来了解`__new__()`魔术方法：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following code is executed inside the Python shell. We are creating an
    object of the `Base` class, and observing that the `new` method is called before
    the `init` method:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码在Python shell中执行。我们正在创建一个`Base`类的对象，并观察到在`init`方法之前调用了`new`方法：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that in the preceding code, we passed `cls` as an argument while defining
    the `new` magic method and the `self` variable as an argument while defining the
    `init` constructor. The distinction between these two variables—`cls` and `self`—is
    defined in PEP 8, which defines the style guide for Python code. This coding style
    is not mandatory, but according to PEP 8, we should always do the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上述代码中，我们在定义`new`魔术方法时将`cls`作为参数传递，并在定义`init`构造函数时将`self`变量作为参数传递。`cls`和`self`这两个变量之间的区别在PEP
    8中有定义，它定义了Python代码的样式指南。这种编码风格并不是强制性的，但根据PEP 8，我们应该始终做到以下几点：
- en: Always use `self` for the first argument to instance methods.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终将`self`用作实例方法的第一个参数。
- en: Always use `cls` for the first argument to class methods.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终将`cls`用作类方法的第一个参数。
- en: 'I think that we are now capable enough to predict the working internals of
    any built-in function. Let''s take the example of the `len()` method. If there
    is any built-in `fun()` function in Python, it corresponds to `__fun__()`. The
    Python parser makes an internal call as `object.__fun__()`, where the object is
    the instance of a class. Considering this analogy, for the `len()` function, the
    Python parser interprets its call as `object.__len__()`, and it returns the length
    of the object. We have seen how it works internally; however, since the main topic
    we want to cover is how to override it, let''s define this magic method inside
    our custom-made classes (in a similar way to the preceding example, where we used
    the `add` magic function to add objects of a class). In the case of `__len__()`,
    consider the following example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们现在已经足够能够预测任何内置函数的工作内部。让我们以`len()`方法为例。如果Python中有任何内置的`fun()`函数，它对应于`__fun__()`。Python解析器会进行内部调用，如`object.__fun__()`，其中对象是类的实例。考虑到这个类比，对于`len()`函数，Python解析器将其调用解释为`object.__len__()`，并返回对象的长度。我们已经看到了它的内部工作方式；然而，由于我们想要覆盖的主要主题是如何覆盖它，让我们在我们自定义的类中定义这个魔术方法（类似于前面的例子，我们使用`add`魔术函数来添加类的对象）。在`__len__()`的情况下，考虑以下示例：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Therefore, when we define such magic methods or data models in our own class,
    we override the behavior of the functions that are originally defined by Python;
    thus, we are now no longer calling the original method. When you override the
    original method with your new one, we refer to this as method overriding. Up to
    this point, we have been learning about data models and ways of using them in
    our own classes. Now, let's learn about why they are essential in game programming.
    We will do this by exploring vectors in the next section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们在自己的类中定义这样的魔术方法或数据模型时，我们覆盖了Python原始定义的函数的行为；因此，我们不再调用原始方法。当你用新方法覆盖原始方法时，我们称之为方法覆盖。到目前为止，我们一直在学习数据模型及其在我们自己的类中的使用方式。现在，让我们学习为什么它们在游戏编程中是必不可少的。我们将在下一节中通过探索向量来做到这一点。
- en: Dealing with two-dimensional vectors
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理二维向量
- en: 'Before actually exploring vectors, let''s start with the basic overview of
    motion and how characters are moved in a straight line. To move any object or
    image, we have to make a slight change to the frames by a fixed amount. The movement
    must be fixed for each frame in order to make it symmetrical. To make an object
    move in a horizontal direction, we carry out an addition of a fixed amount to
    the *x* position, and to make it move in a vertical direction, we add the same
    amount to the y position. Thus, motion in 2D games can be represented as (*x*,
    *y*). Let''s consider the following example to illustrate the usage of these coordinates
    on order to draw any shape into the game environment:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际探索向量之前，让我们从运动的基本概述开始，以及如何使角色在直线上移动。要移动任何对象或图像，我们必须对每一帧进行微小的固定量的改变。运动必须对每一帧都是固定的，以使其对称。要使一个对象在水平方向上移动，我们对*x*位置进行固定量的加法，要使其在垂直方向上移动，我们对*y*位置加上相同的量。因此，2D游戏中的运动可以表示为（*x*，*y*）。让我们考虑以下例子，以说明如何使用这些坐标来在游戏环境中绘制任何形状：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are using the `turtle` module, which we used in the previous chapter to draw
    a line using the `(a, b)` and `(x, y)` positions. The `goto()` method is used
    to move the pen to the passed positions. These coordinates—`(x, y)` or `(a, b)`—clearly
    show the importance of knowing the positions in order to create game characters
    (we use line as a metaphor for any game character).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了在上一章中使用的`turtle`模块，用于使用（a，b）和（x，y）位置绘制线条。`goto()`方法用于将笔移动到传递的位置。这些坐标——（x，y）或（a，b）——清楚地显示了知道位置以创建游戏角色的重要性（我们使用线条作为任何游戏角色的比喻）。
- en: 'We can deem that the usage of a straight line motion is pretty useful, but
    looking at it from a different perspective, a game that only supports vertical
    or horizontal motions may seem dull and unexciting. For example, in the Pacman
    game, where a player would move either in a vertical or horizontal direction,
    this may be appropriate, but in the case of a car-racing game, where users can
    move in any direction, this motion doesn''t work properly. We must be able to
    move in any direction by adjusting the positions of *x* and *y* for each frame.
    We will use the same two positions, *x* and *y*, to generate both straight and
    diagonal motions: a rate that indicates speed for the *x* and *y* positions. The
    form that represents `(x, y)` is known as a vector, but more importantly, vectors
    signify direction, unlike scalar. We will explore vectors in more detail in the
    following subsection.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以认为直线运动的使用非常有用，但从不同的角度来看，一个只支持垂直或水平运动的游戏可能会显得乏味和无聊。例如，在吃豆人游戏中，玩家只能在垂直或水平方向上移动，这可能是合适的，但在赛车游戏中，用户可以朝任何方向移动，这种运动就不适用了。我们必须能够通过调整每一帧的*x*和*y*位置来朝任何方向移动。我们将使用相同的*x*和*y*位置来生成直线和对角线运动：一个表示*x*和*y*位置速度的比率。表示`(x,
    y)`的形式被称为向量，但更重要的是，向量表示方向，而标量不表示。我们将在下一小节中更详细地探讨向量。
- en: Exploring vectors
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索向量
- en: 'As the mathematical adage says:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如数学格言所说：
- en: '" Vector refers to any quantity that has magnitude as well as direction, especially
    for determining the position of one point in space relative to another."'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “向量是指任何具有大小和方向的量，特别用于确定空间中一个点相对于另一个点的位置。”
- en: 'We couldn''t agree more. This concept is taken from mathematics, and is the
    most well-known topic for any game programmer, naive to suave. Vectors are the
    proper representation of any position of an object, with the critical information
    of the direction attached to it. Vectors have similar representations as a straight
    line motion in the form of *x* and *y* coordinates (2D), but they are not restricted
    to only providing information about magnitude; they have a specific purpose. For
    example, vector (4, 5) represents the next position, where 4 is added to the *x*
    coordinate of the current position and 5 is added to the *y* coordinate of the
    current position; something like this—(0 + 4, 0 + 5)—where (0, 0) is the origin
    or center position. Let''s examine vectors figuratively with the following examples:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完全同意。这个概念源自数学，对于任何游戏程序员来说都是最知名的话题，无论是天真还是老练。向量是任何对象位置的正确表示，附加了方向的关键信息。向量与直线运动的形式相似，以*x*和*y*坐标（2D）的形式表示，但它们不仅仅限于提供大小的信息；它们有一个特定的目的。例如，向量（4，5）表示下一个位置，其中4被添加到当前位置的*x*坐标，5被添加到当前位置的*y*坐标；类似于这样——（0
    + 4，0 + 5）——其中（0，0）是原点或中心位置。让我们用以下例子形象地来研究向量：
- en: '![](Images/9d2fb736-745b-402b-9479-7af3f02d1681.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9d2fb736-745b-402b-9479-7af3f02d1681.png)'
- en: 'In the preceding diagram, vector (4,5) has magnitude and direction. The green
    line indicates magnitude and the orange line indicates direction. Thus, a vector
    is incomplete without the information of its previous direction. Let''s look at
    another simple example to clarify this further:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，向量（4,5）具有大小和方向。绿线表示大小，橙线表示方向。因此，一个向量如果没有前面的方向信息就是不完整的。让我们看另一个简单的例子来进一步澄清这一点：
- en: '![](Images/7047fb35-abc6-4eef-99f4-a175f1310dcc.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7047fb35-abc6-4eef-99f4-a175f1310dcc.png)'
- en: The preceding diagram says it all. The vector AB is the subtraction of the *x*
    and *y* positions from the target with the initial position. Suppose a Pacman
    is at position (30, 20), and he has to reach the target, that is, (50, 45). Vector
    AB is the critical information which indicates that Pacman has to move 20 units
    more in the *x* direction, and 25 more in the *y* direction.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表已经说明了一切。向量AB是目标位置与初始位置的*x*和*y*位置的减法。假设一个吃豆人在位置（30，20），他必须到达目标位置（50，45）。向量AB是关键信息，表明吃豆人在*x*方向上还需要移动20个单位，在*y*方向上还需要移动25个单位。
- en: 'It is well-known that Python does not have a built-in *vector* data structure.
    If you think there is, perform a quick internet search on it; you will get the
    basic idea. However, we didn''t cover vectors as built-in data structures in the
    preceding chapters. Although we don''t have vectors as built-in data types, we
    can make one for ourselves. As we know, vectors constitute two different positions
    (*x*, *y*), and our main aim is to use other built-in data structures to make
    them. For example, we can use lists to make vectors, but indicating each point
    with indexes such as `[0]` and `[1]` adds unwanted overheads. The same goes for
    using tuples. Probably the best way of creating vectors would be by making our
    own vector class. In doing so, we can reference points as *x* and *y* instead
    of indexes. Furthermore, the best exploits can be made by using data models with
    vectors. We can use `__add__()`, `__mul__()`, and many more magic functions inside
    the vector class, which will introduce motion to the game characters. As an example,
    we will create a simple vector class and make use of the `__str__()` method, along
    with a constructor, which will provide a proper representation of positions with
    vectors:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，Python没有内置的*向量*数据结构。如果你认为有的话，快速在互联网上搜索一下，你会得到基本的概念。然而，在前面的章节中，我们并没有涵盖向量作为内置数据结构。虽然我们没有向量作为内置数据类型，但我们可以自己制作一个。正如我们所知，向量包括两个不同的位置（*x*，*y*），我们的主要目标是使用其他内置数据结构来制作它们。例如，我们可以使用列表来制作向量，但使用索引来表示每个点，如`[0]`和`[1]`，会增加不必要的开销。元组也是如此。创建向量的最佳方式可能是制作我们自己的向量类。这样做，我们可以引用点为*x*和*y*，而不是索引。此外，使用数据模型与向量可以获得最佳的利用。我们可以在向量类中使用`__add__()`，`__mul__()`和许多其他魔术函数，这将为游戏角色引入运动。例如，我们将创建一个简单的向量类，并使用`__str__()`方法，以及一个构造函数，它将提供向量位置的适当表示：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding program, we created a `Vector` class and defined two members
    in it: one being the constructor, and the other being the magic method. Now, when
    we create any object of this class, such as `> pos = Vector(10,40)`*,* the `init()`
    method will perform initialization so that we can reference each component of
    the vector as `>>> pos.x` and `>>> pos.y`. The `__str__()` method is the magic
    method that is used as the overriding method and it has a custom definition in
    our `Vector` class, which is used as a representation of the components of vector
    in the form of the *x* and *y* positions. Let''s see how it works by running the
    following code and creating a `Vector` class object:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们创建了一个`Vector`类，并在其中定义了两个成员：一个是构造函数，另一个是魔术方法。现在，当我们创建这个类的任何对象时，比如`>
    pos = Vector(10,40)`，`init()`方法将执行初始化，这样我们就可以引用向量的每个分量，如`>>> pos.x`和`>>> pos.y`。`__str__()`方法是魔术方法，它被用作覆盖方法，并且在我们的`Vector`类中有一个自定义定义，用作向量分量的表示形式，即*x*和*y*位置。让我们通过运行以下代码并创建一个`Vector`类对象来看看它是如何工作的：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Apart from the `__str__()` method, we have a bunch of magic functions that are
    applicable for manipulating vectors. We can use `__add__()` to perform addition
    between vectors, `__sub__()` to perform subtraction, `__neg__()` to perform negation,
    and so on. We will learn about these data models and ways of using them to modify
    vectors in the next section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`__str__()`方法之外，我们还有一堆适用于操作向量的魔术函数。我们可以使用`__add__()`执行向量之间的加法，`__sub__()`执行减法，`__neg__()`执行否定等。我们将在下一节学习这些数据模型以及使用它们修改向量的方法。
- en: Modeling for vectored motion
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于向量运动建模
- en: 'As we know, vectors are the quantity that constitute both magnitude and direction.
    These two pieces of information can be extremely critical when determining the
    next position for game characters, based on a user''s action. For example, a game
    character, Steve (a Minecraft character), can use vectors to determine the units
    he has to travel further using magnitude (AB) and direction (→AB) in order to
    track his goal. Although we can change both of these sources of information one
    by one, we are primarily concerned with magnitude because magnitude is responsible
    for providing motion in 2D games. In this section, we will uncover the techniques
    that will teach us how to add and subtract vectors, and even perform multiplication
    and division. These types of operations will be added as logic in the game, along
    with user events, so that whenever the user presses any keys on the keyboard,
    it is addressed by a particular event. The techniques that can be used while performing
    this operation mathematically are as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，向量是构成大小和方向的量。当根据用户的行动确定游戏角色的下一个位置时，这两个信息非常关键。例如，游戏角色Steve（一个Minecraft角色）可以使用向量来确定他必须使用大小（AB）和方向（→AB）来跟踪他的目标。虽然我们可以逐个更改这些信息源，但我们主要关注大小，因为大小负责在2D游戏中提供运动。在本节中，我们将揭示教我们如何添加和减去向量，甚至执行乘法和除法的技术。这些类型的操作将作为逻辑添加到游戏中，以及用户事件，因此每当用户在键盘上按下任何键时，它都会被特定事件处理。在进行这种数学操作时可以使用的技术如下：
- en: Performing operations (subtracting/adding) on vectors with known components
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对已知分量的向量进行操作（减法/加法）
- en: Performing operations by finding components, or simply using head/tail methods
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过查找分量执行操作，或者简单地使用头/尾方法
- en: Let's learn about the use of these techniques by hopping over to the next section,
    where we will perform vectored operations using magic functions or data models.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何使用这些技术，跳到下一节，在那里我们将使用魔术函数或数据模型执行向量操作。
- en: Vector addition
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量加法
- en: 'Similar to numeric addition, we can overload the `+` operator using the `__add__()`
    data model, which will add two different vectors and combine its effect in order
    to produce a new single vector. Using this method, we can make diagonal motions
    with the game characters. We need two vectors to perform addition; the first one
    will be the current position of the game character, and next one will be a predefined
    fixed amount for each component of the vector that needs to be added when the
    user presses any key on the keyboard. The following diagram illustrates the addition
    of vectors in detail:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与数值加法类似，我们可以使用“__add__（）”数据模型重载“+”运算符，它将添加两个不同的向量并将其效果组合以产生一个新的单一向量。使用此方法，我们可以使游戏角色进行对角线运动。我们需要两个向量来执行加法；第一个将是游戏角色的当前位置，下一个将是用户在键盘上按下任何键时需要添加的向量的每个分量的预定义固定量。以下图示了向量加法的详细过程：
- en: '![](Images/eadbff9a-5933-446d-9314-fa85759bc534.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: ！[](Images/eadbff9a-5933-446d-9314-fa85759bc534.png)
- en: 'Never perform addition operation of vectors with the `+` operator when you
    have a vector that''s represented by tuples or lists. [1,2] + [3,4] does not add
    individual digits like this: [4, 6]. Instead, it will concatenate two lists into
    one, like so: [1,2,3,4].'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有一个由元组或列表表示的向量时，永远不要使用“+”运算符执行向量的加法操作。[1,2] + [3,4]不会像这样添加单个数字：[4,6]。相反，它将两个列表连接成一个，如下所示：[1,2,3,4]。
- en: 'The following code uses the `__iadd__()` magic function to add two vectors.
    The `iadd` and `add` methods work in a similar way, but the main difference between
    them is that `__iadd__()` stores its result into the memory location, unlike `__add__()`.
    You can use either of these to write the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用“__iadd__（）”魔术函数来添加两个向量。“iadd”和“add”方法的工作方式类似，但它们之间的主要区别是“__iadd__（）”将其结果存储在内存位置中，而“__add__（）”不会。您可以使用其中任何一个来编写以下代码：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Make sure that the preceding code is included inside the previously made `Vector`
    class. The `__iadd__()` method takes the argument, *other,* which represents a
    second vector that needs to be added to the vector that it is called upon. Inside
    the magic function, we have made conditionals to check whether the passed *other* vector
    is a type of `Vector` class. If it is, we are adding matching components of the
    first vector with the second vector, which is `first.x` to `second.x`, and `first.y`
    to `second.y`, where first and second are vectors. Let''s make the instances of
    the `Vector` class and check the output of the vector addition:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 确保前面的代码包含在先前创建的“Vector”类中。 “__iadd__（）”方法接受参数* other *，表示需要添加到其上调用的向量的第二个向量。在魔术函数内部，我们已经制作了条件语句，以检查传递的*
    other *向量是否是“Vector”类的类型。如果是，我们将第一个向量的匹配分量与第二个向量相加，即`first.x`到`second.x`和`first.y`到`second.y`，其中first和second是向量。让我们创建“Vector”类的实例并检查向量加法的输出：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have successfully used the magic method to implement vector addition,
    it's time to learn a few more of them in order to implement vector subtraction
    and vector negation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功使用魔术方法来实现向量加法，是时候学习更多的方法来实现向量减法和向量否定了。
- en: Vector subtraction
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量减法
- en: 'Just like the addition of vectors implies the forward motion for game characters,
    vector subtraction suggests the opposite direction from where it is currently
    facing. We can use either `__sub__()` or `__isub__()` to implement vector subtraction.
    We normally prefer `isub` because it stores a result before returning it and it
    can be perfectly used in order to clone the vector objects so that we can perform
    different manipulation in the duplicate objects, without harming original one.
    Vector subtraction is quite similar to addition; instead of adding each components
    of a vector, we are simply going to subtract them. This motion is useful in games
    such as Pacman, where users have to reverse their direction spontaneously without
    disturbing the gameplay. Let''s write the following code inside the `Vector` class
    in order to perform vector subtraction:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像向量的加法意味着游戏角色的前进运动一样，向量的减法暗示着与当前面向相反的方向。我们可以使用“__sub__（）”或“__isub__（）”来实现向量减法。我们通常更喜欢“isub”，因为它在返回结果之前存储结果，并且可以完美地用于克隆向量对象，以便我们可以在重复对象中执行不同的操作，而不会损害原始对象。向量减法与加法非常相似；而不是添加向量的每个分量，我们只是要减去它们。这种运动在游戏中非常有用，比如吃豆人，用户必须在不干扰游戏过程的情况下突然改变方向。让我们在“Vector”类中编写以下代码，以执行向量减法：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s run the preceding code in the Python shell in order to observe the result
    of vector subtraction:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python shell中运行上述代码，以观察向量减法的结果：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Vector multiplication and division
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量乘法和除法
- en: 'Operations such as multiplication and division will make vectors larger and
    smaller, respectively. The change of motion due to multiplication can be linear
    when a vector is multiplied by any scalar number. For example, when we multiply
    any vector by two, its magnitude will be twice than before, but the direction
    will remain unchanged. Similarly, when we multiply the same vector with a negative
    number, let''s say, -2, its direction will be opposite to the direction it was
    originally facing. Multiplication operations are normally used for scaling vectors.
    We can multiply and divide two vectors as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法和除法等操作将使向量变大和变小。由于乘法而产生的运动变化可能是线性的，当向量乘以任何标量时。例如，当我们将任何向量乘以二时，其大小将是以前的两倍，但方向将保持不变。同样，当我们用负数乘以相同的向量，比如-2时，它的方向将与最初的方向相反。乘法操作通常用于缩放向量。我们可以按以下方式乘以和除以两个向量：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Similar to vector multiplication and division, we can perform a scaling process
    using scalar quantity. We will pass a number, instead of the second vector, as
    a parameter to the magic methods. It can be done as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与向量乘法和除法类似，我们可以使用标量数量进行缩放过程。我们将传递一个数字，而不是第二个向量，作为魔术方法的参数。可以按以下方式完成：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Vector negation and equality
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量否定和相等
- en: 'Since we have covered the most important operations of vectors, such as addition,
    multiplication, and subtraction, we will now learn the easy, yet important, vector
    manipulation technique, which is known as vector negation and equality. Vector
    negation is important when a player wants to reach out to the preceding state
    from the current one (since AB = -BA), which implies that negating any vector
    creates another vector of the same magnitude but in the opposite direction. In
    order to negate a vector, we can simply add the `-` negative operator to each
    component of the vector. As an example, we can consider the following lines of
    code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经涵盖了向量的最重要的操作，如加法、乘法和减法，我们现在将学习简单但重要的向量操作技术，即向量否定和相等。当玩家想要从当前状态到达前一个状态时（因为AB
    = -BA），向量否定就变得很重要，这意味着否定任何向量都会创建另一个大小相同但方向相反的向量。为了否定一个向量，我们可以简单地向向量的每个分量添加`-`负运算符。例如，我们可以考虑以下代码行：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can check whether two vectors are equal by checking each of the components
    of the vector. For example, `first.x` should be compared with `second.x`, and
    `first.y` should be compared with `second.y`. For example, the following method
    will return `True` if two vectors are equal:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查向量的每个分量来检查两个向量是否相等。例如，`first.x`应该与`second.x`进行比较，`first.y`应该与`second.y`进行比较。例如，以下方法将在两个向量相等时返回`True`：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'According to the Python official documentation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python官方文档：
- en: '*("*`NotImplemented` *signals to the runtime that it should ask someone else
    to satisfy the operation. In the expression `a == b`, if `a.__eq__(b)` returns*
    `NotImplemented`*, then Python tries `b.__eq__(a)`. If b knows enough to return*
    `True` *or* `False`*, then the expression can succeed. If it doesn''t, then the
    runtime will fall back to the built-in behavior (which is based on the identity
    of == and != )")*.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*（"`NotImplemented` *向运行时发出信号，告诉它应该要求其他人满足操作。在表达式`a == b`中，如果`a.__eq__(b)`返回*
    `NotImplemented`*，那么Python会尝试* `b.__eq__(a)`。如果b知道足够返回* `True` *或* `False`*，那么表达式可以成功。如果不知道，那么运行时将退回到内置行为（基于==和！=的身份）"）*。'
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have covered a wide range of topics in this chapter, starting from data models
    to the creation and manipulation of vectors. Vectors are undoubtedly the most
    essential topic for any game developer; they help to create motion for the game
    characters and sprites so that the game will be more user interactive. We have
    learned about different operations, such as addition, subtraction, division, negation,
    and many more. We also manipulated our vector components using these operations
    and magic methods. Magic methods are a part of method overriding, which should
    have been covered in [Chapter 6](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml),
    *Object-Oriented Programming*. However, I reserved it until this chapter because
    it makes more sense to learn about it while exploring vectors.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了各种主题，从数据模型到向量的创建和操作。向量无疑是任何游戏开发者最重要的主题；它们帮助创建游戏角色和精灵的运动，使游戏更具用户互动性。我们学习了不同的操作，如加法、减法、除法、否定等。我们还使用这些操作和魔术方法来操作我们的向量组件。魔术方法是方法重写的一部分，应该在[第6章](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml)
    *面向对象编程*中介绍。然而，我将它保留到了这一章，因为在探索向量时学习它更有意义。
- en: As the mathematical logic concerning vectors is a primary building block for
    the expedition of character movements in the game, you have learned how to implement
    operator overloading using magic functions. The vector manipulation skills we've
    learned in this chapter are important because they specify the position of an
    object and help us perform manipulation with some algebraic operations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于关于向量的数学逻辑是游戏中角色移动的主要基础，您已经学会了如何使用魔术函数实现运算符重载。本章学到的向量操作技能很重要，因为它们指定了对象的位置，并帮助我们执行一些代数运算。
- en: This chapter has introduced us to two-dimensional vectors—a mathematical concept
    that makes the motion of game characters possible in a game. To implement this,
    we had to use the concepts of data overloading using magic functions. To overload
    any operator— that is, change the implementation of any operator such as `+` or
    `-`—we extend the usage of such operators from primitive data types to complex
    data structures. The main goal of this chapter was to introduce you to the ways
    you can accomplish mathematical concepts such as 2D vectored operations using
    the Python programming paradigm.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了二维向量——一种数学概念，使得游戏中角色的运动成为可能。为了实现这一点，我们必须使用魔术函数的数据重载概念。为了重载任何运算符——即改变任何运算符的实现，比如`+`或`-`——我们将这些运算符的使用从原始数据类型扩展到复杂数据结构。本章的主要目标是向您介绍使用Python编程范式实现2D向量运算等数学概念的方法。
- en: In the next chapter, we will take a roller coaster ride of game programming
    using the turtle module by applying our knowledge from this chapter. We will make
    multiple games such as Snake, Pong, and Flappy Bird. Now, it's time for you to
    start experimenting with vectors; try to mix them together and develop various
    kinds of movements for the vector.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将利用本章的知识，使用海龟模块进行游戏编程的过山车之旅。我们将制作多个游戏，如贪吃蛇、乒乓球和Flappy Bird。现在，是时候让您开始尝试向量的实验了；尝试将它们混合在一起，并为向量开发各种运动。
