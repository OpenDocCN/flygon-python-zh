- en: Multithreading with QTimer and QThread
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QTimer和QThread进行多线程处理
- en: Despite the ever-increasing power of computer hardware, programs are still often
    called upon to perform tasks that take seconds, if not minutes, to complete. While
    such delays may be due to factors outside the programmer's control, it nevertheless
    reflects poorly on an application to become unresponsive while background tasks
    are running. In this chapter, we're going to learn about some tools that can help
    us to retain our application's responsiveness by deferring heavy operations or
    moving them out of the thread entirely. We'll also learn how to use a multithreaded
    application design to speed up these operations on multicore systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管计算机硬件的功能不断增强，程序仍然经常需要执行需要几秒甚至几分钟才能完成的任务。虽然这种延迟可能是由于程序员无法控制的因素造成的，但它仍然会影响应用程序的性能，使其在后台任务运行时变得无响应。在本章中，我们将学习一些工具，可以帮助我们通过推迟重型操作或将其移出线程来保持应用程序的响应性。我们还将学习如何使用多线程应用程序设计来加快多核系统上的这些操作。
- en: 'This chapter is broken into the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为以下主题：
- en: Delayed actions with `QTimer`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QTimer`进行延迟操作
- en: Multithreading with `QThread`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QThread`进行多线程处理
- en: High concurrency with `QThreadPool` and `QRunner`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QThreadPool`和`QRunner`实现高并发
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires only the basic Python and PyQt5 setup you've been using
    throughout the book. You can also reference the example code at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter10](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter10).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章只需要您在整本书中一直在使用的基本Python和PyQt5设置。您还可以参考[https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter10](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter10)上的示例代码。
- en: Check out the following video to see the code in action: [http://bit.ly/2M6iSPl](http://bit.ly/2M6iSPl)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的运行情况：[http://bit.ly/2M6iSPl](http://bit.ly/2M6iSPl)
- en: Delayed actions with QTimer
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QTimer进行延迟操作
- en: Being able to delay action in a program is useful in a variety of situations.
    For example, let's say that we want a modeless **pop-up** dialog that closes itself
    after a defined number of seconds rather than waiting for a user to click on a
    button.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中能够延迟操作在各种情况下都是有用的。例如，假设我们想要一个无模式的**弹出**对话框，在定义的秒数后自动关闭，而不是等待用户点击按钮。
- en: 'We will start by subclassing `QDialog`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从子类化`QDialog`开始：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Having saved a `timeout` value, we now want to override the dialog box's `show()`
    method so that it closes after that number of seconds.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 保存了一个`timeout`值后，我们现在想要重写对话框的`show()`方法，以便在指定的秒数后关闭它。
- en: 'A naive approach might be as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个天真的方法可能是：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Python's `time.sleep()` function will halt program execution for the number
    of seconds we pass in as an argument. At first glance, it appears like this should
    do what we want—that is, show the window, pause for `timeout` seconds, and then
    hide the window.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`time.sleep()`函数将暂停程序执行我们传入的秒数。乍一看，它似乎应该做我们想要的事情，即显示窗口，暂停`timeout`秒，然后隐藏窗口。
- en: 'So, let''s add some code in our `MainWindow.__init__()` method to test it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在我们的`MainWindow.__init__()`方法中添加一些代码来测试它：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you run the program, you'll find that things don't go quite as expected.
    Since this dialog is modeless, it should appear alongside our main window and
    not block anything. Additionally, since we called `show()` before calling `sleep()`,
    it should display itself before pausing. Instead, you most likely got a blank
    and frozen dialog window that paused the entire program for the duration of its
    existence. So, what's happening here?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行程序，您会发现事情并不如预期。由于这个对话框是无模式的，它应该出现在我们的主窗口旁边，而不会阻塞任何东西。此外，由于我们在调用`sleep()`之前调用了`show()`，它应该在暂停之前显示自己。相反，您很可能得到一个空白和冻结的对话框窗口，它在其存在的整个期间都会暂停整个程序。那么，这里发生了什么？
- en: Remember from [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting
    Started with PyQt,* that Qt programs have an **event loop**, which is started
    when we call `QApplication.exec()`. When we call a method such as `show()`, which
    involves many behind-the-scenes actions such as painting widgets and communicating
    with the window manager, these tasks aren't executed immediately. Instead, they
    are placed in a task queue. The event loop works through this task queue one job
    at a time until it's empty. This process is **asynchronous**, so a call to the `QWidget.show()` method
    doesn't wait for the window to be shown before it returns; it merely places the
    tasks involved in showing the widget on the event queue and returns.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml) *PyQt入门*中记得，Qt程序有一个**事件循环**，当我们调用`QApplication.exec()`时启动。当我们调用`show()`这样的方法时，它涉及许多幕后操作，如绘制小部件和与窗口管理器通信，这些任务不会立即执行。相反，它们被放置在任务队列中。事件循环逐个处理任务队列中的工作，直到它为空。这个过程是**异步**的，因此调用`QWidget.show()`方法不会等待窗口显示后再返回；它只是将显示小部件的任务放在事件队列中并返回。
- en: Our call to the `time.sleep()` method creates an immediate blocking delay in
    the program, halting all other processing until the function exits. This includes
    halting the Qt event loop, which means that all of those drawing operations that
    are still in the queue won't happen. In fact, no events will be processed until
    `sleep()` completes. This is why the widget was not fully drawn, and why the program
    did not continue while `sleep()` was executing.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`time.sleep()`方法的调用在程序中创建了一个立即阻塞的延迟，直到函数退出为止，这将停止所有其他处理。这包括停止Qt事件循环，这意味着所有仍在队列中的绘图操作都不会发生。事实上，直到`sleep()`完成，没有事件会被处理。这就是为什么小部件没有完全绘制，程序在`sleep()`执行时为什么没有继续的原因。
- en: In order to work correctly, we need to place our `hide()` call on the event
    loop, so that our call to `AutoCloseDialog.show()` can return immediately and
    let the event loop handle hiding the dialog, in the same way that it handles showing
    it. But we don't want to do this right away—we want to delay its execution on
    the event queue until a certain amount of time has passed. This is what the `QtCore.QTimer`
    class can do for us.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确工作，我们需要将`hide()`调用放在事件循环中，这样我们对`AutoCloseDialog.show()`的调用可以立即返回，并让事件循环处理隐藏对话框，就像它处理显示对话框一样。但我们不想立即这样做，我们希望在事件队列上延迟执行一段时间。这就是`QtCore.QTimer`类可以为我们做的事情。
- en: Single shot timers
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单发定时器
- en: '`QTimer` is a simple `QObject` subclass that can emit a `timeout` signal after
    a certain period of time.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTimer`是一个简单的`QObject`子类，可以在一定时间后发出`timeout`信号。'
- en: 'The simplest way to defer a single action with `QTimer` is to use the `QTimer.singleShot()`
    static method, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`QTimer`延迟单个操作的最简单方法是使用`QTimer.singleShot()`静态方法，如下所示：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`singleShot()` takes two arguments: an interval in milliseconds and a callback
    function. In this case, we''re calling the `self.hide()` method after a number
    of `self.timeout` seconds (we will multiply by 1,000 to convert this into milliseconds).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`singleShot()`接受两个参数：毫秒为单位的间隔和回调函数。在这种情况下，我们在一定数量的`self.timeout`秒后调用`self.hide()`方法（我们将乘以1,000将其转换为毫秒）。'
- en: Running this script again, you should now see your dialog behaving as expected.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行此脚本，您现在应该看到您的对话框表现如预期。
- en: Repeating timers
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复定时器
- en: Sometimes in an application, we need to repeat an action at specified intervals,
    such as autosaving a document, polling a network socket, or nagging a user incessantly
    to give the application a 5-star review in the app store (well, maybe not that
    one).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，有时我们需要在指定的间隔重复执行某个操作，比如自动保存文档，轮询网络套接字，或者不断地催促用户在应用商店给应用程序评5星（好吧，也许不是这个）。
- en: '`QTimer` can handle this too, as you can see from the following code block:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTimer`也可以处理这个问题，您可以从以下代码块中看到：'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we're creating a `QTimer` object explicitly rather than using
    the static `singleShot()` method. Then, we're using the `setInterval()` method
    to configure a timeout interval in milliseconds. When that interval has passed,
    the timer object will emit a `timeout` signal. By default, the `QTimer` object
    will repeatedly issue the `timeout` signal every time reaches the end of the specified
    interval. You can use the `setSingleShot()` method to convert it into a single
    shot as well, though, in general, it's easier to use the static method that we
    demonstrated in the *Single shot timers* section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们明确创建了一个`QTimer`对象，而不是使用静态的`singleShot()`方法。然后，我们使用`setInterval()`方法配置了以毫秒为单位的超时间隔。当间隔过去时，定时器对象将发出`timeout`信号。默认情况下，`QTimer`对象将在达到指定间隔的末尾时重复发出`timeout`信号。您也可以使用`setSingleShot()`方法将其转换为单发，尽管一般来说，使用我们在*单发定时器*部分演示的静态方法更容易。
- en: After creating the `QTimer` object and configuring the interval, we just connect
    its `timeout` signal to the `show()` method of another `AutoCloseDialog` object
    and then start the timer by calling the `start()` method.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`QTimer`对象并配置间隔后，我们只需将其`timeout`信号连接到另一个`AutoCloseDialog`对象的`show()`方法，然后通过调用`start()`方法启动定时器。
- en: 'We can also stop the timer and restart it again:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以停止定时器，然后重新启动：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `QTimer.stop()` method stops the timer and the `start()` method will start
    it again from the beginning. It's worth noting that there is no `pause()` method
    here; the `stop()` method will clear any current progress and the `start()` method will
    start over from the configured interval.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTimer.stop()`方法停止定时器，`start()`方法将重新开始。值得注意的是这里没有`pause()`方法；`stop()`方法将清除任何当前的进度，`start()`方法将从配置的间隔重新开始。'
- en: Getting information from timers
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从定时器获取信息
- en: '`QTimer` has a few methods that we can use to extract information about the
    state of the timer. For example, let''s keep our user updated on how things are
    going with the following lines of code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTimer`有一些方法，我们可以用来提取有关定时器状态的信息。例如，让我们通过以下代码让用户了解事情的进展：'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We''ve set up yet another timer that will call `self.update_status()` once
    every second. `update_status()` will then query the first time for information,
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了另一个定时器，它将每秒调用`self.update_status()`。`update_status()`然后查询信息的第一次如下：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `QTimer.isActive()` method tells us whether a timer is currently running,
    while `remainingTime()` tells us how many milliseconds remain until the next `timeout`
    signal.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`QTimer.isActive()`方法告诉我们定时器当前是否正在运行，而`remainingTime()`告诉我们距离下一个`timeout`信号还有多少毫秒。'
- en: Running this program now, you should see a status update about your next dialog
    box.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行这个程序，您应该看到关于下一个对话框的状态更新。
- en: Limitations of timers
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时器的限制
- en: While timers allow us to defer actions to the event queue and can help to prevent
    awkward pauses in our programs, it's important to understand that functions connected
    to the `timeout` signal are still executed in—and will therefore block—the main
    execution thread.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然定时器允许我们将操作推迟到事件队列，并可以帮助防止程序中的尴尬暂停，但重要的是要理解连接到`timeout`信号的函数仍然在主执行线程中执行，并且因此会阻塞主执行线程。
- en: 'For example, suppose that we have a long blocking method, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个长时间阻塞的方法，如下所示：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You might think that calling this method from a single shot timer will prevent
    it from locking up your application. Let''s test that theory by adding this code
    to `MainView.__init__()`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能认为从单发定时器调用此方法将阻止其锁定应用程序。让我们通过将此代码添加到`MainView.__init__()`来测试这个理论：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Calling `singleShot()` with a `1` millisecond delay is a simple way of scheduling
    an event almost immediately. So, does it work?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`1`毫秒延迟调用`singleShot()`是安排一个几乎立即发生的事件的简单方法。那么，它有效吗？
- en: Well, no, it doesn't; if you run the program, then you'll see that it locks
    up for 30 seconds. Despite the fact that we deferred the action, it's still a
    long blocking action that will freeze up the program when it runs. It may be that
    we can play with the delay value to make sure it's deferred to a more opportune
    moment (such as after the application has painted itself or after a splash screen
    displays), but sooner or later, the application will have to freeze and become
    unresponsive while the task runs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，实际上并不是这样；如果你运行程序，你会发现它会锁定30秒。尽管我们推迟了操作，但它仍然是一个长时间的阻塞操作，会在运行时冻结程序。也许我们可以调整延迟值，以确保它被推迟到更合适的时刻（比如在应用程序绘制完毕后或者在启动画面显示后），但迟早，应用程序将不得不冻结并在任务运行时变得无响应。
- en: There is a solution to such a problem, however; in the next section, *Multithreading
    with QThread*, we'll look at how to push heavy, blocking tasks like this to another
    thread so that our program can keep running without freezing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于这样的问题有一个解决方案；在下一节*使用QThread进行多线程处理*中，我们将看看如何将这样的繁重阻塞任务推送到另一个线程，以便我们的程序可以继续运行而不会冻结。
- en: Multithreading with QThread
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QThread进行多线程处理
- en: Waiting is sometimes unavoidable. Whether querying the network, accessing a
    filesystem, or running a complex computation, sometimes a program just needs time
    to complete a process. While we're waiting, though, there's no reason for our
    GUI to become completely unresponsive. Modern systems with multiple CPU cores
    and threading technology allow us to run concurrent processes, and there's no
    reason why we can't take advantage of this to make responsive GUIs. Although Python
    has its own threading library, Qt offers us the `QThread` object, which can be
    used to build multithreaded applications easily. It has the additional advantage
    of being integrated into Qt and being compatible with signals and slots.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 等待有时是不可避免的。无论是查询网络、访问文件系统还是运行复杂的计算，有时程序只是需要时间来完成一个过程。然而，在等待的时候，我们的GUI没有理由完全变得无响应。具有多个CPU核心和线程技术的现代系统允许我们运行并发进程，我们没有理由不利用这一点来制作响应式的GUI。尽管Python有自己的线程库，但Qt为我们提供了`QThread`对象，可以轻松构建多线程应用程序。它还有一个额外的优势，就是集成到Qt中，并且与信号和槽兼容。
- en: In this section, we'll build a somewhat slow file searching tool and then use
    `QThread` to ensure that the GUI remains responsive.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个相对缓慢的文件搜索工具，然后使用`QThread`来确保GUI保持响应。
- en: The SlowSearcher file search engine
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SlowSearcher文件搜索引擎
- en: In order to talk effectively about threading, we first require a slow process
    that can be run on a separate thread. Open a new copy of the Qt application template
    and call it `file_searcher.py`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地讨论线程，我们首先需要一个可以在单独线程上运行的缓慢过程。打开一个新的Qt应用程序模板副本，并将其命名为`file_searcher.py`。
- en: 'Let''s begin by implementing a file searching engine:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实现一个文件搜索引擎：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We''re calling this `SlowSearcher` because it''s going to be deliberately non-optimized.
    It starts with defining a few signals, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其称为`SlowSearcher`，因为它将是故意非优化的。它首先定义了一些信号，如下所示：
- en: The `match_found` signal will be emitted when a filename matches the search
    term and will contain the matched filename
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当文件名与搜索项匹配时，将发出`match_found`信号，并包含匹配的文件名
- en: The `directory_changed` signal will be emitted whenever we start searching in
    a new directory
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当我们开始在一个新目录中搜索时，将发出`directory_changed`信号
- en: The `finished` signal will be emitted when the whole filesystem tree has been
    searched
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当整个文件系统树已经被搜索时，将发出`finished`信号
- en: Finally, we override `__init__()` just to define an instance variable called
    `self.term`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们重写`__init__()`只是为了定义一个名为`self.term`的实例变量。
- en: 'Next, we''ll create a setter method for `term`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为`term`创建一个setter方法：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you're wondering why we're bothering with such a simple setter method when
    we could just set the variable directly, the reason for this will soon become
    apparent as we discuss some of the limitations of `QThread`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么我们要费力实现一个如此简单的setter方法，而不是直接设置变量，这个原因很快就会显而易见，当我们讨论`QThread`的一些限制时，这个原因将很快显现出来。
- en: 'Now, we''ll create the searching methods, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建搜索方法，如下所示：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This method will be the slot that we call to start off the search process. It
    begins by locating the root directory as a `QDir` object and then calls the `_search()`
    method. Once `_search()` returns, it emits the `finished` signal.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将是我们调用来启动搜索过程的槽。它首先将根目录定位为一个`QDir`对象，然后调用`_search()`方法。一旦`_search()`返回，它就会发出`finished`信号。
- en: 'The actual `_search()` method is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的`_search()`方法如下：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`_search()` is a recursive search method. It begins by emitting the `directory_changed`
    signal to indicate that we''re searching in a new directory and then creates a
    `QDir` object for the current path. Next, it sets the `filter` property so that,
    when we query the `entryInfoList()` method, it won''t include symbolic links or
    the `.` and `..` shortcuts (this is to avoid infinite loops in the search). Finally,
    we iterate the contents of the directory retrieved by `entryInfoList()` and emit
    a `match_found` signal for each matched item. For each directory found, we run
    the `_search()` method on it.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`_search()`是一个递归搜索方法。它首先发出`directory_changed`信号，表示我们正在一个新目录中搜索，然后为当前路径创建一个`QDir`对象。接下来，它设置`filter`属性，以便在查询`entryInfoList()`方法时，不包括符号链接或`.`和`..`快捷方式（这是为了避免搜索中的无限循环）。最后，我们遍历`entryInfoList()`检索到的目录内容，并为每个匹配的项目发出`match_found`信号。对于每个找到的目录，我们在其上运行`_search()`方法。'
- en: In this way, our method will recurse through all of the directories on the filesystem,
    looking for matches to our search term. This is not the most optimized approach,
    and intentionally so. Depending on your hardware, platform, and the number of
    files on your drive, this search can take anywhere from a few seconds to several
    minutes to complete, so it's perfect for looking at how threading can help an
    application that must execute a slow process.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的方法将递归遍历文件系统中的所有目录，寻找与我们的搜索词匹配的内容。这不是最优化的方法，这是故意这样做的。根据您的硬件、平台和驱动器上的文件数量，这个搜索可能需要几秒钟到几分钟的时间才能完成，因此它非常适合查看线程如何帮助必须执行缓慢进程的应用程序。
- en: In multithreading terminology, a class that performs the actual work is referred
    to as a `Worker` class. `SlowSearcher` is an example of a `Worker` class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程术语中，执行实际工作的类被称为`Worker`类。`SlowSearcher`是`Worker`类的一个示例。
- en: A non-threaded searcher
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个非线程化的搜索器
- en: To implement a searching application, let's add a GUI form for entering a search
    term and displaying the search results.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个搜索应用程序，让我们添加一个用于输入搜索词和显示搜索结果的GUI表单。
- en: 'Let''s call it `SearchForm`, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称它为`SearchForm`，如下所示：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This GUI only contains a `QLineEdit` widget for entering a term and a `QListWidget` widget
    for displaying the results. We're forwarding the `QLineEdit` widget's `returnPressed`
    and `textChanged` signals to identically named signals on the `SearchForm` object
    so that we can connect them more easily in our `MainView` method. We've also connected
    `returnPressed` to the list widget's `clear` slot so that starting a new search
    clears the results area.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个GUI只包含一个用于输入搜索词的`QLineEdit`小部件和一个用于显示结果的`QListWidget`小部件。我们将`QLineEdit`小部件的`returnPressed`和`textChanged`信号转发到`SearchForm`对象上的同名信号，以便我们可以更容易地在我们的`MainView`方法中连接它们。我们还将`returnPressed`连接到列表小部件的`clear`槽，以便开始新搜索时清除结果区域。
- en: 'The `SearchForm()` method will also require a method to add a new item:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`SearchForm()`方法还需要一个方法来添加新项目：'
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is simply a convenience method so that, once again, the main application
    doesn't have to directly manipulate the widgets in the form.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个方便的方法，这样一来，主应用程序就不必直接操作表单中的小部件。
- en: 'In our `MainWindow.__init__()` method, we can create a searcher and form object
    and connect them, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`MainWindow.__init__()`方法中，我们可以创建一个搜索器和表单对象，并将它们连接起来，如下所示：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After creating the `SlowSearcher` and `SearchForm` objects and setting the
    form as the central widget, we connect the appropriate signals together, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`SlowSearcher`和`SearchForm`对象并将表单设置为中央部件后，我们将适当的信号连接在一起，如下所示：
- en: The form's `textChanged` signal, which emits the string entered, is connected
    to the searcher's `set_term()` setter method.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单的`textChanged`信号，发出输入的字符串，连接到搜索器的`set_term()`设置方法。
- en: The form's `returnPressed` signal is connected to the searcher's `do_search()`
    method to trigger the search.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单的`returnPressed`信号连接到搜索器的`do_search()`方法以触发搜索。
- en: The searcher's `match_found` signal, which carries the pathname found, is connected
    to the form's `addResult()` method.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索器的`match_found`信号，携带找到的路径名，连接到表单的`addResult()`方法。
- en: 'Finally, let''s add two `MainWindow` methods to keep the user informed about
    the status of the search:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加两个`MainWindow`方法，以便让用户了解搜索的状态：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first will show a status indicating that the search is finished, while the
    second will show a status indicating the current path that the searcher is searching.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个将显示一个指示搜索已完成的状态，而第二个将显示一个指示搜索器正在搜索的当前路径的状态。
- en: 'Back in `__init__()`, these will be connected to the searcher, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`__init__()`，这些将连接到搜索器，如下所示：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Testing our non-threaded search application
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试我们的非线程化搜索应用程序
- en: Our expectation with this script is that, as we search through directories on
    the system, we'll get a steady printout of search results to the results area,
    as well as constant updates on the current directory being searched in the status
    bar.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对这个脚本的期望是，当我们在系统中搜索目录时，我们将在结果区域得到稳定的搜索结果打印输出，同时状态栏中的当前目录也会不断更新。
- en: If you run it, however, you'll find that this is not what actually happens.
    Instead, the moment the search starts, the GUI freezes up. Nothing is shown in
    the status bar and no entries appear in the list widget, even though matches are
    being printed to the console. Only when the search finally finishes do the results
    appear and the status gets updated.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您运行它，您会发现实际发生的并不是这样。相反，一旦搜索开始，GUI就会冻结。状态栏中什么都没有显示，列表小部件中也没有条目出现，尽管匹配项已经打印到控制台上。只有当搜索最终完成时，结果才会出现，状态才会更新。
- en: To fix this, we need to introduce threading.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要引入线程。
- en: So, why does the program print to the console in real time but not update our
    GUI in real time? It's because `print()` is synchronous—it executes as soon as
    it's called and does not return until the text is written to the console. Our
    GUI methods, however, are asynchronous—they are queued in the Qt event queue and
    will not execute until the main event loop finishes executing the `SlowSearcher.search()` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么程序会实时打印到控制台，但不会实时更新我们的GUI呢？这是因为`print()`是同步的——它在调用时立即执行，并且直到文本被写入控制台后才返回。然而，我们的GUI方法是异步的——它们被排队在Qt事件队列中，并且直到主事件循环执行`SlowSearcher.search()`方法后才会执行。
- en: Adding threads
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加线程
- en: A **thread** is an independent code execution context. By default, all of our
    code runs in a single thread, so we refer to it as a **single-threaded** application.
    Using the `QtCore.QThread` class, we can create new threads and move portions
    of our code to them, making it a **multithreaded** application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**线程**是独立的代码执行上下文。默认情况下，我们所有的代码都在一个线程中运行，因此我们将其称为**单线程**应用程序。使用`QtCore.QThread`类，我们可以创建新的线程并将代码的部分移动到这些线程中，使其成为**多线程**应用程序。'
- en: 'You can use the `QThread` object as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`QThread`对象，如下所示：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We start by creating a `QThread` object, and then use the `SlowSearcher.moveToThread()`
    method to move our `SlowSearcher` object to the new thread. `moveToThread()` is
    a `QObject` method inherited by any class that subclasses `QObject`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`QThread`对象，然后使用`SlowSearcher.moveToThread()`方法将我们的`SlowSearcher`对象移动到新线程中。`moveToThread()`是`QObject`的一个方法，由任何子类`QObject`的类继承。
- en: Next, we connect the searcher's `finished` signal to the thread's `quit` slot;
    this will cause the thread to stop executing when the search is finished. Since
    the search thread isn't part of our main execution thread, it must have some way
    to quit on its own or it will continue to run after the search is over.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将搜索器的`finished`信号连接到线程的`quit`槽；这将导致线程在搜索完成时停止执行。由于搜索线程不是我们主要的执行线程的一部分，它必须有一种方法来自行退出，否则在搜索结束后它将继续运行。
- en: Finally, we need to call the search thread's `start()` method to begin executing
    the code and allow our main thread to interact with the `SlowSearcher` object.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要调用搜索线程的`start()`方法来开始执行代码，并允许我们的主线程与`SlowSearcher`对象交互。
- en: This code needs to be inserted after the `SlowSearcher` object is created, but
    before any signals or slots are connected to it (we'll discuss why in the *Threading
    tips and caveats* section).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码需要在创建`SlowSearcher`对象之后插入，但在连接到它的任何信号或槽之前（我们将在*线程提示和注意事项*部分讨论原因）。
- en: 'Since we''re quitting the thread after each search, we need to restart the
    thread each time a new search is started. We can do this by using the following
    connection:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在每次搜索后都要退出线程，所以需要在每次开始新搜索时重新启动线程。我们可以通过以下连接来实现这一点：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is all that is needed to use a thread. Run the script again and you'll
    see that the GUI is updated as the search progresses.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用线程所需的一切。再次运行脚本，你会看到随着搜索的进行，GUI会更新。
- en: 'Let''s recap the process, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下这个过程，如下所示：
- en: Create an instance of the `Worker` class of your `QObject` object
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Worker`类的实例
- en: Create a `QThread` object
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`QThread`对象
- en: Use the `Worker` class' `moveToThread()` method to move it to the new thread
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Worker`类的`moveToThread()`方法将其移动到新线程
- en: Connect any other signals and slots
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接任何其他信号和槽
- en: Call the thread's `start()` method
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用线程的`start()`方法
- en: An alternate method
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另一种方法
- en: Although the `moveToThread()` method of working with `QThread` is the preferred
    approach recommended by the documentation, there is another way that works perfectly
    well and, in some way, simplifies our code. This approach is to create our `Worker`
    class by subclassing `QThread` and overriding the `run()` method using our worker
    code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`moveToThread()`方法是使用`QThread`的推荐方法，但还有另一种方法可以完全正常地工作，并且在某种程度上简化了我们的代码。这种方法是通过对`QThread`进行子类化并重写`run()`方法来创建我们的`Worker`类，使用我们的工作代码。
- en: 'For example, create a copy of `SlowSearcher` and alter it as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，创建`SlowSearcher`的副本，并进行如下修改：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we''ve altered only three things:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只改变了三件事：
- en: We've renamed the class to `SlowSearcherThread`.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已将类重命名为`SlowSearcherThread`。
- en: We've changed the parent class to `QThread`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已将父类更改为`QThread`。
- en: We've renamed `do_search()` to `run()`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经将`do_search()`重命名为`run()`。
- en: 'Our `MainWindow.__init__()` method will now be considerably simpler:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`MainWindow.__init__()`方法现在会简单得多：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, we only need to connect `returnPressed` to `SlowSearcher.start()`. The
    `start()` method creates the new thread and executes the object's `run()` method
    inside the new thread. This means that, by overriding that method, we can effectively
    place that code in a new thread.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将`returnPressed`连接到`SlowSearcher.start()`。`start()`方法创建了新线程，并在新线程中执行对象的`run()`方法。这意味着，通过重写该方法，我们可以有效地将该代码放在一个新线程中。
- en: Always remember to implement `run()` but call `start()`. Don't get this mixed
    up, or your multithreading won't work!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 始终记得实现`run()`，但调用`start()`。不要搞混了，否则你的多线程就无法工作！
- en: While there are some valid use cases for such an approach, it can create subtle
    problems with the thread ownership of the object's data. Even though a `QThread`
    object provides a control interface for a secondary thread, the object itself
    lives in the main thread. When we call `moveToThread()` on a `worker` object,
    we can be assured that the `worker` object is moved entirely to the new thread.
    However, when the `worker` object is a subclass of `QThread`, those `QThread`
    parts must remain in the main thread even though the executed code is moved to
    the new thread. This can lead to subtle bugs as it is difficult to untangle which
    parts of the `worker` object are in which thread.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法有一些有效的用例，但它可能会在对象数据的线程所有权上产生微妙的问题。即使`QThread`对象为辅助线程提供了控制接口，但对象本身仍然存在于主线程中。当我们在`worker`对象上调用`moveToThread()`时，我们可以确保`worker`对象完全移动到新线程中。然而，当`worker`对象是`QThread`的子类时，`QThread`的部分必须保留在主线程中，即使执行的代码被移动到新线程中。这可能会导致微妙的错误，因为很难搞清楚`worker`对象的哪些部分在哪个线程中。
- en: Ultimately, unless you have clear reasons for subclassing `QThread5`, you should
    use `moveToThread()`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，除非你有清晰的理由来对`QThread5`进行子类化，否则应该使用`moveToThread()`。
- en: Threading tips and caveats
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程的提示和注意事项
- en: The previous example may have made multithreaded programming seem simple, but
    that's because the code was carefully designed to avoid some of the problems that
    can arise when working with threads. In reality, retrofitting multithreading on
    a single-threaded application can be much more difficult.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例可能让多线程编程看起来很简单，但那是因为代码经过精心设计，避免了在处理线程时可能出现的一些问题。实际上，在单线程应用程序上进行多线程改造可能会更加困难。
- en: One common problem is when a `worker` object gets stuck in the main thread,
    causing us to lose the benefits of multithreading. This can happen in a few ways.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的问题是`worker`对象在主线程中被卡住，导致我们失去了多线程的好处。这可能以几种方式发生。
- en: For example, in our original threading script (the one that used `moveToThread()`),
    we had to move the worker to the thread before connecting any signals. If you
    try moving the threading code after the signal connections, you will find that
    the GUI locks up as though you hadn't used a thread.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们原始的线程脚本（使用`moveToThread()`的脚本）中，我们必须在连接任何信号之前将工作线程移动到线程中。如果您尝试在信号连接之后移动线程代码，您会发现GUI会锁定，就好像您没有使用线程一样。
- en: 'The reason this happens is that our worker''s methods are Python methods and
    connecting to them creates a connection in Python, which must persist in the main
    thread. One way around this is to use the `pyqtSlot()` decorator to make the worker''s
    methods into true Qt slots, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 发生这种情况的原因是我们的工作线程方法是Python方法，并且连接到它们会在Python中创建一个连接，这个连接必须在主线程中持续存在。解决这个问题的一种方法是使用`pyqtSlot()`装饰器将工作线程的方法转换为真正的Qt槽，如下所示：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once you do this, the order won't matter because the connections will exist
    entirely between the Qt objects rather than between the Python objects.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您这样做了，顺序就不重要了，因为连接将完全存在于Qt对象之间，而不是Python对象之间。
- en: 'You can also trap a `worker` object in the main thread by calling one of its
    methods directly in the main thread:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在主线程中直接调用`worker`对象的一个方法来捕获`worker`对象：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Placing the preceding lines in `__init__()` will cause the GUI to remain hidden
    until a filesystem search for `foo` has completed. Sometimes, this issue can be
    subtle; for example, the following `lambda` callback suggests that we are simply
    connecting the signal directly to the slot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述行放在`__init__()`中将导致GUI保持隐藏，直到对`foo`进行的文件系统搜索完成。有时，这个问题可能会很微妙；例如，以下`lambda`回调表明我们只是将信号直接连接到槽：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, this connection breaks threading because the `lambda` function is itself
    part of the main thread and, therefore, the call to `search()` will be executed
    in the main thread.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种连接会破坏线程，因为`lambda`函数本身是主线程的一部分，因此对`search()`的调用将在主线程中执行。
- en: 'Unfortunately, this limitation also means that you cannot use a `MainWindow`
    method as a slot to call the worker methods either; for example, we cannot run
    the following code in `MainWindow`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个限制也意味着您不能将`MainWindow`方法用作调用工作方法的槽；例如，我们不能在`MainWindow`中运行以下代码：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using this as a callback for `returnPressed` rather than connecting the signal
    to the `worker` object's methods individually causes the threading to fail and
    the GUI to lock.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将其作为`returnPressed`的回调，而不是将信号连接到`worker`对象的方法，会导致线程失败和GUI锁定。
- en: In short, it's best to constrain your interactions with the `worker` object
    to pure Qt signal and slot connections with no intermediate functions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，最好将与`worker`对象的交互限制为纯Qt信号和槽连接，没有中间函数。
- en: High concurrency with QThreadPool and QRunner
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QThreadPool和QRunner进行高并发
- en: '`QThreads` are ideal for putting a single long process into the background,
    especially when we want to communicate with that process using signals and slots.
    Sometimes, however, what we need to do is run a number of computationally intensive
    operations in parallel using as many threads as possible. This can be done with
    `QThread`, but a better alternative is found in `QThreadPool` and `QRunner`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`QThreads`非常适合将单个长时间的进程放入后台，特别是当我们希望使用信号和槽与该进程进行通信时。然而，有时我们需要做的是使用尽可能多的线程并行运行多个计算密集型操作。这可以通过`QThread`来实现，但更好的选择是在`QThreadPool`和`QRunner`中找到。'
- en: '`QRunner` represents a single runnable task that we want our worker threads
    to perform. Unlike `QThread`, it is not derived from `QObject` and cannot use
    signals and slots. However, it is very efficient and is much simpler to use when
    you want many threads.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`QRunner`代表我们希望工作线程执行的单个可运行任务。与`QThread`不同，它不是从`QObject`派生的，也不能使用信号和槽。然而，它非常高效，并且在需要多个线程时使用起来更简单。'
- en: The `QThreadPool` object's job is to manage a queue of `QRunner` objects, spinning
    up new threads to execute the objects as compute resources become available.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`QThreadPool`对象的工作是管理`QRunner`对象的队列，当计算资源可用时，启动新线程来执行对象。'
- en: To demonstrate how to work with this, let's build a file hashing utility.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何使用这个，让我们构建一个文件哈希实用程序。
- en: The file hasher GUI
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件哈希GUI
- en: Our file hasher utility will take a source directory, a destination file, and
    a number of threads to use. It will use the number of threads to calculate the
    MD5 hash of each file in the directory and then write the information out to the
    destination file as it does so.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的文件哈希工具将接受一个源目录、一个目标文件和要使用的线程数。它将使用线程数来计算目录中每个文件的MD5哈希值，然后在执行此操作时将信息写入目标文件。
- en: A **hashing function** such as MD5 is used to calculate a unique, fixed-length
    binary value from any arbitrary piece of data. Hashes are often used to determine
    the authenticity of a file since any change to the file will result in a different
    hash value.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如MD5之类的**哈希函数**用于从任意数据计算出唯一的固定长度的二进制值。哈希经常用于确定文件的真实性，因为对文件的任何更改都会导致不同的哈希值。
- en: Make a clean copy of your Qt template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow,* calling it `hasher.py`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)中制作一个干净的Qt模板的副本，*使用QMainWindow构建应用程序*，将其命名为`hasher.py`。
- en: 'Then, we''ll start with our GUI form class, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将从我们的GUI表单类开始，如下所示：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This form is very similar to the forms we've designed in previous chapters,
    with a `submitted` signal to publish the data, `QPushButton` objects to store
    the selected files, a spin box to select the number of threads, and another push
    button to submit the form.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式与我们在前几章设计的形式非常相似，有一个`submitted`信号来发布数据，`QPushButton`对象来存储选定的文件，一个旋转框来选择线程的数量，以及另一个按钮来提交表单。
- en: 'The file button callbacks will be as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 文件按钮的回调将如下所示：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we're using `QFileDialog` static functions (which you learned about in
    [Chapter 5](61ff4931-02af-474a-996c-5da827e0684f.xhtml), *Creating Data Interfaces
    with Model-View Classes*) to retrieve a directory name to examine and a filename
    that we'll use to save the output to.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`QFileDialog`静态函数（你在[第5章](61ff4931-02af-474a-996c-5da827e0684f.xhtml)中学到的，*使用模型视图类创建数据接口*）来检索要检查的目录名称和我们将用来保存输出的文件名。
- en: 'Finally, our `on_submit()` callback is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的`on_submit()`回调如下：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This callback simply gathers the data from our widgets and publishes it with
    the `submitted` signal.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个回调只是简单地从我们的小部件中收集数据，并使用`submitted`信号发布它。
- en: 'In `MainWindow.__init__()`, create a form and make it the central widget:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainWindow.__init__()`中，创建一个表单并将其设置为中央小部件：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: That takes care of our GUI, so let's now build the backend.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们的GUI就完成了，现在让我们来构建后端。
- en: A hash runner
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希运行器
- en: The `HashRunner` class will represent a single instance of the actual task that
    we're going to perform. For each file that we need to process, we'll create a
    unique `HashRunner` instance so its constructor will need to receive an input
    filename and an output filename as arguments. Its task will be to calculate the
    MD5 hash of the input file and append it along with the input filename to the
    output file.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashRunner`类将表示我们要执行的实际任务的单个实例。对于我们需要处理的每个文件，我们将创建一个唯一的`HashRunner`实例，因此它的构造函数将需要接收输入文件名和输出文件名作为参数。它的任务将是计算输入文件的MD5哈希，并将其与输入文件名一起追加到输出文件中。'
- en: 'We''ll start it by subclassing `QRunnable`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过子类化`QRunnable`来启动它：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first thing we do is create a `QMutex` object. In multithreading terminology,
    a **mutex** is an object shared between threads that can be locked or unlocked.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`QMutex`对象。在多线程术语中，**互斥锁**是一个在线程之间共享的可以被锁定或解锁的对象。
- en: You can think of a mutex in the same way as the door of a single-user restroom
    facility; suppose that Bob attempts to enter the restroom and lock the door. If
    Alice is in the restroom already, then the door won't open, and Bob will have
    to wait patiently outside until Alice has unlocked the door and exited the restroom.
    Then, Bob will be able to enter and lock the door.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将互斥锁看作是单用户洗手间的门的方式；假设Bob试图进入洗手间并锁上门。如果Alice已经在洗手间里，那么门不会打开，Bob将不得不耐心地等待，直到Alice解锁门并离开洗手间。然后，Bob才能进入并锁上门。
- en: Likewise, when a thread attempts to lock a mutex that another thread has already
    locked, it has to wait until the first thread has finished and unlocked the mutex
    before it can acquire the lock.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当一个线程尝试锁定另一个线程已经锁定的互斥锁时，它必须等到第一个线程完成并解锁互斥锁，然后才能获取锁。
- en: In `HashRunner`, we're going to use our `file_lock` mutex to ensure that two
    threads don't attempt to write to the output file at the same time. Note that
    this object is created in the class definition so it will be shared by all instances
    of `HashRunner`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在`HashRunner`中，我们将使用我们的`file_lock`互斥锁来确保两个线程不会同时尝试写入输出文件。请注意，该对象是在类定义中创建的，因此它将被`HashRunner`的所有实例共享。
- en: 'Now, let''s create the `__init__()` method:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建`__init__()`方法：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The object will receive paths to the input file and output file and store them
    as instance variables. It also creates an instance of `QtCore.QCryptographicHash`.
    This object is able to calculate various cryptographic hashes of data, such as
    MD5, SHA-256, or Keccak-512\. A complete list of hashes supported by this class
    can be found at [https://doc.qt.io/qt-5/qcryptographichash.html](https://doc.qt.io/qt-5/qcryptographichash.html).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 该对象将接收输入文件和输出文件的路径，并将它们存储为实例变量。它还创建了一个`QtCore.QCryptographicHash`的实例。这个对象能够计算数据的各种加密哈希，比如MD5、SHA-256或Keccak-512。这个类支持的哈希的完整列表可以在[https://doc.qt.io/qt-5/qcryptographichash.html](https://doc.qt.io/qt-5/qcryptographichash.html)找到。
- en: Finally, we set the `autoDelete` property of the class to `True`. This property
    of `QRunnable` will cause the object to be deleted whenever the `run()` method
    returns, saving us memory and resources.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将类的`autoDelete`属性设置为`True`。`QRunnable`的这个属性将导致对象在`run()`方法返回时被删除，节省我们的内存和资源。
- en: 'The actual work done by the runner is defined in the `run()` method:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 运行器执行的实际工作在`run()`方法中定义：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Our function starts by printing a message to the console and resetting the `QCryptographicHash`
    object, clearing out any data that might be in it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数首先通过打印一条消息到控制台并重置`QCryptographicHash`对象来开始，清除其中可能存在的任何数据。
- en: We then read the binary contents of our file into the hash object using the `addData()`
    method. The hash value can be calculated and retrieved as a `QByteArray` object
    from the hash object using the `result()` method. We then convert the byte array
    into a hexadecimal string using the `toHex()` method and then into a Python Unicode
    string by way of a `bytes` object.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`addData()`方法将文件的二进制内容读入哈希对象中。可以使用`result()`方法从哈希对象中计算和检索哈希值作为`QByteArray`对象。然后，我们使用`toHex()`方法将字节数组转换为十六进制字符串，然后通过`bytes`对象将其转换为Python
    Unicode字符串。
- en: Now all that's left is to write this hash string to the output file. This is
    where our mutex object comes in.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将这个哈希字符串写入输出文件。这就是我们的互斥锁对象发挥作用的地方。
- en: 'Traditionally, the way to use the mutex is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，使用互斥锁的方式如下：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We call the mutex's `lock()` method inside a `try` block and then perform our
    file operation. Inside the `finally` block, we call the `unlock` method. The reason
    this is done inside the `try` and `finally` blocks is so that the mutex is sure
    to be released even if something goes wrong with the `file` method.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`try`块内调用互斥锁的`lock()`方法，然后执行我们的文件操作。在`finally`块内，我们调用`unlock`方法。之所以在`try`和`finally`块内执行这些操作，是为了确保即使`file`方法出现问题，互斥锁也一定会被释放。
- en: In Python, however, whenever we have an operation like this that has initialization
    and cleanup code, it is best to use a **context manager** object in conjunction
    with the `with` keyword. PyQt provides us with such an object: `QMutexLocker`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Python中，每当我们有像这样具有初始化和清理代码的操作时，最好使用**上下文管理器**对象与`with`关键字结合使用。PyQt为我们提供了这样的对象：`QMutexLocker`。
- en: 'We can use this object as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像下面这样使用这个对象：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This method is much cleaner. By using the mutex context manager, we are assured
    that anything done inside the `with` block is done by only one thread at a time,
    and other threads will wait until the object finishes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法更加清晰。通过使用互斥上下文管理器，我们确保`with`块内的任何操作只由一个线程执行，其他线程将等待直到对象完成。
- en: Creating the thread pool
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建线程池
- en: The final piece of this application will be a `HashManager` object. The job
    of this object is to take the form output, locate the files to be hashed, and
    then start up a `HashRunner` object for each file.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的最后一部分将是一个`HashManager`对象。这个对象的工作是接收表单输出，找到要进行哈希处理的文件，然后为每个文件启动一个`HashRunner`对象。
- en: 'It will begin like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 它将开始像这样：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We've based the class on `QObject` so that we can define a `finished` signal.
    This signal will be emitted when all of the runners have completed their tasks.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们基于`QObject`类，这样我们就可以定义一个`finished`信号。当所有的运行者完成他们的任务时，这个信号将被发射。
- en: In the constructor, we're creating our `QThreadPool` object. Rather than creating
    a new object, however, we're using the `globalInstance()` static method to access
    the global thread pool object that already exists in every Qt application. You
    don't have to do this, but it is sufficient for most applications and removes
    some complexities involved in having multiple thread pools.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们创建了`QThreadPool`对象。但是，我们使用`globalInstance()`静态方法来访问每个Qt应用程序中已经存在的全局线程池对象，而不是创建一个新对象。你不必这样做，但对于大多数应用程序来说已经足够了，并且消除了涉及多个线程池的一些复杂性。
- en: 'The real work of this class will happen in a method we''ll call `do_hashing`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的真正工作将在一个我们将称之为`do_hashing`的方法中发生：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This method is designed to be hooked directly to the `HashForm.submitted` signal,
    so we've made it a slot with a matching signal. It begins by setting the thread
    pool's maximum number of threads (as defined by the `maxThreadCount` property)
    to the number received in the function call. Once this is set, we can queue up
    any number of `QRunnable` objects in the thread pool, but only `maxThreadCount`
    threads will actually be started up concurrently.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法被设计为直接连接到`HashForm.submitted`信号，所以我们将它作为一个槽与匹配的信号。它首先通过将线程池的最大线程数（由`maxThreadCount`属性定义）设置为函数调用中接收到的数字。一旦设置了这个值，我们可以在线程池中排队任意数量的`QRunnable`对象，但只有`maxThreadCount`个线程会同时启动。
- en: Next, we'll use the `QDir` object's `entryList()` method to iterate through
    the files in the directory and create a `HashRunner` object for each one. The
    runner object is then passed to the thread pool's `start()` method, which adds
    it to the pool's work queue.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`QDir`对象的`entryList()`方法来遍历目录中的文件，并为每个文件创建一个`HashRunner`对象。然后将运行对象传递给线程池的`start()`方法，将其添加到池的工作队列中。
- en: At this point, all of our runners are running in separate execution threads,
    but we'd like to emit a signal when they are done. Unfortunately, there is no
    signal built-in to `QThreadPool` to tell us this, but the `waitForDone()` method
    will continue to block until all of the threads are done.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们所有的运行者都在单独的执行线程中运行，但是当它们完成时，我们想发射一个信号。不幸的是，`QThreadPool`中没有内置的信号告诉我们这一点，但`waitForDone()`方法将继续阻塞，直到所有线程都完成。
- en: 'So, add the following code to `do_hashing()`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将以下代码添加到`do_hashing()`中：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Back in `MainWindow.__init__()`, let''s create our manager object and add our
    connections:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`MainWindow.__init__()`，让我们创建我们的管理器对象并添加我们的连接：
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After creating our `HashManager`, we move it to a separate thread using `moveToThread()`.
    This is because our `do_hashing()` method is going to block until all of the runners
    are completed, and we don't want the GUI to freeze up while waiting for that to
    happen. Had we left out the last two lines of `do_hashing()`, this wouldn't be
    necessary (but we'd also never know when it was done).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了我们的`HashManager`之后，我们使用`moveToThread()`将其移动到一个单独的线程中。这是因为我们的`do_hashing()`方法将阻塞，直到所有的运行者都完成，而我们不希望GUI在等待时冻结。如果我们省略了`do_hashing()`的最后两行，这是不必要的（但我们也永远不会知道何时完成）。
- en: 'In order to get feedback on what''s happening, let''s add two more connections:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得发生的反馈，让我们添加两个更多的连接：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The first connection will set the status when the form is submitted, indicating
    details about the job that is commencing; the second will notify us when the job
    is done.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个连接将在表单提交时设置状态，指示即将开始的工作的详细信息；第二个连接将在工作完成时通知我们。
- en: Testing the script
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试脚本
- en: Go ahead and launch this script and let's see how it works. Point your source
    directory at a folder full of large files, such as DVD images, archive files,
    or video files. Leave the threads' spin box at its default setting and click on Go.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 继续启动这个脚本，让我们看看它是如何工作的。将源目录指向一个充满大文件的文件夹，比如DVD镜像、存档文件或视频文件。将线程的旋钮保持在默认设置，并点击`Go`。
- en: Notice from the console output that the files are being hashed two at a time.
    As soon as one completes, another one starts until all of the files have been
    hashed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从控制台输出中可以看到，文件正在一次处理两个。一旦一个完成，另一个就开始，直到所有文件都被处理完。
- en: Try it again, but this time bump the threads up to four or five. Notice that
    more files are being processed at once. As you play with this value, you may also
    notice that there is a point of diminishing returns, especially as you approach
    the number of cores in your CPU. This is an important lesson about parallelization—sometimes,
    too much causes the performance to drop.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 再试一次，但这次将线程数增加到四或五。注意到更多的文件正在同时处理。当您调整这个值时，您可能也会注意到有一个收益递减的点，特别是当您接近CPU核心数时。这是关于并行化的一个重要教训——有时候，过多会导致性能下降。
- en: Threading and the Python GIL
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程和Python GIL
- en: No discussion of multithreading in Python is complete without addressing the
    **global interpreter lock** (**GIL**). The GIL is part of the memory management
    system in the official Python implementation (CPython). Essentially, it is like
    the mutex that we used in our `HashRunner` class—just as a `HashRunner` class
    has to acquire the `file_lock` mutex before it can write to the output, any thread
    in a Python application must acquire the GIL before it can execute any Python
    code. In other words, only one thread can execute Python code at a time.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，没有讨论多线程是完整的，而不涉及全局解释器锁（GIL）。GIL是官方Python实现（CPython）中内存管理系统的一部分。本质上，它就像我们在“HashRunner”类中使用的互斥锁一样——就像“HashRunner”类必须在写入输出之前获取“file_lock”互斥锁一样，Python应用程序中的任何线程在执行任何Python代码之前必须获取GIL。换句话说，一次只有一个线程可以执行Python代码。
- en: At first glance, this may appear to make multithreading in Python a futile pursuit;
    after all, what's the point of creating multiple threads if only one thread can
    execute Python code at a time?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这可能会使Python中的多线程看起来是徒劳的；毕竟，如果只有一个线程可以一次执行Python代码，那么创建多个线程有什么意义呢？
- en: 'The answer involves two exceptions to the GIL requirement:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 答案涉及GIL要求的两个例外情况：
- en: The long-running code can be **CPU-bound** or **I/O-bound**. CPU-bound means
    that most of the processing time is spent running heavy CPU operations, such as
    cryptographic hashing. I/O-bound operations are those that spend most of their
    time waiting on **i****nput/output** (**I/O**) calls, such as writing a large
    file to a disk or reading data from a network socket. When a thread makes an I/O
    call and begins waiting on a response, it releases the GIL. Therefore, if our
    worker code is mostly I/O-bound, we can benefit from multithreading because other
    code can run while we wait on the I/O operation to finish.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长时间运行的代码可以是CPU绑定或I/O绑定。CPU绑定意味着大部分处理时间都用于运行繁重的CPU操作，比如加密哈希。I/O绑定操作是指大部分时间都花在等待输入/输出调用上，比如将大文件写入磁盘或从网络套接字读取数据。当线程进行I/O调用并开始等待响应时，它会释放GIL。因此，如果我们的工作代码大部分是I/O绑定的，我们可以从多线程中受益，因为在等待I/O操作完成时，其他代码可以运行。
- en: CPU-bound code also releases the GIL if the code is running outside of Python.
    In other words, if we use a C or C++ function or object to perform a CPU-bound
    operation, then the GIL is released and only reacquired when the next Python operation
    is run.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果CPU绑定的代码在Python之外运行，则会释放GIL。换句话说，如果我们使用C或C++函数或对象执行CPU绑定操作，那么GIL会被释放，只有在下一个Python操作运行时才重新获取。
- en: 'This is why our `HashRunner` works; its two heaviest operations are as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们的“HashRunner”起作用的原因；它的两个最重的操作如下：
- en: Reading the large file from disk (which is an I/O-bound operation)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从磁盘读取大文件（这是一个I/O绑定操作）
- en: Hashing the file contents (which is handled inside of the `QCryptographicHash`
    object—a C++ object that operates outside of Python)
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对文件内容进行哈希处理（这是在“QCryptographicHash”对象内部处理的——这是一个在Python之外运行的C++对象）
- en: If we were to implement a hashing algorithm in pure Python instead, then we'd
    likely find that our multithreaded code actually ran slower than even a single-threaded
    implementation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要在纯Python中实现一个哈希算法，那么我们很可能会发现我们的多线程代码实际上比单线程实现还要慢。
- en: Ultimately, multithreading is not a magic bullet to speed up the code in Python;
    it must be carefully planned out to avoid problems with the GIL and the pitfalls
    that we discussed in the *Threading tips and caveats* section. With proper care,
    however, it can help us to create fast and responsive programs.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，多线程并不是Python中加速代码的魔法子弹；必须仔细规划，以避免与GIL和我们在“线程提示和注意事项”部分讨论的陷阱有关的问题。然而，经过适当的关怀，它可以帮助我们创建快速响应的程序。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to keep your application responsive when running
    a slow code. You learned how to use `QTimer` to defer actions to a later time,
    either as a one-time or repeating action. You learned how to push code to another
    thread using `QThread`, both by using `moveToThread()` and by subclassing `QThread`.
    Finally, you learned how to use `QThreadPool` and `QRunnable` to build highly
    concurrent data processing applications.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何在运行缓慢的代码时保持应用程序的响应性。您学会了如何使用“QTimer”将操作推迟到以后的时间，无论是作为一次性操作还是重复操作。您学会了如何使用“QThread”将代码推送到另一个线程，既可以使用“moveToThread()”也可以通过子类化“QThread”。最后，您学会了如何使用“QThreadPool”和“QRunnable”来构建高度并发的数据处理应用程序。
- en: In [Chapter 11](a9b58d41-a0ec-41f8-8f59-39ae2bc921ee.xhtml), *Creating Rich
    Text with QTextDocument,* we're going to take a look at working with rich text
    in PyQt. You'll learn how to define rich text using an HTML-like markup and how
    to inspect and manipulate documents using the `QDocument` API. You'll also learn
    how to take advantage of Qt's printing support to bring documents into the real
    world.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](a9b58d41-a0ec-41f8-8f59-39ae2bc921ee.xhtml)中，“使用QTextDocument创建丰富的文本”，我们将看看如何在PyQt中处理丰富的文本。您将学会如何使用类似HTML的标记定义丰富的文本，以及如何使用“QDocument”API检查和操作文档。您还将学会如何利用Qt的打印支持将文档带入现实世界。
- en: Questions
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try answering these questions to test your knowledge from this chapter:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试回答这些问题，以测试你从本章学到的知识：
- en: Create code to call the `self.every_ten_seconds()` method every 10 seconds.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建代码以每10秒调用“self.every_ten_seconds()”方法。
- en: The following code uses `QTimer` incorrectly. Can you fix it?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码错误地使用了“QTimer”。你能修复它吗？
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You've created the following word-counting `Worker` class and want to move it
    to another thread to prevent large documents from slowing the GUI. But it's not
    working—what do you need to change about this class?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已经创建了以下单词计数的“Worker”类，并希望将其移动到另一个线程以防止大型文档减慢GUI。但它没有起作用——你需要改变这个类的什么？
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The following code is blocking rather than running in a separate thread. Why
    is this the case?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码是阻塞的，而不是在单独的线程中运行。为什么会这样？
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Will this `Worker` class run correctly? If not, why?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个“Worker”类会正确运行吗？如果不会，为什么？
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The following code is a `run()` method from a `QRunnable` class designed for
    processing large data files output from scientific equipment. The files consist
    of millions of long rows of space-delimited numbers. Is this code likely to be
    slowed down by the Python GIL? Could you make it less likely that the GIL will
    interfere?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码是设计用于处理科学设备输出的大型数据文件的`QRunnable`类的`run()`方法。这些文件包含数百万行以空格分隔的长数字。这段代码可能会受到Python
    GIL的影响吗？您能否减少GIL的干扰？
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The following is a `run()` method from a `QRunnable` class in a multithreaded
    TCP Server application you're writing. All of the threads share a server socket
    instance accessed through `self.datastream`. This code is not thread-safe, however.
    What do you need to do to fix it?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是您正在编写的多线程TCP服务器应用程序中`QRunnable`类的`run()`方法。所有线程共享通过`self.datastream`访问的服务器套接字实例。然而，这段代码不是线程安全的。您需要做什么来修复它？
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Further reading
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For further information, please refer to the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请参考以下内容：
- en: A **semaphore** is similar to a mutex but allows for an arbitrary number of
    locks to be taken rather than just a single lock. You can read more about Qt's
    implementation, the `QSemaphore` class, at [https://doc.qt.io/qt-5/qsemaphore.html](https://doc.qt.io/qt-5/qsemaphore.html)
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号量类似于互斥锁，但允许获取任意数量的锁，而不仅仅是单个锁。您可以在[https://doc.qt.io/qt-5/qsemaphore.html](https://doc.qt.io/qt-5/qsemaphore.html)了解更多关于Qt实现的`QSemaphore`类的信息。
- en: David Beazley's talk from PyCon 2010, available at [https://www.youtube.com/watch?v=Obt-vMVdM8s](https://www.youtube.com/watch?v=Obt-vMVdM8s),
    provides deeper insight into the operation of the Python GIL
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: David Beazley在PyCon 2010的演讲提供了更深入的了解Python GIL的运作，可在[https://www.youtube.com/watch?v=Obt-vMVdM8s](https://www.youtube.com/watch?v=Obt-vMVdM8s)上观看。
