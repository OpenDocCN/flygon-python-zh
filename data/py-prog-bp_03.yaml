- en: Casting Votes on Twitter
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Twitter上投票
- en: In the previous chapter, we implemented a Terminal application that serves as
    a remote control for the popular music service Spotify. In this application, we
    could search for artists, browse albums, and browse the tracks in each album.
    Lastly, we could even request the track to be played on the user's active device.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们实现了一个终端应用程序，作为流行音乐服务Spotify的远程控制器。在这个应用程序中，我们可以搜索艺术家，浏览专辑，以及浏览每张专辑中的曲目。最后，我们甚至可以请求在用户的活动设备上播放曲目。
- en: This time, we are going to develop an application that will integrate with Twitter,
    making use of its REST API. Twitter is a social network that has been around since
    2006 and there are over 300 million active users. Private users, companies, artists,
    soccer clubs, you can find almost everything on Twitter. But what makes Twitter
    so popular, I believe, is its simplicity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们将开发一个将与Twitter集成的应用程序，利用其REST API。 Twitter是一个自2006年以来就存在的社交网络，拥有超过3亿活跃用户。私人用户、公司、艺术家、足球俱乐部，你几乎可以在Twitter上找到任何东西。但我认为让Twitter如此受欢迎的是它的简单性。
- en: Unlike blog posts, Twitter posts or *tweets* have to be short and get right
    to the point, and it doesn't require too much time to prepare something to post.
    Another point that makes Twitter so popular is the fact that the service is a
    great news source. If you want to keep updated with what's going on in the world,
    politics, sports, technology, you name it, Twitter is the place to be.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与博客文章不同，Twitter的帖子或*推文*必须简短并直奔主题，而且准备发布的时间也不需要太长。另一个使Twitter如此受欢迎的原因是该服务是一个很好的新闻来源。如果你想要了解世界上正在发生的事情，政治、体育、科技等等，Twitter就是你要去的地方。
- en: Apart from all that, Twitter has a fairly decent API for us developers and,
    to take advantage of that, we are going to develop an application where users
    can cast votes using hashtags. In our application, we are going to configure which
    hashtags we are going to monitor and it will automatically, from time to time,
    fetch the latest tweets matching that hashtag, count them, and display them in
    a user interface.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Twitter对于开发者来说有一个相当不错的API，为了利用这一点，我们将开发一个应用程序，用户可以使用标签投票。在我们的应用程序中，我们将配置要监视的标签，并且它将自动定期获取与该标签匹配的最新推文，对它们进行计数，并在用户界面中显示它们。
- en: 'In this chapter, you will learn how to do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: Create a tweet application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个推文应用程序
- en: Use the `OAuth` library and implement a three-legged authentication flow
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`OAuth`库并实现三步验证流程
- en: Search for the latest tweets using the Twitter API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Twitter API搜索最新的推文
- en: Build a simple user interface using `Tkinter`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Tkinter`构建一个简单的用户界面
- en: Learn the basics of multiprocessing and reactive programming
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习多进程和响应式编程的基础知识
- en: Setting up the environment
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: 'The first thing we have to do is, as usual, set up our development environment
    and the first step is to create a virtual environment for our application. Our
    application will be called `twittervotes`, so let''s go ahead and create a virtual
    environment called `twittervotes`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要做的事情通常是设置我们的开发环境，第一步是为我们的应用程序创建一个虚拟环境。我们的应用程序将被称为`twittervotes`，所以让我们继续创建一个名为`twittervotes`的虚拟环境：
- en: '![](assets/9cf0dbeb-8a22-4726-930f-c0869b9b0dbf.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9cf0dbeb-8a22-4726-930f-c0869b9b0dbf.png)'
- en: 'When the `virtualenv` environment has been created, you can activate it with
    the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当`virtualenv`环境创建好后，您可以使用以下命令激活它：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Great! Now let''s set up the project''s directory structure. It should look
    like the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在让我们设置项目的目录结构。它应该如下所示：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s dive into the structure a bit:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一下结构：
- en: '| `twittervotes` | The application''s root directory. Here, we will create
    the application''s entry point as well as a small helper application to perform
    the Twitter authentication. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `twittervotes` | 应用程序的根目录。在这里，我们将创建应用程序的入口点，以及一个小的辅助应用程序来执行Twitter身份验证。 |'
- en: '| `twittervotes/core` | This will contain all the core functionality of our
    project. It will contain the code to authenticate, read config files, send requests
    to the Twitter API, and so on. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `twittervotes/core` | 这将包含我们项目的所有核心功能。它将包含身份验证代码、读取配置文件、向Twitter API发送请求等等。
    |'
- en: '| `twittervotes/core/models` | Directory in which to keep the application''s
    data models. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `twittervotes/core/models` | 用于保存应用程序数据模型的目录。 |'
- en: '| `twittervotes/core/twitter` | In the `twitter` directory, we are going to
    keep `helper` functions to interact with the Twitter API. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `twittervotes/core/twitter` | 在`twitter`目录中，我们将保留与Twitter API交互的`helper`函数。
    |'
- en: '| `twittervotes/templates` | Here, we are going to keep all the HTML templates
    that will be used by our application. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `twittervotes/templates` | 在这里，我们将保存我们应用程序将使用的所有HTML模板。 |'
- en: 'Next, it is time to add our project''s dependencies. Go ahead and create a
    file called `requirements.txt` in the `twittervotes` directory with the following
    content:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是时候添加我们项目的依赖关系了。继续在`twittervotes`目录中创建一个名为`requirements.txt`的文件，内容如下：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following table explains what the preceding dependencies mean:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了前面的依赖关系的含义：
- en: '| `Flask` | We are going to use Flask here to create a simple web application
    to perform the authentication with Twitter. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `Flask` | 我们将在这里使用Flask创建一个简单的Web应用程序，以便与Twitter进行身份验证。 |'
- en: '| `oauth2` | This is a great package that will abstract a lot of the complexity
    when performing `OAuth` authentication. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `oauth2` | 这是一个很棒的包，它将在执行`OAuth`身份验证时抽象出很多复杂性。 |'
- en: '| `PyYAML` | We are going to use this package to create and read config files
    in YAML format. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `PyYAML` | 我们将使用这个包来创建和读取YAML格式的配置文件。 |'
- en: '| `Requests` | Allow us to access the Twitter API over HTTP. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `Requests` | 允许我们通过HTTP访问Twitter API。 |'
- en: '| `Rx` | Finally, we are going to use Reactive Extensions for Python so we
    can reactively update our UI soon as a new tweet count arrives. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `Rx` | 最后，我们将使用Python的Reactive Extensions，以便在新的推文计数到达时，可以对我们的UI进行响应式更新。 |'
- en: 'When the file has been created, run the command `pip install -r requirements.txt`,
    and you should see an output similar to the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 文件创建后，运行命令`pip install -r requirements.txt`，您应该会看到类似以下的输出：
- en: '![](assets/40df8c49-f4b0-4320-bef0-833905edb509.png)If you run the command
    `pip freeze`, you will get a list of dependencies in pip format and you will notice
    that the output lists more dependencies that we actually added to the `requirements`
    file. The reason for that is that the packages that our project requires also
    have dependencies and they will also be installed. So do not worry if you have
    more packages installed than you specified in your `requirements` file.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/40df8c49-f4b0-4320-bef0-833905edb509.png)如果运行命令`pip freeze`，您将获得以pip格式列出的依赖项列表，并且您将注意到输出列出了比我们实际添加到`requirements`文件中的依赖项更多的依赖项。
    原因是我们的项目需要的软件包也有依赖项，并且它们也将被安装。 因此，如果您安装的软件包比您在`requirements`文件中指定的要多，请不要担心。'
- en: Now that our environment is set up, we can start creating our Twitter application.
    As usual, before you start coding, make sure that you have your code under a source
    control system such as Git; there are plenty of online services that will host
    your repositories for free.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的环境已经设置好，我们可以开始创建我们的Twitter应用程序。 通常，在开始编码之前，请确保您的代码已经在Git等源代码控制系统下； 有很多在线服务可以免费托管您的存储库。
- en: In this way, you can roll back different versions of your projects and you don't
    have the risk of losing your work if you have problems with your computers. With
    that said, let's create our Twitter application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，您可以回滚项目的不同版本，如果您的计算机出现问题，也不会丢失工作。 话虽如此，让我们创建我们的Twitter应用程序。
- en: Creating a Twitter application
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Twitter应用程序
- en: In this section, we are going to create our first Twitter application so we
    can consume the Twitter REST API. You will need to create an account if you don't
    already have one. If you are not using Twitter, I would strongly recommend it;
    it is a great way of getting up-to-date with all the news and what is going on
    in the development world, and it is a great way of making new friends in the Python
    community.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建我们的第一个Twitter应用程序，以便可以使用Twitter REST API。 如果您还没有帐户，则需要创建一个帐户。 如果您不使用Twitter，我强烈建议您使用；
    这是一个了解所有新闻和开发世界正在发生的事情的好方法，也是在Python社区中结交新朋友的好方法。
- en: 'After you create an account, head over to [https://apps.twitter.com/](https://apps.twitter.com/),
    sign in with your login credentials, and you will land on a page where you can
    see a list of apps that you have already created (the first time, you will probably
    have an empty list of apps), and on the same page you will have the possibility
    of creating new apps. Click on the Create new app button in the top-right corner
    and it will open up the following page:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建帐户后，转到[https://apps.twitter.com/](https://apps.twitter.com/)，使用您的登录凭据登录，您将进入一个页面，您可以在该页面上看到您已经创建的应用程序的列表（第一次，您可能会有一个空的应用程序列表），并且在同一页上，您将有可能创建新的应用程序。
    单击右上角的“创建新应用程序”按钮，它将打开以下页面：
- en: '![](assets/4599e1a6-0846-42c4-9920-11341efa9cec.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4599e1a6-0846-42c4-9920-11341efa9cec.png)'
- en: 'In this form, there are three fields that are required—name, description, and
    website:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在此表单中，有三个必填字段-名称，描述和网站：
- en: '**Name**: This is the name of your application; it is also the name that will
    be presented to the users of your application when performing authorization. The
    name doesn''t need to follow any specific naming convention, you can have anything
    you want.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：这是您的应用程序的名称； 这也是在执行授权时将呈现给您的应用程序用户的名称。 名称不需要遵循任何特定的命名约定，您可以随意命名。'
- en: '**Description**: As the name suggests, this is the description of your application.
    This field will also be presented to the users of your application, so it is good
    to have nice text describing your application. In this case, here we don''t need
    much text. Let''s add `Application to cast votes on Twitter using hashtags`**.**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：顾名思义，这是您的应用程序的描述。 这个字段也将呈现给您的应用程序用户，因此最好有描述您的应用程序的好文本。 在这种情况下，我们不需要太多文本。
    让我们添加`用于在Twitter上使用标签投票的应用程序`。'
- en: '**Website**: Specify your application''s website; it is also going to be presented
    to the users during authorization and it is the site where your users can go to
    download or get more information about your application. Since we are in the development
    phase, we can just add a placeholder such as [http://www.example.com](http://www.example.com)*.*'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网站**：指定您的应用程序的网站； 它也将在授权期间呈现给用户，并且是用户可以下载或获取有关您的应用程序的更多信息的网站。 由于我们处于开发阶段，我们可以添加一个占位符，例如[http://www.example.com](http://www.example.com)。'
- en: '**Callback URL**: This works the same way as the callback URL in the previous
    application (the Spotify Terminal app) in the previous chapter. It is a URL that
    Twitter will call to send the authorization code. It is not a required field but
    we are going to need it, so let''s go ahead and add ;`http://localhost:3000/callback`.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回调URL**：这与上一章中的Spotify终端应用程序中的回调URL的工作方式相同。 这是Twitter将调用以发送授权代码的URL。 这不是必需的字段，但我们需要它，所以让我们继续添加；`http://localhost:3000/callback`。'
- en: After filling in all the fields, you just need to check the Twitter Developer
    Agreement and click the Create your Twitter application button.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 填写所有字段后，您只需要勾选Twitter开发者协议并单击“创建Twitter应用程序”按钮。
- en: 'If everything went well, you will be directed to another page where you can
    see more details of your newly created application. Just below the name of the
    application, you will see an area with tabs that shows settings and different
    pieces of information about the application:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您将被引导到另一个页面，您可以在该页面上看到您新创建的应用程序的更多详细信息。 在应用程序名称下方，您将看到一个带有选项卡的区域，显示有关应用程序的设置和不同信息的选项卡：
- en: '![](assets/469924a4-645a-46fc-837d-bd1517bc4733.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/469924a4-645a-46fc-837d-bd1517bc4733.png)'
- en: On the first tab, Details, we want to copy all the URLs that we are going to
    use to perform the authentication. Scroll down to Application settings, and copy
    Request token URL, *Authorize URL*, and *Access token URL:*
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个选项卡“详细信息”中，我们要复制所有我们将用于执行身份验证的URL。滚动到“应用程序设置”，并复制“请求令牌URL”、“授权URL”和“访问令牌URL”：
- en: '![](assets/e709f442-79ec-4474-8cfc-d18c21a0b195.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e709f442-79ec-4474-8cfc-d18c21a0b195.png)'
- en: Great! Now let's head over to the Keys and Access Tokens tab and copy Consumer
    Key and Consumer Secret*:*
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在让我们转到“密钥和访问令牌”选项卡，复制“消费者密钥”和“消费者密钥”*：*
- en: '![](assets/30c5220e-277f-4cc8-b2b4-db7c7bb37429.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/30c5220e-277f-4cc8-b2b4-db7c7bb37429.png)'
- en: Now that we have copied all the necessary information, we can create a configuration
    file that is going to be used by our application. It is always good practice to
    keep all this in a configuration file so we don't need to hardcode those URLs
    in our code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经复制了所有必要的信息，我们可以创建一个将被我们的应用程序使用的配置文件。将所有这些内容保存在配置文件中是一种良好的做法，这样我们就不需要在代码中硬编码这些URL。
- en: We are going to add the *consumer key* and *consumer secret* to a configuration
    file in our project; as the name suggests, this key is *secret* so if you are
    planning to create a repository for your code in a service such as GitHub, make
    sure to add the configuration file to the `.gitignore` file so the keys are not
    pushed to the cloud repository. Never share these keys with anyone; if you suspect
    that someone has the keys, you can generate new keys for your application on the
    Twitter app's website.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将*消费者密钥*和*消费者密钥*添加到我们项目中的配置文件；正如名称所示，这个密钥是*秘密*的，所以如果您计划在GitHub等服务中为您的代码创建存储库，请确保将配置文件添加到`.gitignore`文件中，以便密钥不被推送到云存储库。永远不要与任何人分享这些密钥；如果您怀疑有人拥有这些密钥，您可以在Twitter应用的网站上为您的应用生成新的密钥。
- en: Adding the configuration file
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加配置文件
- en: In this section, we are going to create the configuration file for our application;
    the configuration file will be in YAML format. If you would like to know more
    about YAML, you can check the site [http://yaml.org/](http://yaml.org/), where
    you will find examples, the specification, and also a list of libraries in different
    programming languages that can be used to manipulate YAML files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将为我们的应用程序创建配置文件；配置文件将采用YAML格式。如果您想了解有关YAML的更多信息，可以查看网站[http://yaml.org/](http://yaml.org/)，在那里您将找到示例、规范，以及可以用于操作YAML文件的不同编程语言的库列表。
- en: For our application, we are going to use PyYAML, which will allow us to read
    and write YAML files in a very simple manner. Our configuration file is quite
    simple so we will not need to use any advanced features of the library, we just
    want to read the content and write, and the data that we are going to add is quite
    flat; we will not have any nested objects or lists of any kind.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将使用PyYAML，它将允许我们以非常简单的方式读取和写入YAML文件。我们的配置文件非常简单，所以我们不需要使用库的任何高级功能，我们只想读取内容并写入，我们要添加的数据非常平坦；我们不会有任何嵌套对象或任何类型的列表。
- en: 'Let''s get the information that we obtained from Twitter when we created our
    app and add it to the configuration file. Create a file called `config.yaml` in
    the application''s `twittervotes` directory with the following content:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取我们从Twitter获取的信息，并将其添加到配置文件中。在应用程序的`twittervotes`目录中创建一个名为`config.yaml`的文件，内容如下：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Great! Now we are going to create the first Python code in our project. If
    you have followed the previous chapters, the functions to read the configuration
    file will be familiar to you. The idea is simple: we are going to read the configuration
    file, parse it, and create a model that we can easily use to access the data we
    added to the config. First, we need to create the configuration model.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们将在我们的项目中创建第一个Python代码。如果您已经阅读了前几章，那么读取配置文件的函数对您来说将是熟悉的。这个想法很简单：我们将读取配置文件，解析它，并创建一个我们可以轻松使用来访问我们添加到配置中的数据的模型。首先，我们需要创建配置模型。
- en: 'Create a file called `models.py` in `twittervotes/core/models/` with the following
    content:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`twittervotes/core/models/`中创建一个名为`models.py`的文件，内容如下：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There was a more extensive introduction to `namedtuple` in the previous chapter,
    so I will not go into as much  detail about it again; if you haven't been going
    through the second chapter, it will suffice to know that `namedtuple` is a kind
    of class and this code will define a `namedtuple` called `Config` with the fields
    specified in the array in the second argument.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中对`namedtuple`进行了更详细的介绍，所以我不会再详细介绍它；如果您还没有阅读第二章，只需知道`namedtuple`是一种类，这段代码将使用第二个参数中指定的字段定义一个名为`Config`的`namedtuple`。
- en: 'Great, now let''s create another file called `__init__.py` in `twittervotes/core/models` and
    import the `namedtuple` that we just created:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在让我们在`twittervotes/core/models`中创建另一个名为`__init__.py`的文件，并导入我们刚刚创建的`namedtuple`：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now it is time to create the functions that will do the actual work of reading
    the YAML file and returning it to us. Create a file called `config.py` in `twittervotes/core/`. Let''s get
    started by adding the import statements:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建读取YAML文件并将其返回给我们的函数了。在`twittervotes/core/`中创建一个名为`config.py`的文件。让我们开始添加导入语句：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are going to use the `os` package to easily obtain the user's current directory
    and manipulate paths. We also import PyYAML so we can read the YAML files and,
    lastly, from the `models` module, we import the `Config` model that we just created.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`os`包轻松获取用户当前目录并操作路径。我们还导入PyYAML，以便读取YAML文件，最后，从`models`模块中导入我们刚刚创建的`Config`模型。
- en: Then we define two functions, starting with the `_read_yaml_file` function.
    This function gets two arguments—the `filename`, which is the name of the config
    file that we want to read, and also `cls`, which can be a `class` or `namedtuple`
    that we will use to store the configuration data.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义两个函数，首先是`_read_yaml_file`函数。这个函数有两个参数——`filename`，是我们要读取的配置文件的名称，还有`cls`，可以是我们用来存储配置数据的`class`或`namedtuple`。
- en: 'In this case, we are going to pass the `Config`—`namedtuple`, which has the
    same properties as the YAML configuration file that we are going to read:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将传递`Config`——`namedtuple`，它具有我们将要读取的YAML配置文件相同的属性：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, we use the `os.path.abspath` function, passing as an argument the special
    variable `__file__`. When a module is loaded, the variable `__file__` will be
    set to the same name as the module. That will allow us to easily find where to
    load the configuration file. So the following snippet will return the path of
    the core module
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`os.path.abspath`函数，将特殊变量`__file__`作为参数传递。当一个模块被加载时，变量`__file__`将被设置为与模块同名。这将使我们能够轻松找到加载配置文件的位置。因此，以下代码段将返回核心模块的路径。
- en: '`/projects/twittervotes/core`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`/projects/twittervotes/core`：'
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We know that the configuration file will live in `/projects/twittervotes/`
    so we need to join `..` to the path to go up one level in the directory structure
    so we can read the file. That''s why we build the complete configuration file''s
    path as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道配置文件将位于`/projects/twittervotes/`，所以我们需要将`..`与路径连接起来，以在目录结构中向上移动一级，以便读取文件。这就是我们构建完整配置文件路径的原因。
- en: '`file_path = os.path.join(core_dir, ''..'', filename)`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`file_path = os.path.join(core_dir, ''..'', filename)`'
- en: That will give us the flexibility of running this code from any location in
    our system.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够从系统中的任何位置运行此代码。
- en: We open the file in the reading mode using UTF-8 encoding and pass it to the
    `yaml.load` function, assigning the results to the `config` variable. The `config`
    variable will be a dictionary with all the data we have in the `config` file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以UTF-8编码以读取模式打开文件，并将其传递给`yaml.load`函数，将结果赋给`config`变量。`config`变量将是一个包含配置文件中所有数据的字典。
- en: 'The last line of this function is the interesting part: if you recall, the
    `cls` argument was a `class` or a `namedtuple` so we spread the values of the
    config dictionary as an argument. Here, we are going to use the `Config`—`namedtuple`
    so `cls(**config)` is the same as `Config`, `(**config)` and passing the arguments
    with `**` will be the same as passing all the arguments one by one:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的最后一行是有趣的部分：如果你还记得，`cls`参数是一个`class`或者`namedtuple`，所以我们将配置字典的值作为参数展开。在这里，我们将使用`Config`——`namedtuple`，所以`cls(**config)`等同于`Config`，`(**config)`，使用`**`传递参数将等同于逐个传递所有参数：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we are going to add the second function we are going to need, the `read_config` function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要添加我们需要的第二个函数，`read_config`函数：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function is pretty straightforward; it just makes use of the `_read_yaml_file` function
    that we just created, passing the `config.yaml` file in the first argument and
    also the `Config`, `namedtuple` in the second argument.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单；它只是利用我们刚刚创建的`_read_yaml_file`函数，将`config.yaml`文件作为第一个参数传递，并将`Config`、`namedtuple`作为第二个参数传递。
- en: We catch the `IOError` exception that will be thrown if the file doesn't exist
    in the application's  directory; in that case, we throw a help message showing
    the users of your application how the config file should be structured.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们捕获`IOError`异常，如果文件在应用程序目录中不存在，则会抛出该异常；在这种情况下，我们会抛出一个帮助消息，向您的应用程序用户显示配置文件应该如何结构化。
- en: 'The final touch is to import it into the `__init__.py` in the `twittervotes/core` directory:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将其导入到`twittervotes/core`目录中的`__init__.py`中：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s try this out in the Python REPL:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python REPL中尝试一下：
- en: '![](assets/614acd5c-35c0-47b3-93aa-ad1c894123e2.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/614acd5c-35c0-47b3-93aa-ad1c894123e2.png)'
- en: Great, it worked just like we wanted! In the next section, we can start creating
    the code that will perform the authentication.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，它的工作原理就像我们想要的那样！在下一节中，我们可以开始创建执行认证的代码。
- en: Performing authentication
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行认证
- en: In this section, we are going to create the program that will perform authentication
    for us so we can use the Twitter API. We are going to do that using a simple Flask
    application that will expose two routes. The first is the root `/`, which will
    just load and render a simple HTML template with a button that will redirect us
    to the Twitter authentication dialog.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个程序，该程序将为我们执行认证，以便我们可以使用Twitter API。我们将使用一个简单的Flask应用程序来实现这一点，该应用程序将公开两个路由。第一个是根路径`/`，它将加载和呈现一个简单的HTML模板，其中包含一个按钮，该按钮将重定向我们到Twitter认证对话框。
- en: The second route that we are going to create is `/callback`. Remember when we
    specified the callback URL in the Twitter app configuration? This is the route
    that will be called after we authorize the app. It will return an authorization
    token that will be used to perform requests to the Twitter API. So let's get right
    into it!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要创建的第二个路由是`/callback`。还记得我们在Twitter应用程序配置中指定的回调URL吗？这是在我们授权应用程序后将被调用的路由。它将返回一个授权令牌，该令牌将用于向Twitter
    API发出请求。所以让我们开始吧！
- en: 'Before we start implementing the Flask app, we need to add another model to
    our model''s module. This model will represent the request authorization data.
    Open the `models.py` file in `twittervotes/core/models` and add the following
    code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现Flask应用程序之前，我们需要在我们的模型模块中添加另一个模型。这个模型将代表请求授权数据。打开`twittervotes/core/models`中的`models.py`文件，并添加以下代码：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will create a `namedtuple` called `RequestToken` with the fields `oauth_token`,
    `oauth_token_secret`, and `outh_callback_confirmed`; this data will be necessary
    for us to perform the second step of the authentication.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`RequestToken`的`namedtuple`，包含字段`oauth_token`、`oauth_token_secret`和`outh_callback_confirmed`；这些数据对我们执行认证的第二步是必要的。
- en: 'Lastly, open the `__init__.py` file in the `twittervotes/core/models` directory
    and let''s import the `RequestToken` `namedtuple` that we just created, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`twittervotes/core/models`目录中打开`__init__.py`文件，并导入我们刚刚创建的`RequestToken`
    `namedtuple`，如下所示：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we have the model in place, let's start creating the Flask application.
    Let's add a very simple template to show a button that will start the authentication
    process.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了模型，让我们开始创建Flask应用程序。让我们添加一个非常简单的模板，显示一个按钮，该按钮将启动认证过程。
- en: 'Create a new directory in the `twittervotes` directory called `templates` and
    create a file called `index.html` with the following content:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`twittervotes`目录中创建一个名为`templates`的新目录，并创建一个名为`index.html`的文件，内容如下：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating the Flask application
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Flask应用程序
- en: 'Perfect, now let''s add another file called `twitter_auth.py` in the `twittervotes`
    directory. We are going to create three functions in it but, first, let''s add
    some imports:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 完美，现在让我们在`twittervotes`目录中添加一个名为`twitter_auth.py`的文件。我们将在其中创建三个函数，但首先让我们添加一些导入：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, we import the `parser_qls` from the `urllib.parse` module to parse the
    returned query string, and the `yaml` module so we can read and write `YAML` configuration
    files. Then we import everything we need to build our Flask application. The last
    third-party module that we are going to import here is the `oauth2` module, which
    will help us to perform the `OAuth` authentication.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`urllib.parse`模块中导入`parser_qls`来解析返回的查询字符串，以及`yaml`模块，这样我们就可以读取和写入`YAML`配置文件。然后我们导入构建Flask应用程序所需的一切。我们在这里要导入的最后一个第三方模块是`oauth2`模块，它将帮助我们执行`OAuth`认证。
- en: Lastly, we import our function `read_config` and the `RequestToken` `namedtuple`
    that we just created.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们导入我们的函数`read_config`和我们刚刚创建的`RequestToken` `namedtuple`。
- en: 'Here, we create our Flask app and a few global variables that will hold values
    for the client, consumer, and the `RequestToken` instance:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了我们的Flask应用程序和一些全局变量，这些变量将保存客户端、消费者和`RequestToken`实例的值：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first function that we are going to create is a function called `get_req_token`
    with the following content:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要创建的第一个函数是一个名为`get_req_token`的函数，内容如下：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function gets as argument an instance to the configuration and the global
    statements say to the interpreter that the consumer, client, and `req_token` used
    in the function will be referencing the global variables.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的参数是一个配置实例，全局语句告诉解释器函数中使用的`req_token`将引用全局变量。
- en: We create a consumer object using the consumer key and the consumer secret that
    we obtained when the Twitter app was created. When the consumer is created, we
    can pass it to the client function to create the client, then we call the function
    request, which, as the name suggests, will perform the request to Twitter, passing
    the request token URL.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用在创建Twitter应用程序时获得的消费者密钥和消费者密钥创建一个消费者对象。当消费者创建后，我们可以将其传递给客户端函数来创建客户端，然后我们调用请求函数，这个函数将执行请求到Twitter，传递请求令牌URL。
- en: When the request is complete, the response and the content will be stored in
    the variables `resp` and `content`. Right after that, we test whether the response
    status is not `200` or `HTTP.OK`; in that case, we raise an exception, otherwise
    we parse the query string to get the values that have been sent back to us and
    create a `RequestToken` instance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求完成时，响应和内容将被存储在变量`resp`和`content`中。紧接着，我们测试响应状态是否不是`200`或`HTTP.OK`；在这种情况下，我们会引发一个异常，否则我们解析查询字符串以获取发送回来的值，并创建一个`RequestToken`实例。
- en: Creating the application routes
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序路由
- en: 'Now we can start creating the routes. First, we are going to add the root route:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始创建路由了。首先，我们要添加根路由：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We read the configuration file and pass it the `get_oauth_token` function. This
    function will populate the global variable `req_token` with the `oauth_token`
    value; we need this token to start the authorization process. Then we build the
    authorization URL with the values of `authorize_url` obtained from the configuration
    file and the `OAuth` request token.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取配置文件并将其传递给`get_oauth_token`函数。这个函数将用`oauth_token`的值填充全局变量`req_token`；我们需要这个令牌来开始授权过程。然后我们使用从配置文件中获取的`authorize_url`值和`OAuth`请求令牌构建授权URL。
- en: Lastly, we use the `render_template` to render the `index.html` template that
    we created and we also pass to the function a second argument, which is the context.
    In this case, we are creating an item called `link` with the value set to `url`.
    If you remember the `index.html` template, there is an `"{{url}}"` placeholder.
    This placeholder will be replaced by the value that we assigned to `link` in the
    `render_template` function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`render_template`来渲染我们创建的`index.html`模板，并且还向函数传递了第二个参数，即上下文。在这种情况下，我们创建了一个名为`link`的项目，其值设置为`url`。如果你还记得`index.html`模板，那里有一个`"{{url}}"`的占位符。这个占位符将被我们在`render_template`函数中分配给`link`的值所替换。
- en: By default, Flask uses Jinja2 as a template engine but that can be changed to
    the engine of your preference; we are not going into the details of how to do
    this in this book because it is beyond our scope.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Flask使用Jinja2作为模板引擎，但可以更改为您喜欢的引擎；我们不会在本书中详细介绍如何做到这一点，因为这超出了我们的范围。
- en: 'The last route that we are going to add is the `/callback` route and that will
    be the route that will be called by Twitter after the authorization:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要添加的最后一个路由是`/callback`路由，这将是Twitter在授权后调用的路由：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The implementation of the callback route starts off by using global statements
    so we can use the global variables `req_token` and `consumer`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 回调路由的实现从使用全局语句开始，这样我们就可以使用全局变量`req_token`和`consumer`。
- en: Now we get to the interesting part. After the authorization, Twitter will return
    an `outh_verifier` so we get it from the request arguments and set it to the variable
    `oauth_verifier`; we create a `Token` instance using the `oauth_token` and `oauth_token_secret`
    that we obtained in the first part of our authorization process.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了有趣的部分。在授权后，Twitter会返回一个`outh_verifier`，所以我们从请求参数中获取它并将其设置为变量`oauth_verifier`；我们使用在授权过程的第一部分中获得的`oauth_token`和`oauth_token_secret`创建一个`Token`实例。
- en: And we set the `oauth_verifier` in the `Token` object and finally create a new
    client that we are going to use to perform a new request with.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在`Token`对象中设置`oauth_verifier`，最后创建一个新的客户端，我们将使用它来执行一个新的请求。
- en: We decode the data received from the request and add it to the access token
    variable and, to wrap things up, we write the content of `access_token` to a file
    `.twitterauth` in the `twittervotes` directory. This file is also in YAML format
    so we are going to add another model and one more function in the `config.py`
    file to read the new settings.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解码从请求接收到的数据，并将其添加到访问令牌变量中，最后，我们将`access_token`的内容写入`twittervotes`目录中的`.twitterauth`文件。这个文件也是YAML格式，所以我们将在`config.py`文件中添加另一个模型和一个新的函数来读取新的设置。
- en: Note that this process needs to be done just once. That is the reason that we
    store the data in the `.twitterauth` file. Further requests need only to use the
    data contained in this file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个过程只需要做一次。这就是我们将数据存储在`.twitterauth`文件中的原因。进一步的请求只需要使用这个文件中包含的数据。
- en: 'If you check the contents of the `.twitterauth` file, you should have something
    similar to the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查`.twitterauth`文件的内容，您应该有类似以下的内容：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To finish the Flask application, we need to add the following code at the end
    of the file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成Flask应用程序，我们需要在文件末尾添加以下代码：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s add a new model to the `models.py` file in `twittervotes/core/models/` with
    the following content:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`twittervotes/core/models/`中的`models.py`文件中添加一个新的模型，内容如下：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Great! One more thing—we need to import the new model in the `__init__.py`
    file in the `twittervotes/core/models` directory:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！还有一件事——我们需要在`twittervotes/core/models`目录中的`__init__.py`文件中导入新的模型：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Also, let''s add a function to read the `.twittervotes` file in `config.py` in
    `twittervotes/core`. First, we need to import the `RequestAuth`—`namedtuple` that
    we just created:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，让我们在`twittervotes/core`中的`config.py`文件中添加一个函数来读取`.twittervotes`文件。首先，我们需要导入我们刚刚创建的`RequestAuth`——`namedtuple`：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then we create a function called `read_reqauth` shown as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个名为`read_reqauth`的函数，如下所示：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This function is very straightforward: we just call the `_read_yaml_file`,
    passing as arguments the `.twitterauth` file and the new `namedtuple`, `RequestAuth`,
    that we just created. Again, if some error occurs, we raise an exception and show
    a help message.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单：我们只是调用`_read_yaml_file`，将`.twitterauth`文件和我们刚刚创建的新的`namedtuple`，`RequestAuth`作为参数传递进去。同样，如果发生错误，我们会引发异常并显示帮助消息。
- en: 'Now we can try the authentication. In the `twittervotes` directory, execute
    the script `twitter_auth.py`. You should see the following output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试进行身份验证。在`twittervotes`目录中，执行脚本`twitter_auth.py`。您应该会看到以下输出：
- en: '![](assets/a1052ea8-4738-468c-8caf-a568a927ddb4.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a1052ea8-4738-468c-8caf-a568a927ddb4.png)'
- en: 'Great! The server is up and running so we can open a browser and go to `http://localhost:3000`.
    You should see a very simple page with a link to perform the authentication:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！服务器已经启动，所以我们可以打开浏览器，转到`http://localhost:3000`。您应该会看到一个非常简单的页面，上面有一个链接可以进行身份验证：
- en: '![](assets/f28c4eee-25af-45b5-9e14-5393bcf250dd.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f28c4eee-25af-45b5-9e14-5393bcf250dd.png)'
- en: 'If you inspect the link with the browser development tools, you will see that
    the link is pointing to the authorize endpoint and it is passing the `oauth_token`
    that we created:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用浏览器开发工具检查链接，您将看到链接指向授权端点，并传递了我们创建的`oauth_token`：
- en: '![](assets/a23ce439-f6f8-4e4d-ac05-2552bf452cf7.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a23ce439-f6f8-4e4d-ac05-2552bf452cf7.png)'
- en: 'Go ahead and click on the link and you will be sent to the authorization page:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 继续点击链接，您将被发送到授权页面：
- en: '![](assets/8d73d3dc-f1c8-409d-b33a-f7833b594ba1.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8d73d3dc-f1c8-409d-b33a-f7833b594ba1.png)'
- en: 'If you click on the Authorize app button, you will be redirected back to localhost
    and a success message will be displayed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击“授权应用”按钮，您将被重定向回本地主机，并显示成功消息：
- en: '![](assets/ce6bc11b-7601-4b60-847b-4bdbb247c79a.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ce6bc11b-7601-4b60-847b-4bdbb247c79a.png)'
- en: 'If you pay attention to the URL Twitter has sent back to us, you will find
    some information. The important point here is the `oauth_verifier` that we will
    set to the request token and we perform one last request to get the access token.
    Now you can close the browser, stop the Flask app, and see the results in the
    file `.twitterauth` in the `twittervotes` directory:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到Twitter发送给我们的URL，您会发现一些信息。这里的重点是`oauth_verifier`，我们将其设置为请求令牌，然后我们执行最后一个请求以获取访问令牌。现在您可以关闭浏览器，停止Flask应用程序，并在`twittervotes`目录中的`.twitterauth`文件中查看结果：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, all the functionality that we implemented here is very useful if other
    users are going to use our application; however, there's an easier way to obtain
    the access token if you are authorizing your own Twitter app. Let's have a look
    at how that is done.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在这里实现的所有功能对于其他用户使用我们的应用程序非常有用；然而，如果您正在授权自己的Twitter应用程序，有一种更简单的方法可以获取访问令牌。让我们看看如何做到这一点。
- en: 'Go back to the Twitter application settings in [https://apps.twitter.com/](https://apps.twitter.com/);
    select the Keys and Access Tokens tab and scroll all the way down. If you have
    already authorized this application, you will see the same information we have
    now in the file `.twitterauth` but if you haven''t authorized the application
    yet, you will see a Your Access Token section looking like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到[https://apps.twitter.com/](https://apps.twitter.com/)中的Twitter应用程序设置；选择Keys
    and Access Tokens选项卡并滚动到最底部。如果您已经授权了这个应用程序，您将在`.twitterauth`文件中看到与我们现在相同的信息，但如果您还没有授权该应用程序，您将看到一个看起来像下面这样的Your
    Access Token部分：
- en: '![](assets/a155fb51-8b1d-443a-bb29-9eebada375ce.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a155fb51-8b1d-443a-bb29-9eebada375ce.png)'
- en: 'If you click on Create my access token, Twitter will generate the access token
    for you:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击“创建我的访问令牌”，Twitter将为您生成访问令牌：
- en: '![](assets/48983a7f-97bd-4851-a5a1-45ddc1151e89.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/48983a7f-97bd-4851-a5a1-45ddc1151e89.png)'
- en: After the access token is created, you can just copy the data into the `.twitterauth`
    file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌创建后，您只需将数据复制到`.twitterauth`文件中。
- en: Building the Twitter voting application
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Twitter投票应用程序
- en: Now we have our environment set up and we have seen how to create an app on
    Twitter and perform three-legged authentication, it is time to get right into
    building the actual application that will count the Twitter votes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的环境已经设置好，我们已经看到了如何在Twitter上创建一个应用程序并执行三条腿的身份验证，现在是时候开始构建实际的应用程序来计算Twitter投票了。
- en: 'We start off by creating a model class that will represent a hashtag. Create
    a file called `hashtag.py` in the `twittervotes/core/twitter` directory with the
    following content:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个模型类来表示一个标签。在`twittervotes/core/twitter`目录中创建一个名为`hashtag.py`的文件，内容如下：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is a very simple class. We can pass a name as an argument to the initializer;
    the name is the hashtag without the hash sign (`#`). In the initializer, we define
    a few properties: the name, which will be set to the argument that we pass to
    the initializer, then a property called `total` that will keep the hashtag usage
    count for us.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的类。我们可以将一个名称作为参数传递给初始化程序；名称是没有井号(`#`)的标签。在初始化程序中，我们定义了一些属性：名称，将设置为我们传递给初始化程序的参数，然后是一个名为`total`的属性，它将为我们保留标签的使用次数。
- en: Finally, we set the `refresh_url`. The `refresh_url` is going to be used to
    perform queries to the Twitter API, and the interesting part here is that the
    `refresh_url` already contains the `id` of the latest tweet that has been returned,
    so we can use that to fetch only tweets that we haven't already fetched, to avoid
    counting the same tweet multiple times.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们设置`refresh_url`。`refresh_url`将用于执行对Twitter API的查询，这里有趣的部分是`refresh_url`已经包含了最新返回的tweet的`id`，因此我们可以使用它来仅获取我们尚未获取的tweet，以避免多次计数相同的tweet。
- en: 'The `refresh_url` looks like the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`refresh_url`看起来像下面这样：'
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now we can open the file `__init__.py` in the `twittervotes/core/twitter` directory
    and import the class that we just created, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以打开`twittervotes/core/twitter`目录中的`__init__.py`文件，并导入我们刚刚创建的类，如下所示：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Perfect! Now go ahead and create a file called `request.py` in the `twittervotes/core/`
    directory.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在继续在`twittervotes/core/`目录中创建一个名为`request.py`的文件。
- en: 'As usual, we start adding some imports:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们开始添加一些导入：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First, we import the `oauth2` package that we are going to use to perform authentication;
    we prepare the request, signing it with the `SHA1` key. We also import `time`
    to set the `OAuth` timestamp setting. We import the function `parse_qsl`, which
    we are going to use to parse a query string so we can prepare a new request to
    search for the latest tweets, and the `json` module so we can deserialize the
    JSON data that the Twitter API sends back to us.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`oauth2`包，我们将使用它来执行身份验证；我们准备请求，并用`SHA1`密钥对其进行签名。我们还导入`time`来设置`OAuth`时间戳设置。我们导入函数`parse_qsl`，我们将使用它来解析查询字符串，以便我们可以准备一个新的请求来搜索最新的tweets，以及`json`模块，这样我们就可以反序列化Twitter
    API发送给我们的JSON数据。
- en: 'Then, we import our own functions, `read_config` and `read_req_auth`, so we
    can read both configuration files. Lastly, we import the `json` package to parse
    the results and the `requests` package to perform the actual request to the Twitter
    search endpoint:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们导入我们自己的函数`read_config`和`read_req_auth`，这样我们就可以读取两个配置文件。最后，我们导入`json`包来解析结果和`requests`包来执行对Twitter搜索端点的实际请求：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This function will read both configuration files—the `config.org` configuration
    file contains all the endpoint URLs that we need, and also the consumer keys.
    The `.twitterauth` file contains the `oauth_token` and `oauth_token_secret` that
    we will use to create a `Token` object that we will pass along with our request.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将读取两个配置文件——`config.org`配置文件包含我们需要的所有端点URL，以及消费者密钥。`.twitterauth`文件包含我们将用于创建`Token`对象的`oauth_token`和`oauth_token_secret`。
- en: After that, we define some parameters. `oauth_version` should, according to
    the Twitter API documentation, always be set to `1.0`. We also send `oauth_nonce`,
    which is a unique token that we must generate for every request, and lastly, `oauth_timestamp`,
    which is the time at which the request was created. Twitter will reject a request
    that was created too long before sending the request.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们定义一些参数。根据Twitter API文档，`oauth_version`应该始终设置为`1.0`。我们还发送`oauth_nonce`，这是我们必须为每个请求生成的唯一令牌，最后是`oauth_timestamp`，这是请求创建的时间。Twitter将拒绝在发送请求之前太长时间创建的请求。
- en: The last thing that we attach to the parameters is `oauth_token`, which is the
    token that is stored in the `.twitterath` file, and the consumer key, which is
    the key that was stored in the `config.yaml` file.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们附加到参数的最后一件事是`oauth_token`，它是存储在`.twitterath`文件中的令牌，以及消费者密钥，它是存储在`config.yaml`文件中的密钥。
- en: We perform a request to get an authorization and if everything goes right, we
    sign the request with an SHA1 key and return the URL of the request.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行一个请求来获取授权，如果一切顺利，我们用SHA1密钥对请求进行签名，并返回请求的URL。
- en: 'Now we are going to add the function that will perform a request to search
    for a specific hashtag and return the results to us. Let''s go ahead and add another
    function called `execute_request`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要添加一个函数，该函数将执行一个请求来搜索特定的标签，并将结果返回给我们。让我们继续添加另一个名为`execute_request`的函数：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function will get a `Hashtag` object as an argument and the first thing
    we do in this function is to read the configuration file. Then we check whether
    the `Hashtag` object has a value in the `refresh_url` property; in that case,
    we are going remove the `?` sign in the front of the `refresh_url` string.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将以`Hashtag`对象作为参数，并且在这个函数中我们要做的第一件事是读取配置文件。然后我们检查`Hashtag`对象的`refresh_url`属性是否有值；如果有，我们将删除`refresh_url`字符串前面的`?`符号。
- en: 'After that, we use the function `parse_qsl` to parse the query string and return
    a list of tuples where the first item in the tuple is the name of the parameter
    and the second is its value. For example, let''s say we have a query string that
    looks like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用函数`parse_qsl`来解析查询字符串，并返回一个元组列表，其中元组中的第一项是参数的名称，第二项是其值。例如，假设我们有一个看起来像这样的查询字符串：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we use the `parse_qsl`, passing as an argument this query string, we will
    get the following list:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`parse_qsl`，将这个查询字符串作为参数传递，我们将得到以下列表：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And then if we pass this result to the `dict` function, we will get a dictionary
    like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们将这个结果传递给`dict`函数，我们将得到一个像这样的字典：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As I showed before, the `refresh_url` has the following format:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所示，`refresh_url`的格式如下：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: And after parsing and transforming it into a dictionary, we can use it to get
    refreshed data for the underlying hashtag.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析和转换为字典之后，我们可以使用它来获取底层标签的刷新数据。
- en: If the `Hashtag` object does not have the property `refresh_url` set, then we
    simply define a dictionary where the `q` is the hashtag name and the result type
    is set to `mixed` to tell the Twitter API that it should return popular, recent,
    and real-time tweets.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Hashtag`对象没有设置`refresh_url`属性，那么我们只需定义一个字典，其中`q`是标签名称，结果类型设置为`mixed`，告诉Twitter
    API它应该返回热门、最新和实时的推文。
- en: After defining the search parameters, we use the `prepare_request` function
    that we created above to authorize the request and sign it; when we get the URL
    back, we perform the request using the URL we get back from the `prepare_request`
    function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了搜索参数之后，我们使用上面创建的`prepare_request`函数来授权请求并对其进行签名；当我们得到URL后，我们使用从`prepare_request`函数得到的URL执行请求。
- en: We make use of the `json.loads` function to parse the JSON data and return a
    tuple containing the first item, the hashtag itself; the second item will be the
    results we get back from the request.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`json.loads`函数来解析JSON数据，并返回一个包含第一项，即标签本身的元组；第二项将是我们从请求中得到的结果。
- en: 'The final touch, as usual, is to import the `execute_request` function in the
    `__init__.py` file in the core module:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步，像往常一样，在核心模块的`__init__.py`文件中导入`execute_request`函数：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s see how that works in the Python REPL:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这在Python REPL中是如何工作的：
- en: '![](assets/4df954cf-1c1b-40f6-951d-3c6d7acaa55d.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4df954cf-1c1b-40f6-951d-3c6d7acaa55d.png)'
- en: The output above is much bigger than this but a lot of it has been omitted;
    I just wanted to demonstrate how the function works.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的输出比这个要大得多，但其中很多都被省略了；我只是想演示一下这个函数是如何工作的。
- en: Enhancing our code
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强我们的代码
- en: We also want to give our users a good experience so we are going to add a command-line
    parser so the users of our application can specify some parameters before starting
    the voting process. There will be only one argument that we are going to implement
    and that is `--hashtags`, where users can pass a space-separated list of hashtags.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望为我们的用户提供良好的体验，因此我们将添加一个命令行解析器，这样我们的应用程序的用户可以在开始投票过程之前指定一些参数。我们将只实现一个参数，即`--hashtags`，用户可以传递一个以空格分隔的标签列表。
- en: With that said, we are going to define some rules for these arguments. First,
    we will limit the maximum number of hashtags that we are going to monitor, so
    we are going to add a rule that no more than four hashtags can be used.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，我们将为这些参数定义一些规则。首先，我们将限制我们要监视的标签的最大数量，因此我们将添加一个规则，即不能使用超过四个标签。
- en: If the user specifies more than four hashtags, we will simply display a warning
    on the Terminal and pick the first four hashtags. We also want to remove the duplicated
    hashtags.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户指定了超过四个标签，我们将简单地在终端上显示一个警告，并选择前四个标签。我们还希望删除重复的标签。
- en: When showing these warning messages that we talked about, we could simply print
    them on the Terminal and it would definitely work; however, we want to make things
    more interesting, so we are going to use the logging package to do it. Apart from
    that, implementing a proper logging will give us much more control over what kind
    of log we want to have and also how we want to present it to the users.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示我们谈论过的这些警告消息时，我们可以简单地在终端上打印它们，这肯定会起作用；然而，我们想要让事情变得更有趣，所以我们将使用日志包来做这件事。除此之外，实现适当的日志记录将使我们对我们想要拥有的日志类型以及如何向用户呈现它有更多的控制。
- en: 'Before we start implementing the command-line parser, let''s add the logger.
    Create a file called `app_logger.py` in the `twittervotes/core` directory with
    the following content:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现命令行解析器之前，让我们添加日志记录器。在`twittervotes/core`目录中创建一个名为`app_logger.py`的文件，内容如下：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This function doesn't do much but first we import the `os` module, then we import
    the logging package, and lastly, we import the function `fileConfig`, which reads
    the logging configuration from a config file. This configuration file has to be
    in the `configparser` format and you can get more information about this format
    at [https://docs.python.org/3.6/library/logging.config.html#logging-config-fileformat](https://docs.python.org/3.6/library/logging.config.html#logging-config-fileformat).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数并没有做太多事情，但首先我们导入`os`模块，然后导入日志包，最后导入`fileConfig`函数，它从配置文件中读取日志配置。这个配置文件必须是`configparser`格式的，你可以在[https://docs.python.org/3.6/library/logging.config.html#logging-config-fileformat](https://docs.python.org/3.6/library/logging.config.html#logging-config-fileformat)获取有关这种格式的更多信息。
- en: After we read the configuration file, we just return a logger called `twitterVotesLogger`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们读取配置文件之后，我们只返回一个名为`twitterVotesLogger`的记录器。
- en: 'Let''s see what the configuration file for our application looks like. Create
    a file called `logconfig.ini` in the `twittervotes` directory with the following
    content:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的应用程序的配置文件是什么样的。在`twittervotes`目录中创建一个名为`logconfig.ini`的文件，内容如下：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So here we define two loggers, `root` and `twitterVotesLogger`; the loggers
    are responsible for exposing methods that we can use at runtime to log messages.
    It is also through the loggers that we can set the level of severity, for example,
    `INFO`, `DEBUG` and so on. Lastly, the logger passes the log messages along to
    the appropriated handler.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里定义了两个记录器，`root`和`twitterVotesLogger`；记录器负责公开我们可以在运行时使用的记录消息的方法。也是通过记录器，我们可以设置严重程度的级别，例如`INFO`，`DEBUG`等。最后，记录器将日志消息传递给适当的处理程序。
- en: In the definition of our `twitterVotesLogger`, we set the level of severity
    to `INFO`, we set the handler to `consoleHandler` (we are going to describe this
    very soon), and we also set a qualified name that will be used when we want to
    get hold of the `twitterVotesLogger`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`twitterVotesLogger`的定义中，我们将严重级别设置为`INFO`，将处理程序设置为`consoleHandler`（我们将很快描述这一点），并设置一个限定名称，以便在需要获取`twitterVotesLogger`时使用。
- en: The last option for `twitterVotesLoggers` is `propagate`. Since the `twitterVotesLogger`
    is a child logger, we don't want the log message sent through the `twittersVotesLogger`
    to propagate to its ancestors. Without `propagate` set to `0`, every log message
    would be shown twice since the `twitterVotesLogger`'s ancestor is the `root` logger.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`twitterVotesLoggers`的最后一个选项是`propagate`。由于`twitterVotesLogger`是子记录器，我们不希望通过`twittersVotesLogger`发送的日志消息传播到其祖先。如果将`propagate`设置为`0`，则由于`twitterVotesLogger`的祖先是`root`记录器，每条日志消息都会显示两次。'
- en: The next component in the logging configuration is the handler. Handlers are
    the component that sends the log messages of a specific logger to a destination.
    We defined a handler called `consoleHandler` of type `StreamHandler`, which is
    a built-in handler of the logging module. The `StreamHandler` sends out log messages
    to streams such as `sys.stdout`, `sys.stderr`, or a file. This is perfect for
    us because we want to send messages to the Terminal.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 日志配置中的下一个组件是处理程序。处理程序是将特定记录器的日志消息发送到目的地的组件。我们定义了一个名为`consoleHandler`的处理程序，类型为`StreamHandler`，这是日志模块的内置处理程序。`StreamHandler`将日志消息发送到诸如`sys.stdout`、`sys.stderr`或文件之类的流。这对我们来说非常完美，因为我们希望将消息发送到终端。
- en: In the `consoleHandler`, we also set the severity level to `INFO` and also we
    set the formatter which is set to the `customFormatter`; then we set the value
    for args to `(sys.stdout, )`. Args specify where the log messages will be sent
    to; in this case, we set only `sys.stdout` but you can add multiple output streams
    if you need.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在`consoleHandler`中，我们还将严重级别设置为`INFO`，并设置了格式化程序，该格式化程序设置为`customFormatter`；然后我们将args的值设置为`(sys.stdout,
    )`。Args指定日志消息将被发送到的位置；在这种情况下，我们只设置了`sys.stdout`，但如果需要，可以添加多个输出流。
- en: The last component of this configuration is the formatter `customFormatter`.
    Formatters simply define how the log message should be displayed. In our `customFormatter`,
    we just define how the message should be displayed and show the date format.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置的最后一个组件是格式化程序`customFormatter`。格式化程序简单地定义了日志消息应该如何显示。在我们的`customFormatter`中，我们只定义了消息应该如何显示并显示日期格式。
- en: 'Now that we have the logging in place, let''s add the functions that will parse
    the command line. Create a file `cmdline_parser.py` in `twittervotes/core` and
    add some imports:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了日志记录，让我们添加解析命令行的函数。在`twittervotes/core`中创建一个名为`cmdline_parser.py`的文件，并添加一些导入：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then we will need to add a function that will validate the command-line arguments:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要添加一个函数来验证命令行参数：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`validate_args` functions have only one parameter and it is the arguments that
    have been parsed by the `ArgumentParser.` The first thing we do in this function
    is to get hold of the logger that we just created, so we can send log messages
    to inform the user about possible problems in the command-line arguments that
    have been passed to the application.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate_args`函数只有一个参数，即由`ArgumentParser`解析的参数。在此函数中，我们首先获取刚刚创建的记录器，以便向用户发送日志消息，通知可能存在的命令行参数问题。'
- en: Next, we transform the list of hashtags into a set so all the duplicated hashtags
    are removed and then we transform it back to a list. After that, we check whether
    the number of unique hashtags is less than the original number of hashtags that
    have been passed on the command line. That means that we had duplication and we
    log a message to inform the user about that.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将标签列表转换为集合，以便删除所有重复的标签，然后将其转换回列表。之后，我们检查唯一标签的数量是否小于在命令行传递的原始标签数量。这意味着我们有重复，并记录一条消息通知用户。
- en: The last verification we do is to make sure that a maximum of four hashtags
    will be monitored by our application. If the number of items in the hashtag list
    is greater than four, then we slice the array, getting only the first four items,
    and we also log a message to inform the user that only four hashtags will be displayed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行的最后一个验证是确保我们的应用程序最多监视四个标签。如果标签列表中的项目数大于四，则我们对数组进行切片，仅获取前四个项目，并且我们还记录一条消息，通知用户只会显示四个标签。
- en: 'Let''s add another function, `parse_commandline_args`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加另一个函数`parse_commandline_args`：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We saw how the `ArgumentParser` works when we were developing the application
    in the first chapter, the weather application. However, we can still go through
    what this function does.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第一章开发应用程序时，我们看到了`ArgumentParser`的工作原理，即天气应用程序。但是，我们仍然可以了解一下这个函数的作用。
- en: First, we define an `ArgumentParser` object, defining a name and a description,
    and we create a subgroup called `required` that, as the name suggests, will have
    all the required fields.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个`ArgumentParser`对象，定义了一个名称和描述，并创建了一个名为`required`的子组，正如其名称所示，它将包含所有必填字段。
- en: Note that we don't really need to create this extra group; however, I find that
    it helps to keep the code more organized and easier to maintain in case it is
    necessary to add new options in the future.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们实际上不需要创建这个额外的组；但是，我发现这有助于保持代码更有组织性，并且在将来有必要添加新选项时更容易维护。
- en: 'We define only one argument, `hashtags`. In the definition of the `hashtags`
    argument, there is an argument called `nargs` and we have set it to `+`; this
    means that I can pass an unlimited number of items separated by spaces, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只定义了一个参数`hashtags`。在`hashtags`参数的定义中，有一个名为`nargs`的参数，我们将其设置为`+`；这意味着我可以传递由空格分隔的无限数量的项目，如下所示：
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The last thing we do in this function is to parse the arguments with the `parse_args`
    function and run the arguments through the `validate_args` function that has been
    shown previously.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中我们做的最后一件事是使用`parse_args`函数解析参数，并将参数通过之前展示的`validate_args`函数进行验证。
- en: 'Let''s import the `parse_commandline_args` function in the `__init__.py` file
    in the `twittervotes/core` directory:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`twittervotes/core`目录中的`__init__.py`文件中导入`parse_commandline_args`函数：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we need to create a class that will help us to manage hashtags and perform
    tasks such as keeping the score count of hashtags, updating its value after every
    request. So let''s go ahead and create a class called `HashtagStatsManager`. Create
    a file called `hashtagstats_manager.py` in `twittervotes/core/twitter` with the
    following content:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个类，帮助我们管理标签并执行诸如保持标签的得分计数、在每次请求后更新其值等任务。因此，让我们继续创建一个名为`HashtagStatsManager`的类。在`twittervotes/core/twitter`中创建一个名为`hashtagstats_manager.py`的文件，内容如下：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This class is also very simple: in the constructor, we get a list of hashtags
    and initialize a property, `_hashtags`, which will be a dictionary where the key
    is the name of the hashtag and the value is an instance of the `Hashtag` class.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类也非常简单：在构造函数中，我们获取一个标签列表并初始化一个属性`_hashtags`，它将是一个字典，其中键是标签的名称，值是`Hashtag`类的实例。
- en: The update method gets a tuple containing a `Hashtag` object and the results
    are returned by the Twitter API.  First, we unpack the tuple values and set it
    to the `hashtag` and `results` variables. The `results` dictionary has two items
    that are interesting to us. The first is the `search_metadata`; in this item,
    we will find the `refresh_url` and the statuses contain a list of all tweets that
    used the hashtag that we were searching for.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 更新方法获取一个包含`Hashtag`对象和Twitter API返回结果的元组。首先，我们解包元组值并将其设置为`hashtag`和`results`变量。`results`字典对我们来说有两个有趣的项目。第一个是`search_metadata`；在这个项目中，我们将找到`refresh_url`，而`statuses`包含了使用我们搜索的标签的所有推文的列表。
- en: So we get the values for the `search_metadata`, the `refresh_url`, and lastly
    the `statuses`. Then we count how many items there are in the `statuses` list.
    If the number of items on the statuses list is greater than `0`, we update the
    total count for the underlying hashtag as well as its `refresh_url`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们获得了`search_metadata`、`refresh_url`和最后`statuses`的值。然后我们计算`statuses`列表中有多少项。如果`statuses`列表中的项目数大于`0`，我们将更新底层标签的总计数以及其`refresh_url`。
- en: 'Then we import the `HashtagStatsManager` class that we just created in the
    `__init__.py` file in the `twittervotes/core/twitter` directory:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在`twittervotes/core/twitter`目录中的`__init__.py`文件中导入了我们刚刚创建的`HashtagStatsManager`类：
- en: '[PRE46]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The heart of this application is the class `Runner`. This class will perform
    the execution of a function and queue it in the process pool. Every function will
    be executed in parallel in a different process, which will make the program much
    faster than if I executed these functions one by one.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的核心是`Runner`类。这个类将执行一个函数并将其排入进程池。每个函数将在不同的进程中并行执行，这将使程序比我逐个执行这些函数要快得多。
- en: 'Let''s have a look at how the `Runner` class is implemented:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`Runner`类是如何实现的：
- en: '[PRE47]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The class `Runner` has an initializer taking three arguments; they are all functions
    that will be called in different statuses of the execution. `on_success` will
    be called when the execution of the item has been successful, `on_error` when
    the execution of one function has failed for some reason, and finally `on_complete` will
    be called when all the functions in the queue have been executed.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`Runner`类有一个初始化器，接受三个参数；它们都是在执行的不同状态下将被调用的函数。当项目的执行成功时将调用`on_success`，当一个函数的执行由于某种原因失败时将调用`on_error`，最后当队列中的所有函数都执行完毕时将调用`on_complete`。'
- en: There is also a method called `exec` that takes a function as the first argument,
    which is the function that will be executed, and the second argument is a list
    of `Hashtag` instances.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为`exec`的方法，它以一个函数作为第一个参数，这个函数将被执行，第二个参数是一个`Hashtag`实例的列表。
- en: There are a few interesting things in the `Runner` class. First, we are using
    the `concurrent.futures` module, which is a really nice addition to Python and
    has been around since Python 3.2; this module provides ways of executing callables
    asynchronously.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`Runner`类中有一些有趣的东西。首先，我们使用了`concurrent.futures`模块，这是Python的一个非常好的补充，自Python
    3.2以来一直存在；这个模块提供了异步执行可调用对象的方法。'
- en: The `concurrent.futures` module also provides the `ThreadPoolExecutor`, which
    will perform asynchronous executions using threads, and the `ProcessPollExecutor`,
    which uses a process. You can easily switch between these execution strategies
    according to your needs.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`concurrent.futures`模块还提供了`ThreadPoolExecutor`，它将使用线程执行异步操作，以及`ProcessPollExecutor`，它使用进程。您可以根据自己的需求轻松切换这些执行策略。'
- en: The rule of thumb is if your function is CPU-bound, it is a good idea to use
    `ProcessPollExecutor`, otherwise, you will suffer big performances issues because
    of the Python **Global Interpreter Lock** (**GIL**). For I/O-bound operations,
    I prefer using `ThreadPoolExecutor`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则是，如果您的函数是CPU绑定的，最好使用`ProcessPollExecutor`，否则，由于Python的**全局解释器锁**（**GIL**），您将遇到性能问题。对于I/O绑定的操作，我更喜欢使用`ThreadPoolExecutor`。
- en: If you want to read more about the GIL, you can check out the following wiki
    page: [https://wiki.python.org/moin/GlobalInterpreterLock](https://wiki.python.org/moin/GlobalInterpreterLock).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于GIL的信息，可以查看以下维基页面：[https://wiki.python.org/moin/GlobalInterpreterLock](https://wiki.python.org/moin/GlobalInterpreterLock)。
- en: Since we are not doing any I/O-bound operations, we use `ProcessPoolExecutor`.
    Then, we loop through the values of the items, which is a dictionary containing
    all the hashtags that our application is monitoring. And for every hashtag, we
    pass it to the `submit` function of the `ProcessPollExecutor` along with the function
    that we want to execute; in our case, it will be the `execute_request` function
    defined in the core module of our application.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有进行任何I/O绑定的操作，我们使用`ProcessPoolExecutor`。然后，我们循环遍历项目的值，这是一个包含我们的应用程序正在监视的所有标签的字典。对于每个标签，我们将其传递给`ProcessPollExecutor`的`submit`函数，以及我们要执行的函数；在我们的情况下，它将是我们应用程序的核心模块中定义的`execute_request`函数。
- en: The `submit` function, instead of returning the value returned by the `execute_request`
    function, will return a `future` object, which encapsulates the asynchronous execution
    of the `execute_request` function. The `future` object provides methods to cancel
    an execution, check the status of the execution, get the results of the execution,
    and so on.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`submit`函数不会返回`execute_request`函数返回的值，而是返回一个`future`对象，它封装了`execute_request`函数的异步执行。`future`对象提供了取消执行、检查执行状态、获取执行结果等方法。'
- en: Now, we want a way to be notified when the executions change state or when they
    finish. That is where reactive programming comes in handy.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望有一种方法在执行状态改变或完成时得到通知。这就是响应式编程派上用场的地方。
- en: Here, we get the `future` object and create an `Observable`. `Observables` are
    the core of reactive programming. An `Observable` is an object that can be observed
    and emit events at any given time. When an `Observable` emits an event, all observers
    that subscribed to that `Observable` will be notified and react to those changes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取`future`对象并创建一个`Observable`。`Observables`是响应式编程的核心。`Observable`是一个可以被观察并在任何给定时间发出事件的对象。当`Observable`发出事件时，所有订阅该`Observable`的观察者都将得到通知并对这些变化做出反应。
- en: 'This is exactly what we are trying to achieve here: we have an array of future
    executions and we want to be notified when those executions change state. These
    states will be handled by the functions that we passed as an argument to the `Runner`
    initializer—`_on_sucess`, `_on_error`, and `_on_complete`.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们在这里要实现的：我们有一系列未来的执行，我们希望在这些执行状态改变时得到通知。这些状态将由我们作为`Runner`初始化器参数传递的函数处理——`_on_sucess`、`_on_error`和`_on_complete`。
- en: 'Perfect! Let''s import the `Runner` class into `__init__.py` in the `twittervotes/core`
    directory:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！让我们在`twittervotes/core`目录的`__init__.py`中导入`Runner`类：
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The last piece of our project is to add the entry point of our application.
    We are going to add the user interface using the `Tkinter` package from the standard
    library. So let''s start implementing it. Create a file called `app.py` in the
    `twittervotes` directory, and let''s start by adding some imports:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的最后一部分是添加应用程序的入口点。我们将使用标准库中的`Tkinter`包添加用户界面。所以让我们开始实现它。在`twittervotes`目录中创建一个名为`app.py`的文件，然后让我们从添加一些导入开始：
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we import the command-line argument parser that we created, `execute_request` to
    perform the requests to the Twitter API, and also the `Runner` class that will
    help us execute the requests to the Twitter API  in parallel.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入了我们创建的命令行参数解析器，`execute_request`来执行对Twitter API的请求，还有`Runner`类，它将帮助我们并行执行对Twitter
    API的请求。
- en: We also import the `HashtagStatsManager` to manage the hashtag voting results
    for us.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还导入`HashtagStatsManager`来为我们管理标签投票结果。
- en: Lastly, we have all the imports related to `tkinter`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有与`tkinter`相关的所有导入。
- en: 'In the same file, let''s create a class called `Application` as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个文件中，让我们创建一个名为`Application`的类，如下所示：
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'So here, we create a class, `Application`, that inherits from `Frame`. The
    initializer takes two arguments: hashtags, which are the hashtags that we are
    going to monitor, and the master argument, which is an object of type `Tk`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，我们创建了一个名为`Application`的类，它继承自`Frame`。初始化器接受两个参数：标签，这些是我们将要监视的标签，以及master参数，它是一个`Tk`类型的对象。
- en: Then we create an instance of `HashtagStatsManager`, passing the list of hashtags;
    we also create an instance of the `Runner` class passing three arguments. These
    arguments are functions that will be called when one execution finishes successfully,
    when the execution fails, and when all the executions are complete.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建一个`HashtagStatsManager`的实例，传递标签列表；我们还创建`Runner`类的一个实例，传递三个参数。这些参数是在一个执行成功时将被调用的函数，执行失败时将被调用的函数，以及所有执行完成时将被调用的函数。
- en: Then we have a dictionary comprehension that will create a dictionary where
    the keys are the hashtags and the values are a `Tkinter` variable of type string,
    which in the `Tkinter` world is called `StringVar`. We do that so it will be easier
    to update the labels with the results later on.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有一个字典推导式，它将创建一个字典，其中键是标签，值是`Tkinter`的字符串变量，`Tkinter`世界中称为`StringVar`。我们这样做是为了以后更容易更新标签的结果。
- en: We call the methods `set_header `and `create_labels` that we are going to implement
    shortly and finally we call `pack`. The `pack` function will organize widgets
    such as buttons and labels and place them in the parent widget, in this case,
    the `Application`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用即将实现的`set_header`和`create_labels`方法，最后调用`pack`。`pack`函数将组织小部件，如按钮和标签，并将它们放在父小部件中，本例中是`Application`。
- en: 'Then we define a button that will execute the function `_fetch_data` when clicked
    and we use `pack` to place the button at the bottom of the frame:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义一个按钮，当点击时将执行`_fetch_data`函数，并使用`pack`将按钮放在框架的底部：
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here's the `set_header` method that I mentioned earlier; it simply creates `Label` objects
    and places them at the top of the frame.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我之前提到的`set_header`方法；它只是创建`Label`对象并将它们放在框架的顶部。
- en: 'Now we can add the `create_labels` method:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加`create_labels`方法：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `create_labels` method loops through `self._items`, which, if you remember,
    is a dictionary where the key is the name of the hashtag and the value is a `Tkinter`
    variable of type string.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_labels`方法循环遍历`self._items`，如果您记得的话，这是一个字典，其中键是标签的名称，值是一个字符串类型的`Tkinter`变量。'
- en: First, we create a `Label`, and the interesting part is the `textvariable` argument;
    we set it to `value`, which is a `Tkinter` variable related to a specific hashtag.
    Then we place the `Label` in the frame and, lastly, we set the value of the label
    using the function `set`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`Label`，有趣的部分是`textvariable`参数；我们将其设置为`value`，这是与特定标签相关的`Tkinter`变量。然后我们将`Label`放在框架中，最后，我们使用`set`函数设置标签的值。
- en: 'Then we need to add a method that will update the `Labels` for us:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要添加一个方法来为我们更新`Labels`：
- en: '[PRE53]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `_update_label`, as the name suggests, updates the label of a specific hashtag.
    The data argument is the results returned by the Twitter API and we get the total
    number of the hashtags from the manager. Finally, we use the `set` function again
    to update the label.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`_update_label`，顾名思义，更新特定标签的标签。数据参数是Twitter API返回的结果，我们从管理器中获取标签的总数。最后，我们再次使用`set`函数来更新标签。'
- en: 'Let''s add another function that will actually do the work of sending the requests
    to the Twitter API:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加另一个函数，实际上会发送请求到Twitter API的工作：
- en: '[PRE54]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This method will call the method `exec` of the `Runner` to execute the function
    that performs the requests to the Twitter API.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将调用`Runner`的`exec`方法来执行执行请求Twitter API的函数。
- en: 'Then we need to define the methods that will handle the events emitted by the
    `Observable`s created in the `Runner` class; we start by adding the method that
    will handle execution errors:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要定义处理`Runner`类中创建的`Observable`发出的事件的方法；我们首先添加处理执行错误的方法：
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is a `helper` method just to raise an exception in case something goes
    wrong with the execution of the requests.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`helper`方法，只是为了在请求执行出现问题时引发异常。
- en: 'Then we add another method that handles when the execution of an `Observable`
    has been successful:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加另一个处理`Observable`执行成功的方法：
- en: '[PRE56]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `_on_success` method is going to be called when one execution from the `Runner`
    finished successfully, and it will just update the manager with the new data and
    also update the label in the UI.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`_on_success`方法将在`Runner`的一个执行成功完成时被调用，它将只是更新管理器的新数据，并在UI中更新标签。'
- en: 'Lastly, we define a method that will handle when all the executions have been
    completed:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义一个处理所有执行完成的方法：
- en: '[PRE57]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `_on_complete` will be called when all the executions of the `Runner` finish.
    We are not going to be using it so we just use the `pass` statement.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`_on_complete`将在所有`Runner`的执行完成时被调用。我们不会使用它，所以我们只使用`pass`语句。'
- en: 'Now it is time to implement the function that will set up the application and
    initialize the UI—the function `start_app`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现设置应用程序并初始化UI的函数`start_app`了：
- en: '[PRE58]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This function creates the root application, sets the title, defines its dimensions,
    and also calls the `mainloop` function so the application keeps running.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建根应用程序，设置标题，定义其尺寸，并调用`mainloop`函数，以便应用程序保持运行。
- en: 'The last piece is to define the `main` function:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是定义`main`函数：
- en: '[PRE59]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `main` function is pretty simple. First, we parse the command-line arguments,
    then we start the application, passing the command-line arguments to it.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数非常简单。首先，我们解析命令行参数，然后启动应用程序，并将命令行参数传递给它。'
- en: 'Let''s see the application in action! Run the following command:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看应用程序的运行情况！运行以下命令：
- en: '[PRE60]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You will see the following output:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '![](assets/c3d0e26c-fbeb-405e-9809-f6a8547098ef.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c3d0e26c-fbeb-405e-9809-f6a8547098ef.png)'
- en: 'Let''s say we want the voting process to run for 3 minutes and it will monitor
    the hashtags `#debian`, `#ubuntu`, and `#arch`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望投票过程运行3分钟，并且它将监视`#debian`，`#ubuntu`和`#arch`这些标签：
- en: '[PRE61]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then you should see the following UI:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您应该看到以下UI：
- en: '![](assets/0b4368f8-3691-4d0c-b79d-48b2dcfb5bd2.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0b4368f8-3691-4d0c-b79d-48b2dcfb5bd2.png)'
- en: And if you click the Update button, the count for every hashtag will be updated.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击更新按钮，每个标签的计数都将被更新。
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we developed an application to cast votes on Twitter and we
    learned the different concepts and paradigms of the Python programming language.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了一个在Twitter上投票的应用程序，并学习了Python编程语言的不同概念和范式。
- en: By creating the hashtag voting application, you have learned how to create and
    configure a Twitter app and also how to implement a three-legged `OAuth` authentication
    to consume data from the Twitter API.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建标签投票应用程序，您已经学会了如何创建和配置Twitter应用程序，以及如何实现三条腿的`OAuth`身份验证来消费Twitter API的数据。
- en: We also learned how to use the logging module to show informational messages
    to the users of our application. Like the previous modules, we also created a
    command-line parser using the `ArgumentParser` module in the standard library.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学会了如何使用日志记录模块向我们的应用程序用户显示信息消息。与之前的模块一样，我们还使用标准库中的`ArgumentParser`模块创建了一个命令行解析器。
- en: We also had an introduction to reactive programming using the `Rx` (Reactive
    Extensions for Python) module. Then we used the `concurrent.futures` module to
    enhance the performance of our application, running multiple requests to the Twitter
    API in parallel.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了使用`Rx`（Python的响应式扩展）模块进行响应式编程。然后我们使用`concurrent.futures`模块来增强我们应用程序的性能，以并行方式运行多个请求到Twitter
    API。
- en: Lastly, we built a user interface using the `Tkinter` module.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`Tkinter`模块构建了一个用户界面。
- en: In the next chapter, we are going to build an application that will fetch exchange
    rate data from the site [http://fixer.io](http://fixer.io) to perform currency
    conversion.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建一个应用程序，该应用程序将从网站[http://fixer.io](http://fixer.io)获取汇率数据以进行货币转换。
