- en: 10\. Foundational Calculus with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10\. 使用Python进行基础微积分
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn to calculate the derivatives of functions at
    a given value of x. You'll also learn to calculate the integrals of functions
    between given values and use derivation to solve optimization problems, such as
    maximizing profit or minimizing cost. By the end of this chapter, you will be
    able to use calculus to solve a range of mathematical problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何在给定的*x*值处计算函数的导数。您还将学习如何计算给定值之间函数的积分，并使用导数来解决优化问题，例如最大化利润或最小化成本。在本章结束时，您将能够使用微积分来解决各种数学问题。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Calculus has been called the science of change, since its tools were developed
    to deal with constantly changing values such as the position and velocity of planets
    and projectiles. Previously, there was no way to express this kind of change in
    a variable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分被称为变化的科学，因为它的工具是为了处理不断变化的值，如行星和抛射物的位置和速度而开发的。以前，没有办法表达这种变量的变化。
- en: 'The first important topic in calculus is the **derivative**. This is the rate
    of change of a function at a given point. Straight lines follow a simple pattern
    known as the slope. This is the change in the *y* value (the *rise*) over a given
    range of *x* values (the *run*):'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分中的第一个重要主题是**导数**。这是给定点的函数变化率。直线遵循一个简单的模式，称为斜率。这是*y*值（*上升*）在给定的*x*值范围内（*水平移动*）的变化：
- en: '![Figure 10.1: Slope of a line'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1：直线的斜率'
- en: '](image/B15968_10_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_01.jpg)'
- en: 'Figure 10.1: Slope of a line'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：直线的斜率
- en: In *Figure 10.1*, the *y* value in the line increases by 2 units for every 1-unit
    increase in the *x* value, so we divide 2 by 1 to get a slope of 2.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图10.1*中，线条中的*y*值每增加1个单位，*x*值就增加2个单位，因此我们将2除以1得到斜率为2。
- en: 'However, the slope of a curve isn''t constant over the whole curve like it
    is in a line. So, as you can see in *Figure 10.2*, the rate of change of this
    function at point **A** is different from the rate of change at point **B**:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，曲线的斜率并不像直线那样在整条曲线上是恒定的。因此，正如您在*图10.2*中所看到的，该函数在点**A**的变化率与点**B**的变化率是不同的：
- en: '![Figure 10.2: Finding the slope of a curve'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2：找到曲线的斜率'
- en: '](image/B15968_10_02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_02.jpg)'
- en: 'Figure 10.2: Finding the slope of a curve'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：找到曲线的斜率
- en: However, if we zoom in closely enough on point **A**, we see the curve is pretty
    closely approximated by a straight line.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们在点**A**上放大得足够近，我们会发现曲线被一条直线相当精确地近似。
- en: '![Figure 10.3: Zooming in on the curve'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3：放大曲线'
- en: '](image/B15968_10_03.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_03.jpg)'
- en: 'Figure 10.3: Zooming in on the curve'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：放大曲线
- en: 'This is how derivatives work: we make the change in *x*, the *run*, small enough
    that the slope over that small part of the curve will closely approximate the
    rate of change of the curve at that point. Let''s see what it looks like in Python.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是导数的工作原理：我们使*x*的变化，即*水平移动*，足够小，以至于曲线的这一小部分的斜率将近似等于该点的曲线变化率。让我们看看在Python中是什么样子。
- en: Writing the Derivative Function
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写导数函数
- en: For all the fear whipped up about derivatives in calculus courses, the function
    for calculating a derivative numerically is surprisingly easy.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在微积分课程中对导数进行了大量炒作，但用于数值计算导数的函数实际上非常简单。
- en: 'In a Jupyter notebook, we''ll define a function, *f(x)*, to be the parabola
    *y = x*2:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jupyter笔记本中，我们将定义一个函数*f(x)*，即抛物线*y = x*2：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we can write a function to calculate the derivative at any point *(x, f(x))*
    using the classic formula:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写一个函数，使用经典公式在任何点*(x, f(x))*计算导数：
- en: '![Figure 10.4: Formula for calculating derivatives'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4：计算导数的公式'
- en: '](image/B15968_10_04.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_04.jpg)'
- en: 'Figure 10.4: Formula for calculating derivatives'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：计算导数的公式
- en: 'The numerator is the *rise* and the denominator is the *run*. *Δ x* means the
    *change in x*, and we''re going to make that a really small decimal by dividing
    1 by a million:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 分子是*上升*，分母是*水平移动*。*Δ x*表示*x*的变化，并且我们将通过将1除以一百万来使其成为一个非常小的小数：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The triple-quotes ( `"""` ) shown in the code snippet below are used to denote
    the start and end points of a multi-line code comment. Comments are added into
    code to help explain specific bits of logic.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下面代码片段中显示的三引号（`"""`）用于表示多行代码注释的起始和结束点。注释被添加到代码中，以帮助解释特定的逻辑部分。
- en: 'Now we can calculate the derivative of the function at any *x* value and we''ll
    get a very accurate approximation:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以计算任何*x*值处函数的导数，并且我们将得到一个非常精确的近似值：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you run the preceding code, you''ll get the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行上述代码，您将得到以下输出：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These values are only a little off from their actual values (-5.999999 instead
    of -6). We can round up the printout to the nearest tenth and we''ll see the values
    more clearly:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值与它们的实际值只有一点偏差（-5.999999而不是-6）。我们可以将打印输出四舍五入到最接近的十分位，这样我们将更清楚地看到这些值：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output will be:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''ve calculated the derivative of the function *y = x*2 at a number of points
    and we can see the pattern: the derivative is always twice the *x* value. This
    is the slope of the line that approximates the curve at that point. The awesome
    power of this method will become clear in this exercise.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经计算了函数*y = x*2在许多点的导数，我们可以看到模式：导数始终是*x*值的两倍。这是近似该点曲线的直线的斜率。这种方法的强大之处将在这个练习中变得清晰。 '
- en: 'Exercise 10.01: Finding the Derivatives of Other Functions'
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.01：找到其他函数的导数
- en: 'We can use our derivative function to calculate the derivative of any function
    we can express. There''s no need to go through tedious algebraic manipulations
    when we can simply use the *tiny run* method of calculating the slope. Here, our
    function will find the derivative of some complicated-looking functions. We reused
    *f*, but you can call other functions as well. In this exercise, you will find
    the derivatives of each function at the given *x* values:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用导数函数计算我们可以表达的任何函数的导数。当我们可以简单地使用计算斜率的*微小运行*方法时，就无需进行繁琐的代数运算。在这里，我们的函数将找到一些看起来复杂的函数的导数。我们重复使用了*f*，但您也可以调用其他函数。在这个练习中，您将找到给定*x*值处每个函数的导数：
- en: '![Figure 10.5: Function definitions at given x values'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.5：给定x值的函数定义'
- en: '](image/B15968_10_05.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_05.jpg)'
- en: 'Figure 10.5: Function definitions at given x values'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：给定x值的函数定义
- en: 'Perform the following steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'First, we''ll need to import the square root function from the `math` module:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要从`math`模块导入平方根函数：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here are the preceding functions in the equations, translated into Python code:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是前述方程中的函数，转换为Python代码：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Define the derivative function if you haven''t already:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有定义导数函数，请定义它：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then print out the derivatives by calling each function and the desired *x*
    value:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后通过调用每个函数和所需的*x*值打印出导数：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output will be as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You''ve just learned a very important skill: finding the derivative of a function
    (any function) at a specific *x* value. This is the reason calculus students do
    lots of hard algebra: to get the derivative as a function, and then they can plug
    in an *x* value. However, with Python, we just directly calculated the numerical
    derivative of a function without doing any algebra.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚学会了一个非常重要的技能：在特定*x*值处找到函数（任何函数）的导数。这就是微积分学生要做大量艰难代数的原因：要将导数作为一个函数得到，然后他们可以代入*x*值。然而，使用Python，我们直接计算了函数的数值导数，而不需要进行任何代数运算。
- en: Note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2AnlJOC](https://packt.live/2AnlJOC).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2AnlJOC](https://packt.live/2AnlJOC)。
- en: You can also run this example online at [https://packt.live/3gi4I7S](https://packt.live/3gi4I7S).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/3gi4I7S](https://packt.live/3gi4I7S)上在线运行此示例。
- en: Finding the Equation of the Tangent Line
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到切线的方程
- en: 'A common question in calculus is to find the equation of the line tangent to
    the curve at a given point. Remember our points **A** and **B**? The tangent lines
    are the lines that closely approximate the curve at those points, as you can see
    in *Figure 10.6*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分中一个常见的问题是找到曲线在给定点处的切线方程。还记得我们的点**A**和**B**吗？切线是在这些点附近紧密逼近曲线的线，正如您在*图10.6*中所看到的：
- en: '![Figure 10.6: Two tangent lines to a curve'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.6：曲线的两条切线'
- en: '](image/B15968_10_06.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_06.jpg)'
- en: 'Figure 10.6: Two tangent lines to a curve'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：曲线的两条切线
- en: 'Let''s use the information in *Figure 10.6*. The equation is as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用*图10.6*中的信息。方程如下：
- en: '![Figure 10.7: Equation of f(x)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7：f(x)的方程'
- en: '](image/B15968_10_07.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_07.jpg)'
- en: 'Figure 10.7: Equation of f(x)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：f(x)的方程
- en: The *x* value at point **A** in *Figure 10.6* is -0.48 and the *x* value at
    **B** is 0.67\. The great thing about using Python to do this is it won't matter
    if the given values are whole numbers, negatives, or decimals, the computer will
    easily process the number-crunching.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.6*中点**A**的*x*值为-0.48，**B**的*x*值为0.67。使用Python的好处是，给定的值是整数、负数还是小数都无关紧要，计算机会轻松处理这些数字计算。'
- en: 'To find the equation of a line, all we need is a slope and a point. If you
    remember your algebra, you can use this formula:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到直线的方程，我们只需要一个斜率和一个点。如果您记得您的代数，您可以使用这个公式：
- en: '![Figure 10.8: Equation of a line'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8：直线的方程'
- en: '](image/B15968_10_08.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_08.jpg)'
- en: 'Figure 10.8: Equation of a line'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：直线的方程
- en: 'We''re given the function and the point (*x*0*, y*0), so from that, we can
    find the slope *m* from the derivative of the function at the given *x* value.
    The equation of the tangent line will be in the form *y = mx + b*, and the only
    thing we don''t know is *b*, the *y* intercept of the line. But if we rearrange
    the preceding equation, we can see it on the right side of the equation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已知函数和点(*x*0*, y*0)，因此我们可以从给定的*x*值处函数的导数中找到斜率*m*。切线的方程将以*y = mx + b*的形式表示，我们唯一不知道的是*b*，即线的*y*截距。但是，如果我们重新排列前面的方程，我们可以在方程的右侧看到它：
- en: '![Figure 10.9: Equation of line at the point'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.9：点处的直线方程'
- en: '](image/B15968_10_09.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_09.jpg)'
- en: 'Figure 10.9: Equation of line at the point'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：点处的直线方程
- en: 'We need to find the slope *m* using the derivative function we already have,
    then plug it into *y*0 *- m x*0. To do this, perform the following steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用已有的导数函数找到斜率*m*，然后将其代入*y*0 *- m x*0。为此，请执行以下步骤：
- en: 'First, we''ll define our `f(x)` function:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将定义我们的`f(x)`函数：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then we''ll write a function to return the *y* intercept of a line given the
    slope and a point. Call it `point_slope`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将编写一个函数，根据斜率和一个点返回直线的*y*截距。将其命名为`point_slope`：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we''ll write a function that takes the function `f` and an `x` value
    and finds the derivative of `f` at `x`, puts that into the `point_slope` function,
    and prints out the equation of the line in *y = mx + b* form. Call it `tangent_line`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将编写一个函数，该函数接受函数`f`和一个`x`值，并找到`f`在`x`处的导数，将其放入`point_slope`函数中，并以*y = mx
    + b*的形式打印出直线的方程。将其命名为`tangent_line`：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We find the slope of the tangent line by taking the derivative of `f` at `x`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过对`f`在`x`处进行导数运算来找到切线的斜率：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we use the `point_slope` function to find the *y* intercept:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用`point_slope`函数来找到*y*截距：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, to get the equations of the lines tangent to `f` at *x = -0.48* and *x
    = 0.67*, use the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要得到在*x = -0.48*和*x = 0.67*处切线的方程，使用以下代码：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this section, we learned how to find out the equations of tangent lines at
    specific values of `x`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何找出在特定 `x` 值处的切线方程。
- en: Calculating Integrals
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算积分
- en: One major topic of calculus is differential calculus, which means taking derivatives,
    as we've been doing so far in this chapter. The other major topic is integral
    calculus, which involves adding up areas or volumes using many small *slices*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分的一个主要主题是微分微积分，这意味着取导数，就像我们在本章中一直在做的那样。另一个主要主题是积分微积分，它涉及使用许多小 *切片* 来累加面积或体积。
- en: When calculating integrals by hand, we're taught to reverse the algebra we would
    do to find a derivative. But that algebra gets messy and, in some cases, impossible.
    The *hard* version we learned in school was Riemann sums, which required us to
    cut the area under a curve into rectangular *slices* and add them up to get the
    area. But you could never work with more than 10 slices in a realistic amount
    of time, certainly not on a test.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在手工计算积分时，我们被教导要逆转我们用来找到导数的代数。但是那个代数变得混乱，并且在某些情况下是不可能的。我们在学校学到的 *困难* 版本是黎曼和，它要求我们将曲线下的面积切成矩形
    *切片* 并将它们相加以获得面积。但你永远无法在一个现实的时间内处理超过 10 个切片，当然也不可能在考试中。
- en: However, using Python, we can work with as many slices as we want, and it saves
    us the drudgery of jumping through a lot of hoops to get an algebraic equation.
    The point of finding the algebraic equation is to obtain accurate number values,
    and if using a program will get us the most accurate numbers, then we should definitely
    take that route.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 Python，我们可以使用任意多的切片，并且它可以节省我们通过许多步骤获得代数方程的麻烦。找到代数方程的目的是获得准确的数值，如果使用程序可以得到最准确的数值，那么我们肯定应该选择这条路线。
- en: '*Figure 10.10* shows a function and the area under it. Most commonly the area
    is bounded by the function itself, a lower *x* value **a**, an upper *x* value
    **b**, and the *x* axis.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.10* 显示了一个函数和其下的面积。通常面积由函数本身、一个较低的 *x* 值 **a**、一个较高的 *x* 值 **b** 和 *x*
    轴界定。'
- en: '![Figure 10.10: The area S under a curve defined by the function f(x) from
    a to b'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.10：由函数 f(x) 定义的曲线下的面积 S'
- en: '](image/B15968_10_10.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_10.jpg)'
- en: 'Figure 10.10: The area S under a curve defined by the function f(x) from a
    to b'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：由函数 f(x) 定义的曲线下的面积 S
- en: 'What we''re going to do is to slice the area **S** into rectangles of equal
    width, and since we know the height (*f(x)*), it''ll be easy to add them all up
    using Python. *Figure 10.11* shows what the situation looks like for *f(x) = x*2:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是将面积 **S** 切成等宽的矩形，由于我们知道高度（*f(x)*），所以使用 Python 将它们全部加起来会很容易。*图10.11* 显示了
    *f(x) = x*2 的情况：
- en: '![Figure 10.11: The area S sliced into 10 rectangles of equal width'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.11：面积 S 被切成 10 个等宽的矩形'
- en: '](image/B15968_10_11.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_11.jpg)'
- en: 'Figure 10.11: The area S sliced into 10 rectangles of equal width'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：面积 S 被切成 10 个等宽的矩形
- en: 'First, we''ll define the function and choose the number of rectangles (so that
    the value of both will be easy to change). In this instance, we will use 20 rectangles,
    which will give us a higher degree of accuracy than the 10 rectangles shown in
    *Figure 10.11*:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义函数并选择矩形的数量（以便两者的值都容易更改）。在这种情况下，我们将使用 20 个矩形，这将比 *图10.11* 中显示的 10 个矩形给我们更高的准确度：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we define our integral function. First, divide the range `(b – a)` into
    equal widths by dividing by `num`, the number of rectangles:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义我们的积分函数。首先，通过将范围 `(b – a)` 划分为 `num` 个矩形来获得等宽：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we''ll loop over the range, adding the area of the rectangles as we go.
    We do this with a one-line list comprehension. For every `n`, we multiply the
    base of the rectangle (`width`) by the height (*f(x)*) to get the area of each
    rectangle. Finally, we return the sum of all the areas:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将循环遍历范围，随着我们的遍历，我们将矩形的面积相加。我们可以使用一行列表推导来实现这一点。对于每个 `n`，我们将矩形的底部（`width`）乘以高度（*f(x)*）来获得每个矩形的面积。最后，我们返回所有面积的总和：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is how the function call looks:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是函数调用的样子：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output shows how, with more rectangles, we get closer and closer to the
    actual value of the area:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示，随着更多的矩形，我们越来越接近实际面积的值：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It seems to be growing slowly. What if we jump ahead to 100 rectangles? That
    would create the situation shown in *Figure 10.12*:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来增长得很慢。如果我们直接跳到 100 个矩形呢？这将产生 *图10.12* 中所示的情况：
- en: '![Figure 10.12: Smaller rectangles making a better approximation of the area'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.12：较小的矩形更好地逼近面积'
- en: '](image/B15968_10_12.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_12.jpg)'
- en: 'Figure 10.12: Smaller rectangles making a better approximation of the area'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：较小的矩形更好地逼近面积
- en: 'Here''s how we change the `print` statement to give us the area of the 100
    rectangles:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们如何更改 `print` 语句以给出 100 个矩形的面积：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output will be as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'How about 1,000 rectangles, an integral that would be extremely difficult and
    time-consuming to calculate by hand? Using Python, we''ll just change `100` to
    `1000` and get a much more accurate approximation:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，使用 1,000 个矩形，这个积分将会非常困难和耗时地手工计算？使用 Python，我们只需将 `100` 改为 `1000`，就可以得到一个更准确的逼近：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output will be as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And summing up 100,000 rectangles gets us 0.3333283333\. It seems like it's
    getting close to 0.333, or 1/3\. But adding more zeroes doesn't cost us anything,
    so feel free to increase the number of rectangles as much as required to get a
    more accurate result.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将 100,000 个矩形相加得到 0.3333283333\. 看起来它接近于 0.333，或者 1/3\. 但增加更多的零不会花费我们任何代价，所以随时增加矩形的数量以获得更准确的结果。
- en: Using Trapezoids
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用梯形
- en: 'We can get better approximations sooner using trapezoids rather than rectangles.
    That way, we won''t miss as much area, as you can see in *Figure 10.13*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更快地获得更好的逼近，而不是使用矩形，而是使用梯形。这样，我们就不会错过太多的面积，就像在 *图10.13* 中所示的那样：
- en: '![Figure 10.13: Using trapezoids for better approximations to the curve'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.13：使用梯形更好地逼近曲线'
- en: '](image/B15968_10_13.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_13.jpg)'
- en: 'Figure 10.13: Using trapezoids for better approximations to the curve'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13：使用梯形更好地逼近曲线
- en: 'The following is the formula for the trapezoidal rule:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是梯形规则的公式：
- en: '![Figure 10.14: Formula for area of trapezoids'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.14：梯形面积的公式'
- en: '](image/B15968_10_14.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_14.jpg)'
- en: 'Figure 10.14: Formula for area of trapezoids'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14：梯形面积的公式
- en: The heights of the segments at the endpoints *x = a* and *x = b* are counted
    once, while all the other heights are counted twice. That's because there are
    two *heights* in the formula for the area of a trapezoid. Can you guess how to
    adapt your integral function to be trapezoidal?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 端点*x = a*和*x = b*处的段的高度计算一次，而所有其他高度计算两次。这是因为在梯形面积的公式中有两个*高度*。您能猜到如何调整您的积分函数以成为梯形吗？
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we''ll run the `trap_integral` function using `5` trapezoids:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用`5`个梯形运行`trap_integral`函数：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output will be as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So, by using only 5 trapezoids, we have reduced the error to 3%. (Remember,
    we know the true value of the area for this function is 0.333...) Using 10 trapezoids,
    we get 0.335, which has an error of 0.6%.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，仅使用5个梯形，我们将误差降低到3%。（请记住，我们知道该函数的真实面积值为0.333...）使用10个梯形，我们得到0.335，误差为0.6%。
- en: 'Exercise 10.02: Finding the Area Under a Curve'
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.02：找到曲线下的面积
- en: 'In this exercise, we''ll find the area under the following functions in the
    given intervals:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将找到给定间隔内以下函数的面积：
- en: '![Figure 10.15: Formula for intervals'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.15：间隔的公式'
- en: '](image/B15968_10_15.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_15.jpg)'
- en: 'Figure 10.15: Formula for intervals'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15：间隔的公式
- en: 'Perform the following steps to find the area. Having written the `trap_integral`
    function to use trapezoids to approximate the area under a curve, it''s easy:
    just define the function (you may have to import a `trig` function and `pi`) and
    declare the endpoints. Have it use 100 trapezoids, because that''ll be very accurate
    and quickl:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来找到面积。编写了`trap_integral`函数来使用梯形来近似曲线下的面积，很容易：只需定义函数（您可能需要导入`trig`函数和`pi`）并声明端点。让它使用100个梯形，因为那将非常准确和快速：
- en: 'First, import the `math` functions you''ll need and define `f`, `g`, and `h`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入您需要的`math`函数并定义`f`，`g`和`h`：
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then call the `trap_integral` function on each function between the specified
    *x* values:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在指定的*x*值之间对每个函数调用`trap_integral`函数：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By now, you can probably see the power in this numerical method. If you can
    express a function in Python, you can get a very accurate approximation of its
    integral using the function for adding up all the rectangles under the curve,
    or even more accurately, the function for adding up all the trapezoids under the
    curve.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经看到了这种数值方法的威力。如果您可以用Python表达一个函数，您可以使用用于在曲线下添加所有矩形的函数或更准确地说，用于在曲线下添加所有梯形的函数来获得其积分的非常准确的近似值。
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3dTUVTG](https://packt.live/3dTUVTG).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/3dTUVTG](https://packt.live/3dTUVTG)。
- en: You can also run this example online at [https://packt.live/2Zsfxxi](https://packt.live/2Zsfxxi).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2Zsfxxi](https://packt.live/2Zsfxxi)上在线运行此示例。
- en: Using Integrals to Solve Applied Problems
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用积分解决应用问题
- en: 'If a curve is rotated about the *x* or *y* axis or a line parallel to one of
    the axes, to form a 3D object, we can calculate the volume of this solid by using
    the tools of integration. For example, let''s say the parabola *y = x*2 is rotated
    around its axis of symmetry to form a paraboloid, as in *Figure 10.16*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果曲线围绕*x*轴或*y*轴或与其中一个轴平行的线旋转，以形成3D对象，我们可以使用积分工具来计算这个固体的体积。例如，假设抛物线*y = x*2围绕其对称轴旋转形成一个抛物面，如*图10.16*中所示：
- en: '![Figure 10.16: A parabola rotated about the z axis'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.16：绕z轴旋转的抛物线'
- en: '](image/B15968_10_16.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_16.jpg)'
- en: 'Figure 10.16: A parabola rotated about the z axis'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16：绕z轴旋转的抛物线
- en: We can find the volume by adding up all the *slices* of the paraboloid as you
    go up the solid. Just as before, when we were using rectangles in two dimensions,
    now we're using cylinders in three dimensions. In *Figure 10.16*, the slices are
    going up the figure and not to the right, so we can flip it in our heads and redefine
    the curve *y = x*2 as *y = sqrt(x)*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将抛物面的所有*切片*相加来找到体积，就像在二维中使用矩形一样，现在我们在三维中使用圆柱体。在*图10.16*中，切片是沿着图形向上而不是向右移动的，因此我们可以在脑海中翻转它，并重新定义曲线*y
    = x*2为*y = sqrt(x)*。
- en: 'Now the radius of each cylinder is the *y* value, and let''s say we''re going
    from *x = 0* to *x = 1*:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每个圆柱体的半径是*y*值，假设我们从*x = 0*到*x = 1*：
- en: '![Figure 10.17: Flipping the paraboloid on its side'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.17：将抛物面侧翻'
- en: '](image/B15968_10_17.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_17.jpg)'
- en: 'Figure 10.17: Flipping the paraboloid on its side'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17：将抛物面侧翻
- en: The endpoints are still *0* and *1*, but the radius of the curve is the *y*
    value, which is *sqrt(x)*. So the volume of each circular slice is the volume
    of a cylinder (*pi * radius*2 ** height*), in this case *pi * r*2 ** thickness*,
    or *pi * sqrt(x)*2 ** width*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 端点仍然是*0*和*1*，但曲线的半径是*y*值，即*sqrt(x)*。因此，每个圆形切片的体积是圆柱体的体积（*pi * radius*2 ** height*），在这种情况下是*pi
    * r*2 ** thickness*，或*pi * sqrt(x)*2 ** width*。
- en: 'First, we import `sqrt` and `pi` from the `math` module and define `f(x)`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`math`模块导入`sqrt`和`pi`并定义`f(x)`：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then we''ll define a function that will take the function of the paraboloid
    and the beginning and ending values of `x`. It starts off by defining the running
    volume and the number of slices we''re going to use:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将定义一个函数，该函数将使用抛物面的函数和`x`的起始和结束值。它首先定义运行体积和我们将使用的切片数：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then we calculate the thickness of the slices by dividing the range of *x*
    values by the number of slices:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过将*x*值的范围除以切片的数量来计算切片的厚度：
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we calculate the volume of each cylindrical slice, which is *pi * r*2 **
    width*. We add that to the running volume, and when the loop is done we return
    the final volume:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们计算每个圆柱切片的体积，即*pi * r*2 ** 宽度*。我们将其添加到运行体积中，当循环完成时，我们返回最终体积：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s add up all the volumes between `0` and `1`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把`0`到`1`之间的所有体积加起来：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output will be as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This value is an approximation of the volume of the bounded paraboloid. Again,
    the more slices we split the function up into, the more accurate the approximation
    to the real volume.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值是有界抛物面积的近似值。同样，我们将函数分成的切片越多，近似值就越接近真实体积。
- en: 'Exercise 10.03: Finding the Volume of a Solid of Revolution'
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.03：找到旋转体的体积
- en: 'Here''s another solid-of-revolution problem: find the volume of the solid formed
    when the following functions are rotated around the *x* axis on the given intervals.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个旋转体问题：找到以下函数在给定区间上绕*x*轴旋转时形成的固体的体积。
- en: In the following figure, the green curve is *f(x) = 4 – 4x*2 and the red curve
    is *g(x) = 1-x*2. Find the volume of the solid formed when the area between the
    functions is rotated about the *x* axis.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，绿色曲线是*f(x) = 4 – 4x*2*，红色曲线是*g(x) = 1-x*2*。找到当函数之间的区域围绕*x*轴旋转时形成的固体的体积。
- en: '![Figure 10.18: A two-dimensional look at the two functions'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.18：两个函数的二维外观'
- en: '](image/B15968_10_18.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_18.jpg)'
- en: 'Figure 10.18: A two-dimensional look at the two functions'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18：两个函数的二维外观
- en: 'The resulting shape of the solid would be as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 固体的结果形状如下：
- en: '![Figure 10.19: The resulting shape is like a ring'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.19：结果形状像一个环'
- en: '](image/B15968_10_19.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_19.jpg)'
- en: 'Figure 10.19: The resulting shape is like a ring'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.19：结果形状像一个环
- en: 'This is like a problem of finding the area of a ring, as shown in the preceding
    figure. The formula is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像一个找到环的面积的问题，就像前面的图所示。公式如下：
- en: '![Figure 10.20: Formula for area of a ring'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.20：环形面积公式'
- en: '](image/B15968_10_20.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_20.jpg)'
- en: 'Figure 10.20: Formula for area of a ring'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.20：环形面积公式
- en: 'Now to find the volume of the solid using Python, perform the following steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用Python来找到固体的体积，执行以下步骤：
- en: 'Create `f` and `g` as usual, and a third function (`h`) to be the difference
    of the squares of `f` and `g`, from the ring area formula:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样创建`f`和`g`，以及第三个函数（`h`）作为`f`和`g`的平方的差，来自环面积公式：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now the volume of the solid will be the sum of a given number (`num`) of cylinders
    made between the functions. We do the same thing as in our integration function.
    The radius of the cylinder is the same as the height of our rectangle when we
    were integrating:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，固体的体积将是在函数之间制成的给定数量（`num`）的圆柱体的总和。我们和我们的积分函数做同样的事情。圆柱的半径与我们积分时的矩形的高度相同：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The volume of a cylinder is *pi*r*2**h*, and we''ll add that to the running
    total volume:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 圆柱的体积是*pi*r*2**h*，我们将其加到总体积中：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here''s where we call `vol_solid` on the `h` function for *x* between `-1`
    and `1`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们在`-1`和`1`之间的*x*上调用`vol_solid`函数：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output will be as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Hence, the volume of the resulting solid is 50.3 cubic units. So, we have used
    our function to find the volumes of solids, and we have adapted it to find the
    volume of the solid between two curves.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，得到的固体的体积为50.3立方单位。因此，我们已经使用我们的函数找到了固体的体积，并且已经调整它以找到两个曲线之间的固体的体积。
- en: Note
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2NR9Svg](https://packt.live/2NR9Svg).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2NR9Svg](https://packt.live/2NR9Svg)。
- en: You can also run this example online at [https://packt.live/3eWJaxs](https://packt.live/3eWJaxs).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/3eWJaxs](https://packt.live/3eWJaxs)上在线运行此示例。
- en: Using Derivatives to Solve Optimization Problems
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用导数解决优化问题
- en: 'In many applied problems, we''re looking for an optimal point, where the error
    is lowest, for example, or the profit is highest. The traditional way is to model
    the situation using a function, find the derivative of the function, and solve
    for the input that makes the derivative zero. This is because the derivative is
    zero at local minima and maxima, as shown in the following figure:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用问题中，我们正在寻找一个最佳点，在这个点，误差最低，例如，或者利润最高。传统的方法是使用函数对情况进行建模，找到函数的导数，并解决使导数为零的输入。这是因为导数在局部最小值和最大值处为零，如下图所示：
- en: '![Figure 10.21: A cubic function and the points we want to find'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.21：一个三次函数和我们想要找到的点'
- en: '](image/B15968_10_21.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_21.jpg)'
- en: 'Figure 10.21: A cubic function and the points we want to find'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.21：一个三次函数和我们想要找到的点
- en: The function we're given in the figure is *f(x) = x*3 *- 2.8x*2 *+ 1.2x + 0.85*.
    We're interested in finding the local maximum, point **A**, and the local minimum,
    point **B**. We would have to differentiate the function and solve the resulting
    equation by hand. But using a computer, we can simply start at a value of *x*
    on the left of the grid and take small steps, checking *f(x)* until we get a change
    in direction. To do that, we can use our derivative function to check when the
    derivative changes sign.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在图中给出的函数是*f(x) = x*3 *- 2.8x*2 *+ 1.2x + 0.85*。我们有兴趣找到局部最大值，点**A**，和局部最小值，点**B**。我们需要对函数进行微分，并手动解决得到的方程。但是使用计算机，我们可以从网格左侧的一个*x*值开始，小步骤地检查*f(x)*，直到我们得到方向的改变。为此，我们可以使用我们的导数函数来检查导数何时改变符号。
- en: 'First, we define `f(x)`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义`f(x)`：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then we''ll define a function called `find_max_mins` to start at a minimum
    *x* value and take tiny steps, checking if the derivative equals zero or if it
    changes sign, from positive to negative or vice versa. The most mathematical way
    to do that is to check whether the previous derivative times the new one is negative:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义一个名为`find_max_mins`的函数，从最小的*x*值开始，小步骤地检查导数是否等于零，或者是否改变符号，从正变为负，或者反之。最数学的方法是检查前一个导数乘以新的导数是否为负：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, we call the function so it''ll print out all the values at which the
    derivative changes sign:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用函数，这样它将打印出导数改变符号的所有值：
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These are the local maximum and local minimum of `f` in *Figure 10.21*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是*图10.21*中`f`的局部最大值和局部最小值。
- en: 'Exercise 10.04: Find the Quickest Route'
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.04：寻找最快的路线
- en: 'We can use this procedure of finding maxima and minima to find the minimum
    value of a complicated function. In traditional calculus classes, students have
    to take the derivative algebraically, set it to zero, and then solve the resulting
    equation. We can model the situation in Python and use our derivative and the
    `find_max_min` functions to easily find the minimum value. Here''s the situation:
    a lighthouse is located 6 kilometers offshore, and a cabin on the straight shoreline
    is 9 kilometers from the point on the shore nearest the lighthouse. If you row
    at a rate of 3 km/hr and walk at a rate of 5 km/hr, where should you land your
    boat in order to get from the lighthouse to the cabin as quickly as possible?'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这种找到极值的方法来找到复杂函数的最小值。在传统的微积分课程中，学生们必须代数地求导，将其设为零，然后解决所得方程。我们可以在Python中对情况进行建模，并使用我们的导数和`find_max_min`函数轻松找到最小值。这就是情况：灯塔位于离岸6公里处，直线海岸上的小屋距离离灯塔最近的海岸点有9公里。如果你划船的速度是3公里/小时，步行的速度是5公里/小时，你应该在哪里着陆才能尽快地从灯塔到小屋？
- en: '![Figure 10.22: Distance of the lighthouse from the cabin'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.22：灯塔到小屋的距离'
- en: '](image/B15968_10_22.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_22.jpg)'
- en: 'Figure 10.22: Distance of the lighthouse from the cabin'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.22：灯塔到小屋的距离
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'We''re aiming to minimize the time it takes to make this trip, so let''s make
    a formula for time. Remember, time is distance divided by rate:![Figure 10.23:
    Formula for calculating time'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的目标是最小化这次旅行所需的时间，所以让我们制定一个时间公式。记住，时间是距离除以速度：![图10.23：计算时间的公式
- en: '](image/B15968_10_23.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_23.jpg)'
- en: 'Figure 10.23: Formula for calculating time'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.23：计算时间的公式
- en: 'And there''s the function we need to minimize. The optimal *x* is going to
    be between 0 and 9 kilometers, so we''ll set those as our start and end values
    when we call our `find_max_mins` function:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是我们需要最小化的函数。最佳的*x*将在0到9公里之间，所以当我们调用我们的`find_max_mins`函数时，我们将把它们设置为我们的起始和结束值：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output will be as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'That''s very close to 4.5 kilometers along the beach. This is a very useful
    calculation: we found the shortest distance between two points when other constraints
    have been put in place.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常接近沿着海滩的4.5公里。这是一个非常有用的计算：我们找到了两点之间的最短距离，当其他约束条件已经放置。
- en: Note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: To access the source code for this specific section, please refer to [https://packt.live/31DwYxu](https://packt.live/31DwYxu).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/31DwYxu](https://packt.live/31DwYxu)。
- en: You can also run this example online at [https://packt.live/38wNRM5](https://packt.live/38wNRM5).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/38wNRM5](https://packt.live/38wNRM5)上在线运行此示例。
- en: 'Exercise 10.05: The Box Problem'
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.05：箱子问题
- en: 'There''s a classic problem given to all calculus students in which a manufacturer
    has a rectangular piece of material that they want to make into a box by cutting
    identical squares out of the corners, like in the following figure:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有微积分学生来说，有一个经典问题，即制造商有一块矩形材料，他们想通过从角落切割相同大小的正方形来制成一个箱子，就像下图所示：
- en: '![Figure 10.24: Cutting squares out of the corners of a rectangle'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.24：从矩形的角落切割正方形'
- en: '](image/B15968_10_24.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_24.jpg)'
- en: 'Figure 10.24: Cutting squares out of the corners of a rectangle'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.24：从矩形的角落切割正方形
- en: 'In this case, the piece of material is 10 inches by 12 inches. Here''s the
    problem: find the size of the square to cut out in order to maximize the volume
    of the resulting box:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，材料的尺寸是10英寸乘以12英寸。问题是：找出要切割的正方形的大小，以使得所得箱子的体积最大化：
- en: 'The formula for the volume of the box will be length multiplied by width multiplied
    by height. In terms of *x*, the length of the square cut from the corners, the
    length of the box is *12 – 2x*, since two corners are cut out of the 12-inch sides.
    Similarly, the width of the box will be *10 – 2x*. The height, once the "flaps"
    are bent upwards, will be *x*. So, the volume is:![Figure 10.25: Formula to calculate
    the volume'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 箱子体积的公式将是长度乘以宽度乘以高度。就*x*而言，从角落切下的正方形的长度，箱子的长度是*12-2x*，因为两个角落被切出了12英寸的边。同样，箱子的宽度将是*10-2x*。高度，一旦“盖子”向上弯曲，将是*x*。所以，体积是：![图10.25：计算体积的公式
- en: '](image/B15968_10_25.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_25.jpg)'
- en: 'Figure 10.25: Formula to calculate the volume'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.25：计算体积的公式
- en: 'Here''s how you define this function in Python:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是如何在Python中定义这个函数的方法：
- en: '[PRE50]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'By now, you know how to put this into your `find_max_mins` function. We only
    want to plug in values between 0 and 5 because more than 5 inches would mean we''d
    be left with no side (the width is 10 inches):'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，您知道如何将其放入您的`find_max_mins`函数中。我们只想插入0到5之间的值，因为超过5英寸将意味着我们将没有一边（宽度为10英寸）：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output will be as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE52]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The maximum volume is achieved by cutting squares with side length 1.81 inches.
    Here''s a plot of the volume:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过切割边长为1.81英寸的正方形来实现最大体积。这是体积的图表：
- en: '![Figure 10.26: Plot of maximum value achieved'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.26：实现最大值的图表'
- en: '](image/B15968_10_26.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_26.jpg)'
- en: 'Figure 10.26: Plot of maximum value achieved'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.26：实现最大值的图表
- en: We can see that the maximum volume is achieved when a square of 1.81 inches
    is cut from each side, since this is where the maximum point of the plot lies.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当每边切割1.81英寸的正方形时，最大体积就会实现，因为这是图中最大点的位置。
- en: Note
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: To access the source code for this specific section, please refer to [https://packt.live/3gc11AC](https://packt.live/3gc11AC).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3gc11AC](https://packt.live/3gc11AC)。
- en: You can also run this example online at [https://packt.live/2NNSNmb](https://packt.live/2NNSNmb).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2NNSNmb](https://packt.live/2NNSNmb)上在线运行此示例。
- en: 'Exercise 10.06: The Optimal Can'
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.06：最佳罐头
- en: 'A cylindrical can hold 355 cm3 of soda. What dimensions (radius and height)
    will minimize the cost of metal to construct the can? You can neglect the top
    of the can:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一个圆柱体罐子可以容纳355立方厘米的苏打水。哪些尺寸（半径和高度）将使得构造罐子的金属成本最小？你可以忽略罐子的顶部：
- en: 'The surface area of a cylinder is the area of the bottom (a circle, so πr2)
    plus the area of its side, which is a rectangle of base *2πr* and a height of
    *h*. The volume of a cylinder is πr2h, so we put it all together:![Figure 10.27:
    Formula to calculate the volume of a cylinder'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 圆柱体的表面积是底部的面积（一个圆，所以πr2）加上它的侧面积，这是一个底部为*2πr*，高度为*h*的矩形。圆柱体的体积是πr2h，所以我们把它全部放在一起：![图10.27：计算圆柱体体积的公式
- en: '](image/B15968_10_27.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_27.jpg)'
- en: 'Figure 10.27: Formula to calculate the volume of a cylinder'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.27：计算圆柱体体积的公式
- en: 'The volume is already set to 355\. From there, we can get an expression for
    *h* in terms of *r* and we''ll have the surface area all in terms of one variable:![Figure
    10.28: Substituting the values in the formula'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 体积已经设定为355。从那里，我们可以得到一个关于* r *的表达式，然后我们将表面积都转化为一个变量的表达式：![图10.28：在公式中替换值
- en: '](image/B15968_10_28.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_28.jpg)'
- en: 'Figure 10.28: Substituting the values in the formula'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.28：在公式中替换值
- en: 'Let''s express it in Python and put it in our `find_max_mins` function:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用Python表达它，并把它放到我们的`find_max_mins`函数中：
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When you run the code, the output will be as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码时，输出将如下所示：
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'So the solution is for the radius to be around 4.8 cm and the height to be
    355/(π(4.8)2) = 4.9 cm. That means the can is about twice as wide as it is tall.
    Here''s a plot of the `surf_area` function for cans between 2 and 6 cm. You can
    see the point that minimizes the material, between 4.5 and 5 cm. We calculated
    it to be exactly 4.9 cm:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，解决方案是半径约为4.8厘米，高度约为355/(π(4.8)2) = 4.9厘米。这意味着罐子的宽度大约是高度的两倍。这是一个`surf_area`函数的图，显示了2到6厘米之间的罐子。你可以看到最小化材料的点，在4.5和5厘米之间。我们计算得到确切的值是4.9厘米：
- en: '![Figure 10.29: Finding the minimum material needed to make a can'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.29：找到制作罐子所需的最小材料'
- en: '](image/B15968_10_29.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_29.jpg)'
- en: 'Figure 10.29: Finding the minimum material needed to make a can'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.29：找到制作罐子所需的最小材料
- en: Note
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2Zu2bAK](https://packt.live/2Zu2bAK).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的源代码，请参阅[https://packt.live/2Zu2bAK](https://packt.live/2Zu2bAK)。
- en: You can also run this example online at [https://packt.live/38lUNeE](https://packt.live/38lUNeE).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/38lUNeE](https://packt.live/38lUNeE)上在线运行这个例子。
- en: 'Exercise 10.07: Calculating the Distance between Two Moving Ships'
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.07：计算两艘移动船之间的距离
- en: 'At noon, ship A is 20 km north of ship B. If ship A sails south at 6 km/hr
    and ship B sails east at 8 km/hr, find the time at which the distance between
    the two ships is smallest. The following figure shows the situation:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 中午时，A船在B船的北面20公里。如果A船以6公里/小时向南航行，B船以8公里/小时向东航行，找到两艘船之间距离最小的时间。以下图显示了这种情况：
- en: '![Figure 10.30: Ships A and B moving south and east'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.30：A和B船向南和东移动'
- en: '](image/B15968_10_30.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_30.jpg)'
- en: 'Figure 10.30: Ships A and B moving south and east'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.30：A和B船向南和东移动
- en: 'Perform the following steps to find the time:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤找到时间：
- en: 'The distance is velocity multiplied by time, so the distance between the two
    ships can be modeled by this equation:![Figure 10.31: Formula for calculating
    distance'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 距离是速度乘以时间，因此两艘船之间的距离可以用这个方程来建模：![图10.31：计算距离的公式
- en: '](image/B15968_10_31.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_31.jpg)'
- en: 'Figure 10.31: Formula for calculating distance'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.31：计算距离的公式
- en: 'Let''s express that using Python and put it into our `find_max_mins` function:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用Python表达这个问题，并把它放到我们的`find_max_mins`函数中：
- en: '[PRE55]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We assume the time will be between `0` and `4` hours:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们假设时间将在`0`和`4`小时之间：
- en: '[PRE56]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output will be as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE57]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The time is therefore 1.2 hours, illustrated by the minimum point on the following
    plot. Two tenths of an hour is 12 minutes, meaning the ships will be closest at
    1:12 pm. Here''s a plot of the distance versus time:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 因此时间是1.2小时，由下图上的最小点表示。两小时的十分之一是12分钟，这意味着两艘船在下午1:12时最接近。这是距离与时间的图：
- en: '![Figure 10.32: Plot of distance versus time'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.32：距离与时间的图'
- en: '](image/B15968_10_32.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_32.jpg)'
- en: 'Figure 10.32: Plot of distance versus time'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.32：距离与时间的图
- en: Note
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/38k2kuF](https://packt.live/38k2kuF).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的源代码，请参阅[https://packt.live/38k2kuF](https://packt.live/38k2kuF)。
- en: You can also run this example online at [https://packt.live/31FK3GG](https://packt.live/31FK3GG).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/31FK3GG](https://packt.live/31FK3GG)上在线运行这个例子。
- en: 'Activity 10.01: Maximum Circle-to-Cone Volume'
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动10.01：最大圆锥体积
- en: 'This is a classic optimization problem, which results in some extremely complicated
    equations to differentiate and solve if you''re doing it by hand. However, doing
    it with the help of Python will make the calculus part much easier. You start
    with a circle and cut out a sector of θ degrees. Then you attach points **A**
    and **B** in the following figure to make a cone:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个经典的优化问题，如果你手工完成，将导致一些非常复杂的方程式来求导和解决。然而，使用Python将使微积分部分变得更容易。你从一个圆开始，切出一个θ度的扇形。然后你在下图中连接点**A**和**B**，制作一个圆锥：
- en: '![Figure 10.33: Circle to cone volume'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.33：圆锥体积'
- en: '](image/B15968_10_33.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_33.jpg)'
- en: 'Figure 10.33: Circle to cone volume'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.33：圆锥体积
- en: The problem, like in the box problem, is to find the angle to cut out which
    maximizes the volume of the cone. It will require you to visualize cutting out
    the angle, attach the points to make a cone, and calculate the volume of the resulting
    cone.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 问题，就像在盒子问题中一样，是找到切出的角度，使圆锥体的体积最大化。这将要求你想象切出角度，连接点制作圆锥体，并计算结果圆锥体的体积。
- en: 'Steps for completion:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 完成步骤：
- en: Find the arc length of `AB`.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`AB`的弧长。
- en: Find *h*, the height of the resulting cone.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到* h *，结果圆锥体的高度。
- en: Find *r*, the radius of the base of the cone.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到* r *，圆锥的底半径。
- en: Find an expression for the volume of the cone as a function of theta (*θ*),
    the angle cut out.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出圆锥的体积表达式作为角度切出的函数(*θ*)。
- en: Note
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 694.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第694页找到。
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The tools of calculus allowed mathematicians and scientists to deal with constantly
    changing values, and those tools changed the way science is done. All of a sudden,
    we could use infinitely small steps to approximate the slope of a curve at a point,
    or infinitely small rectangles to approximate the area under a curve. These tools
    were developed hundreds of years before our modern world of computers and free
    programming software, but there's no reason to limit ourselves to the tools available
    to Newton, Leibniz, and the Bernoullis.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分的工具使数学家和科学家能够处理不断变化的值，这些工具改变了科学研究的方式。突然之间，我们可以使用无限小的步骤来近似曲线在某一点的斜率，或者使用无限小的矩形来近似曲线下的面积。这些工具是在我们现代计算机和免费编程软件的世界出现数百年之前发展起来的，但是没有理由限制自己只使用牛顿、莱布尼兹和伯努利可用的工具。
- en: In this chapter, we learned to take derivatives of functions by simply dividing
    the *rise* of the function from one point to another by the infinitesimal *run*
    between those points. We simply told Python to divide 1 by a million to give us
    that small number. Without a computer, plugging those decimals into a function
    would be a daunting task, but Python plugs a decimal into a function as easily
    as a whole number.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学会了通过简单地将函数从一个点到另一个点的*上升*除以这些点之间的无限小*运行*来对函数进行求导。我们只需告诉Python将1除以一百万，就可以得到这个小数。没有计算机的话，将这些小数插入函数将是一项艰巨的任务，但是Python可以像处理整数一样轻松地将小数插入函数。
- en: We used the derivative idea to find the highest or lowest output of a function,
    where the derivative equals zero. This enabled us to find the optimal value of
    a function that would yield the shortest distance, or the greatest volume, for
    example.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用导数的概念来找到函数的最高或最低输出，其中导数等于零。这使我们能够找到函数的最优值，例如产生最短距离或最大体积。
- en: The second most important topic in calculus is integration, and that allowed
    us to build up a complicated area or volume slice by slice using rectangles, trapezoids,
    or cylinders. Using Python, we could easily combine hundreds or thousands of slices
    to accurately approximate an area or volume.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 微积分中第二重要的主题是积分，这使我们能够使用矩形、梯形或圆柱体逐层构建复杂的面积或体积。使用Python，我们可以轻松地组合数百或数千个切片，准确地近似一个面积或体积。
- en: We've only scratched the surface of the power that calculus and Python give
    us to work with changing values, infinitely small values, and infinitely large
    ones, too.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是触及了微积分和Python赋予我们处理变化值、无限小值以及无限大值的能力的表面。
- en: In the next chapter, we'll expand on these basic tools to find the lengths of
    curves, the areas of surfaces, and, most usefully for machine learning, the minimum
    point on a surface.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展这些基本工具，以找到曲线的长度、表面的面积，以及对机器学习最有用的，表面上的最小点。
- en: WFT54
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: WFT54
- en: GLS48
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: GLS48
