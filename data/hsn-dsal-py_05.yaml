- en: Stacks and Queues
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈和队列
- en: In this chapter, we are going to build upon the skills we learned in the last
    chapter in order to create special list implementations. We are still sticking
    to linear structures. We will get into the details of more complex data structures
    in the coming chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在上一章学到的技能基础上创建特殊的列表实现。我们仍然坚持使用线性结构。在接下来的章节中，我们将深入了解更复杂的数据结构的细节。
- en: In this chapter, we are going to understand the concepts of stacks and queues.
    We will also implement these data structures in Python using various methods such
    as `lists` and `node`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解栈和队列的概念。我们还将使用各种方法在Python中实现这些数据结构，如`lists`和`node`。
- en: 'In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Implementing stacks and queues using various methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用各种方法实现栈和队列
- en: Some real-life example applications of stacks and queues
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈和队列的一些真实应用示例
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You should have a computer system on which Python is installed. All the programs
    based on the concepts discussed in this chapter are provided in the book as well
    as the GitHub repository at the following link: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter05).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该有一台安装了Python的计算机系统。本章讨论的概念的所有程序都在书中提供，也可以在以下链接的GitHub存储库中找到：[https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter05)。
- en: Stacks
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: 'A stack is a data structure that stores data, similar to a stack of plates
    in a kitchen. You can put a plate on the top of the stack, and when you need a
    plate, you take it from the top of the stack. The last plate that was added to
    the stack will be the first to be picked up from the stack. Similarly, a stack
    data structure allows us to store and read data from one end, and the element
    which is added last is picked up first. Thus, a stack is a **last in, first out**
    (**LIFO**) structure:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种存储数据的数据结构，类似于厨房里的一堆盘子。你可以把一个盘子放在栈的顶部，当你需要一个盘子时，你从栈的顶部拿走它。最后添加到栈上的盘子将首先从栈中取出。同样，栈数据结构允许我们从一端存储和读取数据，最后添加的元素首先被取出。因此，栈是一种**后进先出**（**LIFO**）结构：
- en: '![](Images/7db7f285-a46b-405d-a964-5a7367bb4533.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7db7f285-a46b-405d-a964-5a7367bb4533.png)'
- en: The preceding diagram depicts a stack of plates. Adding a plate to the pile
    is only possible by leaving that plate on top of the pile. To remove a plate from
    the pile of plates means to remove the plate that is on top of the pile.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表描述了一堆盘子。只有将一个盘子放在堆的顶部才有可能添加一个盘子。从盘子堆中移除一个盘子意味着移除堆顶上的盘子。
- en: There are two primary operations that are performed on stacks—`push` and `pop`.
    When an element is added to the top of the stack, it is pushed onto the stack.
    When an element is to be picked up from the top of the stack, it is popped off
    the stack. Another operation that is used sometimes is `peek`, which makes it
    possible to see the element on top of the stack without popping it off.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 栈上执行的两个主要操作是`push`和`pop`。当元素被添加到栈顶时，它被推送到栈上。当要从栈顶取出元素时，它被弹出栈。有时使用的另一个操作是`peek`，它可以查看栈顶的元素而不将其弹出。
- en: 'Stacks are used for a number of things. One very common usage for stacks is
    to keep track of the return address during function calls. Let''s imagine that
    we have the following program:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 栈用于许多事情。栈的一个非常常见的用途是在函数调用期间跟踪返回地址。假设我们有以下程序：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When the program execution gets to the call to `a()`, the following happens:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序执行到`a()`的调用时，发生以下情况：
- en: It first pushes the address of the current instruction onto the stack, then
    jumps to the definition of `a`
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先将当前指令的地址推送到栈上，然后跳转到`a`的定义
- en: Inside function `a()`, the function `b()` is called
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数`a()`内部，调用函数`b()`
- en: And, the return address of the function `b()` is pushed onto the stack
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数`b()`的返回地址被推送到栈上
- en: Once the execution of the instructions in `b()` and the function are complete,
    the return address is popped off the stack, which takes us back to function `a()`
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`b()`函数和函数执行完毕，返回地址将从栈中弹出，这将带我们回到函数`a()`。
- en: When all the instructions in function `a` are completed, the return address
    is again popped off from the stack, which takes us back to the `main` function
    and the `print` statement
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当函数`a`中的所有指令完成时，返回地址再次从栈中弹出，这将带我们回到`main`函数和`print`语句
- en: 'Stacks are also used to pass data between functions. Consider the following
    example. Say you have the following function call somewhere in your code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 栈也用于在函数之间传递数据。考虑以下示例。假设你的代码中有以下函数调用：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What happens internally is that the values passed by the functions `14, ''eggs'',
    ''ham''`, and `''spam''` will be pushed onto the stack, one at a time, as shown
    in the following diagram:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 内部发生的是，函数传递的值`14, 'eggs', 'ham'`和`'spam'`将依次被推送到栈上，如下图所示：
- en: '![](Images/90a07abc-4ef2-4623-ab9b-73bfc8b6c7a2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/90a07abc-4ef2-4623-ab9b-73bfc8b6c7a2.png)'
- en: 'When the code calls jump to the definition of the function, the values for
    `a, b, c, d` will be popped off the stack. The `spam` element will be popped off
    first and assigned to `d`, then `ham` will be assigned to `c`, and so on:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码调用`jump`到函数定义时，`a, b, c, d`的值将从栈中弹出。首先弹出`spam`元素并赋值给`d`，然后将`ham`赋值给`c`，依此类推：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Stack implementation
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈实现
- en: 'Stacks can be implemented in Python using node. We start off by creating a
    `node` class, as we did in the previous chapter with lists:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 栈可以使用节点在Python中实现。我们首先创建一个`node`类，就像在上一章中使用列表一样：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we discussed, a node holds data and a reference to the next item in a list.
    Here, we are going to implement a stack instead of a list; however, the same principle
    of nodes works here—nodes are linked together through references.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论的，一个节点包含数据和列表中下一个项目的引用。在这里，我们将实现一个栈而不是列表；然而，节点的相同原则在这里也适用——节点通过引用链接在一起。
- en: 'Now let us look at the `stack` class. It starts off in a similar way to a singly
    linked list. We will need two things to implement a stack using nodes:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`stack`类。它的开始方式与单链表类似。我们需要两样东西来实现使用节点的栈：
- en: We first need to know the node which is at the top of the stack so that we will
    be able to apply the `push` and `pop` operations through this node.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要知道位于栈顶的节点，以便我们能够通过这个节点应用`push`和`pop`操作。
- en: 'We would also like to keep track of the number of nodes in the stack, so we
    add a `size` variable to the stack class. Consider the following code snippet
    for the stack class:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望跟踪栈中节点的数量，因此我们向栈类添加一个`size`变量。考虑以下代码片段用于栈类：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Push operation
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推送操作
- en: The `push` operation is an important operation on a stack; it is used to add
    an element at the top of the stack. We implement the push functionality in Python
    to understand how it works.  At first, we check if the stack already has some
    items in it or it is empty when we wish to add a new node in the stack.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`push`操作是栈上的一个重要操作；它用于在栈顶添加一个元素。我们在Python中实现推送功能以了解它是如何工作的。首先，我们检查栈是否已经有一些项目或者它是空的，当我们希望在栈中添加一个新节点时。'
- en: 'If the stack already has some elements, then we have to do two things:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果栈已经有一些元素，那么我们需要做两件事：
- en: The new node must have its next pointer pointing to the node that was at the
    top earlier.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新节点必须使其下一个指针指向先前位于顶部的节点。
- en: 'We put this new node at the top of the stack by pointing `self.top` to the
    newly added node. See the two instructions in the following diagram:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过将`self.top`指向新添加的节点，将这个新节点放在栈的顶部。请参阅以下图表中的两条指令：
- en: '![](Images/e27ba744-6175-41ae-afc1-0ee0b18031cb.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e27ba744-6175-41ae-afc1-0ee0b18031cb.png)'
- en: 'If the existing stack is empty, and the new node to be added is the first element,
    we need to make this node the top node of the element. Thus, `self.top` will point
    to this new node. See the following diagram:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现有栈为空，并且要添加的新节点是第一个元素，我们需要将此节点作为元素的顶部节点。因此，`self.top`将指向这个新节点。请参阅以下图表：
- en: '![](Images/3c415c87-cfa5-41e5-87b9-35283f6d50fd.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3c415c87-cfa5-41e5-87b9-35283f6d50fd.png)'
- en: 'The following is globally the complete implementation of the `push` operation
    in `stack`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`stack`中`push`操作的完整实现：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Pop operation
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹出操作
- en: Now, we need another important function of the stack, and that is the `pop`
    operation. It reads the topmost element of the stack and removes it from the stack.
    The `pop` operation returns the topmost element of the stack and returns `None`
    if the stack is empty.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要栈的另一个重要功能，那就是`pop`操作。它读取栈的顶部元素并将其从栈中移除。`pop`操作返回栈的顶部元素，并且如果栈为空则返回`None`。
- en: 'To implement the `pop` operation on a stack:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要在栈上实现`pop`操作：
- en: First, check if the stack is empty. The `pop` operation is not allowed on an
    empty stack.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查栈是否为空。在空栈上不允许`pop`操作。
- en: 'If the stack is not empty, it can be checked if the top node has its **next** attribute
    pointing to some other node. It means the stack has elements, and the topmost
    node is pointing to the next node in the stack. To apply the `pop` operation,
    we have to change the top pointer. The next node should be at the top. We do this
    by pointing `self.top` to `self.top.next`. See the following diagram to understand
    this:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果栈不为空，可以检查顶部节点是否具有其`next`属性指向其他节点。这意味着栈中有元素，并且顶部节点指向栈中的下一个节点。要应用`pop`操作，我们必须更改顶部指针。下一个节点应该在顶部。我们通过将`self.top`指向`self.top.next`来实现这一点。请参阅以下图表以了解这一点：
- en: '![](Images/45afd13e-ada4-4424-b49e-5e78b9e2c4c1.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/45afd13e-ada4-4424-b49e-5e78b9e2c4c1.png)'
- en: 'When there is only one node in the stack, the stack will be empty after the
    pop operation. We have to change the top pointer to `None`. See the following
    diagram:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当栈中只有一个节点时，在弹出操作后栈将为空。我们必须将顶部指针更改为`None`。见下图：
- en: '![](Images/ee07d980-b726-4efe-bbc7-ac9a7bb29cb3.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ee07d980-b726-4efe-bbc7-ac9a7bb29cb3.png)'
- en: 'Removing such a node results in `self.top` pointing to `None`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除这样一个节点会导致`self.top`指向`None`：
- en: '![](Images/c6831f6e-a390-4a57-b4cc-9abd84efb305.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c6831f6e-a390-4a57-b4cc-9abd84efb305.png)'
- en: 'We also decrement the size of the stack by `1` if the stack is not empty. Here
    is the complete code for the `pop` operation for `stack` in Python:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果栈不为空，如果栈的顶部节点具有其`next`属性指向其他节点，则可以将栈的大小减少`1`。以下是Python中`stack`的`pop`操作的完整代码：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Peek operation
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看操作
- en: There is another important operation that can be applied on stacks—the `peek`
    method. This method returns the top element from the stack without deleting it
    from the stack. The only difference between `peek` and `pop` is that the `peek` method
    just returns the topmost element; however, in the case of a `pop` method, the
    topmost element is returned and also that element is deleted from the stack.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个可以应用在栈上的重要操作——`peek`方法。这个方法返回栈顶的元素，而不从栈中删除它。`peek`和`pop`之间唯一的区别是，`peek`方法只返回顶部元素；然而，在`pop`方法的情况下，顶部元素被返回并且也从栈中删除。
- en: 'The pop operation allows us to look at the top element without changing the
    stack. This operation is very straightforward. If there is a top element, return
    its data; otherwise, return `None` (thus, the behavior of `peek` matches that
    of `pop`):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 弹出操作允许我们查看顶部元素而不改变栈。这个操作非常简单。如果有顶部元素，则返回其数据；否则，返回`None`（因此，`peek`的行为与`pop`相匹配）：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Bracket-matching application
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 括号匹配应用
- en: 'Now let us look at an example application showing how we can use our stack implementation.
    We are going to write a little function that will verify whether a statement containing
    brackets—`(`, `[`,  or  `{`—is balanced, that is, whether the number of closing
    brackets matches the number of opening brackets. It will also ensure that one
    pair of brackets really is contained in another:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个示例应用程序，展示我们如何使用我们的堆栈实现。我们将编写一个小函数，用于验证包含括号（`(`，`[`或`{`）的语句是否平衡，即关闭括号的数量是否与开放括号的数量匹配。它还将确保一个括号对确实包含在另一个括号中：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our function parses each character in the statements passed to it. If it gets
    an open bracket, it pushes it onto the stack. If it gets a closing bracket, it
    pops the top element off the stack and compares the two brackets to make sure
    their types match, `(` should match `)`, `[` should match `]`, and `{` should
    match `}`. If they don't, we return `False`; otherwise, we continue parsing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数解析传递给它的语句中的每个字符。如果它得到一个开放括号，它将其推送到堆栈上。如果它得到一个关闭括号，它将堆栈的顶部元素弹出并比较两个括号，以确保它们的类型匹配，`(`应该匹配`)`，`[`应该匹配`]`，`{`应该匹配`}`。如果它们不匹配，我们返回`False`；否则，我们继续解析。
- en: 'Once we reach the end of the statement, we need to do one last check. If the
    stack is empty, then it is fine and we can return `True`. But if the stack is
    not empty, then we have an opening bracket that does not have a matching closing
    bracket and we will return `False`. We can test the bracket-matcher with the following
    code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们到达语句的末尾，我们需要进行最后一次检查。如果堆栈为空，那么很好，我们可以返回`True`。但是如果堆栈不为空，那么我们有一个没有匹配的关闭括号，我们将返回`False`。我们可以使用以下代码测试括号匹配器：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Only the first of the three statements should match. And when we run the code,
    we get the following output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 只有三个语句中的第一个应该匹配。当我们运行代码时，我们得到以下输出：
- en: '![](Images/17bdec19-ac8d-4124-bb4e-16767635d5e8.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/17bdec19-ac8d-4124-bb4e-16767635d5e8.png)'
- en: The output of the preceding code is `True`, `False`, and `False`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出是`True`，`False`和`False`。
- en: In summary, the `push` and `pop` operations of the stack data structure attract
    a complexity of *O(1)*. The stack data structure is simple; however, it is used
    to implement many functionalities in real-world applications. The back and forward
    buttons in the browser are implemented using the stacks. Stacks are also used
    to implement the undo and redo functionalities in word processors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，堆栈数据结构的`push`和`pop`操作吸引了*O(1)*的复杂性。堆栈数据结构很简单；然而，它被用于实现许多真实世界应用中的功能。浏览器中的后退和前进按钮是使用堆栈实现的。堆栈也用于实现文字处理器中的撤销和重做功能。
- en: Queues
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: Another special type of list is the queue data structure. The queue data structure
    is very similar to the regular queue you are accustomed to in real life. If you
    have stood in line at an airport or to be served your favorite burger at your
    neighborhood shop, then you should know how things work in a queue.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种特殊的列表类型是队列数据结构。队列数据结构非常类似于你在现实生活中习惯的常规队列。如果你曾经在机场排队或在邻里商店排队等待你最喜欢的汉堡，那么你应该知道队列是如何工作的。
- en: Queues are very fundamental and an important concept to grasp since many other
    data structures are built on them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是非常基础和重要的概念，因为许多其他数据结构都是建立在它们之上的。
- en: 'A queue works as follows. The first person to join the queue usually gets served
    first, and everyone will be served in the order of how they joined the queue.
    The acronym FIFO best explains the concept of a queue. **FIFO** stands for **first
    in, first out**. When people are standing in a queue waiting for their turn to
    be served, service is only rendered at the front of the queue. The only time people
    exit the queue is when they have been served, which only occurs at the very front
    of the queue. See the following diagram, where people are standing in the queue,
    and the person in the front would be served first:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的工作方式如下。通常，第一个加入队列的人会首先被服务，每个人都将按照加入队列的顺序被服务。首先进入，先出的首字母缩写FIFO最好地解释了队列的概念。**FIFO**代表**先进先出**。当人们站在队列中等待轮到他们被服务时，服务只在队列的前端提供。人们只有在被服务时才会离开队列，这只会发生在队列的最前面。请参见以下图表，其中人们站在队列中，最前面的人将首先被服务：
- en: '![](Images/e5fb97b2-07a9-4729-b679-8b1f1727db3f.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e5fb97b2-07a9-4729-b679-8b1f1727db3f.png)'
- en: To join the queue, participants must stand behind the last person in the queue.
    This is the only legal or permitted way the queue accepts new entrants. The length
    of the queue does not matter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入队列，参与者必须站在队列中的最后一个人后面。这是队列接受新成员的唯一合法方式。队列的长度并不重要。
- en: We shall provide various implementations of a queue, but this will revolve around
    the same concept of FIFO. The item added first will be read first. We shall call
    the operation to add an element to the queue as `enqueue`. When we delete an element
    from the queue, we shall call this a `dequeue` operation. Whenever an element
    is enqueued, the length or size of the queue increments by 1\. Conversely, dequeuing
    items reduces the number of elements in the queue by 1.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供各种队列的实现，但这将围绕FIFO的相同概念。首先添加的项目将首先被读取。我们将称添加元素到队列的操作为`enqueue`。当我们从队列中删除一个元素时，我们将称之为`dequeue`操作。每当一个元素被入队时，队列的长度或大小增加1。相反，出队的项目会减少队列中的元素数量1。
- en: 'To demonstrate the two operations, the following table shows the effects of
    adding and removing elements from a queue:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这两个操作，以下表格显示了从队列中添加和删除元素的效果：
- en: '| **Queue operation** | **Size** | **Contents** | **Operation results** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **队列操作** | **大小** | **内容** | **操作结果** |'
- en: '| `Queue()` | 0 | `[]` | Queue object created, which is empty.  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `Queue()` | 0 | `[]` | 创建了一个空的队列对象。 |'
- en: '| `Enqueue` Packt  | 1 | `[''Packt'']` |  One item *Packt* is added to queue.
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `Enqueue` Packt  | 1 | `[''Packt'']` |  队列中添加了一个 *Packt* 项目。 |'
- en: '| `Enqueue` Publishing  | 2 | `[''Publishing'', ''Packt'']` | One more item
    *Publishing *is added to the queue.  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `Enqueue` 发布  | 2 | `[''发布'', ''Packt'']` | 队列中添加了一个 *发布* 项目。 |'
- en: '| `Size()` | 2 | `[''Publishing'', ''Packt'']` | Return the number of items
    in the queue, which is 2 in this example. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `Size()` | 2 | `[''Publishing'', ''Packt'']` | 返回队列中的项目数，在此示例中为2。|'
- en: '| `Dequeue()` | 1 | `[''Publishing'']` | The *Packt* item is dequeued and returned.
    (This item  was added first, so it is removed first.) |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `Dequeue()` | 1 | `[''Publishing'']` | *Packt*项目被出队并返回。（这个项目是第一个添加的，所以它被第一个移除。）|'
- en: '| `Dequeue()` | 0 | `[]` | The *Publishing* item is dequeued and returned.
    (This is the last item added, so it is returned last.) |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `Dequeue()` | 0 | `[]` | *Publishing*项目被出队并返回。（这是最后添加的项目，所以最后返回。）|'
- en: List-based queues
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于列表的队列
- en: 'Queues can be implemented using various methods such as `list`, `stack`, and
    `node`. We shall discuss the implementation of queues using all these methods
    one by one. Let''s start by implementing a queue using Python''s `list` class.
    This is to help us quickly learn about queues. The operations that must be performed
    on the queue are encapsulated in the `ListQueue` class:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 队列可以使用各种方法实现，例如`list`、`stack`和`node`。我们将逐一讨论使用所有这些方法实现队列的方法。让我们从使用Python的`list`类实现队列开始。这有助于我们快速了解队列。必须在队列上执行的操作封装在`ListQueue`类中：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the initialization method, `__init__`, the `items` instance variable is set
    to `[]`, which means the queue is empty when created. The size of the queue is
    also set to `zero`. The `enqueue` and `dequeue` are important methods in queues,
    and we will discuss them in the next subsections.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化方法`__init__`中，`items`实例变量设置为`[]`，这意味着创建时队列为空。队列的大小也设置为`零`。`enqueue`和`dequeue`是队列中重要的方法，我们将在下一小节中讨论它们。
- en: The enqueue operation
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入队操作
- en: 'The `enqueue` operation adds an item to the queue. It uses the `insert` method
    of the `list` class to insert items (or data) at the front of the list. See the
    following code for the implementation of the `enqueue` method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`enqueue`操作将项目添加到队列中。它使用`list`类的`insert`方法在列表的前面插入项目（或数据）。请参阅以下代码以实现`enqueue`方法：'
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It is important to note how we implement insertions in queues using list. The
    concept is that we add the items at index `0` in a list; it is the first position
    in an array or list. To understand the concept of how the queue works when we
    add items at index `0` in a list, consider the following diagram. We start with
    an empty list. Initially, we add an item `1` at index `0`. Next, we add an item
    `2` at index `0`; it will shift the previously added item to the next index.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意我们如何使用列表实现队列中的插入。概念是我们在列表的索引`0`处添加项目；这是数组或列表中的第一个位置。要理解在列表的索引`0`处添加项目时队列的工作原理的概念，请考虑以下图表。我们从一个空列表开始。最初，我们在索引`0`处添加一个项目`1`。接下来，我们在索引`0`处添加一个项目`2`；它将先前添加的项目移动到下一个索引。
- en: 'Next, when we again add a new item `3` to the list at index `0`, all the items
    already added to the list are shifted, as shown in the following figure. Similarly,
    when we add item `4` at index `0`, all the items are shifted in the list:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当我们再次在索引`0`处向列表中添加一个新项目`3`时，已添加到列表中的所有项目都会被移动，如下图所示。同样，当我们在索引`0`处添加项目`4`时，列表中的所有项目都会被移动：
- en: '![](Images/3f3d2269-8c89-4dcd-88b6-986e1ff83407.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3f3d2269-8c89-4dcd-88b6-986e1ff83407.png)'
- en: Thus, in our implementation of a queue using a Python list, the array index
    `0` is the only place where new data elements are inserted into the queue. The
    `insert` operation will shift existing data elements in the list by one position
    up and then insert the new data in the space created at index `0`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们使用Python列表实现队列时，数组索引`0`是唯一可以向队列中插入新数据元素的位置。`insert`操作将列表中现有的数据元素向上移动一个位置，然后将新数据插入到索引`0`处创建的空间中。
- en: 'To make our queue reflect the addition of the new element, the size is increased
    by `1`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的队列反映新元素的添加，大小增加了`1`：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We could have used Python's `shift` method on the list as another way of implementing
    the insert at `0`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Python列表的`shift`方法作为在`0`处实现插入的另一种方法。
- en: The dequeue operation
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 出队操作
- en: 'The `dequeue` operation is used to delete items from the queue. This method returns
    the topmost item from the queue and deletes it from the queue. Here is the implementation
    of the `dequeue` method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`dequeue`操作用于从队列中删除项目。该方法返回队列中的顶部项目并将其从队列中删除。以下是`dequeue`方法的实现：'
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The Python `list` class has a method called `pop()`. The `pop` method does
    the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`list`类有一个名为`pop()`的方法。`pop`方法执行以下操作：
- en: Deletes the last item from the list
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中删除最后一个项目
- en: Returns the deleted item from the list back to the user or code that called
    it
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将从列表中删除的项目返回给用户或调用它的代码
- en: The last item in the list is popped and saved in the `data` variable. In the
    last line of the method, the data is returned.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的最后一个项目被弹出并保存在`data`变量中。在方法的最后一行，返回数据。
- en: 'Consider the following figure as our queue implementation, where three elements
    are added—`1`, `2`, and `3`. To perform a `dequeue` operation, the node with data
    `1` is removed from the front of the queue as it was added first:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图表作为我们的队列实现，其中添加了三个元素—`1`、`2`和`3`。执行`dequeue`操作时，数据为`1`的节点从队列的前面移除，因为它是最先添加的：
- en: '![](Images/26a4406e-d047-41ca-a5ac-802bf0f38a3a.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/26a4406e-d047-41ca-a5ac-802bf0f38a3a.png)'
- en: 'The resulting elements in the queue are shown as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 队列中的结果元素如下所示：
- en: '![](Images/57d7bcfd-6bd3-40eb-9fac-9d062009f56f.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/57d7bcfd-6bd3-40eb-9fac-9d062009f56f.png)'
- en: The `enqueue` operation is very inefficient due to one reason. The method has
    to first shift all the elements by one space. Imagine there are 1 million elements
    in a list which need to be shifted around any time a new element is being added
    to the queue. This will make the enqueue process very slow for large lists.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个原因，`enqueue`操作非常低效。该方法必须首先将所有元素向前移动一个空间。想象一下，列表中有100万个元素需要在每次向队列添加新元素时进行移动。这将使大型列表的入队过程非常缓慢。
- en: Stack-based queues
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于堆栈的队列
- en: 'Queues can also be implemented using two stacks. We initially set two instance
    variables to create an empty queue upon initialization. These are the stacks that
    will help us to implement a queue. The stacks, in this case, are simply Python
    lists that allow us to call `push` and `pop` methods on them, which eventually
    allow us to get the functionality of `enqueue` and `dequeue` operations. Here
    is the `Queue` class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 队列也可以使用两个栈来实现。我们最初设置了两个实例变量来在初始化时创建一个空队列。这些是帮助我们实现队列的栈。在这种情况下，栈只是允许我们在其上调用`push`和`pop`方法的Python列表，最终允许我们获得`enqueue`和`dequeue`操作的功能。以下是`Queue`类：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `inbound_stack` is only used to store elements that are added to the queue.
    No other operation can be performed on this stack.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`inbound_stack`只用于存储添加到队列中的元素。不能对此堆栈执行其他操作。'
- en: Enqueue operation
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入队操作
- en: 'The `enqueue` method is to add items to the queue. This method is very simple
    and only receives the `data` to append to the queue. This data is then passed
    to the `append` method of the `inbound_stack` in the `queue` class. Further, the `append` method
    is used to mimic the `push` operation, which pushes elements to the top of the
    stack. The following code is the implementation of `enqueue` using the stack in
    Python:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`enqueue`方法用于向队列中添加项目。这个方法非常简单，只接收要附加到队列的`data`。然后将此数据传递给`queue`类中`inbound_stack`的`append`方法。此外，`append`方法用于模拟`push`操作，将元素推送到栈的顶部。以下代码是使用Python中的栈实现`enqueue`的方法：'
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To `enqueue` data onto the `inbound_stack`, the following code does the job:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据`enqueue`到`inbound_stack`，以下代码可以完成任务：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A command-line output of the `inbound_stack` inside the queue is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 队列中`inbound_stack`的命令行输出如下：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Dequeue operation
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 出队操作
- en: The `dequeue` operation is used to delete the elements from the queue in the
    order of items added. New elements added to our queue end up in the `inbound_stack`.
    Instead of removing elements from the `inbound_stack`, we shift our attention
    to another stack, that is, `outbound_stack`. We shall delete the elements from
    our queue only through the `outbound_stack`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`dequeue`操作用于按添加的项目顺序从队列中删除元素。添加到我们的队列中的新元素最终会出现在`inbound_stack`中。我们不是从`inbound_stack`中删除元素，而是将注意力转移到另一个栈，即`outbound_stack`。我们只能通过`outbound_stack`删除队列中的元素。'
- en: To understand how `outbound_stack` can be used to delete the items from the
    queue, let us consider the following example.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解`outbound_stack`如何用于从队列中删除项目，让我们考虑以下示例。
- en: 'Initially, our `inbound_stack` was filled with the elements **5**, **6**, and **7**,
    as shown in the following diagram:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们的`inbound_stack`填充了元素**5**、**6**和**7**，如下图所示：
- en: '![](Images/445b36d4-1c69-4ec0-bba4-7588a994ea88.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/445b36d4-1c69-4ec0-bba4-7588a994ea88.png)'
- en: 'We first check if the `outbound_stack` is empty or not. As it is empty at the
    start, we move all the elements of the `inbound_stack` to the `outbound_stack`
    using the `pop` operation on the stack.  Now the `inbound_stack` becomes empty
    and the `outbound_stack` keeps the elements. We show this in the following diagram
    for more clarity:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查`outbound_stack`是否为空。由于开始时它是空的，我们使用`pop`操作将`inbound_stack`的所有元素移动到`outbound_stack`。现在`inbound_stack`变为空，而`outbound_stack`保留元素。我们在下图中展示了这一点，以便更清楚地理解：
- en: '![](Images/9e911f2b-2f63-4ff0-b4ad-ec6f2d1e1860.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9e911f2b-2f63-4ff0-b4ad-ec6f2d1e1860.png)'
- en: 'Now, if the `outbound_stack` is not empty, we proceed to remove the items from
    the queue using the `pop` operation. In the preceding figure, when we apply the `pop`
    operation on `outbound_stack`, we get the element `5`, which is correct as it
    was added first and should be the first element to be popped off from the queue.
    This leaves the `outbound_stack` with only two elements:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果`outbound_stack`不为空，我们继续使用`pop`操作从队列中删除项目。在前面的图中，当我们对`outbound_stack`应用`pop`操作时，我们得到了元素`5`，这是正确的，因为它是第一个添加的元素，应该是从队列中弹出的第一个元素。这样`outbound_stack`就只剩下两个元素了：
- en: '![](Images/414ded21-9d68-426a-84e5-eed9190d9f37.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/414ded21-9d68-426a-84e5-eed9190d9f37.png)'
- en: 'Here is the implementation of the `dequeue` method for the queue:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是队列的`dequeue`方法的实现：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `if` statement first checks whether the `outbound_stack` is empty or not.
    If it is not empty, we proceed to remove the element at the front of the queue
    using the `pop` method, shown as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句首先检查`outbound_stack`是否为空。如果不为空，我们继续使用`pop`方法删除队列前端的元素，如下所示：'
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the `outbound_stack` is empty instead, all the elements in the `inbound­_stack` are
    moved to the `outbound_stack` before the front element in the queue is popped
    out:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`outbound_stack`为空，那么在弹出队列的前端元素之前，`inbound_stack`中的所有元素都将移动到`outbound_stack`中：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `while` loop will continue to be executed as long as there are elements
    in the `inbound_stack`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环将在`inbound_stack`中有元素的情况下继续执行。'
- en: The `self.inbound_stack.pop()` statement will remove the latest element that
    was added to the `inbound_stack` and immediately passes the popped data to the `self.outbound_stack.append()` method
    call.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.inbound_stack.pop()`语句将删除添加到`inbound_stack`的最新元素，并立即将弹出的数据传递给`self.outbound_stack.append()`方法调用。'
- en: 'Let us consider an example code to understand the operations on the queue.
    We firstly use the queue implementation to add three items in the queue,that is, `5`,
    `6`, and `7`. Next, we apply dequeue operations to remove items from the queue.
    Here is the code :'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个示例代码，以理解队列上的操作。我们首先使用队列实现向队列中添加三个项目，即`5`、`6`和`7`。接下来，我们应用`dequeue`操作从队列中删除项目。以下是代码：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code snippet firstly adds elements to a queue and prints out the
    elements within the queue. Next, the `dequeue` method is called, after which a
    change in the number of elements is observed when the queue is printed out again.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段首先向队列添加元素，并打印出队列中的元素。接下来调用`dequeue`方法，然后再次打印队列时观察到元素数量的变化。
- en: Implementing a queue with two stacks is very important and questions about this
    are often posed during interviews.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个栈实现队列非常重要，关于这个问题在面试中经常被提出。
- en: Node-based queues
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于节点的队列
- en: Using a Python list to implement a queue is a good start to get a feel for how
    queues work. It is also possible for us to implement our own queue data structure
    by utilizing pointer structures.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python列表来实现队列是一个很好的开始，可以让我们了解队列的工作原理。我们也可以通过使用指针结构来实现自己的队列数据结构。
- en: A queue can be implemented using a doubly linked list, and `insertion` and `deletion`
    operations on this data structure, and that has a time complexity of `*O(1)*`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用双向链表实现队列，并且在这个数据结构上进行`插入`和`删除`操作，时间复杂度为`*O(1)*`。
- en: The definition for the `node` class remains the same as the `Node` we defined
    when we discussed in the doubly linked lists. A doubly linked list can be treated
    as a queue if it enables a FIFO kind of data access, where the first element added
    to the list is the first to be removed.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`node`类的定义与我们在讨论双向链表时定义的`Node`相同。如果双向链表能够实现FIFO类型的数据访问，那么它可以被视为队列，其中添加到列表中的第一个元素是要被移除的第一个元素。'
- en: Queue class
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列类
- en: 'The `queue` class is very similar to that of the doubly linked `list` class
    and the `Node` class to adding a node in a doubly linked list:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue`类与双向链表`list`类和`Node`类非常相似，用于在双向链表中添加节点：'
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Initially, the `self.head` and `self.tail` pointers are set to `None` upon creation
    of an instance of the `queue` class. To keep a count of the number of nodes in
    `Queue`, the `count` instance variable is also maintained here and initially set
    to `0`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`queue`类实例时，`self.head`和`self.tail`指针最初设置为`None`。为了保持`Queue`中节点数量的计数，这里还维护了`count`实例变量，最初设置为`0`。
- en: The enqueue operation
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入队操作
- en: Elements are added to a `Queue` object via the `enqueue` method. The elements
    or data are added through nodes. The `enqueue` method code is very similar to
    the `append` operation of the doubly linked list which we discussed in [Chapter
    4](234b9cb7-47a2-4910-8039-d7fed6c4af81.xhtml), *Lists and Pointer Structures*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`enqueue`方法向`Queue`对象添加元素。元素或数据通过节点添加。`enqueue`方法的代码与我们在[第4章](234b9cb7-47a2-4910-8039-d7fed6c4af81.xhtml)中讨论的双向链表的`append`操作非常相似，*列表和指针结构*。
- en: 'The enqueue operation creates a node from the data passed to it and appends
    it to the `tail` of the queue, and points both `self.head` and `self.tail` to
    the newly created node if the queue is empty. The total count of elements in the
    queue is increased by the line `self.count += 1`. If the queue is not empty, the
    new node''s previous variable is set to the tail of the list, and the tail''s
    next pointer (or variable) is set to the new node. Lastly, we update the tail
    pointer to point to the new node. This is shown in the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 入队操作从传递给它的数据创建一个节点，并将其附加到队列的`tail`，如果队列为空，则将`self.head`和`self.tail`都指向新创建的节点。队列中元素的总数增加了一行`self.count
    += 1`。如果队列不为空，则新节点的`previous`变量设置为列表的`tail`，并且尾部的下一个指针（或变量）设置为新节点。最后，我们更新尾指针指向新节点。代码如下所示：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The dequeue operation
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 出队操作
- en: 'The other operation that makes our doubly linked list behave as a queue is
    the `dequeue` method. This method removes the node at the front of the queue. To
    remove the first element pointed to by `self.head`, an `if` statement is used:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的双向链表作为队列的另一个操作是`dequeue`方法。这个方法移除队列前面的节点。为了移除`self.head`指向的第一个元素，使用了一个`if`语句：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`current` is initialized by pointing it to `self.head`. If `self.count` is
    `1`, then it means only one node is in the list and invariably the queue. Thus,
    to remove the associated node (pointed to by `self.head`), the `self.head` and
    `self.tail` variables are set to `None`.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`current`被初始化为指向`self.head`。如果`self.count`为`1`，那么意味着列表中只有一个节点，也就是队列。因此，要移除相关的节点（由`self.head`指向），`self.head`和`self.tail`变量被设置为`None`。'
- en: If the queue has many nodes, then the head pointer is shifted to point to the
    next node after `self.head`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果队列有多个节点，那么头指针会移动到`self.head`之后的下一个节点。
- en: After the `if` statement is executed, the method returns the node that was pointed
    to by the `head`. Also, the variable `self.count` is decremented by `1` in both
    of these conditions, that is, when the count is initially `1` and more than `1`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`if`语句之后，该方法返回被`head`指向的节点。此外，在这两种情况下，即初始计数为`1`和大于`1`时，变量`self.count`都会减少`1`。
- en: Equipped with these methods, we have implemented a queue, borrowing heavily
    from the idea of a doubly linked list.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些方法，我们已经实现了一个队列，很大程度上借鉴了双向链表的思想。
- en: Remember also that the only things transforming our doubly linked list into
    a queue are the two methods, namely, `enqueue` and `dequeue` methods.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，将我们的双向链表转换成队列的唯一方法是`enqueue`和`dequeue`方法。
- en: Application of queues
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列的应用
- en: Queues can be used to implement a variety of functionalities in many real computer-based
    applications. For instance, instead of providing each computer on a network with
    its own printer, a network of computers can be made to share one printer by queuing
    what each printer wants to print. When the printer is ready to print, it will
    pick one of the items (usually called jobs) in the queue to print out. It will
    print the command from the computer that has given the command first and in the
    order of the commands given by different computers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 队列可以在许多实际的计算机应用程序中用于实现各种功能。例如，可以通过排队打印机要打印的内容，而不是为网络上的每台计算机提供自己的打印机。当打印机准备好打印时，它将选择队列中的一个项目（通常称为作业）进行打印。它将按照不同计算机给出的命令的顺序打印出来。
- en: Operating systems also queue processes to be executed by the CPU. Let's create
    an application that makes use of a queue to create a bare-bones media player.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统也会对要由CPU执行的进程进行排队。让我们创建一个应用程序，利用队列来创建一个简单的媒体播放器。
- en: Media player queues
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 媒体播放器队列
- en: The most music player software allows users to add songs to a playlist. Upon
    hitting the play button, all the songs in the main playlist are played one after
    the other. Sequential playing of the songs can be implemented with queues because
    the first song to be queued is the first song that is to be played. This aligns
    with the FIFO acronym. We will implement our own playlist queue to play songs
    in the FIFO manner.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数音乐播放器软件允许用户将歌曲添加到播放列表中。点击播放按钮后，主播放列表中的所有歌曲都会依次播放。使用队列可以实现歌曲的顺序播放，因为排队的第一首歌曲是要播放的第一首歌曲。这符合FIFO首字母缩写。我们将实现自己的播放列表队列以按FIFO方式播放歌曲。
- en: Our media player queue will only allow for the addition of tracks and a way
    to play all the tracks in the queue. In a full-blown music player, threads would
    be used to improve how the queue is interacted with, while the music player continues
    to be used to select the next song to be played, paused, or even stopped.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的媒体播放器队列只允许添加曲目以及播放队列中的所有曲目。在一个完整的音乐播放器中，线程将被用于改进与队列的交互方式，同时音乐播放器继续用于选择下一首要播放、暂停或停止的歌曲。
- en: 'The `track` class will simulate a musical track:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`track`类将模拟音乐曲目：'
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Each track holds a reference to the title of the song and also the length of
    the song. The length of the song is a random number between `5` and `10`. The
    random module in Python provides the `randint` function to enable us to generate
    the random numbers. The class represents any MP3 track or file that contains music.
    The random length of a track is used to simulate the number of seconds it takes
    to play a song or track.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 每个曲目都保存了歌曲的标题的引用，以及歌曲的长度。歌曲的长度是在`5`和`10`之间的随机数。Python中的随机模块提供了`randint`函数，使我们能够生成随机数。该类表示包含音乐的任何MP3曲目或文件。曲目的随机长度用于模拟播放歌曲或曲目所需的秒数。
- en: 'To create a few tracks and print out their lengths, we do the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建几个曲目并打印出它们的长度，我们需要做以下操作：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Your output may be different depending on the random length generated for the
    two tracks.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 根据生成的两个曲目的随机长度，您的输出可能会有所不同。
- en: 'Now, let''s create our queue. Using inheritance, we simply inherit from the
    `queue` class:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的队列。使用继承，我们只需从`queue`类继承：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A call is made to properly initialize the queue by making a call to `super`.
    This class is essentially a queue that holds a number of track objects in a queue.
    To add tracks to the queue, an `add_track` method is created:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`super`来适当初始化队列。这个类本质上是一个队列，它在队列中保存了一些曲目对象。要将曲目添加到队列，需要创建一个`add_track`方法：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The method passes a `track` object to the `enqueue` method of the queue `super` class.
    This will, in effect, create a `Node` using the `track` object (as the node's
    data) and point either the tail, if the queue is not empty, or both head and tail,
    if the queue is empty, to this new node.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将`track`对象传递给队列`super`类的`enqueue`方法。这将实际上使用`track`对象（作为节点的数据）创建一个`Node`，并将尾部（如果队列不为空）或头部和尾部（如果队列为空）指向这个新节点。
- en: 'Assuming the tracks in the queue are played sequentially from the first track
    added to the last (FIFO), then the `play` function has to loop through the elements
    in the queue:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 假设队列中的曲目是按照添加的第一首曲目到最后一首曲目的顺序依次播放（FIFO），那么`play`函数必须循环遍历队列中的元素：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `self.count` keeps count of when a track is added to our queue and when
    tracks have been dequeued. If the queue is not empty, a call to the `dequeue`
    method will return the node (which houses the `track` object) at the front of
    the queue. The `print` statement then accesses the title of the track through
    the `data` attribute of the node. To further simulate the playing of a track,
    the `time.sleep()` method halts program execution till the number of seconds for
    the track has elapsed:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.count`用于计算何时向我们的队列添加了曲目以及何时曲目已被出队。如果队列不为空，对`dequeue`方法的调用将返回队列前端的节点（其中包含`track`对象）。然后，`print`语句通过节点的`data`属性访问曲目的标题。为了进一步模拟播放曲目，`time.sleep()`方法会暂停程序执行，直到曲目的秒数已经过去：'
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The media player queue is made up of nodes. When a track is added to the queue,
    the track is hidden in a newly created node and associated with the data attribute
    of the node. That explains why we access a node''s `track` object through the
    data property of the node which is returned by the call to `dequeue`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体播放器队列由节点组成。当一首曲目被添加到队列时，该曲目会隐藏在一个新创建的节点中，并与节点的数据属性相关联。这就解释了为什么我们通过对`dequeue`的调用返回的节点的数据属性来访问节点的`track`对象：
- en: '![](Images/a61216ca-9e9e-4cc4-af3e-d1923711a688.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a61216ca-9e9e-4cc4-af3e-d1923711a688.png)'
- en: You can see that, instead of our `node` object just storing just any data, it
    stores tracks in this case.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们的`node`对象不仅仅存储任何数据，而是在这种情况下存储曲目。
- en: 'Let''s take our music player for a spin:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来试试我们的音乐播放器：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We create five track objects with random words as titles:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用随机单词创建了五个曲目对象作为标题：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The output should be different from what you get on your machine due to the
    random length.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于随机长度，输出应该与您在您的机器上得到的不同。
- en: 'Next, an instance of the `MediaPlayerQueue` class is created:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`MediaPlayerQueue`类的一个实例：
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The tracks will be added and the output of the `play` function should print
    out the tracks being played in the same order in which we queued them:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 曲目将被添加，`play`函数的输出应该按照我们排队的顺序打印出正在播放的曲目：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE37]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Upon execution of the program, it can be seen that the tracks are played in
    the order in which they were queued. When playing the track, the system also pauses
    for the number of seconds equal to that of the length of the track.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行时，可以看到曲目按照它们排队的顺序播放。在播放曲目时，系统还会暂停与曲目长度相等的秒数。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used our knowledge of linking nodes together to create other
    data structures, namely `stacks` and `queues`. We have seen how these data structures
    closely mimic stacks and queues in the real world. Concrete implementations, together
    with their varying types, were explored. We later applied the concepts of stacks
    and queues to write real-life programs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们利用了我们对链接节点的知识来创建其他数据结构，即“栈”和“队列”。我们已经看到了这些数据结构如何紧密地模仿现实世界中的栈和队列。我们探讨了具体的实现，以及它们不同的类型。我们随后将应用栈和队列的概念来编写现实生活中的程序。
- en: We shall consider trees in the next chapter. The major operations of a tree
    will be discussed, and likewise the different spheres in which to apply their
    data structure.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将考虑树。将讨论树的主要操作，以及适用它们数据结构的不同领域。
