- en: Essential Scripting and File Information Recipes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本脚本和文件信息配方
- en: 'The following recipes are covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下配方：
- en: Handling arguments like an adult
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像成年人一样处理参数
- en: Iterating over loose files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代松散文件
- en: Recording file attributes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录文件属性
- en: Copying files, attributes, and timestamps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制文件、属性和时间戳
- en: Hashing files and data streams
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对文件和数据流进行哈希处理
- en: Keeping track with a progress bar
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用进度条跟踪
- en: Logging results
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录结果
- en: Multiple hands make light work
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多人合作，事半功倍
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Digital forensics involves the identification and analysis of digital media
    to assist in legal, business, and other types of investigations. Oftentimes, results
    stemming from our analysis have a major impact on the direction of an investigation.
    With *Moore’s law* more or less holding true, the amount of data we are expected
    to review is steadily growing. Given this, it’s a foregone conclusion that an
    investigator must rely on some level of automation to effectively review evidence.
    Automation, much like a theory, must be thoroughly vetted and validated so as
    not to allow for falsely drawn conclusions. Unfortunately, investigators may use
    a tool to automate some process but not fully understand the tool, the underlying
    forensic artifact, or the output’s significance. This is where Python comes into
    play.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数字取证涉及识别和分析数字媒体，以协助法律、商业和其他类型的调查。我们分析的结果往往对调查的方向产生重大影响。鉴于“摩尔定律”或多或少成立，我们预期要审查的数据量正在稳步增长。因此，可以断定，调查人员必须依赖某种程度的自动化来有效地审查证据。自动化，就像理论一样，必须经过彻底的审查和验证，以免导致错误的结论。不幸的是，调查人员可能使用工具来自动化某些过程，但并不完全了解工具、潜在的取证物件或输出的重要性。这就是Python发挥作用的地方。
- en: 'In *Python Digital Forensics Cookbook*, we develop and detail recipes covering
    a number of typical scenarios. The purpose is to not only demonstrate Python features
    and libraries for those learning the language but to also illustrate one of its
    great benefits: namely, a forced basic understanding of the artifact. Without
    this understanding, it is impossible to develop the code in the first place, thereby
    forcing you to understand the artifact at a deeper level. Add to that the relative
    ease of Python and the obvious benefits of automation, and it is easy to see why
    this language has been adapted so readily by the community.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在《Python数字取证食谱》中，我们开发和详细介绍了一些典型场景的示例。目的不仅是演示Python语言的特性和库，还要说明它的一个巨大优势：即对物件的基本理解。没有这种理解，就不可能首先开发代码，因此迫使您更深入地理解物件。再加上Python的相对简单和自动化的明显优势，很容易理解为什么这种语言被社区如此迅速地接受。
- en: One method of ensuring that investigators understand the product of our scripts
    is to provide meaningful documentation and explanation of the code. Hence the
    purpose of this book. The recipes demonstrated throughout show how to configure
    argument parsing that is both easy to develop and simple for the user to understand.
    To add to the script's documentation, we will cover techniques to effectively
    log the process that was taken and any errors encountered by the script.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 确保调查人员理解我们脚本的产品的一种方法是提供有意义的文档和代码解释。这就是本书的目的。本书中演示的示例展示了如何配置参数解析，这既易于开发，又简单易懂。为了增加脚本的文档，我们将介绍有效记录脚本执行过程和遇到的任何错误的技术。
- en: Another unique feature of scripts designed for digital forensics is the interaction
    with files and their associated metadata. Forensic scripts and applications require
    the accurate retrieval and preservation of file attributes, including dates, permissions,
    and file hashes. This chapter will cover methods to extract and present this data
    to the examiner.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数字取证脚本的另一个独特特性是与文件及其相关元数据的交互。取证脚本和应用程序需要准确地检索和保留文件属性，包括日期、权限和文件哈希。本章将介绍提取和呈现这些数据给审查员的方法。
- en: 'Interaction with the operating system and files found on attached volumes are
    at the core of any script designed for use in digital forensics. During analysis,
    we need to access and parse files with a wide variety of structures and formats.
    For this reason, it''s important to accurately and properly handle and interact
    with files. The recipes presented in this chapter cover common libraries and techniques
    that will continue to be used throughout the book:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与操作系统和附加卷上找到的文件进行交互是数字取证中设计的任何脚本的核心。在分析过程中，我们需要访问和解析具有各种结构和格式的文件。因此，准确和正确地处理和与文件交互非常重要。本章介绍的示例涵盖了本书中将继续使用的常见库和技术：
- en: Parsing command-line arguments
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析命令行参数
- en: Recursively iterating over files and folders
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归迭代文件和文件夹
- en: Recording and preserving file and folder metadata
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录和保留文件和文件夹的元数据
- en: Generating hash values of files and other content
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成文件和其他内容的哈希值
- en: Monitoring code with progress bars
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用进度条监视代码
- en: Logging recipe execution information and errors
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录配方执行信息和错误
- en: Improving performance with multiprocessing
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过多进程改善性能
- en: Visit [www.packtpub.com/books/content/support](http://www.packtpub.com/books/content/support)
    to download the code bundle for this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[www.packtpub.com/books/content/support](http://www.packtpub.com/books/content/support)下载本章的代码包。
- en: Handling arguments like an adult
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 像成年人一样处理参数
- en: 'Recipe Difficulty: Easy'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 配方难度：简单
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Any'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任何
- en: 'Person A: I came here for a good argument!'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: A人：我来这里是为了进行一场好的争论！
- en: 'Person B: Ah, no you didn''t, you came here for an argument!'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: B人：啊，不，你没有，你来这里是为了争论！
- en: 'Person A: An argument isn''t just contradiction.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: A人：一个论点不仅仅是矛盾。
- en: 'Person B: Well! it can be!'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: B人：好吧！可能吧！
- en: 'Person A: No it can''t! An argument is a connected series of statements'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: A人：不，不行！一个论点是一系列相关的陈述
- en: intended to establish a proposition.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 旨在建立一个命题。
- en: 'Person B: No it isn''t!'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: B人：不，不是！
- en: 'Person A: Yes it is! It isn''t just contradiction.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: A人：是的，是的！不仅仅是矛盾。
- en: Monty Python ([http://www.montypython.net/scripts/argument.php](http://www.montypython.net/scripts/argument.php))
    aside, arguments are an integral part of any script. Arguments allow us to provide
    an interface for users to specify options and configurations that change the way
    the code behaves. Effective use of arguments, not just contradictions, can make
    a tool more versatile and a favorite among examiners.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了蒙提·派森([http://www.montypython.net/scripts/argument.php](http://www.montypython.net/scripts/argument.php))之外，参数是任何脚本的一个组成部分。参数允许我们为用户提供一个接口，以指定改变代码行为的选项和配置。有效地使用参数，不仅仅是矛盾，可以使工具更加灵活，并成为审查人员喜爱的工具。
- en: Getting started
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: All libraries used in this script are present in Python's standard library.
    While there are other argument-handling libraries available, such as `optparse`
    and `ConfigParser`, our scripts will leverage `argparse` as our de facto command-line
    handler. While `optparse` was the library to use in prior versions of Python,
    `argparse` has served as the replacement for creating argument handling code.
    The `ConfigParser` library parses arguments from a configuration file instead
    of the command line. This is useful for code that requires a large number of arguments
    or has a significant number of options. We will not cover `ConfigParser` in this
    book, though it is worth exploring if you find your `argparse` configuration becomes
    difficult to maintain.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本中使用的所有库都包含在Python的标准库中。虽然还有其他可用的参数处理库，例如`optparse`和`ConfigParser`，但我们的脚本将利用`argparse`作为我们的事实命令行处理程序。虽然`optparse`是以前版本的Python中使用的库，但`argparse`已成为创建参数处理代码的替代品。`ConfigParser`库从配置文件中解析参数，而不是从命令行中解析。这对于需要大量参数或有大量选项的代码非常有用。在本书中，我们不会涵盖`ConfigParser`，但如果发现您的`argparse`配置变得难以维护，值得探索一下。
- en: To learn more about the `argparse` library, visit [https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关`argparse`库的更多信息，请访问[https://docs.python.org/3/library/argparse.html](https://docs.python.org/3/library/argparse.html)。
- en: How to do it…
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this script, we perform the following steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，我们执行以下步骤：
- en: Create positional and optional arguments.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建位置参数和可选参数。
- en: Add descriptions to arguments.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向参数添加描述。
- en: Configure arguments with select choices.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用选择选项配置参数。
- en: How it works…
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: To begin, we import `print_function` and the `argparse` module. By importing
    the `print_function` from the `__future__` library we can write print statements
    as they are written in Python 3.X but still run them in Python 2.X. This allows
    us to make recipes compatible with both Python 2.X and 3.X. Where possible, we
    carry this through with most recipes in the book.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`print_function`和`argparse`模块。通过从`__future__`库导入`print_function`，我们可以像在Python
    3.X中编写打印语句一样编写它们，但仍然在Python 2.X中运行它们。这使我们能够使配方与Python 2.X和3.X兼容。在可能的情况下，我们在本书中的大多数配方中都这样做。
- en: 'After creating a few descriptive variables about the recipe, we initialize
    our `ArgumentParser` instance. Within the constructor, we define the `description`
    and `epilog` keyword arguments. This data will display when the user specifies
    the `-h` argument and can give the user additional context about the script being
    run. The `argparse` library is very flexible and can scale in complexity if required
    for a script. Throughout this book, we cover many of the library''s different
    features, which are detailed on its document page:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建有关配方的一些描述性变量之后，我们初始化了我们的`ArgumentParser`实例。在构造函数中，我们定义了`description`和`epilog`关键字参数。当用户指定`-h`参数时，这些数据将显示，并且可以为用户提供有关正在运行的脚本的额外上下文。`argparse`库非常灵活，如果需要，可以扩展其复杂性。在本书中，我们涵盖了该库的许多不同特性，这些特性在其文档页面上有详细说明：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With the parser instance created, we can now begin adding arguments to our
    command-line handler. There are two types of arguments: positional and optional.
    Positional arguments start with an alphabetic character, unlike optional arguments,
    which start with a dash, and are required to execute the script. Optional arguments
    start with a single or double dash character and are non-positional (that is,
    the order does not matter). These characteristics can be manually specified to
    overwrite the default behavior we’ve described if desired. The following code
    block illustrates how to create two positional arguments:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了解析器实例后，我们现在可以开始向我们的命令行处理程序添加参数。有两种类型的参数：位置参数和可选参数。位置参数以字母开头，与可选参数不同，可选参数以破折号开头，并且需要执行脚本。可选参数以单个或双破折号字符开头，不是位置参数（即，顺序无关紧要）。如果需要，可以手动指定这些特性以覆盖我们描述的默认行为。以下代码块说明了如何创建两个位置参数：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In addition to changing whether an argument is required, we can specify help
    information, create default values, and other actions. The `help` parameter is
    useful in conveying what the user should provide. Other important parameters are
    `default`, `type`, `choices`, and `action`. The `default` parameter allows us
    to set a default value, while `type` converts the type of the input, which is
    a string by default, to the specified Python object type. The `choices` parameter
    uses a defined list, dictionary, or set to create valid options the user can select
    from.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更改参数是否必需，我们还可以指定帮助信息，创建默认值和其他操作。`help`参数有助于传达用户应提供的内容。其他重要参数包括`default`、`type`、`choices`和`action`。`default`参数允许我们设置默认值，而`type`将输入的类型（默认为字符串）转换为指定的Python对象类型。`choices`参数使用定义的列表、字典或集合来创建用户可以选择的有效选项。
- en: 'The `action` parameter specifies the type of action that should be applied
    to a given argument. Some common actions include `store`, which is the default
    and stores the passed value associated with the argument; `store_true`, which
    assigns `True` to the argument; and `version`, which prints the version of the
    code specified by the version parameter:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`action`参数指定应用于给定参数的操作类型。一些常见的操作包括`store`，这是默认操作，用于存储与参数关联的传递值；`store_true`，将`True`分配给参数；以及`version`，打印由版本参数指定的代码版本：'
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With our arguments defined and configured, we can now parse them and use the
    provided inputs in our code. The following snippet shows how we can access the
    values and test whether the user specified an optional argument. Notice how we
    refer to arguments by the name we assign them. If we specify a short and long
    argument name, we must use the long name:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义和配置了我们的参数后，我们现在可以解析它们并在我们的代码中使用提供的输入。以下片段显示了我们如何访问这些值并测试用户是否指定了可选参数。请注意我们如何通过我们分配的名称来引用参数。如果我们指定了短和长的参数名，我们必须使用长名：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When combined into a script and executed at the command line with the `-h`
    argument, the preceding code will provide the following output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当组合成一个脚本并在命令行中使用`-h`参数执行时，上述代码将提供以下输出：
- en: '![](../images/00005.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00005.jpeg)'
- en: 'As seen here, the `-h` flag displays the script help information, automatically
    created by `argparse`, along with the valid options for the `--hash-algorithm`
    argument. We can also use the `-v` option to display the version information.
    The `--script-version` argument displays the version in the same manner as the
    `-v` or `-version` arguments as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，`-h`标志显示了脚本帮助信息，由`argparse`自动生成，以及`--hash-algorithm`参数的有效选项。我们还可以使用`-v`选项来显示版本信息。`--script-version`参数以与`-v`或`-version`参数相同的方式显示版本，如下所示：
- en: '![](../images/00006.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00006.jpeg)'
- en: 'The following screenshot shows the message printed to the console when we select
    one of our valid hashing algorithms:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了当我们选择我们的一个有效的哈希算法时在控制台上打印的消息：
- en: '![](../images/00007.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00007.jpeg)'
- en: There's more…
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This script can be further improved. We have provided a couple of recommendations
    here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。我们在这里提供了一些建议：
- en: Explore additional `argparse` functionality. For example, the `argparse.FileType`
    object can be used to accept a `File` object as an input.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索额外的`argparse`功能。例如，`argparse.FileType`对象可用于接受`File`对象作为输入。
- en: We can also use the `argparse.ArgumentDefaultsHelpFormatter` class to show defaults
    we set to the user. This is helpful when combined with optional arguments to show
    the user what will be used if nothing is specified.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用`argparse.ArgumentDefaultsHelpFormatter`类来显示我们为用户设置的默认值。当与可选参数结合使用时，这对于向用户显示如果没有指定将使用什么是有帮助的。
- en: Iterating over loose files
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代松散的文件
- en: 'Recipe Difficulty: Easy'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 示例难度：简单
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Any'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任何
- en: Often it is necessary to iterate over a directory and its subdirectories to
    recursively process all files. In this recipe, we will illustrate how to use Python
    to walk through directories and access files within them. Understanding how you
    can recursively navigate a given input directory is key as we frequently perform
    this exercise in our scripts.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要迭代一个目录及其子目录以递归处理所有文件。在这个示例中，我们将说明如何使用Python遍历目录并访问其中的文件。了解如何递归地浏览给定的输入目录是关键的，因为我们经常在我们的脚本中执行这个操作。
- en: Getting started
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'All libraries used in this script are present in Python''s standard library.
    The preferred library, in most situations, for handling file and folder iteration
    is the built-in `os` library. While this library supports many useful operations,
    we will focus on the `os.path()` and `os.walk()` functions. Let’s use the following
    folder hierarchy as an example to demonstrate how directory iteration works in
    Python:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本中使用的所有库都包含在Python的标准库中。在大多数情况下，用于处理文件和文件夹迭代的首选库是内置的`os`库。虽然这个库支持许多有用的操作，但我们将专注于`os.path()`和`os.walk()`函数。让我们使用以下文件夹层次结构作为示例来演示Python中的目录迭代是如何工作的：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How to do it…
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following steps are performed in this recipe:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中执行以下步骤：
- en: Create a positional argument for the input directory to scan.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为要扫描的输入目录创建一个位置参数。
- en: Iterate over all subdirectories and print file paths to the console.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有子目录并将文件路径打印到控制台。
- en: How it works…
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We create a very basic argument handler that accepts one positional input,
    `DIR_PATH`, the path of the input directory to iterate. As an example, we will
    use the `~/Desktop` path, the parent of `SecretDocs`, as the input argument for
    the script. We parse the command-line arguments and assign the input directory
    to a local variable. We’re now ready to begin iterating over this input directory:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个非常基本的参数处理程序，接受一个位置输入`DIR_PATH`，即要迭代的输入目录的路径。例如，我们将使用`~/Desktop`路径作为脚本的输入参数，它是`SecretDocs`的父目录。我们解析命令行参数并将输入目录分配给一个本地变量。现在我们准备开始迭代这个输入目录：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To iterate over a directory, we need to provide a string representing its path
    to `os.walk()`. This method returns three objects in each iteration, which we
    have captured in the root, directories, and files variables:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要迭代一个目录，我们需要提供一个表示其路径的字符串给`os.walk()`。这个方法在每次迭代中返回三个对象，我们已经在root、directories和files变量中捕获了这些对象：
- en: '`root`: This value provides the relative path to the current directory as a
    string. Using the example directory structure, root would start as `SecretDocs`
    and eventually become `SecretDocs/Team` and `SecretDocs/Plans/SuccessfulPlans`.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root`：这个值以字符串形式提供了当前目录的相对路径。使用示例目录结构，root将从`SecretDocs`开始，最终变成`SecretDocs/Team`和`SecretDocs/Plans/SuccessfulPlans`。'
- en: '`directories`: This value is a list of sub-directories located within the current
    root location. We can iterate through this list of directories, although the entries
    in this list will become part of the root value during successive `os.walk()`
    calls. For this reason, the value is not frequently used.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`directories`：这个值是当前根目录中的子目录列表。我们可以遍历这个目录列表，尽管在后续的`os.walk()`调用中，这个列表中的条目将成为根值的一部分。因此，这个值并不经常使用。'
- en: '`files`: This value is a list of files in the current root location.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`files`：这个值是当前根位置的文件列表。'
- en: Be careful in naming the directory and file variables. In Python the `dir` and
    `file` names are reserved for other uses and should not be used as variable names.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名目录和文件变量时要小心。在Python中，`dir`和`file`名称被保留用于其他用途，不应该用作变量名。
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It is common to create a second for loop, as shown in the following code, to
    step through each of the files located in that directory and perform some action
    on them. Using the `os.path.join()` method, we can join the root and `file_entry`
    variables to obtain the file’s path. We then print this file path to the console.
    We may also, for example, append this file path to a list that we later iterate
    over to process each of the files:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会创建第二个for循环，如下面的代码所示，以遍历该目录中的每个文件，并对它们执行某些操作。使用`os.path.join()`方法，我们可以将根目录和`file_entry`变量连接起来，以获取文件的路径。然后我们将这个文件路径打印到控制台上。例如，我们还可以将这个文件路径追加到一个列表中，然后对列表进行迭代以处理每个文件：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can also use `root + os.sep() + file_entry` to achieve the same effect, but
    it is not as Pythonic as the method we're using to join paths. Using `os.path.join()`,
    we can pass two or more strings to form a single path, such as directories, subdirectories,
    and files.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`root + os.sep() + file_entry`来实现相同的效果，但这不如我们使用的连接路径的方法那样符合Python的风格。使用`os.path.join()`，我们可以传递两个或更多的字符串来形成单个路径，比如目录、子目录和文件。
- en: 'When we run the preceding script with our example input directory, we see the
    following output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用示例输入目录运行上述脚本时，我们会看到以下输出：
- en: '![](../images/00008.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00008.jpeg)'
- en: As seen, the `os.walk()` method iterates through a directory, then will descend
    into any discovered sub-directories, thereby scanning the entire directory tree.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，`os.walk()`方法遍历目录，然后会进入任何发现的子目录，从而扫描整个目录树。
- en: There's more…
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This script can be further improved. Here''s a recommendation:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。以下是一个建议：
- en: Check out and implement similar functionality using the `glob` library which,
    unlike the `os` module, allows for wildcard pattern recursive searches for files
    and directories
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看并使用`glob`库实现类似功能，与`os`模块不同，它允许对文件和目录进行通配符模式递归搜索
- en: Recording file attributes
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录文件属性
- en: 'Recipe Difficulty: Easy'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 配方难度：简单
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Any'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任何
- en: Now that we can iterate over files and folders, let’s learn to record metadata
    about these objects. File metadata plays an important role in forensics, as collecting
    and reviewing this information is a basic task during most investigations. Using
    a single Python library, we can gather some of the most important attributes of
    files across platforms.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以遍历文件和文件夹，让我们学习如何记录这些对象的元数据。文件元数据在取证中扮演着重要的角色，因为收集和审查这些信息是大多数调查中的基本任务。使用单个Python库，我们可以跨平台收集一些最重要的文件属性。
- en: Getting started
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: All libraries used in this script are present in Python’s standard library.
    The `os` library, once again, can be used here to gather file metadata. One of
    the most helpful methods for gathering file metadata is the `os.stat()` function.
    It's important to note that the `stat()` call only provides information available
    with the current operating system and the filesystem of the mounted volume. Most
    forensic suites allow an examiner to mount a forensic image as a volume on a system
    and generally preserve the `file` attributes available to the stat call. In [Chapter
    8](part0241.html#75QNI0-260f9401d2714cb9ab693c4692308abe), *Working with Forensic
    Evidence Containers Recipes,* we will demonstrate how to open forensic acquisitions
    to directly extract file information.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本中使用的所有库都包含在Python的标准库中。`os`库再次可以在这里用于收集文件元数据。收集文件元数据最有帮助的方法之一是`os.stat()`函数。需要注意的是，`stat()`调用仅提供当前操作系统和挂载卷的文件系统可用的信息。大多数取证套件允许检查员将取证图像挂载为系统上的卷，并通常保留stat调用可用的`file`属性。在[第8章](part0241.html#75QNI0-260f9401d2714cb9ab693c4692308abe)，*使用取证证据容器配方*中，我们将演示如何打开取证获取以直接提取文件信息。
- en: To learn more about the `os` library, visit [https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`os`库的信息，请访问[https://docs.python.org/3/library/os.html](https://docs.python.org/3/library/os.html)。
- en: How to do it…
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will record file attributes using the following steps:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下步骤记录文件属性：
- en: Obtain the input file to process.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取要处理的输入文件。
- en: 'Print various metadata: MAC times, file size, group and owner ID, and so on.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印各种元数据：MAC时间，文件大小，组和所有者ID等。
- en: How it works…
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To begin, we import the required libraries: `argparse` for argument handling,
    `datetime` for interpretation of timestamps, and `os` to access the `stat()` method.
    The `sys` module is used to identify the platform (operating system) the script
    is running on. Next, we create our command-line handler, which accepts one argument,
    `FILE_PATH`, a string representing the path to the file we will extract metadata
    from. We assign this input to a local variable before continuing execution of
    the script:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的库：`argparse`用于处理参数，`datetime`用于解释时间戳，`os`用于访问`stat()`方法。`sys`模块用于识别脚本正在运行的平台（操作系统）。接下来，我们创建我们的命令行处理程序，它接受一个参数`FILE_PATH`，表示我们将从中提取元数据的文件的路径。在继续执行脚本之前，我们将这个输入分配给一个本地变量：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Timestamps are one of the most common file metadata attributes collected. We
    can access the creation, modification, and access timestamps using the `os.stat()`
    method. The timestamps are returned as a float representing the seconds since
    1970-01-01\. Using the `datetime.fromtimestamp()` method, we convert this value
    into a readable format.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳是收集的最常见的文件元数据属性之一。我们可以使用`os.stat()`方法访问创建、修改和访问时间戳。时间戳以表示自1970-01-01以来的秒数的浮点数返回。使用`datetime.fromtimestamp()`方法，我们将这个值转换为可读格式。
- en: The `os.stat()` module interprets timestamps differently depending on the platform.
    For example, the `st_ctime` value on Windows displays the file's creation time,
    while on macOS and UNIX this same attribute displays the last modification of
    the file's metadata, similar to the NTFS entry modified time. This is not the
    only part of `os.stat()` that varies by platform, though the remainder of this
    recipe uses items that are common across platforms.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.stat()`模块根据平台不同而解释时间戳。例如，在Windows上，`st_ctime`值显示文件的创建时间，而在macOS和UNIX上，这个属性显示文件元数据的最后修改时间，类似于NTFS条目的修改时间。然而，`os.stat()`的其余部分在不同平台上是相同的。'
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We continue printing file metadata following the timestamps. The file mode
    and `inode` properties return the file permissions and `inode` as an integer,
    respectively. The device ID refers to the device the file resides on. We can convert
    this integer into major and minor device identifiers using the `os.major()` and
    `os.minor()` methods:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续打印时间戳后的文件元数据。文件模式和`inode`属性分别返回文件权限和整数`inode`。设备ID指的是文件所在的设备。我们可以使用`os.major()`和`os.minor()`方法将这个整数转换为主设备标识符和次设备标识符：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `st_nlink` property returns a count of the number of hard links to the file.
    We can print the owner and group information using the `st_uid` and `st_gid` properties,
    respectively. Lastly, we can gather file size using `st_size`, which returns an
    integer representing the file's size in bytes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`st_nlink`属性返回文件的硬链接数。我们可以分别使用`st_uid`和`st_gid`属性打印所有者和组信息。最后，我们可以使用`st_size`来获取文件大小，它返回一个表示文件大小的整数（以字节为单位）。'
- en: Be aware that if the file is a symbolic link, the `st_size` property reflects
    the length of the path to the target file rather than the target file’s size.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果文件是符号链接，则`st_size`属性反映的是指向目标文件的路径的长度，而不是目标文件的大小。
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'But wait, that’s not all! We can use the `os.path()` module to extract a few
    more pieces of metadata. For example, we can use it to determine whether a file
    is a symbolic link, as shown below with the `os.islink()` method. With this, we
    could alert the user if the `st_size` attribute is not equivalent to the target
    file''s size. The `os.path()` module can also gather the absolute path, check
    whether it exists, and get the parent directory. We can also gather the parent
    directory using the `os.path.dirname()` function or by accessing the first element
    of the `os.path.split()` function. The `split()` method is more commonly used
    to acquire the filename from a path:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，这还不是全部！我们可以使用`os.path()`模块来提取更多的元数据。例如，我们可以使用它来确定文件是否是符号链接，就像下面展示的`os.islink()`方法一样。有了这个，我们可以警告用户，如果`st_size`属性不等于目标文件的大小。`os.path()`模块还可以获取绝对路径，检查它是否存在，并获取父目录。我们还可以使用`os.path.dirname()`函数或访问`os.path.split()`函数的第一个元素来获取父目录。`split()`方法更常用于从路径中获取文件名：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By running the script, we can relevant metadata about the file. Notice how
    the `format()` method allows us to print values without concern for their data
    types. Normally, we would have to convert integers and other data types to strings
    first if we were to try printing the variable directly without string formatting:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行脚本，我们可以获取有关文件的相关元数据。请注意，`format()`方法允许我们打印值，而不必担心它们的数据类型。通常情况下，如果我们直接打印变量而不使用字符串格式化，我们需要先将整数和其他数据类型转换为字符串：
- en: '![](../images/00009.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00009.jpeg)'
- en: There's more…
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This script can be further improved. We have provided a couple of recommendations
    here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。我们在这里提供了一些建议：
- en: Integrate this recipe with the *Iterating over loose files* recipe to recursively
    extract metadata for files in a given series of directories
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这个方法与*遍历松散文件*方法结合起来，递归地提取给定一系列目录中文件的元数据
- en: Implement logic to filter by file extension, date modified, or even file size
    to only collect metadata information on files matching the desired criteria
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现逻辑以按文件扩展名、修改日期或文件大小进行过滤，以仅收集符合所需条件的文件的元数据信息
- en: Copying files, attributes, and timestamps
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制文件、属性和时间戳
- en: 'Recipe Difficulty: Easy'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 方法难度：简单
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Windows'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：Windows
- en: Preserving files is a fundamental task in digital forensics. It is often preferable
    to containerize files in a format that can store hashes and other metadata of
    loose files. However, sometimes we need to copy files in a forensic manner from
    one location to another. Using this recipe, we will demonstrate some of the methods
    available to copy files while preserving common metadata fields.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 保留文件是数字取证中的一项基本任务。通常情况下，最好将文件容器化为可以存储松散文件的哈希和其他元数据的格式。然而，有时我们需要以数字取证的方式从一个位置复制文件到另一个位置。使用这个方法，我们将演示一些可用于复制文件并保留常见元数据字段的方法。
- en: Getting started
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: This recipe requires the installation of two third-party modules `pywin32` and
    `pytz`. All other libraries used in this script are present in Python's standard
    library. This recipe will primarily use two libraries, the built-in `shutil` and
    a third-party library, `pywin32`. The `shutil` library is our go-to for copying
    files within Python, and we can use it to preserve most of the timestamps and
    other file attributes. The `shutil` module, however, is unable to preserve the
    creation time of files it copies. Rather, we must rely on the Windows-specific
    `pywin32` library to preserve it. While the `pywin32` library is platform specific,
    it is incredibly useful to interact with the Windows operating system.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法需要安装两个第三方模块`pywin32`和`pytz`。此脚本中使用的所有其他库都包含在Python的标准库中。这个方法主要使用两个库，内置的`shutil`和第三方库`pywin32`。`shutil`库是我们在Python中复制文件的首选，我们可以使用它来保留大部分时间戳和其他文件属性。然而，`shutil`模块无法保留它复制的文件的创建时间。相反，我们必须依赖于特定于Windows的`pywin32`库来保留它。虽然`pywin32`库是特定于平台的，但它非常有用，可以与Windows操作系统进行交互。
- en: To learn more about the `shutil` library, visit [https://docs.python.org/3/library/shutil.html](https://docs.python.org/3/library/shutil.html).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关`shutil`库的更多信息，请访问[https://docs.python.org/3/library/shutil.html](https://docs.python.org/3/library/shutil.html)。
- en: To install `pywin32`, we need to access its SourceForge page at [https://sourceforge.net/projects/pywin32/](https://sourceforge.net/projects/pywin32/)
    and download the version that matches our Python installation. To check our Python
    version, we can import the `sys` module and call `sys.version` within an interpreter.
    Both the version and the architecture are important when selecting the correct
    `pywin32` installer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`pywin32`，我们需要访问其SourceForge页面[https://sourceforge.net/projects/pywin32/](https://sourceforge.net/projects/pywin32/)并下载与我们的Python安装相匹配的版本。要检查我们的Python版本，我们可以导入`sys`模块并在解释器中调用`sys.version`。在选择正确的`pywin32`安装程序时，版本和架构都很重要。
- en: To learn more about the `sys` library, visit [https://docs.python.org/3/library/sys.html](https://docs.python.org/3/library/sys.html).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关`sys`库的更多信息，请访问[https://docs.python.org/3/library/sys.html](https://docs.python.org/3/library/sys.html)。
- en: 'In addition to the installation of the `pywin32` library, we need to install
    `pytz`, a third-party library used to manage time zones in Python. We can install
    this library using the `pip` command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安装`pywin32`库之外，我们还需要安装`pytz`，这是一个第三方库，用于在Python中管理时区。我们可以使用`pip`命令安装这个库：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How to do it…
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We perform the following steps to forensically copy files on a Windows system:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行以下步骤来在Windows系统上进行取证复制文件：
- en: Gather source file and destination arguments.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集源文件和目标参数。
- en: Use `shutil` to copy and preserve most file metadata.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`shutil`来复制和保留大多数文件元数据。
- en: Manually set timestamp attributes with `win32file`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`win32file`手动设置时间戳属性。
- en: How it works…
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Let’s now dive into copying files and preserving their attributes and timestamps.
    We use some familiar libraries to assist us in the execution of this recipe. Some
    of the libraries, such as `pytz`, `win32file`, and `pywintypes` are new. Let’s
    briefly discuss their purpose here. The `pytz` module allows us to work with time
    zones more granularly and allows us to initialize dates for the `pywin32` library.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入研究复制文件并保留其属性和时间戳。我们使用一些熟悉的库来帮助我们执行这个配方。一些库，如`pytz`，`win32file`和`pywintypes`是新的。让我们在这里简要讨论它们的目的。`pytz`模块允许我们更细致地处理时区，并允许我们为`pywin32`库初始化日期。
- en: 'To allow us to pass timestamps in the correct format, we must also import `pywintypes`.
    Lastly, the `win32file` library, available through our installation of `pywin32`,
    provides various methods and constants for file manipulation in Windows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够以正确的格式传递时间戳，我们还必须导入`pywintypes`。最后，`win32file`库，通过我们安装的`pywin32`提供了在Windows中进行文件操作的各种方法和常量：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This recipe's command-line handler takes two positional arguments, `source`
    and `dest`, which represent the source file to copy and the output directory,
    respectively. This recipe has an optional argument, `timezone`, which allows the
    user to specify a time zone.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的命令行处理程序接受两个位置参数，`source`和`dest`，分别代表要复制的源文件和输出目录。这个配方有一个可选参数`timezone`，允许用户指定一个时区。
- en: 'To prepare the source file, we store the absolute path and split the filename
    from the rest of the path, which we may need to use later if the destination is
    a directory. Our last bit of preparation involves reading the timezone input from
    the user, one of the four common US time zones, and UTC. This allows us to initialize
    the `pytz` time zone object for later use in the recipe:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备源文件，我们存储绝对路径并从路径的其余部分中分离文件名，如果目标是目录，则稍后可能需要使用。我们最后的准备工作涉及从用户那里读取时区输入，这是四个常见的美国时区之一，以及UTC。这使我们能够为后续在配方中使用初始化`pytz`时区对象：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: At this point, we can copy the source file to the destination using the `shutil.copy2()`
    method. This method accepts either a directory or file as the destination. The
    major difference between the `shutil` `copy()` and `copy2()` methods is that the
    `copy2()` method also preserves file attributes, including the last written time
    and permissions. This method does not preserve file creation times on Windows,
    for that we need to leverage the `pywin32` bindings.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以使用`shutil.copy2()`方法将源文件复制到目标。这个方法接受目录或文件作为目标。`shutil` `copy()`和`copy2()`方法之间的主要区别在于`copy2()`方法还保留文件属性，包括最后写入时间和权限。这个方法不会在Windows上保留文件创建时间，为此我们需要利用`pywin32`绑定。
- en: 'To that end, we must build the destination path for the file copied by the
    `copy2()` call by using the following `if` statement to join the correct path
    if the user provided a directory at the command line:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们必须通过使用以下`if`语句构建`copy2()`调用复制的文件的目标路径，以便在命令行提供目录时连接正确的路径：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we prepare the timestamps for the `pywin32` library. We use the `os.path.getctime()`
    methods to gather the respective Windows creation times, and convert the integer
    value into a date using the `datetime.fromtimestamp()` method. With our `datetime`
    object ready, we can make the value time zone-aware by using the specified `timezone`
    and providing it to the `pywintype.Time()` function before printing the timestamps
    to the console:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为`pywin32`库准备时间戳。我们使用`os.path.getctime()`方法收集相应的Windows创建时间，并使用`datetime.fromtimestamp()`方法将整数值转换为日期。有了我们的`datetime`对象准备好了，我们可以通过使用指定的`timezone`使值具有时区意识，并在将时间戳打印到控制台之前将其提供给`pywintype.Time()`函数：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: "With the preparation complete, we can open the file with the `CreateFile()`\
    \ method and pass the string path, representing the copied file, followed by arguments\
    \ specified by the Windows API for accessing the file. Details of these arguments\
    \ and their meanings can be reviewed at [https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx\uFEFF\
    ](https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx):"
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: "准备工作完成后，我们可以使用`CreateFile()`方法打开文件，并传递表示复制文件的字符串路径，然后是由Windows API指定的用于访问文件的参数。这些参数及其含义的详细信息可以在[https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx\uFEFF\
    ](https://msdn.microsoft.com/en-us/library/windows/desktop/aa363858(v=vs.85).aspx)上进行查看："
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once we have an open file handle, we can call the `SetFileTime()` function
    to update, in order, the file''s created, accessed, and modified timestamps. With
    the destination file''s timestamps set, we need to close the file handle using
    the `CloseHandle()` method. To confirm to the user that the copying of the file''s
    timestamps was successful, we print the destination file''s created, modified,
    and accessed times:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个打开的文件句柄，我们可以调用`SetFileTime()`函数按顺序更新文件的创建、访问和修改时间戳。设置了目标文件的时间戳后，我们需要使用`CloseHandle()`方法关闭文件句柄。为了向用户确认文件时间戳的复制成功，我们打印目标文件的创建、修改和访问时间：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The script output shows copying a file from the source to the destination with
    timestamps successfully preserved:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本输出显示了成功保留时间戳的文件从源复制到目标的过程：
- en: '![](../images/00010.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00010.jpeg)'
- en: There's more…
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'This script can be further improved. We have provided a couple of recommendations
    here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。我们在这里提供了一些建议：
- en: Hash the source and destination files to ensure they were copied successfully.
    Hashing files are introduced in the hashing files and data streams recipe in the
    next section.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对源文件和目标文件进行哈希处理，以确保它们被成功复制。哈希处理在下一节的文件和数据流哈希处理配方中介绍。
- en: Output a log of the files copied and any exceptions encountered during the copying
    process.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出文件复制的日志以及在复制过程中遇到的任何异常。
- en: Hashing files and data streams
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对文件和数据流进行哈希处理
- en: 'Recipe Difficulty: Easy'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 配方难度：简单
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Any'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任意
- en: File hashes are a widely accepted identifier for determining file integrity
    and authenticity. While some algorithms have become vulnerable to collision attacks,
    the process is still important in the field. In this recipe, we will cover the
    process of hashing a string of characters and a stream of file content.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 文件哈希是确定文件完整性和真实性的广泛接受的标识符。虽然一些算法已经容易受到碰撞攻击，但这个过程在这个领域仍然很重要。在这个配方中，我们将介绍对一串字符和文件内容流进行哈希处理的过程。
- en: Getting started
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: All libraries used in this script are present in Python’s standard library.
    For generating hashes of files and other data sources, we implement the `hashlib`
    library. This built-in library has support for common algorithms, such as MD5,
    SHA-1, SHA-256, and more. As of the writing of this book, many tools still leverage
    the MD5 and SHA-1 algorithms, though the current recommendation is to use SHA-256
    at a minimum. Alternatively, one could use multiple hashes of a file to further
    decrease the odds of a hash collision. While we'll showcase a few of these algorithms,
    there are other, less commonly used, algorithms available.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本中使用的所有库都包含在Python的标准库中。为了生成文件和其他数据源的哈希值，我们实现了`hashlib`库。这个内置库支持常见的算法，如MD5、SHA-1、SHA-256等。在撰写本书时，许多工具仍然利用MD5和SHA-1算法，尽管当前的建议是至少使用SHA-256。或者，可以使用文件的多个哈希值来进一步减少哈希冲突的几率。虽然我们将展示其中一些算法，但还有其他不常用的算法可供选择。
- en: To learn more about the `hashlib` library, visit [https://docs.python.org/3/library/hashlib.html](https://docs.python.org/3/library/hashlib.html).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关`hashlib`库的更多信息，请访问[https://docs.python.org/3/library/hashlib.html](https://docs.python.org/3/library/hashlib.html)。
- en: How to do it…
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We hash files with the following steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下步骤对文件进行哈希处理：
- en: Print hashed filename using the specified input file and algorithm.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指定的输入文件和算法打印哈希文件名。
- en: Print hashed file data using the specified input file and algorithm.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指定的输入文件和算法打印哈希文件数据。
- en: How it works…
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'To begin, we must import `hashlib` as shown in the following. For ease of use,
    we have defined a dictionary of algorithms that our script can use: `MD5`, `SHA-1`,
    `SHA-256` and `SHA-512`. By updating this dictionary, we can support other hash
    functions that have `update()` and `hexdigest()` methods, including some from
    libraries other than `hashlib`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须像下面所示导入`hashlib`。为了方便使用，我们已经定义了一个算法字典，我们的脚本可以使用`MD5`、`SHA-1`、`SHA-256`和`SHA-512`。通过更新这个字典，我们可以支持其他具有`update()`和`hexdigest()`方法的哈希函数，包括一些不属于`hashlib`库的库中的函数：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how we define our hashing algorithm object using our dictionary and the
    argument provided at the command line, followed by open and close parentheses
    to initiate the object. This provides additional flexibility when adding new hashing
    algorithms.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用字典和命令行提供的参数来定义我们的哈希算法对象，然后使用括号来初始化对象。这在添加新的哈希算法时提供了额外的灵活性。
- en: 'With our hash algorithms defined, we now can hash the file''s absolute path,
    a similar method employed during file naming for iTunes backups of an iOS device,
    by passing the string into the `update()` method. When we are ready to display
    the hex value of the calculated hash, we can call the `hexdigest()` method on
    our `file_name` object:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了我们的哈希算法后，我们现在可以对文件的绝对路径进行哈希处理，这是在为iOS设备的iTunes备份命名文件时使用的类似方法，通过将字符串传递到`update()`方法中。当我们准备显示计算出的哈希的十六进制值时，我们可以在我们的`file_name`对象上调用`hexdigest()`方法：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's move onto opening the file and hashing its contents. While we can read
    the entire file and pass it to the `hash` function, not all files are small enough
    to fit in memory. To ensure our code works on larger files, we will use the technique
    in the following example to read a file in a piecemeal fashion and hash it in
    chunks.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续打开文件并对其内容进行哈希处理。虽然我们可以读取整个文件并将其传递给 `hash` 函数，但并非所有文件都足够小以适应内存。为了确保我们的代码适用于更大的文件，我们将使用以下示例中的技术以分段方式读取文件并以块的方式进行哈希处理。
- en: By opening the file as `rb`, we will ensure that we are reading the binary contents
    of the file, not the string content that may exist. With the file open, we will
    define the buffer size to read in content and then read the first chunk of data
    in.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以 `rb` 打开文件，我们将确保读取文件的二进制内容，而不是可能存在的字符串内容。打开文件后，我们将定义缓冲区大小以读取内容，然后读取第一块数据。
- en: Entering a while loop, we will update our hashing object with the new content
    for as long as there is content in the file. This is possible as the `read()`
    method allows us to pass an integer of the number of bytes to read and, if the
    integer is larger than the number of bytes remaining in the file, will simply
    pass us the remaining bytes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 while 循环，我们将根据文件中的内容更新我们的哈希对象。只要文件中有内容，这是可能的，因为 `read()` 方法允许我们传递一个要读取的字节数的整数，如果整数大于文件中剩余的字节数，它将简单地传递给我们剩余的字节。
- en: 'Once the entire file is read, we call the `hexdigest()` method of our object
    to display the file hash to the examiner:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 读取整个文件后，我们调用对象的 `hexdigest()` 方法来向检查员显示文件哈希：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When we execute the code, we see the output from the two print statements revealing
    the hash value of the file''s absolute path and content. We can generate additional
    hashes for the file by changing the algorithm at the command line:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行代码时，我们会看到两个打印语句的输出，显示文件的绝对路径和内容的哈希值。我们可以通过在命令行中更改算法来为文件生成额外的哈希：
- en: '![](../images/00011.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00011.jpeg)'
- en: There's more…
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'This script can be further improved. Here''s a recommendation:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。以下是一个建议：
- en: Add support for additional hashing algorithms and create the appropriate entry
    within the `available_algorithms` global variable
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加对其他哈希算法的支持，并在 `available_algorithms` 全局变量中创建相应的条目
- en: Keeping track with a progress bar
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用进度条进行跟踪
- en: 'Recipe Difficulty: Easy'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 示例难度：简单
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Python 版本：2.7 或 3.5
- en: 'Operating System: Any'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任何
- en: Long-running scripts are unfortunately commonplace when processing data measured
    in gigabytes or terabytes. While your script may be processing this data smoothly,
    a user may think it's frozen after three hours with no indication of progress.
    Luckily, several developers have built an incredibly simple progress bar library,
    giving us little excuse for not incorporating this into our code.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，处理以千兆字节或兆字节为单位的数据时，长时间运行的脚本是司空见惯的。虽然您的脚本可能在顺利处理这些数据，但用户可能会认为它在三个小时后没有任何进展的情况下已经冻结。幸运的是，一些开发人员构建了一个非常简单的进度条库，让我们没有理由不将其纳入我们的代码中。
- en: Getting started
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'This recipe requires the installation of the third-party module `tqdm`. All
    other libraries used in this script are present in Python''s standard library.
    The `tqdm` library, pronounced taqadum, can be installed via `pip` or downloaded
    from GitHub at [https://github.com/tqdm/tqdm](https://github.com/tqdm/tqdm). To
    use all of the features shown in this recipe, ensure you are using release 4.11.2,
    available on the `tqdm` GitHub page or with `pip` using the following command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例需要安装第三方模块 `tqdm`。此脚本中使用的所有其他库都包含在 Python 的标准库中。`tqdm` 库，发音为 taqadum，可以通过
    `pip` 安装或从 GitHub 下载 [https://github.com/tqdm/tqdm](https://github.com/tqdm/tqdm)。要使用本示例中显示的所有功能，请确保您使用的是
    4.11.2 版本，在 `tqdm` GitHub 页面上或使用以下命令通过 `pip` 获取：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How to do it…
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To create a simple progress bar, we follow these steps:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个简单的进度条，我们按照以下步骤进行：
- en: Import `tqdm` and `time`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `tqdm` 和 `time`。
- en: Create multiple examples with `tqdm` and loops.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `tqdm` 和循环创建多个示例。
- en: How it works…
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'As with all other recipes, we begin with the imports. While we only need the
    `tqdm` import to enable the progress bars, we will use the time module to slow
    down our script to better visualize the progress bar. We use a list of fruits
    as our sample data and identify which fruits containing "berry" or "berries" in
    their name:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有其他示例一样，我们从导入开始。虽然我们只需要 `tqdm` 导入来启用进度条，但我们将使用时间模块来减慢脚本的速度，以更好地可视化进度条。我们使用水果列表作为我们的样本数据，并确定哪些水果的名称中包含
    "berry" 或 "berries"：
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The following for loop is very straightforward and iterates through our list
    of fruits, checking for the substring `berr` is within the fruit's name before
    sleeping for one-tenth of a second. By wrapping the `tqdm()` method around the
    iterator, we automatically have a nice-looking progress bar giving us the percentage
    complete, elapsed time, remaining time, the number of iterations complete, and
    total iterations.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的 for 循环非常简单，遍历我们的水果列表，在休眠一秒钟之前检查水果名称中是否包含子字符串 `berr`。通过在迭代器周围包装 `tqdm()`
    方法，我们自动获得一个漂亮的进度条，显示完成百分比、已用时间、剩余时间、完成的迭代次数和总迭代次数。
- en: 'These display options are the defaults for `tqdm` and gather all of the necessary
    information using properties of our list object. For example, the library knows
    almost all of these details for the progress bar just by gathering the length
    and calculating the rest based on the amount of time per iteration and the number
    elapsed:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些显示选项是 `tqdm` 的默认选项，并且使用我们的列表对象的属性收集所有必要的信息。例如，该库几乎可以通过收集长度并根据每次迭代的时间和已经过的数量来计算其余部分，从而了解进度条的几乎所有细节：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Extending the progress bar beyond the default configuration is as easy as specifying
    keyword arguments. The progress bar object can also be created prior to the start
    of the loop and using the list object, `fruits`, as the iterable argument. The
    following code exhibits how we can define our progress bar with our list, a description,
    and providing the unit name.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定关键字参数，可以轻松地扩展默认配置以超出进度条。进度条对象也可以在循环开始之前创建，并使用列表对象`fruits`作为可迭代参数。以下代码展示了如何使用列表、描述和提供单位名称定义我们的进度条。
- en: If we were not using a list but another iterator type that does not have a `__len__`
    attribute defined, we would need to manually supply a total with the `total` keyword.
    Only basic statistics about elapsed time and iterations per second display if
    the total number of iterations is unavailable.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不是使用列表，而是使用另一种迭代器类型，该类型没有定义`__len__`属性，我们将需要手动使用`total`关键字提供总数。如果迭代的总数不可用，将仅显示有关经过的时间和每秒迭代次数的基本统计信息。
- en: 'Once we are in the loop, we can display the number of results discovered using
    the `set_postfix()` method. Each iteration will provide an update of the number
    of hits we have found to the right of the progress bar:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进入循环，我们可以使用`set_postfix()`方法显示发现的结果数量。每次迭代都会在进度条右侧提供我们找到的命中数量的更新：
- en: '[PRE26]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'One other common use case for progress bars is to measure execution in a range
    of integers. Since this is a common use of the library the developers built a
    range call into the library, called `trange()`. Notice how we can specify the
    same arguments here as before. One new argument that we will use here, due to
    the larger numbers, is the `unit_scale` argument, which simplifies large numbers
    into a small number with a letter to designate the magnitude:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 进度条的另一个常见用途是在一系列整数中测量执行。由于这是该库的常见用法，开发人员在库中构建了一个称为`trange()`的范围调用。请注意，我们可以在这里指定与之前相同的参数。由于数字较大，我们将在此处使用一个新参数`unit_scale`，它将大数字简化为一个带有字母表示数量的小数字：
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When we execute the code, the following output is visible. Our first progress
    bar displays the default format, while the second and third show the customizations
    we have added:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行代码时，将显示以下输出。我们的第一个进度条显示默认格式，而第二个和第三个显示了我们添加的自定义内容：
- en: '![](../images/00012.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00012.jpeg)'
- en: There's more…
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'This script can be further improved. Here''s a recommendation:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。以下是一个建议：
- en: Further explore the capabilities the `tqdm` library affords developers. Consider
    using the `tqdm.write()` method to print status messages without breaking the
    progress bar.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步探索`tqdm`库为开发人员提供的功能。考虑使用`tqdm.write()`方法在不中断进度条的情况下打印状态消息。
- en: Logging results
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录结果
- en: 'Recipe Difficulty: Easy'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱难度：简单
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Any'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任何
- en: Outside of progress bars, we generally need to provide messages to the user
    to describe any exceptions, errors, warnings, or other information that has occurred
    during execution. With logging, we can provide this information at execution and
    in a text file for future reference.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 进度条之外，我们通常需要向用户提供消息，描述执行过程中发生的任何异常、错误、警告或其他信息。通过日志记录，我们可以在执行过程中提供这些信息，并在文本文件中供将来参考。
- en: Getting started
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: All libraries used in this script are present in Python’s standard library.
    This recipe will use the built-in `logging` library to generate status messages
    to the console and a text file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本中使用的所有库都包含在Python的标准库中。本食谱将使用内置的`logging`库向控制台和文本文件生成状态消息。
- en: To learn more about the `logging` library, visit [https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`logging`库的信息，请访问[https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html)。
- en: How to do it…
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following steps can be used to effectively log program execution data:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤可用于有效记录程序执行数据：
- en: Create a log formatting string.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建日志格式化字符串。
- en: Log various message types during script execution.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本执行期间记录各种消息类型。
- en: How it works…
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Let''s now learn to log results. After our imports, we create our `logger`
    object by initializing an instance using the script''s name represented by the
    `__file__` attribute. With our `logging` object initiated, we will set the level
    and specify various formatters and handlers for this script. The formatters provide
    the flexibility to define what fields will be displayed for each message, including
    timestamps, function name, and the message level. The format strings follow the
    standards of Python string formatting, meaning we can specify padding for the
    following strings:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们学习记录结果。在导入之后，我们通过使用`__file__`属性表示的脚本名称初始化一个实例来创建我们的`logger`对象。通过初始化`logging`对象，我们将为此脚本设置级别并指定各种格式化程序和处理程序。格式化程序提供了灵活性，可以定义每条消息显示哪些字段，包括时间戳、函数名称和消息级别。格式化字符串遵循Python字符串格式化的标准，这意味着我们可以为以下字符串指定填充：
- en: '[PRE28]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The handlers allow us to specify where the log message should be recorded,
    including a log file, standard output (console), or standard error. In the following
    example, we use the standard output for our stream handler and the script''s name
    with the `.log` extension for the file handler. Lastly, we register these handlers
    with our logger object:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序允许我们指定日志消息应记录在哪里，包括日志文件、标准输出（控制台）或标准错误。在下面的示例中，我们使用标准输出作为我们的流处理程序，并使用脚本名称加上`.log`扩展名作为文件处理程序。最后，我们将这些处理程序注册到我们的记录器对象中：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The logging library by default uses the following levels in increasing order
    of severity: `NOTSET`, `DEBUG`, `INFORMATION`, `WARNING`, `ERROR`, and `CRITICAL`.
    To showcase some of the features of the format string, we will log a few types
    of messages from functions:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 日志库默认使用以下级别，按严重性递增：`NOTSET`、`DEBUG`、`INFORMATION`、`WARNING`、`ERROR`和`CRITICAL`。为了展示格式字符串的一些特性，我们将从函数中记录几种类型的消息：
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When we execute this code, we can see the following message information from
    the invocation of the script. Inspection of the generated log file matches what
    was recorded in the console:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行此代码时，我们可以看到从脚本调用中获得的以下消息信息。检查生成的日志文件与在控制台中记录的内容相匹配：
- en: '![](../images/00013.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00013.jpeg)'
- en: There’s more…
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This script can be further improved. Here''s a recommendation:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。这是一个建议：
- en: It is often important to provide as much information as possible to the user
    in the event of an error in the script or for a user's validation of the process.
    Therefore, we recommend implementing additional formatters and logging levels.
    Using the `stderr` stream is best practice for logging, as we can provide the
    output at the console while not disrupting `stdout`.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在脚本出现错误或用户验证过程时，提供尽可能多的信息通常很重要。因此，我们建议实施额外的格式化程序和日志级别。使用`stderr`流是记录的最佳实践，因为我们可以在控制台上提供输出，而不会中断`stdout`。
- en: Multiple hands make light work
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多人成群，事情好办
- en: 'Recipe Difficulty: Medium'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱难度：中等
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Any'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任何
- en: While Python is known for being single threaded, we can use built-in libraries
    to spin up new processes to handle tasks. Generally, this is preferred when there
    are a series of tasks that can be run simultaneously and the processing is not
    already bound by hardware limits, such as network bandwidth or disk speed.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python以单线程闻名，但我们可以使用内置库来启动新进程来处理任务。通常，当有一系列可以同时运行的任务并且处理尚未受到硬件限制时，这是首选，例如网络带宽或磁盘速度。
- en: Getting started
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: All libraries used in this script are present in Python’s standard library.
    Using the built-in `multiprocessing` library, we can handle the majority of situations
    where we would need multiple processes to efficiently tackle a problem.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本中使用的所有库都包含在Python的标准库中。使用内置的`multiprocessing`库，我们可以处理大多数需要多个进程有效地解决问题的情况。
- en: To learn more about the `multiprocessing` library, visit [https://docs.python.org/3/library/multiprocessing.html](https://docs.python.org/3/library/multiprocessing.html).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关`multiprocessing`库的更多信息，请访问[https://docs.python.org/3/library/multiprocessing.html](https://docs.python.org/3/library/multiprocessing.html)。
- en: How to do it…
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'With the following steps, we showcase basic multiprocessing support in Python:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤，我们展示了Python中的基本多进程支持：
- en: Set up a log to record `multiprocessing` activity.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置日志以记录`multiprocessing`活动。
- en: Append data to a list using `multiprocessing`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`multiprocessing`将数据附加到列表。
- en: How it works…
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s now look at how we can achieve multiprocessing in Python. Our imports
    include the `multiprocessing` library, shortened to `mp`, as it is quite lengthy
    otherwise; the `logging` and `sys` libraries for thread status messages; the `time`
    library to slow down execution for our example; and the `randint` method to generate
    times that each thread should wait for:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在Python中实现多进程。我们导入了`multiprocessing`库，缩写为`mp`，因为它太长了；`logging`和`sys`库用于线程状态消息；`time`库用于减慢我们示例的执行速度；`randint`方法用于生成每个线程应等待的时间：
- en: '[PRE31]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Before creating our processes, we set up a function that they will execute.
    This is where we put the task each process should execute before returning to
    the main thread. In this case, we take a number of seconds for the thread to sleep
    as our only argument. To print a status message that allows us to differentiate
    between the processes, we use the `current_process()` method to access the name
    property for each thread:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建进程之前，我们设置一个函数，它们将执行。这是我们在返回主线程之前应该执行的每个进程的任务。在这种情况下，我们将线程睡眠的秒数作为唯一参数。为了打印允许我们区分进程的状态消息，我们使用`current_process()`方法访问每个线程的名称属性：
- en: '[PRE32]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With our worker function defined, we create our `logger` instance, borrowing
    code from the previous recipe, and set it to only record to the console.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了我们的工作函数后，我们创建了我们的`logger`实例，从上一个食谱中借用代码，并将其设置为仅记录到控制台。
- en: '[PRE33]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We now define the number of workers we want to spawn and create them in a for
    loop. Using this technique, we can easily adjust the number of processes we have
    running. Inside of our loop, we define each `worker` using the `Process` class
    and set our target function and the required arguments. Once the process instance
    is defined, we start it and append the object to a list for later use:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义要生成的工作人员数量，并在for循环中创建它们。使用这种技术，我们可以轻松调整正在运行的进程数量。在我们的循环内，我们使用`Process`类定义每个`worker`，并设置我们的目标函数和所需的参数。一旦定义了进程实例，我们就启动它并将对象附加到列表以供以后使用：
- en: '[PRE34]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'By appending the `workers` to a list, we can join them in sequential order.
    Joining, in this context, is the process of waiting for a process to complete
    before execution continues. If we do not join our process, one of them could continue
    to the end of the script and complete the code before other processes complete.
    While that wouldn''t cause huge problems in our example, it can cause the next
    snippet of code to start too early:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`workers`附加到列表中，我们可以按顺序加入它们。在这种情况下，加入是指在执行继续之前等待进程完成的过程。如果我们不加入我们的进程，其中一个进程可能会在脚本的末尾继续并在其他进程完成之前完成代码。虽然这在我们的示例中不会造成很大问题，但它可能会导致下一段代码过早开始：
- en: '[PRE35]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When we execute the script, we can see the processes start and join over time.
    Since we stored these items in a list, they will join in an ordered fashion, regardless
    of the time it takes for one worker to finish. This is visible below as `Process-5`
    slept for 14 seconds before completing, and meanwhile, `Process-4` and `Process-3`
    had already completed:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行脚本时，我们可以看到进程随着时间的推移开始和加入。由于我们将这些项目存储在列表中，它们将以有序的方式加入，而不管一个工作人员完成需要多长时间。这在下面可见，因为`Process-5`在完成之前睡了14秒，与此同时，`Process-4`和`Process-3`已经完成：
- en: '![](../images/00014.jpeg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00014.jpeg)'
- en: There's more…
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This script can be further improved. We have provided a recommendation here:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。我们在这里提供了一个建议：
- en: "Rather than using function arguments to pass data between threads, review pipes\
    \ and queues as alternatives to sharing data. Additional information about these\
    \ objects can be found at [https://docs.python.org/3/library/multiprocessing.html#exchanging-objects-between-processes](https://docs.python.org/3/library/multiprocessing.html#exchanging-objects-between-processes.).[\uFEFF\
    ](https://docs.python.org/3/library/multiprocessing.html#exchanging-objects-between-processes.)"
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: "与使用函数参数在线程之间传递数据不同，可以考虑使用管道和队列作为共享数据的替代方法。关于这些对象的更多信息可以在[https://docs.python.org/3/library/multiprocessing.html#exchanging-objects-between-processes](https://docs.python.org/3/library/multiprocessing.html#exchanging-objects-between-processes.)找到。[\uFEFF\
    ](https://docs.python.org/3/library/multiprocessing.html#exchanging-objects-between-processes.)"
