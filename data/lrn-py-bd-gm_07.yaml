- en: List Comprehension and Properties
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表推导和属性
- en: '*Necessity is the Mother of Invention* is a popular English proverb which means
    that any pioneer ideas that have been invented so far or will be invented are
    because of their need. For instance, the giant video hosting platform YouTube
    became popular not only because of its business model but also because of the
    time it was introduced. Many creative artists such as video editors, singers,
    dancers, and gamers wanted the platform to be recognized globally without any
    initial investments, and audiences wanted a platform where they could learn and
    be entertained free of charge. Thus, the need is the driving force for any new
    invention. However, this doesn''t mean that every revolutionary idea that was
    created at the right time succeeded. Some of them have failed miserably because
    they didn''t address the limitations that were posed by the technology. Our quixotic
    imagination is fettered by these technologies, and, although we have been progressing,
    we are not there yet.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “需要是发明之母”是一句流行的英语谚语，意思是迄今为止或将来发明的任何先驱性想法都是因为它们的需要。例如，巨大的视频托管平台YouTube之所以受欢迎，不仅是因为其商业模式，还因为它的推出时间。许多创意艺术家，如视频编辑者、歌手、舞者和游戏玩家，希望该平台能在全球范围内得到认可，而观众希望有一个可以免费学习和娱乐的平台。因此，需求是任何新发明的推动力。然而，这并不意味着每一个在正确时间创造的革命性想法都会成功。其中一些因为没有解决技术所带来的限制而失败。我们的异想天开受到这些技术的限制，尽管我们一直在进步，但我们还没有到达那里。
- en: Thus, in order to make any revolutionary ideas successful, we have to know our
    limitations. Our primary limitations are memory space and processing power. Taking
    care of these limitations, this chapter will teach us to write an elegant program
    that will save memory storage and running time to some extent. We will learn about
    the comprehension and generation that are provided by Python. They will make the
    program run faster while maintaining its readability.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使任何革命性的想法成功，我们必须了解我们的限制。我们的主要限制是内存空间和处理能力。在处理这些限制的同时，本章将教会我们编写一个优雅的程序，可以在一定程度上节省内存存储和运行时间。我们将学习Python提供的理解和生成，它们将使程序在保持可读性的同时运行得更快。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Overview of code complexities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码复杂性概述
- en: For loop versus list comprehension
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环与列表推导的比较
- en: Decorators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: Python property
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python属性
- en: Refining the snake game with LC and property
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LC和属性完善贪吃蛇游戏
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following requirements to complete this chapter:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要满足以下要求才能完成本章：
- en: Python version 3.5 or newer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.5或更新版本
- en: Python IDLE (Python's built-in IDE)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python IDLE（Python的内置IDE）
- en: A text editor
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本编辑器
- en: A web browser
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络浏览器
- en: The files for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter07](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter07)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的文件可以在本书的GitHub存储库中找到：[https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter07](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter07)
- en: 'Check out the following video to see the code in action:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的运行情况：
- en: '[http://bit.ly/2pzX8Au](http://bit.ly/2pzX8Au)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2pzX8Au](http://bit.ly/2pzX8Au)'
- en: Overview of code complexities
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码复杂性概述
- en: So far, we have been learning about the basics of Python, such as functions,
    data structures, and object-oriented programming. Now, we are able to create our
    own logic and even program some games too. As we continue to add features for
    these games, we are expected to have millions of lines of code. Those huge **lines
    of code** (**LOC**) will be hard to understand, interpret, and process. For example,
    in some cases, we may have to make a trade-off between code maintainability and
    optimization. Let's suppose you maintain the code for a shopping website and one
    day you got millions of hits on your website, which is beyond the processing speed
    of your server. Now, you have to accommodate a situation in which you must either
    serve the page without a delay and give the customers no proper recommendations
    about products or serve the page with little delay and give proper recommendations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在学习Python的基础知识，如函数、数据结构和面向对象编程。现在，我们能够创建自己的逻辑，甚至编写一些游戏。随着我们继续为这些游戏添加功能，我们预计会有数百万行代码。这些庞大的代码行（LOC）将很难理解、解释和处理。例如，在某些情况下，我们可能需要在代码可维护性和优化之间进行权衡。假设您维护一个购物网站的代码，有一天您的网站被数百万次点击，这超出了服务器的处理速度。现在，您必须适应这样一种情况，即您必须要么在没有延迟的情况下为客户提供没有适当产品推荐的页面，要么在稍有延迟的情况下为客户提供适当的推荐。
- en: On the other hand, we may want to achieve some amount of code optimization.
    If any program takes seconds to execute, then after optimization, we may want
    to run it within a millisecond. Now, we may think this time is negligible, which
    it is on the first run. However, when we have to run the same program a thousand
    times, we may cut off some seconds and this could be potentially useful for any
    real-time applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可能希望实现一定程度的代码优化。如果某个程序需要几秒钟才能执行，那么优化后，我们可能希望在一毫秒内运行它。现在，我们可能认为这段时间微不足道，但在第一次运行时确实如此。然而，当我们不得不运行相同的程序一千次时，我们可能会节省一些时间，这对于任何实时应用可能是有用的。
- en: In this chapter, we will focus on the ways we can modify our code to improve
    its quality and efficiency. Any original program can be said to have been optimized
    if we managed to make its code shorter, reduce memory consumption and increase
    its execution speed and the interaction of fewer input/output instructions. The
    basic canonization followed by optimization is that the outcome of the optimization
    must have the same output and consequences as that of the non-optimized one.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于修改我们的代码以提高其质量和效率的方法。如果我们设法使原始程序的代码更短，减少内存消耗并增加其执行速度，并减少输入/输出指令的交互，那么可以说任何原始程序都已经被优化了。优化的基本规则是，优化的结果必须与非优化的结果具有相同的输出和后果。
- en: However, these requirements may be insignificant whenever the achieved optimized
    program has favorable results over the non-optimized one in terms of time and
    space complexities. For example, in the rocket-launch activities, we may want
    the real-time data of the surrounding area while trading for the accuracy of the
    data. Thus, optimization is important in such cases even though it might affect
    the system's output in one way or another.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当优化后的程序在时间和空间复杂性方面比非优化程序有利的结果时，这些要求可能是微不足道的。例如，在火箭发射活动中，我们可能希望获得周围区域的实时数据，而不在乎数据的准确性。因此，即使优化可能以某种方式影响系统的输出，但在这种情况下优化是重要的。
- en: 'Before we learn about optimization, we will look at the necessity for it. In
    order to check the room for optimization, we have to analyze the code first, and
    the prime way to analyze it is by using complexity analysis. Algorithm complexity
    analysis is a tool that will explain the behavior of the program as the size of
    the program increases. The size increases when input to the program increases.
    Thus, we have to check the program against the mathematical `f(n)` function, where
    *n* represents the input to the programs. Now, you may be wondering whether running
    this algorithm may cause a difference in time units, depending on the different
    computers that are used by companies such as NASA or Apple Inc. as they will have
    higher processing power than our simple computer. Therefore, it might be an injustice
    to judge the algorithm that is running on our PC. If you''re ever faced with such
    ambiguity, just pat on yourself on the back as you are thinking like a programmer.
    To test whether the algorithm is independent of processing speed, disk power,
    and powerful software, scientists have developed something called symptotic analysis.
    This analysis will check the algorithm against the size of the input and without
    recording the time it took to execute it. We call this **time complexity**, and
    it allows us to check how the algorithm runs with respect to the size of the input
    data. To observe the time complexity of the algorithm, the best and well-known
    notation we should use is Big-Oh notation. This notation will help us analyze
    the worst-case scenario of the algorithm and help us optimize it. Let''s analyze
    the following complexities using some simple examples:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习优化之前，我们将先看看它的必要性。为了检查优化的空间，我们必须首先分析代码，而分析代码的主要方法是使用复杂性分析。算法复杂性分析是一个工具，它将解释程序随着程序大小的增加而表现的行为。当输入到程序中增加时，程序的大小也会增加。因此，我们必须根据数学`f(n)`函数来检查程序，其中*n*代表程序的输入。现在，你可能会想知道，运行这个算法是否会导致时间单位的差异，这取决于诸如NASA或苹果公司等公司使用的不同计算机，它们的处理能力比我们的简单计算机要高。因此，对我们的PC上运行的算法进行评判可能是不公平的。如果你曾经面对这种模棱两可的情况，那么恭喜你，因为你正在像程序员一样思考。为了测试算法是否独立于处理速度、磁盘能力和强大的软件，科学家们开发了一种称为渐近分析的东西。这种分析将检查算法与输入的大小，并且不记录执行所需的时间。我们称之为**时间复杂度**，它允许我们检查算法在输入数据大小方面的运行情况。为了观察算法的时间复杂度，我们应该使用最好和最知名的符号，即大O符号。这个符号将帮助我们分析算法的最坏情况，并帮助我们优化它。让我们使用一些简单的例子来分析以下复杂性：
- en: '`O(1)`: This notation is used to define the algorithms that are independent
    of input size. Increasing or decreasing any sets of data from the input might
    not affect the execution speed of the algorithm:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O(1)`: 这个符号用来定义与输入大小无关的算法。增加或减少输入数据的任何集合可能不会影响算法的执行速度：'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding program is going to print the first element of the array, no matter
    what data is in it. Thus, it has a time complexity of `O(1)`. This is considered
    a best-case scenario and is hard to achieve in a real-life scenario.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序将打印数组的第一个元素，无论其中的数据是什么。因此，它的时间复杂度为`O(1)`。这被认为是最佳情况，很难在现实情况中实现。
- en: '`O(n)`: This notation describes the algorithm that will have a linear increase
    in running time as the size of the input data, `(n)`, increases. For example,
    in the following program, the worst-case scenario may lead us to iterate over
    the whole list. Thus, performance depends on the size of the input:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O(n)`: 这个符号描述了随着输入数据的大小`(n)`的增加，算法的运行时间将呈线性增加。例如，在下面的程序中，最坏情况可能导致我们遍历整个列表。因此，性能取决于输入的大小：'
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`O(n²)`: This notation specifies the performance of algorithms, which is proportional
    to the square size of the input data. It is highly common in nested loops.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O(n²)`: 这个符号指定了与输入数据的平方大小成正比的算法的性能。在嵌套循环中非常常见。'
- en: There are a few more notations, such as `O(2^N)` and `O(log N)`, but we don't
    need to go any further as we have already learned enough so that we can differentiate
    between good and bad code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他符号，比如`O(2^N)`和`O(log N)`，但我们不需要再深入了解，因为我们已经学到足够多，可以区分好的代码和坏的代码。
- en: 'Now that we have gained enough information about optimization and the way we
    can analyze algorithms, it''s time to look at some examples to clarify the differences
    between non-optimized and optimized code. Before diving into the algorithmic analysis
    of the following code, we will learn how to analyze the complexities of the programs.
    Since this book is not going to teach advanced algorithmic concepts, we will take
    a look at the basic ideas to evaluate performance and optimization. This will
    provide you with a tool that will help you write programs that are shorter, readable,
    and don''t waste memory resources. Thus, this practice will make us able to make
    proper decisions while differentiating between the algorithms in terms of their
    efficient use of resources, which means time and memory, depending on the scenario.
    Let''s get started by taking a look at the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经获得了足够的关于优化的信息，以及我们如何分析算法的方式，是时候看一些例子来澄清非优化和优化代码之间的差异了。在深入分析以下代码的算法之前，我们将学习如何分析程序的复杂性。由于本书不打算教授高级算法概念，我们将研究评估性能和优化的基本思想。这将为您提供一个工具，帮助您编写更短、可读且不浪费内存资源的程序。因此，这种实践将使我们能够在根据场景的资源的有效使用方面，即时间和内存，区分算法时做出正确的决策。让我们开始看一下以下代码：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, we used two nested `for` loops to get the desired output.
    In the case of the first for loop, it takes all the elements of the range one
    by one and for each iteration, we make a second for loop. For the second loop,
    we will have a range of the same elements with the same number of counts. For
    example, for element 2, we will have [2,2] for the second j loop, thus printing
    the same number multiple times. If you followed the preceding chapters properly,
    this code shouldn''t be hard to understand. Now, let''s observe the fun part.
    We know that the first i^([-])loop is going to iterate into the whole range of
    datasets, which will lead to the time complexity of `O(n)`. The same goes for
    the j-loop. Thus, the total time complexity will be `O(n) * O(n)`, which will
    result in `O(n²)`. This represents an expensive algorithm. We have to try and
    convert the programs with nested loops into single loops, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了两个嵌套的`for`循环来获得所需的输出。在第一个for循环的情况下，它逐个获取范围的所有元素，并且在每次迭代时，我们进行第二个for循环。对于第二个循环，我们将有相同元素的相同数量的范围计数。例如，对于元素2，我们将在第二个j循环中得到[2,2]，从而多次打印相同的数字。如果您正确地遵循了前面的章节，那么这段代码应该不难理解。现在，让我们观察有趣的部分。我们知道第一个i^([-])循环将迭代整个数据集的范围，这将导致时间复杂度为`O(n)`。j循环也是如此。因此，总时间复杂度将是`O(n)
    * O(n)`，这将导致`O(n²)`。这代表了一个昂贵的算法。我们必须尝试将嵌套循环的程序转换为单个循环，如下所示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding program contains a single for loop, and so it will loop the entire
    datasets once, which will result in only `O(n)` and not `O(n²)`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序包含一个单独的for循环，因此它将一次循环整个数据集，结果只会是`O(n)`而不是`O(n²)`。
- en: 'You may be wondering why these things are so important and why we covered them
    in this chapter. The answer is simple. Although in some applications written by
    Python, that is, Android applications or websites, saving some milliseconds would
    be unnecessary. But, in a large application that''s handling gigantic amounts
    of data, this time measurement can be increased. For example, let''s think about
    an application calling a function to predict whether the news is fake or not.
    Let''s say the non-optimized code would take a few seconds to make a prediction
    and that optimization would take some milliseconds. Here, the quantity would seem
    small but imagine we are calling the same function 1 million times. Now, calculate
    the time that would be saved as a whole: 277.5 hours.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么这些东西如此重要，为什么我们在本章中涵盖了它们。答案很简单。尽管在Python编写的某些应用程序中，即Android应用程序或网站，节省几毫秒可能是不必要的。但是，在处理大量数据的大型应用程序中，这种时间测量可能会增加。例如，让我们想象一个应用程序调用一个函数来预测新闻是否是假的。假设非优化的代码需要几秒钟来进行预测，而优化则需要几毫秒。在这里，数量似乎很小，但想象一下我们调用相同的函数100万次。现在，计算整体上将节省的时间：277.5小时。
- en: 'That''s cumbersome, isn''t it? Python provides two constructs to facilitate
    faster and efficient processing of these huge data collections: comprehension
    and generators. There are three types of comprehensions, that is, list, dict,
    and set. First, we will delve into learning about list comprehension. Then, we
    will explore the other two (dict and set) by relating to them.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这很麻烦，不是吗？Python提供了两种构造来促进这些庞大数据集的更快和更有效的处理：推导和生成器。推导有三种类型，即列表、字典和集合。首先，我们将深入学习列表推导。然后，我们将通过与它们相关联来探索另外两种（字典和集合）。
- en: For loop versus list comprehension
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环与列表推导
- en: 'Since we''ve been coding our program with loops since [Chapter 3](49a63c5e-e333-46c8-b8de-a54ca40d949c.xhtml), *Flow
    Control – Building a Decision Maker For Your Game*, we are quite familiar with
    looping patterns, especially for loops. They are going to iterate through some
    items and, at each iteration, the iterating variable is going to perform some
    manipulation. The power of for loops can be alleviated by combining it with the
    appropriate data structure, like so:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 自从[第3章](49a63c5e-e333-46c8-b8de-a54ca40d949c.xhtml)以来，我们一直在使用循环编写我们的程序，*流程控制-为您的游戏构建决策制造者*，我们对循环模式非常熟悉，特别是对于循环。它们将迭代一些项目，并且在每次迭代时，迭代变量将执行一些操作。通过将for循环与适当的数据结构结合使用，可以减轻for循环的强大力量，就像这样：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Python has another easier way of doing the same thing, and is known as list
    comprehension. The output of list comprehension will always be a list, which will
    be the result of the evaluation of the expression in the context of the for loop.
    This is followed by if conditionals. The code that emulates the for loop with
    expressions and conditionals by using list comprehension will be single-line code.
    Thus, code that's written using list comprehension is shorter and easily maintainable.
    To understand how list comprehension works, we have to be familiar with its pattern.
    We'll learn about the list comprehension pattern in the next section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python还有另一种更简单的方法来做同样的事情，即列表推导。列表推导的输出将始终是一个列表，这将是在for循环上下文中表达式评估的结果。这之后是条件。使用列表推导通过表达式和条件模拟`for`循环的代码将是单行代码。因此，使用列表推导编写的代码更短，更易于维护。要理解列表推导的工作原理，我们必须熟悉其模式。我们将在下一节学习列表推导模式。
- en: List comprehension pattern
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表推导模式
- en: 'In this section, we will use list comprehension to modify the preceding code
    that was written by a for loop. The result of list comprehension is a list. The
    pattern inside the square bracket is an expression followed by a loop, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用列表推导修改之前由`for`循环编写的代码。列表推导的结果是一个列表。方括号内的模式是一个表达式，后面跟着一个循环，如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, the left-hand side object, that is, `new_list` represents
    the output list that stores the result of list comprehension. On the right-hand
    side expression, the statement enclosed by square brackets will result in list
    comprehension. First, we pass the expression to be performed, then the loop and
    conditionals (if any). The following illustration represents the pattern for list
    comprehension:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，左侧的对象，即`new_list`代表存储列表推导结果的输出列表。在右侧的表达式中，由方括号括起来的语句将导致列表推导。首先，我们传递要执行的表达式，然后是循环和条件（如果有的话）。以下插图表示了列表推导的模式：
- en: '![](Images/e20c0782-2c51-466c-b885-f82aec9c0a0a.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e20c0782-2c51-466c-b885-f82aec9c0a0a.png)'
- en: 'Let''s take a look at a simple example to explain the preceding pattern:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子来解释上述模式：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first statement inside the square brackets represents an expression. There
    can only be a single expression while we use list comprehension, unlike the body
    of a `for` loop. After the expression, we apply spaces and provide iteration.
    We can add nested loops too. After adding the iterations, we have to specify the
    conditionals, if there are any. List comprehension is widely used to concatenate
    the elements of two lists and create a new one, like so:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号内的第一个语句表示一个表达式。在使用列表推导时，只能有一个单一的表达式，而不像`for`循环的主体那样。在表达式之后，我们应用空格并提供迭代。我们也可以添加嵌套循环。在添加迭代之后，我们必须指定条件，如果有的话。列表推导广泛用于连接两个列表的元素并创建一个新的列表，如下所示：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code was able to create a complex list of lists. The comprehensions
    are not only limited to lists; there''s also dict and set comprehensions. As for
    the list, we used square brackets to perform comprehension. For set and dict comprehension,
    we need to use curly braces `{}`. Note, however, that the patterns will be similar
    for all of these comprehensions. Let''s take a look at an example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码能够创建一个复杂的列表。推导不仅限于列表；还有字典和集合的推导。对于列表，我们使用方括号进行推导。对于集合和字典推导，我们需要使用大括号`{}`。然而，这些推导的模式对所有这些推导都是相似的。让我们看一个例子：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code represents the usage of dict comprehension. The pattern
    is similar to list comprehension except we use curly braces to perform comprehension.
    The result of dict comprehension will be a dictionary. Similarly, in the case
    of set comprehension, the result of comprehension will be set. This is shown in
    the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码表示了字典推导的用法。模式与列表推导类似，只是我们使用大括号进行推导。字典推导的结果将是一个字典。同样，在集合推导的情况下，推导的结果将是一个集合。这在下面的代码中显示：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Before wrapping up this section, we have to cover two powerful built-in functions
    of Python that manipulate the data of collections faster than ever. If you ever
    got a chance to learn about big data, you should have heard these two words: zip
    and map. Python has provided these two functions in order to work with a high
    amount of data with minimal load and faster computation. Let''s look at a simple
    example to understand the concepts of zip and map. Let''s say we have two lists
    containing limited integers. Now, you have to write a program to create a new
    list that will store the smallest number from each of them. A comparison will
    be made between the elements that have the same indexes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本节之前，我们必须介绍Python的两个强大的内置函数，它们可以比以往更快地操作集合的数据。如果你曾经有机会学习大数据，你应该听说过这两个词：zip和map。Python提供了这两个函数，以便在最小的负载和更快的计算下处理大量数据。让我们看一个简单的例子来理解zip和map的概念。假设我们有两个包含有限整数的列表。现在，你必须编写一个程序来创建一个新的列表，该列表将存储每个列表中的最小数字。将对具有相同索引的元素进行比较：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The most simple and conventional approach is shown in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单和常规的方法如下所示：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s learn about the other way we can perform the preceding computation.
    This is done with a single line of code which is made by using the `zip` and `map`
    functions. The `zip` function is a simple Python built-in function that takes
    two objects of equal length and merges them together. If you pass two lists of
    equal length to the `zip` function, it will merge it into a single one so that
    computation can be performed within a single object. This is shown in the following
    code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习另一种执行上述计算的方法。这是使用`zip`和`map`函数制作的单行代码。`zip`函数是一个简单的Python内置函数，它接受两个相等长度的对象并将它们合并在一起。如果你将两个相等长度的列表传递给`zip`函数，它将把它们合并成一个，以便在单个对象内执行计算。这在下面的代码中显示：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We know that the comparison between the numbers should be made since they have
    the same indexes. Thus, we can combine the original array of numbers with the `zip`
    function so that we can store tuples of numbers in the single list, like so:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道应该进行数字之间的比较，因为它们具有相同的索引。因此，我们可以使用`zip`函数将原始数字数组与`zip`函数结合起来，以便我们可以将数字的元组存储在单个列表中，就像这样：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Map function
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射函数
- en: The prime task of programming is to perform a computation. The operation that's
    done on elements can be done independent of one another; that is, we can perform
    a comparison on lists a and b separately, like we did in the preceding code, or
    simply merge them so that comparison can be done faster. The `zip` method is able
    to merge two objects that are the same length into a new iterable. Now, the major
    task is to create a comparison operation and use it on each element of the iterable,
    which is done by using the `map` function. The `map` function takes some function
    and applies it to each of the elements of the iterable.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的主要任务是执行计算。对元素进行的操作可以独立于彼此进行；也就是说，我们可以分别对列表a和b进行比较，就像我们在前面的代码中所做的那样，或者简单地将它们合并，以便可以更快地进行比较。`zip`方法能够将长度相同的两个对象合并为一个新的可迭代对象。现在，主要任务是创建一个比较操作，并将其应用于可迭代对象的每个元素，这是通过使用`map`函数来完成的。`map`函数采用某个函数，并将其应用于可迭代对象的每个元素。
- en: 'According to Python''s official documentation, map can be described as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python的官方文档，可以描述`map`如下：
- en: '*Map applies a function to every item of iterable and returns a list of the
    results. If additional iterable arguments are passed, the function must take that
    many arguments and is applied to the items from all the iterables in parallel.
    If one iterable is shorter than another, it is assumed to be extended with None
    items. If the function is None, the identity function is assumed; if there are
    multiple arguments,* `map()` *returns a list consisting of tuples containing the
    corresponding items from all the iterables (a kind of transpose operation). The
    iterable arguments may be a sequence or any iterable object; the result is always
    a list.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*Map将函数应用于可迭代对象的每个项目，并返回结果列表。如果传递了额外的可迭代参数，则函数必须采用相同数量的参数，并且并行应用于所有可迭代对象的项目。如果一个可迭代对象比另一个短，则假定它将被扩展为None项目。如果函数为None，则假定为恒等函数；如果有多个参数，*`map()`*返回一个由包含所有可迭代对象对应项目的元组的列表（一种转置操作）。可迭代参数可以是序列或任何可迭代对象；结果始终是列表。*'
- en: 'The argument that''s passed when we call map function is a function that''s
    followed by iterables. Normally, we use an anonymous or lambda function, such
    as `some_function`, which takes some positional arguments and returns them as
    a tuple. This is shown in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 调用map函数时传递的参数是一个函数，后面跟着可迭代对象。通常，我们使用匿名或lambda函数，例如`some_function`，它接受一些位置参数并将它们作为元组返回。这在以下代码中显示：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s create a simple example to illustrate the use of the `map` function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的示例来说明`map`函数的用法：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code was not fruitful as the `map` function doesn''t return any
    iterables or objects. Instead, it prints the string representing the map object.
    To achieve a desirable result, we have to wrap the `map` method with a list constructor,
    like so:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码并不成功，因为`map`函数并不返回任何可迭代对象。相反，它打印表示地图对象的字符串。为了实现期望的结果，我们必须使用列表构造函数包装`map`方法，就像这样：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we will use the concepts of the `map` and `zip` functions to find the
    list of minimum elements from the two lists. The following code is pretty simple;
    we started by defining two arrays. After that, we used the `map` function, which
    will take the `lambda` function containing the comparison operation and `zip`
    method and merge the two arrays into the list of tuples. Each pair of tuples made
    by the `zip` method are passed to `lambda` functions for comparison:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用`map`和`zip`函数的概念来找到两个列表中最小元素的列表。以下代码非常简单；我们首先定义了两个数组。之后，我们使用`map`函数，它将采用包含比较操作的`lambda`函数和`zip`方法，并将两个数组合并为元组列表。`zip`方法生成的每对元组都会传递给比较的`lambda`函数：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With the power of `map` and `zip`, we can do anything, similar to list comprehension.
    With the preceding program complete with list comprehension, the `map` function,
    and a for loop, we can see the following runtime performance:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 借助`map`和`zip`的功能，我们可以做任何事情，类似于列表推导。通过使用列表推导、`map`函数和for循环完成的前面的程序，我们可以看到以下运行时性能：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Thus, these three features of Python primarily enable the manipulation of collections
    faster than anything. But in terms of code maintainability and readability, list
    comprehension tops the list as it provides us with a way to customize the inner
    workings of programs effectively. Now, it's time to learn about another feature
    of Python, known as decorators. These allow us to modify the functionality of
    an existing object without modifying its current structure.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Python的这三个特性主要使集合的操作比任何其他操作都更快。但就代码的可维护性和可读性而言，列表推导在提供有效定制程序内部工作方式的方法方面名列前茅。现在，是时候了解Python的另一个特性，即装饰器。这使我们能够修改现有对象的功能，而不修改其当前结构。
- en: Decorators
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: 'A decorator is a design pattern that adds new functionality to an existing
    object without deferring its original structure. We must be comfortable with the
    fact that everything in Python is an object – even functions. The different names
    that are used for defining these objects are just their identifiers. Let''s run
    the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是一种设计模式，它在不改变原始结构的情况下为现有对象添加新功能。我们必须习惯于Python中的一切都是对象，甚至函数也是对象。用于定义这些对象的不同名称只是它们的标识符。让我们运行以下代码：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we run the preceding code, the `fun1` and `fun2` functions print the same
    output of `"Good Morning"` as both refer to the same objects (functions). Thus,
    functions are just objects with attributes. Let''s get back to decorators. In
    a basic sense, a decorator is a construct where a part of the program tries to
    change the behavior of another part of the program at compile time. In the case
    of functions, the decorator takes a function, adds unique functionality to it,
    and eventually returns it, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上面的代码时，`fun1`和`fun2`函数打印出相同的输出`"Good Morning"`，因为两者都指向相同的对象（函数）。因此，函数只是带有属性的对象。让我们回到装饰器。基本上，装饰器是一个构造，其中程序的一部分试图在编译时改变程序的另一部分的行为。对于函数来说，装饰器接受一个函数，为其添加独特的功能，最终返回它，如下所示：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s try to run the preceding code from the Python shell:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试从Python shell中运行上面的代码：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding example, `decorate_it()` is a decorator that takes a non-decorated
    function as an argument. The `decorate = decorate_it(non_Decorated)` statement
    is an assignment, where the `Non_Decorated` function was passed to the decorator
    and it returned the function called decorate. Thus, we can conclude that decorators
    are callables that return a callable. In the preceding example, we can see that
    the `decorate_it()` decorator added some functionality to the `non_Decorated`
    or ordinary function. When decorators started getting famous, the introduced design
    pattern was based on decorating the function first and returning to the name of
    the second callable, just like we did in this example. However, programmers found
    this job to be redundant. Thus, they developed another syntax that simplified
    the preceding construct: using the`@` symbol.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`decorate_it()`是一个装饰器，它以未装饰的函数作为参数。`decorate = decorate_it(non_Decorated)`语句是一个赋值语句，其中`Non_Decorated`函数被传递给装饰器，它返回了名为decorate的函数。因此，我们可以得出结论，装饰器是可调用的，返回一个可调用的。在上面的例子中，我们可以看到`decorate_it()`装饰器为`non_Decorated`或普通函数添加了一些功能。当装饰器开始变得有名气时，引入的设计模式是首先装饰函数，然后返回第二个可调用对象的名称，就像我们在这个例子中所做的那样。然而，程序员们发现这项工作是多余的。因此，他们开发了另一种语法，简化了前面的结构：使用`@`符号。
- en: 'To decorate an ordinary function, we use the `@` symbol, along with the decorator''s
    name, and place it at the top of the non-decorated function, like so:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要装饰一个普通函数，我们使用`@`符号，加上装饰器的名称，并将其放在未装饰的函数的顶部，如下所示：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code is auxiliary to the following code, which we wrote earlier:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码是下面的代码的辅助，我们之前写过：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s look at another example. We want to make a decorator that acts like
    an exception handler that throws error messages whenever unusual activity is encountered
    by the programs. The preceding decorator was simple since it wasn''t concerned
    about the argument that was passed to the inner function. Now, we are going to
    make a program that will multiply any two numbers but also handle the error if
    any other data is passed, such as a string or complex numbers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。我们想制作一个装饰器，它就像一个异常处理程序，当程序遇到异常活动时抛出错误消息。上面的装饰器很简单，因为它不关心传递给内部函数的参数。现在，我们将制作一个程序，它将乘以任意两个数字，但也处理错误，如果传递了其他数据，比如字符串或复数：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we will try to make a decorator that will check whether we got an exception,
    like in the preceding code, and handle it automatically:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试制作一个装饰器，它将检查我们是否得到了异常，就像在上面的代码中一样，并自动处理它：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As soon as you run the previous code, you will be asked for entries in the
    Python Shell. You have to enter two entities for `a` and `b`, and then the code
    does the rest:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行了上面的代码，你将被要求在Python Shell中输入条目。你必须为`a`和`b`输入两个实体，然后代码就会完成剩下的工作：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s run the preceding code one more time. This time, we will input the values
    of `a` and `b` as strings:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行上面的代码。这一次，我们将把`a`和`b`的值输入为字符串：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you can see, the `inner` function of the decorator has the same number of
    arguments as those that were passed in by the non-decorated function. Thus, generalization
    can be done with `inner(*args, **kwargs)`, where `args` is the tuple of positional
    arguments and `kwargs` represents the dictionary of keyword arguments. Now, we
    can make decorators that will work with any number of arguments, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，装饰器的`inner`函数具有与未装饰函数传入的参数相同的数量。因此，可以使用`inner(*args, **kwargs)`进行泛化，其中`args`是位置参数的元组，`kwargs`表示关键字参数的字典。现在，我们可以制作能够处理任意数量参数的装饰器，如下所示：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Thus, at compile time, decorators modify the operations of the original function,
    methods, or even classes without altering the code of the objects being decorated.
    This ultimately leads to the use of **don't repeat yourself** (**DRY**) technique.
    In the next section, we are going to learn about the `@property` decorator – a
    built-in decorator of Python for implementing the `property()` function. As you
    may recall from the previous chapter, this construct of `@property` has already
    been used and it was defined as a Pythonic way of implementing getters and setters.
    Now, we will learn about it in detail.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在编译时，装饰器修改了原始函数、方法甚至类的操作，而不改变被装饰对象的代码。这最终导致了**不要重复自己**（**DRY**）技术的使用。在下一节中，我们将学习`@property`装饰器
    - Python的内置装饰器，用于实现`property()`函数。正如你可能还记得上一章所述，`@property`的这种构造已经被使用，并且它被定义为实现getter和setter的Pythonic方式。现在，我们将详细了解它。
- en: Python property
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python属性
- en: 'To understand the usage of the property in the first place, we have to recall
    one of the principles of the object-oriented paradigm: data encapsulation. This
    bundles the data with the methods as a single capsule. The methods that are going
    to get and set the attributes of the classes are getters and setters. This principle
    of OOP infers that the attributes of the class must be made private so that accident
    modification or theft is prevented. Let''s look at a simple example to begin:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解首先使用属性的用法，我们必须回顾面向对象范式的一个原则：数据封装。这将数据与方法捆绑为一个单一的胶囊。将要获取和设置类的属性的方法称为getter和setter。面向对象编程的这一原则暗示了类的属性必须私有化，以防止意外修改或盗窃。让我们从一个简单的例子开始：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding code, we made a class called `Speed` that stores the speed
    of the vehicle in kilometers. It has `members` as a method that converts kilometers
    into miles. Now, we can make the objects of the `Speed` class and manipulate the
    members of this class as we like. We will use the Python Shell for this, like
    so:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了一个名为`Speed`的类，用于存储车辆的速度（以公里为单位）。它有一个`members`方法，用于将公里转换为英里。现在，我们可以创建`Speed`类的对象，并随意操纵这个类的成员。我们将使用Python
    Shell进行操作，如下所示：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Whenever assignment is done to the attributes of the class, the Python interpreter
    maintains the dictionary where the attributes and their values are maintained
    as key and value. In the case of the `Speed` class, we can retrieve any attributes
    of the object, that is, `speed`, with `__dict__ attributes`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每当对类的属性进行赋值时，Python解释器都会维护一个字典，其中属性及其值被维护为键和值。在`Speed`类的情况下，我们可以使用`__dict__属性`检索对象的任何属性，即`speed`：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Thus, whenever we execute the `car.speed` operation, the Python interpreter
    makes a search in the preceding dictionary and fetches the value as `car.__dict__['speed']`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当我们执行`car.speed`操作时，Python解释器会在上述字典中进行搜索，并将值提取为`car.__dict__['speed']`。
- en: 'Now, let''s assume that the preceding code became popular worldwide in the
    field of traffic control. One day, traffic police argued that there should be
    constraints in terms of the speed of a vehicle so that law can be enforced. Now,
    we have to modify the code in such a way that, if any driver drives too fast,
    the program provides them with a warning message. We can do this using getters
    and setters. Inside the `setter` method, we can explicitly check the maximum speed
    of the vehicle using conditionals. This can be done as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设上述代码在交通控制领域全球范围内变得流行。有一天，交通警察提出应该对车辆的速度进行约束，以便可以执行法律。现在，我们必须修改代码，以便如果任何驾驶员驾驶速度过快，程序会向他们提供警告消息。我们可以使用getter和setter来实现这一点。在`setter`方法内部，我们可以使用条件语句明确检查车辆的最高速度。可以这样做：
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding code, two major modifications were done and we are familiar
    with them. They are the `getter: get_speed` method and `setter: set_speed` method.
    Another change that was made in the code is the signature of the attribute. The
    speed attribute begins with a single underscore, which makes it private (data
    encapsulation). Try the following code in the Python Shell:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '在上述代码中，进行了两个重大修改，我们对它们很熟悉。它们是`getter: get_speed`方法和`setter: set_speed`方法。在代码中进行的另一个更改是属性的签名。速度属性以单下划线开头，这使其成为私有属性（数据封装）。在Python
    Shell中尝试以下代码：'
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The update to the original program was successfully reflected with new ranges
    of restriction. The driver is not allowed to drive their vehicle at a speed of
    more than 50km/hr.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对原始程序的更新成功地反映了新的限制范围。驾驶员不被允许以超过50公里/小时的速度驾驶他们的车辆。
- en: 'Now, let''s run the preceding code and observe the overhead that might be caused
    by the new updates. We can simply compare the code that was written with the getter
    and the setter with the code that was written without them. A major headache will
    arise when you try to accommodate the original code with the new changes as you
    have to modify your code from calling the attributes of the `car.speed` object
    to calling the attributes of `car.get_speed()`. The constructor must be changed
    to `car.set_speed` (speed). We might find it easier to make changes in this program,
    but imagine if the program had 10,000+ lines of code. It would be a hard time
    for any programmer to update and synchronize it with the new code. Now, here comes
    the property decorator in action. The following code solves this problem for us:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行上述代码，并观察新更新可能引起的开销。我们可以简单地比较使用getter和setter编写的代码与不使用它们编写的代码。当您尝试调整原始代码以适应新更改时，将会出现一个主要的头痛问题，因为您必须修改代码，从调用`car.speed`对象的属性到调用`car.get_speed()`的属性。构造函数必须更改为`car.set_speed`（speed）。我们可能会发现在这个程序中进行更改更容易，但是想象一下，如果程序有10,000多行代码。对于任何程序员来说，更新和与新代码同步将是一件困难的事情。现在，属性装饰器开始发挥作用。以下代码为我们解决了这个问题：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Since we are familiar with decorators, the preceding construct should be familiar
    to us. Now, let''s run our code in the Python Shell:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们熟悉装饰器，上述构造对我们来说应该是熟悉的。现在，让我们在Python Shell中运行我们的代码：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using the property construct, we modified our original class and provided some
    constraints too. But this time, we removed the changes we made, such as `get_speed`
    and `set_speed`, that were added by the getter and the setter. Thus, the traffic
    control system can use this new code without making any changes to the original
    code, which leads to backward compatibility.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性构造，我们修改了原始类并提供了一些约束。但是这一次，我们移除了我们所做的更改，比如由getter和setter添加的`get_speed`和`set_speed`。因此，交通控制系统可以使用这个新代码，而不需要对原始代码进行任何更改，这导致了向后兼容性。
- en: 'We also have another way of implementing the preceding code, which is by using
    the `property()` function. The following code is equivalent to the preceding code
    being written with the `@` property construct:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有另一种实现上述代码的方法，那就是使用`property()`函数。以下代码等同于使用`@`属性构造编写的上述代码：
- en: '[PRE36]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The last line of the preceding code makes an object of the speed property. Remember
    that the property must be made out of those attributes, which are likely to be
    changed. We added some code that creates the object of property and inside parenthesis,
    we passed the getter and setter method. Now, any program that uses the value of
    speed will invoke the `get_speed` method automatically and any program that assigns
    the value of speed will invoke the `set_speed` method without having to look up `dictionary(obj.__dict__)`,
    which is managed by class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的最后一行创建了一个speed属性的对象。请记住，属性必须由可能被更改的属性组成。我们添加了一些代码，创建了属性的对象，并在括号内传递了getter和setter方法。现在，任何使用speed值的程序都会自动调用`get_speed`方法，任何分配speed值的程序都会调用`set_speed`方法，而无需查找由类管理的`dictionary(obj.__dict__)`。
- en: Now, let's use our knowledge of list comprehension and property that we learned
    about in this chapter to modify our snake game.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们利用本章学到的列表理解和属性知识来修改我们的蛇游戏。
- en: Refining the snake game with LC and property
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LC和属性完善蛇游戏
- en: 'This section will be kept as concise as possible because there is nothing new
    to cover. Now that we have learned about list comprehension and property in detail,
    we should be able to cover this topic quickly, as we discussed in the summary
    of the previous chapter. Just as a recap: list comprehension is a technique that
    is used to create a new list of elements from other iterables. A list comprehension
    statement consists of square brackets containing transformation that must be made
    for each element, along with a for loop. This is followed by some conditions.
    On the other hand, the `@property` or `property()` constructs are the Pythonic
    way of implementing getters and setters.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分将尽可能保持简洁，因为没有新内容可覆盖。现在我们已经详细学习了列表理解和属性，我们应该能够快速地覆盖这个主题，就像我们在上一章的总结中讨论的那样。简而言之：列表理解是一种从其他可迭代对象创建新元素列表的技术。列表理解语句由包含必须对每个元素进行转换的方括号组成，以及一个for循环。然后是一些条件。另一方面，`@property`或`property()`构造是实现getter和setter的Pythonic方式。
- en: 'Let''s go over some of the refinements we can make to our snake game:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们可以对蛇游戏进行的一些改进：
- en: 'First, we can make a function that will check the collision of the snake with
    the boundary or with itself. For example, if the coordinate (x,y) for the head
    of the snake is the same as the coordinate for its body, we have a collision.
    This logic can be made with list comprehension: `[body.coor == self.head.coor
    for body in self.body_list[:-1]]`. The following expression is going to store
    a Boolean that''s either True or False in the result list. The `body.coor == self.head.coor` comparison
    is going to be made for every position representing the body of the snake. The
    following lines of code represent a function that returns either True or False
    based on the check for collision:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以创建一个函数，检查蛇与边界或自身的碰撞。例如，如果蛇头的坐标(x,y)与其身体的坐标相同，我们就有了碰撞。这个逻辑可以用列表理解来实现：`[body.coor
    == self.head.coor for body in self.body_list[:-1]]`。以下表达式将在结果列表中存储一个True或False的布尔值。对于蛇身的每个位置，都会进行`body.coor
    == self.head.coor`的比较。以下代码行表示一个函数，根据碰撞检查返回True或False：
- en: '[PRE37]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Secondly, we can decorate the preceding method with the `@property` construct.
    Since we''ve covered it in detail, this should not create any confusion for us.
    If there is, let me enlighten you. The main use of `@property` is to support backward
    compatibility. We can modify the specifications of classes and implement the constraints
    without actually modifying the code of the previous versions that are distributed
    to the clients. Similarly, we can decorate a score function with `@property` since
    we need to update its time value. Thus, in order to continually access the score
    method as an attribute, we can add the property we decorated previously, like
    so:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，我们可以用`@property`构造装饰前面的方法。由于我们已经详细介绍过，这不应该对我们造成任何困惑。如果有的话，让我来解释一下。`@property`的主要用途是支持向后兼容。我们可以修改类的规范并实现约束，而不实际修改分发给客户的先前版本的代码。同样，我们可以用`@property`装饰一个得分函数，因为我们需要更新它的时间值。因此，为了不断地将得分方法作为属性访问，我们可以像这样添加我们之前装饰的属性：
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding implementation of property and list comprehension is both an easy
    and efficient way of making code more readable and maintainable. We are going
    to find these types of constructs more often while programming with Python at
    an enterprise level.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 属性和列表理解的前面实现都是使代码更易读和易维护的简单有效的方式。在企业级Python编程中，我们经常会发现这些类型的构造。
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has uncovered the advanced concepts of comprehension and generation,
    followed by some examples and its applications in the real-world. We saw the usage
    of comprehension and some of the built-in functions of Python such as map and
    zip, which over-shadowed the performance of for loops. Although these concepts
    of comprehension and mapping may seem overrated, we usually find it helpful if
    we have gigantic lines of code where performance matters rather than code readability.
    We also explored decorators in this chapter, which added some extra functionality
    to the existing code without affecting its original substance. Then, we learned
    about the concepts of the property decorator, which is a Pythonic way of implementing
    getters and setters while maintaining backward code compatibility.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本章揭示了理解和生成的高级概念，接着是一些示例及其在现实世界中的应用。我们看到了理解的用法和Python的一些内置函数，比如map和zip，它们超越了for循环的性能。虽然这些理解和映射的概念可能被高估了，但如果我们有大量代码需要考虑性能而不是代码可读性，通常会发现它们很有帮助。本章还探讨了装饰器，它为现有代码添加了一些额外功能，而不影响其原始内容。然后，我们学习了属性装饰器的概念，这是一种Pythonic的实现方式，可以实现getter和setter，同时保持向后兼容的代码。
- en: From the next chapter onward, our main goal will likely be lean toward game
    programming. We have successfully learned about the essentials of Python in order
    to become proficient game programmers. Now, we will learn about the graphical
    user interface and ways of making it using modules provided by Python, such as
    turtle and pygame. But before we hop over to the next chapter, make sure you are
    playing with the code we've written so far properly. It is a very important thing
    for any programmer to be able to read the code by breaking it line by line. If
    you already have enough confidence in your skills, proceed to the next chapter,
    where we will look at the turtle module, which is a basic way of drawing shapes
    into the game screen.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一章开始，我们的主要目标可能会倾向于游戏编程。我们已经成功学习了Python的基本知识，以便成为熟练的游戏程序员。现在，我们将学习关于图形用户界面以及使用Python提供的模块（如turtle和pygame）制作图形界面的方法。但在我们跳到下一章之前，请确保你已经正确地使用我们迄今为止编写的代码。对于任何程序员来说，能够逐行阅读代码是非常重要的。如果你已经对自己的技能有足够的信心，那么可以继续到下一章，我们将学习turtle模块，这是在游戏屏幕上绘制形状的基本方法。
