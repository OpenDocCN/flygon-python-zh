- en: Chapter 3. APIs in Action
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。API的实际应用
- en: When we talk about APIs in relation to Python, we usually refer to the classes
    and the functions that a module presents to us to interact with. In this chapter,
    we'll be talking about something different, that is, web APIs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论Python中的API时，通常指的是模块向我们呈现的类和函数，以便与之交互。在本章中，我们将谈论一些不同的东西，即Web API。
- en: A web API is a type of API that you interact with through the HTTP protocol.
    Nowadays, many web services provide a set of HTTP calls, which are designed to
    be used programmatically by clients, that is, they are meant to be used by machines
    rather than by humans. Through these interfaces it's possible to automate interaction
    with the services and to perform tasks such as extracting data, configuring the
    service in some way, and uploading your own content into the service.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Web API是一种通过HTTP协议与之交互的API类型。如今，许多Web服务提供一组HTTP调用，旨在由客户端以编程方式使用，也就是说，它们是为机器而不是人类设计的。通过这些接口，可以自动化与服务的交互，并执行诸如提取数据、以某种方式配置服务以及将自己的内容上传到服务中等任务。
- en: 'In this chapter, we''ll look at:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到：
- en: 'Two popular data exchange formats used by web APIs: XML and JSON'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web API使用的两种流行数据交换格式：XML和JSON
- en: 'How to interact with two major web APIs: Amazon S3 and Twitter'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何与两个主要Web API进行交互：Amazon S3和Twitter
- en: How to pull data from HTML pages when an API is not available
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在API不可用时如何从HTML页面中提取数据
- en: How to make life easier for the webmasters that provide these APIs and websites
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为提供这些API和网站的网络管理员简化工作
- en: There are hundreds of services that offer web APIs. A quite comprehensive and
    ever-growing list of these services can be found at [http://www.programmableweb.com](http://www.programmableweb.com).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有数百种提供Web API的服务。这些服务的相当全面且不断增长的列表可以在[http://www.programmableweb.com](http://www.programmableweb.com)找到。
- en: We're going to start by introducing how XML is used in Python, and then we will
    explain an XML-based API called the Amazon S3 API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍Python中如何使用XML，然后解释一种基于XML的API，称为Amazon S3 API。
- en: Getting started with XML
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用XML
- en: The **Extensible Markup Language** (**XML**) is a way of representing hierarchical
    data in a standard text format. When working with XML-based web APIs, we'll be
    creating XML documents and sending them as the bodies of HTTP requests and receiving
    XML documents as the bodies of responses.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**可扩展标记语言**（**XML**）是一种以标准文本格式表示分层数据的方式。在使用基于XML的Web API时，我们将创建XML文档，并将其作为HTTP请求的主体发送，并接收XML文档作为响应的主体。'
- en: 'Here''s the text representation of an XML document, perhaps this represents
    the stock at a cheese shop:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是XML文档的文本表示，也许代表奶酪店的库存：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you've coded with HTML before, then this may look familiar. XML is a markup
    based format. It is from the same family of languages as HTML. The data is structured
    in an hierarchy formed by elements. Each element is represented by two tags, a
    start tag, for example, `<name>`, and a matching end tag, for example, `</name>`.
    Between these two tags, we can either put data, such as `Caerphilly`, or add more
    tags, which represent child elements.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前使用过HTML编码，那么这可能看起来很熟悉。 XML是一种基于标记的格式。它来自与HTML相同语言系列。数据以元素形式的层次结构进行组织。每个元素由两个标签表示，例如开始标签`<name>`和匹配的结束标签，例如`</name>`。在这两个标签之间，我们可以放置数据，例如`Caerphilly`，或者添加更多标签，代表子元素。
- en: Unlike HTML, XML is designed such that we can define our own tags and create
    our own data formats. Also, unlike HTML, the XML syntax is always strictly enforced.
    Whereas in HTML small mistakes, such as tags being closed in the wrong order,
    closing tags missing altogether, or attribute values missing quotes are tolerated,
    in XML, these mistakes will result in completely unreadable XML documents. A correctly
    formatted XML document is called well formed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与HTML不同，XML被设计成我们可以定义自己的标签并创建自己的数据格式。此外，与HTML不同，XML语法始终严格执行。在HTML中，小错误（例如标签以错误顺序关闭，完全缺少关闭标签或属性值缺少引号）是可以容忍的，但在XML中，这些错误将导致完全无法阅读的XML文档。格式正确的XML文档称为格式良好的。
- en: The XML APIs
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML API
- en: 'There are two main approaches to working with XML data:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 处理XML数据有两种主要方法：
- en: Reading in a whole document and creating an object-based representation of it,
    then manipulating it by using an object-oriented API
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取整个文档并创建基于对象的表示，然后使用面向对象的API进行操作。
- en: Processing the document from start to end, and performing actions as specific
    tags are encountered
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头到尾处理文档，并在遇到特定标签时执行操作
- en: For now, we're going to focus on the object-based approach by using a Python
    XML API called **ElementTree**. The second so-called pull or event-based approach
    (also often called **SAX**, as SAX is one of the most popular APIs in this category)
    is more complicated to set up, and is only needed for processing large XML files.
    We won't need this to work with Amazon S3.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将专注于使用名为**ElementTree**的Python XML API的基于对象的方法。第二种所谓的拉或事件驱动方法（也经常称为**SAX**，因为SAX是这一类别中最流行的API之一）设置更加复杂，并且仅在处理大型XML文件时才需要。我们不需要这个来处理Amazon
    S3。
- en: The basics of ElementTree
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ElementTree的基础知识
- en: We'll be using the Python standard library implementation of the `ElementTree`
    API, which is in the `xml.etree.ElementTree` module.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python标准库中的`ElementTree` API实现，该API位于`xml.etree.ElementTree`模块中。
- en: 'Let''s see how we may create the aforementioned example XML document by using
    `ElementTree`. Open a Python interpreter and run the following commands:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`ElementTree`创建上述示例XML文档。打开Python解释器并运行以下命令：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We start by creating the root element, that is, the outermost element of the
    document. We create a root element `<inventory>` here, and then print its string
    representation to screen. The `<inventory />` representation is an XML shortcut
    for `<inventory></inventory>`. It's used to show an empty element, that is, an
    element with no data and no child tags.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建根元素，也就是文档的最外层元素。我们在这里创建了一个根元素“<inventory>”，然后将其字符串表示打印到屏幕上。“<inventory
    />”表示是“<inventory></inventory>”的XML快捷方式。它用于显示一个空元素，即没有数据和子标签的元素。
- en: We create the `<inventory>` element by creating a new `ElementTree.Element`
    object. You'll notice that the argument we give to `Element()` is the name of
    the tag that is created.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个新的“ElementTree.Element”对象来创建“<inventory>”元素。您会注意到我们给“Element（）”的参数是创建的标签的名称。
- en: 'Our `<inventory>` element is empty at the moment, so let''s put something in
    it. Do this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“<inventory>”元素目前是空的，所以让我们往里面放点东西。这样做：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, we have an element called `<cheese>` in our `<inventory>` element. When
    an element is directly nested inside another, then the nested element is called
    a **child** of the outer element, and the outer element is called the **parent**.
    Similarly, elements that are at the same level are called **siblings**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的“<inventory>”元素中有一个“<cheese>”元素。当一个元素直接嵌套在另一个元素内时，那么嵌套的元素称为外部元素的**子元素**，外部元素称为**父元素**。同样，处于同一级别的元素称为**兄弟元素**。
- en: 'Let''s add another element, and this time let''s give it some content. Add
    the following commands:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加另一个元素，这次给它一些内容。添加以下命令：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, our document is starting to shape up. We do two new things here: first,
    we use the shortcut class method `ElementTree.SubElement()` to create the new
    `<name>` element and insert it into the tree as a child of `<cheese>` in a single
    operation. Second, we give it some content by assigning some text to the element''s
    `text` attribute.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的文档开始成形了。我们在这里做了两件新事情：首先，我们使用了快捷类方法“ElementTree.SubElement（）”来创建新的“<name>”元素，并将其作为“<cheese>”的子元素一次性插入树中。其次，我们通过将一些文本赋给元素的“text”属性来为其赋予一些内容。
- en: 'We can remove elements by using the `remove()` method on the parent element,
    as shown in the following commands:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用父元素上的“remove（）”方法来删除元素，如下面的命令所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Pretty printing
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 漂亮打印
- en: 'It would be useful for us to be able to produce output in a more legible format,
    such as the example shown at the beginning of this section. The ElementTree API
    doesn''t have a function for doing this, but another XML API, `minidom`, provided
    by the standard library, does, and it''s simple to use. First, import `minidom`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够以更易读的格式生成输出将会很有用，比如在本节开头展示的例子。ElementTree API没有用于执行此操作的函数，但标准库提供的另一个XML
    API“minidom”有，并且使用起来很简单。首先，导入“minidom”：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Second, use the following command to print some nicely formatted XML:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，使用以下命令打印一些格式良好的XML：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These are not the easiest lines of code at first glance, so let's break them
    down. The `minidom` library can't directly work with ElementTree elements, so
    we use ElementTree's `tostring()` function to create a string representation of
    our XML. We load the string into the `minidom` API by using `minidom.parseString()`,
    and then we use the `toprettyxml()` method to output our formatted XML.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些乍一看不是最容易的代码行，所以让我们来分解一下。 “minidom”库不能直接处理ElementTree元素，因此我们使用ElementTree的“tostring（）”函数来创建我们的XML的字符串表示。我们通过使用“minidom.parseString（）”将字符串加载到“minidom”
    API中，然后使用“toprettyxml（）”方法输出我们格式化的XML。
- en: 'This can be wrapped into a function so that it becomes more handy. Enter the
    command block as shown in the following into your Python shell:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以封装成一个函数，使其更加方便。在Python shell中输入以下命令块：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, just do the following to pretty print:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需执行以下操作进行漂亮的打印：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Element attributes
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元素属性
- en: In the example shown at the beginning of this section, you may have spotted
    something in the opening tag of the `<cheese>` element, that is, the `id="c01"`
    text. This is called an **attribute**. We can use attributes to attach extra information
    to elements, and there's no limit to the number of attributes an element can have.
    Attributes are always comprised of an attribute name, which in this case is `id`,
    and a value, which in this case is `c01`. The values can be any text, but they
    must be enclosed in quotes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节开头展示的例子中，您可能已经注意到了“<cheese>”元素的开标签中的内容，“id =“c01””。这被称为**属性**。我们可以使用属性来附加额外的信息到元素上，元素可以拥有的属性数量没有限制。属性始终由属性名称组成，在本例中是“id”，以及一个值，在本例中是“c01”。值可以是任何文本，但必须用引号括起来。
- en: 'Now, add the `id` attribute to the `<cheese>` element, as shown here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下方式为“<cheese>”元素添加“id”属性：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `attrib` attribute of an element is a dict-like object which holds an element's
    attribute names and values. We can manipulate the XML attributes as we would a
    regular `dict`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 元素的“attrib”属性是一个类似字典的对象，保存着元素的属性名称和值。我们可以像操作常规“dict”一样操作XML属性。
- en: By now, you should be able to fully recreate the example document shown at the
    beginning of this section. Go ahead and give it a try.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该能够完全重新创建本节开头展示的示例文档。继续尝试吧。
- en: Converting to text
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换为文本
- en: 'Once we have an XML tree that we''re happy with, usually we would want to convert
    it into a string to send it over the network. The `ET.dump()` function that we''ve
    been using isn''t appropriate for this. All the `dump()` function does is print
    the tag to the screen. It doesn''t return a string which we can use. We need to
    use the `ET.tostring()` function for this, as shown in the following commands:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了满意的XML树，通常我们会希望将其转换为字符串以便通过网络发送。我们一直在使用的“ET.dump（）”函数不适用于此。 “dump（）”函数所做的只是将标签打印到屏幕上。它不会返回我们可以使用的字符串。我们需要使用“ET.tostring（）”函数，如下面的命令所示：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that it returns a bytes object. It encods our string for us. The default
    character set is `us-ascii` but it's better to use UTF-8 for transmitting over
    HTTP, since it can encode the full range of Unicode characters, and it is widely
    supported by web applications.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意它返回一个字节对象。它为我们编码字符串。默认字符集是`us-ascii`，但最好使用UTF-8进行HTTP传输，因为它可以编码完整的Unicode字符范围，并且得到了Web应用的广泛支持。
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For now, this is all that we need to know about creating XML documents, so let's
    see how we can apply it to a web API.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这就是我们需要了解有关创建XML文档的所有内容，让我们看看如何将其应用到Web API。
- en: The Amazon S3 API
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 亚马逊S3 API
- en: Amazon S3 is a data storage service. It underpins many of today's high-profile
    web services. Despite offering enterprise-grade resilience, performance and features,
    it's pretty easy to start with. It is affordable, and it provides a simple API
    for automated access. It's one of many cloud services in the growing **Amazon
    Web Services** (**AWS**) portfolio.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊S3是一个数据存储服务。它支撑了今天许多知名的网络服务。尽管提供了企业级的弹性、性能和功能，但它非常容易上手。它价格合理，并且提供了一个简单的API用于自动访问。它是不断增长的**亚马逊网络服务**（**AWS**）组合中的众多云服务之一。
- en: APIs change every now and then, and they are usually given a version number
    so that we can track them. We'll be working with the current version of the S3
    REST API, "2006-03-01".
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: API不断变化，通常会被赋予一个版本号，以便我们可以跟踪它们。我们将使用当前版本的S3 REST API，“2006-03-01”。
- en: You'll notice that in the S3 documentation and elsewhere, the S3 web API is
    referred to as a **REST API**. **REST** stands for **Representational State Transfer**,
    and it is a fairly academic conception of how HTTP should be used for APIs, originally
    presented by Roy Fielding in his PhD dissertation. Although the properties that
    an API should possess so as to be considered RESTful are quite specific, in practice
    pretty much any API that is based on HTTP is now slapped with the RESTful label.
    The S3 API is actually among the most RESTful high-profile APIs, because it appropriately
    uses a good range of the HTTP methods.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到在S3文档和其他地方，S3 Web API被称为**REST API**。**REST**代表**表述性状态转移**，这是Roy Fielding在他的博士论文中最初提出的关于如何使用HTTP进行API的相当学术的概念。尽管一个API应该具有被认为是RESTful的属性是非常具体的，但实际上几乎任何基于HTTP的API现在都被贴上了RESTful的标签。S3
    API实际上是最具有RESTful特性的高调API之一，因为它适当地使用了HTTP方法的广泛范围。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to read more about this topic, Roy Fielding's dissertation is available
    here [http://ics.uci.edu/~fielding/pubs/dissertation](http://ics.uci.edu/~fielding/pubs/dissertation),
    and one of the original books that promoted the concept, and is a great read,
    *RESTful Web Services* by *Leonard Richardson* and *Sam Ruby*, is now available
    for free download from this page [http://restfulwebapis.org/rws.html](http://restfulwebapis.org/rws.html).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于这个主题的信息，Roy Fielding的博士论文可以在这里找到[http://ics.uci.edu/~fielding/pubs/dissertation](http://ics.uci.edu/~fielding/pubs/dissertation)，而最初提出这个概念并且是一本很好的读物的书籍之一，*RESTful
    Web Services*由*Leonard Richardson*和*Sam Ruby*，现在可以从这个页面免费下载[http://restfulwebapis.org/rws.html](http://restfulwebapis.org/rws.html)。
- en: Registering with AWS
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册AWS
- en: Before we can access S3, we need to register with AWS. It is the norm for APIs
    to require registration before allowing access to their features. You can use
    either an existing Amazon account or create a new one at [http://www.amazonaws.com](http://www.amazonaws.com).
    Although S3 is ultimately a paid-for service, if you are using AWS for the first
    time, then you will get a year's free trial for low-volume use. A year is plenty
    of time for finishing this chapter! The trial provides 5GB of free S3 storage.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以访问S3之前，我们需要在AWS上注册。API通常要求在允许访问其功能之前进行注册。您可以使用现有的亚马逊账户或在[http://www.amazonaws.com](http://www.amazonaws.com)上创建一个新账户。虽然S3最终是一个付费服务，但如果您是第一次使用AWS，那么您将获得一年的免费试用，用于低容量使用。一年的时间足够完成本章的学习！试用提供5GB的免费S3存储空间。
- en: Authentication
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证
- en: Next, we need to discuss authentication, which is an important topic of discussion
    when using many web APIs. Most web APIs we use will specify a way for supplying
    authentication credentials that allow requests to be made to them, and typically
    every HTTP request we make must include authentication information.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要讨论认证，这是在使用许多Web API时的一个重要讨论话题。我们使用的大多数Web API都会指定一种提供认证凭据的方式，允许向它们发出请求，通常我们发出的每个HTTP请求都必须包含认证信息。
- en: 'APIs require this information for the following reasons:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: API需要这些信息有以下原因：
- en: To ensure that others can't abuse your application's access permissions
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保其他人无法滥用应用程序的访问权限
- en: To apply per-application rate limiting
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用每个应用程序的速率限制
- en: To manage delegation of access rights, so that an application can act on the
    behalf of other users of a service or other services
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理访问权限的委托，以便应用程序可以代表服务的其他用户或其他服务进行操作
- en: Collection of usage statistics
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集使用统计数据
- en: All of the AWS services use an HTTP request signing mechanism for authentication.
    To sign a request, we hash and sign unique data in an HTTP request using a cryptographic
    key, then add the signature to the request as a header. By recreating the signature
    on the server, AWS can ensure that the request has been sent by us, and that it
    doesn't get altered in transit.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的AWS服务都使用HTTP请求签名机制进行认证。为了签署一个请求，我们使用加密密钥对HTTP请求中的唯一数据进行哈希和签名，然后将签名作为标头添加到请求中。通过在服务器上重新创建签名，AWS可以确保请求是由我们发送的，并且在传输过程中没有被更改。
- en: 'The AWS signature generation process is currently on its 4th version, and an
    involved discussion would be needed to cover it, so we''re going to employ a third-party
    library, that is, `requests-aws4auth`. This is a companion library for the `Requests`
    module that automatically handles signature generation for us. It''s available
    at PyPi. So, install it on a command line with the help of `pip`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: AWS签名生成过程目前处于第4版，需要进行详细讨论，因此我们将使用第三方库，即`requests-aws4auth`。这是一个`Requests`模块的伴侣库，可以自动处理签名生成。它可以在PyPi上获得。因此，请在命令行上使用`pip`安装它：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Setting up an AWS user
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置AWS用户
- en: To use authentication, we need to acquire some credentials.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用身份验证，我们需要获取一些凭据。
- en: We will set this up through the AWS Console. Once you've registered with AWS,
    log into the Console at [https://console.aws.amazon.com](https://console.aws.amazon.com).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过AWS控制台进行设置。注册AWS后，登录到[https://console.aws.amazon.com](https://console.aws.amazon.com)控制台。
- en: 'Once you are logged in, you need to perform the steps shown here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您登录，您需要执行这里显示的步骤：
- en: Click on your name at the top-right, and then choose **Security Credentials**.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右上角的您的名称，然后选择**安全凭据**。
- en: Click on **Users**, which is on the list in the left-hand side of the screen,
    and then click on the **Create New Users** button at the top.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕左侧列表中的**用户**，然后点击顶部的**创建新用户**按钮。
- en: Type in the **username**, and make sure that **Generate an access key for each
    user** has been checked, and then click on the **Create** button in the bottom
    right-hand corner.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**用户名**，确保已选中**为每个用户生成访问密钥**，然后点击右下角的**创建**按钮。
- en: You'll see a new page saying that the user has been created successfully. Click
    on the **Download credentials** button at the bottom right corner to download
    a CSV file, which contains the **Access ID** and **Access Secret** for this user.
    These are important because they will help in authenticating ourselves to the
    S3 API. Make sure that you store them securely, as they will allow full access
    to your S3 files.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到一个新页面，显示用户已成功创建。点击右下角的**下载凭据**按钮下载一个CSV文件，其中包含此用户的**访问ID**和**访问密钥**。这些很重要，因为它们将帮助我们对S3
    API进行身份验证。请确保将它们安全地存储，因为它们将允许完全访问您的S3文件。
- en: 'Then, click on **Close** at the bottom of the screen, and click on the new
    user in the list that will appear, and then click on the **Attach Policy** button.
    A list of policy templates will appear. Scroll down this list and select the **AmazonS3FullAccess**
    policy, as shown in the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击屏幕底部的**关闭**，点击将出现的列表中的新用户，然后点击**附加策略**按钮。将显示一系列策略模板。滚动此列表并选择**AmazonS3FullAccess**策略，如下图所示：
- en: '![Setting up an AWS user](graphics/6008OS_03_01.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![设置AWS用户](graphics/6008OS_03_01.jpg)'
- en: Finally, click on the **Attach Policy** button at the bottom right-hand side
    when it appears. Now, our user has full access to the S3 service.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当它出现时，点击右下角的**附加策略**按钮。现在，我们的用户已完全访问S3服务。
- en: Regions
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区域
- en: AWS has datacenters around the world, so when we activate a service in AWS we
    pick the region we want it to live in. There is a list of regions for S3 at [http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region](http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: AWS在世界各地都有数据中心，因此当我们在AWS中激活服务时，我们选择希望其存在的区域。S3的区域列表在[http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region](http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region)上。
- en: It's best to choose a region that is closest to the users who will be using
    the service. For now, you'll be the only user, so just decide on the region that
    is closest to you for our first S3 tests.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最好选择离将使用该服务的用户最近的区域。目前，您将是唯一的用户，所以只需为我们的第一个S3测试选择离您最近的区域。
- en: S3 buckets and objects
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: S3存储桶和对象
- en: 'S3 organizes the data that we store in it using two concepts: buckets and objects.
    An object is the equivalent of a file, that is, a blob of data with a name, and
    a bucket is equivalent to a directory. The only difference between buckets and
    directories is that buckets cannot contain other buckets.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: S3使用两个概念来组织我们存储在其中的数据：存储桶和对象。对象相当于文件，即具有名称的数据块，而存储桶相当于目录。存储桶和目录之间唯一的区别是存储桶不能包含其他存储桶。
- en: 'Every bucket has its own URL of the form:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个存储桶都有自己的URL形式：
- en: '`http://<bucketname>.s3-<region>.amazonaws.com`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://<bucketname>.s3-<region>.amazonaws.com`。'
- en: In the URL, `<bucketname>` is the name of the bucket and `<region>` is the AWS
    region where the bucket is present, for example `eu-west-1`. The bucket name and
    region are set when we create the bucket.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在URL中，`<bucketname>`是存储桶的名称，`<region>`是存储桶所在的AWS区域，例如`eu-west-1`。存储桶名称和区域在创建存储桶时设置。
- en: Bucket names are shared globally among all S3 users, and so they must be unique.
    If you own a domain, then a subdomain of that will make an appropriate bucket
    name. You could also use your email address by replacing the `@` symbol with a
    hyphen or underscore.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 存储桶名称在所有S3用户之间是全局共享的，因此它们必须是唯一的。如果您拥有域名，则该域名的子域名将成为适当的存储桶名称。您还可以使用您的电子邮件地址，将`@`符号替换为连字符或下划线。
- en: Objects are named when we first upload them. We access objects by adding the
    object name to the end of the bucket's URL as a path. For example, if we have
    a bucket called `mybucket.example.com` in the `eu-west-1` region containing the
    object `cheeseshop.txt`, then we can access it by using the URL [http://mybucket.example.com.s3-eu-west-1.amazonaws.com/cheeseshop.txt](http://mybucket.example.com.s3-eu-west-1.amazonaws.com/cheeseshop.txt).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对象在我们首次上传时命名。我们通过将对象名称作为路径添加到存储桶的URL末尾来访问对象。例如，如果我们在`eu-west-1`区域有一个名为`mybucket.example.com`的存储桶，其中包含名为`cheeseshop.txt`的对象，那么我们可以通过URL[http://mybucket.example.com.s3-eu-west-1.amazonaws.com/cheeseshop.txt](http://mybucket.example.com.s3-eu-west-1.amazonaws.com/cheeseshop.txt)来访问它。
- en: 'Let''s create our first bucket through the AWS Console. We can perform most
    of the operations that the API exposes manually through this web interface, and
    it''s a good way of checking that our API client is performing the desired tasks:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过AWS控制台创建我们的第一个存储桶。我们可以通过这个网页界面手动执行API公开的大多数操作，并且这是检查我们的API客户端是否执行所需任务的好方法：
- en: Log into the Console at [https://console.aws.amazon.com](https://console.aws.amazon.com).
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到[https://console.aws.amazon.com](https://console.aws.amazon.com)控制台。
- en: Go to the S3 service. You will see a page, which will prompt you to create a
    bucket.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到S3服务。您将看到一个页面，提示您创建一个存储桶。
- en: Click on the **Create Bucket** button.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建存储桶**按钮。
- en: Enter a bucket name, pick a region, and then click on **Create**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入存储桶名称，选择一个区域，然后点击**创建**。
- en: You will be taken to the bucket list, and you will be able to see your bucket.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被带到存储桶列表，并且您将能够看到您的存储桶。
- en: An S3 command-line client
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个S3命令行客户端
- en: Okay, enough preparation, let's get to coding. For the rest of this section
    on S3, we will be writing a small command line client that will enable us to interact
    with the service. We will create buckets, and then upload and download files.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，准备工作足够了，让我们开始编码。在接下来的S3部分中，我们将编写一个小的命令行客户端，这将使我们能够与服务进行交互。我们将创建存储桶，然后上传和下载文件。
- en: 'First we''ll set up our command line interpreter and initialize the authentication.
    Create a file called `s3_client.py` and save the following code block in it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将设置我们的命令行解释器并初始化身份验证。创建一个名为`s3_client.py`的文件，并将以下代码块保存在其中：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: You'll need to replace `<ACCESS ID>` and `<ACCESS KEY>` with the values from
    the credentials CSV that we downloaded earlier, and `<REGION>` with the AWS region
    of your choice.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要用之前下载的凭据CSV中的值替换`<ACCESS ID>`和`<ACCESS KEY>`，并用您选择的AWS区域替换`<REGION>`。
- en: So, what are we doing here? Well, first we set up our endpoint. An endpoint
    is a general term for a URL which is used to access an API. Some web APIs have
    a single endpoint, some have many endpoints, it depends on how the API is designed.
    The endpoint we generate here is actually only a part of the full endpoint which
    we'll use when we work with buckets. Our actual endpoint is the endpoint prefixed
    by a bucket name.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在这里做什么呢？首先，我们设置了我们的端点。端点是一个通用术语，用于访问API的URL。一些Web API只有一个端点，一些有多个端点，这取决于API的设计方式。我们在这里生成的端点实际上只是我们在使用存储桶时将使用的完整端点的一部分。我们的实际端点是由存储桶名称前缀的端点。
- en: Next, we create our `auth` object. We'll use this in conjunction with `Requests`
    to add AWS authentication to our API requests.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的`auth`对象。我们将与`Requests`一起使用它来为我们的API请求添加AWS身份验证。
- en: The `ns` variable is a string, which we'll need for working with XML from the
    S3 API. We'll discuss this when we use it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`ns`变量是一个字符串，我们需要用它来处理来自S3 API的XML。我们将在使用它时讨论这个。'
- en: We've included a modified version of our `xml_pprint()` function to help with
    debugging. And, for now, the `create_bucket()` function is just a placeholder.
    We'll learn more about this in the next section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了我们的`xml_pprint()`函数的修改版本，以帮助调试。目前，`create_bucket()`函数只是一个占位符。我们将在下一节中了解更多。
- en: 'Finally, we have the command interpreter itself - it simply takes the first
    argument given to the script on the command line and tries to run a function with
    the same name, passing any remaining command-line arguments to the function. Let''s
    give this a test run. Enter the following in a command prompt:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有命令解释器本身 - 它只是获取脚本在命令行上给出的第一个参数，并尝试运行一个同名的函数，将任何剩余的命令行参数传递给函数。让我们进行一次测试。在命令提示符中输入以下内容：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see that the script pulls `create_bucket` from the command line arguments
    and so calls the function `create_bucket()`, passing `myBucket` as an argument.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到脚本从命令行参数中提取`create_bucket`，因此调用`create_bucket()`函数，将`myBucket`作为参数传递。
- en: This framework makes adding functions to expand our client's capabilities a
    straightforward process. Let's start by making `create_bucket()` do something
    useful.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架使得添加功能来扩展我们客户的能力成为一个简单的过程。让我们从使`create_bucket()`做一些有用的事情开始。
- en: Creating a bucket with the API
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用API创建一个存储桶
- en: Whenever we write a client for an API, our main point of reference is the API
    documentation. The documentation tells us how to construct the HTTP requests for
    performing operations. The S3 documentation can be found at [http://docs.aws.amazon.com/AmazonS3/latest/API/APIRest.html](http://docs.aws.amazon.com/AmazonS3/latest/API/APIRest.html).
    The [http://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUT.html](http://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUT.html)
    URL will provide the details of bucket creation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们为API编写客户端时，我们的主要参考点是API文档。文档告诉我们如何构造执行操作的HTTP请求。S3文档可以在[http://docs.aws.amazon.com/AmazonS3/latest/API/APIRest.html](http://docs.aws.amazon.com/AmazonS3/latest/API/APIRest.html)找到。[http://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUT.html](http://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketPUT.html)
    URL将提供存储桶创建的详细信息。
- en: This documentation tells us that to create a bucket we need to make an HTTP
    request to our new bucket's endpoint by using the HTTP `PUT` method. It also tells
    us that the request body must contain some XML, which specifies the AWS region
    that we want the bucket to be created in.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这份文档告诉我们，要创建一个存储桶，我们需要通过使用HTTP `PUT`方法向我们新存储桶的端点发出HTTP请求。它还告诉我们，请求正文必须包含一些XML，其中指定了我们希望创建存储桶的AWS区域。
- en: 'So, now we know what we''re aiming for, let''s discuss our function. First,
    let''s create the XML. Replace the content of `create_bucket()` with the following
    code block:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们知道我们的目标是什么，让我们讨论我们的功能。首先，让我们创建XML。用以下代码块替换`create_bucket()`的内容：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here we create an XML tree following the format given in the S3 documentation.
    If we run our client now, then we will see the XML shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个遵循S3文档中给出的格式的XML树。如果我们现在运行我们的客户端，那么我们将看到这里显示的XML：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This matches the format specified in the documentation. You can see that we've
    used the `ns` variable to fill the `xmlns` attribute. This attribute pops up throughout
    the S3 XML, having the `ns` variable pre-defined makes it quicker to work with
    it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这与文档中指定的格式相匹配。您可以看到我们使用`ns`变量来填充`xmlns`属性。这个属性在整个S3 XML中都会出现，预定义`ns`变量使得更快地处理它。
- en: 'Now, let''s add the code to make the request. Replace the `xml_pprint(data)`
    at the end of `create_bucket()` with the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加代码来发出请求。将`create_bucket()`末尾的`xml_pprint(data)`替换为以下内容：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line shown here will generate the full URL from our bucket name and
    endpoint. The second line will make the request to the S3 API. Notice that we
    have used the `requests.put()` function to make this request using the HTTP `PUT`
    method, rather than by using either the `requests.get()`method or the `requests.post()`
    method. Also, note that we have supplied our `auth` object to the call. This will
    allow `Requests` to handle all the S3 authentication for us!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的第一行将从我们的存储桶名称和端点生成完整的URL。第二行将向S3 API发出请求。请注意，我们使用`requests.put()`函数使用HTTP
    `PUT`方法进行此请求，而不是使用`requests.get()`方法或`requests.post()`方法。还要注意，我们已经提供了我们的`auth`对象给调用。这将允许`Requests`为我们处理所有S3身份验证！
- en: If all goes well , then we print out a message. In case everything does not
    go as expected, we print out the response body. S3 returns error messages as XML
    in the response body. So we use our `xml_pprint()` function to display it. We'll
    look at working with these errors in the *Handling errors* section, later on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将打印出一条消息。如果一切不如预期，我们将打印出响应正文。S3将错误消息作为XML返回到响应正文中。因此，我们使用我们的`xml_pprint()`函数来显示它。稍后我们将在*处理错误*部分讨论处理这些错误。
- en: 'Now run the client, and if everything works as expected, then we will get a
    confirmation message. Make sure that you have picked a bucket that hasn''t already
    been created:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行客户端，如果一切正常，那么我们将收到确认消息。确保您选择的存储桶尚未创建：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When we refresh the S3 Console in our browser, we will see that our bucket has
    been created.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在浏览器中刷新S3控制台时，我们将看到我们的存储桶已创建。
- en: Uploading a file
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上传文件
- en: Now that we've created a bucket, we can upload some files. Writing a function
    for uploading a file is similar to creating a bucket. We check the documentation
    to see how to construct our HTTP request, figure out what information should be
    collected at the command line, and then write the function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个存储桶，我们可以上传一些文件。编写一个上传文件的函数类似于创建一个存储桶。我们查看文档以了解如何构建我们的HTTP请求，找出应该在命令行收集哪些信息，然后编写函数。
- en: We need to use an HTTP `PUT` again. We need the name of the bucket that we want
    to store the file in and the name that we want the file to be stored under in
    S3\. The body of the request will contain the file data. At the command line,
    we'll collect the bucket name, the name we want the file to have in the S3 service
    and the name of the local file to upload.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要再次使用HTTP `PUT`。我们需要存储文件的存储桶名称以及我们希望文件在S3中存储的名称。请求的正文将包含文件数据。在命令行中，我们将收集存储桶名称，我们希望文件在S3服务中存储的名称以及要上传的本地文件的名称。
- en: 'Add the following function to your `s3_client.py` file after the `create_bucket()`
    function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`create_bucket()`函数之后将以下函数添加到您的`s3_client.py`文件中：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In creating this function, we follow a pattern similar to that for creating
    a bucket:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建此函数时，我们遵循了与创建存储桶类似的模式：
- en: Prepare the data that will go in the request body.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备要放入请求正文中的数据。
- en: Construct our URL.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建我们的URL。
- en: Make the request.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出请求。
- en: Check the outcome.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查结果。
- en: Note that we open the local file in binary mode. The file could contain any
    type of data, so we don't want text transforms applied. We could pull this data
    from anywhere, such as a database or another web API. Here, we just use a local
    file for simplicity.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们以二进制模式打开本地文件。文件可以包含任何类型的数据，因此我们不希望应用文本转换。我们可以从任何地方获取这些数据，例如数据库或另一个Web
    API。在这里，我们只是简单地使用本地文件。
- en: The URL is the same endpoint that we constructed in `create_bucket()` with the
    S3 object name appended to the URL path. Later, we can use this URL to retrieve
    the object.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: URL与我们在`create_bucket()`中构建的端点相同，并且S3对象名称附加到URL路径。稍后，我们可以使用此URL检索对象。
- en: 'Now, run the command shown here to upload a file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行这里显示的命令来上传一个文件：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You'll need to replace `mybucket.example.com` with your own bucket name. Once
    the file gets uploaded, you will see it in the S3 Console.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将`mybucket.example.com`替换为您自己的存储桶名称。一旦文件上传完成，您将在S3控制台中看到它。
- en: I have used a JPEG image that was stored in my home directory as the source
    file. You can use any file, just change the last argument to an appropriate path.
    However, using a JPEG image will make the following sections easier for you to
    reproduce.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了一个存储在我的主目录中的JPEG图像作为源文件。您可以使用任何文件，只需将最后一个参数更改为适当的路径。但是，使用JPEG图像将使您更容易重现以下部分。
- en: Retrieving an uploaded file through a web browser
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过Web浏览器检索已上传的文件
- en: By default, S3 applies restrictive permissions for buckets and objects. The
    account that creates them has full read-write permissions, but access is completely
    denied for anyone else. This means that the file that we've just uploaded can
    only be downloaded if the download request includes authentication for our account.
    If we try the resulting URL in a browser, then we'll get an access denied error.
    This isn't very useful if we're trying to use S3 for sharing files with other
    people.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，S3对存储桶和对象应用限制权限。创建它们的帐户具有完全的读写权限，但对于其他人完全拒绝访问。这意味着我们刚刚上传的文件只有在下载请求包括我们帐户的身份验证时才能下载。如果我们在浏览器中尝试结果URL，那么我们将收到访问被拒绝的错误。如果我们试图使用S3与其他人共享文件，这并不是很有用。
- en: 'The solution for this is to use one of S3''s mechanisms for changing the permissions.
    Let''s look at the simple task of making our uploaded file public. Change `upload_file()`
    to the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的方法是使用S3的一种机制来更改权限。让我们看看使我们上传的文件公开的简单任务。将`upload_file()`更改为以下内容：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We have now included a header in our HTTP request, `x-amz-acl`, which specifies
    a permission set to be applied to the object. We've also added a new argument
    to our function signature so that we can specify the permission set on the command
    line. We have used the so-called **canned** **ACLs** (**canned** **Access Control
    Lists**), which have been provided by S3, and are documented at [http://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl](http://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在我们的HTTP请求中包含了一个头部，`x-amz-acl`，它指定了要应用于对象的权限集。我们还在函数签名中添加了一个新的参数，这样我们就可以在命令行上指定权限集。我们使用了S3提供的所谓的**预设**
    **ACLs**（**预设** **访问控制列表**），并在[http://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl](http://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl)中进行了记录。
- en: 'The ACL that we''re interested in is called `public-read`. This will allow
    anyone to download the file without needing any kind of authentication. We can
    now re-run our upload, but this time it will apply this ACL to it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的ACL称为`public-read`。这将允许任何人下载文件而无需任何形式的身份验证。现在，我们可以重新运行我们的上传，但这次会将这个ACL应用到它上面：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, visiting the file's S3 URL in a browser will give us the option to download
    the file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中访问文件的S3 URL将给我们下载文件的选项。
- en: Displaying an uploaded file in a web browser
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Web浏览器中显示上传的文件
- en: If you have uploaded an image, then you may be wondering why the browser had
    asked us to save it instead of just displaying it. The reason is that we haven't
    set the file's `Content-Type`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你上传了一张图片，那么你可能会想知道为什么浏览器要求我们保存它而不是直接显示它。原因是我们没有设置文件的`Content-Type`。
- en: If you remember from the last chapter, the `Content-Type` header in an HTTP
    response tells the client, which in this case is our browser, the type of file
    that is in the body. By default, S3 applies the content type of `binary/octet-stream`.
    Because of this `Content-Type`, the browser can't tell that it's downloading an
    image, so it just presents it as a file that can be saved. We can fix this by
    supplying a `Content-Type` header in the upload request. S3 will store the type
    that we specify, and it will use it as the `Content-Type` in the subsequent download
    responses.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得上一章，HTTP响应中的`Content-Type`头部告诉客户端，这里是我们的浏览器，正文中的文件类型。默认情况下，S3应用`binary/octet-stream`的内容类型。由于这个`Content-Type`，浏览器无法知道它正在下载一个图像，所以它只是将它呈现为一个可以保存的文件。我们可以通过在上传请求中提供`Content-Type`头部来解决这个问题。S3将存储我们指定的类型，并在随后的下载响应中使用它作为`Content-Type`。
- en: 'Add the code block shown here to the import at the beginning of `s3_client.py`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`s3_client.py`的开头添加以下代码块到导入中：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then change `upload_file()` to this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将`upload_file()`更改为以下内容：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we have used the `mimetypes` module to guess a suitable `Content-Type`
    by looking at the file extension of `local_path`. If `mimetypes` can't determine
    a `Content-Type` from `local_path`, then we don't include the `Content-Type` header,
    and let S3 apply the default `binary/octet-stream` type.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`mimetypes`模块来猜测一个适合的`Content-Type`，通过查看`local_path`的文件扩展名。如果`mimetypes`无法从`local_path`确定`Content-Type`，那么我们就不包括`Content-Type`头部，让S3应用默认的`binary/octet-stream`类型。
- en: Unfortunately, in S3 we won't be able to overwrite the metadata for an existing
    object by using a simple `PUT` request. It's possible to do it by using a `PUT`
    copy request, but that's beyond the scope of this chapter. For now, it's better
    to just delete the file from S3 by using the AWS Console before uploading it again.
    We only need to do this once. Now, our code will automatically add the `Content-Type`
    for any new file that we upload.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在S3中，我们无法通过简单的`PUT`请求覆盖现有对象的元数据。可以通过使用`PUT`复制请求来实现，但这超出了本章的范围。现在，最好的方法是在上传文件之前使用AWS控制台从S3中删除文件。我们只需要做一次。现在，我们的代码将自动为我们上传的任何新文件添加`Content-Type`。
- en: Once you've deleted the file, re-run the client just as shown in the last section,
    that is, upload the file with the new `Content-Type` and try to download the file
    in a browser again. If all goes well, then the image will be displayed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你删除了文件，就像上一节所示重新运行客户端，也就是说，用新的`Content-Type`上传文件并尝试在浏览器中再次下载文件。如果一切顺利，那么图像将被显示。
- en: Downloading a file with the API
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用API下载文件
- en: Downloading a file through the S3 API is similar to uploading it. We simply
    take the bucket name, the S3 object name and the local filename again but issue
    a `GET` request instead of a `PUT request`, and then write the data received to
    disk.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过S3 API下载文件与上传文件类似。我们只需要再次提供存储桶名称、S3对象名称和本地文件名，但是发出一个`GET`请求而不是`PUT`请求，然后将接收到的数据写入磁盘。
- en: 'Add the following function to your program, underneath the `upload_file()`
    function:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的程序中添加以下函数，放在`upload_file()`函数下面：
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, run the client and download a file, which you have uploaded previously,
    by using the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行客户端并下载一个文件，你之前上传的文件，使用以下命令：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Parsing XML and handling errors
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析XML和处理错误
- en: 'If you ran into any errors while running the aforementioned code, then you''ll
    notice that a clear error message will not get displayed. S3 embeds error messages
    in the XML returned in the response body, and until now we''ve just been dumping
    the raw XML to the screen. We can improve on this and pull the text out of the
    XML. First, let''s generate an error message so that we can see what the XML looks
    like. In `s3_client.py`, replace your access secret with an empty string, as shown
    here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行上述代码时遇到任何错误，那么你会注意到清晰的错误消息不会被显示。S3将错误消息嵌入到响应体中返回的XML中，直到现在我们只是将原始XML转储到屏幕上。我们可以改进这一点，并从XML中提取文本。首先，让我们生成一个错误消息，这样我们就可以看到XML的样子。在`s3_client.py`中，将你的访问密钥替换为空字符串，如下所示：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, try and perform the following operation on the service:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试在服务上执行以下操作：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding XML is the S3 error information. I've truncated several of the
    fields so as to show it here. Your code block will be slightly longer than this.
    In this case, it's telling us that it can't authenticate our request, and this
    is because we have set a blank access secret.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的XML是S3错误信息。我已经截断了几个字段以便在这里显示。你的代码块会比这个稍微长一点。在这种情况下，它告诉我们它无法验证我们的请求，这是因为我们设置了一个空的访问密钥。
- en: Parsing XML
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析XML
- en: Printing all of the XML is too much for an error message. There's a lot of extraneous
    information which isn't useful to us. It would be better if we could just pull
    out the useful parts of the error message and display them.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 打印所有的XML对于错误消息来说太多了。有很多无用的额外信息对我们来说没有用。最好的办法是只提取错误消息的有用部分并显示出来。
- en: Well, `ElementTree` gives us some powerful tools for extracting such information
    from XML. We're going back to XML for a while to explore these tools a little.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，`ElementTree`为我们从XML中提取这样的信息提供了一些强大的工具。我们将回到XML一段时间，来探索这些工具。
- en: 'First we need to open an interactive Python shell, and then generate the aforementioned
    error message again by using the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要打开一个交互式的Python shell，然后使用以下命令再次生成上述错误消息：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You'll need to replace `<ID>` with your AWS access ID. Print out `r.text` to
    make sure that you get an error message, which is similar to the one that we generated
    earlier.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要用你的AWS访问ID替换`<ID>`。打印出`r.text`以确保你得到一个错误消息，类似于我们之前生成的那个。
- en: 'Now, we can explore our XML. Convert the XML text into an `ElementTree` tree.
    A handy function for doing this is:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以探索我们的XML。将XML文本转换为`ElementTree`树。一个方便的函数是：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We now have an ElementTree instance, with `root` as the root element.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个ElementTree实例，`root`作为根元素。
- en: Finding elements
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找元素
- en: 'The simplest way of navigating the tree is by using the elements as iterators.
    Try doing the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用元素作为迭代器来浏览树的最简单方法。尝试做以下事情：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Iterating over `root` returns each of its child elements, and then we print
    out the tag of an element by using the `tag` attribute.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代`root`会返回它的每个子元素，然后我们通过使用`tag`属性打印出元素的标签。
- en: 'We can apply a filter to the tags that we iterate over by using the following
    command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令对我们迭代的标签应用过滤器：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we have used the `findall()` method of the `root` element. This method
    will provide us with a list of all the direct children of the `root` element that
    match the specified tag, which in this case is `<Message>`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`root`元素的`findall()`方法。这个方法将为我们提供与指定标签匹配的`root`元素的所有直接子元素的列表，在这种情况下是`<Message>`。
- en: And this will solve our problem of just extracting the text of the error message.
    Now, let's update our error handling.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解决我们只提取错误消息文本的问题。现在，让我们更新我们的错误处理。
- en: Handling errors
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理错误
- en: 'We can go back and add this to our `s3_client.py` file, but let''s include
    a little more information in the output, and structure the code to allow re-use.
    Add the following function to the file underneath the `download_file()` function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以回去并将这添加到我们的`s3_client.py`文件中，但让我们在输出中包含更多信息，并结构化代码以允许重用。将以下函数添加到`download_file()`函数下面的文件中：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You'll notice that we have used a new function here, namely, `root.find()`.
    This works in the same way as `findall()` except that it only returns the first
    matching element, as opposed to a list of all matching elements.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们在这里使用了一个新的函数，即`root.find()`。这与`findall()`的工作方式相同，只是它只返回第一个匹配的元素，而不是所有匹配的元素列表。
- en: 'Then, replace each instance of `xml_pprint(r.text)` in your file with `handle_error(r)`
    and then run the client again with the incorrect access secret. Now, you will
    see a more informative error message:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，用`handle_error(r)`替换文件中每个`xml_pprint(r.text)`的实例，然后再次使用错误的访问密钥运行客户端。现在，你会看到一个更详细的错误消息：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Further enhancements
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步的增强
- en: That's as far as we're going to take our client. We've written a command line
    program that can perform essential operations, such as creating buckets and uploading
    and downloading objects on the Amazon S3 service. There are still plenty of operations
    that can be implemented, and these can be found in the S3 documentation; operations
    such as listing buckets' contents, deleting objects, and copying objects.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们要为客户提供的服务。我们编写了一个命令行程序，可以在Amazon S3服务上执行创建存储桶、上传和下载对象等基本操作。还有很多操作可以实现，这些可以在S3文档中找到；例如列出存储桶内容、删除对象和复制对象等操作。
- en: We could improve a few other things, especially if we are going to make this
    into a production application. The command-line parsing mechanism, although compact,
    is not satisfactory from a security perspective, since anybody with access to
    the command line can run any built-in python command. It would be better to have
    a whitelist of functions and to implement a proper command line parser by using
    one of the standard library modules like `argparse`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以改进一些其他东西，特别是如果我们要将其制作成一个生产应用程序。命令行解析机制虽然紧凑，但从安全角度来看并不令人满意，因为任何有权访问命令行的人都可以运行任何内置的python命令。最好是有一个函数白名单，并使用标准库模块之一，如`argparse`来实现一个适当的命令行解析器。
- en: Storing the access ID and the access secret in the source code is also a problem
    for security. Several serious security incidents have happened because passwords
    were stored in source code and then uploaded to cloud code repositories. It's
    much better to load the keys from an external source, such as a file or a database
    at run time.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将访问ID和访问密钥存储在源代码中也是安全问题。由于密码存储在源代码中，然后上传到云代码仓库，发生了几起严重的安全事件。最好在运行时从外部来源加载密钥，比如文件或数据库。
- en: The Boto package
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boto包
- en: We've discussed working directly with the S3 REST API, and this has given us
    some useful techniques that will allow us to program against similar APIs in the
    future. In many cases, this will be the only way in which we can interact with
    a web API.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了直接使用S3 REST API，并且这给了我们一些有用的技术，让我们能够在将来编写类似API时进行编程。在许多情况下，这将是我们与Web
    API交互的唯一方式。
- en: However, some APIs, including AWS, have ready-to-use packages which expose the
    functionality of the service without having to deal with the complexities of the
    HTTP API. These packages generally make the code cleaner and simpler, and they
    should be preferred for doing production work if they're available.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些API，包括AWS，有现成的包可以暴露服务的功能，而无需处理HTTP API的复杂性。这些包通常使代码更清晰、更简单，如果可用的话，应该优先用于生产工作。
- en: The AWS package is called **Boto**. We will take a very quick look at the `Boto`
    package to see how it can provide some of the functionalities that we wrote earlier.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: AWS包被称为**Boto**。我们将快速浏览一下`Boto`包，看看它如何提供我们之前编写的一些功能。
- en: 'The `boto` package is available in PyPi, so we can install it with `pip`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`boto`包在PyPi中可用，所以我们可以用`pip`安装它：'
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, fire up a Python shell and let''s try it out. We need to connect to the
    service first:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动一个Python shell，让我们试一试。我们需要先连接到服务：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You''ll need to replace `<ACCESS ID>` and `<ACCESS SECRET>` with your access
    ID and access secret. Now, let''s create a bucket:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要用您的访问ID和访问密钥替换`<ACCESS ID>`和`<ACCESS SECRET>`。现在，让我们创建一个存储桶：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This creates the bucket in the default standard US region. We can supply a
    different region, as shown here:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在默认的标准美国地区创建存储桶。我们可以提供不同的地区，如下所示：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The region names we need to use for this function are different to the ones
    we used when creating buckets earlier. To see a list of acceptable region names
    do this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用不同的区域名称来执行此功能，这些名称与我们之前创建存储桶时使用的名称不同。要查看可接受的区域名称列表，请执行以下操作：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Do the following to display a list of the buckets we own:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作以显示我们拥有的存储桶列表：
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can also list the contents of a bucket. To do so, first, we need to get
    a reference to it:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以列出存储桶的内容。为此，首先我们需要获取对它的引用：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And then to list the contents:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后列出内容：
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Uploading a file is a straightforward process. First, we need to get a reference
    to the bucket that we want to put it in, and then we need to create a `Key` object,
    which will represent our object in the bucket:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 上传文件是一个简单的过程。首先，我们需要获取要放入的存储桶的引用，然后我们需要创建一个`Key`对象，它将代表我们在存储桶中的对象：
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we have to set the `Key` name and then upload our file data:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置`Key`名称，然后上传我们的文件数据：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `boto` package will automatically set the `Content-Type` when it uploads
    a file like this, and it uses the same `mimetypes` module that we used earlier
    for determining a type.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`boto`包在上传文件时会自动设置`Content-Type`，它使用了我们之前用于确定类型的`mimetypes`模块。'
- en: 'Downloading also follows a similar pattern. Try the following commands:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 下载也遵循类似的模式。尝试以下命令：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This downloads the `parrot.txt` S3 object in the `mybucket.example.com` bucket
    and then stores it in the `~/parrot.txt` local file.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载`mybucket.example.com`存储桶中的`parrot.txt` S3对象，然后将其存储在`~/parrot.txt`本地文件中。
- en: 'Once we have a reference to the key, just use the following to set the ACL:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了对`Key`的引用，只需使用以下内容来设置ACL：
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: I'll leave you to further explore the `boto` package's functionality with the
    help of the tutorial, which can be found at [https://boto.readthedocs.org/en/latest/s3_tut.html](https://boto.readthedocs.org/en/latest/s3_tut.html).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我将让您通过教程进一步探索`boto`包的功能，该教程可以在[https://boto.readthedocs.org/en/latest/s3_tut.html](https://boto.readthedocs.org/en/latest/s3_tut.html)找到。
- en: It should be evident that for everyday S3 work in Python, `boto` should be your
    go to package.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，对于Python中的日常S3工作，`boto`应该是您的首选包。
- en: Wrapping up with S3
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束S3
- en: So, we've discussed some of the uses of the Amazon S3 API, and learned some
    things about working with XML in Python. These skills should give you a good start
    in working with any XML based REST API, whether or not it has a pre-built library
    like `boto`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经讨论了Amazon S3 API的一些用途，并学到了一些关于在Python中使用XML的知识。这些技能应该让您在使用任何基于XML的REST
    API时有一个良好的开端，无论它是否有像`boto`这样的预构建库。
- en: 'However, XML isn''t the only data format that is used by web APIs, and the
    S3 way of working with HTTP isn''t the only model used by web APIs. So, we''re
    going to move on and take a look at the other major data format in use today,
    JSON and another API: Twitter.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，XML并不是Web API使用的唯一数据格式，S3处理HTTP的方式也不是Web API使用的唯一模型。因此，我们将继续并看一看今天使用的另一种主要数据格式，JSON和另一个API：Twitter。
- en: JSON
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: '**JavaScript Object Notation (JSON)** is a standard way of representing simple
    objects, such as `lists` and `dicts`, in the form of text strings. Although, it
    was originally developed for JavaScript, JSON is language independent and most
    languages can work with it. It''s lightweight, yet flexible enough to handle a
    broad range of data. This makes it ideal for exchanging data over HTTP, and a
    large number of web APIs use this as their primary data format.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法（JSON）**是一种用文本字符串表示简单对象（如`列表`和`字典`）的标准方式。尽管最初是为JavaScript开发的，但JSON是与语言无关的，大多数语言都可以使用它。它轻巧，但足够灵活，可以处理广泛的数据范围。这使得它非常适合在HTTP上传数据，许多Web
    API使用它作为其主要数据格式。'
- en: Encoding and decoding
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码和解码
- en: 'We use the `json` module for working with JSON in Python. Let''s create a JSON
    representation of a Python list by using the following commands:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`json`模块来处理Python中的JSON。通过以下命令，让我们创建一个Python列表的JSON表示：
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We use the `json.dumps()` function for converting an object to a JSON string.
    In this case, we can see that the JSON string appears to be identical to Python''s
    own representation of a list, but note that this is a string. Confirm this by
    doing the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`json.dumps()`函数将对象转换为JSON字符串。在这种情况下，我们可以看到JSON字符串似乎与Python对列表的表示相同，但请注意这是一个字符串。通过以下操作确认：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Converting JSON to a Python object is also straightforward, as shown here:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 将JSON转换为Python对象也很简单，如下所示：
- en: '[PRE49]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We use the `json.loads()` function, and just pass it a JSON string. As we'll
    see, this is very powerful when interacting with web APIs. Typically, we will
    receive a JSON string as the body of an HTTP response, which can simply be decoded
    using `json.loads()` to provide immediately usable Python objects.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`json.loads()`函数，只需传递一个JSON字符串。正如我们将看到的，这在与Web API交互时非常强大。通常，我们将收到一个JSON字符串作为HTTP响应的主体，只需使用`json.loads()`进行解码，即可提供可立即使用的Python对象。
- en: Using dicts with JSON
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JSON的字典
- en: JSON natively supports a mapping-type object, which is equivalent to a Python
    `dict`. This means that we can work directly with `dicts` through JSON.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: JSON本身支持映射类型对象，相当于Python的`dict`。这意味着我们可以直接通过JSON使用`dicts`。
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Also, it is useful to know how JSON handles nested objects.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，了解JSON如何处理嵌套对象也是有用的。
- en: '[PRE51]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'There is just one gotcha though: JSON dictionary keys can only be in the form
    of strings.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 不过有一个需要注意的地方：JSON字典键只能是字符串形式。
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Notice, how the keys in the JSON dictionary become string representations of
    integers? To decode a JSON dictionary that uses numeric keys, we need to manually
    type-convert them if we want to work with them as numbers. Do the following to
    accomplish this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，JSON字典中的键如何成为整数的字符串表示？要解码使用数字键的JSON字典，如果我们想将它们作为数字处理，我们需要手动进行类型转换。执行以下操作来实现这一点：
- en: '[PRE53]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We just use a dictionary comprehension to apply `int()` to the dictionary's
    keys.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需使用字典推导将`int()`应用于字典的键。
- en: Other object types
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他对象类型
- en: 'JSON cleanly handles only Python `lists` and `dicts`, for other object types
    `json` may attempt to cast the object type as one or the other, or fail completely.
    Try a tuple, as shown here:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: JSON只能干净地处理Python的`lists`和`dicts`，对于其他对象类型，`json`可能会尝试将对象类型转换为其中一个，或者完全失败。尝试一个元组，如下所示：
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'JSON doesn''t have a tuple data type, so the `json` module will cast it to
    a `list`. If we convert it back:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: JSON没有元组数据类型，因此`json`模块将其转换为`list`。如果我们将其转换回：
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'It will still remain a `list`. The `json` module doesn''t support `sets`, so
    they also need to be recast as `lists`. Try the following commands:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 它仍然是一个`list`。`json`模块不支持`sets`，因此它们也需要重新转换为`lists`。尝试以下命令：
- en: '[PRE56]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This will cause problems similar to the ones caused by tuples. If we convert
    the JSON back to a Python object, then it will be a `list` and not a `set`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致类似于元组引起的问题。如果我们将JSON转换回Python对象，那么它将是一个`list`而不是`set`。
- en: We almost never encounter web APIs that need these kinds of specialist Python
    objects, and if we do, then the API should provide some kind of convention for
    handling it. But we do need to keep track of any conversions that we would need
    to apply to the outgoing or the incoming objects, if we were storing the data
    locally in any format other than that of `lists` or `dicts`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎从不遇到需要这些专门的Python对象的Web API，如果我们确实遇到，那么API应该提供一些处理它的约定。但是，如果我们将数据存储在除`lists`或`dicts`之外的任何格式中，我们需要跟踪我们需要应用于传出或传入对象的任何转换。
- en: Now that we have an understanding of JSON, let's see how it works in a web API.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对JSON有了一定的了解，让我们看看它在Web API中是如何工作的。
- en: The Twitter API
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Twitter API
- en: The Twitter API provides access to all the functions that we may want a Twitter
    client to perform. With the Twitter API, we can create clients that search for
    recent tweets, find out what's trending, look up user details, follow users' timelines,
    and even act on the behalf of users by posting tweets and direct messages for
    them.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter API提供了访问我们可能希望Twitter客户端执行的所有功能。使用Twitter API，我们可以创建搜索最新推文、查找趋势、查找用户详细信息、关注用户时间线，甚至代表用户发布推文和直接消息的客户端。
- en: We'll be looking at Twitter API version 1.1, the version current at time of
    writing this chapter.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看Twitter API版本1.1，这是撰写本章时的当前版本。
- en: Note
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Twitter maintains comprehensive documentation for its API, which can be found
    at [https://dev.twitter.com/overview/documentation](https://dev.twitter.com/overview/documentation).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter为其API提供了全面的文档，可以在[https://dev.twitter.com/overview/documentation](https://dev.twitter.com/overview/documentation)找到。
- en: A Twitter world clock
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个Twitter世界时钟
- en: To illustrate some of the functionalities of the Twitter API, we're going to
    write the code for a simple Twitter world clock. Our application will periodically
    poll its Twitter account for mentions which contain a recognizable city name,
    and if it finds one, then it will reply to the Tweet with the current local time
    of that city. In Twitter speak, a mention is any Tweet which includes our account
    name prefixed by an `@`, for example, `@myaccount`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明Twitter API的一些功能，我们将编写一个简单的Twitter世界时钟的代码。我们的应用程序将定期轮询其Twitter账户，寻找包含可识别城市名称的提及，如果找到，则会回复推文并显示该城市的当前当地时间。在Twitter中，提及是指包含我们账户名前缀`@`的任何推文，例如`@myaccount`。
- en: Authentication for Twitter
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Twitter的身份验证
- en: Similar to S3, we need to determine how authentication will be managed before
    we get started. We need to register, and then we need to find out how Twitter
    expects us to authenticate our requests.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 与S3类似，我们需要确定在开始之前如何管理身份验证。我们需要注册，然后了解Twitter希望我们如何对请求进行身份验证。
- en: Registering your application for the Twitter API
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为Twitter API注册您的应用程序
- en: We need to create a Twitter account, register our application against the account,
    and then we will receive the authentication credentials for our app. It's also
    a good idea to set up a second account, which we can use for sending test tweets
    to the application account. This provides for a cleaner way of checking whether
    the app is working properly, rather than having the app account send tweets to
    itself. There's no limit on the number of Twitter accounts that you can create.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个Twitter账户，注册我们的应用程序，并且我们将收到我们应用程序的身份验证凭据。另外，建立一个第二个账户也是一个好主意，我们可以用它来向应用程序账户发送测试推文。这提供了一种更干净的方式来检查应用程序是否正常工作，而不是让应用程序账户向自己发送推文。您可以创建的Twitter账户数量没有限制。
- en: 'To create an account, go to [http://www.twitter.com](http://www.twitter.com)
    and complete the signup process. Do the following for registering your application
    once you have a Twitter account:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建帐户，请转到[http://www.twitter.com](http://www.twitter.com)并完成注册过程。一旦您拥有Twitter帐户，执行以下操作注册您的应用程序：
- en: Log into [http://apps.twitter.com](http://apps.twitter.com) with your main Twitter
    account, and then create a new app.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的主要Twitter帐户登录[http://apps.twitter.com](http://apps.twitter.com)，然后创建一个新应用程序。
- en: Fill out the new app form, note that Twitter application names need to be unique
    globally.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写新应用程序表格，注意Twitter应用程序名称需要在全球范围内是唯一的。
- en: Go to the app's settings and then change the app permissions to have read and
    write access. You may need to register your mobile number for enabling this. Even
    if you're unhappy about supplying this, we can create the full app; however the
    final function that sends a tweet in reply won't be active.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到应用程序设置，然后更改应用程序权限以具有读写访问权限。您可能需要注册您的手机号码以启用此功能。即使您不愿意提供这个信息，我们也可以创建完整的应用程序；但是，最终发送回复推文的最终功能将不会激活。
- en: 'Now we need to get our access credentials, as shown here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要获取我们的访问凭证，如下所示：
- en: Go to the **Keys and Access Tokens** section and then note the **Consumer Key**
    and the **Access Secret**.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**Keys and Access Tokens**部分，然后记下**Consumer Key**和**Access Secret**。
- en: Generate an **Access Token**.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个**访问令牌**。
- en: Note down the **Access Token** and the **Access Secret**.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记下**访问令牌**和**访问密钥**。
- en: Authenticating requests
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证请求
- en: We now have enough information for authenticating requests. Twitter uses an
    authentication standard called **oAuth,** version 1.0a. It's described in detail
    at [http://oauth.net/core/1.0a/](http://oauth.net/core/1.0a/).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有足够的信息来进行请求认证。Twitter使用一个称为**oAuth**的认证标准，版本1.0a。详细描述在[http://oauth.net/core/1.0a/](http://oauth.net/core/1.0a/)。
- en: The oAuth authentication standard is a little tricky, but fortunately the `Requests`
    module has a companion library called `requests-oauthlib`, which can handle most
    of the complexity for us. This is available on PyPi, so we can download and install
    it with `pip`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: oAuth认证标准有点棘手，但幸运的是，`Requests`模块有一个名为`requests-oauthlib`的伴侣库，它可以为我们处理大部分复杂性。这在PyPi上可用，因此我们可以使用`pip`下载和安装它。
- en: '[PRE57]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, we can add authentication to our requests, and then write our application.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为我们的请求添加认证，然后编写我们的应用程序。
- en: A Twitter client
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个Twitter客户端
- en: 'Save the code mentioned here to a file, and save it as `twitter_worldclock.py`.
    You''ll need to replace `<CONSUMER_KEY>`, `<CONSUMER_SECRET>`, `<ACCESS_TOKEN>`,
    and `<ACCESS_SECRET>` with the values that you have taken down from the aforementioned
    Twitter app configuration:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 将此处提到的代码保存到文件中，并将其保存为`twitter_worldclock.py`。您需要用从上述Twitter应用程序配置中获取的值替换`<CONSUMER_KEY>`，`<CONSUMER_SECRET>`，`<ACCESS_TOKEN>`和`<ACCESS_SECRET>`：
- en: '[PRE58]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Remember that `consumer_secret` and `access_secret` act as the password to your
    Twitter account, so in a production app they should be loaded from a secure external
    location instead of being hard-coded into the source code.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`consumer_secret`和`access_secret`充当您的Twitter帐户的密码，因此在生产应用程序中，它们应该从安全的外部位置加载，而不是硬编码到源代码中。
- en: In the aforementioned code, we create the `OAuth1` authentication instance,
    `auth_obj`, in the `init_auth()` function by using our access credentials. We
    pass this to `Requests` whenever we need to make an HTTP request, and through
    it `Requests` handles the authentication. You can see an example of this in the
    `verify_credentials()` function.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们通过使用我们的访问凭证在`init_auth()`函数中创建`OAuth1`认证实例`auth_obj`。每当我们需要发出HTTP请求时，我们将其传递给`Requests`，通过它`Requests`处理认证。您可以在`verify_credentials()`函数中看到这个例子。
- en: In the `verify_credentials()` function, we test whether Twitter recognizes our
    credentials. The URL that we're using here is an endpoint that Twitter provides
    purely for testing whether our credentials are valid. It returns an HTTP 200 status
    code if they are valid or a 401 status code if not.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在`verify_credentials()`函数中，我们测试Twitter是否识别我们的凭据。我们在这里使用的URL是Twitter专门用于测试我们的凭据是否有效的终点。如果它们有效，则返回HTTP
    200状态代码，否则返回401状态代码。
- en: 'Now, let''s run `twitter_worldclock.py` and if we''ve registered our application
    and filled out the tokens and secrets properly, then we should see `Validated
    credentials OK`. Now that the authentication is working, the basic flow of our
    program will be, as shown in the following diagram:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行`twitter_worldclock.py`，如果我们已经注册了我们的应用程序并正确填写了令牌和密钥，那么我们应该会看到`验证凭据OK`。现在认证已经工作，我们程序的基本流程将如下图所示：
- en: '![A Twitter client](graphics/6008OS_03_02.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![Twitter客户端](graphics/6008OS_03_02.jpg)'
- en: Our program will be running as a daemon, polling Twitter periodically to see
    whether there are any new tweets for us to process and reply to. When we poll
    the mentions timeline, we will download any new tweets that were received in a
    single batch since our last poll, so that we can process all of them without having
    to poll again.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序将作为守护程序运行，定期轮询Twitter，查看是否有任何新的推文需要我们处理和回复。当我们轮询提及时间线时，我们将下载自上次轮询以来接收到的任何新推文，以便我们可以处理所有这些推文而无需再次轮询。
- en: Polling for Tweets
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轮询推文
- en: 'Let''s add a function for checking and retrieving new tweets from our mentions
    timeline. We''ll get this to work before we add the loop. Add the new function
    underneath `verify_credentials()`, and then add a call this function to the main
    section, as shown here; also, add `json` to the list of the imports at the beginning
    of the file:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个函数来检查并从我们的提及时间线中检索新推文。在我们添加循环之前，我们将使其工作。在`verify_credentials()`下面添加新函数，然后在主部分中添加对此函数的调用；同时，在文件开头的导入列表中添加`json`：
- en: '[PRE59]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Using `get_mentions()`, we check for and download any tweets that mention our
    app account by connecting to the `statuses/mentions_timeline.json` endpoint. We
    supply a number of parameters, which `Requests` passes on as a query string. These
    parameters are specified by Twitter and they control how the tweets will be returned
    to us. They are as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`get_mentions()`，我们通过连接到`statuses/mentions_timeline.json`端点来检查并下载提及我们应用账户的任何推文。我们提供了一些参数，`Requests`将其作为查询字符串传递。这些参数由Twitter指定，它们控制推文将如何返回给我们。它们如下：
- en: '`''count''`: This specifies the maximum number of tweets that will be returned.
    Twitter will allow 200 tweets to be received by a single request made to this
    endpoint.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''count''`：这指定将返回的最大推文数。Twitter将允许通过单个请求接收200条推文。'
- en: '`''include_entities''`: This is used for trimming down some extraneous information
    from the tweets retrieved.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''include_entities''`：这用于从检索到的推文中删除一些多余的信息。'
- en: '`''include_rts''`: This tells Twitter not to include any retweets. We don''t
    want the user to receive another time update if someone retweets our reply.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''include_rts''`：这告诉Twitter不要包括任何转发。如果有人转发我们的回复，我们不希望用户收到另一个时间更新。'
- en: '`''since_id''`: This tells Twitter to only return the tweets with IDs above
    this value. Every tweet has a unique 64-bit integer ID, and later tweets have
    higher value IDs than earlier tweets. By remembering the ID of the last tweet
    we process and then passing it as this parameter, Twitter will filter out the
    tweets that we''ve already seen.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''since_id''`：这告诉Twitter只返回ID大于此值的推文。每条推文都有一个唯一的64位整数ID，后来的推文比先前的推文具有更高的值ID。通过记住我们处理的最后一条推文的ID，然后将其作为此参数传递，Twitter将过滤掉我们已经看过的推文。'
- en: Before running the aforementioned, we want to generate some mentions for our
    account so that we have something to download. Log into your Twitter test account
    and then create a couple of tweets that contain `@username`, where you replace
    `username` with your app account's username. After this, when you go into the
    **Mentions** section of the **Notifications** tab of your app account, you will
    see these tweets.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上述操作之前，我们希望为我们的账户生成一些提及，这样我们就有东西可以下载。登录您的Twitter测试账户，然后创建一些包含`@username`的推文，其中您将`username`替换为您的应用账户用户名。之后，当您进入应用账户的**通知**选项卡的**提及**部分时，您将看到这些推文。
- en: Now, if we run the aforementioned code, then we will get the text of our mentions
    printed to screen.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行上述代码，我们将在屏幕上打印出我们提及的文本。
- en: Processing the Tweets
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理推文
- en: 'The next step is to parse our mentions and then generate the times that we
    want to include in our replies. Parsing is a straightforward process. In this,
    we just check the ''text'' value of the tweets, but it takes a little more work
    to generate the times. In fact, for this, we''ll need a database of cities and
    their time zones. This is available in the `pytz` package, which can be found
    at PyPi. For doing this, install the following package:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是解析我们的提及，然后生成我们想要包含在回复中的时间。解析是一个简单的过程。在这里，我们只需检查推文的“text”值，但生成时间需要更多的工作。实际上，为此，我们需要一个城市及其时区的数据库。这在`pytz`包中可用，在PyPi上可以找到。为此，请安装以下包：
- en: '[PRE60]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And then, we can write our tweet processing function. Add this function underneath
    `get_mentions()`, and then add `datetime` and `pytz` to the list of the imports
    at the beginning of the file:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以编写我们的推文处理函数。将此函数添加到`get_mentions()`下方，然后在文件开头的导入列表中添加`datetime`和`pytz`：
- en: '[PRE61]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The bulk of `process_tweet()` is used for formatting the tweet's text and processing
    the time zone data. First we will remove any `@username` mentions and `#hashtags`
    from the tweet. Then, we prepare the remaining tweet text to be compared with
    the time zone names database. The time zone names database is held in `pytz.common_timezones`,
    but the names also contain regions, which are separated from the names with slashes
    (`/`). Also, in these names underscores are used in place of spaces.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_tweet()`的大部分内容用于格式化推文文本和处理时区数据。首先，我们将从推文中删除任何`@username`提及和`#hashtags`。然后，我们准备剩下的推文文本与时区名称数据库进行比较。时区名称数据库存储在`pytz.common_timezones`中，但名称中还包含地区，用斜杠(`/`)与名称分隔。此外，在这些名称中，下划线用于代替空格。'
- en: We scan through the database checking against the formatted tweet text. If a
    match is found, then we construct a reply, which contains the local time of the
    matched time zone. For this, we use the `datetime` module along with a time zone
    object generated by `pytz.` If we don't find a match in the time zone database,
    then we compose a reply to let the user know the same. Then, we print our reply
    to screen to check if it's working as expected.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过扫描数据库来检查格式化的推文文本。如果找到匹配项，我们将构建一个包含匹配时区的当地时间的回复。为此，我们使用`datetime`模块以及由`pytz`生成的时区对象。如果在时区数据库中找不到匹配项，我们将组成一个回复，让用户知道这一点。然后，我们将我们的回复打印到屏幕上，以检查它是否按预期工作。
- en: Again, before running this, we may want to create a few tweets that contain
    just a city name and mention our world clock app account, so that the function
    has something to process. Some cities that appear in the time zone database are
    Dublin, New York, and Tokyo.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在运行此操作之前，我们可能希望创建一些只包含城市名称并提及我们的世界时钟应用账户的推文，以便函数有东西可以处理。在时区数据库中出现的一些城市包括都柏林、纽约和东京。
- en: Give it a try! When you run it, you will get some tweet reply texts on the screen,
    which contain the cities and the current local times for those cities.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 试一试！当您运行它时，您将在屏幕上得到一些包含这些城市和这些城市当前当地时间的推文回复文本。
- en: Rate limits
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 速率限制
- en: If we run the aforementioned several times, then we'll find that it will stop
    working after a while. Either the credentials will temporarily fail to validate,
    or the HTTP request in `get_mentions()` will fail.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们多次运行上述操作，然后我们会发现它在一段时间后会停止工作。要么凭据暂时无法验证，要么`get_mentions()`中的HTTP请求将失败。
- en: This is because Twitter applies rate limits to its API, which means that our
    application is only allowed to make a certain number of requests to an endpoint
    in a given amount of time. The limits are listed in the Twitter documentation
    and they vary according to the authentication route (as discussed later) and endpoint.
    We are using `statuses/mentions_timeline.json`, so our limit is 15 requests for
    every 15 minutes. If we exceed this, then Twitter will respond with a `429` `Too
    many requests` status code. This will force us to wait till the next 15 minute
    window starts before it lets us get any useful data back.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Twitter对其API应用速率限制，这意味着我们的应用程序只允许在一定时间内对端点进行一定数量的请求。限制在Twitter文档中列出，根据认证路线（稍后讨论）和端点的不同而有所不同。我们使用`statuses/mentions_timeline.json`，因此我们的限制是每15分钟15次请求。如果我们超过这个限制，那么Twitter将以`429`
    `Too many requests`状态代码做出响应。这将迫使我们等待下一个15分钟窗口开始之前，才能让我们获得任何有用的数据。
- en: 'Rate limits are a common feature of web APIs, so it''s useful to have ways
    of testing efficiently when using them. One approach to testing with data from
    rate-limited APIs is to download some data once and then store it locally. After
    this, load it from the file instead of pulling it from the API. Download some
    test data by using the Python interpreter, as shown here:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 速率限制是Web API的常见特征，因此在使用它们时，有一些有效的测试方法是很有用的。使用速率限制的API数据进行测试的一种方法是下载一些数据，然后将其存储在本地。之后，从文件中加载它，而不是从API中拉取它。通过使用Python解释器下载一些测试数据，如下所示：
- en: '[PRE62]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You'll need to be in the same folder as `twitter_worldclock.py` when you run
    this`.` This creates a file called `test_mentions.json,` which contains our JSONized
    mentions. Here, the `json.dump()` function writes the supplied data into a file
    rather than returning it as a string.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此时，您需要在与`twitter_worldclock.py`相同的文件夹中。这将创建一个名为`test_mentions.json`的文件，其中包含我们的JSON化提及。在这里，`json.dump()`函数将提供的数据写入文件，而不是将其作为字符串返回。
- en: 'Instead of calling the API, we can use this data by modifying our program''s
    main section to look like the following:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改程序的主要部分来使用这些数据，看起来像下面这样：
- en: '[PRE63]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Sending a reply
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送回复
- en: 'The final function that we need to perform is sending a tweet in response to
    a mention. For this, we use the `statuses/update.json` endpoint. If you''ve not
    registered your mobile number with your app account, then this won''t work. So,
    just leave your program as it is. If you have registered your mobile number, then
    add this function under `process_tweets()`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行的最后一个函数是对提及进行回复。为此，我们使用`statuses/update.json`端点。如果您尚未在应用帐户中注册您的手机号码，则这将无法工作。因此，只需将程序保持原样。如果您已经注册了手机号码，则在`process_tweets()`下添加此功能：
- en: '[PRE64]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And add this below the `print()` call at the end of `process_tweet()`, at the
    same indentation level:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 并在`process_tweet()`末尾的`print()`调用下面，与相同的缩进级别：
- en: '[PRE65]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now, if you run this and then check your test account's Twitter notifications,
    you will see some replies.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您运行此程序，然后检查您的测试帐户的Twitter通知，您将看到一些回复。
- en: 'The `post_reply()` function just calls the endpoint by using the following
    parameters to inform Twitter on what to post:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`post_reply()`函数只是使用以下参数调用端点，通知Twitter要发布什么：'
- en: '`status`: This is the text of our reply tweet.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`：这是我们回复推文的文本。'
- en: '`in_reply_to_status_id`: This is the ID of the tweet that we''re replying to.
    We supply this so that Twitter can link the tweets as a conversation.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`in_reply_to_status_id`：这是我们要回复的推文的ID。我们提供这个信息，以便Twitter可以将推文链接为对话。'
- en: When testing this, we might get some `403` status code responses. This is okay,
    it's just that Twitter refuses to let us post two tweets with identical text in
    a row, which we may find happens with this set up, depending on what test tweets
    we send.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时，我们可能会收到一些`403`状态代码响应。这没关系，只是Twitter拒绝让我们连续发布两条相同文本的推文，这可能会发生在这个设置中，具体取决于我们发送了什么测试推文。
- en: Final touches
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最后的修饰
- en: 'The building blocks are in place, and we can add our main loop to make the
    program a daemon. Add the `time` module to the imports at the top, and then change
    the main section to what is shown here:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑模块已经就位，我们可以添加主循环使程序成为守护进程。在顶部导入`time`模块，然后将主要部分更改为以下内容：
- en: '[PRE66]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This will call `get_mentions()` every 60 seconds and then process any new tweets
    that have been downloaded. If we hit any HTTP errors, then it will retry the process
    15 times before exiting the program.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这将每60秒调用`get_mentions()`，然后处理已下载的任何新推文。如果出现任何HTTP错误，它将在退出程序之前重试15次。
- en: Now if we run our program, then it will run continuously, replying to tweets
    that mention the world clock app account. Give it a try, run the program, and
    then send some tweets from your test account. After a minute, you will see some
    replies to your notifications.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行程序，它将持续运行，回复提及世界时钟应用帐户的推文。试一试，运行程序，然后从您的测试帐户发送一些推文。一分钟后，您将看到一些回复您的通知。
- en: Taking it further
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步进行
- en: Now that we've written a basic functional Twitter API client, there are certainly
    some things that we could improve upon. Although we don't have space in this chapter
    to explore enhancements in detail, it's worth mentioning a few to inform future
    projects you may want to undertake.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了一个基本的功能Twitter API客户端，肯定有一些可以改进的地方。虽然本章没有空间详细探讨增强功能，但值得提到一些，以便通知您可能想要承担的未来项目。
- en: Polling and the Twitter streaming APIs
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轮询和Twitter流API
- en: You may have already spotted a problem that our client will only pull a maximum
    of 200 tweets per poll. In each poll, Twitter provides the most recent tweets
    first. This means that if we get more than 200 tweets in 60 seconds, then we will
    permanently lose the tweets that come in first. In fact, there is no complete
    solution for this using the `statuses/mentions_timeline.json` endpoint.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到一个问题，即我们的客户端每次轮询最多只能拉取200条推文。在每次轮询中，Twitter首先提供最近的推文。这意味着如果我们在60秒内收到超过200条推文，那么我们将永久丢失最先收到的推文。实际上，使用`statuses/mentions_timeline.json`端点没有完整的解决方案。
- en: Twitter's solution for this problem is to provide an alternative type of API,
    which is called a **streaming API**. When connecting to these APIs, the HTTP response
    connection is actually left open and the incoming tweets are continuously streamed
    through it. The `Requests` package provides neat functionality for handling this.
    The `Requests` response objects have an `iter_lines()` method, which runs indefinitely.
    It is capable of outputting a line of data whenever the server sends one, which
    can then be processed by us. If you do find that you need this, then there's an
    example that will help you in getting started in the Requests documentation, and
    it can be found at [http://docs.python-requests.org/en/latest/user/advanced/#streaming-requests](http://docs.python-requests.org/en/latest/user/advanced/#streaming-requests).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter针对这个问题的解决方案是提供一种另类的API，称为**流式API**。连接到这些API时，HTTP响应连接实际上是保持打开状态的，并且传入的推文会不断通过它进行流式传输。`Requests`包提供了处理这种情况的便捷功能。`Requests`响应对象具有`iter_lines()`方法，可以无限运行。它能够在服务器发送数据时输出一行数据，然后我们可以对其进行处理。如果您发现您需要这个功能，那么在Requests文档中有一个示例可以帮助您入门，可以在[http://docs.python-requests.org/en/latest/user/advanced/#streaming-requests](http://docs.python-requests.org/en/latest/user/advanced/#streaming-requests)找到。
- en: Alternative oAuth flows
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代oAuth流程
- en: Our setup for having our app operate against our main account and having a second
    account for sending the test tweets is a little clunky, especially so if you use
    your app account for regular tweeting. Wouldn't it be better to have a separate
    account dedicated to handling the world clock tweets?
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设置是让我们的应用程序针对我们的主账户进行操作，并为发送测试推文使用第二个账户，这有点笨拙，特别是如果您将您的应用账户用于常规推文。有没有更好的办法，专门有一个账户来处理世界时钟的推文？
- en: Well, yes it would. The ideal set up is to have a main account on which you
    register the app, and which you can also use it as a regular Twitter account,
    and have the app process tweets for a second dedicated world clock account.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，是的。理想的设置是在一个主账户上注册应用程序，并且您也可以将其用作常规Twitter账户，并且让应用程序处理第二个专用世界时钟账户的推文。
- en: oAuth makes this possible, but there are some extra steps that are needed to
    get it to work. We would need the world clock account to authorize our app to
    act on its behalf. You'll notice that the oAuth credentials mentioned earlier
    are comprised of two main elements, **consumer** and **access**. The consumer
    element identifies our application, and the access element proves that the account
    the access credentials came from authorized our app to act on its behalf. In our
    app we shortcut the full account authorization process by having the app act on
    behalf of the account through which it was registered, that is, our app account.
    When we do this, Twitter lets us acquire the access credentials directly from
    the [dev.twitter.com](http://dev.twitter.com) interface. To use a different user
    account, we would have needed to have inserted a step where the user is taken
    to Twitter, which would be opened in a web browser, where the user would have
    to log in and then explicitly authorize our application.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: oAuth使这成为可能，但需要一些额外的步骤才能使其正常工作。我们需要世界时钟账户来授权我们的应用代表其行事。您会注意到之前提到的oAuth凭据由两个主要元素组成，**消费者**和**访问**。消费者元素标识我们的应用程序，访问元素证明了访问凭据来自授权我们的应用代表其行事的账户。在我们的应用程序中，我们通过让应用程序代表注册时的账户，也就是我们的应用账户，来简化完整的账户授权过程。当我们这样做时，Twitter允许我们直接从[dev.twitter.com](http://dev.twitter.com)界面获取访问凭据。要使用不同的用户账户，我们需要插入一个步骤，让用户转到Twitter，这将在Web浏览器中打开，用户需要登录，然后明确授权我们的应用程序。
- en: Note
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This process is demonstrated in the `requests-oauthlib` documentation, which
    can be found at [https://requests-oauthlib.readthedocs.org/en/latest/oauth1_workflow.html](https://requests-oauthlib.readthedocs.org/en/latest/oauth1_workflow.html).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程在`requests-oauthlib`文档中有演示，可以在[https://requests-oauthlib.readthedocs.org/en/latest/oauth1_workflow.html](https://requests-oauthlib.readthedocs.org/en/latest/oauth1_workflow.html)找到。
- en: HTML and screen scraping
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML和屏幕抓取
- en: Although more and more services are offering their data through APIs, when a
    service doesn't do this then the only way of getting the data programmatically
    is to download its web pages and then parse the HTML source code. This technique
    is called **screen scraping**.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管越来越多的服务通过API提供其数据，但当一个服务没有这样做时，以编程方式获取数据的唯一方法是下载其网页，然后解析HTML源代码。这种技术称为**屏幕抓取**。
- en: Though it sounds simple enough in principle, screen scraping should be approached
    as a last resort. Unlike XML, where the syntax is strictly enforced and data structures
    are usually reasonably stable and sometimes even documented, the world of web
    page source code is a messy one. It is a fluid place, where the code can change
    unexpectedly and in a way that can completely break your script and force you
    to rework the parsing logic from scratch.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然原则上听起来很简单，但屏幕抓取应该被视为最后的手段。与XML不同，XML的语法严格执行，数据结构通常是相对稳定的，有时甚至有文档记录，而网页源代码的世界却是一个混乱的世界。这是一个不断变化的地方，代码可能会意外改变，以一种完全破坏你的脚本并迫使你从头开始重新设计解析逻辑的方式。
- en: Still, it is sometimes the only way to get essential data, so we're going to
    take a brief look at developing an approach toward scraping. We will discuss ways
    to reduce the impact when the HTML code does change.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，有时这是获取基本数据的唯一方法，因此我们将简要讨论开发一种抓取方法。我们将讨论在HTML代码发生变化时减少影响的方法。
- en: You should always check a site's terms and conditions before scraping. Some
    websites explicitly disallow automated parsing and retrieval. Breaching the terms
    may result in your IP address being barred. However, in most cases, as long as
    you don't republish the data and don't make excessively frequent requests, you
    should be okay.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在抓取之前，您应该始终检查网站的条款和条件。一些网站明确禁止自动解析和检索。违反条款可能导致您的IP地址被禁止。然而，在大多数情况下，只要您不重新发布数据并且不进行过于频繁的请求，您应该没问题。
- en: HTML parsers
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML解析器
- en: We'll be parsing HTML just as we parsed XML. We again have a choice between
    pull-style APIs and object-oriented APIs. We are going to use `ElementTree` for
    the same reasons as mentioned before.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解析HTML就像我们解析XML一样。我们再次可以选择拉取式API和面向对象的API。我们将使用`ElementTree`，原因与之前提到的相同。
- en: There are several HTML parsing libraries that are available. They're differentiated
    by their speed, the interfaces that they offer for navigating within HTML documents,
    and their ability at handling badly constructed HTML. The Python standard library
    doesn't include an object-oriented HTML parser. The universally recommended third-party
    package for this is `lxml`, which is primarily an XML parser. However, it does
    include a very good HTML parser. It's quick, it offers several ways of navigating
    documents, and it is tolerant of broken HTML.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个可用的HTML解析库。它们的区别在于它们的速度、在HTML文档中导航的接口，以及它们处理糟糕构建的HTML的能力。Python标准库不包括面向对象的HTML解析器。这方面普遍推荐的第三方包是`lxml`，它主要是一个XML解析器。但是，它确实包含一个非常好的HTML解析器。它快速，提供了几种浏览文档的方式，并且对破碎的HTML宽容。
- en: 'The `lxml` library can be installed on Debian and Ubuntu through the `python-lxml`
    package. If you need an up-to-date version or if you''re not able to install the
    system packages, then `lxml` can be installed through `pip`. Note that you''ll
    need a build environment for this. Debian usually comes with an environment that
    has already been set up but if it''s missing, then the following will install
    one for both Debian and Ubuntu:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`lxml`库可以通过`python-lxml`包在Debian和Ubuntu上安装。如果您需要一个最新版本，或者无法安装系统包，那么可以通过`pip`安装`lxml`。请注意，您需要一个构建环境。Debian通常带有一个已经设置好的环境，但如果缺少，那么以下内容将为Debian和Ubuntu都安装一个：'
- en: '[PRE67]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then you should be able to install `lxml`, like this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你应该能够像这样安装`lxml`：
- en: '[PRE68]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If you hit compilation problems on a 64-bit system, then you can also try:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在64位系统上遇到编译问题，那么您也可以尝试：
- en: '[PRE69]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: On Windows, installer packages are available from the `lxml` website at [http://lxml.de/installation.html](http://lxml.de/installation.html).
    Check the page for links to third-party installers in case an installer for your
    version of Python isn't available.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，可以从`lxml`网站[http://lxml.de/installation.html](http://lxml.de/installation.html)获取安装程序包。如果您的Python版本没有安装程序，可以在页面上查找第三方安装程序的链接。
- en: The next best library, in case `lxml` doesn't work for you, is BeautifulSoup.
    BeautifulSoup is pure Python, so it can be installed with `pip`, and it should
    run anywhere. Although it has its own API, it's a well-respected and capable library,
    and it can, in fact, use `lxml` as a backend library.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`lxml`对您不起作用，下一个最好的库是BeautifulSoup。BeautifulSoup是纯Python，因此可以使用`pip`安装，并且应该可以在任何地方运行。尽管它有自己的API，但它是一个备受尊重和有能力的库，实际上它可以使用`lxml`作为后端库。
- en: Show me the data
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给我看数据
- en: Before we start parsing HTML, we need something to parse! Let's grab the version
    and codename of the latest stable Debian release from the Debian website. Information
    about the current stable release can be found at [https://www.debian.org/releases/stable/](https://www.debian.org/releases/stable/).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始解析HTML之前，我们需要解析的东西！让我们从Debian网站上获取最新稳定版Debian发行版的版本和代号。有关当前稳定版发行版的信息可以在[https://www.debian.org/releases/stable/](https://www.debian.org/releases/stable/)找到。
- en: 'The information that we want is displayed in the page title and in the first
    sentence:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的信息显示在页面标题和第一句中：
- en: '![Show me the data](graphics/6008OS_03_03.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![给我看数据](graphics/6008OS_03_03.jpg)'
- en: So, we should extract the *"jessie"* codename and the 8.0 version number.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该提取*"jessie"*代号和8.0版本号。
- en: Parsing HTML with lxml
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用lxml解析HTML
- en: Let's open a Python shell and get to parsing. First, we'll download the page
    with `Requests`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个Python shell并开始解析。首先，我们将使用`Requests`下载页面。
- en: '[PRE70]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Next, we parse the source into an `ElementTree` tree. This is the same as it
    is for parsing XML with the standard library's `ElementTree`, except here we will
    use the `lxml` specialist `HTMLParser`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将源代码解析成`ElementTree`树。这与使用标准库的`ElementTree`解析XML相同，只是这里我们将使用`lxml`专家`HTMLParser`。
- en: '[PRE71]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The `HTML()` function is a shortcut that reads the HTML that is passed to it,
    and then it produces an XML tree. Notice that we're passing `response.content`
    and not `response.text`. The `lxml` library produces better results when it uses
    the raw response rather than the decoded Unicode text.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTML()`函数是一个快捷方式，它读取传递给它的HTML，然后生成一个XML树。请注意，我们传递的是`response.content`而不是`response.text`。`lxml`库在使用原始响应而不是解码的Unicode文本时会产生更好的结果。'
- en: 'The `lxml` library''s `ElementTree` implementation has been designed to be
    100 percent compatible with the standard library''s, so we can start exploring
    the document in the same way as we did with XML:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`lxml`库的`ElementTree`实现已经被设计为与标准库的100%兼容，因此我们可以像处理XML一样开始探索文档：'
- en: '[PRE72]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the preceding code, we have printed out the text content of the document's
    `<title>` element, which is the text that appears in the tab in the preceding
    screenshot. We can already see it contains the codename that we want.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们已经打印出了文档的`<title>`元素的文本内容，这是在上面截图的标签中显示的文本。我们已经看到它包含了我们想要的代号。
- en: Zeroing in
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚焦
- en: Screen scraping is the art of finding a way to unambiguously address the elements
    in the HTML that contain the information that we want, and extract the information
    from only those elements.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕抓取是一种寻找明确地址HTML元素的艺术，这些元素包含我们想要的信息，并且只从这些元素中提取信息。
- en: However, we also want the selection criteria to be as simple as possible. The
    less we rely on the contents of the document, the lesser the chance of it being
    broken if the page's HTML changes.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也希望选择标准尽可能简单。我们依赖文档的内容越少，页面的HTML发生变化时就越不容易破坏。
- en: 'Let''s inspect the HTML source of the page, and see what we''re dealing with.
    For this, either use `View Source` in a web browser, or save the HTML to a file
    and open it in a text editor. The page''s source code is also included in the
    source code download for this book. Search for the text `Debian 8.0`, so that
    we are taken straight to the information we want. For me, it looks like the following
    block of code:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查页面的HTML源代码，看看我们正在处理什么。为此，可以在Web浏览器中使用`查看源代码`，或者将HTML保存到文件中并在文本编辑器中打开。本书的源代码下载中也包含了页面的源代码。搜索文本`Debian
    8.0`，这样我们就可以直接找到我们想要的信息。对我来说，它看起来像以下代码块：
- en: '[PRE73]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: I've skipped the HTML between the `<body>` and the `<div>` to show that the
    `<div>` is a direct child of the `<body>` element. From the above, we can see
    that we want the contents of the `<p>` tag child of the `<div>` element.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我跳过了`<body>`和`<div>`之间的HTML，以显示`<div>`是`<body>`元素的直接子元素。从上面可以看出，我们想要`<div>`元素的`<p>`标签子元素的内容。
- en: 'If we navigated to this element by using the `ElementTree` functions, which
    we have used before, then we''d end up with something like the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用之前使用过的`ElementTree`函数导航到此元素，那么我们最终会得到类似以下的内容：
- en: '[PRE74]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: But this isn't the best approach, as it depends quite heavily on the HTML structure.
    A change, such as a `<div>` tag being inserted before the one that we needed,
    would break it. Also, in more complex documents, this can lead to horrendous chains
    of method calls, which are hard to maintain. Our use of the `<title>` tag in the
    previous section to get the codename is an example of a good technique, because
    there is always only one `<head>` and one `<title>` tag in a document. A better
    approach to finding our `<div>` would be to make use of the `id="content"` attribute
    it contains. It's a common web page design pattern to break a page into a few
    top-level `<divs>` for the major page sections like the header, the footer and
    the content, and to give the `<divs> id` attributes which identify them as such.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是最佳方法，因为它相当大程度上依赖于HTML结构。例如，插入一个我们需要的`<div>`标签之前的变化会破坏它。此外，在更复杂的文档中，这可能导致可怕的方法调用链，难以维护。我们在上一节中使用`<title>`标签来获取代号的方法是一个很好的技巧的例子，因为文档中始终只有一个`<head>`和一个`<title>`标签。找到我们的`<div>`的更好方法是利用它包含的`id="content"`属性。将页面分成几个顶级`<div>`，如页眉、页脚和内容，并为`<div>`赋予标识它们的`id`属性，是一种常见的网页设计模式。
- en: Hence, if we could search for `<div>`s with an `id` attribute of `"content"`,
    then we'd have a clean way of selecting the right `<div>.` There is only one `<div>`
    in the document that is a match, and it's unlikely that another`<div>` like that
    will be added to the document. This approach doesn't depend on the document structure,
    and so it won't be affected by any changes that are made to the structure. We'll
    still need to rely on the fact that the `<p>` tag in the `<div>` is the first
    `<p>` tag that appears, but given that there is no other way to identify it, this
    is the best we can do.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们可以搜索具有`id`属性为`"content"`的`<div>`，那么我们将有一种干净的方法来选择正确的`<div>`。文档中只有一个匹配的`<div>`，并且不太可能会添加另一个类似的`<div>`到文档中。这种方法不依赖于文档结构，因此不会受到对结构所做的任何更改的影响。我们仍然需要依赖于`<div>`中的`<p>`标签是出现的第一个`<p>`标签，但鉴于没有其他方法来识别它，这是我们能做的最好的。
- en: So, how do we run such a search for our content `<div>`?
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何运行这样的搜索来找到我们的内容`<div>`呢？
- en: Searching with XPath
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用XPath搜索
- en: In order to avoid exhaustive iteration and the checking of every element, we
    need to use **XPath**, which is more powerful than what we've used so far. It
    is a query language that was developed specifically for XML, and it's supported
    by `lxml`. Plus, the standard library implementation provides limited support
    for it.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免穷举迭代和检查每个元素，我们需要使用**XPath**，它比我们迄今为止使用的更强大。它是一种专门为XML开发的查询语言，并且得到了`lxml`的支持。此外，标准库实现对其提供了有限的支持。
- en: We're going to take a quick look at XPath, and in the process we will find the
    answer to the question posed earlier.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速了解XPath，并在此过程中找到之前提出的问题的答案。
- en: 'To get started, use the Python shell from the last section, and do the following:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Python shell，可以执行以下操作：
- en: '[PRE75]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This is the simplest form of XPath expression: it searches for children of
    the current element that have tag names that match the specified tag name. The
    current element is the one we call `xpath()` on, in this case `root`. The `root`
    element is the top-level `<html>` element in the HTML document, and so the returned
    element is the `<body>` element`.`'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这是XPath表达式的最简单形式：它搜索当前元素的子元素，其标签名称与指定的标签名称匹配。当前元素是我们在其上调用`xpath()`的元素，在本例中是`root`。`root`元素是HTML文档中的顶级`<html>`元素，因此返回的元素是`<body>`元素。
- en: 'XPath expressions can contain multiple levels of elements. The searches start
    from the node the `xpath()` call is made on and work down the tree as they match
    successive elements in the expression. We can use this to find just the `<div>`
    child elements of `<body>`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: XPath表达式可以包含多个级别的元素。搜索从进行`xpath()`调用的节点开始，并随着它们在表达式中匹配连续元素而向下工作。我们可以利用这一点来仅查找`<body>`的`<div>`子元素。
- en: '[PRE76]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `body/div` expression means match `<div>` children of `<body>` children
    of the current element. Elements with the same tag can appear more than once at
    the same level in an XML document, so an XPath expression can match multiple elements,
    hence the `xpath()` function always returns a list.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`body/div`表达式意味着匹配当前元素的`<body>`子元素的`<div>`子元素。在XML文档中，具有相同标签的元素可以在同一级别出现多次，因此XPath表达式可以匹配多个元素，因此`xpath()`函数始终返回一个列表。'
- en: 'The preceding queries are relative to the element that we call `xpath()` on,
    but we can force a search from the root of the tree by adding a slash to the start
    of the expression. We can also perform a search over all the descendants of an
    element, with the help of a double-slash. To do this, try the following:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的查询是相对于我们称之为`xpath()`的元素的，但我们可以通过在表达式开头添加斜杠来强制从树的根部进行搜索。我们还可以通过双斜杠来对元素的所有后代进行搜索。要做到这一点，请尝试以下操作：
- en: '[PRE77]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, we've directly found our `<h1>` element by only specifying a single tag,
    even though it's several levels below `root`. This double-slash at the beginning
    of the expression will always search from the root, but we can prefix this with
    a dot if we want it to start searching from the context element.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只通过指定单个标记就直接找到了我们的`<h1>`元素，即使它在`root`下面几个级别。表达式开头的双斜杠将始终从根目录搜索，但如果我们希望从上下文元素开始搜索，可以在前面加上一个点。
- en: '[PRE78]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This will not find anything because there are no `<h1>` descendents of `<head>`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这将找不到任何内容，因为`<head>`没有`<h1>`的后代。
- en: XPath conditions
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XPath条件
- en: So, we can be quite specific by supplying paths, but the real power of XPath
    lies in applying additional conditions to the elements in the path. In particular,
    our aforementioned problem, which is, testing element attributes.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过提供路径，我们可以非常具体，但XPath的真正力量在于对路径中的元素应用附加条件。特别是，我们前面提到的问题，即测试元素属性。
- en: '[PRE79]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The square brackets after `div`, `[@id="content"]`, form a condition that we
    place on the `<div>` elements that we''re matching. The `@` sign before `id` means
    that `id` refers to an attribute, so the condition means: only elements with an
    `id` attribute equal to `"content"`. This is how we can find our content `<div>`.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在`div`后面的方括号`[@id="content"]`形成了我们放在匹配的`<div>`元素上的条件。`id`之前的`@`符号表示`id`是一个属性，因此条件的含义是：只有`id`属性等于`"content"`的元素。这就是我们如何找到我们的内容`<div>`。
- en: 'Before we employ this to extract our information, let''s just touch on a couple
    of useful things that we can do with conditions. We can specify just a tag name,
    as shown here:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用它来提取信息之前，让我们简单介绍一下我们可以使用条件做的一些有用的事情。我们可以只指定一个标记名称，如下所示：
- en: '[PRE80]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This returns all `<div>` elements which have an `<h1>` child element. Also
    try:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回所有具有`<h1>`子元素的`<div>`元素。也可以尝试：
- en: '[PRE81]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Putting a number as a condition will return the element at that position in
    the matched list. In this case this is the second `<div>` child element of `<body>`.
    Note that these indexes start at `1`, unlike Python indexing which starts at `0`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字作为条件将返回匹配列表中的该位置的元素。在这种情况下，这是`<body>`的第二个`<div>`子元素。请注意，这些索引从`1`开始，而不像Python索引从`0`开始。
- en: There's a lot more that XPath can do, the full specification is a **World Wide
    Web Consortium** (**W3C**) standard. The latest version can be found at [http://www.w3.org/TR/xpath-3/](http://www.w3.org/TR/xpath-3/).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: XPath还有很多功能，完整的规范是**万维网联盟**（**W3C**）的标准。最新版本可以在[http://www.w3.org/TR/xpath-3/](http://www.w3.org/TR/xpath-3/)上找到。
- en: Pulling it together
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汇总
- en: 'Now that we''ve added XPath to our superpowers, let''s finish up by writing
    a script to get our Debian version information. Create a new file, `get_debian_version.py`,
    and save the following to it:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将XPath添加到我们的超能力中，让我们通过编写一个脚本来获取我们的Debian版本信息来完成。创建一个新文件`get_debian_version.py`，并将以下内容保存到其中：
- en: '[PRE82]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, we have downloaded and parsed the web page by pulling out the text that
    we want with the help of XPath. We have used a regular expression to pull out
    *jessie*, and a `split` to extract the version 8.0\. Finally we print it out.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过XPath下载和解析了网页，通过XPath提取我们想要的文本。我们使用了正则表达式来提取*jessie*，并使用`split`来提取版本8.0。最后我们将其打印出来。
- en: 'So, run it like it is shown here:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，像这里显示的那样运行它：
- en: '[PRE83]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Magnificent. Well, darned nifty, at least. There are some third-party packages
    available which can speed up scraping and form submission, two popular ones are
    Mechanize and Scrapy. Check them out at [http://wwwsearch.sourceforge.net/mechanize/](http://wwwsearch.sourceforge.net/mechanize/),
    and [http://scrapy.org](http://scrapy.org).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 了不起。至少非常巧妙。有一些第三方包可用于加快抓取和表单提交的速度，其中两个流行的包是Mechanize和Scrapy。请在[http://wwwsearch.sourceforge.net/mechanize/](http://wwwsearch.sourceforge.net/mechanize/)和[http://scrapy.org](http://scrapy.org)上查看它们。
- en: With great power...
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伟大的力量……
- en: As an HTTP client developer, you may have different priorities to the webmasters
    that run websites. A webmaster will typically provide a site for human users;
    possibly offering a service designed for generating revenue, and it is most likely
    that all this will need to be done with the help of very limited resources. They
    will be interested in analyzing how humans use their site, and may have areas
    of the site they would prefer that automated clients didn't explore.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 作为HTTP客户端开发人员，您可能有不同的优先级，与运行网站的网络管理员不同。网络管理员通常会为人类用户提供网站；可能提供旨在产生收入的服务，并且很可能所有这些都需要在非常有限的资源的帮助下完成。他们将对分析人类如何使用他们的网站感兴趣，并且可能有他们希望自动客户端不要探索的网站区域。
- en: HTTP clients that automatically parse and download pages on websites are called
    various things, such as *bots*, *web crawlers*, and *spiders*. Bots have many
    legitimate uses. All the search engine providers make extensive use of bots for
    crawling the web and building their huge page indexes. Bots can be used to check
    for dead links, and to archive sites for repositories, such as the Wayback Machine.
    But, there are also many uses that might be considered as illegitimate. Automatically
    traversing an information service to extract the data on its pages and then repackaging
    that data for presentation elsewhere without permission of the site owners, downloading
    large batches of media files in one go when the spirit of the service is online
    viewing and so on could be considered as illegitimate. Some sites have terms of
    service which explicitly bar automated downloads. Although some actions such as
    copying and republishing copyrighted material are clearly illegitimate, some other
    actions are subject to interpretation. This gray area is a subject of ongoing
    debate, and it is unlikely that it will ever be resolved to everyone's satisfaction.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 自动解析和下载网站页面的HTTP客户端被称为各种各样的东西，比如*机器人*、*网络爬虫*和*蜘蛛*。机器人有许多合法的用途。所有的搜索引擎提供商都大量使用机器人来爬取网页并构建他们庞大的页面索引。机器人可以用来检查死链接，并为存储库存档网站，比如Wayback
    Machine。但是，也有许多可能被认为是非法的用途。自动遍历信息服务以提取其页面上的数据，然后在未经网站所有者许可的情况下重新打包这些数据以在其他地方展示，一次性下载大批量的媒体文件，而服务的精神是在线查看等等，这些都可能被认为是非法的。一些网站有明确禁止自动下载的服务条款。尽管一些行为，比如复制和重新发布受版权保护的材料，显然是非法的，但其他一些行为则需要解释。这个灰色地带是一个持续辩论的话题，而且不太可能会得到所有人的满意解决。
- en: However, even when they do serve a legitimate purpose, in general, bots do make
    webmasters lives somewhat more difficult. They pollute the webserver logs, which
    webmasters use for calculating statistics on how their site is being used by their
    human audience. Bots also consume bandwidth and other server resources.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使它们确实有合法的目的，总的来说，机器人确实使网站所有者的生活变得更加困难。它们污染了Web服务器日志，而网站所有者用这些日志来计算他们的人类受众如何使用他们的网站的统计数据。机器人还会消耗带宽和其他服务器资源。
- en: Using the methods that we are looking at in this chapter, it is quite straightforward
    to write a bot that performs many of the aforementioned functions. Webmasters
    provide us with services that we will be using, so in return, we should respect
    the aforementioned areas and design our bots in such a way that they impact them
    as little as possible.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章中我们正在研究的方法，编写一个执行许多前述功能的机器人是非常简单的。网站所有者为我们提供了我们将要使用的服务，因此，作为回报，我们应该尊重上述领域，并设计我们的机器人，使它们对他们的影响尽可能小。
- en: Choosing a User Agent
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择用户代理
- en: There are a few things that we can do to help our webmasters out. We should
    always pick an appropriate user agent for our client. The principle way in which
    webmasters filter out bot traffic from their logfiles is by performing user agent
    analysis.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做一些事情来帮助我们的网站所有者。我们应该为我们的客户端选择一个合适的用户代理。网站所有者从日志文件中过滤出机器人流量的主要方法是通过用户代理分析。
- en: There are lists of the user agents of known bots, for example, one such list
    can be found at [http://www.useragentstring.com/pages/Crawlerlist/](http://www.useragentstring.com/pages/Crawlerlist/).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 有已知机器人的用户代理列表，例如，可以在[http://www.useragentstring.com/pages/Crawlerlist/](http://www.useragentstring.com/pages/Crawlerlist/)找到这样的列表。
- en: 'Webmasters can use these in their filters. Many webmasters also simply filter
    out any user agents that contain the words *bot*, *spider*, or *crawler*. So,
    if we are writing an automated bot rather than a browser, then it will make the
    webmasters'' lives a little easier if we use a user agent that contains one of
    these words. Many bots used by the search engine providers follow this convention,
    some examples are listed here:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 网站所有者可以在他们的过滤器中使用这些。许多网站所有者也会简单地过滤掉包含*bot*、*spider*或*crawler*等词的用户代理。因此，如果我们编写的是一个自动化机器人而不是一个浏览器，那么如果我们使用包含这些词中的一个的用户代理，那么这将使网站所有者的生活变得更加轻松。搜索引擎提供商使用的许多机器人都遵循这个惯例，这里列举了一些例子：
- en: '`Mozilla/5.0` `compatible; bingbot/2.0; http://www.bing.com/bingbot.htm`'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mozilla/5.0` `compatible; bingbot/2.0; http://www.bing.com/bingbot.htm`'
- en: '`Baiduspider: http://www.baidu.com/search/spider.htm`'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Baiduspider: http://www.baidu.com/search/spider.htm`'
- en: '`Mozilla/5.0 compatible; Googlebot/2.1; http://www.google.com/bot.html`'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mozilla/5.0 compatible; Googlebot/2.1; http://www.google.com/bot.html`'
- en: There are also some guidelines in section 5.5.3 of the HTTP RFC 7231.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP RFC 7231的第5.5.3节中也有一些指南。
- en: The Robots.txt file
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Robots.txt文件
- en: There is an unofficial but standard mechanism to tell bots if there are any
    parts of a website that they should not crawl. This mechanism is called `robots.txt`,
    and it takes the form of a text file called, unsurprisingly, `robots.txt`. This
    file always lives in the root of a website so that bots can always find it. It
    has rules that describe the accessible parts of the website. The file format is
    described at [http://www.robotstxt.org](http://www.robotstxt.org).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非官方但标准的机制，可以告诉机器人网站的哪些部分不应该被爬取。这个机制称为`robots.txt`，它采用一个名为`robots.txt`的文本文件的形式。这个文件总是位于网站的根目录，以便机器人总是可以找到它。它包含描述网站可访问部分的规则。文件格式在[http://www.robotstxt.org](http://www.robotstxt.org)中有描述。
- en: The Python standard library provides the `urllib.robotparser` module for parsing
    and working with `robots.txt` files. You can create a parser object, feed it a
    `robots.txt` file and then you can simply query it to see whether a given URL
    is permitted for a given user agent. A good example can be found in the documentation
    in the standard library. If you check every URL that your client might want to
    access before you access it, and honor the webmasters wishes, then you'll be helping
    them out.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库提供了`urllib.robotparser`模块，用于解析和处理`robots.txt`文件。您可以创建一个解析器对象，将`robots.txt`文件传递给它，然后可以简单地查询它，以查看给定用户代理是否允许给定URL。在标准库的文档中可以找到一个很好的例子。如果您在访问之前检查客户端可能想要访问的每个URL，并遵守网站所有者的意愿，那么您将会帮助他们。
- en: Finally, since we may be making quite a lot of requests as we test out our fledgling
    clients, it's a good idea to make local copies of the web pages or the files that
    you want your client to parse and test it against them. In this way, we'll be
    saving bandwidth for ourselves and for the websites.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们可能会频繁地进行请求来测试我们新建的客户端，最好是在本地复制你想让客户端解析和测试的网页或文件。这样，我们既可以为自己节省带宽，也可以为网站节省带宽。
- en: Summary
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've covered a lot of ground in this chapter, but you should now be able to
    start making real use of the web APIs that you encounter.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容，但现在你应该能够开始真正利用你遇到的Web API了。
- en: We looked at XML, how to construct documents, parse them and extract data from
    them by using the `ElementTree` API. We looked at both the Python `ElementTree`
    implementation and `lxml`. We also looked at how the XPath query language can
    be used efficiently for extracting information from documents.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了XML，如何构建文档，解析它们并通过使用`ElementTree` API从中提取数据。我们研究了Python的`ElementTree`实现和`lxml`。我们还研究了XPath查询语言如何有效地从文档中提取信息。
- en: We looked at the Amazon S3 service and wrote a client that lets us perform basic
    operations, such as creating buckets, and uploading and downloading files through
    the S3 REST API. We learned about setting access permissions and setting content
    types, such that the files work properly in web browsers.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了Amazon S3服务，并编写了一个客户端，让我们可以执行基本操作，比如创建存储桶，通过S3 REST API上传和下载文件。我们学习了如何设置访问权限和内容类型，使文件在Web浏览器中正常工作。
- en: We looked at the JSON data format, how to convert Python objects into the JSON
    data format and how to convert them back to Python objects.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了JSON数据格式，如何将Python对象转换为JSON数据格式，以及如何将它们转换回Python对象。
- en: We then explored the Twitter API and wrote an on-demand world clock service,
    through which we learned how to read and process tweets for an account, and how
    to send a tweet as a reply.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探索了Twitter API，并编写了一个按需的世界时钟服务，通过这个服务，我们学会了如何阅读和处理账户的推文，以及如何发送推文作为回复。
- en: We saw how to extract or scrape information from the HTML source of web pages.
    We saw how to work with HTML when using `ElementTree` and the `lxml` HTML parser.
    We also learned how to use XPath to help make this process more efficient.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何从网页的HTML源代码中提取信息。我们学习了在使用`ElementTree`和`lxml` HTML解析器时如何处理HTML。我们还学习了如何使用XPath来帮助使这个过程更加高效。
- en: And finally, we looked at how we can give back to the webmasters that provide
    us with all the data. We discussed a few ways in which we can code our clients
    to make the webmasters lives a little easier and respect how they would like us
    to use their sites.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了如何回报给为我们提供所有数据的网站管理员。我们讨论了一些编写客户端的方式，使网站管理员的生活变得更轻松，并尊重他们希望我们如何使用他们的网站。
- en: 'So, that''s it for HTTP for now. We''ll re-visit HTTP in [Chapter 9](ch09.html
    "Chapter 9. Applications for the Web"), *Applications for the Web*, where we''ll
    be looking at using Python for constructing the server-side of web applications.
    In the next chapter, we''ll discuss the other great workhorse of the Internet:
    e-mail.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，暂时就介绍这么多关于HTTP了。我们将在[第9章](ch09.html "第9章。Web应用程序")中重新讨论HTTP，*Web应用程序*，届时我们将学习如何使用Python构建Web应用程序的服务器端。在下一章中，我们将讨论互联网的另一个重要工具：电子邮件。
