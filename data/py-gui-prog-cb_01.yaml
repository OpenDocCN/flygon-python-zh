- en: Chapter 1. Creating the GUI Form and Adding Widgets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。创建GUI表单并添加小部件
- en: 'In this chapter, we start creating amazing GUIs using Python 3:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始使用Python 3创建令人惊叹的GUI：
- en: Creating our first Python GUI
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的第一个Python GUI
- en: Preventing the GUI from being resized
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止GUI大小调整
- en: Adding a label to the GUI form
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将标签添加到GUI表单
- en: Creating buttons and changing their text property
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建按钮并更改其文本属性
- en: Text box widgets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本框小部件
- en: Setting the focus to a widget and disabling widgets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将焦点设置为小部件并禁用小部件
- en: Combo box widgets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合框小部件
- en: Creating a check button with different initial states
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有不同初始状态的复选按钮
- en: Using radio button widgets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单选按钮小部件
- en: Using scrolled text widgets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用滚动文本小部件
- en: Adding several widgets in a loop
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在循环中添加多个小部件
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In this chapter, we will develop our first GUI in Python. We start with the
    minimum code required to build a running GUI application. Each recipe then adds
    different widgets to the GUI form.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在Python中开发我们的第一个GUI。我们从构建运行的GUI应用程序所需的最少代码开始。然后，每个示例都向GUI表单添加不同的小部件。
- en: In the first two recipes, we show the entire code, consisting of only a few
    lines of code. In the following recipes we only show the code to be added to the
    previous recipes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个示例中，我们展示了仅包含几行代码的完整代码。在接下来的示例中，我们只展示要添加到前面示例中的代码。
- en: By the end of this chapter, we will have created a working GUI application that
    consists of labels, buttons, text boxes, combo boxes, and check buttons in various
    states, as well as radio buttons that change the background color of the GUI.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将创建一个工作的GUI应用程序，其中包括各种状态的标签、按钮、文本框、组合框和复选按钮，以及可以更改GUI背景颜色的单选按钮。
- en: Creating our first Python GUI
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个Python GUI
- en: Python is a very powerful programming language. It ships with the built-in tkinter
    module. In only a few lines of code (four, to be precise) we can build our first
    Python GUI.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种非常强大的编程语言。它附带了内置的tkinter模块。只需几行代码（确切地说是四行），我们就可以构建我们的第一个Python GUI。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow this recipe, a working Python development environment is a prerequisite.
    The IDLE GUI that ships with Python is enough to start. IDLE was built using tkinter!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循此示例，需要一个可用的Python开发环境。Python附带的IDLE GUI足以开始。IDLE是使用tkinter构建的！
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All the recipes in this book were developed using Python 3.4 on a Windows 7
    64-bit OS. They have not been tested on any other configuration. As Python is
    a cross-platform language, the code from each recipe is expected to run everywhere.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有示例都是在Windows 7 64位操作系统上使用Python 3.4开发的。它们尚未在任何其他配置上进行测试。由于Python是一种跨平台语言，预计每个示例的代码都可以在任何地方运行。
- en: If you are using a Mac, it does come built-in with Python, yet it might be missing
    some modules such as tkinter, which we will use throughout this book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Mac，它确实内置了Python，但可能缺少一些模块，例如我们将在本书中使用的tkinter。
- en: We are using Python 3 and the creator of Python intentionally chose not to make
    it backwards compatible with Python 2.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Python 3，Python的创建者有意选择不与Python 2向后兼容。
- en: If you are using a Mac or Python 2, you might have to install Python 3 from
    [www.python.org](http://www.python.org) in order to successfully run the recipes
    in this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Mac或Python 2，您可能需要从[www.python.org](http://www.python.org)安装Python 3，以便成功运行本书中的示例。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the four lines of Python code required to create the resulting GUI:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建结果GUI所需的四行Python代码：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Execute this code and admire the result:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码并欣赏结果：
- en: '![How to do it...](graphics/B04829_01_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_01_01.jpg)'
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In line 1, we import the built-in `tkinter` module and alias it as `tk` to simplify
    our Python code. In line 2, we create an instance of the `Tk` class by calling
    its constructor (the parentheses appended to `Tk` turn the class into an instance).
    We are using the alias `tk` so we don't have to use the longer word `tkinter`.
    We are assigning the class instance to a variable named `win` (short for a window).
    As Python is a dynamically typed language, we did not have to declare this variable
    before assigning to it and we did not have to give it a specific type. *Python
    infers the type from the assignment of this statement*. Python is a strongly typed
    language, so every variable always has a type. We just don't have to specify its
    type beforehand like in other languages. This makes Python a very powerful and
    productive language to program in.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行中，我们导入内置的`tkinter`模块，并将其别名为`tk`以简化我们的Python代码。在第2行中，我们通过调用其构造函数（括号附加到`Tk`将类转换为实例）创建`Tk`类的实例。我们使用别名`tk`，这样我们就不必使用更长的单词`tkinter`。我们将类实例分配给名为`win`（窗口的缩写）的变量。由于Python是一种动态类型的语言，我们在分配给它之前不必声明此变量，并且我们不必给它指定特定的类型。*Python从此语句的分配中推断出类型*。Python是一种强类型的语言，因此每个变量始终都有一个类型。我们只是不必像其他语言那样事先指定其类型。这使得Python成为一种非常强大和高效的编程语言。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A little note about classes and types:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关于类和类型的一点说明：
- en: In Python every variable always has a type. We cannot create a variable without
    assigning it a type. Yet, in Python, we do not have to declare the type beforehand,
    as we have to do in the C programming language.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，每个变量始终都有一个类型。我们不能创建一个没有分配类型的变量。然而，在Python中，我们不必事先声明类型，就像在C编程语言中一样。
- en: Python is smart enough to infer the type. At the time of writing, C# also has
    this capability.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Python足够聪明，可以推断类型。在撰写本文时，C#也具有这种能力。
- en: Using Python, we can create our own classes using the `class` keyword instead
    of the `def` keyword.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python，我们可以使用`class`关键字而不是`def`关键字来创建自己的类。
- en: In order to assign the class to a variable, we first have to create an instance
    of our class. We create the instance and assign this instance to our variable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将类分配给变量，我们首先必须创建我们类的一个实例。我们创建实例并将此实例分配给我们的变量。
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now the variable `classInstance` is of the type `AClass`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在变量`classInstance`的类型是`AClass`。
- en: If this sounds confusing, do not worry. We will cover OOP in the coming chapters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来令人困惑，不要担心。我们将在接下来的章节中介绍面向对象编程。
- en: In line 3, we use the instance variable of the class (`win`) to give our window
    a title via the `title` property. In line 4, we start the window's event loop
    by calling the `mainloop` method on the class instance `win`. Up to this point
    in our code, we created an instance and set one property *but the GUI will not
    be displayed until we start the main event loop*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3行，我们使用类的实例变量(`win`)通过`title`属性给我们的窗口设置了一个标题。在第4行，通过在类实例`win`上调用`mainloop`方法来启动窗口的事件循环。在我们的代码中到目前为止，我们创建了一个实例并设置了一个属性*但是GUI直到我们启动主事件循环之前都不会显示*。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An event loop is a mechanism that makes our GUI work. We can think of it as
    an endless loop where our GUI is waiting for events to be sent to it. A button
    click creates an event within our GUI or our GUI being resized also creates an
    event.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环是使我们的GUI工作的机制。我们可以把它看作是一个无限循环，我们的GUI在其中等待事件发送给它。按钮点击在我们的GUI中创建一个事件，或者我们的GUI被调整大小也会创建一个事件。
- en: We can write all of our GUI code in advance and nothing will be displayed on
    the user's screen until we call this endless loop (`win.mainloop()` in the code
    shown above).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提前编写所有的GUI代码，直到我们调用这个无限循环(`win.mainloop()`在上面显示的代码中)用户的屏幕上什么都不会显示。
- en: The event loop ends when the user clicks the red **X** button or a widget that
    we have programmed to end our GUI. When the event loop ends, our GUI also ends.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击红色的**X**按钮或者我们编程结束GUI的小部件时，事件循环就会结束。当事件循环结束时，我们的GUI也会结束。
- en: There's more...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe used a minimum amount of Python code to create our first GUI program.
    However, throughout this book, we will use OOP when it makes sense.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用了最少量的Python代码来创建我们的第一个GUI程序。然而，在本书中，我们会在合适的时候使用OOP。
- en: Preventing the GUI from being resized
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻止GUI的大小可调整
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe extends the previous one. Therefore, it is necessary to have typed
    Recipe 1 yourself into a project of your own or downloaded the code from [https://www.packtpub.com/support](https://www.packtpub.com/support).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例扩展了之前的示例。因此，有必要自己输入第1个示例的代码到你自己的项目中，或者从[https://www.packtpub.com/support](https://www.packtpub.com/support)下载代码。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We are preventing the GUI from being resized.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在阻止GUI的大小可调整。
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Running the code creates this GUI:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码会创建这个GUI：
- en: '![How to do it...](graphics/B04829_01_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_01_02.jpg)'
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Line 4 prevents the Python GUI from being resized.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第4行阻止Python GUI的大小可调整。
- en: Running this code will result in a GUI similar to the one we created in Recipe
    1\. However, the user can no longer resize it. Also, notice how the maximize button
    in the toolbar of the window is grayed out.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码将会得到一个类似于我们在第1个示例中创建的GUI。然而，用户不能再调整它的大小。同时，注意窗口工具栏中的最大化按钮是灰色的。
- en: Why is this important? Because, once we add widgets to our form, resizing can
    make our GUI look not as good as we want it to be. We will add widgets to our
    GUI in the next recipes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很重要？因为一旦我们向我们的表单添加小部件，调整大小可能会使我们的GUI看起来不如我们希望的那样好。我们将在下一个示例中向我们的GUI添加小部件。
- en: '`Resizable()` is a method of the `Tk()` class and, by passing in `(0, 0),`
    we prevent the GUI from being resized. If we pass in other values, we hard-code
    the x and y start up size of the GUI, *but that won''t make it nonresizable*.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resizable()`是`Tk()`类的一个方法，通过传入`(0, 0)`，我们阻止了GUI的大小可调整。如果我们传入其他值，我们就会硬编码GUI的x和y的启动大小，*但这不会使它不可调整大小*。'
- en: We also added comments to our code in preparation for the recipes contained
    in this book.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在我们的代码中添加了注释，为本书中包含的示例做准备。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In visual programming IDEs such as Visual Studio .NET, C# programmers often
    do not think of preventing the user from resizing the GUI they developed in this
    language. That creates inferior GUIs. Adding this one line of Python code can
    make our users appreciate our GUI.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio .NET等可视化编程IDE中，C#程序员通常不会考虑阻止用户调整他们用这种语言开发的GUI。这会导致GUI质量较差。添加这一行Python代码可以让我们的用户欣赏我们的GUI。
- en: Adding a label to the GUI form
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向GUI表单添加标签
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are extending the first recipe. We will leave the GUI resizable, so don't
    use the code from the second recipe (or comment the `win.resizable` line 4 out).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在扩展第一个示例。我们将保持GUI可调整大小，所以不要使用第二个示例中的代码(或者将第4行的`win.resizable`注释掉)。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In order to add a `Label` widget to our GUI, we are importing the `ttk` module
    from `tkinter`. Please note the two import statements.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向我们的GUI添加一个`Label`小部件，我们从`tkinter`中导入了`ttk`模块。请注意这两个导入语句。
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Add the following code just above `win.mainloop()` located at the bottom of
    recipes 1 and 2.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例1和2底部的`win.mainloop()`上面添加以下代码。
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running the code adds a label to our GUI:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码会向我们的GUI添加一个标签：
- en: '![How to do it...](graphics/B04829_01_03.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_01_03.jpg)'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In line 3 of the above code, we are importing a separate module from `tkinter`.
    The `ttk` module has some advanced widgets that make our GUI look great. In a
    sense, `ttk` is an extension within `tkinter`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码的第3行，我们从`tkinter`中导入了一个单独的模块。`ttk`模块有一些高级的小部件，可以让我们的GUI看起来很棒。在某种意义上，`ttk`是`tkinter`中的一个扩展。
- en: We still need to import `tkinter` itself, but we have to specify that we now
    want to also use `ttk` from `tkinter`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要导入`tkinter`本身，但是我们必须指定我们现在也想要从`tkinter`中使用`ttk`。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`ttk` stands for ''themed tk". It improves our GUI look and feel.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`ttk`代表"themed tk"。它改善了我们的GUI外观和感觉。'
- en: Line 5 above adds the label to the GUI, just before we call `mainloop` (not
    shown here to preserve space. See recipes 1 or 2).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的第5行在调用`mainloop`之前向GUI添加了标签(这里没有显示以保持空间。请参见示例1或2)。
- en: We are passing our window instance into the `ttk.Label` constructor and setting
    the text property. This becomes the text our `Label` will display.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的窗口实例传递给`ttk.Label`构造函数，并设置文本属性。这将成为我们的`Label`将显示的文本。
- en: We are also making use of the *grid layout manager*, which we'll explore in
    much more depth in [Chapter 2](ch02.html "Chapter 2. Layout Management"), *Layout
    Management*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了*网格布局管理器*，我们将在[第2章](ch02.html "第2章.布局管理")中更深入地探讨*布局管理*。
- en: Note how our GUI suddenly got much smaller than in previous recipes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们的GUI突然变得比以前的食谱小得多。
- en: The reason why it became so small is that we added a widget to our form. Without
    a widget, `tkinter` uses a default size. Adding a widget causes optimization,
    which generally means using as little space as necessary to display the widget(s).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它变得如此之小的原因是我们在表单中添加了一个小部件。没有小部件，`tkinter`使用默认大小。添加小部件会导致优化，通常意味着尽可能少地使用空间来显示小部件。
- en: If we make the text of the label longer, the GUI will expand automatically.
    We will cover this automatic form size adjustment in a later recipe in [Chapter
    2](ch02.html "Chapter 2. Layout Management"), *Layout Management*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使标签的文本更长，GUI将自动扩展。我们将在[第2章](ch02.html "第2章.布局管理")中的后续食谱中介绍这种自动表单大小调整，*布局管理*。
- en: There's more...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Try resizing and maximizing this GUI with a label and watch what happens.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整和最大化带有标签的GUI，看看会发生什么。
- en: Creating buttons and changing their text property
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建按钮并更改它们的文本属性
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe extends the previous one. You can download the entire code from
    the Packt Publishing website.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱扩展了上一个食谱。您可以从Packt Publishing网站下载整个代码。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We are adding a button that, when clicked, performs an action. In this recipe,
    we will update the label we added in the previous recipe, as well as updating
    the text property of the button.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在添加一个按钮，当点击时执行一个动作。在这个食谱中，我们将更新上一个食谱中添加的标签，以及更新按钮的文本属性。
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Before clicking the button:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮之前：
- en: '![How to do it...](graphics/B04829_01_04.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_01_04.jpg)'
- en: After clicking the button, the color of the label has been changed, and so has
    the text of the button. Action!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮后，标签的颜色已经改变，按钮的文本也改变了。动作！
- en: '![How to do it...](graphics/B04829_01_05.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_01_05.jpg)'
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In line 2 we are now assigning the label to a variable and in line 3 we use
    this variable to position the label within the form. We will need this variable
    to change its properties in the `clickMe()` function. By default, this is a module-level
    variable so we can access it inside the function as long as we declare the variable
    above the function that calls it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行，我们现在将标签分配给一个变量，在第3行，我们使用这个变量来定位表单中的标签。我们将需要这个变量来在`clickMe()`函数中更改它的属性。默认情况下，这是一个模块级变量，因此只要我们在调用它的函数上方声明变量，我们就可以在函数内部访问它。
- en: Line 5 is the event handler that is being invoked once the button gets clicked.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第5行是一旦按钮被点击就被调用的事件处理程序。
- en: In line 7, we create the button and bind the command to the `clickMe()` function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7行，我们创建按钮并将命令绑定到`clickMe()`函数。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: GUIs are event-driven. Clicking the button creates an event. We bind what happens
    when this event occurs in the callback function using the command property of
    the `ttk.Button` widget. Notice how we do not use parentheses; only the name `clickMe`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: GUI是事件驱动的。点击按钮会创建一个事件。我们使用`ttk.Button`小部件的命令属性绑定事件发生时回调函数中的操作。请注意我们没有使用括号；只有名称`clickMe`。
- en: We also change the text of the label to include `red` as in the printed book,
    this might otherwise not be obvious. When you run the code you can see that the
    color did indeed change.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将标签的文本更改为包含`red`，就像印刷版中一样，否则可能不太明显。当您运行代码时，您会看到颜色确实改变了。
- en: Lines 3 and 8 both use the grid layout manager, which will be discussed in the
    following chapter. This aligns both the label and the button.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第3行和第8行都使用了网格布局管理器，这将在下一章中讨论。这样可以对齐标签和按钮。
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We will continue to add more and more widgets to our GUI and we will make use
    of many built-in properties in other recipes in the book.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续向我们的GUI中添加更多的小部件，并在本书的其他章节中利用许多内置属性。
- en: Text box widgets
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本框小部件
- en: In `tkinter`, the typical textbox widget is called `Entry`. In this recipe,
    we will add such an `Entry` to our GUI. We will make our label more useful by
    describing what the `Entry` is doing for the user.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tkinter`中，典型的文本框小部件称为`Entry`。在这个食谱中，我们将向我们的GUI添加这样一个`Entry`。我们将通过描述`Entry`为用户做了什么来使我们的标签更有用。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe builds upon the *Creating buttons and changing their text property*
    recipe.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱是基于*创建按钮并更改它们的文本属性*食谱的。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now our GUI looks like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的GUI看起来是这样的：
- en: '![How to do it...](graphics/B04829_01_06.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_01_06.jpg)'
- en: 'After entering some text and clicking the button, there is the following change
    in the GUI:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一些文本并点击按钮后，GUI发生了以下变化：
- en: '![How to do it...](graphics/B04829_01_07.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_01_07.jpg)'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In line 2 we are getting the value of the `Entry` widget. We are not using OOP
    yet, so how come we can access the value of a variable that was not even declared
    yet?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行，我们获取`Entry`小部件的值。我们还没有使用面向对象编程，那么我们怎么能访问甚至还没有声明的变量的值呢？
- en: Without using OOP classes, in Python procedural coding we have to physically
    place a name above a statement that tries to use that name. So how come this works
    (it does)?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python过程式编码中，如果不使用面向对象编程类，我们必须在尝试使用该名称的语句上方物理放置一个名称。那么为什么这样会起作用呢（它确实起作用）？
- en: The answer is that the button click event is a callback function, and by the
    time the button is clicked by a user, the variables referenced in this function
    are known and do exist.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是按钮单击事件是一个回调函数，当用户单击按钮时，此函数中引用的变量是已知且存在的。
- en: Life is good.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 生活很美好。
- en: Line 4 gives our label a more meaningful name, because now it describes the
    textbox below it. We moved the button down next to the label to visually associate
    the two. We are still using the grid layout manager, to be explained in more detail
    in [Chapter 2](ch02.html "Chapter 2. Layout Management"), *Layout Management*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第4行给我们的标签一个更有意义的名称，因为现在它描述了它下面的文本框。我们将按钮移动到标签旁边，以视觉上将两者关联起来。我们仍然使用网格布局管理器，将在[第2章](ch02.html
    "第2章.布局管理")中详细解释，*布局管理*。
- en: Line 6 creates a variable `name`. This variable is bound to the `Entry` and,
    in our `clickMe()` function, we are able to retrieve the value of the `Entry`
    box by calling `get()` on this variable. This works like a charm.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第6行创建了一个变量“name”。这个变量绑定到“Entry”，在我们的“clickMe（）”函数中，我们可以通过在这个变量上调用“get（）”来检索“Entry”框的值。这非常有效。
- en: Now we see that while the button displays the entire text we entered (and more),
    the textbox `Entry` widget did not expand. The reason for this is that we had
    hard-coded it to a width of 12 in line 7.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到，虽然按钮显示了我们输入的整个文本（以及更多），但文本框“Entry”小部件没有扩展。原因是我们在第7行中将其硬编码为宽度为12。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Python is a dynamically-typed language and infers the type from the assignment.
    What this means is if we assign a string to the variable `name,` the variable
    will be of the type string, and if we assign an integer to `name,` this variable's
    type will be integer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种动态类型的语言，并且从赋值中推断类型。这意味着如果我们将一个字符串赋给变量“name”，那么该变量将是字符串类型，如果我们将一个整数赋给“name”，那么该变量的类型将是整数。
- en: Using tkinter, we have to declare the variable `name` as the type `tk.StringVar()`
    before we can use it successfully. The reason is this that Tkinter is not Python.
    We can use it from Python but it is not the same language.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用tkinter，我们必须将变量“name”声明为类型“tk.StringVar（）”才能成功使用它。原因是Tkinter不是Python。我们可以从Python中使用它，但它不是相同的语言。
- en: Setting the focus to a widget and disabling widgets
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将焦点设置为小部件并禁用小部件
- en: While our GUI is nicely improving, it would be more convenient and useful to
    have the cursor appear in the `Entry` widget as soon as the GUI appears. Here
    we learn how to do this.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的图形用户界面正在不断改进，但在GUI出现时让光标立即出现在“Entry”小部件中会更方便和有用。在这里，我们学习如何做到这一点。
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe extends the previous recipe.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例扩展了以前的示例。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Python is truly great. All we have to do to set the focus to a specific control
    when the GUI appears is call the `focus()` method on an instance of a `tkinter`
    widget we previously created. In our current GUI example, we assigned the `ttk.Entry`
    class instance to a variable we named `nameEntered`. Now we can give it the focus.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Python真的很棒。当GUI出现时，我们只需调用先前创建的“tkinter”小部件实例上的“focus（）”方法，就可以将焦点设置为特定控件。在我们当前的GUI示例中，我们将“ttk.Entry”类实例分配给了一个名为“nameEntered”的变量。现在我们可以给它焦点。
- en: Place the following code just above the bottom of the module that starts the
    main windows event loop, just like in previous recipes. If you get some errors,
    make sure you are placing calls to variables below the code where they are declared.
    We are not using OOP as of yet, so this is still necessary. Later, it will no
    longer be necessary to do this.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码放在启动主窗口事件循环的模块底部之上，就像以前的示例一样。如果出现错误，请确保将变量调用放在声明它们的代码下面。我们目前还没有使用面向对象编程，所以这仍然是必要的。以后，将不再需要这样做。
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: On a Mac, you might have to set the focus to the GUI window first before being
    able to set the focus to the `Entry` widget in this window.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上，您可能必须先将焦点设置为GUI窗口，然后才能将焦点设置为该窗口中的“Entry”小部件。
- en: Adding this one line of Python code places the cursor into our text `Entry`
    box, giving the text `Entry` box the focus. As soon as the GUI appears, we can
    type into this text box without having to click it first.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这一行Python代码将光标放入我们的文本“Entry”框中，使文本“Entry”框获得焦点。一旦GUI出现，我们就可以在不必先单击它的情况下在这个文本框中输入。
- en: '![How to do it...](graphics/B04829_01_08.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_01_08.jpg)'
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note how the cursor now defaults to residing inside the text `Entry` box.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，光标现在默认驻留在文本“Entry”框内。
- en: 'We can also disable widgets. To do that, we set a property on the widget. We
    can make the button disabled by adding this one line of Python code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以禁用小部件。为此，我们在小部件上设置一个属性。通过添加这一行Python代码，我们可以使按钮变为禁用状态：
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After adding the above line of Python code, clicking the button no longer creates
    any action!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 添加上述一行Python代码后，单击按钮不再产生任何动作！
- en: '![How to do it...](graphics/B04829_01_09.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_01_09.jpg)'
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This code is self-explanatory. We set the focus to one control and disable another
    widget. Good naming in programming languages helps to eliminate lengthy explanations.
    Later in this book, there will be some advanced tips on how to do this while programming
    at work or practicing our programming skills at home.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是不言自明的。我们将焦点设置为一个控件并禁用另一个小部件。在编程语言中良好的命名有助于消除冗长的解释。在本书的后面，将有一些关于如何在工作中编程或在家练习编程技能时进行高级提示。
- en: There's more...
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Yes. This is only the first chapter. There is much more to come.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。这只是第一章。还有更多内容。
- en: Combo box widgets
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合框小部件
- en: In this recipe, we will improve our GUI by adding drop-down combo boxes that
    can have initial default values. While we can restrict the user to only certain
    choices, at the same time, we can allow the user to type in whatever they wish.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将通过添加下拉组合框来改进我们的GUI，这些下拉组合框可以具有初始默认值。虽然我们可以限制用户只能选择某些选项，但与此同时，我们也可以允许用户输入他们希望的任何内容。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe extends the previous recipes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例扩展了以前的示例。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We are inserting another column between the `Entry` widget and the `Button`
    using the grid layout manager. Here is the Python code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用网格布局管理器在“Entry”小部件和“Button”之间插入另一列。以下是Python代码。
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code, when added to previous recipes, creates the following GUI. Note how,
    in line 4 in the preceding code, we assign a tuple with default values to the
    combo box. These values then appear in the drop-down box. We can also change them
    if we like (by typing in different values when the application is running).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码添加到以前的示例中后，将创建以下GUI。请注意，在前面的代码的第4行中，我们将默认值的元组分配给组合框。然后这些值出现在下拉框中。如果需要，我们也可以在应用程序运行时更改它们（通过输入不同的值）。
- en: '![How to do it...](graphics/B04829_01_10.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_01_10.jpg)'
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Line 1 adds a second label to match the newly created combo box (created in
    line 3). Line 2 assigns the value of the box to a variable of a special `tkinter`
    type (`StringVar`), as we did in a previous recipe.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第1行添加了第二个标签以匹配新创建的组合框（在第3行创建）。第2行将框的值分配给特殊`tkinter`类型的变量（`StringVar`），就像我们在之前的示例中所做的那样。
- en: Line 5 aligns the two new controls (label and combo box) within our previous
    GUI layout, and line 6 assigns a default value to be displayed when the GUI first
    becomes visible. This is the first value of the `numberChosen['values']` tuple,
    the string `"1"`. We did not place quotes around our tuple of integers in line
    4, but they got casted into strings because, in line 2, we declared the values
    to be of type `tk.StringVar`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第5行将两个新控件（标签和组合框）与我们之前的GUI布局对齐，第6行在GUI首次可见时分配要显示的默认值。这是`numberChosen['values']`元组的第一个值，字符串`"1"`。我们在第4行没有在整数元组周围放置引号，但它们被转换为字符串，因为在第2行，我们声明值为`tk.StringVar`类型。
- en: The screenshot shows the selection made by the user (**42**). This value gets
    assigned to the `number` variable.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕截图显示用户所做的选择（**42**）。这个值被分配给`number`变量。
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we want to restrict the user to only be able to select the values we have
    programmed into the `Combobox`, we can do that by passing the *state property*
    into the constructor. Modify line 3 in the previous code to:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望限制用户只能选择我们编程到`Combobox`中的值，我们可以通过将*state属性*传递给构造函数来实现。修改前面代码中的第3行：
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now users can no longer type values into the `Combobox`. We can display the
    value chosen by the user by adding the following line of code to our Button Click
    Event Callback function:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户不能再在`Combobox`中输入值。我们可以通过在我们的按钮单击事件回调函数中添加以下代码行来显示用户选择的值：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After choosing a number, entering a name, and then clicking the button, we
    get the following GUI result, which now also displays the number selected:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个数字，输入一个名称，然后单击按钮，我们得到以下GUI结果，现在还显示了所选的数字：
- en: '![There''s more...](graphics/B04829_01_11.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](graphics/B04829_01_11.jpg)'
- en: Creating a check button with different initial states
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建具有不同初始状态的复选按钮
- en: In this recipe, we will add three `Checkbutton` widgets, each with a different
    initial state.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将添加三个`Checkbutton`小部件，每个小部件都有不同的初始状态。
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe extends the previous recipes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例扩展了之前的示例。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We are creating three `Checkbutton` widgets that differ in their states. The
    first is disabled and has a checkmark in it. The user cannot remove this checkmark
    as the widget is disabled.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了三个`Checkbutton`小部件，它们的状态不同。第一个是禁用的，并且其中有一个复选标记。用户无法移除此复选标记，因为小部件被禁用。
- en: The second `Checkbutton` is enabled and, by default, has no checkmark in it,
    but the user can click it to add a checkmark.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`Checkbutton`是启用的，并且默认情况下没有复选标记，但用户可以单击它以添加复选标记。
- en: The third `Checkbutton` is both enabled and checked by default. The users can
    uncheck and recheck the widget as often as they like.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个`Checkbutton`既启用又默认选中。用户可以随意取消选中和重新选中小部件。
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running the new code results in the following GUI:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 运行新代码将得到以下GUI：
- en: '![How to do it...](graphics/B04829_01_12.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_01_12.jpg)'
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In lines 2, 6, and 10, we create three variables of type `IntVar`. In the following
    line, for each of these variables we create a `Checkbutton`, passing in these
    variables. They will hold the state of the `Checkbutton` (unchecked or checked).
    By default, that is either 0 (unchecked) or 1 (checked) so the type of the variable
    is a `tkinter` integer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2、6和10行，我们创建了三个`IntVar`类型的变量。在接下来的一行中，对于这些变量中的每一个，我们创建一个`Checkbutton`，传入这些变量。它们将保存`Checkbutton`的状态（未选中或选中）。默认情况下，它们是0（未选中）或1（选中），因此变量的类型是`tkinter`整数。
- en: We place these `Checkbutton` widgets in our main window so the first argument
    passed into the constructor is the parent of the widget; in our case `win`. We
    give each `Checkbutton` a different label via its `text` property.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些`Checkbutton`小部件放在我们的主窗口中，因此传递给构造函数的第一个参数是小部件的父级；在我们的情况下是`win`。我们通过其`text`属性为每个`Checkbutton`提供不同的标签。
- en: Setting the sticky property of the grid to `tk.W` means that the widget will
    be aligned to the west of the grid. This is very similar to Java syntax and it
    means that it will be aligned to the left. When we resize our GUI, the widget
    will remain on the left side and not be moved towards the center of the GUI.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将网格的sticky属性设置为`tk.W`意味着小部件将对齐到网格的西侧。这与Java语法非常相似，意味着它将对齐到左侧。当我们调整GUI的大小时，小部件将保持在左侧，并不会向GUI的中心移动。
- en: Lines 4 and 12 place a checkmark into the `Checkbutton` widget by calling the
    `select()` method on these two `Checkbutton` class instances.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第4和12行通过调用这两个`Checkbutton`类实例的`select()`方法向`Checkbutton`小部件中放入复选标记。
- en: We continue to arrange our widgets using the grid layout manager, which will
    be explained in more detail in [Chapter 2](ch02.html "Chapter 2. Layout Management"),
    *Layout Management*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用网格布局管理器来排列我们的小部件，这将在[第2章](ch02.html "第2章。布局管理")*布局管理*中详细解释。
- en: Using radio button widgets
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用单选按钮小部件
- en: In this recipe, we will create three `tkinter Radiobutton` widgets. We will
    also add some code that changes the color of the main form depending upon which
    `Radiobutton` is selected.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建三个`tkinter Radiobutton`小部件。我们还将添加一些代码，根据选择的`Radiobutton`来更改主窗体的颜色。
- en: Getting ready
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe extends the previous recipes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例扩展了之前的示例。
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We are adding the following code to the previous recipe:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以下代码添加到之前的示例中：
- en: '[PRE13]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Running this code and selecting the `Radiobutton` named **Gold** creates the
    following window:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码并选择名为**Gold**的`Radiobutton`将创建以下窗口：
- en: '![How to do it...](graphics/B04829_01_13.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B04829_01_13.jpg)'
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In lines 2-4 we create some module-level global variables, which we will use
    in the creation of each radio button as well as in the callback function that
    creates the action of changing the background color of the main form (using the
    instance variable `win`).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在2-4行中，我们创建了一些模块级全局变量，我们将在每个单选按钮的创建以及在创建改变主窗体背景颜色的回调函数（使用实例变量`win`）中使用这些变量。
- en: We are using global variables to make it easier to change the code. By assigning
    the name of the color to a variable and using this variable in several places,
    we can easily experiment with different colors. Instead of doing a global search-and-replace
    of a hard-coded string (which is prone to errors), we just need to change one
    line of code and everything else will work. This is known as the **DRY principle**,
    which stands for **Don't Repeat Yourself**. This is an OOP concept that we will
    use in later recipes of the book.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用全局变量使代码更容易更改。通过将颜色的名称分配给一个变量，并在多个地方使用这个变量，我们可以轻松地尝试不同的颜色。我们只需要更改一行代码，而不是全局搜索和替换硬编码的字符串（容易出错），其他所有东西都会工作。这被称为**DRY原则**，代表**不要重复自己**。这是我们将在本书的后续食谱中使用的面向对象编程概念。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The names of the colors we are assigning to the variables (`COLOR1`, `COLOR2
    …`) are `tkinter` keywords (technically, they are *symbolic names*). If we use
    names that are not `tkinter` color keywords, then the code will not work.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分配给变量（`COLOR1`，`COLOR2...`）的颜色名称是`tkinter`关键字（从技术上讲，它们是*符号名称*）。如果我们使用不是`tkinter`颜色关键字的名称，那么代码将无法工作。
- en: Line 6 is the *callback function* that changes the background of our main form
    (`win`) depending upon the user's selection.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第6行是*回调函数*，根据用户的选择改变我们主窗体（`win`）的背景。
- en: In line 8 we are creating a `tk.IntVar` variable. What is important about this
    is that we are creating only one variable to be used by all three radio buttons.
    As can be seen from the above screenshot, no matter which `Radiobutton` we select,
    all the others will automatically be unselected for us.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8行，我们创建了一个`tk.IntVar`变量。重要的是，我们只创建了一个变量供所有三个单选按钮使用。从上面的截图中可以看出，无论我们选择哪个`Radiobutton`，所有其他的都会自动为我们取消选择。
- en: Lines 9 to 14 create the three radio buttons, assign them to the main form,
    and pass in the variable to be used in the callback function that creates the
    action of changing the background of our main window.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第9到14行创建了三个单选按钮，将它们分配给主窗体，并传入要在回调函数中使用的变量，以创建改变主窗口背景的操作。
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While this is the first recipe that changes the color of a widget, quite honestly,
    it looks a bit ugly. A large portion of the following recipes in this book explain
    how to make our GUI look truly amazing.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是第一个改变小部件颜色的食谱，但老实说，它看起来有点丑。本书中的大部分后续食谱都会解释如何使我们的GUI看起来真正令人惊叹。
- en: There's more...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here is a small sample of the available symbolic color names that you can look
    up at the official tcl manual page:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一小部分可用的符号颜色名称，您可以在官方tcl手册页面上查找：
- en: '[http://www.tcl.tk/man/tcl8.5/TkCmd/colors.htm](http://www.tcl.tk/man/tcl8.5/TkCmd/colors.htm)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.tcl.tk/man/tcl8.5/TkCmd/colors.htm](http://www.tcl.tk/man/tcl8.5/TkCmd/colors.htm)'
- en: '| Name | Red | Green | Blue |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 红 | 绿 | 蓝 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| alice blue | 240 | 248 | 255 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| alice blue | 240 | 248 | 255 |'
- en: '| AliceBlue | 240 | 248 | 255 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| AliceBlue | 240 | 248 | 255 |'
- en: '| Blue | 0 | 0 | 255 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| Blue | 0 | 0 | 255 |'
- en: '| Gold | 255 | 215 | 0 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 金色 | 255 | 215 | 0 |'
- en: '| Red | 255 | 0 | 0 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 红色 | 255 | 0 | 0 |'
- en: Some of the names create the same color, so `alice blue` creates the same color
    as `AliceBlue`. In this recipe we used the symbolic names `Blue`, `Gold`, and
    `Red`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一些名称创建相同的颜色，因此`alice blue`创建的颜色与`AliceBlue`相同。在这个食谱中，我们使用了符号名称`Blue`，`Gold`和`Red`。
- en: Using scrolled text widgets
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用滚动文本小部件
- en: '`ScrolledText` widgets are much larger than simple `Entry` widgets and span
    multiple lines. They are widgets like Notepad and wrap lines, automatically enabling
    vertical scrollbars when the text gets larger than the height of the `ScrolledText`
    widget.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrolledText`小部件比简单的`Entry`小部件大得多，跨越多行。它们就像记事本一样的小部件，自动换行，并在文本大于`ScrolledText`小部件的高度时自动启用垂直滚动条。'
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe extends the previous recipes. You can download the code for each
    chapter of this book from the Packt Publishing website.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱扩展了之前的食谱。您可以从Packt Publishing网站下载本书每一章的代码。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'By adding the following lines of code, we create a `ScrolledText` widget:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加以下代码行，我们创建了一个`ScrolledText`小部件：
- en: '[PRE14]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can actually type into our widget, and if we type enough words, the lines
    will automatically wrap around!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以在我们的小部件中输入文字，如果我们输入足够多的单词，行将自动换行！
- en: '![How to do it...](graphics/B04829_01_14.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_01_14.jpg)'
- en: Once we type in more words than the height of the widget can display, the vertical
    scrollbar becomes enabled. This all works out-of-the-box without us needing to
    write any more code to achieve this.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们输入的单词超过了小部件可以显示的高度，垂直滚动条就会启用。所有这些都是开箱即用的，我们不需要编写任何额外的代码来实现这一点。
- en: '![How to do it...](graphics/B04829_01_15.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B04829_01_15.jpg)'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In line 2 we are importing the module that contains the `ScrolledText` widget
    class. Add that to the top of the module, just below the other two `import` statements.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行，我们导入包含`ScrolledText`小部件类的模块。将其添加到模块顶部，就在其他两个`import`语句的下面。
- en: Lines 4 and 5 define the width and height of the `ScrolledText` widget we are
    about to create. These are hard-coded values we are passing into the `ScrolledText`
    widget constructor in line 6.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第4和5行定义了我们即将创建的`ScrolledText`小部件的宽度和高度。这些是硬编码的值，我们将它们传递给第6行中`ScrolledText`小部件的构造函数。
- en: These values are *magic numbers* found by experimentation to work well. You
    might experiment by changing `srcolW` from 30 to 50 and observe the effect!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值是通过实验找到的*魔术数字*，可以很好地工作。您可以尝试将`srcolW`从30更改为50，并观察效果！
- en: In line 6 we are setting a property on the widget by passing in `wrap=tk.WORD`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6行，我们通过传入`wrap=tk.WORD`在小部件上设置了一个属性。
- en: By setting the `wrap` property to `tk.WORD` we are telling the `ScrolledText`
    widget to break lines by words, so that we do not wrap around within a word. The
    default option is `tk.CHAR`, which wraps any character regardless of whether we
    are in the middle of a word.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`wrap`属性设置为`tk.WORD`，我们告诉`ScrolledText`小部件按单词换行，这样我们就不会在单词中间换行。默认选项是`tk.CHAR`，它会在单词中间换行。
- en: The second screenshot shows that the vertical scrollbar moved down because we
    are reading a longer text that does not entirely fit into the x, y dimensions
    of the `SrolledText` control we created.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个屏幕截图显示，垂直滚动条向下移动，因为我们正在阅读一个较长的文本，它不能完全适应我们创建的`SrolledText`控件的x，y维度。
- en: Setting the `columnspan` property of the grid widget to `3` for the `SrolledText`
    widget makes this widget span all three columns. If we did not set this property,
    our `SrolledText` widget would only reside in column one, which is not what we
    want.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将网格小部件的`columnspan`属性设置为`3`，使`SrolledText`小部件跨越所有三列。如果我们不设置这个属性，我们的`SrolledText`小部件将只驻留在第一列，这不是我们想要的。
- en: Adding several widgets in a loop
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在循环中添加多个小部件
- en: So far we have created several widgets of the same type (for example. `Radiobutton`)
    by basically copying and pasting the same code and then modifying the variations
    (for example, the column number). In this recipe, we start refactoring our code
    to make it less redundant.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过基本上复制和粘贴相同的代码，然后修改变化（例如，列号）来创建了几个相同类型的小部件（例如`Radiobutton`）。在这个示例中，我们开始重构我们的代码，使其不那么冗余。
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are refactoring some parts of the previous recipe's code, so you need that
    code to apply to this recipe to.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在重构上一个示例代码的一些部分，所以你需要将那个代码应用到这个示例中。
- en: How to do it...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: '[PRE15]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Running this code will create the same window as before, but our code is much
    cleaner and easier to maintain. This will help us when we expand our GUI in the
    following recipes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将创建与以前相同的窗口，但我们的代码更清晰，更易于维护。这将有助于我们在下一个示例中扩展我们的GUI。
- en: How it works...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In line 1, we have turned our global variables into a list.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行，我们将全局变量转换为列表。
- en: In line 2, we are setting a default value to the `tk.IntVar` variable we named
    `radVar`. This is important because, while in the previous recipe we had set the
    value for `Radiobutton` widgets starting at 1, in our new loop it is much more
    convenient to use Python's zero-based indexing. If we did not set the default
    value to a value outside the range of our `Radiobutton` widgets, one of the radio
    buttons would be selected when the GUI appears. While this in itself might not
    be so bad, *it would not trigger the callback* and we would end up with a radio
    button selected that does not do its job (that is, change the color of the main
    win form).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行，我们为名为`radVar`的`tk.IntVar`变量设置了默认值。这很重要，因为在上一个示例中，我们将`Radiobutton`小部件的值设置为1，但在我们的新循环中，使用Python的基于零的索引更方便。如果我们没有将默认值设置为超出`Radiobutton`小部件范围的值，当GUI出现时，将选择一个单选按钮。虽然这本身可能并不那么糟糕，*它不会触发回调*，我们最终会选择一个不起作用的单选按钮（即更改主窗体的颜色）。
- en: In line 3 we are replacing the three previously hard-coded creations of the
    Radiobutton widgets with a loop, which does the same. It is just more concise
    (fewer lines of code) and much more maintainable. For example, if we want to create
    100 instead of just 3 `Radiobutton` widgets, all we have to change is the number
    inside Python's range operator. We would not have to type or copy and paste 97
    sections of duplicate code, just one number.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3行，我们用循环替换了之前硬编码创建`Radiobutton`小部件的三个部分，这样做是一样的。它只是更简洁（代码行数更少）和更易于维护。例如，如果我们想创建100个而不仅仅是3个`Radiobutton`小部件，我们只需要改变Python的range运算符中的数字。我们不必输入或复制粘贴97个重复代码段，只需一个数字。
- en: Line 4 shows the modified callback, which physically lives above the previous
    lines. We placed it below to give emphasis to the more important parts of this
    recipe.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 第4行显示了修改后的回调，实际上它位于前面的行之上。我们将其放在下面是为了强调这个示例的更重要的部分。
- en: There's more...
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe concludes the first chapter of this book. All the following recipes
    in all of the next chapters will build upon the GUI we have constructed so far,
    greatly enhancing it.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例结束了本书的第一章。接下来章节中的所有示例都将在我们迄今为止构建的GUI基础上进行扩展，大大增强它。
