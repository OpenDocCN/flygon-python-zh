- en: Making Your Own Area Scanner
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在，假设在0度的位置，电位器的输出电压为4.8V；当我们将它旋转到90度时，值会变为大约3.2V，当完全旋转到180度时，由于电阻的改变，电压会降至仅有2V。
- en: Motors are amazing things; they come in all shapes and sizes. Primarily, they
    can be considered the backbone of most robots. However, nothing is perfect in
    this world. There must be some drawbacks to these motors as well. By now, you
    might have figured out some by yourself. In the previous chapter, when we made
    the car turn, you might have seen that the angle of turn was never really the
    same. Also when the vehicle was given the command to go straight, it really would
    not do so. Rather it would try to run slight, toward one side.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 电机是令人惊奇的东西；它们有各种各样的形状和大小。主要上，它们可以被认为是大多数机器人的支撑。然而，在这个世界上没有什么是完美的。这些电机肯定也有一些缺点。到现在为止，你可能已经自己发现了一些。在上一章中，当我们让车子转弯时，你可能已经注意到转弯的角度从来不是完全相同的。同样，当车辆被命令直行时，它实际上并不会这样做。相反，它会试图向一侧轻微偏离。
- en: Say hello to the first problem—precision. The motors are exceptionally simple
    to control, but the problem with these motors come when we have to rotate the
    motors only till a specific angle. If you need to rotate the motor of your robotic
    vehicle only by 90 degrees, then how would you do it? The first and foremost thing
    that might come to your mind would be to fiddle with the timings of the motors.
    You might be right here. But still, it would be impossible to make sure that it
    is exactly 90 degrees every single time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/f982d278-8b3c-45b1-8280-67f23461fbeb.png)'
- en: But when we talk about robots, accuracy of even 1 degree may not be enough.
    Roboticists these days are looking forward to accuracy within the magnitude of
    two decimal digits. So, the precision we are talking about is close to 0.01 degrees.
    What do you think now? How do we achieve this level of accuracy with motors?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们谈论机器人时，即使1度的精度可能还不够。如今的机器人学家期待的精度在两位小数的数量级内。因此，我们所说的精度接近0.01度。你现在怎么想？我们如何用电机实现这种精度水平呢？
- en: 'The answers to all these questions will be answered in this chapter through
    the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 激光雷达
- en: Servo motor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伺服电机
- en: Lists
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在我们有的是一个通过多个减速齿轮与电位器耦合的电机，它将减慢电机的速度并增加扭矩。在最终齿轮处，轴向外安装到机身上并与电位器耦合。列表
- en: LIDAR
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们把它放在一个有趣的组合中：
- en: Servo motor
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伺服电机
- en: 'So, let me introduce you to *servo motor*. Servo motor is basically a motor
    with a few added components. Now to understand what those added components, let''s
    first go through this example. Let''s say that you want to go to London. Now to
    see how you have to go there and what would be the route to reach London, the
    first thing you need to know is that where exactly you are now. If you don''t
    know where you are currently, it is impossible to calculate a route. Similarly,
    if we want to reach a certain position of motor, we need to know where the shaft
    of the motor is standing right now. To do this, we use a **potentiometer**. A
    potentiometer is basically a variable resistor that essentially has a shaft that
    when rotated changes the value of resistance. A variable resistor looks like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当电阻器的值改变时，电阻器的输出电压也会改变。有趣的是，如果电位器的输入电压是已知的，那么它的输出电压可以用来推断轴的位置。让我们看看如何做到：
- en: '![](Images/f982d278-8b3c-45b1-8280-67f23461fbeb.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5e54a397-af93-4c44-8c7b-4fcf74a10a7b.png)'
- en: 'When the value of resistor change, then the output voltage from the resistor
    will also change. The interesting thing is that if the input voltage to the potentiometer
    is well known, then the output voltage from it can be used to infer where the
    shaft is. Let''s see how:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 而不用真正看电位器的轴，我们可以很容易地推断出，如果电阻器的输出电压为4.8V，那么轴必须处于0度的位置。同样，我们可以说，如果电压为3.2V，那么它就处于90度的位置，当电压为2V时，它就处于180度的位置。
- en: '![](Images/5e54a397-af93-4c44-8c7b-4fcf74a10a7b.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: 制作你自己的区域扫描仪
- en: Now, let's say at a position of 0 degrees, the output voltage for the potentiometer
    is 4.8V; when we move it up to 90 degrees, the value changes to around 3.2V, and
    upon turning entirely 180 degrees, the voltage reduces to a mere 2V due to the
    change in resistance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我向你介绍*伺服电机*。伺服电机基本上是一个带有一些附加组件的电机。现在，要理解这些附加组件是什么，让我们先通过这个例子来看一下。假设你想去伦敦。现在，要了解你如何去那里以及到达伦敦的路线，你首先需要知道的是你现在的确切位置。如果你不知道你目前在哪里，就不可能计算出一条路线。同样，如果我们想要到达电机的某个位置，我们需要知道电机的轴现在所处的位置。为了做到这一点，我们使用一个**电位器**。电位器基本上是一个变阻器，它有一个轴，当旋转时会改变电阻的值。一个变阻器看起来像这样：
- en: Without really looking at the shaft of the potentiometer, we can easily derive
    that if the voltage output from the resistor is 4.8V, then the shaft must be at
    a position of 0 degrees. Similarly, we can say that it is at 90 degrees if the
    voltage is 3.2V and at 180 degrees when the voltage is 2V.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/f099b21d-72be-42ac-bc4f-1a754d738656.png)'
- en: 'Here, we have just plotted three points, but for any given point on the potentiometer,
    there would be a very specific resistance corresponding to it. Through this we
    can precisely calculate where the shaft of the potentiometer would be. Now, let''s
    put it in an interesting combination:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是绘制了三个点，但对于电位器上的任何给定点，都会有一个非常特定的电阻与之对应。通过这个，我们可以精确计算出电位器的轴会在哪里。
- en: '![](Images/f099b21d-72be-42ac-bc4f-1a754d738656.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: 通过以下主题，本章将回答所有这些问题：
- en: Now what we have is a motor coupled with potentiometer through multiple reducing
    gears that will reduce the speed of the motor and increase the torque. Further
    at the final gear, a shaft is mounted outward to the body coupled with a potentiometer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 向第一个问题打个招呼——精度。控制这些电机非常简单，但当我们必须将电机旋转到特定角度时，这些电机的问题就出现了。如果你需要将你的机器人车的电机只旋转90度，那么你该怎么做呢？你脑海中可能首先想到的是调整电机的时间。在这一点上你可能是对的。但是，要确保每次都能旋转到确切的90度是不可能的。
- en: So as you learned, the potentiometer will be able to sense at which angle the
    output shaft is pointing. The potentiometer is then connected to a control circuit
    that takes the reading from the potentiometer and further guides the motor on
    how much more to move to reach the goal position. Due to this closed loop arrangement
    in which the control circuit knows where the shaft is, it could calculate how
    much it has to move the motor to reach the goal position. Hence, this arrangement
    is able to turn the output shaft to any given position precisely.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如您所了解的，电位器将能够感知输出轴指向的角度。然后，电位器连接到一个控制电路，该电路从电位器中读取数据，并进一步指导电机移动多少才能达到目标位置。由于这种闭环安排中控制电路知道轴在哪里，它可以计算需要移动电机多少才能达到目标位置。因此，这种安排能够将输出轴精确地转到任何给定的位置。
- en: 'This arrangement is typically known as a **servo motor**. Throughout the robotics
    industry, it is one of the most widely used hardware to control precise movements.
    Essentially, there are three wires going into the control circuit—VCC, ground,
    and signal. The signal line will receive the data from our Raspberry Pi, and upon
    receiving, it will do the necessary motor movement to make the shaft reach the
    desired position. An image of a servo motor is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安排通常被称为**舵机**。在机器人行业中，这是控制精确运动最广泛使用的硬件之一。基本上，有三根导线进入控制电路——VCC、地线和信号。信号线将接收来自我们的树莓派的数据，并在接收后，它将进行必要的电机运动，使轴达到所需的位置。舵机的图像如下：
- en: '![](Images/d29c7091-5e71-476a-9560-458e8548d3db.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d29c7091-5e71-476a-9560-458e8548d3db.jpg)'
- en: These can start from being extremely inexpensive, around $4 to $5, but they
    can go up to thousands of dollars. But what really decides the pricing of these
    servo motors? There are several factors that we need to keep in mind while choosing
    a servo motor, but the most important of it is **torque**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以从非常便宜的价格开始，大约4到5美元，但它们的价格可以上升到数千美元。但是是什么决定了这些舵机的定价呢？在选择舵机时，有几个因素需要记住，但其中最重要的是**扭矩**。
- en: 'Torque is a basically a turning force by which a motor can turn the output
    shaft. This is measured usually in kg·cm or N·m. Now what does this actually mean?  Let''s
    see the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 扭矩基本上是电机可以转动输出轴的转动力。通常以千克·厘米或牛顿·米来衡量。那这实际上是什么意思呢？让我们看下面的图表：
- en: '![](Images/8f141cf1-1546-4aa6-b001-a25230a76c6c.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8f141cf1-1546-4aa6-b001-a25230a76c6c.png)'
- en: Let's say in the preceding diagram, we have a motor that has a torque of 10
    kg·cm and the rotor attached to it is of 1 cm. So, it should be able to pull up
    a weight of 10 kg perpendicularly up from the ground. However, when we change
    the radius of the rotor to 2 cm, then the weight that can be lifted gets halved. Similarly,
    if the radius increases to 10 cm, then the weight that can be lifted would only
    reduce to 1 kg. So basically, the weight that can be lifted would be torque/radius.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在前面的图表中，我们有一个扭矩为10千克·厘米的电机，附在上面的转子是1厘米。因此，它应该能够垂直从地面上拉起10千克的重量。然而，当我们将转子的半径改为2厘米时，可以被提起的重量减半。同样，如果半径增加到10厘米，那么可以被提起的重量只会减少到1千克。因此，基本上可以提起的重量将是扭矩/半径。
- en: 'But for most of our purposes, we would not be using a mechanism as shown previously,
    so let''s look at the next diagram to see how the calculations can be made:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但是对于我们大多数的目的，我们不会使用之前显示的机制，所以让我们看下一个图表，看看如何进行计算：
- en: '![](Images/f16efa7c-28dc-4e55-b304-677c5cc3bd63.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f16efa7c-28dc-4e55-b304-677c5cc3bd63.png)'
- en: Now, let's say we have a shaft of length **L** and a load at the extreme edge
    of the shaft. For ease of calculation purposes, we would consider the weight of
    shaft to be negligible. Now if the servo is having a torque of 100 kg·cm and the
    length of shaft (**L**) is 10 cm, then by simple calculation, the load that we
    can pick up would be 100/10 = 10 kg. Similarly, if the length increases to 100
    cm, the load that can be lifted would reduce to a mere 1 kg.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个长度为**L**的轴和轴的极端边上的负载。为了方便计算，我们将轴的重量视为可以忽略不计。现在，如果舵机的扭矩为100千克·厘米，轴的长度(**L**)为10厘米，那么通过简单的计算，我们可以提起的负载将是100/10
    = 10千克。同样，如果长度增加到100厘米，可以提起的负载将减少到仅为1千克。
- en: OK then; we have had a good amount of exposure to servo motors. Now the question
    is how do we control a servo motor? As I mentioned, there are different types
    of servo motors that are available that can be addressed by various means. However,
    the most common one used for hobby purposes is a digital servo motor. These servo
    motors require **PWM**, and based on the duty cycle of PWM, the angle of the shaft
    changes. So, let's see how it happens.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们已经对舵机有了相当多的了解。现在的问题是我们如何控制舵机？正如我提到的，有不同类型的舵机可供选择，可以通过各种方式进行控制。然而，用于业余用途最常用的是数字舵机。这些舵机需要**PWM**，根据PWM的占空比，轴的角度会改变。因此，让我们看看它是如何发生的。
- en: 'Typically, most of these servos have a frequency of 50 Hz. So basically the
    length of every pulse would be 1/50 = 0.02 seconds or in other words 20 ms. Further,
    the duty cycle that can be given to theses servo motors can be 2.5% to 12.5%,
    which basically means pulse width of 0.5 ms to 2.5 ms. Now let''s see how it works:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，大多数舵机的频率为50赫兹。因此，每个脉冲的长度通常为1/50 = 0.02秒，换句话说就是20毫秒。此外，可以给这些舵机的占空比可以是2.5%到12.5%，这基本上意味着脉冲宽度为0.5毫秒到2.5毫秒。现在让我们看看它是如何工作的：
- en: '![](Images/6bf9dcb1-8667-43f3-a692-7512b4b9ff8a.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6bf9dcb1-8667-43f3-a692-7512b4b9ff8a.png)'
- en: As you can see, when given a duty cycle of 2.5%, the shaft gets down to the
    minimum position of 0 degrees, and when the duty cycle is increased to 7.5%, the
    shaft goes to the middle position of 90 degrees. Finally, when the duty cycle
    is increased to 12.5%, the shaft goes to the maximum position of 180 degrees.
    If you want any position in between, then you can simply choose the PWM corresponding
    to it, and it will change the position of servo to the desired angle.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，当给定一个2.5%的占空比时，轴会下降到最小位置0度，当占空比增加到7.5%时，轴会到达中间位置90度。最后，当占空比增加到12.5%时，轴会到达最大位置180度。如果你想要中间的任何位置，你可以简单地选择相应的PWM，它会改变舵机的位置到所需的角度。
- en: But you may be thinking what if we want to take it beyond 180 degrees? Well,
    good question, but most of the digital servos only come with a range of 180 degrees
    of rotation. There are servos that can rotate completely its axis, that is, 360
    degrees; however, their addressing is slightly different. After this chapter,
    you can pretty much go ahead check out any digital servo motor's data sheet and
    control it the way you want.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你可能会想，如果我们想要超过180度怎么办？好问题，但是大多数数字舵机只能旋转180度。有些舵机可以完全旋转其轴，即360度；然而，它们的寻址略有不同。在本章之后，你基本上可以查看任何数字舵机的数据表，并按照自己的方式进行控制。
- en: 'All right, enough of theory; it''s time to do some fun. So, let''s go ahead
    and set up the hardware and control a servo by our bare hands! Connect the servo
    to Raspberry Pi as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，理论够了；是时候做一些有趣的事情了。所以，让我们继续设置硬件，并用我们的双手控制一个舵机！将舵机连接到树莓派如下：
- en: '![](Images/33afed26-fe51-481c-a42e-ca52ceedebf4.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/33afed26-fe51-481c-a42e-ca52ceedebf4.png)'
- en: 'The color coding of the wires is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 电线的颜色编码如下：
- en: '![](Images/54d5c3d3-abad-46a3-9b00-b633d33d4a28.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/54d5c3d3-abad-46a3-9b00-b633d33d4a28.png)'
- en: 'Next, we need to upload the following code and see what happens:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要上传以下代码并看看会发生什么：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As soon as you run this program, you will see the shaft of the servo moving
    from left to right, making steps at 0 degrees, 45 degrees, 90 degrees, 135 degrees,
    and finally 180 degrees.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会看到舵机的轴从左到右移动，分别在0度、45度、90度、135度和最后180度位置上停下。
- en: 'Let''s see what we have done in the program to achieve it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在程序中做了什么来实现它：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the line `pwm = GPIO.PWM(14, 50)`, we have defined that GPIO pin number
    `14` will be used for PWM and the frequency of PWM will be `50`. We have used
    the line `pwm.start(0)` in earlier chapters as well. It basically sets the PWM
    pin to `0` that is no duty cycle:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`pwm = GPIO.PWM(14, 50)`这一行，我们已经定义了GPIO引脚号14将用于PWM，PWM的频率将为50。我们在之前的章节中也使用了`pwm.start(0)`这一行。它基本上将PWM引脚设置为0，即没有占空比：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: No all the earlier program is in the `while` loop, that is, it will be executed
    over and over until the program is forced to quit. Now the line `pwm.ChangeDutyCycle(2.5)`
    sends a PWM of 2.5% duty cycle to the servo motor. This will simply turn the servo
    motor to 0 degree angle. Next, we use the good old `time.sleep(2)`, which we all
    know would halt the program that line for two seconds.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有之前的程序都在`while`循环中，也就是说，它将一遍又一遍地执行，直到程序被强制退出。现在，`pwm.ChangeDutyCycle(2.5)`这一行发送了一个2.5%的PWM占空比给舵机。这将简单地将舵机转到0度角。接下来，我们使用老式的`time.sleep(2)`，我们都知道这会使程序暂停两秒。
- en: The same cycle is being repeated with different PWM values of 5%, which would
    turn the shaft to 45 degrees, 7.5% for 90 degrees, 10% for 135 degrees, 12.5 %
    for 180 degrees. It's a very simple program that would clear out our basics of
    the servo motor.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的循环正在重复，使用不同的PWM值，5%的PWM会将轴转到45度，7.5%的PWM会转到90度，10%的PWM会转到135度，12.5%的PWM会转到180度。这是一个非常简单的程序，可以清楚地了解舵机的基础知识。
- en: 'So by now, you have learned how to control servo motor and move it in the direction
    in which we want. Now, let''s go a step ahead and change the code slightly to
    make the servo run smoothly:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何控制舵机并使其朝我们想要的方向移动。现在，让我们再进一步，稍微改变代码使舵机平稳运行：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What happened when you uploaded this code in your Pi? You would have noted
    that the servo is swiping from left to right very smoothly and then right to left.
    We have done a very simple trick; let''s see what it is:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在你的树莓派上上传了这段代码时发生了什么？你会注意到舵机非常平稳地从左到右刷过去，然后从右到左。我们做了一个非常简单的技巧；让我们看看是什么：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we are running a loop that will run till the time the value of `i<=12.5`,
    as we have defined earlier in the program the value of `i` has been set to `2.5`
    as default in the starting of the program. Thereafter every time the code runs,
    the duty cycle is set to the value of `I` , the program halts for 0.1 seconds
    and then the value of `i` is incremented by a value of `0.1`. This is increasing
    the duty cycle of the PWM. Once the value reaches 12.5, the loop exits.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在运行一个循环，直到值`i<=12.5`，因为我们在程序的开头已经定义了值`i`的默认值为`2.5`。之后，每次代码运行时，占空比被设置为`i`的值，程序暂停0.1秒，然后`i`的值增加0.1。这增加了PWM的占空比。一旦值达到12.5，循环退出。
- en: The entire PWM range we have is 2.5% to 12.5%, so we have a space of 10% to
    play with. Now if we map it to the angular rotation of the servo motor, then every
    percent of PWM corresponds to a change of 180/10 = 18 degrees. Similarly, every
    0.1% of the change would result in a change of 180/100 = 1.8 degrees. Hence, with
    every 0.1 seconds, we are adding duty cycle by 0.1%, or in other words, we are
    increasing the angle by 1.8 degrees. Hence, we find this action extremely smooth.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的整个PWM范围是2.5%到12.5%，所以我们有10%的空间可以使用。现在，如果我们将其映射到舵机的角度旋转，那么每个百分比的PWM对应于180/10
    = 18度的变化。同样，每0.1%的变化将导致180/100 = 1.8度的变化。因此，每0.1秒，我们增加0.1%的占空比，换句话说，我们增加1.8度的角度。因此，我们发现这个动作非常平滑。
- en: We are doing the similar thing in the next portion of the program; however,
    we are doing it for the reverse motion.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的下一部分中，我们正在做类似的事情；然而，我们是为了反向运动。
- en: Lists
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: All right then, we are quite sure on how to use the servo and have a controlled
    motion as per our needs. Now it's time to move forward and understand another
    concept that we would be using greatly. It's named **arrays**. If you have programmed
    in any other language, you must be familiar with it. But we need to understand
    a few basics concepts of it, which will make our lives a lot easier. So, let's
    get started.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么，我们非常确定如何使用伺服，并根据我们的需求进行控制运动。现在是时候继续前进，了解我们将大量使用的另一个概念。它被称为**数组**。如果你在任何其他语言中编程过，你一定很熟悉它。但我们需要了解一些基本概念，这将使我们的生活变得更加轻松。所以，让我们开始吧。
- en: 'First things, first. Arrays in Python are not named arrays, rather it is named
    as **lists**. List is basically a data structure that can store multiple elements
    at the same time. The only limitation being is that the elements must be of the
    same data type. Such as if you are storing integers, then all the values should
    be `int`. Similarly, if you are storing a character, then every element of the
    list should be `char`. To define a list, all you need to do is name the list such
    as we have done by doing `myList`; the name of the list could be anything next
    we need to tell the compiler that it is actually a list. To do that, we need to
    put values inside square brackets. It would look like:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，首先。在Python中，数组不被称为数组，而是被称为**列表**。列表基本上是一种可以同时存储多个元素的数据结构。唯一的限制是元素必须是相同的数据类型。比如，如果你存储整数，那么所有的值都应该是`int`。同样，如果你存储一个字符，那么列表的每个元素都应该是`char`。要定义一个列表，你所需要做的就是给列表命名，比如我们通过`myList`所做的那样；列表的名称可以是任何东西，接下来我们需要告诉编译器它实际上是一个列表。为了做到这一点，我们需要将值放在方括号内。它看起来像这样：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'One thing to keep in mind is that every value should be separated with commas. Whenever
    we want to address any single element of the list, we can simply use it by calling
    their index number. This is based on the position of the element in the list.
    The index value in Python list starts from 0\. So as per the preceding declaration
    at the index 0, the value would be `14`, and at the address 4, the value would
    be `9`. Now when we need to print these elements in between our program, we need
    to write the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一件事是，每个值都应该用逗号分隔。每当我们想要访问列表的任何单个元素时，我们可以通过调用它们的索引号来简单地使用它们。这是基于元素在列表中的位置。Python列表中的索引值从0开始。所以根据前面的声明，在索引0处，值将是`14`，在地址4处，值将是`9`。现在，当我们需要在程序中间打印这些元素时，我们需要写下以下代码：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once we write this, the program will print the value of the second value in
    the list. In our case, it would be `35`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们写了这个，程序将打印列表中第二个值的值。在我们的例子中，它将是`35`。
- en: 'Now, this is one way to access the elements of the list; we can however access
    it in reverse order as well. So, let''s say you want to access the last item of
    the array. Then, we can write the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是访问列表元素的一种方式；我们也可以以相反的顺序访问它。所以，假设你想访问数组的最后一个项目。然后，我们可以编写以下代码：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code will return the value of the last element of the array. Now whenever
    we use the negative values in the lists, then it would start the indexing in the
    reverse order. So, let's say if we type in `print myList[-2]`, this will give
    us the value of the second last value in the array. One thing to remember in this
    whole schematic is that the numbering would start from 0, whereas when we start
    it in the reverse order, then the numbering would start from -1.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将返回数组的最后一个元素的值。现在，每当我们在列表中使用负值时，它将以相反的顺序开始索引。所以，假设我们输入`print myList[-2]`，这将给我们数组中倒数第二个值的值。在整个方案中需要记住的一件事是，编号将从0开始，而当我们以相反的顺序开始时，编号将从-1开始。
- en: Python is really interesting and quite simple if you know the right tools. The
    developers of Python have included some really helpful functions that can be used
    over lists. So, let's go and explore them a bit.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Python真的很有趣，如果你知道正确的工具，它也很简单。Python的开发人员包含了一些非常有用的函数，可以在列表上使用。所以，让我们去探索一下它们。
- en: 'The first one is to add elements to the array. For this, we use a function
    named `append()`. What the `append()` function does is that it adds the value,
    which would want at the end of the array. So, write the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是向数组添加元素。为此，我们使用一个名为`append()`的函数。`append()`函数的作用是在数组的末尾添加你想要的值。所以，写下以下内容：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What this would do is that it would add the element `45` at the end of `myList`.
    So now the list would be as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的效果是在`myList`的末尾添加元素`45`。所以现在列表将如下所示：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Easy, isn''t it ? But what if you want to add an element in between the list?
    Obviously, the developer won''t leave you dry. They have included a function for
    that as well; it''s named `insert(index, element)`. Now whenever you are using
    this function, you need to make sure that you mention the index where you want
    this element to be and second, the element that you want to put. So it looks something
    like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 简单，不是吗？但是如果你想在列表中间添加一个元素怎么办？显然，开发人员不会让你措手不及。他们也包含了一个名为`insert(index, element)`的函数；现在每当你使用这个函数时，你需要确保提到你想要这个元素的索引位置，其次是你想要放置的元素。所以它看起来像这样：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When you have used this function, the array will look as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用这个函数时，数组将如下所示：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Obviously, whenever the developer has given the function to add an element,
    then they would have certainly given a function to remove the elements as well.
    But the trick is that you can do it two ways. First, the common way. We simply
    select the index number and delete it. We are going to do it now:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当开发人员给出添加元素的功能时，他们肯定也会给出删除元素的功能。但诀窍在于你可以用两种方法做到这一点。首先，是常见的方法。我们只需选择索引号并删除它。我们现在要做的就是这样：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now what this will do is that it would delete the second element of the array,
    so after doing this operation, the array will look like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这样做的效果是删除数组的第二个元素，所以在执行此操作后，数组将如下所示：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'But now here comes the real trick; you can also delete the element by simply
    specifying the element. This is how it''s done:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在真正的技巧来了；你也可以通过简单地指定元素来删除元素。就是这样做的：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now the moment you do this, it will find wherever the element `9` is in your
    list and delete it from the positions. So you don't have to care about where the
    element is; this function will say, I will find you and I will kill you!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你这样做了，它会找到列表中元素`9`的位置并将其从中删除。所以你不必关心元素在哪里；这个函数会说，我会找到你并杀死你！
- en: Looking around
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 四处张望
- en: Okay then enough of movie quotes. We can talk about many other functions that
    we can use over lists, but what we have done is enough for now. We will see the
    rest of them as the need arise. But for now let's take the things a step further
    in robotics. You might have seen a rotating object on top of many autonomous cars.
    The production cars generally don't tend to have primarily due to its high price,
    but research purpose cars are always loaded with it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，够了电影台词。我们可以讨论我们可以在列表上使用的许多其他功能，但我们现在所做的已经足够了。我们将根据需要看到其余的功能。但现在让我们在机器人技术上迈出一步。你可能已经在许多自动驾驶汽车的顶部看到旋转的物体。生产车辆通常不会有这种装置，主要是因为价格昂贵，但研究用途的车辆总是装备有它。
- en: So what is this device? It's named **LIDAR**; it is an acronym for **Light Detection
    and Ranging**. I know bad acronym. There is a reason for LIDAR to be very common.
    It gives distance reading of the areas around it in a very precise way. However,
    buying it for our projects would slightly overkill as a good one would cost you
    close $500 to $10,000\. If you still think that it's in your budget, then you
    would be very lucky! But for those who don't want to buy it. I have a good news
    for you. Today, we are going to build our own LIDAR scanner. So to make an area
    scanner, we need a servo over which we will mount our IR proximity sensor. Now
    to do this, we would need a slight makeshift arrangement. You can take a cardboard
    and fix it like we have done in the picture here, or otherwise, you can also use
    a right-angled aluminum and drill it to fix the components if you want it to do
    the pro way. The one thing to remember that the sensor must be facing exactly
    parallel to the ground and not up or down.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这个装置是什么？它被称为**激光雷达**；这是**光探测和测距**的缩写。我知道这是个糟糕的缩写。激光雷达之所以如此普遍，是有原因的。它以非常精确的方式给出了周围区域的距离读数。然而，为我们的项目购买它可能有点杀鸡用牛刀，因为一个好的激光雷达可能会花费你接近500到10,000美元。如果你仍然认为这在你的预算范围内，那么你会非常幸运！但对于那些不想购买它的人，我有一个好消息。今天，我们将建立我们自己的激光雷达扫描仪。因此，为了制作一个区域扫描仪，我们需要一个伺服电机，我们将在其上安装我们的红外近距传感器。现在要做到这一点，我们需要一个轻微的临时安排。你可以拿一块硬纸板，像我们在这里的图片中所做的那样固定它，或者你也可以使用一个直角铝材并钻孔来固定组件，如果你想要以专业的方式来做。要记住的一件事是，传感器必须正好平行于地面，而不是向上或向下。
- en: 'Once the mounting is done, then it''s time to connect the rest of the hardware.
    So go ahead and connect the hardware, as shown in the following diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，就是连接其余的硬件的时候了。所以继续连接硬件，如下图所示：
- en: '![](Images/100d1350-9710-4ddf-910a-13518c62bf16.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/100d1350-9710-4ddf-910a-13518c62bf16.png)'
- en: 'OK, so let''s see what this thing can do, so get ready and upload this code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们看看这个东西能做什么，准备好，上传这段代码：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What did the code do? If it ran fine, then it should return you the scanned
    readings entire 180 degree broken down into 10 even steps. Go ahead—try it out
    and then return to see what actually is happening.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 代码做了什么？如果它正常运行，那么它应该将整个180度的扫描读数分成10个均匀的步骤返回给你。继续——试一试，然后返回看看实际发生了什么。
- en: 'Now most of the code is elementary, and you must have also got an idea of what
    this code is actually doing. However, let''s get deeper into it and see the specifics:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大部分代码都是基础的，你可能也已经对这段代码实际在做什么有了一个概念。然而，让我们深入了解一下，看看具体情况：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this part of the program, we have defined a function named `Distance()`.
    As you can see, it is simply getting the reading from the ADC in the step `D_value
    = adc0.get_last_result()`; thereafter, this is the value procured that is stored
    in a variable `D` is then computed in the line `D = (1.0/F-value/13.15)) - 0.35`
    to get the metric reading from the ADC reading. Finally, using the line `Return
    D`, we are returning the value `D` from the function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的这一部分，我们定义了一个名为`Distance()`的函数。你可以看到，它只是从ADC中获取读数在步骤`D_value = adc0.get_last_result()`；然后，存储在变量`D`中的值在行`D
    = (1.0/F-value/13.15)) - 0.35`中计算，以获取ADC读数的度量读数。最后，使用行`Return D`，我们从函数中返回值`D`：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have declared two lists: `distLR`, namely for distance for left to right
    swipe of the servo and `distRL` for the distance received in right to left swipe
    of the servo. You might be wondering how is it that there is nothing inside these
    brackets. It is completely normal to have an empty array declared. There is no
    need for them to have value initially:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了两个列表：`distLR`，用于伺服从左到右扫描的距离，`distRL`用于伺服从右到左扫描的距离。你可能会想这些括号里面为什么什么都没有。声明一个空数组是完全正常的。它们最初没有必要有值：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now this is where the real action is happening. The `while` loop will be executed
    only till the time the value of `k` is less than or equal to `12.5`. In the next
    line `servo.ChangeDutyCycle(k)`, the value of the duty cycle will be whatever
    the value of `k` would be. Initially, the value of `k` would be `2.5` as we have
    already defined in the beginning of the program. Now we add another line `time
    sleep(.1)`, which will make the program halt for `.1` second. This is necessary;
    otherwise, the program would parse through this loop within milliseconds and the
    servo would not be able to cope up with it. Hence, this is a short delay. In the
    next line, we have `distLR.insert(I,Distance())`. This line of program is doing
    a lot of things. First, as we have named a `Distance()` function inside this line.
    As we defined, it would calculate the distance using the ADC and the IR proximity
    sensor. Thereafter, it would insert that distance value inside an the list `distLR`
    at the position `I`. Previously in our program, we have already assigned the value `i
    = 0`; hence, the distance value would be put up in the first position in the array.
    Once this entire process is done, then we move forward and increment the value
    by one in this line `k = k + 1`; thereafter, we do the same thing in `I = I +
    1`. Now finally, once this loop''s executed, the values of the list is printed
    using the line `print distLR`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这就是真正的行动发生的地方。`while`循环只会在`k`的值小于或等于`12.5`的时候执行。在接下来的一行中，`servo.ChangeDutyCycle(k)`，占空比的值将是`k`的值。最初，`k`的值将是`2.5`，因为我们已经在程序的开头定义了。现在我们添加另一行`time
    sleep(.1)`，这将使程序暂停`.1`秒。这是必要的；否则，程序会在毫秒内解析完这个循环，舵机将无法跟上。因此，这是一个短暂的延迟。在接下来的一行中，我们有`distLR.insert(I,Distance())`。这行程序做了很多事情。首先，我们在这一行内命名了一个`Distance()`函数。正如我们定义的那样，它将使用ADC和红外接近传感器来计算距离。然后，它会将该距离值插入到列表`distLR`的位置`I`。在我们的程序中，我们之前已经赋值了`i
    = 0`的值；因此，距离值将被放在数组中的第一个位置。一旦整个过程完成，然后我们继续向前移动，并在这一行中将值增加一，`k = k + 1`；然后，我们在`I
    = I + 1`中做同样的事情。现在最后，一旦这个循环执行完毕，列表的值将使用`print distLR`打印出来：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this line, we are simply resetting the values of `i = 0` and `k = 0` for
    the next loop:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行中，我们只是为下一个循环重置`i = 0`和`k = 0`的值：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This may be slightly new for you.  Whenever we use a colon inside a bracket,
    that basically means that the entire elements of the array would be deleted:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你来说可能有点新。每当我们在括号内使用冒号时，基本上意味着整个数组的元素将被删除：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this code, the same thing is happening that we did for the left to right
    swipe; the only difference being is that we are saving it a new list named `distRL`,
    and the swipe starts from 12.5% duty cycle and ends at 2.5%:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，发生的事情与我们对左到右滑动所做的事情相同；唯一的区别是我们将它保存在一个名为`distRL`的新列表中，并且滑动从12.5%的占空比开始，结束于2.5%：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we have printed all the values, we again reset the values of `i = 1`, `k
    = 2.5`, and `j = 12.5` so that our first loop can start seamlessly further to
    it we are also making sure that there is nothing left inside the list `distRL`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印出所有的值后，我们再次重置`i = 1`，`k = 2.5`和`j = 12.5`的值，以便我们的第一个循环可以无缝地开始，此外，我们还确保列表`distRL`中没有剩下任何东西。
- en: So this is how our code was working, straight and simple!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的代码是如何工作的，直截了当！
- en: LIDAR on an autonomous vehicle
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动驾驶汽车上的激光雷达
- en: Remember the last time we made autonomous car. It was cool, and surely it might
    be something you can show off to your friends. However, now what we are about
    to make is surely cooler than anything we have ever done till now.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得上次我们制作自动驾驶汽车吗？很酷，当然，这可能是你可以向朋友炫耀的东西。然而，现在我们要做的肯定比我们迄今为止所做的任何事情都要酷。
- en: We are going to put this area scanner over our robotic vehicle. But wait, didn't
    we scan the area earlier using the same sensor and turning the car to other sides.
    We did it and it worked fine, almost fine. I bet sometimes it wasn't as accurate
    as you thought it would be. But that's not the real problem. The main problem
    is that it was not seamless. It has to stop in between check for spaces and then
    move in either direction. What we are going to do now is something that is a step
    ahead. So before doing any more explanation, let's go ahead and make this new
    robotic vehicle and then you be the judge to decide whether it is cooler.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个区域扫描仪放在我们的机器人车上。但等等，我们之前使用相同的传感器扫描过这个区域，把车转向其他方向。我们做到了，而且效果还不错，几乎不错。我敢打赌，有时它的准确性并不像你想象的那样。但这不是真正的问题。主要问题是它不是无缝的。它必须在中间停下来检查空间，然后向任一方向移动。我们现在要做的是更进一步的事情。所以在做任何更多的解释之前，让我们继续制作这辆新的机器人车，然后你来判断它是否更酷。
- en: 'So, to make it, you need to mount the area scanner on the vehicle. It''s advisable
    that you set it up at the frontend of the vehicle and make sure that the arm of
    the servo is able to rotate 180 degrees. You can use the similar method that we
    did to fix the IR sensor on top of the servo. While you are doing all of this,
    try using cable ties to make sure the cables are not messy and also make sure
    to leave some slack for the movement of the shaft and the sensor on top of it.
    These cable ties can make your life really simple. Once we are all set up, you
    should connect the IR proximity using an ADS1115 to the Raspberry Pi and then
    connect the motor driver, as shown in the following diagram:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了制作它，你需要将区域扫描仪安装在车辆上。建议你将其设置在车辆的前端，并确保舵机的臂能够旋转180度。你可以使用我们用来固定红外传感器在舵机顶部的类似方法。在做所有这些的时候，尝试使用电缆束带来确保电缆不凌乱，并确保为轴和顶部的传感器的移动留出一些松弛。这些电缆束带可以让你的生活变得非常简单。一旦我们都准备好了，你应该将红外接近传感器使用ADS1115连接到树莓派，然后连接电机驱动器，如下图所示：
- en: '![](Images/6dcbf2c2-2bde-4c2f-a9a9-c7a48760fd99.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6dcbf2c2-2bde-4c2f-a9a9-c7a48760fd99.png)'
- en: 'Once we are done go ahead and upload the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，继续上传以下代码：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Phew! That was long wasn''t it? But trust me it might be long, but not tough.
    So let''s see what this code is doing:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！那是很长，不是吗？但相信我，可能很长，但不难。所以让我们看看这段代码在做什么：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This stuff might look pretty new to you. Though it isn't. What we are doing
    is that we are defining which pin number will be operating at what PWM frequency.
    Also, we have named every GPIO pins that is being used for motor control. OK then,
    it is fine that we are doing all this, but why have we suddenly started to give
    PWM to motor drivers. Were we not happy giving a simple high pulse?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些东西可能对你来说看起来很新。但其实并不是。我们正在定义哪个引脚号将以什么PWM频率运行。此外，我们已经为用于电机控制的每个GPIO引脚命名。好吧，我们做所有这些都没问题，但为什么我们突然开始给电机驱动器提供PWM。我们不是很满意给一个简单的高脉冲吗？
- en: 'The answer is very straightforward. With the use of PWM, we were able to change
    the brightness of an LED in previous chapters. Similarly, by changing the PWM
    output to the control pins of the motor driver, you cannot only define which direction
    to spin in. But also the speed at which it can spin. This is all done with PWM.
    So let''s say pin number `20` is getting a PWM at 50% duty cycle. So it basically
    means that the motor which is attached to it will get half the input voltage that
    the motor driver is receiving. So now we can not only control which direction
    we want the motor to spin but also at what speed we can do so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 答案非常直接。通过使用PWM，我们能够在之前的章节中改变LED的亮度。同样，通过改变PWM输出到电机驱动器的控制引脚，你不仅可以定义旋转的方向，还可以定义旋转的速度。这一切都是通过PWM完成的。所以假设引脚号`20`正在以50%的占空比获得PWM。这基本上意味着连接到它的电机将获得电机驱动器接收到的输入电压的一半。所以现在我们不仅可以控制电机旋转的方向，还可以控制旋转的速度：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this statement, we have defined a function `direction(index)`. What this
    does is that it compares the value of index and based on it. The power will be
    given to the motors. So lets say that the index is 0\. In this case the wheel
    on the left side would move in reverse direction whereas the right wheel would
    move in the reverse direction this will turn the robot on its axis.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语句中，我们定义了一个`direction(index)`函数。它的作用是比较索引的值，并根据它给予电机动力。所以假设索引是0。在这种情况下，左侧的车轮将向相反方向移动，而右侧的车轮将向相反方向移动，这将使机器人绕着轴旋转。
- en: 'In the next statement, we have written an `elif` statement, so if the `else` statement
    is not true, then it will check for the rest `else if` statement in the body.
    There are four `elif` statements in the entire definition of `direction(index)`,
    which basically means that it will check for each one of it and do either of the
    activities based on the value of the argument. In this case, it is the index.
    Further, there is a final `else` statement, which would be done if none of the
    cases are true. So according to the statement, it will call a function of stop.
    That would stop the vehicle:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一条语句中，我们写了一个`elif`语句，所以如果`else`语句不成立，它将检查主体中的其余`elif`语句。在`direction(index)`的整个定义中有四个`elif`语句，这基本上意味着它将检查每一个并根据参数的值执行其中之一的活动。在这种情况下，它是索引。此外，还有一个最终的`else`语句，如果没有一个情况成立，它将调用一个停止的函数。这将停止车辆：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This line is pretty interesting as we are using another fun part of the lists
    that we have used. So, with the `max()` method, we can find the largest value
    inside a list. So, in this line, we are simply finding the max value and putting
    it in a variable named `max_dist1`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行非常有趣，因为我们正在使用我们已经使用过的列表的另一个有趣部分。因此，通过`max()`方法，我们可以找到列表中的最大值。因此，在这一行中，我们只是找到最大值并将其放入一个名为`max_dist1`的变量中：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The beauty of lists just doesn''t seem to end. In this line, we are using another
    method named `index()`; this method gives us the index of the value inside the
    list. So, we can know where the value exists in the list. Hence, in this line,
    we are proving the value of `max_dist1`. The method `index()` searches the index
    number and stores that value down into a variable named `max_dist1_index`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的美妙似乎没有尽头。在这一行中，我们正在使用另一种名为`index()`的方法；这种方法给出了列表中数值的索引。因此，我们可以知道数值在列表中的位置。因此，在这一行中，我们正在证明`max_dist1`的值。`index()`方法搜索索引号，并将该值存储在一个名为`max_dist1_index`的变量中：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we have already defined the function `Direction()`, now all we are doing
    is calling the function to decide which direction to go in. Prefect then, power
    up your vehicles and see how well they are driving and do not forget to shoot
    a video and post it online.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经定义了`Direction()`函数，现在我们所做的就是调用函数来决定前进的方向。那么，给你的车辆加油，看看它们驾驶得如何，不要忘记拍摄视频并在网上发布。
- en: Have fun!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 玩得开心！
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Professional laser scanners are super expensive, so, in this chapter, we went
    on to build an alternative by ourselves and mounted it on our vehicle. In the
    next chapter, we will cover topics such as vision processing, and object detection,
    object tracking, which will enable us to do basic vision processing and to make
    the car move in the direction of a specific object such as a ball.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 专业激光扫描仪非常昂贵，因此在本章中，我们自己制作了一种替代品，并将其安装在我们的车辆上。在下一章中，我们将涵盖诸如视觉处理、物体检测、物体跟踪等主题，这将使我们能够进行基本的视觉处理，并使汽车朝着特定物体（如球）的方向移动。
