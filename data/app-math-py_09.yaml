- en: Finding Optimal Solutions
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找最优解
- en: In this chapter, we'll address various methods for finding the best outcome
    in a given situation. This is called*optimization*and usually involves either
    minimizing or maximizing an objective function. An *objective function* is a function
    that takes a number of parameters as arguments and returns a single scalar value
    that represents the cost or payoff for a given choice of parameters. The problems
    regarding minimizing and maximizing functions are actually equivalent to one another,
    so we'll only discuss minimizing object functions in this chapter. Minimizing
    a function, *f*(*x*), is equivalent to maximizing the function *-f*(*x*). More
    details on this will be provided when we discuss the first recipe.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论寻找给定情况下最佳结果的各种方法。这被称为*优化*，通常涉及最小化或最大化目标函数。*目标函数*是一个接受多个参数作为参数并返回代表给定参数选择的成本或回报的单个标量值的函数。关于最小化和最大化函数的问题实际上是相互等价的，因此我们只会在本章讨论最小化目标函数。最小化函数*f*(*x*)等同于最大化函数*-f*(*x*)。在我们讨论第一个配方时将提供更多细节。
- en: The algorithms available to us for minimizing a given function depend on the
    nature of the function. For instance, a simple linear function containing one
    or more variables has different algorithms available compared to a non-linear
    function with many variables. The minimization of linear functions falls within
    the category of *linear programming*, which is a well-developed theory. For non-linear
    functions, we usually make use of the gradient (derivative) of a function in order
    to find the minimum points. We will discuss several methods for minimizing various
    functions of different types.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用的算法来最小化给定函数取决于函数的性质。例如，包含一个或多个变量的简单线性函数与具有许多变量的非线性函数相比，可用的算法不同。线性函数的最小化属于*线性规划*范畴，这是一个发展完善的理论。对于非线性函数，我们通常利用函数的梯度（导数）来寻找最小点。我们将讨论几种不同类型函数的最小化方法。
- en: Finding the minima and maxima of the functions of a single variable is especially
    simple, and can be done easily if the derivatives of the function are known. If
    not, then the method described in the appropriate recipe will be applicable. The
    notes in the *Minimizing a non-linear function* recipe give some extra details
    about this.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找单变量函数的极小值和极大值特别简单，如果函数的导数已知，可以轻松完成。如果不知道导数，则适用于适当配方的方法。*最小化非线性函数*配方中的注释提供了一些额外细节。
- en: We'll also provide a very short introduction to *game theory*. Broadly speaking,
    this is a theory surrounding decision-making and has wide-ranging implications
    in subjects such as economics. In particular, we'll discuss how to represent simple
    two-player games as objects in Python, compute payoffs associated with certain
    choices, and compute Nash equilibria for these games.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将提供一个非常简短的介绍*博弈论*。广义上讲，这是一个围绕决策制定的理论，并在经济学等学科中具有广泛的影响。特别是，我们将讨论如何在Python中将简单的双人游戏表示为对象，计算与某些选择相关的回报，并计算这些游戏的纳什均衡。
- en: We will start by looking at how to minimize linear and non-linear functions
    containing one or more variables. Then, we'll move on and look at gradient descent
    methods and curve fitting using least squares. We'll conclude this chapter by
    analyzing two-player games and Nash equilibria.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看如何最小化包含一个或多个变量的线性和非线性函数。然后，我们将继续研究梯度下降方法和使用最小二乘法进行曲线拟合。最后，我们将通过分析双人游戏和纳什均衡来结束本章。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Minimizing a simple linear function
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化简单线性函数
- en: Minimizing a non-linear function
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化非线性函数
- en: Using gradient descent methods in optimization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用梯度下降法进行优化
- en: Using least squares to fit a curve to data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最小二乘法拟合数据的曲线
- en: Analyzing simple two-player games
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析简单的双人游戏
- en: Computing Nash equilibria
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算纳什均衡
- en: Let's get started!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will need the NumPy package, the SciPy package, and the
    Matplotlib package, as usual. We will also need the Nashpy package for the final
    two recipes. These packages can be installed using your favorite package manager,
    such as `pip`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将像往常一样需要NumPy包、SciPy包和Matplotlib包。我们还将需要Nashpy包用于最后两个配方。这些包可以使用您喜欢的包管理器（如`pip`）进行安装：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code for this chapter can be found in the `Chapter 09` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2009](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2009).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub存储库的`Chapter 09`文件夹中找到，网址为[https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2009](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2009)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2BjzwGo](https://bit.ly/2BjzwGo).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[https://bit.ly/2BjzwGo](https://bit.ly/2BjzwGo)。
- en: Minimizing a simple linear function
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化简单线性函数
- en: 'The most basic type of problem we face in optimization is finding the parameters
    where a function takes its minimum value. Usually, this problem is *constrained*
    by some bounds on the possible values of the parameters, which increases the complexity
    of the problem. Obviously, the complexity of this problem increases further if
    the function that we are minimizing is also complex. For this reason, we must
    first consider *linear functions*, which are in the following form:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化中我们面临的最基本问题是找到函数取得最小值的参数。通常，这个问题受到参数可能值的一些限制的*约束*，这增加了问题的复杂性。显然，如果我们要最小化的函数也很复杂，那么这个问题的复杂性会进一步增加。因此，我们必须首先考虑*线性函数*，它们的形式如下：
- en: '![](assets/81d86696-3f59-4c53-9c0b-7610003405b0.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/81d86696-3f59-4c53-9c0b-7610003405b0.png)'
- en: To solve these kinds of problems, we need to convert the constraints into a
    form that can be used by the computer. In this case, we usually convert them into
    a linear algebra problem (matrices and vectors). Once this is done, we can use
    the tools from the linear algebra packages in NumPy and SciPy to find the parameters
    we seek. Fortunately, since these kinds of problems occur quite frequently, SciPy
    has routines that handle this conversion and subsequent solving.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，我们需要将约束转化为计算机可用的形式。在这种情况下，我们通常将它们转化为线性代数问题（矩阵和向量）。一旦完成了这一步，我们就可以使用NumPy和SciPy中的线性代数包中的工具来找到我们所寻求的参数。幸运的是，由于这类问题经常发生，SciPy有处理这种转化和随后求解的例程。
- en: 'In this recipe, we''ll solve the following constrained linear minimization
    problem using routines from the SciPy `optimize` module:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用SciPy `optimize`模块的例程来解决以下受限线性最小化问题：
- en: '![](assets/bf60d0a9-bda0-4b13-b5b8-a21a96bfe9b0.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bf60d0a9-bda0-4b13-b5b8-a21a96bfe9b0.png)'
- en: 'This will be subject to the following conditions:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将受到以下条件的约束：
- en: '![](assets/06c40ed3-2f7d-48d6-8d32-53756bc49383.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/06c40ed3-2f7d-48d6-8d32-53756bc49383.png)'
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we need to import the NumPy package under the alias `np`,
    the Matplotlib `pyplot` module under the name `plt`, and the SciPy `optimize`
    module. We also need to import the `Axes3D` class from `mpl_toolkits.mplot3d`
    to make 3D plotting available:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要在别名`np`下导入NumPy包，以`plt`的名称导入Matplotlib `pyplot`模块，以及SciPy `optimize`模块。我们还需要从`mpl_toolkits.mplot3d`导入`Axes3D`类，以使3D绘图可用：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to solve a constrained linear minimization problem using
    SciPy:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用SciPy解决受限线性最小化问题：
- en: 'Set up the system in a form that SciPy can recognize:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将系统设置为SciPy可以识别的形式：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we need to define a routine that evaluates the linear function at a value
    of *x*, which is a vector (a NumPy array):'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一个评估线性函数在*x*值处的例程，这是一个向量（NumPy数组）：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we create a new figure and add a set of `3d` axes that we can plot the
    function on:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的图并添加一组`3d`轴，我们可以在上面绘制函数：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we create a grid of values covering the region from the problem and plot
    the value of the function over this region:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个覆盖问题区域的值网格，并在该区域上绘制函数的值：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we plot the line in the plane of function values that corresponds to the
    critical line, `2*x0 + x1 == 6`, and plot the values that fall within the range
    on top of our plot:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在函数值平面上绘制与临界线`2*x0 + x1 == 6`对应的线，并在我们的图上绘制落在范围内的值：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We repeat this plotting step for the second critical line, `x0 + x1 == -4`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重复这个绘图步骤，对第二条临界线`x0 + x1 == -4`：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we shade the region that lies within the two critical lines, which corresponds
    to the feasible region for the minimization problem:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们着色位于两条临界线之间的区域，这对应于最小化问题的可行区域：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The plot of the function values over the feasible region can be seen in the
    following image:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 函数值在可行区域上的图可以在以下图片中看到：
- en: '![](assets/e58a70ae-06b2-4718-892d-8dde0fa89bea.png)Figure 9.1: Values of the
    linear function with the feasible region highlighted'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/e58a70ae-06b2-4718-892d-8dde0fa89bea.png)图9.1：突出显示了可行区域的线性函数值'
- en: As we can see, the minimum value that lies within this shaded region occurs
    at the intersection of the two critical lines.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，位于这个着色区域内的最小值发生在两条临界线的交点处。
- en: 'Next, we use `linprog` to solve the constrained minimization problem with the
    bounds we created in *Step 1*. We print the resulting object in the terminal:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`linprog`来解决带有我们在*步骤1*中创建的边界的受限最小化问题。我们在终端中打印出结果对象：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we plot the minimum function value on top of the feasible region:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在可行区域上绘制最小函数值：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The updated plot can be seen in the following image:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的图可以在以下图片中看到：
- en: '![](assets/d18cd25f-8786-4d1e-a253-aebdc3d4bd92.png)Figure 9.2: Minimum value
    plotted on the feasible region'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/d18cd25f-8786-4d1e-a253-aebdc3d4bd92.png)图9.2：在可行区域上绘制的最小值'
- en: Here, we can see that the `linprog` routine has indeed found that the minimum
    is at the intersection of the two critical lines.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`linprog`例程确实发现了最小值在两条临界线的交点处。
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Constrained linear minimization problems are common in economic situations,
    where you try to minimize costs while maintaining other aspects of the parameters.
    In fact, a lot of the terminology from optimization theory mirrors this fact.
    A very simple algorithm for solving these kinds of problems is called the **simplex
    method**, which uses a sequence of array operations to find the minimal solution.
    Geometrically, these operations represent changing to different vertices of a
    simplex (which we won't define here), and it is this that gives the algorithm
    its name.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 受限线性最小化问题在经济情况中很常见，您尝试在保持参数的其他方面的同时最小化成本。实际上，优化理论中的许多术语都反映了这一事实。解决这些问题的一个非常简单的算法称为**单纯形法**，它使用一系列数组操作来找到最小解。从几何上讲，这些操作代表着改变单纯形的不同顶点（我们在这里不定义），正是这一点赋予了算法其名称。
- en: 'Before we continue, we''ll provide a brief outline of the process used by the
    simplex method to solve a constrained linear optimization problem. The problem,
    as presented to us, is not a matrix equation problem but a matrix inequality problem.
    We can remedy this problem by introducing **slack variables**, which turn an inequality
    into an equality. For example, the first constraint inequality can be rewritten
    as follows by introducing the slack variable, *s[1]*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们将简要概述单纯形法用于解决受限线性优化问题的过程。我们所面临的问题不是一个矩阵方程问题，而是一个矩阵不等式问题。我们可以通过引入**松弛变量**来解决这个问题，将不等式转化为等式。例如，通过引入松弛变量*s[1]*，可以将第一个约束不等式重写如下：
- en: '![](assets/7d8c2f37-dc9d-4c8c-8718-96a71e709d6f.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7d8c2f37-dc9d-4c8c-8718-96a71e709d6f.png)'
- en: 'This satisfies the desired inequality, provided that *s[1]* is not negative.
    The second constraint inequality is a greater than or equal to type inequality
    that we must first change so that it''s of the less than or equal to type. We
    do this by multiplying all terms by -1\. This gives us the second row of matrix
    `A` that we defined in the recipe. After introducing a second slack variable,
    *s[2]*, we get the second equation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 只要*s[1]*不是负数，这就满足了所需的不等式。第二个约束不等式是大于或等于类型的不等式，我们必须首先将其更改为小于或等于类型。我们通过将所有项乘以-1来实现这一点。这给了我们在配方中定义的矩阵`A`的第二行。引入第二个松弛变量*s[2]*后，我们得到了第二个方程：
- en: '![](assets/6aa8a05b-274f-4d44-9eac-9101a8a40105.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6aa8a05b-274f-4d44-9eac-9101a8a40105.png)'
- en: From this, we can construct a matrix whose columns contain the coefficients
    of the two parameter variables, *x[1]* and *x[2,]* and the two slack variables,
    *s[1]* and *s[2.]* The rows of this matrix represent the two bounding equations
    and the objective function*.* This system of equations can now be solved, using
    elementary row operations on this matrix, to obtain the values of*x[1]* and *x[2]*,
    which minimize the objective function. Since solving matrix equations is easy
    and fast, this means that we can minimize linear functions quickly and efficiently.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从中，我们可以构建一个矩阵，其列包含两个参数变量*x[1]*和*x[2]*以及两个松弛变量*s[1]*和*s[2]*的系数。该矩阵的行代表两个边界方程和目标函数。现在可以使用对该矩阵进行初等行操作来解决这个方程组，以获得最小化目标函数的*x[1]*和*x[2]*的值。由于解决矩阵方程很容易且快速，这意味着我们可以快速高效地最小化线性函数。
- en: Fortunately, we don't need to remember how to reduce our system of inequalities
    into a system of linear equations since routines such as `linprog` do this for
    us. We can simply provide the bounding inequalities as a matrix and vector pair,
    consisting of the coefficients of each, and a separate vector that defines the
    objective function. The `linprog` routine takes care of formulating and then solving
    the minimization problem.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要记住如何将不等式系统化简为线性方程组，因为诸如`linprog`之类的例程会为我们完成这一工作。我们只需将边界不等式提供为矩阵和向量对，包括每个系数，以及定义目标函数的单独向量。`linprog`例程负责制定和解决最小化问题。
- en: In practice, the simplex method is not the algorithm used by the `linprog` routine
    to minimize the function. Instead, `linprog` uses an interior point algorithm,
    which is more efficient. (The method can actually be set to `simplex` or `revised-simplex`
    by providing the `method` keyword argument with the appropriate method name. In
    the printed resulting output, we can see that it only took five iterations to
    reach the solution.) The resulting object that is returned by this routine contains
    the parameter values at which the minimum occurs stored in the `x` attribute,
    the value of the function at this minimum value stored in the `fun` attribute,
    and various other pieces of information about the solving process. If the method
    had failed, then the `status` attribute would have contained a numerical code
    that described why the method failed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，单纯形法并不是`linprog`例程用于最小化函数的算法。相反，`linprog`使用内点算法，这更有效率。（可以通过提供`method`关键字参数并使用适当的方法名称将方法设置为`simplex`或`revised-simplex`。在打印的输出结果中，我们可以看到只用了五次迭代就达到了解决方案。）该例程返回的结果对象包含最小值发生的参数值存储在`x`属性中，该最小值存储在`fun`属性中，以及有关解决过程的各种其他信息。如果方法失败，那么`status`属性将包含一个数值代码，描述方法失败的原因。
- en: In *step 2* of this recipe, we created a function that represents the objective
    function for this problem. This function takes a single array as input, which
    contains the parameter space values at which the function should be evaluated.
    Here, we used the `tensordot` routine (with `axes=1`) from NumPy to evaluate the
    dot product of the coefficient vector, *c*, with each input, *x*. We have to be
    quite careful here since the values that we pass into the function will be a 2
    × 50 × 50 array in a later step. The ordinary matrix multiplication (`np.dot`)
    would not give the 50 × 50 array output that we desire in this case.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本文的*步骤2*中，我们创建了一个代表此问题的目标函数的函数。该函数以单个数组作为输入，该数组包含应在其上评估函数的参数空间值。在这里，我们使用了NumPy的`tensordot`例程（带有`axes=1`）来评估系数向量*c*与每个输入*x*的点积。在这里我们必须非常小心，因为我们传递给函数的值在后续步骤中将是一个2×50×50的数组。普通的矩阵乘法（`np.dot`）在这种情况下不会给出我们所期望的50×50数组输出。
- en: 'In *steps 5* and *6*, we computed the points on the critical lines as those
    points with the following equation:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*和*6*中，我们计算了临界线上的点，这些点具有以下方程：
- en: '![](assets/112c73bc-cd66-44aa-941c-c2d03e5f4bbc.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/112c73bc-cd66-44aa-941c-c2d03e5f4bbc.png)'
- en: We then computed the corresponding *z* values so that we could plot the lines
    that lie on the plane defined by the objective function. We also need to "trim"
    the values so that we only include those that lie in the range specified in the
    problem.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们计算了相应的*z*值，以便绘制在由目标函数定义的平面上的线。我们还需要“修剪”这些值，以便只包括在问题中指定范围内的值。
- en: There's more...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This recipe covered the constrained minimization problem and how to solve it
    using SciPy. However, the same method can be used to solve the constrained *maximization*
    problem. This is because maximization and minimization are *dual* to one another
    in the sense that maximizing a function, *f*(*x*), is the same as minimizing the
    function *-f*(*x*), and then taking the negative of this value. In fact, we used
    this fact in this recipe to change the second constraining inequality from ≥ to
    ≤.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本文介绍了受约束的最小化问题以及如何使用SciPy解决它。然而，相同的方法也可以用于解决受约束的*最大化*问题。这是因为最大化和最小化在某种意义上是*对偶*的，即最大化函数*f*(*x*)等同于最小化函数*-f*(*x*)，然后取其负值。事实上，我们在本文中使用了这一事实，将第二个约束不等式从≥改为≤。
- en: In this recipe, we solved a problem with only two parameter variables, but the
    same method will work (except for the plotting steps) for a problem involving
    more than two such variables. We just need to add more rows and columns to each
    of the arrays to account for this increased number of variables – this includes
    the tuple of bounds supplied to the routine. The routine can also be used with
    sparse matrices, where appropriate, for extra efficiency when dealing with very
    large amounts of variables.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们解决了一个只有两个参数变量的问题，但是相同的方法将适用于涉及两个以上这样的变量的问题（除了绘图步骤）。我们只需要向每个数组添加更多的行和列，以考虑这增加的变量数量
    - 这包括提供给例程的边界元组。在处理非常大量的变量时，例程也可以与稀疏矩阵一起使用，以获得额外的效率。
- en: The `linprog` routine gets its name from *linear programming*, which is used
    to describe problems of this type – finding values of *x* that satisfy some matrix
    inequalities subject to other conditions. Since there is a very close connection
    to the theory of matrices and linear algebra, there are many very fast and efficient
    techniques available for linear programming problems that are not available in
    a non-linear context.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`linprog`例程的名称来自*线性规划*，用于描述这种类型的问题 - 找到满足一些矩阵不等式的*x*的值，受其他条件的限制。由于与矩阵理论和线性代数的理论有非常紧密的联系，因此在线性规划问题中有许多非常快速和高效的技术，这些技术在非线性情境中是不可用的。'
- en: Minimizing a non-linear function
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化非线性函数
- en: In the previous recipe, we saw how to minimize a very simple linear function.
    Unfortunately, most functions are not linear and usually don't have nice properties
    that we would like. For these non-linear functions, we cannot use the fast algorithms
    that have been developed for linear problems, so we need to devise new methods
    that can be used in these more general cases. The algorithm that we will use there
    is called the Nelder-Mead algorthim, which is a robust and general-purpose method
    that's used to find the minimum value of a function and does not rely on the gradient
    of the function.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们看到了如何最小化一个非常简单的线性函数。不幸的是，大多数函数都不是线性的，通常也没有我们希望的良好性质。对于这些非线性函数，我们不能使用为线性问题开发的快速算法，因此我们需要设计可以在这些更一般情况下使用的新方法。我们将使用的算法称为Nelder-Mead算法，这是一种健壮且通用的方法，用于找到函数的最小值，并且不依赖于函数的梯度。
- en: In this recipe, we'll learn how to use the Nelder-Mead simplex method to minimize
    a non-linear function containing two variables.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用Nelder-Mead单纯形法来最小化包含两个变量的非线性函数。
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will use the NumPy package imported as `np`, the Matplotlib
    `pyplot` module imported as `plt`, the `Axes3D` class imported from `mpl_toolkits.mplot3d`
    to enable 3D plotting, and the SciPy `optimize` module:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用导入为`np`的NumPy包，导入为`plt`的Matplotlib `pyplot`模块，从`mpl_toolkits.mplot3d`导入的`Axes3D`类以启用3D绘图，以及SciPy
    `optimize`模块：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps show you how to use the Nelder-Mead simplex method to find
    the minimum of a general non-linear objective function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤向您展示如何使用Nelder-Mead单纯形法找到一般非线性目标函数的最小值：
- en: 'Define the objective function that we will minimize:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们将最小化的目标函数：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, create a grid of values that we can plot our objective function on:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个值网格，我们可以在上面绘制我们的目标函数：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we evaluate the function on this grid of points:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在这个点网格上评估函数：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we create a new figure with a `3d` axes object and set the axis labels
    and the title:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个带有`3d`轴对象的新图，并设置轴标签和标题：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can plot the objective function as a surface on the axes we just created:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们刚刚创建的轴上将目标函数绘制为表面：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We choose an initial point that our minimization routine will start its iteration
    at and plot this on the surface:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择一个初始点，我们的最小化例程将从该点开始迭代，并在表面上绘制这个点：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The plot of the objective function''s surface, along with the initial point,
    can be seen in the following image. Here, we can see that the minimum value appears
    to occur at around 0.5 on the x-axis and -0.5 on the y-axis:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下图像中看到目标函数表面的绘图，以及初始点。在这里，我们可以看到最小值似乎出现在x轴上约0.5，y轴上约-0.5的位置：
- en: '![](assets/5ab26e54-d0c2-4be6-a1e6-2f3e71f1a30e.png)Figure 9.3: Non-linear
    objective function with a starting value'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5ab26e54-d0c2-4be6-a1e6-2f3e71f1a30e.png)图9.3：具有起始值的非线性目标函数'
- en: 'Now, we use the `minimize` routine from the `optimize` package to find the
    minimum value and print the `result` object that it produces:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`optimize`包中的`minimize`例程来找到最小值，并打印它产生的`result`对象：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we plot the minimum value found by the `minimize` routine on top of
    the objective function surface:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在目标函数表面上绘制`minimize`例程找到的最小值：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The updated plot of the objective function, including the minimum point found
    by the `minimize` routine, can be seen in the following image:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 包括`minimize`例程找到的最小点的目标函数的更新绘图可以在以下图像中看到：
- en: '![](assets/5d9fcc80-cded-4642-a3b3-60f27b872b09.png)Figure 9.4: Objective function
    with a starting point and a minimum point'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5d9fcc80-cded-4642-a3b3-60f27b872b09.png)图9.4：具有起始点和最小点的目标函数'
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Nelder-Mead simplex method – not to be confused with the simplex method
    for linear optimization problems – is a simple algorithm for finding the minimum
    values of a non-linear function and works even when the objective function does
    not have a known derivative. (This is not the case for the function in this recipe;
    the only gains from using a gradient-based method is the speed of convergence.)
    The method works by comparing the values of the objective function at the vertices
    of a simplex, which is a triangle in a two-dimensional space. The vertex with
    the largest function value is "reflected" through the opposite edge and performs
    an appropriate expansion or contraction that, in effect, moves the simplex "downhill".
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Nelder-Mead单纯形法-不要与线性优化问题的单纯形法混淆-是一种简单的算法，用于找到非线性函数的最小值，即使目标函数没有已知的导数也可以工作。（这不适用于此示例中的函数；使用基于梯度的方法的唯一收益是收敛速度。）该方法通过比较单纯形的顶点处的目标函数值来工作，在二维空间中是一个三角形。具有最大函数值的顶点通过相反的边被“反射”，并执行适当的扩展或收缩，实际上将单纯形“下坡”移动。
- en: The `minimize` routine from the SciPy `optimize` module is an entry point for
    many non-linear function minimization algorithms. In this recipe, we used the
    Nelder-Mead simplex algorithm, but there are also a number of other algorithms
    available. Many of these algorithms require knowledge of the gradient of the function,
    which might be computed automatically by the algorithm. The algorithm can be used
    by providing the appropriate name to the `method` keyword argument.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy“optimize”模块中的“minimize”例程是许多非线性函数最小化算法的入口点。在这个示例中，我们使用了Nelder-Mead单纯形算法，但还有许多其他可用的算法。其中许多算法需要对函数的梯度有所了解，该梯度可能会被算法自动计算。可以通过向“method”关键字参数提供适当的名称来使用该算法。
- en: The `result` object that's returned by the `minimize` routine contains lots
    of information about the solution that has been found – or not found, if an error
    occurred – by the solver. In particular, the desired parameters that the calculated
    minimum occurs at is stored in the `x`attribute of the result, while the value
    of the function is stored in the `fun`attribute.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: “最小化”例程返回的“result”对象包含有关求解器找到的解决方案的大量信息-或者如果发生错误，则未找到-。特别是，计算出的最小值发生的期望参数存储在结果的“x”属性中，而函数值存储在“fun”属性中。
- en: The `minimize` routine requires the function and a starting value of `x0`. In
    this recipe, we also provided a tolerance value that the minimum should be computed
    at using the `tol` keyword argument. Changing this value will modify the accuracy
    that the solution is computed with.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: “最小化”例程需要函数和“x0”的起始值。在这个示例中，我们还提供了一个容差值，最小值应该使用“tol”关键字参数计算。更改此值将修改计算解的准确度。
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Nelder-Mead algorithm is an example of a "gradient-free" minimization algorithm
    since it does not require any information about the gradient (derivative) of the
    objective function. There are several such algorithms, all of which typically
    involve evaluating the objective function at a number of specified points, and
    then using this information to move toward the minimum value. In general, gradient-free
    methods tend to converge more slowly than gradient descent models. However, they
    can be used for almost any objective function, even where it is not easy to compute
    the gradient either exactly or by means of approximation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Nelder-Mead算法是“无梯度”最小化算法的一个例子，因为它不需要任何关于目标函数的梯度（导数）的信息。有几种这样的算法，通常涉及在指定点评估目标函数，然后使用这些信息朝向最小值移动。一般来说，无梯度方法的收敛速度比梯度下降模型慢。但是，它们可以用于几乎任何目标函数，即使很难精确计算梯度或通过近似手段计算。
- en: Optimizing the functions of a single variable is generally easier than the multi-dimensional
    case and has its own special function in the SciPy `optimize` library. The `minimize_scalar`
    routine performs minimization for functions of a single variable and should be
    used instead of `minimize` in this case.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，优化单变量函数比多维情况更容易，并且在SciPy“optimize”库中有其专用函数。“minimize_scalar”例程对单变量函数执行最小化，并且在这种情况下应该使用而不是“minimize”。
- en: Using gradient descent methods in optimization
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在优化中使用梯度下降方法
- en: In the previous recipe, we used the Nelder-Mead simplex algorithm to minimize
    a non-linear function containing two variables. This is a fairly robust method
    that works even if very little is known about the objective function. However,
    in many situations, we do know more about the objective function, and this fact
    allows us to devise faster and more efficient algorithms for minimizing the function.
    We can do this by making use of properties such as the gradient of the function.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用Nelder-Mead单纯形算法最小化包含两个变量的非线性函数。这是一种相当健壮的方法，即使对目标函数了解甚少也可以工作。然而，在许多情况下，我们对目标函数了解更多，这一事实使我们能够设计更快和更有效的最小化函数的算法。我们可以通过利用函数的梯度等属性来做到这一点。
- en: 'The *gradient* of a function of more than one variable describes the rate of
    change of the function in each of its component directions. This is a vector of
    the partial derivatives of the function with respect to each of the variables.
    From this gradient vector, we can deduce the direction in which the function is
    increasing most rapidly and, conversely, the direction in which the function is
    decreasing most rapidly from any given position. This gives us the basis for *gradient
    descent* methods for minimizing a function. The algorithm is very simple: given
    a starting position, **x**, we compute the gradient at this **x** and the corresponding
    direction in which the gradient is most rapidly decreasing, then make a small
    step in that direction. After a few iterations, this will move from the starting
    position to the minimum of the function.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 多于一个变量的函数的*梯度*描述了函数在各个分量方向上的变化率。这是函数对每个变量的偏导数的向量。从这个梯度向量中，我们可以推断出函数在哪个方向上增长最快，反之亦然，从任意给定位置开始，函数在哪个方向上下降最快。这为*梯度下降*方法最小化函数提供了基础。算法非常简单：给定一个起始位置**x**，我们计算在这个**x**处的梯度以及梯度最快下降的相应方向，然后沿着那个方向迈出一小步。经过几次迭代，这将从起始位置移动到函数的最小值。
- en: In this recipe, we will learn how to implement an algorithm based on the steepest
    descent algorithm to minimize an objective function within a bounded region.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何实现基于最陡下降算法的算法，以在有界区域内最小化目标函数。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the NumPy package imported as `np`, the Matplotlib
    `pyplot` module imported as `plt`, and the `Axes3D` object imported from `mpl_toolkits.mplot3d`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要导入NumPy包作为`np`，导入Matplotlib的`pyplot`模块作为`plt`，并从`mpl_toolkits.mplot3d`导入`Axes3D`对象：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the following steps, we will implement a simple gradient descent method
    to minimize an objective function with a known gradient function (we''re actually
    going to use a generator function so that we can see the method as it works):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将实现一个简单的梯度下降方法，以最小化具有已知梯度函数的目标函数（实际上我们将使用一个生成器函数，以便我们可以看到方法的工作方式）：
- en: 'We will start by defining a `descend` routine, which will carry out our algorithm.
    The function declaration is as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先定义一个`descend`例程，它将执行我们的算法。函数声明如下：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we need to implement this routine. We start by defining the variables
    that will hold the iterate values while the method is running:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要实现这个例程。我们首先定义将在方法运行时保存迭代值的变量：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We then start our loop, which will run the iterations. We immediately check
    whether we are making meaningful progress before continuing:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们开始我们的循环，这将运行迭代。我们立即检查是否在继续之前正在取得有意义的进展：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The direction is minus the gradient vector. We compute this once and store
    it in the `direction` variable:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方向是梯度向量的负。我们计算一次并将其存储在`direction`变量中：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we update the previous and current values, `xnm1` and `xn`, respectively,
    ready for the next iteration. This concludes the code for the `descend` routine:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们更新先前和当前的值，分别为`xnm1`和`xn`，准备进行下一次迭代。这结束了`descend`例程的代码：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we can compute the gradient at the current value and yield all the appropriate
    values:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以计算当前值的梯度并产生所有适当的值：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This concludes the definition of the `descend` routine.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了`descend`例程的定义。
- en: 'We can now define a sample objective function to minimize:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以定义一个要最小化的样本目标函数：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we create a grid that we will evaluate and then plot the objective function
    on:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个网格，我们将评估并绘制目标函数：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once the grid has been created, we can evaluate our function and store the
    result in the `z` variable:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦网格创建完成，我们可以评估我们的函数并将结果存储在`z`变量中：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we create a three-dimensional surface plot of the objective function:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建目标函数的三维表面图：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Before we can start the minimization process, we need to define an initial
    point, `x0`. We plot this point on the objective function plot we created in the
    previous step:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们开始最小化过程之前，我们需要定义一个初始点`x0`。我们在前一步中创建的目标函数图上绘制这一点：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The surface plot of the objective function, along with the initial value, can
    be seen in the following image:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 目标函数的表面图，以及初始值，可以在以下图像中看到：
- en: '![](assets/5c4283c9-96a3-4818-8b34-16b400f57003.png)Figure 9.5: Surface of
    the objective function with the initial position'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5c4283c9-96a3-4818-8b34-16b400f57003.png)图9.5：具有初始位置的目标函数表面'
- en: 'Our `descend` routine requires a function that evaluates the gradient of the
    objective function, so we will define one:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`descend`例程需要一个评估目标函数梯度的函数，因此我们将定义一个：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will plot the iterations on a contour plot, so we set this up as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在轮廓图上绘制迭代，因此我们设置如下：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we create a variable that holds the bounds in the *x* and *y* directions
    as a tuple of tuples. These are the same bounds from the `linspace` calls in *step
    10*:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个变量，将*x*和*y*方向的边界作为元组的元组保存。这些是*步骤10*中`linspace`调用中的相同边界：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can now use a `for` loop to drive the `descend` generator to produce each
    of the iterations and add the steps to the contour plot:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用`for`循环驱动`descend`生成器来产生每个迭代，并将步骤添加到轮廓图中：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once the loop is complete, we print the final values to the Terminal:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环完成后，我们将最终值打印到终端：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of the preceding print statements is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前面打印语句的输出如下：
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we can see that our routine used 37 iterations to find a minimum at approximately
    (0.5, -0.5), which is correct.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的例程使用了37次迭代来找到大约在(0.5，-0.5)处的最小值，这是正确的。
- en: 'The contour plot with its iterations plotted can be seen in the following image:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在以下图像中看到带有其迭代的轮廓图：
- en: '![](assets/2925d695-1772-420f-b35e-85cac413956f.png)Figure 9.6: Contour plot
    of the objective function with gradient descent iterating to a minimum value'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2925d695-1772-420f-b35e-85cac413956f.png)图9.6：梯度下降迭代到最小值的目标函数轮廓图'
- en: Here, we can see that the direction of each iteration – shown by the dashed
    lines – is in the direction where the objective function is decreasing most rapidly.
    The final iteration lies at the center of the "bowl" of the objective function,
    which is where the minimum occurs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到每次迭代的方向 - 由虚线表示 - 是目标函数下降最快的方向。最终迭代位于目标函数“碗”的中心，这是最小值出现的地方。
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The heart of this recipe is the `descend` routine. The process that's defined
    in this routine is a very simple implementation of the gradient descent method.
    Computing the gradient at a given point is handled by the `grad` argument, and
    is then used to deduce the direction of travel for the iteration by taking `direction
    = -grad`. We multiply this direction by a fixed scale factor (sometimes called
    the **learning rate**) with a value of 0.2 to obtain the scaled step, and then
    take this step by adding `0.2*direction` to the current position.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的核心是`descend`例程。在这个例程中定义的过程是梯度下降法的一个非常简单的实现。在给定点计算梯度由`grad`参数处理，然后用`direction
    = -grad`推断迭代的旅行方向。我们将这个方向乘以一个固定的比例因子（有时称为**学习率**）0.2的值来获得缩放步骤，然后通过添加`0.2*direction`到当前位置来进行这一步。
- en: The solution in the recipe took 37 iterations to converge, which is a mild improvement
    on the Nelder-Mead simplex algorithm from the *Minimizing a non-linear function*
    recipe, which took 58 iterations. (This is not a perfect comparison since we changed
    the starting position for this recipe.) This performance is heavily dependent
    on the step size that we choose. In this case, we fixed the maximum step size
    to be 0.2 times the size of the direction vector. This keeps the algorithm simple,
    but it is not particularly efficient.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的解决方案需要37次迭代才能收敛，这比*最小化非线性函数*配方中的Nelder-Mead单纯形算法需要58次迭代要好一点。（这并不是一个完美的比较，因为我们改变了这个配方的起始位置。）这种性能在很大程度上取决于我们选择的步长。在这种情况下，我们将最大步长固定为方向向量的0.2倍。这使得算法简单，但并不特别高效。
- en: In this recipe, we chose to implement the algorithm as a generator function
    so that we could see the output of each step and plot this on our contour plot
    as we stepped through the iteration. In practice, we probably wouldn't want to
    do this and instead return the calculated minimum once the iterations have finished.
    To do this, we can simply remove the `yield`statement and replace it with`return
    xn`at the very end of the function, at the main function's indentation (that is,
    not inside the loop). If you want to guard against non-convergence, you can use
    the `else`feature of the `for` loop to catch cases where the loop finishes because
    it has reached the end of its iterator without hitting the `break`keyword. This`else`block
    could raise an exception to indicate that the algorithm has failed to stabilize
    to a solution. The condition we used to end the iteration in this recipe does
    not guarantee that the method has reached a minimum, but this will usually be
    the case.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们选择将算法实现为生成器函数，以便我们可以看到每一步的输出，并在迭代中绘制在等高线图上。在实践中，我们可能不想这样做，而是在迭代完成后返回计算出的最小值。为此，我们可以简单地删除`yield`语句，并在函数的最后，即主函数的缩进位置（即不在循环内），用`return
    xn`替换它。如果你想防止不收敛，你可以使用`for`循环的`else`特性来捕捉循环完成的情况，因为它已经到达了迭代器的末尾而没有触发`break`关键字。这个`else`块可以引发一个异常，以表明算法未能稳定到一个解决方案。在这个配方中，我们用来结束迭代的条件并不能保证该方法已经达到了最小值，但这通常是这种情况。
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In practice, you would not usually implement the gradient descent algorithm
    for yourself and instead use a general-purpose routine from a library such as
    the SciPy `optimize` module. We can use the same `minimize` routine that we used
    in the previous recipe to perform minimization with a variety of different algorithms,
    including several gradient descent algorithms. These implementations are likely
    to have much higher performance and be more robust than a custom implementation
    such as this.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你通常不会为自己实现梯度下降算法，而是使用来自库（如SciPy `optimize`模块）的通用例程。我们可以使用与前一个配方中使用的相同的`minimize`例程来执行多种不同算法的最小化，包括几种梯度下降算法。这些实现可能比这样的自定义实现具有更高的性能和更强大的鲁棒性。
- en: 'The gradient descent method we used in this recipe is a very naive implementation
    and can be greatly improved by allowing the routine to choose the step size at
    each step. (Methods that are allowed to choose their own step size are sometimes
    called adaptive methods.) The difficult part of this improvement is choosingthe
    size of the step to take in this direction. For this, we need to consider the
    function of a single variable, which is given by the following equation:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个配方中使用的梯度下降方法是一个非常天真的实现，可以通过允许例程在每一步选择步长来大大改进。（允许选择自己步长的方法有时被称为自适应方法。）这种改进的困难部分是选择在这个方向上采取的步长大小。为此，我们需要考虑单变量函数，它由以下方程给出：
- en: '![](assets/be48ec70-e6d7-44a1-968a-30847a25765e.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/be48ec70-e6d7-44a1-968a-30847a25765e.png)'
- en: Here, **x***[n]*represents the current point, **d**[*n*]represents the current
    direction, and *t* is a parameter. For simplicity, we can use a minimization routine
    called `minimize_scalar` for scalar-valued functions from the SciPy `optimize`module.
    Unfortunately, it is not quite as simple as passing in this auxiliary function
    and finding the minimum value. We have to bound the possible value of *t* so that
    the computed minimizing point, **x**[*n*]+ *t***d**[*n*], lies within the region
    that we are interested in.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**x***[n]*表示当前点，**d**[*n*]表示当前方向，*t*是一个参数。为了简单起见，我们可以使用SciPy `optimize`模块中的`minimize_scalar`最小化例程来处理标量值函数。不幸的是，这并不像简单地传入这个辅助函数并找到最小值那样简单。我们必须限定*t*的可能值，以便计算出的最小化点**x**[*n*]+
    *t***d**[*n*]位于我们感兴趣的区域内。
- en: 'To understand how we bound the values of *t*, we must first look at the construction
    geometrically. The auxiliary function that we introduce evaluates the objective
    function along a single line in the given direction. We can picture this as taking
    a single cross-section through the surface that passes through the current **x***[n]*point
    in the**d**[*n*] direction. The next step of the algorithm is finding the step
    size, *t*, that minimizes the values of the objective function along this line
    – this is a scalar function, which is much easier to minimize. The bounds should
    then be the range of *t*values during which this line lies within the rectangle
    defined by the *x*and *y*boundary values. We determine the four values at which
    this line crosses those *x*and *y*boundary lines, two of which will be negative
    and two of which will be positive. (This is because the current point must lie
    within the rectangle.) We take the minimum of the two positive values and the
    maximum of the two negative values and pass these bounds to the scalar minimization
    routine. This is achieved using the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解我们如何限制*t*的值，我们必须首先从几何上看这个构造。我们引入的辅助函数在给定方向上沿着一条直线评估目标函数。我们可以将其想象为通过当前**x***[n]*点在**d**[*n*]方向上穿过的表面的单个横截面。算法的下一步是找到最小化沿着这条直线的目标函数值的步长*t*，这是一个标量函数，要最小化它要容易得多。然后边界应该是*t*值的范围，在这个范围内，这条直线位于由*x*和*y*边界值定义的矩形内。我们确定这条直线穿过这些*x*和*y*边界线的四个值，其中两个将是负值，另外两个将是正值。（这是因为当前点必须位于矩形内。）我们取两个正值中的最小值和两个负值中的最大值，并将这些边界传递给标量最小化例程。这是通过以下代码实现的：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once the step size has been chosen, the only remaining step is to update the
    current `xn` value, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择了步长，唯一剩下的步骤就是更新当前的`xn`值，如下所示：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Using this adaptive step size increases the complexity of the routine, but the
    performance is massively improved. Using this revised routine, the method converged
    in just three iterations, which is far fewer than the number of iterations used
    by the naive code in this recipe (37 iterations) or by the Nelder-Mead simplex
    algorithm in the previous recipe (58 iterations). This reduction in the number
    of iterations is exactly what we expected by providing the method with more information
    in the form of the gradient function.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种自适应步长会增加例程的复杂性，但性能大大提高。使用这个修改后的例程，该方法在只进行了三次迭代后就收敛了，远少于本食谱中使用的朴素代码（37次迭代）或上一个食谱中使用的Nelder-Mead单纯形算法（58次迭代）。通过在梯度函数中提供更多信息，减少了迭代次数，这正是我们预期的。
- en: We created a function that returned the gradient of the function at a given
    point. We computed this gradient by hand before we started, which will not always
    be easy or even possible. Instead, it is much more common to replace the "analytic"
    gradient used here with a numerically computed gradient that's been estimated
    using finite differences or a similar algorithm. This has an impact on performance
    and accuracy, as all approximations do, but these concerns are usually minor given
    the improvement in the speed of convergence offered by gradient descent methods.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个函数，返回给定点处函数的梯度。我们在开始之前手动计算了这个梯度，这并不总是容易或甚至可能的。相反，更常见的是用数值计算的梯度替换这里使用的“解析”梯度，这个数值梯度是使用有限差分或类似算法估计的。这对性能和准确性有影响，就像所有近似一样，但鉴于梯度下降方法提供的收敛速度的提高，这些问题通常是次要的。
- en: Gradient descent type algorithms are particularly popular in machine learning
    applications. Most of the popular Python machine learning libraries – including
    PyTorch, TensorFlow, and Theano – offer utilities for automatically computing
    gradients numerically for data arrays. This allows gradient descent methods to
    be used in the background to improve performance.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度下降类型的算法在机器学习应用中特别受欢迎。大多数流行的Python机器学习库，包括PyTorch、TensorFlow和Theano，都提供了用于自动计算数据数组梯度的实用工具。这使得梯度下降方法可以在后台使用以提高性能。
- en: A popular variation of the gradient descent method is **stochastic gradient
    descent**, where the gradient is estimated by sampling randomly rather than using
    the whole set of data. This can dramatically reduce the computational burden of
    the method – at the cost of slower convergence – especially for high-dimensional
    problems such as those that are common in machine learning applications. Stochastic
    gradient descent methods are often combined with backpropagation to form the basis
    for training artificial neural networks in machine learning applications.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度下降方法的一种流行变体是**随机梯度下降**，其中梯度是通过随机抽样来估计的，而不是使用整个数据集。这可以显著减少方法的计算负担，但会以更慢的收敛速度为代价，特别是对于高维问题，比如在机器学习应用中常见的问题。随机梯度下降方法通常与反向传播结合，构成了机器学习应用中训练人工神经网络的基础。
- en: There are several extensions of the basic stochastic gradient descent algorithm.
    For example, the momentum algorithm incorporates the previous increment into the
    calculation of the next increment. Another example is the adaptive gradient algorithm,
    which incorporates per-parameter learning rates to improve the rate of convergence
    for problems that involve a large number of sparse parameters.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 基本随机梯度下降算法有几种扩展。例如，动量算法将先前的增量纳入到下一个增量的计算中。另一个例子是自适应梯度算法，它纳入每个参数的学习率，以改善涉及大量稀疏参数的问题的收敛速度。
- en: Using least squares to fit a curve to data
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用最小二乘法拟合数据曲线
- en: Least squares is a powerful technique for finding a function from a relatively
    small family of potential functions that best describe a particular set of data.
    This technique is especially common in statistics. For example, least squares
    is used in linear regression problems – here, the family of potential functions
    is the collection of all linear functions. Usually, this family of functions that
    we try to fit has relatively few parameters that can be adjusted to solve the
    problem.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最小二乘法是一种强大的技术，用于从相对较小的潜在函数族中找到最能描述特定数据集的函数。这种技术在统计学中特别常见。例如，最小二乘法用于线性回归问题-在这里，潜在函数族是所有线性函数的集合。通常，我们尝试拟合的这个函数族具有相对较少的参数，可以调整以解决问题。
- en: The idea of least squares is relatively simple. For each data point, we compute
    the square of the residual – the difference between the value of the point and
    the expected value given a function – and try to make the sum of these squared
    residuals as small as possible (hence least squares).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最小二乘法的思想相对简单。对于每个数据点，我们计算残差的平方-点的值与给定函数的期望值之间的差异-并尝试使这些残差的平方和尽可能小（因此最小二乘法）。
- en: In this recipe, we'll learn how to use least squares to fit a curve to a sample
    set of data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用最小二乘法来拟合一组样本数据的曲线。
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'For this recipe, we will need the NumPy package imported, as usual, as `np`,
    and the Matplotlib `pyplot` module imported as `plt`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将需要导入NumPy包，通常作为`np`，并导入Matplotlib `pyplot`模块作为`plt`：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will also need an instance of the default random number generator from the
    NumPy `random` module imported, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要从NumPy `random`模块中导入默认随机数生成器的实例，如下所示：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we need the `curve_fit` routine form the SciPy `optimize` module:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要从SciPy `optimize`模块中的`curve_fit`例程：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps show you how to use the `curve_fit` routine to fit a curve
    to a set of data:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤向您展示如何使用`curve_fit`例程来拟合一组数据的曲线：
- en: 'The first step is to create the sample data:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建样本数据：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we produce a scatter plot of the data to see if we can identify the underlying
    trend in the data:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们生成数据的散点图，以查看是否可以识别数据中的潜在趋势：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The scatter plot that we have produced can be seen in the following image.
    Here, we can see that the data certainly doesn''t follow a linear trend (straight
    line). Since we know the trend is a polynomial, our next guess would be a quadratic
    trend. This is what we''re using here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成的散点图可以在下面的图像中看到。在这里，我们可以看到数据显然不遇线性趋势（直线）。由于我们知道趋势是多项式，我们的下一个猜测将是二次趋势。这就是我们在这里使用的：
- en: '![](assets/3ceb7823-e247-404c-a2d3-f2fe41c0478c.png)Figure 9.7: Scatter plot
    of the sample data. We can see that the data does not follow a linear trend'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/3ceb7823-e247-404c-a2d3-f2fe41c0478c.png)图9.7：样本数据的散点图。我们可以看到数据不遵循线性趋势'
- en: 'Next, we create a function that represents the model that we wish to fit:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个代表我们希望拟合的模型的函数：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we can use the `curve_fit` routine to fit the model function to the sample
    data:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`curve_fit`例程将模型函数拟合到样本数据中：
- en: '[PRE46]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we plot the best fit curve on top of the scatter plot to evaluate
    how well the fitted curve describes the data:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在散点图上绘制最佳拟合曲线，以评估拟合曲线描述数据的效果如何：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The updated scatter plot can be seen in the following image:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的散点图可以在下面的图像中看到：
- en: '![](assets/dd4d4a24-007e-44fe-be30-d65cbd0cc903.png)Figure 9.8: Scatter plot
    with the curve of best fit found using least-squares superimposed'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/dd4d4a24-007e-44fe-be30-d65cbd0cc903.png)图9.8：散点图，使用最小二乘法找到的最佳拟合曲线'
- en: Here, we can see that the curve we have found fits the data reasonably well.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们找到的曲线相当合理地拟合了数据。
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `curve_fit` routine performs least-squares fitting to fit the model''s
    curve to the sample data. In practice, this amounts to minimizing the following
    objective function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`curve_fit`例程执行最小二乘拟合，将模型的曲线拟合到样本数据中。在实践中，这相当于最小化以下目标函数：'
- en: '![](assets/ba94af51-b092-4000-933f-7e50b33b54ea.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ba94af51-b092-4000-933f-7e50b33b54ea.png)'
- en: Here, the pairs (*x[i]*, *y[i]*) are the points from the sample data. In this
    case, we are optimizing over a three-dimensional parameter space, with one dimension
    for each of the parameters. The routine returns the estimated coefficients – the
    point in the parameter space at which the objective function is minimized – and
    a second variable that contains estimates for the covariance matrix for the fit.
    We ignored this in this recipe.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，配对（*x[i]*，*y[i]*）是样本数据中的点。在这种情况下，我们正在优化一个三维参数空间，每个参数都有一个维度。该例程返回估计的系数-参数空间中的点，其中目标函数被最小化-和包含拟合的协方差矩阵的估计的第二个变量。在这个配方中，我们忽略了这一点。
- en: The estimated covariance matrix that's returned from the `curve_fit` routine
    can be used to give a confidence interval for the estimated parameters. This is
    done by taking the square root of the diagonal elements divided by sample size
    (100 in this recipe). This gives the standard error for the estimate that, when
    multiplied by the appropriate values corresponding to the confidence, gives us
    the size of the confidence interval. (We discussed confidence intervals in [Chapter
    6](87b0f91d-3086-41a9-995d-27fe7d364e8b.xhtml), *Working with Data and Statistics*.)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从`curve_fit`例程返回的估计协方差矩阵可以用于为估计的参数提供置信区间。这是通过取对角线元素的平方根除以样本大小（在这个配方中为100）来完成的。这给出了估计的标准误差，当乘以与置信度对应的适当值时，给出了置信区间的大小。（我们在[第6章](87b0f91d-3086-41a9-995d-27fe7d364e8b.xhtml)中讨论了置信区间，*使用数据和统计*。）
- en: You might have noticed that the parameters estimated by the `curve_fit` routine
    are close, but not exactly equal, to the parameters that we used to define the
    sample data in *step 1*. The fact that these are not exactly equal is due to the
    normally distributed noise that we added to the data. In this recipe, we knew
    that the underlying structure of the data was quadratic – that is, a degree 2
    polynomial – and not some other, more esoteric, function. In practice, we are
    unlikely to know so much about the underlying structure of the data, which is
    the reason we added noise to the sample.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，`curve_fit`例程估计的参数接近，但并非完全等于我们用于定义*步骤1*中的样本数据的参数。这些参数并非完全相等的原因是我们向数据中添加了正态分布的噪声。在这个示例中，我们知道数据的基本结构是二次的
    - 也就是二次多项式 - 而不是其他更神秘的函数。实际上，我们不太可能知道数据的基本结构，这就是我们向样本添加噪声的原因。
- en: There's more...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There is another routine in the SciPy `optimize` module for performing least-squares
    fitting called `least_squares`. This routine has a slightly less intuitive signature
    but does return a results object with more information about the optimization
    process. However, the way this routine is set up is perhaps more similar to the
    way that we constructed the underlying mathematical problem in the *How it works...*
    section. To use this routine, we define the objective function as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy `optimize`模块中还有另一个用于执行最小二乘拟合的例程，名为`least_squares`。这个例程的签名略微不太直观，但确实返回了一个包含有关优化过程的更多信息的结果对象。然而，这个例程的设置方式可能更类似于我们在*它是如何工作的...*部分中构造基础数学问题的方式。要使用这个例程，我们定义目标函数如下：
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We pass this function along with a starting estimate in the parameter space,
    `x0`, such as `(1, 0, 0)`. The additional parameters for the objective function,
    `func`, can be passed using the `args` keyword argument; for example, we could
    use `args=(x_data, y_data)`. These arguments are passed into the `x` and `y` arguments
    of the objective function. To summarize, we could have estimated the parameters
    using the following call to `least_squares`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个函数与参数空间中的起始估计`x0`一起传递，例如`(1, 0, 0)`。目标函数的额外参数`func`可以使用`args`关键字参数传递；例如，我们可以使用`args=(x_data,
    y_data)`。这些参数被传递到目标函数的`x`和`y`参数中。总之，我们可以使用以下调用`least_squares`来估计参数：
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `results` object that's returned from the `least_squares` routine is actually
    the same as the one returned by the other optimization routines described in this
    chapter. It contains details such as the number of iterations used, whether the
    process was successful, detailed error messages, the parameter values, and the
    value of the objective function at the minimum value.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从`least_squares`例程返回的`results`对象实际上与本章中描述的其他优化例程返回的对象相同。它包含诸如使用的迭代次数、过程是否成功、详细的错误消息、参数值以及最小值处的目标函数值等细节。
- en: Analyzing simple two-player games
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析简单的两人游戏
- en: Game theory is a branch of mathematics concerned with the analysis of decision-making
    and strategy. It has applications in economics, biology, and behavioral science.
    Many seemingly complex situations can be reduced to a relatively simple mathematical
    game that can be analyzed in a systematic way to find "optimal" solutions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 博弈论是数学的一个分支，涉及决策和策略分析。它在经济学、生物学和行为科学中有应用。许多看似复杂的情况可以简化为一个相对简单的数学游戏，可以以系统的方式进行分析，找到“最优”解决方案。
- en: 'A classic problem in game theory is the *prisoner''s dilemma*, which, in its
    original form, is as follows: two co-conspirators are caught and must decide whether
    to remain quiet or to testify against the other. If both remain quiet, they both
    serve a 1-year sentence; if one testifies but the other does not, the testifier
    is released and the other serves a 3-year sentence; and if both testify against
    one another, they both serve a 2-year sentence. What should each conspirator do?
    It turns out that the best choice each conspirator can make, given any reasonable
    distrust of the other, is to testify. Adopting this strategy, they will either
    serve no sentence or a 2-year sentence maximum.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 博弈论中的一个经典问题是*囚徒困境*，其原始形式如下：两个同谋被抓住，必须决定是保持沉默还是对对方作证。如果两人都保持沉默，他们都要服刑1年；如果一个作证而另一个不作证，作证者将获释，而另一个将服刑3年；如果两人都相互作证，他们都将服刑2年。每个同谋应该怎么做？事实证明，在对对方有任何合理的不信任的情况下，每个同谋可以做出的最佳选择是作证。采用这种策略，他们将不会服刑或最多服刑2年。
- en: 'Since this book is about Python, we will use a variation of this classic problem
    to illustrate just how universal the idea of this problem is. Consider the following
    problem: you and your colleague have to write some code for a client. You think
    that you could write the code faster in Python, but your colleague thinks that
    they could write it faster in C. The question is, which language should you choose
    for the project?'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这本书是关于Python的，我们将使用这个经典问题的变体来说明这个问题的普遍性。考虑以下问题：你和你的同事必须为客户编写一些代码。你认为你可以用Python更快地编写代码，但你的同事认为他们可以用C更快地编写代码。问题是，你应该选择哪种语言来进行项目？
- en: 'You think that you could write the Python code 4 times faster than in C, so
    you write C with speed 1 and Python with speed 4\. Your colleague says that they
    can write C slightly faster than Python, so they write C with speed 3 and Python
    with speed 2\. If you both agree on a language, then you write the code at the
    speed you predicted, but if you disagree, then the productivity of the faster
    programmer is reduced by 1\. We can summarize this as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为你可以用Python代码比C代码快4倍，所以你用速度1写C，用速度4写Python。你的同事说他们可以比Python稍微更快地写C，所以他们用速度3写C，用速度2写Python。如果你们两个都同意一种语言，那么你们按照你预测的速度编写代码，但如果你们意见不一致，那么更快的程序员的生产力会降低1。我们可以总结如下：
- en: '| **Colleague/You** | **C** | **Python** |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| **同事/你** | **C** | **Python** |'
- en: '| C | 3 / 1 | 3 / 2 |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| C | 3 / 1 | 3 / 2 |'
- en: '| Python | 2 / 1 | 2 / 4 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| Python | 2 / 1 | 2 / 4 |'
- en: In this recipe, we will learn how to construct an object in Python to represent
    this simple two-player game, and then perform some elementary analysis regarding
    the outcomes of this game.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何在Python中构建一个对象来表示这个简单的双人游戏，然后对这个游戏的结果进行一些基本分析。
- en: Getting ready
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the NumPy package imported as `np`, and the Nashpy
    package imported as `nash`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要导入NumPy包为`np`，导入Nashpy包为`nash`：
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How to do it...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps show you how to create and perform some simple analysis
    of a two-player game using Nashpy:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤向您展示了如何使用Nashpy创建和执行一些简单的双人游戏分析：
- en: 'First, we need to create matrices that hold the payoff information for each
    player (you and your colleague, in this example):'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建矩阵，用于保存每个玩家（在这个例子中是您和您的同事）的支付信息。
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we create a `Game` object that holds the game represented by these payoff
    matrices:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`Game`对象，它保存了由这些支付矩阵表示的游戏：
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We compute the utility for the given choices using index notation:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用索引表示法计算给定选择的效用：
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can also compute the expected utilities based on the probabilities of making
    a specific choice:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以根据做出特定选择的概率计算预期效用：
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works...
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we built a Python object that represents a very simple two-player
    strategic game. The idea here is that there are two "players" who have decisions
    to make, and each combination of both player's choices gives a specific payoff
    value. What we're aiming to do here is find the best choice that each player can
    make. The players are assumed to make a single move simultaneously, in the sense
    that neither is aware of the other's choice. Each player has a strategy that determines
    the choice they make.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们构建了一个代表非常简单的双人战略游戏的Python对象。 这里的想法是有两个“玩家”需要做决定，每个玩家的选择组合都会给出一个特定的支付值。
    我们的目标是找到每个玩家可以做出的最佳选择。 假设玩家同时进行一次移动，即没有人知道对方的选择。 每个玩家都有一个确定他们所做选择的策略。
- en: In *step 1,* we create two matrices – one for each player – that are assigned
    to each combination of choices for the payoff value. These two matrices are wrapped
    by the `Game` class from Nashpy, which provides a convenient and intuitive (from
    a game-theoretic point of view) interface for working with games. We can quickly
    calculate the utility of a given combination of choices by passing in the choices
    using index notation.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们创建两个矩阵 - 每个玩家一个 - 分配给每个选择组合的支付值。 这两个矩阵由Nashpy的`Game`类包装，它提供了一个方便且直观（从博弈论的角度来看）的接口来处理游戏。
    通过使用索引表示法传递选择，我们可以快速计算给定选择组合的效用。
- en: We can also provide calculate expected utilities based on a strategy where choices
    are chosen at random according to some probability distribution. The syntax is
    the same as for the deterministic case described previously, except we provide
    a vector of probabilities for each choice. We compute the expected utilities based
    on the probability that you choose Python 90% of the time, while your colleague
    chooses Python 50% of the time. The expected speeds are 2.45 and 2.05 for you
    and your colleague, respectively.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以根据一种策略提供预期效用的计算，其中选择是根据某种概率分布随机选择的。 语法与先前描述的确定性情况相同，只是我们为每个选择提供了一个概率向量。
    我们根据您选择Python的概率计算预期效用为90％，而您的同事选择Python的概率为50％。 预期速度分别为2.45和2.05。
- en: There's more...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is an alternative to computational game theory in Python. The Gambit project
    is a collection of tools that's used for computation in game theory that has a
    Python interface ([http://www.gambit-project.org/](http://www.gambit-project.org/)).
    This is a mature project built around C libraries and offers more performance
    than Nashpy.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，还有一种计算博弈论的替代方法。 Gambit项目是一组用于博弈论计算的工具，具有Python接口（[http://www.gambit-project.org/](http://www.gambit-project.org/)）。
    这是一个成熟的项目，建立在C库周围，并提供比Nashpy更高的性能。
- en: Computing Nash equilibria
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算纳什均衡
- en: 'A *Nash equilibrium* is a two-player strategic game – similar to the one we
    saw in the *Analyzing simple two-player games* recipe – that represents a "steady
    state" in which every player sees the "best possible" outcome. However, this doesn''t
    mean that the outcome linked to a Nash equilibrium is the best overall. Nash equilibria
    are more subtle than this. An informal definition of a Nash equilibrium is as
    follows: an action profile in which no individual player can improve their outcome,
    assuming that all other players adhere to the profile.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*纳什均衡*是一个双人战略游戏 - 类似于我们在*分析简单的双人游戏*配方中看到的游戏 - 代表每个玩家都看到“最佳可能”结果的“稳态”。 但是，这并不意味着与纳什均衡相关联的结果是最好的。
    纳什均衡比这更微妙。 纳什均衡的非正式定义如下：在其中没有个别玩家可以改善他们的结果的行动配置，假设所有其他玩家都遵守该配置。'
- en: 'We will explore the notion of a Nash equilibrium with the classic game of rock-paper-scissors.
    The rules are as follows. Each player can choose one of the options: rock, paper,
    or scissors. Rock beats scissors, but loses to paper; paper beats rock, but loses
    to scissors; scissors beats paper, but loses to rock. Any game in which both players
    make the same choice is a draw. Numerically, we represent a win by +1, a loss
    by -1, and a draw by 0\. From this, we can construct a two-player game and compute
    Nash equilibria for this game.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨纳什均衡的概念，使用经典的猜拳游戏。 规则如下。 每个玩家可以选择以下选项之一：石头，纸或剪刀。 石头打败剪刀，但输给纸； 纸打败石头，但输给剪刀；
    剪刀打败纸，但输给石头。 如果两名玩家做出相同选择的游戏是平局。 在数值上，我们用+1表示赢，-1表示输，0表示平局。 从中，我们可以构建一个双人游戏，并计算该游戏的纳什均衡。
- en: In this recipe, we will compute Nash equilibria for the classic game of rock-paper-scissors.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将计算猜拳游戏的纳什均衡。
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the NumPy package imported as `np`, and the Nashpy
    package imported as `nash`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要导入NumPy包为`np`，导入Nashpy包为`nash`：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps show you how to compute Nash equilibria for a simple two-player
    game:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤向您展示了如何计算简单的两人游戏的纳什均衡：
- en: 'First, we need to create a payoff matrix for each player. We will start with
    the first player:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要为每个玩家创建一个收益矩阵。我们将从第一个玩家开始：
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The payoff matrix for the second player is the transpose of `rps_p1`:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个玩家的收益矩阵是`rps_p1`的转置：
- en: '[PRE57]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, we create the `Game` object to represent the game:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建`Game`对象来表示游戏：
- en: '[PRE58]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We compute the Nash equilibria for the game using the support enumeration algorithm:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用支持枚举算法计算游戏的纳什均衡：
- en: '[PRE59]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We iterate over the equilibria and print the profile for each player:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历均衡，并打印每个玩家的策略：
- en: '[PRE60]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output of these print statements is as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这些打印语句的输出如下：
- en: '[PRE61]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Nash equilibria are extremely important in game theory because they allow us
    to analyze the outcomes of strategic games and identify advantageous positions.
    They were first described by John F. Nash in 1950, and have played a pivotal role
    in modern game theory. A two-player game may have many Nash equilibria, but any
    finite two-player game must have at least one. The problem is finding all the
    possible Nash equilibria for a given game.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 纳什均衡在博弈论中非常重要，因为它们允许我们分析战略游戏的结果，并确定有利的位置。它们最早由约翰·F·纳什在1950年描述，并在现代博弈论中发挥了重要作用。一个两人游戏可能有许多纳什均衡，但任何有限的两人游戏必须至少有一个。问题在于找到给定游戏的所有可能的纳什均衡。
- en: 'In this recipe, we used the support enumeration, which effectively enumerates
    all possible strategies and filters down to those that are Nash equilibria. In
    this recipe, the support enumeration algorithm found just one Nash equilibrium,
    which is a mixed strategy. This means that the only strategy for which there is
    no improvement involves picking one of the choices at random, each with a 1/3
    probability. This is hardly a surprise to anyone who has played rock-paper-scissors
    since for any choice we make, our opponent has a 1 in 3 chance of choosing (at
    random) the move that beats our choice. Equally, we have a 1 in 3 chance of drawing
    or winning the game, so our expected value over all these possibilities is as
    follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了支持枚举，它有效地枚举了所有可能的策略，并筛选出了那些是纳什均衡的策略。在这个示例中，支持枚举算法只找到了一个纳什均衡，这是一个混合策略。这意味着唯一没有改进的策略是随机选择其中一个选项，每个选项的概率为1/3。这对于任何玩过石头剪刀布的人来说都不足为奇，因为无论我们做出什么选择，我们的对手都有1/3的机会（随机）选择打败我们选择的动作。同样，我们有1/3的机会平局或赢得比赛，因此我们在所有这些可能性中的期望值如下：
- en: '![](assets/e8194320-0a11-4aaa-b6ff-58939c4505f7.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e8194320-0a11-4aaa-b6ff-58939c4505f7.png)'
- en: Without knowing exactly which of the choices our opponent will choose, there
    is no way to improve this expected outcome.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在不知道我们的对手会选择哪一个选项的情况下，没有办法改进这个预期结果。
- en: There's more...
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Nashpy package also provides other algorithms for computing Nash equilibria.
    Specifically, the `vertex_enumeration` method, when used on a `Game` object, uses
    the *vertex enumeration* algorithm, while the `lemke_howson_enumeration` method
    uses the *Lemke Howson* algorithm. These alternative algorithms have different
    characteristics and may be more efficient for some problems.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Nashpy软件包还提供了其他计算纳什均衡的算法。具体来说，`vertex_enumeration`方法在`Game`对象上使用*顶点枚举*算法，而`lemke_howson_enumeration`方法使用*Lemke
    Howson*算法。这些替代算法具有不同的特性，对于某些问题可能更有效。
- en: See also
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The documentation for the Nashpy package contains more detailed information
    about the algorithms and game theory involved. This includes a number of references
    to texts on game theory. This documentation can be found at [https://nashpy.readthedocs.io/en/latest/](https://nashpy.readthedocs.io/en/latest/).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Nashpy软件包的文档包含了有关所涉及的算法和博弈论的更详细信息。其中包括了一些关于博弈论的文本参考。这些文档可以在[https://nashpy.readthedocs.io/en/latest/](https://nashpy.readthedocs.io/en/latest/)找到。
- en: Further reading
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'As usual, the *Numerical Recipes* book is a good source of numerical algorithms.
    [Chapter 10](169df36b-7160-4fe9-ab59-e20047fc4dc6.xhtml), *Miscellaneous Topics*,
    deals with the maximization and minimization of functions:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，*Numerical Recipes*书是数值算法的良好来源。[第10章](169df36b-7160-4fe9-ab59-e20047fc4dc6.xhtml)，*其他主题*，涉及函数的最大化和最小化：
- en: '*Press, W.H., Teukolsky, S.A., Vetterling, W.T., and Flannery, B.P., 2017\.
    Numerical recipes: the art of scientific computing. 3rd ed. Cambridge: Cambridge
    University Press*.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Press, W.H., Teukolsky, S.A., Vetterling, W.T., and Flannery, B.P., 2017\.
    Numerical recipes: the art of scientific computing. 3rd ed. Cambridge: Cambridge
    University Press*。'
- en: 'More specific information on optimization can be found in the following books:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 有关优化的更具体信息可以在以下书籍中找到：
- en: '*Boyd, S.P. and Vandenberghe, L., 2018\. Convex optimization**. Cambridge:
    Cambridge University Press*.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Boyd, S.P. and Vandenberghe, L., 2018\. Convex optimization**. Cambridge:
    Cambridge University Press*。'
- en: '*Griva, I., Nash, S., and Sofer, A., 2009\. Linear and nonlinear optimization.**2nd
    ed. Philadelphia: Society for Industrial and Applied Mathematics*.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Griva, I., Nash, S., and Sofer, A., 2009\. Linear and nonlinear optimization.**2nd
    ed. Philadelphia: Society for Industrial and Applied Mathematics*。'
- en: 'Finally, the following book is a good introduction to game theory:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下书籍是博弈论的良好入门：
- en: '*Osborne, M.J., 2017\. An introduction to game theory**. Oxford: Oxford University
    Press*.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Osborne, M.J., 2017\. An introduction to game theory**. Oxford: Oxford University
    Press*。'
