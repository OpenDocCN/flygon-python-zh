- en: Stacks and Queues
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈和队列
- en: In this chapter, we are going to build upon the skills we learned in the last
    chapter in order to create special list implementations. We are still sticking
    to linear structures. We will get to more complex data structures in the coming
    chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在上一章中学到的技能的基础上构建，以创建特殊的列表实现。我们仍然坚持线性结构。在接下来的章节中，我们将介绍更复杂的数据结构。
- en: 'In this chapter, we are going to look at the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下内容：
- en: Implementing stacks and queues
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现堆栈和队列
- en: Some applications of stacks and queues
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈和队列的一些应用
- en: Stacks
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈
- en: 'A stack is a data structure that is often likened to a stack of plates. If
    you have just washed a plate, you put it on top of the stack. When you need a
    plate, you take it off the top of the stack. So the last plate to be added to
    the stack will be the first to be removed from the stack. Thus, a stack is a **last
    in, first out** (**LIFO**) structure:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈是一种经常被比作一堆盘子的数据结构。如果你刚刚洗了一个盘子，你把它放在堆叠的顶部。当你需要一个盘子时，你从堆叠的顶部取出它。因此，最后添加到堆叠的盘子将首先从堆叠中移除。因此，堆栈是**后进先出**（**LIFO**）结构：
- en: '![](assets/f9b6f83e-4f80-4394-8403-1be5aec87197.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f9b6f83e-4f80-4394-8403-1be5aec87197.jpg)'
- en: The preceding figure depicts a stack of plates. Adding a plate to the pile is
    only possible by leaving that plate on top of the pile. To remove a plate from
    the pile of plates means to remove the plate that is on top of the pile.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 上图描述了一堆盘子的堆栈。只有将一个盘子放在堆叠的顶部才可能添加一个盘子。从盘子堆中移除一个盘子意味着移除堆顶上的盘子。
- en: 'There are two primary operations that are done on stacks: `push` and `pop`.
    When an element is added to the top of the stack, it is pushed onto the stack.
    When an element is taken off the top of the stack, it is popped off the stack.
    Another operation which is used sometimes is `peek`, which makes it possible to
    see the element on the stack without popping it off.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈上执行的两个主要操作是`push`和`pop`。当元素添加到堆栈顶部时，它被推送到堆栈上。当元素从堆栈顶部取出时，它被弹出堆栈。有时使用的另一个操作是`peek`，它可以查看堆栈上的元素而不将其弹出。
- en: 'Stacks are used for a number of things. One very common usage for stacks is
    to keep track of the return address during function calls. Let''s imagine that
    we have the following little program:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈用于许多事情。堆栈的一个非常常见的用途是在函数调用期间跟踪返回地址。让我们想象一下我们有以下小程序：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When the program execution gets to the call to `a()`, it first pushes the address
    of the following instruction onto the stack, then jumps to `a`. Inside `a`, `b()`
    is called, but before that, the return address is pushed onto the stack. Once
    in `b()` and the function is done, the return address is popped off the stack,
    which takes us back to `a()`. When `a` has completed, the return address is popped
    off the stack, which takes us back to the `print` statement.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序执行到对`a()`的调用时，首先将以下指令的地址推送到堆栈上，然后跳转到`a`。在`a`内部，调用`b()`，但在此之前，返回地址被推送到堆栈上。一旦在`b()`中，函数完成后，返回地址就会从堆栈中弹出，这将带我们回到`a()`。当`a`完成时，返回地址将从堆栈中弹出，这将带我们回到`print`语句。
- en: 'Stacks are actually also used to pass data between functions. Say you have
    the following function call somewhere in your code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，堆栈也用于在函数之间传递数据。假设你的代码中的某处有以下函数调用：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What is going to happen is that `14, ''eggs'', ''ham''` and `''spam''` will
    be pushed onto the stack, one at a time:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将发生的是`14, 'eggs', 'ham'`和`'spam'`将依次被推送到堆栈上：
- en: '![](assets/ada829bd-7a36-417d-8b9c-0c959bd9e8ed.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ada829bd-7a36-417d-8b9c-0c959bd9e8ed.jpg)'
- en: 'When the code jumps into the function, the values for `a, b, c, d` will be
    popped off the stack. The `spam` element will be popped off first and assigned
    to `d`, then `"ham"` will be assigned to `c`, and so on:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码跳转到函数时，`a, b, c, d`的值将从堆栈中弹出。首先将`spam`元素弹出并分配给`d`，然后将`"ham"`分配给`c`，依此类推：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Stack implementation
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈实现
- en: 'Now let us study an implementation of a stack in Python. We start off by creating
    a `node` class, just as we did in the previous chapter with lists:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来学习Python中堆栈的实现。我们首先创建一个`node`类，就像我们在上一章中使用列表一样：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This should be familiar to you by now: a node holds data and a reference to
    the next item in a list. We are going to implement a stack instead of a list,
    but the same principle of nodes linked together still applies.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这对你来说应该很熟悉：一个节点保存数据和列表中下一个项目的引用。我们将实现一个堆栈而不是列表，但节点链接在一起的原则仍然适用。
- en: 'Now let us look at the `stack` class. It starts off similar to a singly linked
    list. We need to know the node at the top of the stack. We would also like to
    keep track of the number of nodes in the stack. So we will add these fields to
    our class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`stack`类。它开始类似于单链表。我们需要知道堆栈顶部的节点。我们还想跟踪堆栈中节点的数量。因此，我们将向我们的类添加这些字段：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Push operation
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推送操作
- en: 'The `push` operation is used to add an element to the top of the stack. Here
    is an implementation:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`push`操作用于将元素添加到堆栈的顶部。以下是一个实现：'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the following figure, there is no existing node after creating our new node.
    Thus `self.top` will point to this new node. The else part of the `if` statement
    guarantees that this happens:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，在创建新节点后没有现有节点。因此`self.top`将指向这个新节点。`if`语句的`else`部分保证了这一点：
- en: '![](assets/8c66894e-0d5c-43ff-af8d-bc571afa8205.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8c66894e-0d5c-43ff-af8d-bc571afa8205.jpg)'
- en: 'In a scenario where we have an existing stack, we move `self.top` so that it
    points to the newly created node. The newly created node must have its **next**
    pointer, pointing to the node that used to be the top node on the stack:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有一个现有的堆栈的情况下，我们移动`self.top`，使其指向新创建的节点。新创建的节点必须有其**next**指针，指向堆栈上原来的顶部节点：
- en: '![](assets/6eb72349-1b93-4d2c-ae5e-775a76109b02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6eb72349-1b93-4d2c-ae5e-775a76109b02.jpg)'
- en: Pop operation
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹出操作
- en: 'Now we need a `pop` method to remove the top element from the stack. As we
    do so, we need to return the topmost element as well. We will make the stack return
    `None` if there are no more elements:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个`pop`方法来从堆栈中移除顶部元素。在这样做的同时，我们需要返回顶部元素。如果没有更多元素，我们将使堆栈返回`None`：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The thing to pay attention to here is the inner `if` statement. If the top
    node has its **next** attribute pointing to another node, then we must set the
    top of the stack to now point to that node:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是内部的`if`语句。如果顶部节点的**next**属性指向另一个节点，那么我们必须将堆栈的顶部指向该节点：
- en: '![](assets/e832ddc2-57ec-4252-ab91-d1031c910468.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e832ddc2-57ec-4252-ab91-d1031c910468.jpg)'
- en: 'When there is only one node in the stack, the `pop` operation will proceed
    as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当堆栈中只有一个节点时，`pop`操作将按以下方式进行：
- en: '![](assets/068806f4-31b6-4dd2-8e06-1fe00b7a30a3.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/068806f4-31b6-4dd2-8e06-1fe00b7a30a3.jpg)'
- en: 'Removing such a node results in `self.top` pointing to `None`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 移除这样的节点会导致`self.top`指向`None`：
- en: '![](assets/42040b37-cc5f-4fb9-9e0b-f9789f7200aa.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/42040b37-cc5f-4fb9-9e0b-f9789f7200aa.jpg)'
- en: Peek
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Peek
- en: 'As we said earlier, we could also add a `peek` method. This will just return
    the top of the stack without removing it from the stack, allowing us to look at
    the top element without changing the stack itself. This operation is very straightforward.
    If there is a top element, return its data, otherwise return `None` (so that the
    behavior of `peek` matches that of `pop`):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，我们也可以添加一个`peek`方法。这将只返回堆栈的顶部而不将其从堆栈中移除，使我们能够查看堆栈的顶部元素而不改变堆栈本身。这个操作非常简单。如果有一个顶部元素，返回它的数据，否则返回`None`（以便`peek`的行为与`pop`的行为相匹配）：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Bracket-matching application
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 括号匹配应用程序
- en: 'Now let us look at an example of how we can use our stack implementation. We
    are going to write a little function that will verify whether a statement containing
    brackets--(, [, or {--is balanced, that is, whether the number of closing brackets
    matches the number of opening brackets. It will also ensure that one pair of brackets
    really is contained in another:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个例子，说明我们如何使用我们的堆栈实现。我们将编写一个小函数，用于验证包含括号（（，[或{）的语句是否平衡，也就是说，闭合括号的数量是否与开放括号的数量匹配。它还将确保一个括号对确实包含在另一个括号中：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our function parses each character in the statement passed to it. If it gets
    an open bracket, it pushes it onto the stack. If it gets a closing bracket, it
    pops the top element off the stack and compares the two brackets to make sure
    their types match: ( should match ), [ should match ], and { should match }. If
    they don''t, we return `False`, otherwise we continue parsing.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数解析传递给它的语句中的每个字符。如果它得到一个开放括号，它将其推送到堆栈上。如果它得到一个闭合括号，它将堆栈的顶部元素弹出并比较两个括号，以确保它们的类型匹配：（应该匹配），[应该匹配]，{应该匹配}。如果它们不匹配，我们返回`False`，否则我们继续解析。
- en: 'Once we have got to the end of the statement, we need to do one last check.
    If the stack is empty, then we are fine and we can return `True`. But if the stack
    is not empty, then we have some opening bracket which does not have a matching
    closing bracket and we shall return `False`. We can test the bracket-matcher with
    the following little code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们到达语句的末尾，我们需要进行最后一次检查。如果堆栈为空，那么一切正常，我们可以返回`True`。但是如果堆栈不为空，那么我们有一些没有匹配的闭合括号，我们将返回`False`。我们可以用以下小代码测试括号匹配器：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Only the first of the three statements should match. And when we run the code,
    we get the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 只有三个语句中的第一个应该匹配。当我们运行代码时，我们得到以下输出：
- en: '![](assets/348b931f-31df-4d67-a398-4e9d96f6db4f.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/348b931f-31df-4d67-a398-4e9d96f6db4f.png)'
- en: '`True`, `False`, `False`. The code works. In summary, the `push` and `pop`
    operations of the stack data structure attract a **O**(*1*). The stack data structure
    is simply enough but is used to implement a whole range of functionality in the
    real world. The back and forward buttons on the browser are made possible by stacks.
    To be able to have undo and redo functionality in word processors, stacks are
    also used.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`True`，`False`，`False`。代码有效。总之，堆栈数据结构的`push`和`pop`操作吸引了**O**(*1*)。堆栈数据结构非常简单，但在现实世界中用于实现整个范围的功能。浏览器上的后退和前进按钮是由堆栈实现的。为了能够在文字处理器中具有撤销和重做功能，也使用了堆栈。'
- en: Queues
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: Another special type of list is the queue data structure. This data structure
    is no different from the regular queue you are accustomed to in real life. If
    you have stood in line at an airport or to be served your favorite burger at your
    neighborhood shop, then you should know how things work in a queue.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种特殊类型的列表是队列数据结构。这种数据结构与你在现实生活中习惯的常规队列没有什么不同。如果你曾经在机场排队或者在邻里商店等待你最喜欢的汉堡，那么你应该知道队列是如何工作的。
- en: Queues are also a very fundamental and important concept to grasp since many
    other data structures are built on them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 队列也是一个非常基本和重要的概念，因为许多其他数据结构都是基于它们构建的。
- en: 'The way a queue works is that the first person to join the queue usually gets
    served first, all things being equal. The acronym FIFO best explains this. **FIFO**
    stands for **first in, first out**. When people are standing in a queue waiting
    for their turn to be served, service is only rendered at the front of the queue.
    The only time people exit the queue is when they have been served, which only
    occurs at the very front of the queue. By strict definition, it is illegal for
    people to join the queue at the front where people are being served:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的工作方式是，通常第一个加入队列的人会首先得到服务，一切条件相同。首先进入，先出的首字母缩写**FIFO**最好地解释了这一点。当人们站在队列中等待轮到他们接受服务时，服务只在队列的前面提供。人们离开队列的唯一时机是在他们被服务时，这只发生在队列的最前面。严格定义来说，人们加入队列的前面是不合法的，因为那里正在为人们提供服务：
- en: '![](assets/76e5d4fd-9702-49c6-ba06-ae510f3137f4.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/76e5d4fd-9702-49c6-ba06-ae510f3137f4.jpg)'
- en: To join the queue, participants must first move behind the last person in the
    queue. The length of the queue does not matter. This is the only legal or permitted
    way by which the queue accepts new entrants.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入队列，参与者必须首先移动到队列中最后一个人的后面。队列的长度并不重要。这是队列接受新参与者的唯一合法或允许的方式。
- en: As human as we are, the queues that we form do not conform to strict rules.
    It may have people who are already in the queue deciding to fall out or even have
    others substituting for them. It is not our intent to model all the dynamics that
    happen in a real queue. Abstracting what a queue is and how it behaves enables
    us to solve a plethora of challenges, especially in computing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为人，所形成的队列并不遵循严格的规则。可能有人已经在队列中决定退出，甚至有其他人替代他们。我们的目的不是模拟真实队列中发生的所有动态。抽象出队列是什么以及它的行为方式使我们能够解决大量的挑战，特别是在计算方面。
- en: We shall provide various implementations of a queue but all will revolve around
    the same idea of FIFO. We shall call the operation to add an element to the queue
    enqueue. To remove an element from the queue, we will create a `dequeue` operation.
    Anytime an element is enqueued, the length or size of the queue increases by one.
    Conversely, dequeuing items reduce the number of elements in the queue by one.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供各种队列的实现，但所有实现都将围绕FIFO的相同思想。我们将称添加元素到队列的操作为enqueue。要从队列中删除元素，我们将创建一个`dequeue`操作。每次入队一个元素时，队列的长度或大小增加一个。相反，出队项目会减少队列中的元素数量。
- en: 'To demonstrate the two operations, the following table shows the effect of
    adding and removing elements from a queue:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这两个操作，以下表格显示了从队列中添加和移除元素的效果：
- en: '| **Queue operation** | **Size** | **Contents** | **Operation results** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **队列操作** | **大小** | **内容** | **操作结果** |'
- en: '| `Queue()` | 0 | `[]` | Queue object created |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `Queue()` | 0 | `[]` | 创建队列对象 |'
- en: '| `Enqueue` "Mark" | 1 | `[''mark'']` | Mark added to queue |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `Enqueue` "Mark" | 1 | `[''mark'']` | Mark添加到队列中 |'
- en: '| `Enqueue` "John" | 2 | `[''mark'',''john'']` | John added to queue |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `Enqueue` "John" | 2 | `[''mark'',''john'']` | John添加到队列中 |'
- en: '| `Size()` | 2 | `[''mark'',''john'']` | Number of items in queue returned
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `Size()` | 2 | `[''mark'',''john'']` | 返回队列中的项目数 |'
- en: '| `Dequeue()` | 1 | `[''mark'']` | John is dequeued and returned |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `Dequeue()` | 1 | `[''mark'']` | John被出队并返回 |'
- en: '| `Dequeue()` | 0 | `[]` | Mark is dequeued and returned |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `Dequeue()` | 0 | `[]` | Mark被出队并返回 |'
- en: List-based queue
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于列表的队列
- en: 'To put into code everything discussed about queues to this point, let''s go
    ahead and implement a very simple queue using Python''s `list` class. This is
    to help us develop quickly and learn about queues. The operations that must be
    performed on the queue are encapsulated in the `ListQueue` class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将到目前为止讨论的有关队列的一切内容转化为代码，让我们继续使用Python的`list`类实现一个非常简单的队列。这有助于我们快速开发并了解队列。必须在队列上执行的操作封装在`ListQueue`类中：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the initialization method `__init__`, the `items` instance variable is set
    to `[]`, which means the queue is empty when created. The size of the queue is
    also set to `zero`. The more interesting methods are the `enqueue` and `dequeue`
    methods.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化方法`__init__`中，`items`实例变量设置为`[]`，这意味着创建时队列为空。队列的大小也设置为`zero`。更有趣的方法是`enqueue`和`dequeue`方法。
- en: Enqueue operation
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入队操作
- en: 'The `enqueue` operation or method uses the `insert` method of the `list` class
    to insert items (or data) at the front of the list:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`enqueue`操作或方法使用`list`类的`insert`方法在列表的前面插入项目（或数据）：'
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Do note how we implement insertions to the end of the queue. Index 0 is the
    first position in any list or array. However, in our implementation of a queue
    using a Python list, the array index 0 is the only place where new data elements
    are inserted into the queue. The `insert` operation will shift existing data elements
    in the list by one position up and then insert the new data in the space created
    at index 0\. The following figure visualizes this process:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何将插入到队列末尾的操作实现。索引0是任何列表或数组中的第一个位置。但是，在我们使用Python列表实现队列时，数组索引0是新数据元素插入队列的唯一位置。`insert`操作将列表中现有的数据元素向上移动一个位置，然后将新数据插入到索引0处创建的空间中。以下图形可视化了这个过程：
- en: '![](assets/acda141e-486b-4998-acf8-d12153b3b79e.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/acda141e-486b-4998-acf8-d12153b3b79e.jpg)'
- en: 'To make our queue reflect the addition of the new element, the size is increased
    by one:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的队列反映新元素的添加，大小增加了一个：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We could have used Python's `shift` method on the list as another way of implementing
    the "insert at 0". At the end of the day, an implementation is the overall objective
    of the exercise.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Python的`shift`方法在列表上实现“在0处插入”的另一种方法。归根结底，实现是练习的总体目标。
- en: Dequeue operation
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 出队操作
- en: 'The `dequeue` operation is used to remove items from the queue. With reference
    to the introduction to the topic of queues, this operation captures the point
    where we serve the customer who joined the queue first and also waited the longest:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`dequeue`操作用于从队列中移除项目。参考队列主题的介绍，此操作捕获了我们为首次加入队列并等待时间最长的客户提供服务的地方：'
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The Python `list` class has a method called `pop()`. The `pop` method does
    the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`list`类有一个名为`pop()`的方法。`pop`方法执行以下操作：
- en: Removes the last item from the list.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中删除最后一个项目。
- en: Returns the removed item from the list back to the user or code that called
    it.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将从列表中删除的项目返回给调用它的用户或代码。
- en: The last item in the list is popped and saved in the `data` variable. In the
    last line of the method, the data is returned.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的最后一个项目被弹出并保存在`data`变量中。在方法的最后一行，返回数据。
- en: 'Consider the tunnel in the following figure as our queue. To perform a `dequeue`
    operation, the node with data `1` is removed from the front of the queue:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑下图中的隧道作为我们的队列。执行`dequeue`操作时，从队列前面移除数据`1`的节点：
- en: '![](assets/6aa30ff3-231a-4368-b56d-b03352d05ef9.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6aa30ff3-231a-4368-b56d-b03352d05ef9.jpg)'
- en: 'The resulting elements in the queue are as shown as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 队列中的结果元素如下所示：
- en: '![](assets/fcfb8cff-59f5-476f-bdd6-05a3c74ee882.jpg)What can we say about the
    `enqueue` operation? It is highly inefficient in more than one way. The method
    has to first shift all the elements by one space. Imagine when there are 1 million
    elements in a list which need to be shifted around anytime a new element is being
    added to the queue. This will generally make the enqueue process very slow for
    large lists.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/fcfb8cff-59f5-476f-bdd6-05a3c74ee882.jpg)对于`enqueue`操作，我们能说些什么呢？它在多个方面都非常低效。该方法首先必须将所有元素向后移动一个空间。想象一下，当列表中有100万个元素需要在每次向队列添加新元素时进行移动。这通常会使大型列表的enqueue过程非常缓慢。'
- en: Stack-based queue
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于堆栈的队列
- en: 'Yet another implementation of a queue is to use two stacks. Once more, the
    Python `list` class will be used to simulate a stack:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个堆栈的另一种队列实现方式。再次，Python的`list`类将被用来模拟一个堆栈：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding `queue` class sets the two instance variables to empty lists upon
    initialization. These are the stacks that will help us implement a queue. The
    stacks in this case are simply Python lists that allow us to call `push` and `pop`
    methods on them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的`queue`类在初始化时将两个实例变量设置为空列表。这些堆栈将帮助我们实现队列。在这种情况下，堆栈只是允许我们在它们上面调用`push`和`pop`方法的Python列表。
- en: The `inbound_stack` is only used to store elements that are added to the queue.
    No other operation can be performed on this stack.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`inbound_stack` 仅用于存储添加到队列中的元素。在此堆栈上不能执行其他操作。'
- en: Enqueue operation
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入队操作
- en: 'The `enqueue` method is what adds elements to the queue:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`enqueue`方法是向队列添加元素的方法：'
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The method is a simple one that only receives the `data` the client wants to
    append to the queue. This data is then passed to the `append` method of the `inbound_stack`
    in the `queue` class. Furthermore, the `append` method is used to mimic the `push`
    operation, which pushes elements to the top of the stack.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法是一个简单的方法，只接收客户端想要追加到队列中的`data`。然后将此数据传递给`queue`类中的`inbound_stack`的`append`方法。此外，`append`方法用于模拟`push`操作，将元素推送到堆栈顶部。
- en: 'To `enqueue` data onto the `inbound_stack`, the following code does justice:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数据`enqueue`到`inbound_stack`，以下代码可以胜任：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A command-line output of the `inbound_stack` inside the queue is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 队列中`inbound_stack`的命令行输出如下：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Dequeue operation
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 出队操作
- en: 'The `dequeue` operation is a little more involved than its `enqueue` counterpart
    operation. New elements added to our queue end up in the `inbound_stack`. Instead
    of removing elements from the `inbound_stack`, we shift our attention to the `outbound_stack`.
    As we said, elements can be deleted from our queue only through the `outbound_stack`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`dequeue`操作比其`enqueue`对应操作更复杂一些。添加到我们的队列中的新元素最终会出现在`inbound_stack`中。我们不是从`inbound_stack`中删除元素，而是将注意力转向`outbound_stack`。正如我们所说，只能通过`outbound_stack`从我们的队列中删除元素：'
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `if` statement first checks whether the `outbound_stack` is empty or not.
    If it is not empty, we proceed to remove the element at the front of the queue
    by doing the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句首先检查`outbound_stack`是否为空。如果不为空，我们继续通过执行以下操作来移除队列前端的元素：'
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the `outbound_stack` is empty instead, all the elements in the `inbound­_stack`
    are moved to the `outbound_stack` before the front element in the queue is popped
    out:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`outbound_stack`为空，那么在弹出队列的前端元素之前，`inbound_stack`中的所有元素都将移动到`outbound_stack`中：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `while` loop will continue to be executed as long as there are elements
    in the `inbound_stack`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 只要`inbound_stack`中有元素，`while`循环将继续执行。
- en: The statement `self.inbound_stack.pop()` will remove the latest element that
    was added to the `inbound_stack` and immediately pass the popped data to the `self.outbound_stack.append()`
    method call.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 语句`self.inbound_stack.pop()`将删除最新添加到`inbound_stack`中的元素，并立即将弹出的数据传递给`self.outbound_stack.append()`方法调用。
- en: 'Initially, our `inbound_stack` was filled with the elements **5**, **6** and
    **7**:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们的`inbound_stack`填充了元素**5**，**6**和**7**：
- en: '![](assets/0c9f8597-491f-473c-b03a-931f030741ea.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0c9f8597-491f-473c-b03a-931f030741ea.jpg)'
- en: 'After executing the body of the `while` loop, the `outbound_stack` looks like
    this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`while`循环的主体后，`outbound_stack`如下所示：
- en: '![](assets/b9f482bd-7bd5-4c63-9587-bb17ff0eecd6.jpg)![](assets/a8cd8bb4-4c0e-47a5-95c1-0e2ced3edb1b.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b9f482bd-7bd5-4c63-9587-bb17ff0eecd6.jpg)![](assets/a8cd8bb4-4c0e-47a5-95c1-0e2ced3edb1b.png)'
- en: 'The last line in the `dequeue` method will return `5` as the result of the
    `pop` operation on the `outbound_stack`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`dequeue`方法中的最后一行将返回`5`，作为对`outbound_stack`上的`pop`操作的结果：'
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This leaves the `outbound_stack` with only two elements:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使`outbound_stack`只剩下两个元素：
- en: '![](assets/18c49954-4199-454a-bec0-f7619ad6113c.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/18c49954-4199-454a-bec0-f7619ad6113c.jpg)'
- en: The next time the `dequeue` operation is called, the `while` loop will not be
    executed because there are no elements in the `outbound_stack`, which makes the
    outer `if` statement fail.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下次调用`dequeue`操作时，`while`循环将不会被执行，因为`outbound_stack`中没有元素，这使得外部的`if`语句失败。
- en: The `pop` operation is called right away in that case so that only the element
    in the queue that has waited the longest is returned.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，立即调用`pop`操作，以便只返回队列中等待时间最长的元素。
- en: 'A typical run of code to use this queue implementation is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此队列实现的典型代码运行如下：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的输出如下：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code sample adds elements to a queue and prints out the elements within
    the queue. The `dequeue` method is called, after which a change in the number
    of elements is observed when the queue is printed out again.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例向队列添加元素，并打印队列中的元素。调用`dequeue`方法后，再次打印队列时观察到元素数量的变化。
- en: Implementing a queue with two stacks is a popular question posed during interviews.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个堆栈实现队列是面试中经常提出的一个问题。
- en: Node-based queue
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于节点的队列
- en: Using a Python list to implement a queue is a good starter to get the feel of
    how queues work. It is completely possible for us to implement our own queue data
    structure by utilizing our knowledge of pointer structures.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python列表来实现队列是一个很好的起点，可以让我们感受队列的工作原理。我们完全可以利用指针结构的知识来实现自己的队列数据结构。
- en: A queue can be implemented using a doubly linked list, and `insertion` and `deletion`
    operations on this data structure have a time complexity of **O**(*1*).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用双向链表实现队列，对该数据结构的`插入`和`删除`操作的时间复杂度为**O**(*1*)。
- en: The definition for the `node` class remains the same as the `Node` we defined
    when we touched on doubly linked list, The doubly linked list can be treated as
    a queue if it enables a FIFO kind of data access, where the first element added
    to the list is the first to be removed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`node`类的定义与我们在双向链表中定义的`Node`相同，如果双向链表能够实现FIFO类型的数据访问，那么它可以被视为队列，其中添加到列表中的第一个元素是第一个被移除的。'
- en: Queue class
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列类
- en: 'The `queue` class is very similar to that of the doubly linked `list` class:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue`类与双向链表`list`类非常相似：'
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`self.head` and `self.tail` pointers are set to `None` upon creation of an
    instance of the `queue` class. To keep a count of the number of nodes in `Queue`,
    the `count` instance variable is maintained here too and set to `0`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`queue`类的实例时，`self.head`和`self.tail`指针被设置为`None`。为了保持`Queue`中节点数量的计数，这里也维护了`count`实例变量，并将其设置为`0`。
- en: Enqueue operation
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入队操作
- en: 'Elements are added to a `Queue` object via the `enqueue` method. The elements
    in this case are the nodes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 元素通过`enqueue`方法添加到`Queue`对象中。在这种情况下，元素是节点：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `enqueue` method code is the same code already explained in the `append`
    operation of the doubly linked list. It creates a node from the data passed to
    it and appends it to the tail of the queue, or points both `self.head` and `self.tail`
    to the newly created node if the queue is empty. The total count of elements in
    the queue is increased by the line `self.count += 1.`
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`enqueue`方法的代码与双向链表的`append`操作中已经解释过的代码相同。它从传递给它的数据创建一个节点，并将其附加到队列的尾部，或者如果队列为空，则将`self.head`和`self.tail`都指向新创建的节点。队列中元素的总数增加了一行`self.count
    += 1`。'
- en: Dequeue operation
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 出队操作
- en: The other operation that makes our doubly linked list behave as a queue is the
    `dequeue` method. This method is what removes the node at the front of the queue.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使我们的双向链表作为队列的另一个操作是`dequeue`方法。这个方法是用来移除队列前面的节点。
- en: 'To remove the first element pointed to by `self.head`, an `if` statement is
    used:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除由`self.head`指向的第一个元素，使用`if`语句：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`current` is initialized by pointing it to `self.head`. If `self.count` is
    1, then it means only one node is in the list and invariably the queue. Thus,
    to remove the associated node (pointed to by `self.head`), the `self.head` and
    `self.tail` variables are set to `None`.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`current`通过指向`self.head`来初始化。如果`self.count`为1，则意味着列表中只有一个节点，也就是队列中只有一个节点。因此，要移除相关联的节点（由`self.head`指向），需要将`self.head`和`self.tail`变量设置为`None`。'
- en: If, on the other hand, the queue has many nodes, then the head pointer is shifted
    to point to `self.head`'s next node.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果队列有许多节点，那么头指针将被移动以指向`self.head`的下一个节点。
- en: After the `if` statement is run, the method returns the node that was pointed
    to by `head`. `self.count` is decremented by one in either way the `if` statement
    execution path flows.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`if`语句之后，该方法返回被`head`指向的节点。`self.count`在`if`语句执行路径流程中的任何一种方式中都会减少一。
- en: Equipped with these methods, we have successfully implemented a queue, borrowing
    heavily from the idea of a doubly linked list.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些方法，我们成功地实现了一个队列，大量借鉴了双向链表的思想。
- en: Remember also that the only things transforming our doubly linked list into
    a queue are the two methods, namely `enqueue` and `dequeue`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，将我们的双向链表转换为队列的唯一方法是两种方法，即`enqueue`和`dequeue`。
- en: Application of queues
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列的应用
- en: Queues are used to implement a variety of functionalities in computer land.
    For instance, instead of providing each computer on a network with its own printer,
    a network of computers can be made to share one printer by queuing what each printer
    wants to print. When the printer is ready to print, it will pick one of the items
    (usually called jobs) in the queue to print out.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 队列在计算机领域中用于实现各种功能。例如，网络上的每台计算机都不提供自己的打印机，可以通过排队来共享一个打印机。当打印机准备好打印时，它将选择队列中的一个项目（通常称为作业）进行打印。
- en: Operating systems also queue processes to be executed by the CPU. Let's create
    an application that makes use of a queue to create a bare-bones media player.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统还将进程排队以供CPU执行。让我们创建一个应用程序，利用队列来创建一个简单的媒体播放器。
- en: Media player queue
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 媒体播放器队列
- en: Most music player software allows users the chance to add songs to a playlist.
    Upon hitting the play button, all the songs in the main playlist are played one
    after the other. The sequential playing of the songs can be implemented with queues
    because the first song to be queued is the first song that is played. This aligns
    with the FIFO acronym. We shall implement our own playlist queue that plays songs
    in the FIFO manner.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数音乐播放器软件允许用户将歌曲添加到播放列表中。点击播放按钮后，主播放列表中的所有歌曲都会依次播放。歌曲的顺序播放可以使用队列来实现，因为排队的第一首歌曲是首先播放的。这符合FIFO首字母缩写。我们将实现自己的播放列表队列，以FIFO方式播放歌曲。
- en: Basically, our media player queue will only allow for the addition of tracks
    and a way to play all the tracks in the queue. In a full-blown music player, threads
    would be used to improve how the queue is interacted with, while the music player
    continues to be used to select the next song to be played, paused, or even stopped.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们的媒体播放器队列只允许添加曲目以及播放队列中的所有曲目。在一个完整的音乐播放器中，线程将被用来改进与队列的交互方式，同时音乐播放器继续用于选择下一首要播放、暂停或停止的歌曲。
- en: 'The `track` class will simulate a musical track:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`track`类将模拟音乐曲目：'
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Each track holds a reference to the title of the song and also the length of
    the song. The length is a random number between 5 and 10\. The random module provides
    the `randint` method to enable us generate the random numbers. The class represents
    any MP3 track or file that contains music. The random length of a track is used
    to simulate the number of seconds it takes to play a song or track.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 每个音轨都包含对歌曲标题的引用，以及歌曲的长度。长度是在5到10之间的随机数。随机模块提供了`randint`方法，使我们能够生成随机数。该类表示包含音乐的任何MP3音轨或文件。音轨的随机长度用于模拟播放歌曲或音轨所需的秒数。
- en: 'To create a few tracks and print out their lengths, we do the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建几个音轨并打印出它们的长度，我们需要做以下操作：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Your output may be different depending on the random length generated for the
    two tracks.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于为两个音轨生成的随机长度可能不同，因此您的输出可能会有所不同。
- en: 'Now, let''s create our queue. Using inheritance, we simply inherit from the
    `queue` class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的队列。使用继承，我们只需从`queue`类继承：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A call is made to properly initialize the queue by making a call to `super`.
    This class is essentially a queue that holds a number of track objects in a queue.
    To add tracks to the queue, an `add_track` method is created:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`super`来正确初始化队列。该类本质上是一个队列，其中包含队列中的多个音轨对象。要将音轨添加到队列中，需要创建一个`add_track`方法：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The method passes a `track` object to the `enqueue` method of the queue `super`
    class. This will, in effect, create a `Node` using the `track` object (as the
    node's data) and point either the tail, if the queue is not empty, or both head
    and tail, if the queue is empty, to this new node.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将`track`对象传递给队列`super`类的`enqueue`方法。这将实际上使用`track`对象（作为节点的数据）创建一个`Node`，并将尾部（如果队列不为空）或头部和尾部（如果队列为空）指向这个新节点。
- en: 'Assuming the tracks in the queue are played sequentially from the first track
    added to the last (FIFO), then the `play` function has to loop through the elements
    in the queue:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 假设队列中的音轨是按照先进先出的顺序播放的，那么`play`函数必须循环遍历队列中的元素：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`self.count` keeps count of when a track is added to our queue and when tracks
    have been dequeued. If the queue is not empty, a call to the `dequeue` method
    will return the node (which houses the `track` object) at the front of the queue.
    The `print` statement then accesses the title of the track through the `data`
    attribute of the node. To further simulate the playing of a track, the `time.sleep()`
    method halts program execution till the number of seconds of the track has elapsed:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.count`用于计算音轨何时被添加到我们的队列以及何时被出队。如果队列不为空，对`dequeue`方法的调用将返回队列前面的节点（其中包含`track`对象）。然后，`print`语句通过节点的`data`属性访问音轨的标题。为了进一步模拟播放音轨，`time.sleep()`方法将暂停程序执行，直到音轨的秒数已经过去：'
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The media player queue is made up of nodes. When a track is added to the queue,
    the track is hidden in a newly created node and associated with the data attribute
    of the node. That explains why we access a node''s `track` object through the
    data property of the node which is returned by the call to `dequeue`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体播放器队列由节点组成。当音轨被添加到队列时，该音轨会隐藏在一个新创建的节点中，并与节点的数据属性相关联。这就解释了为什么我们通过对`dequeue`的调用返回的节点的数据属性来访问节点的`track`对象：
- en: '![](assets/46c48a15-546f-44d7-b5d2-0a916532f052.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/46c48a15-546f-44d7-b5d2-0a916532f052.jpg)'
- en: You can see, instead of our `node` object just storing just any data, it stores
    tracks in this case.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，`node`对象不仅仅存储任何数据，而是在这种情况下存储音轨。
- en: 'Let''s take our music player for a spin:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来试试我们的音乐播放器：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We create five track objects with random words as titles:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用随机单词创建了五个音轨对象的标题：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The output should be different from what you get on your machine due to the
    random length.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于随机长度的原因，输出应该与您在您的机器上获得的结果不同。
- en: 'Next, an instance of the `MediaPlayerQueue` class is created:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`MediaPlayerQueue`类的一个实例：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The tracks will be added and the output of the `play` function should print
    out the tracks being played in the same order in which we queued them:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 音轨将被添加，并且`play`函数的输出应该按照我们排队的顺序打印出正在播放的音轨：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Upon execution of the program, it can be seen that the tracks are played in
    the order in which they were queued. When playing the track, the system also pauses
    for the number of seconds equal to that of the length of the track.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行时，可以看到音轨是按照它们排队的顺序播放的。在播放音轨时，系统还会暂停与音轨长度相等的秒数。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used our knowledge of linking nodes together to create other
    data structures, namely stacks and queues. We have seen how these data structures
    closely mimic stacks and queues in the real world. Concrete implementations, together
    with their varying types, have been shown. We later applied the concept of stacks
    and queues to write real-life programs.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们利用了将节点链接在一起来创建其他数据结构的知识，即栈和队列。我们已经看到了这些数据结构如何紧密地模仿现实世界中的栈和队列。具体的实现，以及它们不同的类型，都已经展示出来。我们随后将栈和队列的概念应用于编写现实生活中的程序。
- en: We shall consider trees in the next chapter. The major operations on a tree
    will be discussed, likewise the different spheres in which to apply the data structure.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中讨论树。将讨论树的主要操作，以及在哪些领域应用数据结构。
