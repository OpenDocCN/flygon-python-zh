- en: Chapter 1. Numbers, Strings, and Tuples
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。数字，字符串和元组
- en: 'We''ll cover these recipes to introduce basic Python data types:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍这些食谱来介绍基本的Python数据类型：
- en: Creating meaningful names and using variables
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建有意义的名称并使用变量
- en: Working with large and small integers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理大整数和小整数
- en: Choosing between float, decimal, and fraction
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浮点数，小数和分数之间进行选择
- en: Choosing between true division and floor division
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在真除法和地板除法之间进行选择
- en: Rewriting an immutable string
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写不可变字符串
- en: String parsing with regular expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式解析字符串
- en: Building complex strings with "template".format()
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“template”。格式（）构建复杂的字符串
- en: Building complex strings from lists of characters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从字符列表构建复杂的字符串
- en: Using the Unicode characters that aren't on our keyboards
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不在键盘上的Unicode字符
- en: Encoding strings – creating ASCII and UTF-8 bytes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码字符串-创建ASCII和UTF-8字节
- en: Decoding bytes – how to get proper characters from some bytes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解码字节-如何从一些字节中获取正确的字符
- en: Using tuples of items
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用项目的元组
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: This chapter will look at some central types of Python objects. We'll look at
    the different kinds of numbers, working with strings, and using tuples. We'll
    look at these first because they're the simplest kinds of data Python works with.
    In later chapters, we'll look at data collections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍Python对象的一些中心类型。我们将研究不同类型的数字，处理字符串和使用元组。我们首先研究这些，因为它们是Python处理的最简单的数据类型。在后面的章节中，我们将研究数据集合。
- en: Most of these recipes assume a beginner's level of understanding of Python 3\.
    We'll be looking at how we use the essential built-in types available in Python—numbers,
    strings, and tuples. Python has a rich variety of numbers, and two different division
    operators, so we'll need to look closely at the choices available to us.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些大多数食谱假设初学者对Python 3有一定的理解。我们将研究如何使用Python中提供的基本内置类型-数字，字符串和元组。Python有各种各样的数字和两种不同的除法运算符，因此我们需要仔细研究可用的选择。
- en: When working with strings, there are several common operations that are important.
    We'll explore some of the differences between bytes—as used by our OS files, and
    Strings—as used by Python. We'll look at how we can exploit the full power of
    the Unicode character set.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理字符串时，有几个重要的常见操作。我们将探讨字节（由操作系统文件使用）和字符串（由Python使用）之间的一些区别。我们将看看如何利用Unicode字符集的全部功能。
- en: In this chapter, we'll show the recipes as if we're working from the `>>>` prompt
    in interactive Python. This is sometimes called the **read-eval-print loop** (
    **REPL** ). In later chapters, we'll look more closely at writing script files.
    The goal is to encourage interactive exploration because it's a great way to learn
    the language.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示食谱，就好像我们是从交互式Python的`>>>`提示符中工作一样。这有时被称为**读取-求值-打印循环**（**REPL**）。在后面的章节中，我们将更仔细地研究编写脚本文件。目标是鼓励交互式探索，因为这是学习语言的好方法。
- en: Creating meaningful names and using variables
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建有意义的名称并使用变量
- en: How can we be sure our programs make sense? One of the core elements of making
    expressive code is to use *meaningful* names. But what counts as meaningful? In
    this recipe, we'll review some common rules for creating meaningful Python names.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确保我们的程序是有意义的？制作表达性代码的核心元素之一是使用*有意义*的名称。但什么算是有意义的？在这个食谱中，我们将回顾一些创建有意义的Python名称的常见规则。
- en: We'll also look at some of Python's assignment statement variations. We can,
    for example, assign more than one variable in a single statement.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将研究一些Python的赋值语句变体。例如，我们可以在单个语句中分配多个变量。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: The core issue when creating a name is to ask ourselves the question *what is
    this thing?* For software, we'd like a name that's descriptive of the object being
    named. Clearly, a name like `x` is not very descriptive, it doesn't seem to refer
    to an actual thing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 创建名称时的核心问题是问自己一个问题*这是什么东西？*对于软件，我们希望一个描述对象的名称。显然，像`x`这样的名称并不是很描述性，它似乎并不指代实际的东西。
- en: Vague, non-descriptive names are distressingly common in some programming. It's
    not helpful to others when we use them. A descriptive name helps everyone.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些编程中，模糊的，不具描述性的名称是令人沮丧的常见现象。当我们使用它们时，对他人并不有帮助。描述性的名称有助于每个人。
- en: When naming things, it's also important to separate the problem domain—what
    we're really trying to accomplish—from the solution domain. The solution domain
    consists of the technical details of Python, OS, and Internet. Anyone who reads
    the code can see the solution; it doesn't require deep explanation. The problem
    domain, however, can be obscured by technical details. It's our job to make the
    problem clearly visible. Well-chosen names will help.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名事物时，将问题域-我们真正想要实现的目标-与解决方案域分开也很重要。解决方案域包括Python，操作系统和互联网的技术细节。任何阅读代码的人都可以看到解决方案；它不需要深入解释。然而，问题域可能会被技术细节所掩盖。我们的工作是使问题清晰可见。选择恰当的名称将有所帮助。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll look at names first. Then we'll move on to assignment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看名称。然后我们将转向赋值。
- en: Choosing names wisely
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 明智地选择名称
- en: On a purely technical level, Python names must begin with a letter. They can
    include any number of letters, digits, and the _ character. Python 3 is based
    on Unicode, so a letter is not limited to the Latin alphabet. While the A-Z Latin
    alphabet is commonly used, it's not required.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯技术层面上讲，Python名称必须以字母开头。它们可以包括任意数量的字母，数字和_字符。Python 3基于Unicode，因此字母不限于拉丁字母表。虽然A-Z拉丁字母表通常被使用，但并非必需。
- en: When creating a descriptive variable, we want to create names that are both
    specific and articulate the relationships among things in our programs. One widely
    used technique is to create longer names in a style that moves from particular
    to general.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建描述性变量时，我们希望创建既具体又能表达程序中事物之间关系的名称。一个广泛使用的技术是创建更长的名称，风格从具体到一般。
- en: 'The steps to choosing a name are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 选择名称的步骤如下：
- en: The last part of the name is a very broad summary of the thing. In a few cases,
    this may be all we need; context will supply the rest. We'll suggest some typical
    broad summary categories later.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 名称的最后部分是对这个事物的一个非常广泛的总结。在一些情况下，这可能是我们所需要的全部；上下文会提供其余的部分。我们稍后会提出一些典型的广泛总结类别。
- en: Use a prefix to narrow this name around your application or problem domain.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前缀来围绕你的应用程序或问题域缩小这个名称。
- en: If needed, put more narrow and specialized prefixes on this name to clarify
    how it's distinct from other classes, modules, packages, functions, and other
    objects. When in doubt about prefixing, remember how domain names work. Think
    of `mail.google.com` —the name flows from particular to general. There's no magic
    about the three levels of naming, but it often happens to work out that way.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，可以在这个名称上加上更窄和专业的前缀，以澄清它与其他类、模块、包、函数和其他对象的区别。如果对于加前缀感到犹豫，可以回想一下域名是如何工作的。想想`mail.google.com`
    ——名称从具体到一般。命名的三个级别并没有什么神奇之处，但通常情况下会按照这种方式进行。
- en: 'Format the name depending on how it''s used in Python. There are three broad
    classes of things we''ll put names on, which are shown as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据Python中的使用方式来格式化名称。我们将给出三种我们会给名称的东西的广泛类别，如下所示：
- en: '**Classes** : A class has a name that summarizes the objects that are part
    of the class. These names will (often) use `CapitalizedCamelCase` . The first
    letter of a class name is capitalized to emphasize that it''s a class, not an
    instance of the class. A class is often a generic concept, rarely a description
    of a tangible thing.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：类有一个总结了属于该类的对象的名称。这些名称通常会使用`CapitalizedCamelCase`。类名的第一个字母大写是为了强调它是一个类，而不是类的实例。类通常是一个通用的概念，很少是一个具体的东西的描述。'
- en: '**Objects** : A name for an object usually uses `snake_case` - all lowercase
    with multiple `_` characters between words. In Python, this includes variables,
    functions, modules, packages, parameters, attributes of objects, methods of classes,
    and almost everything else.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**：对象的名称通常使用`snake_case`——所有小写，单词之间用多个`_`字符分隔。在Python中，这包括变量、函数、模块、包、参数、对象的属性、类的方法，几乎所有其他东西。'
- en: '**Script and module files** : These are really the OS resources, as seen by
    Python. Therefore, a filename should follow the conventions for Python objects,
    using letters, the `_` characters and ending with the `.py` extension. It''s technically
    possible to have pretty wild and free filenames. Filenames that don''t follow
    Python rules can be difficult to use as a module or package.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚本和模块文件**：这些实际上是Python所看到的操作系统资源。因此，文件名应该遵循Python对象的约定，使用字母、`_`字符，并以`.py`扩展名结尾。技术上可以有相当狂野和自由的文件名。不遵循Python规则的文件名可能很难作为模块或包使用。'
- en: How do we choose the broad category part of a name? The general category depends
    on whether we're talking about a thing or a property of a thing. While the world
    is full of things, we can create some board groupings that are helpful. Some of
    the examples are Document, Enterprise, Place, Program, Product, Process, Person,
    Asset, Rule, Condition, Plant, Animal, Mineral, and so on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何选择名称的广泛类别部分？一般的类别取决于我们是在谈论一个事物还是一个事物的属性。虽然世界充满了事物，但我们可以创建一些有用的广泛分类。一些例子是Document、Enterprise、Place、Program、Product、Process、Person、Asset、Rule、Condition、Plant、Animal、Mineral等等。
- en: 'We can then narrow these with qualifiers:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以用限定词来缩小这些范围：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first example is a class called `Document` . We've narrowed it slightly
    by adding a prefix to call it a `StatusDocument` . We narrowed it even further
    by calling it a `FinalStatusDocument` . The second example is a `Name` that we
    narrowed by specifying that it's a `ReceivedInventoryItemName` . This example
    required a four-level name to clarify the class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子是一个名为`Document`的类。我们通过添加前缀稍微缩小了它，称其为`StatusDocument`。我们甚至进一步缩小了它，称其为`FinalStatusDocument`。第二个例子是一个`Name`，我们通过指定它是一个`ReceivedInventoryItemName`来缩小了它。这个例子需要一个四级名称来澄清这个类。
- en: An object often has properties or attributes. These have a decomposition based
    in the kind of information that's being represented. Some examples of terms that
    should be part of a complete name are amount, code, identifier, name, text, date,
    time, datetime, picture, video, sound, graphic, value, rate, percent, measure,
    and so on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象通常有属性。这些属性有一个基于所表示信息类型的分解。一些应该作为完整名称的一部分的术语的例子是amount、code、identifier、name、text、date、time、datetime、picture、video、sound、graphic、value、rate、percent、measure等等。
- en: 'The idea is to put the narrow, more detailed description first, and the broad
    kind of information last:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 思路是先放窄、更详细的描述，然后是广泛的信息类型：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the first example, `height` narrows a more general representation term `value`
    . And `measured_height_value` further narrows this. Given this name, we can expect
    to see other variations on height. Similar thinking applies to `weight_value`
    , `delivery_date` and `location_code` . Each of these has a narrowing prefix or
    two.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，`height`缩小了更一般的表示术语`value`。而`measured_height_value`进一步缩小了这个范围。根据这个名称，我们可以期待看到关于height的其他变化。类似的思路也适用于`weight_value`，`delivery_date`和`location_code`。每个名称都有一个缩小的前缀或两个。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Some things to avoid** :'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一些需要避免的事情：
- en: Don't include detailed technical type information using coded prefixes or suffixes.
    This is often called **Hungarian Notation** ; we don't use `f_measured_height_value`
    where the `f` is supposed to mean a floating-point. A variable like `measured_height_value`
    can be any numeric type and Python will do all the necessary conversions. The
    technical decoration doesn't offer much help to someone reading our code, because
    the type specification can be misleading or even incorrect.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用编码的前缀或后缀包含详细的技术类型信息。这通常被称为**匈牙利命名法**；我们不使用`f_measured_height_value`，其中`f`应该表示浮点数。像`measured_height_value`这样的变量可以是任何数字类型，Python会进行所有必要的转换。技术装饰对于阅读我们的代码的人并没有太多帮助，因为类型规范可能是误导性的，甚至是错误的。
- en: Don't waste a lot of effort forcing names to look like they belong together.
    We don't need to make `SpadesCardSuit` , `ClubsCardSuit` , and so on. Python has
    many different kinds of namespaces, including packages, modules, and classes,
    as well as namespace objects to gather related names together. If you combine
    these names in a `CardSuit` class, you can use `CardSuit.Spades` , which uses
    the class as namespace to separate these names from other, similar names.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不要浪费大量精力让名称看起来像是属于一起的。我们不需要让`SpadesCardSuit`，`ClubsCardSuit`等看起来像是属于一起的。Python有许多不同类型的命名空间，包括包、模块和类，以及命名空间对象来将相关名称聚集在一起。如果你将这些名称组合在一个`CardSuit`类中，你可以使用`CardSuit.Spades`，这样可以使用类作为命名空间将这些名称与其他类似的名称分开。
- en: Assigning names to objects
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 给对象命名
- en: 'Python doesn''t use static variable definitions. A variable is created when
    a name is assigned to an object. It''s important to think of the objects as central
    to our processing, and variables as little more than sticky notes that identify
    an object. Here''s how we use the fundamental assignment statement:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Python不使用静态变量定义。当一个名称被赋予一个对象时，变量就被创建了。重要的是要把对象看作是我们处理的中心，而变量只是标识对象的便利贴。以下是我们如何使用基本的赋值语句：
- en: Create an object. In many of the examples we'll create objects as literals.
    We'll use `355` or `113` as literal representations of integer objects in Python.
    We might use a string like `FireBrick` or a tuple like `(178, 34, 34)` .
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个对象。在许多例子中，我们将创建对象作为文字。我们将使用`355`或`113`作为Python中整数对象的文字表示。我们可能会使用像`FireBrick`这样的字符串，或者像`(178,
    34, 34)`这样的元组。
- en: 'Write the following kind of statement: *variable = object* . Here are some
    examples:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写下以下类型的陈述：*变量 = 对象*。以下是一些例子：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We've created some objects and assigned them to variables. The first object
    is the result of a calculation. The next two objects are simple literals. Generally,
    objects are created by expressions that involve functions or classes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一些对象并将它们分配给变量。第一个对象是计算的结果。接下来的两个对象是简单的文字。通常，对象是通过涉及函数或类的表达式创建的。
- en: 'This basic statement isn''t the only kind of assignment. We can assign a single
    object to multiple variables using a kind of duplicated assignment like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基本的语句并不是唯一一种赋值方式。我们可以使用一种重复赋值的方式将单个对象分配给多个变量，就像这样：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This creates two names for the same string object. We can confirm this by checking
    the internal ID values that Python uses:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了同一个字符串对象的两个名称。我们可以通过检查Python使用的内部ID值来确认这一点：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This comparison shows us that the internal identifiers for these two objects
    are the same.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种比较告诉我们，这两个对象的内部标识符是相同的。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A test for equality uses `==` . Simple assignment uses `=` .
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 相等的测试使用`==`。简单的赋值使用`=`。
- en: 'When we look at numbers and collections, we''ll see that we can combine assignment
    with an operator. We can do things like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看数字和集合时，我们会发现我们可以将赋值与运算符结合起来。我们可以做这样的事情：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We've augmented assignment with an operator. `total_count += 5` is the same
    as `total_count = total_count + 5` . This technique has the advantage of being
    shorter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用运算符增强了赋值。`total_count += 5`与`total_count = total_count + 5`是一样的。这种技术的优点是更短。
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This approach to creating names follows the pattern of using narrow, more specific
    qualifiers first and the wider, less-specific category last. This follows the
    common convention used for domain names and e-mail addresses.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建名称的这种方法遵循了首先使用狭窄、更具体的限定词，然后是更广泛、不太具体的类别的模式。这遵循了用于域名和电子邮件地址的常见约定。
- en: For example, a domain name like `mail.google.com` has a specific service, a
    more general enterprise, and finally a very general domain. This follows the principle
    of narrow-to-wider.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，像`mail.google.com`这样的域名具有特定的服务，更一般的企业，最后是一个非常普遍的域。这遵循了由狭窄到更广泛的原则。
- en: As another example, service@packtpub.com starts with a specific destination
    name, has a more general enterprise, and finally a very general domain. Even the
    name of destination ( *PacktPub* ) is a two-part name with a narrow enterprise
    name ( *Packt* ) followed by a wider industry ( *Pub* , short for *publishing*
    ). ( *We don't agree with those who suggest it stands for Public House.* )
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，service@packtpub.com以特定的目的地名称开头，具有更一般的企业，最后是一个非常普遍的域。甚至目的地的名称（*PacktPub*）也是一个由狭窄的企业名称（*Packt*）和更广泛的行业（*Pub*，缩写为*publishing*）组成的两部分名称。（*我们不同意那些认为它代表公共场所的人。*）
- en: The assignment statement is the only way to put a name on an object. We noted
    that we can have two names for the same underlying object. This isn't too useful
    right now. But in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures
    – list, set, dict") , *Built-in Data Structures – list, set, dict* we'll see some
    interesting consequences of multiple names for a single object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值语句是将名称放在对象上的唯一方法。我们注意到我们可以为同一个基础对象有两个名称。目前这并不太有用。但是在[第4章](text00048.html#page
    "第4章。内置数据结构-列表、集合、字典")中，*内置数据结构-列表、集合、字典*，我们将看到单个对象的多个名称的一些有趣的后果。
- en: There's more...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We'll try to show descriptive names in all of the recipes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试在所有的食谱中展示描述性的名称。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We have to grant exceptions to existing software which doesn't follow this pattern.
    It's often better to be consistent with legacy software than impose new rules
    even if the new rules are better.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须对不遵循这种模式的现有软件做出例外。与强加新规则相比，与遗留软件保持一致通常更好，即使新规则更好。
- en: Almost every example will involve assignment to variables. It's central to stateful
    object-oriented programming.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个例子都涉及对变量的赋值。这对于有状态的面向对象编程至关重要。
- en: We'll look at classes and class names in [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* ; we'll look at modules
    in [Chapter 13](text00137.html#page "Chapter 13. Application Integration") , *Application
    Integration* .
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](text00070.html#page "第6章。类和对象的基础")中查看类和类名，*类和对象的基础*；我们将在[第13章](text00137.html#page
    "第13章。应用集成")中查看模块，*应用集成*。
- en: See also
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The subject of descriptive naming is a source of ongoing research and discussion.
    There are two aspects—syntax and semantics. The starting point for thoughts on
    Python syntax is the famous **Python Enhancement Proposal number 8** ( **PEP-8**
    ). This leads to use of `CamelCase` , and `snake_case` names.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 描述性命名的主题是持续研究和讨论的来源。有两个方面——语法和语义。关于Python语法的思考的起点是著名的**Python Enhancement Proposal
    number 8**（**PEP-8**）。这导致使用`CamelCase`和`snake_case`名称。
- en: 'Also, be sure to do this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，一定要这样做：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will provide more insight into Python ideals.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更多地了解Python的理想。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For information on semantics, look at the legacy UDEF and NIEM Naming and Design
    Rules standards ([http://www.opengroup.org/udefinfo/AboutTheUDEF.pdf](http://www.opengroup.org/udefinfo/AboutTheUDEF.pdf)
    ). Additional details are in ISO11179 ([https://en.wikipedia.org/wiki/ISO/IEC_11179](https://en.wikipedia.org/wiki/ISO/IEC_11179)
    ), which talks in detail about meta-data and naming.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有关语义的信息，请参阅传统的UDEF和NIEM命名和设计规则标准（[http://www.opengroup.org/udefinfo/AboutTheUDEF.pdf](http://www.opengroup.org/udefinfo/AboutTheUDEF.pdf)）。ISO11179中还有更多详细信息（[https://en.wikipedia.org/wiki/ISO/IEC_11179](https://en.wikipedia.org/wiki/ISO/IEC_11179)），其中详细讨论了元数据和命名。
- en: Working with large and small integers
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用大和小整数
- en: Many programming languages make a distinction between integers, bytes, and long
    integers. Some languages include distinctions for *signed versus* *unsigned* integers.
    How do we map these concepts to Python?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言区分整数、字节和长整数。一些语言包括*有符号*和*无符号*整数的区别。我们如何将这些概念映射到Python呢？
- en: The easy answer is that we don't. Python handles integers of all sizes in a
    uniform way. From bytes to immense numbers with hundreds of digits, it's all just
    integers to Python.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的答案是我们不需要。Python以统一的方式处理所有大小的整数。从字节到数百位数的巨大数字，对Python来说都只是整数。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Imagine you need to calculate something really big. For example, calculate the
    number of ways to permute the cards in a 52-card deck. The number 52! = 52 × 51
    × 50 × ... × 2 × 1, is a very, very large number. Can we do this in Python?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你需要计算一个非常大的东西。例如，计算52张牌的牌组的排列方式。数字52! = 52 × 51 × 50 × ... × 2 × 1，是一个非常非常大的数字。我们可以在Python中做到这一点吗？
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Don''t worry. Really. Python behaves as if it has one universal type of integer,
    and this covers all of the bases from bytes to numbers that fill all of the memory.
    Here are the steps to using integers properly:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心。真的。Python的行为就好像它有一种通用类型的整数，这涵盖了从字节到填满所有内存的数字的所有基础。以下是使用整数的步骤：
- en: 'Write the numbers you need. Here are some smallish numbers: 355, 113\. There’s
    no practical upper limit.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写下你需要的数字。以下是一些小数字：355，113。没有实际的上限。
- en: 'Creating a very small value—a single byte—looks like this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个非常小的值——一个字节——看起来像这样：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or perhaps this, if you want to use base 16:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想使用16进制，可能是这样：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In later recipes, we''ll look at a sequence of bytes that has only a single
    value in it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的示例中，我们将看到一个字节序列，其中只有一个值：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This isn't—technically—an integer. It has a prefix of `b'` that shows us it's
    a 1-byte sequence.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这不是一个整数。它有一个`b'`的前缀，表明它是一个1字节序列。
- en: 'Creating a much, much bigger number with a calculation might look like this:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用计算创建一个非常大的数字可能看起来像这样：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This number has 617 digits. We didn't show all of them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字有617位。我们没有展示所有的位数。
- en: How it works...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Internally, Python uses two kinds of numbers. The conversion between these two
    is seamless and automatic.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Python使用两种类型的数字。这两者之间的转换是无缝和自动的。
- en: For smallish numbers, Python will generally use 4 or 8 byte integer values.
    Details are buried in CPython's internals, and depend on the facilities of the
    C-compiler used to build Python.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小整数，Python通常会使用4或8字节的整数值。细节被埋在CPython的内部，并且取决于用于构建Python的C编译器的功能。
- en: For largish numbers, over `sys.maxsize` , Python switches to large integer numbers
    which are sequences of digits. Digit, in this case, often means a 30-bit value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大整数，超过`sys.maxsize`，Python将切换到大整数数字，这些数字是数字序列。在这种情况下，数字通常意味着30位值。
- en: 'How many ways can we permute a standard deck of 52 cards? The answer is 52!
    ≈ 8 × 10^(67) . Here''s how we can compute that large number. We''ll use the factorial
    function in the `math` module, shown as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对标准的52张牌的牌组进行多少种排列？答案是52! ≈ 8 × 10^(67)。以下是我们如何计算这个大数字。我们将使用`math`模块中的阶乘函数，如下所示：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Yes, these giant numbers work perfectly.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这些巨大的数字完美地工作。
- en: The first parts of our calculation of 52! (from 52 × 51 × 50 × .. *.* down to
    about 42) could be performed entirely using the smallish integers. After that,
    the rest of the calculation had to switch to largish integers. We don't see the
    switch; we only see the results.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算52!（从52×51×50×..*.*到约42）的前几部分可以完全使用较小的整数。之后，计算的其余部分必须切换到较大的整数。我们看不到切换；我们只看到结果。
- en: 'For some of the details on the internals of integers, we can look at this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 关于整数的内部细节，我们可以看看这个：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `sys.maxsize` value is the largest of the small integer values. We computed
    the log to base 2 to find out how many bits are required for this number.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.maxsize`值是小整数值中最大的值。我们计算了以2为底的对数，以找出这个数字需要多少位。'
- en: This tells us that our Python uses 63-bit values for small integers. The range
    of smallish integers is from -2^(64) ... 2^(63) - 1\. Outside this range, largish
    integers are used.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，我们的Python对于小整数使用63位值。小整数的范围是从-2^(64) ... 2^(63) - 1。在此范围之外，将使用大整数。
- en: The values in `sys.int_info` tells us that large integers are a sequence of
    numbers that use 30-bit digits, and each of these digits occupies 4 bytes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.int_info`中的值告诉我们，大整数是使用30位数字的数字序列，每个数字占据4个字节。'
- en: A large value like 52! consists of 8 of these 30-bit-sized digits. It can be
    a little confusing to think of a digit as requiring 30 bits to represent. Instead
    of 10 symbols used to represent base 10 numbers, we'd need *2**30* distinct symbols
    for each digit of these large numbers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 像52!这样的大值由8个这样的30位大小的数字组成。将一个数字表示为需要30位来表示可能有点令人困惑。与用于表示十进制数的10个符号不同，我们需要*2**30*个不同的符号来表示这些大数字的每个数字。
- en: A calculation involving a number of big integer values can consume a fair bit
    of memory. What about small numbers? How can Python manage to keep track of lots
    of little numbers like one and zero?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及大量大整数值的计算可能会消耗大量内存。那么小数字呢？Python如何管理跟踪像1和0这样的许多小数字？
- en: 'For the commonly used numbers (-5 to 256) Python actually creates a secret
    pool of objects to optimize memory management. You can see this when you check
    the `id()` value for integer objects:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常用的数字（-5到256），Python实际上创建了一个秘密的对象池来优化内存管理。当您检查整数对象的`id()`值时，您可以看到这一点：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We've shown the internal `id` for the integer `1` and the integer `2` . When
    we calculate a value, the resulting object turns out to be the same integer `2`
    object that was found in the pool.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了整数`1`和整数`2`的内部`id`。当我们计算一个值时，结果对象实际上是在池中找到的相同整数`2`对象。
- en: When you try this, your `id()` values may be different. However, every time
    the value of `2` is used, it will be the same object; on the author's laptop,
    it's id = `4297537984` . This saves having many, many copies of the 2 object cluttering
    up memory.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试这样做时，您的`id()`值可能会有所不同。但是，每次使用`2`的值时，它都将是相同的对象；在作者的笔记本电脑上，它的id = `4297537984`。这样可以节省很多2对象的副本占用内存。
- en: 'Here''s a little trick for seeing exactly how huge a number is:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个查看一个数字有多大的小技巧：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We created a string from a calculated number. Then we asked what the length
    of the string was. The response tells us that the number had 617 digits.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个计算出的数字创建了一个字符串。然后我们询问字符串的长度。响应告诉我们这个数字有617位。
- en: There's more...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Python offers us a broad set of arithmetic operators: `+` , `-` , `*` , `/`
    , `//` , `%` , and `**` . The `/` and `//` are for division; we''ll look at these
    in a separate recipe named *Choosing between true division and floor division*
    . The `**` raises a number to a power.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了一套广泛的算术运算符：`+`，`-`，`*`，`/`，`//`，`%`和`**`。`/`和`//`用于除法；我们将在一个名为*在真除法和地板除法之间进行选择*的单独配方中查看这些。`**`将一个数提高到幂。
- en: For dealing with individual bits, we have some additional operations. We can
    use `&` , `^` , `|` , `<<` , and `>>` . These operators work bit-by-bit on the
    internal binary representations of integers. These compute a binary **AND** ,
    a binary **Exclusive OR** , I **nclusive OR** , **Left Shift** , and **Right Shift**
    respectively.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理单个位，我们有一些额外的操作。我们可以使用`&`，`^`，`|`，`<<`和`>>`。这些运算符在整数的内部二进制表示上逐位运算。这些分别计算二进制**AND**，二进制**异或**，**或**，**左移**和**右移**。
- en: While these will work on very big integers, they don't really make much sense
    outside the world of individual bytes. Some binary files and network protocols
    will involve looking at the bits within an individual byte of data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些将适用于非常大的整数，但在个别字节的世界之外，它们实际上并没有太多意义。一些二进制文件和网络协议将涉及查看数据的单个字节中的位。
- en: We can play around with these operators by using the `bin()` function to see
    what's going on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`bin()`函数来玩弄这些运算符，看看发生了什么。
- en: 'Here''s a quick example of what we mean:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速的例子：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've used `0b0011` and `0b0101` as our two strings of bits. This helps to clarify
    precisely what the two numbers have as their binary representation. We applied
    the exclusive or (`^` ) operator to these two sequences of bits. We used the `bin()`
    function to see the result as a string of bits. We can carefully line up the bits
    to see what the operator did.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`0b0011`和`0b0101`作为我们的两个比特字符串。这有助于准确地澄清这两个数字的二进制表示。我们对这两个比特序列应用了异或（`^`）运算符。我们使用`bin()`函数将结果作为比特字符串查看。我们可以仔细地对齐比特，看看运算符做了什么。
- en: 'We can decompose a byte into portions. Say we want to separate the left-most
    two bits from the other six bits. One way to do this is with bit-fiddling expressions
    like these:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一个字节分解成几部分。假设我们想要将最左边的两位与其他六位分开。一种方法是使用这样的位操作表达式：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We've defined a composite byte which has `01` in the most significant two bits,
    and `101100` in the least significant six bits. We used the `>>` shift operator
    to shift the value by six positions, removing the least significant bits and preserving
    the two most significant bits. We used the `&` operator with a mask. Where the
    mask has 1 bit, a position's value is preserved in the result, where a mask has
    `0` bits, the result position is set to `0` .
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个复合字节，其中最高的两位是`01`，最低的六位是`101100`。我们使用`>>`移位运算符将该值向右移动六个位置，删除最低有效位并保留最高的两位。我们使用了一个掩码的`&`运算符。掩码中有1位时，结果中保留了位置的值，掩码中有`0`位时，结果位置设置为`0`。
- en: See also
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We'll look at the two division operators in the *Choosing between true division
    and floor division* recipe
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在*在真除法和地板除法之间进行选择*配方中查看两个除法运算符
- en: We'll look at other kinds of numbers in the *Choosing between float, decimal,
    and fraction* recipe
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在*在浮点数、十进制和分数之间进行选择*配方中查看其他类型的数字
- en: For details on integer processing, see [https://www.python.org/dev/peps/pep-0237/](https://www.python.org/dev/peps/pep-0237/)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关整数处理的详细信息，请参见[https://www.python.org/dev/peps/pep-0237/](https://www.python.org/dev/peps/pep-0237/)
- en: Choosing between float, decimal, and fraction
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浮点数、十进制和分数之间进行选择
- en: 'Python offers us several ways to work with rational numbers and approximations
    of irrational numbers. We have three basic choices:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了几种处理有理数和无理数近似的方法。我们有三种基本选择：
- en: Float
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数
- en: Decimal
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制
- en: Fraction
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分数
- en: With so many choices, when do we use each of these?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这么多选择，我们什么时候使用每种选择呢？
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: It's important to be sure about our core mathematical expectations. If we're
    not sure what kind of data we have, or what kinds of results we want to get, we
    really shouldn't be coding. We need to take a step back and review things with
    pencil and paper.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 确定我们的核心数学期望是很重要的。如果我们不确定我们有什么样的数据，或者我们想要得到什么样的结果，我们真的不应该编码。我们需要退一步，用铅笔和纸重新审视事情。
- en: 'There are three general cases for math that involve numbers beyond integers,
    which are:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及超出整数的数字的数学有三种一般情况，即：
- en: '**Currency** : Dollars, cents, or euros. Currency generally has a fixed number
    of decimal places. There are rounding rules used to determine what 7.25% of $2.95
    is.'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 货币：美元、分或欧元。货币通常有固定的小数位数。有舍入规则用于确定7.25%的$2.95是多少。
- en: '**Rational Numbers or Fractions** : When we''re working with American units
    for feet and inches, or cooking measurements in cups and fluid ounces, we often
    need to work in fractions. When we scale a recipe that serves eight, for example,
    down to five people, we''re doing fractional math using a scaling factor of 5/8
    . How do we apply this to 2/3 cup of rice and still get a measurement that fits
    an American kitchen gadget?'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有理数或分数：当我们使用英尺和英寸的美国单位，或者使用杯和液体盎司的烹饪度量时，我们经常需要使用分数。例如，当我们将为八个人的食谱缩小到五个人时，我们正在使用5/8的缩放因子进行分数运算。我们如何将这应用到2/3杯米饭，并且仍然得到一个适合美国厨房工具的度量？
- en: '**Irrational Numbers** : This includes all other kinds of calculations. It''s
    important to note that digital computers can only approximate these numbers, and
    we''ll occasionally see odd little artifacts of this approximation. The float
    approximations are very fast, but sometimes suffer from truncation issues.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无理数：这包括所有其他类型的计算。重要的是要注意，数字计算机只能近似这些数字，我们偶尔会看到这种近似的奇怪小瑕疵。浮点数近似非常快，但有时会遇到截断问题。
- en: When we have one of the first two cases, we should avoid floating-point numbers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有前两种情况之一时，我们应该避免使用浮点数。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll look at each of the three cases separately. First, we'll look at computing
    with currency. Then we'll look at rational numbers, and finally irrational or
    floating-point numbers. Finally, we'll look at making explicit conversions among
    these various types.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别查看这三种情况。首先，我们将看一下使用货币进行计算。然后我们将看一下有理数，最后是无理数或浮点数。最后，我们将看一下在这些各种类型之间进行明确转换。
- en: Doing currency calculations
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进行货币计算
- en: When working with currency, we should always use the `decimal` module. If we
    try to use Python's built-in `float` values, we'll have problems with rounding
    and truncation of numbers.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理货币时，我们应该始终使用`decimal`模块。如果我们尝试使用Python内置的`float`值，我们将遇到舍入和截断数字的问题。
- en: 'To work with currency, we''ll do this. Import the `Decimal` class from the
    `decimal` module:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要处理货币，我们将这样做。从`decimal`模块导入`Decimal`类：
- en: '[PRE17]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create `Decimal` objects from strings or integers:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串或整数创建`Decimal`对象：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We created the `tax_rate` from two `Decimal` objects. One was based on a string,
    the other based on an integer. We could have used `Decimal('0.0725')` instead
    of doing the division explicitly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从两个`Decimal`对象创建了`tax_rate`。一个是基于字符串的，另一个是基于整数的。我们可以使用`Decimal('0.0725')`而不是显式地进行除法。
- en: The result is a hair over $0.21\. It's computed out correctly to the full number
    of decimal places.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是超过$0.21。它被正确计算到了完整的小数位数。
- en: 'If you try to create decimal objects from floating-point values, you''ll see
    unpleasant artifacts of float approximations. Avoid mixing `Decimal` and `float`
    . To round to the nearest penny, create a `penny` object:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尝试从浮点数值创建十进制对象，您将看到浮点数近似的不愉快的副作用。避免混合`Decimal`和`float`。要舍入到最接近的一分钱，创建一个`penny`对象：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Quantize your data using this penny object:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个penny对象对数据进行量化：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This shows how we can use the default rounding rule of `ROUND_HALF_EVEN` .
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了我们如何使用`ROUND_HALF_EVEN`的默认舍入规则。
- en: 'Every financial wizard has a different style of rounding. The `Decimal` module
    offers every variation. We might, for example, do something like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 每个财务巫师都有不同的舍入风格。`Decimal`模块提供了每种变化。例如，我们可能会做这样的事情：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This shows the consequences of using a different rounding rule.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了使用不同的舍入规则的后果。
- en: Fraction calculations
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分数计算
- en: 'When we''re doing calculations that have exact fraction values, we can use
    the `fractions` module. This provides us handy rational numbers that we can use.
    To work with fractions, we’ll do this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行具有精确分数值的计算时，我们可以使用`fractions`模块。这为我们提供了方便的有理数，我们可以使用。要处理分数，我们将这样做：
- en: 'Import the `Fraction` class from the `fractions` module:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`fractions`模块导入`Fraction`类：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create `Fraction` objects from strings, integers, or pairs of integers. If
    you create fraction objects from floating-point values, you may see unpleasant
    artifacts of float approximations. When the denominator is a power of 2, things
    can work out exactly:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串、整数或整数对创建`Fraction`对象。如果从浮点数值创建分数对象，可能会看到浮点数近似的不愉快的副作用。当分母是2的幂时，事情可能会完全解决：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We created one fraction from a string, `2.5` . We created the second fraction
    from a floating-point calculation, `5/8` . Because the denominator is a power
    of 2, this works out exactly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个字符串`2.5`创建了一个分数。我们从一个浮点计算`5/8`创建了第二个分数。因为分母是2的幂，这完全解决了。
- en: The result, 25/16, is a complex-looking fraction. What's a nearby fraction that
    might be simpler?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 结果25/16是一个看起来复杂的分数。附近可能更简单的分数是什么？
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can see that we'll use almost a cup and a half to scale the recipe for five
    people instead of eight.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们将使用将近一杯半来将为八个人的食谱缩小到五个人。
- en: Floating-point approximations
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点数近似
- en: Python's built-in `float` type is capable of representing a wide variety of
    values. The trade-off here is that float often involves an approximation. In some
    cases—specifically when doing division that involves powers of 2—it can be as
    exact as a `fraction` . In all other cases, there may be small discrepancies that
    reveal the differences between the implementation of `float` and the mathematical
    ideal of an irrational number.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Python的内置`float`类型能够表示各种各样的值。这里的权衡是，float通常涉及近似值。在某些情况下——特别是在涉及2的幂的除法时，它可以像`fraction`一样精确。在所有其他情况下，可能会有一些小的差异，揭示了`float`的实现和无理数的数学理想之间的差异。
- en: 'To work with `float` , we often need to round values to make them look sensible.
    Recognize that all calculations are an approximation:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`float`，我们经常需要四舍五入值使其看起来合理。请认识到所有计算都是近似值：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Mathematically, the value should be `1` . Because of the approximations used
    for `float` , the answer isn''t exact. It''s not wrong by much, but it''s wrong.
    When we round appropriately, the value is more useful:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数学上讲，该值应为`1`。由于`float`的近似值，答案并不精确。它并不错得很多，但是错了。当我们适当四舍五入时，该值更有用：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Know the error term. In this case, we know what the exact answer is supposed
    to be, so we can compare our calculation with the known correct answer. This gives
    us the general error value that can creep into floating-point numbers:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 了解误差项。在这种情况下，我们知道应该是什么精确答案，所以我们可以将我们的计算与已知的正确答案进行比较。这给了我们可能会渗入浮点数的一般误差值：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For most floating-point errors, this is the typical value—about 10^(-16) . Python
    has clever rules that hide this error some of the time by doing some automatic
    rounding. For this calculation, however, the error wasn't hidden.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数浮点错误，这是典型值——约为10^(-16)。Python有巧妙的规则，通过一些自动四舍五入来隐藏这种错误。然而，对于这个计算，错误并没有被隐藏。
- en: This is a very important consequence.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的结果。
- en: Tip
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't compare floating-point values for exact equality.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将浮点值进行精确相等的比较。
- en: When we see code that uses an exact `==` test between floating-point numbers,
    there are going to be problems when the approximations differ by a single bit.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到使用浮点数之间的精确`==`测试的代码时，当近似值相差一个位时，就会出现问题。
- en: Converting numbers from one type to another
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数字从一种类型转换为另一种类型
- en: 'We can use the `float()` function to create a `float` value from another value.
    It looks like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`float()`函数从另一个值创建一个`float`值。它看起来像这样：
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the first example, we converted a `Decimal` value to `float` . In the second
    example, we converted a `Fraction` value to `float` .
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们将`Decimal`值转换为`float`。在第二个示例中，我们将`Fraction`值转换为`float`。
- en: 'As we just saw, we''re never happy trying to convert `float` to `Decimal` or
    `Fraction` :'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才看到的，我们永远无法将`float`转换为`Decimal`或`Fraction`：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the first example, we did a calculation among integers to create a `float`
    value that has a known truncation problem. When we created a `Fraction` from that
    truncated `float` value, we got some terrible looking numbers that exposed the
    details of the truncation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们进行了整数之间的计算，以创建一个已知截断问题的`float`值。当我们从该截断的`float`值创建一个`Fraction`时，我们得到了一些暴露了截断细节的可怕数字。
- en: Similarly, the second example tried to create a `Decimal` value from a `float`
    .
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，第二个示例试图从`float`创建一个`Decimal`值。
- en: How it works...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'For these numeric types, Python offers us a variety of operators: `+` , `-`
    , `*` , `/` , `//` , `%` , and `**` . These are for addition, subtraction, multiplication,
    true division, truncated division, modulus, and raising to a power. We''ll look
    at the two division operators in the *Choosing between true division and floor
    division* recipe.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些数字类型，Python为我们提供了各种运算符：`+`，`-`，`*`，`/`，`//`，`%`和`**`。这些是用于加法、减法、乘法、真除法、截断除法、模数和乘方的。我们将在*选择真除法和地板除法*的示例中查看这两个除法运算符。
- en: Python is adept at converting numbers between the various types. We can mix
    `int` and `float` values; the integers will be promoted to floating-point to provide
    the most accurate answer possible. Similarly, we can mix `int` and `Fraction`
    and the results will be `Fractions` . We can also mix `int` and `Decimal` . We
    cannot casually mix `Decimal` with `float` or `Fraction` ; we need to provide
    explicit conversions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Python擅长在各种类型之间转换数字。我们可以混合`int`和`float`值；整数将被提升为浮点以提供尽可能准确的答案。同样，我们可以混合`int`和`Fraction`，结果将是`Fractions`。我们也可以混合`int`和`Decimal`。我们不能随意混合`Decimal`和`float`或`Fraction`；我们需要提供显式转换。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to note that `float` values are really approximations. The Python
    syntax allows us to write numbers as decimal values; that's not how they're processed
    internally.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`float`值实际上是近似值。Python语法允许我们将数字写成小数值；这不是它们在内部处理的方式。
- en: 'We can write a value like this in Python, using ordinary base-10 values:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Python中写出这样的值，使用普通的十进制值：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The actual value used internally will involve a binary approximation of the
    decimal value we wrote.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 内部使用的实际值将涉及我们写的十进制值的二进制近似值。
- en: 'The internal value for this example, `8.066e+67` , is this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的内部值`8.066e+67`是这样的：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The numerator is a big number, `6737037547376141` . The denominator is always
    *2^(53)* . Since the denominator is fixed, the resulting fraction can only have
    53 meaningful bits of data. Since more bits aren't available, values might get
    truncated. This leads to tiny discrepancies between our idealized abstraction
    and actual numbers. The exponent ( *2^(226)* ) is required to scale the fraction
    up to the proper range.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 分子是一个大数，`6737037547376141`。分母始终是*2^(53)*。由于分母是固定的，结果分数只能有53个有意义的数据位。由于没有更多的位可用，值可能会被截断。这导致我们理想化抽象和实际数字之间的微小差异。指数（*2^(226)*）是将分数放大到适当范围所必需的。
- en: Mathematically, 6737037547376141 * 2^(226) /2^(53) .
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，6737037547376141 * 2^(226) /2^(53)。
- en: 'We can use `math.frexp()` to see these internal details of a number:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`math.frexp()`来查看数字的这些内部细节：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The two parts are called the **mantissa** and the **exponent** . If we multiply
    the mantissa by *2^(53)* , we always get a whole number, which is the numerator
    of the binary fraction.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这两部分被称为**尾数**和**指数**。如果我们将尾数乘以*2^(53)*，我们总是得到一个整数，这是二进制分数的分子。
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The error we noticed earlier matches this quite nicely: 10^(-16) ≈ 2^(-53)
    .'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前注意到的误差非常匹配：10^(-16) ≈ 2^(-53)。
- en: Unlike the built-in `float` , a `Fraction` is an exact ratio of two integer
    values. As we saw in the *Working with large and small integers* recipe, integers
    in Python can be very large. We can create ratios which involve integers with
    a large number of digits. We're not limited by a fixed denominator.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与内置的`float`不同，`Fraction`是两个整数值的精确比率。正如我们在*使用大整数和小整数*配方中看到的，Python中的整数可以非常大。我们可以创建涉及具有大量数字的整数的比率。我们不受固定分母的限制。
- en: A `Decimal` value, similarly, is based on a very large integer value, and a
    scaling factor to determine where the decimal place goes. These numbers can be
    huge and won't suffer from peculiar representation issues.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`Decimal`值是基于一个非常大的整数值和一个缩放因子来确定小数点的位置。这些数字可以非常庞大，并且不会受到奇怪的表示问题的影响。
- en: Note
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Why use floating-point? Two reasons** :'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么使用浮点数？两个原因**：'
- en: Not all computable numbers can be represented as fractions. That's why mathematicians
    introduced (or perhaps discovered) irrational numbers. The built-in float type
    is as close as we can get to the mathematical abstraction of irrational numbers.
    A value like √2, for example, can't be represented as a fraction.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有可计算的数字都可以表示为分数。这就是为什么数学家引入（或者也许是发现）无理数的原因。内置的浮点类型是我们可以接近数学抽象的无理数的方式。例如，像√2这样的值不能表示为分数。
- en: Also, float values are very fast.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，浮点值非常快。
- en: There's more...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Python `math` module contains a number of specialized functions for working
    with floating-point values. This module includes common functions such as square
    root, logarithms, and various trigonometry functions. It has some other functions
    such as gamma, factorial, and the Gaussian error function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`math`模块包含了许多专门用于处理浮点数值的函数。这个模块包括了常见的函数，比如平方根、对数和各种三角函数。它还有一些其他函数，比如gamma、阶乘和高斯误差函数。
- en: The `math` module includes several functions that can help us do more accurate
    floating-point calculations. For example, the `math.fsum()` function will compute
    a floating-point sum more carefully than the built-in `sum()` function. It's less
    susceptible to approximation issues.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`math`模块包括几个函数，可以帮助我们进行更准确的浮点计算。例如，`math.fsum()`函数将比内置的`sum()`函数更谨慎地计算浮点和。它不太容易受到近似问题的影响。'
- en: 'We can also make use of the `math.isclose()` function to compare two floating-point
    values to see if they''re nearly equal:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以利用`math.isclose()`函数来比较两个浮点值，看它们是否几乎相等：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This function provides us with a way to compare floating-point numbers meaningfully.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数为我们提供了一种有意义地比较浮点数的方法。
- en: Python also offers complex data. This involves a real and an imaginary part.
    In Python, we write `3.14+2.78j` to represent the complex number 3.14 + 2.78 √-1\.
    Python will comfortably convert between float and complex. We have the usual group
    of operators available for complex numbers.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Python还提供了复数数据。这涉及到一个实部和一个虚部。在Python中，我们写`3.14+2.78j`来表示复数3.14 + 2.78 √-1。Python可以很舒适地在浮点数和复数之间转换。我们有一组通常的操作符可用于复数。
- en: 'To support complex numbers, there''s a `cmath` package. The `cmath.sqrt()`
    function, for example, will return a complex value rather than raise an exception
    when extracting the square root of a negative number. Here''s an example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持复数，有一个`cmath`包。例如，`cmath.sqrt()`函数将返回一个复数值，而不是在提取负数的平方根时引发异常。这里有一个例子：
- en: '[PRE34]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is essential when working with complex numbers.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这在处理复数时是必不可少的。
- en: See also
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We'll talk more about floating point and fractions in the *Choosing between
    true division and floor division* recipe
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在*在真除法和地板除法之间进行选择*配方中更多地讨论浮点数和分数
- en: See [https://en.wikipedia.org/wiki/IEEE_floating_point](https://en.wikipedia.org/wiki/IEEE_floating_point)
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见[https://en.wikipedia.org/wiki/IEEE_floating_point](https://en.wikipedia.org/wiki/IEEE_floating_point)
- en: Choosing between true division and floor division
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在真除法和地板除法之间进行选择
- en: Python offers us two kinds of division operators. What are they, and how do
    we know which one to use? We'll also look at the Python division rules and how
    they apply to integer values.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了两种类型的除法运算符。它们是什么，我们如何知道该使用哪一个？我们还将看一下Python的除法规则以及它们如何适用于整数值。
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There are several general cases for doing division:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种一般情况可以进行除法：
- en: 'A *div-mod* pair: We want two parts—the quotient and the remainder. We often
    use this when converting values from one base to another. When we convert seconds
    to hours, minutes, and seconds, we''ll be doing a *div-mod* kind of division.
    We don''t want the exact number of hours, we want a truncated number of hours,
    the remainder will be converted to minutes and seconds.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*div-mod*对：我们想要两部分——商和余数。当我们将值从一种基数转换为另一种基数时，我们经常使用这种方法。当我们将秒转换为小时、分钟和秒时，我们将进行*div-mod*类型的除法。我们不想要准确的小时数，我们想要截断的小时数，余数将被转换为分钟和秒。
- en: 'The *true* value: This is a typical floating-point value—it will be a good
    approximation to the quotient. For example, if we''re computing an average of
    several measurements, we usually expect the result to be floating-point, even
    if the input values are all integers.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*真实*值：这是典型的浮点值——它将是商的一个很好的近似值。例如，如果我们计算几个测量的平均值，我们通常希望结果是浮点数，即使输入值都是整数。'
- en: 'A *rational fraction* value: This is often necessary when working in American
    units of feet, inches, and cups. For this, we should be using the `Fraction` class.
    When we divide `Fraction` objects, we always get exact answers.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*有理分数*值：这在使用英尺、英寸和杯的美国单位时经常需要。对于这一点，我们应该使用`Fraction`类。当我们除以`Fraction`对象时，我们总是得到精确的答案。
- en: We need to decide which of these cases apply, so we know which division operator
    to use.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要决定哪些情况适用，这样我们就知道要使用哪个除法运算符。
- en: How to do it...
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We'll look at the three cases separately. First we'll look at truncated floor
    division. Then we'll look at true floating-point division. Finally, we'll look
    at division of fractions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别查看三种情况。首先我们将查看截断的地板除法。然后我们将查看真正的浮点除法。最后，我们将查看分数的除法。
- en: Doing floor division
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进行地板除法
- en: When we are doing the *div-mod* kind of calculations, we might use floor division,
    `//` , and modulus, `%` . Or, we might use the `divmod()` function.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行*div-mod*类型的计算时，我们可能会使用地板除法，`//`，和模数，`%`。或者，我们可以使用`divmod()`函数。
- en: 'We''ll divide the number of seconds by 3600 to get the value of `hours` ; the
    modulus, or remainder, can be converted separately to `minutes` and `seconds`
    :'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把秒数除以3600得到`小时`的值；余数可以分别转换为`分钟`和`秒`：
- en: '[PRE35]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Again, using remaining values, we''ll divide the number of seconds by 60 to
    get `minutes` ; the remainder is a number of seconds less than 60:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用剩余值，我们将把秒数除以60得到`分钟`；余数是小于60的秒数：
- en: '[PRE36]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here''s the alternative, using the `divmod()` function:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种方法，使用`divmod()`函数：
- en: 'Compute quotient and remainder at the same time:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同时计算商和余数：
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Compute quotient and remainder again:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次计算商和余数：
- en: '[PRE38]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Doing true division
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进行真正的除法
- en: 'A true value calculation gives as a floating-point approximation. For example,
    about how many hours is 7386 seconds? Divide using the true division operator:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 真值计算给出一个浮点近似值。例如，7386秒大约是多少小时？使用真正的除法运算符进行除法：
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We provided two integer values, but got a floating-point exact result. Consistent
    with our previous recipe for using floating-point values, we rounded the result
    to avoid having to look at tiny error values.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了两个整数值，但得到了一个浮点数的精确结果。与我们之前使用浮点数值的配方一致，我们四舍五入了结果，以避免查看微小的误差值。
- en: This true division is a feature of Python 3\. We'll look at this from a Python
    2 perspective in the next sections.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这种真正的除法是Python 3的一个特性。我们将在接下来的章节中从Python 2的角度来看这一点。
- en: Rational fraction calculations
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有理数分数计算
- en: 'We can do division using `Fraction` objects and integers. This forces the result
    to be a mathematically exact rational number:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Fraction`对象和整数进行除法。这将强制结果成为一个数学上精确的有理数：
- en: 'Create at least one `Fraction` value:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建至少一个`Fraction`值：
- en: '[PRE40]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Use the `Fraction` value in a calculation. Any integer will be promoted to
    a `Fraction` :'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在计算中使用`Fraction`值。任何整数都将被提升为`Fraction`：
- en: '[PRE41]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If necessary, convert the exact fraction to a floating-point approximation:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果必要，将精确分数转换为浮点数近似值：
- en: '[PRE42]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, we created a `Fraction` object for the total number of seconds. When
    we do arithmetic on fractions, Python will promote any integers to be fractions;
    this promotion means that the math is done as exactly as possible.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为总秒数创建了一个`Fraction`对象。当我们对分数进行算术运算时，Python会将任何整数提升为分数；这种提升意味着尽可能精确地进行数学运算。
- en: How it works...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Python 3 has two division operators.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3有两个除法运算符。
- en: The `/` true division operator always tries to produce a true, floating-point
    result. It does this even when the two operands are integers. This is an unusual
    operator in this respect. All other operators try to preserve the type of the
    data. The true division operation - when applied to integers - produces a `float`
    result.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`真正的除法运算符总是尝试产生一个真正的浮点结果。即使两个操作数是整数，它也会这样做。在这方面，这是一个不寻常的运算符。所有其他运算符都试图保留数据的类型。真正的除法操作-当应用于整数时-产生一个`float`结果。'
- en: 'The `//` truncated division operator always tries to produce a truncated result.
    For two integer operands, this is the truncated quotient. For two floating-point
    operands, this is a truncated floating-point result:'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`//`截断除法运算符总是尝试产生一个截断的结果。对于两个整数操作数，这是截断的商。对于两个浮点操作数，这是一个截断的浮点结果：'
- en: '[PRE43]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'By default, Python 2 only has one division operator. For programmers still
    using Python 2, we can start using these new division operators with this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Python 2只有一个除法运算符。对于仍在使用Python 2的程序员，我们可以开始使用这些新的除法运算符：
- en: '[PRE44]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This import will install the Python 3 division rules.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导入将安装Python 3除法规则。
- en: See also
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more on the choice between floating-point and fractions, see the *Choosing
    between float, decimal, and fraction* recipe
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关浮点数和分数之间的选择，请参阅*在浮点数、小数和分数之间进行选择*配方
- en: See [https://www.python.org/dev/peps/pep-0238/](https://www.python.org/dev/peps/pep-0238/)
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[https://www.python.org/dev/peps/pep-0238/](https://www.python.org/dev/peps/pep-0238/)
- en: Rewriting an immutable string
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重写一个不可变的字符串
- en: 'How can we rewrite an immutable string? We can''t change individual characters
    inside a string:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如何重写一个不可变的字符串？我们无法改变字符串内部的单个字符：
- en: '[PRE45]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Since this doesn't work, how do we make a change to a string?
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这不起作用，我们如何对字符串进行更改？
- en: Getting ready
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: 'Let''s assume we have a string like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有这样一个字符串：
- en: '[PRE46]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We''d like to do two transformations:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想做两个转换：
- en: Remove the part before the `:`
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除`:`之前的部分
- en: Replace the punctuation with `_` , and make all the characters lowercase
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用`_`替换标点符号，并将所有字符转换为小写
- en: 'Since we can''t replace characters in a string object, we have to work out
    some alternatives. There are several common things we can do, shown as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法替换字符串对象中的字符，我们必须想出一些替代方案。以下是一些常见的事情，如下所示：
- en: A combination of slicing and concatenating a string to create a new string.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用切片和连接字符串的组合来创建一个新的字符串。
- en: When shortening, we often use the `partition()` method.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在缩短时，我们经常使用`partition()`方法。
- en: We can replace a character or a substring with the `replace()` method.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以用`replace()`方法替换一个字符或子字符串。
- en: We can expand the string into a list of characters, then join the string back
    into a single string again. This is the subject for a separate recipe, *Building
    complex strings with a list of characters* .
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将字符串扩展为字符列表，然后再次将字符串连接成单个字符串。这是一个单独配方的主题，*使用字符列表构建复杂字符串*。
- en: How to do it...
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Since we can''t update a string in place, we have to replace the string variable''s
    object with each modified result. We''ll use a statement that looks like this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法直接更新字符串，因此必须用每个修改后的结果替换字符串变量的对象。我们将使用类似于以下的语句：
- en: '[PRE47]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Or we could even use:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们甚至可以使用：
- en: '[PRE48]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We'll look at a number of specific variations on this general theme. We'll slice
    a piece of a string, we'll replace individual characters within a string, and
    we'll apply blanket transformations such as making the string lowercase. We'll
    also look at ways to remove extra `_` that show up in our final string.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一些特定变体的这个一般主题。我们将切片字符串的一部分，我们将替换字符串中的单个字符，并且我们将应用像使字符串小写之类的全面转换。我们还将看看如何删除出现在最终字符串中的额外的“_”。
- en: Slicing a piece of a string
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切片字符串的一部分
- en: 'Here''s how we can shorten a string via slicing:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何通过切片缩短字符串：
- en: 'Find the boundary:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到边界：
- en: '[PRE49]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The index function locates a particular substring and returns the position where
    that substring can be found. If the substring doesn't exist, it raises an exception.
    This is always `true` of the result `title[colon_position] == ':'` .
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 索引函数定位特定的子字符串并返回该子字符串的位置。如果子字符串不存在，它会引发一个异常。这总是`true`的结果`title[colon_position]
    == ':'`。
- en: 'Pick the substring:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择子字符串：
- en: '[PRE50]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We've used the slicing notation to show the `start:end` of the characters to
    pick. We also used multiple assignment to assign two variables, `discard_text`
    and `post_colon_text` , from two expressions.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用切片表示法显示要选择的字符的“start:end”。我们还使用多重赋值从两个表达式中分配两个变量`discard_text`和`post_colon_text`。
- en: 'We can use `partition()` as well as manual slicing. Find the boundary and partition:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`partition()`以及手动切片。找到边界并分区：
- en: '[PRE51]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `partition` function returns three things: the part before the target,
    the target, and the part after the target. We used multiple assignment to assign
    each object to a different variable. We assigned the target to a variable named
    `_` because we''re going to ignore that part of the result. This is a common idiom
    for places where we must provide a variable, but we don''t care about using the
    object.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`partition`函数返回三个东西：目标之前的部分，目标和目标之后的部分。我们使用多重赋值将每个对象分配给不同的变量。我们将目标分配给一个名为“_”的变量，因为我们将忽略结果的这一部分。这是一个常见的习惯用法，用于我们必须提供一个变量的地方，但我们不关心使用该对象。'
- en: Updating a string with a replacement
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用替换更新字符串
- en: 'We can use `replace()` to remove punctuation marks. When using `replace` to
    switch punctuation marks, save the results back into the original variable. In
    this case, `post_colon_text` :'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`replace()`来删除标点符号。在使用`replace`切换标点符号时，将结果保存回原始变量。在这种情况下，`post_colon_text`：
- en: '[PRE52]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This has replaced the two kinds of punctuation with the desired `_` characters.
    We can generalize this to work with all punctuation. This leverages the `for`
    statement, which we'll look at in [Chapter 2](text00027.html#page "Chapter 2. Statements
    and Syntax") , *Statements and Syntax* .
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经用所需的“_”字符替换了两种标点符号。我们可以将其推广到所有标点符号。这利用了“for”语句，我们将在[第2章](text00027.html#page
    "第2章。语句和语法")中进行讨论，*语句和语法*。
- en: 'We can iterate through all punctuation characters:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遍历所有标点字符：
- en: '[PRE53]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As each kind of punctuation character is replaced, we assign the latest and
    greatest version of the string to the `post_colon_text` variable.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 当每种标点符号字符被替换时，我们将最新和最好的字符串版本分配给`post_colon_text`变量。
- en: Making a string all lowercase
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使字符串全部小写
- en: 'Another transformational step is changing a string to all lowercase. As with
    the previous examples, we''ll assign the results back to the original variable.
    Use the `lower()` method, assigning the result to the original variable:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个转换步骤是将字符串更改为全部小写。与前面的例子一样，我们将结果分配回原始变量。使用`lower()`方法，将结果分配给原始变量：
- en: '[PRE54]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Removing extra punctuation marks
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除额外的标点符号
- en: 'In many cases, there are some additional steps we might follow. We often want
    to remove leading and trailing `_` characters. We can use `strip()` for this:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们可能会遵循一些额外的步骤。我们经常希望删除前导和尾随的“_”字符。我们可以使用`strip()`来实现这一点：
- en: '[PRE55]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In some cases, we''ll have multiple `_` characters because we had multiple
    punctuation marks. The final step would be something like this to cleanup up multiple
    `_` characters:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能会有多个“_”字符，因为我们有多个标点符号。最后一步将是这样清理多个“_”字符：
- en: '[PRE56]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is yet another example of the same pattern we've been using to modify a
    string in place. This depends on the `while` statement, which we'll look at in
    [Chapter 2](text00027.html#page "Chapter 2. Statements and Syntax") , *Statements
    and Syntax* .
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个例子，我们一直在使用相同的模式来修改字符串。这取决于“while”语句，我们将在[第2章](text00027.html#page "第2章。语句和语法")中进行讨论，*语句和语法*。
- en: How it works...
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We can't—technically—modify a string in place. The data structure for a string
    is immutable. However, we can assign a new string back to the original variable.
    This technique behaves the same as modifying a string in place.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们不能直接修改字符串。字符串的数据结构是不可变的。但是，我们可以将新的字符串赋回原始变量。这种技术的行为与直接修改字符串相同。
- en: 'When a variable''s value is replaced, the previous value no longer has any
    references and is garbage collected. We can see this by using the `id()` function
    to track each individual string object:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量的值被替换时，先前的值不再有任何引用，并且被垃圾回收。我们可以通过使用`id()`函数跟踪每个单独的字符串对象来看到这一点：
- en: '[PRE57]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Your actual id numbers may be different. What's important is that the original
    string object assigned to `post_colon_text` had one id. The new string object
    assigned to `post_colon_text` has a different id. It's a new string object.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您的实际ID号可能不同。重要的是，分配给`post_colon_text`的原始字符串对象具有一个ID。分配给`post_colon_text`的新字符串对象具有不同的ID。这是一个新的字符串对象。
- en: When the old string has no more references, it is removed from memory automatically.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当旧字符串没有更多引用时，它会自动从内存中删除。
- en: 'We made use of **slice notation** to decompose a string. A slice has two parts:
    `[start:end]` . A slice always includes the starting index. String indices always
    start with zero as the first item. It never includes the ending index.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了**切片表示法**来分解字符串。切片有两部分：`[start:end]`。切片始终包括起始索引。字符串索引始终从零开始作为第一项。它永远不包括结束索引。
- en: Tip
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The items in a slice have an index from `start` to `end-1` . This is sometimes
    called a **half-open** interval.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 切片中的项目从`start`到`end-1`具有索引。有时这被称为**半开放**区间。
- en: 'Think of a slice like this: all characters where the index, *i* , are in the
    range *start ≤ i* < *end* .'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下切片是这样的：所有的字符都在索引*i*的范围内*start ≤ i* < *end*。
- en: 'We noted briefly that we can omit the start or end indices. We can actually
    omit both. Here are the various options available:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要提到我们可以省略开始或结束索引。我们实际上可以两者都省略。以下是各种可用的选项：
- en: '`title[colon_position]` : A single item, the `:` we found using `title.index('':'')`
    .'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title[colon_position]`：一个单独的项目，我们使用`title.index('':'')`找到的`:`。'
- en: '`title[:colon_position]` : A slice with the start omitted. It begins at the
    first position, index of zero.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title[:colon_position]`：省略了开始。它从第一个位置开始，索引为零。'
- en: '`title[colon_position+1:]` : A slice with the end omitted. It ends at the end
    of the string, as if we said `len(title)` .'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title[colon_position+1:]`：省略了结束。它以字符串的结束结束，就好像我们说`len(title)`一样。'
- en: '`title[:]` : Since both start and end are omitted, this is the entire string.
    Actually, it''s a *copy* of the entire string. This is the quick and easy way
    to duplicate a string.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title[:]`：由于开始和结束都被省略了，这是整个字符串。实际上，这是整个字符串的*副本*。这是复制字符串的快速简单方法。'
- en: There's more...
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are more features to indexing in Python collections like a string. The
    normal indices start with 0 at the left end. We have an alternate set of indices
    using negative names that work from the right end of a string.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Python集合中的索引有更多特性，如字符串。正常索引从左端以0开始。我们有一组使用负名称的替代索引，从字符串的右端开始工作。
- en: '`title[-1]` is the last character in the title, `g`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title[-1]`是标题中的最后一个字符，`g`'
- en: '`title[-2]` is the next-to-last character, `n`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title[-2]`是倒数第二个字符，`n`'
- en: '`title[-6:]` is the last six characters, `String`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`title[-6:]`是最后六个字符，`String`'
- en: We have a lot of ways to pick pieces and parts out of a string.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多方法可以从字符串中选择片段和部分。
- en: Python offers dozens of methods for modifying a string. *Section 4.7* of the
    *Python Standard Library* describes the different kinds of transformations that
    are available to us. There are three broad categories of string methods. We can
    ask about a string, we can parse a string, and we can transform a string. Methods
    such as `isnumeric()` tell us if a string is all digits.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了几十种修改字符串的方法。*Python标准库*的*第4.7节*描述了我们可以使用的不同类型的转换。字符串方法有三大类。我们可以询问字符串，我们可以解析字符串，我们可以转换字符串。例如，`isnumeric()`等方法告诉我们字符串是否全是数字。
- en: 'Here''s an example:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE58]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We've looked at parsing with the `partition()` method. And we've looked at transforming
    with the `lower()` method.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`partition()`方法进行了解析。我们已经使用`lower()`方法进行了转换。
- en: See also
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We'll look at the string as list technique for modifying a string in the *Building
    complex strings from lists of characters* recipe.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在*从字符列表构建复杂字符串*的示例中使用字符串作为列表的技术来修改字符串。
- en: Sometimes we have data that's only a stream of bytes. In order to make sense
    of it, we need to convert it into characters. That's the subject for the *Decoding
    bytes – how to get proper characters from some bytes* recipe.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时我们的数据只是一串字节。为了理解它，我们需要将其转换为字符。这是*解码字节-如何从一些字节中获取适当的字符*的主题。
- en: String parsing with regular expressions
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式进行字符串解析
- en: How do we decompose a complex string? What if we have complex, tricky punctuation?
    Or—worse yet—what if we don't have punctuation, but have to rely on patterns of
    digits to locate meaningful information?
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何分解复杂字符串？如果我们有复杂的、棘手的标点符号怎么办？或者更糟的是，如果我们没有标点符号，而必须依靠数字模式来定位有意义的信息怎么办？
- en: Getting ready
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The easiest way to decompose a complex string is by generalizing the string
    into a pattern and then writing a regular expression that describes that pattern.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 分解复杂字符串的最简单方法是将字符串泛化为模式，然后编写描述该模式的正则表达式。
- en: There are limits to the patterns that regular expressions can describe. When
    we're confronted with deeply-nested documents in a language like HTML, XML, or
    JSON, we often run into problems, and can't use regular expressions.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式可以描述的模式有限。当我们面对像HTML、XML或JSON这样的深度嵌套的文档时，我们经常遇到问题，无法使用正则表达式。
- en: The `re` module contains all of the various classes and functions we need to
    create and use regular expressions.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`re`模块包含了我们需要创建和使用正则表达式的各种类和函数。'
- en: 'Let''s say that we want to decompose text from a recipe website. Each line
    looks like this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要从食谱网站分解文本。每行看起来像这样：
- en: '[PRE59]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We want to separate the ingredient from the measurements.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要将成分与测量分开。
- en: How to do it...
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To write and use regular expressions, we often do this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写和使用正则表达式，我们经常这样做：
- en: 'Generalize the example. In our case, we have something that we can generalize
    as:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将示例泛化。在我们的情况下，我们有一些可以泛化的东西：
- en: '[PRE60]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We''ve replaced literal text with a two-part summary: what it means and how
    it''s represented. For example, ingredient is represented as words, amount is
    represented as digits. Import the `re` module:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用两部分摘要替换了文字：它的含义和它的表示方式。例如，成分表示为单词，数量表示为数字。导入`re`模块：
- en: '[PRE61]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Rewrite the pattern into **Regular Expression** ( **RE** ) notation:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模式重写为**正则表达式**（**RE**）表示法：
- en: '[PRE62]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We've replaced representation hints such as *words* with `\w+` . We've replaced
    *digits* with `\d+` . And we've replaced *single spaces* with `\s+` to allow one
    or more spaces to be used as punctuation. We've left the colon in place, because
    in the regular expression notation, a colon matches itself.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用`\w+`替换了*单词*等表示提示。我们用`\d+`替换了*数字*。我们用`\s+`替换了*单个空格*，以允许使用一个或多个空格作为标点符号。我们保留了冒号，因为在正则表达式符号中，冒号与自身匹配。
- en: For each of the fields of data, we've used `?P<name>` to provide a name that
    identifies the data we want to extract. We didn't do this around the colon or
    the spaces because we don't want those characters.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据的每个字段，我们使用了`?P<name>`来提供一个标识我们想要提取的数据的名称。我们没有在冒号或空格周围这样做，因为我们不想要这些字符。
- en: REs use a lot of `\` characters. To make this work out nicely in Python, we
    almost always use *raw* strings. The `r'` prefix tells Python not to look at the
    `\` characters and not to replace them with special characters that aren't on
    our keyboards.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: REs使用了很多`\`字符。为了使其在Python中工作得很好，我们几乎总是使用*原始*字符串。`r'`前缀告诉Python不要查看`\`字符，也不要用我们键盘上没有的特殊字符替换它们。
- en: 'Compile the pattern:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译模式：
- en: '[PRE63]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Match the pattern against input text. If the input matches the pattern, we''ll
    get a match object that shows details of the matching:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据输入文本匹配模式。如果输入与模式匹配，我们将得到一个显示匹配详细信息的匹配对象：
- en: '[PRE64]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This, by itself, is pretty cool: we have a tuple of the different fields within
    the string. We''ll return to the use of tuples in a recipe named *Using tuples*
    .'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这本身就很酷：我们有一个元组，其中包含字符串中的不同字段。我们将在名为*使用元组*的食谱中再次使用元组。
- en: 'Extract the named groups of characters from the match object:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从匹配对象中提取命名组的字符：
- en: '[PRE65]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Each group is identified by the name we used in the `(?P<name>...)` part of
    the RE.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组都由我们在RE的`(?P<name>...)`部分中使用的名称标识。
- en: How it works...
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are a lot of different kinds of string patterns that we can describe with
    RE.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用RE描述许多不同类型的字符串模式。
- en: 'We''ve shown a number of character classes:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了许多字符类：
- en: '`\w` matches any alphanumeric character (a to z, A to Z, 0 to 9)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\w`匹配任何字母数字字符（a到z，A到Z，0到9）'
- en: '`\d` matches any decimal digit'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\d`匹配任何十进制数字'
- en: '`\s` matches any space or tab character'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\s` 匹配任何空格或制表符'
- en: 'These classes also have inverses:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类也有反义：
- en: '`\W` matches any character that''s not a letter or a digit'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\W`匹配任何不是字母或数字的字符'
- en: '`\D` matches any character that''s not a digit'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\D`匹配任何不是数字的字符'
- en: '`\S` matches any character that''s not some kind of space or tab'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\S`匹配任何不是某种空格或制表符的字符'
- en: 'Many characters match themselves. Some characters, however, have special meaning,
    and we have to use `\` to escape from that special meaning:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 许多字符与自身匹配。然而，一些字符具有特殊含义，我们必须使用`\`来逃离这种特殊含义：
- en: We saw that `+` as a suffix means to match one or more of the preceeding patterns.
    `\d+` matches one or more digits. To match an ordinary `+` , we need to use `\+`
    .
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到`+`作为后缀意味着匹配一个或多个前面的模式。`\d+`匹配一个或多个数字。要匹配一个普通的`+`，我们需要使用`\+`。
- en: We also have `*` as a suffix which matches zero or more of the preceding patterns.
    `\w*` matches zero or more characters. To match a `*` , we need to use `\*` .
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有`*`作为后缀，它匹配零个或多个前面的模式。`\w*`匹配零个或多个字符。要匹配一个`*`，我们需要使用`\*`。
- en: We have `?` as a suffix which matches zero or one of the preceding expressions.
    This character is used in other places, and has a slightly different meaning.
    We saw it in `(?P<name>...)` where it was inside the `()` to define special properties
    for the grouping.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有`?`作为后缀，它匹配前面表达式的零次或一次。这个字符在其他地方也有用，意义略有不同。我们在`(?P<name>...)`中看到它，其中它在`()`内定义了分组的特殊属性。
- en: The `.` matches any single character. To match a `.` specifically, we need to
    use `\` .
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.`匹配任何单个字符。要匹配一个`.`，我们需要使用`\`。'
- en: 'We can create our own unique sets of characters using `[]` to enclose the elements
    of the set. We might have something like this:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`[]`来创建我们自己独特的字符集，以括起集合的元素。我们可能会有这样的东西：
- en: '[PRE66]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This has a `\w+` to match any number of alphanumeric characters. This will be
    collected into a group with the name of `name` .
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个`\w+`来匹配任意数量的字母数字字符。这将被收集到一个名为`name`的组中。
- en: It uses `\s*` to match an optional sequence of spaces.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`\s*`来匹配可选的空格序列。
- en: It matches any character in the set `[=:]` . One of the two characters in this
    set must be present.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 它匹配集合`[=：]`中的任何字符。这个集合中的两个字符之一必须存在。
- en: It uses `\s*` again to match an optional sequence of spaces.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 它再次使用`\s*`来匹配一个可选的空格序列。
- en: Finally, it uses `.*` to match everything else in the string. This is collected
    into a group named `value` .
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它使用`.*`来匹配字符串中的其他所有内容。这被收集到一个名为`value`的组中。
- en: 'We can use this to parse strings like this:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这个来解析这样的字符串：
- en: '[PRE67]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: By being flexible with the punctuation, we can make a program easier to use.
    We'll tolerate any number of spaces, and either an `=` or a `:` as a separator.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在标点符号上灵活使用，我们可以使程序更容易使用。我们将容忍任意数量的空格，并且`=`或`:`作为分隔符。
- en: There's more...
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A long regular expression can be awkward to read. We have a clever Pythonic
    trick for presenting an expression in a way that''s much easier to read:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很长的正则表达式可能很难阅读。我们有一个巧妙的Python技巧，可以以更容易阅读的方式呈现表达式：
- en: '[PRE68]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This leverages three syntax rules:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这利用了三个语法规则：
- en: A statement isn't finished until the `()` characters match
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直到`()`字符匹配完成，语句才算结束
- en: Adjacent string literals are silently concatenated into a single long string
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相邻的字符串文字会被静默连接成一个长字符串
- en: Anything between `#` and the end of the line is a comment, and is ignored
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#`和行尾之间的任何内容都是注释，会被忽略'
- en: We've put Python comments after the important clauses in our regular expression.
    This can help us understand what we did, and perhaps help us diagnose problems
    later.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在正则表达式的重要子句后面放置了Python注释。这可以帮助我们理解我们做了什么，也许帮助我们以后诊断问题。
- en: See also
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Decoding Bytes - How to get proper characters from some bytes* recipe
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解码字节-如何从一些字节中获取正确的字符*食谱'
- en: There are many books on Regular Expressions and Python Regular Expressions in
    particular like *Mastering Python Regular Expressions* ([https://www.packtpub.com/application-development/mastering-python-regular-expressions](https://www.packtpub.com/application-development/mastering-python-regular-expressions)
    )
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多关于正则表达式和特别是Python正则表达式的书籍，比如*掌握Python正则表达式*([https://www.packtpub.com/application-development/mastering-python-regular-expressions](https://www.packtpub.com/application-development/mastering-python-regular-expressions))
- en: Building complex strings with "template".format()
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用"template".format()构建复杂的字符串
- en: Creating complex strings is, in many ways, the polar opposite of parsing a complex
    string. We generally find that we'll use a template with substitution rules to
    put data into a more complex format.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 创建复杂的字符串，在许多方面，与解析复杂的字符串截然相反。通常，我们会使用带有替换规则的模板，将数据放入更复杂的格式中。
- en: Getting ready
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: 'Let''s say we have pieces of data that we need to turn into a nicely formatted
    message. We might have data including the following:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一些数据需要转换为格式良好的消息。我们可能有包括以下内容的数据：
- en: '[PRE69]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'And we''d like a line that looks like this:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要一行看起来像这样的：
- en: '[PRE70]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How to do it...
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Create a template string from the result, replacing all of the data items with
    `{}` placeholders. Inside each placeholder, put the name of the data item.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从结果中创建一个模板字符串，用`{}`占位符替换所有数据项。在每个占位符内，放入数据项的名称。
- en: '[PRE71]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'For each data item, append `:data type` information to the placeholders in
    the template string. The basic data type codes are:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个数据项，在模板字符串的占位符后附加`:数据类型`信息。基本数据类型代码有：
- en: '`s` for string'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`代表字符串'
- en: '`d` for decimal number'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`代表十进制数'
- en: '`f` for floating-point number'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数的`f`
- en: 'It would look like this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 它会看起来像这样：
- en: '[PRE72]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Add length information where required. Length is not always required, and in
    some cases, it''s not even desirable. In this example, though, the length information
    assures that each message has a consistent format. For strings and decimal numbers,
    prefix the format with the length like this: `19s` or `3d` . For floating-point
    numbers use a two part prefix like this: `5.2f` to specify the total length of
    five characters with two to the right of the decimal point. Here''s the whole
    format:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在必要的地方添加长度信息。长度并不总是必需的，在某些情况下甚至是不可取的。但在这个例子中，长度信息确保每条消息具有一致的格式。对于字符串和十进制数，前缀格式为长度，如`19s`或`3d`。对于浮点数，请使用两部分前缀，如`5.2f`，以指定总长度为五个字符，小数点右边为两个。这是整个格式：
- en: '[PRE73]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Use the `format()` method of this string to create the final string:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此字符串的`format()`方法创建最终字符串：
- en: '[PRE74]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We''ve provided all of the variables by name in the `format()` method of the
    template string. This can get tedious. In some cases, we might want to build a
    dictionary object with the variables. In that case, we can use the `format_map()`
    method:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经按名称在模板字符串的`format()`方法中提供了所有变量。这可能会变得乏味。在某些情况下，我们可能想要构建一个带有变量的字典对象。在这种情况下，我们可以使用`format_map()`方法：
- en: '[PRE75]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We'll return to dictionaries in [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Build-in Data Structures – list, set, dict*
    .
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](text00048.html#page "Chapter 4. Built-in Data Structures – list, set,
    dict")中返回到字典，*内置数据结构 - 列表，集合，字典*。
- en: 'The built-in `vars()` function builds a dictionary of all of the local variables
    for us:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`vars()`函数为我们构建了所有本地变量的字典：
- en: '[PRE76]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `vars()` function is very handy for building a dictionary automatically.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`vars()`函数非常方便，可以自动构建字典。'
- en: How it works...
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The string `format()` and `format_map()` methods can do a lot of relatively
    sophisticated string assembly for us.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`format()`和`format_map()`方法可以为我们执行相对复杂的字符串组装。
- en: The basic feature is to interpolate data into a string based on names of keyword
    arguments or keys in a dictionary. Variables can also be interpolated by position—we
    can provide position numbers instead of names. We can use a format specification
    like `{0:3s}` to use the first positional argument to `format()` .
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 基本功能是根据关键字参数的名称或字典中的键将数据插入到字符串中。变量也可以按位置插入 - 我们可以提供位置数字而不是名称。我们可以使用格式规范，如`{0:3s}`来使用`format()`的第一个位置参数。
- en: 'We''ve seen three of the formatting conversions—`s` , `d` , `f` —there are
    many others. Details are in *Section 6.1.3* of the *Python Standard Library* .
    Here are some of the format conversions we might use:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了三种格式转换 - `s`，`d`，`f` - 还有许多其他的。详细信息请参阅*Python标准库*的*第6.1.3节*。这里是我们可能使用的一些格式转换：
- en: '`b` is for binary, base 2.'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`代表二进制，基数为2。'
- en: '`c` is for Unicode character. The value must be a number, which is converted
    to a character. Often, we use hexadecimal numbers for this so you might want to
    try values such as `0x2661` through `0x2666` for fun.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`代表Unicode字符。值必须是一个数字，它将被转换为一个字符。通常，我们使用十六进制数，所以你可能想尝试一些有趣的值，比如`0x2661`到`0x2666`。'
- en: '`d` is for decimal numbers.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`代表十进制数。'
- en: '`E` and `e` are for scientific notations. `6.626E-34` or `6.626e-34` depending
    on which E or e character is used.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E`和`e`代表科学计数法。`6.626E-34`或`6.626e-34`取决于使用了哪个E或e字符。'
- en: '`F` and `f` are for floating-point. For *not a number* the `f` format shows
    lowercase `nan` ; the `F` format shows uppercase `NAN` .'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F`和`f`代表浮点数。对于*非数字*，`f`格式显示小写`nan`；`F`格式显示大写`NAN`。'
- en: '`G` and `g` are for general. This switches automatically between `E` and `F`
    (or `e` and `f` ,) to keep the output in the given sized field. For a format of
    `20.5G` , up to 20-digit numbers will be displayed using `F` formatting. Larger
    numbers will use `E` formatting.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G`和`g`代表通用。这会自动在`E`和`F`（或`e`和`f`）之间切换，以保持输出在给定的大小字段中。对于格式为`20.5G`，将使用`F`格式显示最多20位数字。较大的数字将使用`E`格式。'
- en: '`n` is for locale-specific decimal numbers. This will insert `,` or `.` characters
    depending on the current locale settings. The default locale may not have a thousand
    separators defined. For more information, see the `locale` module.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`代表特定于区域设置的十进制数。这将根据当前区域设置插入`,`或`.`字符。默认区域设置可能没有定义千位分隔符。有关更多信息，请参见`locale`模块。'
- en: '`o` is for octal, base 8.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o`代表八进制，基数为8。'
- en: '`s` is for string.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`代表字符串。'
- en: '`X` and `x` is for hexadecimal, base 16\. The digits include uppercase `A-F`
    and lowercase `a-f` , depending on which `X` or `x` format character is used.'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X`和`x`用于十六进制，基数16。数字包括大写`A-F`和小写`a-f`，具体取决于使用哪个`X`或`x`格式字符。'
- en: '`%` is for percentage. The number is multiplied by 100 and includes the `%`
    .'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%`是用于百分比的。数字乘以100并包括`%`。'
- en: 'We have a number of prefixes we can use for these different types. The most
    common one is the length. We might use `{name:5d}` to put in a 5-digit number.
    There are several prefixes for the preceding types:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有许多前缀可以用于这些不同类型。最常见的是长度。我们可能会使用`{name:5d}`来输入一个5位数。前面类型有几个前缀：
- en: '**Fill and alignment** : We can specify a specific filler character (space
    is the default) and an alignment. Numbers are generally aligned to the right and
    strings to the left. We can change that using `<` , `>` , or `^` . This forces
    left alignment, right alignment, or centering. There''s a peculiar `=` alignment
    that''s used to put padding after a leading sign.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**填充和对齐**：我们可以指定特定的填充字符（默认为空格）和对齐方式。数字通常右对齐，字符串左对齐。我们可以使用`<`，`>`或`^`来改变这一点。这会强制左对齐、右对齐或居中。有一个奇特的`=`对齐方式，用于在前导符号后放置填充。'
- en: '**Sign** : The default rule is a leading negative sign where needed. We can
    use `+` to put a sign on all numbers, `-` to put a sign only on negative numbers,
    and a space to use a space instead of a plus for positive numbers. In scientific
    output, we must use `{value: 5.3f}` . The space makes sure that room is left for
    the sign, assuring that all the decimal points line up nicely.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**符号**：默认规则是在需要时使用前导负号。我们可以使用`+`在所有数字上加上符号，使用`-`只在负数上加上符号，使用空格代替正数的加号。在科学输出中，我们必须使用`{value:
    5.3f}`。空格确保留有空间放置符号，确保所有小数点排列得很好。'
- en: '**Alternate form** : We can use the `#` to get an alternate form. We might
    have something like `{0:#x}` , `{0:#o}` , `{0:#b}` to get a prefix on hexadecimal,
    octal, or binary values. With a prefix, the numbers will look like `0xnnn` , `0onnn`
    , or `0bnnn` . The default is to omit the two character prefix.'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备用形式**：我们可以使用`#`来获得备用形式。我们可能会有类似`{0:#x}`，`{0:#o}`，`{0:#b}`的东西，以获得十六进制、八进制或二进制值的前缀。有了前缀，数字看起来像`0xnnn`，`0onnn`或`0bnnn`。默认情况下省略了两个字符的前缀。'
- en: '**Leading zero** : We can include `0` to get leading zeros to fill in the front
    of a number. Something like `{code:08x` ) will produce a hexadecimal value with
    leading zeroes to pad it out to eight characters.'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前导零**：我们可以包括`0`来获得前导零以填充数字的前部。类似`{code:08x}`将产生一个十六进制值，前面有前导零以将其填充到八个字符。'
- en: '**Width and precision** : For integer values and strings, we only provide the
    width. For floating-point values we often provide `width.precision` .'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宽度和精度**：对于整数值和字符串，我们只提供宽度。对于浮点值，我们经常提供`width.precision`。'
- en: There are some times when we won't use a `{name:format}` specification. Sometimes
    we'll need to use a `{name!conversion}` specification. There are only three conversions
    available.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不会使用`{name:format}`规范。有时我们需要使用`{name!conversion}`规范。只有三种转换可用。
- en: '`{name!r}` shows the representation that would be produced by `repr(name)`'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{name!r}`显示了由`repr(name)`产生的表示'
- en: '`{name!s}` shows the string value that would be produced by `str(name)`'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{name!s}`显示了由`str(name)`产生的字符串值'
- en: '`{name!a}` shows the ASCII value that would be produced by `ascii(name)`'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{name!a}`显示了由`ascii(name)`产生的ASCII值'
- en: In [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , we'll leverage the idea of the `{name!r}`
    format specification to simplify displaying information about related objects.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](text00070.html#page "第6章。类和对象的基础")，*类和对象的基础*中，我们将利用`{name!r}`格式规范的想法来简化显示有关相关对象的信息。
- en: There's more...
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A handy debugging hack this:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方便的调试技巧：
- en: '[PRE77]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `vars()` function—with no arguments—collects all of the local variables
    into a mapping. We provide that mapping for `format_map()` . The format template
    can use lots of `{variable_name!r}` to display details about various objects we
    have in local variables.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`vars()`函数——没有参数——将所有局部变量收集到一个映射中。我们为`format_map()`提供该映射。格式模板可以使用许多`{variable_name!r}`来显示有关我们在局部变量中拥有的各种对象的详细信息。'
- en: 'Inside a class definition we can use techniques such as `vars(self)` . This
    looks forward to [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes
    and Objects") , *Basics of Classes and Objects* :'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义内部，我们可以使用诸如`vars(self)`的技术。这预示着[第6章](text00070.html#page "第6章。类和对象的基础")，*类和对象的基础*：
- en: '[PRE78]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Our class definition includes a `__str__()` method. This method relies on `vars(self)`
    to create a useful dictionary of just the attribute of the object.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类定义包括一个`__str__()`方法。这个方法依赖于`vars(self)`来创建一个有用的对象属性字典。
- en: See also
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Python Standard Library* , *Section 6.1.3* has all of the details on the
    format method of a string
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python标准库*，*第6.1.3节*中有关字符串格式方法的所有细节。'
- en: Building complex strings from lists of characters
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从字符列表构建复杂字符串
- en: How can we make very complex changes to an immutable string? Can we assemble
    a string from individual characters?
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何对不可变字符串进行非常复杂的更改？我们可以从单个字符组装一个字符串吗？
- en: In most cases, the recipes we've already seen give us a number of tools for
    creating and modifying strings. There are yet more ways in which we can tackle
    the string manipulation problem. We'll look at using a list object. This will
    dovetail with some of the recipes in [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Built-in Data Structures – list, set, dict*
    .
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们已经看到的配方为我们创建和修改字符串提供了许多工具。我们还有更多的方法来解决字符串操作问题。我们将使用列表对象。这将与[第4章](text00048.html#page
    "第4章。内置数据结构-列表、集合、字典")中的一些配方相契合，*内置数据结构-列表、集合、字典*。
- en: Getting ready
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Here''s a string that we''d like to rearrange:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们想重新排列的字符串：
- en: '[PRE79]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We''d like to do two transformations:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想做两个转换：
- en: Remove the part before the `:`
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除`:`之前的部分
- en: Replace the punctuation with `_` , and make all the characters lowercase
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用`_`替换标点符号，并将所有字符转换为小写
- en: 'We''ll make use of the `string` module:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用`string`模块：
- en: '[PRE80]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This has two important constants:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个重要的常数：
- en: '`string.whitespace` lists all of the common whitespace characters, including
    space and tab'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string.whitespace`列出了所有常见的空白字符，包括空格和制表符'
- en: '`string.punctuation` lists the common ASCII punctuation marks. Unicode has
    a larger list of punctuation marks; that''s also available based on your locale
    settings'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string.punctuation`列出了常见的ASCII标点符号。Unicode有一个更大的标点符号列表；也可以根据您的区域设置使用'
- en: How to do it...
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We can work with a string exploded into a list. We'll look at lists in more
    depth in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures
    – list, set, dict") , *Built-in Data Structures – list, set, dict* .
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以处理分解为列表的字符串。我们将在[第4章](text00048.html#page "第4章。内置数据结构-列表、集合、字典")中更深入地研究列表，*内置数据结构-列表、集合、字典*。
- en: 'Explode the string into a `list` object:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字符串分解为`列表`对象：
- en: '[PRE81]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Find the partition character. The `index()` method for a list has the same
    semantics as the `index()` method for a list. It locates the position with the
    given value:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到分区字符。列表的`index()`方法与列表的`index()`方法具有相同的语义。它定位具有给定值的位置：
- en: '[PRE82]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Delete the characters no longer needed. The `del` statement can remove items
    from a list. Lists are a mutable data structures:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除不再需要的字符。`del`语句可以从列表中删除项目。列表是可变数据结构：
- en: '[PRE83]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We don't need to carefully work with the useful piece of the original string.
    We can remove items from a list.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要仔细处理原始字符串的有用部分。我们可以从列表中删除项目。
- en: 'Replace punctuation by stepping through each position. In this case, we''ll
    use a `for` statement to visit every index in the string:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过遍历每个位置来替换标点符号。在这种情况下，我们将使用`for`语句访问字符串中的每个索引：
- en: '[PRE84]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The expression `range(len(title_list))` generates all of the values between
    `0` and `len(title_list)-1` . This assures us that the value of position will
    be each value index in the list. Join the list of characters to create a new string.
    It seems a little odd to use zero-length string, `''''` , as a separator when
    concatenating strings together. However, it works perfectly:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表达式`range(len(title_list))`生成`0`和`len(title_list)-1`之间的所有值。这确保了位置的值将是列表中每个值的索引。连接字符列表以创建新字符串。当将字符串连接在一起时，使用零长度字符串`''`作为分隔符似乎有点奇怪。但是，它完美地工作：
- en: '[PRE85]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We assigned the resulting string back to the original variable. The original
    string object, which had been referred to by that variable, is no longer needed:
    it''s removed from memory. The new string object replaces the value of the variable.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结果字符串分配回原始变量。原始字符串对象，该对象已被该变量引用，不再需要：它已从内存中删除。新的字符串对象替换了变量的值。
- en: How it works...
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This is a change in representation trick. Since a string is immutable, we can't
    update it. We can, however, convert it into a mutable form; in this case, a list.
    We can do whatever changes are required to the mutable list object. When we're
    done, we can change the representation from a list back to a string.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种表示变化的技巧。由于字符串是不可变的，我们无法更新它。但是，我们可以将其转换为可变形式；在这种情况下，是列表。我们可以对可变列表对象进行任何所需的更改。完成后，我们可以将表示从列表更改回字符串。
- en: Strings provide a number of features that lists don't. Conversely, strings provide
    a number of features a list doesn't have. We can't convert a list to lowercase
    the way we can convert a string.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串提供了一些列表没有的功能。相反，字符串提供了列表没有的一些功能。我们无法像转换字符串那样将列表转换为小写。
- en: 'There''s an important trade-off here:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要的权衡：
- en: Strings are immutable, that makes them very fast. Strings are focused on Unicode
    characters. When we look at mappings and sets, we can use strings as keys for
    mappings and items in sets because the value is immutable.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串是不可变的，这使它们非常快。字符串专注于Unicode字符。当我们查看映射和集合时，我们可以使用字符串作为映射的键和集合中的项目，因为该值是不可变的。
- en: Lists are mutable. Operations are slower. Lists can hold any kind of item. We
    can't use a list as a key for a mapping or an item in a set because the value
    could change.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表是可变的。操作速度较慢。列表可以容纳任何类型的项目。我们不能使用列表作为映射的键或集合中的项目，因为值可能会改变。
- en: 'Strings and lists are both specialized kinds of sequences. Consequently, they
    have a number of common features. The basic item indexing and slicing features
    are shared. Similarly a list uses the same kind of negative index values that
    a string does: `list[-1]` is the last item in a list object.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串和列表都是特殊类型的序列。因此，它们具有许多共同的特征。基本的项目索引和切片功能是共享的。同样，列表使用与字符串相同类型的负索引值：`list[-1]`是列表对象中的最后一个项目。
- en: We'll return to mutable data structures in [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Built-in Data Structures – list, set, dict*
    .
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](text00048.html#page "第4章。内置数据结构-列表、集合、字典")中再次使用可变数据结构，*内置数据结构-列表、集合、字典*。
- en: There's more
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有更多
- en: Once we've started working with a list of characters instead of a string, we
    no longer have the string processing methods. We do have a number of list-processing
    techniques available to us. In addition to being able to delete items from a list,
    we can append an item, extend a list with another list, and insert a character
    into the list.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始处理字符列表而不是字符串，我们就不再具有字符串处理方法。我们有许多可用的列表处理技术。除了能够从列表中删除项目外，我们还可以附加项目，用另一个列表扩展列表，并将字符插入列表中。
- en: 'We can also change our viewpoint slightly, and look at a list of strings instead
    of a list of characters. The technique of doing `''''.join(list)` will work when
    we have a list of strings as well as a list of characters. For example, we might
    do this:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以稍微改变我们的观点，看看字符串列表而不是字符列表。当我们有一个字符串列表时，做`''.join(list)`的技巧也会起作用。例如，我们可能会这样做：
- en: '[PRE86]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Our `title_list` object will be mutated into a list that contains a six-character
    string, prefix, plus 30 individual characters.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`title_list`对象将被改变为一个包含六个字符的字符串前缀，以及30个单独字符的列表。
- en: See also
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We can also work with strings using the internal methods of a string. See the
    *Rewriting an immutable string* recipe for more techniques.
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用字符串的内部方法来处理字符串。有关更多技术，请参见*重写不可变字符串*配方。
- en: Sometimes, we need to build a string, and then convert it into bytes. See the
    *Encoding strings – creating ASCII and UTF-8 bytes* recipe for how we can do this.
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，我们需要构建一个字符串，然后将其转换为字节。查看*编码字符串 - 创建ASCII和UTF-8字节*配方，了解我们可以如何做到这一点。
- en: Other times, we'll need to convert bytes into a string. See the *Decoding Bytes
    - How to get proper characters from some bytes* recipe.
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他时候，我们需要将字节转换为字符串。参见*解码字节 - 如何从一些字节中获取正确的字符*配方。
- en: Using the Unicode characters that aren't on our keyboards
  id: totrans-531
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不在键盘上的Unicode字符
- en: A big keyboard might have almost 100 individual keys. Fewer than 50 of these
    are letters, numbers and punctuation. At least a dozen are *function* keys that
    do things other than simply *insert* letters into a document. Some of the keys
    are different kinds of *modifiers* that are meant to be used in conjunction with
    another key—we might have *Shift* , *Ctrl* , Option, and *Command* .
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大键盘可能有近100个单独的键。其中不到50个是字母、数字和标点符号。至少有十几个是*功能*键，除了简单地*插入*字母到文档之外还可以做其他事情。一些键是不同类型的*修饰符*，意味着要与另一个键一起使用——我们可能有*Shift*，*Ctrl*，Option和*Command*。
- en: Most operating systems will accept simple key combinations that create about
    100 or so characters. More elaborate key combinations may create another 100 or
    so less popular characters. This isn't even close to covering the million characters
    from the world's alphabets. And there are icons, emoticons, and dingbats galore
    in our computer fonts. How do we get to all of those glyphs?
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统都接受简单的键组合，可以创建大约100个左右的字符。更复杂的键组合可能会创建另外大约100个不太受欢迎的字符。这甚至无法涵盖世界各种语言的百万字符。我们的计算机字体中还有图标、表情符号和特殊符号。我们如何才能获得所有这些字形？
- en: Getting ready
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Python works in Unicode. There are millions of individual Unicode characters
    available.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用Unicode。有数百万个可用的Unicode字符。
- en: We can see all the available characters at [https://en.wikipedia.org/wiki/List_of_Unicode_characters
    and also http://www.unicode.org/charts/](https://en.wikipedia.org/wiki/List_of_Unicode_characters%20and%20also%20http://www.unicode.org/charts/)
    .
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在[https://en.wikipedia.org/wiki/List_of_Unicode_characters和http://www.unicode.org/charts/](https://en.wikipedia.org/wiki/List_of_Unicode_characters%20and%20also%20http://www.unicode.org/charts/)上看到所有可用的字符。
- en: We'll need the Unicode character number. We might also want the Unicode character
    name.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要Unicode字符编号。我们可能还需要Unicode字符名称。
- en: 'A given font on our computer may not be designed to provide glyphs for all
    of those characters. In particular, Windows computer fonts may have trouble displaying
    some of these characters. Using the Windows command to change to code page 65001
    is sometimes necessary:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算机上的某个字体可能没有设计为提供所有这些字符的字形。特别是，Windows计算机字体可能无法显示其中一些字符。有时需要使用Windows命令更改到代码页65001：
- en: '[PRE87]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Linux and Mac OS X rarely have problems with Unicode characters.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: Linux和Mac OS X很少出现Unicode字符的问题。
- en: How to do it...
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Python uses **escape sequences** to extend the ordinary characters we can type
    to cover the vast space of Unicode characters. The escape sequences start with
    a `\` character. The next character tells exactly how the Unicode character will
    be represented. Locate the character that''s needed. Get the name or the number.
    The numbers are always given as hexadecimal, base 16\. They''re often written
    as `U+2680` . The name might be `DIE FACE-1` . Use `\unnnn` with up to a four-digit
    number. Or use `\N{name}` with the spelled-out name. If the number is more than
    four digits, use `\Unnnnnnnn` with the number padded out to eight digits:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用**转义序列**来扩展我们可以输入的普通字符，以涵盖Unicode字符的广阔空间。转义序列以`\`字符开头。下一个字符准确告诉Unicode字符将如何表示。找到所需的字符。获取名称或数字。数字总是以十六进制、16进制给出。它们通常写为`U+2680`。名称可能是`DIE
    FACE-1`。使用\unnnn，最多使用四位数字。或使用\N{name}与拼写的名称。如果数字超过四位数，使用\Unnnnnnnn，数字填充到八位数：
- en: '![How to do it...](Image00001.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](Image00001.jpg)'
- en: Yes, we can include a wide variety of characters in Python output. To place
    a `\` character in the string, we need to use `\\` . For example, we might need
    this for Windows filenames.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们可以在Python输出中包含各种字符。要在字符串中放置`\`字符，我们需要使用`\\`。例如，我们可能需要这个用于Windows文件名。
- en: How it works...
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Python uses Unicode internally. The 128 or so characters we can type directly
    using the keyboard all have handy internal Unicode numbers.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: Python在内部使用Unicode。我们可以直接使用键盘输入的128个左右字符都有方便的内部Unicode编号。
- en: 'When we write:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们写：
- en: '[PRE88]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Python treats it as shorthand for this:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: Python将其视为此的简写：
- en: '[PRE89]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Once we get beyond the characters on our keyboards, the remaining millions of
    characters are identified only by their number.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们超出键盘上的字符，剩下的数百万个字符只能通过它们的编号来识别。
- en: When the string is being compiled by Python, the `\uxx` , `\Uxxxxxxxx` , and
    `\N{name}` are all replaced by the proper Unicode character. If we have something
    syntactically wrong—for example, `\N{name` with no closing `}` —we'll get an immediate
    error from Python's internal syntax checking.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python编译字符串时，\uxx，\Uxxxxxxxx和\N{name}都将被正确的Unicode字符替换。如果我们有一些语法错误，例如`\N{name`没有闭合`}`，我们将立即从Python的内部语法检查中获得错误。
- en: Back in the *String parsing with regular expressions* recipe, we noted that
    regular expressions use a lot of `\` characters and we specifically do not want
    Python's normal compiler to touch them; we used the `r'` prefix on a regular expression
    string to prevent the `\` from being treated as an escape and possibly converted
    to something else.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 回到*使用正则表达式解析字符串*配方，我们注意到正则表达式使用了很多`\`字符，我们特别不希望Python的正常编译器去处理它们；我们在正则表达式字符串上使用`r'`前缀，以防止`\`被视为转义并可能转换为其他内容。
- en: What if we need to use Unicode in a Regular Expression? We'll need to use `\\`
    all over the place in the Regular Expression. We might see this `'\\w+[\u2680\u2681\u2682\u2683\u2684\u2685]\\d+'`
    . We skipped the `r'` prefix on the string. We doubled up the `\` used for Regular
    Expressions. We used `\uxxxx` for the Unicode characters that are part of the
    pattern. Python's internal compiler will replace the `\uxxxx` with Unicode characters
    and the `\\` with a single `\` internally.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在正则表达式中使用Unicode？我们需要在正则表达式中到处使用`\\`。我们可能会看到这个`'\\w+[\u2680\u2681\u2682\u2683\u2684\u2685]\\d+'`。我们省略了字符串的`r'`前缀。我们将用于正则表达式的`\`加倍。我们使用`\uxxxx`表示模式中的Unicode字符。Python的内部编译器将用Unicode字符替换`\uxxxx`，并在内部用单个`\`替换`\\`。
- en: Note
  id: totrans-555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'When we look at a string at the `>>>` prompt, Python will display the string
    in its canonical form. Python prefers to use the `''` as a delimiter even though
    we can use either `''` or `"` for a string delimiter. Python doesn''t generally
    display raw strings, instead it puts all of the necessary escape sequences back
    into the string:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`>>>`提示符下查看一个字符串时，Python会以规范形式显示字符串。Python更喜欢使用`'`作为分隔符，尽管我们可以使用`'`或`"`作为字符串分隔符。Python通常不显示原始字符串，而是将所有必要的转义序列放回字符串中：
- en: '`>>> r"\w+"`'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>> r"\w+"`'
- en: '`''\\w+''`'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`''\\w+''`'
- en: We provided a string in raw form. Python displayed it in canonical form.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个原始形式的字符串。Python以规范形式显示它。
- en: See also
  id: totrans-560
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In the *Encoding strings – creating ASCII and UTF-8 bytes* and the *Decoding
    Bytes - How to get proper characters from some bytes* recipes we'll look at how
    Unicode characters are converted to sequences of bytes so we can write them to
    a file. We'll look at how bytes from a file (or downloaded from a website) are
    turned into Unicode characters so they can be processed.
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*编码字符串 - 创建ASCII和UTF-8字节*和*解码字节 - 如何从一些字节中获取正确的字符*中，我们将看看如何将Unicode字符转换为字节序列，以便将它们写入文件。我们将看看如何将文件中的字节（或从网站下载的字节）转换为Unicode字符，以便进行处理。
- en: If you're interested in history, you can read up on ASCII and EBCDIC and other
    old-fashioned character codes here [http://www.unicode.org/charts/](http://www.unicode.org/charts/)
    .
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你对历史感兴趣，你可以在这里阅读ASCII和EBCDIC以及其他老式字符编码的相关内容[http://www.unicode.org/charts/](http://www.unicode.org/charts/)。
- en: Encoding strings – creating ASCII and UTF-8 bytes
  id: totrans-563
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码字符串 - 创建ASCII和UTF-8字节
- en: Our computer files are bytes. When we upload or download from the Internet,
    the communication works in bytes. A byte only has 256 distinct values. Our Python
    characters are Unicode. There are a lot more than 256 Unicode characters.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算机文件是字节。当我们上传或下载文件时，通信是以字节为单位的。一个字节只有256个不同的值。我们的Python字符是Unicode。Unicode字符远远超过256个。
- en: How do we map Unicode characters to bytes for writing to a file or transmitting?
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将Unicode字符映射到字节以便写入文件或传输？
- en: Getting ready
  id: totrans-566
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Historically, a character occupied 1 byte. Python leverages the old ASCII encoding
    scheme for bytes; this sometimes leads to confusion between bytes and proper strings
    of Unicode characters.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，一个字符占用1个字节。Python利用旧的ASCII编码方案进行字节处理；这有时会导致字节和正确的Unicode字符之间的混淆。
- en: Unicode characters are encoded into sequences of bytes. We have a number of
    standardized encodings and a number of non-standard encodings.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode字符被编码为字节序列。我们有许多标准编码和许多非标准编码。
- en: Plus, we also have some encodings that only work for a small subset of Unicode
    characters. We try to avoid this, but there are some situations where we'll need
    to use a subset encoding scheme.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有一些只适用于小部分Unicode字符的编码。我们尽量避免这种情况，但有些情况下我们需要使用子集编码方案。
- en: Unless we have a really good reason, we almost always use the UTF-8 encoding
    for Unicode characters. Its main advantage is that it's a compact representation
    for the Latin alphabet used for English and a number of European languages.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们有一个非常好的理由，我们几乎总是使用UTF-8编码来处理Unicode字符。它的主要优势是它是拉丁字母表的紧凑表示，用于英语和一些欧洲语言。
- en: Sometimes, an Internet protocol requires ASCII characters. This is a special
    case that requires some care because the ASCII encoding can only handle a small
    subset of Unicode characters.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，互联网协议需要ASCII字符。这是一个特殊情况，需要一些小心，因为ASCII编码只能处理Unicode字符的一个小子集。
- en: How to do it...
  id: totrans-572
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Python will generally use our OS''s default encoding for files and Internet
    traffic. The details are unique to each OS:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: Python通常会使用我们操作系统的默认编码进行文件和互联网通信。细节因操作系统而异：
- en: 'We can make a general setting using the `PYTHONIOENCODING` environment variable.
    We set this outside of Python to assure that a particular encoding is used everywhere.
    Set the environment variable as:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`PYTHONIOENCODING`环境变量进行一般设置。我们在Python之外设置这个变量，以确保在任何地方都使用特定的编码。设置环境变量如下：
- en: '[PRE90]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Run Python:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Python：
- en: '[PRE91]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We sometimes need to make specific settings when we open a file inside our
    script. We''ll return this in [Chapter 9](text00099.html#page "Chapter 9. Input/Output,
    Physical Format, and Logical Layout") , *Input/Output, Physical Format, Logical
    Layout* . Open the file with a given encoding. Read or write Unicode characters
    to the file:'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时候我们需要在脚本中打开文件时进行特定的设置。我们将在[第9章](text00099.html#page "第9章 输入/输出、物理格式和逻辑布局")中返回这个问题，*输入/输出、物理格式、逻辑布局*。使用给定的编码打开文件。读取或写入Unicode字符到文件中：
- en: '[PRE92]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We can also manually encode characters, in the rare case that we need to open
    a file in bytes mode; if we use a mode of `wb` , we''ll need to use manual encoding:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见的情况下，我们也可以手动编码字符，如果我们需要以字节模式打开文件；如果我们使用`wb`模式，我们需要手动编码：
- en: '[PRE93]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We can see that a sequence of bytes (`\xf0\x9f\x80\x80` ) was used to encode
    a single Unicode character, `U+1F000` , ![How to do it...](Image00002.jpg)  .
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一系列字节(`\xf0\x9f\x80\x80`)被用来编码一个Unicode字符`U+1F000`，![如何做...](Image00002.jpg)。
- en: How it works...
  id: totrans-583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Unicode defines a number of encoding schemes. While UTF-8 is the most popular,
    there are also UTF-16 and UTF-32\. The number is the typical number of bits per
    character. A file with 1000 characters encoded in UTF-32 would be 4000 8-bit bytes.
    A file with 1000 characters encoded in UTF-8 could be as few as 1000 bytes, depending
    on the exact mix of characters. In the UTF-8 encoding, characters with Unicode
    numbers above `U+007F` require multiple bytes.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode定义了许多编码方案。虽然UTF-8是最流行的，但还有UTF-16和UTF-32。数字是每个字符的典型位数。一个包含1000个字符的UTF-32编码文件将是4000个8位字节。一个包含1000个字符的UTF-8编码文件可能只有1000个字节，具体取决于字符的确切混合。在UTF-8编码中，Unicode编号大于`U+007F`的字符需要多个字节。
- en: Various OS's have their own coding schemes. Mac OS X files are often encoded
    in `Mac Roman` or `Latin-1` . Windows files might use `CP1252` encoding.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 各种操作系统都有自己的编码方案。Mac OS X文件通常以`Mac Roman`或`Latin-1`编码。Windows文件可能使用`CP1252`编码。
- en: The point with all of these schemes is to have a sequence of bytes that can
    be mapped to a Unicode character. And—going the other way—a way to map each Unicode
    character to one or more bytes. Ideally, all of the Unicode characters are accounted
    for. Pragmatically, some of these coding schemes are incomplete. The tricky part
    is to avoid writing any more bytes than is necessary.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方案的要点是有一个字节序列，可以映射到一个Unicode字符。而且-反过来-一种将每个Unicode字符映射到一个或多个字节的方法。理想情况下，所有的Unicode字符都被考虑在内。实际上，一些编码方案是不完整的。棘手的部分是避免写入比必要的更多的字节。
- en: The historical `ASCII` encoding can only represent about 250 of the Unicode
    characters as bytes. It's easy to create a string which cannot be encoded using
    the ASCII scheme.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上的`ASCII`编码只能表示大约250个Unicode字符作为字节。很容易创建一个不能使用ASCII方案编码的字符串。
- en: 'Here''s what the error looks like:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是错误的样子：
- en: '[PRE94]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We may see this kind of error when we accidentally open a file with a poorly
    chosen encoding. When we see this, we'll need to change our processing to select
    a more useful encoding; ideally, UTF-8.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们意外地用一个选择不当的编码打开文件时，我们可能会看到这种错误。当我们看到这个错误时，我们需要改变我们的处理方式，选择一个更有用的编码；理想情况下是UTF-8。
- en: Note
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Bytes vs Strings**'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '**字节 vs 字符串**'
- en: Bytes are often displayed using printable characters.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 字节通常使用可打印字符显示。
- en: We'll see `b'hello'` as a short-hand for a five-byte value. The letters are
    chosen using the old ASCII encoding scheme. Many byte values from about `0x20`
    to `0xFE` will be shown as characters.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会看到`b'hello'`作为一个五字节值的简写。这些字母是使用旧的ASCII编码方案选择的。大约从`0x20`到`0xFE`的许多字节值将显示为字符。
- en: This can be confusing. The prefix of `b'` is our hint that we're looking at
    bytes, not proper Unicode characters.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会让人困惑。`b'`的前缀是我们正在看字节，而不是合适的Unicode字符。
- en: See also
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: There are a number of ways to build strings of data. See the *Building complex
    strings with "template".format()* and the *Building complex strings from lists
    of characters* recipes for examples of creating complex strings. The idea is that
    we might have an application that builds a complex string, and then we encode
    it into bytes.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多构建数据字符串的方法。查看*使用"template".format()构建复杂字符串*和*从字符列表构建复杂字符串*配方，了解创建复杂字符串的示例。这个想法是我们可能有一个构建复杂字符串的应用程序，然后将其编码为字节。
- en: For more information on the UTF-8 encoding, see [https://en.wikipedia.org/wiki/UTF-8](https://en.wikipedia.org/wiki/UTF-8)
    .
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关UTF-8编码的更多信息，请参阅[https://en.wikipedia.org/wiki/UTF-8](https://en.wikipedia.org/wiki/UTF-8)。
- en: For general information on Unicode encodings, see [http://unicode.org/faq/utf_bom.html](https://en.wikipedia.org/wiki/UTF-8)
    .
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Unicode编码的一般信息，请参阅[http://unicode.org/faq/utf_bom.html](https://en.wikipedia.org/wiki/UTF-8)。
- en: Decoding bytes – how to get proper characters from some bytes
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码字节-如何从一些字节中获得正确的字符
- en: How can we work with files that aren't properly encoded? What do we do with
    files written in the ASCII encoding?
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理没有正确编码的文件？我们如何处理用ASCII编码写的文件？
- en: A download from the Internet is almost always in bytes—not characters. How do
    we decode the characters from that stream of bytes?
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 从互联网下载的几乎总是字节，而不是字符。我们如何从字节流中解码字符？
- en: Also, when we use the `subprocess` module, the results of an OS command are
    in bytes. How can we recover proper characters?
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们使用`subprocess`模块时，操作系统命令的结果是字节。我们如何恢复正确的字符？
- en: Much of this is also relevant to the material in [Chapter 9](text00099.html#page
    "Chapter 9. Input/Output, Physical Format, and Logical Layout") , *Input/Output,
    Physical Format, Logical Layout* . We've included the recipe here because it's
    the inverse of the previous recipe, *Encoding strings – creating ASCII and UTF-8
    bytes* .
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这个大部分也与[第9章](text00099.html#page "第9章 输入/输出、物理格式和逻辑布局")中的材料相关，*输入/输出、物理格式、逻辑布局*。我们在这里包含了这个配方，因为它是前一个配方的反向，*编码字符串-创建ASCII和UTF-8字节*。
- en: Getting ready
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: Let's say we're interested in offshore marine weather forecasts. Perhaps because
    we own a large sailboat. Or perhaps because good friends of ours have a large
    sailboat and are departing the **Chesapeake Bay** for the **Caribbean** .
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们对近海海洋天气预报感兴趣。也许是因为我们拥有一艘大帆船。或者是因为我们的好朋友拥有一艘大帆船，正在离开**切萨皮克湾**前往**加勒比海**。
- en: Are there any special warnings coming from the **National Weather Services**
    office in Wakefield, Virginia?
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 来自**国家气象局**维吉尼亚州韦克菲尔德办公室的有没有特别的警告？
- en: 'Here''s where we can get the warnings: [http://www.nws.noaa.gov/view/national.php?prod=SMW&sid=AKQ](http://www.nws.noaa.gov/view/national.php?prod=SMW&sid=AKQ)
    .'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们可以得到警告的地方：[http://www.nws.noaa.gov/view/national.php?prod=SMW&sid=AKQ](http://www.nws.noaa.gov/view/national.php?prod=SMW&sid=AKQ)。
- en: 'We can download this with Python''s `urllib` module:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Python的`urllib`模块下载这个。
- en: '[PRE95]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Or, we can use programs like `curl` or `wget` to get this. We might do:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`curl`或`wget`等程序来获取这个。我们可以这样做：
- en: '[PRE96]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Since `curl` left us with an awkward file name, we needed to rename the file.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`curl`给我们留下了一个尴尬的文件名，我们需要重命名文件。
- en: 'The `forecast_text` value is a stream of bytes. It''s not a proper string.
    We can tell because it starts like this:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '`forecast_text` 值是一系列字节。它不是一个合适的字符串。我们可以知道这一点，因为它是这样开始的：'
- en: '[PRE97]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: And goes on for a while providing details. Because it starts with `b'` , it's
    bytes, not proper Unicode characters. It was probably encoded with UTF-8, which
    means some characters could have weird-looking `\xnn` escape sequences instead
    of proper characters. We want to have the proper characters.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 并且提供了一段时间的细节。因为它以`b'`开头，所以它是字节，而不是合适的Unicode字符。它可能是用UTF-8编码的，这意味着一些字符可能具有奇怪的`\xnn`转义序列，而不是合适的字符。我们想要有合适的字符。
- en: Tip
  id: totrans-617
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Bytes vs Strings**'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '**字节与字符串**'
- en: Bytes are often displayed using printable characters.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 字节通常使用可打印字符显示。
- en: We'll see `b'hello'` as a short-hand for a five-byte value. The letters are
    chosen using the old ASCII encoding scheme. Many byte values from about `0x20`
    to `0xFE` will be shown as characters.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`b'hello'`看作是一个五字节值的简写。字母是使用旧的ASCII编码方案选择的。大约从`0x20`到`0xFE`的许多字节值将显示为字符。
- en: This can be confusing. The prefix of `b'` is our hint that we're looking at
    bytes, not proper Unicode characters.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会让人感到困惑。`b'`的前缀是我们正在查看字节而不是合适的Unicode字符的提示。
- en: Generally, bytes behave somewhat like strings. Sometimes we can work with bytes
    directly. Most of the time, we'll want to decode the bytes and create proper Unicode
    characters.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，字节的行为有点像字符串。有时我们可以直接使用字节。大多数情况下，我们会想要解码字节并创建合适的Unicode字符。
- en: How to do it..
  id: totrans-623
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: '.Determine the coding scheme if possible. In order to decode bytes to create
    proper Unicode characters, we need to know what encoding scheme was used. When
    we read XML documents, there''s a big hint provided within the document:'
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可能的话，确定编码方案。为了解码字节以创建合适的Unicode字符，我们需要知道使用了什么编码方案。当我们读取XML文档时，文档中提供了一个重要提示：
- en: '[PRE98]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'When browsing web pages, there''s often a header with this information:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览网页时，通常会有包含此信息的页眉：
- en: '[PRE99]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Sometimes an HTML page may include this as part of the header:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，HTML页面可能包括这部分内容作为页眉的一部分：
- en: '[PRE100]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In other cases, we're left to guess. In the case of US Weather data, a good
    first guess is UTF-8\. Other good guesses include ISO-8859-1\. In some cases,
    the guess will depend on the language.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，我们只能猜测。在美国天气数据的情况下，UTF-8是一个很好的第一猜测。其他好的猜测包括ISO-8859-1。在某些情况下，猜测将取决于语言。
- en: '*Section 7.2.3* , *Python Standard Library* lists the standard encodings available.
    Decode the data:'
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*第7.2.3节*，*Python标准库*列出了可用的标准编码。解码数据：'
- en: '[PRE101]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The `b'` prefix is gone. We've created a proper string of Unicode characters
    from the stream of bytes.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '`b''`前缀消失了。我们从字节流中创建了一个合适的Unicode字符字符串。'
- en: If this step fails with an exception, we guessed wrong about the encoding. We
    need to try another encoding. Parse the resulting document.
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果此步骤出现异常，则我们对编码的猜测是错误的。我们需要尝试另一种编码。解析生成的文档。
- en: Since this is an HTML document, we should use **Beautiful Soup** . See [http://www.crummy.com/software/BeautifulSoup/](http://www.crummy.com/software/BeautifulSoup/)
    .
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个HTML文档，我们应该使用**Beautiful Soup**。请参见[http://www.crummy.com/software/BeautifulSoup/](http://www.crummy.com/software/BeautifulSoup/)。
- en: 'We can, however, extract one nugget of information from this document without
    completely parsing the HTML:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以从这个文档中提取一条信息而不完全解析HTML：
- en: '[PRE102]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This tells us what we need to know: there are no warnings at this time. That
    doesn''t mean smooth sailing, but it does mean that there aren''t any major weather
    systems that can cause catastrophes.'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们我们需要知道的信息：目前没有警告。这并不意味着一帆风顺，但这意味着没有任何可能引起灾难的重大天气系统。
- en: How it works...
  id: totrans-639
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: See the *Encoding strings – creating ASCII and UTF-8 bytes* recipe for more
    information on Unicode and the different ways that Unicode characters can be encoded
    into streams of bytes.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Unicode以及将Unicode字符编码为字节流的不同方式的更多信息，请参见*编码字符串-创建ASCII和UTF-8字节*示例。
- en: At the foundation of the operating system, files and network connections are
    built up from bytes. It's our software that decodes the bytes to discover the
    content. It might be characters, or images, or sounds. In some cases, the default
    assumptions are wrong and we need to do our own decoding.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统的基础上，文件和网络连接是由字节构建起来的。是我们的软件解码字节来发现内容。它可能是字符、图像或声音。在某些情况下，默认的假设是错误的，我们需要自己解码。
- en: See also
  id: totrans-642
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参见
- en: Once we've recovered the string data, we have a number of ways of parsing or
    rewriting it. See the *String parsing with regular expressions* recipe for examples
    of parsing a complex string.
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们恢复了字符串数据，我们有许多解析或重写它的方法。参见*使用正则表达式解析字符串*示例。
- en: For more information on encodings, see [https://en.wikipedia.org/wiki/UTF-8](https://en.wikipedia.org/wiki/UTF-8)
    and [http://unicode.org/faq/utf_bom.html](http://unicode.org/faq/utf_bom.html)
    .
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关编码的更多信息，请参见[https://en.wikipedia.org/wiki/UTF-8](https://en.wikipedia.org/wiki/UTF-8)和[http://unicode.org/faq/utf_bom.html](http://unicode.org/faq/utf_bom.html)。
- en: Using tuples of items
  id: totrans-645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用项目的元组
- en: What's the best way to represent simple ( *x* , *y* ) and ( *r* , *g* , *b*
    ) groups of values? How can we keep things which are pairs such as latitude and
    longitude together?
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 如何最好地表示简单的(*x*, *y*)和(*r*, *g*, *b*)值组？我们如何将诸如纬度和经度之类的成对物品保持在一起？
- en: Getting ready
  id: totrans-647
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the *String parsing with regular expressions* recipe, we skipped over an
    interesting data structure.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用正则表达式解析字符串*示例中，我们跳过了一个有趣的数据结构。
- en: 'We had data that looked like this:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有这样的数据：
- en: '[PRE103]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We parsed this into the meaningful data using a regular expression like this:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用类似于这样的正则表达式将其解析为有意义的数据：
- en: '[PRE104]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The result is a tuple object with three pieces of data. There are lots of places
    where this kind of grouped data come in handy.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含三个数据片段的元组对象。有很多地方可以使用这种分组数据。
- en: How to do it...
  id: totrans-654
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll look at two aspects to this: putting things into tuples and getting
    things out of tuples.'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从两个方面来看这个问题：将事物放入元组中和从元组中取出事物。
- en: Creating tuples
  id: totrans-656
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建元组
- en: There are lots of places where Python creates tuples of data for us. In the
    *Getting ready* section of the *String Parsing with Regular Expressions* recipe
    we showed how a regular expression match object will create a tuple of text that
    was parsed from a string.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多地方，Python会为我们创建数据的元组。在*使用正则表达式解析字符串*配方的*准备就绪*部分中，我们展示了正则表达式匹配对象将创建一个从字符串中解析出的文本元组。
- en: 'We can create our own tuples, too. Here are the steps:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以创建自己的元组。以下是步骤：
- en: Enclose the data in `()` .
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据括在`()`中。
- en: Separate the items with a `,` .
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`,`分隔项目。
- en: '[PRE105]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: There's an important special case for the one-tuple, or singleton. We have to
    include an extra `,` even when there's only one item in the tuple.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单元素元组或单例，有一个重要的特殊情况。即使元组中只有一个项目，我们也必须包含一个额外的`,`。
- en: '[PRE106]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Tip
  id: totrans-664
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'The `()` characters aren''t always required. There are a few times where we
    can omit them. It''s not a good idea to omit them, but we can see funny things
    when we have an extra comma:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '`()`字符并不总是必需的。有几种情况下我们可以省略它们。省略它们并不是一个好主意，但当我们有一个额外的逗号时，我们可以看到有趣的事情：'
- en: '[PRE107]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The extra comma after `355` makes the value into a singleton tuple.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 在`355`后面的额外逗号将该值变成了一个单元素元组。
- en: Extracting items from a tuple
  id: totrans-668
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从元组中提取项目
- en: 'The idea of a tuple is to be a container with a number of items that''s fixed
    by the problem domain: for example, `(red, green, blue)` color numbers. The number
    of items is always three.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的概念是作为一个包含一定数量项目的容器，这个数量由问题域确定：例如，`(红色，绿色，蓝色)`颜色编号。项目的数量始终是三个。
- en: 'In our example, we''ve got an ingredient, and amount, and units. This must
    be a three-item collection. We can look at the individual items two ways:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们有一个成分、一个数量和一个单位。这必须是一个三个项目的集合。我们可以以两种方式查看单个项目：
- en: 'By index position: Positions are numbered starting with zero from the left:'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按索引位置：位置从左边开始编号为零：
- en: '[PRE108]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Using multiple assignment:'
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多重赋值：
- en: '[PRE109]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Tuples—like strings—are immutable. We can't change the individual items inside
    a tuple. We use tuples when we want to keep the data together.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 元组——就像字符串一样——是不可变的。我们不能改变元组中的单个项目。当我们想要将数据保持在一起时，我们使用元组。
- en: How it works...
  id: totrans-676
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Tuples are one example of the more general class of `Sequence` . We can do a
    few things with sequences.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是“序列”的更一般类别的一个例子。我们可以对序列做一些事情。
- en: 'Here''s an example tuple that we can work with:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个我们可以使用的示例元组：
- en: '[PRE110]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Here are some operations we can perform on this tuple:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以在这个元组上执行的一些操作：
- en: How many items in `t` ?
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “t”中有多少个项目？
- en: '[PRE111]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: How many times does a particular value appear in `t` ?
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定值在“t”中出现了多少次？
- en: '[PRE112]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Which position has a particular value?
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个位置有特定的值？
- en: '[PRE113]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'When an item doesn''t exist, we''ll get an exception:'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个项目不存在时，我们会得到一个异常：
- en: '[PRE114]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Does a particular value exist?
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定值是否存在？
- en: '[PRE115]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: There's more
  id: totrans-691
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: A tuple, like a string, is a sequence of items. In the case of a string, it's
    a sequence of characters. In the case of a tuple, it's a sequence of many things.
    Because they're both sequences, they have some common features. We've noted that
    we can pluck out individual items by their index position. We can use the `index()`
    method to locate the position of an item.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 元组，就像字符串一样，是一系列项目。对于字符串，它是一系列字符。对于元组，它是一系列许多东西。因为它们都是序列，它们有一些共同的特点。我们注意到我们可以通过它们的索引位置取出单个项目。我们可以使用`index()`方法来定位项目的位置。
- en: The similarities end there. A string has many methods to create a new string
    that's a transformation of a string, plus methods to parse strings, plus methods
    to determine the content of the strings. A tuple doesn't have any of these bonus
    features. It's—perhaps—the simplest possible data structure.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 相似之处就到此为止。字符串有许多方法来创建一个新的字符串，这是对字符串的转换，还有解析字符串的方法，以及确定字符串内容的方法。元组没有这些额外的功能。它可能是最简单的数据结构。
- en: See also...
  id: totrans-694
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅...
- en: We've looked at one other sequence, the list, in the *Building complex strings
    from lists of characters* recipe
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还在*从字符列表构建复杂字符串*配方中查看了另一个序列，即列表。
- en: We'll also look at sequences in [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Built-in Data Structures – list, tuple,
    set, dict*
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将在[第4章](text00048.html#page "第4章。内置数据结构-列表、集合、字典")中查看序列，*内置数据结构-列表、元组、集合、字典*
