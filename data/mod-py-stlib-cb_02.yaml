- en: Text Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本管理
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Pattern matching—regular expressions are not the only way to parse patterns;
    Python provides easier and just as powerful tools to parse patterns
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配-正则表达式不是解析模式的唯一方法；Python提供了更简单且同样强大的工具来解析模式
- en: Text similarity—detecting how two similar strings in a performing way can be
    hard but Python has some easy-to-use built-in tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本相似性-检测两个相似字符串的性能可能很困难，但Python有一些易于使用的内置工具
- en: Text suggestion—Python looks for the most similar one to suggest to the user
    the right spelling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本建议-Python寻找最相似的一个建议给用户正确的拼写
- en: Templating—when generating text, templating is the easiest way to define the
    rules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板化-在生成文本时，模板化是定义规则的最简单方法
- en: Splitting strings preserving spaces—splitting on empty spaces can be easy, but
    gets harder when you want to preserve some spaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留空格拆分字符串-在空格上拆分可能很容易，但当您想保留一些空格时会变得更加困难
- en: Cleanup text—removes any punctuation or odd character from text
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理文本-从文本中删除任何标点符号或奇怪的字符
- en: Normalizing text—when working with international text, it's often convenient
    to avoid having to cope with special characters and misspelling of words
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本标准化-在处理国际文本时，通常方便避免处理特殊字符和单词拼写错误
- en: Aligning text—when outputting text, properly aligning it greatly increases readability
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对齐文本-在输出文本时，正确对齐文本大大增加了可读性
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Python was born for system engineering and a very frequent need when working
    with shell scripts and shell-based software is to create and parse text. That's
    why Python has very powerful tools to handle text.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python是为系统工程而生的，当与shell脚本和基于shell的软件一起工作时，经常需要创建和解析文本。这就是为什么Python有非常强大的工具来处理文本。
- en: Pattern matching
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: When looking for patterns in text, regular expressions are frequently the most
    common way to attach those kind of problems. They are very flexible and powerful,
    and even though they cannot express all kinds of grammar they frequently can handle
    most common cases.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本中寻找模式时，正则表达式通常是解决这类问题的最常见方式。它们非常灵活和强大，尽管它们不能表达所有种类的语法，但它们通常可以处理大多数常见情况。
- en: 'The power of regular expressions comes out of the wide set of symbols and expressions
    they can generate. The problem is that for developers that are not used to regular
    expressions, they can look just like plain noise, and even people who have experience
    with them will frequently have to think a bit before understanding an expression
    like the following one:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的强大之处在于它们可以生成的广泛符号和表达式集。问题在于，对于不习惯正则表达式的开发人员来说，它们可能看起来就像纯噪音，即使有经验的人也经常需要花一点时间才能理解下面的表达式：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This expression actually tries to detect phone numbers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式实际上试图检测电话号码。
- en: 'For most common cases, developers need to look for very simple patterns: for
    example, file extensions (does it end with `.txt`?), separated text, and so on.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数常见情况，开发人员需要寻找非常简单的模式：例如，文件扩展名（它是否以`.txt`结尾？），分隔文本等等。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The `fnmatch` module provides a simplified pattern-matching language with a
    very quick and easy-to-understand syntax for most developers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`fnmatch`模块提供了一个简化的模式匹配语言，对于大多数开发人员来说，语法非常快速和易于理解。'
- en: 'Very few characters have a special meaning:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有字符具有特殊含义：
- en: '`*` means any text'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`表示任何文本'
- en: '`?` means any character'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?`表示任何字符'
- en: '`[...]` means the contained characters within square brackets'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[...]`表示方括号内包含的字符'
- en: '`[!...]` means everything apart from the characters contained within the square
    brackets'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[!...]`表示除了方括号内包含的字符之外的所有内容'
- en: 'You will probably recognize this syntax from your system shell, so it''s easy
    to see how `*.txt` means *every name that has a .txt extension*:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会从系统shell中认出这个语法，所以很容易看出`*.txt`意味着*每个具有.txt扩展名的名称*：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There's more...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Practically, `fnmatch` can be used to recognize pieces of text separated by
    some kind of constant value.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`fnmatch`可以用于识别由某种常量值分隔的文本片段。
- en: 'For example, if I have a pattern that defines the `type`, `name`, and `value`
    of a variable separated by `:`, we can recognize it through `fnmatch` and then
    declare the described variable:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我有一个模式，定义了变量的`类型`，`名称`和`值`，通过`:`分隔，我们可以通过`fnmatch`识别它，然后声明所描述的变量：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Where `fnmatch` obviously shines is with filenames. If you have a list of files,
    it''s easy to extract only those that match a specific pattern:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`fnmatch`在文件名方面表现出色。如果您有一个文件列表，很容易提取只匹配特定模式的文件：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While very convenient, `fnmatch` is surely limited, but one of the best things
    a tool can do when it reaches its limits is to provide compatibility with an alternative
    tool that can overcome them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然非常方便，`fnmatch`显然是有限的，但当一个工具达到其极限时，最好的事情之一就是提供与可以克服这些限制的替代工具兼容的兼容性。
- en: For example, if I wanted to find all files that contained the word `git` or
    `vs`, I couldn't do that in a single `fnmatch` pattern. I have to declare two
    different patterns and then join the results. But, if I could use a regular expression,
    that is absolutely possible.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我想找到所有包含单词`git`或`vs`的文件，我不能在一个`fnmatch`模式中做到这一点。我必须声明两种不同的模式，然后将结果连接起来。但是，如果我可以使用正则表达式，那是绝对可能的。
- en: '`fnmatch.translate` bridges between `fnmatch` patterns and regular expressions,
    providing the regular expression that describes an `fnmatch` pattern, so that
    it can be extended how you wish.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`fnmatch.translate`在`fnmatch`模式和正则表达式之间建立桥梁，提供描述`fnmatch`模式的正则表达式，以便可以根据需要进行扩展。'
- en: 'For example, we could create a regular expression that matches both patterns:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个匹配这两种模式的正则表达式：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The real advantage of `fnmatch` is that it is an easy and safe enough language
    that you can expose to your users. Suppose you are writing an email client and
    you want to provide a search feature, how could you let your users search for
    Smith as a name or surname if you have emails from Jane Smith and Smith Lincoln?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`fnmatch`的真正优势在于它是一种足够简单和安全的语言，可以向用户公开。假设您正在编写一个电子邮件客户端，并且希望提供搜索功能，如果您有来自Jane
    Smith和Smith Lincoln的电子邮件，您如何让用户搜索名为Smith或姓为Smith的人？'
- en: 'Well with `fnmatch` that''s easy because you can just expose it to your users
    and let them write `*Smith` or `Smith*`, depending on whether they are looking
    for someone named Smith or with Smith as a surname:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fnmatch`很容易，因为您可以将其提供给用户，让他们编写`*Smith`或`Smith*`，具体取决于他们是在寻找名为Smith的人还是姓氏为Smith的人：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Text similarity
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本相似性
- en: In many cases, when working with text, we might have to recognize text that
    is similar to other text, even when the two are not equal. This is a very common
    case in record linkage, finding duplicate entries, or for typing errors correction.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，当处理文本时，我们可能需要识别与其他文本相似的文本，即使这两者并不相等。这在记录链接、查找重复条目或更正打字错误时非常常见。
- en: Finding similarity across text is not a straightforward task. If you try to
    go your own way, you will quickly realize that it gets complex and slow pretty
    soon.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 查找文本相似性并不是一项简单的任务。如果您尝试自己去做，您很快就会意识到它很快变得复杂和缓慢。
- en: The Python library provides tools to detect differences between two sequences
    in the `difflib` module. Since text itself is a sequence (a sequence of characters),
    we can apply the provided functions to detect similarities in strings.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Python库提供了在`difflib`模块中检测两个序列之间差异的工具。由于文本本身是一个序列（字符序列），我们可以应用提供的函数来检测字符串的相似性。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps for this recipe:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此食谱的以下步骤：
- en: 'Given a string, we want to compare:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个字符串，我们想要比较：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Furthermore, we want to compare a set of strings to the first string:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们想将一组字符串与第一个字符串进行比较：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can use `difflib.SequenceMatcher` to compute the similitude (from 0 to 1)
    between the strings:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`difflib.SequenceMatcher`来计算字符串之间的相似度（从0到1）。
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So `SequenceMatcher` was able to detect that `s` and `s2` are very similar (98%),
    and apart from a typo in `weather`*,* they are in fact the same exact phrase.
    Then it stated that `Today the weather is nice` is 80% similar to `Yesterday the
    weather was nice` and finally that `Today the weather is nice` and `Today my dog
    ate steak` have very little in common.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`SequenceMatcher`能够检测到`s`和`s2`非常相似（98%），除了`weather`中的拼写错误之外，它们实际上是完全相同的短语。然后它指出`Today
    the weather is nice`与`Yesterday the weather was nice`相似度为80%，最后指出`Today the weather
    is nice`和`Today my dog ate steak`几乎没有共同之处。
- en: There's more...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `SequenceMatcher` provides support for marking some values as *junk.* You
    might expect this to mean that those values are ignored, but in fact that's not
    what happens.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`SequenceMatcher`提供了对一些值标记为*junk*的支持。您可能期望这意味着这些值被忽略，但实际上并非如此。'
- en: 'Computing ratios with and without junk will return the same value in most cases:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用和不使用垃圾计算比率在大多数情况下将返回相同的值：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `a` results were not ignored even though we provided an `isjunk` function
    that reports all `a` results as junk (the first argument to `SequenceMatcher`).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们提供了一个报告所有`a`结果为垃圾的`isjunk`函数（`SequenceMatcher`的第一个参数），`a`的结果也没有被忽略。
- en: 'You can see by using `.get_matching_blocks()` that in both cases the only parts
    of the string that match are the `X` in position `13` and `0` for `a` and `b`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`.get_matching_blocks()`来看到，在这两种情况下，字符串匹配的唯一部分是`X`在位置`13`和`0`处的`a`和`b`：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you want to ignore some characters when computing the difference, you will
    have to strip them before running the `SequenceMatcher`, maybe using a translation
    map that discards them all:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在计算差异时忽略一些字符，您将需要在运行`SequenceMatcher`之前剥离它们，也许使用一个丢弃它们的翻译映射：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Text suggestion
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本建议
- en: In our previous recipe, we saw how `difflib` can compute the similitude between
    two strings. This means that we can compute the similitude between two words and
    suggest corrections to our users.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的食谱中，我们看到`difflib`如何计算两个字符串之间的相似度。这意味着我们可以计算两个单词之间的相似度，并向我们的用户提供建议更正。
- en: If the set of *correct* words is known (which usually is for any language),
    we can first check if the word is in this set and, if not, we can look for the
    most similar one to suggest to the user the right spelling.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已知*正确*单词的集合（通常对于任何语言都是如此），我们可以首先检查单词是否在这个集合中，如果不在，我们可以寻找最相似的单词建议给用户正确的拼写。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The steps to follow this recipe are:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循此食谱的步骤是：
- en: 'First of all we need the set of valid words. To avoid bringing in the whole
    English dictionary, we will just sample some words:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一组有效的单词。为了避免引入整个英语词典，我们只会抽样一些单词：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we can make a function that for any provided phrase looks for the words
    in our dictionary and, if they are not there, provides the most similar candidate
    through `difflib`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以编写一个函数，对于提供的任何短语，都会在我们的字典中查找单词，如果找不到，就通过`difflib`提供最相似的候选词：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our `suggest` function will be able to detect misspellings and suggest a corrected
    phrase:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`suggest`函数将能够检测拼写错误并建议更正的短语：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first returned argument is the number of wrong words detected and the second
    is the string with the most reasonable corrections.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个返回的参数是检测到的错误单词数，第二个是具有最合理更正的字符串。
- en: 'If our phrase has no errors, we will just get back `0` with the original phrase:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的短语没有错误，我们将得到原始短语的`0`：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Templating
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: A very frequent need when showing text to users is to generate it dynamically
    depending on the state of the software.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户显示文本时，经常需要根据软件状态动态生成文本。
- en: 'Typically, this leads to code like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这会导致这样的代码：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This makes it very hard to foresee the upcoming structure of the message and
    it's also very hard to maintain in the long term. To generate text, it's usually
    more convenient to reverse the approach and instead of putting text in code, we
    shall put code in text. That's exactly what template engines do and, while the
    standard library has very complete solutions for formatting, it lacks a template
    engine out of the box, but it can easily be extended to make one.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得很难预见消息的即将到来的结构，而且在长期内也很难维护。生成文本时，通常更方便的是反转这种方法，而不是将文本放入代码中，我们应该将代码放入文本中。这正是模板引擎所做的，虽然标准库提供了非常完整的格式化解决方案，但缺少一个开箱即用的模板引擎，但可以很容易地扩展为一个模板引擎。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The steps for this recipe are:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的步骤如下：
- en: 'The `string.Formatter` object allows you to extend its syntax, so we can specialize
    it to support injecting code into the expressions that it''s going to accept:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`string.Formatter`对象允许您扩展其语法，因此我们可以将其专门化以支持将代码注入到它将要接受的表达式中：'
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our `TemplateFormatter` can then be used to generate text similar to our example
    in a much cleaner way:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们的`TemplateFormatter`可以用来以更简洁的方式生成类似于我们示例的文本：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The result should be:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `string.Formatter` supports the same language that the `str.format` method
    supports. Practically, it parses expressions contained with `{}` according to
    what Python calls *format string syntax*. Everything outside of `{}` is preserved
    as is, while anything within `{}` is parsed for the `field_name!conversion:format_spec`
    specification. So, as our `field_name` doesn't contain `!` or `:`, it can be anything
    else.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`string.Formatter`支持与`str.format`方法支持的相同语言。实际上，它根据Python称为*格式化字符串语法*的内容解析包含在`{}`中的表达式。`{}`之外的所有内容保持不变，而`{}`中的任何内容都会被解析为`field_name!conversion:format_spec`规范。因此，由于我们的`field_name`不包含`!`或`:`，它可以是任何其他内容。'
- en: The `field_name` extracted is then provided to `Formatter.get_field` to look
    up the value of that field in the provided arguments of the `format` method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后提取的`field_name`被提供给`Formatter.get_field`，以查找`format`方法提供的参数中该字段的值。
- en: 'So, for example, take an expression like:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，采用这样的表达式：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This leads to:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Because the `{name}` is identified as a block to parse, the name is looked up
    in `.format` arguments and the rest is preserved as is.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`{name}`被识别为要解析的块，所以会在`.format`参数中查找名称，并保留其余部分不变。
- en: This is very convenient and can solve most string formatting needs, but it lacks
    the power of a real template engine like loops and conditionals.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便，可以解决大多数字符串格式化需求，但缺乏像循环和条件语句这样的真正模板引擎的功能。
- en: What we did is extended `Formatter` not only to resolve variables specified
    in `field_name`, but also to evaluate Python expressions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是扩展`Formatter`，不仅解析`field_name`中指定的变量，还评估Python表达式。
- en: 'As we know that all `field_name` resolutions go through `Formatter.get_field`,
    overriding that method in our own custom class would allow us to change what happens
    whenever a `field_name` like `{name}` is evaluated:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道所有的`field_name`解析都要经过`Formatter.get_field`，在我们自己的自定义类中覆盖该方法将允许我们更改每当评估像`{name}`这样的`field_name`时发生的情况：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To distinguish plain variables from expressions, we used the `$` symbol. As
    a Python variable could never start with `$`, there was no risk that we would
    collide with an argument provided to format (as `str.format($something=5` is actually
    a syntax error in Python). So, a `field_name` like `{$something}` would not mean
    looking up the value of `''''$something`, but to evaluate the `something` expression:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分普通变量和表达式，我们使用了`$`符号。由于Python变量永远不会以`$`开头，因此我们不会与提供给格式化的参数发生冲突（因为`str.format($something=5`实际上是Python中的语法错误）。因此，像`{$something}`这样的`field_name`不意味着查找`''$something`的值，而是评估`something`表达式：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `eval` function runs any code written in a string and restricts execution
    to an expression (expressions in Python always lead to a value, differently from
    statements which don''t), so we also had syntax checking that would prevent template
    users from writing `if something: x=''hi''`, which wouldn''t provide any value
    to display in the text resulting from rendering the template.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval`函数运行在字符串中编写的任何代码，并将执行限制为表达式（Python中的表达式总是导致一个值，与不导致值的语句不同），因此我们还进行了语法检查，以防止模板用户编写`if
    something: x=''hi''`，这将不会提供任何值来显示在渲染模板后的文本中。'
- en: Then, as we want users to be able to look up any variable that was referenced
    by the expressions they provided (like `{$len(messages)}`), we provide `kwargs`
    as the `locals` variables to `eval`, so that any expression referring to a variable
    would properly resolve. We also provide an empty global context `{}`, so that
    we don't inadvertently touch any global variable of our software.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，由于我们希望用户能够查找到他们提供的表达式引用的任何变量（如`{$len(messages)}`），我们将`kwargs`提供给`eval`作为`locals`变量，以便任何引用变量的表达式都能正确解析。我们还提供一个空的全局上下文`{}`，以便我们不会无意中触及软件的任何全局变量。
- en: 'The final part left is just returning the result of the expression execution
    provided by `eval` as the result of the `field_name` resolution:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的最后一部分就是将`eval`提供的表达式执行结果作为`field_name`解析的结果返回：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The really interesting part is that as all the processing happens in the `get_field`
    phase. Conversion and format specification are still supported as they are applied
    over the value returned by `get_field`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 真正有趣的部分是所有处理都发生在`get_field`阶段。转换和格式规范仍然受支持，因为它们是应用于`get_field`返回的值。
- en: 'This allows us to write something like:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以写出这样的东西：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We get back `1.50` as the output instead of `1.5`. This is because we evaluate
    `3/2.0` as first thing in our specialized `TemplateFormatter.get_field` method
    and then the parser goes on applying the formatter specification (`.2f`) to the
    resulting value.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的输出是`1.50`，而不是`1.5`。这是因为我们在我们专门的`TemplateFormatter.get_field`方法中首先评估了`3/2.0`，然后解析器继续应用格式规范（`.2f`）到结果值。
- en: There's more...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Our simple template engine is convenient, but limited to cases where we can
    express the code generating our text as a set of expressions and static text.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的简单模板引擎很方便，但仅限于我们可以将生成文本的代码表示为一组表达式和静态文本的情况。
- en: The problem is that more advanced templates are not always possible to represent.
    We are restricted to plain expressions, so practically anything that cannot be
    represented in a `lambda` cannot be executed by our template engine.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于更高级的模板并不总是可以表示。我们受限于简单的表达式，因此实际上任何不能用`lambda`表示的东西都不能由我们的模板引擎执行。
- en: While some would argue that very complex software can be written by combining
    multiple `lambda`, most people would recognize that statements lead to far more
    readable code.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有人会认为通过组合多个`lambda`可以编写非常复杂的软件，但大多数人会认为语句会导致更可读的代码。
- en: For that reason, if you need to process very complex text, you should go to
    a full-featured template engine and look for something such as Jinja, Kajiki,
    or Mako as a solution to your problem. Especially for generating HTML, solutions
    such as Kajiki, which is also able to validate your HTML, are very convenient
    and can go much further than our `TemplateFormatter`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你需要处理非常复杂的文本，你应该使用功能齐全的模板引擎，并寻找像Jinja、Kajiki或Mako这样的解决方案。特别是对于生成HTML，像Kajiki这样的解决方案，它还能够验证你的HTML，非常方便，可以比我们的`TemplateFormatter`做得更多。
- en: Splitting strings and preserving spaces
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分字符串并保留空格
- en: Usually when splitting strings on spaces, developers will tend to rely on `str.split`,
    which is able to serve that purpose pretty well. But when the need to *split some
    spaces and preserve others* arises, things quickly become harder and implementing
    a custom solution can require investing time in proper escaping.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在按空格拆分字符串时，开发人员倾向于依赖`str.split`，它能够很好地完成这个目的。但是当需要*拆分一些空格并保留其他空格*时，事情很快变得更加困难，实现一个自定义解决方案可能需要投入时间来进行适当的转义。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Just rely on `shlex.split` instead of `str.split`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 只需依赖`shlex.split`而不是`str.split`：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`shlex` is a module originally created to parse Unix shell code. For that reason,
    it supports preserving phrases through quotes. Typically, in Unix command lines,
    words separated by spaces are provided as arguments to the called command, but
    if you want to provide multiple words as a single argument, you can use quotes
    to group them.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`shlex`是最初用于解析Unix shell代码的模块。因此，它支持通过引号保留短语。通常在Unix命令行中，由空格分隔的单词被提供为调用命令的参数，但如果你想将多个单词作为单个参数提供，可以使用引号将它们分组。'
- en: That's exactly what `shlex` reproduces, providing us with a reliable way to
    drive the splitting. We just need to wrap everything we want to preserve in double
    or single quotes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是`shlex`所复制的，为我们提供了一个可靠的驱动拆分的方法。我们只需要用双引号或单引号包裹我们想要保留的所有内容。
- en: Cleanup text
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理文本
- en: When analyzing user-provided text, we are frequently interested only in meaningful
    words; punctuation, spaces, and conjunctions might easily get in our way. Suppose
    you want to count word frequencies in a book, you don't want to end up with "world"
    and "world" being counted as two different words.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析用户提供的文本时，我们通常只对有意义的单词感兴趣；标点、空格和连词可能很容易妨碍我们。假设你想要统计一本书中单词的频率，你不希望最后得到"world"和"world"被计为两个不同的单词。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You have to perform the following steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要执行以下步骤：
- en: 'Supply the text you want to clean up:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供要清理的文本：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can rely on `string.punctuation` to know which characters we want to discard
    and make a translation table to discard them all:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以依赖`string.punctuation`来知道我们想要丢弃的字符，并制作一个转换表来丢弃它们全部：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The result will be a cleaned-up version of our text:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是我们文本的清理版本：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The core of this recipe is the usage of translation tables. Translation tables
    are mappings that link a character to its replacement. A translation table like `{''c'':
    ''A''}` means that any `''c''` must be replaced with an `''A''`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '这个示例的核心是使用转换表。转换表是将字符链接到其替换的映射。像`{''c'': ''A''}`这样的转换表意味着任何`''c''`都必须替换为`''A''`。'
- en: '`str.maketrans` is the function used to build translation tables. Each character
    in the first argument will be mapped to the character in the same position in
    the second argument. Then all characters in the last argument will be mapped to `None`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.maketrans`是用于构建转换表的函数。第一个参数中的每个字符将映射到第二个参数中相同位置的字符。然后最后一个参数中的所有字符将映射到`None`：'
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `97`, `98`, and `99` are the Unicode values for `''a''`, `''b''`, and `''c''`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`97`，`98`和`99`是`''a''`，`''b''`和`''c''`的Unicode值：'
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then our mapping can be passed to `str.translate` to apply it on the target
    string. The interesting part is that any character that is mapped to `None` will
    be just removed:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的映射可以传递给`str.translate`来应用到目标字符串上。有趣的是，任何映射到`None`的字符都将被删除：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In our previous example, we provided as `str.maketrans` the third argument `string.punctuation`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，我们将`string.punctuation`作为`str.maketrans`的第三个参数。
- en: '`string.punctuation` is a string that contains the most common punctuation
    characters:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`string.punctuation`是一个包含最常见标点字符的字符串：'
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'By doing so, we built a transaction map that mapped each punctuation character
    to `None` and didn''t specify any other mapping:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们建立了一个事务映射，将每个标点字符映射到`None`，并没有指定任何其他映射：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This, once applied with `str.translate`, made it so that punctuation characters
    were all discarded, preserving all the other characters as they were:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，一旦应用了`str.translate`，标点字符就都被丢弃了，保留了所有其他字符：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Normalizing text
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本规范化
- en: In many cases, a single word can be written in multiple ways. For example, users
    who wrote "Über" and "Uber" probably meant the same word. If you were implementing
    a feature like tagging for a blog, you certainly don't want to end up with two
    different tags for the two words.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，一个单词可以用多种方式书写。例如，写"Über"和"Uber"的用户可能意思相同。如果你正在为博客实现标记等功能，你肯定不希望最后得到两个不同的标记。
- en: So, before saving your tags, you might want to normalize them to plain ASCII
    characters so that they end up all being considered as the same tag.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在保存标签之前，您可能希望将它们标准化为普通的ASCII字符，以便它们最终被视为相同的标签。
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'What we need is a translation map that converts all accented characters to
    their plain representation:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一个翻译映射，将所有带重音的字符转换为它们的普通表示：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then we can apply it to any word to normalize it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将其应用于任何单词来进行规范化：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We already know as explained in the *Cleanup text* recipe how `str.translate` works:
    each character is looked up in a translation table and it’s substituted with the
    replacement specified in the table.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何解释*清理文本*食谱中解释的那样，`str.translate`是如何工作的：每个字符都在翻译表中查找，并且用表中指定的替换进行替换。
- en: So, what we need is a translation table that maps `"Ü"` to `"U"` and `"ç"` to `"c"`,
    and so on.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要的是一个翻译表，将`"Ü"`映射到`"U"`，将`"ç"`映射到`"c"`，依此类推。
- en: But how can we know all these mappings? One interesting property of these characters
    is that they can be considered plain characters with an added symbol. Much like
    `à` can be considered an `a` with an accent.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何知道所有这些映射呢？这些字符的一个有趣特性是它们可以被认为是带有附加符号的普通字符。就像`à`可以被认为是带有重音的`a`。
- en: Unicode equivalence knows this and provides multiple ways to write what's considered
    the same character. What we are really interested in is decomposed form, which
    means to write a character as multiple separated symbols that define it. For example, `é`
    would be decomposed to `0065` and `0301`, which are the code points for `e` and
    the accent.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode等价性知道这一点，并提供了多种写入被认为是相同字符的方法。我们真正感兴趣的是分解形式，这意味着将字符写成定义它的多个分隔符。例如，`é`将被分解为`0065`和`0301`，这是`e`和重音的代码点。
- en: 'Python provides a way to know the decomposed version of a character through
    the `unicodedata.decompostion` function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一种通过`unicodedata.decompostion`函数知道字符分解版本的方法：
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The first code point is the one of the base character, while the second is
    the added symbol. So to normalize our `è`, we would pick the first code point
    `0065` and throw away the symbol:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个代码点是基本字符的代码点，而第二个是添加的符号。因此，要规范化我们的`è`，我们将选择第一个代码点`0065`并丢弃符号：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now we can't use the code point by itself, but we want the character it represents.
    Luckily, the `chr` function provides a way to get a character from the integer
    representation of its code point.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不能单独使用代码点，但我们想要它表示的字符。幸运的是，`chr`函数提供了一种从其代码点的整数表示中获取字符的方法。
- en: 'The `unicodedata.decomposition` function provided the code points as strings
    representing hexadecimal numbers, so first we need to convert them to integers:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`unicodedata.decomposition`函数提供的代码点是表示十六进制数字的字符串，因此首先我们需要将它们转换为整数：'
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then we can apply `chr` to know the actual character:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以应用`chr`来知道实际的字符：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now we know how to decompose these characters and get the base characters to
    which we want to normalize them all, but how can we build a translation map for
    all of them?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何分解这些字符并获得我们想要将它们全部标准化为的基本字符，但是我们如何为它们构建一个翻译映射呢？
- en: The answer is we don't. Building the translation map beforehand for all characters
    wouldn't be very convenient, so we can use a feature provided by dictionaries
    to build the translation for a character dynamically when it's needed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是我们不需要。事先为所有字符构建翻译映射并不是很方便，因此我们可以使用字典提供的功能，在需要时动态地为字符构建翻译。
- en: Translation maps are dictionaries and whenever a dictionary needs to look up
    a key that it doesn't know, it can rely on the `__missing__` method to generate
    a value for that key. So our `__missing__` method has to do what we just did and
    use `unicodedata.decomposition` to grab the normalized version of a character
    whenever `str.translate` tries to look it up in our translation map.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译映射是字典，每当字典需要查找它不知道的键时，它可以依靠`__missing__`方法为该键生成一个值。因此，我们的`__missing__`方法必须做我们刚才做的事情，并使用`unicodedata.decomposition`来获取字符的规范化版本，每当`str.translate`尝试在我们的翻译映射中查找它时。
- en: Once we have computed the translation for the requested character, we just store
    it in the dictionary itself, so the next time it will be asked for, we won't have
    to compute it again.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们计算出所请求字符的翻译，我们只需将其存储在字典本身中，这样下次再被请求时，我们就不必再计算它。
- en: So, the `unaccented_map` of our recipe is just a dictionary providing a `__missing__`
    method that relies on `unicodedata.decompostion` to retrieve the normalized version
    of each provided character.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的食谱的`unaccented_map`只是一个提供`__missing__`方法的字典，该方法依赖于`unicodedata.decompostion`来检索每个提供的字符的规范化版本。
- en: If it is unable to find a denormalized version of the character, it will just
    return the original version once so that the string doesn't get corrupted.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它无法找到字符的非规范化版本，它将只返回原始版本一次，以免字符串被损坏。
- en: Aligning text
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对齐文本
- en: When printing tabular data, it's usually very important to ensure that the text
    is properly aligned to a fixed length, no longer and no shorter than the space
    we reserved for our table cell.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印表格数据时，通常非常重要的是确保文本正确对齐到固定长度，既不长也不短于我们为表格单元保留的空间。
- en: 'If the text is too short, the next column might start too early; if it''s too
    long, it might start too late. This leads to results like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文本太短，下一列可能会开始得太早；如果太长，它可能会开始得太晚。这会导致像这样的结果：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Or this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这样：
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Both of these are really hard to read and are far from showing a proper table.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者都很难阅读，并且远非显示正确表格的样子。
- en: Given a fixed column width (20 characters), we want our text to always be of
    that exact length so that it won't result in a misaligned table.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 给定固定的列宽（20个字符），我们希望我们的文本始终具有确切的长度，以便它不会导致错位的表格。
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps for this recipe:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此食谱的步骤：
- en: 'The `textwrap` module once combined with the features of the `str` object can
    help us achieve the expected result. First we need the content of the columns
    we want to print:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦将`textwrap`模块与`str`对象的特性结合起来，就可以帮助我们实现预期的结果。首先，我们需要打印的列的内容：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then we need to fix the size of a column:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要修复列的大小：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once those are ready, we can actually implement our indentation function:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦这些准备好了，我们就可以实际实现我们的缩进函数：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then we can properly print any table:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以正确地打印任何表格：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'There are three problems we have to solve to implement our `maketable` function:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须解决三个问题来实现我们的`maketable`函数：
- en: Lengthen text shorter than 20 characters
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长度小于20个字符的文本
- en: Split text longer than 20 characters on multiple lines
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将长度超过20个字符的文本拆分为多行
- en: Fill missing lines in columns with fewer lines
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充列中缺少的行
- en: 'If we decompose our `maketable` function, the first thing it does is to split
    text longer than 20 characters into multiple lines:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分解我们的`maketable`函数，它的第一件事就是将长度超过20个字符的文本拆分为多行：
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'That applied to each column leads us to having a list of columns, each containing
    a list of rows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将其应用于每一列，我们得到了一个包含列的列表，每个列包含一列行：
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then we need to ensure that each row shorter than 20 characters is extended
    to be exactly 20 characters, so that our table retains shape, and that''s achieved
    by applying the `ljust` method to each row:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要确保每行长度小于20个字符的文本都扩展到恰好20个字符，以便我们的表保持形状，这是通过对每行应用`ljust`方法来实现的：
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Combining `ljust` with `textwrap` leads to the result we were looking for:
    a list of columns containing rows of 20 characters each:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ljust`与`textwrap`结合起来，就得到了我们想要的结果：包含每个20个字符的行的列的列表：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now we need to find a way to flip rows and columns, as when printing we need
    to print by row due to the `print` function printing one row at a time. Also,
    we need to ensure that each column has the same amount of rows, as we need to
    print all the rows when printing by row.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要找到一种方法来翻转行和列，因为在打印时，由于`print`函数一次打印一行，我们需要按行打印。此外，我们需要确保每列具有相同数量的行，因为按行打印时需要打印所有行。
- en: 'Both these needs can be solved by the `itertools.zip_longest` function, which
    will generate a new list by interleaving the values contained in each one of the
    provided lists until the longest list is exhausted. As `zip_longest` goes on until
    the longest iterable is exhausted, it supports a `fillvalue` argument that can
    be used to specify a value used to fill values for shorter lists:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个需求都可以通过`itertools.zip_longest`函数解决，它将生成一个新列表，通过交错提供的每个列表中包含的值，直到最长的列表用尽。由于`zip_longest`会一直进行，直到最长的可迭代对象用尽，它支持一个`fillvalue`参数，该参数可用于指定用于填充较短列表的值：
- en: '[PRE52]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The result will be a list of rows, each containing a column, with empty columns
    for rows that didn''t have a value for them:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一列包含一列的行的列表，对于没有值的行，将有空列：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The tabular form of the text is now clearly visible. The last two steps in
    our function involve adding a `|` separator between the columns and merging the
    columns in a single string through `'' | ''.join`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 文本的表格形式现在清晰可见。我们函数中的最后两个步骤涉及在列之间添加`|`分隔符，并通过`' | '.join`将列合并成单个字符串：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This will result in a list of strings containing the text of all three columns:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致一个包含所有三列文本的字符串列表：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, the rows can be printed. For the purpose of returning a single string,
    our function applies one last step and joins all the lines in a single string
    separated by newline characters by applying a final `''n''.join()`, which leads
    to returning a single string containing the whole text ready for printing:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，行可以被打印。为了返回单个字符串，我们的函数应用了最后一步，并通过应用最终的`'n'.join()`将所有行连接成一个由换行符分隔的单个字符串，从而返回一个包含整个文本的单个字符串，准备打印：
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
