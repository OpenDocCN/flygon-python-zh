- en: Read/Write Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读/写数据
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Reading and writing text data—reading text encoded in any encoding from a file
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入文本数据——从文件中读取任何编码的文本
- en: Reading lines of text—reading a text file divided line by line
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文本行——逐行读取文本文件
- en: Reading and writing binary data—reading binary-structured data from a file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入二进制数据——从文件中读取二进制结构化数据
- en: Zipping a directory—reading and writing a compressed ZIP archive
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩目录——读取和写入压缩的ZIP存档
- en: Pickling and shelving—how to save Python objects on disk
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pickling和shelving——如何将Python对象保存在磁盘上
- en: Reading configuration files—how to read configuration files in the `.ini` format
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取配置文件——如何读取`.ini`格式的配置文件
- en: Writing XML/HTML content—generating XML/HTML content
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入XML/HTML内容——生成XML/HTML内容
- en: Reading XML/HTML content—parsing XML/HTML content from a file or string
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取XML/HTML内容——从文件或字符串解析XML/HTML内容
- en: Reading and writing CSV—reading and writing CSV spreadsheet-like files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入CSV——读取和写入类似电子表格的CSV文件
- en: Reading and writing to a relational database—loading and saving data into a
    `SQLite` database
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入关系数据库——将数据加载到`SQLite`数据库中
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'The input for your software will come from various sources: command-line options,
    the standard input, the network, and, frequently, files. Reading from an input
    itself is rarely the problem when dealing with external sources of data; some
    input might require a bit more setup, some are more straightforward, but generally
    it''s just a matter of opening it and then reading from it.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您的软件的输入将来自各种来源：命令行选项，标准输入，网络，以及经常是文件。从输入中读取本身很少是处理外部数据源时的问题；一些输入可能需要更多的设置，有些更直接，但通常只是打开它然后从中读取。
- en: The problem arises with what to do with the data that we read. There are thousands
    of formats out there, each with its own complexities, some are text-based and
    some are binaries. In this chapter, we will set recipes to deal with the most
    common formats that you will probably have to face during your life as a developer.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在我们读取的数据该如何处理。有成千上万种格式，每种格式都有其自己的复杂性，有些是基于文本的，有些是二进制的。在本章中，我们将设置处理您作为开发人员在生活中可能会遇到的最常见格式的配方。
- en: Reading and writing text data
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入文本数据
- en: When reading a text file, we already know we should open it in text mode, which
    is the default Python mode. In this mode, Python will try to decode the content
    of the file according to what `locale.getpreferredencoding` returns as being the
    preferred encoding for our system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取文本文件时，我们已经知道应该以文本模式打开它，这是Python的默认模式。在这种模式下，Python将尝试根据`locale.getpreferredencoding`返回的作为我们系统首选编码的编码来解码文件的内容。
- en: Sadly, the fact that any type of encoding is the preferred encoding for our
    system has nothing to do with what encoding might have been used to save the contents
    of the file. As it might be a file that someone else wrote, or even if we write
    it ourselves, the editor might have saved it in any encoding.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，任何类型的编码都是我们系统的首选编码与文件内容保存时使用的编码无关。因为它可能是别人写的文件，甚至是我们自己写的，编辑器可能以任何编码保存它。
- en: So the only solution is to specify the encoding that should be used to decode
    the file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，唯一的解决方案是指定应该用于解码文件的编码。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `open` function that Python provides accepts an `encoding` argument that
    can be used to properly encode/decode the contents of a file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供的`open`函数接受一个`encoding`参数，可以用于正确地编码/解码文件的内容：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once the `encoding` option is passed to `open`, the resulting object file will
    know that any string provided to `file.write` must be encoded to the specified
    encoding before storing the actual bytes into the file. This is also true for
    `file.read()`, which will fetch the bytes from the file and decode them with the
    specified encoding before returning them to you.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`encoding`选项传递给`open`，生成的文件对象将知道任何提供给`file.write`的字符串必须在将实际字节存储到文件之前编码为指定的编码。对于`file.read()`也是如此，它将从文件中获取字节，并在将它们返回给您之前使用指定的编码对其进行解码。
- en: This allows you to read/write content in files with any encoding independently
    from the one that your system declares as the favorite one.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您独立于系统声明的首选编码，读/写文件中的内容。
- en: There's more...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you're wondering how it might be possible to read a file for which the encoding
    is unknown, well, that's a far more complex problem.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道如何可能读取编码未知的文件，那么这是一个更加复杂的问题。
- en: The fact is that unless the file provides some guidance in a header, or something
    equivalent, that can tell you the type of encoding on the content, there is no
    reliable way to know how a file might be encoded.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是，除非文件在头部提供一些指导，或者等效物，可以告诉您内容的编码类型，否则没有可靠的方法可以知道文件可能被编码的方式。
- en: 'You might try multiple different types of encoding and check which one is able
    to decode the content (doesn''t throw `UnicodeDecodeError`), but the fact that
    a set of bytes decodes to an encoding doesn''t guarantee that it decodes to the
    right result. For example, the `''ì''` character encoded to `utf-8` decodes perfectly
    in `latin-1`, but results in a totally different thing:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试多种不同类型的编码，并检查哪种编码能够解码内容（不会抛出`UnicodeDecodeError`），但是一组字节解码为一种编码并不保证它解码为正确的结果。例如，编码为`utf-8`的`'ì'`字符在`latin-1`中完美解码，但结果完全不同：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you really want to try guessing the type-encoding of the content, you might
    want to try a library, such as `chardet`, that is able to detect most common types
    of encoding. If the length of the data to decode is long and varied enough, it
    will frequently succeed in detecting the right encoding.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的想尝试猜测内容的类型编码，您可能想尝试一个库，比如`chardet`，它能够检测到大多数常见类型的编码。如果要解码的数据长度足够长且足够多样化，它通常会成功地检测到正确的编码。
- en: Reading lines of text
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取文本行
- en: When working with text files, the easiest way to process them is usually by
    line; each line of text is a separate entity and we can build them back by joining
    all lines by `'\n'` or `'\r\n'` depending on the system, thus it would be very
    convenient to have all the lines of a text file available in a list.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文本文件时，通常最容易的方法是按行处理；每行文本是一个单独的实体，我们可以通过`'\n'`或`'\r\n'`连接所有行，因此在列表中有文本文件的所有行将非常方便。
- en: There is a very convenient way to grab lines out of a text file that Python
    makes instantly available.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种非常方便的方法可以立即从文本文件中提取行，Python可以立即使用。
- en: How to do it...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'As the `file` object itself is an iterable, we can directly build a list out
    of it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`file`对象本身是可迭代的，我们可以直接构建一个列表：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`open` acts as a context manager, returning the resulting object file. It''s
    very convenient to rely on the context manager as, when we are done with our file,
    we need to close it and using `open` as a context manager will actually do that
    for us as soon as we quit the body of `with`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`open`充当上下文管理器，返回结果对象`file`。依赖上下文管理器非常方便，因为当我们完成文件操作时，我们需要关闭它，使用`open`作为上下文管理器将在我们退出`with`的主体时为我们关闭文件。'
- en: The interesting part is that `file` is actually an iterable. When you iterate
    over a file, you get back the lines that are contained within it. So applying
    `list` to it will build a list of all the lines and we can then navigate the resulting
    list as we wish.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是`file`实际上是一个可迭代对象。当你迭代一个文件时，你会得到其中包含的行。因此，将`list`应用于它将构建所有行的列表，然后我们可以按照我们的意愿导航到结果列表。
- en: Reading and writing binary data
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符
- en: Reading text data is already pretty complex as it requires decoding the contents
    of a file, but reading binary data can be far more complex as it requires parsing
    the bytes and their contents to reconstruct the original data that was saved within
    the file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文本数据已经相当复杂，因为它需要解码文件的内容，但读取二进制数据可能会更加复杂，因为它需要解析字节及其内容以重建保存在文件中的原始数据。
- en: In some cases, you might even have to cope with byte-ordering because, when
    saving a number into a text file, the order the bytes will be written in really
    depends on the system that is writing that file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，甚至可能需要处理字节顺序，因为当将数字保存到文本文件时，字节的写入顺序实际上取决于写入该文件的系统。
- en: 'Suppose we want to read the beginning of the TCP header, the specific source
    and destination port, sequence number, and acknowledgment number, which is represented
    as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要读取TCP头的开头，特定的源和目标端口、序列号和确认号，表示如下：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The steps for this recipe are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱的步骤如下：
- en: Given a file that contains a dump of a TCP packet (on my computer, I saved it
    as `/tmp/packet.dump`), we can try to read it as binary data and parse its contents.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设有一个包含TCP数据包转储的文件（在我的计算机上，我将其保存为`/tmp/packet.dump`），我们可以尝试将其读取为二进制数据并解析其内容。
- en: 'The Python `struct` module is the perfect tool for reading binary-structured
    data and we can use it to parse our TCP packet as we know the size of each piece:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`struct`模块是读取二进制结构化数据的完美工具，我们可以使用它来解析我们的TCP数据包，因为我们知道每个部分的大小：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Being an HTTP connection, the result is what we would expect: `Source Port:
    50291, Destination Port: 80, Sequence Number: 2778997212`, and `Acknowledgment
    Number: 644363807`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 作为HTTP连接，结果是我们所期望的：`源端口：50291，目标端口：80，序列号：2778997212`和`确认号：644363807`。
- en: 'The same can be done to write back the binary data by using `struct.pack`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`struct.pack`将二进制数据写回：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: First of all, we opened the file in *binary mode* (the `rb` argument). This
    tells Python to avoid trying to decode the contents of the file as if it was text;
    the content is returned as it is in a `bytes` object.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们以*二进制模式*（`rb`参数）打开文件。这告诉Python避免尝试解码文件的内容，就像它是文本一样；内容以`bytes`对象的形式返回。
- en: Then the data we read with `f.read()` is passed to `struct.unpack_from`, which
    is able to decode binary data as a set of numbers, strings, and so on. In our
    case, we used `>` to specify that the data we are reading is in big-endian ordering
    (like all network-related data) and then `HHLL` to state that we want to read
    two unsigned 16-bit numbers and two unsigned 32-bit numbers (the ports and the
    sequence/acknowledgment numbers).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`f.read()`读取的数据传递给`struct.unpack_from`，它能够解码二进制数据作为一组数字、字符串等。在我们的例子中，我们使用`>`指定我们正在读取的数据是大端排序的（就像所有与网络相关的数据一样），然后使用`HHLL`来说明我们要读取两个无符号16位数字和两个无符号32位数字（端口和序列/确认号）。
- en: As we used `unpack_from`, any other remaining data is just ignored after the
    four specified numbers are consumed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了`unpack_from`，在消耗了指定的四个数字后，任何其他剩余的数据都会被忽略。
- en: The same applies to writing binary data. We opened the file in binary mode,
    packaged the four numbers into a bytes object through `struct.pack`, and wrote
    them to the file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 写入二进制数据也是一样的。我们以二进制模式打开文件，通过`struct.pack`将四个数字打包成一个字节对象，并将它们写入文件。
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `struct.pack` and `struct.unpack` functions support many options and formatters
    to define what data should be written/read and how it should be written/read.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct.pack`和`struct.unpack`函数支持许多选项和格式化程序，以定义应该写入/读取的数据以及应该如何写入/读取。'
- en: 'The most common formatters for byte order are the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 字节顺序的最常见格式化程序如下：
- en: '| Character | Byte order |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: 字节顺序
- en: '| --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: 读取和写入二进制数据
- en: '| `=` | native |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: 本地
- en: '| `<` | little-endian |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: 小端
- en: '| `>` | big-endian |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: 大端
- en: If none of those is specified, the data will be encoded in your system native
    byte order and will be aligned as it's naturally aligned in your system memory.
    It's strongly discouraged to save data this way as the only system guaranteed
    to be able to read it back is the one that saved it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定这些选项中的任何一个，数据将以您系统的本机字节顺序进行编码，并且将按照在系统内存中的自然对齐方式进行对齐。强烈不建议以这种方式保存数据，因为能够读取它的唯一系统是保存它的系统。
- en: 'For the data itself, each type of data is represented by a single character,
    and each character defines the kind of data (integer, float, string) and its size:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据本身，每种数据类型由一个单个字符表示，每个字符定义数据的类型（整数、浮点数、字符串）和其大小：
- en: '| Format | C type | Python type | Size (bytes) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 格式 | C类型 | Python类型 | 大小（字节） |'
- en: '| --- | --- | --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `x` | pad byte | no value |  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 填充字节 | 无值 |  |'
- en: '| `c` | `char` | bytes of length 1 | 1 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `c` | `char` | 长度为1的字节 | 1 |'
- en: '| `b` | signed `char` | integer | 1 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `b` | 有符号`char` | 整数 | 1 |'
- en: '| `B` | unsigned `char` | integer | 1 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `B` | 无符号`char` | 整数 | 1 |'
- en: '| `?` | `_Bool` | bool | 1 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `?` | `_Bool` | 布尔值 | 1 |'
- en: '| `h` | `short` | integer | 2 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `h` | `short` | 整数 | 2 |'
- en: '| `H` | unsigned `short` | integer | 2 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `H` | 无符号`short` | 整数 | 2 |'
- en: '| `i` | `int` | integer | 4 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `i` | `int` | 整数 | 4 |'
- en: '| `I` | unsigned `int` | integer | 4 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `I` | 无符号`int` | 整数 | 4 |'
- en: '| `l` | `long` | integer | 4 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `l` | `long` | 整数 | 4 |'
- en: '| `L` | unsigned `long` | integer | 4 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `L` | 无符号`long` | 整数 | 4 |'
- en: '| `q` | `long long` | integer | 8 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `q` | `long long` | 整数 | 8 |'
- en: '| `Q` | unsigned `long long` | integer | 8 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `Q` | 无符号`long long` | 整数 | 8 |'
- en: '| `n` | `ssize_t` | integer |  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `n` | `ssize_t` | 整数 |  |'
- en: '| `N` | `size_t` | integer |  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `N` | `size_t` | 整数 |  |'
- en: '| `e` | half precision `float` | float | 2 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `e` | 半精度`float` | 浮点数 | 2 |'
- en: '| `f` | `float` | float | 4 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `f` | `float` | 浮点数 | 4 |'
- en: '| `d` | `double` | float | 8 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `d` | `double` | 浮点数 | 8 |'
- en: '| `s` | `char[]` | bytes |  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `s` | `char[]` | 字节 |  |'
- en: '| `p` | `char[]` | bytes |  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `p` | `char[]` | 字节 |  |'
- en: '| `P` | `void *` | integer |  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `P` | `void *` | 整数 |  |'
- en: Zipping a directory
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压缩目录
- en: Archive files are a good way to distribute whole directories as if they were
    a single file and to reduce the size of the distributed files.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 存档文件是以一种好的方式来分发整个目录，就好像它们是单个文件，并且可以减小分发文件的大小。
- en: Python has built-in support for creating ZIP archive files, which can be leveraged
    to compress a whole directory.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Python内置支持创建ZIP存档文件，可以利用它来压缩整个目录。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The steps for this recipes are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的步骤如下：
- en: 'The `zipfile` module allows us to create compressed ZIP archives made up of
    multiple files:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`zipfile`模块允许我们创建由多个文件组成的压缩ZIP存档：'
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Using `zipdir` is as simple as providing a name for the `.zip` file that should
    be created and a path for the directory that should be archived:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`zipdir`就像提供应该创建的`.zip`文件的名称和应该存档的目录的路径一样简单：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this case, I compressed the directory that contains the document trees for
    this book. Once the archive is ready, we can verify its content by opening it
    with `zipfile` again and listing the contained entries:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我压缩了包含本书文档树的目录。存档准备好后，我们可以通过再次使用`zipfile`打开它并列出包含的条目来验证其内容：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: '`zipfile.ZipFile` is first opened in write mode with the `ZIP_DEFLATED` compression
    (which means compress the data with the standard ZIP format) as a context. That
    allows us to perform changes to the archive and then flush them and close the
    archive automatically as soon as we exit the body of the context manager.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`zipfile.ZipFile`首先以`ZIP_DEFLATED`压缩（这意味着用标准ZIP格式压缩数据）的写模式打开。这允许我们对存档进行更改，然后在退出上下文管理器的主体时自动刷新并关闭存档。'
- en: Within the context, we rely on `os.walk` to traverse the whole directory and
    all its subdirectories and find all the contained files.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文中，我们依靠`os.walk`来遍历整个目录及其所有子目录，并找到所有包含的文件。
- en: 'For each file found in each directory, we build two paths: the absolute one
    and the relative one.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在每个目录中找到的每个文件，我们构建两个路径：绝对路径和相对路径。
- en: The absolute one is required to tell `ZipFile` from where to read the data that
    needs to be added to the archive, and the relative one is used to give a proper
    name to the data we are writing into the archive. This way, each file we write
    into the archive will be named as it was on our disk, but instead of being stored
    with its full path (`/home/amol/pystlcookbook/_build/doctrees/io.doctree`), it
    will be stored with the relative path (`_build/doctrees/io.doctree`), so that
    in case the archive is decompressed, the file will be created relative to the
    directory we are decompressing into, instead of ending up with a long pointless
    path that resembles the one that the file had on my computer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对路径是必需的，以告诉`ZipFile`从哪里读取需要添加到存档中的数据，相对路径用于为写入存档的数据提供适当的名称。这样，我们写入存档的每个文件都将以磁盘上的名称命名，但是不会存储其完整路径（`/home/amol/pystlcookbook/_build/doctrees/io.doctree`），而是以相对路径（`_build/doctrees/io.doctree`）存储，因此，如果存档被解压缩，文件将相对于我们正在解压缩的目录创建，而不是以长而无意义的路径结束，这个路径类似于文件在我的计算机上的路径。
- en: Once the path of the file and the name that should be used to store it are ready,
    they are provided to `ZipFile.write` to actually write the file into the archive.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件的路径和应该用来存储它的名称准备好，它们就被提供给`ZipFile.write`来实际将文件写入存档。
- en: Once all the files are written, we exit the context manager and the archive
    is finally flushed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有文件都被写入，我们退出上下文管理器，存档最终被刷新。
- en: Pickling and shelving
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pickling and shelving
- en: If there is a lot of information that your software needs or if you want to
    preserve history across different runs, there is little choice apart from saving
    it somewhere and loading it back on the next run.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的软件需要大量信息，或者如果您希望在不同运行之间保留历史记录，除了将其保存在某个地方并在下次运行时加载它之外，几乎没有其他选择。
- en: Manually saving and loading back data can be tedious and error-prone, especially
    if the data structures are complex.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 手动保存和加载数据可能会很繁琐且容易出错，特别是如果数据结构很复杂。
- en: For this reason, Python provides a very convenient module, `shelve`, that allows
    us to save and restore Python objects of any kind as far as it's possible to `pickle`
    them.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Python提供了一个非常方便的模块`shelve`，允许我们保存和恢复任何类型的Python对象，只要可以对它们进行`pickle`。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following steps for this recipe:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此食谱：
- en: '`shelf`, implemented by `shelve`, can be opened like any other file in Python.
    Once opened, it''s possible to read and write keys into it like a dictionary:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`shelve`，由`shelve`实现，可以像Python中的任何其他文件一样打开。一旦打开，就可以像字典一样将键读入其中：'
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Values stored into `shelf` can be read back as a dictionary, too:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储到`shelf`中的值也可以作为字典读回：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Complex values, or even custom classes, can be stored in `shelve`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复杂的值，甚至自定义类，都可以存储在`shelve`中：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: The `shelve` module is implemented as a context manager that manages a `dbm`
    database.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve` 模块被实现为管理`dbm`数据库的上下文管理器。'
- en: When the context is entered, the database is opened, and the contained objects
    become accessible because `shelf` was a dictionary.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当上下文进入时，数据库被打开，并且因为`shelf`是一个字典，所以包含的对象变得可访问。
- en: 'Each object is stored into the database as a pickled object. That means that
    before storing it, each object is encoded with `pickle` and results in a serialized
    string:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象都作为一个pickled对象存储在数据库中。这意味着在存储之前，每个对象都使用`pickle`进行编码，并产生一个序列化字符串：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That allows `shelve` to store any kind of Python object, even custom classes,
    as far as they are available again at the time the object is read back.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许`shelve`存储任何类型的Python对象，甚至自定义类，只要它们在读取对象时再次可用。
- en: Then, when the context is exited, all the keys of `shelf` that were changed
    are written back to disk by calling `shelf.sync` when `shelf` is closed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当上下文退出时，所有已更改的`shelf`键都将通过在关闭`shelf`时调用`shelf.sync`写回磁盘。
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A few things need attention when working with `shelve`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`shelve`时需要注意一些事项。
- en: 'First of all, `shelve` doesn''t track mutations. If you store a mutable object
    (such as `dict` or `list`) in `shelf`, any change you do to it won''t be saved.
    Only changes to the root keys of `shelf` itself are tracked:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`shelve`不跟踪突变。如果您将可变对象（如`dict`或`list`）存储在`shelf`中，则对其进行的任何更改都不会被保存。只有对`shelf`本身的根键的更改才会被跟踪：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This just means that you need to reassign any value you want to mutate:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是意味着您需要重新分配您想要改变的任何值：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`shelve` doesn''t allow concurrent read/writes from multiple processes or threads.
    You must wrap the `shelf` access with a lock (such as by using `fcntl.flock`)
    if you want to access the same `shelf` from multiple processes.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve` 不允许多个进程或线程同时进行并发读/写。如果要从多个进程访问相同的`shelf`，则必须使用锁（例如使用`fcntl.flock`）来包装`shelf`访问。'
- en: Reading configuration files
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取配置文件
- en: When your software has too many options to simply pass them all through the
    command line, or when you want to ensure that your users don't have to manually
    provide them every time they start the application, loading those options from
    a configuration file is one of the most widespread solutions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的软件有太多的选项无法通过命令行简单地传递它们，或者当您希望确保用户不必每次启动应用程序时手动提供它们时，从配置文件加载这些选项是最常见的解决方案之一。
- en: Configuration files should be easy to read and write for humans, as they will
    be working with them quite often, and one of the most common requirements is for
    them to allow comments, so that the user can place comments in the configuration
    to write down why some options were set or how some values were computed. This
    way, when the user comes back to the configuration file in six months, they will
    still know the reasons for those options.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件应该易于人类阅读和编写，因为他们经常会与它们一起工作，而最常见的要求之一是允许注释，以便用户可以在配置中写下为什么设置某些选项或如何计算某些值的原因。这样，当用户在六个月后回到配置文件时，他们仍然会知道这些选项的原因。
- en: For these reasons, usually relying on JSON or machine-machine formats to configure
    options doesn't work very well, so a configuration-specific format is best.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常依赖于JSON或机器-机器格式来配置选项并不是很好，因此最好使用特定于配置的格式。
- en: One of the longest-living configuration formats is the `.ini` file, which allows
    us to declare multiple sections with the `[section]` syntax and to set options
    with the `name = value` syntax.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最长寿的配置格式之一是`.ini`文件，它允许我们使用`[section]`语法声明多个部分，并使用`name = value`语法设置选项。
- en: 'A resulting configuration file will look as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的配置文件将如下所示：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Another great advantage is that we can easily read `.ini` files from Python.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很大的优势是我们可以轻松地从Python中读取`.ini`文件。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The steps for this recipe are:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的步骤是：
- en: 'Most of the work of loading and parsing `.ini` can be done by the `configparser`
    module itself, but we are going to extend it to implement per-section default
    values and converters:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数加载和解析`.ini`的工作可以由`configparser`模块本身完成，但我们将扩展它以实现每个部分的默认值和转换器：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using the provided function is as easy as providing a configuration and a schema
    that should be used to parse it:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供的函数就像提供一个应该用于解析它的配置和模式一样容易：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The resulting configuration dictionary, `config`, will contain all the options
    provided in the configuration or declared in the schema, converted to the type
    specified in the schema:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的配置字典`config`将包含配置中提供的所有选项或在模式中声明的选项，转换为模式中指定的类型：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: 'The `read_config` function does three major things:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`read_config`函数执行三件主要事情：'
- en: 'Allows us to parse plain lists of options without sections. This allows us
    to parse simple `config` files:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们解析没有部分的简单`config`文件的纯列表选项：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Applies default values for all options declared in the configuration's `default` schema.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为配置的`default`模式中声明的所有选项应用默认值。
- en: Converts all values to the `type` provided in the schema.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有值转换为模式中提供的`type`。
- en: The first feature is provided by trapping any `MissingSectionHeaderError` exception
    raised during parsing and automatically adding a `[main]` section if it's missing.
    All the options provided without any section will be recorded under the `main`
    section.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个特性是通过捕获解析过程中引发的任何`MissingSectionHeaderError`异常来提供的，并在缺少时自动添加`[main]`部分。所有未在任何部分中提供的选项都将记录在`main`部分下。
- en: Providing default values is instead done by doing a first pass through all the
    sections and options declared in the schema and setting them to the value provided
    in their `default` or to `None` if no default value is provided.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 提供默认值是通过首先遍历模式中声明的所有部分和选项，并将它们设置为其`default`中提供的值或者如果没有提供默认值，则设置为`None`来完成的。
- en: In a second pass, all the default values are then overridden with the actual
    values stored in the configuration when those exist.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次遍历中，所有默认值都将被实际存储在配置中的值所覆盖。
- en: During this second pass, for each value being set, the `type` for that option
    is looked up in the schema. A string such as `getboolean` or `getint` is built
    by prefixing the type with the `get` word. This results in being the name of the
    `configparser` method that needs to be used to parse the configuration option
    into the requested type.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次遍历期间，对于每个被设置的值，该选项的`type`在模式中被查找。通过在类型前加上`get`单词来构建诸如`getboolean`或`getint`的字符串。这导致成为需要用于将配置选项解析为请求的类型的`configparser`方法的名称。
- en: If no `type` was provided, an empty string is used. That results in the plain
    `.get` method being used, which reads the values as text. So not providing a `type`
    means treating the option as a normal string.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供`type`，则使用空字符串。这导致使用普通的`.get`方法，该方法将值读取为文本。因此，不提供`type`意味着将选项视为普通字符串。
- en: All the fetched and converted options are then stored in a dictionary, which
    makes it easier to access the converted values through the `config[section][name]`
    notation without needing to always call an accessor, such as `.getboolean`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，所有获取和转换的选项都存储在字典中，这样就可以通过`config[section][name]`的表示法更容易地访问转换后的值，而无需总是调用访问器，例如`.getboolean`。
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `interpolation=configparser.ExtendedInterpolation()` argument provided to
    the `ConfigParser` object also enables an interpolation mode that allows us to
    refer to values from other sections into the configuration file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 提供给`ConfigParser`对象的`interpolation=configparser.ExtendedInterpolation()`参数还启用了一种插值模式，允许我们引用配置文件中其他部分的值。
- en: 'This is convenient to avoid having to repeat the same values over and over,
    for example, when providing multiple paths that should all start from the same
    root:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这很方便，可以避免一遍又一遍地重复相同的值，例如，当提供应该都从同一个根开始的多个路径时：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Also, the syntax allows us to refer to options in other sections:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该语法允许我们引用其他部分中的选项：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Another convenient feature of `ConfigParser` is that if you want to make an
    option available in all sections, you can just specify it in the special `[DEFAULT]`
    section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigParser`的另一个便利功能是，如果要使一个选项在所有部分中都可用，只需在特殊的`[DEFAULT]`部分中指定它。'
- en: 'That will make the option available in all other sections unless it''s explicitly
    overwritten in the section itself:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使该选项在所有其他部分中都可用，除非在该部分本身中明确覆盖它：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Writing XML/HTML content
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写XML/HTML内容
- en: Writing SGML-based languages is generally not very hard, most languages provide
    utilities to work with them, but if the document gets too big, it's easy to get
    lost when trying to build the tree of elements programmatically.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 编写基于SGML的语言通常并不是很困难，大多数语言都提供了用于处理它们的实用程序，但是如果文档变得太大，那么在尝试以编程方式构建元素树时很容易迷失。
- en: Ending up with hundreds of `.addChild` or similar calls all after each other
    makes it really hard to understand where we were in the document and what part
    of it we are currently editing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最终会有数百个`.addChild`或类似的调用，这些调用都是连续的，这样很难理解我们在文档中的位置以及我们当前正在编辑的部分是什么。
- en: Thankfully, by joining the Python `ElementTree` module with context managers,
    we can have a solution that allows our code structure to match the structure of
    the XML/HTML we are trying to generate.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，通过将Python的`ElementTree`模块与上下文管理器结合起来，我们可以拥有一个解决方案，使我们的代码结构能够与我们试图生成的XML/HTML的结构相匹配。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For this recipe, perform the following steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，执行以下步骤：
- en: 'We can create an `XMLDocument` class that represents the tree of an XML/HTML
    document and have `XMLDocumentBuilder` assist in actually building the document
    by allowing us to insert tags and text:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建一个代表XML/HTML文档树的`XMLDocument`类，并且通过允许我们插入标签和文本的`XMLDocumentBuilder`来辅助实际构建文档。
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can then use our `XMLDocument` to build the document we want. For example,
    we can build web pages in HTML mode:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用我们的`XMLDocument`来构建我们想要的文档。例如，我们可以在HTML模式下构建网页：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`XMLDocument` supports casting to string, so to see the resulting XML, we can
    just print it:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`XMLDocument`支持转换为字符串，因此要查看生成的XML，我们只需打印它：'
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, the structure of our code matches the nesting of the actual
    XML document, so it's easy to see that anything within `_.tag('body')` is the
    content of our body tag.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们的代码结构与实际XML文档的嵌套相匹配，因此很容易看到`_.tag('body')`中的任何内容都是我们body标签的内容。
- en: 'Writing the resulting document to an actual file can be done by relying on
    the `XMLDocument.write` method:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成的文档写入实际文件可以依赖于`XMLDocument.write`方法来完成：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The actual document generation is performed by `xml.etree.ElementTree`, but
    if we had to generate the same document with plain `xml.etree.ElementTree`, it
    would have resulted in a bunch of `el.append` calls:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的文档生成是由`xml.etree.ElementTree`执行的，但是如果我们必须使用普通的`xml.etree.ElementTree`生成相同的文档，那么将会导致一堆`el.append`调用：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This makes it really hard to have any understanding of where we are. In this
    example, we were just building a structure, `<html><head><title>This is the title</title></head></html>`,
    but it was already pretty hard to follow that `title` was inside head and so on.
    For a more complex document, it would become impossible.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们很难理解我们所在的位置。在这个例子中，我们只是构建一个结构，`<html><head><title>This is the title</title></head></html>`，但是已经很难跟踪`title`在head中，依此类推。对于更复杂的文档，这将变得不可能。
- en: So while our `XMLDocument` preserves the `root` of the document tree and provides
    support for casting it to string and writing it to a file, the actual work is
    done by `XMLDocumentBuilder`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然我们的`XMLDocument`保留了文档树的`root`并支持将其转换为字符串并将其写入文件，但实际工作是由`XMLDocumentBuilder`完成的。
- en: '`XMLDocumentBuilder` keeps a stack of nodes to track where we are in the tree
    (`XMLDocumentBuilder._current`). The tail of that list will always tell us which
    tag we''re currently inside.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLDocumentBuilder`保持节点堆栈以跟踪我们在树中的位置（`XMLDocumentBuilder._current`）。该列表的尾部将始终告诉我们当前在哪个标签内。'
- en: 'Calling `XMLDocumentBuilder.text` will add text to the currently active tag:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`XMLDocumentBuilder.text`将向当前活动标签添加文本：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code will result in `<html>Some text, and even more</html>` being
    generated.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成`<html>Some text, and even more</html>`。
- en: 'The `XMLDocumentBuilder.tag` method will add a new tag within the currently
    active tag:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLDocumentBuilder.tag`方法将在当前活动标签中添加一个新标签：'
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This leads to the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下结果：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The interesting part is that the `XMLDocumentBuilder.tag` method also returns
    a context manager. On entry, it will set the entered tag as the currently active
    one and on exit, it will recover the previously active node.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`XMLDocumentBuilder.tag`方法还返回一个上下文管理器。进入时，它将设置输入的标签为当前活动标签，退出时，它将恢复先前的活动节点。
- en: 'That allows us to nest `XMLDocumentBuilder.tag` calls and generate a tree of
    tags:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够嵌套`XMLDocumentBuilder.tag`调用并生成标签树：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This leads to the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下结果：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The actual document node can be grabbed through `as`, so in previous examples
    we were able to grab the `title` node that was just created and set a text for
    it, but `XMLDocumentBuilder.text` would have worked too because the `title` node
    was now the active element once we entered its context.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 实际文档节点可以通过`as`获取，因此在先前的示例中，我们能够获取刚刚创建的`title`节点并为其设置文本，但`XMLDocumentBuilder.text`也可以工作，因为`title`节点现在是活动元素，一旦我们进入其上下文。
- en: There's more...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is one trick that I frequently apply when using this recipe. It makes
    it a bit harder to understand what's going on, on the Python side, and that's
    the reason why I avoided doing it while explaining the recipe itself, but it makes
    the HTML/XML structure even more readable by getting rid of most Python *noise*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此方法时，我经常应用一个技巧。这使得在Python端更难理解发生了什么，这就是我在解释配方本身时避免这样做的原因，但通过消除大部分Python *噪音*，它使HTML/XML结构更加可读。
- en: 'If you assign the `XMLDocumentBuilder.tag` and `XMLDocumentBuilder.text` methods
    to some short names, you can nearly disappear the fact that you are calling Python
    functions and make the XML structure more relevant:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将`XMLDocumentBuilder.tag`和`XMLDocumentBuilder.text`方法分配给一些简短的名称，您几乎可以忽略调用Python函数的事实，并使XML结构更相关：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Written this way, the only things you actually see are the HTML tags and their
    content, which makes the document structure more obvious.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式编写，您实际上只能看到HTML标签及其内容，这使得文档结构更加明显。
- en: Reading XML/HTML content
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读XML/HTML内容
- en: Reading HTML or XML files allows us to parse web pages' content and to read
    documents or configurations described in XML.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读HTML或XML文件使我们能够解析网页内容，并阅读XML中描述的文档或配置。
- en: Python has a built-in XML parser, the `ElementTree` module which is perfect
    for parsing XML files, but when HTML is involved, it chokes quickly due to the
    various quirks of HTML.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个内置的XML解析器，`ElementTree`模块非常适合解析XML文件，但涉及HTML时，由于HTML的各种怪癖，它很快就会出现问题。
- en: 'Consider trying to parse the following HTML:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑尝试解析以下HTML：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You will quickly face errors:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您将很快遇到错误：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Luckily, it's not too hard to adapt the parser to handle at least the most common
    HTML files, such as self-closing/void tags.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，调整解析器以处理至少最常见的HTML文件并不太难，例如自闭合/空标签。
- en: How to do it...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You need to perform the following steps for this recipe:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此配方，您需要执行以下步骤：
- en: '`ElementTree` by default uses `expat` to parse documents, and then relies on
    `xml.etree.ElementTree.TreeBuilder` to build the DOM of the document.'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ElementTree`默认使用`expat`解析文档，然后依赖于`xml.etree.ElementTree.TreeBuilder`构建文档的DOM。'
- en: 'We can replace `XMLParser` based on `expat` with our own parser based on `HTMLParser`
    and have `TreeBuilder` rely on it:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用基于`HTMLParser`的自己的解析器替换基于`expat`的`XMLParser`，并让`TreeBuilder`依赖于它：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Using this parser, we can finally handle our HTML document with success:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此解析器，我们最终可以成功处理我们的HTML文档：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can verify that our `root` node actually contains our original HTML document
    by printing it back:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以验证我们的`root`节点实际上包含我们原始的HTML文档，通过将其打印回来：
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The resulting `root` document can then be navigated like any other tree of
    `ElementTree.Element`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，生成的`root`文档可以像任何其他`ElementTree.Element`树一样进行导航：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To build the tree of `ElementTree.Element` objects representing the HTML document,
    we used two classes together: `HTMLParser` to read the HTML text, and `TreeBuilder`
    to build the tree of `ElementTree.Element` objects.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建表示HTML文档的`ElementTree.Element`对象树，我们一起使用了两个类：`HTMLParser`读取HTML文本，`TreeBuilder`构建`ElementTree.Element`对象树。
- en: Every time `HTMLParser` faces an open or closed tag, it will call `handle_starttag`
    and `handle_endtag`. When we face those, we notify `TreeBuilder` that a new element
    must be started and then that the element must be closed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 每次`HTMLParser`遇到打开或关闭标签时，它将调用`handle_starttag`和`handle_endtag`。当我们遇到这些时，我们通知`TreeBuilder`必须启动一个新元素，然后关闭该元素。
- en: Concurrently, we keep track of the last tag that was started (so the tag we're
    currently in) in `self._stack`. This way, we can know the currently opened tag
    that hasn't yet been closed. Every time we face a new open tag or a closed tag,
    we check whether the last open tag was a self-closing tag; if it was, we close
    it before opening or closing the new tag.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们在`self._stack`中跟踪上次启动的标签（因此我们当前所在的标签）。这样，我们可以知道当前打开的标签尚未关闭。每次遇到新的打开标签或关闭标签时，我们都会检查上次打开的标签是否是自闭合标签；如果是，我们会在打开或关闭新标签之前关闭它。
- en: 'This automatically converts code. Consider the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动转换代码。考虑以下内容：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It will be converted to the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被转换为以下内容：
- en: '[PRE41]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As a new open tag was found, after facing a self-closing tag (`<br>`), the `<br>`
    tag is automatically closed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在遇到一个新的开放标签后，当遇到一个自关闭标签（`<br>`）时，`<br>`标签会自动关闭。
- en: 'It also handles code such as the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 它还处理以下代码：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding code is converted into the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码转换为以下内容：
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As a different closing tag (`</body>`) is faced right after the `<br>` self-closing
    tag, `<br>` is automatically closed.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对`<br>`自关闭标签后，遇到不同的关闭标签（`</body>`），`<br>`会自动关闭。
- en: 'Even when `handle_data` is called, while processing text inside a tag, if the
    last open tag was a self-closing one, the self-closing tag is automatically closed:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在处理标签内文本时调用`handle_data`，如果最后一个开放标签是自关闭标签，自关闭标签也会自动关闭：
- en: '[PRE44]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `Hello World` text is considered as being the content of `<p>` instead
    of being the content of `<br>` because the code was converted to the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hello World`文本被认为是`<p>`的内容，而不是`<br>`的内容，因为代码被转换为以下内容：'
- en: '[PRE45]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Finally, once the full document is parsed, calling `ETHTMLParser.close()` will
    terminate the tree built by `TreeBuilder` and will return the resulting root `Element`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦完整的文档被解析，调用`ETHTMLParser.close()`将终止`TreeBuilder`构建的树，并返回生成的根`Element`。
- en: There's more...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The proposed recipe shows how to use `HTMLParser` to adapt the XML parsing utilities
    to cope with HTML, which is more flexible in rules when compared with XML.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 提出的食谱展示了如何使用`HTMLParser`来适应XML解析工具以处理HTML，与XML相比，HTML的规则更加灵活。
- en: 'While this solution handles mostly commonly written HTML, it won''t cover all
    possible cases. HTML supports some oddities that are sometimes used, such as attributes
    without any value:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个解决方案主要处理常见的HTML写法，但它不会涵盖所有可能的情况。HTML支持一些奇怪的情况，有时会使用一些没有值的属性：
- en: '[PRE46]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Or attributes without quotes:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 或者没有引号的属性：
- en: '[PRE47]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And even some attributes with content but without any closing tag:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至一些带内容但没有任何关闭标签的属性：
- en: '[PRE48]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Even though most of these formats are supported, they are rarely used (with
    maybe the exception of attributes without any value, which our parser will just
    report as having a value of `None`), so in most cases, they won't cause trouble.
    But if you really need to parse HTML supporting all the possible oddities, it's
    surely easier to use an external library, such as `lxml` or `html5lib`, that tries
    to behave as much like a browser as possible when facing oddities.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数这些格式都得到支持，但它们很少被使用（也许除了没有任何值的属性，我们的解析器会报告其值为`None`之外），所以在大多数情况下，它们不会引起麻烦。但是，如果您真的需要解析支持所有可能的奇怪情况的HTML，那么最好使用外部库，比如`lxml`或`html5lib`，它们在面对奇怪情况时会尽可能地像浏览器一样行为。
- en: Reading and writing CSV
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读写CSV
- en: CSV is considered one of the best exchange formats for tabular data; nearly
    all spreadsheet tools support reading and writing CSV, and it's easy to edit it
    with any plain text editor as it's easy for humans to understand.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: CSV被认为是表格数据的最佳交换格式之一；几乎所有的电子表格工具都支持读写CSV，并且可以使用任何纯文本编辑器轻松编辑，因为它对人类来说很容易理解。
- en: Just split and set the values with a comma and you have practically written
    a CSV document.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 只需拆分并用逗号设置值，您几乎已经写了一个CSV文档。
- en: Python has very good built-in support for reading CSV files, and we can easily
    write or read CSV data through the `csv` module.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Python对于读取CSV文件有非常好的内置支持，我们可以通过`csv`模块轻松地写入或读取CSV数据。
- en: 'We will see how it''s possible to read and write a table:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何读写表格：
- en: '[PRE49]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How to do it...
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see the steps for this recipe:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个食谱的步骤：
- en: 'First of all, we will see how to write the specified table:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将看到如何写指定的表：
- en: '[PRE50]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `table.csv` file will contain the same table that we saw previously, and
    we can read it back using any of the `csv` readers. The most convenient one, when
    your CSV file has headers, is `DictReader`, which will read each row in a dictionary
    with the headers as the keys:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`table.csv`文件将包含我们之前看到的相同的表，我们可以使用任何`csv`读取器将其读回。当您的CSV文件有标题时，最方便的是`DictReader`，它将使用标题作为键读取每一行到一个字典中：'
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Iterating over `DictReader` will consume the rows, which should print the same
    data we wrote:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代`DictReader`将消耗行，应该打印我们写的相同数据：
- en: '[PRE52]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There's more...
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: CSV files are plain text files, with a few limitations. For example, nothing
    tells us how a newline should be encoded (`\r\n` or `\n`) and nothing tells us
    which encoding should be used, `utf-8` or `ucs-2`. In theory, CSV doesn't even
    state that it must be comma-separated; a lot of software will write it separated
    by `:` or `;`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: CSV文件是纯文本文件，有一些限制。例如，没有任何东西告诉我们如何编码换行符（`\r\n`或`\n`），也没有告诉我们应该使用哪种编码，`utf-8`还是`ucs-2`。理论上，CSV甚至没有规定必须是逗号分隔的；很多软件会用`:`或`;`来分隔。
- en: That's why you should pay attention to the `encoding` provided to the `open`
    function when reading CSV files. In our example, we knew for sure that `utf8`
    was used, because we wrote the file ourselves, but in other cases, there would
    be no guarantee that any specific encoding was used.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在读取CSV文件时，您应该注意提供给`open`函数的`encoding`。在我们的例子中，我们确定使用了`utf8`，因为我们自己写了文件，但在其他情况下，不能保证使用了任何特定的编码。
- en: In case you are not sure how the CSV file is formatted, you can try to use the
    `csv.Sniffer` object, which, when applied to the text contained in the CSV file,
    will try to detect the dialect that was used.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定CSV文件的格式，可以尝试使用`csv.Sniffer`对象，当应用于CSV文件中包含的文本时，它将尝试检测使用的方言。
- en: Once the dialect is known, you can pass it to `csv.reader` to tell the reader
    to parse the file using that dialect.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦方言被确定，您可以将其传递给`csv.reader`，告诉读取器使用该方言解析文件。
- en: Reading/writing a database
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读写数据库
- en: Python is often referred to as a language that has *batteries included*, thanks
    to its very complete standard library, and one of the best features it provides
    is reading and writing from a full-featured relational database.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Python通常被称为一个*内置电池*的语言，这要归功于它非常完整的标准库，它提供的最好的功能之一就是从一个功能齐全的关系型数据库中读取和写入。
- en: Python ships with the `SQLite` library built in, meaning that we can save and
    read database files stored by `SQLite`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Python内置了`SQLite`库，这意味着我们可以保存和读取由`SQLite`存储的数据库文件。
- en: The usage is pretty straightforward and most of it actually just involves sending
    SQL for execution.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用起来非常简单，实际上大部分只涉及发送SQL进行执行。
- en: How to do it...
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'For this recipes, the steps are as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些食谱，步骤如下：
- en: 'Using the `sqlite3` module, it''s possible to create a new database file, create
    a table, and insert entries into it:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sqlite3`模块，可以创建一个新的数据库文件，创建一个表，并向其中插入条目：
- en: '[PRE53]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `sqlite3` module also provides support for `cursors`, which allow us to
    stream the results of a query from the database to your own code:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sqlite3`模块还提供了对`cursors`的支持，它允许我们将查询的结果从数据库流式传输到你自己的代码：'
- en: '[PRE54]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The previous snippet will print all rows stored in our database as `dict`,
    with the keys matching column names, and the values matching the value of each
    column in the row:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的片段将打印存储在我们的数据库中的所有行作为`dict`，键与列名匹配，值与行中每个列的值匹配。
- en: '[PRE55]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works...
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`sqlite3.connect` is used to open a database file; the returned object can
    then be used to perform any query against it, being an insertion or a selection.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite3.connect`用于打开数据库文件；返回的对象可以用于对其执行任何查询，无论是插入还是选择。'
- en: The `.execute` method is then used to run any SQL against the opened database.
    The SQL to run is provided as a plain string.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`.execute`方法来运行任何SQL代码。要运行的SQL以纯字符串的形式提供。
- en: When performing queries, it's usually a bad idea to provide values directly
    in SQL, especially if those values were provided by the user.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行查询时，通常不应直接在SQL中提供值，特别是如果这些值是由用户提供的。
- en: 'Imagine we write the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们写了以下内容：
- en: '[PRE56]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: What would have happened if instead of `Italian`, the user provided the string
    `'Italian" OR 1=1 OR "'`? Instead of filtering the results, the user would have
    got access to the full content of the table. It's easy to see how this can become
    a security issue if the query is filtered by user ID and the table contains data
    from multiple users.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户提供的字符串是`Italian" OR 1=1 OR "`，而不是`Italian`，会发生什么？用户不会过滤结果，而是可以访问表的全部内容。很容易看出，如果查询是通过用户ID进行过滤，而表中包含来自多个用户的数据，这可能会成为安全问题。
- en: Also in case of `executescript` commands, the user would be able to rely on
    the same behavior to actually execute any SQL code, thereby injecting code into
    our own application.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`executescript`命令的情况下，用户将能够依赖相同的行为来实际执行任何SQL代码，从而将代码注入到我们自己的应用程序中。
- en: For this reason, `sqlite3` provides a way to pass arguments to the SQL queries
    and escape their content, so that even if the user provided malicious input, nothing
    bad would happen.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`sqlite3`提供了一种方法来传递参数到SQL查询并转义它们的内容，这样即使用户提供了恶意输入，也不会发生任何不好的事情。
- en: 'The `?` placeholders in our `INSERT` statements and the `:language` placeholder
    in our `SELECT` statement exist exactly for this purpose: to rely on `sqlite`
    escaping behavior.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`INSERT`语句中的`?`占位符和我们的`SELECT`语句中的`:language`占位符正是为了这个目的：依赖于`sqlite`的转义行为。
- en: The two are equivalent and it's your choice which one you use. One works with
    tuples while the other works with dictionaries.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者是等价的，你可以选择使用哪一个。一个适用于元组，而另一个适用于字典。
- en: When consuming results from the database, they are then provided through `Cursor`.
    You can think of a cursor as something streaming data from the database. Each
    row is read only when you need to access it, thereby avoiding the need to load
    all rows in memory and transfer them all in a single shot.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在从数据库中获取结果时，它们是通过`Cursor`提供的。你可以将光标视为从数据库流式传输数据的东西。每当你需要访问它时，才会读取每一行，从而避免将所有行加载到内存中并一次性传输它们的需要。
- en: While this is not a major problem for common cases, it can cause issues when
    a lot of data is read, up to the point where the system might kill your Python
    script because it's consuming too much memory.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对于常见情况不是一个主要问题，但当读取大量数据时可能会出现问题，直到系统可能会因为消耗太多内存而终止你的Python脚本。
- en: By default, reading rows from a cursor returns tuples, with values in the same
    order the columns were declared. By using `db.row_factory = sqlite3.Row`, we ensure
    that the cursor returns rows as `sqlite3.Row` objects.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，从光标读取行会返回元组，其中值的顺序与列的声明顺序相同。通过使用`db.row_factory = sqlite3.Row`，我们确保光标返回`sqlite3.Row`对象作为行。
- en: They are far more convenient than tuples, because while they can be indexed
    like tuples (you can still write `row[0]`), they also support accessing through
    column names (`row['name']`). Our snippet relies on the fact that `sqlite3.Row`
    objects can be converted to dictionaries to print all the row values with their
    column names.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 它们比元组更方便，因为它们可以像元组一样进行索引（你仍然可以写`row[0]`），而且还支持通过列名进行访问（`row['name']`）。我们的片段依赖于`sqlite3.Row`对象可以转换为字典，以打印所有带有列名的行值。
- en: There's more...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `sqlite3` module supports many additional features, such as transactions,
    custom types, and in-memory databases.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite3`模块支持许多其他功能，例如事务、自定义类型和内存数据库。'
- en: Custom types allow us to read structured data as Python objects, but my favorite
    feature is support for in-memory databases.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义类型允许我们将结构化数据读取为Python对象，但我最喜欢的功能是支持内存数据库。
- en: Using an in-memory database is very convenient when writing test suites for
    your software. If you write software that relies on the `sqlite3` module, make
    sure you write tests connecting to a `":memory:"` database. That will make your
    tests faster and will avoid piling up test database files on your disk every time
    you run tests.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写软件的测试套件时，使用内存数据库非常方便。如果你编写依赖于`sqlite3`模块的软件，请确保编写连接到`":memory:"`数据库的测试。这将使你的测试更快，并且将避免在每次运行测试时在磁盘上堆积测试数据库文件。
