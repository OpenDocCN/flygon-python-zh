- en: Data Structures Used in Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法中使用的数据结构
- en: Algorithms need necessary in-memory data structures that can hold temporary
    data while executing. Choosing the right data structures is essential for their
    efficient implementation. Certain classes of algorithms are recursive or iterative
    in logic and need data structures that are specially designed for them. For example,
    a recursive algorithm may be more easily implemented, exhibiting better performance,
    if nested data structures are used. In this chapter, data structures are discussed
    in the context of algorithms. As we are using Python in this book, this chapter
    focuses on Python data structures, but the concepts presented in this chapter
    can be used in other languages such as Java and C++.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 算法需要必要的内存数据结构来在执行时保存临时数据。选择合适的数据结构对于它们的高效实现至关重要。某些类别的算法是递归或迭代的逻辑，并且需要专门为它们设计的数据结构。例如，如果使用嵌套数据结构，递归算法可能更容易实现，并表现出更好的性能。在本章中，数据结构是在算法的上下文中讨论的。由于本书中使用Python，本章重点介绍Python数据结构，但本章中提出的概念也可以用于其他语言，如Java和C++。
- en: By the end of this chapter, you should be able to understand how Python handles
    complex data structures and which one should be used for a certain type of data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您应该能够理解Python如何处理复杂的数据结构，以及应该为某种类型的数据使用哪种数据结构。
- en: 'Hence, here are the main points discussed in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是本章讨论的主要要点：
- en: Exploring data structures in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中探索数据结构
- en: Exploring abstract data type
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索抽象数据类型
- en: Stacks and queues
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈和队列
- en: Trees
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树
- en: Exploring data structures in Python
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中探索数据结构
- en: 'In any language, data structures are used to store and manipulate complex data.
    In Python, data structures are storage containers to manage, organize, and search
    data in an efficient way. They are used to store a group of data elements called
    *collections* that need to be stored and processed together. In Python, there
    are five various data structures that can be used to store collections:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何语言中，数据结构都用于存储和操作复杂数据。在Python中，数据结构是存储容器，用于以高效的方式管理、组织和搜索数据。它们用于存储一组称为*集合*的数据元素，这些元素需要一起存储和处理。在Python中，有五种不同的数据结构可以用来存储集合：
- en: '**Lists**: Ordered mutable sequences of elements'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**：有序的可变元素序列'
- en: '**Tuples**: Ordered immutable sequences of elements'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元组**：有序的不可变元素序列'
- en: '**Sets**: Unordered bags of elements'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：无序的元素集合'
- en: '**Dictionary**: Unordered bags of key-value pairs'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字典**：无序的键-值对集合'
- en: '**Data frames**: Two-dimensional structures to store two-dimensional data'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据框**：用于存储二维数据的二维结构'
- en: Let's look into them in more detail in the upcoming subsections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的小节中更详细地了解它们。
- en: List
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: In Python, a list is the main data structure used to store a mutable sequence
    of elements. The sequence of data elements stored in the list need not be of the
    same type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，列表是用于存储可变序列元素的主要数据结构。存储在列表中的数据元素的序列不一定是相同类型的。
- en: 'To create a list, the data elements need to be enclosed in [ ] and they need
    to be separated by a comma. For example, the following code creates four data
    elements together that are of different types:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个列表，数据元素需要用[ ]括起来，并用逗号分隔。例如，以下代码创建了四个不同类型的数据元素：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In Python, a list is a handy way of creating one-dimensional writable data structures
    that are needed especially at different internal stages of algorithms.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，列表是创建一维可写数据结构的方便方式，特别是在算法的不同内部阶段需要时。
- en: Using lists
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用列表
- en: Utility functions in data structures make them very useful as they can be used
    to manage data in lists.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构中的实用函数使它们非常有用，因为它们可以用来管理列表中的数据。
- en: 'Let''s look into how we can use them:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用它们：
- en: '**List indexing**: As the position of an element is deterministic in a list,
    the index can be used to get an element at a particular position. The following
    code demonstrates the concept:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表索引**：由于列表中元素的位置是确定的，索引可以用于获取特定位置的元素。以下代码演示了这个概念：'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The four-element list created by this code is shown in the following screenshot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建的四个元素列表如下截图所示：
- en: '![](assets/b74b3d8f-f1de-463d-8516-4eeb03b634b8.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b74b3d8f-f1de-463d-8516-4eeb03b634b8.png)'
- en: Note that the index starts from 0 and therefore **Green**, which is the second
    element, is retrieved by index **1**, that is, `bin_color[1]`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，索引从0开始，因此第二个元素**Green**通过索引**1**检索，即`bin_color[1]`。
- en: '**List slicing**: Retrieving a subset of the elements of a list by specifying
    a range of indexes is called **slicing**. The following code can be used to create
    a slice of the list:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表切片**：通过指定索引范围来检索列表的子集称为**切片**。以下代码可用于创建列表的切片：'
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that lists are one of the most popular single-dimensional data structures
    in Python.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，列表是Python中最受欢迎的单维数据结构之一。
- en: 'While slicing a list, the range is indicated as follows: the first number (inclusive)
    and the second number (exclusive). For example, `bin_colors[0:2]` will include
    `bin_color[0]` and `bin_color[1]` but not `bin_color[2]`. While using lists, this
    should be kept in mind as some users of the Python language complain that this
    is not very intuitive.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在切片列表时，范围表示为：第一个数字（包括）和第二个数字（不包括）。例如，`bin_colors[0:2]`将包括`bin_color[0]`和`bin_color[1]`，但不包括`bin_color[2]`。在使用列表时，应该记住这一点，因为Python语言的一些用户抱怨这不是很直观。
- en: 'Let''s have a look at the following code snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看下面的代码片段：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the starting index is not specified, it means the beginning of the list,
    and if the ending index is not specified, it means the end of the list. The preceding
    code actually demonstrates this concept.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定起始索引，则表示列表的开头，如果未指定结束索引，则表示列表的结尾。前面的代码实际上演示了这个概念。
- en: '**Negative indexing**: In Python, we also have negative indices, which count
    from the end of the list. This is demonstrated in the following code:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负索引**：在Python中，我们还有负索引，它们从列表的末尾开始计数。这在以下代码中得到了证明：'
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that negative indices are especially useful when we want to use the last
    element as a reference point instead of the first one.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们想要使用最后一个元素作为参考点而不是第一个元素时，负索引特别有用。
- en: '**Nesting**: An element of a list can be of a simple data type or a complex
    data type. This allows nesting in lists. For iterative and recursive algorithms,
    this provides important capabilities.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套**：列表的一个元素可以是简单数据类型或复杂数据类型。这允许在列表中进行嵌套。对于迭代和递归算法，这提供了重要的功能。'
- en: 'Let''s have a look at the following code, which is an example of a list within
    a list (nesting):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看下面的代码，这是一个列表中嵌套列表的例子（嵌套）：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Iteration**: Python allows iterating over each element on a list by using
    a `for` loop. This is demonstrated in the following example:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代**：Python允许使用`for`循环来迭代列表中的每个元素。这在下面的例子中进行了演示：'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that the preceding code iterates through the list and prints each element.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的代码会遍历列表并打印每个元素。
- en: Lambda functions
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda函数
- en: 'There are a bunch of lambda functions that can be used on lists. They are specifically
    important in the context of algorithms and provide the ability to create a function
    on the fly. Sometimes, in the literature, they are also called *anonymous functions*.
    This section demonstrates their uses:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有一堆可以用在列表上的lambda函数。它们在算法的上下文中特别重要，并且提供了即时创建函数的能力。有时，在文献中，它们也被称为*匿名函数*。本节演示了它们的用法：
- en: '**Filtering data**: To filter the data, first, we define a predicate, which
    is a function that inputs a single argument and returns a Boolean value. The following
    code demonstrates its use:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据过滤**：要过滤数据，首先我们定义一个谓词，它是一个输入单个参数并返回布尔值的函数。下面的代码演示了它的用法：'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that, in this code, we filter a list using the `lambda` function, which
    specifies the filtering criteria. The filter function is designed to filter elements
    out of a sequence based on a defined criterion. The filter function in Python
    is usually used with `lambda`. In addition to lists, it can be used to filter
    elements from tuples or sets. For the preceding code, the defined criterion is
    `x > 100`. The code will iterate through all the elements of the list and will
    filter out the elements that do not pass this criterion.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这段代码中，我们使用`lambda`函数来过滤列表，它指定了过滤的条件。过滤函数被设计用来根据定义的条件从序列中过滤元素。Python中的过滤函数通常与`lambda`一起使用。除了列表，它还可以用来从元组或集合中过滤元素。对于前面的代码，定义的条件是`x
    > 100`。代码将遍历列表的所有元素，并过滤掉不符合这个条件的元素。
- en: '**Data transformation**: The `map()` function can be used for data transformation
    using a lambda function. An example is as follows:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据转换**：可以使用`map()`函数来使用lambda函数进行数据转换。一个例子如下：'
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using the `map` function with a `lambda` function provides quite powerful functionality.
    When used with the `map` function, the `lambda` function can be used to specify
    a transformer that transforms each element of the given sequence. In the preceding
    code, the transformer is multiplication by two. So, we are using the `map` function
    to multiply each element in the list by two.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`map`函数与`lambda`函数提供了非常强大的功能。当与`map`函数一起使用时，`lambda`函数可以用来指定一个转换器，它转换给定序列的每个元素。在前面的代码中，转换器是乘以二。因此，我们使用`map`函数来将列表中的每个元素乘以二。
- en: '**Data aggregation**: For data aggregation, the `reduce()` function can be
    used, which recursively runs a function to pairs of values on each element of
    the list:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据聚合**：对于数据聚合，可以使用`reduce()`函数，它会递归地对列表的每个元素运行一对值的函数：'
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the `reduce` function needs a data aggregation function to be defined.
    That data aggregation function in the preceding code is `functools`. It defines
    how it will aggregate the items of the given list. The aggregation will start
    from the first two elements and the result will replace the first two elements.
    This process of reduction is repeated until we reach the end, resulting in one
    aggregated number. `x1` and `x2` in the `doSum` function represent two numbers
    in each of these iterations and `doSum` represents the aggregation criterion for
    them.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`reduce`函数需要一个数据聚合函数来进行定义。在前面的代码中，数据聚合函数是`functools`。它定义了如何聚合给定列表的项目。聚合将从前两个元素开始，并且结果将替换前两个元素。这个缩减的过程会重复，直到达到末尾，得到一个聚合的数字。`doSum`函数中的`x1`和`x2`代表每次迭代中的两个数字，而`doSum`代表它们的聚合标准。
- en: The preceding code block results in a single value (which is `270`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块会得到一个单一的值（为`270`）。
- en: The range function
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: range函数
- en: The `range` function can be used to easily generate a large list of numbers.
    It is used to auto-populate sequences of numbers in a list.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`函数可以用来轻松生成一个大量的数字列表。它用于自动填充列表中的数字序列。'
- en: 'The `range` function is simple to use. We can use it by just specifying the
    number of elements we want in the list. By default, it starts from zero and increments
    by one:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`函数使用简单。我们可以通过指定列表中要包含的元素数量来使用它。默认情况下，它从零开始，每次增加一个：'
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also specify the end number and the step:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定结束数字和步长：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding range function will give us odd numbers starting from `3` to `29`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的range函数将给我们从`3`到`29`的奇数。
- en: The time complexity of lists
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表的时间复杂度
- en: 'The time complexity of various functions of a list can be summarized as follows
    using the Big O notation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表各种函数的时间复杂度可以使用大O符号总结如下：
- en: '| **Different methods** | **Time complexity** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: 不同的方法 | 时间复杂度
- en: '| Insert an element | O(1) |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: 插入一个元素 | O(1)
- en: '| Delete an element | O(n) (as in the worst case may have to iterate the whole
    list) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: 删除一个元素 | O(n)（在最坏的情况下可能需要遍历整个列表）
- en: '| Slicing a list | O(n) |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: 切片列表 | O(n)
- en: '| Element retrieval | O(n) |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: 元素检索 | O(n)
- en: '| Copy | O(n) |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: 复制 | O(n)
- en: Please note that the time taken to add an individual element is independent
    of the size of the list. Other operations mentioned in the table are dependent
    on the size of the list. As the size of the list gets bigger, the impact on performance
    becomes more pronounced.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，添加单个元素所需的时间与列表的大小无关。表中提到的其他操作取决于列表的大小。随着列表的大小变大，对性能的影响变得更加显著。
- en: Tuples
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: The second data structure that can be used to store a collection is a tuple.
    In contrast to lists, tuples are immutable (read-only) data structures. Tuples
    consist of several elements surrounded by ( ).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用于存储集合的第二种数据结构是元组。与列表相反，元组是不可变（只读）的数据结构。元组由( )括起来的几个元素组成。
- en: Like lists, elements within a tuple can be of different types. They also allow
    complex data types for their elements. So, there can be a tuple within a tuple
    providing a way to create a nested data structure. The capability to create nested
    data structures is especially useful in iterative and recursive algorithms.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表一样，元组中的元素可以是不同类型的。它们还允许为其元素使用复杂数据类型。因此，可以在元组中创建一个元组，从而提供了创建嵌套数据结构的方法。在迭代和递归算法中，创建嵌套数据结构的能力尤其有用。
- en: 'The following code demonstrates how to create tuples:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何创建元组：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Wherever possible, immutable data structures (such as tuples) should be preferred
    over mutable data structures (such as lists) due to performance. Especially when
    dealing with big data, immutable data structures are considerably faster than
    mutable ones. There is a price we pay for the ability to change data elements
    in lists, for example, and we should carefully analyze that it is really needed
    so we can implement the code as read-only tuples, which will be much faster.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，应优先选择不可变数据结构（如元组）而不是可变数据结构（如列表），因为性能更好。特别是在处理大数据时，不可变数据结构比可变数据结构要快得多。例如，更改列表中的数据元素的能力是有代价的，我们应该仔细分析是否真的需要这样做，这样我们可以将代码实现为只读元组，这将更快。
- en: Note that, in the preceding code, `a[2]` refers to the third element, which
    is a tuple, `(100,200,300)`. `a[2][1]` refers to the second element within this
    tuple, which is `200`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上述代码中，`a[2]`指的是第三个元素，即一个元组`(100,200,300)`。`a[2][1]`指的是这个元组中的第二个元素，即`200`。
- en: The time complexity of tuples
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组的时间复杂度
- en: 'The time complexity of various functions of tuples can be summarized as follows
    (using Big O notation):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大O表示法，可以总结元组各种函数的时间复杂度如下：
- en: '| **Function** | **Time** **Complexity** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **时间** **复杂度** |'
- en: '| `Append` | O(1) |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `Append` | O(1) |'
- en: Note that `Append` is a function that adds an element toward the end of the
    already existing tuple. Its complexity is O(1).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Append`是一个向已有元组的末尾添加元素的函数。其复杂度为O(1)。
- en: Dictionary
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: Holding data as key-value pairs is important especially in distributed algorithms.
    In Python, a collection of these key-value pairs is stored as a data structure
    called a *dictionary*. To create a dictionary, a key should be chosen as an attribute
    that is best suited to identify data throughout data processing. The value can
    be an element of any type, for example, a number or string. Python also always
    uses complex data types such as lists as values. Nested dictionaries can be created
    by using a dictionary as the data type of a value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以键值对的形式保存数据在分布式算法中尤为重要。在Python中，这些键值对的集合被存储为一种称为*字典*的数据结构。要创建字典，应选择一个最适合在整个数据处理过程中标识数据的属性作为键。值可以是任何类型的元素，例如数字或字符串。Python还总是使用列表等复杂数据类型作为值。可以通过使用字典作为值的数据类型来创建嵌套字典。
- en: 'To create a simple dictionary that assigns colors to various variables, the
    key-value pairs need to be enclosed in { }. For example, the following code creates
    a simple dictionary consisting of three key-value pairs:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个简单的字典，将键值对放在{ }中。例如，以下代码创建了一个由三个键值对组成的简单字典：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The three key-value pairs created by the preceding piece of code are also illustrated
    in the following screenshot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码创建的三个键值对也在以下截图中说明：
- en: '![](assets/5e368cad-172b-4e21-866a-ef187bebe372.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5e368cad-172b-4e21-866a-ef187bebe372.png)'
- en: 'Now, let''s see how to retrieve and update a value associated with a key:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何检索和更新与键相关联的值：
- en: 'To retrieve a value associated with a key, either the `get` function can be
    used or the key can be used as the index:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检索与键关联的值，可以使用`get`函数，也可以使用键作为索引：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To update a value associated with a key, use the following code:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更新与键关联的值，请使用以下代码：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that the preceding code shows how we can update a value related to a particular
    key in a dictionary.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的代码显示了如何更新与字典中特定键相关联的值。
- en: The time complexity of a dictionary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典的时间复杂度
- en: 'The following table gives the time complexity of a dictionary using Big O notation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格给出了使用大O表示法的字典的时间复杂度：
- en: '| **Dictionary** | **Time** **complexity** |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **字典** | **时间** **复杂度** |'
- en: '| Get a value or a key | O(1) |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 获取值或键 | O(1) |'
- en: '| Set a value or a key | O(1) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 设置值或键 | O(1) |'
- en: '| Copy a dictionary | O(n) |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 复制字典 | O(n) |'
- en: An important thing to note from the complexity analysis of the dictionary is
    that the time taken to get or set a key-value is totally independent of the size
    of the dictionary. This means that the time taken to add a key-value pair to a
    dictionary of a size of three is the same as the time taken to add a key-value
    pair to a dictionary of a size of one million.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 从字典的复杂度分析中重要的一点是，获取或设置键值的时间与字典的大小完全独立。这意味着在大小为三的字典中添加键值对所需的时间与在大小为一百万的字典中添加键值对所需的时间相同。
- en: Sets
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'A set is defined as a collection of elements that can be of different types.
    The elements are enclosed within { }. For example, have a look at the following
    code block:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 集合被定义为可以是不同类型的元素的集合。元素被包含在{ }中。例如，看一下以下代码块：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The defining characteristic of a set is that it only stores the distinct value
    of each element. If we try to add another redundant element, it will ignore that,
    as illustrated in the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 集合的定义特征是它只存储每个元素的不同值。如果我们尝试添加另一个冗余元素，它将忽略该元素，如下所示：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To demonstrate what sort of operations can be done on sets, let''s define two
    sets:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示可以在集合上执行的操作类型，让我们定义两个集合：
- en: A set named yellow, which has things that are yellow
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为yellow的集合，其中包含黄色的东西
- en: Another set named red, which has things that are red
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个名为red的集合，其中包含红色的东西
- en: 'Note that some things are common between these two sets. The two sets and their
    relationship can be represented with the help of the following Venn diagram:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两个集合之间有一些共同之处。这两个集合及其关系可以用以下维恩图表示：
- en: '*![](assets/8cdd35a9-b222-4671-8917-7ace89de60fb.png)*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*![](assets/8cdd35a9-b222-4671-8917-7ace89de60fb.png)*'
- en: 'If we want to implement these two sets in Python, the code will look like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在Python中实现这两个集合，代码将如下所示：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s consider the following code, which demonstrates set operations
    using Python:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑以下代码，演示了使用Python进行集合操作：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As shown in the preceding code snippet, sets in Python can have operations
    such as unions and intersections. As we know, a union operation combines all of
    the elements of both sets, and the intersection operation will give a set of common
    elements between the two sets. Note the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码片段所示，Python中的集合可以进行联合和交集等操作。正如我们所知，联合操作将合并两个集合的所有元素，而交集操作将给出两个集合之间的共同元素集合。请注意以下内容：
- en: '`yellow|red` is used to get the union of the preceding two defined sets.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yellow|red`用于获取前面两个定义的集合的并集。'
- en: '`yellow&red` is used to get the overlap between yellow and red.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yellow&red`用于获取黄色和红色之间的重叠部分。'
- en: Time complexity analysis for sets
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合的时间复杂度分析
- en: 'Following is the time complexity analysis for sets:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是集合的时间复杂度分析：
- en: '| **Sets** | **Complexity** |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **集合** | **复杂度** |'
- en: '| Add an element | O(1) |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 添加一个元素 | O(1) |'
- en: '| Remove an element | O(1) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 删除一个元素 | O(1) |'
- en: '| Copy | O(n) |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 复制 | O(n) |'
- en: An important thing to note from the complexity analysis of the sets is that
    the time taken to add an element is totally independent of the size of a particular
    set.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从集合的复杂度分析中重要的一点是，添加一个元素所需的时间完全独立于特定集合的大小。
- en: DataFrames
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据框
- en: 'A DataFrame is a data structure used to store tabular data available in Python''s
    `pandas` package. It is one of the most important data structures for algorithms
    and is used to process traditional structured data. Let''s consider the following
    table:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框是一种用于存储Python的`pandas`包中可用的表格数据的数据结构。它是算法中最重要的数据结构之一，用于处理传统的结构化数据。让我们考虑以下表格：
- en: '| **id** | **name** | **age** | **decision** |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **id** | **name** | **age** | **decision** |'
- en: '| 1 | Fares | 32 | True |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 费尔斯 | 32 | 真 |'
- en: '| 2 | Elena | 23 | False |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 艾琳娜 | 23 | 假 |'
- en: '| 3 | Steven | 40 | True |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 史蒂文 | 40 | 真 |'
- en: Now, let's represent this using a DataFrame.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用数据框来表示这一点。
- en: 'A simple DataFrame can be created by using the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码创建一个简单的数据框：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that, in the preceding code, `df.column` is a list that specifies the names
    of the columns.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上述代码中，`df.column`是一个指定列名称的列表。
- en: The DataFrame is also used in other popular languages and frameworks to implement
    a tabular data structure. Examples are R and the Apache Spark framework.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框也用于其他流行的语言和框架中来实现表格数据结构。例如R和Apache Spark框架。
- en: Terminologies of DataFrames
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据框的术语
- en: 'Let''s look into some of the terminologies that are used in the context of
    a DataFrame:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些在数据框的上下文中使用的术语：
- en: '**Axis**: In the pandas documentation, a single column or row of a DataFrame
    is called an axis.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轴**：在pandas文档中，数据框的单个列或行称为一个轴。'
- en: '**Axes**: If there is more than one axis, they are called axes as a group.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轴**：如果有多个轴，则将它们作为一个组称为轴。'
- en: '**Label**: A DataFrame allows the naming of both columns and rows with what''s
    called a label.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：数据框允许使用所谓的标签对列和行进行命名。'
- en: Creating a subset of a DataFrame
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据框的子集
- en: 'Fundamentally, there are two main ways of creating the subset of a DataFrame
    (say the name of the subset is `myDF`):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上讲，有两种主要方法可以创建数据框的子集（假设子集的名称为`myDF`）：
- en: Column selection
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列选择
- en: Row selection
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行选择
- en: Let's see them one by one.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次看一下。
- en: Column selection
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列选择
- en: In machine learning algorithms, selecting the right set of features is an important
    task. Out of all of the features that we may have, not all of them may be needed
    at a particular stage of the algorithm. In Python, feature selection is achieved
    by column selection, which is explained in this section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习算法中，选择正确的特征集是一项重要的任务。在我们可能拥有的所有特征中，不一定所有特征在算法的特定阶段都是必需的。在Python中，通过列选择来实现特征选择，这在本节中有所解释。
- en: 'A column may be retrieved by *name*, as in the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按*名称*检索列，如下所示：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The positioning of a column is deterministic in a DataFrame. A column can be
    retrieved by its position as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框中列的位置是确定的。可以按其位置检索列，如下所示：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that, in this code, we are retrieving the first three rows of the DataFrame.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此代码中，我们正在检索数据框的前三行。
- en: Row selection
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行选择
- en: 'Each row in a DataFrame corresponds to a data point in our problem space. We
    need to perform row selection if we want to create a subset of the data elements
    we have in our problem space. This subset can be created by using one of the two
    following methods:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 数据框中的每一行对应于问题空间中的一个数据点。如果我们想要创建问题空间中的数据元素的子集，我们需要执行行选择。可以使用以下两种方法之一来创建这个子集：
- en: By specifying their position
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定它们的位置
- en: By specifying a filter
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过指定过滤器
- en: 'A subset of rows can be retrieved by its position as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按照其位置检索数据框的子集行，如下所示：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that the preceding code will return the first two rows and all columns.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述代码将返回数据框的前两行和所有列。
- en: 'To create a subset by specifying the filter, we need to use one or more columns
    to define the selection criterion. For example, a subset of data elements can
    be selected by this method, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定过滤器创建子集，我们需要使用一个或多个列来定义选择条件。例如，可以通过以下方法选择数据元素的子集：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that this code creates a subset of rows that satisfies the condition stipulated
    in the filter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此代码创建了满足过滤器中规定条件的行的子集。
- en: Matrix
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵
- en: A matrix is a two-dimensional data structure with a fixed number of columns
    and rows. Each element of a matrix can be referred to by its column and the row.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵是一个具有固定列数和行数的二维数据结构。矩阵的每个元素可以通过其列和行来引用。
- en: 'In Python, a matrix can be created by using the `numpy` array, as shown in
    the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，可以使用`numpy`数组创建矩阵，如下代码所示：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that the preceding code will create a matrix that has three rows and three
    columns.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述代码将创建一个具有三行三列的矩阵。
- en: Matrix operations
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 矩阵操作
- en: 'There are many operations available for matrix data manipulation. For example,
    let''s try to transpose the preceding matrix. We will use the `transpose()` function,
    which will convert columns into rows and rows into columns:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵数据操作有许多可用的操作。例如，让我们尝试转置上述矩阵。我们将使用`transpose()`函数，它将列转换为行，行转换为列：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that matrix operations are used a lot in multimedia data manipulation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，矩阵操作在多媒体数据处理中经常使用。
- en: Now that we have learned about data structures in Python, let's move onto the
    abstract data types in the next section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Python中的数据结构，让我们在下一节中转向抽象数据类型。
- en: Exploring abstract data types
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索抽象数据类型
- en: Abstraction, in general, is a concept used to define complex systems in terms
    of their common core functions. The use of this concept to create generic data
    structures gives birth to **Abstract Data Types** (**ADT**). By hiding the implementation
    level details and giving the user a generic, implementation-independent data structure,
    the use of ADTs creates algorithms that result in simpler and cleaner code. ADTs
    can be implemented in any programming language such as C++, Java, and Scala. In
    this section, we shall implement ADTs using Python. Let's start with vectors first.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象，一般来说，是一个用于以其共同核心功能来定义复杂系统的概念。使用这个概念来创建通用数据结构，产生了**抽象数据类型**（**ADT**）。通过隐藏实现级别的细节并为用户提供一个通用的、与实现无关的数据结构，ADT的使用创建了产生更简单和更清晰代码的算法。ADT可以在任何编程语言中实现，如C++、Java和Scala。在本节中，我们将使用Python来实现ADT。让我们首先从向量开始。
- en: Vector
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向量
- en: 'A vector is a single dimension structure to store data. They are one of the
    most popular data structures in Python. There are two ways of creating vectors
    in Python as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 向量是一种用于存储数据的单维结构。它们是Python中最受欢迎的数据结构之一。在Python中有两种创建向量的方式如下：
- en: 'Using a Python list: The simplest way of creating a vector is by using a Python
    list, as follows:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python列表：创建向量的最简单方法是使用Python列表，如下所示：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that this code will create a list with four elements.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此代码将创建一个包含四个元素的列表。
- en: 'Using a `numpy` array: Another popular way of creating a vector is by using
    NumPy arrays, as follows:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`numpy`数组：创建向量的另一种流行方法是使用NumPy数组，如下所示：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that we created `myVector` using `np.array` in this code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在此代码中使用`np.array`创建了`myVector`。
- en: In Python, we can represent integers using underscores to separate parts. It
    makes them more readable and less error-prone. This is especially useful when
    dealing with large numbers. So, one billion can be represented as a=1
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以使用下划线表示整数以分隔部分。这样可以使它们更易读，减少出错的可能性。在处理大数字时尤其有用。因此，十亿可以表示为a=1
- en: Stacks
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈
- en: A stack is a linear data structure to store a one-dimensional list. It can store
    items either in **Last-In, First-Out** (**LIFO**) or **First-In, Last-Out** (**FILO**)
    manner. The defining characteristic of a stack is the way elements are added and
    removed from it. A new element is added at one end and an element is removed from
    that end only.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈是一种线性数据结构，用于存储一维列表。它可以以**后进先出**（**LIFO**）或**先进后出**（**FILO**）的方式存储项目。堆栈的定义特征是元素的添加和移除方式。新元素被添加到一端，只能从该端移除一个元素。
- en: 'Following are the operations related to stacks:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与堆栈相关的操作：
- en: '**isEmpty:** Returns true if the stack is empty'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**isEmpty:** 如果堆栈为空则返回true'
- en: '**push:** Adds a new element'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**push:** 添加一个新元素'
- en: '**pop**: Returns the element added most recently and removes it'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pop**: 返回最近添加的元素并将其删除'
- en: 'The following diagram shows how push and pop operations can be used to add
    and remove data from a stack:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了如何使用push和pop操作向堆栈添加和删除数据：
- en: '![](assets/a9ce44cc-08ed-4e39-b3ba-6a5691b22a2b.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a9ce44cc-08ed-4e39-b3ba-6a5691b22a2b.png)'
- en: The top portion of the preceding diagram shows the use of push operations to
    add items to the stack. In steps **1.1**, **1.2**, and **1.3**, push operations
    are used three times to add three elements to the stack. The bottom portion of
    the preceding diagram is used to retrieve the stored values from the stack. In
    steps **2.2** and **2.3**, pop operations are used to retrieve two elements from
    the stack in LIFO format.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 上图的顶部显示了使用push操作向堆栈添加项目。在步骤**1.1**、**1.2**和**1.3**中，push操作被用于三次向堆栈添加三个元素。上图的底部用于从堆栈中检索存储的值。在步骤**2.2**和**2.3**中，pop操作被用于以LIFO格式从堆栈中检索两个元素。
- en: 'Let''s create a class named `Stack` in Python, where we will define all of
    the operations related to the stack class. The code of this class will be as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python中创建一个名为`Stack`的类，我们将在其中定义与堆栈类相关的所有操作。该类的代码如下：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To push four elements to the stack, the following code can be used:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要向堆栈推送四个元素，可以使用以下代码：
- en: '![](assets/819b0842-cfd2-4d01-a306-19b01905bba9.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/819b0842-cfd2-4d01-a306-19b01905bba9.png)'
- en: Note that the preceding code creates a stack with four data elements.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上述代码创建了一个包含四个数据元素的堆栈。
- en: The time complexity of stacks
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈的时间复杂度
- en: 'Let''s look into the time complexity of stacks (using Big O notation):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看堆栈的时间复杂度（使用大O表示法）：
- en: '| **Operations** | **Time Complexity** |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **时间复杂度** |'
- en: '| `push` | O(1) |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `push` | O(1) |'
- en: '| `pop` | O(1) |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `pop` | O(1) |'
- en: '| `size` | O(1) |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `size` | O(1) |'
- en: '| `peek` | O(1) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `peek` | O(1) |'
- en: An important thing to note is that the performance of none of the four operations
    mentioned in the preceding table depends on the size of the stack.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，前面表中提到的四种操作的性能都不取决于栈的大小。
- en: Practical example
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际例子
- en: A stack is used as the data structure in many use cases. For example, when a
    user wants to browse the history in a web browser, it is a LIFO data access pattern
    and a stack can be used to store the history. Another example is when a user wants
    to perform an `Undo` operation in word processing software.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 栈在许多用例中用作数据结构。例如，当用户想要在Web浏览器中浏览历史记录时，这是一种LIFO数据访问模式，可以使用栈来存储历史记录。另一个例子是当用户想要在文字处理软件中执行“撤销”操作时。
- en: Queues
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: Like stacks, a queue stores *n* elements in a single-dimensional structure.
    The elements are added and removed in **FIFO** format. One end of the queue is
    called the *rear* and the other is called the *front*. When elements are removed
    from the front, the operation is called *dequeue*. When elements are added at
    the rear, the operation is called *enqueue*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 和栈一样，队列将*n*个元素存储在单维结构中。元素以**FIFO**格式添加和移除。队列的一端称为 *后端*，另一端称为 *前端*。当元素从前端移除时，该操作称为
    *出队*。当元素在后端添加时，该操作称为 *入队*。
- en: In the following diagram, the top portion shows the enqueue operation. Steps
    **1.1**, **1.2**, and **1.3** add three elements to the queue and the resultant
    queue is shown in **1.4**. Note that **Yellow** is the  *rear*  and **Red** is
    the  *front*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，顶部部分显示了入队操作。步骤1.1，1.2和1.3将三个元素添加到队列中，结果队列显示在1.4中。请注意，**黄色** 是 *后端*，**红色**
    是 *前端*。
- en: 'The bottom portion of the following diagram shows a dequeue operation. Steps
    **2.2**, **2.3**, and **2.4** remove elements from the queue one by one from the
    front of the queue:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 下图的底部部分显示了一个出队操作。步骤2.2，2.3和2.4依次从队列的前端一个接一个地移除元素：
- en: '![](assets/0da2e641-e84f-4f35-bdea-2fe3d9366528.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0da2e641-e84f-4f35-bdea-2fe3d9366528.png)'
- en: 'The queue shown in the preceding diagram can be implemented by using the following
    code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图中显示的队列可以通过以下代码实现：
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s enqueue and dequeue elements as shown in the preceding diagram with
    the help of the following screenshot:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据以下截图，按照前面的图示进行入队和出队操作：
- en: '![](assets/c068e281-0709-4d13-8f5c-c4b4b9b8fd12.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c068e281-0709-4d13-8f5c-c4b4b9b8fd12.png)'
- en: Note that the preceding code creates a queue first and then enqueues four items
    into it.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的代码首先创建一个队列，然后将四个项目入队。
- en: The basic idea behind the use of stacks and queues
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用栈和队列的基本思想
- en: 'Let''s look into the basic idea behind the use of stacks and queues using an
    analogy. Let''s assume that we have a table where we put our incoming mail from
    our postal service, for example, Canada Mail. We stack it until we get some time
    to open and look at the mail, one by one. There are two possible ways of doing
    this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个类比来了解使用栈和队列的基本思想。假设我们有一张桌子，我们把我们从邮政服务收到的信放在上面，例如，加拿大邮件。我们堆积起来，直到有时间逐一打开和查看信件。有两种可能的做法：
- en: We put the letter in a stack and whenever we get a new letter, we put it on
    the top of the stack. When we want to read a letter, we start with the one that
    is on top. This is what we call a  *stack*. Note that the latest letter to arrive
    will be on the top and will be processed first. Picking up a letter from the top
    of the list is called a  *pop*  operation. Whenever a new letter arrives, putting
    it on the top is called  *push*  operation. If we end up having a sizable stack
    and lots of letters are continuously arriving, there is a chance that we never
    get a chance to reach a very important letter waiting for us at the lower end
    of the stack.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们把信放在一个栈里，每当我们收到一封新信时，我们把它放在栈的顶部。当我们想读一封信时，我们从顶部开始。这就是我们所说的 *栈*。请注意，最新的信件将位于顶部，并且将首先被处理。从列表顶部取出一封信称为
    *弹出* 操作。每当有新信到达时，把它放在顶部称为 *推入* 操作。如果我们最终有一个相当大的栈，并且有大量信件不断到达，有可能我们永远没有机会到达等待我们的非常重要的信件。
- en: 'We put the letter in pile, but we want to handle the oldest letter first: each
    time we want to look at one or more letters, we take care to handle the oldest
    one first. This is what we call a *q**ueue*. Adding a letter to the pile is called
    an *e**nqueue*  operation. Removing the letter from the pile is called *d**equeue*  operation.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们把信放在一堆里，但我们想先处理最老的信：每次我们想看一个或多个信时，我们要确保先处理最老的那个。这就是我们所说的 *队列*。把一封信放到一堆里叫做
    *入队* 操作。从一堆里取出一封信叫做 *出队* 操作。
- en: Tree
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树
- en: In the context of algorithms, a tree is one of the most useful data structures
    due to its hierarchical data storage capabilities. While designing algorithms,
    we use trees wherever we need to represent hierarchical relationships among the
    data elements that we need to store or process.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法的上下文中，树是最有用的数据结构之一，因为它具有分层数据存储能力。在设计算法时，我们使用树来表示我们需要存储或处理的数据元素之间的分层关系。
- en: Let's look deeper into this interesting and quite important data structure.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解这个有趣且非常重要的数据结构。
- en: Each tree has a finite set of nodes so that it has a starting data element called
    a *root* and a set of nodes joined together by links called *branches*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每棵树都有一个有限的节点集，因此它有一个称为 *根* 的起始数据元素和一组由链接连接在一起的称为 *分支* 的节点。
- en: Terminology
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语
- en: 'Let''s look into some of the terminology related to the tree data structure:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些与树数据结构相关的术语：
- en: '| Root node | A node with no parent is called the *root* node. For example,
    in the following diagram, the root node is **A**. In algorithms, usually, the
    root node holds the most important value in the tree structure. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 根节点 | 没有父节点的节点称为 *根* 节点。例如，在下图中，根节点是 **A**。在算法中，通常根节点保存树结构中最重要的值。|'
- en: '| Level of a node | The distance from the root node is the level of a node.
    For example, in the following diagram, the level of nodes **D**, **E,** and **F**
    is two. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 节点的级别 | 从根节点到节点的距离就是节点的级别。例如，在下图中，节点**D**，**E**和**F**的级别为2。|'
- en: '| Siblings nodes | Two nodes in a tree are called *siblings* if they are at
    the same level. For example, if we check the following diagram, nodes **B** and
    **C** are siblings. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 兄弟节点 | 树中的两个节点如果在同一级别，则称为*兄弟节点*。例如，如果查看下图，节点**B**和**C**是兄弟节点。|'
- en: '| Child and parent node | A node, **F**, is a child of node **C**, if both
    are directly connected and the level of node **C** is less than node **F**. Conversely,
    node **C** is a parent of node **F**. Nodes **C** and **F** in the following diagram
    show this parent-child relationship. |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 子节点和父节点 | 如果节点**C**和节点**F**直接连接，并且节点**C**的级别低于节点**F**，那么节点**F**是节点**C**的子节点。反之，节点**C**是节点**F**的父节点。下图中的节点**C**和**F**展示了这种父子关系。|'
- en: '| Degree of a node | The degree of a node is the number of children it has.
    For example, in the following diagram, node **B** has a degree of two. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 节点的度 | 节点的度是它拥有的子节点数量。例如，在下图中，节点**B**的度为2。|'
- en: '| Degree of a tree | The degree of a tree is equal to the maximum degree that
    can be found among the constituent nodes of a tree. For example, the tree presented
    in the following diagram has a degree of two. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 树的度 | 树的度等于树的组成节点中可以找到的最大度。例如，下图中呈现的树的度为2。|'
- en: '| Subtree | A subtree of a tree is a portion of the tree with the chosen node
    as the root node of the subtree and all of the children as the nodes of the tree.
    For example, a subtree at node **E** of the tree presented in the following diagram
    consists of node **E** as the root node and node **G** and **H** as the two children.
    |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 子树 | 树的子树是树的一部分，选择的节点是子树的根节点，所有子节点是树的节点。例如，在下图中呈现的树的节点**E**的子树包括节点**E**作为根节点和节点**G**和**H**作为两个子节点。|'
- en: '| Leaf node | A node in a tree with no children is called a *leaf* node. For
    example, in the following figure, **D**, **G**, **H,** and **F** are the four
    leaf nodes. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 叶节点 | 树中没有子节点的节点称为*叶节点*。例如，在下图中，**D**，**G**，**H**和**F**是四个叶节点。|'
- en: '| Internal node | Any node that is neither a root nor a leaf node is an internal
    node. An internal node will have at least one parent and at least one child node.
    |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 内部节点 | 既不是根节点也不是叶节点的任何节点都是内部节点。内部节点至少有一个父节点和至少一个子节点。|'
- en: Note that trees are a kind of network or graph that we will study in [Chapter
    6](ce14ecc1-8ad5-406e-88d0-7f3acb3e4569.xhtml), *Unsupervised Machine Learning
    Algorithms*. For graphs and network analysis, we use the terms link or edge instead
    of branches. Most of the other terminology remains unchanged.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，树是我们将在[第6章](ce14ecc1-8ad5-406e-88d0-7f3acb3e4569.xhtml)中学习的网络或图的一种，*无监督机器学习算法*。对于图和网络分析，我们使用术语链接或边而不是分支。大多数其他术语保持不变。
- en: Types of trees
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树的类型
- en: 'There are different types of trees, which are explained as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 树有不同的类型，如下所述：
- en: '**Binary tree:** If the degree of a tree is two, that tree is called a *binary
    tree*. For example, the tree shown in the following diagram is a binary tree as
    it has a degree of two:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二叉树：** 如果一棵树的度为2，则称该树为*二叉树*。例如，下图中呈现的树是一棵二叉树，因为它的度为2：'
- en: '![](assets/28eabe7e-aae6-46a6-8eec-9b13113cc38b.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/28eabe7e-aae6-46a6-8eec-9b13113cc38b.png)'
- en: Note that the preceding diagram shows a  tree that has four levels with eight
    nodes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前图显示了一个有四个级别和八个节点的树。
- en: '**Full tree:** A full tree is the one in which all of the nodes are of the
    same degree, which will be equal to the degree of the tree. The following diagram
    shows the kinds of trees discussed earlier:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**满树：** 所有节点的度都相同的树称为满树，其度将等于树的度。下图展示了前面讨论过的树的类型：'
- en: '![](assets/5a20e164-3199-48f1-a79d-fde170d1ed32.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5a20e164-3199-48f1-a79d-fde170d1ed32.png)'
- en: Note that the binary tree on the left is not a full tree, as node **C** has
    a degree of one and all other nodes have a degree of two. The tree in the middle
    and the one on the left are both full trees.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，左侧的二叉树不是一棵满树，因为节点**C**的度为1，而所有其他节点的度为2。中间的树和左侧的树都是满树。
- en: '**Perfect tree****:** A perfect tree is a special type of full tree in which
    all the leaf nodes are at the same level. For example, the binary tree on the
    right as shown in the preceding diagram is a perfect, full tree as all the leaf
    nodes are at the same level, that is, **level 2**.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完美树：** 完美树是一种特殊类型的满树，其中所有叶节点都在同一级别。例如，右侧的二叉树如前图所示是一棵完美的满树，因为所有叶节点都在同一级别，即**级别2**。'
- en: '**Ordered t****ree**: If the children of a node are organized in some order
    according to particular criteria, the tree is called an *ordered tree*. A tree,
    for example, can be ordered left to right in an ascending order in which the nodes
    at the same level will increase in value while traversing from left to right.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有序树：** 如果节点的子节点根据特定标准有序排列，那么树被称为*有序树*。例如，树可以按照从左到右的升序顺序进行排序，同一级别的节点在从左到右遍历时值会增加。'
- en: Practical examples
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际例子
- en: An abstract data type tree is one of the main data structures that are used
    in developing decision trees as will be discussed in [Chapter 7](e3df232d-9571-4514-a5f1-2789965492e1.xhtml),
    *Traditional Supervised Learning Algorithms*. Due to its hierarchical structure,
    it is also popular in algorithms related to network analysis as will be discussed
    in detail in [Chapter 6](ce14ecc1-8ad5-406e-88d0-7f3acb3e4569.xhtml), *Unsupervised
    Machine Learning Algorithms*. Trees are also used in various search and sort algorithms
    where divide and conquer strategies need to be implemented.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 树是一种主要的数据结构之一，在开发决策树中被使用，将在[第7章](e3df232d-9571-4514-a5f1-2789965492e1.xhtml)
    *传统监督学习算法*中讨论。由于其分层结构，它在与网络分析相关的算法中也很受欢迎，将在[第6章](ce14ecc1-8ad5-406e-88d0-7f3acb3e4569.xhtml)
    *无监督机器学习算法*中详细讨论。树还被用于各种搜索和排序算法，其中需要实现分而治之的策略。
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed data structures that can be used to implement
    various types of algorithms. After going through this chapter, I expect that you
    should be able to select the right data structure to be used to store and process
    data by an algorithm. You should also be able to understand the implications of
    our choice on the performance of the algorithm.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了可以用来实现各种类型算法的数据结构。通过阅读本章，我期望你能够选择合适的数据结构来存储和处理算法的数据。你还应该能够理解我们选择对算法性能的影响。
- en: The next chapter is about sorting and searching algorithms, where we will be
    using some of the data structures presented in this chapter in the implementation
    of the algorithms.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是关于排序和搜索算法，我们将在算法的实现中使用本章介绍的一些数据结构。
