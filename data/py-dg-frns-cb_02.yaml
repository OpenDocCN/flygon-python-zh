- en: Creating Artifact Report Recipes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建物件报告配方
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Using HTML templates
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML模板
- en: Creating a paper trail
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一份纸质追踪
- en: Working with CSVs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSV
- en: Visualizing events with Excel
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Excel可视化事件
- en: Auditing your work
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计您的工作
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Probably within the first few hours of starting your career in cyber security,
    you were already hunched over a screen, feverishly scanning a spreadsheet for
    clues. This sounds familiar because it is true and part of the daily process for
    most investigations. Spreadsheets are the bread and butter of cyber security.
    Within them are details of various processes and specific information extracted
    from valuable artifacts. In this cookbook, we will frequently output parsed artifact
    data into a spreadsheet due to its portability and ease of use. However, considering
    that at one time or another every cyber security professional has created a technical
    report for a nontechnical audience, a spreadsheet may not be the best option.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始从事网络安全职业的前几个小时内，您可能已经弯腰在屏幕前，疯狂地扫描电子表格以寻找线索。这听起来很熟悉，因为这是真实的，也是大多数调查的日常流程的一部分。电子表格是网络安全的基础。其中包含了各种流程的细节以及从有价值的物件中提取的具体信息。在这本食谱书中，我们经常会将解析后的物件数据输出到电子表格中，因为它便携且易于使用。然而，考虑到每个网络安全专业人员都曾经为非技术人员创建过技术报告，电子表格可能不是最佳选择。
- en: Why create reports at all? I think I've heard that muttered by stressed examiners
    before. Today, everything is built on information interchange and people want
    to know things as soon as you do. But that doesn't necessarily mean they want
    a technical spreadsheet and to figure it out themselves. Examiners must be able
    to effectively distill technical knowledge to laymen audiences in order to properly
    do their job. As good as an artifact may be, even if it is the proverbial smoking
    gun for a given case, it will likely require detailed explanation to nontechnical
    individuals for them to fully understand the meaning and ramifications. Give up;
    reports are here to stay and there's nothing that can be done about that.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要创建报告？我想我以前听到过紧张的审查员喃喃自语。今天，一切都建立在信息交换之上，人们希望尽快了解事情。但这并不一定意味着他们希望得到一个技术电子表格并自己弄清楚。审查员必须能够有效地将技术知识传达给非专业观众，以便正确地完成他们的工作。即使一个物件可能非常好，即使它是某个案例的象征性证据，它很可能需要向非技术人员进行详细解释，以便他们完全理解其含义和影响。放弃吧；报告会一直存在，对此无能为力。
- en: 'In this chapter, you will learn how to create a number of different types of
    reports and a script to automatically audit our investigation. We will create
    HTML, XLSX, and CSV reports to summarize data in a meaningful manner:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何创建多种不同类型的报告以及一个用于自动审计我们调查的脚本。我们将创建HTML、XLSX和CSV报告，以便以有意义的方式总结数据：
- en: Developing an HTML dashboard template
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发HTML仪表板模板
- en: Parsing FTK Imager acquisition logs
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析FTK Imager获取日志
- en: Building a robust CSV writer
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建强大的CSV写入器
- en: Plotting charts and data with Microsoft Excel
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Microsoft Excel绘制图表和数据
- en: Creating an audit trail of screenshots throughout an investigation
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调查过程中创建截图的审计跟踪
- en: Visit [www.packtpub.com/books/content/support](http://www.packtpub.com/books/content/support)
    to download the code bundle for this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[www.packtpub.com/books/content/support](http://www.packtpub.com/books/content/support)下载本章的代码捆绑包。
- en: Using HTML templates
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTML模板
- en: 'Recipe Difficulty: Easy'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 配方难度：简单
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Any'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任意
- en: HTML can be an effective medium for a report. There are a great number of snazzy
    templates out there that can make even technical reports look appealing. That's
    the first step towards hooking the audience. Or, at the very least, a preventative
    measure to forestall the audience from instantly nodding off. This recipe uses
    one such template and some test data to create a visually compelling example of
    acquisition details. We really have our work cut out for us here.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: HTML可以是一份有效的报告。有很多时髦的模板可以使即使是技术报告看起来也很吸引人。这是吸引观众的第一步。或者至少是一种预防措施，防止观众立刻打瞌睡。这个配方使用了这样一个模板和一些测试数据，以创建一个视觉上引人注目的获取细节的例子。我们在这里确实有很多工作要做。
- en: Getting started
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'This recipe introduces HTML templating with the `jinja2` module. The `jinja2`
    library is a very powerful tool and has a number of different documented features.
    We will be using it in a rather simple scenario. All other libraries used in this
    script are present in Python''s standard library. We can use pip to install `jinja2`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方介绍了使用`jinja2`模块的HTML模板化。`jinja2`库是一个非常强大的工具，具有许多不同的文档化功能。我们将在一个相当简单的场景中使用它。此脚本中使用的所有其他库都包含在Python的标准库中。我们可以使用pip来安装`jinja2`：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In addition to `jinja2`, we will also be using a slightly modified template,
    called light bootstrap dashboard. This slightly modified dashboard has been provided
    with the recipe's code bundle.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`jinja2`之外，我们还将使用一个稍微修改过的模板，称为轻量级引导式仪表板。这个稍微修改过的仪表板已经随配方的代码捆绑提供了。
- en: To learn more about the `jinja2` library, visit [http://jinja.pocoo.org/docs/2.9/](http://jinja.pocoo.org/docs/2.9/).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`jinja2`库的信息，请访问[http://jinja.pocoo.org/docs/2.9/](http://jinja.pocoo.org/docs/2.9/)。
- en: To download the light bootstrap dashboard, visit [https://www.creative-tim.com/product/light-bootstrap-dashboard](https://www.creative-tim.com/product/light-bootstrap-dashboard).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载轻量级引导式仪表板，请访问[https://www.creative-tim.com/product/light-bootstrap-dashboard](https://www.creative-tim.com/product/light-bootstrap-dashboard)。
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We deploy an HTML dashboard following these principles:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循以下原则部署HTML仪表板：
- en: Design HTML template global variables.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设计HTML模板全局变量。
- en: Process the test acquisition metadata.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理测试获取元数据。
- en: Render the HTML templates with the inserted acquisition metadata.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用插入的获取元数据呈现HTML模板。
- en: Create a report in the desired output directory.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所需的输出目录中创建报告。
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, we import the required libraries to handle argument parsing, creating
    counts of objects, and copying files:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的库来处理参数解析、创建对象计数和复制文件：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This recipe''s command-line handler takes one positional argument, `OUTPUT_DIR`,
    which represents the desired output path for the HTML dashboard. After checking
    whether the directory exists, and creating it if it doesn''t, we call the `main()`
    function and pass the output directory to it:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的命令行处理程序接受一个位置参数 `OUTPUT_DIR`，它表示 HTML 仪表板的期望输出路径。在检查目录是否存在并在不存在时创建它之后，我们调用
    `main()` 函数并将输出目录传递给它：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Defined at the top of the script are a number of global variables: `DASH`,
    `TABLE`, and `DEMO`. These variables represent the various HTML and JavaScript
    files we create as a product of the script. This is a book about Python, so we
    will not get into the details of how these files are structured and how they work.
    However, let''s look at an example to showcase how `jinja2` bridges the gap between
    these types of files and Python.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本顶部定义了一些全局变量：`DASH`、`TABLE` 和 `DEMO`。这些变量代表脚本生成的各种 HTML 和 JavaScript 文件。这是一本关于
    Python 的书，所以我们不会深入讨论这些文件的结构和工作原理。不过，让我们看一个示例，展示 `jinja2` 如何弥合这些类型文件和 Python 之间的差距。
- en: 'A portion of the global variable `DEMO` is captured in the following snippet.
    Note that the string block is passed to the `jinja2.Template()` method. This allows
    us to create an object for which we can use `jinja2` to interact with and dynamically
    insert data into the JavaScript file. Specifically, the following code block shows
    two locations where we can use `jinja2` to insert data. These are denoted by the
    double curly braces and the keywords we will refer to them by in the Python code
    - `pi_labels` and `pi_series`, respectively:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段捕获了全局变量 `DEMO` 的一部分。请注意，字符串块被传递给 `jinja2.Template()` 方法。这使我们能够创建一个对象，可以使用
    `jinja2` 与之交互并动态插入数据到 JavaScript 文件中。具体来说，以下代码块显示了两个我们可以使用 `jinja2` 插入数据的位置。这些位置由双大括号和我们在
    Python 代码中将引用它们的关键字（`pi_labels` 和 `pi_series`）表示：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s now turn our attention to the `main()` function. This function is really
    quite simple for reasons you will understand in the second recipe. This function
    creates a list of lists containing sample acquisition data, prints a status message
    to the console, and sends that data to the `process_data()` method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转向 `main()` 函数。由于您将在第二个配方中理解的原因，这个函数实际上非常简单。这个函数创建一个包含示例获取数据的列表列表，向控制台打印状态消息，并将该数据发送到
    `process_data()` 方法：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The purpose of the `process_data()` method is to get the sample acquisition
    data into an HTML or JavaScript format that we can drop in place within the `jinja2`
    templates. This dashboard is going to have two components: a series of charts
    visualizing the data and a table of the raw data. The following code block deals
    with the latter. We accomplish this by iterating through the acquisition list
    and adding each element of the table to the `html_table` string with the appropriate
    HTML tags:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_data()` 方法的目的是将示例获取数据转换为 HTML 或 JavaScript 格式，以便我们可以将其放置在 `jinja2`
    模板中。这个仪表板将有两个组件：可视化数据的一系列图表和原始数据的表格。以下代码块处理了后者。我们通过遍历获取列表并使用适当的 HTML 标记将表的每个元素添加到
    `html_table` 字符串中来实现这一点：'
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we use the `Counter()` method from the `collections` library to quickly
    generate a dictionary-like object of the number of occurrences of each item in
    the sample data. For example, the first `Counter` object, `device_types`, creates
    a dictionary-like object where each key is a different device type (for example,
    mobile, external, and computer) and the value represents the number of occurrences
    of each key. This allows us to quickly summarize data across the data set and
    cuts down on the legwork required before we can plot this information.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `collections` 库中的 `Counter()` 方法快速生成一个类似字典的对象，表示样本数据中每个项目的出现次数。例如，第一个
    `Counter` 对象 `device_types` 创建了一个类似字典的对象，其中每个键都是不同的设备类型（例如，移动设备、外部设备和计算机），值表示每个键的出现次数。这使我们能够快速总结数据集中的数据，并减少了在绘制此信息之前所需的工作量。
- en: 'Once we have created the `Counter` objects, we again iterate through each acquisition
    to perform a more manual summation of acquisition date information. This `date_dict`
    object maintains keys for all the acquisition data and adds the size of all acquisitions
    made on that day as the key''s value. We specifically split on a space to isolate
    just the date value from the date-time string (for example, `08/15/2017`). If
    the specific date is already in the dictionary, we add the acquisition size directly
    to the key. Otherwise, we create the key and assign its value to the acquisition
    size. Once we have created the various summarizing objects, we call the `output_html()`
    method to populate the HTML dashboard with this information:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了 `Counter` 对象，我们再次遍历每个获取以执行更多手动的获取日期信息的总结。这个 `date_dict` 对象维护了所有获取数据的键，并将在该天进行的所有获取的大小添加为键的值。我们特别在空格上拆分，以仅从日期时间字符串中隔离出日期值（例如，`08/15/2017`）。如果特定日期已经在字典中，我们直接将获取大小添加到键中。否则，我们创建键并将其值分配给获取大小。一旦我们创建了各种总结对象，我们调用
    `output_html()` 方法来用这些信息填充 HTML 仪表板：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `output_html()` method starts by printing a status message to the console
    and storing the current working directory to a variable. We append the folder
    path to light-bootstrap-dashboard and use `shutil.copytree()` to copy the bootstrap
    files to the output directory. Following that, we create three file paths representing
    the output locations and names of the three `jinja2` templates:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`output_html()` 方法首先通过在控制台打印状态消息并将当前工作目录存储到变量中来开始。我们将文件夹路径附加到 light-bootstrap-dashboard，并使用
    `shutil.copytree()` 将 bootstrap 文件复制到输出目录。随后，我们创建三个文件路径，表示三个 `jinja2` 模板的输出位置和名称：'
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s start by looking at the two HTML files, as these are relatively simple.
    After opening file objects for the two HTML files, we use the `jinja2.render()`
    method and use keyword arguments to refer to the placeholders in the curly brackets
    from the `Template` objects. With the file rendered with the Python data, we write
    the data to the file. Simple, right? The JavaScript file, thankfully, is not much
    more difficult:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看两个HTML文件，因为它们相对简单。在为两个HTML文件打开文件对象之后，我们使用`jinja2.render()`方法，并使用关键字参数来引用`Template`对象中花括号中的占位符。使用Python数据呈现文件后，我们将数据写入文件。简单吧？幸运的是，JavaScript文件并不难：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'While syntactically similar to the previous code block, when we render the
    data this time, we feed the data to the `return_labels()` and `return_series()`
    methods. These methods take the key and values from the `Counter` objects and
    format them appropriately to work with the JavaScript file. You may have also
    noticed a call to the `calculate_size()` method in the previous code block called
    on the `dates` dictionary. Let''s explore these three supporting functions now:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在语法上与前一个代码块相似，但这次在呈现数据时，我们将数据提供给`return_labels()`和`return_series()`方法。这些方法从`Counter`对象中获取键和值，并适当地格式化以与JavaScript文件一起使用。您可能还注意到在前一个代码块中对`dates`字典调用了`calculate_size()`方法。现在让我们来探讨这三个支持函数：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `calculate_size()` method simply uses the built-in `sum()` method to return
    each date key''s total size collected. The `return_labels()` and `return_series()`
    methods use string methods to format the data appropriately. Essentially, the
    JavaScript file expects the labels to be within single quotes, which is accomplished
    with the `format()` method, and both labels and series must be comma-delimited:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculate_size()`方法简单地使用内置的`sum()`方法返回每个日期键收集的总大小。`return_labels()`和`return_series()`方法使用字符串方法适当地格式化数据。基本上，JavaScript文件期望标签在单引号内，这是通过`format()`方法实现的，标签和系列都必须用逗号分隔：'
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we run this script, we receive a copy of the report in the specified output
    directory along with the required assets for loading and rendering the page. We
    can zip up this folder and provide it to team members, as it is designed to be
    portable. Viewing this dashboard shows us the first page with the chart information:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个脚本时，我们会收到报告的副本，以及加载和呈现页面所需的资产，放在指定的输出目录中。我们可以将这个文件夹压缩并提供给团队成员，因为它被设计为可移植的。查看这个仪表板，我们可以看到包含图表信息的第一页：
- en: '![](../images/00015.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00015.jpeg)'
- en: 'And the second page as the table of acquisition information:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以及作为采集信息表的第二页：
- en: '![](../images/00016.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00016.jpeg)'
- en: There's more...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'This script can be further improved. We have provided a couple of recommendations
    here:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。我们在这里提供了一些建议：
- en: Add support for additional types of reports to better highlight the data
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加对其他类型报告的支持，以更好地突出显示数据
- en: Include the ability to export the tables and charts for printing and sharing
    through additional javascript
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括通过额外的javascript导出表格和图表以进行打印和分享的能力
- en: Creating a paper trail
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一份纸质记录
- en: 'Recipe Difficulty: Medium'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 菜谱难度：中等
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Any'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任何
- en: Most imaging utilities create audit logs recording the details of the acquisition
    media and other available metadata. Admit it; unless something goes horribly wrong,
    these logs are mostly untouched if the evidence verifies. Let's change that and
    leverage the newly created HTML dashboard from the previous recipe and make better
    use of this acquisition data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数成像工具都会创建记录采集介质细节和其他可用元数据的审计日志。承认吧；除非出现严重问题，否则这些日志大多不会被触及，如果证据验证了。让我们改变这种情况，利用前一个菜谱中新创建的HTML仪表板，并更好地利用这些采集数据。
- en: Getting started
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: All libraries used in this script are present in Python's standard library or
    functions imported from the prior script.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本中使用的所有库都存在于Python的标准库中，或者是从之前的脚本中导入的函数。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We parse acquisition logs with these steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下步骤解析采集日志：
- en: Identify and validate FTK logs.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别和验证FTK日志。
- en: Parse the log to extract relevant fields.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析日志以提取相关字段。
- en: Create a dashboard with the acquisition data.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含采集数据的仪表板。
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'First, we import the required libraries to handle argument parsing, parsing
    dates, and the `html_dashboard` script we created in the previous recipe:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的库来处理参数解析、解析日期和我们在上一个菜谱中创建的`html_dashboard`脚本：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This recipe''s command-line handler takes two positional arguments, `INPUT_DIR`
    and `OUTPUT_DIR`, which represent the path to the directory containing acquisition
    logs and the desired output path, respectively. After creating the output directory,
    if necessary, and validating that the input directory exists, we call the `main()`
    method and pass these two variables to it:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的命令行处理程序接受两个位置参数，`INPUT_DIR`和`OUTPUT_DIR`，分别代表包含采集日志的目录路径和期望的输出路径。在创建输出目录（如果需要）并验证输入目录存在后，我们调用`main()`方法并将这两个变量传递给它：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the `main()` function, we use the `os.listdir()` function to get a directory
    listing of the input directory and identify only those files with a `.txt` file
    extension. This is important, as FTK Imager creates acquisition logs with the
    `.txt` extension. This helps us avoid some files that should not be processed
    by the extension alone. We will, however, take it one step further. After we create
    a list of the possible FTK logs, we create a placeholder list, `ftk_data`, to
    store the processed acquisition data. Next, we iterate through each potential
    log and set up a dictionary with the desired keys we will extract. To further
    eliminate false positives, we call the `validate_ftk()` method, which returns
    either a `True` or `False` Boolean value depending on the results of its inspection.
    Let''s take a quick look at how it works:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们使用`os.listdir()`函数获取输入目录的目录列表，并仅识别具有`.txt`文件扩展名的文件。这很重要，因为FTK
    Imager创建带有`.txt`扩展名的获取日志。这有助于我们仅通过扩展名避免处理一些不应该处理的文件。然而，我们将进一步进行。在创建可能的FTK日志列表后，我们创建一个占位符列表`ftk_data`，用于存储处理过的获取数据。接下来，我们遍历每个潜在的日志，并设置一个具有所需键的字典来提取。为了进一步排除误报，我们调用`validate_ftk()`方法，该方法根据其检查结果返回`True`或`False`布尔值。让我们快速看一下它是如何工作的：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Thankfully, each FTK Imager log contains the words `"Created by AccessData"`
    on the first line. We can rely on this to be the case to verify that the log is
    likely a valid FTK Imager log. With the input `log_file` path, we open the file
    object and read the first line using the `readline()` method. With the first line
    extracted, we check whether the phrase is present and return `True` if it is or
    `False` otherwise:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 值得庆幸的是，每个FTK Imager日志的第一行都包含“Created by AccessData”这几个词。我们可以依靠这一点来验证该日志很可能是有效的FTK
    Imager日志。使用输入的`log_file`路径，我们打开文件对象并使用`readline()`方法读取第一行。提取第一行后，我们检查短语是否存在，如果存在则返回`True`，否则返回`False`：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Back in the `main()` method, after having validated the FTK Imager log, we open
    the file, set a few variables to `None`, and begin iterating through each line
    in the file. Based on the dependable layout of these logs, we can use specific
    keywords to identify whether the current line is one we are interested in. For
    example, if the line contains the phrase `"Evidence Number:"`, we can be sure
    that this line contains the evidence number value. And in fact, we split the phrase
    and take the value to the right of the colon and associate it with the dictionary
    `e_numb` key. This type of logic can be applied to most of the desired values,
    with a few exceptions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`main()`方法，在验证了FTK Imager日志之后，我们打开文件，将一些变量设置为`None`，并开始迭代文件中的每一行。基于这些日志的可靠布局，我们可以使用特定关键字来识别当前行是否是我们感兴趣的行。例如，如果该行包含短语“Evidence
    Number:”，我们可以确定该行包含证据编号值。实际上，我们分割短语并取冒号右侧的值，并将其与字典`e_numb`键关联。这种逻辑可以应用于大多数所需的值，但也有一些例外。
- en: 'For the acquisition time, we must use the `datetime.strptime()` method to convert
    the string into an actual `datetime` object. We must do this to store it in the
    format that the HTML dashboard is expecting. We use the `strftime()` method on
    the `datetime` object and associate it with the `date` key in the dictionary:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于获取时间，我们必须使用`datetime.strptime()`方法将字符串转换为实际的`datetime`对象。我们必须这样做才能以HTML仪表板期望的格式存储它。我们在字典中使用`datetime`对象的`strftime()`方法并将其与`date`键关联：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The bytes per sector and sector count are handled a little differently from
    the rest. Due to the fact that the HTML dashboard script is expecting to receive
    the data size (in GB), we need to extract these values and calculate the acquired
    media size. To do this, once identified, we convert each value into an integer
    and assign it to the two local variables that were originally `None`. Once we
    finish iterating through all lines, we check whether these variables are no longer
    `None`, and if they are not, we send them to the `calculate_size()` method. This
    method performs the necessary calculation and stores the media size within the
    dictionary:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每个扇区的字节数和扇区计数与其他部分处理方式略有不同。由于HTML仪表板脚本期望接收数据大小（以GB为单位），我们需要提取这些值并计算获取的媒体大小。一旦识别出来，我们将每个值转换为整数，并将其分配给最初为`None`的两个局部变量。在完成对所有行的迭代后，我们检查这些变量是否不再是`None`，如果不是，则将它们发送到`calculate_size()`方法。该方法执行必要的计算并将媒体大小存储在字典中：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once the file has been processed, the dictionary with the extracted acquisition
    data is appended to the `ftk_data` list. After all the logs have been processed,
    we call the `html_dashboard.process_data()` method and supply it with the acquisition
    data and output directory. The `process_data()` function is, of course, the exact
    same as the previous recipe. Therefore, you know that this acquisition data replaces
    the sample acquisition data of the previous recipe and populates the HTML dashboard
    with real data:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 处理完文件后，提取的获取数据的字典将附加到`ftk_data`列表中。在处理完所有日志后，我们调用`html_dashboard.process_data()`方法，并向其提供获取数据和输出目录。`process_data()`函数当然与上一个示例中的完全相同。因此，您知道这些获取数据将替换上一个示例中的示例获取数据，并用真实数据填充HTML仪表板：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we run this tool, we can see the acquisition log information, as shown
    in the following two screenshots:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个工具时，我们可以看到获取日志信息，如下两个截图所示：
- en: '![](../images/00017.jpeg)![](../images/00018.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00017.jpeg)![](../images/00018.jpeg)'
- en: There's more...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This script can be further improved. Here''s a recommendation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。以下是一个建议：
- en: Create additional scripts to support logs from other acquisition tools, such
    as **Guymager**, **Cellebrite**, **MacQuisition**, and so on
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建额外的脚本以支持来自其他获取工具的日志，例如**Guymager**，**Cellebrite**，**MacQuisition**等等
- en: Working with CSVs
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理CSV文件
- en: 'Recipe Difficulty: Easy'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱难度：简单
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Any'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任意
- en: Everyone has reviewed data in a CSV spreadsheet at some point. They are pervasive
    and a common output format for most applications. Writing CSVs with Python is
    one of the easiest methods to create a report of processed data. In this recipe,
    we will demonstrate how you can use the `csv` and `unicodecsv` libraries to create
    quick reports with Python.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都曾经在CSV电子表格中查看过数据。它们是无处不在的，也是大多数应用程序的常见输出格式。使用Python编写CSV是创建处理数据报告的最简单方法之一。在这个配方中，我们将演示如何使用`csv`和`unicodecsv`库来快速创建Python报告。
- en: Getting started
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'Part of this recipe uses the `unicodecsv` module. This module replaces the
    built-in Python 2 `csv` module and adds Unicode support. Python 3''s `csv` module
    does not have this limitation and can be used without the support of any additional
    library. All other libraries used in this script are present in Python''s standard
    library. The `unicodecsv` library can be installed with `pip`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的一部分使用了`unicodecsv`模块。该模块替换了内置的Python 2 `csv`模块，并添加了Unicode支持。Python 3的`csv`模块没有这个限制，可以在不需要任何额外库支持的情况下使用。此脚本中使用的所有其他库都包含在Python的标准库中。`unicodecsv`库可以使用`pip`安装：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To learn more about the `unicodecsv` library, visit [https://github.com/jdunck/python-unicodecsv](https://github.com/jdunck/python-unicodecsv).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`unicodecsv`库的信息，请访问[https://github.com/jdunck/python-unicodecsv](https://github.com/jdunck/python-unicodecsv)。
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We follow these steps to create CSV spreadsheets:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下步骤创建CSV电子表格：
- en: Identify the version of Python that invoked the script.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别调用脚本的Python版本。
- en: Output a list of lists and a list of dictionaries using Python 2 and Python
    3 conventions to spreadsheets in the current working directory.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python 2和Python 3的约定在当前工作目录的电子表格中输出一个列表和一个字典列表。
- en: How it works...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, we import the required libraries to write spreadsheets. Later on in
    this recipe, we also import the `unicodecsv` module:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的库来写入电子表格。在这个配方的后面，我们还导入了`unicodecsv`模块：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This recipe does not use `argparse` as a command-line handler. Instead, we
    directly call the desired functions based on the version of Python. We can determine
    the version of Python running with the `sys.version_info` attribute. If the user
    is using Python 2.X, we call both the `csv_writer_py2()` and `unicode_csv_dict_writer_py2()`
    methods. Both of these methods take four arguments, where the last argument is
    optional: these are the data to write, a list of headers, the desired output directory,
    and, optionally, the name of the output CSV spreadsheet. Alternatively, if Python
    3.X is being used, we call the `csv_writer_py3()` method. While similar, CSV writing
    is handled a little differently between the two versions of Python, and the `unicodecsv`
    module is applicable only to Python 2:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方不使用`argparse`作为命令行处理程序。相反，我们根据Python的版本直接调用所需的函数。我们可以使用`sys.version_info`属性确定正在运行的Python版本。如果用户使用的是Python
    2.X，我们调用`csv_writer_py2()`和`unicode_csv_dict_writer_py2()`方法。这两种方法都接受四个参数，最后一个参数是可选的：要写入的数据、标题列表、所需的输出目录，以及可选的输出CSV电子表格的名称。或者，如果使用的是Python
    3.X，我们调用`csv_writer_py3()`方法。虽然相似，但在两个版本的Python之间处理CSV写入的方式有所不同，而`unicodecsv`模块仅适用于Python
    2：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This recipe has two global variables that represent sample data types. The
    first of these, `TEST_DATA_LIST`, is a nested list structure containing strings
    and integers. The second, `TEST_DATA_DICT`, is another representation of this
    data but stored as a list of dictionaries. Let''s look at how the various functions
    write this sample data to the output CSV file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方有两个表示样本数据类型的全局变量。其中第一个`TEST_DATA_LIST`是一个嵌套列表结构，包含字符串和整数。第二个`TEST_DATA_DICT`是这些数据的另一种表示，但存储为字典列表。让我们看看各种函数如何将这些样本数据写入输出CSV文件：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `csv_writer_py2()` method first checks whether the name input was provided.
    If it is still the default value of `None`, we simply assign the output name ourselves.
    Next, after printing a status message to the console, we open a `File` object
    in the `"wb"` mode in the desired output directory. Note that it is important
    to open CSV files in the `"wb"` mode in Python 2 to prevent intervening gaps between
    rows in the resulting spreadsheet. Once we have the `File` object, we use the
    `csv.writer()` method to convert this into a `writer` object. With this, we can
    use the `writerow()` and `writerows()` methods to write a single list of data
    and a nested list structure, respectively. Now, let''s look at how `unicodecsv`
    works with lists of dictionaries:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`csv_writer_py2()`方法首先检查输入的名称是否已提供。如果仍然是默认值`None`，我们就自己分配输出名称。接下来，在控制台打印状态消息后，我们在所需的输出目录中以`"wb"`模式打开一个`File`对象。请注意，在Python
    2中重要的是以`"wb"`模式打开CSV文件，以防止在生成的电子表格中的行之间出现干扰间隙。一旦我们有了`File`对象，我们使用`csv.writer()`方法将其转换为`writer`对象。有了这个，我们可以使用`writerow()`和`writerows()`方法分别写入单个数据列表和嵌套列表结构。现在，让我们看看`unicodecsv`如何处理字典列表：'
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `unicodecsv` module is a drop in for the built-in `csv` module and can be
    used interchangeably. The difference, and it's a big one, is that `unicodecsv`
    automatically handles Unicode strings in a way that the built-in `csv` module
    in Python 2 does not. This was addressed in Python 3.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`unicodecsv`模块是内置`csv`模块的替代品，可以互换使用。不同之处在于，`unicodecsv`自动处理Unicode字符串的方式与Python
    2中的内置`csv`模块不同。这在Python 3中得到了解决。'
- en: First, we attempt to import the `unicodecsv` module and print a status message
    to the console if the import fails before exiting the script. If we are able to
    import the library, we check whether the name input was supplied and create a
    name if it wasn't, before opening a `File` object. With this `File` object, we
    use the `unicodecsv.DictWriter` class and supply it with the list of headers.
    This object, by default, expects the keys present in the supplied `fieldnames`
    list to represent all of the keys in each dictionary. If this behavior is not
    desired or if this is not the case, it can be ignored by setting the extrasaction
    keyword argument to the string `ignore`. Doing so will result in all additional
    dictionary keys not specified in the `fieldnames` list being ignored and not added
    to the CSV spreadsheet.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们尝试导入`unicodecsv`模块，并在退出脚本之前，如果导入失败，则在控制台打印状态消息。如果我们能够导入库，我们检查是否提供了名称输入，并在打开`File`对象之前创建一个名称。使用这个`File`对象，我们使用`unicodecsv.DictWriter`类，并提供它的标题列表。默认情况下，该对象期望提供的`fieldnames`列表中的键表示每个字典中的所有键。如果不需要这种行为，或者如果不是这种情况，可以通过将extrasaction关键字参数设置为字符串`ignore`来忽略它。这样做将导致所有未在`fieldnames`列表中指定的附加字典键被忽略，并且不会添加到CSV电子表格中。
- en: 'After the `DictWriter` object is set up, we use the `writerheader()` method
    to write the field names and `writerows()` to, this time, write the list of dictionaries
    to the CSV file. Another important thing to note is that the columns will be in
    the order of the elements in the supplied `fieldnames` list:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`DictWriter`对象后，我们使用`writerheader()`方法写入字段名称，然后使用`writerows()`方法，这次将字典列表写入CSV文件。另一个重要的事情要注意的是，列将按照提供的`fieldnames`列表中元素的顺序排列：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Lastly, the `csv_writer_py3()` method operates in mostly the same fashion.
    However, note the difference in how the `File` object is created. Rather than
    opening a file in the `"wb"` mode, with Python 3, we open the file in the `"w"`
    mode and set the newline keyword argument to an empty string. After doing that,
    the rest of the operations proceed in the same manner as previously described:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`csv_writer_py3()`方法的操作方式基本相同。但是，请注意`File`对象创建方式的不同。与在Python 3中以`"wb"`模式打开文件不同，我们以`"w"`模式打开文件，并将newline关键字参数设置为空字符串。在这样做之后，其余的操作与之前描述的方式相同：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we run this code, we can look at either of the two newly generated CSV
    files and see the same information, as in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们可以查看两个新生成的CSV文件中的任何一个，并看到与以下截图中相同的信息：
- en: '![](../images/00019.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00019.jpeg)'
- en: There's more...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This script can be further improved. Here''s a recommendation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。以下是一个建议：
- en: Create more robust CSV writers with additional feature sets and options. The
    idea here is that you could supply data of different types and have a method to
    handle them equivalently.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更健壮的CSV写入器和附加功能集和选项。这里的想法是，您可以提供不同类型的数据，并有一个处理它们的方法。
- en: Visualizing events with Excel
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Excel可视化事件
- en: 'Recipe Difficulty: Easy'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 配方难度：简单
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Any'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任何
- en: Let's take it one step further from the previous recipe with Excel. Excel is
    a very robust spreadsheet application and we can do a lot with it. We will use
    Excel to create a table and plot graphs of the data.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上一个配方进一步进行Excel。Excel是一个非常强大的电子表格应用程序，我们可以做很多事情。我们将使用Excel创建一个表格，并绘制数据的图表。
- en: Getting started
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'There are a number of different Python libraries with varying support for Excel
    and its many features. In this recipe, we use the `xlsxwriter` module to create
    a table and graph of the data. This module can be used for much more than that.
    This module can be installed by `pip` using the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的Python库，对Excel及其许多功能的支持各不相同。在这个配方中，我们使用`xlsxwriter`模块来创建数据的表格和图表。这个模块可以用于更多的用途。可以使用以下命令通过`pip`安装这个模块：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To learn more about the `xlsxwriter` library, visit [https://xlsxwriter.readthedocs.io/](https://xlsxwriter.readthedocs.io/).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于`xlsxwriter`库的信息，请访问[https://xlsxwriter.readthedocs.io/](https://xlsxwriter.readthedocs.io/)。
- en: We also use a custom `utilcsv` module that we wrote based on the previous recipe
    to handle interactions with CSVs. All other libraries used in this script are
    present in Python's standard library.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一个基于上一个配方编写的自定义`utilcsv`模块来处理与CSV的交互。此脚本中使用的所有其他库都包含在Python的标准库中。
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We create an Excel spreadsheet via the following steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下步骤创建Excel电子表格：
- en: Create a workbook and worksheet objects.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建工作簿和工作表对象。
- en: Create a table of spreadsheet data.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建电子表格数据的表格。
- en: Create a chart of the event log data.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建事件日志数据的图表。
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, we import the required libraries to handle argument parsing, creating
    counts of objects, parsing dates, writing XLSX spreadsheets, and our custom `utilcsv`
    module, which handles CSV reading and writing in this recipe:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的库来处理参数解析、创建对象计数、解析日期、编写XLSX电子表格，以及我们的自定义`utilcsv`模块，该模块在这个配方中处理CSV的读取和写入：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This recipe''s command-line handler takes one positional argument: `OUTPUT_DIR`.
    This represents the desired output path for the `XLSX` file. Before calling the
    `main()` method, we check whether the output directory exists and create it if
    it does not:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的命令行处理程序接受一个位置参数：`OUTPUT_DIR`。这代表了`XLSX`文件的期望输出路径。在调用`main()`方法之前，我们检查输出目录是否存在，如果不存在则创建它：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `main()` function is really quite simple; its job is to print a status
    message to the console, use the `csv_reader()` method, which is a slightly modified
    function from the previous recipe, and then write the resulting data to the output
    directory with the `xlsx_writer()` method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数实际上非常简单；它的工作是在控制台打印状态消息，使用`csv_reader()`方法（这是从上一个配方稍微修改的函数），然后使用`xlsx_writer()`方法将结果数据写入输出目录：'
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `xlsx_writer()` starts by printing a status message and creating the `workbook`
    object in the output directory. Next, we create two `worksheet` objects for the
    dashboard and data worksheets. The dashboard worksheet will contain a graph summarizing
    the raw data on the data worksheet:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`xlsx_writer()`从打印状态消息和在输出目录中创建`workbook`对象开始。接下来，我们为仪表板和数据工作表创建了两个`worksheet`对象。仪表板工作表将包含一个总结数据工作表上原始数据的图表：'
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We use the `add_format()` method on the `workbook` object to create customized
    formats for the spreadsheet. These formats are dictionaries with key-value pairs
    configuring the format. Most of these keys are self-explanatory based on the key
    name. A description of the various format options and features can be found at
    [http://xlsxwriter.readthedocs.io/format.html](http://xlsxwriter.readthedocs.io/format.html):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`workbook`对象上使用`add_format()`方法来为电子表格创建自定义格式。这些格式是带有键值对配置格式的字典。根据键名，大多数键都是不言自明的。有关各种格式选项和功能的描述可以在[http://xlsxwriter.readthedocs.io/format.html](http://xlsxwriter.readthedocs.io/format.html)找到：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With the formats set, we can enumerate through the list of lists and write each
    using the `write()` method. This method takes a few inputs; the first and second
    arguments are the row and column followed by the value to write. Note that in
    addition to the `write()` method, we also use the `write_number()` and `write_datetime()`
    methods. These preserve the data type within the XLSX spreadsheet. Specifically,
    with the `write_datetime()` method, we supply it with the `date_format` variable
    to appropriately format the date object. After looping through all of the data,
    we have successfully stored the data within the spreadsheet and retained its value
    types. However, we can do much more than that with an XLSX spreadsheet.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 设置格式后，我们可以枚举列表中的每个列表，并使用`write()`方法写入每个列表。这个方法需要一些输入；第一个和第二个参数是行和列，然后是要写入的值。请注意，除了`write()`方法之外，我们还使用`write_number()`和`write_datetime()`方法。这些方法保留了XLSX电子表格中的数据类型。特别是对于`write_datetime()`方法，我们提供了`date_format`变量来适当地格式化日期对象。循环遍历所有数据后，我们成功地将数据存储在电子表格中，并保留了其值类型。但是，我们可以在XLSX电子表格中做的远不止这些。
- en: 'We use the `add_table()` method to create a table of the data we just wrote.
    To accomplish this, we must supply the function using the Excel notation to denote
    the top-left and bottom-right columns of the table. Beyond that, we can also provide
    a dictionary of objects to further configure the table. In this case, the dictionary
    only contains the header names for each column of the table:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`add_table()`方法创建刚刚写入的数据的表格。为了实现这一点，我们必须使用Excel符号来指示表格的左上角和右下角列。除此之外，我们还可以提供一个对象字典来进一步配置表格。在这种情况下，字典只包含表格每列的标题名称：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With the data worksheet complete, let's now turn our focus on the dashboard
    worksheet. We will create a graph on this dashboard, breaking down the event IDs
    by frequency. First, we calculate this frequency using a `Counter` object, as
    shown in the HTML dashboard recipe. Next, we set a title for this page by merging
    a number of columns and setting the title text and format.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 完成数据工作表后，现在让我们把焦点转向仪表板工作表。我们将在这个仪表板上创建一个图表，按频率分解事件ID。首先，我们使用`Counter`对象计算这个频率，就像HTML仪表板配方中所示的那样。接下来，我们通过合并多列并设置标题文本和格式来为这个页面设置一个标题。
- en: 'Once that is complete, we iterate through the frequency of event IDs `Counter`
    object and write them to the worksheet. We write them starting at row `100` to
    make sure the data is out of the way and not at the forefront. Once this data
    is written, we convert it into a table using the same method discussed previously:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们遍历事件ID频率`Counter`对象，并将它们写入工作表。我们从第100行开始写入，以确保数据不会占据前台。一旦数据写入，我们使用之前讨论过的相同方法将其转换为表格：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we can plot this chart we keep talking about. We use the `add_chart()`
    method and specify the type as a bar chart. Next, we use the `set_title()` and
    `set_size()` methods to properly configure this graph. All that is left is to
    use the `add_series()` method to add the data to the chart. This method takes
    a dictionary with a category and values key. In a bar chart, the categories values
    represent the *x* axis and the values represent the *y* axis. Note the use of
    Excel notation to designate the range of cells that make up the categories and
    values keys. Once the data has been selected, we use the `insert_chart()` method
    on the `worksheet` object to display it before closing the `workbook` object:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以绘制我们一直在谈论的图表。我们使用`add_chart()`方法，并将类型指定为柱状图。接下来，我们使用`set_title()`和`set_size()`方法来正确配置这个图表。剩下的就是使用`add_series()`方法将数据添加到图表中。这个方法使用一个带有类别和值键的字典。在柱状图中，类别值代表*x*轴，值代表*y*轴。请注意使用Excel符号来指定构成类别和值键的单元格范围。选择数据后，我们在`worksheet`对象上使用`insert_chart()`方法来显示它，然后关闭`workbook`对象：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When we run this script, we can review the data in an XLSX spreadsheet and
    the chart we created summarizing Event IDs:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个脚本时，我们可以在XLSX电子表格中查看数据和我们创建的总结事件ID的图表：
- en: '![](../images/00020.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00020.jpeg)'
- en: Auditing your work
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审计您的工作
- en: 'Recipe Difficulty: Easy'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 配方难度：简单
- en: 'Python Version: 2.7 or 3.5'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Python版本：2.7或3.5
- en: 'Operating System: Any'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统：任何
- en: Keeping detailed investigative notes is a key to any investigation. Without
    this, it can be difficult to put all of the pieces together or accurately recall
    findings. Sometimes, it can be helpful to have a screenshot or a series of them
    to remind you of the various steps you took during your review.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 保持详细的调查笔记是任何调查的关键。没有这些，很难将所有的线索放在一起或准确地回忆发现。有时，有一张屏幕截图或一系列屏幕截图可以帮助您回忆您在审查过程中所采取的各种步骤。
- en: Getting started
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始吧
- en: 'In order to create a recipe with cross-platform support, we have elected to
    use the `pyscreenshot` module. This module relies on a few dependencies, specifically
    the **Python Imaging Library** (**PIL**), and one or more backends. The backend
    used here is the WX GUI library. All three of these modules can be installed with
    `pip`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建具有跨平台支持的配方，我们选择使用`pyscreenshot`模块。该模块依赖于一些依赖项，特别是**Python Imaging Library**（**PIL**）和一个或多个后端。这里使用的后端是WX
    GUI库。这三个模块都可以使用`pip`安装：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To learn more about the pyscreenshot library, visit [https://pypi.python.org/pypi/pyscreenshot](https://pypi.python.org/pypi/pyscreenshot).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关pyscreenshot库的更多信息，请访问[https://pypi.python.org/pypi/pyscreenshot](https://pypi.python.org/pypi/pyscreenshot)。
- en: All other libraries used in this script are present in Python's standard library.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本中使用的所有其他库都包含在Python的标准库中。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We use the following methodology to accomplish our objective:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下方法来实现我们的目标：
- en: Process user-supplied arguments.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理用户提供的参数。
- en: Take screenshots based on user-supplied inputs.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据用户提供的输入进行截图。
- en: Save screenshots to the specified output folder.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将截图保存到指定的输出文件夹。
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First, we import the required libraries to handle argument parsing, sleeping
    the script, and taking screenshots:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入所需的库来处理参数解析、脚本休眠和截图：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This recipe''s command-line handler takes two positional arguments, `OUTPUT_DIR`
    and `INTERVAL`, which represent the desired output path and the interval between
    screenshots, respectively. The optional `total` argument can be used to impose
    an upper limit on the number of screenshots that should be taken. Note that we
    specify the type for both `INTERVAL` and `total` arguments as integers. After
    validating that the output directory exists, we pass these inputs to the `main()`
    method:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的命令行处理程序接受两个位置参数，`OUTPUT_DIR`和`INTERVAL`，分别表示所需的输出路径和截图之间的间隔。可选的`total`参数可用于对应该采取的截图数量设置上限。请注意，我们为`INTERVAL`和`total`参数指定了整数类型。在验证输出目录存在后，我们将这些输入传递给`main()`方法：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `main()` function creates an infinite `while` loop and starts incrementing
    a counter by one for each screenshot taken. Following that, the script sleeps
    for the provided interval before using the `pyscreenshot.grab()` method to capture
    a screenshot. With the screenshot captured, we create the output filename and
    use the screenshot object''s `save()` method to save it to the output location.
    That''s really it. We print a status message notifying the user about this and
    then check whether the `total` argument was provided and whether the counter is
    equal to it. If it is, the `while` loop is exited, but otherwise, it continues
    forever. As a word of caution/wisdom, if you choose not to provide a `total` limit,
    make sure to stop the script manually once you have completed your review. Otherwise,
    you may come back to an ominous blue screen and full hard drive:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数创建一个无限的`while`循环，并开始逐个递增一个计数器以获取每个截图。随后，脚本在提供的时间间隔后休眠，然后使用`pyscreenshot.grab()`方法来捕获截图。捕获了截图后，我们创建输出文件名，并使用截图对象的`save()`方法将其保存到输出位置。就是这样。我们打印一个状态消息通知用户，然后检查是否提供了`total`参数以及计数器是否等于它。如果是，退出`while`循环，否则，它将永远继续。作为一种谨慎/智慧的提醒，如果您选择不提供`total`限制，请确保在完成审阅后手动停止脚本。否则，您可能会回到一个不祥的蓝屏和满硬盘：'
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With the screenshotting script running every five seconds and storing the pictures
    in the folder of our choice, we can see the following output, as captured in the
    following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 随着截图脚本每五秒运行一次，并将图片存储在我们选择的文件夹中，我们可以看到以下输出，如下截图所示：
- en: '![](../images/00021.gif)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00021.gif)'
- en: There's more...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'This script can be further improved. We have provided a couple of recommendations
    here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本可以进一步改进。我们在这里提供了一些建议：
- en: Add video recording support to the script
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为脚本添加视频录制支持
- en: Add the functionality to automatically create archives of the screenshots with
    the date as the archive name
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自动创建带有日期作为存档名称的截图的功能
