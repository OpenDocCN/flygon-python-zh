- en: Lists and Pointer Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表和指针结构
- en: We have discussed **lists** in Python, and these are convenient and powerful.
    Normally, most of the time, we use Python's built-in list implementation to store
    any data. However, in this chapter, we will be understanding how lists work and
    will be studying list internals.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Python中讨论了**列表**，它们方便而强大。通常情况下，我们使用Python内置的列表实现来存储任何数据。然而，在本章中，我们将了解列表的工作原理，并将研究列表的内部。
- en: Python's list implementation is quite powerful and can encompass several different
    use cases. The concept of a node is very important in lists. We shall discuss
    them in this chapter and will be referring to them throughout the book. Thus,
    we suggest readers study the content of this chapter carefully.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python的列表实现非常强大，可以包含多种不同的用例。节点的概念在列表中非常重要。我们将在本章讨论它们，并在整本书中引用它们。因此，我们建议读者仔细学习本章的内容。
- en: 'The focus of this chapter will be the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点将是以下内容：
- en: Understanding pointers in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Python中的指针
- en: Understanding the concept and implementation of nodes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解节点的概念和实现
- en: Implementing singly, doubly, and circularly linked lists
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现单向、双向和循环链表。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Executing the programs based on the concepts discussed in this chapter will
    help you to better understand them. We have provided the source codes of all the
    programs and concepts in the chapter. We also provide the complete source code
    files on GitHub at the following link: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter04).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本章讨论的概念执行程序将有助于更好地理解它们。我们已经提供了本章中所有程序和概念的源代码。我们还在GitHub上提供了完整的源代码文件，链接如下：[https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter04)。
- en: We assume that you have already installed Python on your system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您已经在系统上安装了Python。
- en: Beginning with an example
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一个例子开始
- en: Let's remind you about the concept of pointers as we will be dealing with them
    in this chapter. To begin with, imagine that you have a house that you want to
    sell. Lacking time, you contact an agent to find interested buyers. So, you pick
    up your house and take it over to the agent, who will, in turn, carry the house
    to anybody who may want to buy it. Ludicrous, you say? Now imagine that you have
    a few Python functions that work with images. So, you pass high-resolution image
    data between your functions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先提醒一下指针的概念，因为我们将在本章中处理它们。首先，想象一下你有一所房子想要卖掉。由于时间不够，你联系了一个中介来寻找感兴趣的买家。所以，你拿起你的房子，把它带到中介那里，中介会把房子带给任何可能想要买它的人。你觉得这很荒谬？现在想象一下你有一些处理图像的Python函数。所以，你在这些函数之间传递高分辨率图像数据。
- en: Of course, you don't carry your house around. What you do is write the address
    of the house down on a piece of scrap paper and hand it over to the agent. The
    house remains where it is, but the note containing the directions to the house
    is passed around. You might even write it down on several pieces of paper. Each
    one is small enough to fit in your wallet, but they all point to the same house.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不会带着你的房子四处走动。你要做的是把房子的地址写在一张废纸上，递给中介。房子还在原地，但包含房子地址的纸条在传递。你甚至可以在几张纸上写下来。每张纸都足够小，可以放在你的钱包里，但它们都指向同一所房子。
- en: As it turns out, things are not very different in Python land. Those large image
    files remain in one single place in memory.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，在Python领域情况并没有太大不同。那些大型图像文件仍然在内存中的一个地方。
- en: What you do is create variables that hold the locations of those images in memory.
    These variables are small and can easily be passed around between different functions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你要做的是创建变量，保存这些图像在内存中的位置。这些变量很小，可以在不同的函数之间轻松传递。
- en: That is the big benefit of pointers—they allow you to point to a potentially
    large segment of memory with just a simple memory address.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是指针的好处——它们允许你用一个简单的内存地址指向一个潜在的大内存段。
- en: Support for pointers exists in your computer's hardware, where it is known as
    indirect addressing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你的计算机硬件中支持指针，这被称为间接寻址。
- en: 'In Python, you don''t manipulate pointers directly, unlike in some other languages,
    such as C or Pascal. This has led some people to think that pointers aren''t used
    in Python. Nothing could be further from the truth. Consider this assignment in
    the Python interactive shell:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你不会直接操作指针，不像其他一些语言，比如C或Pascal。这导致一些人认为Python中不使用指针。这是大错特错。考虑一下在Python交互式shell中的这个赋值：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We would normally say that `s` is a variable of the **set** type. That is, `s`
    is a set. However, this is not strictly true; the variable `s` is rather a reference
    (a *safe* pointer) to a set. The set constructor creates a set somewhere in memory
    and returns the memory location where that set starts. This is what gets stored
    in `s`. Python hides this complexity from us. We can safely assume that `s` is
    a set and that everything works fine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们会说`s`是**集合**类型的变量。也就是说，`s`是一个集合。然而，这并不严格正确；变量`s`实际上是一个引用（一个*安全*指针）指向一个集合。集合构造函数在内存中创建一个集合，并返回该集合开始的内存位置。这就是存储在`s`中的内容。Python隐藏了这种复杂性。我们可以安全地假设`s`是一个集合，一切都运行正常。
- en: Arrays
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An array is a sequential list of data. Being sequential means that each element
    is stored right after the previous one in memory. If your array is really big
    and you are low on memory, it could be impossible to find large enough storage
    to fit your entire array. This will lead to problems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一系列数据的顺序列表。顺序意味着每个元素都存储在前一个元素的后面。如果你的数组非常大，而且内存不足，可能无法找到足够大的存储空间来容纳整个数组。这将导致问题。
- en: Of course, the flip side of the coin is that arrays are very fast. Since each
    element follows on from the previous one in memory, there is no need to jump around
    between different memory locations. This can be a very important point to take
    into consideration when choosing between a list and an array in your own real-world
    applications.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，硬币的另一面是数组非常快速。由于每个元素在内存中紧随前一个元素，因此无需在不同的内存位置之间跳转。在选择在你自己的现实世界应用程序中列表和数组之间时，这可能是一个非常重要的考虑因素。
- en: We have already discussed arrays in [Chapter 2](c25be006-f893-4141-99c3-0d726bc31664.xhtml),
    *Python Data Types and Structures*. We looked at the array data type and discussed
    various operations that could be performed on it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第2章](c25be006-f893-4141-99c3-0d726bc31664.xhtml)中讨论了数组，*Python数据类型和结构*。我们看了数组数据类型，并讨论了可以对其执行的各种操作。
- en: Pointer structures
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针结构
- en: Contrary to arrays, pointer structures are lists of items that can be spread
    out in memory. This is because each item contains one or more links to other items
    in the structure. The types of these links are dependent on the type of structures
    we have. If we are dealing with linked lists, then we will have links to the next
    (and possibly previous) items in the structure. In the case of a tree, we have
    parent-child links as well as sibling links.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组相反，指针结构是可以在内存中分散的项目列表。这是因为每个项目都包含一个或多个指向结构中其他项目的链接。这些链接的类型取决于我们拥有的结构类型。如果我们处理的是链表，那么我们将有指向结构中下一个（可能是上一个）项目的链接。在树的情况下，我们有父子链接以及兄弟链接。
- en: There are several benefits to pointer structures. First of all, they don't require
    sequential storage space. Secondly, they can start small and grow arbitrarily
    as you add more nodes to the structure. However, this flexibility in pointers
    comes at a cost. We need additional space to store the address. For example, if
    you have a list of integers, each node is going to take up space by storing an
    integer, as well as an additional integer for storing the pointer to the next
    node.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 指针结构有几个好处。首先，它们不需要顺序存储空间。其次，它们可以从小开始，随着向结构添加更多节点而任意增长。然而，指针的这种灵活性是有代价的。我们需要额外的空间来存储地址。例如，如果你有一个整数列表，每个节点都将占用空间来存储一个整数，以及额外的整数来存储指向下一个节点的指针。
- en: Nodes
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点
- en: At the heart of lists (and several other data structures) is the concept of
    a node. Before we go any further, let us consider this idea for a while.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表（以及其他几种数据结构）的核心是节点的概念。在我们进一步讨论之前，让我们考虑一下这个想法。
- en: 'To begin with, let us consider an example. We shall create a few strings:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑一个例子。我们将创建一些字符串：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now you have three variables, each with a unique name, a type, and a value.
    At the moment, there is no way to show the relationships between these variables.
    Nodes allow us to show how these variables relate to each other. A node is a container
    of data, together with one or more links to other nodes. A link is a pointer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了三个变量，每个变量都有一个唯一的名称、类型和值。目前，没有办法显示这些变量之间的关系。节点允许我们展示这些变量之间的关系。节点是数据的容器，以及一个或多个指向其他节点的链接。链接就是指针。
- en: 'A simple type of node is one that has only a link to the next node. As we know
    about the pointers, the string is not actually stored in the node, but rather
    there is a pointer to the actual string. Consider the example in the following
    diagram, in which there are two nodes. The first node has a pointer to the string
    (**eggs**) stored in the memory and another pointer that stores the address of
    another node:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单类型的节点只有一个指向下一个节点的链接。正如我们所知道的指针，字符串实际上并没有存储在节点中，而是有一个指向实际字符串的指针。考虑下面的图表中的例子，其中有两个节点。第一个节点有一个指向存储在内存中的字符串（**eggs**）的指针，另一个指针存储着另一个节点的地址：
- en: '![](Images/0b94a5a7-7532-473e-91a9-06287979287c.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0b94a5a7-7532-473e-91a9-06287979287c.png)'
- en: Thus, the storage requirement for this simple node is two memory addresses.
    The data attributes of the nodes are pointers to the strings **eggs** and **ham**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个简单节点的存储需求是两个内存地址。节点的数据属性是指向字符串**eggs**和**ham**的指针。
- en: Finding endpoints
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找端点
- en: We have created three nodes—one containing **eggs**, one **ham**, and another
    **spam**. The **eggs** node points to the **ham** node, which in turn points to
    the **spam** node. But what does the **spam** node point to? Since this is the
    last element in the list, we need to make sure its next member has a value that
    makes this clear.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了三个节点——一个包含**eggs**，一个**ham**，另一个**spam**。**eggs**节点指向**ham**节点，**ham**节点又指向**spam**节点。但是**spam**节点指向什么呢？由于这是列表中的最后一个元素，我们需要确保它的下一个成员有一个清晰的值。
- en: 'If we make the last element point to nothing, then we make this fact clear.
    In Python, we will use the special value **None** to denote nothing. Consider
    the following diagram. Node **B** is the last element in the list, and thus it
    is pointing to **None**:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使最后一个元素指向空，那么我们就清楚地表明了这一事实。在Python中，我们将使用特殊值**None**来表示空。考虑下面的图表。节点**B**是列表中的最后一个元素，因此它指向**None**：
- en: '![](Images/938a3e9b-a0e1-4b54-bfbf-149bcfe6f360.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/938a3e9b-a0e1-4b54-bfbf-149bcfe6f360.png)'
- en: The last node has its next point pointing to **None**. As such, it is the last
    node in the chain of nodes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个节点的下一个指针指向**None**。因此，它是节点链中的最后一个节点。
- en: Node class
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点类
- en: 'Here is a simple node implementation of what we have discussed so far:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们迄今为止讨论的一个简单节点实现：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The **Next** pointer is initialized to `None`, meaning that unless you change
    the value of **Next**, the node is going to be an endpoint. This is a good idea,
    so that we do not forget to terminate the list properly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**Next**指针初始化为`None`，这意味着除非你改变**Next**的值，否则节点将成为一个端点。这是一个很好的主意，这样我们就不会忘记正确终止列表。'
- en: You can add other things to the node class as you see fit. Just make sure that
    you keep in mind the distinction between nodes and data. If your node is going
    to contain customer data, then create a `Customer` class and put all the data
    there.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要向节点类添加其他内容。只要记住节点和数据之间的区别。如果你的节点将包含客户数据，那么创建一个`Customer`类，并把所有数据放在那里。
- en: 'One thing you may want to do is implement the `_str_ ` method so that it calls
    the `_str_` method of the contained object is called when the node object is passed
    to print:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想要做的一件事是实现`_str_`方法，以便在将节点对象传递给打印时调用所包含对象的`_str_`方法：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Other node types
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他节点类型
- en: As we have already discussed a node that has a pointer to the next node to link
    the data items, however, it is probably the simplest type of node. Further, depending
    on our requirements, we can create a number of other types of nodes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，一个节点具有指向下一个节点的指针来链接数据项，但它可能是最简单的节点类型。此外，根据我们的需求，我们可以创建许多其他类型的节点。
- en: 'Sometimes we want to go from node **A** to node **B**, but at the same time
    we may need to go from node **B** to node **A**. In that case, we add a **Previous**
    pointer in addition to the **Next** pointer:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想从节点**A**到节点**B**，但同时我们可能需要从节点**B**到节点**A**。在这种情况下，我们除了**Next**指针之外还添加了**Previous**指针：
- en: '![](Images/70762d9f-ef9c-4282-bbc4-e7d6dca8689b.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/70762d9f-ef9c-4282-bbc4-e7d6dca8689b.png)'
- en: As you can see from the preceding diagram, we have created the**Previous** pointer
    in addition to the data and the **Next** pointer. It is also important to note
    that the **N****ext** pointer to **B** is **None**, and the **Previous** pointer
    in node **A** is also **None**—that is to indicate that we have reached the boundary
    of our list at both endpoints. The first node **A**'s previous pointer points
    to **None** since it has no predecessor, just as the last item **B**'s **Next**
    pointer points to **None** because it has no successor node.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图可以看出，我们除了数据和**Next**指针之外，还创建了**Previous**指针。还需要注意的是，**B**的**Next**指针是**None**，而节点**A**的**Previous**指针也是**None**，这表示我们已经到达了列表的边界。第一个节点**A**的前指针指向**None**，因为它没有前驱，就像最后一个项目**B**的**Next**指针指向**None**一样，因为它没有后继节点。
- en: Introducing lists
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入列表
- en: The list is an important and popular data structure. There are three kinds of
    the list—singly linked list, doubly linked list, and circular linked list. We
    will discuss these data structures in more detail in this chapter. We will also
    be discussing various important operations such as the `append` operation, `delete`
    operation, and the `traversing` and `searching` operations that can be performed
    on these lists in subsequent subsections.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是一个重要且流行的数据结构。列表有三种类型——单链表、双链表和循环链表。我们将在本章更详细地讨论这些数据结构。我们还将在接下来的小节中讨论各种重要操作，如`append`操作、`delete`操作以及可以在这些列表上执行的`traversing`和`searching`操作。
- en: Singly linked lists
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单链表
- en: A singly linked list is a list with only one pointer between two successive
    nodes. It can only be traversed in a single direction; that is, you can go from
    the first node in the list to the last node, but you cannot move from the last
    node to the first node.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 单链表是一种只有两个连续节点之间的指针的列表。它只能以单个方向遍历；也就是说，您可以从列表中的第一个节点到最后一个节点，但不能从最后一个节点移动到第一个节点。
- en: 'We can actually use the node class that we created earlier to implement a very
    simple singly linked list. For example, we create three nodes `n1`, `n2`, and
    `n3` that stores three strings:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以使用之前创建的节点类来实现一个非常简单的单链表。例如，我们创建三个存储三个字符串的节点`n1`、`n2`和`n3`：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we link the nodes together so that they form a chain:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将节点链接在一起，形成一个链：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To traverse the list, you could do something like the following. We start by
    setting the `current` variable to the first item in the list, and then we traverse
    the whole list through a loop as shown in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历列表，您可以像下面这样做。我们首先将`current`变量设置为列表中的第一个项目，然后通过循环遍历整个列表，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the loop, we print out the current element after which we set `current` to
    point to the next element in the list. We keep doing this until we have reached
    the end of the list.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，我们打印出当前元素，然后将`current`设置为指向列表中的下一个元素。我们一直这样做，直到我们到达列表的末尾。
- en: 'There are, however, several problems with this simplistic list implementation:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种简单的列表实现存在几个问题：
- en: It requires too much manual work by the programmer
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员需要做太多的手动工作
- en: It is too error prone (this is a consequence of the first point)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这太容易出错了（这是第一点的结果）
- en: Too much of the inner workings of the list is exposed to the programmer
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表的内部工作过于暴露给程序员
- en: We are going to address all these issues in the following sections.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中解决所有这些问题。
- en: Singly linked list class
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单链表类
- en: 'A list is a separate concept from a node. We start by creating a very simple
    class to hold our list. We start with a constructor that holds a reference to
    the very first node in the list (that is `tail` in the following code). Since
    this list is initially empty, we will start by setting this reference to `None`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是一个与节点不同的概念。我们首先创建一个非常简单的类来保存我们的列表。我们从一个构造函数开始，它保存对列表中第一个节点的引用（在下面的代码中是`tail`）。由于这个列表最初是空的，我们将首先将这个引用设置为`None`：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The append operation
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追加操作
- en: The first operation that we need to perform is to append items to the list.
    This operation is sometimes called an insert operation. Here we get a chance to
    hide away the `Node` class. The user of our list class should really never have
    to interact with `Node` objects. These are purely for internal use.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行的第一个操作是向列表追加项目。这个操作有时被称为插入操作。在这里，我们有机会隐藏`Node`类。我们的列表类的用户实际上不应该与`Node`对象交互。这些纯粹是内部使用的。
- en: 'The first shot at an `append()` method may look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试`append()`方法可能如下所示：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We encapsulate data in a node so that it has the next pointer attribute. From
    here, we check if there are any existing nodes in the list (that is, whether `self.tail`
    points to a `Node` or not). If there is `None`, we make the new node the first
    node of the list; otherwise, we find the insertion point by traversing the list
    to the last node, updating the next pointer of the last node to the new node.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们封装数据在一个节点中，以便它具有下一个指针属性。从这里开始，我们检查列表中是否存在任何现有节点（即`self.tail`是否指向一个`Node`）。如果是`None`，我们将新节点设置为列表的第一个节点；否则，我们通过遍历列表找到插入点，将最后一个节点的下一个指针更新为新节点。
- en: 'Consider the following example code to append three nodes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例代码以追加三个节点：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'List traversal will work as we discussed before. You will get the first element
    of the list from the list itself, and then traverse the list through the `next` pointer:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表遍历将按照我们之前讨论的方式进行。您将从列表本身获取列表的第一个元素，然后通过`next`指针遍历列表：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A faster append operation
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更快的追加操作
- en: 'There is a big problem with the append method in the previous section: it has
    to traverse the entire list to find the insertion point. This may not be a problem
    when there are just a few items in the list, but it will be a big problem when
    the list is long, as we would need to traverse the whole list to add an item every
    time. Each append will be slightly slower than the previous one. The current implementation
    for the append operation is slowed down by  `O(n)`, which is not desirable in
    the case of a long list.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，追加方法存在一个大问题：它必须遍历整个列表以找到插入点。当列表中只有一些项目时，这可能不是问题，但当列表很长时，这将是一个大问题，因为我们需要每次遍历整个列表来添加一个项目。每次追加都会比上一次略慢。追加操作的当前实现速度降低了`O(n)`，这在长列表的情况下是不可取的。
- en: 'To fix this, we store not only a reference to the first node in the list but
    also a reference to the last node. That way, we can quickly append a new node
    at the end of the list. The worst-case running time of the append operation is
    now reduced from `O(n)` to `O(1)`. All we have to do is make sure the previous
    last node points to the new node that is about to be appended to the list. Here
    is our updated code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们不仅存储了对列表中第一个节点的引用，还存储了对最后一个节点的引用。这样，我们可以快速地在列表的末尾追加一个新节点。追加操作的最坏情况运行时间现在从`O(n)`降低到了`O(1)`。我们所要做的就是确保前一个最后一个节点指向即将追加到列表中的新节点。以下是我们更新后的代码：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Take note of the convention being used. The point at which we append new nodes
    is through `self.head`. The `self.tail` variable points to the first node in the
    list.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意正在使用的约定。我们追加新节点的位置是通过`self.head`。`self.tail`变量指向列表中的第一个节点。
- en: Getting the size of the list
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取列表的大小
- en: 'We would like to be able to get the size of the list by counting the number
    of nodes. One way we could do this is by traversing the entire list and increasing
    a counter as we go along:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够通过计算节点的数量来获取列表的大小。我们可以通过遍历整个列表并在遍历过程中增加一个计数器来实现这一点：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This works fine. However, list traversal is potentially an expensive operation
    that we should avoid wherever we can. So instead, we shall opt for another rewrite
    of the method. We add a size member to the `SinglyLinkedList` class, initializing
    it to `0` in the constructor. Then we increment the size by one in the append
    method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好用。但是，列表遍历可能是一个昂贵的操作，我们应该尽量避免。因此，我们将选择另一种重写方法。我们在`SinglyLinkedList`类中添加一个size成员，在构造函数中将其初始化为`0`。然后我们在追加方法中将size增加一：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Because we are now only reading the size attribute of the node object, and not
    using a loop to count the number of nodes in the list, we reduce the worst-case
    running time from `O(n)` to `O(1)`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们现在只是读取节点对象的size属性，而不是使用循环来计算列表中节点的数量，所以我们将最坏情况的运行时间从`O(n)`降低到了`O(1)`。
- en: Improving list traversal
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进列表遍历
- en: 'If you will notice in the earlier of the list traversal, where we are exposing
    the node class to the client/user. However, it is desirable that the client node
    should not interact with the node object.  We need to use `node.data` to get the
    contents of the node and `node.next` to get the next node. We can access the data
    by creating a method that returns a generator. It looks as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到，在列表遍历的早期，我们向客户/用户公开了节点类。但是，希望客户端节点不要与节点对象进行交互。我们需要使用`node.data`来获取节点的内容，使用`node.next`来获取下一个节点。我们可以通过创建一个返回生成器的方法来访问数据。如下所示：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, list traversal is much simpler and looks a lot better as well. We can
    completely ignore the fact that there is anything called a node outside of the
    list:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，列表遍历变得简单得多，看起来也好得多。我们可以完全忽略列表之外有一个叫做节点的东西：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that since the `iter()` method yields the data member of the node, our
    client code doesn't need to worry about that at all.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`iter()`方法产生节点的数据成员，我们的客户端代码根本不需要担心这一点。
- en: Deleting nodes
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除节点
- en: Another common operation that you will perform on a list is to delete nodes.
    This may seem simple, but we first have to decide how to select a node for deletion.
    Is it going to be determined by the index number or by the data the node contains?
    Here, we will choose to delete a node depending on the data it contains.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在列表上执行的另一个常见操作是删除节点。这可能看起来很简单，但我们首先必须决定如何选择要删除的节点。它是由索引号还是由节点包含的数据来确定的？在这里，我们将选择根据节点包含的数据来删除节点。
- en: 'The following is a diagram of a special case considered when deleting a node
    from the list:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在从列表中删除节点时考虑的特殊情况的图示：
- en: '![](Images/9a448606-c04c-4256-babb-acae72ff10b6.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9a448606-c04c-4256-babb-acae72ff10b6.png)'
- en: When we want to delete a node that is between two other nodes, all we have to
    do is we make the previous node point to the successor of its next node that is
    to be deleted. That is, we simply cut the node to be deleted out of the chain
    and point directly to the next node as shown in the preceding diagram.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要删除两个节点之间的一个节点时，我们所要做的就是使前一个节点指向其下一个要删除的节点的后继节点。也就是说，我们只需将要删除的节点从链表中切断，并直接指向下一个节点，如前面的图所示。
- en: 'Here is what the implementation of the `delete()` method may look like:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete()`方法的实现可能如下所示：'
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `delete` operation to remove a node has the time complexity `O(n).`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 删除节点的`delete`操作的时间复杂度为`O(n)`。
- en: List search
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表搜索
- en: 'We may also need a way to check whether a list contains an item. This method
    is fairly easy to implement thanks to the `iter()` method we previously wrote.
    Each pass of the loop compares the current data to the data being searched. If
    a match is found, `True` is returned, or else `False` is returned:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还需要一种方法来检查列表是否包含某个项目。由于我们之前编写的`iter()`方法，这种方法非常容易实现。循环的每次通过将当前数据与正在搜索的数据进行比较。如果找到匹配项，则返回`True`，否则返回`False`：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Clearing a list
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清除列表
- en: 'We may need to clear a list quickly; there is a very simple way to do it. We
    can clear a list by simply clearing the pointer head and tail by setting them
    to `None`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要快速清除列表；有一种非常简单的方法可以做到。我们可以通过简单地将指针头和尾清除为`None`来清除列表：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Doubly linked lists
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表
- en: We have discussed the singly linked list and the important operation that can
    be performed on it. Now, we will be focusing on the topic of a doubly linked list
    in this section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了单链表以及可以在其上执行的重要操作。现在，我们将在本节中专注于双向链表的主题。
- en: 'A doubly linked list is quite similar to the singly linked list in the sense
    that we use the same fundamental concept of string nodes together, as we did in
    a singly linked list. The only difference between a singly linked list and a doubly
    linked list is that in a singly linked list, there is only one link between each
    successive node, whereas, in a doubly linked list, we have two pointers—a pointer
    to the next node and a pointer to the previous node. See the following diagram
    of a *node*; there is a pointer to the next node and the previous node, which
    are set to `None` as there is no node attached to this node. Consider the following
    diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表与单链表非常相似，因为我们使用了将字符串节点串在一起的相同基本概念，就像在单链表中所做的那样。单链表和双链表之间唯一的区别在于，在单链表中，每个连续节点之间只有一个链接，而在双链表中，我们有两个指针——一个指向下一个节点，一个指向前一个节点。请参考以下*节点*的图表；有一个指向下一个节点和前一个节点的指针，它们设置为`None`，因为没有节点连接到这个节点。考虑以下图表：
- en: '![](Images/9f1ca24a-6fc0-4c9e-9668-ca3fa2df2ee0.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9f1ca24a-6fc0-4c9e-9668-ca3fa2df2ee0.png)'
- en: A node in a singly linked list can only determine the next node associated with
    it. However, there is no way or link to go back from this referenced node. The
    direction of flow is only one way.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 单链表中的节点只能确定与其关联的下一个节点。然而，没有办法或链接可以从这个引用节点返回。流动的方向只有一种。
- en: 'In a doubly linked list, we solve this issue and include the ability not only
    to reference the next node but also to reference the previous node. Consider the
    following example diagram to understand the nature of the linkages between two
    successive nodes. Here, node **A** is referencing node **B**; in addition, there
    is also a link back to node **A**:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在双向链表中，我们解决了这个问题，并且不仅可以引用下一个节点，还可以引用前一个节点。考虑以下示例图表，以了解两个连续节点之间链接的性质。这里，节点**A**引用节点**B**；此外，还有一个链接返回到节点**A**：
- en: '![](Images/be75f67d-d6ff-420d-b5e0-1cd2ca679be2.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/be75f67d-d6ff-420d-b5e0-1cd2ca679be2.png)'
- en: With the existence of two pointers that point to the next and previous nodes,
    doubly linked lists become equipped with certain capabilities.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在指向下一个和前一个节点的两个指针，双向链表具有某些功能。
- en: Doubly linked lists can be traversed in any direction. A node in a doubly linked
    list can be easily referred to its previous node whenever required without having
    a variable to keep track of that node. However, in a singly linked list, it may
    be difficult to move back to the start or beginning of the list in order to make
    some changes at the start of the list, which is very easy now in the case of a
    doubly linked list.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表可以在任何方向进行遍历。在双向链表中，可以很容易地引用节点的前一个节点，而无需使用变量来跟踪该节点。然而，在单链表中，可能难以返回到列表的开始或开头，以便在列表的开头进行一些更改，而在双向链表的情况下现在非常容易。
- en: A doubly linked list node
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表节点
- en: 'The Python code to create a doubly linked list node includes its initializing
    methods, the `prev` pointer, the `next` pointer, and the `data` instance variables.
    When a node is newly created, all these variables default to `None`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建双向链表节点的Python代码包括其初始化方法、`prev`指针、`next`指针和`data`实例变量。当新建一个节点时，所有这些变量默认为`None`：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `prev` variable has a reference to the previous node, while the `next` variable
    keeps the reference to the next node, and the `data` variable stores the data.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev`变量引用前一个节点，而`next`变量保留对下一个节点的引用，`data`变量存储数据。'
- en: Doubly linked list class
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表类
- en: 'The doubly linked list class captures the data on which our functions will
    be operating. For the `size` method, we set the count instance variable to `0`;
    it can be used to keep track of the number of items in the linked list. `head` and `tail` will
    point to the head and tail of the list when we begin to insert nodes into the
    list. Consider the following Python code for creating a class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表类捕获了我们的函数将要操作的数据。对于`size`方法，我们将计数实例变量设置为`0`；它可以用来跟踪链表中的项目数量。当我们开始向列表中插入节点时，`head`和`tail`将指向列表的头部和尾部。考虑以下用于创建类的Python代码：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We adopt a new convention where `self.head` points to the beginner node of the
    list and `self.tail` points to the latest node added to the list. This is contrary
    to the convention we used in the singly linked list. There are no fixed rules
    as to the naming of the head and tail node pointers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采用了一个新的约定，其中`self.head`指向列表的起始节点，而`self.tail`指向添加到列表中的最新节点。这与我们在单链表中使用的约定相反。关于头部和尾部节点指针的命名没有固定的规则。
- en: Doubly linked lists also require functionalities that return the size of the
    list, insert items into the list, and also delete nodes from the list. We will
    be discussing and providing important functionalities and code on the doubly linked
    list in the following subsections. Let's start with the append operation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 双链表还需要返回列表大小、向列表中插入项目以及从列表中删除节点的功能。我们将在以下子部分中讨论并提供关于双链表的重要功能和代码。让我们从附加操作开始。
- en: Append operation
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加操作
- en: 'The `append` operation is used to add an element at the end of a list. It is
    important to check whether the `head` of the list is `None`. If it is `None`,
    it means that the list is empty, or else the list has some nodes and a new node
    will be appended to the list. If a new node is to be added to the empty list,
    it should have the `head` pointing to the newly created node, and the tail of
    the list should also point at this newly created node through `head`. By the end
    of these series of steps, the head and tail will now be pointing to the same node.
    The following diagram illustrates the `head` and `tail` pointers of the doubly
    linked list when a new node is added to an empty list:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`操作用于在列表的末尾添加元素。重要的是要检查列表的`head`是否为`None`。如果是`None`，则表示列表为空，否则列表有一些节点，并且将向列表添加一个新节点。如果要向空列表添加新节点，则应将`head`指向新创建的节点，并且列表的尾部也应通过`head`指向该新创建的节点。经过这一系列步骤，头部和尾部现在将指向同一个节点。以下图示了当向空列表添加新节点时，双链表的`head`和`tail`指针：'
- en: '![](Images/39e8e53b-5a79-4ba8-912d-6fe36f8871d5.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/39e8e53b-5a79-4ba8-912d-6fe36f8871d5.png)'
- en: 'The following code is used to append an item to the doubly linked list:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于将项目附加到双链表：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `If` part of the preceding program is for adding a node to the empty node;
    the `else` part of the preceding program will be executed if the list is not empty.
    If the new node is to be added to a list, the new node''s previous variable is
    to be set to the tail of the list:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序的`If`部分用于将节点添加到空节点；如果列表不为空，则将执行上述程序的`else`部分。如果要将新节点添加到列表中，则新节点的前一个变量应设置为列表的尾部：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The tail''s next pointer (or variable) has to be set to the new node:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尾部的下一个指针（或变量）必须设置为新节点：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Lastly, we update the tail pointer to point to the new node:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更新尾部指针以指向新节点：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since an append operation increases the number of nodes by one, we increase
    the counter by one:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于附加操作将节点数增加一，因此我们将计数器增加一：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A visual representation of the append operation to an existing list is shown
    in the following diagram:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了向现有列表附加操作的可视表示：
- en: '![](Images/65d93f4e-efe7-408f-99c5-e7817f1262f5.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/65d93f4e-efe7-408f-99c5-e7817f1262f5.png)'
- en: The delete operation
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除操作
- en: The deletion operation is easier in the doubly linked list compared to the singly
    linked list.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与单链表相比，双链表中的删除操作更容易。
- en: Unlike a singly linked list, where we needed to keep track of the previously
    encountered node any time we traverse the whole length of the list, the doubly
    linked list avoids that whole step. This is made possible by the use of the previous
    pointer.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与单链表不同，我们需要在遍历整个列表的整个长度时始终跟踪先前遇到的节点，双链表避免了整个步骤。这是通过使用前一个指针实现的。
- en: 'The `delete` operation in a doubly linked list can encounter the following
    four scenarios:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在双链表中，`delete`操作可能会遇到以下四种情况：
- en: The search item to be deleted is not found in the list
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未找到要删除的搜索项在列表中
- en: The search item to be deleted is located at the start of the list
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除的搜索项位于列表的开头
- en: The search item to be deleted is found at the tail end of the list
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除的搜索项位于列表的末尾
- en: The search item to be deleted is located in the middle of the list
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除的搜索项位于列表的中间
- en: 'The node to be deleted is identified by matching the data instance variable
    with the data that is passed to the method. If the data matches the data variable
    of a node, that matching node will be deleted. Following is the complete code
    to delete a node from the doubly linked list. We''ll discuss each part of this
    code step by step:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除的节点是通过将数据实例变量与传递给方法的数据进行匹配来识别的。如果数据与节点的数据变量匹配，则将删除该匹配的节点。以下是从双链表中删除节点的完整代码。我们将逐步讨论此代码的每个部分：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Initially, we create a `node_deleted` variable to denote the deleted node in
    the list and this is initialized to `False`.  The `node_deleted` variable is set
    to `True` if a matching node is found and subsequently removed. In the delete
    method, the `current` variable is initially set to the `head` of the list (that
    is, it points to the `self.head` of the list). See the following code fragment:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们创建一个`node_deleted`变量来表示列表中被删除的节点，并将其初始化为`False`。如果找到匹配的节点并随后删除，则将`node_deleted`变量设置为`True`。在删除方法中，`current`变量最初设置为列表的`head`（即指向列表的`self.head`）。请参阅以下代码片段：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Next, we use a set of `if...else` statements to search various parts of the
    list to find out the node with the specified data that is to be deleted.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用一组`if...else`语句来搜索列表的各个部分，找出具有指定数据的节点，该节点将被删除。
- en: 'First of all,  we search for the data to be deleted at the `head` node and if
    the data is matched at the `head` node, this node would be deleted. Since `current`
    is pointing at `head`, if `current` is `None`, it means that the list is empty
    and has no nodes to find the node to be deleted. The following is its code fragment:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`head`节点处搜索要删除的数据，如果在`head`节点处匹配数据，则将删除该节点。由于`current`指向`head`，如果`current`为`None`，则表示列表为空，没有节点可以找到要删除的节点。以下是其代码片段：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, if `current` (which now points to head) contains the data being searched
    for, it means that we found the data to be deleted at the `head` node, then `self.head`
    is marked to point to the `current` node. Since there is no node behind `head`
    now, `self.head.prev` is set to `None`. Consider the following code snippet for
    this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果`current`（现在指向头部）包含正在搜索的数据，这意味着我们在`head`节点找到了要删除的数据，那么`self.head`被标记为指向`current`节点。由于现在`head`后面没有节点了，`self.head.prev`被设置为`None`。考虑以下代码片段：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Similarly, if the node that is to be deleted is found at the `tail` end of
    the list, we delete the last node by setting its previous node pointing to `None`.
    This is the third possible scenario in the `delete` operation in a doubly linked
    list that searches for the node to be deleted might be found at the end of the
    list. The `self.tail` is set to point to `self.tail.prev`, and `self.tail.next`
    is set to `None` as there is no node afterward. Consider the following code fragment
    for this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果要删除的节点位于列表的“尾部”，我们通过将其前一个节点指向“None”来删除最后一个节点。这是双向链表中“删除”操作的第三种可能情况，搜索要删除的节点可能在列表末尾找到。`self.tail`被设置为指向`self.tail.prev`，`self.tail.next`被设置为`None`，因为后面没有节点了。考虑以下代码片段：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Lastly, we search for the node to be deleted by looping through the whole list
    of the nodes. If the data that is to be deleted is matched with a node, that node
    will be deleted. To delete a node, we make the previous node of the `current` node
    to point to the current''s next node using the code  `current.prev.next = current.next`.
    After that step, we make the current''s next node to point to the previous node
    of the `current` node using `current.next.prev = current.prev`. Consider the following
    code snippet for this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过循环整个节点列表来搜索要删除的节点。如果要删除的数据与节点匹配，则删除该节点。要删除节点，我们使用代码`current.prev.next
    = current.next`使`current`节点的前一个节点指向当前节点的下一个节点。在那之后，我们使用`current.next.prev = current.prev`使`current`节点的下一个节点指向`current`节点的前一个节点。考虑以下代码片段：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To better understand the concept of a delete operation in a doubly linked list,
    consider the following example diagram. In the following diagram, there are three
    nodes, **A**, **B**, and **C**. To delete node **B** in the middle of the list,
    we will essentially make **A** point to node **C** as its next node, while making
    **C** point to **A** as its previous node:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解双向链表中的删除操作的概念，请考虑以下示例图。在下图中，有三个节点，**A**，**B**和**C**。要删除列表中间的节点**B**，我们实质上会使**A**指向**C**作为其下一个节点，同时使**C**指向**A**作为其前一个节点：
- en: '![](Images/53dc9efd-2d80-4221-a5d9-deb25a9d0999.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/53dc9efd-2d80-4221-a5d9-deb25a9d0999.png)'
- en: 'After such an operation, we end up with the following list:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 进行此操作后，我们得到以下列表：
- en: '![](Images/9f1a8569-6ab4-4de8-b252-429145333607.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9f1a8569-6ab4-4de8-b252-429145333607.png)'
- en: 'Finally, the `node_delete` variable is then checked to find out if a node is
    actually deleted or not. If any node is deleted then we decrease the count variable
    by `1`, and this keeps track of the total number of nodes in the list. See the
    following code fragment that decrements the count variable by `1` in case any
    node is deleted:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，检查`node_delete`变量以确定是否实际删除了节点。如果删除了任何节点，则将计数变量减少`1`，这可以跟踪列表中节点的总数。以下代码片段减少了删除任何节点时的计数变量`1`：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: List search
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表搜索
- en: 'The search for an item in a doubly linked list is similar to the way we did
    it in the singly linked list. We use the `iter()` method to check the data in
    all the nodes. As we run a loop through all the data in the list, each node is
    matched with the data passed in the `contain` method. If we find the item in the
    list, `True` is returned, denoting that the item is found, otherwise `False` is
    returned, which means the item was not found in the list. The Python code for
    this is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在双向链表中搜索项目与在单向链表中的方式类似。我们使用`iter()`方法来检查所有节点中的数据。当我们遍历列表中的所有数据时，每个节点都与`contain`方法中传递的数据进行匹配。如果我们在列表中找到项目，则返回`True`，表示找到了该项目，否则返回`False`，这意味着在列表中未找到该项目。其Python代码如下：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The append operation in a doubly linked list has running time complexity `O(1)`
    and the delete operation has the complexity  `O(n)`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表中的追加操作具有运行时间复杂度`O(1)`，删除操作具有复杂度`O(n)`。
- en: Circular lists
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环列表
- en: 'A circular linked list is a special case of a linked list. In a circular linked
    list, the endpoints are connected to each other. It means that the last node in
    the list points back to the first node. In other words, we can say that in circular
    linked lists all the nodes point to the next node (and the previous node in the
    case of a doubly linked list) and there is no end node, thus no node will point
    to `Null`. Circular lists can be based on both singly and doubly linked lists.
    In the case of a doubly linked circular list, the first node points to the last
    node and the last node points back to the first node. Consider the following diagram
    for the circular linked list, based on a singly linked list where the last node
    **C** is again connected to the first node **A**, thus making a circular list:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表是链表的特殊情况。在循环链表中，端点彼此相连。这意味着列表中的最后一个节点指向第一个节点。换句话说，我们可以说在循环链表中，所有节点都指向下一个节点（在双向链表的情况下还指向前一个节点），没有结束节点，因此没有节点将指向“Null”。循环列表可以基于单向链表和双向链表。在双向循环链表的情况下，第一个节点指向最后一个节点，最后一个节点指向第一个节点。考虑以下基于单向链表的循环链表的图示，其中最后一个节点**C**再次连接到第一个节点**A**，从而形成循环列表：
- en: '![](Images/5226b232-2fca-4ddf-a27f-680cc8883b9a.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5226b232-2fca-4ddf-a27f-680cc8883b9a.png)'
- en: 'The following diagram shows the concept of the circular linked list based on
    a doubly linked list where the last node **C** is again connected to the first
    node **A** through the `next` pointer. The node **A** is also connected to the
    node **C** through, `previous` pointer, thus making a circular list:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了基于双向链表的循环链表概念，其中最后一个节点**C**通过`next`指针再次连接到第一个节点**A**。节点**A**也通过`previous`指针连接到节点**C**，从而形成一个循环列表：
- en: '![](Images/3dd10ee2-a107-4e9c-b869-0cd26cfa9414.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3dd10ee2-a107-4e9c-b869-0cd26cfa9414.png)'
- en: Here, we are going to look at an implementation of a singly linked circular
    list. It should be straightforward to implement a doubly linked circular list
    once we understand the basic concepts.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看一个单链表循环列表的实现。一旦我们理解了基本概念，实现双链表循环列表应该是直截了当的。
- en: We can reuse the node class that we created in the subsection—singly linked
    lists. As a matter of fact, we can reuse most parts of the `SinglyLinkedList`
    class as well. So we are going to focus on the methods where the circular list
    implementation differs from the normal singly linked list.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用我们在子节中创建的节点类——单链表。事实上，我们也可以重用大部分`SinglyLinkedList`类的部分。因此，我们将专注于循环列表实现与普通单链表不同的方法。
- en: Appending elements
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追加元素
- en: 'To append an element to the circular list in a singly linked list, we have
    to just include a new functionality so that the newly added or appended node points
    back to the `tail` node. This is demonstrated in the following code. There is
    one extra line as compared to the singly linked list implementation, which is
    shown in bold font:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要在单链表循环列表中追加一个元素，我们只需包含一个新功能，使新添加或追加的节点指向`tail`节点。这在以下代码中得到了演示。与单链表实现相比，多了一行额外的代码，如粗体所示：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Deleting an element in a circular list
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在循环列表中删除元素
- en: 'To delete a node in a circular list, it looks like we can do it similarly to
    how we did in the case of the append operation—simply make sure that `head` points
    to the `tail`. There is just a single line that needs to change in the delete
    operation. It is only when we remove the `tail` node that we need to make sure
    that the `head` node is updated to point to the new tail node. This would give
    us the following implementation (the bold font code line is an addition to the
    delete operation implementation in the singly linked list):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除循环列表中的一个节点，看起来我们可以类似于在追加操作中所做的方式来做。只需确保`head`指向`tail`。在删除操作中只有一行需要更改。只有当我们删除`tail`节点时，我们需要确保`head`节点被更新为指向新的尾节点。这将给我们以下实现（粗体字代码行是单链表中删除操作实现的一个补充）：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: However, there is a serious problem with this code. In the case of a circular
    list, we cannot loop until `current` becomes `None`, since the current node will
    never point to the `None` in case of circular linked lists. If you delete an existing
    node, you won't see this, but try deleting a nonexistent node and you will get
    stuck in an indefinite loop.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码存在一个严重的问题。在循环列表的情况下，我们不能循环直到`current`变成`None`，因为在循环链表的情况下，当前节点永远不会指向`None`。如果删除一个现有节点，你不会看到这一点，但是尝试删除一个不存在的节点，你将陷入无限循环。
- en: 'We thus need to find a different way to control the `while` loop. We cannot
    check whether `current` has reached `head`, because then it will never check the
    last node. But we could use `prev`, since it lags behind `current` by one node.
    However, there is a special case. The very first loop iteration, `current`, and
    `prev`, will point to the same node, namely the tail node. We want to ensure that
    the loop runs here since we need to take the one node list into consideration.
    The updated delete method now looks as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要找到一种不同的方法来控制`while`循环。我们不能检查`current`是否已经到达`head`，因为那样它永远不会检查最后一个节点。但我们可以使用`prev`，因为它比`current`落后一个节点。然而，有一个特殊情况。在第一个循环迭代中，`current`和`prev`将指向相同的节点，即尾节点。我们希望确保循环在这里运行，因为我们需要考虑单节点列表。更新后的删除方法现在如下所示：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Iterating through a circular list
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历循环列表
- en: 'To traverse the circular linked list, it is very convenient as we don''t need
    to look for the starting point. We can start anywhere, and we just need to carefully
    stop traversing when we reach the same node again. We can use the same `iter()`
    method, which we discussed at the start of this chapter. It should work for our
    circular list; the only difference is that we have to mention an exit condition
    when we are iterating through the circular list, or otherwise the program will
    get stuck in a loop and it will run indefinitely. We can make an exit condition
    by using a counter variable. Consider the following example code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历循环链表非常方便，因为我们不需要寻找起始点。我们可以从任何地方开始，只需要在再次到达相同节点时小心停止遍历。我们可以使用我们在本章开头讨论过的`iter()`方法。它应该适用于我们的循环列表；唯一的区别是在遍历循环列表时，我们必须提及一个退出条件，否则程序将陷入循环并无限运行。我们可以通过使用一个计数变量来创建一个退出条件。考虑以下示例代码：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Once we have printed out 1,000 elements, we break out of the loop.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们打印出1,000个元素，我们就会跳出循环。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at linked lists. We studied the concepts that underlie
    lists, such as nodes and pointers to other nodes. We implemented the major operations
    that occur in these types of lists and saw how the worst-case running times compare.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了链表。我们学习了列表的基本概念，如节点和指向其他节点的指针。我们实现了这些类型列表中发生的主要操作，并看到了最坏情况的运行时间是如何比较的。
- en: In the next chapter, we are going to look at two other data structures that
    are usually implemented using lists—stacks and queues.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看两种通常使用列表实现的其他数据结构——栈和队列。
