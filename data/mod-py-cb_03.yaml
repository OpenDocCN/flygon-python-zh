- en: Chapter 3. Function Definitions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。函数定义
- en: 'In this chapter, we''ll look at the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下以下配方：
- en: Designing functions with optional parameters
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计带有可选参数的函数
- en: Using super flexible keyword parameters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用超灵活的关键字参数
- en: Forcing keyword-only arguments with the * separator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*分隔符强制关键字参数
- en: Writing explicit types on function parameters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数参数上写明确的类型
- en: Picking an order for parameters based on partial functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于部分函数选择参数顺序
- en: Writing clear documentation strings with RST markup
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RST标记编写清晰的文档字符串
- en: Designing recursive functions around Python's stack limits
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕Python的堆栈限制设计递归函数
- en: Writing reusable scripts with the script library switch
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚本库开关编写可重用脚本
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Function definitions are a way to decompose a large problem into smaller problems.
    Mathematicians have been doing this for centuries. It's also a way to package
    our Python programming into intellectually manageable chunks.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义是将一个大问题分解为较小问题的一种方式。数学家们已经做了几个世纪了。这也是将我们的Python编程打包成智力可管理的块的一种方式。
- en: We'll look at a number of function definition techniques in these recipes. This
    will include ways to handle flexible parameters and ways to organize the parameters
    based on some higher-level design principles.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些配方中，我们将看一些函数定义技术。这将包括处理灵活参数的方法以及根据一些更高级别的设计原则组织参数的方法。
- en: We'll also look at the Python 3.5 typing module and how we can create more formal
    annotations for our functions. We can start down the road toward using the `mypy`
    project for making more formal assertions about the data types in use.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看一下Python 3.5的typing模块以及如何为我们的函数创建更正式的注释。我们可以开始使用`mypy`项目，以对数据类型的使用进行更正式的断言。
- en: Designing functions with optional parameters
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计带有可选参数的函数
- en: When we define a function, we often have a need for optional parameters. This
    allows us to write functions which are more flexible, and can be used in more
    situations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个函数时，通常需要可选参数。这使我们能够编写更灵活的函数，并且可以在更多情况下使用。
- en: We can also think of this as a way to create a family of closely-related functions,
    each with a slightly different collection of parameters – called the **signature**
    – but all sharing the same simple name. The idea of many functions sharing the
    same name can be a bit confusing. Therefore, we'll focus more on the idea of optional
    parameters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将这看作是创建一系列密切相关函数的一种方式，每个函数具有略有不同的参数集合 - 称为**签名** - 但都共享相同的简单名称。许多函数共享相同的名称的想法可能有点令人困惑。因此，我们将更多地关注可选参数的概念。
- en: 'An example of optional parameters is the `int()` function. This has two forms:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数的一个示例是`int()`函数。它有两种形式：
- en: '`int(str)` : For example, the value of `int(''355'')` has a value of `355`
    . In this case, we didn''t provide a value for the optional `base` parameter;
    the default value of `10` was used.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int(str)`: 例如，`int(''355'')`的值为`355`。在这种情况下，我们没有为可选的`base`参数提供值；使用了默认值`10`。'
- en: '`int(str, base)` : For example, the value of `int(''0x163'', 16)` is `355`
    . In this case, we provided a value for the `base` parameter.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int(str, base)`：例如，`int(''0x163'', 16)`的值是`355`。在这种情况下，我们为`base`参数提供了一个值。'
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A great many games rely on collections of dice. The casino game of *Craps* uses
    two dice. A game like *Zilch* (or *Greed* or *Ten Thousand* ) uses six dice. Variations
    on the game may use more.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏依赖于骰子的集合。赌场游戏*Craps*使用两个骰子。像*Zilch*（或*Greed*或*Ten Thousand*）这样的游戏使用六个骰子。游戏的变体可能使用更多。
- en: It's handy to have a dice-rolling function that can handle all of these variations.
    How can we write a dice-simulator that works for any number of dice, but will
    use two as a handy default value?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个可以处理所有这些变化的掷骰子函数非常方便。我们如何编写一个骰子模拟器，可以处理任意数量的骰子，但是将使用两个作为方便的默认值？
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We have two approaches to designing a function with optional parameters:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法来设计带有可选参数的函数：
- en: '**General to Particular** : We start by designing the most general solution
    and provide handy defaults for the most common case.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一般到特定**：我们首先设计最一般的解决方案，并为最常见的情况提供方便的默认值。'
- en: '**Particular to General** : We start by designing several related functions.
    We then merge them into one general function that covers all of the cases, singling
    out one of the original functions to be the default behavior.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定到一般**：我们首先设计几个相关的函数。然后将它们合并为一个涵盖所有情况的一般函数，将原始函数中的一个单独出来作为默认行为。'
- en: Particular to General Design
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从特定到一般的设计
- en: 'When following the Particular to General strategy, we''ll design several individual
    functions and look for common features:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循特定到一般策略时，我们将设计几个单独的函数，并寻找共同的特征：
- en: 'Write one version of the function. We''ll start with the *Craps* game because
    it seems simplest:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写函数的一个版本。我们将从*Craps*游戏开始，因为它似乎最简单：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We defined a handy helper function, `die()` , which encapsulates a basic fact
    about what are sometimes called standard dice. There are five platonic solids
    that can be pressed into service, yielding four-sided, six-sided, eight-sided,
    twelve-sided, and twenty-sided dice. The six-sided die has a long history, starting
    as *Astragali* bones, which were easily trimmed into a six-sided cube.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个方便的辅助函数`die()`，它封装了有时被称为标准骰子的基本事实。有五个可以使用的立体几何体，可以产生四面体、六面体、八面体、十二面体和二十面体骰子。六面骰子有着悠久的历史，最初是作为*骰子*骨头，很容易修剪成六面立方体。
- en: 'Here''s an example of the underlying `die()` function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是底层`die()`函数的一个示例：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We've rolled two dice to show how the values combine for rolling larger piles
    of dice.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们掷了两个骰子，以展示值如何组合以掷更大堆的骰子。
- en: 'Our function for the game of *Craps* looks like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的*Craps*游戏函数看起来是这样的：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This shows some two-dice rolls for the game of *Craps* .
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了*Craps*游戏的一些两个骰子投掷。
- en: 'Write another version of the function:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写函数的另一个版本：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We've used a generator expression to create a tuple object with six dice. We'll
    look at generator expressions in depth in [Chapter 8](text00088.html#page "Chapter 8. Functional
    and Reactive Programming Features") , *Functional And Reactive Programming Features*
    .
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个生成器表达式来创建一个有六个骰子的元组对象。我们将在[第8章](text00088.html#page "第8章。函数式和反应式编程特性")中深入研究生成器表达式，*函数式和反应式编程特性*。
- en: Our generator expression has a variable, `x` , which is ignored. It's also common
    to see this written as `tuple(die() for _ in range(6))` . The variable `_` is
    a valid Python variable name; this name can be used as a hint that we don't ever
    want to see the value of this variable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的生成器表达式有一个变量`x`，它被忽略了。通常也可以看到这样写成`tuple(die() for _ in range(6))`。变量`_`是一个有效的Python变量名；这个名字可以作为一个提示，表明我们永远不想看到这个变量的值。
- en: 'Here''s an example of using the `zonk()` function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`zonk()`函数的一个例子：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This shows us a roll of six individual dice. There's a short straight (1-5)
    as well as a pair of ones. In some versions of the game, this is a good scoring
    hand.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了六个单独骰子的结果。有一个短顺（1-5）以及一对一。在游戏的某些版本中，这是一个很好的得分手。
- en: Locate the common features in the two functions. This may require some rewriting
    of the various functions to locate a common design. In many cases, we'll wind
    up introducing additional variables to replace constants or other assumptions.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出两个函数中的共同特征。这可能需要对各种函数进行一些重写，以找到一个共同的设计。在许多情况下，我们最终会引入额外的变量来替换常数或其他假设。
- en: 'In this case, we can generalize the creation of the two-tuple. Rather than
    hardwiring two evaluations of the `die()` function, we can introduce a generator
    expression based on `range(2)` that will evaluate the `die()` function twice:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以将两元组的创建概括化。我们可以引入一个基于`range(2)`的生成器表达式，它将两次评估`die()`函数：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This seems like more code than required for solving the specific two-dice problem.
    In the long run, using a single general function means that we can eliminate a
    number of specific functions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎比解决特定的两个骰子问题需要更多的代码。从长远来看，使用一个通用函数意味着我们可以消除许多特定的函数。
- en: 'Merge the two functions. This will often involve exposing a variable that had
    previously been a constant or other hardwired assumption:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并这两个函数。这通常涉及到暴露一个之前是常数或其他硬编码假设的变量：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This provides a general function that covers the needs of both *Craps* and
    *Zonk* :'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个通用函数，涵盖了*Craps*和*Zonk*的需求：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Identify the most common use case, and make this the default value for any
    parameters that were introduced. If our most common simulation was *Craps* , we
    might do this:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定最常见的用例，并将其作为引入的任何参数的默认值。如果我们最常见的模拟是*Craps*，我们可能会这样做：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we can simply use `dice()` for *Craps* . We'll need to use `dice(6)` for
    *Zonk* .
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以简单地在*Craps*中使用`dice()`。我们需要在*Zonk*中使用`dice(6)`。
- en: General to Particular design
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从一般到特殊的设计
- en: 'When following the General to Particular strategy, we''ll identify all of the
    needs first. We''ll often do this by introducing variables into the requirements:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循从一般到特殊的策略时，我们会首先确定所有的需求。我们通常会通过在需求中引入变量来做到这一点：
- en: 'Summarize the requirements for dice-rolling. We might have a list like this:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总结掷骰子的需求。我们可能有一个像这样的列表：
- en: '*Craps* : two dice.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Craps*：两个骰子。'
- en: 'First roll in *Zonk* : six dice.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Zonk*中的第一次掷骰子：六个骰子。'
- en: 'Subsequent rolls in *Zonk* : one to six dice.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Zonk*中的后续掷骰子：一到六个骰子。'
- en: This list of requirements shows a common theme of rolling *n* dice.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个需求列表显示了掷*n*个骰子的一个共同主题。
- en: 'Rewrite the requirements with an explicit parameter in place of any literal
    value. We''ll replace all of our numbers with a parameter, *n* , and show the
    values for this new parameter that we''ve introduced:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一个显式参数重写需求，代替任何字面值。我们将用参数*n*替换所有的数字，并展示我们引入的这个新参数的值：
- en: '*Craps* : *n* dice, where *n = 2* .'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Craps*：*n*个骰子，其中*n=2*。'
- en: 'First roll in *Zonk* : *n* dice, where *n = 6* .'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Zonk*中的第一次掷骰子：*n*个骰子，其中*n=6*。'
- en: 'Subsequent rolls in *Zonk* : *n* dice, where *1 ≤ n ≤ 6* .'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Zonk*中的后续掷骰子：*n*个骰子，其中*1≤n≤6*。'
- en: The goal here is to be absolutely sure that all of the variations really have
    a common abstraction. In more complex problems, something that seems similar may
    not have a common specification.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是确保所有的变化确实有一个共同的抽象。在更复杂的问题中，看似相似的东西可能没有一个共同的规范。
- en: We want to be sure, also, that we've properly parameterized each of the various
    functions. In more complex cases, we may have values that don't really need to
    be parameterized; they can remain as constants.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望确保我们已经正确地对各种函数进行了参数化。在更复杂的情况下，我们可能有一些不需要被参数化的值；它们可以保持为常数。
- en: 'Write the function that fits the general pattern:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写符合一般模式的函数：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the third case – subsequent rolls in *Zonk*  – we identified a constraint
    of *1 ≤ n ≤ 6* . We need to determine if this is a constraint that's part of our
    `dice()` function, or if this constraint is imposed on the dice by the simulation
    application that uses the `dice` function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三种情况下——*Zonk*中的后续掷骰子——我们确定了一个*1≤n≤6*的约束。我们需要确定这是否是我们`dice()`函数的约束，还是这个约束是由使用`dice`函数的模拟应用所施加的。
- en: In this case, the constraint is incomplete. The rules for *Zonk* require that
    the dice which are not being rolled form some kind of scoring pattern. The constraint
    isn't merely that the number of dice is between one and six; the constraint is
    tied to the game state. There doesn't seem to be a good reason to tie the `dice()`
    function to the game state.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，约束是不完整的。*Zonk*的规则要求没有被掷动的骰子形成某种得分模式。约束不仅仅是骰子的数量在一到六之间；约束与游戏状态有关。似乎没有充分的理由将`dice()`函数与游戏状态联系起来。
- en: 'Provide a default value for the most common use case. If our most common simulation
    was *Craps* , we might do this:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为最常见的用例提供一个默认值。如果我们最常见的模拟是*Craps*，我们可能会这样做：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we can simply use `dice()` for *Craps* . We'll need to use `dice(6)` for
    *Zonk* .
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以简单地在*Craps*中使用`dice()`。我们需要在*Zonk*中使用`dice(6)`。
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Python''s rules for providing parameter values are very flexible. There are
    several ways to assure that each parameter has a value. We can think of it working
    like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供参数值的规则非常灵活。有几种方法可以确保每个参数都有一个值。我们可以将其视为以下方式工作：
- en: Set each parameter to any provided default value.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个参数设置为任何提供的默认值。
- en: For arguments without names, the argument values are assigned to the parameters
    by position.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于没有名称的参数，参数值是按位置分配给参数的。
- en: For arguments with names – for example, `dice(n=2)`  – the parameter values
    are assigned using the name. It's an error to assign a parameter both by position
    and by name.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于具有名称的参数，例如`dice(n=2)`，参数值是使用名称分配的。通过位置和名称同时分配参数是错误的。
- en: If any parameter doesn't have a value, this is an error.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何参数没有值，这是一个错误。
- en: These rules allow us to provide defaults as needed. They also allow us to mix
    positional values with named values. The presence of a default value is what makes
    a parameter optional.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则允许我们根据需要提供默认值。它们还允许我们混合位置值和命名值。默认值的存在是使参数可选的原因。
- en: 'The use of optional parameters stems from two considerations:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可选参数的使用源于两个考虑因素：
- en: Can we parameterize the processing?
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以对处理进行参数化吗？
- en: What's the most common argument value for that parameter?
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该参数的最常见参数值是什么？
- en: Introducing parameters into a process definition can be challenging. In some
    cases, it helps to have code so that we can replace literal values (such as 2
    or 6) with a parameter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在流程定义中引入参数可能是具有挑战性的。在某些情况下，有代码可以帮助我们用参数替换文字值（例如2或6）。
- en: In some cases, however, the literal value doesn't need to be replaced with a
    parameter. It can be left as a literal value. We don't always want to replace
    every literal with a parameter. Our `die()` function, for example, has a literal
    value of 6 because we're only interested in standard, cubic dice. This isn't a
    parameter because we don't see a need to make a more general kind of die.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，文字值不需要被参数替换。它可以保留为文字值。我们并不总是想用参数替换每个文字值。例如，我们的`die()`函数有一个文字值为6，因为我们只对标准的立方骰子感兴趣。这不是一个参数，因为我们不认为有必要制作更一般的骰子。
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we want to be very thorough, we can write functions that are specialized
    versions of our more generalized function. These functions can simplify an application:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想非常彻底，我们可以编写专门的版本函数，这些函数是我们更通用的函数的专门版本。这些函数可以简化应用程序：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our application features – `craps()` and `zonk()` – depend on a general function,
    `dice()` . This, in turn, depends on another function, `die()` . We'll revisit
    this idea in the *Picking an order for parameters based on partial functions*
    recipe.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序功能-`craps()`和`zonk()`-依赖于一个通用函数`dice()`。这又依赖于另一个函数`die()`。我们将在*基于部分函数选择参数顺序*食谱中重新讨论这个想法。
- en: Each layer in this stack of dependencies introduces a handy abstraction that
    saves us from having to understand too many details. This idea of layered abstractions
    is sometimes called **chunking** . It's a way of managing complexity by isolating
    the details.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个依赖堆栈中的每一层都引入了一个方便的抽象，使我们不必理解太多细节。这种分层抽象的想法有时被称为**chunking**。这是一种通过隔离细节来管理复杂性的方法。
- en: A common extension to this design pattern is to provide parameters at multiple
    levels in this hierarchy of functions. If we want to parameterize the `die()`
    function, we'll be providing parameters to both `dice()` and `die()` .
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式的常见扩展是在这个函数层次结构中的多个级别提供参数。如果我们想要对`die()`函数进行参数化，我们将为`dice()`和`die()`提供参数。
- en: 'For this more complex parameterization, we''ll need to introduce more parameters
    with default values into our hierarchy. We''ll start by adding a parameter to
    `die()` . This parameter must have a default value so that we don''t break any
    of our existing test cases:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种更复杂的参数化，我们需要在我们的层次结构中引入更多具有默认值的参数。我们将从`die()`中添加一个参数开始。这个参数必须有一个默认值，这样我们就不会破坏我们现有的测试用例：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After introducing this parameter at the bottom of the stack of abstractions,
    we''ll need to provide this parameter to higher-level functions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入这个参数到抽象堆栈的底部之后，我们需要将这个参数提供给更高级别的函数：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We now have many ways of using the `dice()` function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有很多种使用`dice()`函数的方法：
- en: 'All default values: `dice()` covers *Craps* nicely.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有默认值：`dice()`很好地覆盖了*Craps*。
- en: 'All positional arguments: `dice(6, 6)` would cover *Zonk* .'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有位置参数：`dice(6, 6)`将覆盖*Zonk*。
- en: 'A mixture of positional and named arguments: The positional values must be
    provided first because the order matters. For example, `dice(2, sides=8)` would
    cover a game that uses two eight-sided dice.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置和命名参数的混合：位置值必须首先提供，因为顺序很重要。例如，`dice(2, sides=8)`将覆盖使用两个八面体骰子的游戏。
- en: 'All named arguments: `dice(sides=4, n=4)` this would handle the case where
    we needed to emulate rolling four tetrahedral dice. When using all named arguments,
    order doesn''t matter.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有命名参数：`dice(sides=4, n=4)`这将处理我们需要模拟掷四个四面体骰子的情况。在使用所有命名参数时，顺序并不重要。
- en: In this example, our stack of functions only has two layers. In a more complex
    application, we may have to introduce parameters at many layers in a hierarchy.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的函数堆栈只有两层。在更复杂的应用程序中，我们可能需要在层次结构的许多层中引入参数。
- en: See also
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We'll extend some of these ideas in the *Picking an order for parameters based
    on partial functions* recipe.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在*基于部分函数选择参数顺序*食谱中扩展一些这些想法。
- en: We've made use of optional parameters that involve immutable objects. In this
    recipe, we focused on numbers. In [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Built-in Data Structures – list, set, dict*
    , we'll look at mutable objects, which have an internal state that can be changed.
    In the *Avoiding mutable default values for function parameters* recipe, we'll
    look at some additional considerations that are important for designing functions
    that have optional values that are mutable objects.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了涉及不可变对象的可选参数。在这个配方中，我们专注于数字。在[第4章](text00048.html#page "第4章。内置数据结构-列表、集合、字典")中，*内置数据结构-列表、集合、字典*，我们将研究可变对象，它们具有可以更改的内部状态。在*避免函数参数的可变默认值*配方中，我们将研究一些重要的额外考虑因素，这些因素对于设计具有可变对象的可选值的函数非常重要。
- en: Using super flexible keyword parameters
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用超级灵活的关键字参数
- en: 'Some design problems involve solving a simple equation for one unknown given
    enough known values. For example, rate, time, and distance have a simple linear
    relationship. We can solve for any one given the other two. Here are the three
    rules that we can use as an example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些设计问题涉及解决一个未知的简单方程，给定足够的已知值。例如，速率、时间和距离之间有一个简单的线性关系。我们可以解决任何一个，只要知道另外两个。以下是我们可以用作示例的三条规则：
- en: '*d = r* × *t*'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*d = r* × *t*'
- en: '*r = d / t*'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*r = d / t*'
- en: '*t = d / r*'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*t = d / r*'
- en: When designing electrical circuits, for example, a similar set of equations
    is used based on Ohm's Law. In that case, the equations tie together resistance,
    current, and voltage.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计电路时，例如，基于欧姆定律使用了一组类似的方程。在这种情况下，方程将电阻、电流和电压联系在一起。
- en: In some cases, we want to provide a simple, high-performance software implementation
    that can perform any of the three different calculations based on what's known
    and what's unknown. We don't want to use a general algebraic framework; we want
    to bundle the three solutions into a simple, efficient function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望提供一个简单、高性能的软件实现，可以根据已知和未知的情况执行三种不同的计算中的任何一种。我们不想使用通用的代数框架；我们想将三个解决方案捆绑到一个简单、高效的函数中。
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll build a single function that can solve a **Rate-Time-Distance** ( **RTD**
    ) calculation by embodying all three solutions given any two known values. With
    minor variable name changes, this applies to a surprising number of real-world
    problems.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个单一函数，可以通过体现任意两个已知值的三个解来解决**速率-时间-距离**（**RTD**）计算。通过微小的变量名称更改，这适用于令人惊讶的许多现实世界问题。
- en: There's a trick here. We don't necessarily want a single value answer. We can
    slightly generalize this by creating a small Python dictionary with the three
    values in it. We'll look more at dictionaries in [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structures –
    list, set, dict* .
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个技巧。我们不一定想要一个单一的值答案。我们可以通过创建一个包含三个值的小Python字典来稍微概括这一点。我们将在[第4章](text00048.html#page
    "第4章。内置数据结构-列表、集合、字典")中更多地了解字典。
- en: 'We''ll use the `warnings` module instead of raising an exception when there''s
    a problem:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现问题时，我们将使用`warnings`模块而不是引发异常：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Sometimes it is more helpful to produce a result that is doubtful than to stop
    processing.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，产生一个有疑问的结果比停止处理更有帮助。
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Solve the equation for each of the unknowns. We''ve shown that previously for
    *d = r * t* , the RTD calculation:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 解出每个未知数的方程。我们先前已经展示了这一点，例如*d = r * t*，RTD计算：
- en: 'This leads to three separate expressions:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这导致了三个单独的表达式：
- en: distance = rate * time
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 距离=速率*时间
- en: rate = distance / time
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率=距离/时间
- en: time = distance / rate
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间=距离/速率
- en: 'Wrap each expression in an `if` statement based on one of the values being
    `None` when it''s unknown:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据一个值为`None`时未知的情况，将每个表达式包装在一个`if`语句中：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Refer to the *Designing complex if...elif chains* recipe from [Chapter 2](text00027.html#page
    "Chapter 2. Statements and Syntax") , *Statements and Syntax* , for guidance on
    designing these complex `if...elif` chains. Include a variation on the `else`
    crash option:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考[第2章](text00027.html#page "第2章。语句和语法")中的*设计复杂的if...elif链*，*语句和语法*，以指导设计这些复杂的`if...elif`链。包括`else`崩溃选项的变体：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Build the resulting dictionary object. In simple cases, we can use the `vars()`
    function to simply emit all of the local variables as a resulting dictionary.
    In some cases, we may have local variables we don''t want to include; in that
    case, we''ll need to build the dictionary explicitly:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建生成的字典对象。在简单情况下，我们可以使用`vars()`函数简单地将所有本地变量作为生成的字典发出。在某些情况下，我们可能有一些本地变量不想包括；在这种情况下，我们需要显式构建字典：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Wrap all of this as a function using keyword parameters:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用关键字参数将所有这些包装为一个函数：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can use the resulting function like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用生成的函数：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This shows us that going 31.2 nautical miles at a rate of 6 knots will take
    5.2 hours.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，以6节的速率行驶31.2海里将需要5.2小时。
- en: 'For nicely formatted output, we might do this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到格式良好的输出，我们可以这样做：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To break up the long string, we used the *Designing complex if...elif chains*
    recipe from [Chapter 2](text00027.html#page "Chapter 2. Statements and Syntax")
    , *Statements and Syntax* .
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打破长字符串，我们使用了[第2章](text00027.html#page "第2章。语句和语法")中的*设计复杂的if...elif链*。
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Because we've provided default values for all of the parameters, we can provide
    argument values for two of the three parameters, and the function can then solve
    for the third parameter. This saves us from having to write three separate functions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们为所有参数提供了默认值，所以我们可以为三个参数中的两个提供参数值，然后函数就可以解决第三个参数。这样可以避免我们编写三个单独的函数。
- en: Returning a dictionary as the final result isn't essential to this. It's simply
    handy. It allows us to have a uniform result no matter which parameter values
    were provided.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将字典作为最终结果返回并不是必要的。这只是方便。它允许我们无论提供了哪些参数值，都有一个统一的结果。
- en: There's more...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We have an alternative formulation for this, one that involves more flexibility.
    Python functions have an *all other keywords* parameter, prefixed with `**` .
    It is often shown like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有另一种表述，涉及更多的灵活性。Python函数有一个*所有其他关键字*参数，前缀为`**`。通常显示如下：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Any additional keyword arguments are collected into a dictionary that is provided
    to the `**keywords` parameter. We can then call this function with extra parameters.
    Evaluate this function like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 任何额外的关键字参数都会被收集到提供给`**keywords`参数的字典中。然后我们可以用额外的参数调用这个函数。像这样评估这个函数：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''ll then see that the value of the `keywords` parameter is a dictionary
    object with the value of `{''something_else'': 60}` . We can then use ordinary
    dictionary processing techniques on this structure. The keys and values in this
    dictionary are the names and values provided when the function was evaluated.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '然后我们会看到`keywords`参数的值是一个带有`{''something_else'': 60}`值的字典对象。然后我们可以对这个结构使用普通的字典处理技术。这个字典中的键和值是在函数被评估时提供的名称和值。'
- en: 'We can leverage this and insist that all arguments be provided with keywords:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这一点，并坚持要求所有参数都提供关键字：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This version uses the dictionary `get()` method to find a given key in the dictionary.
    If the key is not present, a default value of `None` is provided.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本使用字典`get()`方法在字典中查找给定的键。如果键不存在，则提供`None`的默认值。
- en: (Returning a default of `None` is the default behavior of the `get()` method.
    Our example contains some redundancy to clarify the processing. For some very
    complex situations, we might have defaults other than `None` .)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: （返回`None`的默认值是`get()`方法的默认行为。我们的示例包含一些冗余，以阐明处理过程。对于一些非常复杂的情况，我们可能有除`None`之外的默认值。）
- en: This has the potential advantage of being slightly more flexible. It has the
    potential disadvantage of making the actual parameter names very hard to discern.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这有可能具有稍微更灵活的优势。它可能的缺点是使实际参数名称非常难以辨别。
- en: We can follow the *Writing Clear documentation strings with RST markup* recipe
    and provide a good docstring. It seems somehow better, though, to provide the
    parameter names explicitly as part of the Python code rather than implicitly through
    documentation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遵循*使用RST标记编写清晰文档字符串*的配方，并提供一个良好的文档字符串。然而，通过文档隐式地提供参数名称似乎更好一些。
- en: See also
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We'll look at documentation of functions in the *Writing* *Clear documentation
    strings with RST markup* recipe
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将查看*使用RST标记编写清晰文档字符串*配方中函数的文档
- en: '![](image/614271.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](image/614271.jpg)'
- en: Forcing keyword-only arguments with the * separator
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用*分隔符强制使用关键字参数
- en: There are some situations where we have a large number of positional parameters
    to a function. Perhaps we've followed the *Designing functions with optional parameters*
    recipe and this leads us to design a function with so many parameters that it
    gets confusing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，我们需要将大量的位置参数传递给函数。也许我们遵循了*设计具有可选参数的函数*的配方，这导致我们设计了一个参数如此之多的函数，以至于变得令人困惑。
- en: Pragmatically, a function with more than about three parameters can be confusing.
    A great deal of conventional mathematics seems to focus on one and two parameter
    functions. There don't seem to be too many common mathematical operators that
    involve three or more operands.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从实用的角度来看，一个具有超过三个参数的函数可能会令人困惑。大量的传统数学似乎集中在一个和两个参数函数上。似乎没有太多常见的数学运算符涉及三个或更多的操作数。
- en: When it gets difficult to remember the required order for the parameters, there
    are too many parameters.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当难以记住参数的所需顺序时，参数太多了。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll look at a function that has a large number of parameters. We'll use a
    function which prepares a wind-chill table and writes the data to a CSV format
    output file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个具有大量参数的函数。我们将使用一个准备风冷表并将数据写入CSV格式输出文件的函数。
- en: We need to provide a range of temperatures, a range of wind speeds, and information
    on the file we'd like to create. This is a lot of parameters.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供一系列温度、一系列风速以及我们想要创建的文件的信息。这是很多参数。
- en: 'The basic formula is this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 基本公式是这样的：
- en: '*T[wc]* ( *T[a] , V* ) = 13.12 + 0.6215 *T[a]* - 11.37 *V* ^(0.16) + 0.3965
    *T[a] V* ^(0.16)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*T[wc]* ( *T[a]*, V* ) = 13.12 + 0.6215 *T[a]* - 11.37 *V* ^(0.16) + 0.3965
    *T[a] V* ^(0.16)'
- en: The wind chill temperature, *T[wc]* , is based on the air temperature, *T[a]*
    , in degrees *C* , and the wind speed, *V* , in KPH.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 风冷温度，*T[wc]*，基于空气温度，*T[a]*，以摄氏度为单位，以及风速，*V*，以KPH为单位。
- en: 'For Americans, this requires some conversions:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于美国人来说，这需要一些转换：
- en: 'Convert from °F to °C: *C* = 5( *F* -32) / 9'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从°F转换为°C：*C* = 5( *F* -32) / 9
- en: 'Convert windspeed from MPH, *V[m]* , to KPH, *V[k]* : *V[k] = V[m]* × 1.609344'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将风速从MPH，*V[m]*，转换为KPH，*V[k]*：*V[k] = V[m]* × 1.609344
- en: 'The result needs to be converted from °C back to °F: *F* = 32 + *C* (9/5)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果需要从°C转换回°F：*F* = 32 + *C* (9/5)
- en: We won't fold these into this solution. We'll leave that as an exercise for
    the reader.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会将这些纳入这个解决方案。我们将把这留给读者作为一个练习。
- en: 'One approach for creating a wind-chill table is to create something like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 创建风冷表的一种方法是创建类似于这样的东西：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've opened an output file using the `with` context. This follows the *Managing
    a context using the with statement* recipe in [Chapter 2](text00027.html#page
    "Chapter 2. Statements and Syntax") , *Statements and Syntax* . Within this context,
    we've created a write for the CSV output file. We'll look at this in more depth
    in [Chapter 9](text00099.html#page "Chapter 9. Input/Output, Physical Format,
    and Logical Layout") , *Input/Output, Physical Format, Logical Layout* .
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`with`上下文打开了一个输出文件。这遵循了[第2章](text00027.html#page "第2章。语句和语法")中的*使用with语句管理上下文*配方，*语句和语法*。在这个上下文中，我们为CSV输出文件创建了一个写入。我们将在[第9章](text00099.html#page
    "第9章。输入/输出、物理格式和逻辑布局")中更深入地研究这个问题，*输入/输出、物理格式、逻辑布局*。
- en: We've used an expression, `[None]+list(range(start_T, stop_T, step_T))` , to
    create a heading row. This expression includes a list literal and a generator
    expression that builds a list. We'll look at lists in [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structures –
    list, set, dict* . We'll look at the generator expression in [Chapter 8](text00088.html#page
    "Chapter 8. Functional and Reactive Programming Features") , *Functional and Reactive
    Programming Features* .
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用表达式`[None]+list(range(start_T, stop_T, step_T)`，创建了一个标题行。这个表达式包括一个列表文字和一个生成器表达式，用于构建一个列表。我们将在[第4章](text00048.html#page
    "第4章。内置数据结构-列表、集合、字典")中查看列表，*内置数据结构-列表、集合、字典*。我们将在[第8章](text00088.html#page "第8章。函数式和响应式编程特性")中查看生成器表达式，*函数式和响应式编程特性*。
- en: Similarly, each cell of the table is built by a generator expression, `[Twc(T,
    V) for T in range(start_T, stop_T, step_T)]` . This is a comprehension that builds
    a list object. The list consists of values computed by the wind-chill function,
    `Twc()` . We provide the wind velocity based on the row in the table. We provide
    a temperature based on the column in the table.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，表格的每个单元格都是由一个生成器表达式构建的，`[Twc(T, V) for T in range(start_T, stop_T, step_T)]`。这是一个构建列表对象的理解。列表由风冷函数`Twc()`计算的值组成。我们根据表中的行提供风速。我们根据表中的列提供温度。
- en: While the details involve forward-looking sections, the `def` line presents
    a problem. This `def` line is very complex.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然细节涉及前瞻性部分，`def`行提出了一个问题。这个`def`行非常复杂。
- en: 'The problem with this design is that the `wind_chill()` function has seven
    positional parameters. When we try to use this function, we wind up with code
    like the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的问题在于`wind_chill()`函数有七个位置参数。当我们尝试使用这个函数时，我们得到以下代码：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What are all those numbers? Is there something we can do to help explain what
    this line of code means?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数字是什么？有没有什么可以帮助解释这行代码的意思？
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: When we have a large number of parameters, it helps to use keyword arguments
    instead of positional arguments.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有大量参数时，使用关键字参数而不是位置参数会有所帮助。
- en: 'In Python 3, we have a technique that mandates the use of keyword arguments.
    We can use the `*` as a separator between two groups of parameters:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3中，我们有一种强制使用关键字参数的技术。我们可以使用`*`作为两组参数之间的分隔符：
- en: Before the `*` , we list the argument values that can be *either* positional
    or named by keyword. In this example, we don't have any of these parameters.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`*`之前，我们列出可以*或*按关键字命名的参数值。在这个例子中，我们没有这些参数。
- en: After the `*` , we list the argument values that must be given with a keyword.
    For our example, this is all of the parameters.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`*`之后，我们列出必须使用关键字给出的参数值。对于我们的示例，这是所有的参数。
- en: 'For our example, the resulting function looks like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，生成的函数如下：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When we try to use the confusing positional parameters, we''ll see this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试使用令人困惑的位置参数时，我们会看到这个：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We must use the function as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须按以下方式使用该函数：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This use of mandatory keyword parameters forces us to write a clear statement
    each time we use this complex function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 强制使用必填关键字参数的用法迫使我们每次使用这个复杂函数时都写出清晰的语句。
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `*` character has two meanings in the definition of a function:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`字符在函数定义中有两个含义：'
- en: It's used as a prefix for a special parameter that receives all the unmatched
    positional arguments. We often use `*args` to collect all of the positional arguments
    into a single parameter named `args` .
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它作为一个特殊参数的前缀，接收所有未匹配的位置参数。我们经常使用`*args`将所有位置参数收集到一个名为`args`的单个参数中。
- en: It's used by itself, as a separator between parameters that may be applied positionally
    and parameters which must be provided by keyword.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被单独使用，作为可以按位置应用的参数和必须通过关键字提供的参数之间的分隔符。
- en: The `print()` function exemplifies this. It has three keyword-only parameters
    for the output file, the field separator string, and the line end string.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()`函数就是一个例子。它有三个仅限关键字参数，用于输出文件、字段分隔符字符串和行结束字符串。'
- en: There's more...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can, of course, combine this technique with default values for the various
    parameters. We might, for example, make a change to this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以将此技术与各种参数的默认值结合使用。例如，我们可以对此进行更改：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can now use this function in two ways:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以以两种方式使用这个函数：
- en: 'Here''s a way to print the table on the console:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是在控制台上打印表的方法：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here''s a way to write to a file:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是写入文件的方法：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We've changed the approach here, to one which is slightly more generalized.
    This follows the *Designing functions with optional parameters* recipe.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里改变了方法，稍微更加通用。这遵循了*设计具有可选参数的函数*配方。
- en: See also
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Picking an order for parameters based on partial functions*  recipe
    for another application of this technique
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看*基于部分函数选择参数顺序*配方，了解此技术的另一个应用
- en: Writing explicit types on function parameters
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数参数上写明确的类型
- en: 'The Python language allows us to write functions (and classes) which are entirely
    generic with respect to data type. Consider this function as an example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言允许我们编写完全与数据类型相关的函数（和类）。以这个函数为例：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This follows three recipes shown earlier: *Using super flexible keyword parameters*
    , *Forcing keyword-only arguments with the * separator* from this chapter, and
    *Designing complex if...elif chains* from [Chapter 2](text00027.html#page "Chapter 2. Statements
    and Syntax") , *Statements and Syntax* .'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循了之前展示的三个配方：*使用超灵活的关键字参数*，*使用本章的*分隔符强制关键字参数*，以及*设计复杂的if...elif链*来自[第2章](text00027.html#page
    "第2章。语句和语法")，*语句和语法*。
- en: This function will work for argument values of any numeric type. Indeed, it
    will work for any data structure that implements the `+` , `-` , `*` , and `/`
    operators.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将适用于任何数值类型的参数值。实际上，它将适用于任何实现`+`、`-`、`*`和`/`运算符的数据结构。
- en: 'There are times when we do not want our functions to be completely generic.
    In some cases, we would like to make some stronger assertions about data types.
    While we sometimes care about the data type, we do not want to write a lot of
    code that looks like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不希望我们的函数完全通用。在某些情况下，我们希望对数据类型做出更强的断言。虽然我们有时关心数据类型，但我们不想编写大量看起来像这样的代码：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This introduces performance overhead of an extra `assert` statement. It also
    clutters our programs with a statement that – generally – should be restating
    the obvious.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这引入了额外的`assert`语句的性能开销。它还会用一个通常应该重申显而易见的语句来使我们的程序混乱。
- en: 'Additionally, we can''t rely on docstrings for testing purposes. Here''s the
    recommended style:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不能依赖文档字符串进行测试。这是推荐的风格：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The docstring doesn't allow any automated testing to confirm that the documentation
    actually matches the code. The two could disagree with each other.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串不允许进行任何自动化测试来确认文档实际上是否与代码匹配。两者可能不一致。
- en: What we want are hints about the type of data involved that can be used for
    testing and confirmation, but don't interfere with performance. How can we provide
    meaningful type hints?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的是关于涉及的数据类型的提示，可以用于测试和确认，但不会影响性能。我们如何提供有意义的类型提示？
- en: Getting ready
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We''ll implement a version of the `temperature()` function. We''ll need two
    modules that will help us provide hints regarding the data types for parameters
    and return values:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现`temperature()`函数的一个版本。我们将需要两个模块，这些模块将帮助我们提供关于参数和返回值的数据类型的提示：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We've opted to import all of the names from the `typing` module. If we're going
    to supply type hints, we want them to be terse. It's awkward having to write `typing.List[str]`
    . We prefer to omit the module name.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择从`typing`模块导入所有名称。如果我们要提供类型提示，我们希望它们简洁。写`typing.List[str]`很尴尬。我们更喜欢省略模块名称。
- en: We'll also need to install the latest version of `mypy` . This project is undergoing
    rapid development. Rather than use the `pip` program to get a copy from PyPI,
    it's better to download the latest version directly from the GitHub repository,
    [https://github.com/JukkaL/mypy](https://github.com/JukkaL/mypy) .
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装最新版本的`mypy`。这个项目正在快速发展。与其使用`pip`程序从PyPI获取副本，最好直接从GitHub存储库[https://github.com/JukkaL/mypy](https://github.com/JukkaL/mypy)下载最新版本。
- en: The instructions say that, *Currently, the version of mypy on PyPI is not compatible
    with Python 3.5\. If you run Python 3.5 install directly from git* .
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 说明中说，*目前，PyPI上的mypy版本与Python 3.5不兼容。如果你使用Python 3.5，请直接从git安装*。
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `mypy` tool can be used to analyze our Python programs to determine if the
    type hints match the actual code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`mypy`工具可用于分析我们的Python程序，以确定类型提示是否与实际代码匹配。'
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Python 3.5 introduces type hints to the language. We can use them in three
    places: function parameters, function returns, and type hint comments:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.5引入了语言类型提示。我们可以在三个地方使用它们：函数参数、函数返回和类型提示注释：
- en: 'Define a handy type for a variety of numbers:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为各种数字定义一个方便的类型：
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Ideally, we'd like to use the abstract `Number` class in the numbers module.
    Currently, this module doesn't have a formal type specification available, so
    we'll define our own expectation for `Number` . This definition is a union of
    several numeric types. Ideally, a future release of `mypy` or Python will include
    the needed definitions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望在numbers模块中使用抽象的`Number`类。目前，该模块没有可用的正式类型规范，因此我们将为`Number`定义自己的期望。这个定义是几种数字类型的联合。理想情况下，`mypy`或Python的未来版本将包括所需的定义。
- en: 'Annotate arguments to functions like this:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像这样注释函数的参数：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We've added `:` and a type hint as part of the parameter. In this case, we're
    using our own type definition of `Number` to state that any number is allowed
    here. We've wrapped this with the `Optional[]` type operation to state that the
    argument value can be either a `Number` or `None` .
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在参数的一部分添加了`:`和类型提示。在这种情况下，我们使用我们自己的`Number`类型定义来声明任何数字都可以在这里。我们将其包装在`Optional[]`类型操作中，以声明参数值可以是`Number`或`None`。
- en: 'Annotate return values from functions like this:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的返回值可以这样注释：
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We've added `->` and a type hint for the return value of this function. In this
    case, we've stated that the result will be a dictionary object with keys that
    are strings, `str` , and values that are numbers using our type definition of
    `Number` .
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为此函数的返回值添加了`->`和类型提示。在这种情况下，我们声明结果将是一个具有字符串键`str`和使用我们的`Number`类型定义的数字值的字典对象。
- en: The `typing` module introduces the type hint names such as `Dict` that we use
    to explain the results of a function. This is different from the `dict` class
    which actually builds objects. The `typing.Dict` is merely a hint.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing`模块引入了类型提示名称，例如`Dict`，我们用它来解释函数的结果。这与实际构建对象的`dict`类不同。`typing.Dict`只是一个提示。'
- en: 'If necessary, we can add type hints as comments in assignment and `with` statements.
    These are rarely needed, but may clarify a long, complex series of statements.
    If we wanted to add them, the annotations could look like this:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要的话，我们可以在赋值和`with`语句中添加类型提示作为注释。这些很少需要，但可能会澄清一长串复杂的语句。如果我们想要添加它们，注释可能看起来像这样：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We''ve added `# type: Dict[str, Number]` on the statement that builds the final
    dictionary object.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在构建最终字典对象的语句上添加了`# type: Dict[str, Number]`。'
- en: How it works...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The type information we've added are called **hints** . They're not requirements
    that are somehow checked by the Python compiler. They're not checked at runtime
    either.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的类型信息称为**提示**。它们不是Python编译器以某种方式检查的要求。它们在运行时也不会被检查。
- en: The type hints are used by a separate program, `mypy` . See [http://mypy-lang.org](http://mypy-lang.org)
    for more information.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示由一个名为`mypy`的独立程序使用。有关更多信息，请参见[http://mypy-lang.org](http://mypy-lang.org)。
- en: The `mypy` program examines the Python code, including the type hints. It applies
    some formal reasoning and inference techniques to determine if the various type
    hints will be `true` for any data that the Python program can process.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`mypy`程序检查Python代码，包括类型提示。它应用一些形式推理和推断技术，以确定各种类型提示是否对Python程序可以处理的任何数据为“真”。'
- en: For larger and more complex programs, the output from `mypy` will include warnings
    and errors that describe potential problems with either the code itself, or the
    type hints decorating the code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大更复杂的程序，`mypy`的输出将包括描述代码本身或装饰代码的类型提示可能存在问题的警告和错误。
- en: 'For example, here''s a mistake that''s easy to make. We''ve assumed that our
    function returns a single number. Our return statement, however, doesn''t match
    our expectation:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个容易犯的错误。我们假设我们的函数返回一个单一的数字。然而，我们的返回语句与我们的期望不匹配：
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When we run `mypy` , we''ll see this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`mypy`时，我们会看到这个：
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can see our `Number` type name was expanded to `Union[builtins.int, builtins.float,
    builtins.complex, decimal.Decimal]` in the error message. More importantly, we
    can see that line 37, the `return` statement, doesn't match the function definition.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的`Number`类型名称在错误消息中被扩展为`Union[builtins.int, builtins.float, builtins.complex,
    decimal.Decimal]`。更重要的是，我们可以看到在第37行，`return`语句与函数定义不匹配。
- en: 'Given this error, we need to either fix the return or the definition to be
    sure that the expected type and the actual type match. It''s not clear which is
    *right* . Either of these could be the intent:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个错误，我们需要修复返回值或定义，以确保期望的类型和实际类型匹配。目前不清楚哪个是“正确”的。以下任一种可能是意图：
- en: 'Compute and return a single value: This means that there would need to be two
    `return` statements depending on which value was computed. In this case, there''s
    no reason to build the `result` dictionary object.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算并返回单个值：这意味着需要有两个`return`语句，取决于计算了哪个值。在这种情况下，没有理由构建`result`字典对象。
- en: 'Return the dictionary object: This means we need to correct the `def` statement
    to have the proper return type. Changing this may spread ripples of change to
    other functions that expect `temperature` to return a instance of `Number` .'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回字典对象：这意味着我们需要更正`def`语句以具有正确的返回类型。更改这可能会对其他期望`temperature`返回`Number`实例的函数产生连锁变化。
- en: The extra syntax for parameters and return values has no real impact on runtime,
    and only a very small cost when the source code is first compiled into byte code.
    They are—after all—merely hints.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 参数和返回值的额外语法对运行时没有真正影响，只有在源代码首次编译成字节码时才会有很小的成本。它们毕竟只是提示。
- en: There's more...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'When using built-in types, we can often create elaborate structures. We might,
    for example, have a dictionary that maps tuples of three integers to lists of
    strings:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用内置类型时，我们经常可以创建复杂的结构。例如，我们可能有一个字典，将三个整数的元组映射到字符串列表：
- en: '[PRE43]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If this is the result of a function, how do we describe this?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是函数的结果，我们如何描述这个？
- en: 'We''ll be creating a fairly complex type expression that summarizes each layer
    of the structure:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个相当复杂的类型表达式，总结每个结构层次：
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We've summarized a dictionary that maps one type, `Tuple[int, int, int]` , as
    the key to another type, `List[str]` , as the value. This captures how several
    built-in types can be combined to build complex data structures.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总结了一个将一个类型`Tuple[int, int, int]`映射为另一个类型`List[str]`的字典。这捕捉了几种内置类型如何组合以构建复杂的数据结构。
- en: In this case, we've treated the tuple of three integers as an otherwise anonymous
    tuple. In many cases, it's not merely a generic tuple, it's actually an RGB color
    which is modeled as a tuple. Perhaps the list of strings is really a line of text
    from a longer document that's been split on spaces into words.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将三个整数的元组视为一个匿名元组。在许多情况下，它不仅仅是一个通用元组，它实际上是一个被建模为元组的RGB颜色。也许字符串列表实际上是来自更长文档的一行文本，已经根据空格拆分成单词。
- en: 'In this case, we should do something like the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们应该做如下操作：
- en: '[PRE45]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Creating our own application-specific type names can greatly clarify the processing
    that's being performed using the built-in collection types.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们自己的应用程序特定类型名称可以极大地澄清使用内置集合类型执行的处理。
- en: See also
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See [https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/)
    for more information on type hints.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关类型提示的更多信息，请参见[https://www.python.org/dev/peps/pep-0484/](https://www.python.org/dev/peps/pep-0484/)。
- en: See [https://github.com/JukkaL/mypy](https://github.com/JukkaL/mypy) for the
    current `mypy` project.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关当前`mypy`项目，请参见[https://github.com/JukkaL/mypy](https://github.com/JukkaL/mypy)。
- en: See [http://www.mypy-lang.org](http://www.mypy-lang.org) for documentation on
    how `mypy` works with Python 3.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`mypy`如何与Python 3一起工作的文档，请参见[http://www.mypy-lang.org](http://www.mypy-lang.org)。
- en: Picking an order for parameters based on partial functions
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于部分函数选择参数顺序
- en: When we look at complex functions, we'll sometimes see a pattern to the ways
    we use the function. We might, for example, evaluate a function many times with
    some argument values that are fixed by context, and other argument values that
    are changing with the details of the processing.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看复杂的函数时，有时我们会看到我们使用函数的方式有一个模式。例如，我们可能多次评估一个函数，其中一些参数值由上下文固定，而其他参数值随着处理的细节而变化。
- en: It can simplify our programming if our design reflects this concern. We'd like
    to provide a way to make the common parameters slightly easier to work with than
    the uncommon parameters. We'd also like to avoid having to repeat the parameters
    that are part of a larger context.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的设计反映了这一点，它可以简化我们的编程。我们希望提供一种使常见参数比不常见参数更容易处理的方法。我们也希望避免重复大上下文中的参数。
- en: Getting ready
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We''ll look at a version of the haversine formula. This computes distances
    between points on the surface of the Earth, using the latitude and longitude coordinates
    of that point:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一个haversine公式的版本。这计算地球表面上点之间的距离，使用该点的纬度和经度坐标：
- en: '![Getting ready](Image00005.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](Image00005.jpg)'
- en: '*c* = 2 *arc sin(√a)*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*c* = 2 *arc sin(√a)*'
- en: The essential calculation yields the central angle, *c* , between two points.
    The angle is measured in radians. We convert it into distance by multiplying by
    the Earth's mean radius in some units. If we multiply the angle *c* by a radius
    of 3,959 miles, the distance, we'll convert the angle to miles.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的计算得出了两点之间的中心角*c*。角度以弧度表示。我们通过将其乘以地球的平均半径来将其转换为距离。如果我们将角度*c*乘以半径为3959英里，距离，我们将角度转换为英里。
- en: 'Here''s an implementation of this function. We''ve included type hints:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个函数的一个实现。我们包括了类型提示：
- en: '[PRE46]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note on the doctest example:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 关于doctest示例的说明：
- en: The doctest example uses an earth radius with an extra decimal point that's
    not used elsewhere. This is so that this example matches other examples online.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的doctest使用了一个额外的小数点，这在其他地方没有使用。这样做是为了使这个示例与在线上的其他示例匹配。
- en: The earth isn't spherical. Around the equator, a more accurate radius is 6378.1370
    km. Across the poles, the radius is 6356.7523 km. We're using common approximations
    in the constants.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 地球不是球形的。在赤道附近，更精确的半径是6378.1370公里。在极地附近，半径是6356.7523公里。我们在常数中使用常见的近似值。
- en: The problem we often have is that we're generally working in a single context,
    and we will be providing the same value for `R` all the time. If, for example,
    we're working in a marine environment, we'd always be using `R = NM` to get nautical
    miles.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常遇到的问题是，我们通常在一个单一的上下文中工作，并且我们将始终为`R`提供相同的值。例如，如果我们在海洋环境中工作，我们将始终使用`R = NM`来获得海里。
- en: There are two common approaches to providing a consistent value for an argument.
    We'll look at both.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 提供参数的一致值有两种常见的方法。我们将看看两种方法。
- en: How to do it...
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In some cases, an overall context will establish a variable for a parameter.
    The value will rarely change. There are several common approaches to providing
    a consistent value for an argument. These involve wrapping the function in another
    function. There are several approaches:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一个整体的上下文将为参数建立一个变量。这个值很少改变。提供参数的一致值有几种常见的方法。这涉及将函数包装在另一个函数中。有几种方法：
- en: Wrap the function in a new function.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个新函数中包装函数。
- en: 'Create a partial function. This has two further refinements:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个偏函数。这有两个进一步的改进：
- en: We can provide keyword parameters
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以提供关键字参数
- en: Or we can provide positional parameters
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者我们可以提供位置参数
- en: We'll look at each of these in separate variations in this recipe.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个配方中分别看看这些不同的变化。
- en: Wrapping a function
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包装一个函数
- en: 'We can provide contextual values by wrapping a general function in a context-specific
    wrapper function:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将一个通用函数包装在一个特定上下文的包装函数中来提供上下文值：
- en: Make some parameters positional and some parameters keywords. We want the contextual
    features—the ones which change rarely—to be keywords. The parameters which change
    more frequently should be left as positional. We can follow the *Forcing keyword-only
    arguments with the * separator* recipe.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使一些参数成为位置参数，一些参数成为关键字参数。我们希望上下文特征——很少改变的特征——成为关键字。更频繁更改的参数应该保持为位置参数。我们可以遵循*使用*分隔符强制关键字参数*的方法。
- en: 'We might change the basic haversine function to look like this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会将基本的haversine函数更改为这样：
- en: '[PRE47]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We inserted the `*` to separate parameters into two groups. The first group
    can have arguments supplied either by position or by keyword. The second group,
    – `R` , in this case – must be given by keyword.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们插入了`*`来将参数分成两组。第一组可以通过位置或关键字提供参数。第二组，- 在这种情况下是`R` - 必须通过关键字给出。
- en: 'We can then write a wrapper function the will apply all of the positional arguments
    unmodified. It will supply the additional keyword argument as part of the long-running
    context:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以编写一个包装函数，它将应用所有的位置参数而不加修改。它将作为长期上下文的一部分提供额外的关键字参数：
- en: '[PRE48]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We've the `*args` construct in the function declaration to accept all positional
    argument values in a single tuple, `args` . We've also `*args` when evaluating
    the `haversine()` function to expand the tuple into all of the positional argument
    values to this function.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数声明中使用了`*args`构造来接受一个单独的元组`args`中的所有位置参数值。当评估`haversine()`函数时，我们还使用了`*args`来将元组扩展为该函数的所有位置参数值。
- en: Creating a partial function with keyword parameters
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用关键字参数创建一个偏函数
- en: 'A partial function is a function which has some of the argument values supplied.
    When we evaluate a partial function, we''re mixing the previously supplied parameters
    with additional parameters. One approach is to use keyword parameters, similar
    to wrapping a function:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 偏函数是一个有一些参数值被提供的函数。当我们评估一个偏函数时，我们将之前提供的参数与额外的参数混合在一起。一种方法是使用关键字参数，类似于包装一个函数：
- en: 'We can follow the *Forcing keyword-only arguments with the * separator* recipe.
    We might change the basic haversine function to look like this:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以遵循*使用*分隔符强制关键字参数*的方法。我们可能会将基本的haversine函数更改为这样：
- en: '[PRE49]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a partial function using the keyword parameter:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用关键字参数创建一个偏函数：
- en: '[PRE50]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `partial()` function builds a new function from an existing function and
    a concrete set of argument values. The `nm_haversine()` function has a specific
    value for `R` provided when the partial was built.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial()`函数从现有函数和一组具体的参数值中构建一个新函数。`nm_haversine()`函数在构建偏函数时提供了`R`的特定值。'
- en: 'We can use this like we''d use any other function:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像使用任何其他函数一样使用它：
- en: '[PRE51]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We get an answer in nautical miles, allowing us to do boating-related calculations
    without having to patiently check that each time we used the `haversine()` function
    it had `R=NM` as an argument.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个海里的答案，这样我们就可以进行与船只相关的计算，而不必每次使用`haversine()`函数时都要耐心地检查它是否有`R=NM`作为参数。
- en: Creating a partial function with positional parameters
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用位置参数创建一个偏函数
- en: A partial function is a function which has some of the argument values supplied.
    When we evaluate a partial function, we're supplying additional parameters. An
    alternative approach is to use positional parameters.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数是一个具有一些参数值的函数。当我们评估部分函数时，我们正在提供额外的参数。另一种方法是使用位置参数。
- en: 'If we try to use `partial()` with positional arguments, we''re constrained
    to providing the leftmost parameter values in the partial definition. This leads
    us to think of the first few arguments to a function as candidates for being hidden
    by a partial function or a wrapper:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用带有位置参数的`partial()`，我们只能在部分定义中提供最左边的参数值。这让我们想到函数的前几个参数可能被部分函数或包装器隐藏。
- en: 'We might change the basic `haversine` function to look like this:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可能会将基本的`haversine`函数更改为这样：
- en: '[PRE52]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create a partial function using the positional parameter:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用位置参数创建一个部分函数：
- en: '[PRE53]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `partial()` function builds a new function from an existing function and
    a concrete set of argument values. The `nm_haversine()` function has a specific
    value for the first parameter, `R` , provided when the partial was built.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial()`函数从现有函数和具体的参数值集构建一个新的函数。`nm_haversine()`函数在构建部分时为第一个参数`R`提供了一个特定的值。'
- en: 'We can use this like we''d use any other function:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像使用其他函数一样使用这个：
- en: '[PRE54]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We get an answer in nautical miles, allowing us to do boating-related calculations
    without having to patiently check that each time we used the `haversine()` function
    it had `R=NM` as an argument.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个海里的答案，这样我们就可以进行与航海有关的计算，而不必耐心地检查每次使用`haversine()`函数时是否有`R=NM`作为参数。
- en: How it works...
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The partial function is—essentially—identical to the wrapper function. While
    it saves us a line of code, it has a more important purpose. We can build partials
    freely in the middle of other, more complex pieces of a program. We don't need
    to use a `def` statement for this.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数本质上与包装函数相同。虽然它为我们节省了一行代码，但它有一个更重要的目的。我们可以在程序的其他更复杂的部分中自由构建部分函数。我们不需要使用`def`语句。
- en: 'Note that creating partial functions leads to a few additional considerations
    when looking at the order for positional parameters:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在查看位置参数的顺序时，创建部分函数会引起一些额外的考虑：
- en: When we use `*args` , it must be last. This is a language requirement. It means
    that the parameters in front of this can be identified specifically, all the rest
    become anonymous and can be passed – *en masse* – to the wrapped function.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用`*args`时，它必须是最后一个。这是语言要求。这意味着在它前面的参数可以被具体识别，其余的都变成了匿名的，并且可以被一次性传递给包装函数。
- en: The leftmost positional parameters are easiest to provide a value when creating
    a partial function.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建部分函数时，最左边的位置参数最容易提供一个值。
- en: 'These two considerations lead us to look at the leftmost argument as being
    more of a context: these are expected to change rarely. The rightmost parameters
    provide details and change frequently.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个考虑让我们将最左边的参数视为更多的上下文：这些预计很少改变。最右边的参数提供细节并经常改变。
- en: There's more...
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There''s a third way to wrap a function—we can also build a `lambda` object.
    This will also work:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第三种包装函数的方法——我们也可以构建一个`lambda`对象。这也可以工作：
- en: '[PRE55]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Notice that a `lambda` object is a function that''s been stripped of name and
    body. It''s reduced to just two essentials:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`lambda`对象是一个被剥离了名称和主体的函数。它被简化为只有两个要素：
- en: The parameter list
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数列表
- en: A single expression that is the result
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单一的表达式是结果
- en: A `lambda` cannot have any statements. If we need statements, we need to use
    the `def` statement to create a definition that includes a name and a body with
    multiple statements.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda`不能有任何语句。如果我们需要语句，我们需要使用`def`语句来创建一个包含名称和多个语句的定义。'
- en: See also
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: We'll also look at further extending this design in the *Writing reusable scripts
    with the script library switch * recipe
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将在*使用脚本库开关编写可重用脚本*的配方中进一步扩展这个设计
- en: Writing clear documentation strings with RST markup
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RST标记编写清晰文档字符串
- en: How can we clearly document what a function does? Can we provide examples? Of
    course we can, and we really should. In the *Including descriptions and documentation*
     in [Chapter 2](text00027.html#page "Chapter 2. Statements and Syntax") , *Statements
    and Syntax* and *Writing clear documentation strings with RST markup*  recipes,
    we looked at some essential documentation techniques. Those recipes introduced
    **ReStructuredText** ( **RST** ) for module docstrings.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何清楚地记录函数的作用？我们可以提供例子吗？当然可以，而且我们真的应该。在[第2章](text00027.html#page "第2章。语句和语法")中的*包括描述和文档*，*语句和语法*和*使用RST标记编写清晰文档字符串*的配方中，我们看到了一些基本的文档技术。这些配方介绍了**ReStructuredText**（**RST**）用于模块文档字符串。
- en: We'll extend those techniques to write RST for function docstrings. When we
    use a tool such as Sphinx, the docstrings from our function will become elegant-looking
    documentation that describes what our function does.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展这些技术，为函数文档字符串编写RST。当我们使用Sphinx等工具时，我们函数的文档字符串将成为描述函数作用的优雅文档。
- en: Getting ready
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the *Forcing keyword-only arguments with the * separator* recipe, we looked
    at a function that had a large number of parameters and another function that
    had only two parameters.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用*分隔符强制关键字参数*的配方中，我们看到了一个具有大量参数的函数和另一个只有两个参数的函数。
- en: 'Here''s a slightly different version of one of those functions, `Twc()` :'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个稍微不同版本的`Twc()`函数：
- en: '[PRE56]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We need to annotate this function with some more complete documentation.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用更完整的文档来注释这个函数。
- en: Ideally, we've got Sphinx installed to see the fruits of our labor. See [http://www.sphinx-doc.org](http://www.sphinx-doc.org)
    .
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们已经安装了Sphinx来看我们的劳动成果。请参阅[http://www.sphinx-doc.org](http://www.sphinx-doc.org)。
- en: How to do it...
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll generally write the following things for a function description:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们会为函数描述写以下内容：
- en: Synopsis
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概要
- en: Description
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述
- en: Parameters
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数
- en: Returns
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回
- en: Exceptions
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常
- en: Test cases
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试案例
- en: Anything else that seems meaningful
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他看起来有意义的东西
- en: 'Here''s how we''ll create nice documentation for a function. We can apply a
    similar recipe for a function, or even a module:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何为一个函数创建良好文档的方法。我们可以应用类似的方法来为一个函数，甚至一个模块创建文档：
- en: 'Write the synopsis: A proper subject isn''t required—we don''t write *This
    function computes...* ; we start with *Computes...* . There''s no reason to overstate
    the context:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写概要：不需要一个适当的主题——我们不写 *这个函数计算...* ；我们从 *计算...* 开始。没有理由过分强调上下文：
- en: '[PRE57]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Write the description with details:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用详细描述写：
- en: '[PRE58]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this case, we used a little block of typeset math in our description. The
    `:math:` interpreted text role uses LaTeX math typesetting. If you have LaTeX
    installed, Sphinx will use that to prepare a little `.png` file with the math.
    If you want, Sphinx can use MathJax or JSMath to do JavaScript math typesetting
    instead of creating a `.png` file.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在描述中使用了一小块排版数学。`:math:` 解释文本角色使用LaTeX数学排版。如果你安装了LaTeX，Sphinx将使用它来准备一个带有数学的小`.png`文件。如果你愿意，Sphinx可以使用MathJax或JSMath来进行JavaScript数学排版，而不是创建一个`.png`文件。
- en: 'Describe the parameters: For positional parameters, it''s common to use `:param
    name: description` . Sphinx will tolerate a number of variations, but this is
    common.'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '描述参数：对于位置参数，通常使用 `:param name: description` 。Sphinx将容忍许多变化，但这是常见的。'
- en: 'For parameters which must be keywords, it''s common to use `:key name: description`
    . The word `key` instead of `param` shows that it''s a keyword-only parameter:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '对于必须是关键字的参数，通常使用 `:key name: description` 。使用 `key` 而不是 `param` 显示它是一个仅限关键字的参数：'
- en: '[PRE59]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'There are two ways to include type information:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种包含类型信息的方法：
- en: Using Python 3 type hints
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python 3类型提示
- en: Using RST `:type name:` markup
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RST `:type name:` 标记
- en: We generally don't use both techniques. Type hints are a better idea than the
    RST `:type:` markup.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常不会同时使用这两种技术。类型提示比RST `:type:` 标记更好。
- en: 'Describe the return value using `:returns:` :'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `:returns:` 描述返回值：
- en: '[PRE60]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'There are two ways to include return type information:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种包含返回类型信息的方法：
- en: Using Python 3 type hints
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python 3类型提示
- en: Using RST `:rtype:` markup
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RST `:rtype:` 标记
- en: We generally don't use both techniques. The RST `:rtype:` markup has been superseded
    by type hints.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常不会同时使用这两种技术。RST `:rtype:` 标记已被类型提示取代。
- en: 'Identify the important exceptions that might be raised. Use the `:raises exception:`
    reason markup. There are several possible variations, but `:raises exception:`
    seems to be most popular:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定可能引发的重要异常。使用 `:raises exception:` 原因标记。有几种可能的变化，但 `:raises exception:` 似乎最受欢迎：
- en: '[PRE61]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Include a doctest test case, if possible:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可能的话，包括一个doctest测试用例：
- en: '[PRE62]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Write any additional notes and helpful information. We could add the following
    to the docstring:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写任何其他附加说明和有用信息。我们可以将以下内容添加到文档字符串中：
- en: '[PRE63]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We've included a reference to a Wikipedia page that summarizes wind-chill calculations
    and has links to more detailed information.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了一个维基百科页面的参考，该页面总结了风冷计算并链接到更详细的信息。
- en: We've also included a `.. math::` directive with the LaTeX formula that's used
    in the function. This will typeset nicely, providing a very readable version of
    the code.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包括了一个带有函数中使用的LaTeX公式的 `.. math::` 指令。这将排版得很好，提供了代码的一个非常可读的版本。
- en: How it works...
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: For more information on docstrings, see the *Including descriptions and documentation*
     recipe in [Chapter 2](text00027.html#page "Chapter 2. Statements and Syntax")
    , *Statements and Syntax* . While Sphinx is popular, it isn't the only tool that
    can create documentation from the docstring comments. The pydoc utility that's
    part of the Python Standard Library can also produce good looking documentation
    from the docstring comments.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 有关文档字符串的更多信息，请参见[第2章](text00027.html#page "第2章。语句和语法")中的*包括描述和文档* 配方，*语句和语法*。虽然Sphinx很受欢迎，但它并不是唯一可以从文档字符串注释中创建文档的工具。Python标准库中的pydoc实用程序也可以从文档字符串注释中生成漂亮的文档。
- en: The Sphinx tool relies on the core features of RST processing in the `docutils`
    package. See [https://pypi.python.org/pypi/docutils](https://pypi.python.org/pypi/docutils)
    for more information.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx工具依赖于`docutils`包中RST处理的核心功能。有关更多信息，请参见[https://pypi.python.org/pypi/docutils](https://pypi.python.org/pypi/docutils)。
- en: The RST rules are relatively simple. Most of the additional features in this
    recipe leverage the *interpreted text roles* of RST. Each of our `:param T:` ,
    `:returns:` , and `:raises ValueError:` constructs is a text role. The RST processor
    can use this information to decide on style and structure for the content. The
    style usually includes a distinctive font. The context might be an HTML **definition
    list** format.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: RST规则相对简单。这个配方中的大多数附加功能都利用了RST的*解释文本角色*。我们的每个 `:param T:` 、 `:returns:` 和 `:raises
    ValueError:` 结构都是一个文本角色。RST处理器可以使用这些信息来决定内容的样式和结构。样式通常包括一个独特的字体。上下文可能是HTML **定义列表**格式。
- en: There's more...
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In many cases, we'll also need to include cross-references among functions and
    classes. For example, we might have a function that prepares a wind-chill table.
    This function might have documentation that includes a reference to the `Twc()`
    function.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们还需要在函数和类之间包含交叉引用。例如，我们可能有一个准备风冷表的函数。这个函数可能有包含对 `Twc()` 函数的引用的文档。
- en: 'Sphinx will generate these cross-references using a special `:func:` text role:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx将使用特殊的 `:func:` 文本角色生成这些交叉引用：
- en: '[PRE64]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We've used the `:func:`Twc`` to cross-reference one function in the RST documentation
    for a different function. Sphinx will turn these into proper hyperlinks.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在RST文档中使用了 `:func:`Twc`` 来交叉引用一个函数。Sphinx将把这些转换为适当的超链接。
- en: See also
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the  *Including descriptions and documentation* and *Writing better RST
    markup in docstrings*  recipes in [Chapter 2](text00027.html#page "Chapter 2. Statements
    and Syntax") , *Statements and Syntax* ,  for other recipes that show how RST
    works
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关RST工作的其他配方，请参见[第2章](text00027.html#page "第2章。语句和语法")中的*包括描述和文档* 和*在文档字符串中编写更好的RST标记*
    配方。
- en: Designing recursive functions around Python's stack limits
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 围绕Python的堆栈限制设计递归函数
- en: 'Some functions can be defined clearly and succinctly using a recursive formula.
    There are two common examples:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数可以使用递归公式清晰而简洁地定义。有两个常见的例子：
- en: 'The factorial function:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘函数：
- en: '![Designing recursive functions around Python''s stack limits](Image00006.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![围绕Python的堆栈限制设计递归函数](Image00006.jpg)'
- en: 'The rule for computing Fibonacci numbers:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 计算斐波那契数的规则：
- en: '![Designing recursive functions around Python''s stack limits](Image00007.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![围绕Python的堆栈限制设计递归函数](Image00007.jpg)'
- en: Each of these involves a case that has a simple defined value and a case that
    involves computing the function's value based on other values of the same function.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 其中每个都涉及一个具有简单定义值的情况，以及涉及根据同一函数的其他值计算函数值的情况。
- en: The problem we have is that Python imposes a limitation on the upper limit for
    these kinds of recursive function definitions. While Python's integers can easily
    represent *1000!* , the stack limit prevents us from doing this casually.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们面临的问题是，Python对这种递归函数定义的上限施加了限制。虽然Python的整数可以轻松表示*1000!*，但堆栈限制阻止我们随意这样做。
- en: 'Computing *F[n]* Fibonacci numbers involves an additional problem. If we''re
    not careful, we''ll compute a lot of values more than once:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 计算*F[n]*斐波那契数涉及一个额外的问题。如果我们不小心，我们会计算很多值超过一次：
- en: '*F[5] = F[4] + F[3]*'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '*F[5] = F[4] + F[3]*'
- en: '*F[5] = (F[3] + F[2] ) + (F[2] + F[1] )*'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '*F[5] = (F[3] + F[2] ) + (F[2] + F[1] )*'
- en: And so on.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。
- en: To compute *F[5]* , we'll compute *F[3]* twice, and *F[2]* three times. This
    is extremely costly.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算*F[5]*，我们将计算*F[3]*两次，*F[2]*三次。这是非常昂贵的。
- en: Getting ready
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Many recursive function definitions follow the pattern set by the factorial
    function. This is sometimes called **tail recursion** because the recursive case
    can be written at the tail of the function body:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 许多递归函数定义遵循阶乘函数设定的模式。这有时被称为**尾递归**，因为递归情况可以写在函数体的尾部：
- en: '[PRE65]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The last expression in the function refers back to the function with a different
    argument value.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中的最后一个表达式引用了具有不同参数值的函数。
- en: We can restate this, avoiding the recursion limits in Python.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新陈述这一点，避免Python中的递归限制。
- en: How to do it...
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'A tail recursion can also be described as a **reduction** . We''re going to
    start with a collection of values, and then reduce them to a single value:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归也可以被描述为**归约**。我们将从一组值开始，然后将它们减少到一个单一的值：
- en: 'Expand the rule to show all of the details:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展规则以显示所有细节：
- en: '*n! = n* x *(n-* 1 *)* × *(n-* 2 *)* × *(n-* 3 *)...* × 1'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '*n! = n* x *(n-* 1 *)* × *(n-* 2 *)* × *(n-* 3 *)...* × 1'
- en: 'Write a loop that enumerates all the values:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个循环，枚举所有的值：
- en: '*N =* { *n, n-* 1 *, n-* 2 *, ...,* 1}In Python, it''s simply this: `range(1,
    n+1)` . In some cases, though, we might have to apply some transformation function
    to the base values:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '*N =* { *n, n-* 1 *, n-* 2 *, ...,* 1}在Python中，它就是这样的：`range(1, n+1)`。然而，在某些情况下，我们可能需要对基本值应用一些转换函数：'
- en: '*N =* { *f(i):* 1 *≤ i < n* +1}If we had to perform some kind of transformation,
    it might look like this in Python:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '*N =* { *f(i):* 1 *≤ i < n* +1}如果我们必须执行某种转换，它在Python中可能看起来像这样：'
- en: '[PRE66]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Incorporate the reduction function. In this case, we're computing a large product,
    using multiplication. We can summarize this using ![How to do it...](Image00008.jpg)   *x*  notation.
    For this example, we're only imposing a simple boundary on the values computed
    in the product:![How to do it...](Image00009.jpg)
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整合归约函数。在这种情况下，我们正在计算一个大的乘积，使用乘法。我们可以使用 ![如何做...](Image00008.jpg)   *x*  表示这一点。对于这个例子，我们只对产品中计算的值施加了一个简单的边界:![如何做...](Image00009.jpg)
- en: 'Here''s the implementation in Python:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Python中的实现：
- en: '[PRE67]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can restate this into a solution like this. This uses higher-level functions:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个重新陈述为这样的解决方案。这使用了更高级的函数：
- en: '[PRE68]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This works nicely. We've optimized the first solution to combine the `prod()`
    and `fact()` functions into a single function. It turns out that doing that optimization
    doesn't actually shave much time off the operation.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好地起作用。我们已经优化了将`prod()`和`fact()`函数合并为一个函数的第一个解决方案。事实证明，进行这种优化实际上并没有减少操作的时间。
- en: 'Here are the comparisons, run using the `timeit` module:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`timeit`模块运行的比较：
- en: '| **Simple** | **4.7766** |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| **简单** | **4.7766** |'
- en: '| Optimized | 4.6901 |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| 优化 | 4.6901 |'
- en: This is in the order of a 2% performance improvement. Not a significant change.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个2%的性能改进。并不是一个显著的改变。
- en: Note that the Python 3 `range` object is lazy—it doesn't create a big `list`
    object, it returns values as they are requested by the `prod()` function. This
    is different from Python 2, where the `range()` function eagerly created a big
    `list` object with all of the values, and the `xrange()` function was lazy.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Python 3的`range`对象是惰性的——它不创建一个大的`list`对象，它会在`prod()`函数请求时返回值。这与Python 2不同，Python
    2中的`range()`函数急切地创建一个包含所有值的大的`list`对象，而`xrange()`函数是惰性的。
- en: How it works...
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A tail recursion definition is handy because it's short and easy to remember.
    Mathematicians like this because it can help clarify what a function means.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归定义很方便，因为它既简短又容易记忆。数学家喜欢这个，因为它可以帮助澄清函数的含义。
- en: 'Many static, compiled languages are optimized in a manner similar to the technique
    we''ve shown. There are two parts to this optimization:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 许多静态的编译语言都以类似于我们展示的技术进行了优化。这种优化有两个部分：
- en: 'Use relatively simple algebraic rules to reorder the statements so that the
    recursive clause is actually last. The `if` clauses can be reorganized into a
    different physical order so that the `return fact(n-1) * n` is last. This rearrangement
    is necessary for code organized like this:'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相对简单的代数规则重新排列语句，使递归子句实际上是最后一个。`if`子句可以重新组织成不同的物理顺序，以便`return fact(n-1) * n`是最后一个。这种重新排列对于这样组织的代码是必要的：
- en: '[PRE69]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Inject a special instruction into the virtual machine''s byte code—or the actual
    machine code—that re-evaluates the function without creating a new stack frame.
    Python doesn''t have this feature. In effect, this special instruction transforms
    the recursion into a kind of `while` statement:'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个特殊指令注入到虚拟机的字节码中 - 或者实际的机器码中 - 重新评估函数，而不创建新的堆栈帧。Python没有这个特性。实际上，这个特殊指令将递归转换成一种`while`语句：
- en: '[PRE70]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This purely mechanical transformation leads to rather ugly code. In Python,
    it may also be remarkably slow. In other languages, the presence of the special
    byte code instruction will lead to code that runs quickly.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这种纯机械的转换会导致相当丑陋的代码。在Python中，它也可能非常慢。在其他语言中，特殊的字节码指令的存在将导致代码运行速度快。
- en: We prefer not to do this kind of mechanical optimization. First, it leads to
    ugly code. More importantly – in Python – it tends to create code that's actually
    slower than the alternative developed above.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不喜欢做这种机械优化。首先，它会导致丑陋的代码。更重要的是 - 在Python中 - 它往往会创建比上面开发的替代方案更慢的代码。
- en: There's more...
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The Fibonacci problem involves two recursions. If we write it naively as a
    recursion, it might look like this:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契问题涉及两个递归。如果我们将其简单地写成递归，可能会像这样：
- en: '[PRE71]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: It's difficult to do a simple mechanical transformation into a tail recursion.
    A problem with multiple recursions like this requires some more careful design.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个简单的机械转换成尾递归是困难的。像这样具有多个递归的问题需要更加仔细的设计。
- en: 'We have two ways to reduce the computation complexity of this:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法来减少这个计算复杂度：
- en: Use memoization
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用记忆化
- en: Restate the problem
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新阐述问题
- en: The **memoization** technique is easy to apply in Python. We can use the `functools.lru_cache()`
    as a decorator. This function will cache previously computed values. This means
    that we'll only compute a value once; every other time, the `lru_cache` will return
    the previously computed value.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '**记忆化**技术在Python中很容易应用。我们可以使用`functools.lru_cache()`作为装饰器。这个函数将缓存先前计算过的值。这意味着我们只计算一次值；每一次，`lru_cache`都会返回先前计算过的值。'
- en: 'It looks like this:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来像这样：
- en: '[PRE72]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Adding a decorator is a simple way to optimize a more complex multi-way recursion.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个装饰器是优化更复杂的多路递归的简单方法。
- en: 'Restating the problem means looking at it from a new perspective. In this case,
    we can think of computing all Fibonacci numbers up to and including *F[n]* . We
    only want the last value in this sequence. We compute all the intermediates because
    it''s more efficient to do it that way. Here''s a generator function that does
    this:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 重新阐述问题意味着从新的角度来看待它。在这种情况下，我们可以考虑计算所有斐波那契数，直到*F[n]*。我们只想要这个序列中的最后一个值。我们计算所有的中间值，因为这样做更有效。这是一个执行此操作的生成器函数：
- en: '[PRE73]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This function is an infinite iteration of Fibonacci numbers. It uses Python's
    `yield` so that it emits values in a lazy fashion. When a client function uses
    this iterator, the next number in the sequence is computed as each number is consumed.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是斐波那契数的无限迭代。它使用Python的`yield`，以便以懒惰的方式发出值。当客户函数使用这个迭代器时，每个数字被消耗时，序列中的下一个数字被计算。
- en: 'Here''s a function that consumes the values and also imposes an upper limit
    on the otherwise infinite iterator:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数，它消耗值，并对否则无限的迭代器施加一个上限：
- en: '[PRE74]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This function consumes each value from the `fibo_iter()` iterator. When the
    desired number has been reached, the `break` statement ends the `for` statement.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从`fibo_iter()`迭代器中消耗每个值。当达到所需的数字时，`break`语句结束`for`语句。
- en: When we look back at the *Designing a while statement which terminates properly*
    recipe in [Chapter 2](text00027.html#page "Chapter 2. Statements and Syntax")
    , *Statements and Syntax* , we noted that a `while` statement with a `break` may
    have multiple reasons for terminating. In this example, there is only one way
    to end the `for` statement.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回顾[第2章](text00027.html#page "第2章。语句和语法")中的*设计一个正确终止的while语句*配方时，我们注意到一个带有`break`的`while`语句可能有多个终止的原因。在这个例子中，结束`for`语句只有一种方法。
- en: We can always assert that `i == n` at the end of the loop. This simplifies the
    design of the function.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以始终断言在循环结束时`i == n`。这简化了函数的设计。
- en: See also
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Designing a while statement which terminates properly* recipe in [Chapter
    2](text00027.html#page "Chapter 2. Statements and Syntax") , *Statements and Syntax*
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第2章](text00027.html#page "第2章。语句和语法")中的*设计一个正确终止的while语句*配方，*语句和语法*
- en: Writing reusable scripts with the script library switch
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用脚本库开关编写可重用脚本
- en: It's common to create small scripts which we want to combine into a larger script.
    We don't want to copy and paste the code. We want to leave the working code in
    one file and use it in multiple places. Often we want to combine elements from
    multiple files to create more sophisticated scripts.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会创建一些小脚本，我们希望将它们组合成一个更大的脚本。我们不想复制和粘贴代码。我们希望将工作代码留在一个文件中，并在多个地方使用它。通常，我们希望从多个文件中组合元素，以创建更复杂的脚本。
- en: The problem we have is that when we import a script it actually starts running.
    This is generally not what we expect when we import a script so that we can reuse
    it.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的问题是，当我们导入一个脚本时，它实际上开始运行。这通常不是我们导入一个脚本以便重用它时的预期行为。
- en: How can we import the functions (or classes) from a file without having the
    script start doing something?
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何导入文件中的函数（或类），而不让脚本开始执行某些操作？
- en: Getting ready
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: Let's say that we have a handy implementation of the haversine distance function
    called `haversine()` , and it's in a file named `ch03_r08.py` .
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个方便的haversine距离函数的实现，名为`haversine()`，并且它在一个名为`ch03_r08.py`的文件中。
- en: 'Initially, the file might look like this:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，文件可能是这样的：
- en: '[PRE75]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We've omitted the body of the `haversine()` function, showing only `... and
    more...` , since it's shown in the *Picking an order for parameters based on partial
    functions*  recipe. We've focused on the context in which the function is in a
    Python script that also opens a file, `wapypoints.csv` , and does some processing
    on that file.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了`haversine()`函数的主体，只显示了`...和更多...`，因为它在*基于部分函数选择参数顺序*的配方中有所展示。我们专注于函数在Python脚本中的上下文，该脚本还打开一个名为`wapypoints.csv`的文件，并对该文件进行一些处理。
- en: How can we import this module without it printing a display of distances between
    waypoints in our `waypoints.csv` file?
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何导入这个模块，而不让它打印出`waypoints.csv`文件中航点之间的距离？
- en: How to do it...
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Python scripts can be simple to write. Indeed, it''s often too simple to create
    a working script. Here''s how we transform a simple script into a reusable library:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: Python脚本可以很容易编写。事实上，创建一个可工作的脚本通常太简单了。以下是我们如何将一个简单的脚本转换为可重用的库：
- en: 'Identify the statements that do the work of the script: we''ll distinguish
    between *definition* and *action* . Statements such as `import` , `def` , and
    `class` are clearly definitional—they support the work but they don''t do the
    work. Almost all other statements take action.'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别脚本的工作语句：我们将区分*定义*和*动作*。例如`import`，`def`和`class`等语句显然是定义性的——它们支持工作但并不执行工作。几乎所有其他语句都是执行动作的。
- en: In our example, we have four assignment statements that are more definition
    than action. The distinction is entirely one of intent. All statements, by definition,
    take an action. These actions, though, are more like the action of the `def` statement
    than they are like the action of the `with` statement later in the script.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，有四个赋值语句更多地是定义而不是动作。区别完全是出于意图。所有语句，根据定义，都会执行一个动作。不过，这些动作更像是`def`语句的动作，而不像脚本后面的`with`语句的动作。
- en: 'Here are the generally definitional statements:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通常的定义性语句：
- en: '[PRE76]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The rest of the statements clearly take an action toward producing the printed
    results.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的语句明显是朝着产生打印结果的动作。
- en: 'Wrap the actions into a function:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将动作封装成一个函数：
- en: '[PRE77]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Where possible, extract literals and make them into parameters. This is often
    a simple movement of the literal to a parameter with a default value.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在可能的情况下，提取文字并将其转换为参数。这通常是将文字移到具有默认值的参数中。
- en: 'From this:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始：
- en: '[PRE78]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To this:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里：
- en: '[PRE79]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This makes the script reusable because the path is now a parameter instead of
    an assumption.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得脚本可重用，因为路径现在是一个参数而不是一个假设。
- en: 'Include the following as the only high-level action statements in the script
    file:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容作为脚本文件中唯一的高级动作语句包括：
- en: '[PRE80]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We've packaged the action of the script as a function. The top-level action
    script is now wrapped in an `if` statement so that it isn't executed during import.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将脚本的动作封装为一个函数。顶层动作脚本现在被包裹在一个`if`语句中，以便在导入时不被执行。
- en: How it works...
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The most important rule for Python is that an `import` of a module is essentially
    the same as running the module as a script. The statements in the file are executed
    in order from top to bottom.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: Python的最重要规则是，导入模块实质上与运行模块作为脚本是一样的。文件中的语句按顺序从上到下执行。
- en: When we import a file, we're generally interested in executing the `def` and
    `class` statements. We might be interested in some assignment statements.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们导入一个文件时，通常我们对执行`def`和`class`语句感兴趣。我们可能对一些赋值语句感兴趣。
- en: 'When Python runs a script, it sets a number of built-in special variables.
    One of these is `__name__` . This variable has two different values, depending
    on the context in which the file is being executed:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python运行一个脚本时，它设置了一些内置的特殊变量。其中之一是`__name__`。这个变量有两个不同的值，取决于文件被执行的上下文：
- en: 'The top-level script, executed from the command line: In this case, the value
    of the built-in special name of `__name__` is set to `__main__` .'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行执行的顶层脚本：在这种情况下，内置特殊名称`__name__`的值设置为`__main__`。
- en: 'A file being executed because of an import statement: In this case, the value
    of `__name__` is the name of the module being created.'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于导入语句而执行的文件：在这种情况下，`__name__`的值是正在创建的模块的名称。
- en: The standard name of `__main__` may seem a little odd at first. Why not use
    the filename in all cases? This special name is assigned because a Python script
    can be read from one of many sources. It can be a file. Python can also be read
    from the `stdin` pipeline, or it can be provided on the Python command line using
    the `-c` option.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '`__main__`的标准名称一开始可能有点奇怪。为什么不在所有情况下使用文件名？这个特殊名称是被分配的，因为Python脚本可以从多个来源之一读取。它可以是一个文件。Python也可以从`stdin`管道中读取，或者可以在Python命令行中使用`-c`选项提供。'
- en: When a file is being imported, however, the value of `__name__` is set to the
    name of the module. It will not be `__main__` . In our example, the value `__name__`
    during `import` processing will be `ch03_r08` .
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当一个文件被导入时，`__name__`的值被设置为模块的名称。它不会是`__main__`。在我们的例子中，`import`处理期间`__name__`的值将是`ch03_r08`。
- en: There's more...
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can now build useful work around a reusable library. We might make several
    files that look like this:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以围绕一个可重用的库构建有用的工作。我们可能会创建几个看起来像这样的文件：
- en: 'File `trip_1.py` :'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`trip_1.py`：
- en: '[PRE81]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Or perhaps something even more complex:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 或者甚至更复杂一些：
- en: 'File `all_trips.py` :'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`all_trips.py`：
- en: '[PRE82]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The goal is to decompose a practical solution into two collections of features:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是将实际解决方案分解为两个特性集合：
- en: The definition of classes and functions
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和函数的定义
- en: A very small action-oriented script that uses the definitions to do useful work
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个非常小的面向行动的脚本，使用定义来进行有用的工作
- en: To get to this goal, we'll often start with a script that conflates both sets
    of features. This kind of script can be viewed as a **spike solution** . Our spike
    solution should evolve towards a more refined solution as soon as we're sure that
    it works.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个目标，我们经常会从一个混合了两组特性的脚本开始。这种脚本可以被视为一个**尖峰解决方案**。我们的尖峰解决方案应该在我们确信它有效之后逐渐演变成一个更精细的解决方案。
- en: A *spike* or *piton* is a piece of removable mountain-climbing gear that doesn't
    get us any higher on the route, but it enables us to climb safely.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 尖峰或者悬崖钉是一种可移动的登山装备，它并不能让我们在路线上爬得更高，但它能让我们安全地攀登。
- en: See also
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , we'll look at class definitions. These are
    another kind of widely used definitional statement.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第6章](text00070.html#page "第6章 类和对象的基础")中，*类和对象的基础*，我们将看一下类定义。这是另一种广泛使用的定义性语句。
