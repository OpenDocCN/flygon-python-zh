- en: Python Objects, Types, and Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python对象、类型和表达式
- en: Data structures and algorithms are two of the core elements of a large and complex
    software project. They are a systematic way of storing and organizing data in
    software so that it can be used efficiently. Python has efficient high-level data
    structures and an effective object-oriented programming language. Python is the
    language of choice for many advanced data tasks, for a very good reason. It is
    one of the easiest advanced programming languages to learn. Intuitive structures
    and semantics mean that for people who are not computer scientists, but maybe
    biologists, statisticians, or the directors of a start-up, Python is a  straightforward
    way to perform a wide variety of data tasks. It is not just a scripting language,
    but a full-featured, object-oriented programming language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构和算法是一个大型复杂软件项目的核心要素之一。它们是一种系统化的方式，用于在软件中存储和组织数据，以便能够高效地使用。Python具有高效的高级数据结构和有效的面向对象编程语言。Python是许多高级数据任务的首选语言，原因很充分。它是最容易学习的高级编程语言之一。直观的结构和语义意味着对于那些不是计算机科学家，但可能是生物学家、统计学家或初创公司的负责人来说，Python是执行各种数据任务的简单方式。它不仅仅是一种脚本语言，而是一种功能齐全的面向对象的编程语言。
- en: In Python, there are many useful data structures and algorithms built into the
    language. Also, because Python is an object-based language, it is relatively easy
    to create custom data objects. In this book, we will examine  Python's internal
    libraries and some of the external libraries, and we'll learn how to build your
    own data objects from first principles.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有许多有用的数据结构和算法内置在语言中。此外，由于Python是一种基于对象的语言，相对容易创建自定义数据对象。在本书中，我们将研究Python的内部库和一些外部库，并学习如何从头开始构建自己的数据对象。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Obtaining a general working knowledge of data structures and algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获得对数据结构和算法的一般工作知识
- en: Understanding core data types and their functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解核心数据类型及其功能
- en: Exploring the object-oriented aspects of the Python programming language
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Python编程语言的面向对象的方面
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The data structures and algorithms are presented using the Python programming
    language (version 3.7) in this book. This book does assume that you know Python.
    However, if you are a bit rusty, coming from another language, or do not know
    Python at all, don't worry—this first chapter should get you quickly up to speed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用Python编程语言（版本3.7）介绍数据结构和算法。本书假设您已经了解Python。但是，如果您有点生疏，来自其他语言，或者根本不了解Python，不用担心
    - 这一章应该能让您迅速掌握。
- en: The following is the GitHub link: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter01](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter01).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是GitHub链接：[https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter01](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter01)。
- en: If you are not familiar with Python, then visit [https://docs.python.org/3/tutorial/index.html](https://docs.python.org/3/tutorial/index.html),
    and you can also find the documentation at [https://www.python.org/doc/](https://www.python.org/doc/).
    These are all excellent resources for easily learning this programming language.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对Python不熟悉，请访问[https://docs.python.org/3/tutorial/index.html](https://docs.python.org/3/tutorial/index.html)，您也可以在[https://www.python.org/doc/](https://www.python.org/doc/)找到文档。这些都是很好的资源，可以轻松学习这种编程语言。
- en: Installing Python
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Python
- en: To install Python, we use the following method.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Python，我们使用以下方法。
- en: Python is an interpreted language, and statements are executed line by line.
     A programmer can typically write down the series of commands in a source code
    file. For Python, the source code is stored in a file with a `.py` file extension.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种解释性语言，语句是逐行执行的。程序员通常可以将一系列命令写在源代码文件中。对于Python，源代码存储在一个带有`.py`文件扩展名的文件中。
- en: 'Python is fully integrated and usually already installed on most of the Linux
    and Mac operating systems. Generally, the pre-installed Python version is 2.7\.
    You can check the version installed on the system using the following commands:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python通常已经完全集成并安装在大多数Linux和Mac操作系统上。通常，预安装的Python版本是2.7。您可以使用以下命令检查系统上安装的版本：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also install a different version of Python using the following commands
    on Linux:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下命令在Linux上安装不同版本的Python：
- en: Open the Terminal
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端
- en: '`sudo apt-get update`'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sudo apt-get update`'
- en: '`sudo apt-get install -y python3-pip`'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sudo apt-get install -y python3-pip`'
- en: '`pip3 install <package_name>`'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pip3 install <package_name>`'
- en: 'Python has to be installed on systems with Windows operating systems, as it
    is not pre-installed, unlike Linux/macOS. Any version of Python can be downloaded
    from this link: [https://www.python.org/downloads/](https://www.python.org/downloads/).
    You can download the software installer and run it—select Install for all users
    and then click on Next. You need to specify the location where you want to install
    the package, then click Next. After that, select the option Add Python to environment
    variables in the Customize Python dialog box, then just click Next again for final
    installation. When the installation is finished, you can confirm the installation
    by opening up Command Prompt and typing the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Python必须安装在Windows操作系统的系统上，因为它不像Linux/macOS那样预安装。可以从此链接下载Python的任何版本：[https://www.python.org/downloads/](https://www.python.org/downloads/)。您可以下载软件安装程序并运行它
    - 选择为所有用户安装，然后单击下一步。您需要指定要安装软件包的位置，然后单击下一步。之后，在自定义Python对话框中选择将Python添加到环境变量的选项，然后再次单击下一步进行最终安装。安装完成后，您可以通过打开命令提示符并输入以下命令来确认安装：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The latest stable Python version is Python 3.7.0\. The Python program can be
    executed by typing the following in the command line:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最新的稳定Python版本是Python 3.7.0。可以通过在命令行中输入以下内容来执行Python程序：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Understanding data structures and algorithms
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数据结构和算法
- en: 'Algorithms and data structures are the most fundamental concepts in computing.
    They are the main building blocks from which complex software is built. Having
    an understanding of these foundation concepts is extremely important in software
    design and this involves the following three characteristics:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 算法和数据结构是计算机中最基本的概念。它们是构建复杂软件的主要构建模块。理解这些基础概念在软件设计中是非常重要的，这涉及以下三个特征：
- en: How algorithms manipulate information contained within data structures
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法如何操作数据结构中包含的信息
- en: How data is arranged in memory
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3. 数据在内存中的排列方式
- en: What the performance characteristics of particular data structures are
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1. 特定数据结构的性能特征是什么
- en: In this book, we will examine the topic from several perspectives. Firstly,
    we will look at the fundamentals of the Python programming language from the perspective
    of data structures and algorithms. Secondly, it is important that we have the
    correct mathematical tools. We need to understand the fundamental concepts of
    computer science and for this we need mathematics. By taking a heuristic approach,
    developing some guiding principles means that, in general, we do not need any
    more than high school mathematics to understand the principles of these key ideas.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将从几个角度来审视这个话题。首先，我们将从数据结构和算法的角度来看Python编程语言的基础知识。其次，重要的是我们要有正确的数学工具。我们需要理解计算机科学的基本概念，为此我们需要数学。通过采取一种启发式的方法，制定一些指导原则意味着，一般来说，我们不需要比高中数学更多的知识来理解这些关键思想的原则。
- en: Another important aspect is an evaluation. Measuring the performance of algorithms
    requires an understanding of how the increase in data size affects operations
    on that data. When we are working on large datasets or real-time applications,
    it is essential that our algorithms and structures are as efficient as they can
    be.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要方面是评估。衡量算法的性能需要理解数据规模的增加如何影响数据的操作。当我们处理大型数据集或实时应用程序时，我们的算法和结构尽可能高效是至关重要的。
- en: Finally, we need a strong experimental design strategy. Being able to conceptually
    translate a real-world problem into the algorithms and data structures of a programming
    language involves being able to understand the important elements of a problem
    and a methodology for mapping these elements to programming structures.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个强大的实验设计策略。能够将现实世界的问题概念化为编程语言的算法和数据结构，需要能够理解问题的重要元素以及将这些元素映射到编程结构的方法。
- en: 'To better understand the importance of algorithmic thinking, let''s consider
    a real-world example. Imagine we are at an unfamiliar market and we are given
    the task of purchasing a list of items. We assume that the market is laid out
    randomly, each vendor sells a random subset of items, and some of these items
    may be on our list. Our aim is to minimize the price for each item we buy, as
    well as minimize the time spent at the market. One way to approach this problem
    is to write an algorithm like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解算法思维的重要性，让我们考虑一个现实世界的例子。假设我们在一个陌生的市场，我们被要求购买一些物品。我们假设市场是随机布局的，每个供应商销售一个随机子集的物品，其中一些物品可能在我们的清单上。我们的目标是尽量减少每个购买物品的价格，同时最小化在市场上花费的时间。解决这个问题的一种方法是编写以下类似的算法：
- en: 1\. Does the vendor have items that are on our list and the cost is less than
    a predicted cost for that item?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 供应商是否有我们清单上的物品，且成本低于该物品的预测成本？
- en: 2\. If yes, buy and remove from list; if no, move on to the next vendor.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 如果是，购买并从清单中删除；如果不是，继续下一个供应商。
- en: 3\. If no more vendors, end.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 如果没有更多的供应商，结束。
- en: This is a simple iterator, with a decision and an action. If we have to implement
    this using programming language, we would need data structures to define and store
    in memory both the list of items we want to buy and the list of items the vendor
    is selling. We would need to determine the best way of matching items in each
    list and we need some sort of logic to decide whether to purchase or not.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 如果我们必须使用编程语言来实现这个简单的迭代器，我们需要数据结构来定义和存储我们想要购买的物品清单和供应商正在销售的物品清单。我们需要确定最佳的匹配物品的方式，并且我们需要一些逻辑来决定是否购买。
- en: There are several observations that we can make regarding this algorithm. Firstly,
    since the cost calculation is based on a prediction, we don't know what the real
    cost is. As such, we do not purchase an item because we underpredicted the cost
    of the item, and we reach the end of the market with items remaining on our list.
    To handle this situation, we need an effective way of storing the data so that
    we can efficiently backtrack to the vendor with the lowest cost.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个算法，我们可以做出几点观察。首先，由于成本计算是基于预测的，我们不知道真实成本是多少。因此，我们不会购买物品，因为我们低估了物品的成本，导致我们在市场结束时仍有剩余物品。为了处理这种情况，我们需要一种有效的方式来存储数据，以便我们可以有效地回溯到成本最低的供应商。
- en: Also, we need to understand the time taken to compare items on our shopping
    list with the items being sold by each vendor. It is important because as the
    number of items on our shopping list, or the number of items sold by each vendor,
    increases, searching for an item takes a lot more time. The order in which we
    search through items and the shape of the data structures can make a big difference
    to the time it takes to do a search. Clearly, we would like to arrange our list
    as well as the order we visit each vendor in such a way that we minimize the search
    time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要了解比较我们购物清单上的物品与每个供应商出售的物品所花费的时间。这很重要，因为随着我们购物清单上物品的数量或每个供应商出售的物品数量的增加，搜索物品需要更多的时间。我们搜索物品的顺序和数据结构的形状可以对搜索所需的时间产生很大的影响。显然，我们希望安排我们的清单以及我们访问每个供应商的顺序，以便最小化搜索时间。
- en: Also, consider what happens when we change the buy condition to purchase at
    the *cheapest* price, not just the below-average predicted price. This changes
    the problem entirely. Instead of sequentially going from one vendor to the next,
    we need to traverse the market once and, with this knowledge, we can order our
    shopping list with regards to the vendors we want to visit.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，考虑一下当我们将购买条件更改为以*最便宜*的价格购买，而不仅仅是低于平均预测价格时会发生什么。这会完全改变问题。我们不再是顺序地从一个供应商到另一个供应商，而是需要遍历市场一次，并且有了这个知识，我们可以根据我们想要访问的供应商对我们的购物清单进行排序。
- en: Obviously, there are many more subtleties involved in translating a real-world
    problem into an abstract construct such as a programming language. For example,
    as we progress through the market, our knowledge of the cost of a product improves,
    so our predicted average-price variable becomes more accurate until, by the last
    stall, our knowledge of the market is perfect. Assuming any kind of backtracking
    algorithm incurs a cost, we can see cause to review our entire strategy. Conditions
    such as high price variability, the size and shape of our data structures, and
    the cost of backtracking all determine the most appropriate solution. The whole
    discussion clearly demonstrates the importance of data structures and algorithms
    in building a complex solution.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，将现实世界的问题转化为编程语言这样的抽象构造涉及许多微妙之处。例如，随着我们在市场上的进展，我们对产品成本的了解会提高，因此我们预测的平均价格变量会变得更加准确，直到在最后一个摊位，我们对市场的了解是完美的。假设任何形式的回溯算法都会产生成本，我们可以看到有理由重新审视整个策略。高价格波动、数据结构的大小和形状，以及回溯的成本等条件都决定了最合适的解决方案。整个讨论清楚地表明了数据结构和算法在构建复杂解决方案中的重要性。
- en: Python for data
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python用于数据
- en: Python has several built-in data structures, including lists, dictionaries,
    and sets, which we use to build customized objects. In addition, there are a number
    of internal libraries, such as collections and  math object, which  allow us to
    create more advanced structures as well as perform calculations on those structures.
    Finally, there are the external libraries such as those found in the SciPy packages.
    These allow us to perform a range of advanced data tasks such as logistic and
    linear regression, visualization, and mathematical calculations, such as operations
    on matrices and vectors. External libraries can be very useful for an out-of-the-box
    solution. However, we must also be aware that there is often a performance penalty
    compared to building customized objects from the ground up. By learning how to
    code these objects ourselves, we can target them to specific tasks, making them
    more efficient. This is not to exclude the role of external libraries and we will
    look at this in [Chapter 12](fff4acae-cc26-4b4c-a6d1-454703fa9e67.xhtml)*, Design
    Techniques and Strategies.*
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Python具有几种内置的数据结构，包括列表、字典和集合，我们可以用它们来构建定制对象。此外，还有一些内部库，如collections和math对象，它们允许我们创建更高级的结构，并对这些结构进行计算。最后，还有像SciPy包中发现的外部库。这些库允许我们执行一系列高级数据任务，如逻辑和线性回归、可视化和数学计算，比如矩阵和向量的操作。外部库对于开箱即用的解决方案非常有用。然而，我们也必须意识到，与从头开始构建定制对象相比，通常会有性能损失。通过学习如何自己编写这些对象，我们可以将它们针对特定任务，使它们更有效率。这并不排除外部库的作用，我们将在第12章《设计技术和策略》中讨论这一点。
- en: To begin, we will take an overview of some of the key language features that
    make Python such a great choice for data programming.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将概述一些关键的语言特性，这些特性使Python成为数据编程的绝佳选择。
- en: The Python environment
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python环境
- en: Python is one of the most popular and extensively used programming languages
    all over the world due to its **readability and flexibility**.A feature of the
    Python environment is its interactive console, allowing you to both use Python
    as a desktop-programmable calculator and also as an environment to write and test
    snippets of code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其可读性和灵活性，Python是全球最受欢迎和广泛使用的编程语言之一。Python环境的一个特点是其交互式控制台，允许您将Python用作桌面可编程计算器，也可以用作编写和测试代码片段的环境。
- en: The `read...evaluate...print` loop of the console is a very convenient way to
    interact with a larger code base, such as to run functions and methods or to create
    instances of classes. This is one of the major advantages of Python over compiled
    languages such as C/C++ or Java, where the `write...compile...test...recompile`
    cycle can increase development time considerably compared to Python's `read...evaluate...print`
    loop. Being able to type in expressions and get an immediate response can greatly
    speed up data science tasks.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台的`读取...评估...打印`循环是与更大代码库交互的非常方便的方式，比如运行函数和方法或创建类的实例。这是Python相对于编译语言（如C/C++或Java）的主要优势之一，后者的`编写...编译...测试...重新编译`循环与Python的`读取...评估...打印`循环相比，可以大大增加开发时间。能够输入表达式并立即得到响应可以大大加快数据科学任务的速度。
- en: There are some excellent distributions of Python apart from the official CPython
    version. Two of the most popular are available at:  Anaconda ([h](https://www.continuum.io/downloads)[t](https://www.continuum.io/downloads)[t](https://www.continuum.io/downloads)[p](https://www.continuum.io/downloads)[s](https://www.continuum.io/downloads)[://w](https://www.continuum.io/downloads)[w](https://www.continuum.io/downloads)[w](https://www.continuum.io/downloads)[.](https://www.continuum.io/downloads)[c](https://www.continuum.io/downloads)[o](https://www.continuum.io/downloads)[n](https://www.continuum.io/downloads)[t](https://www.continuum.io/downloads)[i](https://www.continuum.io/downloads)[n](https://www.continuum.io/downloads)[u](https://www.continuum.io/downloads)[u](https://www.continuum.io/downloads)[m](https://www.continuum.io/downloads)[.](https://www.continuum.io/downloads)[i](https://www.continuum.io/downloads)[o](https://www.continuum.io/downloads)[/d](https://www.continuum.io/downloads)[o](https://www.continuum.io/downloads)[w](https://www.continuum.io/downloads)[n](https://www.continuum.io/downloads)[l](https://www.continuum.io/downloads)[o](https://www.continuum.io/downloads)[a](https://www.continuum.io/downloads)[d](https://www.continuum.io/downloads)[s](https://www.continuum.io/downloads))
    and Canopy ([h](https://www.enthought.com/products/canopy/)[t](https://www.enthought.com/products/canopy/)[t](https://www.enthought.com/products/canopy/)[p](https://www.enthought.com/products/canopy/)[s](https://www.enthought.com/products/canopy/)[://w](https://www.enthought.com/products/canopy/)[w](https://www.enthought.com/products/canopy/)[w](https://www.enthought.com/products/canopy/)[.](https://www.enthought.com/products/canopy/)[e](https://www.enthought.com/products/canopy/)[n](https://www.enthought.com/products/canopy/)[t](https://www.enthought.com/products/canopy/)[h](https://www.enthought.com/products/canopy/)[o](https://www.enthought.com/products/canopy/)[u](https://www.enthought.com/products/canopy/)[g](https://www.enthought.com/products/canopy/)[h](https://www.enthought.com/products/canopy/)[t](https://www.enthought.com/products/canopy/)[.](https://www.enthought.com/products/canopy/)[c](https://www.enthought.com/products/canopy/)[o](https://www.enthought.com/products/canopy/)[m](https://www.enthought.com/products/canopy/)[/p](https://www.enthought.com/products/canopy/)[r](https://www.enthought.com/products/canopy/)[o](https://www.enthought.com/products/canopy/)[d](https://www.enthought.com/products/canopy/)[u](https://www.enthought.com/products/canopy/)[c](https://www.enthought.com/products/canopy/)[t](https://www.enthought.com/products/canopy/)[s](https://www.enthought.com/products/canopy/)[/c](https://www.enthought.com/products/canopy/)[a](https://www.enthought.com/products/canopy/)[n](https://www.enthought.com/products/canopy/)[o](https://www.enthought.com/products/canopy/)[p](https://www.enthought.com/products/canopy/)[y](https://www.enthought.com/products/canopy/)[/](https://www.enthought.com/products/canopy/)).
    Most distributions come with their own developer environments. Both Canopy and
    Anaconda include libraries for scientific, machine learning, and other data applications.
    Most distributions come with an editor.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了官方的CPython版本外，还有一些优秀的Python发行版。其中最受欢迎的两个可以在以下网址找到：Anaconda（https://www.continuum.io/downloads）和Canopy（https://www.enthought.com/products/canopy/）。大多数发行版都带有自己的开发环境。Canopy和Anaconda都包括用于科学、机器学习和其他数据应用的库。大多数发行版都带有编辑器。
- en: There are also a number of implementations of the Python console, apart from
    the CPython version. Most notable among these is the IPython/Jupyter platform
    which is based on a web-based computational environment.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了CPython版本外，还有许多Python控制台的实现。其中最值得注意的是基于网络的计算环境IPython/Jupyter平台。
- en: Variables and expressions
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和表达式
- en: 'To solve a real-world problem through algorithm implementation, we first have
    to select the variables and then apply the operations on these variables. Variables
    are labels that are attached to the objects. Variables are not objects nor containers
    for objects; they only act as a pointer or a reference to the object. For example,
    consider the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过算法实现解决现实世界的问题，我们首先必须选择变量，然后对这些变量应用操作。变量是附加到对象的标签。变量不是对象，也不是对象的容器；它们只是作为对象的指针或引用。例如，考虑以下代码：
- en: '![](Images/745e0608-bbd2-46b2-a213-47194b782fc8.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/745e0608-bbd2-46b2-a213-47194b782fc8.png)'
- en: Here, we have created a variable, `a`, that points to a list object. We create
    another variable, `b`, that points to this same list object. When we append an
    element to this list object, this change is reflected in both `a` and `b`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个指向列表对象的变量`a`。我们创建另一个变量`b`，它指向相同的列表对象。当我们向这个列表对象添加一个元素时，这个变化会反映在`a`和`b`中。
- en: 'In Python, variable names are attached to different data types during the program
    execution; it is not required to first declare the datatype for the variables.
    Each value is of a type (for example, a string or integer); however, the variable
    name that points to this value does not have a specific type. More specifically,
    variables point to an object that can change their type depending on the kind
    of values assigned to them. Consider the following example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，变量名在程序执行期间附加到不同的数据类型；不需要首先声明变量的数据类型。每个值都有一个类型（例如字符串或整数）；然而，指向这个值的变量名没有特定的类型。更具体地说，变量指向一个对象，可以根据分配给它们的值的类型而改变它们的类型。考虑以下例子：
- en: '![](Images/2b7de8f3-a61b-4ac6-a154-12653f2518c8.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2b7de8f3-a61b-4ac6-a154-12653f2518c8.png)'
- en: In the preceding code example, the type of `a` is changed from `int` to `float`,
    depending upon the value stored in the variable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，`a`的类型从`int`变为`float`，具体取决于变量中存储的值。
- en: Variable scope
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量作用域
- en: 'Scoping rules of variables inside functions are important. Whenever a function
    executes, a local environment (namespace) is created. This local namespace contains
    all the variables and parameter names that are assigned by the functions. Whenever
    a function is called, Python Interpreter first looks into the local namespace
    that is the function itself—if no match is found, then it looks at the global
    namespace. If the name is still not found, then it searches in the built-in namespace.
    If it is not found, then the interpreter would raise a `NameError` exception.
    Consider the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 函数内部变量的作用域规则很重要。每当函数执行时，都会创建一个局部环境（命名空间）。这个局部命名空间包含所有由函数分配的变量和参数名。每当调用函数时，Python解释器首先查找函数本身的局部命名空间——如果找不到匹配项，然后查找全局命名空间。如果名称仍然找不到，那么它会在内置命名空间中搜索。如果还是找不到，解释器会引发`NameError`异常。考虑以下代码：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we define two `global` variables. We need to tell the
    interpreter, using the keyword `global`, that inside the function we are referring
    to a `global` variable. When we change this variable to `11`, these changes are
    reflected in the global scope. However, the `b` variable we set to `21` is local
    to the function, and any changes made to it inside the function are not reflected
    in the global scope. When we run the function and print `b`, we see that it retains
    its global value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了两个`global`变量。我们需要使用关键字`global`告诉解释器，在函数内部我们正在引用一个`global`变量。当我们将这个变量更改为`11`时，这些更改会反映在全局范围内。然而，我们将`b`变量设置为`21`是函数内部的局部变量，对它进行的任何更改都不会反映在全局范围内。当我们运行函数并打印`b`时，我们看到它保留了它的全局值。
- en: 'In addition, let''s consider another interesting example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们考虑另一个有趣的例子：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The code works, and gives an output of `10`, but see the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以正常工作，并输出`10`，但看看下面的代码：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code gives an error because assignment to a variable in a scope
    makes that variable a local variable to that scope. In the preceding example,
    in the `my_function()` assignment to the `a` variable, the compiler assumes `a`
    as a local variable, and that is why the earlier `print()` function tries to print
    a local variable `a`, which is not initialized as a local variable; thus, it gives
    an error. It can be resolved by accessing the outer scope variable by declaring
    it as `global`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码出错了，因为在作用域内对变量进行赋值会使该变量成为该作用域的局部变量。在前面的例子中，在`my_function()`中对变量`a`进行赋值，编译器会将`a`视为局部变量，这就是为什么之前的`print()`函数尝试打印一个未初始化的局部变量`a`，从而导致错误。可以通过声明为`global`来访问外部作用域变量来解决这个问题：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, in Python, the variables that are referenced inside a function are global
    implicitly, and if the `a` variable is assigned a value anywhere inside the function's
    body, it is assumed to be a local variable unless explicitly declared as global.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在Python中，函数内部引用的变量隐式地是全局的，如果`a`变量在函数体内的任何地方被赋值，它会被假定为局部变量，除非显式声明为全局变量。
- en: Flow control and iteration
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程控制和迭代
- en: Python programs consist of a sequence of statements. The interpreter executes
    each statement in order until there are no more statements. This is true if files
    run as the main program, as well as if they are loaded via `import`. All statements,
    including variable assignment, function definitions, class definitions, and module
    imports, have equal status. There are no special statements that have higher priority
    than any other, and every statement can be placed anywhere in a program. All the
    instructions/statements in the program are executed in sequence in general. However,
    there are two main ways of controlling the flow of program execution—conditional
    statements and loops.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序由一系列语句组成。解释器按顺序执行每个语句，直到没有更多的语句为止。这对于作为主程序运行的文件以及通过`import`加载的文件都是如此。所有语句，包括变量赋值、函数定义、类定义和模块导入，都具有相同的地位。没有比其他更高优先级的特殊语句，每个语句都可以放在程序的任何位置。通常，程序中的所有指令/语句都按顺序执行。然而，控制程序执行流的主要方法有两种——条件语句和循环。
- en: 'The `if...else` and `elif` statements control the conditional execution of
    statements. The general format is a series of `if` and `elif` statements followed
    by a final `else` statement:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`if...else`和`elif`语句控制条件执行语句。一般格式是一系列`if`和`elif`语句，后跟最终的`else`语句：'
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note the use of the `==` operator to compare the two values. This returns `True`
    if both the values are equal; it returns `False` otherwise. Note also that setting
    `x` to a string will return `Something else` rather than generate a type error
    as may happen in languages that are not dynamically typed. Dynamically typed languages,
    such as Python, allow flexible assignment of objects with different types.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用`==`运算符来比较两个值。如果两个值相等，则返回`True`；否则返回`False`。还要注意，将`x`设置为字符串将返回`Something
    else`，而不会像在静态类型的语言中那样生成类型错误。动态类型的语言，如Python，允许对具有不同类型的对象进行灵活赋值。
- en: 'The other way of controlling program flow is with loops. Python offers two
    ways of constructing looping, such as the `while` and `for` loop statements. A
    `while` loop repeats executing statements until a Boolean condition is true. A
    `for` loop provides a way of repeating the execution into the loop through a series
    of elements. Here is an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 控制程序流的另一种方法是使用循环。Python提供了两种构建循环的方式，如`while`和`for`循环语句。`while`循环重复执行语句，直到布尔条件为真。`for`循环提供了一种通过一系列元素重复执行循环的方法。下面是一个例子：
- en: '![](Images/8bddf69a-d89b-49c0-a9a6-358dbcb2dd2e.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8bddf69a-d89b-49c0-a9a6-358dbcb2dd2e.png)'
- en: 'In this example, the `while` loop executes the statements until the condition `x
    < 3` is true. Let''s consider another example that uses a *for* loop:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`while`循环执行语句，直到条件`x < 3`为真。让我们考虑另一个使用*for*循环的例子：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, the *for* loop executes iterating for all the items over the
    list.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，*for*循环执行对列表中所有项目的迭代。
- en: Overview of data types and objects
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型和对象概述
- en: Python contains various built-in data types. These include four numeric types
    (`int`, `float`, `complex`, `bool`), four sequence types (`str`, `list`, `tuple`,
    `range`), one mapping type (`dict`), and two set types. It is also possible to
    create user-defined objects, such as functions or classes. We will look at the
    string and the list data types in this chapter and the remaining built-in types
    in the next chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python包含各种内置数据类型。这些包括四种数值类型（`int`、`float`、`complex`、`bool`）、四种序列类型（`str`、`list`、`tuple`、`range`）、一种映射类型（`dict`）和两种集合类型。还可以创建用户定义的对象，如函数或类。我们将在本章中讨论字符串和列表数据类型，下一章中讨论其余的内置类型。
- en: All data types in Python are **objects**. In fact, pretty much everything is
    an object in Python, including modules, classes, and functions, as well as literals
    such as strings and integers. Each object in Python has a **type**, a **value,**
    and an **identity**. When we write `greet= "helloworld"`, we are creating an instance
    of a string object with the value `"hello world"` and the identity of `greet`.
    The identity of an object acts as a pointer to the object's location in memory.
    The type of an object, also known as the object's class, describes the object's
    internal representation, as well as the methods and operations it supports. Once
    an instance of an object is created, its identity and type cannot be changed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的所有数据类型都是**对象**。实际上，在Python中几乎所有的东西都是对象，包括模块、类和函数，以及字面量，如字符串和整数。Python中的每个对象都有一个**类型**、一个**值**和一个**标识**。当我们写`greet=
    "helloworld"`时，我们创建了一个字符串对象的实例，其值为`"hello world"`，标识为`greet`。对象的标识充当指向对象在内存中位置的指针。对象的类型，也称为对象的类，描述了对象的内部表示，以及它支持的方法和操作。一旦创建了对象的实例，它的标识和类型就不能被改变。
- en: We can get the identity of an object by using the built-in function `id()`.
    This returns an identifying integer and on most systems, this refers to its memory
    location, although you should not rely on this in any of your code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用内置函数`id()`来获取对象的标识。这将返回一个标识整数，在大多数系统上，这将指向其内存位置，尽管您不应该依赖于这一点在您的任何代码中。
- en: 'Also, there are a number of ways to compare objects; for example, see the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，有许多比较对象的方法；例如，参见以下内容：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: An important distinction needs to be made between **mutable** and **immutable**
    objects. Mutable objects such as lists can have their values changed. They have
    methods, such as `insert()` or `append()`, that change an object's value. Immutable
    objects such as strings cannot have their values changed, so when we run their
    methods, they simply return a value rather than change the value of an underlying
    object. We can, of course, use this value by assigning it to a variable or using
    it as an argument in a function. For example, the `int` class is immutable—once
    an instance of it is created, its value cannot be changed, however, an identifier
    referencing this object can be reassigned another value.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 需要区分**可变**和**不可变**对象之间的重要区别。可变对象如列表可以改变其值。它们有`insert()`或`append()`等方法，可以改变对象的值。不可变对象如字符串不能改变其值，因此当我们运行它们的方法时，它们只是返回一个值，而不是改变底层对象的值。当然，我们可以通过将其分配给一个变量或将其用作函数中的参数来使用这个值。例如，`int`类是不可变的——一旦创建了它的实例，它的值就不能改变，但是，引用这个对象的标识符可以被重新分配另一个值。
- en: Strings
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings are immutable sequence objects, with each character representing an
    element in the sequence. As with all objects, we use methods to perform operations.
    Strings, being immutable, do not change the instance; each method simply returns
    a value. This value can be stored as another variable or given as an argument
    to a function or method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是不可变的序列对象，每个字符代表序列中的一个元素。与所有对象一样，我们使用方法来执行操作。字符串是不可变的，不会改变实例；每个方法只是返回一个值。这个值可以存储为另一个变量，或作为参数传递给函数或方法。
- en: 'The following table is a list of some of the most commonly used string methods
    and their descriptions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了一些最常用的字符串方法及其描述：
- en: '| Method | Description |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| `s.capitalize` | Returns a string with only the first character capitalized,
    the rest remaining lowercase. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `s.capitalize` | 返回只有第一个字符大写的字符串，其余字符保持小写。|'
- en: '| `s.count(substring,[start,end])` | Counts occurrences of a substring. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `s.count(substring,[start,end])` | 计算子字符串的出现次数。|'
- en: '| `s.expandtabs([tabsize])` | Replaces tabs with spaces. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `s.expandtabs([tabsize])` | 用空格替换制表符。|'
- en: '| `s.endswith(substring,[start, end]` | Returns `True` if a string ends with
    a specified substring. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `s.endswith(substring,[start, end]` | 如果字符串以指定的子字符串结尾，则返回`True`。 |'
- en: '| `s.find(substring,[start,end])` | Returns index of first presence of a substring.
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `s.find(substring,[start,end])` | 返回子字符串第一次出现的索引。 |'
- en: '| `s.isalnum()` | Returns `True` if all chars are alphanumeric of string `s`.
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `s.isalnum()` | 如果字符串`s`中所有字符都是字母数字，则返回`True`。 |'
- en: '| `s.isalpha()` | Returns `True` if all chars are alphabetic of string `s`.
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `s.isalpha()` | 如果字符串`s`中所有字符都是字母，则返回`True`。 |'
- en: '| `s.isdigit()` | Returns `True` if all chars are digits in the string. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `s.isdigit()` | 如果字符串中所有字符都是数字，则返回`True`。 |'
- en: '| `s.split([separator],[maxsplit])` | Splits a string separated by whitespace
    or an optional separator. Returns a list. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `s.split([separator],[maxsplit])` | 以空格或可选分隔符分割字符串。返回一个列表。 |'
- en: '| `s.join(t)` | Joins the strings in sequence `t`. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `s.join(t)` | 连接序列`t`中的字符串。 |'
- en: '| `s.lower()` | Converts the string to all lowercase. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `s.lower()` | 将字符串转换为全小写。 |'
- en: '| `s.replace(old, new[maxreplace])` | Replaces old substring with a new substring.
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `s.replace(old, new[maxreplace])` | 用新的子字符串替换旧的子字符串。 |'
- en: '| `s.startswith(substring, [start, end]])` | Returns `True` if the string starts
    with a specified substring. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `s.startswith(substring, [start, end]])` | 如果字符串以指定的子字符串开头，则返回`True`。 |'
- en: '| `s.swapcase()` | Returns a copy of the string with swapped case in the string.
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `s.swapcase()` | 返回字符串中交换大小写的副本。 |'
- en: '| `s.strip([characters])` | Removes whitespace or optional characters. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `s.strip([characters])` | 移除空格或可选字符。 |'
- en: '| `s.lstrip([characters])` | Returns a copy of the string with leading characters
    removed. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `s.lstrip([characters])` | 返回删除前导字符的字符串副本。 |'
- en: 'Strings, like all sequence types, support indexing and slicing. We can retrieve
    any character from a string by using its index `s[i]`. We can retrieve a slice
    of a string by using `s[i:j]`, where `i` and `j` are the start and end points
    of the slice. We can return an extended slice by using a stride, as in the following—`s[i:j:stride]`.
    The following code should make this clear:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有序列类型一样，字符串支持索引和切片。我们可以通过使用索引`s[i]`检索字符串的任何字符。我们可以通过使用`s[i:j]`检索字符串的一个切片，其中`i`和`j`是切片的起点和终点。我们可以通过使用步长返回一个扩展的切片，如下所示—`s[i:j:stride]`。以下代码应该能说明这一点：
- en: '![](Images/3da1c070-0671-4a9b-91cb-38e3ec444994.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3da1c070-0671-4a9b-91cb-38e3ec444994.png)'
- en: The first two examples are pretty straightforward, returning the character located
    at index `1` and the first seven characters of the string, respectively. Notice
    that indexing begins at `0`. In the third example, we are using a stride of `2`.
    This results in every second character being returned. In the final example, we
    omit the end index and the slice returns every second character in the entire
    string.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个例子非常直接，分别返回索引`1`处的字符和字符串的前七个字符。请注意，索引从`0`开始。在第三个例子中，我们使用了步长为`2`。这导致每隔一个字符被返回。在最后一个例子中，我们省略了结束索引，切片返回整个字符串中每隔一个字符。
- en: 'You can use any expression, variable, or operator as an index as long as the
    value is an integer:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 只要值是整数，就可以使用任何表达式、变量或运算符作为索引：
- en: '![](Images/045aeaf6-1be2-49ba-a3ea-059b09cb361e.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/045aeaf6-1be2-49ba-a3ea-059b09cb361e.png)'
- en: 'Another common operation is traversing through a string with a loop:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的操作是使用循环遍历字符串：
- en: '![](Images/55d863c4-45e2-4aa1-936e-7e41915b13a3.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/55d863c4-45e2-4aa1-936e-7e41915b13a3.png)'
- en: 'Given that strings are immutable, a common question that arises is how we perform
    operations such as inserting values. Rather than changing a string, we need to
    think of ways to build new string objects for the results we need. For example,
    if we wanted to insert a word into our greeting, we could assign a variable to
    the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于字符串是不可变的，一个常见的问题是如何执行插入值等操作。我们需要想办法为我们需要的结果构建新的字符串对象，而不是改变一个字符串。例如，如果我们想要在问候语中插入一个单词，我们可以将一个变量赋值给以下内容：
- en: '![](Images/93ff7c53-9bb0-4339-9ad3-bdaf2bb16046.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/93ff7c53-9bb0-4339-9ad3-bdaf2bb16046.png)'
- en: 'As this code shows, we use the slice operator to split the string at index
    position `5` and use `+` to concatenate. Python never interprets the contents
    of a string as a number. If we need to perform mathematical operations on a string,
    we need to first convert them to a numeric type:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这段代码所示，我们使用切片操作符在索引位置`5`处拆分字符串，并使用`+`进行连接。Python从不将字符串的内容解释为数字。如果我们需要对字符串执行数学运算，我们需要先将它们转换为数字类型：
- en: '![](Images/d4bd788f-9566-4712-b1ab-6b09c31cc858.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d4bd788f-9566-4712-b1ab-6b09c31cc858.png)'
- en: Lists
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: List is one of the most commonly used built-in data structures, as they can
    store any number of different data types. They are simple representations of objects
    and are indexed by integers starting from zero, as we saw in the case of *strings. *
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是最常用的内置数据结构之一，因为它们可以存储任意数量的不同数据类型。它们是对象的简单表示，并且由整数索引，从零开始，如我们在*字符串*中看到的那样。
- en: 'The following table contains the most commonly used list methods and their
    descriptions:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下表包含了最常用的列表方法及其描述：
- en: '| **Method** | **Description** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `list(s)` | Returns a list of sequence `s.` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `list(s)` | 返回序列`s`的列表。 |'
- en: '| `s.append(x)` | Appends element `x` at the end of list `s`. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `s.append(x)` | 在列表`s`的末尾添加元素`x`。 |'
- en: '| `s.extend(x)` | Appends list `x` at the end of list `s`. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `s.extend(x)` | 在列表`s`的末尾添加列表`x`。 |'
- en: '| `s.count(x)` | Returns the count of the occurrence of `x` in list `s`. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `s.count(x)` | 返回列表`s`中`x`出现的次数。 |'
- en: '| `s.index(x,[start],[stop])` | Returns the smallest index `i`, where `s[i]==x`.
    We can include an optional start and stop index for the lookup. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `s.index(x,[start],[stop])` | 返回最小的索引`i`，其中`s[i]==x`。我们可以为查找包括可选的开始和结束索引。
    |'
- en: '| `s.insert(i,e)` | Inserts `x` at index `i`. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `s.insert(i,e)` | 在索引`i`处插入`x`。 |'
- en: '| `s.pop(i)` | Returns the element `i` and removes it from the list `s`. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `s.pop(i)` | 返回列表`s`中的元素`i`并将其移除。 |'
- en: '| `s.remove(x)` | Removes element `x` from the list `s`. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `s.remove(x)` | 从列表`s`中移除元素`x`。 |'
- en: '| `s.reverse()` | Reverses the order of list `s`. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `s.reverse()` | 颠倒列表`s`的顺序。 |'
- en: '| `s.sort(key,[reverse])` | Sorts list `s` with optional key and reverses it.
    |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `s.sort(key,[reverse])` | 用可选的key对列表`s`进行排序并反转。 |'
- en: In Python, lists implementation is different when compared to other languages.
    Python does not create multiple copies of a variable. For example, when we assign
    a value of one variable in another variable, both variables point to the same
    memory address where the value is stored. A copy would only be allocated if the
    variables change their values. This feature makes Python memory efficient, in
    the sense that it only creates multiple copies when it is required.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，与其他语言相比，列表的实现是不同的。Python不会创建变量的多个副本。例如，当我们将一个变量的值分配给另一个变量时，两个变量都指向存储值的相同内存地址。只有在变量改变其值时才会分配一个副本。这个特性使得Python在内存上更有效，因为它只在需要时才创建多个副本。
- en: 'This has important consequences for mutable compound objects such as lists.
    Consider the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于可变的复合对象（如列表）有重要的影响。考虑以下代码：
- en: '![](Images/14c189e7-ddb4-4e04-89b7-84b8635d7bb6.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14c189e7-ddb4-4e04-89b7-84b8635d7bb6.png)'
- en: In the preceding code, both the `list1` and `list2`   variables are pointing
    to the same memory location. However, when we change the `y` through `list2` to
    `4`, we are actually changing the same `y` variable that `list1` is pointing to
    as well.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`list1`和`list2`变量都指向同一内存位置。但是，当我们通过`list2`将`y`更改为`4`时，实际上也更改了`list1`指向的相同`y`变量。
- en: 'An important feature of `list` is that it can contain nested structures; that
    is, list can contain other lists. For example, in the following code, list `items`
    contains three other lists:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`的一个重要特性是它可以包含嵌套结构；也就是说，列表可以包含其他列表。例如，在以下代码中，列表`items`包含了另外三个列表：'
- en: '![](Images/43641e4c-00c8-455c-bb6c-e1ee22e484b7.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/43641e4c-00c8-455c-bb6c-e1ee22e484b7.png)'
- en: 'We can access the values of the list using the bracket operators and, since
    lists are mutable, they are copied in place. The following example demonstrates
    how we can use this to update elements; for example, here we are raising the price
    of flour by 20 percent:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用方括号运算符访问列表的值，并且由于列表是可变的，它们是就地复制的。以下示例演示了我们如何使用这一点来更新元素；例如，在这里我们将面粉的价格提高了20%：
- en: '![](Images/c19d6173-458d-4901-b494-d34600607c0f.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c19d6173-458d-4901-b494-d34600607c0f.png)'
- en: 'We can create a list from expressions using a very common and intuitive method;
    that is, **list comprehensions.** It allows us to create a list through an expression
    directly into the list. Consider the following example, where a list `l` is created
    using this expression:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用非常常见和直观的方法，即**列表推导**，从表达式中创建一个列表。它允许我们通过一个表达式直接创建一个列表。考虑以下示例，使用这个表达式创建了一个列表`l`：
- en: '![](Images/b27ed8e2-fff4-49b6-95c4-84808f5c1f5f.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b27ed8e2-fff4-49b6-95c4-84808f5c1f5f.png)'
- en: 'List comprehensions can be quite flexible; for example, consider the following
    code. It essentially shows two different ways to performs a function composition,
    where we apply one function (`x*4`) to another (`x*2`). The following code prints
    out two lists representing the function composition of `f1` and `f2`, calculated
    first using a for loop and then using a list comprehension:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导可以非常灵活；例如，考虑以下代码。它基本上展示了执行函数组合的两种不同方式，其中我们将一个函数（`x*4`）应用于另一个函数（`x*2`）。以下代码打印出了两个列表，分别表示`f1`和`f2`的函数组合，首先使用for循环计算，然后使用列表推导计算：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first line of output is from the for loop construct. The second is from
    the list comprehension expression:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行是来自于for循环结构。第二行是来自于列表推导表达式：
- en: '![](Images/39930806-6c10-4d9c-afbc-8a39002c8708.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/39930806-6c10-4d9c-afbc-8a39002c8708.png)'
- en: 'List comprehensions can also be used to replicate the action of nested loops
    in a more compact form. For example, we multiply each of the elements contained
    within `list1` with each other:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导也可以用来复制嵌套循环的操作，以更紧凑的形式。例如，我们将`list1`中的每个元素与彼此相乘：
- en: '![](Images/79b4fd28-f816-49d9-98de-145f8aa50ff3.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/79b4fd28-f816-49d9-98de-145f8aa50ff3.png)'
- en: 'We can also use list comprehensions with other objects such as strings, to
    build more complex structures. For example, the following code creates a list
    of words and their letter count:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用列表推导与其他对象（如字符串）一起构建更复杂的结构。例如，以下代码创建了一个单词及其字母计数的列表：
- en: '![](Images/db9ed782-f9e2-45cf-a87f-96f4001a4224.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/db9ed782-f9e2-45cf-a87f-96f4001a4224.png)'
- en: As we will see, lists form the foundation of many of the data structures we
    will look at. Their versatility, ease of creation, and use enable them to build
    more specialized and complex data structures.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，列表构成了我们将要研究的许多数据结构的基础。它们的多功能性、易于创建和使用使它们能够构建更专业化和复杂的数据结构。
- en: Functions as first class objects
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为一等对象
- en: 'In Python, it is not only data types that are treated as objects. Both functions
    and classes are what are known as first class objects, allowing them to be manipulated
    in the same ways as built-in data types. By definition, first class objects are
    the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，不仅数据类型被视为对象。函数和类都被称为一等对象，允许它们以与内置数据类型相同的方式进行操作。根据定义，一等对象具有以下特点：
- en: Created at runtime
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时创建
- en: Assigned as a variable or in a data structure
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配为变量或数据结构中
- en: Passed as an argument to a function
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为函数的参数传递
- en: Returned as the result of a function
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为函数结果返回
- en: In Python, the term **first class object** is a bit of a misnomer, since it
    implies some sort of hierarchy, whereas all Python objects are essentially first
    class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，术语**一等对象**有点不准确，因为它暗示了某种层次结构，而所有Python对象本质上都是一等对象。
- en: 'To have a look at how this works, let''s define a simple function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看这是如何工作的，让我们定义一个简单的函数：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since user-defined functions are objects, we can do things such as include
    them in other objects, such as lists:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户定义的函数是对象，我们可以将它们包含在其他对象中，比如列表中：
- en: '![](Images/68d69688-ec25-41e1-8c34-932ae3496c25.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/68d69688-ec25-41e1-8c34-932ae3496c25.png)'
- en: 'Functions can also be used as arguments for other functions. For example, we
    can define the following function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以作为其他函数的参数使用。例如，我们可以定义以下函数：
- en: '![](Images/8ae8379b-84a1-4848-b182-2edb6099f0d5.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8ae8379b-84a1-4848-b182-2edb6099f0d5.png)'
- en: Here, `callf()` takes a function as an argument, sets a language variable to
    `'eng'`, and then calls the function with the language variable as its argument.
    We could see how this would be useful if, for example, we wanted to produce a
    program that returns specific sentences in a variety of languages, perhaps for
    some sort of natural language application. Here, we have a central place to set
    the language. As well as our greeting function, we could create similar functions
    that return different sentences. By having one point where we set the language,
    the rest of the program logic does not have to worry about this. If we want to
    change the language, we simply change the language variable and we can keep everything
    else the same.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`callf()`接受一个函数作为参数，将语言变量设置为`'eng'`，然后调用带有语言变量作为参数的函数。我们可以看到，如果我们想要生成一个以各种语言返回特定句子的程序，这将是有用的。在这里，我们有一个设置语言的中心位置。除了我们的问候函数，我们还可以创建返回不同句子的类似函数。通过在一个地方设置语言，程序逻辑的其余部分不必担心这一点。如果我们想要改变语言，我们只需改变语言变量，其他一切都可以保持不变。
- en: Higher order functions
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: 'Functions that take other functions as arguments, or that return functions,
    are called **higher order functions**. Python 3 contains two built-in higher order
    functions—`filter()` and `map().` Note that in earlier versions of Python, these
    functions returned lists; in Python 3, they return an iterator, making them much
    more efficient. The `map()` function provides an easy way to transform each item
    into an iterable object. For example, here is an efficient, compact way to perform
    an operation on a sequence. Note the use of the `lambda` anonymous function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接受其他函数作为参数或返回函数的函数称为**高阶函数**。Python 3包含两个内置的高阶函数——`filter()`和`map()`。请注意，在Python的早期版本中，这些函数返回列表；在Python
    3中，它们返回一个迭代器，使它们更加高效。`map()`函数提供了一种简单的方法来将每个项目转换为可迭代对象。例如，这是一种在序列上执行操作的高效、紧凑的方法。请注意使用`lambda`匿名函数：
- en: '![](Images/7315856e-a4c1-44e6-8072-af7c4f03d3f6.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7315856e-a4c1-44e6-8072-af7c4f03d3f6.png)'
- en: 'Similarly, we can use the filter built-in function to filter items in a list:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用内置的filter函数来过滤列表中的项目：
- en: '![](Images/7a36c976-240b-448f-bf5a-bed8d610d781.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7a36c976-240b-448f-bf5a-bed8d610d781.png)'
- en: Note that both map and filter perform the same function similar to what can
    be achieved by list comprehensions. There does not seem to be a great deal of
    difference in the performance characteristics, apart from a slight performance
    advantage when using the in-built functions map and filter without the `lambda`
    operator, compared to list comprehensions. Despite this, most style guides recommend
    the use of list comprehensions over built-in functions, possibly because they
    tend to be easier to read.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，map和filter执行与列表推导可以实现的相同功能。除了在使用内置函数map和filter时，与列表推导相比，性能特性没有太大的区别，除了在不使用`lambda`运算符时稍微有一点性能优势。尽管如此，大多数风格指南建议使用列表推导而不是内置函数，可能是因为它们更容易阅读。
- en: 'Creating our own higher order functions is one of the hallmarks of functional
    programming style. A practical example of how higher order functions can be useful
    is demonstrated by the following. Here, we are passing the `len` function as the
    key to the sort function. This way, we can sort a list of words by length:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们自己的高阶函数是函数式编程风格的一个标志。高阶函数的一个实际例子是以下演示的。在这里，我们将`len`函数作为sort函数的键传递。这样，我们可以按长度对单词列表进行排序：
- en: '![](Images/0d25a0df-964c-447a-8c22-a25b83b4eb96.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0d25a0df-964c-447a-8c22-a25b83b4eb96.png)'
- en: 'Here is another example for case-insensitive sorting:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个不区分大小写的排序示例：
- en: '![](Images/56fc79db-0fb0-404e-9f1c-a839e62eca5e.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/56fc79db-0fb0-404e-9f1c-a839e62eca5e.png)'
- en: Note the difference between the `list.sort()` method and the sorted built-in
    function. The `list.sort()` method, a method of the list object, sorts the existing
    instance of a list without copying it. This method changes the target object and
    returns `None`. It is an important convention in Python that functions or methods
    that change the object return `None`, to make it clear that no new object was
    created and that the object itself was changed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`list.sort()`方法和内置的sorted函数之间的区别。`list.sort()`方法是列表对象的一个方法，它对现有的列表实例进行排序而不复制它。这种方法改变了目标对象并返回`None`。在Python中，一个重要的约定是改变对象的函数或方法返回`None`，以明确表示没有创建新对象并且对象本身已经改变。
- en: On the other hand, the sorted built-in function returns a new list. It actually
    accepts any iterable object as an argument, but it will always return a list.
    Both *list sort* and *sorted* take two optional keyword arguments as key.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，内置的sorted函数返回一个新的列表。它实际上接受任何可迭代对象作为参数，但它总是返回一个列表。*list sort*和*sorted*都接受两个可选的关键字参数。
- en: 'A simple way to sort more complex structures is to use the index of the element
    to sort, using the lambda operator, for example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对更复杂的结构进行排序的一个简单方法是使用lambda运算符来使用元素的索引进行排序，例如：
- en: '![](Images/2cb6f820-9f35-4208-8dc7-9abf5407197b.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2cb6f820-9f35-4208-8dc7-9abf5407197b.png)'
- en: Here we have sorted the items by price.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们按价格对项目进行了排序。
- en: Recursive functions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归函数
- en: Recursion is one of the most fundamental concepts of computer science. It is
    called *recursion* when a function takes one or more calls to itself during execution.
    Loop iterations and recursion are different in the sense that *loops* execute
    statements repeatedly through a Boolean condition or through a series of elements,
    whereas recursion repeatedly calls a function. In Python, we can implement a recursive
    function simply by calling it within its own function body. To stop a recursive
    function turning into an infinite loop, we need at least one argument that tests
    for a terminating case to end the recursion. This is sometimes called the base
    case. It should be pointed out that recursion is different from iteration. Although
    both involve repetition, iteration loops through a sequence of operations, whereas
    recursion repeatedly calls a function. Technically, recursion is a special case
    of iteration known as tail iteration, and it is usually always possible to convert
    an iterative function to a recursive function and vice versa. The interesting
    thing about recursive functions is that they are able to describe an infinite
    object within a finite statement.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是计算机科学中最基本的概念之一。在执行过程中，当一个函数调用自身一次或多次时，它被称为*递归*。循环迭代和递归在*循环*通过布尔条件或一系列元素重复执行语句的意义上是不同的，而递归则重复调用一个函数。在Python中，我们可以通过在其自身函数体内调用它来实现递归函数。为了防止递归函数变成无限循环，我们需要至少一个测试终止情况的参数来结束递归。这有时被称为基本情况。应该指出，递归与迭代不同。虽然两者都涉及重复，但迭代循环通过一系列操作，而递归重复调用一个函数。从技术上讲，递归是迭代的一种特殊情况，通常总是可以将迭代函数转换为递归函数，反之亦然。递归函数的有趣之处在于它们能够用有限的语句描述一个无限的对象。
- en: 'The following code should demonstrate the difference between recursion and
    iteration. Both these functions simply print out numbers between low and high,
    the first one using iteration and the second using recursion:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码应该演示了递归和迭代之间的区别。这两个函数都简单地打印出低和高之间的数字，第一个使用迭代，第二个使用递归：
- en: '![](Images/1511f7af-2b45-439a-bcfa-ab700239a3b9.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1511f7af-2b45-439a-bcfa-ab700239a3b9.png)'
- en: Notice that for `iterTest`, the iteration example, we use a while statement
    to test for the condition, then call the print method, and finally increment the
    low value. The recursive example tests for the condition, prints, then calls itself,
    incrementing the low variable in its argument. In general, iteration is more efficient;
    however, recursive functions are often easier to understand and write. Recursive
    functions are also useful for manipulating recursive data structures such as linked
    lists and trees, as we will see.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于`iterTest`，迭代示例，我们使用while语句来测试条件，然后调用打印方法，最后递增低值。递归示例测试条件，打印，然后调用自身，在其参数中递增低变量。一般来说，迭代更有效率；然而，递归函数通常更容易理解和编写。递归函数还可用于操作递归数据结构，如链表和树，我们将会看到。
- en: Generators and co-routines
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器和协程
- en: 'We can create functions that do not just return one result but rather an entire
    sequence of results, by using the yield statement. These functions are called
    **generators.** Python contains generator functions, which are an easy way to
    create iterators and are especially useful as a replacement for unworkably long
    lists. A generator yields items rather than builds lists. For example, the following
    code shows why we might choose to use a generator, as opposed to creating a list:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建不仅返回一个结果而且返回整个结果序列的函数，方法是使用yield语句。这些函数被称为**生成器**。Python包含生成器函数，这是一种创建迭代器的简单方法，特别适用于替代不可行的长列表。生成器产生项目而不是构建列表。例如，以下代码显示了为什么我们可能选择使用生成器而不是创建列表：
- en: '[PRE12]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This prints out the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出以下内容：
- en: '![](Images/8c1bd48e-7fc3-4d72-9e55-251c14fd0573.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8c1bd48e-7fc3-4d72-9e55-251c14fd0573.png)'
- en: As we can see, building a list to do this calculation takes significantly longer.
    The performance improvement as a result of using generators is because the values
    are generated on demand, rather than saved as a list in memory. A calculation
    can begin before all the elements have been generated and elements are generated
    only when they are needed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，构建一个列表来进行这种计算需要更长的时间。使用生成器的性能改进是因为值是按需生成的，而不是保存在内存中作为列表。计算可以在所有元素生成之前开始，并且只有在需要时才生成元素。
- en: In the preceding example, the sum method loads each number into memory when
    it is needed for the calculation. This is achieved by the generator object repeatedly
    calling the `__next__ ()` special method. Generators never return a value other
    than `None`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，sum方法在需要进行计算时将每个数字加载到内存中。这是通过生成器对象重复调用`__next__()`特殊方法实现的。生成器永远不会返回除`None`之外的值。
- en: 'Typically, generator objects are used in for loops. For example, we can make
    use of the `oddLst` generator function created in the preceding code to print
    out odd integers between `1` and `10`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，生成器对象用于for循环。例如，我们可以利用前面代码中创建的`oddLst`生成器函数来打印出`1`到`10`之间的奇数：
- en: '[PRE13]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can also create a **generator expression**, which, apart from replacing square
    brackets with parentheses, uses the same syntax and carries out the same operation
    as list comprehensions. Generator expressions, however, do not create a list;
    they create a **generator object**. This object does not create the data, but
    rather creates that data on demand. This means that generator objects do not support
    sequence methods such as `append()` and `insert()`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个**生成器表达式**，它除了用括号替换方括号外，使用与列表推导相同的语法并执行与列表推导相同的操作。然而，生成器表达式不会创建一个列表；它创建一个**生成器对象**。这个对象不会创建数据，而是根据需要创建数据。这意味着生成器对象不支持`append()`和`insert()`等序列方法。
- en: 'You can, however, change a generator into a list using the `list()` function:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以使用`list()`函数将生成器转换为列表：
- en: '![](Images/b912eedf-5db9-4363-a0c1-ac65aa3b96fb.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b912eedf-5db9-4363-a0c1-ac65aa3b96fb.png)'
- en: Classes and object programming
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象编程
- en: Classes are a way to create new kinds of objects and they are central to object-oriented
    programming. A class defines a set of attributes that are shared across instances
    of that class. Typically, classes are sets of functions, variables, and properties.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 类是创建新类型对象的一种方式，它们是面向对象编程的核心。一个类定义了一组在该类的所有实例之间共享的属性。通常，类是一组函数、变量和属性。
- en: The object-oriented paradigm is compelling because it gives us a concrete way
    to think about and represent the core functionality of our programs. By organizing
    our programs around objects and data rather than actions and logic, we have a
    robust and flexible way to build complex applications. The actions and logic are
    still present, of course, but by embodying them in objects, we have a way to encapsulate
    functionality, allowing objects to change in very specific ways. This makes our
    code less error-prone, easier to extend and maintain, and able to model real-world
    objects.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的范式是令人信服的，因为它为我们提供了一种具体的方式来思考和表示程序的核心功能。通过围绕对象和数据而不是动作和逻辑组织我们的程序，我们有了一种强大而灵活的方式来构建复杂的应用程序。当然，动作和逻辑仍然存在，但通过将它们体现在对象中，我们有了一种封装功能的方式，允许对象以非常具体的方式改变。这使得我们的代码更少容易出错，更容易扩展和维护，并能够模拟现实世界的对象。
- en: 'Classes are created in Python using the class statement. This defines a set
    of shared attributes associated with a collection of class instances. A class
    usually consists of a number of methods, class variables, and computed properties.
    It is important to understand that defining a class does not, by itself, create
    any instances of that class. To create an instance, a variable must be assigned
    to a class. The class body consists of a series of statements that execute during
    the class definition. The functions defined inside a class are called **instance
    methods.** They apply some operations to the class instance by passing an instance
    of that class as the first argument. This argument is called self by convention,
    but it can be any legal identifier. Here is a simple example:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中使用class语句创建类。这定义了与一组类实例关联的一组共享属性。一个类通常由一些方法、类变量和计算属性组成。重要的是要理解，定义一个类本身并不会创建该类的任何实例。要创建一个实例，必须将一个变量分配给一个类。类主体由一系列在类定义期间执行的语句组成。在类内部定义的函数称为**实例方法**。它们通过将该类的实例作为第一个参数传递来对类实例应用一些操作。这个参数按照惯例被称为self，但它可以是任何合法的标识符。这里是一个简单的例子：
- en: '[PRE14]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Class variables, such as `numEmployee`, share values among all the instances
    of the class. In this example, `numEmployee` is used to count the number of employee
    instances. Note that the `Employee` class implements the `__init__ and __del__`
    special methods, which we will discuss in the next section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量，比如`numEmployee`，在类的所有实例之间共享值。在这个例子中，`numEmployee`用于计算员工实例的数量。请注意，`Employee`类实现了`__init__`和`__del__`特殊方法，我们将在下一节讨论。
- en: 'We can create instances of the `Employee` objects, run methods, and return
    class and instance variables by doing the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式创建`Employee`对象的实例，运行方法，并返回类和实例变量：
- en: '![](Images/3c5ad41c-37f0-4906-925a-5d2acef07238.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3c5ad41c-37f0-4906-925a-5d2acef07238.png)'
- en: Special methods
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊方法
- en: We can use the `dir(object)` function to get a list of attributes of a particular
    object. The methods that begin and end with two underscores are called **special
    methods.** Apart from the following exception**,** special methods are generally
    called by the Python interpreter rather than the programmer; for example, when
    we use the `+` operator, we are actually invoking a `to _add_ ()` call. For example,
    rather than using `my_object._len_ ()`, we can use `len(my_object)`; using `len()`
    on a string object is actually much faster, because it returns the value representing
    the object's size in memory, rather than making a call to the object's `_len_`
    method.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`dir(object)`函数获取特定对象的属性列表。以两个下划线开始和结束的方法称为**特殊方法**。除了以下例外，特殊方法通常由Python解释器调用，而不是由程序员调用；例如，当我们使用`+`运算符时，我们实际上是在调用`to
    _add_()`。例如，我们可以使用`len(my_object)`而不是使用`my_object._len_()`；在字符串对象上使用`len()`实际上要快得多，因为它返回表示对象在内存中的大小的值，而不是调用对象的`_len_`方法。
- en: The only special method we actually call in our programs, as common practice,
    is the `_init_` method, to invoke the initializer of the superclass in our own
    class definitions. It is strongly advised not to use the double underscore syntax
    for your own objects because of potential current or future conflicts with Python's
    own special methods.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 作为常见做法，我们在程序中实际调用的唯一特殊方法是`_init_`方法，以调用我们自己的类定义中的超类的初始化程序。强烈建议不要使用双下划线语法来定义自己的对象，因为可能会与Python自己的特殊方法产生当前或将来的冲突。
- en: 'We may, however, want to implement special methods in custom objects, to give
    them some of the behavior of built-in types. In the following code, we create
    a class that implements the `_repr_` method. This method creates a string representation
    of our object that is useful for inspection purposes:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可能希望在自定义对象中实现特殊方法，以赋予它们一些内置类型的行为。在下面的代码中，我们创建了一个实现了`_repr_`方法的类。这个方法创建了一个对象的字符串表示，对于检查目的很有用：
- en: '[PRE15]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When we create an instance of this object and inspect it, we can see we get
    our customized string representation. Notice the use of the `%r` format placeholder
    to return the standard representation of the object. This is useful and best practice
    because, in this case, it shows us that the `greet` object is a string indicated
    by the quotation marks:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建这个对象的实例并进行检查时，我们可以看到我们得到了我们定制的字符串表示。注意使用`%r`格式占位符返回对象的标准表示。这是有用的最佳实践，因为在这种情况下，它向我们显示`greet`对象是由引号表示的字符串：
- en: '![](Images/d231a9ec-fcf0-4387-9c07-2b9f3fecddaf.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d231a9ec-fcf0-4387-9c07-2b9f3fecddaf.png)'
- en: Inheritance
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: Inheritance is one of the most powerful features of object-oriented programming
    languages. It allows us to inherit the functionality from other classes. It is
    possible to create a new class that modifies the behavior of an existing class
    through inheritance. Inheritance means that if an object of one class is created
    by inheriting another class, then the object would have all the functionality,
    methods, and variables of both the classes; that is, the parent class and new
    class. The existing class from which we inherit the functionalities is called
    the parent/base class, and the new class is called the derived/child class.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象编程语言中最强大的功能之一。它允许我们从其他类继承功能。通过继承，可以创建一个修改现有类行为的新类。继承意味着如果通过继承另一个类创建一个类的对象，那么该对象将具有两个类的所有功能、方法和变量；即父类和新类。我们继承功能的现有类称为父类/基类，新类称为派生/子类。
- en: Inheritance can be explained with a very simple example—we create an `employee`
    class with attributes such as name of employee and rate at which he is going to
    be paid hourly. We can now create a new `specialEmployee` class inheriting all
    the attributes from the `employee` class.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 继承可以用一个非常简单的例子来解释——我们创建一个`employee`类，具有员工姓名和每小时支付的费率等属性。现在我们可以创建一个新的`specialEmployee`类，继承自`employee`类的所有属性。
- en: Inheritance in Python is done by passing the inherited class as an argument
    in the class definition. It is often used to modify the behavior of existing methods.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，继承是通过在类定义中传递继承的类作为参数来完成的。它经常用于修改现有方法的行为。
- en: 'An instance of the `specialEmployee` class is identical to an `Employee` instance,
    except for the changed `hours()` method. For example, in the following code we
    create a new `specialEmployee` class that inherits all the functionalities of
    the `Employee` class, and also change the  `hours()` method:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`specialEmployee`类的实例与`Employee`实例相同，只是`hours()`方法发生了变化。例如，在下面的代码中，我们创建一个新的`specialEmployee`类，它继承了`Employee`类的所有功能，并且还改变了`hours()`方法：'
- en: '[PRE16]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For a subclass to define new class variables, it needs to define an `__init__()`
    method, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了子类定义新的类变量，需要定义一个`__init__()`方法，如下所示：
- en: '[PRE17]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Notice that the methods of the base class are not automatically invoked and
    it is necessary for the derived class to call them. We can test for the class
    membership using the built-in `isinstance(obj1,obj2)` function. This returns `True`
    if `obj1` belongs to the class of `obj2` or any class derived from `obj2`. Let''s
    consider the following example to understand this, where `obj1` and `obj2` are
    the objects of the `Employee` and `specialEmployee` classes respectively:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，基类的方法不会自动调用，派生类需要调用它们。我们可以使用内置的`isinstance(obj1,obj2)`函数测试类成员资格。如果`obj1`属于`obj2`的类或任何派生自`obj2`的类，则返回`True`。让我们考虑以下示例来理解这一点，其中`obj1`和`obj2`分别是`Employee`和`specialEmployee`类的对象：
- en: '[PRE18]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Generally, all the methods operate on the instance of a class defined within
    a class. However, it is not a requirement. There are two types of methods—**static
    methods** and **class methods**. A static method is quite similar to a class method,
    which is mainly bound to the class, and not bound with the object of the class.
    It is defined within a class and does not require an instance of a class to execute.
    It does not perform any operations on the instance and it is defined using the `@staticmethod` class
    decorator. Static methods cannot access the attributes of an instance, so their
    most common usage is as a convenience to group utility functions together.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有方法都在类内定义的实例上操作。但这不是必需的。有两种类型的方法——**静态方法**和**类方法**。静态方法与类方法非常相似，主要绑定到类，而不是与类的对象绑定。它在类内定义，不需要类的实例来执行。它不对实例执行任何操作，并且使用`@staticmethod`类装饰器定义。静态方法无法访问实例的属性，因此它们最常见的用法是作为一种方便的方式来将实用函数组合在一起。
- en: 'A class method operates on the class itself and does not work with the instances.
    A class method works in the same way that class variables are associated with
    the classes rather than instances of that class. Class methods are defined using
    the `@classmethod` decorator and are distinguished from instance methods in the
    class. It is passed as the first argument, and this is named `cls` by convention. The
    `exponentialB` class inherits from the `exponentialA` class and changes the base
    class variable to `4`. We can also run the parent class''s `exp()` method as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法在类本身上操作，不与实例一起工作。类方法的工作方式与类变量相关联，而不是该类的实例。类方法是使用`@classmethod`装饰器定义的，并且在类中与实例方法区分开。它作为第一个参数传递，按照惯例命名为`cls`。`exponentialB`类继承自`exponentialA`类，并将基类变量更改为`4`。我们也可以运行父类的`exp()`方法如下：
- en: '[PRE19]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The difference between a static method and a class method is that a static method
    doesn't know anything about the class, it only deals with the parameters, whereas
    the class method works only with the class, and its parameter is always the class
    itself.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法和类方法之间的区别在于，静态方法对类一无所知，它只处理参数，而类方法仅与类一起工作，其参数始终是类本身。
- en: There are several reasons why class methods may be useful. For example, because
    a subclass inherits all the same features of its parent, there is the potential
    for it to break inherited methods. Using class methods is a way to define exactly
    what methods are run.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法可能有几个有用的原因。例如，因为子类继承了其父类的所有相同特性，所以有可能会破坏继承的方法。使用类方法是定义确切运行哪些方法的一种方式。
- en: Data encapsulation and properties
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据封装和属性
- en: Unless otherwise specified, all attributes and methods are accessible without
    restriction. This also means that everything defined in a base class is accessible
    from a derived class. This may cause problems when we are building object-oriented
    applications where we may want to hide the internal implementation of an object.
    This can lead to namespace conflicts between objects defined in derived classes
    with the base class. To prevent this, the methods we define private attributes
    with have a double underscore, such as `__privateMethod()`. These method names
    are automatically changed to `__Classname_privateMethod()` to prevent name conflicts
    with methods defined in base classes. Be aware that this does not strictly hide
    private attributes, rather it just provides a mechanism for preventing name conflicts.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有规定，所有属性和方法都可以自由访问。这也意味着从基类中定义的所有内容都可以从派生类中访问。当我们构建面向对象的应用程序时，这可能会导致问题，因为我们可能希望隐藏对象的内部实现。这可能会导致派生类中定义的对象与基类之间的命名空间冲突。为了防止这种情况，我们使用双下划线定义私有属性，例如`__privateMethod()`。这些方法名称会自动更改为`__Classname_privateMethod()`，以防止与基类中定义的方法发生命名冲突。请注意，这并不严格隐藏私有属性，而只是提供了一种防止命名冲突的机制。
- en: 'It is recommended to use private attributes when using a class **property**
    to define mutable attributes. A property is a kind of attribute that rather than
    returning a stored value computes its value when called. For example, we could
    redefine the `exp()` property with the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在使用类**属性**定义可变属性时使用私有属性。属性是一种属性，它在调用时不返回存储的值，而是计算其值。例如，我们可以使用以下方式重新定义`exp()`属性：
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has given us a basic fundamental and an introduction to the Python
    programming. We described various data structures and algorithms provided by the
    python. We covered the use of variables, lists, a couple of control structures,
    and learned how to use the conditional statement. We also discussed how functions
    are used in python.  The various kinds of objects were discussed, together with
    some materials on the object-oriented aspects of the Python language. We created
    our own objects and inherited from them.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们提供了Python编程的基本基础和介绍。我们描述了Python提供的各种数据结构和算法。我们涵盖了变量的使用，列表，一些控制结构，并学习了如何使用条件语句。我们还讨论了Python中如何使用函数。我们讨论了各种类型的对象，以及Python语言面向对象的一些内容。我们创建了自己的对象并从中继承。
- en: There is still more that Python offers. As we prepare to examine the later chapters
    on some implementations of algorithms, the next chapter will focus on numbers,
    sequences, maps, and sets. These are also data types in Python that prove useful
    when organizing data for a series of operations.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Python还提供了更多功能。当我们准备在后面的章节中研究一些算法的实现时，下一章将重点介绍数字、序列、映射和集合。这些也是Python中的数据类型，在为一系列操作组织数据时非常有用。
- en: Further reading
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Learning Python* by Fabrizio Romano: [https://www.packtpub.com/application-development/learning-python](https://www.packtpub.com/application-development/learning-python).'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习Python* 作者：Fabrizio Romano: [https://www.packtpub.com/application-development/learning-python](https://www.packtpub.com/application-development/learning-python)。'
