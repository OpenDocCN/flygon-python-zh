- en: When to Use Object-Oriented Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用面向对象编程
- en: In previous chapters, we've covered many of the defining features of object-oriented
    programming. We now know the principles and paradigms of object-oriented design,
    and we've covered the syntax of object-oriented programming in Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们已经涵盖了面向对象编程的许多定义特性。我们现在知道面向对象设计的原则和范例，并且我们已经涵盖了Python中面向对象编程的语法。
- en: 'Yet, we don''t know exactly how and, especially, when to utilize these principles
    and syntax in practice. In this chapter, we''ll discuss some useful applications
    of the knowledge we''ve gained, looking at some new topics along the way:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并不确切知道如何，尤其是何时在实践中利用这些原则和语法。在本章中，我们将讨论我们所获得的知识的一些有用应用，同时查看一些新的主题：
- en: How to recognize objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何识别对象
- en: Data and behaviors, once again
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据和行为，再次
- en: Wrapping data behaviors using properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性封装数据行为
- en: Restricting data using behaviors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用行为限制数据
- en: The Don't Repeat Yourself principle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要重复自己的原则
- en: Recognizing repeated code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别重复的代码
- en: Treat objects as objects
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对象视为对象
- en: 'This may seem obvious; you should generally give separate objects in your problem
    domain a special class in your code. We''ve seen examples of this in the case
    studies in previous chapters: first, we identify objects in the problem, and then
    model their data and behaviors.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很明显；你通常应该在代码中为问题域中的单独对象给予特殊的类。我们在之前章节的案例研究中已经看到了这样的例子：首先，我们确定问题中的对象，然后对其数据和行为进行建模。
- en: Identifying objects is a very important task in object-oriented analysis and
    programming. But it isn't always as easy as counting the nouns in short paragraphs
    that, frankly, I have constructed explicitly for that purpose. Remember, objects
    are things that have both data and behavior. If we are working only with data,
    we are often better off storing it in a list, set, dictionary, or other Python
    data structure. On the other hand, if we are working only with behavior, but no
    stored data, a simple function is more suitable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象分析和编程中，识别对象是一项非常重要的任务。但这并不总是像计算短段落中的名词那样容易，坦率地说，我明确为此目的构建了。记住，对象是既有数据又有行为的东西。如果我们只处理数据，通常最好将其存储在列表、集合、字典或其他Python数据结构中。另一方面，如果我们只处理行为，但没有存储的数据，一个简单的函数更合适。
- en: An object, however, has both data and behavior. Proficient Python programmers
    use built-in data structures unless (or until) there is an obvious need to define
    a class. There is no reason to add an extra level of abstraction if it doesn't
    help organize our code. On the other hand, the *obvious* need is not always self-evident.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对象既有数据又有行为。熟练的Python程序员使用内置数据结构，除非（或直到）明显需要定义一个类。如果这并没有帮助组织我们的代码，那么没有理由添加额外的抽象级别。另一方面，*明显的*需要并不总是不言自明的。
- en: 'We can often start our Python programs by storing data in a few variables.
    As the program expands, we will later find that we are passing the same set of
    related variables to a set of functions. This is the time to think about grouping
    both variables and functions into a class. If we are designing a program to model
    polygons in two-dimensional space, we might start with each polygon represented
    as a list of points. The points would be modeled as two tuples (*x*, *y*) describing
    where that point is located. This is all data, stored in a set of nested data
    structures (specifically, a list of tuples):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常可以通过将数据存储在几个变量中来启动我们的Python程序。随着程序的扩展，我们将会发现我们正在将相同的一组相关变量传递给一组函数。这是思考将变量和函数组合成一个类的时候了。如果我们正在设计一个在二维空间中模拟多边形的程序，我们可能会从将每个多边形表示为点列表开始。这些点将被建模为两个元组（*x*，*y*），描述该点的位置。这是所有的数据，存储在一组嵌套的数据结构中（具体来说，是一个元组列表）：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, if we want to calculate the distance around the perimeter of the polygon,
    we need to sum the distances between each point. To do this, we need a function
    to calculate the distance between two points. Here are two such functions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要计算多边形周长的距离，我们需要计算每个点之间的距离。为此，我们需要一个函数来计算两点之间的距离。以下是两个这样的函数：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, as object-oriented programmers, we clearly recognize that a `polygon`
    class could encapsulate the list of points (data) and the `perimeter` function
    (behavior). Further, a `point` class, such as we defined in [Chapter 16](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml),
    *Objects in Python*, might encapsulate the `x` and `y` coordinates and the `distance`
    method. The question is: is it valuable to do this?'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为面向对象的程序员，我们清楚地认识到`polygon`类可以封装点的列表（数据）和`perimeter`函数（行为）。此外，`point`类，就像我们在[第16章](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml)中定义的那样，*Python中的对象*，可能封装`x`和`y`坐标以及`distance`方法。问题是：这样做有价值吗？
- en: 'For the previous code, maybe yes, maybe no. With our recent experience in object-oriented
    principles, we can write an object-oriented version in record time. Let''s compare
    them as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以前的代码，也许是，也许不是。有了我们最近在面向对象原则方面的经验，我们可以以创纪录的速度编写面向对象的版本。让我们进行比较：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see from the highlighted sections, there is twice as much code here
    as there was in our earlier version, although we could argue that the `add_point`
    method is not strictly necessary.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从突出显示的部分所看到的，这里的代码量是我们之前版本的两倍，尽管我们可以争辩说`add_point`方法并不是严格必要的。
- en: 'Now, to understand the differences a little better, let''s compare the two
    APIs in use. Here''s how to calculate the perimeter of a square using the object-oriented
    code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了更好地理解这两种API之间的差异，让我们比较一下两种使用情况。以下是使用面向对象的代码计算正方形的周长：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That''s fairly succinct and easy to read, you might think, but let''s compare
    it to the function-based code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来相当简洁和易读，但让我们将其与基于函数的代码进行比较：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Hmm, maybe the object-oriented API isn't so compact! That said, I'd argue that
    it was easier to *read* than the functional example. How do we know what the list
    of tuples is supposed to represent in the second version? How do we remember what
    kind of object we're supposed to pass into the `perimeter` function? (a list of
    two tuples? That's not intuitive!) We would need a lot of documentation to explain
    how these functions should be used.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，也许面向对象的API并不那么紧凑！也就是说，我认为它比函数示例更容易*阅读*。我们怎么知道第二个版本中的元组列表应该表示什么？我们怎么记得我们应该传递到`perimeter`函数的对象是什么？（两个元组的列表？这不直观！）我们需要大量的文档来解释这些函数应该如何使用。
- en: In contrast, the object-oriented code is relatively self-documenting. We just
    have to look at the list of methods and their parameters to know what the object
    does and how to use it. By the time we wrote all the documentation for the functional
    version, it would probably be longer than the object-oriented code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，面向对象的代码相对自我说明。我们只需要查看方法列表及其参数，就可以知道对象的功能和如何使用它。当我们为函数版本编写所有文档时，它可能会比面向对象的代码还要长。
- en: Finally, code length is not a good indicator of code complexity. Some programmers
    get hung up on complicated *one liners* that do an incredible amount of work in
    one line of code. This can be a fun exercise, but the result is often unreadable,
    even to the original author the following day. Minimizing the amount of code can
    often make a program easier to read, but do not blindly assume this is the case.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码长度并不是代码复杂性的良好指标。一些程序员会陷入复杂的*一行代码*中，这一行代码可以完成大量工作。这可能是一个有趣的练习，但结果通常是令人难以阅读的，即使对于原始作者来说，第二天也是如此。最小化代码量通常可以使程序更易于阅读，但不要盲目地假设这是正确的。
- en: 'Luckily, this trade-off isn''t necessary. We can make the object-oriented `Polygon`
    API as easy to use as the functional implementation. All we have to do is alter
    our `Polygon` class so that it can be constructed with multiple points. Let''s
    give it an initializer that accepts a list of `Point` objects. In fact, let''s
    allow it to accept tuples too, and we can construct the `Point` objects ourselves,
    if needed:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种权衡是不必要的。我们可以使面向对象的`Polygon` API与函数实现一样易于使用。我们只需要修改我们的`Polygon`类，使其可以用多个点构造。让我们给它一个接受`Point`对象列表的初始化器。事实上，让我们也允许它接受元组，如果需要，我们可以自己构造`Point`对象：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This initializer goes through the list and ensures that any tuples are converted
    to points. If the object is not a tuple, we leave it as is, assuming that it is
    either a `Point` object already, or an unknown duck-typed object that can act
    like a `Point` object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始化器遍历列表，并确保任何元组都转换为点。如果对象不是元组，我们将其保留，假设它已经是`Point`对象，或者是一个未知的鸭子类型对象，可以像`Point`对象一样工作。
- en: If you are experimenting with the above code, you could subclass `Polygon` and
    override the `__init__` function instead of replacing the initializer or copying
    the `add_point` and `perimeter` methods.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在尝试上述代码，您可以对`Polygon`进行子类化，并覆盖`__init__`函数，而不是替换初始化器或复制`add_point`和`perimeter`方法。
- en: Still, there's no clear winner between the object-oriented and more data-oriented
    versions of this code. They both do the same thing. If we have new functions that
    accept a polygon argument, such as `area(polygon)` or `point_in_polygon(polygon,
    x, y)`, the benefits of the object-oriented code become increasingly obvious.
    Likewise, if we add other attributes to the polygon, such as `color` or `texture`,
    it makes more and more sense to encapsulate that data into a single class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在面向对象和更注重数据的版本之间没有明显的赢家。它们都做同样的事情。如果我们有新的函数接受多边形参数，比如`area(polygon)`或`point_in_polygon(polygon,
    x, y)`，面向对象代码的好处变得越来越明显。同样，如果我们为多边形添加其他属性，比如`color`或`texture`，将这些数据封装到一个类中就变得更有意义。
- en: The distinction is a design decision, but in general, the more important a set
    of data is, the more likely it is to have multiple functions specific to that
    data, and the more useful it is to use a class with attributes and methods instead.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 区别是一个设计决策，但一般来说，数据集越重要，就越有可能具有针对该数据的多个特定功能，使用具有属性和方法的类会更有用。
- en: When making this decision, it also pays to consider how the class will be used.
    If we're only trying to calculate the perimeter of one polygon in the context
    of a much greater problem, using a function will probably be quickest to code
    and easier to use *one time only*. On the other hand, if our program needs to
    manipulate numerous polygons in a wide variety of ways (calculating the perimeter,
    area, and intersection with other polygons, moving or scaling them, and so on),
    we have almost certainly identified an object; one that needs to be extremely
    versatile.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这个决定时，考虑类将如何使用也是很重要的。如果我们只是试图在更大的问题的背景下计算一个多边形的周长，使用函数可能会是编码最快且最容易*仅一次*使用。另一方面，如果我们的程序需要以各种方式操作大量多边形（计算周长、面积和与其他多边形的交集、移动或缩放它们等），我们几乎肯定已经确定了一个对象；一个需要非常灵活的对象。
- en: Additionally, pay attention to the interaction between objects. Look for inheritance
    relationships; inheritance is impossible to model elegantly without classes, so
    make sure to use them. Look for the other types of relationships we discussed
    in [Chapter 15](c232a9c5-f0ac-46d8-8c31-41aa4d225a71.xhtml), *Object-Oriented
    Design*, association and composition. Composition can, technically, be modeled
    using only data structures; for example, we can have a list of dictionaries holding
    tuple values, but it is sometimes less complicated to create a few classes of
    objects, especially if there is behavior associated with the data.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，要注意对象之间的交互。寻找继承关系；继承无法在没有类的情况下优雅地建模，因此一定要使用它们。寻找我们在[第15章](c232a9c5-f0ac-46d8-8c31-41aa4d225a71.xhtml)中讨论的其他类型的关系，*面向对象设计*，关联和组合。组合在技术上可以使用只有数据结构来建模；例如，我们可以有一个包含元组值的字典列表，但有时创建几个对象类会更不复杂，特别是如果与数据相关联的行为。
- en: Don't rush to use an object just because you can use an object, but don't neglect
    to create a class when you need to use a class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不要急于使用对象，只是因为你可以使用对象，但是当你需要使用类时，不要忽视创建一个类。
- en: Adding behaviors to class data with properties
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性为类数据添加行为
- en: Throughout this book, we've focused on the separation of behavior and data.
    This is very important in object-oriented programming, but we're about to see
    that, in Python, the distinction is uncannily blurry. Python is very good at blurring
    distinctions; it doesn't exactly help us to *think outside the box*. Rather, it
    teaches us to stop thinking about the box.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直专注于行为和数据的分离。这在面向对象编程中非常重要，但是我们将看到，在Python中，这种区别是模糊的。Python非常擅长模糊界限；它并不完全帮助我们*打破思维定势*。相反，它教会我们停止思考盒子。
- en: 'Before we get into the details, let''s discuss some bad object-oriented theory.
    Many object-oriented languages teach us to never access attributes directly (Java
    is the most notorious). They insist that we write attribute access like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入细节之前，让我们讨论一些糟糕的面向对象理论。许多面向对象的语言教导我们永远不要直接访问属性（Java是最臭名昭著的）。他们坚持我们应该像这样写属性访问：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The variables are prefixed with an underscore to suggest that they are private
    (other languages would actually force them to be private). Then, the `get` and
    `set` methods provide access to each variable. This class would be used in practice
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 变量以下划线开头，表示它们是私有的（其他语言实际上会强制它们为私有）。然后，`get`和`set`方法提供对每个变量的访问。这个类将在实践中使用如下：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is not nearly as readable as the direct access version that Python favors:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这不像Python青睐的直接访问版本那样易读：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, why would anyone insist upon the method-based syntax? Their reasoning is
    that, someday, we may want to add extra code when a value is set or retrieved.
    For example, we could decide to cache a value to avoid complex computations, or
    we might want to validate that a given value is a suitable input.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么有人坚持使用基于方法的语法呢？他们的理由是，有一天，我们可能希望在设置或检索值时添加额外的代码。例如，我们可以决定缓存一个值以避免复杂的计算，或者我们可能希望验证给定的值是否是合适的输入。
- en: 'In code, for example, we could decide to change the `set_name()` method as
    follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在代码中，我们可以决定将`set_name()`方法更改如下：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, in Java and similar languages, if we had written our original code for
    direct attribute access, and then later changed it to a method like the preceding
    one, we''d have a problem: anyone who had written code that accessed the attribute
    directly would now have to access a method. If they didn''t then change the access
    style from attribute access to a function call, their code will be broken.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Java和类似的语言中，如果我们最初为直接属性访问编写了原始代码，然后稍后将其更改为像前面的方法，我们会有问题：任何访问属性的代码现在都必须访问一个方法。如果他们没有将访问样式从属性访问更改为函数调用，他们的代码将会出错。
- en: The mantra in these languages is that we should never make public members private.
    This doesn't make much sense in Python since there isn't any real concept of private
    members!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语言中的口头禅是我们永远不应该将公共成员变为私有成员。这在Python中并没有太多意义，因为Python没有真正的私有成员的概念！
- en: 'Python gives us the `property` keyword to make methods that *look* like attributes.
    We can therefore write our code to use direct member access, and if we ever unexpectedly
    need to alter the implementation to do some calculation when getting or setting
    that attribute''s value, we can do so without changing the interface. Let''s see
    how it looks:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Python给了我们`property`关键字，可以使方法看起来像属性。因此，我们可以编写代码来直接访问成员，如果我们需要在获取或设置属性值时进行一些计算，我们可以在不改变接口的情况下进行修改。让我们看看它是什么样子：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Compared to the earlier class, we first change the `name` attribute into a (semi-)private
    `_name` attribute. Then, we add two more (semi-)private methods to get and set
    that variable, performing our validation when we set it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的类相比，我们首先将`name`属性更改为(半)私有的`_name`属性。然后，我们添加了两个更多的(半)私有方法来获取和设置该变量，在设置时执行验证。
- en: 'Finally, we have the `property` declaration at the bottom. This is the Python
    magic. It creates a new attribute on the `Color` class called `name`, to replace
    the direct `name` attribute. It sets this attribute to be a **property**. Under
    the hood, `property` calls the two methods we just created whenever the value
    is accessed or changed. This new version of the `Color` class can be used exactly
    the same way as the earlier version, yet it now performs validation when we set
    the `name` attribute:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在底部有`property`声明。这就是Python的魔力。它在`Color`类上创建了一个名为`name`的新属性，以替换直接的`name`属性。它将此属性设置为**property**。在幕后，`property`在访问或更改值时调用我们刚刚创建的两个方法。这个新版本的`Color`类可以像以前的版本一样使用，但是现在在设置`name`属性时执行验证：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, if we'd previously written code to access the `name` attribute, and then
    changed it to use our `property`-based object, the previous code would still work,
    unless it was sending an empty `property` value, which is the behavior we wanted
    to forbid in the first place. Success!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们以前编写了访问`name`属性的代码，然后更改为使用基于`property`的对象，以前的代码仍然可以工作，除非它发送了一个空的`property`值，这正是我们想要在第一次禁止的行为。成功！
- en: Bear in mind that, even with the `name` property, the previous code is not 100%
    safe. People can still access the `_name` attribute directly and set it to an
    empty string if they want to. But if they access a variable we've explicitly marked
    with an underscore to suggest it is private, they're the ones that have to deal
    with the consequences, not us.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，即使有了`name`属性，以前的代码也不是100%安全的。人们仍然可以直接访问`_name`属性，并将其设置为空字符串。但是，如果他们访问了我们明确标记为下划线的变量，暗示它是私有的，他们就必须处理后果，而不是我们。
- en: Properties in detail
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性详解
- en: Think of the `property` function as returning an object that proxies any requests
    to set or access the attribute value through the methods we have specified. The
    `property` built-in is like a constructor for such an object, and that object
    is set as the public-facing member for the given attribute.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将`property`函数视为返回一个对象，通过我们指定的方法代理对设置或访问属性值的任何请求。内置的`property`就像这样的对象的构造函数，并且该对象被设置为给定属性的公共成员。
- en: 'This `property` constructor can actually accept two additional arguments, a
    `delete` function and a docstring for the property. The `delete` function is rarely
    supplied in practice, but it can be useful for logging the fact that a value has
    been deleted, or possibly to veto deleting if we have reason to do so. The docstring
    is just a string describing what the property does, no different from the docstrings
    we discussed in [Chapter 16](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml), *Objects
    in Python*. If we do not supply this parameter, the docstring will instead be
    copied from the docstring for the first argument: the `getter` method. Here is
    a silly example that states whenever any of the methods are called:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`property`构造函数实际上可以接受两个额外的参数，一个`delete`函数和一个属性的文档字符串。在实践中很少提供`delete`函数，但如果我们有理由这样做，它可能对记录已删除的值或可能否决删除很有用。文档字符串只是描述属性功能的字符串，与我们在[第16章](9179e7f0-fea3-4c8a-b134-a190544099b4.xhtml)中讨论的文档字符串没有什么不同，*Python中的对象*。如果我们不提供此参数，文档字符串将从第一个参数的文档字符串复制：`getter`方法。这是一个愚蠢的例子，说明每当调用任何方法时：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we actually use this class, it does indeed print out the correct strings
    when we ask it to:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实际使用这个类，当我们要求它时，它确实会打印出正确的字符串：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Further, if we look at the help file for the `Silly` class (by issuing `help(Silly)`
    at the interpreter prompt), it shows us the custom docstring for our `silly` attribute:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们查看`Silly`类的帮助文件（通过在解释器提示符处发出`help(Silly)`），它会显示我们的`silly`属性的自定义文档字符串：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once again, everything is working as we planned. In practice, properties are
    normally only defined with the first two parameters: the `getter` and `setter`
    functions. If we want to supply a docstring for a property, we can define it on
    the `getter` function; the property proxy will copy it into its own docstring.
    The `delete` function is often left empty because object attributes are so rarely
    deleted. If a coder does try to delete a property that doesn''t have a `delete`
    function specified, it will raise an exception. Therefore, if there is a legitimate
    reason to delete our property, we should supply that function.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，一切都按我们计划的那样运行。在实践中，属性通常只使用前两个参数进行定义：`getter`和`setter`函数。如果我们想为属性提供文档字符串，我们可以在`getter`函数上定义它；属性代理将把它复制到自己的文档字符串中。`delete`函数通常为空，因为对象属性很少被删除。如果程序员尝试删除没有指定`delete`函数的属性，它将引发异常。因此，如果有正当理由删除我们的属性，我们应该提供该函数。
- en: Decorators – another way to create properties
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器-创建属性的另一种方法
- en: If you've never used Python decorators before, you might want to skip this section
    and come back to it after we've discussed the decorator pattern in [Chapter 22](f09b264b-a4c5-4a1e-9911-8f00ca74144c.xhtml),
    *Python Design Patterns I*. However, you don't need to understand what's going
    on to use the decorator syntax in order to make property methods more readable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前从未使用过Python装饰器，您可能希望跳过本节，在我们讨论[第22章](f09b264b-a4c5-4a1e-9911-8f00ca74144c.xhtml)中的装饰器模式之后再回来，*Python设计模式I*。但是，您不需要理解正在发生的事情，以使用装饰器语法来使属性方法更易读。
- en: 'The `property` function can be used with the decorator syntax to turn a `get`
    function into a `property` function, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`property`函数可以与装饰器语法一起使用，将`get`函数转换为`property`函数，如下所示：'
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This applies the `property` function as a decorator, and is equivalent to the
    previous `foo = property(foo)` syntax. The main difference, from a readability
    perspective, is that we get to mark the `foo` function as a property at the top
    of the method, instead of after it is defined, where it can be easily overlooked.
    It also means we don't have to create private methods with underscore prefixes
    just to define a property.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`property`函数应用为装饰器，并且等同于以前的`foo = property(foo)`语法。从可读性的角度来看，主要区别在于我们可以在方法的顶部将`foo`函数标记为属性，而不是在定义之后，这样很容易被忽视。这也意味着我们不必创建带有下划线前缀的私有方法来定义属性。
- en: 'Going one step further, we can specify a `setter` function for the new property
    as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，我们可以为新属性指定一个`setter`函数，如下所示：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This syntax looks pretty odd, although the intent is obvious. First, we decorate
    the `foo` method as a getter. Then, we decorate a second method with exactly the
    same name by applying the `setter` attribute of the originally decorated `foo`
    method! The `property` function returns an object; this object always comes with
    its own `setter` attribute, which can then be applied as a decorator to other
    functions. Using the same name for the get and set methods is not required, but
    it does help to group together the multiple methods that access one property.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法看起来很奇怪，尽管意图是明显的。首先，我们将`foo`方法装饰为getter。然后，我们通过应用最初装饰的`foo`方法的`setter`属性，装饰了第二个同名方法！`property`函数返回一个对象；这个对象总是带有自己的`setter`属性，然后可以将其应用为其他函数的装饰器。使用相同的名称来命名获取和设置方法并不是必需的，但它确实有助于将访问一个属性的多个方法分组在一起。
- en: 'We can also specify a `delete` function with `@foo.deleter`. We cannot specify
    a docstring using `property` decorators, so we need to rely on the property copying
    the docstring from the initial getter method. Here''s our previous `Silly` class
    rewritten to use `property` as a decorator:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`@foo.deleter`指定一个`delete`函数。我们不能使用`property`装饰器来指定文档字符串，因此我们需要依赖于属性从初始getter方法复制文档字符串。下面是我们之前的`Silly`类重写，以使用`property`作为装饰器：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This class operates *exactly* the same as our earlier version, including the
    help text. You can use whichever syntax you feel is more readable and elegant.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的操作*完全*与我们之前的版本相同，包括帮助文本。您可以使用您认为更可读和优雅的任何语法。
- en: Deciding when to use properties
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定何时使用属性
- en: With the built-in property clouding the division between behavior and data,
    it can be confusing to know when to choose an attribute, or a method, or a property.
    The use case example we saw earlier is one of the most common uses of properties;
    we have some data on a class that we later want to add behavior to. There are
    also other factors to take into account when deciding to use a property.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内置的属性模糊了行为和数据之间的区分，很难知道何时选择属性、方法或属性。我们之前看到的用例示例是属性的最常见用法之一；我们在类上有一些数据，然后希望添加行为。在决定使用属性时，还有其他因素需要考虑。
- en: Technically, in Python, data, properties, and methods are all attributes on
    a class. The fact that a method is callable does not distinguish it from other
    types of attributes; indeed, we'll see in [Chapter 20](72a5d45b-2ade-4c5d-a00c-1c1a36e1a510.xhtml),
    *Python Object-Oriented Shortcuts*, that it is possible to create normal objects
    that can be called like functions. We'll also discover that functions and methods
    are themselves normal objects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，数据、属性和方法在类上都是属性。方法可调用的事实并不能将其与其他类型的属性区分开；事实上，我们将在[第20章](72a5d45b-2ade-4c5d-a00c-1c1a36e1a510.xhtml)中看到，*Python面向对象的快捷方式*，可以创建可以像函数一样调用的普通对象。我们还将发现函数和方法本身也是普通对象。
- en: The fact that methods are just callable attributes, and properties are just
    customizable attributes, can help us make this decision. Methods should typically
    represent actions; things that can be done to, or performed by, the object. When
    you call a method, even with only one argument, it should *do* something. Method
    names are generally verbs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 方法只是可调用的属性，属性只是可定制的属性，这可以帮助我们做出这个决定。方法通常应该表示动作；可以对对象执行的操作。当你调用一个方法时，即使只有一个参数，它也应该*做*一些事情。方法名称通常是动词。
- en: Once confirming that an attribute is not an action, we need to decide between
    standard data attributes and properties. In general, always use a standard attribute
    until you need to control access to that property in some way. In either case,
    your attribute is usually a noun. The only difference between an attribute and
    a property is that we can invoke custom actions automatically when a property
    is retrieved, set, or deleted.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 确认属性不是一个动作后，我们需要在标准数据属性和属性之间做出选择。通常情况下，始终使用标准属性，直到需要以某种方式控制对该属性的访问。无论哪种情况，您的属性通常是一个名词。属性和属性之间唯一的区别是，当检索、设置或删除属性时，我们可以自动调用自定义操作。
- en: Let's look at a more realistic example. A common need for custom behavior is
    caching a value that is difficult to calculate or expensive to look up (requiring,
    for example, a network request or database query). The goal is to store the value
    locally to avoid repeated calls to the expensive calculation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更现实的例子。自定义行为的常见需求是缓存难以计算或昂贵的查找值（例如，需要网络请求或数据库查询）。目标是将值存储在本地，以避免重复调用昂贵的计算。
- en: 'We can do this with a custom getter on the property. The first time the value
    is retrieved, we perform the lookup or calculation. Then, we can locally cache
    the value as a private attribute on our object (or in dedicated caching software),
    and the next time the value is requested, we return the stored data. Here''s how
    we might cache a web page:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过属性的自定义getter来实现这一点。第一次检索值时，我们执行查找或计算。然后，我们可以将值作为对象的私有属性（或专用缓存软件中）进行本地缓存，下次请求值时，我们返回存储的数据。以下是我们可能缓存网页的方法：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can test this code to see that the page is only retrieved once:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试这段代码，以查看页面只被检索一次：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I was on an awful satellite connection when I originally tested this code for
    the first version of this book back in 2010 and it took 20 seconds the first time
    I loaded the content. The second time, I got the result in 2 seconds (which is
    really just the amount of time it took to type the lines into the interpreter).
    On my more modern connection it looks as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我在2010年首次测试这段代码时使用的是糟糕的卫星连接，第一次加载内容花了20秒。第二次，我在2秒内得到了结果（实际上只是在解释器中输入这些行所花费的时间）。在我更现代的连接上，情况如下：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It takes about 620 milliseconds to retrieve a page from my web host. From my
    laptop's RAM, it takes 0.018 milliseconds!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从我的网络主机检索页面大约需要620毫秒。从我的笔记本电脑的RAM中，只需要0.018毫秒！
- en: 'Custom getters are also useful for attributes that need to be calculated on
    the fly, based on other object attributes. For example, we might want to calculate
    the average for a list of integers:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义getter也适用于需要根据其他对象属性动态计算的属性。例如，我们可能想要计算整数列表的平均值：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This very simple class inherits from `list`, so we get list-like behavior for
    free. We just add a property to the class, and hey presto, our list can have an
    average as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常简单的类继承自`list`，所以我们可以免费获得类似列表的行为。我们只需向类添加一个属性，就可以得到列表的平均值。
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Of course, we could have made this a method instead, but then we ought to call
    it `calculate_average()`, since methods represent actions. But a property called
    `average` is more suitable, and is both easier to type and easier to read.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以将其制作成一个方法，但那样我们应该将其命名为`calculate_average()`，因为方法代表动作。但名为`average`的属性更合适，而且更容易输入和阅读。
- en: Custom setters are useful for validation, as we've already seen, but they can
    also be used to proxy a value to another location. For example, we could add a
    content setter to the `WebPage` class that automatically logs into our web server
    and uploads a new page whenever the value is set.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义setter对于验证是有用的，正如我们已经看到的，但它们也可以用于将值代理到另一个位置。例如，我们可以为`WebPage`类添加一个内容setter，以便在设置值时自动登录到我们的Web服务器并上传新页面。
- en: Manager objects
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理对象
- en: We've been focused on objects and their attributes and methods. Now, we'll take
    a look at designing higher-level objects; the kind of objects that manage other
    objects – the objects that tie everything together.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直专注于对象及其属性和方法。现在，我们将看看如何设计更高级的对象；管理其他对象的对象 - 将所有东西联系在一起的对象。
- en: The difference between these objects and most of the previous examples is that
    the latter usually represent concrete ideas. Management objects are more like
    office managers; they don't do the actual *visible* work out on the floor, but
    without them, there would be no communication between departments and nobody would
    know what they are supposed to do (although, this can be true anyway if the organization
    is badly managed!). Analogously, the attributes on a management class tend to
    refer to other objects that do the *visible* work; the behaviors on such a class
    delegate to those other classes at the right time, and pass messages between them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象与大多数先前的示例之间的区别在于，后者通常代表具体的想法。管理对象更像办公室经理；他们不会在现场进行实际的*可见*工作，但没有他们，部门之间就不会有沟通，也没有人知道他们应该做什么（尽管如果组织管理不善，这也可能是真的！）。类似地，管理类上的属性倾向于引用做*可见*工作的其他对象；这样的类上的行为在适当的时候委托给这些其他类，并在它们之间传递消息。
- en: 'As an example, we''ll write a program that does a find-and-replace action for
    text files stored in a compressed ZIP file. We''ll need objects to represent the
    ZIP file and each individual text file (luckily, we don''t have to write these
    classes, as they''re available in the Python standard library). The manager object
    will be responsible for ensuring the following three steps occur in order:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将编写一个程序，对存储在压缩的ZIP文件中的文本文件执行查找和替换操作。我们需要对象来表示ZIP文件和每个单独的文本文件（幸运的是，我们不必编写这些类，因为它们在Python标准库中可用）。管理对象将负责确保以下三个步骤按顺序发生：
- en: Unzipping the compressed file
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压缩压缩文件
- en: Performing the find-and-replace action
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行查找和替换操作
- en: Zipping up the new files
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 压缩新文件
- en: 'The class is initialized with the `.zip` filename, and search and replace strings.
    We create a temporary directory to store the unzipped files in, so that the folder
    stays clean. The `pathlib` library helps out with file and directory manipulation.
    The interface should be pretty clear in the following example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该类使用`.zip`文件名、搜索和替换字符串进行初始化。我们创建一个临时目录来存储解压后的文件，以便文件夹保持干净。`pathlib`库在文件和目录操作中提供帮助。接口在以下示例中应该很清楚：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we create an overall *manager* method for each of the three steps. This
    method delegates responsibility to other objects:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为三个步骤创建一个整体*管理*方法。该方法将责任委托给其他对象：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Obviously, we could do all three steps in one method, or indeed in one script,
    without ever creating an object. There are several advantages to separating the
    three steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以在一个方法中完成所有三个步骤，或者在一个脚本中完成，而不必创建对象。将三个步骤分开有几个优点：
- en: '**Readability**: The code for each step is in a self-contained unit that is
    easy to read and understand. The method name describes what the method does, and
    less additional documentation is required to understand what is going on.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可读性：每个步骤的代码都在一个易于阅读和理解的自包含单元中。方法名称描述了方法的作用，需要更少的额外文档来理解正在发生的事情。
- en: '**Extensibility**: If a subclass wanted to use compressed TAR files instead
    of ZIP files, it could override the `zip` and `unzip` methods without having to
    duplicate the `find_replace` method.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性：如果子类想要使用压缩的TAR文件而不是ZIP文件，它可以重写`zip`和`unzip`方法，而无需复制`find_replace`方法。
- en: '**Partitioning**: An external class could create an instance of this class
    and call the `find_replace` method directly on some folder without having to `zip`
    the content.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区：外部类可以创建此类的实例，并在不必`zip`内容的情况下直接在某个文件夹上调用`find_replace`方法。
- en: 'The delegation method is the first in the following code; the rest of the methods
    are included for completeness:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 委托方法是以下代码中的第一个；其余方法包括在内是为了完整性：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For brevity, the code for zipping and unzipping files is sparsely documented.
    Our current focus is on object-oriented design; if you are interested in the inner
    details of the `zipfile` module, refer to the documentation in the standard library,
    either online or by typing `import zipfile ; help(zipfile)` into your interactive
    interpreter. Note that this toy example only searches the top-level files in a
    ZIP file; if there are any folders in the unzipped content, they will not be scanned,
    nor will any files inside those folders.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，对于压缩和解压缩文件的代码文档很少。我们目前关注的是面向对象的设计；如果您对`zipfile`模块的内部细节感兴趣，请参考标准库中的文档，可以在线查看，也可以在交互式解释器中输入`import
    zipfile ; help(zipfile)`。请注意，此玩具示例仅搜索ZIP文件中的顶层文件；如果解压后的内容中有任何文件夹，它们将不会被扫描，也不会扫描这些文件夹中的任何文件。
- en: If you are using a Python version older than 3.6, you will need to convert the
    path objects to strings before calling `extractall`, `rmtree`, and `file.write`
    on the `ZipFile` object.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是早于3.6的Python版本，则需要在调用`ZipFile`对象上的`extractall`、`rmtree`和`file.write`之前将路径对象转换为字符串。
- en: 'The last two lines in the example allow us to run the program from the command
    line by passing the `zip` filename, the search string, and the replace string
    as arguments, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的最后两行允许我们通过传递`zip`文件名、搜索字符串和替换字符串作为参数来从命令行运行程序，如下所示：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Of course, this object does not have to be created from the command line; it
    could be imported from another module (to perform batch ZIP file processing),
    or accessed as part of a GUI interface or even a higher-level management object
    that knows where to get ZIP files (for example, to retrieve them from an FTP server
    or back them up to an external disk).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个对象不一定要从命令行创建；它可以从另一个模块导入（执行批量ZIP文件处理），或者作为GUI界面的一部分访问，甚至作为一个更高级别的管理对象的一部分，该对象知道从哪里获取ZIP文件（例如，从FTP服务器检索它们或将它们备份到外部磁盘）。
- en: As programs become more and more complex, the objects being modeled become less
    and less like physical objects. Properties are other abstract objects, and methods
    are actions that change the state of those abstract objects. But at the heart
    of every object, no matter how complex, is a set of concrete data and well-defined
    behaviors.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 随着程序变得越来越复杂，被建模的对象变得越来越不像物理对象。属性是其他抽象对象，方法是改变这些抽象对象状态的行为。但无论多么复杂，每个对象的核心都是一组具体数据和明确定义的行为。
- en: Removing duplicate code
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除重复的代码
- en: Often, the code in management style classes such as `ZipReplace` is quite generic
    and can be applied in a variety of ways. It is possible to use either composition
    or inheritance to help keep this code in one place, thus eliminating duplicate
    code. Before we look at any examples of this, let's discuss a tiny bit of theory.
    Specifically, why is duplicate code a bad thing?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，诸如`ZipReplace`之类的管理样式类中的代码非常通用，可以以各种方式应用。可以使用组合或继承来帮助将此代码放在一个地方，从而消除重复代码。在我们查看任何此类示例之前，让我们讨论一点理论。具体来说，为什么重复代码是一件坏事？
- en: There are several reasons, but they all boil down to readability and maintainability.
    When we're writing a new piece of code that is similar to an earlier piece, the
    easiest thing to do is copy the old code and change whatever needs to be changed
    (variable names, logic, comments) to make it work in the new location. Alternatively,
    if we're writing new code that seems similar, but not identical, to code elsewhere
    in the project, it is often easier to write fresh code with similar behavior,
    rather than figuring out how to extract the overlapping functionality.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因，但归根结底都是可读性和可维护性。当我们编写类似于早期代码的新代码时，最容易的方法是复制旧代码并更改需要更改的内容（变量名称、逻辑、注释），使其在新位置上运行。或者，如果我们正在编写似乎类似但不完全相同的新代码，与项目中的其他代码相比，通常更容易编写具有类似行为的新代码，而不是弄清楚如何提取重叠功能。
- en: But as soon as someone has to read and understand the code and they come across
    duplicate blocks, they are faced with a dilemma. Code that might have appeared
    to make sense suddenly has to be understood. How is one section different from
    the other? How are they the same? Under what conditions is one section called?
    When do we call the other? You might argue that you're the only one reading your
    code, but if you don't touch that code for eight months, it will be as incomprehensible
    to you as it is to a fresh coder. When we're trying to read two similar pieces
    of code, we have to understand why they're different, as well as how they're different.
    This wastes the reader's time; code should always be written to be readable first.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一旦有人阅读和理解代码，并且遇到重复的代码块，他们就面临着两难境地。可能看起来有意义的代码突然必须被理解。一个部分与另一个部分有何不同？它们如何相同？在什么条件下调用一个部分？我们什么时候调用另一个部分？你可能会争辩说你是唯一阅读你的代码的人，但是如果你八个月不碰那段代码，它对你来说将和对一个新手编程人员一样难以理解。当我们试图阅读两个相似的代码部分时，我们必须理解它们为何不同，以及它们如何不同。这浪费了读者的时间；代码应始终被编写为首要可读性。
- en: I once had to try to understand someone's code that had three identical copies
    of the same 300 lines of very poorly written code. I had been working with the
    code for a month before I finally comprehended that the three *identical* versions
    were actually performing slightly different tax calculations. Some of the subtle
    differences were intentional, but there were also obvious areas where someone
    had updated a calculation in one function without updating the other two. The
    number of subtle, incomprehensible bugs in the code could not be counted. I eventually
    replaced all 900 lines with an easy-to-read function of 20 lines or so.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经不得不尝试理解某人的代码，其中有三个完全相同的300行非常糟糕的代码副本。在我最终理解这三个*相同*版本实际上执行略有不同的税收计算之前，我已经与这段代码一起工作了一个月。一些微妙的差异是有意的，但也有明显的地方，某人在一个函数中更新了一个计算，而没有更新其他两个。代码中难以理解的微妙错误数量不计其数。最终，我用一个大约20行的易于阅读的函数替换了所有900行。
- en: Reading such duplicate code can be tiresome, but code maintenance is even more
    tormenting. As the preceding story suggests, keeping two similar pieces of code
    up to date can be a nightmare. We have to remember to update both sections whenever
    we update one of them, and we have to remember how multiple sections differ so
    we can modify our changes when we are editing each of them. If we forget to update
    all sections, we will end up with extremely annoying bugs that usually manifest
    themselves as, But I fixed that already, why is it still happening*?*
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读这样的重复代码可能很烦人，但代码维护更加痛苦。正如前面的故事所示，保持两个相似的代码部分最新可能是一场噩梦。每当我们更新其中一个部分时，我们必须记住更新两个部分，并且我们必须记住多个部分的不同之处，以便在编辑每个部分时修改我们的更改。如果我们忘记更新所有部分，我们最终会遇到非常恼人的错误，通常表现为“但我已经修复了，为什么还在发生*？”
- en: The result is that people who are reading or maintaining our code have to spend
    astronomical amounts of time understanding and testing it compared to the time
    required to write it in a non-repetitive manner in the first place. It's even
    more frustrating when we are the ones doing the maintenance; we find ourselves
    saying, Why didn't I do this right the first time? The time we save by copying
    and pasting existing code is lost the very first time we have to maintain it.
    Code is both read and modified many more times and much more often than it is
    written. Comprehensible code should always be a priority.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，阅读或维护我们的代码的人们必须花费天文数字的时间来理解和测试它，而不是在第一次编写时以非重复的方式编写它所需的时间。当我们自己进行维护时，这更加令人沮丧；我们会发现自己说，“为什么我第一次就没做对呢？”通过复制和粘贴现有代码节省的时间在第一次进行维护时就丢失了。代码被阅读和修改的次数比编写的次数多得多，而且频率也更高。可理解的代码应始终是优先考虑的。
- en: This is why programmers, especially Python programmers (who tend to value elegant
    code more than average developers), follow what is known as the **Don't Repeat
    Yourself** (**DRY**) principle. DRY code is maintainable code. My advice for beginning
    programmers is to never use the copy-and-paste feature of their editor. To intermediate
    programmers, I suggest they think thrice before they hit *Ctrl* + *C*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么程序员，尤其是Python程序员（他们倾向于比普通开发人员更重视优雅的代码），遵循所谓的**不要重复自己**（**DRY**）原则。DRY代码是可维护的代码。我给初学者的建议是永远不要使用编辑器的复制粘贴功能。对于中级程序员，我建议他们在按下*Ctrl*
    + *C*之前三思。
- en: But what should we do instead of code duplication? The simplest solution is
    often to move the code into a function that accepts parameters to account for
    whatever parts are different. This isn't a terribly object-oriented solution,
    but it is frequently optimal.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们应该怎么做才能避免代码重复呢？最简单的解决方案通常是将代码移到一个函数中，该函数接受参数以解决不同的部分。这不是一个非常面向对象的解决方案，但通常是最佳的解决方案。
- en: For example, if we have two pieces of code that unzip a ZIP file into two different
    directories, we can easily replace it with a function that accepts a parameter
    for the directory to which it should be unzipped. This may make the function itself
    slightly more difficult to read, but a good function name and docstring can easily
    make up for that, and any code that invokes the function will be easier to read.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有两段代码，它们将ZIP文件解压缩到两个不同的目录中，我们可以很容易地用一个接受目录参数的函数来替换它。这可能会使函数本身稍微难以阅读，但一个好的函数名称和文档字符串很容易弥补这一点，任何调用该函数的代码都会更容易阅读。
- en: 'That''s certainly enough theory! The moral of the story is: always make the
    effort to refactor your code to be easier to read instead of writing bad code
    that may seem easier to write.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够的理论了！故事的寓意是：始终努力重构代码，使其更易读，而不是编写可能看起来更容易的糟糕代码。
- en: In practice
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实践中
- en: Let's explore two ways we can reuse existing code. After writing our code to
    replace strings in a ZIP file full of text files, we are later contracted to scale
    all the images in a ZIP file to 640 x 480\. It looks like we could use a very
    similar paradigm to what we used in `ZipReplace`. Our first impulse might be to
    save a copy of that file and change the `find_replace` method to `scale_image`
    or something similar.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨两种重用现有代码的方法。在编写代码以替换ZIP文件中的文本文件中的字符串后，我们后来受托将ZIP文件中的所有图像缩放到640 x 480。看起来我们可以使用与我们在`ZipReplace`中使用的非常相似的范例。我们的第一反应可能是保存该文件的副本，并将`find_replace`方法更改为`scale_image`或类似的内容。
- en: But, that's suboptimal. What if someday we want to change the `unzip` and `zip`
    methods to also open TAR files? Or maybe we'll want to use a guaranteed unique
    directory name for temporary files. In either case, we'd have to change it in
    two different places!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这是次优的。如果有一天我们想要更改`unzip`和`zip`方法以打开TAR文件呢？或者也许我们想要为临时文件使用一个保证唯一的目录名称。在任何一种情况下，我们都必须在两个不同的地方进行更改！
- en: 'We''ll start by demonstrating an inheritance-based solution to this problem.
    First, we''ll modify our original `ZipReplace` class into a superclass for processing
    generic ZIP files:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从展示基于继承的解决方案开始解决这个问题。首先，我们将修改我们原始的`ZipReplace`类，将其变成一个用于处理通用ZIP文件的超类：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We changed the `filename` property to `zipname` to avoid confusion with the
    `filename` local variables inside the various methods. This helps make the code
    more readable, even though it isn't actually a change in design.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`filename`属性更改为`zipname`，以避免与各种方法内部的`filename`本地变量混淆。这有助于使代码更易读，尽管实际上并没有改变设计。
- en: We also dropped the two parameters to `__init__` (`search_string` and `replace_string`)
    that were specific to `ZipReplace`. Then, we renamed the `zip_find_replace` method
    to `process_zip` and made it call an (as yet undefined) `process_files` method
    instead of `find_replace`; these name changes help demonstrate the more generalized
    nature of our new class. Notice that we have removed the `find_replace` method
    altogether; that code is specific to `ZipReplace` and has no business here.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还删除了`__init__`中的两个参数（`search_string`和`replace_string`），这些参数是特定于`ZipReplace`的。然后，我们将`zip_find_replace`方法重命名为`process_zip`，并让它调用一个（尚未定义的）`process_files`方法，而不是`find_replace`；这些名称更改有助于展示我们新类的更一般化特性。请注意，我们已经完全删除了`find_replace`方法；该代码是特定于`ZipReplace`，在这里没有业务。
- en: This new `ZipProcessor` class doesn't actually define a `process_files` method.
    If we ran it directly, it would raise an exception. Because it isn't meant to
    run directly, we removed the main call at the bottom of the original script. We
    could make this an abstract base class in order to communicate that this method
    needs to be defined in a subclass, but I've left it out for brevity.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`ZipProcessor`类实际上并没有定义`process_files`方法。如果我们直接运行它，它会引发异常。因为它不是用来直接运行的，我们删除了原始脚本底部的主要调用。我们可以将其作为抽象基类，以便传达这个方法需要在子类中定义，但出于简洁起见，我将其省略了。
- en: 'Now, before we move on to our image processing application, let''s fix up our
    original `zipsearch` class to make use of this parent class, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们转向图像处理应用程序之前，让我们修复我们原始的`zipsearch`类，以利用这个父类，如下所示：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code is shorter than the original version, since it inherits its ZIP processing
    abilities from the parent class. We first import the base class we just wrote
    and make `ZipReplace` extend that class. Then, we use `super()` to initialize
    the parent class. The `find_replace` method is still here, but we renamed it `process_files`
    so the parent class can call it from its management interface. Because this name
    isn't as descriptive as the old one, we added a docstring to describe what it
    is doing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比原始版本要短，因为它继承了父类的ZIP处理能力。我们首先导入我们刚刚编写的基类，并使`ZipReplace`扩展该类。然后，我们使用`super()`来初始化父类。`find_replace`方法仍然存在，但我们将其重命名为`process_files`，以便父类可以从其管理界面调用它。因为这个名称不像旧名称那样描述性强，我们添加了一个文档字符串来描述它正在做什么。
- en: Now, that was quite a bit of work, considering that all we have now is a program
    that is functionally not different from the one we started with! But having done
    that work, it is now much easier for us to write other classes that operate on
    files in a ZIP archive, such as the (hypothetically requested) photo scaler. Further,
    if we ever want to improve or bug fix the zip functionality, we can do it for
    all subclasses at once by changing only the one `ZipProcessor` base class. Therefore
    maintenance will be much more effective.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑到我们现在所做的工作量相当大，而我们现在的程序在功能上与我们开始的程序并无不同！但是经过这样的工作，我们现在可以更容易地编写其他操作ZIP存档文件的类，比如（假设请求的）照片缩放器。此外，如果我们想要改进或修复ZIP功能，我们只需更改一个`ZipProcessor`基类，就可以同时为所有子类进行操作。因此维护工作将更加有效。
- en: 'See how simple it is now to create a photo scaling class that takes advantage
    of the `ZipProcessor` functionality:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 看看现在创建一个利用`ZipProcessor`功能的照片缩放类有多简单：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Look how simple this class is! All that work we did earlier paid off. All we
    do is open each file (assuming that it is an image; it will unceremoniously crash
    if a file cannot be opened or isn't an image), scale it, and save it back. The
    `ZipProcessor` class takes care of the zipping and unzipping without any extra
    work on our part.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个类有多简单！我们之前所做的所有工作都得到了回报。我们所做的就是打开每个文件（假设它是一个图像；如果文件无法打开或不是图像，程序将崩溃），对其进行缩放，然后保存。`ZipProcessor`类负责压缩和解压，而我们无需额外工作。
- en: Case study
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: For this case study, we'll try to delve further into the question, When should
    I choose an object versus a built-in type? We'll be modeling a `Document` class
    that might be used in a text editor or word processor. What objects, functions,
    or properties should it have?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个案例研究，我们将尝试进一步探讨一个问题，即何时应该选择对象而不是内置类型？我们将建模一个可能在文本编辑器或文字处理器中使用的`Document`类。它应该具有哪些对象、函数或属性？
- en: We might start with a `str` for the `Document` contents, but in Python, strings
    aren't mutable (able to be changed). Once a `str` is defined, it is forever. We
    can't insert a character into it or remove one without creating a brand new string
    object. That would be leaving a lot of `str` objects taking up memory until Python's
    garbage collector sees fit to clean up behind us.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会从`Document`内容开始使用`str`，但在Python中，字符串是不可变的。一旦定义了一个`str`，它就永远存在。我们无法在其中插入字符或删除字符，而不创建全新的字符串对象。这将导致大量的`str`对象占用内存，直到Python的垃圾收集器决定清理它们。
- en: So, instead of a string, we'll use a list of characters, which we can modify
    at will. In addition, we'll need to know the current cursor position within the
    list, and should probably also store a filename for the document.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用字符列表而不是字符串，这样我们可以随意修改。此外，我们需要知道列表中的当前光标位置，并且可能还需要存储文档的文件名。
- en: Real text editors use a binary tree-based data structure called a `rope` to
    model their document contents. This book's title isn't *Advanced Data Structures*,
    so if you're interested in learning more about this fascinating topic, you may
    want to search the web for *rope data structure*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的文本编辑器使用一种名为`rope`的基于二叉树的数据结构来模拟其文档内容。本书的标题不是*高级数据结构*，所以如果你对这个迷人的主题感兴趣，你可能想在网上搜索*rope数据结构*了解更多信息。
- en: There are a lot of things we might want to do to a text document, including
    inserting, deleting, and selecting characters; cutting, copying, and, pasting
    the selection; and saving or closing the document. It looks like there are copious
    amounts of both data and behavior, so it makes sense to put all this stuff into
    its own `Document` class.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想对文本文档进行许多操作，包括插入、删除和选择字符；剪切、复制和粘贴所选内容；以及保存或关闭文档。看起来有大量的数据和行为，因此将所有这些内容放入自己的`Document`类是有道理的。
- en: 'A pertinent question is: should this class be composed of a bunch of basic
    Python objects such as `str` filenames, `int` cursor positions, and a `list` of
    characters? Or should some or all of those things be specially defined objects
    in their own right? What about individual lines and characters? Do they need to
    have classes of their own?'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的问题是：这个类应该由一堆基本的Python对象组成，比如`str`文件名、`int`光标位置和字符的`list`？还是应该将其中一些或全部内容定义为自己的特定对象？单独的行和字符呢？它们需要有自己的类吗？
- en: 'We''ll answer these questions as we go, but let''s start with the simplest
    possible class first- `Document`  and see what it can do:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在进行过程中回答这些问题，但让我们先从最简单的`Document`类开始，看看它能做什么：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This basic class allows us full control over editing a basic document. Have
    a look at it in action:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本类允许我们完全控制编辑基本文档。看看它的运行情况：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It looks like it's working. We could connect a keyboard's letter and arrow keys
    to these methods and the document would track everything just fine.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来它正在工作。我们可以将键盘的字母和箭头键连接到这些方法，文档将正常跟踪一切。
- en: 'But what if we want to connect more than just arrow keys. What if we want to
    connect the *Home* and *End* keys as well? We could add more methods to the `Document`
    class that search forward or backward for newline characters (a newline character,
    escaped as `\n`, represents the end of one line and the beginning of a new one)
    in the string and jump to them, but if we did that for every possible movement
    action (move by words, move by sentences, *Page Up*, *P**age Down*, end of line,
    beginning of white space, and others), the class would be huge. Maybe it would
    be better to put those methods on a separate object. So, let''s turn the `Cursor`
    attribute into an object that is aware of its position and can manipulate that
    position. We can move the forward and back methods to that class, and add a couple
    more for the `Home` and `End` keys, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想要连接的不仅仅是箭头键。如果我们还想连接*Home*和*End*键怎么办？我们可以向`Document`类添加更多方法，用于在字符串中向前或向后搜索换行符（换行符，转义为`\n`，表示一行的结束和新行的开始），并跳转到它们，但如果我们为每种可能的移动操作（按单词移动，按句子移动，*Page
    Up*，*Page Down*，行尾，空格开头等）都这样做，那么这个类将会很庞大。也许把这些方法放在一个单独的对象上会更好。因此，让我们将`Cursor`属性转换为一个对象，该对象知道自己的位置并可以操纵该位置。我们可以将向前和向后的方法移到该类中，并为*Home*和*End*键添加另外两个方法，如下所示：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This class takes the document as an initialization parameter so the methods
    have access to the content of the document's character list. It then provides
    simple methods for moving backward and forward, as before, and for moving to the `home`
    and `end` positions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将文档作为初始化参数，以便方法可以访问文档字符列表的内容。然后提供了向后和向前移动的简单方法，以及移动到`home`和`end`位置的方法。
- en: This code is not very safe. You can very easily move past the ending position,
    and if you try to go home on an empty file, it will crash. These examples are
    kept short to make them readable, but that doesn't mean they are defensive! You
    can improve the error checking of this code as an exercise; it might be a great
    opportunity to expand your exception-handling skills.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不是很安全。你很容易越过结束位置，如果你试图在空文件上回到开头，它会崩溃。这些示例被保持简短以便阅读，但这并不意味着它们是防御性的！你可以通过练习来改进这段代码的错误检查；这可能是扩展你的异常处理技能的绝佳机会。
- en: 'The `Document` class itself is hardly changed, except for removing the two
    methods that were moved to the `Cursor` class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Document`类本身几乎没有改变，只是删除了移动到`Cursor`类的两个方法：'
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We just updated anything that accessed the old cursor integer to use the new
    object instead. We can now test that the `home` method is really moving to the
    newline character, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚更新了访问旧光标整数的任何内容，以使用新对象代替。我们现在可以测试`home`方法是否真的移动到换行符，如下所示：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, since we''ve been using that string `join` function a lot (to concatenate
    the characters so we can see the actual document contents), we can add a property
    to the `Document` class to give us the complete string as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们一直在大量使用字符串`join`函数（将字符连接起来，以便查看实际文档内容），我们可以向`Document`类添加一个属性，以便得到完整的字符串，如下所示：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This makes our testing a little simpler:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的测试变得更简单：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This framework is simple to extend, create and edit a complete plain text document
    (though it might be a bit time consuming!) Now, let's extend it to work for rich
    text; text that can have **bold**, underlined, or *italic* characters.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架很容易扩展，创建和编辑完整的纯文本文档（尽管可能会有点耗时！）现在，让我们将其扩展到适用于富文本的工作；可以具有**粗体**、下划线或*斜体*字符的文本。
- en: There are two ways we could process this. The first is to insert *fake* characters
    into our character list that act like instructions, such as *bold characters until
    you find a stop bold character*. The second is to add information to each character,
    indicating what formatting it should have. While the former method is more common
    in real editors, we'll implement the latter solution. To do that, we're obviously
    going to need a class for characters. This class will have an attribute representing
    the character, as well as three Boolean attributes representing whether it is
    *bold, italic, or underlined*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以两种方式处理这个问题。第一种是在字符列表中插入*虚假*字符，这些字符就像指令一样，比如*粗体字符，直到找到停止粗体字符*。第二种是向每个字符添加信息，指示它应该具有什么格式。虽然前一种方法在真实编辑器中更常见，但我们将实现后一种解决方案。为此，我们显然需要一个字符类。这个类将具有表示字符的属性，以及三个布尔属性，表示它是否*粗体、斜体或下划线*。
- en: Hmm, wait! Is this `Character` class going to have any methods? If not, maybe
    we should use one of the many Python data structures instead; a tuple or named
    tuple would probably be sufficient. Are there any actions that we would want to
    execute or invoke on a character?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，等等！这个`Character`类会有任何方法吗？如果没有，也许我们应该使用许多Python数据结构之一；元组或命名元组可能就足够了。有没有任何操作我们想要在字符上执行或调用？
- en: Well, clearly, we might want to do things with characters, such as delete or
    copy them, but those are things that need to be handled at the `Document` level,
    since they are really modifying the list of characters. Are there things that
    need to be done to individual characters?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，显然，我们可能想对字符进行一些操作，比如删除或复制它们，但这些是需要在`Document`级别处理的事情，因为它们实际上是在修改字符列表。是否有需要对单个字符进行处理的事情？
- en: Actually, now that we're thinking about what a `Character` class actually **is**...
    what is it? Would it be safe to say that a `Character` class is a string? Maybe
    we should use an inheritance relationship here? Then we can take advantage of
    the numerous methods that `str` instances come with.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，现在我们在思考`Character`类实际上**是**什么……它是什么？可以肯定地说`Character`类是一个字符串吗？也许我们应该在这里使用继承关系？然后我们可以利用`str`实例带来的众多方法。
- en: What sorts of methods are we talking about? There's `startswith`, `strip`, `find`,
    `lower`, and many more. Most of these methods expect to be working on strings
    that contain more than one character. In contrast, if `Character` were to subclass
    `str`, we'd probably be wise to override `__init__` to raise an exception if a
    multi-character string were supplied. Since all those methods we'd get for free
    wouldn't really apply to our `Character` class, it seems we shouldn't use inheritance,
    after all.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在谈论什么样的方法？有`startswith`、`strip`、`find`、`lower`等等。这些方法中的大多数都希望在包含多个字符的字符串上工作。相比之下，如果`Character`是`str`的子类，我们可能最好重写`__init__`，以便在提供多字符字符串时引发异常。由于我们将免费获得的所有这些方法实际上并不适用于我们的`Character`类，因此似乎我们不应该使用继承。
- en: This brings us back to our original question; should `Character` even be a class?
    There is a very important special method on the `object` class that we can take
    advantage of to represent our characters. This method, called `__str__` (two underscores
    at each end, like `__init__`), is used in string-manipulation functions such as `print`
    and the `str` constructor to convert any class to a string. The default implementation
    does some boring stuff, such as printing the name of the module and class, and
    its address in memory. But if we override it, we can make it print whatever we
    like.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们回到了最初的问题；`Character`甚至应该是一个类吗？`object`类上有一个非常重要的特殊方法，我们可以利用它来表示我们的字符。这个方法叫做`__str__`（两端都有两个下划线，就像`__init__`一样），它在字符串操作函数中被使用，比如`print`和`str`构造函数，将任何类转换为字符串。默认实现做了一些无聊的事情，比如打印模块和类的名称，以及它在内存中的地址。但如果我们重写它，我们可以让它打印任何我们喜欢的东西。
- en: 'For our implementation, we could make it prefix characters with special characters
    to represent whether they are bold, italic, or underlined. So, we will create
    a class to represent a character, and here it is:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的实现，我们可以使用特殊字符作为前缀来表示字符是否为粗体、斜体或下划线。因此，我们将创建一个表示字符的类，如下所示：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This class allows us to create characters and prefix them with a special character
    when the `str()` function is applied to them. Nothing too exciting there. We only
    have to make a few minor modifications to the `Document` and `Cursor` classes
    to work with this class. In the `Document` class, we add these two lines at the
    beginning of the `insert` method, as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类允许我们创建字符，并在应用`str()`函数时用特殊字符作为前缀。没有太多激动人心的地方。我们只需要对`Document`和`Cursor`类进行一些小修改，以便与这个类一起工作。在`Document`类中，我们在`insert`方法的开头添加以下两行：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is a rather strange bit of code. Its basic purpose is to check whether
    the character being passed in is a `Character` or a `str`. If it is a string,
    it is wrapped in a `Character` class so all objects in the list are `Character`
    objects. However, it is entirely possible that someone using our code would want
    to use a class that is neither a `Character` nor a string, using duck typing.
    If the object has a character attribute, we assume it is a `Character`-like object.
    But if it does not, we assume it is a `str`-like object and wrap it in `Character`.
    This helps the program take advantage of duck typing as well as polymorphism;
    as long as an object has a character attribute, it can be used in the `Document`
    class.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段相当奇怪的代码。它的基本目的是检查传入的字符是`Character`还是`str`。如果是字符串，它就会被包装在`Character`类中，以便列表中的所有对象都是`Character`对象。然而，完全有可能有人使用我们的代码想要使用既不是`Character`也不是字符串的类，使用鸭子类型。如果对象有一个字符属性，我们假设它是类似`Character`的对象。但如果没有，我们假设它是类似`str`的对象，并将其包装在`Character`中。这有助于程序利用鸭子类型和多态性；只要对象具有字符属性，它就可以在`Document`类中使用。
- en: This generic check could be very useful. For example, if we wanted to make a
    programmer's editor with syntax highlighting, we'd need extra data on the character,
    such as what type of syntax token the character belongs to. Note that, if we are
    doing a lot of this kind of comparison, it's probably better to implement `Character`
    as an abstract base class with an appropriate `__subclasshook__`, as discussed
    in [Chapter 17](63f74e80-a17c-456d-969e-2a36ffb0067b.xhtml), *When Objects Are
    Alike*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通用检查可能非常有用。例如，如果我们想要制作一个带有语法高亮的程序员编辑器，我们需要字符的额外数据，比如字符属于哪种类型的语法标记。请注意，如果我们要做很多这种比较，最好实现`Character`作为一个带有适当`__subclasshook__`的抽象基类，如[第17章](63f74e80-a17c-456d-969e-2a36ffb0067b.xhtml)中讨论的那样，*当对象相似*。
- en: 'In addition, we need to modify the string property on `Document` to accept
    the new `Character` values. All we need to do is call `str()` on each character
    before we join it, as demonstrated in the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要修改`Document`上的字符串属性，以接受新的`Character`值。我们只需要在连接之前对每个字符调用`str()`，如下所示：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This code uses a generator expression, which we'll discuss in [Chapter 21](b9232138-1747-4f88-b7ac-002c40332e92.xhtml),
    *The Iterator Pattern*. It's a shortcut to perform a specific action on all the
    objects in a sequence.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了一个生成器表达式，我们将在[第21章](b9232138-1747-4f88-b7ac-002c40332e92.xhtml)中讨论，*迭代器模式*。这是一个在序列中对所有对象执行特定操作的快捷方式。
- en: 'Finally, we also need to check `Character.character`, instead of just the string
    character we were storing before, in the `home` and `end` functions when we''re
    looking to see whether it matches a newline character, as demonstrated in the
    following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要检查`home`和`end`函数中的`Character.character`，而不仅仅是我们之前存储的字符串字符，看它是否匹配换行符，如下所示：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This completes the formatting of characters. We can test it to see that it
    works as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了字符的格式化。我们可以测试它，看它是否像下面这样工作：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As expected, whenever we print the string, each bold character is preceded by
    a `*` character, each italicized character by a `/` character, and each underlined
    character by a `_` character. All our functions seem to work, and we can modify
    characters in the list after the fact. We have a working rich text document object
    that could be plugged into a proper graphical user interface and hooked up with
    a keyboard for input and a screen for output. Naturally, we'd want to display
    real *bold, italic, and underlined* fonts in a UI, instead of using our `__str__`
    method, but it was sufficient for the basic testing we demanded of it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，每当我们打印字符串时，每个粗体字符前面都有一个`*`字符，每个斜体字符前面都有一个`/`字符，每个下划线字符前面都有一个`_`字符。我们所有的函数似乎都能工作，并且我们可以在事后修改列表中的字符。我们有一个可以插入到适当的图形用户界面中并与键盘进行输入和屏幕进行输出的工作的富文本文档对象。当然，我们希望在UI中显示真正的*粗体、斜体和下划线*字体，而不是使用我们的`__str__`方法，但它对我们要求的基本测试是足够的。
- en: Exercises
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: We've looked at various ways that objects, data, and methods can interact with
    each other in an object-oriented Python program. As usual, your first thoughts
    should be how you can apply these principles to your own work. Do you have any
    messy scripts lying around that could be rewritten using an object-oriented manager?
    Look through some of your old code and look for methods that are not actions.
    If the name isn't a verb, try rewriting it as a property.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了在面向对象的Python程序中对象、数据和方法可以相互交互的各种方式。和往常一样，您的第一个想法应该是如何将这些原则应用到您自己的工作中。您是否有一些混乱的脚本横七竖八地散落在那里，可以使用面向对象的管理器进行重写？浏览一下您的旧代码，寻找一些不是动作的方法。如果名称不是动词，尝试将其重写为属性。
- en: Think about code you've written in any language. Does it break the DRY principle?
    Is there any duplicate code? Did you copy and paste code? Did you write two versions
    of similar pieces of code because you didn't feel like understanding the original
    code? Go back over some of your recent code now and see whether you can refactor
    the duplicate code using inheritance or composition. Try to pick a project you're
    still interested in maintaining; not code so old that you never want to touch
    it again. That will help to keep you interested when you do the improvements!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 思考您用任何语言编写的代码。它是否违反了DRY原则？是否有任何重复的代码？您是否复制和粘贴了代码？您是否编写了两个类似代码的版本，因为您不想理解原始代码？现在回顾一下您最近的一些代码，看看是否可以使用继承或组合重构重复的代码。尝试选择一个您仍然有兴趣维护的项目；不要选择那些您永远不想再碰的代码。这将有助于在您进行改进时保持您的兴趣！
- en: Now, look back over some of the examples we looked at in this chapter. Start
    with the cached web page example that uses a property to cache the retrieved data.
    An obvious problem with this example is that the cache is never refreshed. Add
    a timeout to the property's getter, and only return the cached page if the page
    has been requested before the timeout has expired. You can use the `time` module
    (`time.time() - an_old_time` returns the number of seconds that have elapsed since
    `an_old_time`) to determine whether the cache has expired.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回顾一下本章中我们看过的一些例子。从使用属性缓存检索数据的缓存网页示例开始。这个示例的一个明显问题是缓存从未被刷新。在属性的getter中添加一个超时，并且只有在页面在超时过期之前被请求时才返回缓存的页面。您可以使用`time`模块（`time.time()
    - an_old_time`返回自`an_old_time`以来经过的秒数）来确定缓存是否已过期。
- en: Also look at the inheritance-based `ZipProcessor`. It might be reasonable to
    use composition instead of inheritance here. Instead of extending the class in
    the `ZipReplace` and `ScaleZip` classes, you could pass instances of those classes
    into the `ZipProcessor` constructor and call them to do the processing part. Implement
    this.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 还要看看基于继承的`ZipProcessor`。在这里使用组合而不是继承可能是合理的。您可以在`ZipProcessor`构造函数中传递这些类的实例，并调用它们来执行处理部分。实现这一点。
- en: Which version do you find easier to use? Which is more elegant? What is easier
    to read? These are subjective questions; the answer varies for each of us. Knowing
    the answer, however, is important. If you find you prefer inheritance over composition,
    you need to pay attention that you don't overuse inheritance in your daily coding.
    If you prefer composition, make sure you don't miss opportunities to create an
    elegant inheritance-based solution.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您觉得哪个版本更容易使用？哪个更优雅？哪个更容易阅读？这些都是主观问题；答案因人而异。然而，了解答案是重要的。如果您发现自己更喜欢继承而不是组合，那么您需要注意不要在日常编码中过度使用继承。如果您更喜欢组合，请确保不要错过创建优雅的基于继承的解决方案的机会。
- en: Finally, add some error handlers to the various classes we created in the case
    study. They should ensure single characters are entered, that you don't try to
    move the cursor past the end or beginning of the file, that you don't delete a
    character that doesn't exist, and that you don't save a file without a filename.
    Try to think of as many edge cases as you can, and account for them (thinking
    about edge cases is about 90% of a professional programmer's job!). Consider different
    ways to handle them; should you raise an exception when the user tries to move
    past the end of the file, or just stay on the last character?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在案例研究中为各种类添加一些错误处理程序。它们应确保输入单个字符，不要尝试将光标移动到文件的末尾或开头，不要删除不存在的字符，也不要保存没有文件名的文件。尽量考虑尽可能多的边缘情况，并对其进行考虑（考虑边缘情况大约占专业程序员工作的90%！）。考虑不同的处理方式；当用户尝试移动到文件末尾时，您应该引发异常，还是只停留在最后一个字符？
- en: In your daily coding, pay attention to the copy and paste commands. Every time
    you use them in your editor, consider whether it would be a good idea to improve
    your program's organization so that you only have one version of the code you
    are about to copy.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的日常编码中，注意复制和粘贴命令。每次在编辑器中使用它们时，考虑是否改进程序的组织结构，以便您只有要复制的代码的一个版本。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we focused on identifying objects, especially objects that
    are not immediately apparent; objects that manage and control. Objects should
    have both data and behaviors, but properties can be used to blur the distinction
    between the two. The DRY principle is an important indicator of code quality,
    and inheritance and composition can be applied to reduce code duplication.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们专注于识别对象，特别是那些不太明显的对象；管理和控制对象。对象应该既有数据又有行为，但属性可以用来模糊两者之间的区别。 DRY 原则是代码质量的重要指标，继承和组合可以用来减少代码重复。
- en: In the next chapter, we'll discuss how to integrate the object-oriented and
    not-so-object-oriented aspects of Python. Along the way, we'll discover that it's
    more object-oriented than it looks at first sight!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何整合 Python 的面向对象和非面向对象的方面。在这个过程中，我们会发现它比起初看起来更加面向对象！
