- en: Appendix
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录
- en: 1\. Fundamentals of Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. Python基础
- en: 'Activity 1.01: Building a Sudoku Solver'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1.01：构建数独求解器
- en: '**Solution**'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'First, we define the `Solver` class to store its input puzzle in its `cells`
    attribute, as follows:'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义`Solver`类，将其输入谜题存储在其`cells`属性中，如下所示：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The helper method that prints out the puzzle in a nice format can loop through
    the individual cells in the puzzle while inserting the separating characters `''-''`
    and `''|''` at the appropriate places:'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以漂亮的格式打印出谜题的辅助方法可以循环遍历谜题中的单元格，同时在适当的位置插入分隔字符`'-'`和`'|'`：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `get_presence()` method can maintain three separate lists of Boolean variables
    for the presence of numbers between 1 and 9 in individual rows, columns, and quadrants.
    These Boolean variables should all be initialized as `False` at the beginning,
    but we can loop through all the cells in the input and change their values to
    `True` as appropriate:'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get_presence（）`方法可以维护三个单独的布尔变量列表，用于表示各行、列和象限中1到9之间数字的存在。这些布尔变量在开始时都应初始化为`False`，但我们可以循环遍历输入中的所有单元格，并根据需要将它们的值更改为`True`：'
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It can be tricky to index the quadrants. The preceding code uses the formula
    `row_id // 3 * 3 + col_id // 3`, which effectively results in the count where
    the top-left quadrant is indexed at `0`, the top-center `1`, the top-right `2`,
    the middle-left `3`, ..., the bottom-center `7`, and the bottom-right `8`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对象象限进行索引可能有些棘手。上述代码使用公式`row_id // 3 * 3 + col_id // 3`，这实际上导致了从左上象限索引为`0`，上中`1`，上右`2`，中左`3`，...，底部中`7`，底部右`8`的计数。
- en: 'The `get_possible_values()` method can call `get_presence()` and generate the
    corresponding lists of possible values for the remaining empty cells:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get_possible_values（）`方法可以调用`get_presence（）`并生成剩余空单元格的可能值列表：'
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `simple_update()` method can be implemented in a fairly straightforward
    manner, in which we can have a flag variable (called `update_again` here) to indicate
    whether we would need to call the method again before returning:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`simple_update（）`方法可以以相当直接的方式实现，其中我们可以使用一个标志变量（这里称为`update_again`）来指示我们在返回之前是否需要再次调用该方法：'
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `recur_solve()` method contains multiple instructional components, but
    the logical flow is simple to implement:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`recur_solve（）`方法包含多个教学组件，但逻辑流程简单易实现：'
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we place all of these methods inside the `solve()` method, which calls
    `recur_solve()` on `self.cells`:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将所有这些方法放在`solve（）`方法中，该方法在`self.cells`上调用`recur_solve（）`：
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Print out the returned solution as follows:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式打印返回的解决方案：
- en: '[PRE7]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A section of the output is as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的一部分如下：
- en: '[PRE8]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code and the final output for this specific section, please
    refer to [https://packt.live/3dWRsnE.](https://packt.live/3dWRsnE )
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码和最终输出，请参阅[https://packt.live/3dWRsnE.](https://packt.live/3dWRsnE
    )
- en: You can also run this example online at [https://packt.live/2BBKreC.](https://packt.live/2BBKreC
    )
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2BBKreC.](https://packt.live/2BBKreC )上在线运行此示例
- en: 2\. Python's Main Tools for Statistics
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. Python的统计主要工具
- en: 'Activity 2.01: Analyzing the Communities and Crime Dataset'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动2.01：分析社区和犯罪数据集
- en: '**Solution**:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'Once the dataset has been downloaded, the libraries can be imported, and pandas
    can be used to read in the dataset in a new Jupyter notebook, as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据集下载后，可以导入库，并使用pandas在新的Jupyter笔记本中读取数据集，如下所示：
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are also printing out the first five rows of the dataset, which should be
    as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还打印出数据集的前五行，应该如下所示：
- en: '![Figure 2.21: The first five rows of the dataset'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.21：数据集的前五行'
- en: '](image/B15968_02_211.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_211.jpg)'
- en: 'Figure 2.21: The first five rows of the dataset'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21：数据集的前五行
- en: 'To print out the column names, we can simply iterate through `df.columns` in
    a `for` loop, like so:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打印列名，我们可以简单地在`for`循环中迭代`df.columns`，如下所示：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The total number of columns in the dataset can be computed using the `len()`
    function in Python:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用Python中的`len（）`函数计算数据集中的列总数：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To replace the special character `''?''` with `np.nan` objects, we can use
    the `replace()` method:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要用`np.nan`对象替换特殊字符`'?'`，可以使用`replace（）`方法：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To print out the list of columns in our dataset and their respective numbers
    of missing values, we use a combination of the `isnull().sum()` methods:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打印出数据集中列的列表及其各自的缺失值数量，我们使用`isnull().sum()`方法的组合：
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code should produce the following output:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码应产生以下输出：
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The numbers of missing values of the two specified columns can be accessed
    and displayed as follows:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以按如下方式访问并显示两个指定列的缺失值数量：
- en: '[PRE15]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You should obtain `0` and `1872` as the output.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该获得`0`和`1872`作为输出。
- en: 'To compute and visualize the counts of unique values in `''state''` using a
    bar plot (as well as to adjust the size of the figure), the following code can
    be used:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用条形图计算和可视化`'state'`中唯一值的计数（以及调整图的大小），可以使用以下代码：
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This should produce the following graph:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下图表：
- en: '![Figure 2.22: Bar graph for state counts'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.22：州计数的条形图'
- en: '](image/B15968_02_221.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_221.jpg)'
- en: 'Figure 2.22: Bar graph for state counts'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22：州计数的条形图
- en: 'To compute and visualize the same information using a pie chart, the following
    code can be used:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码可以计算和可视化相同信息的饼图：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following visualization will be generated:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成以下可视化：
- en: '![Figure 2.23: Pie chart for state counts'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.23：州计数的饼图'
- en: '](image/B15968_02_23.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_23.jpg)'
- en: 'Figure 2.23: Pie chart for state counts'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23：州计数的饼图
- en: 'To compute and visualize the population distribution using a histogram, the
    following code can be used:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用直方图计算和可视化人口分布，可以使用以下代码：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This should produce the following graph:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下图表：
- en: '![Figure 2.24: Histogram for population distribution'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.24：人口分布的直方图'
- en: '](image/B15968_02_24.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_24.jpg)'
- en: 'Figure 2.24: Histogram for population distribution'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24：人口分布的直方图
- en: 'To compute and visualize the household size distribution using a histogram,
    the following code can be used:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要计算和可视化家庭规模分布，可以使用以下代码：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should produce the following graph:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下图表：
- en: '![Figure 2.25: Histogram for household size distribution'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.25：家庭规模分布的直方图'
- en: '](image/B15968_02_25.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_02_25.jpg)'
- en: 'Figure 2.25: Histogram for household size distribution'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.25：家庭规模分布的直方图
- en: Note
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2BB5BJT.](https://packt.live/2BB5BJT
    )
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2BB5BJT](https://packt.live/2BB5BJT)
- en: You can also run this example online at [https://packt.live/38nbma9.](https://packt.live/38nbma9
    )
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/38nbma9](https://packt.live/38nbma9)上线运行此示例。
- en: 3\. Python's Statistical Toolbox
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. Python的统计工具箱
- en: 'Activity 3.01: Revisiting the Communities and Crimes Dataset'
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动3.01：重新审视社区和犯罪数据集
- en: '**Solution**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: 'The libraries can be imported, and pandas can be used to read in the dataset
    as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以导入库，并使用pandas读取数据集，如下所示：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Your output should be the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出应该如下所示：
- en: '![Figure 3.29: The first five rows of the dataset'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.29：数据集的前五行'
- en: '](image/B15968_03_29.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_03_29.jpg)'
- en: 'Figure 3.29: The first five rows of the dataset'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.29：数据集的前五行
- en: 'To replace the special character with the `np.nan` object, we can use the following
    code:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要用`np.nan`对象替换特殊字符，我们可以使用以下代码：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To compute the actual count for the different age groups, we can simply use
    the expression `df[''population''] * df[''agePct...'']`, which computes the count
    in a vectorized way:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要计算不同年龄组的实际计数，我们可以简单地使用表达式`df['population'] * df['agePct...']`，以向量化方式计算计数：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that we are rounding the final answers to integers using `astype(int)`.
    The first five rows of these newly created columns should look like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在使用`astype(int)`将最终答案四舍五入为整数。这些新创建的列的前五行应该如下所示：
- en: '![Figure 3.30: Actual count of different age groups'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.30：不同年龄组的实际计数'
- en: '](image/B15968_03_30.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_03_30.jpg)'
- en: 'Figure 3.30: Actual count of different age groups'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.30：不同年龄组的实际计数
- en: 'The expression `df.groupby(''state'')` gives us a `GroupBy` object that aggregates
    our dataset into different groups, each corresponding to a unique value in the
    `''state''` column. Then we can call `sum()` on the object and inspect the columns
    in question:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表达式`df.groupby('state')`给我们一个`GroupBy`对象，将我们的数据集聚合成不同的组，每个组对应`'state'`列中的唯一值。然后我们可以在该对象上调用`sum()`并检查相关的列：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This should print out the count of the different age groups in each state.
    The first five columns of this output should be the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该打印出每个州不同年龄组的计数。输出的前五列应该如下所示：
- en: '![Figure 3.31: Count of different age groups in each state'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.31：每个州不同年龄组的计数'
- en: '](image/B15968_03_31.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_03_31.jpg)'
- en: 'Figure 3.31: Count of different age groups in each state'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.31：每个州不同年龄组的计数
- en: 'Using the `df.describe()` method, you can obtain the following output:![Figure
    3.32: Description of the dataset'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`df.describe()`方法，您可以获得以下输出：![图3.32：数据集的描述
- en: '](image/B15968_03_32.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_03_32.jpg)'
- en: 'Figure 3.32: Description of the dataset'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.32：数据集的描述
- en: 'The boxplots visualizing the count of various crimes can be generated as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可生成可视化各种犯罪数量的箱线图，如下所示：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This should produce the following graph:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下图表：
- en: '![Figure 3.33: Boxplots of various crime counts'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.33：各种犯罪数量的箱线图'
- en: '](image/B15968_03_33.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_03_33.jpg)'
- en: 'Figure 3.33: Boxplots of various crime counts'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.33：各种犯罪数量的箱线图
- en: From the graph, we see that non-violent crime is the most common out of the
    five, while arson is the least common.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从图表中，我们可以看到五种犯罪中非暴力犯罪是最常见的，而纵火犯罪是最不常见的。
- en: 'A heatmap for the correlation matrix that corresponds to the given columns
    can be used to visualize the information that was asked for:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用与给定列对应的相关矩阵的热图来可视化所需的信息：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This should produce the following heatmap:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下热图：
- en: '![Figure 3.34: Heatmap for various population features'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.34：各种人口特征的热图'
- en: '](image/B15968_03_34.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_03_34.jpg)'
- en: 'Figure 3.34: Heatmap for various population features'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.34：各种人口特征的热图
- en: From the graph, we see that the percentage of the population under the poverty
    level and the percentage of unemployed are highly correlated (`0.77` being the
    correlation coefficient). This is an understandable yet telling insight into how
    various crime-related factors are connected to each other.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表中，我们可以看到贫困线以下人口的百分比和失业率之间高度相关（相关系数为`0.77`）。这是一个可以理解但富有启发性的洞察，揭示了各种与犯罪相关的因素是如何相互联系的。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3f8taZn.](https://packt.live/3f8taZn
    )
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3f8taZn](https://packt.live/3f8taZn)
- en: You can also run this example online at [https://packt.live/3ikxjeF.](https://packt.live/3ikxjeF
    )
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[https://packt.live/3ikxjeF](https://packt.live/3ikxjeF)上线运行此示例。
- en: 4\. Functions and Algebra with Python
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 使用Python进行函数和代数
- en: 'Activity 4.01: Multi-Variable Break-Even Analysis'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动4.01：多变量收支平衡分析
- en: '**Solution**:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'Let *x* be the number of burgers that the restaurant produces each month and
    *y* be the price of each burger. Then, the monthly revenue will be *xy*, the cost
    will be *6.56x + 1312.13*, and finally, the total profit will be the difference
    between the two: *xy - 6.56x - 1312.13*.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让*x*表示餐厅每月生产的汉堡数量，*y*表示每个汉堡的价格。然后，月收入将是*xy*，成本将是*6.56x + 1312.13*，最后，总利润将是两者之间的差异：*xy
    - 6.56x - 1312.13*。
- en: 'To break even, the number of burgers produced, *x*, must be equal to the demand,
    which gives us the equation: *x = 4000/y*. Furthermore, the total profit should
    be zero, which leads to *xy - 6.56x = 1312.13*.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要达到收支平衡，生产的汉堡数量*x*必须等于需求，这给我们带来了方程：*x = 4000/y*。此外，总利润应该为零，这导致*xy - 6.56x =
    1312.13*。
- en: 'Overall, we have the following system of equations:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们有以下方程组：
- en: '![Figure 4.48: System of equations'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.48：方程组'
- en: '](image/B15968_04_48.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_48.jpg)'
- en: 'Figure 4.48: System of equations'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.48：方程组
- en: From the first equation, we can solve for *x = 409.73628*. Plugging this into
    the second equation, we can solve for *y = 9.76237691*.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第一个方程中，我们可以解出*x = 409.73628*。将这个值代入第二个方程，我们可以解出*y = 9.76237691*。
- en: 'To solve this system in Python, we first declare our variables and constants:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python中解决这个系统，我们首先声明我们的变量和常数：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then we can call the `solve()` function from SymPy on the corresponding list
    of functions:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在对应的函数列表上调用SymPy中的`solve()`函数：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This code should produce the following output, which corresponds to the actual
    solution of the system:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该产生以下输出，对应于系统的实际解决方案：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The most challenging point about this function is that if the number of burgers
    produced by the restaurant, *x*, exceeds the demand, *4000/y*, their revenue remains
    at *4000*. However, if the number of burgers is low, then the revenue is *xy*.
    Our function therefore needs to have a condition to check for this logic:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个函数最具挑战性的一点是，如果餐厅生产的汉堡数量*x*超过需求*4000/y*，他们的收入仍然是*4000*。然而，如果汉堡的数量较少，那么收入就是*xy*。因此，我们的函数需要有一个条件来检查这个逻辑：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following code generates the specified lists and the corresponding plot
    when the price of each burger is $9.76:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码生成了指定的列表和相应的图表，当每个汉堡的价格为$9.76时：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output should look like the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 4.49: Break-even graph for a price of $9.76'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.49：售价为$9.76的盈亏平衡图'
- en: '](image/B15968_04_49.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_49.jpg)'
- en: 'Figure 4.49: Break-even graph for a price of $9.76'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.49：售价为$9.76的盈亏平衡图
- en: The intersection of the upside-down V-shaped profit curve and the horizontal
    line at `0` denotes the break-even point in the analysis where the price of each
    burger is fixed at $9.76\. The *x* coordinate of this intersection is somewhat
    above `400`, which roughly corresponds to the break-even solution in *step 3*,
    when *x* is approximately `410` and *y* is approximately 9.76.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 利润曲线的倒置V形与水平线在`0`处的交点表示分析中每个汉堡价格固定为$9.76的盈亏平衡点。这个交点的*x*坐标略高于`400`，大致对应于*步骤3*中的盈亏平衡解，当*x*大约为`410`，*y*大约为9.76时。
- en: 'The following code generates the specified lists and the corresponding plot
    when the price of each burger is $9.99:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码生成了指定的列表和相应的图表，当每个汉堡的价格为$9.99时：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output should look like the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 4.50: Break-even graph for a price of $9.99'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.50：售价为$9.99的盈亏平衡图'
- en: '](image/B15968_04_50.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_50.jpg)'
- en: 'Figure 4.50: Break-even graph for a price of $9.99'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.50：售价为$9.99的盈亏平衡图
- en: Similarly, the two intersections of the profit curve and the horizontal line
    at `0` denote the break-even points in the analysis where the price of each burger
    is fixed at $9.99.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，利润曲线与水平线交点处的两个交点`0`表示分析中每个汉堡价格固定为$9.99的盈亏平衡点。
- en: We see that as the number of burgers produced increases, the profit of the restaurant
    grows linearly. However, after this number meets demand and the profit curve peaks,
    the curve starts to decrease linearly. This is when the restaurant over-produces
    and increasing the number of products is no longer beneficial.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，随着生产的汉堡数量增加，餐厅的利润呈线性增长。然而，当这个数量满足需求并且利润曲线达到峰值后，曲线开始线性下降。这是当餐厅过度生产并且增加产品数量不再有利时。
- en: 'The following code generates the specified lists:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码生成了指定的列表：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`profits` is a two-dimensional list that is rather large in size, but the first
    few elements in that list should look like the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`profits`是一个相当大的二维列表，但该列表中的前几个元素应如下所示：'
- en: '![Figure 4.51: Two-dimensional list of profits'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.51：利润的二维列表'
- en: '](image/B15968_04_51.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_51.jpg)'
- en: 'Figure 4.51: Two-dimensional list of profits'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.51：利润的二维列表
- en: 'The specified heatmap can then be generated using the following code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用以下代码生成指定的热图：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output should look like the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 4.52: Heatmap of profit as a function of production and price'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.52：利润的热图作为生产和价格的函数'
- en: '](image/B15968_04_52.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_04_52.jpg)'
- en: 'Figure 4.52: Heatmap of profit as a function of production and price'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.52：利润的热图作为生产和价格的函数
- en: From the plot, we see that there are specific combinations of *x* and *y* that
    control the behavior of the profit of the restaurant.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中我们可以看出，有特定的*x*和*y*的组合来控制餐厅的利润行为。
- en: For example, when the price of each burger is low (the left region of the map),
    the total profit is significantly lower than 0\. As we move to the right of the
    plot, the brightest region represents the combinations of the two variables that
    will result in the highest profit.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当每个汉堡的价格较低时（地图的左侧区域），总利润明显低于0。当我们移动到图的右侧时，最亮的区域代表了两个变量的组合将产生最高利润。
- en: Note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2C6dKWz.](https://packt.live/2C6dKWz
    )
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2C6dKWz](https://packt.live/2C6dKWz)。
- en: You can also run this example online at [https://packt.live/2NTfEwG.](https://packt.live/2NTfEwG
    )
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2NTfEwG](https://packt.live/2NTfEwG)上在线运行此示例。
- en: 5\. More Mathematics with Python
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5\. 使用Python进行更多数学运算
- en: 'Activity 5.01: Calculating Your Retirement Plan Using Series'
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动5.01：使用级数计算您的退休计划
- en: '**Solution**:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'Perform the following steps to complete this activity:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此活动：
- en: First, we need to identify the input variables and note that the problem boils
    down to calculating the *n*-term of a geometric sequence with a common ratio (1
    + interest) and scale factor for the annual salary.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要确定输入变量，并注意问题归结为计算具有公比（1 + 利息）和年薪比例的等比数列的*n*项。
- en: '`annual_salary` and the percentage, *contrib*, of it is what we contribute
    toward our plan. `current_balance` is the money that we have at year 0 and should
    be added to the total amount. `annual_cap` is the maximum percentage that we can
    contribute; any input value beyond that should be equal to `contrib_cap`. `annual_salary_increase`
    tells us how much we expect our salary to increase by per year. `employer_match`
    gives us the percentage amount the employer contributes to the plan (typically,
    this is between 0.5 and 1). Lastly, the current age, the duration of the plan
    in years, the life expectancy in years, and any other fees that the plan might
    incur are input variables. The `per_month` Boolean variable determines whether
    the output will be printed as a per-year or per-month amount of the return.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`annual_salary`和百分比*contrib*是我们为计划做出的贡献。`current_balance`是我们在第0年拥有的钱，应该加到总金额中。`annual_cap`是我们可以贡献的最大百分比；任何超出该值的输入值应该等于`contrib_cap`。`annual_salary_increase`告诉我们每年我们的工资预计增加多少。`employer_match`给我们雇主为计划贡献的百分比（通常在0.5和1之间）。最后，当前年龄，计划的年限，预期寿命以及计划可能产生的任何其他费用都是输入变量。`per_month`布尔变量确定输出是作为每年还是每月的回报金额打印。'
- en: 'Define the first function, `retirement_n`, to calculate the *n*th term of our
    sequence, which returns the contribution and employer''s match as a comma-separated
    tuple:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义第一个函数`retirement_n`，来计算我们序列的第n项，它返回贡献和雇主匹配作为逗号分隔的元组：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The input, as shown here, is the current balance and the annual salary in absolute
    values. We also define the contribution, the contribution cap (that is, the maximum
    value allowed), the increase of the annual salary, the employer match, and the
    rate of the return as relative values (floats between 0 and 1). The annual cap
    is meant to be read as an absolute value too.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示的输入是当前余额和绝对值的年薪。我们还定义了贡献，贡献上限（即允许的最大值），年薪的增加，雇主匹配以及回报率作为相对值（0到1之间的浮点数）。年度上限也应该被视为绝对值。
- en: 'Define the function that will sum up the individual amounts for each year and
    calculate the total value of our plan. This shall divide this number by the number
    of years over which the plan is to be used (payback duration) so that the per-year
    return of the plan is returned by the function. As inputs, it should read the
    current age, the duration of the plan, and the life expectancy (the duration of
    the payback is found by subtracting `current_age + plan_years` from `life_expectancy`):'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，将每年的个人金额相加，并计算我们计划的总价值。这将把这个数字除以计划要使用的年数（偿还期限），以便函数返回计划的每年回报。作为输入，它应该读取当前年龄，计划的持续时间和预期寿命（偿还期限是通过从`预期寿命`中减去`当前年龄+计划年限`来找到的）：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The main operation of the preceding function is to set a loop (`while` iteration)
    where the previous function is called and the value of the plan is found at each
    year, *n* (we call it *cn* here for brevity). The result is the sum of the values
    of all the years and is stored in the `result` variable. We slice *cn (cn[0],
    cn[1], cn[2])* since the `retirement_n` function returns a tuple of three quantities.
    We also store the values of the contribution (employee), match (employee), and
    total in three individual lists. These will be returned from this function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个函数的主要操作是设置一个循环（`while`迭代），在其中调用前一个函数，并找到每年的计划价值*n*（我们在这里称它为*cn*以简洁起见）。结果是所有年份的价值之和，并存储在`result`变量中。我们切片*cn（cn[0]，cn[1]，cn[2])*，因为`retirement_n`函数返回三个数量的元组。我们还将贡献（员工），匹配（员工）和总额的值存储在三个单独的列表中。这些将从此函数返回。
- en: 'Lastly, subtract any fees that might need to be included and return the result:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，减去可能需要包括的任何费用并返回结果：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Check our function and the output:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们的函数和输出：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output is as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Plot your findings. It is always good practice to plot what has been calculated
    since it helps you digest the main message. Also, the functions can be checked
    for potential errors:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制您的发现。绘制已计算的内容总是一个很好的做法，因为它有助于您理解主要信息。此外，可以检查函数是否存在潜在错误：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The plot will be displayed as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将以以下方式显示情节：
- en: '![Figure 5.26: Retirement plan evolution plot'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.26：退休计划演变情节'
- en: '](image/B15968_05_26.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_26.jpg)'
- en: 'Figure 5.26: Retirement plan evolution plot'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.26：退休计划演变情节
- en: With that, we have created a Python program that calculates the per-month or
    per-year return of a retirement plan based on the current contributions and a
    set of other parameters. We have seen how our knowledge of sequences and series
    can be applied to a real-life scenario to yield results regarding financial and
    social interest.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们创建了一个Python程序，根据当前的贡献和一组其他参数来计算退休计划的每月或每年回报。我们已经看到了我们对序列和级数的知识如何应用到现实生活场景中，以产生有关金融和社会利益的结果。
- en: Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2YVgQWE.](https://packt.live/2YVgQWE
    )
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2YVgQWE](https://packt.live/2YVgQWE)
- en: You can also run this example online at [https://packt.live/38rOHts.](https://packt.live/38rOHts
    )
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/38rOHts](https://packt.live/38rOHts)上在线运行此示例。
- en: 6\. Matrices and Markov Chains with Python
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 使用Python进行矩阵和马尔可夫链
- en: 'Activity 6.01: Building a Text Predictor Using a Markov Chain'
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动6.01：使用马尔可夫链构建文本预测器
- en: '**Solution**:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: There are a few ways to approach this problem, and it is worth mentioning that
    the approach we will be taking is perhaps the easiest way in which text prediction
    is used. In actual practice, text predictions are far more complicated and have
    many other factors that affect them, which we will briefly cover at the end of
    the activity.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题，值得一提的是，我们将采取的方法可能是使用文本预测的最简单方式。在实际实践中，文本预测要复杂得多，并且有许多其他因素会影响它们，我们将在活动结束时简要介绍。
- en: We will be using the transcript of the speech given by Winston Churchill at
    the House of Commons after the soldiers of the Allied forces were rescued from
    Dunkirk during World War II. The speech by itself is worth a read and can be easily
    found online if you are interested.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用温斯顿·丘吉尔在第二次世界大战期间从敦刻尔克被解救的盟军士兵后在英国下议院发表的演讲的文本。这篇演讲本身值得一读，如果您感兴趣，可以在网上轻松找到。
- en: Note
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can download the transcript from [https://packt.live/38rZy6v](https://packt.live/38rZy6v
    ) .
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://packt.live/38rZy6v](https://packt.live/38rZy6v)下载演讲稿。
- en: 'This list is stored in a text file named `churchill.txt`. Read through that
    text file:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个列表存储在名为`churchill.txt`的文本文件中。阅读该文本文件：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We save this in a string object called `churchill` and then use the `split()`
    function in string to tokenize the text we have and store it in a list called
    `keywords`. The output of this will be as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其保存在名为`churchill`的字符串对象中，然后使用字符串中的`split()`函数对我们拥有的文本进行标记化，并将其存储在名为`keywords`的列表中。这将产生以下输出：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we iterate through the list and append the elements to a new list, which
    will store the keyword and the word following it:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们遍历列表并将元素附加到一个新列表中，该列表将存储关键字和其后的单词：
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This produces the following output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The list here is already initialized and is a list of tuples that can be converted
    to a list if you so desire, but it is not necessary.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的列表已经初始化，并且是一个元组列表，如果您愿意，可以将其转换为列表，但这并非必要。
- en: 'After that, initialize a dictionary, `word_dict`. Once we have the dictionary,
    we iterate through the preceding `keylist` array and add words to the left in
    the preceding tuple as keys in the dictionary, and words on the right as values
    in that dictionary. If the word on the left is already added to the dictionary,
    we simply append the word on the right to the respective value in the dictionary:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，初始化一个名为`word_dict`的字典。一旦我们有了字典，我们就会遍历先前的`keylist`数组，并将左侧的单词添加到字典中的键的前一个元组中，并将右侧的单词添加为该字典中的值。如果左侧的单词已添加到字典中，我们只需将右侧的单词附加到字典中的相应值中：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This produces the following output:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Having done this, we are now ready to build our predictor. First, we define
    a NumPy string, which takes a random word as a selection from the preceding set
    of keywords, and this will be our first word:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做到这一点后，我们现在准备构建我们的预测器。首先，我们定义一个NumPy字符串，它从先前的关键字集合中选择一个随机单词，这将是我们的第一个单词：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The second part of the preceding code is designed to make sure that we begin
    our sentence with a word that is capitalized. Without understanding in too much
    depth how natural language processing works, it is simple enough if we understand
    that the capitalized word used in the original transcript will pave the way to
    build a more comprehensive statement. We can also specify a specific word here
    instead of choosing it randomly as long as it is present in the corpus of keywords
    that we use.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的第二部分旨在确保我们的句子以大写字母开头。如果不深入了解自然语言处理的工作原理，只要我们了解在原始文本中使用的大写字母单词将为构建更全面的陈述铺平道路，就足够简单了。只要它存在于我们使用的关键字语料库中，我们也可以在这里指定一个特定的单词，而不是随机选择它。
- en: 'Add this word to a new list:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个单词添加到一个新列表中：
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first word here is generated randomly from the corpus of words present in
    the text file that we use, using the `random` function.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第一个单词是从我们使用的文本文件中单词语料库中随机生成的，使用`random`函数。
- en: We will then append other words based on the dictionary we established previously.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将根据先前建立的字典附加其他单词。
- en: 'Typically, we will be looking at the word we have freshly appended to `word_chain`,
    beginning with the first word in the list. Use this as the key in the dictionary
    we have created and follow it randomly with the list of values for that particular
    key from the dictionary we created previously:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，我们将查看我们刚刚附加到`word_chain`的单词，从列表中的第一个单词开始。将其用作我们创建的字典中的键，并随机跟随先前创建的字典中该特定键的值列表：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note the use of the static variable, `WORDCOUNT`, that we have initialized,
    which specifies how long we want our sentence to be. If you are not in the habit
    of using nested Python functions extensively, simply start solving from the innermost
    function and use the value for the `outer` function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用我们初始化的静态变量`WORDCOUNT`，它指定我们希望句子有多长。如果您不习惯广泛使用嵌套的Python函数，只需从最内部的函数开始解决，并使用`outer`函数的值。
- en: 'Finally, we will define a string variable called `sentence`, which will be
    our output:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将定义一个名为`sentence`的字符串变量，这将是我们的输出：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since both the first words chosen here and the values in the dictionary are
    chosen randomly, we will get a different output every time.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这里选择的第一个单词和字典中的值都是随机选择的，因此我们每次都会得到不同的输出。
- en: 'Let''s look at some of the outputs that we will generate:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些我们将生成的输出：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3gr5uQ5.](https://packt.live/3gr5uQ5
    )
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3gr5uQ5](https://packt.live/3gr5uQ5)。
- en: You can also run this example online at [https://packt.live/31JeD2b.](https://packt.live/31JeD2b
    )
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/31JeD2b](https://packt.live/31JeD2b)上在线运行此示例。
- en: 7\. Doing Basic Statistics with Python
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 使用Python进行基本统计
- en: 'Activity 7.01: Finding Out Highly Rated Strategy Games'
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动7.01：查找评分很高的策略游戏
- en: '**Solution**:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'Load the `numpy` and `pandas` libraries as follows:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载`numpy`和`pandas`库如下：
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Load the strategy games dataset (in the `dataset` folder of the chapter):'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载策略游戏数据集（在本章的`dataset`文件夹中）：
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can download the dataset from the GitHub repository at [https://packt.live/2O1hv2B](https://packt.live/2O1hv2B).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub存储库下载数据集[https://packt.live/2O1hv2B](https://packt.live/2O1hv2B)。
- en: 'Perform all the transformations we did in the first section of the chapter.
    Change the names of the variables:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行我们在本章第一部分所做的所有转换。更改变量的名称：
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Set the `''id''` column as `index`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`'id'`列设置为`index`：
- en: '[PRE54]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Drop the `''url`'' and `''icon_url''` columns:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`'url'`和`'icon_url'`列：
- en: '[PRE55]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Change `''original_release_date''` and `''current_version_release_date''` to
    `datetime`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`'original_release_date'`和`'current_version_release_date'`更改为`datetime`：
- en: '[PRE56]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Eliminate the rows where `''average_user_rating''` is null from the DataFrame:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从DataFrame中删除`'average_user_rating'`为空的行：
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Keep in the DataFrame only the rows where `''user_rating_count''` is equal
    or greater than `30`:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在DataFrame中仅保留`'user_rating_count'`等于或大于`30`的行：
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Print the dimensions of the dataset. You must have a DataFrame with `4311`
    rows and `15` columns. You should get the following output:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印数据集的维度。您必须有一个包含`4311`行和`15`列的DataFrame。您应该得到以下输出：
- en: '[PRE59]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Impute the missing values in the `languages` column with the string `EN` to
    indicate that those games are available only in English:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用字符串`EN`填充`languages`列中的缺失值，以指示这些游戏仅以英语提供：
- en: '[PRE60]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Create a variable called `free_game` that has the value of `free` if the game
    has a price of zero and `paid` if the price is above zero:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`free_game`的变量，如果游戏的价格为零，则具有`free`的值，如果价格高于零，则具有`paid`的值：
- en: '[PRE61]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create a variable called `multilingual` that has the values of `monolingual`
    if the `language` column has only one language string, and `multilingual` if the
    `language` column has at least two language strings:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`multilingual`的变量，如果`language`列只有一个语言字符串，则具有`monolingual`的值，如果`language`列至少有两个语言字符串，则具有`multilingual`的值：
- en: '[PRE62]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Create one variable that contains the four combinations from the two variables
    created in the previous step (`free-monolingual`, `free-multilingual`, `paid-monolingual`,
    and `paid-multilingual`):'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量，其中包含上一步中创建的两个变量的四种组合（`free-monolingual`，`free-multilingual`，`paid-monolingual`和`paid-multilingual`）：
- en: '[PRE63]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Calculate how many observations we have of each type in the `price_language`
    variable. You should get the following output:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算`price_language`变量中每种类型的观察次数。您应该得到以下输出：
- en: '[PRE64]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The output will be as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE65]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Use the `groupby` method on the `games` DataFrame, group by the newly created
    variable, then select the `average_user_rating` variables and calculate the descriptive
    statistics:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`games` DataFrame上使用`groupby`方法，按新创建的变量进行分组，然后选择`average_user_rating`变量并计算描述性统计信息：
- en: '[PRE66]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output will be as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 7.35: Summary statistics grouped by the price_language categories'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.35：按price_language类别分组的摘要统计信息'
- en: '](image/B15968_07_35.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_07_35.jpg)'
- en: 'Figure 7.35: Summary statistics grouped by the price_language categories'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.35：按price_language类别分组的摘要统计信息
- en: Note
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2VBGtJZ.](https://packt.live/2VBGtJZ
    )
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2VBGtJZ](https://packt.live/2VBGtJZ)。
- en: You can also run this example online at [https://packt.live/2BwtJNK.](https://packt.live/2BwtJNK
    )
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/2BwtJNK](https://packt.live/2BwtJNK)上在线运行此示例。
- en: 8\. Foundational Probability Concepts and Their Applications
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.基础概率概念及其应用
- en: 'Activity 8.01: Using the Normal Distribution in Finance'
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动8.01：在金融中使用正态分布
- en: '**Solution**:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'Perform the following steps to complete this activity:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此活动：
- en: 'Using pandas, read the CSV file named `MSFT.csv` from the `data` folder:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用pandas，从`data`文件夹中读取名为`MSFT.csv`的CSV文件：
- en: '[PRE67]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Optionally, rename the columns so they are easy to work with:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，重命名列，使其易于使用：
- en: '[PRE68]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Transform the `date` column into a proper `datetime` column:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`date`列转换为适当的`datetime`列：
- en: '[PRE69]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Set the `date` column as the index of the DataFrame:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`date`列设置为DataFrame的索引：
- en: '[PRE70]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In finance, the daily returns of a stock are defined as the percentage change
    of the daily closing price. Create the `returns` column in the MSFT DataFrame
    by calculating the percent change of the `adj close` column. Use the `pct_change`
    series pandas method to do so:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在金融中，股票的日收益被定义为每日收盘价的百分比变化。通过计算`adj close`列的百分比变化，在MSFT DataFrame中创建`returns`列。使用`pct_change`系列pandas方法来实现：
- en: '[PRE71]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Restrict the analysis period to the dates between `2014-01-01` and `2018-12-31`
    (inclusive):'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将分析期限限制在`2014-01-01`和`2018-12-31`之间的日期（包括在内）：
- en: '[PRE72]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Use a histogram to visualize the distribution of the returns column. Use 40
    bins to do so. Does it look like a normal distribution?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用直方图来可视化收益列的分布。使用40个箱子来做到这一点。看起来像正态分布吗？
- en: '[PRE73]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The output should look like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.24: Histogram of returns of the MSFT stock'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.24：MSFT股票收益直方图'
- en: '](image/B15968_08_24.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_08_24.jpg)'
- en: 'Figure 8.24: Histogram of returns of the MSFT stock'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24：MSFT股票收益直方图
- en: 'Calculate the descriptive statistics of the `returns` column:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算`returns`列的描述性统计信息：
- en: '[PRE74]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The output is as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE75]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Create a random variable named `R_rv` that will represent *The daily returns
    of the MSFT stock*. Use the mean and standard deviation of the return column as
    the parameters for this distribution:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`R_rv`的随机变量，表示*MSFT股票的日收益*。使用返回列的均值和标准差作为此分布的参数：
- en: '[PRE76]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Plot the distribution of `R_rv` and the histogram of the actual data. Use the
    `plt.hist()` function with the `density=True` parameter so both the real data
    and the theoretical distribution appear in the same scale:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制`R_rv`的分布和实际数据的直方图。使用`plt.hist()`函数和`density=True`参数，使真实数据和理论分布以相同的比例显示：
- en: '[PRE77]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The output is as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 8.25: Histogram of returns of the MSFT stock'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.25：MSFT股票收益直方图'
- en: '](image/B15968_08_25.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_08_25.jpg)'
- en: 'Figure 8.25: Histogram of returns of the MSFT stock'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25：MSFT股票收益直方图
- en: Note
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2Zw18Ah](https://packt.live/2Zw18Ah).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2Zw18Ah](https://packt.live/2Zw18Ah)。
- en: You can also run this example online at [https://packt.live/31EmOg9.](https://packt.live/31EmOg9
    )
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/31EmOg9](https://packt.live/31EmOg9)上在线运行此示例。
- en: After looking at the preceding plot, would you say that the normal distribution
    provides an accurate model for the daily returns of Microsoft stock?
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看前面的图后，你会说正态分布是否为微软股票的日收益提供了准确的模型？
- en: '*No. The normal distribution does not provide a very accurate approximation
    regarding the distribution of stocks because the theoretical distribution does
    not completely follow the general shape of the histogram. Although the histogram
    is symmetric with respect to the center and "bell-shaped," we can clearly observe
    that the frequency of the values around zero is much higher than we would expect
    in a normal distribution, which is why we can observe that the bars are well above
    the red curve in the center of the plot. Also, we can observe many extreme values
    (little bars on the left- and right-hand sides) that are unlikely to be present
    in a normal distribution.*'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '*不，正态分布并不能提供关于股票分布的非常准确的近似，因为理论分布并不完全遵循直方图的一般形状。尽管直方图关于中心对称且“钟形”，我们可以清楚地观察到零附近的值的频率比我们在正态分布中期望的要高得多，这就是为什么我们可以观察到柱子在图的中心处的红色曲线上方。此外，我们可以观察到许多极端值（左右两侧的小柱子），这些值在正态分布中不太可能出现。*'
- en: 9\. Intermediate Statistics with Python
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. Python中级统计
- en: 'Activity 9.01: Standardized Test Performance'
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动9.01：标准化测试表现
- en: '**Solution**:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'We are going to use the t-confidence interval function that we created earlier
    to calculate a 95% confidence interval. I have recreated it here for completeness:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用之前创建的t-置信区间函数来计算95%的置信区间。我已经在这里重新创建了它以确保完整性：
- en: '[PRE78]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The output for this code should be the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出应该是以下内容：
- en: '[PRE79]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: It looks like we can say with 95% confidence that the mean score in math for
    a country is between `448.3` and `473.7`, between `449.2` and `472.8` for reading,
    and between `453.9` and `477.0` for science.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们可以以95%的置信度说，一个国家的数学平均分在`448.3`和`473.7`之间，在阅读方面在`449.2`和`472.8`之间，在科学方面在`453.9`和`477.0`之间。
- en: 'We are going to divide the dataset into two different datasets; one where there
    are more than `50` internet users per `100` people, and another where there are
    `50` or fewer internet users per `100` people:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将数据集分成两个不同的数据集；一个是每100人中有超过`50`个互联网用户的数据集，另一个是每100人中有`50`个或更少互联网用户的数据集：
- en: '[PRE80]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here are the two datasets, `data1` and `data0`. Notice how `data1` has all
    the countries where we have more than 50 internet users per 100 people, and `data0`
    has 50 or fewer internet users per 100 people:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个数据集，`data1`和`data0`。请注意`data1`包含所有每100人中有超过50个互联网用户的国家，而`data0`包含每100人中有50个或更少互联网用户的国家：
- en: '[PRE81]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Since we are going to compare two samples with likely different variances,
    we are going to use the 2-sample t-test function from the `scipy.stats` package.
    Our significance level is going to be 5%. Since we want to test to see whether
    the internet users'' majority mean is higher, this will be an upper-tailed test.
    This means that we will have to divide our p-value by 2 and only accept the results
    as significant if the test statistic is positive. The following code will run
    our test (note—this is a truncated version of the code; the complete code can
    be found in the GitHub repository):'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们要比较两个可能具有不同方差的样本，我们将使用`scipy.stats`包中的2样本t检验函数。我们的显著性水平将是5%。由于我们想要测试互联网用户多数的均值是否更高，这将是一个上尾检验。这意味着我们将把p值除以2，并且只有在检验统计量为正时才接受结果为显著。以下代码将运行我们的测试（注意——这是代码的截断版本；完整的代码可以在GitHub存储库中找到）：
- en: '[PRE82]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The results are as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE83]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: For math, reading, and science, the p-value (the second number) is less than
    0.05, and the test statistic (the first number) is positive. This means that for
    all three tests, there is a significant increase in test scores between the majority
    internet users' group over the minority internet users' group.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数学、阅读和科学，p值（第二个数字）小于0.05，检验统计量（第一个数字）为正。这意味着在所有三个测试中，多数互联网用户组的测试成绩显著提高，而少数互联网用户组的测试成绩。
- en: Note
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Results like this always bring up a famous saying in statistics—correlation
    does not imply causation. What this means is that just because we found a significant
    increase in the mean score of the internet majority group, that does not mean
    that the internet caused the increase in the scores. There could be some third
    unknown variable that could be causing the difference, known as a **lurking variable**.
    For example, wealth could be behind the increased scores and internet usage.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的结果总是会引起统计学中一个著名的说法——相关并不意味着因果。这意味着仅仅因为我们发现了互联网多数群体平均分的显著增加，并不意味着互联网导致了分数的增加。可能存在一些第三个未知变量，称为**潜在变量**，可能导致差异。例如，财富可能是增加分数和互联网使用背后的原因。
- en: 'For our final task, we will build a linear regression model that describes
    mathematics scores in terms of reading and science scores. First, let''s extract
    the scores from our DataFrame and put the mathematics scores in their own DataFrame
    separate from the reading and science scores. We will use the `LinearRegression`
    function from `sklearn.linear_model` and assign it to its own variable. Then,
    we will fit the model using the smaller DataFrames. Finally, we will print the
    intercept and the coefficients of the regression equation:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的最后任务，我们将建立一个线性回归模型，描述数学成绩与阅读和科学成绩的关系。首先，让我们从我们的DataFrame中提取分数，并将数学分数放在一个独立的DataFrame中，与阅读和科学分数分开。我们将使用`sklearn.linear_model`中的`LinearRegression`函数，并将其分配给它自己的变量。然后，我们将使用较小的DataFrame拟合模型。最后，我们将打印回归方程的截距和系数：
- en: '[PRE84]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The results are as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE85]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The coefficients are listed in order, so science is first and then reading.
    That would make your equation as:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 系数按顺序列出，所以科学是第一个，然后是阅读。这将使你的方程为：
- en: '![Figure 9.23: Formula for mathematics scores in terms of reading and science
    scores'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.23：数学成绩与阅读和科学成绩的公式'
- en: '](image/B15968_09_23.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_09_23.jpg)'
- en: 'Figure 9.23: Formula for mathematics scores in terms of reading and science
    scores'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23：以阅读和科学成绩为基础的数学成绩的公式
- en: 'Finally, we will graph the points and the regression and notice that the linear
    model fits the data well:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将绘制点和回归，并注意线性模型很好地拟合了数据：
- en: '[PRE86]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The results are as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Figure 9.24: The linear equation seems to fit our data well'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.24：线性方程似乎很好地适合我们的数据'
- en: '](image/B15968_09_24.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_09_24.jpg)'
- en: 'Figure 9.24: The linear equation seems to fit our data well'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24：线性方程似乎很好地适合我们的数据
- en: Note
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3is2GE8.](https://packt.live/3is2GE8
    )
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3is2GE8。](https://packt.live/3is2GE8 )
- en: You can also run this example online at [https://packt.live/3dWmz2o.](https://packt.live/3dWmz2o
    )
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/3dWmz2o](https://packt.live/3dWmz2o )上在线运行此示例
- en: 10\. Foundational Calculus with Python
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10\. 使用Python进行基础微积分
- en: 'Activity 10.01: Maximum Circle-to-Cone Volume'
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动10.01：最大圆锥体积
- en: '**Solution**:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: To find the volume of the resulting cone, you need the height of the cone and
    the radius of the base, as in the figure on the right of *Figure 10.33*. First,
    we find the circumference of the base, which is equal to the arc length AB in
    the cut circle on the left. You can set *R* to `1` since all we're interested
    in is the angle.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找到所得圆锥的体积，您需要圆锥的高度和底部的半径，就像*图10.33*右侧的图中所示。首先，我们找到底部的周长，它等于左侧切割圆上的弧长AB。您可以将*R*设置为`1`，因为我们感兴趣的只是角度。
- en: 'Radian measurements make finding arc lengths easy. It''s just the angle left
    over from the cut, which is *2π - θ* times the radius *R*, which we''re setting
    to `1`. So *θ* is also the circumference of the base of the cone. We can set up
    an equation and solve *r*:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 弧度测量使得找到弧长变得容易。它只是从切割中剩下的角度，即*2π - θ*乘以半径*R*，我们将其设置为`1`。因此*θ*也是圆锥底部的周长。我们可以建立一个方程并解决*r*：
- en: '![Figure 10.34: Formula to calculate the radius'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.34：计算半径的公式'
- en: '](image/B15968_10_34.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_34.jpg)'
- en: 'Figure 10.34: Formula to calculate the radius'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.34：计算半径的公式
- en: 'We''ll code that into our program. We''ll need to import a few things from
    Python''s `math` module and define the `r` variable:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把它编码到我们的程序中。我们需要从Python的`math`模块导入一些东西并定义`r`变量：
- en: '[PRE87]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The height of the cone can be found using the Pythagorean theorem, since the
    hypotenuse, the slant height of the cone, is the radius of the original circle,
    which we set to `1`:![Figure 10.35: Formula for calculating the hypotenuse'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 圆锥的高度可以使用毕达哥拉斯定理找到，因为圆锥的斜高，即原始圆的半径，我们设置为`1`：![图10.35：计算斜边的公式
- en: '](image/B15968_10_35.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_35.jpg)'
- en: 'Figure 10.35: Formula for calculating the hypotenuse'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.35：计算斜边的公式
- en: 'The volume of a cone is:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 圆锥的体积是：
- en: '![Figure 10.36: Formula for calculating the volume of a cone'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.36：计算圆锥体积的公式'
- en: '](image/B15968_10_36.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_10_36.jpg)'
- en: 'Figure 10.36: Formula for calculating the volume of a cone'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.36：计算圆锥体积的公式
- en: 'So, we''ll add that to our function:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，我们将把它添加到我们的函数中：
- en: '[PRE88]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Not so hard, is it? This is all we have to do when using Python. If we were
    doing calculus the old-fashioned way, we'd need an expression for the volume *V*
    in terms of only one variable, *θ*, the angle we cut out. But we have an expression
    for *r* in terms of *θ*, an expression of *h* in terms of *r*, and an expression
    for volume in terms of *h* and *r*. Our program will calculate the volume nearly
    instantaneously.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 不难，是吗？这就是我们在使用Python时所要做的一切。如果我们按照传统方式进行微积分，我们需要一个仅用一个变量*θ*表示体积*V*的表达式。但是我们有一个关于*θ*的*r*表达式，一个关于*r*的*h*表达式，以及一个关于*h*和*r*的体积表达式。我们的程序将几乎瞬间计算出体积。
- en: 'Now we can run that through our `find_max_mins` function. Theta is measured
    in radians, so we''ll check from `0` to `6.28` and print out the degrees version:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过我们的`find_max_mins`函数运行它。角度以弧度测量，所以我们将从`0`到`6.28`进行检查，并打印出度的版本：
- en: '[PRE89]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The output will be as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE90]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: So, the optimal angle to cut out of the original circle is 1.15 radians, which
    is around 66 degrees.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从原始圆中切出的最佳角度是1.15弧度，约为66度。
- en: Note
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3iqx6Xj.](https://packt.live/3iqx6Xj
    )
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3iqx6Xj。](https://packt.live/3iqx6Xj )
- en: You can also run this example online at [https://packt.live/2VJHIqB.](https://packt.live/2VJHIqB
    )
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2VJHIqB](https://packt.live/2VJHIqB )上在线运行此示例
- en: 11\. More Calculus with Python
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11\. 使用Python进行更多微积分
- en: 'Activity 11.01: Finding the Minimum of a Surface'
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动11.01：寻找曲面的最小值
- en: '**Solution**:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案：
- en: 'We need to import the `random` module to use its `uniform` function, which
    chooses a random decimal value in a given range:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要导入`random`模块以使用其`uniform`函数，该函数在给定范围内选择一个随机小数值：
- en: '[PRE91]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Create a function that will provide us with partial derivative of `f` with
    respect to `u` at (`v,w`):'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，它将为我们提供`f`相对于`u`在（`v，w`）处的偏导数：
- en: '[PRE92]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Next, we''ll need a function for the surface, a range for *x*, a range for
    *y*, and a step size:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将需要一个曲面函数，*x*的范围，*y*的范围和一个步长：
- en: '[PRE93]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We''ll call the `uniform` function of the `random` module to generate an `x`
    and a `y` value for the starting point:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将调用`random`模块的`uniform`函数来生成起始点的`x`和`y`值：
- en: '[PRE94]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We might as well print out the starting point for testing purposes. If we simply
    say `print(x,y,f(x,y))`, we''d get unnecessarily long decimals, so we''ll round
    everything off to *two* decimal places when we print:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可能也会打印出测试目的的起始点。如果我们只是说`print(x，y，f(x，y))`，我们会得到不必要的长小数，所以我们在打印时会将所有内容四舍五入到*两*个小数位：
- en: '[PRE95]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '10,000 steps will probably be enough. We could also make it an infinite loop
    with `while True`:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1万步可能足够了。我们也可以将其设置为无限循环，使用`while True`：
- en: '[PRE96]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Calculate the partial derivatives at (x,y):'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在（x，y）处计算偏导数：
- en: '[PRE97]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'If the partial derivatives are both really close to 0, that means we''ve descended
    to a minimum value for *z*. It might be a local minimum, but taking more steps
    won''t get us anywhere for this random starting point:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果偏导数都非常接近0，那意味着我们已经下降到了*z*的最小值。这可能是局部最小值，但对于这个随机起点，再走更多步也不会有任何进展：
- en: '[PRE98]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Take a tiny step in the *x* direction, opposite to the value of the partial
    derivative. That way, we''re always stepping down in the *z* value. Do the same
    for *y*:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向*x*方向迈出一个微小步骤，与偏导数的值相反。这样，我们总是在*z*值下降。对*y*也是一样：
- en: '[PRE99]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'If *x* or *y* goes outside the range of values we gave them, print `Out of
    Bounds` and break out of the loop:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*x*或*y*超出了我们给定的值范围，打印`Out of Bounds`并跳出循环：
- en: '[PRE100]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Finally, print out the value of the location we ended up at, as well as its
    *z* value:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打印出我们最终到达的位置的值，以及它的*z*值：
- en: '[PRE101]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Let''s test this on a surface that we know the minimum value of: a paraboloid
    (a 3D parabola), whose minimum value is 0, at the point (0,0). We''ll test it
    for values between -5 and 5\. Here''s the equation for the surface:![Figure 11.48:
    Equation for the surface of 3D parabola'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在一个我们知道最小值的表面上进行测试：一个抛物面（3D抛物线），其最小值为0，在点(0,0)。我们将在-5到5之间的值上进行测试。以下是表面的方程：![图11.48：3D抛物面的方程
- en: '](image/B15968_11_48.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_48.jpg)'
- en: 'Figure 11.48: Equation for the surface of 3D parabola'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.48：3D抛物面的方程
- en: 'In Python, it will look like this:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python中，它看起来像这样：
- en: '[PRE102]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Here''s what the surface looks like:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 表面的样子如下：
- en: '![Figure 11.49: The graph of a paraboloid'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.49：抛物面的图形'
- en: '](image/B15968_11_49.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_49.jpg)'
- en: 'Figure 11.49: The graph of a paraboloid'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.49：抛物面的图形
- en: 'We chose this one because, similar to its 2D equivalent, the minimum point
    is at (0,0) and the minimum *z* value is 0\. Let''s run the `min_of_surface` function
    on the paraboloid:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择这个，因为与其二维等价物类似，最小点在(0,0)，最小的*z*值是0。让我们在抛物面上运行`min_of_surface`函数：
- en: '[PRE103]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The output is as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE104]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The random point that was chosen was (-1.55, 2.63), which produced a z-value
    of 9.29\. After its walk, it found *the minimum point at (0,0) with a z-value
    of 0*. If you rerun the code, it'll start at a different random point but will
    end up at (0,0).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的随机点是(-1.55, 2.63)，产生了一个z值为9.29。在它的行走后，它找到了*在(0,0)处的最小点，z值为0*。如果重新运行代码，它将从不同的随机点开始，但最终会到达(0,0)。
- en: 'Now that we''re confident the `min_of_surface` function works, let''s try another
    surface:![Figure 11.50: Equation of another surface'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们对`min_of_surface`函数的工作很有信心，让我们尝试另一个表面：![图11.50：另一个表面的方程
- en: '](image/B15968_11_50.jpg)'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_50.jpg)'
- en: 'Figure 11.50: Equation of another surface'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.50：另一个表面的方程
- en: We'll use *-1 < x < 5* and *-1 < y < 5*.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用*-1 < x < 5*和*-1 < y < 5*。
- en: 'First, we redefine the surface function and then run the `min_of_surface` function
    for the range specified:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，重新定义表面函数，然后为指定的范围运行`min_of_surface`函数：
- en: '[PRE105]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The output will be as follows:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE106]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: It looks like the minimum point found from this random point is at (1.1,3.14)
    and that the minimum *z* value is `-1.13`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来从这个随机点找到的最小点是(1.1,3.14)，最小的*z*值是`-1.13`。
- en: 'When we rerun the code to make sure everything is correct, sometimes, we get
    an `Out of Bounds` message and sometimes, we get the same result, but significantly
    often, we end up at this point:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们重新运行代码以确保一切正确时，有时会收到`Out of Bounds`消息，有时会得到相同的结果，但很多时候，我们最终会到达这一点：
- en: '[PRE107]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Let''s put the `min_of_surface` into a loop so we can run a number of trials:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`min_of_surface`放入循环中，这样我们就可以运行多次试验：
- en: '[PRE108]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Here''s the output:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE109]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Every time the program produced a `Minimum`, it was one of the two points we''ve
    already seen. What''s going on? Let''s take a look at a graph of the function:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 每次程序产生`Minimum`时，它都是我们已经看到的两个点中的一个。发生了什么？让我们看一下函数的图形：
- en: '![Figure 11.51: A graph of f(x,y) = 3cos(x) + 5x cos(x) * cos(y)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.51：f(x,y) = 3cos(x) + 5x cos(x) * cos(y)的图形'
- en: '](image/B15968_11_51.jpg)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_11_51.jpg)'
- en: 'Figure 11.51: A graph of ![1](image/B15968_11_InlineEquation81.png)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.51：![1](image/B15968_11_InlineEquation81.png)的图形
- en: What the graph shows is that there's more than one minimum. There's a global
    minimum, where the function goes deep into the negative numbers, and a local minimum,
    where any point in that *valley* will simply descend to the point (1.1, 3.14)
    and not be able to get out.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示的是存在多个最小值。有一个全局最小值，在这个函数深入负数，还有一个局部最小值，在该*valley*中的任何点都会简单地下降到点(1.1, 3.14)，无法离开。
- en: Note
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2ApkzCc.](https://packt.live/2ApkzCc
    )
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参考[https://packt.live/2ApkzCc。](https://packt.live/2ApkzCc )
- en: You can also run this example online at [https://packt.live/2Avxt1K.](https://packt.live/2Avxt1K
    )
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/2Avxt1K](https://packt.live/2Avxt1K)上在线运行此示例。
- en: 12\. Intermediate Calculus with Python
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12. 使用Python进行中级微积分
- en: 'Activity 12.01: Finding the Velocity and Location of a Particle'
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动12.01：找到粒子的速度和位置
- en: '**Solution**:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：'
- en: 'For the first part, we only have to find where ![2](image/B15968_12_InlineEquation3.png).
    Let''s write functions for *dx/dt* and *dy/dt*:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第一部分，我们只需要找到![2](image/B15968_12_InlineEquation3.png)的位置。让我们为*dx/dt*和*dy/dt*编写函数：
- en: '[PRE110]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Now, we can loop from 0 to 1.5 and see where *dy/dt* goes from positive to
    negative or vice versa:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以从0到1.5循环，并查看*dy/dt*从正变为负或反之的位置：
- en: '[PRE111]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Here''s the important part of the output:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出的重要部分：
- en: '[PRE112]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: We can see *dy/dt* is zero somewhere between 1.1 and 1.15 and, again, between
    1.25 and 3 since that's where the output changes its sign.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到*dy/dt*在1.1和1.15之间的某处为零，并且在1.25和3之间再次为零，因为输出改变了符号。
- en: 'Let''s use binary search to narrow down those ranges. This is identical to
    the previous `bin_search` function except for the `guess =` line. We''re simply
    plugging the average into the `f` function to get our guess:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用二分搜索来缩小这些范围。这与之前的`bin_search`函数相同，只是`guess =`行不同。我们只是将平均值插入`f`函数以获得我们的猜测：
- en: '[PRE113]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The answer is `t = 1.145`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是`t = 1.145`。
- en: 'For the other range, you have to change `if guess < target` to `if guess >
    target` and call the function this way:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于其他范围，您必须将`if guess < target`更改为`if guess > target`，并以这种方式调用函数：
- en: '[PRE114]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The answer is `t = 1.253`. But that was too easy. The challenge is to find the
    exact *x-y* location of the particle at those times.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是`t = 1.253`。但那太容易了。挑战在于找到这些时间点粒子的确切*x-y*位置。
- en: 'We need a `position` function that will take tiny steps, like in our ball problem:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个`position`函数，它将采取微小的步骤，就像我们的球问题一样：
- en: '[PRE115]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'First, we set up our increment variable and set a variable called `elapsed`
    to `0`:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们设置我们的增量变量，并将名为`elapsed`的变量设置为`0`：
- en: '[PRE116]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Our initial values of `vx` and `vy` will be the derivatives at 0, and `x` and
    `y` will also start off at 0:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`vx`和`vy`的初始值将是0时的导数，`x`和`y`也将从0开始：
- en: '[PRE117]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Now, we start the loop and run it until the elapsed time reaches the desired
    `t`:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们开始循环并运行，直到经过的时间达到所需的`t`：
- en: '[PRE118]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'We calculate the horizontal and vertical velocity, then increment `x` and `y`
    and the loop counter:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们计算水平和垂直速度，然后增加`x`和`y`以及循环计数器：
- en: '[PRE119]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Now, we''ll put the times we found into the `position` function to get the
    position of the particle at the times we know the derivative is 0:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将找到的时间放入`position`函数中，以获取我们知道导数为0的时间点粒子的位置：
- en: '[PRE120]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The output gives us the following:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE121]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Those are the positions where the vertical velocity is 0.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是垂直速度为0的位置。
- en: 'For the second part, where we need to find the speed of the particle at *t
    = 1*, the speed will be the hypotenuse of the right triangle formed by the vertical
    speed and the horizontal speed:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第二部分，在那里我们需要找到*t = 1*时粒子的速度，速度将是由垂直速度和水平速度形成的直角三角形的斜边：
- en: '[PRE122]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The output is as follows:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE123]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The speed of the particle is 4.85 units per second.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子的速度是每秒4.85个单位。
- en: Note
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/3dQjSzy.](https://packt.live/3dQjSzy
    )
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/3dQjSzy.](https://packt.live/3dQjSzy )
- en: You can also run this example online at [https://packt.live/3f0IBCE](https://packt.live/3f0IBCE).
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3f0IBCE](https://packt.live/3f0IBCE)上在线运行此示例。
