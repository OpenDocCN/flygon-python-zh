- en: Exploring SQL with Qt SQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt SQL探索SQL
- en: For about 40 years, **relational databases** managed with the **structured query
    language** (commonly known as SQL) have been the de facto standard technology
    for storing, retrieving, and analyzing the world's data. Whether you are creating
    business applications, games, web applications, or something else, if your application
    deals with a large amount of data, you will almost certainly be working with SQL.
    While Python has many modules available for connecting to a SQL database, Qt's
    `QtSql` module provides us with powerful and convenient classes for integrating
    SQL data into PyQt applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大约40年来，使用**结构化查询语言**（通常称为SQL）管理的**关系数据库**一直是存储、检索和分析世界数据的事实标准技术。无论您是创建业务应用程序、游戏、Web应用程序还是其他应用，如果您的应用处理大量数据，您几乎肯定会使用SQL。虽然Python有许多可用于连接到SQL数据库的模块，但Qt的`QtSql`模块为我们提供了强大和方便的类，用于将SQL数据集成到PyQt应用程序中。
- en: 'In this chapter, you''ll learn how to build database-driven PyQt applications
    as we cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何构建基于数据库的PyQt应用程序，我们将涵盖以下主题：
- en: SQL basics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL基础知识
- en: Performing SQL queries with Qt
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Qt执行SQL查询
- en: Using SQL with model-view widgets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模型视图小部件与SQL
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Apart from the basic setup you've been using since [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml),
    *Getting Started with PyQt*, you will want the example code found in the GitHub
    repository at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter09](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter09).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 除了您自[第1章](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml)以来一直在使用的基本设置，*开始使用PyQt*，您还需要在GitHub存储库中找到的示例代码，网址为[https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter09](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter09)。
- en: You may also find it helpful to have a copy of **SQLite** to practice the SQL
    examples. SQLite is free and can be downloaded from [https://sqlite.org/download.html](https://sqlite.org/download.html).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会发现拥有**SQLite**的副本对练习SQL示例很有帮助。SQLite是免费的，可以从[https://sqlite.org/download.html](https://sqlite.org/download.html)下载。
- en: Check out the following video to see the code in action: [http://bit.ly/2M5xu1r](http://bit.ly/2M5xu1r)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际操作：[http://bit.ly/2M5xu1r](http://bit.ly/2M5xu1r)
- en: SQL basics
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL基础知识
- en: Before we jump into what `QtSql` has to offer, you will need to be familiar
    with the basics of SQL. This section will give you a quick overview of how to
    create, populate, alter, and query data in a SQL database. If you already know
    SQL, you may want to skip ahead to the PyQt part of this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解`QtSql`提供的内容之前，您需要熟悉SQL的基础知识。本节将为您快速概述如何在SQL数据库中创建、填充、更改和查询数据。如果您已经了解SQL，您可能希望跳到本章的PyQt部分。
- en: SQL is a very different language from Python in syntax and structure. It is
    a **declarative** language, meaning that we describe the results we want rather
    than the procedures used to get them. To interact with a SQL database, we execute
    **statements**. Each statement is made up of a SQL **command** followed by a series
    of **clauses**, each of which further describes the results desired.  Statements
    are terminated with a semicolon.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SQL在语法和结构上与Python非常不同。它是一种**声明式**语言，意味着我们描述我们想要的结果，而不是用于获得结果的过程。与SQL数据库交互时，我们执行**语句**。每个语句由一个SQL**命令**和一系列**子句**组成，每个子句进一步描述所需的结果。语句以分号结束。
- en: Although SQL is standardized, all SQL database implementations provide their
    own alterations and extensions to the standard language. We're going to be learning
    the SQLite dialect of SQL, which is reasonably close to standard SQL.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SQL是标准化的，但所有SQL数据库实现都提供其自己的对标准语言的修改和扩展。我们将学习SQL的SQLite方言，它与标准SQL相当接近。
- en: Unlike Python, SQL is generally a case-insensitive language; however, it is
    a long-standing convention to write SQL keywords in all uppercase letters. This
    helps them to stand out from data and object names. We will follow this convention
    in the book, but it is optional for your code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python不同，SQL通常是不区分大小写的语言；但是，长期以来，将SQL关键字写成大写字母是一种惯例。这有助于它们与数据和对象名称区分开。我们将在本书中遵循这个惯例，但对于您的代码来说是可选的。
- en: Creating tables
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表
- en: SQL databases are made of relations, also known as **tables**. A table is a
    two-dimensional data structure made of rows and columns. Each row in the table
    represents a single item about which we have information, and each column represents
    a type of information we are storing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SQL数据库由关系组成，也称为**表**。表是由行和列组成的二维数据结构。表中的每一行代表我们拥有信息的单个项目，每一列代表我们正在存储的信息类型。
- en: 'Tables are defined using the `CREATE TABLE` command, like so:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CREATE TABLE`命令定义表，如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `CREATE TABLE` statement is followed by a table name and a list of column
    definitions. In this example, `coffees` is the name of the table we're creating,
    and the column definitions are inside the parentheses. Each column has a name,
    a data type, and any number of **constraints** that describe valid values.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE TABLE`语句后面跟着表名和列定义列表。在这个例子中，`coffees`是我们正在创建的表的名称，列定义在括号内。每一列都有一个名称，一个数据类型，以及描述有效值的任意数量的**约束**。'
- en: 'In this case, we have three columns:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有三列：
- en: '`id` is an integer column. It''s marked as the **primary key**, which means
    it will be a unique value that can be used to identify the row.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`是一个整数列。它被标记为**主键**，这意味着它将是一个可以用来标识行的唯一值。'
- en: '`coffee_brand` and `coffee_name` are both text columns with a `NOT NULL` constraint,
    meaning they cannot have `NULL` for a value.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coffee_brand`和`coffee_name`都是文本列，具有`NOT NULL`约束，这意味着它们不能有`NULL`值。'
- en: Constraints can also be defined on multiple columns. The `UNIQUE` constraint
    added after the fields is not a field, but a table-level constraint that makes
    sure the combination of `coffee _brand` and `coffee _name` is unique for each
    row.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 约束也可以在多个列上定义。在字段后添加的`UNIQUE`约束不是字段，而是一个表级约束，确保每行的`coffee _brand`和`coffee _name`的组合对于每行都是唯一的。
- en: '`NULL` is the SQL equivalent of Python''s `None`. It indicates the absence
    of information.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`NULL`是SQL中Python的`None`的等价物。它表示信息的缺失。'
- en: SQL databases, at a minimum, support text, numeric, date, time, and binary object
    data types; but it's not uncommon for different database implementations to extend
    SQL with additional data types, such as currency or IP address types. Many databases
    also have `SMALL` and `BIG` variants of numeric types, allowing the developer
    to fine-tune the amount of storage space used by a column.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: SQL数据库至少支持文本、数字、日期、时间和二进制对象数据类型；但不少数据库实现会通过扩展SQL来支持额外的数据类型，比如货币或IP地址类型。许多数据库还有数字类型的`SMALL`和`BIG`变体，允许开发人员微调列使用的存储空间。
- en: 'As useful as simple two-dimensional tables are, the real power of a SQL database
    is in joining multiple, related tables together, for example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管简单的二维表很有用，但SQL数据库的真正威力在于将多个相关表连接在一起，例如：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `roast_id` column in `coffees` holds values that match the primary keys
    of `roasts`, as indicated by the `REFERENCES` constraint. Rather than having to
    rewrite the description and color of a roast in every coffee record, each `coffees`
    record simply points to a row in `roasts` that holds the information about the
    roast of that coffee. In the same way, the `reviews` table contains the `coffee_id`
    column, which refers to an individual `coffees` entry. These relationships are
    called **foreign key relationships** since the field refers to the key from another
    table.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`coffees`中的`roast_id`列保存与`roasts`的主键匹配的值，如`REFERENCES`约束所示。每个`coffees`记录不需要在每条咖啡记录中重写烘焙的描述和颜色，而是简单地指向`roasts`中保存有关该咖啡烘焙信息的行。同样，`reviews`表包含`coffee_id`列，它指向一个单独的`coffees`条目。这些关系称为**外键关系**，因为该字段引用另一个表的键。'
- en: Modeling data in multiple, related tables like this reduces duplication and
    enforces data **consistency**. Imagine if the data in all three tables were combined
    into one table of coffee reviews—it would be possible for two reviews of the same
    coffee product to have different roasts specified. That shouldn't be possible,
    and with relational data tables, it isn't.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个相关表中对数据进行建模可以减少重复，并强制执行数据一致性。想象一下，如果所有三个表中的数据合并成一张咖啡评论表，那么同一款咖啡产品的两条评论可能会指定不同的烘焙程度。这是不可能的，而且在关系型数据表中也不会发生。
- en: Inserting and updating data
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入和更新数据
- en: 'Once tables are created, we can add new rows of data using an `INSERT` statement
    using this syntax:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表后，我们可以使用`INSERT`语句添加新的数据行，语法如下：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For example, let''s insert some rows into `roasts` :'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们向`roasts`中插入一些行：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we're providing a `description` and `color` value for each
    new record in the `roasts` table. The `VALUES` clause contains a list of tuples,
    each of which represents a row of data. The number and data types of the values
    in these tuples *must* match the number and data types of the columns specified.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为`roasts`表中的每条新记录提供了`description`和`color`值。`VALUES`子句包含一个元组列表，每个元组代表一行数据。这些元组中的值的数量和数据类型*必须*与指定的列的数量和数据类型匹配。
- en: Note that we didn't include all the columns—`id` is missing. Any fields we don't
    specify in an `INSERT` statement will get a default value, which is `NULL` unless
    we specify otherwise.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有包括所有的列——`id`缺失。我们在`INSERT`语句中不指定的任何字段都将获得默认值，除非我们另有规定，否则默认值为`NULL`。
- en: In SQLite, an `INTEGER PRIMARY KEY` field has special behavior in which its
    default value is automatically incremented on each insert. Therefore, the `id`
    values resulting from this query will be `1` for `Light`, `2` for `Medium`, `3`
    for `Dark`, and `4` for `Burnt to a Crisp`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLite中，`INTEGER PRIMARY KEY`字段具有特殊行为，其默认值在每次插入时自动递增。因此，此查询产生的`id`值将为`1`（`Light`），`2`（`Medium`），`3`（`Dark`）和`4`（`Burnt
    to a Crisp`）。
- en: 'This is important to know, since we need that key value to insert records into
    our `coffees` table:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点很重要，因为我们需要该键值来插入记录到我们的`coffees`表中：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Unlike Python, SQL string literals *must* use single quotes only. A double-quoted
    string is interpreted as the name of a database object, such as a table or column.
    To escape a single quote in a string, use two of them, as we've done in the preceding
    query.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python不同，SQL字符串文字*必须*只使用单引号。双引号字符串被解释为数据库对象的名称，比如表或列。要在字符串中转义单引号，请使用两个单引号，就像我们在前面的查询中所做的那样。
- en: 'Because of our foreign key constraint, it is impossible to insert a row in
    `coffees` that contains a `roast_id` that doesn''t exist in `roasts`. For example,
    this would return an error:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的外键约束，不可能在`coffees`中插入包含不存在于`roasts`中的`roast_id`的行。例如，这将返回一个错误：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that we can insert `NULL` in the `roast_id` field; unless the column was
    defined with a `NOT NULL` constraint, `NULL` is the only value that doesn't have
    to obey the foreign key constraint.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以在`roast_id`字段中插入`NULL`；除非该列被定义为`NOT NULL`约束，否则`NULL`是唯一不需要遵守外键约束的值。
- en: Updating existing rows
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新现有行
- en: 'To update existing rows in a table, you use the `UPDATE` statement, like so:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新表中的现有行，您可以使用`UPDATE`语句，如下所示：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `SET` clause is followed by a list of value assignments for the fields you
    want to change, and the `WHERE` clause describes conditions that must be true
    if a particular row is to be updated. In this case, we're going to change the
    value of the `roast_id` column to `4` for the record where the `id` column is
    `2`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`SET`子句后面是要更改的字段的值分配列表，`WHERE`子句描述了必须为真的条件，如果要更新特定行。在这种情况下，我们将把`id`列为`2`的记录的`roast_id`列的值更改为`4`。'
- en: SQL uses a single equals sign for both assignment and equality operations. It
    does not ever use the double-equals sign that Python uses.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: SQL使用单个等号来进行赋值和相等操作。它永远不会使用Python使用的双等号。
- en: 'Update operations can also affect multiple records, like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 更新操作也可以影响多条记录，就像这样：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, we're incrementing the `roast_id` value on all the `Strawbunks`
    coffees by setting it equal to `roast_id + 1`. Whenever we reference a column's
    value in a query like this, the value will be that of the column in the same row.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通过将`Strawbunks`咖啡的所有`roast_id`值增加1来增加。每当我们在查询中引用列的值时，该值将是同一行中的列的值。
- en: Selecting data
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择数据
- en: 'Probably the most important operation in SQL is the `SELECT` statement, which
    is used to retrieve data. A simple `SELECT` statement looks like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: SQL中最重要的操作可能是`SELECT`语句，用于检索数据。一个简单的`SELECT`语句看起来像这样：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `SELECT` command is followed by a list of fields, or by the `*` symbol,
    which means *all fields*. The `FROM` clause defines the source of the data; in
    this case, the `reviews` table. The `WHERE` clause, once again, defines conditions
    that must be true for the rows to be included. In this case, we'll only include
    reviews newer than March 1, 2019, by comparing each row's `review_date` field
    (which is a `DATE` type) to the string `'2019-03-01'` (which SQLite will convert
    to a `DATE` to make the comparison). Finally, the `ORDER BY` clause determines
    the sorting of the result set.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT`命令后面跟着一个字段列表，或者跟着`*`符号，表示*所有字段*。`FROM`子句定义了数据的来源；在这种情况下，是`reviews`表。`WHERE`子句再次定义了必须为真的条件才能包括行。在这种情况下，我们只包括比2019年3月1日更新的评论，通过比较每行的`review_date`字段（它是一个`DATE`类型）和字符串`''2019-03-01''`（SQLite将其转换为`DATE`以进行比较）。最后，`ORDER
    BY`子句确定了结果集的排序方式。'
- en: Table joins
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表连接
- en: '`SELECT` statements always return a single table of values. Even if your result
    set has only a single value, it will be in a table of one row and one column,
    and there is no way to return multiple tables from a single query. However, we
    can pull data from multiple tables by combining the data into a single table.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT`语句总是返回一个值表。即使你的结果集只有一个值，它也会在一个行和一列的表中，而且没有办法从一个查询中返回多个表。然而，我们可以通过将数据合并成一个表来从多个表中提取数据。'
- en: 'This can be done using a `JOIN` in the `FROM` clause, for example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在`FROM`子句中使用`JOIN`来实现，例如：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, our `FROM` clause contains two `JOIN` statements. The first joins
    `coffees` to `roasts` by matching the `roast_id` field in `coffees` to the `id`
    field in `roasts`. The second joins the `reviews` table by matching the `coffee_id`
    column in `reviews` to the `id` column in `coffees`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的`FROM`子句包含两个`JOIN`语句。第一个将`coffees`与`roasts`通过匹配`coffees`中的`roast_id`字段和`roasts`中的`id`字段进行连接。第二个通过匹配`reviews`表中的`coffee_id`列和`coffees`表中的`id`列进行连接。
- en: 'The joins are slightly different: notice that the `reviews` join is a `LEFT
    OUTER JOIN`. This means that we''re including rows from `coffees` that don''t
    have any matching `reviews` records; a default `JOIN` is an `INNER` join, meaning
    only rows with matching records in both tables will be shown.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 连接略有不同：请注意`reviews`连接是一个`LEFT OUTER JOIN`。这意味着我们包括了`coffees`中没有任何匹配`reviews`记录的行；默认的`JOIN`是一个`INNER`连接，意味着只有在两个表中都有匹配记录的行才会显示。
- en: We're also using an **aggregate function** in this query, `COUNT()`. The `COUNT()`
    function merely tallies up the matching rows. An aggregate function requires that
    we specify a `GROUP BY` clause listing the fields that will be the basis of the
    aggregation. In other words, for each unique combination of `coffee_brand`, `coffee_name`,
    and `roast`, we'll get a tally of the review records in the database. Other standard
    aggregate functions include `SUM` (for summing all matching values), `MIN` (for
    returning the minimum of all matching values), and `MAX` (for returning the maximum
    of all matching values). Different database implementations also include their
    own custom aggregate functions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个查询中，我们还使用了一个**聚合函数**，`COUNT()`。`COUNT()`函数只是计算匹配的行数。聚合函数要求我们指定一个`GROUP BY`子句，列出将作为聚合基础的字段。换句话说，对于每个`coffee_brand`、`coffee_name`和`roast`的唯一组合，我们将得到数据库中评论记录的总数。其他标准的聚合函数包括`SUM`（用于对所有匹配值求和）、`MIN`（返回所有匹配值的最小值）和`MAX`（返回所有匹配值的最大值）。不同的数据库实现还包括它们自己的自定义聚合函数。
- en: SQL subqueries
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL子查询
- en: 'A `SELECT` statement can be embedded in another SQL statement by putting it
    in parentheses. This is called a **subquery**. Exactly where it can be embedded
    depends on what kind of data the query is expected to return:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT`语句可以通过将其放在括号中嵌入到另一个SQL语句中。这被称为**子查询**。它可以嵌入的确切位置取决于查询预期返回的数据类型：'
- en: If the statement will return a single row and column, it can be embedded wherever
    a single value is expected
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果语句将返回一个单行单列，它可以嵌入到期望单个值的任何地方
- en: If the statement will return a single column with multiple rows, it can be embedded
    wherever a list of values is expected
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果语句将返回一个单列多行，它可以嵌入到期望值列表的任何地方
- en: If the statement will return multiple rows and columns, it can be embedded wherever
    a table of values is expected
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果语句将返回多行多列，它可以嵌入到期望值表的任何地方
- en: 'Consider this query:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个查询：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have three subqueries here. The first is located in the `FROM` clause:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个子查询。第一个位于`FROM`子句中：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Because it begins with `SELECT *`, we can be sure it will return a table of
    data (or no data, but that's moot). Therefore, it can be used in the `FROM` clause,
    since a table is expected here. Note that we need to give the subquery a name
    using the `AS` keyword. This is required when using a subquery in the `FROM` clause.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它以`SELECT *`开头，我们可以确定它将返回一个数据表（或者没有数据，但这不重要）。因此，它可以在`FROM`子句中使用，因为这里期望一个表。请注意，我们需要使用`AS`关键字给子查询一个名称。在`FROM`子句中使用子查询时，这是必需的。
- en: 'This subquery contains its own subquery:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子查询包含了它自己的子查询：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This query is reasonably certain to give us a single value, so we're using it
    where a single value is expected; in this case, as an operand of a greater-than
    expression. If, for some reason, this query returned multiple rows, our query
    would return an error.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询很可能会给我们一个单一的值，所以我们在期望得到单一值的地方使用它；在这种情况下，作为大于表达式的操作数。如果由于某种原因，这个查询返回了多行，我们的查询将会返回一个错误。
- en: 'Our final subquery is in the `WHERE` clause:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的子查询在`WHERE`子句中：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This expression is guaranteed to return only one column but may return multiple
    rows. We're therefore using it as an argument to the `IN` keyword, which expects
    a list of values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式保证只返回一列，但可能返回多行。因此，我们将其用作`IN`关键字的参数，该关键字期望一个值列表。
- en: Subqueries are powerful, but can also cause slowdown and, sometimes, errors
    if our assumptions about the data are incorrect.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询很强大，但如果我们对数据的假设不正确，有时也会导致减速和错误。
- en: Learning more
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习更多
- en: We've only touched on the basics of SQL here, but this should be enough to get
    you started creating and using simple databases, and covers the SQL we'll be using
    in this chapter. See the *Further reading* section at the end of the chapter for
    more in-depth SQL resources. In the next section, you'll see how to combine your
    knowledge of SQL with PyQt to create data-driven applications.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只是简单地介绍了SQL的基础知识，但这应该足够让您开始创建和使用简单的数据库，并涵盖了本章中将要使用的SQL。在本章末尾的*进一步阅读*部分中，您将看到如何将SQL知识与PyQt结合起来创建数据驱动的应用程序。
- en: Performing SQL queries with Qt
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Qt执行SQL查询
- en: 'Working with different SQL implementations can be frustrating: not only are
    there slight differences in the SQL syntax, but the Python libraries used to connect
    to them are often inconsistent in the various methods they implement. While, in
    some ways, it''s less convenient than the better-known Python SQL libraries, `QtSQL`
    does provide us with a single abstracted API for working with a variety of database
    products in a consistent way. When leveraged properly, it can also save us a large
    amount of code.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的SQL实现可能会令人沮丧：不仅SQL语法有细微差异，而且用于连接它们的Python库在它们实现的各种方法上经常不一致。虽然在某些方面，它不如更知名的Python
    SQL库方便，但`QtSQL`确实为我们提供了一种一致的抽象API，以一致的方式处理各种数据库产品。正确利用时，它还可以为我们节省大量代码。
- en: To learn how to work with SQL data in PyQt, we're going to build a graphical
    frontend for the coffee database we created in the *SQL basics* section of this
    chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习如何在PyQt中处理SQL数据，我们将为本章*SQL基础*中创建的咖啡数据库构建一个图形前端。
- en: 'A complete version of this database can be created from the sample code using
    this command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令从示例代码创建完整版本的数据库：
- en: '`$ sqlite3 coffee.db -init coffee.sql`. You will need to create this database
    file before the frontend will work.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ sqlite3 coffee.db -init coffee.sql`。在前端工作之前，您需要创建这个数据库文件。'
- en: Building a form
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个表单
- en: 'Our coffee database has three tables: a list of coffee products, a list of
    roasts, and a table of reviews for the products. Our GUI will be designed as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的咖啡数据库有三个表：咖啡产品列表、烘焙列表和产品评论表。我们的GUI将设计如下：
- en: It will have a list of coffee brands and products
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将有一个咖啡品牌和产品列表
- en: When we double-click an item in the list, it will open a form that will show
    all the information about the coffee and all the reviews associated with that
    product
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们双击列表中的项目时，它将打开一个表单，显示关于咖啡的所有信息，以及与该产品相关的所有评论
- en: It will allow us to add new products and new reviews or edit any existing information
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将允许我们添加新产品和新评论，或编辑任何现有信息
- en: 'Let''s start by copying your basic PyQt application template from [Chapter
    4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml), *Building Applications with QMainWindow*
    to a file called `coffee_list1.py`. Then, add an import for `QtSQL` like so:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从[第4章](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml)中复制您的基本PyQt应用程序模板，*使用QMainWindow构建应用程序*，保存为`coffee_list1.py`。然后，像这样添加一个`QtSQL`的导入：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we''re going to create a form to display information about our coffee product.
    The basic form looks like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要创建一个表单，显示关于我们的咖啡产品的信息。基本表单如下：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This form has fields for the brand, name, and roast of the coffee, plus a table
    widget for showing the reviews. Note that the constructor requires `roasts`, which
    is a list of roasts for the combo box; we want to get these from the database,
    not hardcode them into the form, since new roasts might get added to the database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表单有品牌、名称和咖啡烘焙的字段，以及一个用于显示评论的表格小部件。请注意，构造函数需要`roasts`，这是一个咖啡烘焙的列表，用于组合框；我们希望从数据库中获取这些，而不是将它们硬编码到表单中，因为新的烘焙可能会被添加到数据库中。
- en: 'This form is also going to need a way to display a coffee product. Let''s create
    a method that will take coffee data and review it, and populate the form with
    it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表单还需要一种方法来显示咖啡产品。让我们创建一个方法，它将获取咖啡数据并对其进行审查，并用它填充表单：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This method assumes that `coffee_data` is a `dict` object containing the brand,
    name, and roast ID and that `reviews` is a list of tuples containing the review
    data. It simply goes through those data structures and populates each field with
    the data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法假设`coffee_data`是一个包含品牌、名称和烘焙ID的`dict`对象，而`reviews`是一个包含评论数据的元组列表。它只是遍历这些数据结构，并用数据填充每个字段。
- en: 'Down in `MainWindow.__init__()`, let''s start the main GUI:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainWindow.__init__()`中，让我们开始主GUI：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We'll be using `QStackedWidget` to swap between our coffee list and coffee form
    widgets. Recall that this widget is similar to `QTabWidget` but without the tabs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`QStackedWidget`在我们的咖啡列表和咖啡表单小部件之间进行切换。请记住，这个小部件类似于`QTabWidget`，但没有选项卡。
- en: Before we can build more of our GUI, we need to get some information from the
    database. Let's talk about how to connect to a database with `QtSQL`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以构建更多GUI之前，我们需要从数据库中获取一些信息。让我们讨论如何使用`QtSQL`连接到数据库。
- en: Connecting and making simple queries
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接和进行简单查询
- en: 'To use a SQL database with `QtSQL`, we first have to establish a connection.
    There are three steps to this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`QtSQL`与SQL数据库，我们首先必须建立连接。这有三个步骤：
- en: Create the connection object
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建连接对象
- en: Configure the connection object
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置连接对象
- en: Open the connection
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开连接
- en: 'In `MainWindow.__init__()`, let''s create our database connection:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainWindow.__init__()`中，让我们创建我们的数据库连接：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Rather than directly creating a `QSqlDatabase` object, we create one by calling
    the static `addDatabase` method with the name of the database driver we're going
    to use. In this case, we're using Qt's SQLite3 driver. Qt 5.12 comes with nine
    drivers built-in, including ones for MySQL (`QMYSQL`), PostgreSQL (`QPSQL`), and
    ODBC connections (including Microsoft SQL Server) (`QODBC`). A complete list can
    be found at [https://doc.qt.io/qt-5/qsqldatabase.html#QSqlDatabase-2](https://doc.qt.io/qt-5/qsqldatabase.html#QSqlDatabase-2).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是直接创建`QSqlDatabase`对象，而是通过调用静态的`addDatabase`方法创建一个，其中包含我们将要使用的数据库驱动程序的名称。在这种情况下，我们使用的是Qt的SQLite3驱动程序。Qt
    5.12内置了九个驱动程序，包括MySQL（`QMYSQL`）、PostgreSQL（`QPSQL`）和ODBC连接（包括Microsoft SQL Server）（`QODBC`）。完整的列表可以在[https://doc.qt.io/qt-5/qsqldatabase.html#QSqlDatabase-2](https://doc.qt.io/qt-5/qsqldatabase.html#QSqlDatabase-2)找到。
- en: 'Once our database object is created, we need to configure it with any required
    connection settings, such as the host, user, password, and database name. For
    SQLite, we only need to specify a filename, as shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的数据库对象创建好了，我们需要用任何必需的连接设置来配置它，比如主机、用户、密码和数据库名称。对于SQLite，我们只需要指定一个文件名，如下所示：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Some of the properties we can configure include the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置的一些属性包括以下内容：
- en: '`hostName`—The hostname or IP of the database server'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hostName`—数据库服务器的主机名或IP'
- en: '`port`—The network port on which the database service is listening'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`—数据库服务侦听的网络端口'
- en: '`userName`—The username to connect with'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userName`—连接的用户名'
- en: '`password`—The password to authenticate with'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password`—用于身份验证的密码'
- en: '`connectOptions`—A string of additional connection options'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connectOptions`—附加连接选项的字符串'
- en: All of these can be configured or queried using the usual accessor method (for
    example, `hostName()` and `setHostName()`). If you're working with something other
    than SQLite, consult its documentation to see what settings you need to configure.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以使用通常的访问器方法进行配置或查询（例如`hostName()`和`setHostName()`）。如果你使用的是SQLite之外的其他东西，请查阅其文档，看看你需要配置哪些设置。
- en: Once our connection object is configured, we can open the connection using the
    `open()` method. This method returns a Boolean value, indicating whether or not
    the connection succeeded. If it failed, we can find out why by checking the connection
    object's `lastError` property.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 连接对象配置好之后，我们可以使用`open()`方法打开连接。这个方法返回一个布尔值，表示连接是否成功。如果失败，我们可以通过检查连接对象的`lastError`属性来找出失败的原因。
- en: 'This code demonstrates how we might do that:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码演示了我们可能会这样做：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we call `self.db.open()` and, if it fails, we retrieve the error from
    `lastError` and display it in a dialog. The `lastError()` call returns a `QSqlError`
    object, which holds data and metadata about the error; to extract the actual error
    text, we call its `text()` method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用`self.db.open()`，如果失败，我们从`lastError`中检索错误并在对话框中显示它。`lastError()`调用返回一个`QSqlError`对象，其中包含有关错误的数据和元数据；要提取实际的错误文本，我们调用它的`text()`方法。
- en: Getting information about the database
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取有关数据库的信息
- en: 'Once our connection is actually connected, we can use it to start inspecting
    the database. For example, the `tables()` method lists all tables in the database.
    We can use this to check that all required tables are present as follows, for
    example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的连接实际连接上了，我们就可以使用它来开始检查数据库。例如，`tables()`方法列出数据库中的所有表。我们可以使用这个方法来检查所有必需的表是否存在，例如：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we compare the tables that exist in the database to a set of the required
    tables. If we find any missing, we'll show an error and exit.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们比较数据库中存在的表和必需表的集合。如果我们发现任何缺失，我们将显示错误并退出。
- en: '`set` objects are like lists, except that all items in them are unique, and
    they allow for some useful comparisons. In this situation, we''re subtracting
    sets to find out whether there are any items in `required_tables` that aren''t
    in `tables`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`对象类似于列表，不同之处在于其中的所有项目都是唯一的，并且它们允许进行一些有用的比较。在这种情况下，我们正在减去集合以找出`required_tables`中是否有任何不在`tables`中的项目。'
- en: Making simple queries
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行简单的查询
- en: Interacting with our SQL database relies on the `QSqlQuery` class. This class
    represents a request to the SQL engine and can be used to prepare, execute, and
    retrieve data and metadata about a query.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的SQL数据库交互依赖于`QSqlQuery`类。这个类表示对SQL引擎的请求，可以用来准备、执行和检索有关查询的数据和元数据。
- en: 'We can make a SQL query to the database by using our database object''s `exec()`
    method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用数据库对象的`exec()`方法向数据库发出SQL查询：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `exec()` method creates a `QSqlQuery` object from our string, executes
    it, and returns it to us. We can then retrieve the results of our query from the
    `query` object:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec()`方法从我们的字符串创建一个`QSqlQuery`对象，执行它，并将其返回给我们。然后我们可以从`query`对象中检索我们查询的结果：'
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It's important to get a mental model of what's happening here, because it's
    not terribly intuitive. As you know, SQL queries always return a table of data,
    even if there is just one row and one column. `QSqlQuery` has an implicit *cursor*
    that will be pointed at a row of the data. Initially, this cursor is pointed nowhere,
    but calling the `next()` method moves it to the next available row of data, which,
    in this case, is the first row. The `value()` method is then used to retrieve
    the value of a given column in the currently selected row (`value(0)` will retrieve
    the first column, `value(1)` the second, and so on).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要对这里发生的事情有一个心理模型，因为这并不是非常直观的。正如你所知，SQL查询总是返回一张数据表，即使只有一行和一列。`QSqlQuery`有一个隐式的*游标*，它将指向数据的一行。最初，这个游标指向无处，但调用`next()`方法将它移动到下一个可用的数据行，这种情况下是第一行。然后使用`value()`方法来检索当前选定行中给定列的值（`value(0)`将检索第一列，`value(1)`将检索第二列，依此类推）。
- en: 'So, what''s happening here is something like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里发生的情况类似于这样：
- en: The query is executed and populated with data. The cursor points nowhere.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询被执行并填充了数据。游标指向无处。
- en: We call `next()` to point the cursor at the first row.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用`next()`将光标指向第一行。
- en: We call `value(0)` to retrieve the value from the first column of the row.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用`value(0)`来检索行的第一列的值。
- en: 'To retrieve a list or table of data from a `QSqlQuery` object, we just need
    to repeat those last two steps until `next()` returns `False` (meaning that there
    is not the next row to point to). For example, we need a list of the coffee roasts
    to populate our form, so let''s retrieve that:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`QSqlQuery`对象中检索数据列表或表，我们只需要重复最后两个步骤，直到`next()`返回`False`（表示没有下一行要指向）。例如，我们需要一个咖啡烘焙的列表来填充我们的表单，所以让我们检索一下：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, we've asked a query to get all the data from the `roasts` table
    and order it by `id`. Then, we call `next()` on our query object until it returns
    `False`; each time, extracting the value of the second field (`query.value(1)`)
    and appending it to our `roasts` list.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们要求查询从`roasts`表中获取所有数据，并按`id`排序。然后，我们在查询对象上调用`next()`，直到它返回`False`；每次，提取第二个字段的值（`query.value(1)`）并将其附加到我们的`roasts`列表中。
- en: 'Now that we have that data, we can create our `CoffeeForm` and add it to the
    application:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这些数据，我们可以创建我们的`CoffeeForm`并将其添加到应用程序中：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In addition to retrieving values using `value()`, we can retrieve an entire
    row by calling the `record()` method. This returns a `QSqlRecord` object containing
    data for the current row (or an empty record, if no row is pointed at). We'll
    use `QSqlRecord` later in this chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`value()`检索值之外，我们还可以通过调用`record()`方法来检索整行。这将返回一个包含当前行数据的`QSqlRecord`对象（如果没有指向任何行，则返回一个空记录）。我们将在本章后面使用`QSqlRecord`。
- en: Prepared queries
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好的查询
- en: Quite often, data needs to be passed into a SQL query from an application. For
    example, we need to write a method that looks up a single coffee by ID number
    so that we can display it in our form.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，数据需要从应用程序传递到SQL查询中。例如，我们需要编写一个方法，通过ID号查找单个咖啡，以便我们可以在我们的表单中显示它。
- en: 'We could start writing that method something like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始编写该方法，就像这样：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this situation, we're using a format string to put the `coffee_id` value
    directly into our query. Do not do this!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用格式化字符串直接将`coffee_id`的值放入我们的查询中。不要这样做！
- en: 'Using string formatting or concatenation to build SQL queries can lead to something
    called a **SQL injection vulnerability**, in which passing a specially crafted
    value can expose or destroy data in the database. In this case, we''re assuming
    that `coffee_id` is going to be an integer, but suppose a malicious user is able
    to send this function a string like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串格式化或连接构建SQL查询可能会导致所谓的**SQL注入漏洞**，其中传递一个特制的值可能会暴露或破坏数据库中的数据。在这种情况下，我们假设`coffee_id`将是一个整数，但假设一个恶意用户能够向这个函数发送这样的字符串：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Our string formatting would evaluate this and generate the following SQL statement:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的字符串格式化将评估这一点，并生成以下SQL语句：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The result would be that all the rows in our `coffees` table would be deleted!
    While this may seem trivial or absurd in this context, SQL injection vulnerabilities
    are behind many of the data breaches and hacking scandals you read about in the
    news. It's important to be defensive when working with important data (and what's
    more important than coffee?).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是我们的`coffees`表中的所有行都将被删除！虽然在这种情况下可能看起来微不足道或荒谬，但SQL注入漏洞是许多数据泄露和黑客丑闻背后的原因，这些你在新闻中读到的。在处理重要数据时（还有比咖啡更重要的东西吗？），保持防御是很重要的。
- en: The proper way to do this query and protect your database from such vulnerabilities
    is to use a prepared query. A **prepared query** is a query that contains variables
    to which we can bind values. The database driver will then properly escape our
    values so that they are not accidentally interpreted as SQL code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此查询并保护数据库免受此类漏洞的正确方法是使用准备好的查询。**准备好的查询**是一个包含我们可以绑定值的变量的查询。数据库驱动程序将适当地转义我们的值，以便它们不会被意外地解释为SQL代码。
- en: 'This version of the code uses a prepared query:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的代码使用了一个准备好的查询：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we've explicitly created an empty `QSqlQuery` object connected to our
    database. Then, we passed a SQL string to the `prepare()` method. Notice the `:id`
    string used in our query; the colon indicates that this is a variable. Once we
    have the prepared query, we can begin binding the variables in the query to variables
    in our code using `bindValue()`. In this case, we've bound the `:id` SQL variable to
    our `coffee_id` Python variable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们明确地创建了一个连接到我们的数据库的空`QSqlQuery`对象。然后，我们将SQL字符串传递给`prepare()`方法。请注意我们查询中使用的`:id`字符串；冒号表示这是一个变量。一旦我们有了准备好的查询，我们就可以开始将查询中的变量绑定到我们代码中的变量，使用`bindValue()`。在这种情况下，我们将`：id`
    SQL变量绑定到我们的`coffee_id` Python变量。
- en: Once our query is prepared and the variables are bound, we call its `exec()`
    method to execute it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的查询准备好并且变量被绑定，我们调用它的`exec()`方法来执行它。
- en: 'Once executed, we can extract the data from the query object just as we''ve
    done before:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行，我们可以从查询对象中提取数据，就像以前做过的那样：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s try the same approach to retrieve the coffee''s review data:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试相同的方法来检索咖啡的评论数据：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that we did not pass the database connection object to the `QSqlQuery`
    constructor this time. Since we only have one connection, it's not necessary to
    pass the database connection object to `QSqlQuery`; `QtSQL` will automatically
    use our default connection in any method call that requires a database connection.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次我们没有将数据库连接对象传递给`QSqlQuery`构造函数。由于我们只有一个连接，所以不需要将数据库连接对象传递给`QSqlQuery`；`QtSQL`将自动在任何需要数据库连接的方法调用中使用我们的默认连接。
- en: Also notice that we're using the column names, rather than their numbers, to
    fetch the values from our `reviews` table. This works just as well, and is a much
    friendlier approach, especially in tables with many columns.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们使用列名而不是它们的编号从我们的`reviews`表中获取值。这同样有效，并且是一个更友好的方法，特别是在有许多列的表中。
- en: 'We''ll finish off this method by populating and showing our coffee form:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过填充和显示我们的咖啡表单来完成这个方法：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note that prepared queries are only able to introduce *values* into a query.
    You cannot, for example, prepare a query like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，准备好的查询只能将*值*引入查询中。例如，您不能准备这样的查询：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you want to build queries containing variable tables or column names, you'll
    have to resort to string formatting, unfortunately. In such cases, be aware of
    the potential for SQL injection and take extra precautions to ensure that the
    values being interpolated are what you think they are.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想构建包含可变表或列名称的查询，不幸的是，您将不得不使用字符串格式化。在这种情况下，请注意可能出现SQL注入的潜在风险，并采取额外的预防措施，以确保被插入的值是您认为的值。
- en: Using QSqlQueryModel
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QSqlQueryModel
- en: Populating data into a table widget manually seems like an awful chore; if you
    recall [Chapter 5](61ff4931-02af-474a-996c-5da827e0684f.xhtml), *Creating Data
    Interfaces with Model-View Classes*, Qt provides us with model-view classes that
    do the boring work for us. We could subclass `QAbstractTableModel` and create
    a model that is populated from a SQL query, but fortunately, `QtSql` already provides
    this in the form of `QSqlQueryModel`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 手动将数据填充到表小部件中似乎是一项繁琐的工作；如果您回忆起[第5章](61ff4931-02af-474a-996c-5da827e0684f.xhtml)，*使用模型视图类创建数据接口*，Qt为我们提供了可以为我们完成繁琐工作的模型视图类。我们可以对`QAbstractTableModel`进行子类化，并创建一个从SQL查询中填充的模型，但幸运的是，`QtSql`已经以`QSqlQueryModel`的形式提供了这个功能。
- en: 'As the name suggests, `QSqlQueryModel` is a table model that uses a SQL query
    for its data source. We''ll use one to create our coffee products list, like so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`QSqlQueryModel`是一个使用SQL查询作为数据源的表模型。我们将使用它来创建我们的咖啡产品列表，就像这样：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After creating our model, we set its `query` property to a SQL `SELECT` statement.
    The model's data will be drawn from the table returned by this query.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模型后，我们将其`query`属性设置为SQL `SELECT`语句。模型的数据将从此查询返回的表中获取。
- en: Just as with `QSqlQuery`, we don't need to explicitly pass a database connection
    because there's only one. If you did have multiple database connections active,
    you should pass the one you want to use to `QSqlQueryModel()`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与`QSqlQuery`一样，我们不需要显式传递数据库连接，因为只有一个。如果您有多个活动的数据库连接，您应该将要使用的连接传递给`QSqlQueryModel()`。
- en: 'Once we have the model, we can use it in `QTableView`, like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了模型，我们就可以在`QTableView`中使用它，就像这样：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Just as we did in [Chapter 5](61ff4931-02af-474a-996c-5da827e0684f.xhtml), *Creating
    Data Interfaces with Model-View Classes*, we've created `QTableView` and passed
    the model to its `setModel()` method. Then, we added the table view to the stacked
    widget and set it as the currently visible widget.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[第5章](61ff4931-02af-474a-996c-5da827e0684f.xhtml)中所做的那样，*使用模型视图类创建数据接口*，我们创建了`QTableView`并将模型传递给其`setModel()`方法。然后，我们将表视图添加到堆叠小部件中，并将其设置为当前可见的小部件。
- en: 'By default, the table view will use the column names from the query as the
    header labels. We can override this by using the model''s `setHeaderData()` method,
    like so:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，表视图将使用查询的列名作为标题标签。我们可以通过使用模型的`setHeaderData()`方法来覆盖这一点，就像这样：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Keep in mind that the `QSqlQueryModel` object is in read-only mode, so there
    is no way to set this table view to editable in order to change details about
    our coffee list. We'll look at how to have an editable SQL model in the next section,
    *Using model-view widgets without SQL*. First, though, let's finish our GUI.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`QSqlQueryModel`对象处于只读模式，因此无法将此表视图设置为可编辑，以便更改关于我们咖啡列表的详细信息。我们将在下一节中看看如何使用可编辑的SQL模型，*在没有SQL的情况下使用模型视图小部件*。不过，首先让我们完成我们的GUI。
- en: Finishing the GUI
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成GUI
- en: 'Now that our application has both the list and the form widgets, let''s enable
    some navigation between them. First, create a toolbar button to switch from the
    coffee form to the list:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序既有列表又有表单小部件，让我们在它们之间启用一些导航。首先，创建一个工具栏按钮，用于从咖啡表单切换到列表：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we''ll configure our list so that double-clicking an item will show the
    coffee form with that coffee record in it. Remember that our `MainView.show_coffee()`
    method expects the coffee''s `id` value, but the list widget''s `itemDoubleClicked`
    signal carries the model index of the click. Let''s create a method on `MainView`
    to translate one to the other:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将配置我们的列表，以便双击项目将显示包含该咖啡记录的咖啡表单。请记住，我们的`MainView.show_coffee()`方法需要咖啡的`id`值，但列表小部件的`itemDoubleClicked`信号携带了点击的模型索引。让我们在`MainView`上创建一个方法来将一个转换为另一个：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Since `id` is in column `0` of the model, we retrieve the index of column `0`
    from whatever row was clicked using `siblingAtColumn(0)`. Then we can retrieve
    the `id` value by passing that index to `model().data()`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`id`在模型的列`0`中，我们使用`siblingAtColumn(0)`从被点击的任意行中检索列`0`的索引。然后我们可以通过将该索引传递给`model().data()`来检索`id`值。
- en: 'Now that we have this, let''s add a connection for the `itemDoubleClicked`
    signal:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这个，让我们为`itemDoubleClicked`信号添加一个连接：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: At this point, we have a simple, read-only application for our coffee database.
    We can certainly keep going with the current approach of using SQL queries to
    manage our data, but Qt provides a more elegant approach. We'll explore that approach
    in the next section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们对我们的咖啡数据库有一个简单的只读应用程序。我们当然可以继续使用当前的SQL查询方法来管理我们的数据，但Qt提供了一种更优雅的方法。我们将在下一节中探讨这种方法。
- en: Using model-view widgets without SQL
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在没有SQL的情况下使用模型视图小部件
- en: Having used `QSqlQueryModel` in the last section, you might wonder whether this
    approach can be further generalized to just access tables directly and avoid having
    to write SQL queries altogether. You also might wonder if we can get around the
    read-only limitations of `QSqlQueryModel`. The answer to both questions is *yes*,
    thanks to `QSqlTableModel` and `QSqlRelationalTableModels`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中使用了`QSqlQueryModel`之后，您可能会想知道这种方法是否可以进一步泛化，直接访问表并避免完全编写SQL查询。您可能还想知道我们是否可以避开`QSqlQueryModel`的只读限制。对于这两个问题的答案都是*是*，这要归功于`QSqlTableModel`和`QSqlRelationalTableModels`。
- en: 'To see how these work, let''s back up and start over with our application:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这些是如何工作的，让我们回到应用程序的起点重新开始：
- en: 'Start with a fresh template copy, calling it `coffee_list2.py`. Add the import
    for `QtSql` and the database connection code from the first application. Now let''s
    start building using table models. For simple situations where we want to create
    a model from a single database table, we can use `QSqlTableModel`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个新的模板副本开始，将其命名为`coffee_list2.py`。添加`QtSql`的导入和第一个应用程序中的数据库连接代码。现在让我们开始使用表模型构建。对于简单的情况，我们想要从单个数据库表创建模型，我们可以使用`QSqlTableModel`：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `reviews_model` is now a read-write table model for the `reviews` table.
    Just as we used our CSV table model to edit our CSV file in [Chapter 5](61ff4931-02af-474a-996c-5da827e0684f.xhtml),
    *Creating Data Interfaces with Model-View Classes*, we can use this model to view
    and edit the `reviews` table. For tables that need to look up values from joined
    tables, we can use`QSqlRelationalTableModel`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`reviews_model`现在是`reviews`表的可读/写表模型。就像我们在[第5章](61ff4931-02af-474a-996c-5da827e0684f.xhtml)中使用CSV表模型编辑CSV文件一样，我们可以使用这个模型来查看和编辑`reviews`表。对于需要从连接表中查找值的表，我们可以使用`QSqlRelationalTableModel`：'
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once again, we have a table model that can be used to view and edit the data
    in the SQL table; this time, the `coffees` table. However, the `coffees` table
    has a `roast_id` column that references the `roasts` table. `roast_id` is not
    meaningful to the application user, who would much rather work with the roast''s
    `description` column. To replace `roast_id` with `roasts.description` in our model,
    we can use the `setRelation()` function to join the two tables together, like
    so:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再一次，我们有一个可以用来查看和编辑SQL表中数据的表模型；这次是`coffees`表。但是，`coffees`表有一个引用`roasts`表的`roast_id`列。`roast_id`对应于应用程序用户没有意义，他们更愿意使用烘焙的`description`列。为了在我们的模型中用`roasts.description`替换`roast_id`，我们可以使用`setRelation()`函数将这两个表连接在一起，就像这样：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This method takes two arguments. The first is the column number of the main
    table that we're joining, which we can fetch by name using the model's `fieldIndex()`
    method. The second is a `QSqlRelation` object, which represents a foreign key
    relationship. The arguments it takes are the table name (`roasts`), the related
    column in the joined table (`roasts.id`), and the field to display for this relationship
    (`description`).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接受两个参数。第一个是我们要连接的主表的列号，我们可以使用模型的`fieldIndex()`方法按名称获取。第二个是`QSqlRelation`对象，它表示外键关系。它所需的参数是表名（`roasts`），连接表中的相关列（`roasts.id`），以及此关系的显示字段（`description`）。
- en: The result of setting this relationship is that our table view will use the
    related `description` column from `roasts` in place of the `roast_id` value when
    we join our `coffee_model` to a view.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 设置这种关系的结果是，我们的表视图将使用与`roasts`中的`description`列相关的值，而不是`roast_id`值，当我们将`coffee_model`连接到视图时。
- en: 'Before we can join the model to the view, there''s one more step we need to
    take:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以将模型连接到视图之前，我们需要再走一步：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Whenever we configure or reconfigure a `QSqlTableModel` or `QSqlRelationalTableModel`,
    we must call its `select()` method. This causes the model to generate and run
    a SQL query to refresh its data and make it available to views.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们配置或重新配置`QSqlTableModel`或`QSqlRelationalTableModel`时，我们必须调用它的`select()`方法。这会导致模型生成并运行SQL查询，以刷新其数据并使其可用于视图。
- en: 'Now that our model is ready, we can try it in a view:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的模型准备好了，我们可以在视图中尝试一下：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Running the program at this point, you should get something like this:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上运行程序，您应该会得到类似这样的东西：
- en: '![](assets/85eb90e0-609f-4e31-9fff-1299a9c8b9b1.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/85eb90e0-609f-4e31-9fff-1299a9c8b9b1.png)'
- en: Notice that, thanks to our relational table model, we have a `description` column
    containing the description of the roast in place of the `roast_id` column. Just
    what we wanted.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们的关系表模型，我们有一个包含烘焙描述的`description`列，而不是`roast_id`列。正是我们想要的。
- en: Also note that, at this point, you can view and edit any of the values in the
    coffee list. `QSqlRelationalTableModel` is read/write by default, and we do not
    need to make any adjustments to the view to make it editable. However, it could
    use some improvement.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在这一点上，您可以查看和编辑咖啡列表中的任何值。`QSqlRelationalTableModel`默认是可读/写的，我们不需要对视图进行任何调整来使其可编辑。但是，它可能需要一些改进。
- en: Delegates and data mapping
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理和数据映射
- en: While we can edit the list, we can't yet add or remove items in the list; let's
    add that capability before we move on to the coffee form itself.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以编辑列表，但我们还不能添加或删除列表中的项目；在继续进行咖啡表单之前，让我们添加这个功能。
- en: 'Start by creating some toolbar actions pointing to `MainView` methods:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一些指向`MainView`方法的工具栏操作：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we''ll write the `MainView` methods for those actions:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为这些操作编写`MainView`方法：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To delete a row from the model, we can call its `removeRow()` method, passing
    in the row number desired. This, we can obtain from the `selectedIndexes` property.
    To add a row, we call the model's `insertRows()` method. This code should be familiar,
    from [Chapter 5](61ff4931-02af-474a-996c-5da827e0684f.xhtml), *Creating Data Interfaces
    with Model-View Classes*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要从模型中删除一行，我们可以调用其`removeRow()`方法，传入所需的行号。这可以从`selectedIndexes`属性中获取。要添加一行，我们调用模型的`insertRows()`方法。这段代码应该很熟悉，来自[第5章](61ff4931-02af-474a-996c-5da827e0684f.xhtml)，*使用模型-视图类创建数据接口*。
- en: Now, if you run the program and try to add a row, notice that you get what is
    essentially a `QLineEdit` in each cell for entering the data. This is fine for
    text fields such as coffee brand and product name, but for the roast description,
    it makes more sense to have something that constrains us to the proper values,
    such as a combo box.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您运行程序并尝试添加一行，注意您基本上会得到一个`QLineEdit`，用于在每个单元格中输入数据。这对于咖啡品牌和产品名称等文本字段来说是可以的，但对于烘焙描述，更合理的是使用一些限制我们使用正确值的东西，比如下拉框。
- en: In Qt's model-view system, the object that decides what widget to draw for a
    piece of data is called a **delegate**. The delegate is a property of the view,
    and by setting our own delegate object we can control how data is presented for
    viewing or editing.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt的模型-视图系统中，决定为数据绘制什么小部件的对象称为**代理**。代理是视图的属性，通过设置我们自己的代理对象，我们可以控制数据的呈现方式以进行查看或编辑。
- en: 'In the case of a view backed by `QSqlRelationalTableModel`, we can take advantage
    of a ready-made delegate called `QSqlRelationalDelegate`, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在由`QSqlRelationalTableModel`支持的视图的情况下，我们可以利用一个名为`QSqlRelationalDelegate`的现成委托，如下所示：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`QSqlRelationalDelegate` automatically provides a combo box for any field for
    which a `QSqlRelation` has been set. With this simple change, you should find
    that the `description` column now presents you with a combo box containing the
    available description values from the `roasts` table. Much better!'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSqlRelationalDelegate`自动为已设置`QSqlRelation`的任何字段提供组合框。通过这个简单的更改，您应该发现`description`列现在呈现为一个组合框，其中包含来自`roasts`表的可用描述值。好多了！'
- en: Data mapping
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据映射
- en: Now that our coffee list is in good shape, it's time to deal with the coffee
    form, which will allow us to display and edit the details of individual products
    and their reviews
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的咖啡列表已经很完善了，是时候处理咖啡表单了，这将允许我们显示和编辑单个产品及其评论的详细信息
- en: 'Let''s start with the GUI code for the coffee details part of the form:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从表单的咖啡详情部分的GUI代码开始：
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This section of the form is the exact same information that we displayed in
    the coffee list, except now we're displaying just a single record, using a series
    of distinct widgets. Connecting our `coffees` table model to a view was straightforward,
    but how can we connect a model to a form like this? One answer is with a `QDataWidgetMapper`
    object.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 表单的这一部分是我们在咖啡列表中显示的完全相同的信息，只是现在我们使用一系列不同的小部件来显示单个记录。将我们的`coffees`表模型连接到视图是直接的，但是我们如何将模型连接到这样的表单呢？一个答案是使用`QDataWidgetMapper`对象。
- en: 'The purpose of `QDataWidgetMapper` is to map fields from a model to widgets
    in a form. To see how it works, let''s add one to `CoffeeForm`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`QDataWidgetMapper`的目的是将模型中的字段映射到表单中的小部件。为了了解它是如何工作的，让我们将一个添加到`CoffeeForm`中：'
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The mapper sits between the model and the form's fields, translating the columns
    between them. In order to ensure that data is written properly from the form widgets
    to the relational fields in the model, we also need to set an `itemDelegate` of
    the proper type, in this case, `QSqlRelationalDelegate`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 映射器位于模型和表单字段之间，将它们之间的列进行转换。为了确保数据从表单小部件正确写入到模型中的关系字段，我们还需要设置适当类型的`itemDelegate`，在这种情况下是`QSqlRelationalDelegate`。
- en: 'Now that we have a mapper, we need to define the field mappings using the `addMapping`
    method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了映射器，我们需要使用`addMapping`方法定义字段映射：
- en: '[PRE50]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `addMapping()` method takes two arguments: a widget and a model column
    number. We''re using the model''s `fieldIndex()` method to retrieve these column
    numbers by name, but you could also just use integers here.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`addMapping()`方法接受两个参数：一个小部件和一个模型列编号。我们使用模型的`fieldIndex()`方法通过名称检索这些列编号，但是您也可以在这里直接使用整数。'
- en: 'Before we can use our combo box, we need to populate it with options. To do
    this, we need to retrieve the `roasts` model from our relational model and pass
    it to the combo box:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以使用我们的组合框之前，我们需要用选项填充它。为此，我们需要从我们的关系模型中检索`roasts`模型，并将其传递给组合框：
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `relationalModel()` method can be used to retrieve an individual table model
    back from our `coffees_model` object by passing in the field number. Notice we
    retrieve the field number by asking for the field index of `description`, not
    `roast_id`. In our relational model, `roast_id` has been replaced with `description`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`relationalModel()`方法可用于通过传递字段编号从我们的`coffees_model`对象中检索单个表模型。请注意，我们通过请求`description`的字段索引而不是`roast_id`来检索字段编号。在我们的关系模型中，`roast_id`已被替换为`description`。'
- en: While the coffee list `QTableView` can display all records at once, our `CoffeeForm`
    is designed to show only one record at a time. For this reason, `QDataWidgetMapper`
    has the concept of a *current record* and will populate the widgets only with
    the data of the current record.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然咖啡列表`QTableView`可以同时显示所有记录，但是我们的`CoffeeForm`设计为一次只显示一条记录。因此，`QDataWidgetMapper`具有*当前记录*的概念，并且只会使用当前记录的数据填充小部件。
- en: 'In order to display data in our form, then, we need to control the record that
    the mapper is pointed to. The `QDataWidgetMapper` class has five methods to navigate
    through the table of records:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了在我们的表单中显示数据，我们需要控制映射器指向的记录。`QDataWidgetMapper`类有五种方法来浏览记录表：
- en: '| Method | Description |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `toFirst()` | Go to the first record in the table. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `toFirst()` | 转到表中的第一条记录。 |'
- en: '| `toLast()` | Go to the last record in the table. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `toLast()` | 转到表中的最后一条记录。 |'
- en: '| `toNext()` | Advance to the next record in the table. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `toNext()` | 转到表中的下一条记录。 |'
- en: '| `toPrevious()` | Go back to the previous record. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `toPrevious()` | 返回到上一个记录。 |'
- en: '| `setCurrentIndex()` | Go to a specific row number. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `setCurrentIndex()` | 转到特定的行号。 |'
- en: 'Since our user is selecting an arbitrary coffee from the list to navigate to,
    we are going to use the last method, `setCurrentIndex()`. We''ll use this in our
    `show_coffee()` method, like so:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的用户正在选择列表中的任意咖啡进行导航，我们将使用最后一个方法`setCurrentIndex()`。我们将在我们的`show_coffee()`方法中使用它，如下所示：
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`setCurrentIndex()` takes a single integer value that corresponds to the row
    number in the model. Note that this is not the same as the coffee''s `id` value,
    which we used in the previous version of the application. We''re working strictly
    with model index values at this point.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`setCurrentIndex()`接受一个与模型中的行号对应的整数值。请注意，这与我们在应用程序的先前版本中使用的咖啡`id`值不同。在这一点上，我们严格使用模型索引值。'
- en: 'Now that we have our working `CoffeeForm`, let''s create one back in `MainView`
    and connect it to our coffee list''s signals:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了工作中的`CoffeeForm`，让我们在`MainView`中创建一个，并将其连接到我们咖啡列表的信号：
- en: '[PRE53]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Since we're using indexes instead of row numbers, we can just connect our `doubleClicked`
    signal directly to the form's `show_coffee()` method. We'll also connect it to
    a lambda function to change the current widget to the form.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用索引而不是行号，我们可以直接将我们的`doubleClicked`信号连接到表单的`show_coffee()`方法。我们还将它连接到一个lambda函数，以将当前小部件更改为表单。
- en: 'While we''re here, let''s go ahead and create a toolbar action to return to
    the list:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，让我们继续创建一个工具栏操作来返回到列表：
- en: '[PRE54]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The associated callback looks like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的回调看起来是这样的：
- en: '[PRE55]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: To accommodate possible changes to the data that may have happened while editing
    in `CoffeeForm`, we'll call `resizeColumnsToContents()` and `resizeRowsToContents()`.
    Then, we simply set the stack widget's current widget to `coffee_list`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应在`CoffeeForm`中编辑时可能发生的数据可能的更改，我们将调用`resizeColumnsToContents()`和`resizeRowsToContents()`。然后，我们只需将堆栈小部件的当前小部件设置为`coffee_list`。
- en: Filtering data
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤数据
- en: 'The last thing we need to take care of in this application is the review section
    of the coffee form:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们需要处理的最后一件事是咖啡表单的评论部分：
- en: 'The reviews model, remember, is `QSqlTableModel`, which we pass into the `CoffeeForm`
    constructor. We can easily bind it to `QTableView`, like this:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，评论模型是`QSqlTableModel`，我们将其传递给`CoffeeForm`构造函数。我们可以很容易地将它绑定到`QTableView`，就像这样：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This adds a table of reviews to our form. Before moving on, let''s take care
    of some cosmetic issues with the view:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这在我们的表单中添加了一个评论表。在继续之前，让我们解决一些视图的外观问题：
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The first two columns of the table are the `id` and `coffee_id`, both of which
    are implementation details we don't need to display for the user. The last line
    of code causes the fourth field (`review`) to expand to the right-hand edge of
    the widget.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的前两列是`id`和`coffee_id`，这两个都是我们不需要为用户显示的实现细节。代码的最后一行导致第四个字段（`review`）扩展到小部件的右边缘。
- en: 'If you run this, you''ll see we have a slight problem here: we don''t want
    to see *all* the reviews in the table when we view a coffee''s record. We only
    want to display the ones that are associated with the current coffee product.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个，你会看到我们这里有一个小问题：当我们查看咖啡的记录时，我们不想看到*所有*的评论在表中。我们只想显示与当前咖啡产品相关的评论。
- en: 'We can do this by applying a **filter** to the table model. In the `show_coffee()`
    method, we''ll add the following code:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过对表模型应用**过滤器**来实现这一点。在`show_coffee()`方法中，我们将添加以下代码：
- en: '[PRE58]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We begin by extracting the selected coffee's `id` number from our coffee model.
    This may not be the same as the row number, which is why we are consulting the
    value from column 0 of the selected row. We're going to save it as an instance
    variable because we may need it later.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从我们的咖啡模型中提取选定的咖啡的`id`号码。这可能与行号不同，这就是为什么我们要查看所选行的第0列的值。我们将它保存为一个实例变量，因为以后可能会用到它。
- en: Next, we call the review model's `setFilter()` method. This method takes a string
    that it will quite literally append to a `WHERE` clause in the query used to select
    data from the SQL table. Likewise, `setSort()` will set the `ORDER BY` clause.
    In this case, we're sorting by the review date, with the most recent first.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们调用评论模型的`setFilter()`方法。这个方法接受一个字符串，它会被直接附加到用于从SQL表中选择数据的查询的`WHERE`子句中。同样，`setSort()`将设置`ORDER
    BY`子句。在这种情况下，我们按评论日期排序，最近的排在前面。
- en: Unfortunately, there is no way to use a bound variable in `setFilter()`, so
    if you want to insert a value, you must use string formatting. As you have learned,
    this opens you up to SQL injection vulnerabilities, so be *very* careful about
    how you insert data. In this example, we've cast `coffee_id` to an `int` to make
    sure it's not SQL injection code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`setFilter()`中没有办法使用绑定变量，所以如果你想插入一个值，你必须使用字符串格式化。正如你所学到的，这会使你容易受到SQL注入漏洞的影响，所以在插入数据时要非常小心。在这个例子中，我们将`coffee_id`转换为`int`，以确保它不是SQL注入代码。
- en: After setting our filter and sort properties, we need to call `select()` to
    apply them. Then, we can resize our rows and columns to the new content. Now,
    the form should only show reviews for the currently selected coffee.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了过滤和排序属性后，我们需要调用`select()`来应用它们。然后，我们可以调整行和列以适应新的内容。现在，表单应该只显示当前选定咖啡的评论。
- en: Using a custom delegate
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义委托
- en: 'The reviews table contains a column with a date; while we can certainly edit
    dates using a regular `QLineEdit`, it would be nicer if we could use the more
    appropriate `QDateEdit` widget. Unlike the situation with our coffee list view,
    Qt doesn''t have a ready-made delegate that will do this for us. Fortunately,
    we can easily create our own delegate:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 评论表包含一个带有日期的列；虽然我们可以使用常规的`QLineEdit`编辑日期，但如果我们能使用更合适的`QDateEdit`小部件会更好。与我们的咖啡列表视图不同，Qt没有一个现成的委托可以为我们做到这一点。幸运的是，我们可以很容易地创建我们自己的委托：
- en: 'Above the `CoffeeForm` class, let''s define a new delegate class:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CoffeeForm`类的上面，让我们定义一个新的委托类：
- en: '[PRE59]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The delegate class inherits `QStyledItemDelegate`, and its `createEditor()`
    method is responsible for returning the widget that will be used for editing the
    data. In this case, we simply need to create `QDateEdit` and return it. We can
    configure the widget any way that we deem appropriate; for instance, we've enabled
    the calendar popup here.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 委托类继承自`QStyledItemDelegate`，它的`createEditor()`方法负责返回将用于编辑数据的小部件。在这种情况下，我们只需要创建`QDateEdit`并返回它。我们可以根据需要配置小部件；例如，在这里我们启用了日历弹出窗口。
- en: Note that we're passing along the `parent` argument—this is critical! If you
    don't explicitly pass the parent widget, your delegate widget will pop up in its
    own top-level window.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在传递`parent`参数——这很关键！如果你不明确传递父小部件，你的委托小部件将弹出在它自己的顶层窗口中。
- en: 'For our purposes in the reviews table, this is all that we need to change.
    In more complex scenarios, there are a few other methods you might need to override:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在评论表中的目的，这就是我们需要改变的全部内容。在更复杂的场景中，可能需要覆盖一些其他方法：
- en: The `setModelData()` method is responsible for extracting data from the widget
    and passing it to the model. You might override this if the raw data from the
    widget needs to be converted or prepped in some way before being updated in the
    model.
  id: totrans-281
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setModelData()`方法负责从小部件中提取数据并将其传递给模型。如果需要在模型中更新之前将小部件的原始数据转换或准备好，你可能需要覆盖这个方法。'
- en: The `setEditorData()` method is responsible for retrieving data from the model
    and writing it to the widget. You might override this if the model data isn't
    in the right format for the widget to understand.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setEditorData()`方法负责从模型中检索数据并将其写入小部件。如果模型数据不适合小部件理解，你可能需要重写这个方法。'
- en: The `paint()` method draws the editing widget to the screen. You might override
    this to build a custom widget or to change the appearance of the widget depending
    on the data. If you override this method, you might also need to override `sizeHint()`
    and `updateEditorGeometry()` to make sure enough space is provided for your custom
    widget.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paint()`方法将编辑小部件绘制到屏幕上。你可以重写这个方法来构建一个自定义小部件，或者根据数据的不同来改变小部件的外观。如果你重写了这个方法，你可能还需要重写`sizeHint()`和`updateEditorGeometry()`来确保为你的自定义小部件提供足够的空间。'
- en: 'Once we''ve created our custom delegate class, we need to tell our table view
    to use it:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们创建了自定义委托类，我们需要告诉我们的表视图使用它：
- en: '[PRE60]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this case, we've created an instance of `DateDelegate` and told the `reviews`
    view to use it for the `review_date` column. Now, when you edit the review date,
    you'll get `QDateEdit` with a calendar popup.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建了一个`DateDelegate`的实例，并告诉`reviews`视图在`review_date`列上使用它。现在，当你编辑评论日期时，你会得到一个带有日历弹出窗口的`QDateEdit`。
- en: Inserting custom rows in a table view
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在表视图中插入自定义行
- en: 'The last feature we want to implement is adding and deleting rows in our review
    table:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要实现的最后一个功能是在我们的评论表中添加和删除行：
- en: 'We''ll start with some buttons:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从一些按钮开始：
- en: '[PRE61]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The callback for deleting rows is straightforward enough:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除行的回调足够简单：
- en: '[PRE62]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Just as we did with `MainView.coffee_list`, we just iterate through the selected
    indexes and remove them by row number.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在`MainView.coffee_list`中所做的一样，我们只需遍历所选的索引并按行号删除它们。
- en: 'Adding new rows presents a problem: we can add rows, but we need to make sure
    they''re set to use the currently selected `coffee_id`. To do this, we''ll use
    a `QSqlRecord` object. This object represents a single row from `QSqlTableModel`,
    and can be created using the model''s `record()` method. Once we have an empty
    `record` object, we can populate it with values and write it back to the model.
    Our callback starts like this:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新行会出现一个问题：我们可以添加行，但我们需要确保它们设置为使用当前选定的`coffee_id`。为此，我们将使用`QSqlRecord`对象。这个对象代表了来自`QSqlTableModel`的单行，并且可以使用模型的`record()`方法创建。一旦我们有了一个空的`record`对象，我们就可以用值填充它，并将其写回模型。我们的回调从这里开始：
- en: '[PRE63]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To begin with, we extract an empty record from the `reviews_model` by calling
    `record()`. It's important to do this from the model, as it will be prepopulated
    with all the model's fields. Next, we need to set the values. By default, all
    fields are set to `None` (SQL `NULL` ), so we'll need to override this if we want
    a default value or if our fields have a `NOT NULL` constraint.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过调用`record()`从`reviews_model`中提取一个空记录。这样做很重要，因为它将被预先填充所有模型的字段。接下来，我们需要设置这些值。默认情况下，所有字段都设置为`None`（SQL
    `NULL`），所以如果我们想要默认值或者我们的字段有`NOT NULL`约束，我们需要覆盖这个设置。
- en: In this case, we're setting `coffee_id` to the currently shown coffee ID (good
    thing we saved that as an instance variable, eh?) and `review_date` to the current
    date. We're also setting `reviewer` and `review` to empty strings because they
    have `NOT NULL` constraints. Note that we're leaving `id` as `None`, because inserting
    a `NULL` on a field will cause it to use its default value (which, in this case,
    will be an auto-incremented integer).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将`coffee_id`设置为当前显示的咖啡ID（我们保存为实例变量，很好对吧？），并将`review_date`设置为当前日期。我们还将`reviewer`和`review`设置为空字符串，因为它们有`NOT
    NULL`约束。请注意，我们将`id`保留为`None`，因为在字段上插入`NULL`将导致它使用其默认值（在这种情况下，将是自动递增的整数）。
- en: 'After setting up the `dict`, we iterate through it and write the values to
    the record''s fields. Now we need to insert this prepared record into the model:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置好`dict`后，我们遍历它并将值写入记录的字段。现在我们需要将这个准备好的记录插入模型：
- en: '[PRE64]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`QSqlTableModel.insertRecord()` takes the index of insertion (`-1` means the
    end of the table) and the record to insert, and returns a simple Boolean value
    indicating whether insertion was successful. If it failed, we can query the model
    for the error text by calling `lastError().text()`.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`QSqlTableModel.insertRecord()`接受插入的索引（`-1`表示表的末尾）和要插入的记录，并返回一个简单的布尔值，指示插入是否成功。如果失败，我们可以通过调用`lastError().text()`来查询模型的错误文本。'
- en: Finally, we call `select()` on the model. This will repopulate the view with
    our inserted record and allow us to edit the remaining fields.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在模型上调用`select()`。这将用我们插入的记录重新填充视图，并允许我们编辑剩下的字段。
- en: At this point, our application is fully functional. Take some time to insert
    new records and reviews, edit records, and delete them.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序已经完全功能。花一些时间插入新的记录和评论，编辑记录，并删除它们。
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about SQL databases and how to use them with PyQt.
    You learned the basics of creating a relational database with SQL, how to connect
    to the database with the `QSqlDatabase` class, and how to execute queries on the
    database. You also learned how to build elegant database applications without
    having to write SQL by using the SQL model-view classes available in `QtSql`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了关于SQL数据库以及如何在PyQt中使用它们。你学习了使用SQL创建关系数据库的基础知识，如何使用`QSqlDatabase`类连接数据库，以及如何在数据库上执行查询。你还学习了如何通过使用`QtSql`中可用的SQL模型视图类来构建优雅的数据库应用程序，而无需编写SQL。
- en: In the next chapter, you're going to learn how to create asynchronous applications
    that can deal with slow workloads without locking up your application. You'll
    learn the effective use of the `QTimer` class, as well as how to safely utilize
    `QThread`. We'll also cover the use of `QTheadPool` to enable high-concurrency
    processing.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何创建异步应用程序，可以处理缓慢的工作负载而不会锁定你的应用程序。你将学习如何有效地使用`QTimer`类，以及如何安全地利用`QThread`。我们还将介绍使用`QTheadPool`来实现高并发处理。
- en: Questions
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge of this chapter:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些问题来测试你对本章的了解：
- en: Compose a SQL `CREATE` statement that builds a table to hold television schedule
    listings. Make sure it has fields for date, time, channel, and program name. Also
    make sure it has a primary key and constraints to prevent nonsensical data (such
    as two shows at the same time on the same channel, or a show with no time or date).
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个SQL“CREATE”语句，用于创建一个用于保存电视节目表的表。确保它有日期、时间、频道和节目名称的字段。还要确保它有主键和约束，以防止无意义的数据（例如同一频道上同时播放两个节目，或者没有时间或日期的节目）。
- en: The following SQL query is returning a syntax error; can you fix it?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下SQL查询返回语法错误；你能修复吗？
- en: '[PRE65]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The following SQL query doesn't work correctly; can you fix it?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下SQL查询不正确；你能修复吗？
- en: '[PRE66]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The documentation for `QSqlDatabase` can be found at [https://doc.qt.io/qt-5/qsqldatabase.html](https://doc.qt.io/qt-5/qsqldatabase.html).
    Read up on how you can work with multiple database connections; for example, a
    read-only and read/write connection to the same database. How would you create
    two connections and make specific queries to each?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “QSqlDatabase”的文档可以在[https://doc.qt.io/qt-5/qsqldatabase.html](https://doc.qt.io/qt-5/qsqldatabase.html)找到。了解如何使用多个数据库连接；例如，对同一数据库创建一个只读连接和一个读写连接。你将如何创建两个连接并对每个连接进行特定查询？
- en: 'Using `QSqlQuery`, write code to safely insert the data in the `dict` object
    into the `coffees` table:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“QSqlQuery”，编写代码将“dict”对象中的数据安全地插入到“coffees”表中：
- en: '[PRE67]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You''ve created a `QSqlTableModel` object and attached it to a `QTableView`.
    You know there is data in the table, but it is not showing in the view. Look at
    the code and decide what is wrong:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你创建了一个“QSqlTableModel”对象并将其附加到“QTableView”。你知道表中有数据，但在视图中没有显示。查看代码并决定问题出在哪里：
- en: '[PRE68]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following is a callback attached to the `textChanged` signal of `QLineEdit`.
    Explain why this is not a good idea:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是附加到“QLineEdit”的“textChanged”信号的回调函数。解释为什么这不是一个好主意：
- en: '[PRE69]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You decide you'd rather have colors than names in the `roasts` combo boxes in
    your coffee list. What changes would you need to make to accomplish this?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你决定在咖啡列表的“烘焙”组合框中使用颜色而不是名称。你需要做哪些改变来实现这一点？
- en: Further reading
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Check out these resources for more information:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下资源以获取更多信息：
- en: A guide to the SQL language used in SQLite can be found at [https://sqlite.org/lang.html](https://sqlite.org/lang.html)
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite中使用的SQL语言指南可以在[https://sqlite.org/lang.html](https://sqlite.org/lang.html)找到
- en: An overview of the `QtSQL` module and its use can be found at [https://doc.qt.io/qt-5/qtsql-index.html](https://doc.qt.io/qt-5/qtsql-index.html)
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://doc.qt.io/qt-5/qtsql-index.html](https://doc.qt.io/qt-5/qtsql-index.html)找到“QtSQL”模块及其使用的概述
