- en: Cryptography and Steganography
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学和隐写术
- en: This chapter covers the main modules we have in python for encrypting and decrypting
    information, such as pycrypto and cryptography. Also we cover steganography techniques
    and how to hide information in images with the `stepic` module.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了Python中用于加密和解密信息的主要模块，如pycrypto和cryptography。我们还涵盖了隐写术技术以及如何使用`stepic`模块在图像中隐藏信息。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The `pycrypto` module for encrypting and decrypting information
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于加密和解密信息的`pycrypto`模块
- en: The `cryptography` module for encrypting and decrypting information
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于加密和解密信息的`cryptography`模块
- en: The main steganography techniques for hiding information in images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图像中隐藏信息的主要隐写术技术
- en: How to hide information in images with the `stepic` module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`stepic`模块在图像中隐藏信息
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Examples and source code for this chapter are available in the GitHub repository
    in the `chapter13` folder: [https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security](https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例和源代码可在GitHub存储库的`chapter13`文件夹中找到：[https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security](https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security)。
- en: You will need to install python distribution in your local machine with at least
    4 GB memory.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在本地计算机上安装至少4GB内存的Python发行版。
- en: Encrypting and decrypting information with pycrypto
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pycrypto加密和解密信息
- en: In this section, we review cryptographic algorithms and the `pycrypto` module
    for encrypting and decrypting data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾加密算法和用于加密和解密数据的`pycrypto`模块。
- en: Introduction to cryptography
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学简介
- en: Cryptography can be defined as the practice of hiding information, and includes
    techniques for message-integrity checking, sender/receiver identity authentication,
    and digital signatures.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学可以定义为隐藏信息的实践，包括消息完整性检查、发送者/接收者身份验证和数字签名等技术。
- en: 'The following are the four most common types of cryptography algorithms:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是四种最常见的密码算法：
- en: '**Hash functions:** Also known as one-way encryption, these have no key. A
    `hash` function outputs a fixed-length hash value for plaintext input, and in
    theory it''s impossible to recover the length or content of the plaintext. One
    way `cryptographic` functions are used in websites to store passwords in a manner
    that they cannot be retrieved.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希函数：** 也称为单向加密，它们没有密钥。`hash`函数为明文输入输出固定长度的哈希值，理论上不可能恢复明文的长度或内容。单向`加密`函数在网站中用于以一种无法检索的方式存储密码。'
- en: '**Keyed hash functions:** Used to build message-authentication codes (MACs);
    MACs are intended to prevent brute-force attacks. So, they are intentionally designed
    to be slow.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带密钥的哈希函数：** 用于构建消息认证码（MAC）；MAC旨在防止暴力攻击。因此，它们被故意设计成慢速的。'
- en: '**Symmetric encryption:** Output a ciphertext for some text input using a variable
    key, and we can decrypt the ciphertext using the same key. Algorithms that use
    the same key for both encryption and decryption are known as symmetric key algorithms.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对称加密：** 使用可变密钥对一些文本输入输出密文，我们可以使用相同的密钥解密密文。使用相同密钥进行加密和解密的算法称为对称密钥算法。'
- en: '**Public key algorithms:** For public key algorithms, we have two different
    keys: one for encryption and the other for decryption. This practice uses a pair
    of keys: one to encrypt and another to decrypt. Users of this technology publish
    their public key, while keeping their private key secret. This enables anyone
    to send them a message encrypted with the public key, which only the holder of
    the private key can decrypt. These algorithms are designed so that finding out
    the private key is extremely difficult, even if the corresponding public key is
    known to an attacker.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公钥算法：** 对于公钥算法，我们有两个不同的密钥：一个用于加密，另一个用于解密。这种做法使用一对密钥：一个用于加密，另一个用于解密。这种技术的用户发布他们的公钥，同时保持他们的私钥保密。这使得任何人都可以使用公钥发送加密的消息，只有私钥的持有者才能解密。这些算法被设计成即使攻击者知道相应的公钥，也极其困难找到私钥。'
- en: For example, for hash functions, Python provides some modules, such as `hashlib`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于哈希函数，Python提供了一些模块，比如`hashlib`。
- en: The following script returns the `md5` checksum of the file.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本返回文件的`md5`校验和。
- en: 'You can find the following code in the `md5.py` file inside the `hashlib` folder:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`hashlib`文件夹内的`md5.py`文件中找到以下代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the previous script is:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个脚本的输出是：
- en: '`The MD5 checksum is 8eec2037fe92612b9a141a45b60bec26`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`MD5校验和为8eec2037fe92612b9a141a45b60bec26`'
- en: Introduction to pycrypto
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pycrypto简介
- en: When it comes to encrypting information with Python, we have some options, but
    one of the most reliable is the PyCrypto cryptographic library, which supports
    functions for block-encryption, flow-encryption, and hash-calculation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Python加密信息时，我们有一些选项，但其中最可靠的之一是PyCrypto加密库，它支持分组加密、流加密和哈希计算的功能。
- en: The `PyCrypto` module provides all needed functions for implementing strong
    cryptography in a Python program, including both hash functions and encryption
    algorithms.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`PyCrypto`模块提供了在Python程序中实现强加密所需的所有函数，包括哈希函数和加密算法。'
- en: 'For example, the block ciphers supported by `pycrypto` are:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`pycrypto`支持的分组密码有：
- en: AES
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AES
- en: ARC2
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARC2
- en: Blowfish
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blowfish
- en: CAST
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CAST
- en: DES
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DES
- en: DES3
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DES3
- en: IDEA
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDEA
- en: RC5
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RC5
- en: In general, all these ciphers are used in the same way.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，所有这些密码都是以相同的方式使用的。
- en: 'We can use the `Crypto.Cipher` package to import a specific cipher type:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Crypto.Cipher`包来导入特定的密码类型：
- en: '`from Crypto.Cipher import [Chiper_Type]`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`from Crypto.Cipher import [Chiper_Type]`'
- en: 'We can use the new method constructor to initialize the cipher:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用新的方法构造函数来初始化密码：
- en: '`new ([key], [mode], [Vector IV])`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`new ([key], [mode], [Vector IV])`'
- en: With this method, only the key is mandatory, and we must take into account whether
    the type of encryption requires that it has a specific size. The possible modes
    are `MODE_ECB`, `MODE_CBC`, `MODE_CFB`, `MODE_PGP`, `MODE_OFB`, `MODE_CTR`, and
    `MODE_OPENPGP`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，只有密钥是必需的，我们必须考虑加密类型是否需要具有特定大小。可能的模式有`MODE_ECB`、`MODE_CBC`、`MODE_CFB`、`MODE_PGP`、`MODE_OFB`、`MODE_CTR`和`MODE_OPENPGP`。
- en: If the `MODE_CBC` or `MODE_CFB` modes are used, the third parameter (Vector
    IV) must be initialized, which allows an initial value to be given to the cipher.
    Some ciphers may have optional parameters, such as AES, which can specify the
    block and key size with the `block_size` and `key_size` parameters.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`MODE_CBC`或`MODE_CFB`模式，则必须初始化第三个参数（向量IV），这允许给密码提供初始值。一些密码可能有可选参数，例如AES，可以使用`block_size`和`key_size`参数指定块和密钥大小。
- en: 'In the same way we have seen with hashlib, hash Functions also are supported
    by `pycrypto`. The use of general hash functions with `pycrypto` is similar:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与hashlib一样，`pycrypto`也支持哈希函数。使用`pycrypto`的通用哈希函数类似：
- en: We can use the **`Crypto.Hash`** package to import a specific hash type:`from
    Crypto.Hash import [Hash Type]`
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用**`Crypto.Hash`**包来导入特定的哈希类型：`from Crypto.Hash import [Hash Type]`
- en: We can use the update method to set the data we need obtain the hash:`update('data')`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用update方法设置我们需要获取哈希的数据：`update('data')`
- en: 'We can use the `hexdigest()` method to generate the hash: `hexdigest()`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`hexdigest()`方法生成哈希：`hexdigest()`
- en: The following is the same example that we saw for obtaining the checksum of
    a file, in this case we are using `pycrypt` instead of `hashlib`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在获取文件的校验和时看到的相同示例，这次我们使用`pycrypt`而不是`hashlib`。
- en: 'You can find the following code in the `hash.py` file inside the `pycrypto`
    folder:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pycrypto`文件夹内的`hash.py`文件中可以找到以下代码：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To encrypt and decrypt data, we can use the `**encrypt**` and `**decrypt**`
    functions:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要加密和解密数据，我们可以使用`**encrypt**`和`**decrypt**`函数：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Encrypting and decrypting with the DES algorithm
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DES算法进行加密和解密
- en: DES  is a block cipher, which means that the text to be encrypted is a multiple
    of eight, so I added spaces at the end of the text. When I deciphered it, I removed
    them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: DES是一种分组密码，这意味着要加密的文本是8的倍数，因此我在文本末尾添加了空格。当我解密它时，我将它们删除了。
- en: The following script encrypts a user and a password and, finally, simulating
    that it is the server that has received these credentials, decrypts and displays
    this data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本加密用户和密码，并最后，模拟服务器已收到这些凭据，解密并显示这些数据。
- en: 'You can find the following code in the `Encrypt_decrypt_DES.py` file inside
    the `pycrypto` folder:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pycrypto`文件夹内的`Encrypt_decrypt_DES.py`文件中可以找到以下代码：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The program encrypts the data using DES, so the first thing it does is import
    the `DES` module and create an encoder with the following instruction:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序使用DES加密数据，因此它首先导入`DES`模块并使用以下指令创建编码器：
- en: '`cipher = DES.new(''mycipher'')`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`cipher = DES.new(''mycipher'')`'
- en: The ‘`mycipher`’ parameter value is the encryption key. Once the cipher is created,
    as you can see in the sample program, encryption and decryption is quite simple.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ‘`mycipher`’参数值是加密密钥。一旦创建了密码，就像在示例程序中看到的那样，加密和解密非常简单。
- en: Encrypting and decrypting with the AES algorithm
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AES算法进行加密和解密
- en: AES encryption needs a strong key. The stronger the key, the stronger your encryption. Our
    AES Key needs to be either 16, 24, or 32 bytes long and our **Initialization Vector**
    needs to be **16 Bytes** long. That will be generated using the `random` and `string`
    modules.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: AES加密需要一个强大的密钥。密钥越强大，加密就越强大。我们的AES密钥需要是16、24或32字节长，我们的**初始化向量**需要是**16字节**长。这将使用`random`和`string`模块生成。
- en: To use an encryption algorithm such as AES, we can import it from the **`Crypto.Cipher.AES` **package.
    As the PyCrypto block-level encryption API is very low level, it only accepts
    16-, 24-, or 32-bytes-long keys for AES-128, AES-196, and AES-256, respectively.
    The longer the key, the stronger the encryption.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用AES等加密算法，我们可以从**`Crypto.Cipher.AES`**包中导入它。由于PyCrypto块级加密API非常低级，因此对于AES-128、AES-196和AES-256，它只接受16、24或32字节长的密钥。密钥越长，加密就越强大。
- en: Also, for AES encryption using pycrypto, you need to ensure that the data is
    a multiple of 16 bytes in length. Pad the buffer if it is not and include the
    size of the data at the beginning of the output, so the receiver can decrypt properly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，对于使用pycrypto进行AES加密，需要确保数据的长度是16字节的倍数。如果不是，则填充缓冲区，并在输出的开头包含数据的大小，以便接收方可以正确解密。
- en: 'You can find the following code in the `Encrypt_decrypt_AES.py` file inside
    the `pycrypto` folder:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pycrypto`文件夹内的`Encrypt_decrypt_AES.py`文件中可以找到以下代码：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The **output** of the previous script is:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个脚本的**输出**是：
- en: '`(''Cipher text: '', ''\xf2\xda\x92:\xc0\xb8\xd8PX\xc1\x07\xc2\xad"\xe4\x12\x16\x1e)(\xf4\xae\xdeW\xaf_\x9d\xbd\xf4\xc3\x87\xc4'')`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`(''密码文本：''，''\xf2\xda\x92:\xc0\xb8\xd8PX\xc1\x07\xc2\xad"\xe4\x12\x16\x1e)(\xf4\xae\xdeW\xaf_\x9d\xbd\xf4\xc3\x87\xc4'')`'
- en: '`(''Decrypted text: '', ''This is the secret message'')`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`(''解密文本：''，''这是秘密消息'')`'
- en: File encryption with AES
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AES进行文件加密
- en: AES encryption requires that each block being written be a multiple of 16 bytes
    in size. So we read, encrypt, and write the data in chunks. The chunk size is
    required to be a multiple of 16.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: AES加密要求每个写入的块的大小是16字节的倍数。因此，我们以块的形式读取、加密和写入数据。块大小需要是16的倍数。
- en: The following script encrypts the file provided by the parameter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本加密由参数提供的文件。
- en: 'You can find the following code in the `aes-file-encrypt.py` file inside the
    `pycrypto` folder:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pycrypto`文件夹内的`aes-file-encrypt.py`文件中可以找到以下代码：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The output of the previous script is a file called `file.txt.encrypted`, which
    contains the same content of the original file but the information is not legible.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个脚本的输出是一个名为`file.txt.encrypted`的文件，其中包含原始文件的相同内容，但信息不可读。
- en: 'The previous script works in the way that first we load all required modules
    and define the function to encrypt the file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个脚本的工作方式是首先加载所有所需的模块并定义加密文件的函数：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, we need to obtain our initialization Vector. A 16-byte initialization
    vector is required, which is generated as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要获取我们的初始化向量。需要一个16字节的初始化向量，生成如下：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then we can initialize the AES encryption method in the `PyCrypto` module:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在`PyCrypto`模块中初始化AES加密方法：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: File decryption with AES
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AES进行文件解密
- en: For decrypting, we need to reverse the preceding process to decrypt the file
    using AES.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密，我们需要反转前面的过程，使用AES解密文件。
- en: 'You can find the following code in the** `aes-file-decrypt.py`** file inside
    the `pycrypto` folder:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`pycrypto`文件夹中的**`aes-file-decrypt.py`**文件中找到以下代码：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Encrypting and decrypting information with cryptography
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用密码学对信息进行加密和解密
- en: In this section, we review the `cryptography` module for encrypting and decrypting
    data. `Cryptography` is a module more recent and it has better performance and
    security than `pycrypto`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾用于加密和解密数据的`cryptography`模块。`Cryptography`是一个更近期的模块，比`pycrypto`具有更好的性能和安全性。
- en: Introduction to cryptography
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学简介
- en: Cryptography is available in the `pypi` repository and you can install with
    the `pip install cryptography` command.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学可在`pypi`存储库中找到，并且可以使用`pip install cryptography`命令进行安装。
- en: In the [https://pypi.org/project/cryptography](https://pypi.org/project/cryptography) URL,
    we can see the last version of this module.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://pypi.org/project/cryptography](https://pypi.org/project/cryptography)
    URL中，我们可以看到此模块的最新版本。
- en: For more information about installation and supported platforms, check out [https://cryptography.io/en/latest/installation/](https://cryptography.io/en/latest/installation/).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有关安装和支持的平台的更多信息，请查看[https://cryptography.io/en/latest/installation/](https://cryptography.io/en/latest/installation/)。
- en: Cryptography includes both high-level and low-level interfaces to common cryptographic
    algorithms, such as symmetric ciphers, message digests, and key-derivation functions.
    For example, we can use symmetric encryption with the `fernet` package.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学包括常见加密算法的高级和低级接口，如对称密码、消息摘要和密钥派生函数。例如，我们可以使用`fernet`包进行对称加密。
- en: Symmetric encryption with the fernet package
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fernet包进行对称加密
- en: Fernet is an implementation of symmetric encryption and guarantees that an encrypted
    message cannot be manipulated or read without the key.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Fernet是对称加密的一种实现，并保证加密消息不能在没有密钥的情况下被篡改或读取。
- en: For generating the key, we can use the `generate_key()` method from the `Fernet`
    interface.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成密钥，我们可以使用`Fernet`接口中的`generate_key()`方法。
- en: 'You can find the following code in the`encrypt_decrypt.py` file inside the
    cryptography folder:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在cryptography文件夹中的`encrypt_decrypt.py`文件中找到以下代码：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is the output of the previous script:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是先前脚本的输出：
- en: '![](assets/8ff216ff-69d5-4ad1-be86-befeb736603c.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8ff216ff-69d5-4ad1-be86-befeb736603c.png)'
- en: Using passwords with the fernet package
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fernet包的密码
- en: It is possible to use passwords with Fernet. To do this, you need to run the
    password through a key-derivation function, such as **PBKDF2HMAC.**
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Fernet使用密码。为此，您需要通过密钥派生函数（如**PBKDF2HMAC**）运行密码。
- en: '**PBKDF2 (Password Based Key Derivation Function 2)** is typically used for
    deriving a cryptographic key from a password.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**PBKDF2（基于密码的密钥派生函数2）**通常用于从密码派生加密密钥。'
- en: More information about key derivation functions can be found at [https://cryptography.io/en/latest/hazmat/primitives/key-derivation-functions/](https://cryptography.io/en/latest/hazmat/primitives/key-derivation-functions/).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有关密钥派生函数的更多信息，请访问[https://cryptography.io/en/latest/hazmat/primitives/key-derivation-functions/](https://cryptography.io/en/latest/hazmat/primitives/key-derivation-functions/)。
- en: In this example, we are using this function to generate a key from a password,
    and we use that key to create the Fernet object we will use for encrypting and
    decrypting data. In this case, the data to encrypt is a simple message string.
    We can use the `verify()` method, which checks whether deriving a new key from
    the supplied key generates the same key as expected_key.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用这个函数从密码生成一个密钥，并使用该密钥创建我们用于加密和解密数据的Fernet对象。在这种情况下，要加密的数据是一个简单的消息字符串。我们可以使用`verify()`方法，检查从提供的密钥派生新密钥是否生成与expected_key相同的密钥。
- en: 'You can find the following code in the`encrypt_decrypt_kdf.py` file inside
    the cryptography folder:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在cryptography文件夹中的`encrypt_decrypt_kdf.py`文件中找到以下代码：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is the **output** of the previous script:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是先前脚本的输出：
- en: '![](assets/9c13daa7-c80c-44a2-82b6-1c19d484817e.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9c13daa7-c80c-44a2-82b6-1c19d484817e.png)'
- en: 'If we are verifying the key with the `verify()` method and it checks that keys
    not match during the process, it launches the `cryptography.exceptions.InvalidKey` exception:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`verify()`方法验证密钥，并且在过程中检查到密钥不匹配，它会引发`cryptography.exceptions.InvalidKey`异常：
- en: '![](assets/26d6ed93-5f7b-43d5-b0fb-ff9448d2e7ab.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/26d6ed93-5f7b-43d5-b0fb-ff9448d2e7ab.png)'
- en: Symmetric encryption with the ciphers package
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ciphers包进行对称加密
- en: The ciphers package from the `cryptography` module provides a class for symmetric
    encryption with the`cryptography.hazmat.primitives.ciphers.Cipher` class.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`cryptography`模块中的ciphers包提供了用于对称加密的`cryptography.hazmat.primitives.ciphers.Cipher`类。'
- en: Cipher objects combine an algorithm, such as AES, with a mode, such as CBC or
    CTR.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Cipher对象将算法（如AES）与模式（如CBC或CTR）结合在一起。
- en: In the the following script, we can see an example of encrypting and then decrypting
    content with AES.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的脚本中，我们可以看到使用AES加密然后解密内容的示例。
- en: 'You can find the following code in the `encrypt_decrypt_AES.py` file inside
    the cryptography folder:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在cryptography文件夹中的`encrypt_decrypt_AES.py`文件中找到以下代码：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is the output of the previous script:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是先前脚本的输出：
- en: '![](assets/ab420ee2-3e50-4975-b462-08b648925f9e.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ab420ee2-3e50-4975-b462-08b648925f9e.png)'
- en: Steganography techniques for hiding information in images
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在图像中隐藏信息的隐写术技术
- en: In this section, we review Steganography techniques and stepic as the `python`
    module for hiding information in images.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾隐写术技术和`python`模块stepic，用于在图像中隐藏信息。
- en: Introduction to Steganography
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐写术简介
- en: Steganography ([http://en.wikipedia.org/wiki/Steganography](http://en.wikipedia.org/wiki/Steganography)) 
    is a specific branch of cryptography that allows us to hide a secret message into
    public information, that is, into apparently innocuous information.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 隐写术（[http://en.wikipedia.org/wiki/Steganography](http://en.wikipedia.org/wiki/Steganography)）是密码学的一个特定分支，它允许我们将秘密信息隐藏在公共信息中，也就是在表面上无害的信息中。
- en: One of the main techniques for hiding information is use the **Least Significant
    Bit (LSB).**
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏信息的主要技术之一是使用**最不显著位（LSB）**。
- en: When passing through each pixel of the image, we obtain an RGB triplet composed
    of whole numbers from (0) to (255), and since each number has its own representation
    in binary, we convert that triplet into its equivalent in binary; for example,
    the pixel formed by (148, 28, 202) is binary equivalent to (10010100, 00011100,
    11001010).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过图像的每个像素时，我们获得一个由整数（0）到（255）组成的RGB三元组，由于每个数字都有其自己的二进制表示，我们将该三元组转换为其等效的二进制；例如，由（148，28，202）组成的像素的二进制等效为（10010100，00011100，11001010）。
- en: The goal is to edit the least significant bit, that is, the one that is last
    to the right. In the following LSB column we have altered the bits (in red) but
    the rest are still intact, and the result of the RGB triplet undergoes some changes,
    but they are minimal. If they are carefully set in both colors, it is very unlikely
    that they will find any kind of visual difference but in reality there was a change,
    after altering the least significant bit, the RGB triplet is different from the
    one we had at the beginning, but the color apparently is the same.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是编辑最不显著的位，也就是最右边的位。在下面的LSB列中，我们已经改变了位（用红色标出），但其余部分仍然完好无损，RGB三元组的结果发生了一些变化，但变化很小。如果它们在两种颜色中被小心地设置，很不可能发现任何视觉差异，但实际上发生了变化，改变了最不显著的位之后，RGB三元组与一开始的不同，但颜色显然是相同的。
- en: We can alter the information and send it without an attacker realizing that
    there is something strange.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以改变信息并发送它，而攻击者并不会意识到有什么奇怪的地方。
- en: Everything is ones and zeros and we can make the LSB follow the sequence that
    we want, for example, if we want to hide the word "Hacking," we have to remember
    that each letter (character) can be represented by a Byte being the "H" = 01001000
    so if we have 3 pixels we can hide that sequence using LSB.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都是0和1，我们可以使LSB遵循我们想要的顺序，例如，如果我们想要隐藏单词“Hacking”，我们必须记住每个字母（字符）可以由一个字节表示，即“H”=
    01001000，所以如果我们有3个像素，我们可以使用LSB隐藏该序列。
- en: 'In this image, we can see the representation of the "H" letter in Binary and
    LSB formats:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这张图片中，我们可以看到“H”字母的二进制和LSB格式的表示：
- en: '![](assets/c79ec798-3c4c-4d66-9ce4-ab30a1ae8ec2.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c79ec798-3c4c-4d66-9ce4-ab30a1ae8ec2.png)'
- en: Since each pixel has three values ​​that compose it and in each one we can only
    alter a bit, then three pixels are necessary to hide the letter "H," since its
    representation in binary corresponds to eight bits. The preceding table is very
    intuitive; to get three pixels of the original image, we take out their respective
    RGB, and since we want to hide the letter "H" in binary, we simply replace the
    least significant bits in the order of the "H." Then we go back to reconstruct
    the three pixels, only now that we hide a letter in them, their values ​​have
    changed but no change perceptible to the human eye.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个像素有三个组成它的值，而且在每个值中我们只能改变一个位，所以需要三个像素来隐藏字母“H”，因为它的二进制表示对应于八位。前面的表格非常直观；为了得到原始图像的三个像素，我们取出它们各自的RGB，而且由于我们想要以二进制形式隐藏字母“H”，我们只需按照“H”的顺序替换最不显著的位。然后我们重新构建这三个像素，只是现在我们在其中隐藏了一个字母，它们的值已经改变，但对人眼来说没有可察觉的变化。
- en: In this way, we can hide not only text but all kinds of information, since everything
    is representable in binary values; the way to recover the information is just
    to receive the altered image and start reading the least significant bits, because
    every eight bits, we have the representation of a character.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们不仅可以隐藏文本，还可以隐藏各种信息，因为一切都可以用二进制值来表示；恢复信息的方法只是接收被改变的图像并开始读取最不显著的位，因为每八位，我们有一个字符的表示。
- en: In the next script, we will implement this technique with python.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个脚本中，我们将使用Python实现这种技术。
- en: You can find the following code in the `steganography_LSB.py` fileinside the
    steganography folder.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`steganography_LSB.py`文件中的steganography文件夹中找到以下代码。
- en: 'First, we define our functions for get, set the **Least Significant Bit (LSB)**,
    and set the `extract_message()` method that reads the image and accesses the LSB
    for each pixel pair:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了用于获取、设置**最不显著位（LSB）**的函数，并设置了`extract_message()`方法，该方法读取图像并访问每个像素对的LSB。
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we define our `hide_message` method, which reads the image and hides the
    message in the image using the LSB for each pixel:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们定义我们的`hide_message`方法，它读取图像并使用LSB在图像中隐藏消息：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Steganography with Stepic
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Stepic进行隐写术
- en: Stepic provides a `Python` module and a command-line interface to hide arbitrary
    data within images. It slightly modifies the colours of the pixels in the image
    to store the data.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Stepic提供了一个`Python`模块和一个命令行界面，用于在图像中隐藏任意数据。它轻微地修改图像中像素的颜色以存储数据。
- en: To set up stepic, just install it with the `pip install stepic` command.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置stepic，只需使用`pip install stepic`命令进行安装。
- en: 'Stepic’s `Steganographer` class is the main class of the module,where we can
    see the methods available for encoding and decoding data in images:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Stepic的`Steganographer`类是该模块的主要类，我们可以看到可用于在图像中编码和解码数据的方法：
- en: '![](assets/5d0c2b78-ae66-4ca7-99d1-b282cd23d612.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5d0c2b78-ae66-4ca7-99d1-b282cd23d612.png)'
- en: In the following script, compatible with python version 2.x, we can see the
    implementation of these functions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个脚本中，与Python 2.x版本兼容，我们可以看到这些函数的实现。
- en: 'You can find the following code in the  `**stepic.py**`fileinside the `steganography`
    folder:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`**stepic.py**`文件中的`steganography`文件夹中找到以下代码：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this part of code, we can see methods related to encoding data in the image
    using the LSB.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分代码中，我们可以看到与使用LSB在图像中编码数据相关的方法。
- en: 'Stepic reads pixels image from left to right, starting at the top. Each pixel
    is defined by a triplet of integers between 0 and 255, the first one provides
    the red component, the second one the green, and the third the blue. It reads
    three pixels at a time, each of which contains three values: red, green, and blue.
    Each group of pixels has nine values. A byte of data has eight bits, so if each
    color can be modified just slightly, by setting the least significant bit to zero
    or one, these three pixels can store a byte, with one color value left over:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Stepic从左到右读取图像像素，从顶部开始。每个像素由0到255之间的三个整数三元组定义，第一个提供红色分量，第二个提供绿色，第三个提供蓝色。它一次读取三个像素，每个像素包含三个值：红色，绿色和蓝色。每组像素有九个值。一个字节的数据有八位，所以如果每种颜色都可以稍微修改，通过将最不显著的位设置为零或一，这三个像素可以存储一个字节，还剩下一个颜色值：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this part of the code, we can see methods related to decoding data from
    the image using the LSB. Basically, given a sequence of pixels from the image,
    it returns an iterator of characters encoded in the image:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的这一部分中，我们可以看到与使用LSB从图像中解码数据相关的方法。基本上，给定图像中的一系列像素，它返回一个编码在图像中的字符的迭代器：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Stepic uses the the least significant bit (**[http://en.wikipedia.org/wiki/Least_significant_bit](http://en.wikipedia.org/wiki/Least_significant_bit)**)
    of this leftover value to signify the end of the data.The coding scheme gives
    no clue as to whether an image contains data, so Stepic will always extract at
    least one byte from any image, whether or not someone intentionally hides data
    there.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Stepic使用这个剩余值的最不显著位(**[http://en.wikipedia.org/wiki/Least_significant_bit](http://en.wikipedia.org/wiki/Least_significant_bit)**)来表示数据的结束。编码方案不会透露图像是否包含数据，因此Stepic将始终从任何图像中提取至少一个字节的数据，无论是否有人有意地在那里隐藏数据。
- en: 'To decode it, we can use the following function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要解码它，我们可以使用以下函数：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can see that this function is the inverse of the `encode_imdata(imdata, data)`
    function, where three pixels are read at the same time from left to right, from
    top to bottom, until the last bit of the last color of the last pixel that reads
    its equal to 1.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个函数是`encode_imdata(imdata, data)`函数的逆函数，它一次从左到右，从上到下读取三个像素，直到最后一个像素的最后一个颜色的最后一个位读取到1。
- en: Hiding data inside images with stepic
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用stepic在图像中隐藏数据
- en: In the script that follows, we are using the Image package from the `PIL` module
    form read an image. Once  we have read the image, we use the encode function from
    stepic to hide some text in the image. We save this information in a second image,
    and to obtain the hidden text, we use the decode function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的脚本中，我们使用`PIL`模块中的Image包来读取图像。一旦我们读取了图像，我们使用stepic中的encode函数将一些文本隐藏在图像中。我们将这些信息保存在第二个图像中，并使用decode函数来获取隐藏的文本。
- en: 'You can find the following code in the `stepic_example.py` fileinside the `steganography`
    folder:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`steganography`文件夹中的`stepic_example.py`文件中找到以下代码：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: One of the objectives of this chapter was to learn about the `pycrypto` and
    `cryptography` modules that allow us to encrypt and decrypt information with the
    AES and DES algorithms. We also we looked at steganography techniques, such as
    least significant bit, and how to hide information in images with the stepic module.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一个目标是学习`pycrypto`和`cryptography`模块，它们允许我们使用AES和DES算法对信息进行加密和解密。我们还研究了隐写术技术，如最不显著位，以及如何使用stepic模块在图像中隐藏信息。
- en: To conclude this book, I would like to emphasize that readers should learn more
    about the topics they consider most important. Each chapter covers the fundamental
    ideas, from there, readers can use the *Further reading* section to find resources
    for more information.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这本书，我想强调读者应该更多地了解他们认为最重要的主题。每一章都涵盖了基本的思想，从那里，读者可以使用*进一步阅读*部分找到更多信息的资源。
- en: Questions
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which algorithm type uses the same key to encrypt and decrypt data?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种算法类型使用相同的密钥来加密和解密数据？
- en: Which algorithm type uses two different keys, one for encryption and the other
    for decryption?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种算法类型使用两个不同的密钥，一个用于加密，另一个用于解密？
- en: Which package can we use in pycrypto to use an encryption algorithm such as
    AES?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在pycrypto中使用哪个包来使用AES等加密算法？
- en: Which algorithm needs to ensure that the data is a multiple of 16 bytes in length?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种算法需要确保数据的长度是16字节的倍数？
- en: Which package for the `cryptography` module we can use symmetric encryption?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`cryptography`模块的哪个包进行对称加密？
- en: Which algorithm is used to derive a cryptographic key from a password?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于从密码生成加密密钥的算法是什么？
- en: What provides the fernet package for symmetric encryption and what is the method
    used for generating the key**?**
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: fernet包为对称加密提供了什么，用于生成密钥的方法是什么？
- en: Which class provides ciphers package symmetric encryption?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个类提供了密码包对称加密？
- en: Which method from stepic generates an image with hidden data, starting with
    an existing
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: stepic的哪个方法生成带有隐藏数据的图像，从现有的开始
- en: image and arbitrary data?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图像和任意数据？
- en: Which package from pycrypto contains some `hash` functions that allow one-way
    encryption?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从pycrypto中包含一些`hash`函数的哪个包允许单向加密？
- en: Further reading
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'In these links, you will find more information about the tools mentioned in
    this chapter and their official documentation:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些链接中，您将找到有关本章中提到的工具及其官方文档的更多信息：
- en: '`Pycryptodome` is a module based in the `pycrypto` library available in the
    `pypi` repository:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pycryptodome`是基于`pypi`存储库中可用的`pycrypto`库的模块：'
- en: '[https://pypi.org/project/pycryptodome/](https://pypi.org/project/pycryptodome/)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://pypi.org/project/pycryptodome/](https://pypi.org/project/pycryptodome/)'
- en: '[https://github.com/Legrandin/pycryptodome](https://github.com/Legrandin/pycryptodome)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/Legrandin/pycryptodome](https://github.com/Legrandin/pycryptodome)'
- en: '[https://www.pycryptodome.org/en/latest/](https://www.pycryptodome.org/en/latest/)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.pycryptodome.org/en/latest/](https://www.pycryptodome.org/en/latest/)'
- en: 'In these links, we can see other examples related to the `Pycrypto` modules:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些链接中，我们可以看到与`Pycrypto`模块相关的其他示例：
- en: '[https://github.com/X-Vector/Crypt0x/tree/master/Crypt0x](https://github.com/X-Vector/Crypt0x/tree/master/Crypt0x)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/X-Vector/Crypt0x/tree/master/Crypt0x](https://github.com/X-Vector/Crypt0x/tree/master/Crypt0x)'
- en: '[https://github.com/jmortega/pycon-security_criptography](https://github.com/jmortega/pycon-security_criptography)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/jmortega/pycon-security_criptography](https://github.com/jmortega/pycon-security_criptography)'
- en: 'If you need to explore password-generation in greater depth, you can find other
    interesting modules such as Secrets:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更深入地探索密码生成，您可以找到其他有趣的模块，比如Secrets：
- en: '[https://docs.python.org/3/library/secrets.html#module-secrets](https://docs.python.org/3/library/secrets.html#module-secrets)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/secrets.html#module-secrets](https://docs.python.org/3/library/secrets.html#module-secrets)'
- en: The `secrets` module is used for generating cryptographically-strong random
    numbers that are suitable for managing data, such as passwords,  account authentication,
    security tokens, and related secrets.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: “secrets”模块用于生成适用于管理数据（如密码、帐户验证、安全令牌和相关机密信息）的具有密码学强度的随机数。
