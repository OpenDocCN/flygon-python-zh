- en: String Algorithms and Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串算法和技术
- en: There are many popular string processing algorithms available, depending upon
    the problem being solved. However, one of the most important, popular, and useful
    string processing problems is to find a given substring or pattern from some given
    text. It has various application uses, such as searching an element from a text
    document, plagiarism detection, and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 根据所解决的问题，有许多流行的字符串处理算法。然而，最重要、最流行和最有用的字符串处理问题之一是从给定文本中找到给定的子字符串或模式。它有各种应用，例如从文本文档中搜索元素，检测抄袭等。
- en: In this chapter, we will study the standard string processing or pattern matching
    algorithms that find out the locations of the given pattern or substring in some
    given text. We will also be discussing the brute-force algorithm, as well as the
    Rabin-Karp, **Knuth-Morris-Pratt** (**KMP**), and Boyer-Moore pattern matching
    algorithms. We will also discuss some basic concepts related to strings. We will
    be discussing all of the algorithms with an easy explanation, including examples
    and implementation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习标准的字符串处理或模式匹配算法，以找出给定模式或子字符串在给定文本中的位置。我们还将讨论暴力算法，以及Rabin-Karp、Knuth-Morris-Pratt（KMP）和Boyer-Moore模式匹配算法。我们还将讨论与字符串相关的一些基本概念。我们将用简单的解释、示例和实现来讨论所有算法。
- en: 'This chapter is aimed at discussing algorithms that are focused on being related
    to strings. The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在讨论与字符串相关的算法。本章将涵盖以下主题：
- en: Learning the basic concepts of strings in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Python中字符串的基本概念
- en: Learning pattern matching algorithms and their implementation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习模式匹配算法及其实现
- en: Understanding and implementing the Rabin-Karp pattern matching algorithm
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和实现Rabin-Karp模式匹配算法
- en: Understanding and implementing the Knuth-Morris-Pratt (KMP) algorithm
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和实现Knuth-Morris-Pratt（KMP）算法
- en: Understanding and implementing the Boyer-Moore pattern matching algorithm
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和实现Boyer-Moore模式匹配算法
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All of the programs based on the concepts and algorithms discussed in this chapter
    are provided in the book as well as in the GitHub repository at the following
    link: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter12](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter12).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的基于本章讨论的概念和算法的所有程序都在书中以及GitHub存储库中提供，链接如下：[https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter12](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter12)。
- en: String notations and concepts
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串符号和概念
- en: Strings are basically a sequence of objects, mainly a sequence of characters.
    As with any other data type, such as an int or float, we need to store the data
    and operations that have to be applied to them. String data types allow us to
    store the data, and Python provides a rich set of operations and functions that
    can be applied to the data of the string data type. Most of the operations and
    functions provided by Python 3.7 that can be applied to the strings were described
    in detail in [Chapter 1](2818f56c-fbcf-422f-83dc-16cbdbd8b5bf.xhtml), *Python
    Objects, Types, and Expressions*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串基本上是一系列对象，主要是一系列字符。与其他任何数据类型（如int或float）一样，我们需要存储数据和要应用的操作。字符串数据类型允许我们存储数据，Python提供了一组丰富的操作和函数，可以应用于字符串数据类型的数据。Python
    3.7提供的大多数操作和函数，可以应用于字符串的数据，都在[第1章](2818f56c-fbcf-422f-83dc-16cbdbd8b5bf.xhtml)中详细描述了*Python对象、类型和表达式*。
- en: Strings are mainly textual data that is generally handled very efficiently.
    The following is an example of a string (S)—`"packt publishing"`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串主要是文本数据，通常处理得非常高效。以下是一个字符串（S）的示例——`"packt publishing"`。
- en: A substring is also a sequence of characters that's part of the given string.
    For example, `"packt"` is the substring for the string `"packt publishing"`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 子字符串也是给定字符串的一部分字符序列。例如，`"packt"`是字符串`"packt publishing"`的子字符串。
- en: A subsequence is a sequence of characters that can be obtained from the given
    string by removing some of the characters from the string but by keeping the order
    of occurrence of the characters. For example, `"pct pblishing"` is a valid subsequence
    for the string `"packt publishing"` that is obtained by removing the characters
    `a`, `k`, and `u`. However, this is not a substring. A subsequence is different
    from a substring, since it can be considered as a generalization of substrings.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 子序列是从给定字符串中删除一些字符但保持字符出现顺序的字符序列。例如，`"pct pblishing"`是字符串`"packt publishing"`的有效子序列，通过删除字符`a`、`k`和`u`获得。但是，这不是一个子字符串。子序列不同于子字符串，因为它可以被认为是子字符串的泛化。
- en: The prefix of a string, `s`, is the substring of `s` in that it is present in
    the starting of the string. There is also another string, `u`, that exists in
    the string s after the prefix. For example, the substring `"pack"` is a prefix
    for the string `(s) = "packt publishing"` as it is starting the substring and
    there is another substring after it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`s`的前缀是字符串`s`的子字符串，它出现在字符串的开头。还有另一个字符串`u`，它存在于前缀之后的字符串s中。例如，子字符串`"pack"`是字符串`(s)
    = "packt publishing"`的前缀，因为它是起始子字符串，之后还有另一个子字符串。
- en: 'The suffix `(d)` is a substring that is present at the end of the string (s)
    so that there is another nonempty substring existing before substring d. For example,
    the substring `"shing"` is the suffix for the string `"packt publishing"`. Python
    has built-in functions to check whether a string has a given prefix or suffix,
    as shown in the following code snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀`(d)`是一个子字符串，它出现在字符串（s）的末尾，以便在子字符串d之前存在另一个非空子字符串。例如，子字符串`"shing"`是字符串`"packt
    publishing"`的后缀。Python具有内置函数，用于检查字符串是否具有给定的前缀或后缀，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Pattern matching algorithms are the most important string processing algorithms,
    and we will be discussing them in subsequent sections.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配算法是最重要的字符串处理算法，我们将在后续章节中讨论它们。
- en: Pattern matching algorithms
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配算法
- en: A pattern matching algorithm is used to determine the index positions where
    a given pattern string (P) is matched in a text string (T). It returns `"pattern
    not found"` if the pattern does not match in the text string. For example, for
    the given string (s) = `"packt publisher"`, and the pattern (p)= `"publisher"`,
    the pattern matching algorithm returns the index position where the pattern is
    matched in the text string.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配算法用于确定给定模式字符串（P）在文本字符串（T）中匹配的索引位置。如果模式在文本字符串中不匹配，则返回`"pattern not found"`。例如，对于给定字符串（s）=`"packt
    publisher"`，模式（p）=`"publisher"`，模式匹配算法返回模式在文本字符串中匹配的索引位置。
- en: In this section, we will discuss four pattern matching algorithms, that is,
    the brute-force method, as well as the Rabin-Karp algorithm, Knuth-Morris-Pratt
    (KMP), and Boyer Moore pattern matching algorithms.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论四种模式匹配算法，即暴力方法，以及Rabin-Karp算法，Knuth-Morris-Pratt（KMP）和Boyer Moore模式匹配算法。
- en: The brute-force algorithm
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴力算法
- en: The brute-force algorithm, or naive approach for the pattern matching algorithm,
    is very basic. Using this, we simply test all the possible combinations of the
    input pattern in the given string to find the position of the occurrence of the
    pattern. This algorithm is very naive and is not suitable if the text is very
    long.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力算法，或者模式匹配算法的朴素方法，非常基础。使用这种方法，我们简单地测试给定字符串中输入模式的所有可能组合，以找到模式的出现位置。这个算法非常朴素，如果文本很长就不适用。
- en: Here, we start by comparing the characters of the pattern and the text string
    one by one, and if all the characters of the pattern are matched with the text,
    we return the index position of the text where the first character of the pattern
    is placed. If any character of the pattern is mismatched with the text string,
    we shift the pattern by one place. We continue comparing the pattern and text
    string by shifting the pattern by one index position.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先逐个比较模式和文本字符串的字符，如果模式的所有字符与文本匹配，我们返回模式的第一个字符放置的文本的索引位置。如果模式的任何字符与文本字符串不匹配，我们将模式向右移动一个位置。我们继续比较模式和文本字符串，通过将模式向右移动一个索引位置。
- en: 'To better understand how the brute-force algorithm works, let''s look at an
    example. Suppose we have a text string (T)= **acbcabccababcaacbcac**, and the
    pattern string (P) is **acbcac**. Now, the objective of the pattern matching algorithm
    is to determine the index position of the pattern string in the given text, T,
    as shown in the following figure:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解暴力算法的工作原理，让我们看一个例子。假设我们有一个文本字符串(T)=**acbcabccababcaacbcac**，模式字符串(P)是**acbcac**。现在，模式匹配算法的目标是确定给定文本T中模式字符串的索引位置，如下图所示：
- en: '![](Images/248df9b8-9f4d-4cb4-a404-b08d3cc5cef8.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/248df9b8-9f4d-4cb4-a404-b08d3cc5cef8.png)'
- en: We start by comparing the first character of the text, that is, **a**, and the
    characters of the pattern. Here, the initial five characters of the pattern are
    matched, and there is a mismatch in the last character of the pattern. Since there
    is a mismatch, we further shift the pattern by one place.  We again start comparing
    the first character of the pattern and the second character of the text string
    one by one. Here, character **c** of the text string does not match with the character
    **a** of the pattern. Since it is a mismatch, we shift the pattern by one space,
    as shown in the preceding diagram. We continue comparing the characters of the
    pattern and the text string until we traverse the whole text string. In the preceding
    example, we find a match at index position **14**, which is shown with the arrows
    to **aa**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先比较文本的第一个字符，即**a**，和模式的字符。在这里，模式的初始五个字符匹配，最后一个字符不匹配。由于不匹配，我们进一步将模式向右移动一个位置。我们再次开始逐个比较模式的第一个字符和文本字符串的第二个字符。在这里，文本字符串的字符**c**与模式的字符**a**不匹配。由于不匹配，我们将模式向右移动一个位置，如前面的图所示。我们继续比较模式和文本字符串的字符，直到遍历整个文本字符串。在上面的例子中，我们在索引位置**14**找到了匹配，用箭头指向**aa**。
- en: 'Here, let''s consider the Python implementation of the brute-force algorithm
    for pattern matching:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，让我们考虑模式匹配的暴力算法的Python实现：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code for the brute-force approach, we start by computing the
    length of the given text strings and pattern. We also initialize the looping variables
    with `0` and set the flag to `False`. This variable is used to continue searching
    for a match of the pattern in the string. If the flag is `False` by the end of
    the text string, it means that there is no match of the pattern at all in the
    text string.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在暴力方法的上述代码中，我们首先计算给定文本字符串和模式的长度。我们还用`0`初始化循环变量，并将标志设置为`False`。这个变量用于在字符串中继续搜索模式的匹配。如果标志在文本字符串结束时为`False`，这意味着在文本字符串中根本没有模式的匹配。
- en: 'Next, we start the searching loop from the `0th` index to the end of the text
    string. In this loop, we have a count variable that is used to keep track of the
    length up to which the pattern and the text have been matched. Next, we have another
    nested loop that runs from the `0th` index to the length of the pattern. Here,
    the variable `i` keeps track of the index position in the text string and the
    variable `j` keeps track of the characters in the pattern. Next, we compare the
    characters of the patterns and the text string using the following code fragment:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从文本字符串的`0th`索引开始搜索循环，直到末尾。在这个循环中，我们有一个计数变量，用于跟踪匹配的模式和文本的长度。接下来，我们有另一个嵌套循环，从`0th`索引运行到模式的长度。在这里，变量`i`跟踪文本字符串中的索引位置，变量`j`跟踪模式中的字符。接下来，我们使用以下代码片段比较模式和文本字符串的字符：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Furthermore, we increment the count variable after every match of the character
    of the pattern in the text string. Then, we continue matching the characters of
    the pattern and text string. If the length of the pattern becomes equal to the
    count variable, it means there is a match.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在文本字符串中每次匹配模式的字符后递增计数变量。然后，我们继续匹配模式和文本字符串的字符。如果模式的长度等于计数变量，那么就意味着有匹配。
- en: We print the index position of the text string if there is a match of the pattern
    in the text string, and keep the flag variable to `True` as we wish to continue
    searching for more matches of the patterns in the text string. Finally, if the
    value of the variable flag is `False`, it means that there was not a match of
    the pattern in the text string at all.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在文本字符串中找到了模式的匹配，我们会打印文本字符串的索引位置，并将标志变量保持为“True”，因为我们希望继续在文本字符串中搜索更多模式的匹配。最后，如果标志变量的值为“False”，这意味着在文本字符串中根本没有找到模式的匹配。
- en: The best-case and worst-case time complexity for the naive string matching algorithms
    are `O(n)` and `O(m*(n-m+1))`, respectively. The best-case occurs when the pattern
    is not found in the text and the first character of the pattern is not present
    in the text at all, for example, if the text string is `ABAACEBCCDAAEE`, and the
    pattern is `FAA`. Here, as the first character of the pattern will not match in
    the text, it will have the comparisons equal to the length of the text (`n`).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 朴素字符串匹配算法的最佳情况和最坏情况的时间复杂度分别为`O(n)`和`O(m*(n-m+1))`。最佳情况是模式在文本中找不到，并且模式的第一个字符根本不在文本中，例如，如果文本字符串是`ABAACEBCCDAAEE`，模式是`FAA`。在这种情况下，由于模式的第一个字符在文本中不匹配，比较次数将等于文本的长度(`n`)。
- en: The worst-case occurs when all characters of the text string and the pattern
    are the same, for example, if the text string is `AAAAAAAAAAAAAAAA`, and the pattern
    is `AAAA`. Another worst-case scenario occurs when only the last character is
    different, for example, if the text string is `AAAAAAAAAAAAAAAF` and the pattern
    is `AAAAF`. Thus, worst-case time complexity would be `O(m*(n-m+1))`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏情况发生在文本字符串和模式的所有字符都相同的情况下，例如，如果文本字符串是`AAAAAAAAAAAAAAAA`，模式是`AAAA`。另一个最坏情况是只有最后一个字符不同，例如，如果文本字符串是`AAAAAAAAAAAAAAAF`，模式是`AAAAF`。因此，最坏情况的时间复杂度将是`O(m*(n-m+1))`。
- en: The Rabin-Karp algorithm
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉宾-卡普算法
- en: The Rabin-Karp pattern matching algorithm is an improved version of the brute-force
    approach for finding the location of the given pattern in the text string.  The
    performance of the Rabin-Karp algorithm is improved by reducing the number of
    comparisons with the help of hashing. We described hashing in detail in [Chapter
    7](7caf334d-44bb-4c49-bb74-4f6e1ac8a8e4.xhtml), *Hashing and Symbol Tables*. The
    hashing function returns a unique numeric value for a given string.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 拉宾-卡普模式匹配算法是改进后的蛮力方法，用于在文本字符串中找到给定模式的位置。拉宾-卡普算法的性能通过减少比较次数来改进，借助哈希。我们在[第7章](7caf334d-44bb-4c49-bb74-4f6e1ac8a8e4.xhtml)中详细描述了哈希，*哈希和符号表*。哈希函数为给定的字符串返回一个唯一的数值。
- en: This algorithm is faster than the brute-force approach as it avoids unnecessary
    comparisons, character by character. Instead, the hash value of the pattern is
    compared with the hash of the substring of the text string all at once. If the
    hash values are not matched, the pattern is moved one position, and so there is
    no need to compare all the characters of the pattern one by one.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种算法比蛮力方法更快，因为它避免了不必要的逐个字符比较。相反，模式的哈希值一次性与文本字符串的子字符串的哈希值进行比较。如果哈希值不匹配，模式就向前移动一位，因此无需逐个比较模式的所有字符。
- en: This algorithm is based on the concept that if the hash values of the two strings
    are equal, then it is assumed that both of these strings are also equal. The main
    problem with this algorithm is that there can be two different strings whose hash
    values are equal. In that case, the algorithm may not work; this situation is
    known as a spurious hit. To avoid this problem, after matching the hash values
    of the pattern and the substring, we ensure that the pattern is actually matched
    by comparing them character by character.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种算法基于这样的概念：如果两个字符串的哈希值相等，那么假定这两个字符串也相等。这种算法的主要问题是可能存在两个不同的字符串，它们的哈希值相等。在这种情况下，算法可能无法工作；这种情况被称为虚假命中。为了避免这个问题，在匹配模式和子字符串的哈希值之后，我们通过逐个比较它们的字符来确保模式实际上是匹配的。
- en: 'The Rabin-Karp pattern matching algorithm works as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 拉宾-卡普模式匹配算法的工作原理如下：
- en: First, we preprocess the pattern before starting the search, that is, we compute
    the hash value of the pattern of length `m` and the hash values of all the possible
    substrings of the text of length `m`. So, the total number of possible substrings
    would be `(n-m+1)`. Here, `n` is the length of the text.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在开始搜索之前，我们对模式进行预处理，即计算长度为`m`的模式的哈希值以及长度为`m`的文本的所有可能子字符串的哈希值。因此，可能的子字符串的总数将是`(n-m+1)`。这里，`n`是文本的长度。
- en: We compare the hash value of the pattern and compare it with the hash value
    of the substrings of the text one by one.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们比较模式的哈希值，并逐一与文本的子字符串的哈希值进行比较。
- en: If the hash values are not matched, then we move the pattern by one position.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果哈希值不匹配，我们就将模式向前移动一位。
- en: If the hash value of the pattern and the hash value of the substring of the
    text matches, then we compare the pattern and substring character by character
    to ensure that the pattern is actually found in the text.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果模式的哈希值和文本的子字符串的哈希值匹配，那么我们逐个比较模式和子字符串的字符，以确保模式实际上在文本中找到。
- en: We continue the process of steps 2-4 until we reach the end of the given text
    string.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续进行步骤2-4的过程，直到达到给定文本字符串的末尾。
- en: In this algorithm, we can compute the numerical hash values using Horner's rule
    or any other hashing function that returns a unique value for the given string.
    We can also compute the hashing value using the sum of the ordinal values of all
    the characters of the string.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个算法中，我们可以使用Horner法则或任何返回给定字符串唯一值的哈希函数来计算数值哈希值。我们也可以使用字符串所有字符的序数值之和来计算哈希值。
- en: Let's consider an example to understand the Rabin-Karp algorithm. Let's say
    we have a text string (T)= `"publisher paakt packt"`, and the pattern (P)= `"packt"`.  First,
    we compute the hash value of the pattern (length `m`) and all the substrings (of
    length `m`) of the text string.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子来理解Rabin-Karp算法。假设我们有一个文本字符串（T）=“publisher paakt packt”，模式（P）=“packt”。首先，我们计算模式（长度为`m`）的哈希值和文本字符串的所有子字符串（长度为`m`）的哈希值。
- en: We start comparing the hash of the pattern `"packt"` with the first substring, `"publi" `
    . Since the hash values do not match, we move the pattern by one location, and
    once again we compare the hash value of pattern with the hash value of the next
    substring of the text, `"ublis"`. As these hash values also do not match, we again
    move the pattern by one location. We always move the pattern by one location if
    the hash values do not match.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始比较模式“packt”的哈希值与第一个子字符串“publi”的哈希值。由于哈希值不匹配，我们将模式移动一个位置，然后再次比较模式的哈希值与文本的下一个子字符串“ublis”的哈希值。由于这些哈希值也不匹配，我们再次将模式移动一个位置。如果哈希值不匹配，我们总是将模式移动一个位置。
- en: 'Furthermore, if the hash value of the pattern and the hash value of the substring
    match, we compare the pattern and substring character by character and we return
    the location of the text string. In this example, these values are matched at
    location `17`. It is important to note that there can be a different string whose
    hash value can match with the hash of the pattern. This situation is called a
    spurious hit, and is due to a collision in hashing. The functionality of the Rabin-Karp
    algorithm is shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果模式的哈希值和子字符串的哈希值匹配，我们逐个比较模式和子字符串的字符，并返回文本字符串的位置。在这个例子中，这些值在位置`17`匹配。重要的是要注意，可能有一个不同的字符串，其哈希值可以与模式的哈希值匹配。这种情况称为虚假命中，是由于哈希冲突而引起的。Rabin-Karp算法的功能如下所示：
- en: '![](Images/06dc36ee-ebaf-43b7-b19e-564e36fafb04.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/06dc36ee-ebaf-43b7-b19e-564e36fafb04.png)'
- en: Implementing the Rabin-Karp algorithm
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Rabin-Karp算法
- en: The first step to implementing the Rabin-Karp algorithm is to choose the hash
    function. We use the sum of all the ordinal values of the characters of the string
    as the hashing function.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 实现Rabin-Karp算法的第一步是选择哈希函数。我们使用字符串所有字符的序数值之和作为哈希函数。
- en: We start by storing the ordinal values of all the characters of the text and
    the pattern. Next, we store the length of the text and the pattern in the `len_text`
    and `len_pattern` variables. Next, we compute the hash value for the pattern by
    summing up the ordinal values of all the characters in the pattern.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先存储文本和模式的所有字符的序数值。接下来，我们将文本和模式的长度存储在`len_text`和`len_pattern`变量中。然后，我们通过对模式中所有字符的序数值求和来计算模式的哈希值。
- en: Next, we create a variable called `len_hash_array` that stores the total number
    of possible substrings of length (equal to the length of the pattern) using `len_text
    - len_pattern + 1`, and we create an array called `hash_text` that stores the
    hash value for all the possible substrings.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为`len_hash_array`的变量，它存储了使用`len_text - len_pattern + 1`的长度（等于模式的长度）的所有可能子字符串的总数，并创建了一个名为`hash_text`的数组，它存储了所有可能子字符串的哈希值。
- en: Next, we start a loop that will run for all the possible substrings of the text.
    Initially, we compute the hash value for the first substring by summing the ordinal
    values of all of its characters using `sum(ord_text[:len_pattern])`. Furthermore,
    the hash values for all of the substrings are computed using the hash value of
    its previous substrings as `((hash_text[i-1] - ord_text[i-1]) + ord_text[i+len_pattern-1])`
    .
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始一个循环，它将运行所有可能的文本子字符串。最初，我们通过使用`sum(ord_text[:len_pattern])`对其所有字符的序数值求和来计算第一个子字符串的哈希值。此外，所有子字符串的哈希值都是使用其前一个子字符串的哈希值计算的，如`((hash_text[i-1]
    - ord_text[i-1]) + ord_text[i+len_pattern-1])`。
- en: 'The complete Python implementation to compute the hashing values is shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 计算哈希值的完整Python实现如下所示：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After preprocessing the pattern and text, we have precomputed hash values that
    we will use for comparing the pattern and the text.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在预处理模式和文本之后，我们有预先计算的哈希值，我们将用它们来比较模式和文本。
- en: The implementation of the main Rabin-Karp algorithm works as follows. First,
    we convert the given text and pattern in string format as the ordinal values can
    only be computed for the strings.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的Rabin-Karp算法实现如下。首先，我们将给定的文本和模式转换为字符串格式，因为只能为字符串计算序数值。
- en: Next, we call the `generate_hash` function to compute the hash values. We also
    store the length of the text and patterns in the `len_text` and `len_pattern`
    variables. We also initialize the `flag` variable to `False` so that it keeps
    track of whether the pattern is present in the text at least once.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`generate_hash`函数来计算哈希值。我们还将文本和模式的长度存储在`len_text`和`len_pattern`变量中。我们还将`flag`变量初始化为`False`，以便跟踪模式是否至少出现一次在文本中。
- en: Next, we start a loop that implements the main concept of the algorithm. This
    loop will run for the length of the `hash_text`, which is the total number of
    possible substrings. Initially, we compare the first hash value of the substring
    with the hash of the pattern by using `if hash_text[i] == hash_pattern`. They
    do not match; we do nothing and look for another substring. If they match, we
    compare the substring and the pattern character by character through a loop by
    using `if pattern[j] == text[i+j]`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始一个循环，实现算法的主要概念。这个循环将运行`hash_text`的长度，这是可能子字符串的总数。最初，我们通过使用`if hash_text[i]
    == hash_pattern`比较子字符串的第一个哈希值和模式的哈希值。它们不匹配；我们什么也不做，寻找另一个子字符串。如果它们匹配，我们通过循环使用`if
    pattern[j] == text[i+j]`逐个字符比较子字符串和模式。
- en: We then create a `count` variable to keep track of how many characters match
    in the pattern and the substring. If the length of the count and length of the
    pattern become equal, this means that all of the characters match, and the index
    location is returned where the pattern was found. Finally, if the `flag` variable
    remains `False`, this means that the pattern does not match at all in the text.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`count`变量来跟踪模式和子字符串中匹配的字符数。如果计数的长度和模式的长度变得相等，这意味着所有字符都匹配，并且返回模式被找到的索引位置。最后，如果`flag`变量保持为`False`，这意味着模式在文本中根本不匹配。
- en: 'The complete Python implementation of the Rabin-Karp algorithm is shown as
    follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Rabin-Karp算法的完整Python实现如下所示：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The Rabin-Karp pattern matching algorithm preprocesses the pattern before the
    searching, that is, it computes the hash value for the pattern that has the complexity
    of `O(m)`.  Also, the worst-case running time complexity of the Rabin-Karp algorithm
    is `O(m *(n-m+1))`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Rabin-Karp模式匹配算法在搜索之前预处理模式，即计算模式的哈希值，其复杂度为`O(m)`。此外，Rabin-Karp算法的最坏情况运行时间复杂度为`O(m
    *(n-m+1))`。
- en: The worse-case would be when the pattern does not occur in the text at all.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏情况是模式根本不在文本中出现。
- en: The average-case would occur when the pattern occurs at least once.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 平均情况将发生在模式至少出现一次的情况下。
- en: The Knuth-Morris-Pratt algorithm
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Knuth-Morris-Pratt算法
- en: The **Knuth-Morris-Pratt** (**KMP**) algorithm is a pattern matching algorithm
    that is based on a precomputed prefix function that stores the information of
    an overlapping text portion in the pattern. The KMP algorithm preprocesses this
    pattern to avoid unnecessary comparisons when using the prefix function. The algorithm
    utilizes the prefix function to estimate how much the pattern should be shifted
    to search the pattern in the text string whenever we get a mismatch. The KMP algorithm
    is efficient as it minimizes the comparisons of the given patterns with respect
    to the text string.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**Knuth-Morris-Pratt**（**KMP**）算法是一种基于预先计算的前缀函数的模式匹配算法，该函数存储了模式中重叠文本部分的信息。KMP算法预处理这个模式，以避免在使用前缀函数时进行不必要的比较。该算法利用前缀函数来估计模式应该移动多少来搜索文本字符串中的模式，每当我们得到一个不匹配时。KMP算法是高效的，因为它最小化了给定模式与文本字符串的比较。'
- en: 'The motivation behind the KMP algorithm can be seen in the following explanatory
    diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: KMP算法背后的动机可以在以下解释性图表中看到：
- en: '![](Images/8f518fde-532f-4f1a-855d-94e9c0b80d22.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8f518fde-532f-4f1a-855d-94e9c0b80d22.png)'
- en: The prefix function
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前缀函数
- en: The `prefix` function (also known as the failure function) finds the pattern
    in the pattern itself. It tries to find how much the previous comparisons can
    be reused due to repetition in the pattern itself when there is a mismatch. It
    has a value that is mainly the longest prefix, which is also a suffix.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefix`函数（也称为失败函数）在模式中查找模式本身。当出现不匹配时，它试图找出由于模式本身的重复而可以重复使用多少之前的比较。它的值主要是最长的前缀，也是后缀。'
- en: 'For example, if we have a `prefix` function for a pattern where all of the
    characters are different, the `prefix` function would have a value of `0`, meaning
    that if we find any mismatch, the pattern would be shifted by the number of characters
    in the pattern. It also means that there is no overlap in the pattern, and no
    previous comparisons would be reused. We start by comparing from the first character
    of the pattern with the text string if it contains only different characters.
    Consider the following example: the pattern **abcde** contains all different characters,
    so it would be shifted to the number of characters in the pattern, and we would
    start comparing the first character of the pattern with the next character of
    the text string, as shown in the following diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个模式的`prefix`函数，其中所有字符都不同，那么`prefix`函数的值将为`0`，这意味着如果我们找到任何不匹配，模式将被移动到模式中的字符数。这也意味着模式中没有重叠，并且不会重复使用任何先前的比较。如果文本字符串只包含不同的字符，我们将从模式的第一个字符开始比较。考虑以下示例：模式**abcde**包含所有不同的字符，因此它将被移动到模式中的字符数，并且我们将开始比较模式的第一个字符与文本字符串的下一个字符，如下图所示：
- en: '![](Images/ef15fd04-c114-4737-9dbe-344b65cf61a8.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ef15fd04-c114-4737-9dbe-344b65cf61a8.png)'
- en: 'Let''s consider another example to better understand how the `prefix` function
    works for the pattern (P) **abcabbcab** as shown in the following diagram:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个示例，以更好地理解`prefix`函数如何为模式（P）**abcabbcab**工作，如下图所示：
- en: '![](Images/0a762ce6-7571-451d-a0cb-378a379fc3f1.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0a762ce6-7571-451d-a0cb-378a379fc3f1.png)'
- en: 'In the preceding diagram, we start calculating the values of the `prefix` function
    starting from index **1**. We assign value **0** if there is no repetition of
    the characters. In the preceding example, we assign **0** to the `prefix` function
    for the index positions **1** to **3**.  Next, at index position **4**, we can
    see that there is a character, **a**, which is the repetition of the first character
    of the pattern in itself, so we assign value **1** here, shown as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们从索引**1**开始计算`prefix`函数的值。如果字符没有重复，我们将值赋为**0**。在上面的例子中，我们为索引位置**1**到**3**的`prefix`函数分配了**0**。接下来，在索引位置**4**，我们可以看到有一个字符**a**，它是模式中第一个字符的重复，所以我们在这里分配值**1**，如下所示：
- en: '![](Images/58b14e31-38ce-4f51-b496-bdf83615502d.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/58b14e31-38ce-4f51-b496-bdf83615502d.png)'
- en: 'Next, we look at the next character at position **5**. It has the longest suffix
    pattern, **ab**, and so it would have a value of **2**, as shown in the following
    diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看索引位置**5**处的下一个字符。它有最长的后缀模式**ab**，因此它的值为**2**，如下图所示：
- en: '![](Images/cd0fc819-6318-4b89-926b-d283d072cd15.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cd0fc819-6318-4b89-926b-d283d072cd15.png)'
- en: 'Similarly, we look at the next index position of **6**. Here, the character
    is **b**. This character does not have the longest suffix in the pattern, so it
    has the value **0**. Next, we assign value **0** at index position **7**. Then,
    we look at the index position **8**, and we assign the value **1** as it has the
    longest suffix of length **1**. Finally, at the index position of **9**, we have
    the longest suffix of **2**:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们看下一个索引位置**6**。这里，字符是**b**。这个字符在模式中没有最长的后缀，所以它的值是**0**。接下来，我们在索引位置**7**处赋值**0**。然后，我们看索引位置**8**，并将值**1**分配给它，因为它有长度为**1**的最长后缀。最后，在索引位置**9**，我们有长度为**2**的最长后缀：
- en: '![](Images/04aa8d29-9b55-4e3f-9d39-f519846bc1c5.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/04aa8d29-9b55-4e3f-9d39-f519846bc1c5.png)'
- en: The value of the `prefix` function shows how much of the start of the string
    can be reused if there is a mismatch. For example, if the comparison fails at
    the index position of **5**, the `prefix` function value is **2**, which means
    that the two starting characters don't need to be compared.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefix`函数的值显示了如果不匹配，字符串的开头有多少可以重复使用。例如，如果在索引位置**5**处比较失败，`prefix`函数的值为**2**，这意味着不需要比较前两个字符。'
- en: Understanding KMP algorithms
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解KMP算法
- en: 'The KMP pattern matching algorithm uses a pattern that has overlap in the pattern
    itself so that it avoids unnecessary comparisons. The main idea behind the KMP
    algorithm is to detect how much the pattern should be shifted, based on the overlaps
    in the patterns. The algorithm works as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: KMP模式匹配算法使用具有模式本身重叠的模式，以避免不必要的比较。KMP算法的主要思想是根据模式中的重叠来检测模式应该移动多少。算法的工作原理如下：
- en: First, we precompute the `prefix` function for the given pattern and initialize
    a counter, q, that represents the number of characters that matched.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们为给定的模式预先计算`prefix`函数，并初始化一个表示匹配字符数的计数器q。
- en: We start by comparing the first character of the pattern with the first character
    of the text string, and if this matches, then we increment the counter, **q**,
    for the pattern and the counter for the text string, and we compare the next character.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从比较模式的第一个字符与文本字符串的第一个字符开始，如果匹配，则递增模式的计数器**q**和文本字符串的计数器，并比较下一个字符。
- en: If there is a mismatch, then we assign the value of the precomputed `prefix`
    function for **q** to the index value of **q**.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不匹配，我们将预先计算的`prefix`函数的值赋给**q**的索引值。
- en: We continue searching the pattern in the text string until we reach the end
    of the text, that is, if we do not find any matches. If all of the characters
    in the pattern are matched in the text string, we return the position where the
    pattern is matched in the text and continue to search for another match.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续在文本字符串中搜索模式，直到达到文本的末尾，即如果我们找不到任何匹配。如果模式中的所有字符都在文本字符串中匹配，我们返回模式在文本中匹配的位置，并继续搜索另一个匹配。
- en: 'Let''s consider the following example to understand this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例来理解这一点：
- en: 'The `prefix` function for the given pattern would be as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 给定模式的`prefix`函数如下：
- en: '![](Images/628b4eb1-1001-487f-9197-1dea713c5750.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/628b4eb1-1001-487f-9197-1dea713c5750.png)'
- en: Now, we start comparing the first character of the pattern with the first character
    of the text string and continue comparing it until we find a match. For example,
    in the following diagram, we start by comparing character **a **of the text string
    with the character **a** of the pattern. As it is matched, we continue comparing
    until we find a mismatch or we have compared the whole pattern. Here, we find
    a mismatch at index position **6**, so now we have to shift the pattern.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们开始比较模式的第一个字符与文本字符串的第一个字符，并继续比较，直到找到匹配。例如，在下图中，我们从比较文本字符串的字符**a**和模式的字符**a**开始。由于匹配，我们继续比较，直到找到不匹配或者我们已经比较了整个模式。在这里，我们在索引位置**6**找到了不匹配，所以现在我们必须移动模式。
- en: 'We find the number of shifts the pattern should take by using the help of the
    `prefix` function. This is because the `prefix` function has the value of **2**
    at the mismatch position (that is, `prefix_function(6)` is **2**), and so we start
    comparing the pattern from index position `2` of the pattern. Due to the efficiency
    of the KMP algorithm, we do not need to compare the character at **1** index position,
    and we compare the characters **c** of the pattern, and character **b** of the
    text. Since these do not match, we shift the pattern by **1** position, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`prefix`函数的帮助来找到模式应该移动的次数。这是因为在不匹配的位置（即`prefix_function(6)`为**2**）上，`prefix`函数的值为**2**，所以我们从模式的索引位置`2`开始比较模式。由于KMP算法的效率，我们不需要比较索引位置**1**的字符，我们比较模式的字符**c**和文本的字符**b**。由于它们不匹配，我们将模式向右移动**1**个位置，如下所示：
- en: '![](Images/b4b25215-9e10-4cd4-b815-12f07cb088ad.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b4b25215-9e10-4cd4-b815-12f07cb088ad.png)'
- en: 'Next, the compared characters are **b** and **a**—these do not match, so we
    shift the pattern by **1** distance. Next, we compare the pattern and text string
    and find a mismatch at index position 10 in the text between characters **b** and
    **c**.  Here, we use the precomputed `prefix` function to shift the pattern, as
    the `prefix_function(4)` is **2**, so we shift the at its index position of **2**,
    as shown in the following diagram:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们比较的字符是**b**和**a**——它们不匹配，所以我们将模式向右移动**1**个位置。接下来，我们比较模式和文本字符串，并在文本的索引位置10处找到字符**b**和**c**之间的不匹配。在这里，我们使用预先计算的“前缀”函数来移动模式，因为`prefix_function(4)`是**2**，所以我们将其移动到索引位置**2**，如下图所示：
- en: '![](Images/44d1fb23-e596-45c4-a474-374590b295a9.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/44d1fb23-e596-45c4-a474-374590b295a9.png)'
- en: 'After that, we shift the pattern by 1 location as there is a mismatch between
    characters **b **and **c**. Next, we compare the characters at index **11** in
    the text, and continue until a mismatch is found. We find a mismatch between characters **b** and
    **c**, as shown in the following diagram. We shift the pattern and move it to
    the index of `0` of the pattern as the `prefix_function(2)` is `0`. We repeat
    the same process until we reach the end of the string. We find a match of the
    pattern in the text string at the index location of **13** in the text string,
    as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，由于字符**b**和**c**不匹配，我们将模式向右移动1个位置。接下来，我们比较文本中索引为**11**的字符，直到找到不匹配为止。我们发现字符**b**和**c**不匹配，如下图所示。由于`prefix_function(2)`是`0`，我们将模式移动到模式的索引`0`。我们重复相同的过程，直到达到字符串的末尾。我们在文本字符串的索引位置**13**找到了模式的匹配，如下所示：
- en: '![](Images/bebe5024-3aff-4b76-8623-1c2681510c3d.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bebe5024-3aff-4b76-8623-1c2681510c3d.png)'
- en: The KMP algorithm has two phases, the preprocessing phase, which is where we compute the
    `prefix` function, It takes the space and time complexity of `O(m)` and further,
    in the second phase, that searching, the KMP algorithm takes time complexity of  `O(n)`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: KMP算法有两个阶段，预处理阶段，这是我们计算“前缀”函数的地方，它的空间和时间复杂度为`O(m)`，然后，在第二阶段，即搜索阶段，KMP算法的时间复杂度为`O(n)`。
- en: Now, we will discuss the implementation of the KMP algorithm by using Python.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论如何使用Python实现KMP算法。
- en: Implementing the KMP algorithm
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现KMP算法
- en: The Python implementation of the KMP algorithm is explained here. We start by
    implementing the `prefix` function for the given pattern. For this, first, we
    compute the length of the pattern by using the `len()` function, and then we initialize
    a list to store the computed values by the `prefix` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里解释了KMP算法的Python实现。我们首先为给定的模式实现“前缀”函数。为此，首先我们使用`len()`函数计算模式的长度，然后初始化一个列表来存储“前缀”函数计算出的值。
- en: Next, we start the loop that executes from 2 to the length of the pattern. Then,
    we have a nested loop that is executed until we have processed the whole pattern.
    The variable `k` is initialized to `0`, which is the `prefix` function for the
    first element of the pattern.  If the `k^(th)` element of the pattern is equal
    to the `q^(th)` element, then we increment the value of `k` by `1`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始执行循环，从2到模式的长度。然后，我们有一个嵌套循环，直到我们处理完整个模式为止。变量`k`初始化为`0`，这是模式的第一个元素的“前缀”函数。如果模式的第`k`个元素等于第`q`个元素，那么我们将`k`的值增加`1`。
- en: 'The value of k is the computed value by the `prefix` function, and so we assign
    it at the index position of the `q` of the pattern. Finally, we return the list
    of the `prefix` function that has the computed value for each character of the
    pattern. The code for the `prefix` function is shown as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: k的值是由“前缀”函数计算得出的值，因此我们将其分配给模式的`q`的索引位置。最后，我们返回具有模式每个字符的计算值的“前缀”函数列表。以下是“前缀”函数的代码：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once we have created the `prefix` function, we implement the main KMP matching
    algorithm. We start by computing the length of the text string and the pattern,
    which are stored in the variables `m` and `n`, respectively. The following code
    shows this in detail:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了“前缀”函数，我们就实现了主要的KMP匹配算法。我们首先计算文本字符串和模式的长度，它们分别存储在变量`m`和`n`中。以下代码详细显示了这一点：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Boyer-Moore algorithm
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boyer-Moore算法
- en: As we have already discussed, the main objective of the string pattern matching
    algorithm is to find ways of skipping comparisons as much as possible by avoiding
    unnecessary comparisons.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，字符串模式匹配算法的主要目标是通过避免不必要的比较来尽可能地跳过比较。
- en: 'The Boyer-Moore pattern matching algorithm is another such algorithm (apart
    from the KMP algorithm) that further improves the performance of pattern matching
    by skipping some comparisons using some methods. You need to understand the following
    concepts to be able to use the Boyer-Moore algorithm:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Boyer-Moore模式匹配算法是另一种这样的算法（除了KMP算法），它通过使用一些方法跳过一些比较来进一步提高模式匹配的性能。您需要理解以下概念才能使用Boyer-Moore算法：
- en: In this algorithm, we shift the pattern in the direction from left to right,
    similar to the KMP algorithm
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个算法中，我们将模式从左向右移动，类似于KMP算法
- en: We compare the characters of the pattern and the text string from the right
    to the left direction, which is the opposite of the KMP algorithm
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从右向左比较模式和文本字符串的字符，这与KMP算法相反
- en: The algorithm skips the unnecessary comparisons by using the good-suffix and
    bad-character shifts concept
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该算法通过使用好后缀和坏字符移位的概念来跳过不必要的比较
- en: Understanding the Boyer-Moore algorithm
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Boyer-Moore算法
- en: The Boyer-Moore algorithm compares the pattern over the text from right to left.
    It uses the information of the various possible alignments in the pattern by preprocessing
    it. The main idea of this algorithm is that we compare the end characters of the
    pattern with the text. If they do not match, then the pattern can be moved on
    further. If the characters do not match in the end, there is no need to do further
    comparisons. In addition, in this algorithm, we can also see what portion of the
    pattern has matched (with the matched suffix), so we utilize this information
    and align the text and pattern by skipping any unnecessary comparisons.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Boyer-Moore算法从右到左比较文本上的模式。它通过预处理模式来使用模式中各种可能的对齐信息。这个算法的主要思想是我们将模式的末尾字符与文本进行比较。如果它们不匹配，那么模式可以继续移动。如果末尾的字符不匹配，就没有必要进行进一步的比较。此外，在这个算法中，我们还可以看到模式的哪一部分已经匹配（与匹配的后缀），因此我们利用这个信息，通过跳过任何不必要的比较来对齐文本和模式。
- en: 'The Boyer-Moore algorithm has two heuristics to determine the maximum shift
    possible for the pattern when we find a mismatch:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们发现不匹配时，Boyer-Moore算法有两个启发式来确定模式的最大可能移位：
- en: Bad character heuristic
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坏字符启发式
- en: Good suffix heuristic
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好后缀启发式
- en: At the time of a mismatch, each of these heuristics suggests possible shifts,
    and the Boyer-Moore algorithm shifts the pattern by considering the maximum shift
    possible due to bad character and good suffix heuristics. The details of the bad
    character and good suffix heuristics are explained in detail with examples in
    the following subsections.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在不匹配时，每个启发式都建议可能的移位，而Boyer-Moore算法通过考虑由于坏字符和好后缀启发式可能的最大移位来移动模式。坏字符和好后缀启发式的详细信息将在以下子节中通过示例详细解释。
- en: Bad character heuristic
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坏字符启发式
- en: The Boyer-Moore algorithm compares the pattern and the text string in the direction
    from right to left. It uses the bad character heuristic to shift the pattern.
    According to the bad character shift concept, if there is a mismatch between the
    character of the pattern and the text, then we check if the mismatched character
    of the text occurs in the pattern or not. If this mismatched character (also known
    as a bad character) does not appear in the pattern, then the pattern will be shifted
    next to this character, and if that character appears somewhere in the pattern, 
    we shift the pattern to align with the occurrence of that character with the bad
    character of the text string.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Boyer-Moore算法将模式和文本字符串从右到左进行比较。它使用坏字符启发式来移动模式。根据坏字符移位的概念，如果模式的字符与文本不匹配，那么我们检查文本的不匹配字符是否出现在模式中。如果这个不匹配的字符（也称为坏字符）不出现在模式中，那么模式将被移动到这个字符的旁边，如果该字符在模式中的某处出现，我们将模式移动到与文本字符串的坏字符对齐的位置。
- en: 'Let''s understand this concept by using an example. Consider a text string
    (T) and the pattern = {**acacac**}. We start by comparing the characters from
    right to left, that is, character **b** of the text string and character **c** of
    the pattern. They do not match, so we look for the mismatched character of the
    text string, that is, **b**, in the pattern. Since it does not occur in the pattern,
    we shift the pattern next to the mismatched character, as shown in the following
    diagram:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解这个概念。考虑一个文本字符串（T）和模式={**acacac**}。我们从右到左比较字符，即文本字符串的字符**b**和模式的字符**c**。它们不匹配，所以我们在模式中寻找文本字符串的不匹配字符**b**。由于它不在模式中出现，我们将模式移动到不匹配的字符旁边，如下图所示：
- en: '![](Images/cc298adf-fb27-4d70-9f29-5148bc40d532.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/cc298adf-fb27-4d70-9f29-5148bc40d532.png)'
- en: 'Let''s look at another example. We start by comparing characters of the text
    string and the pattern from right to the left, and we get a mismatch for the character
    **d** of the text. Here, the suffix **ac** is matched, but the characters **d**
    and **c** do not match, and the mismatched character **d** does not occur in the
    pattern. Therefore, we shift the pattern to the mismatched character, as shown
    in the following diagram:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。我们从右到左比较文本字符串和模式的字符，对于文本的字符**d**，我们得到了不匹配。在这里，后缀**ac**是匹配的，但是字符**d**和**c**不匹配，不匹配的字符**d**不在模式中出现。因此，我们将模式移动到不匹配的字符旁边，如下图所示：
- en: '![](Images/9fc8421b-9ed9-4282-bf63-522846e13eb9.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9fc8421b-9ed9-4282-bf63-522846e13eb9.png)'
- en: Let's consider another example case for the bad character heuristic. Here, the
    suffix **ac **is matched, but the next characters, **a** and **c**, do not match,
    so we search for the occurrences of the mismatched character **a** in the pattern.
    Since it has two occurrences in the pattern, we have two options so that we can
    align the mismatched character, as shown in the following diagram. In such a situation,
    where we have more than one option to shift the pattern, we move the pattern with
    the minimum amount of shifts to avoid any possible match. (In other words, it
    would be the rightmost occurrence of that character in the pattern.) If we would
    have only one occurrence of the mismatched character in the pattern, we can easily
    shift the pattern in such a way that the mismatched character is aligned.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑坏字符启发式的另一个例子。在这里，后缀**ac**是匹配的，但是接下来的字符**a**和**c**不匹配，因此我们在模式中搜索不匹配的字符**a**的出现。由于它在模式中出现了两次，我们有两个选项来对齐不匹配的字符，如下图所示。在这种情况下，我们有多个选项来移动模式，我们移动模式的最小次数以避免任何可能的匹配。（换句话说，它将是模式中该字符的最右出现位置。）如果模式中只有一个不匹配的字符的出现，我们可以轻松地移动模式，使不匹配的字符对齐。
- en: 'In the following example, we would prefer option **1** to shift the pattern:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们更喜欢选项**1**来移动模式：
- en: '![](Images/284beb26-731a-441f-a1c3-2eb800c011c1.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/284beb26-731a-441f-a1c3-2eb800c011c1.png)'
- en: Good suffix heuristic
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好后缀启发式
- en: The bad character heuristic does not always provide good suggestions. The Boyer-Moore
    algorithm also uses good suffix heuristic as well to shift the pattern over the
    text string to find out the location of the matched patterns.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 坏字符启发式并不总是提供良好的建议。Boyer-Moore算法还使用好后缀启发式来将模式移位到文本字符串上，以找出匹配模式的位置。
- en: 'Good suffix heuristic is based on the matched suffix. Here, we shift the pattern
    to the right in such a way that the matched suffix subpattern is aligned with
    another occurrence of the same suffix in the pattern. It works like this: we start
    by comparing the pattern and the text string from right to left. If we find any
    mismatch, then we check the occurrence of the suffix that we have matched so far.
    This is known as the good suffix. We shift the pattern in such a way that we align
    another occurrence of the good suffix to the text. Good suffix heuristic has mainly
    two cases:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 好后缀启发式是基于匹配的后缀。在这里，我们将模式向右移动，以使匹配的后缀子模式与模式中另一个相同后缀的出现对齐。它的工作原理是：我们从右到左开始比较模式和文本字符串。如果我们找到任何不匹配，那么我们检查到目前为止已经匹配的后缀的出现。这被称为好后缀。我们以这样的方式移动模式，以便将好后缀的另一个出现对齐到文本上。好后缀启发式主要有两种情况：
- en: The matching suffix has one or more occurrences in the pattern.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配的后缀在模式中有一个或多个出现。
- en: Some part of the matching suffix is present in the start of the pattern (this
    means that the suffix of the matched suffix exists as the prefix of the pattern).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配后缀的某部分存在于模式的开头（这意味着匹配后缀的后缀存在于模式的前缀中）。
- en: 'Let''s understand these cases with the following examples. Suppose we have
    a pattern, **acabac**. We get a mismatch for the characters **a** and **b**, but
    at this moment in time, we have already matched the suffix, that is, **ac**. Now,
    we search for another occurrence of the good suffix **ac** in the pattern and
    we shift the pattern by aligning that suffix, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例了解这些情况。假设我们有一个模式**acabac**。我们对字符**a**和**b**进行不匹配，但此时，我们已经匹配了后缀，即**ac**。现在，我们在模式中搜索好后缀**ac**的另一个出现，并通过对齐后缀来移动模式，如下所示：
- en: '![](Images/19965040-07c0-4fc5-84d1-a785c3b25d1c.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/19965040-07c0-4fc5-84d1-a785c3b25d1c.png)'
- en: 'Let''s consider another example, where we have two options to align the shift
    of the pattern so that we get two good suffix strings. Here, we will take the
    option **1** to align the good suffix by considering the option that has the minimum
    shifts, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子，我们有两个选项来对齐模式的移位，以便获得两个好后缀字符串。在这里，我们将选择**1**来通过考虑具有最小移位的选项来对齐好后缀，如下所示：
- en: '![](Images/467f95d8-927f-44e1-9ff8-dc722ba839ae.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/467f95d8-927f-44e1-9ff8-dc722ba839ae.png)'
- en: 'Let''s take a look at another example. Here, we get a suffix match of **aac**,
    but we get a mismatch for the characters **b** and **a**.  We search for the good
    suffix **aac**, but we do not find another occurrence in the pattern. However,
    we find that the prefix, **ac**, at the start of the pattern does not match with
    the whole suffix, but it does match with the suffix **ac** of the matched suffix
    **aac**. In such a situation, we shift the pattern by aligning with the suffix
    of **aac** that is also a prefix of the pattern and align that prefix with the
    suffix, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个例子。在这里，我们得到了**aac**的后缀匹配，但对于字符**b**和**a**，我们得到了不匹配。我们搜索好后缀**aac**，但在模式中找不到另一个出现。但是，我们发现模式开头的前缀**ac**与整个后缀不匹配，但与匹配后缀**aac**的后缀**ac**匹配。在这种情况下，我们通过将模式与后缀对齐来移动模式，如下所示：
- en: '![](Images/323ab0d1-b503-42f7-ab66-aa97a9fc0299.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/323ab0d1-b503-42f7-ab66-aa97a9fc0299.png)'
- en: 'Another case for the good suffix heuristic is as follows. In this case, we
    match the suffix **aac**, but we mismatch it at characters **b** and **a**. We
    try to search for the matched suffix in the pattern, but there is no occurrence
    of the suffix in the pattern, so in this situation, we shift the pattern after
    the matched suffix, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好后缀启发式的案例如下。在这种情况下，我们匹配后缀**aac**，但在字符**b**和**a**处不匹配。我们尝试在模式中搜索匹配的后缀，但在模式中没有后缀的出现，所以在这种情况下，我们将模式移位到匹配的后缀之后，如下所示：
- en: '![](Images/e84ff37e-2ddd-4ece-9883-2011cd8531ed.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e84ff37e-2ddd-4ece-9883-2011cd8531ed.png)'
- en: We shift the pattern by the longer distance that is given by the bad character
    heuristics and the good suffix heuristics.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过坏字符启发式和好后缀启发式给出的更长距离来移动模式。
- en: The Boyer-Moore algorithm takes the time of `O(m)` for the preprocessing of
    the pattern, and further searching takes the time complexity of `O(mn)`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Boyer-Moore算法在模式的预处理中需要`O(m)`的时间，进一步搜索需要`O(mn)`的时间复杂度。
- en: Implementing the Boyer-Moore algorithm
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Boyer-Moore算法
- en: Let's understand the implementation of the Boyer-Moore algorithm. Initially,
    we have the text string and the pattern. After initializing the variables, we
    start with a while loop that starts by comparing the last character of the pattern
    to the corresponding character of the text.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解Boyer-Moore算法的实现。最初，我们有文本字符串和模式。在初始化变量之后，我们开始使用while循环，该循环从模式的最后一个字符开始与文本的相应字符进行比较。
- en: Then, the characters are compared from right to left by the use of the nested
    loop from the last index of the pattern to the first character of the pattern.
    This uses `range(len(pattern)-1, -1, -1)`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过使用嵌套循环从模式的最后一个索引到模式的第一个字符，从右到左比较字符。这使用`range(len(pattern)-1, -1, -1)`。
- en: The outer while loop keeps tracks of the index in the text string while the
    inner for loop keeps track of the index position in the pattern.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 外部while循环跟踪文本字符串中的索引，而内部for循环跟踪模式中的索引位置。
- en: Next, we start comparing the characters by using `pattern[j] != text[i+j]`.
    If they are mismatched, we make the flag variable `False`, denoting that there
    is a mismatch.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始使用`pattern[j] != text[i+j]`来比较字符。如果它们不匹配，我们将使标志变量`False`，表示存在不匹配。
- en: Now, we check if the good suffix is present or not by using the condition `j
    == len(pattern)-1`. If this condition is true, it means that there is no good
    suffix possible, so we check for the bad character heuristics, that is, if a mismatched
    character is present in the pattern or isn't using the condition `text[i+j] in
    pattern[0:j]`, and if the condition is true, then it means that the bad character
    is present in the pattern. In this case, we move the pattern to align this bad
    character to the other occurrence of this character in the pattern by using `i=i+j-pattern[0:j].rfind(text[i+j])`.
    Here, `(i+j)` is the index of the bad character.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过使用条件`j == len(pattern)-1`来检查好后缀是否存在。如果这个条件为真，意味着没有可能的好后缀，所以我们检查坏字符启发式，即如果模式中存在或不存在不匹配的字符，使用条件`text[i+j]
    in pattern[0:j]`，如果条件为真，则意味着坏字符存在于模式中。在这种情况下，我们使用`i=i+j-pattern[0:j].rfind(text[i+j])`将模式移动到与模式中此字符的其他出现对齐。这里，`(i+j)`是坏字符的索引。
- en: If the bad character is not present in the pattern (it isn't in the `else` part
    of it), we move the whole pattern next to the mismatched character by using the
    index `i=i+j+1`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果坏字符不在模式中（它不在`else`部分），我们使用索引`i=i+j+1`将整个模式移动到不匹配的字符旁边。
- en: 'Next, we go into the `else` part of the condition to check the good suffix.
    When we find the mismatch, we further test to see whether we have any subpart
    of a good suffix present in the prefix of the pattern. We do this by using the
    following condition:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进入条件的`else`部分，检查好后缀。当我们发现不匹配时，我们进一步测试，看看我们的模式前缀中是否有任何好后缀的子部分。我们通过使用以下条件来做到这一点：
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Furthermore, we check whether the length of the good suffix is `1` or not. If
    the length of the good suffix is `1`, we do not consider this shift. If the good
    suffix is more than `1`, we find out the number of shifts by using the good suffix
    heuristics and store this in the `gsshift` variable. This is the pattern to a
    position where the good suffix of a pattern matches with the good suffix of text
    using the instruction `gsshift=i+j+k-pattern[0:len(pattern)-1].rfind(text[i+j+k:i+len(pattern)])`.
    Furthermore, we computed the number of shifts possible due to the bad character
    heuristic and stored this in the `bcshift` variable. The number of shifts possible
    is `i+j-pattern[0:j].rfind(text[i+j])` when the bad character is present in the
    pattern, and the number of shifts possible would be `i+j+1` in the case of the
    bad character not being present in the pattern.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们检查好后缀的长度是否为`1`。如果好后缀的长度为`1`，我们不考虑这个移动。如果好后缀大于`1`，我们通过好后缀启发式找出移动次数，并将其存储在`gsshift`变量中。这是将模式移动到与文本的好后缀匹配的位置的指令。此外，我们计算由于坏字符启发式可能的移动次数，并将其存储在`bcshift`变量中。当坏字符存在于模式中时，可能的移动次数是`i+j-pattern[0:j].rfind(text[i+j])`，当坏字符不在模式中时，可能的移动次数将是`i+j+1`。
- en: Next, we shift the pattern on the text string by the maximum number of moves
    given by a bad character and good suffix heuristics by using the instruction `i=max((bcshift,
    gsshift))`. Finally, we check whether the flag variable is `True` or not. If it
    is `True`, this means that the pattern has been found and that the matched index
    has been stored in the `matched_indexes` variable.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用坏字符和好后缀启发式的最大移动次数将模式移动到文本字符串上。最后，我们检查标志变量是否为`True`。如果为`True`，这意味着找到了模式，并且匹配的索引已存储在`matched_indexes`变量中。
- en: 'The complete implementation of the Boyer-Moore algorithm is shown as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Boyer-Moore算法的完整实现如下所示：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have discussed the most popular and important string processing
    algorithms that have wide applications in real-time scenarios. We started this
    chapter by looking at the basic concepts and definitions related to strings. Next,
    we described the brute-force, Rabin-Karp, KMP, and Boyer-Moore pattern matching
    algorithms in detail for pattern matching problems. We have seen that the brute-force
    pattern matching algorithm is quite slow as it compared the characters of the
    pattern and the text string character by character.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经讨论了在实时场景中具有广泛应用的最流行和重要的字符串处理算法。我们从查看与字符串相关的基本概念和定义开始了本章。接下来，我们详细描述了用于模式匹配问题的暴力、Rabin-Karp、KMP和Boyer-Moore模式匹配算法。我们已经看到，暴力模式匹配算法非常慢，因为它逐个比较模式和文本字符串的字符。
- en: In pattern matching algorithms, we try to find out ways to skip unnecessary
    comparisons and move the pattern over the text as fast as possible to quickly
    find out the positions of the matched patterns. The KMP algorithm finds out the
    unnecessary comparisons by looking at the overlapping substrings in the pattern
    itself to avoid unimportant comparisons. Furthermore, we discussed the Boyer-Moore
    algorithm, which is very efficient when the text and pattern are long. It is the
    most popular algorithm that is being used in practice for pattern matching.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式匹配算法中，我们试图找到跳过不必要比较的方法，并尽快将模式移动到文本上，以快速找到匹配模式的位置。KMP算法通过查看模式本身中的重叠子字符串来找出不必要的比较，以避免不重要的比较。此外，我们讨论了Boyer-Moore算法，在文本和模式很长时非常高效。这是实践中使用的最流行的模式匹配算法。
- en: In the next chapter, we will be discussing data structure design strategies
    and techniques in more detail.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地讨论数据结构设计策略和技术。
