- en: Creating 3D Graphics with QtOpenGL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QtOpenGL创建3D图形
- en: From games to data visualizations to engineering simulations, 3D graphics and
    animations are at the heart of many important software applications. For several
    decades, the de facto standard **Application Programming Interface** (**API**)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从游戏到数据可视化到工程模拟，3D图形和动画是许多重要软件应用的核心。几十年来，事实上的**应用程序编程接口**（**API**）标准一直是OpenGL。
- en: for cross-platform 3D graphics has been OpenGL. Although many Python and C implementations
    of the API exist, Qt offers one that is directly integrated into its widgets,
    giving us the capability to embed interactive OpenGL graphics and animations in
    our GUI.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 用于跨平台3D图形的API一直是OpenGL。尽管存在许多Python和C的API实现，Qt提供了一个直接集成到其小部件中的API，使我们能够在GUI中嵌入交互式的OpenGL图形和动画。
- en: 'In this chapter, we''ll take a look at those capabilities in the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在以下主题中探讨这些功能：
- en: The basics of OpenGL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL的基础知识
- en: Embedding OpenGL drawings with `QOpenGLWidget`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`QOpenGLWidget`嵌入OpenGL绘图
- en: Animating and controlling OpenGL drawings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画和控制OpenGL绘图
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll need a basic Python 3 and PyQt5 setup, as we've been
    using throughout the book, and you might like to download the example code from
    [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter13](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter13).
    You will also need to make sure that your graphics hardware and drivers support
    OpenGL 2.0 or higher, although this is almost certainly true if you are using
    a conventional desktop or laptop computer made within the last ten years.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要一个基本的Python 3和PyQt5设置，就像我们在整本书中一直在使用的那样，并且你可能想从[https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter13](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter13)下载示例代码。你还需要确保你的图形硬件和驱动程序支持OpenGL
    2.0或更高版本，尽管如果你使用的是过去十年内制造的传统台式机或笔记本电脑，这几乎肯定是真的。
- en: Check out the following video to see the code in action: [http://bit.ly/2M5xApP](http://bit.ly/2M5xApP)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，看看代码是如何运行的：[http://bit.ly/2M5xApP](http://bit.ly/2M5xApP)
- en: The basics of OpenGL
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL的基础知识
- en: OpenGL is not simply a library; it is a **specification** for an API to interact
    with your graphics hardware. The implementation of this specification is shared
    between your graphics hardware, the drivers for that hardware, and the OpenGL
    software library you choose to use. As a result, the exact behavior of your OpenGL-based
    code might be slightly different depending on any of those factors, just as, for
    example, the same HTML code might be slightly differently rendered in different
    web browsers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL不仅仅是一个库；它是一个与图形硬件交互的API的**规范**。这个规范的实现是由你的图形硬件、该硬件的驱动程序和你选择使用的OpenGL软件库共享的。因此，你的基于OpenGL的代码的确切行为可能会因其中任何一个因素而略有不同，就像同样的HTML代码在不同的网络浏览器中可能会稍有不同地呈现一样。
- en: OpenGL is also a **versioned** specification, meaning that the available features
    and recommended usage of OpenGL changes depending on which version of the specification
    you're targeting. As new features are introduced and old features deprecated,
    the best practices and recommendations also evolve, so that code written for OpenGL
    2.x systems may look nothing at all like a code written for OpenGL 4.x.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL也是一个**有版本的**规范，这意味着OpenGL的可用功能和推荐用法会随着你所针对的规范版本的不同而改变。随着新功能的引入和旧功能的废弃，最佳实践和建议也在不断发展，因此为OpenGL
    2.x系统编写的代码可能看起来完全不像为OpenGL 4.x编写的代码。
- en: The OpenGL specification is managed by the Khronos Group, an industry consortium
    that maintains several graphics-related standards. The latest specification at
    the time of writing is 4.6, released in February 2019, which can be found at [https://www.khronos.org/registry/OpenGL/index_gl.php](https://www.khronos.org/registry/OpenGL/index_gl.php).
    However, it's not always a good idea to follow the latest specification. A computer's
    ability to run an OpenGL code of a given version is limited by hardware, driver,
    and platform considerations, so if you want your code to be run by the widest
    possible array of users, it's better to target an older and more established version.
    Many common embedded graphics chips from Intel only support OpenGL 3.x or lower,
    and some low-end devices, such as the Raspberry Pi (which we'll look at in [Chapter
    15](77583d1b-8a70-4118-8210-b0a5f09c9603.xhtml), *PyQt on the Raspberry Pi*) only
    support 2.x.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL规范由Khronos Group管理，这是一个维护多个与图形相关的标准的行业联盟。撰写本文时的最新规范是4.6，发布于2019年2月，可以在[https://www.khronos.org/registry/OpenGL/index_gl.php](https://www.khronos.org/registry/OpenGL/index_gl.php)找到。然而，并不总是跟随最新规范是一个好主意。计算机运行给定版本的OpenGL代码的能力受到硬件、驱动程序和平台考虑的限制，因此，如果你希望你的代码能够被尽可能广泛的用户运行，最好是针对一个更旧和更成熟的版本。许多常见的嵌入式图形芯片只支持OpenGL
    3.x或更低版本，一些低端设备，如树莓派（我们将在[第15章](77583d1b-8a70-4118-8210-b0a5f09c9603.xhtml)，*树莓派上的PyQt*中看到）只支持2.x。
- en: In this chapter, we'll limit our code to OpenGL 2.1, since it is well supported
    by PyQt and most modern computers should be able to run it. However, since we're
    going to be sticking to the basics, everything we'll learn applies equally well
    to the 4.x version.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将限制我们的代码在OpenGL 2.1，因为它得到了PyQt的良好支持，大多数现代计算机应该能够运行它。然而，由于我们将坚持基础知识，我们所学到的一切同样适用于4.x版本。
- en: The rendering pipeline and drawing basics
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染管线和绘图基础知识
- en: Turning code and data into pixels on a screen requires a multi-stage process;
    in OpenGL, this process is known as the **rendering pipeline.** Some stages in
    this pipeline are programmable, while others are fixed-function, meaning that
    their behavior is predetermined by the OpenGL implementation and cannot be altered.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码和数据转化为屏幕上的像素需要一个多阶段的过程；在OpenGL中，这个过程被称为**渲染管线。** 这个管线中的一些阶段是可编程的，而其他的是固定功能的，意味着它们的行为是由OpenGL实现预先确定的，不能被改变。
- en: 'Let''s walk through the major stages of this pipeline from start to finish:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从头到尾走一遍这个管道的主要阶段：
- en: '**Vertex specification**: In the first stage, the **vertices** of the drawing
    are determined by your application. A **vertex** is essentially a point in a 3D space
    that can be used to draw a shape. The vertex may also contain metadata about the
    point, such as its color.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**顶点规范**：在第一个阶段，绘图的**顶点**由您的应用程序确定。**顶点**本质上是3D空间中的一个点，可以用来绘制形状。顶点还可以包含关于点的元数据，比如它的颜色。'
- en: '**Vertex processing**: This user-definable stage processes each vertex in various
    ways to calculate the final position of each vertex; for example, in this step
    you might rotate or move the basic shape defined in the vertex specification.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**顶点处理**：这个可用户定义的阶段以各种方式处理每个顶点，计算每个顶点的最终位置；例如，在这一步中，您可能会旋转或移动顶点规范中定义的基本形状。'
- en: '**Vertex post-processing**: This fixed-function stage does some additional
    processing on the vertices, such as clipping sections that fall outside the viewing
    space.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**顶点后处理**：这个固定功能阶段对顶点进行一些额外的处理，比如裁剪超出视图空间的部分。'
- en: '**Primitive assembly**: In this stage, vertices are composed into primitives. A
    primitive is a 2D shape, such as a triangle or rectangle, from which more complex
    3D shapes are built.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**基元组装**：在这个阶段，顶点被组合成基元。一个基元是一个2D形状，比如三角形或矩形，从中可以构建更复杂的3D形状。'
- en: '**Rasterization**: This stage transforms the primitives into a series of individual
    pixel points, called fragments, by interpolating between the vertices.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**光栅化**：这个阶段将基本图元转换为一系列单独的像素点，称为片段，通过在顶点之间进行插值。'
- en: '**Fragment shading**: The main job of this user-defined stage is to determine
    the depth and color value for each fragment.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**片段着色**：这个用户定义阶段的主要工作是确定每个片段的深度和颜色值。'
- en: '**Per-sample operations**: This final stage performs a series of tests on each
    fragment to determine its final visibility and color.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**逐样本操作**：这个最后阶段对每个片段执行一系列测试，以确定其最终的可见性和颜色。'
- en: As programmers using OpenGL, we are mostly concerned with just three stages
    of this operation – the vertex specification, the vertex processing, and the fragment
    shading. For the vertex specification, we will simply define some points in Python
    code to describe a shape for OpenGL to draw; for the other two stages, we will
    need to learn about creating OpenGL programs and shaders.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用OpenGL的程序员，我们主要关注这个操作的三个阶段 - 顶点规范、顶点处理和片段着色。对于顶点规范，我们将简单地在Python代码中定义一些点来描述OpenGL绘制的形状；对于其他两个阶段，我们需要学习如何创建OpenGL程序和着色器。
- en: Programs and shaders
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序和着色器
- en: Despite the name, a **shader** has nothing to do with shadows or shading; it
    is simply the name for a unit of code that runs on your GPU. In the previous section,
    we talked about some stages of the rendering pipeline being user-definable; in
    fact, some of them *must* be defined, as most OpenGL implementations do not provide
    default behavior for certain stages. To define those stages, we need to write
    a shader.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管名字上是着色器，但它与阴影或着色无关；它只是在GPU上运行的代码单元的名称。在前一节中，我们谈到了渲染管线的一些阶段是可用户定义的；事实上，其中一些*必须*被定义，因为大多数OpenGL实现不为某些阶段提供默认行为。为了定义这些阶段，我们需要编写一个着色器。
- en: 'At a minimum, we need to define two shaders:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，我们需要定义两个着色器：
- en: '**The** **vertex shader:** This shader is the first step of the vertex processing
    stage. Its main job is to determine the spatial coordinates of each vertex.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点着色器**：这个着色器是顶点处理阶段的第一步。它的主要工作是确定每个顶点的空间坐标。'
- en: '**The** **fragment shader:** This is the second-to-last stage of the pipeline,
    and its only required job is to determine the color of an individual fragment.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片段着色器**：这是管线倒数第二个阶段，它唯一的必要工作是确定单个片段的颜色。'
- en: When we have a collection of shaders that comprise a complete render pipeline,
    this is called a program.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一组着色器组成完整的渲染管线时，这被称为一个程序。
- en: Shaders cannot be written in Python. They must be written in a language called
    **GL Shader Language** (**GLSL**), a C-like language that is part of the OpenGL
    specification. It's impossible to create serious OpenGL drawings without some
    knowledge of GLSL, but fortunately, it is simple enough to write a fairly rudimentary
    set of shaders good enough for a basic example.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器不能用Python编写。它们必须用一种叫做**GL着色语言**（**GLSL**）的语言编写，这是OpenGL规范的一部分的类似C的语言。没有GLSL的知识，就不可能创建严肃的OpenGL绘图，但幸运的是，写一组足够简单的着色器对于基本示例来说是相当简单的。
- en: A simple vertex shader
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的顶点着色器
- en: 'We''re going to compose a simple GLSL vertex shader that we can use for our
    demo; create a file called `vertex_shader.glsl`, and copy in the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组成一个简单的GLSL顶点着色器，我们可以用于我们的演示；创建一个名为`vertex_shader.glsl`的文件，并复制以下代码：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We've begun with a comment indicating the version of GLSL we are using. This
    is important, as each version of OpenGL is only compatible with a particular version
    of GLSL, and the GLSL compiler will use this comment to check whether we've mismatched
    those versions.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个注释开始，指明我们正在使用的GLSL版本。这很重要，因为每个OpenGL版本只兼容特定版本的GLSL，GLSL编译器将使用这个注释来检查我们是否不匹配这些版本。
- en: A chart showing compatibility between versions of GLSL and OpenGL can be found
    at [https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)](https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://www.khronos.org/opengl/wiki/Core_Language_(GLSL)](https://www.khronos.org/opengl/wiki/Core_Language_(GLSL))找到GLSL和OpenGL版本之间的兼容性图表。
- en: 'Next, we will need to make some **variable declarations**:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要进行一些**变量声明**：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In C-like languages, variable declarations are used to create the variable,
    define various attributes about it, and allocate space for it in memory. Each
    of our declarations has four tokens; let''s go through these in order:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似C的语言中，变量声明用于创建变量，定义关于它的各种属性，并在内存中分配空间。我们的每个声明有四个标记；让我们按顺序来看一下这些：
- en: The first token is one of `attribute`, `uniform`, or `varying`. This indicates
    whether the variable will be distinct for each vertex (`attribute`), each primitive
    (`uniform`), or each fragment (`varying`). So, our first variable will be different
    for each vertex, but our second one will be the same for each vertex within the
    same primitive.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个标记是`attribute`，`uniform`或`varying`中的一个。这表明变量将分别用于每个顶点（`attribute`），每个基本图元（`uniform`）或每个片段（`varying`）。因此，我们的第一个变量将对每个顶点都不同，但我们的第二个变量将对同一基本图元中的每个顶点都相同。
- en: The second token indicates the basic data type that the variable contains. In
    this case, it's either `highp` (a high-precision number), `mediump` (a medium-precision
    number), or `lowp` (a low-precision number). We could have used `float` or `double`
    here, but these aliases are helpful in making our code cross-platform.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个标记指示变量包含的基本数据类型。在这种情况下，它可以是`highp`（高精度数字），`mediump`（中等精度数字）或`lowp`（低精度数字）。我们可以在这里使用`float`或`double`，但这些别名有助于使我们的代码跨平台。
- en: The third term defines each of these variables as pointing to either a **vector**
    or a matrix. You can think of a vector like a Python `list` object, and a matrix
    like a `list` object where each item is a `list` object of the same length. The
    number at the end indicates the size, so `vec4` is a list of four values, and
    `mat4` is a 4x4 matrix of values.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个术语定义了这些变量中的每一个是指向**向量**还是矩阵。你可以将向量看作是Python的`list`对象，将矩阵看作是一个每个项目都是相同长度的`list`对象的`list`对象。末尾的数字表示大小，所以`vec4`是一个包含四个值的列表，`mat4`是一个4x4值的矩阵。
- en: The last token is the variable name. These names will be used through the entire
    program so we can use them in shaders further down the pipeline to access data
    from earlier shaders.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个标记是变量名。这些名称将在整个程序中使用，因此我们可以在管道中更深的着色器中使用它们来访问来自先前着色器的数据。
- en: These variables can be used to insert data into the program or pass data to
    other shaders in the program. We'll see how to do that later in this chapter,
    but for now, understand that, in our shader, `vertex`, `matrix`, and `color_attr`
    represent data that will be received by the vertex shader from our PyQt application.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量可以用来将数据插入程序或将数据传递给程序中的其他着色器。我们将在本章后面看到如何做到这一点，但现在要明白，在我们的着色器中，`vertex`，`matrix`和`color_attr`代表着将从我们的PyQt应用程序接收到的数据。
- en: 'After the variable declarations, we will create a function called `main()`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量声明之后，我们将创建一个名为`main()`的函数：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The primary purpose of the `vertex` shader is to set a variable called `gl_Position`
    with the coordinates of the `vertex`. In this case, we're setting it to our `vertex`
    value passed into the shader multiplied by the `matrix` value. As you'll see later,
    this arrangement will allow us to manipulate our drawing in space.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`vertex`着色器的主要目的是使用`vertex`的坐标设置一个名为`gl_Position`的变量。在这种情况下，我们将其设置为传入着色器的`vertex`值乘以`matrix`值。正如你将在后面看到的，这种安排将允许我们在空间中操作我们的绘图。'
- en: Matrices and vectors are critical mathematical concepts to understand when creating
    3D graphics. While we will remain mostly abstracted from the details of this math
    in this chapter, it's a good idea to brush up on these concepts if you want to
    dive deeper into OpenGL programming.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建3D图形时，矩阵和向量是关键的数学概念。虽然在本章中我们将大部分时间都从这些数学细节中抽象出来，但如果你想深入学习OpenGL编程，了解这些概念是个好主意。
- en: The last line of code in our shader may seem somewhat pointless, but it allows
    us to specify a color for each vertex in the vertex specification stage and have
    that color passed along to other shaders later in the pipeline. Variables in a
    shader are either input or output variables, meaning that they expect to receive
    data from the previous stage of the pipeline or pass data along to the next stages.
    Within the vertex shader, declaring a variable with the `attribute` or `uniform`
    qualifiers implicitly marks a variable as an input variable, while declaring it
    with the `varying` qualifier implicitly marks it as an output variable. Thus,
    we are copying the value of our `attribute`-type `color_attr` variable to the
    `varying`-type `color` variable in order to pass the value to shaders further
    down the pipeline; specifically, we want to pass it to the `fragment` shader.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们着色器中的最后一行代码可能看起来有点无意义，但它允许我们在顶点规范阶段为每个顶点指定一个颜色，并将该颜色传递给管道中的其他着色器。着色器中的变量要么是输入变量，要么是输出变量，这意味着它们期望从管道的前一个阶段接收数据，或者将数据传递给下一个阶段。在顶点着色器中，使用`attribute`或`uniform`限定符声明变量会将变量隐式标记为输入变量，而使用`varying`限定符声明变量会将其隐式标记为输出变量。因此，我们将`attribute`类型的`color_attr`变量的值复制到`varying`类型的`color`变量中，以便将该值传递给管道中更深的着色器；具体来说，我们想将其传递给`fragment`着色器。
- en: A simple fragment shader
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的片段着色器
- en: The second shader we need to create is the `fragment` shader. Remember that
    this shader's primary job is to determine the color of each point (or *fragment*)
    on a primitive.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的第二个着色器是`fragment`着色器。请记住，这个着色器的主要工作是确定每个基本图元上每个点（或*片段*）的颜色。
- en: 'Create a new file called `fragment_shader.glsl` and add in this code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`fragment_shader.glsl`的新文件，并添加以下代码：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Just as with our `vertex` shader, we begin with a comment specifying the version
    of GLSL we're targeting. Then, we will declare a variable called `color`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的`vertex`着色器一样，我们从一个指定我们要针对的GLSL版本的注释开始。然后，我们将声明一个名为`color`的变量。
- en: Because this is the `fragment` shader, specifying a variable as `varying` makes
    it an input variable. Using the name `color`, which was an output variable from
    our shader, means that we will receive from that shader the color value it assigned.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是`fragment`着色器，将变量指定为`varying`会使其成为输入变量。使用`color`这个名称，它是我们着色器的输出变量，意味着我们将从该着色器接收它分配的颜色值。
- en: Within `main()`, we then assign that color to the built-in `gl_FragColor` variable.
    What this shader effectively does is tell OpenGL to use the color value passed
    in with the `vertex` shader to determine the color of an individual fragment.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`main()`中，我们将该颜色分配给内置的`gl_FragColor`变量。这个着色器的有效作用是告诉OpenGL使用`vertex`着色器传入的颜色值来确定单个片段的颜色。
- en: This is about as simple a `fragment` shader as we can get. A more complex `fragment`
    shader, such as one that you would find in a game or simulation, might implement
    textures, lighting effects, or other color manipulations; but this one should
    suffice for our purposes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以得到的最简单的`fragment`着色器。更复杂的`fragment`着色器，例如在游戏或模拟中找到的着色器，可能实现纹理、光照效果或其他颜色操作；但对于我们的目的，这个着色器应该足够了。
- en: Now that we have our required shaders, we can create a PyQt application to use
    them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所需的着色器，我们可以创建一个PyQt应用程序来使用它们。
- en: Embedding OpenGL drawings with QOpenGLWidget
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QOpenGLWidget嵌入OpenGL绘图
- en: To see how OpenGL works with PyQt, we're going to use our shaders to make a
    simple OpenGL image, which we will be able to control through a PyQt interface.
    Create a copy of your Qt application template from [Chapter 4](61ff4931-02af-474a-996c-5da827e0684f.xhtml),
    *Building Applications with QMainWindow*, and call it `wedge_animation.py`. Put
    this in the same directory as your `shader` files.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解OpenGL如何与PyQt一起工作，我们将使用我们的着色器制作一个简单的OpenGL图像，通过PyQt界面我们将能够控制它。从[第4章](61ff4931-02af-474a-996c-5da827e0684f.xhtml)中创建一个Qt应用程序模板的副本，*使用QMainWindow构建应用程序*，并将其命名为`wedge_animation.py`。将其放在与您的`shader`文件相同的目录中。
- en: 'Then, start by adding this code in `MainWindow.__init__()`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，首先在`MainWindow.__init__()`中添加此代码：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code creates our central widget and adds a `GlWidget` object to it. The
    `GlWidget` class is what we'll be creating to display our OpenGL drawing. To create
    it, we'll need to subclass a widget that can display OpenGL content.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建我们的中央小部件并向其添加一个`GlWidget`对象。`GlWidget`类是我们将创建的用于显示我们的OpenGL绘图的类。要创建它，我们需要对可以显示OpenGL内容的小部件进行子类化。
- en: First steps with OpenGLWidget
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGLWidget的第一步
- en: 'There are two Qt classes that we can use to display OpenGL content: `QtWidgets.QOpenGLWidget`
    and `QtGui.QOpenGLWindow`. In practice, they behave almost exactly the same, but
    `OpenGLWindow` offers slightly better performance and may be a better choice if
    you don''t want to use any other Qt widgets (that is, if your application is just
    full-screen OpenGL content). In our case, we''re going to be combining our OpenGL
    drawing with other widgets, so we''ll use `QOpenGLWidget` as the base for our
    class:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个Qt类可用于显示OpenGL内容：`QtWidgets.QOpenGLWidget`和`QtGui.QOpenGLWindow`。在实践中，它们的行为几乎完全相同，但`OpenGLWindow`提供了稍微更好的性能，如果您不想使用任何其他Qt小部件（即，如果您的应用程序只是全屏OpenGL内容），可能是更好的选择。在我们的情况下，我们将把我们的OpenGL绘图与其他小部件组合在一起，因此我们将使用`QOpenGLWidget`作为我们的类的基础：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To create OpenGL content on our widget, we need to override two `QOpenGLWidget`
    methods:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的小部件上创建OpenGL内容，我们需要重写两个`QOpenGLWidget`方法：
- en: '`initializeGL()`, which is run once to set up our OpenGL drawing'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initializeGL()`，它只运行一次来设置我们的OpenGL绘图'
- en: '`paintGL()`, which is called whenever our widget needs to paint itself (for
    example, in response to an `update()` call)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paintGL()`在我们的小部件需要绘制自己时（例如，响应`update()`调用）调用'
- en: 'We''ll start with `initializeGL()`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`initializeGL()`开始：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first thing that we need to do is get access to our OpenGL API. The API
    is made up of a set of functions, variables, and constants; in an object-oriented
    platform, such as PyQt, we will be creating a special OpenGL functions object
    that contains those functions as methods and the variables and constants as properties.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是访问我们的OpenGL API。API由一组函数、变量和常量组成；在诸如PyQt之类的面向对象平台中，我们将创建一个包含这些函数作为方法以及变量和常量作为属性的特殊OpenGL函数对象。
- en: To do this, we first retrieve an OpenGL **context** from the `QOpenGLWidget` method.
    The context represents our interface to the OpenGL surface on which we're currently
    drawing. From the context, we can retrieve the object that contains our API.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们首先从`QOpenGLWidget`方法中检索一个OpenGL**上下文**。上下文表示我们当前绘制的OpenGL表面的接口。从上下文中，我们可以检索包含我们的API的对象。
- en: Because we need access to a specific version of the API (2.1), we will first
    need to create a `QOpenGLVersionProfile` object with its `version` property set
    to `(2, 1)`. This can be passed to the context's `versionFunctions()` method,
    which will return a `QOpenGLFunctions_2_1` object. This is the object that contains
    our OpenGL 2.1 API.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要访问特定版本的API（2.1），我们首先需要创建一个`QOpenGLVersionProfile`对象，并将其`version`属性设置为`(2,
    1)`。这可以传递给上下文的`versionFunctions()`方法，该方法将返回一个`QOpenGLFunctions_2_1`对象。这是包含我们的OpenGL
    2.1 API的对象。
- en: Qt defines OpenGL function objects for other versions of OpenGL as well, but
    be aware that, depending on your platform, your hardware, and how you acquired
    Qt, a particular version may or may not be supported.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Qt还为其他版本的OpenGL定义了OpenGL函数对象，但请注意，根据您的平台、硬件以及您获取Qt的方式，可能会或可能不会支持特定版本。
- en: We're saving the `functions` object as `self.gl`; all of our API calls will
    be done on this object.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`functions`对象保存为`self.gl`；我们所有的API调用都将在这个对象上进行。
- en: 'Now that we have access to the API, let''s start configuring OpenGL:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们可以访问API，让我们开始配置OpenGL：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Much like Qt, OpenGL uses defined constants to represent various settings and
    states. Configuring OpenGL is mostly a matter of passing these constants to various
    API functions that toggle various settings.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与Qt类似，OpenGL使用定义的常量来表示各种设置和状态。配置OpenGL主要是将这些常量传递给各种API函数，以切换各种设置。
- en: 'In this case, we''re performing three settings:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们执行三个设置：
- en: Passing `GL_DEPTH_TEST` to `glEnable()` activates **depth testing,** which means
    that OpenGL will try to figure out which of the points its drawings are in the
    foreground and which are in the background.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`GL_DEPTH_TEST`传递给`glEnable()`会激活**深度测试**，这意味着OpenGL将尝试弄清楚其绘制的点中哪些在前景中，哪些在背景中。
- en: '`glDepthFunc()` sets the function that will determine whether or not a depth-tested
    pixel will be drawn. In this case, the `GL_LESS` constant indicates that the pixel
    with the lowest depth (that is, the one closest to us) will be drawn. Generally,
    this is the setting you want, and it''s also the default setting.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glDepthFunc()`设置将确定是否绘制深度测试像素的函数。在这种情况下，`GL_LESS`常量表示将绘制深度最低的像素（即最接近我们的像素）。通常，这是您想要的设置，也是默认设置。'
- en: Passing `GL_CULL_FACE` to `glEnable()` activates **face culling**. This simply
    means that OpenGL will not bother drawing the sides of the object that the viewer
    can't actually see. It makes sense to enable this as well, as it saves on resources
    that would otherwise be wasted.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`GL_CULL_FACE`传递给`glEnable()`会激活**面剔除**。这意味着OpenGL不会绘制观看者实际看不到的物体的侧面。这也是有意义的，因为它节省了本来会被浪费的资源。
- en: These three optimizations should help to reduce the resources used by our animation;
    in most cases, you'll want to use them. There are many more options that can be
    enabled and configured; for a complete list, see [https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnable.xml](https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnable.xml).
    Be aware that some options only apply to the older fixed-function method of using
    OpenGL.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个优化应该有助于减少我们的动画使用的资源；在大多数情况下，您会想要使用它们。还有许多其他可以启用和配置的选项；有关完整列表，请参见[https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnable.xml](https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnable.xml)。请注意，有些选项只适用于使用OpenGL的旧固定功能方法。
- en: If you see OpenGL code that uses `glBegin()` and `glEnd()`, it is using the
    very old OpenGL 1.x fixed-function drawing API. This approach was easier, but
    much more limited, so this shouldn't be used for modern OpenGL programming.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到使用`glBegin()`和`glEnd()`的OpenGL代码，那么它使用的是非常古老的OpenGL 1.x固定功能绘图API。这种方法更容易，但更有限，所以不应该用于现代OpenGL编程。
- en: Creating a program
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个程序
- en: Our next step in implementing an OpenGL drawing is to create our program. You
    may remember that an OpenGL program is a collection of shaders that form a complete
    pipeline.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现OpenGL绘图的下一步是创建我们的程序。您可能还记得，OpenGL程序是由一组着色器组成的，形成一个完整的管道。
- en: 'In Qt, the process to create a program is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt中，创建程序的过程如下：
- en: Create a `QOpenGLShaderProgram` object
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`QOpenGLShaderProgram`对象
- en: Add your shader code to the program
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的着色器代码添加到程序中
- en: Link the code into a complete program
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码链接成完整的程序
- en: 'The following code will implement this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将实现这一点：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Shaders can be added from files, as we've done here using `addShaderFromSourceFile()`,
    or from strings using `addShaderFromSourceCode()`. We're using relative file paths
    here, but the best approach would be to use Qt resource files (see the *Using
    Qt Resource Files* section in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml),
    *Styling Qt Applications*). As the files are added, Qt compiles the shader code
    and outputs any compilation errors to the Terminal.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器可以从文件中添加，就像我们在这里使用`addShaderFromSourceFile()`做的那样，也可以从字符串中添加，使用`addShaderFromSourceCode()`。我们在这里使用相对文件路径，但最好的方法是使用Qt资源文件（参见[第6章](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml)中的*使用Qt资源文件*部分，*Qt应用程序的样式*）。当文件被添加时，Qt会编译着色器代码，并将任何编译错误输出到终端。
- en: In the production code, you'll want to check the Boolean output of `addShaderFromSourceFile()`
    to see whether your shader compiled successfully before proceeding.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产代码中，您会想要检查`addShaderFromSourceFile()`的布尔输出，以查看您的着色器是否成功编译，然后再继续。
- en: Note that the first argument to `addShaderFromSourceFile()` specifies what kind
    of shader we're adding. This is important, as vertex shaders and fragment shaders
    have very different requirements and functionality.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`addShaderFromSourceFile()`的第一个参数指定了我们要添加的着色器的类型。这很重要，因为顶点着色器和片段着色器有非常不同的要求和功能。
- en: Once all the shaders are loaded, we call `link()` to link all the compiled code
    into a ready-to-execute program.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有着色器都加载完毕，我们调用`link()`将所有编译的代码链接成一个准备执行的程序。
- en: Accessing our variables
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问我们的变量
- en: Our shader programs contained some variables that we need to be able to access
    and put values into, so we need to retrieve a handle for those variables. The
    `QOpenGLProgram` object has two methods, `attributeLocation()` and `uniformLocation()`,
    which can be used to retrieve a handle for attribute and uniform variables, respectively
    (there is no such function for the `varying` types).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的着色器程序包含了一些我们需要能够访问并放入值的变量，因此我们需要检索这些变量的句柄。`QOpenGLProgram`对象有两种方法，`attributeLocation()`和`uniformLocation()`，分别用于检索属性和统一变量的句柄（对于`varying`类型没有这样的函数）。
- en: 'Let''s grab some handles for our `vertex` shader variables:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的`vertex`着色器变量获取一些句柄：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The values returned from these methods are actually just integers; internally,
    OpenGL just uses sequential integers to track and reference objects. However,
    that doesn't matter to us. We can treat this as if they were object handles and
    pass them into OpenGL calls to access these variables, as you'll see soon.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法返回的值实际上只是整数；在内部，OpenGL只是使用顺序整数来跟踪和引用对象。然而，这对我们来说并不重要。我们可以将其视为对象句柄，并将它们传递到OpenGL调用中，以访问这些变量，很快您就会看到。
- en: Configuring a projection matrix
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置投影矩阵
- en: In OpenGL, the **projection matrix** defines how our 3D model is projected to
    a 2D screen. This is represented by a 4x4 matrix of numbers that can be used to
    calculate vertex positions. Before we can do any drawing, we need to define this
    matrix.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenGL中，**投影矩阵**定义了我们的3D模型如何投影到2D屏幕上。这由一个4x4的数字矩阵表示，可以用来计算顶点位置。在我们进行任何绘图之前，我们需要定义这个矩阵。
- en: 'In Qt, we can use the `QMatrix4x4` object to represent it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在Qt中，我们可以使用`QMatrix4x4`对象来表示它：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A `QMatrix4x4` object is very simply a table of numbers arranged in four rows
    and four columns. However, it has several methods that allow us to manipulate
    those numbers in such a way that they represent 3D transformations, such as our
    projection.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMatrix4x4`对象非常简单，它是一个按四行四列排列的数字表。然而，它有几种方法，允许我们以这样的方式操纵这些数字，使它们代表3D变换，比如我们的投影。'
- en: OpenGL can use two kinds of projections—**orthographic**, meaning that points
    at all depths are rendered the same, or **perspective**, meaning that the field
    of view expands as we move away from the viewer. For realistic 3D drawings, you'll
    want to use perspective projection. This kind of projection is represented by
    a **frustum**.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL可以使用两种投影方式——**正交**，意味着所有深度的点都被渲染为相同的，或者**透视**，意味着视野随着我们远离观察者而扩展。对于逼真的3D绘图，您将希望使用透视投影。这种投影由**视锥体**表示。
- en: A frustum is a section of a regular geometric solid between two parallel planes,
    and it's a useful shape for describing a field of vision. To understand this,
    place your hands on either side of your head. Now, move them forward, keeping
    them just outside your field of vision. Notice that you must move them outward
    (to the left and right) in order to do this. Try this again with your hands above
    and below your head. Once again, you must move them outward vertically to keep
    them from your field of visions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 视锥体是两个平行平面之间的一个常规几何固体的一部分，它是用来描述视野的有用形状。要理解这一点，把你的手放在头两侧。现在，把它们向前移动，保持它们刚好在你的视野之外。注意，为了做到这一点，你必须向外移动（向左和向右）。再试一次，把你的手放在头上和头下。再一次，你必须垂直向外移动，以使它们远离你的视野。
- en: The shape that you've just made with your hands is like a pyramid, extending
    from your eyes, whose point has been sliced off parallel to the base—in other
    words, a frustum.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚用手做的形状就像一个金字塔，从您的眼睛延伸出来，其顶点被切成与底部平行的形状，换句话说，是一个视锥体。
- en: 'To create a matrix that represents a perspective frustum, we can use the `matrix`
    object''s `perspective()` method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建表示透视视锥体的矩阵，我们可以使用`matrix`对象的`perspective()`方法：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `perspective()` method takes four arguments:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`perspective()`方法需要四个参数：'
- en: The angle, in degrees, at which the frustum expands from the near plane to the
    far plane
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从近平面到远平面扩展的角度，以度为单位
- en: The aspect ratio of the near and far planes (which are identical)
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 近平面和远平面的纵横比（相同）
- en: The depth into the screen of the near plane
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 近平面向屏幕的深度
- en: The depth into the screen of the far plane
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远平面向屏幕的深度
- en: Without digging into the complicated math, this matrix effectively represents
    our field of view relative to our drawing. As we'll see when we start drawing,
    all we need to do to move our object is to manipulate the matrix.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不用深入复杂的数学，这个矩阵有效地表示了我们相对于绘图的视野。当我们开始绘图时，我们将看到，我们移动对象所需做的就是操纵矩阵。
- en: 'For example, we should probably back up a bit from where we''re going to be
    drawing so that it''s not happening right up in the front of the field of view.
    This movement can be accomplished by the `translate()` method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能应该从我们将要绘制的地方稍微后退一点，这样它就不会发生在视野的最前面。这种移动可以通过`translate()`方法来实现：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`translate` takes three arguments—an x amount, a y amount, and a z amount.
    Here, we''ve specified a z translation of `-5`, which pushes the object deeper
    into the screen.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`translate`需要三个参数——x量、y量和z量。在这里，我们指定了一个z平移量为`-5`，这将使对象深入屏幕。'
- en: This may all seem a bit confusing now, but, once we start drawing our shape,
    things will become clearer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这一切可能看起来有点混乱，但是，一旦我们开始绘制形状，事情就会变得更清晰。
- en: Drawing our first shape
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制我们的第一个形状
- en: Now that our OpenGL environment is initialized, we can move on to the `paintGL()`
    method. This method will contain all the code for drawing our 3D object and will
    be called whenever the widget needs to be updated.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的OpenGL环境已经初始化，我们可以继续进行`paintGL()`方法。这个方法将包含绘制我们的3D对象的所有代码，并且在小部件需要更新时将被调用。
- en: 'The first thing we''ll do when painting is clear the canvas:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 绘画时，我们要做的第一件事是清空画布：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`glClearColor()` is used to fill the background of the drawing with a solid
    color, as specified by our arguments. Colors in OpenGL are specified using three
    or four values. In the case of three values, they represent red, green, and blue.
    A fourth value, when used, represents the **alpha**, or opacity, of the color.
    Unlike Qt, where RGB values are integers ranging from `0` to `255`, OpenGL color
    values are floating-point numbers ranging from `0` to `1`. Our values in the preceding
    describe a deep purple-blue color; feel free to experiment with other values.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`glClearColor()`用于用指定的颜色填充绘图的背景。在OpenGL中，颜色使用三个或四个值来指定。在三个值的情况下，它们代表红色、绿色和蓝色。第四个值，当使用时，代表颜色的**alpha**或不透明度。与Qt不同，其中RGB值是从`0`到`255`的整数，OpenGL颜色值是从`0`到`1`的浮点数。我们前面的值描述了深紫蓝色；可以随意尝试其他值。'
- en: You should redraw the background with `glClearColor` on every repaint; if you
    don't, the previous paint operations will still be visible. This is a problem
    if you animate or resize your drawing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在每次重绘时使用`glClearColor`重新绘制背景；如果不这样做，之前的绘画操作仍然可见。如果您进行动画或调整绘图大小，这将是一个问题。
- en: The `glClear()` function is used to clean out various memory buffers on the
    GPU, which we'd like to reset between redraws. In this case, we're specifying
    some constants that cause OpenGL to clear the color buffer and the depth buffer.
    This helps to maximize performance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`glClear()`函数用于清除GPU上的各种内存缓冲区，我们希望在重绘之间重置它们。在这种情况下，我们指定了一些常量，导致OpenGL清除颜色缓冲区和深度缓冲区。这有助于最大化性能。'
- en: Finally, we `bind()` the program object. Since an OpenGL application can have
    multiple programs, we call `bind()` to tell OpenGL that the commands we're about
    to issue apply to this particular program.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们`bind()`程序对象。由于OpenGL应用程序可以有多个程序，我们调用`bind()`告诉OpenGL我们即将发出的命令适用于这个特定的程序。
- en: Now we can draw our shape.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以绘制我们的形状了。
- en: Shapes in OpenGL are described using vertices. You may recall that a vertex
    is essentially a point in 3D space described by *X*, *Y*, and *Z* coordinates,
    and defines one corner or end of a primitive.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL中的形状是用顶点描述的。您可能还记得，顶点本质上是3D空间中的一个点，由*X*、*Y*和*Z*坐标描述，并定义了一个基本图元的一个角或端点。
- en: 'Let''s create a list of vertices to describe a triangle that will be the front
    of a wedge shape:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个顶点列表来描述一个楔形的前面是三角形：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our vertex data doesn't have to be grouped into distinct objects of any kind,
    but, for convenience and readability, we've used the `QVector3D` object to hold
    the coordinates for each of the vertices in our triangle.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的顶点数据不必分组成任何类型的不同对象，但是为了方便和可读性，我们使用`QVector3D`对象来保存三角形中每个顶点的坐标。
- en: The numbers used here represent points on a grid, where `(0, 0, 0)` is the center
    of our OpenGL viewport at the forward-most point. The x axis goes from `-1` at
    the left-hand side of the screen to `1` at the right-hand side, and the y axis
    goes from `1` at the top of the screen to `-1` at the bottom. The z axis is a
    bit different; if you imagine the field of vision (the frustum we described earlier)
    as a shape expanding out of the back of your monitor, a negative z value pushes
    deeper into that field of vision. A positive z value would move out of the screen
    toward (and eventually behind) the viewer. So, generally, we will be operating
    with negative or zero z values to stay within the visible range.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的数字代表网格上的点，其中`(0, 0, 0)`是我们OpenGL视口的中心在最前面的点。x轴从屏幕左侧的`-1`到右侧的`1`，y轴从屏幕顶部的`1`到底部的`-1`。z轴有点不同；如果想象视野（我们之前描述的视锥体）作为一个形状从显示器背面扩展出来，负z值会推进到视野的更深处。正z值会移出屏幕朝着（最终在后面）观察者。因此，通常我们将使用负值或零值的z来保持在可见范围内。
- en: 'By default, OpenGL will draw in black, but it would be far more interesting
    to have some colors. So, we''ll define a `tuple` object containing some colors:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，OpenGL将以黑色绘制，但是有一些颜色会更有趣。因此，我们将定义一个包含一些颜色的`tuple`对象：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've defined three colors here, one for each vertex of the triangle. These
    are `QColor` objects, though; remember that OpenGL needs colors as vectors of
    values between `0` and `1`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义了三种颜色，每个三角形顶点一个。这些是`QColor`对象，但是请记住OpenGL需要颜色作为值在`0`和`1`之间的向量。
- en: 'To address this, we''ll create a little method to convert a `QColor` to an
    OpenGL-friendly vector:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将创建一个小方法将`QColor`转换为OpenGL友好的向量：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code is fairly self-explanatory, it will create another `QVector3D` object
    with the converted RGB values.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当不言自明，它将创建另一个带有转换后的RGB值的`QVector3D`对象。
- en: 'Back in `paintGL()`, we can use a list comprehension to convert our colors
    to something usable:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`paintGL()`，我们可以使用列表推导将我们的颜色转换为可用的东西：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At this point, we've defined some vertex and color data, but we've sent nothing
    to OpenGL yet; these are just data values in our Python script. To pass these
    to OpenGL, we'll need those variable handles we grabbed in `initializeGL()`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经定义了一些顶点和颜色数据，但是我们还没有发送任何数据到OpenGL；这些只是我们Python脚本中的数据值。要将这些传递给OpenGL，我们需要在`initializeGL()`中获取的那些变量句柄。
- en: 'The first variable we''ll pass to our shaders is the `matrix` variable. We''re
    going to use our `view_matrix` object that we defined in `initializeGL()` for
    this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将传递给我们的着色器的第一个变量是`matrix`变量。我们将使用我们在`initializeGL()`中定义的`view_matrix`对象：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`setUniformValue()` can be used to set the value of a `uniform` variable; we
    can simply pass it the handle of the `GLSL` variable that we retrieved using `uniformLocation()`
    and the `matrix` object we created to define our projection and field of vision.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUniformValue()`可以用来设置`uniform`变量的值；我们可以简单地传递`uniformLocation()`获取的`GLSL`变量的句柄和我们创建的`matrix`对象来定义我们的投影和视野。'
- en: 'You can also use `setAttributeValue()` to set the value of `attribute` variables.
    For instance, if we wanted all our vertices to be red, we could add this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`setAttributeValue()`来设置`attribute`变量的值。例如，如果我们希望所有顶点都是红色，我们可以添加这个：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: But let's not do that; it will look much better if each vertex has its own color.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不要这样做；如果每个顶点都有自己的颜色会看起来更好。
- en: To do this, we need to create some **attribute arrays.** An attribute array
    is an array of data that will be passed into an attribute-type variable. Remember
    that variables marked as attributes in GLSL apply a distinct value to each vertex.
    So effectively we're telling OpenGL, *here are some arrays of data where each
    item applies to one vertex*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要创建一些**属性数组。**属性数组是将传递到属性类型变量中的数据数组。请记住，在GLSL中标记为属性的变量将为每个顶点应用一个不同的值。因此，实际上我们告诉OpenGL，*这里有一些数据数组，其中每个项目都应用于一个顶点*。
- en: 'The code looks like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来像这样：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first step is to enable an array on the `GLSL` variable by calling `enableAttributeArray()`
    with the handle for the variable that we want to set the array on. Then, we pass
    in the data using `setAttributeArray()`. This effectively means that our `vertex`
    shader is going to be run on each of the items in the `front_vertices` array.
    Each time that shader runs, it will also grab the next item from the `gl_colors`
    list and will apply that to the `color_attr` variable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是通过使用要设置数组的变量的句柄调用`enableAttributeArray()`来启用`GLSL`变量上的数组。然后，我们使用`setAttributeArray()`传递数据。这实际上意味着我们的`vertex`着色器将在`front_vertices`数组中的每个项目上运行。每次该着色器运行时，它还将从`gl_colors`列表中获取下一个项目，并将其应用于`color_attr`变量。
- en: If you are using multiple attribute arrays like this, you need to make sure
    that there are enough items in the arrays to cover all the vertices. If we only
    had two colors defined, the third vertex would pull garbage data for `color_attr`,
    resulting in an undefined output.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您像这样使用多个属性数组，您需要确保数组中有足够的项目来覆盖所有顶点。如果我们只定义了两种颜色，第三个顶点将为`color_attr`提取垃圾数据，导致未定义的输出。
- en: 'Now that we''ve queued up all the data for our first primitive, let''s draw
    using the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经排队了我们第一个基元的所有数据，让我们使用以下代码进行绘制：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`glDrawArrays()` will send all the arrays we''ve defined into the pipeline.
    The `GL_TRIANGLES` argument tells OpenGL that it will be drawing triangle primitives,
    and the next two arguments tell it to start at array item `0` and draw three items.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`glDrawArrays()`将发送我们定义的所有数组到管道中。`GL_TRIANGLES`参数告诉OpenGL它将绘制三角形基元，接下来的两个参数告诉它从数组项`0`开始绘制三个项。'
- en: If you run the program at this point, you should see that we've drawn a red
    and yellow triangle. Nice! Now, let's make it 3D.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时运行程序，您应该会看到我们绘制了一个红色和黄色的三角形。不错！现在，让我们让它成为3D。
- en: Creating a 3D object
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个3D对象
- en: 'To make a 3D object, we need to draw the back and sides of our wedge object.
    We''ll start by calculating the coordinates for the back of the wedge using a
    list comprehension:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作一个3D对象，我们需要绘制楔形对象的背面和侧面。我们将首先通过列表推导来计算楔形的背面坐标：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To create the back face, we only need to copy each of the front face coordinates
    and move the z axis back a bit. So, we're using the `QVector3D` object's `toVector2D()`
    method to produce a new vector with only the x and y axes, then passing that to
    the constructor of a new `QVector3D` object along with a second argument specifying
    the new z coordinate.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建背面，我们只需要复制每个正面坐标并将z轴向后移一点。因此，我们使用`QVector3D`对象的`toVector2D()`方法来产生一个只有x和y轴的新向量，然后将其传递给一个新的`QVector3D`对象的构造函数，同时指定新的z坐标作为第二个参数。
- en: 'Now, we''ll pass this set of vertices to OpenGL and draw as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把这组顶点传递给OpenGL并进行绘制如下：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By writing these to `vertex_location`, we've overwritten the vertices for the
    front face (which are already drawn) and replaced them with the back face vertices.
    Then, we make the same call to `glDrawArrays()` and the new set of vertices will
    be drawn, along with the corresponding colors.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些写入`vertex_location`，我们已经覆盖了已经绘制的正面顶点，并用背面顶点替换了它们。然后，我们对`glDrawArrays()`进行相同的调用，新的顶点集将被绘制，以及相应的颜色。
- en: You will notice that we will reverse the order of the vertices before drawing.
    When OpenGL displays a primitive, it only shows one side of that primitive, since
    it's assumed that the primitive is part of some 3D object whose insides would
    not need to be drawn. OpenGL determines which side of the primitive should be
    drawn depending on whether its points are drawn clockwise or counterclockwise.
    By default, the near face of a primitive drawn counter-clockwise is shown, so
    we will reverse the order of the back face vertices so that it is drawn clockwise
    and its far face is shown (which will be the outside of the wedge).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您将注意到我们在绘制之前会颠倒顶点的顺序。当OpenGL显示一个基元时，它只显示该基元的一面，因为假定该基元是某个3D对象的一部分，其内部不需要被绘制。OpenGL根据基元的点是顺时针还是逆时针绘制来确定应该绘制哪一面的基元。默认情况下，绘制逆时针的基元的近面，因此我们将颠倒背面顶点的顺序，以便绘制顺时针并显示其远面（这将是楔形的外部）。
- en: Let's finish our shape by drawing its sides. Unlike the front and back, which
    are triangles, our sides are rectangles and so will need four vertices each to
    describe them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过绘制其侧面来完成我们的形状。与前面和后面不同，我们的侧面是矩形，因此每个侧面都需要四个顶点来描述它们。
- en: 'We''ll calculate those vertices from our other two lists:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们的另外两个列表中计算出这些顶点：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `sides` list contains indexes for the `front_vertices` and `back_vertices`
    lists, which define the sides of each triangle. We iterate this list, and, for
    each one, define a list of four vertices describing one side of the wedge.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`sides`列表包含了`front_vertices`和`back_vertices`列表的索引，它们定义了每个三角形的侧面。我们遍历这个列表，对于每一个，定义一个包含四个顶点描述楔形一个侧面的列表。'
- en: Notice that those four vertices are drawn in counter-clockwise order, just like
    the front (you may need to sketch this out on paper to see it).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这四个顶点是按逆时针顺序绘制的，就像正面一样（您可能需要在纸上草图来看清楚）。
- en: 'We''ll also define a new list of colors since we now need more than three:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将定义一个新的颜色列表，因为现在我们需要更多的颜色：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Our list of side vertices contains a total of 12 vertices (4 for each of the
    3 sides), so we need a list of 12 colors to match it. We can do this by just specifying
    4 colors and then multiplying the Python `list` object by 3 to produce a repeating
    list with 12 items in total.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的侧面顶点列表包含了总共12个顶点（每个侧面4个），所以我们需要一个包含12个颜色的列表来匹配它。我们可以通过只指定4种颜色，然后将Python的`list`对象乘以3来产生一个重复的列表，总共有12个项目。
- en: 'Now, we''ll pass these arrays to OpenGL and draw:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把这些数组传递给OpenGL并进行绘制：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This time, instead of `GL_TRIANGLES`, we're using `GL_QUADS` as the first argument
    to indicate that we're drawing quadrilaterals.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们使用`GL_QUADS`作为第一个参数，而不是`GL_TRIANGLES`，以指示我们正在绘制四边形。
- en: OpenGL can draw several different primitive types, including lines, points,
    and polygons. Most of the time, you should use triangles, because this is the
    fastest primitive on most graphics hardware.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL可以绘制多种不同的基元类型，包括线、点和多边形。大多数情况下，您应该使用三角形，因为这是大多数图形硬件上最快的基元。
- en: 'Now that all our points are drawn, we''ll clean up a bit:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所有的点都绘制完毕，我们来清理一下：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These calls aren't strictly necessary in our simple little demonstration, but,
    in a more complex program, they would likely save you some headaches. OpenGL operates
    as a state machine, where the result of an operation depends on the current state
    of the system. When we bind or enable a particular object, OpenGL is then pointed
    *to* that object and certain operations (such as setting array data) will be automatically
    directed to it. When we've finished a drawing operation, we don't want to leave
    OpenGL pointed at our object, so it's good practice to release and disable objects
    when we're finished with them.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们简单的演示中，这些调用并不是严格必要的，但是在一个更复杂的程序中，它们可能会为您节省一些麻烦。OpenGL作为一个状态机运行，其中操作的结果取决于系统的当前状态。当我们绑定或启用特定对象时，OpenGL就会指向该对象，并且某些操作（例如设置数组数据）将自动指向它。当我们完成绘图操作时，我们不希望将OpenGL指向我们的对象，因此在完成后释放和禁用对象是一个良好的做法。
- en: 'If you run the application now, you should see your amazing 3D shape:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行应用程序，您应该会看到您惊人的3D形状：
- en: '![](assets/67c57d27-65dc-43bf-ada2-e4e1549f0e6d.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/67c57d27-65dc-43bf-ada2-e4e1549f0e6d.png)'
- en: Oops, not so 3D, is it? In fact, we *have* drawn a 3Dshape, but you can't see
    that, because we're looking directly at it. In the next section, we'll create
    some code to animate this shape and get a full appreciation of all its dimensions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，不太3D，是吧？实际上，我们*已经*绘制了一个3D形状，但你看不到，因为我们直接在它上面看。在下一节中，我们将创建一些代码来使这个形状动起来，并充分欣赏它的所有维度。
- en: Animating and controlling OpenGL drawings
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenGL绘图的动画和控制
- en: To get a sense of the 3D aspects of our drawing, we're going to build some controls
    into our GUI that allow us to rotate and zoom around the drawing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了感受我们绘图的3D特性，我们将在GUI中构建一些控件，允许我们围绕绘图进行旋转和缩放。
- en: 'We''ll start by adding some buttons in `MainWindow.__init__()` that we can
    use as controls:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在`MainWindow.__init__()`中添加一些按钮开始，这些按钮可以用作控件：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We've created two sets of buttons here; the first set will be a set of radio-style
    buttons (so only one can be down at a time) that will select the rotation direction
    of the object – none (no rotation), left, right, up, or down. Each button will
    call a corresponding method on the `GlWidget` object when activated.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了两组按钮；第一组将是一组单选样式的按钮（因此一次只能有一个被按下），它们将选择对象的旋转方向——无（不旋转）、左、右、上或下。每个按钮在激活时都会调用`GlWidget`对象上的相应方法。
- en: The second set comprises a zoom-in and zoom-out buttons, which calls a `zoom_in()`
    or `zoom_out()` method on the `GlWidget` respectively. With these buttons added
    to our GUI, let's hop over to `GlWidget` and implement the callback methods.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组包括一个放大和一个缩小按钮，分别在`GlWidget`上调用`zoom_in()`或`zoom_out()`方法。通过将这些按钮添加到我们的GUI，让我们跳到`GlWidget`并实现回调方法。
- en: Animating in OpenGL
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在OpenGL中进行动画
- en: 'Animating our wedge is purely a matter of manipulating the `view` matrix and
    redrawing our image. We''ll start in `GlWidget.initializeGL()` by creating an
    instance variable to hold rotation values:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 动画我们的楔形纯粹是通过操纵`view`矩阵并重新绘制我们的图像。我们将在`GlWidget.initializeGL()`中通过创建一个实例变量来保存旋转值：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first value in this list represents an angle of rotation; the remaining
    values are the *X*, *Y*, and *Z* coordinates of the point around which the `view`
    matrix will rotate.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表中的第一个值表示旋转角度；其余的值是`view`矩阵将围绕的点的*X*、*Y*和*Z*坐标。
- en: 'At the end of `paintGL()`, we can pass these values into the `matrix` object''s
    `rotate()` method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`paintGL()`的末尾，我们可以将这些值传递给`matrix`对象的`rotate()`方法：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Right now, this will do nothing, because our rotation values are all `0`. To
    cause rotation, we will have to change `self.rotation` and trigger a repaint of
    the image.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这将不起作用，因为我们的旋转值都是`0`。要进行旋转，我们将不得不改变`self.rotation`并触发图像的重绘。
- en: 'So, our rotation callbacks will look like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的旋转回调看起来像这样：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Each method simply changes the value of our rotation vector. The angle is shifted
    one degree forward (`1`) or backward (`1`) around an appropriate point to produce
    the rotation desired.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法只是改变了我们旋转向量的值。角度向前（`1`）或向后（`1`）移动一个度数，围绕一个适当的点产生所需的旋转。
- en: 'Now, we just need to kick off animation by triggering repeated repaints. At
    the end of `paintGL()`, add this line:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要通过触发重复的重绘来启动动画。在`paintGL()`的末尾，添加这一行：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`update()` schedules a repaint on the `event` loop, which means that this method
    will be called again and again. Each time, our `view` matrix will be rotated by
    the amount set in `self.rotation`.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`在`event`循环中安排了一次重绘，这意味着这个方法会一遍又一遍地被调用。每次，我们的`view`矩阵都会按照`self.rotation`中设置的角度进行旋转。'
- en: Zooming in and out
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放大和缩小
- en: We also want to implement zooming. Each time we click the zoom-in or zoom-out
    buttons, we want the image to get a tiny bit closer or further away.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想要实现缩放。每次点击放大或缩小按钮时，我们希望图像可以稍微靠近或远离一点。
- en: 'Those callbacks look like this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这些回调看起来像这样：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `scale()` method of `QMatrix4x4` causes the matrix to multiply each vertex
    point by the given amounts. Thus, we can cause our object to shrink or grow, giving
    the illusion that it is nearer or further away.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`QMatrix4x4`的`scale()`方法会使矩阵将每个顶点点乘以给定的数量。因此，我们可以使我们的对象缩小或放大，产生它更近或更远的错觉。'
- en: We could use `translate()` here, but translating in conjunction with rotation
    can cause some confusing results and we can lose sight of our object quickly.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里使用`translate()`，但是在旋转时使用平移可能会导致一些混乱的结果，我们很快就会失去对我们对象的视野。
- en: 'Now, when you run the application, you should be able to spin your wedge and
    see it in all its 3D glory:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您运行应用程序时，您应该能够旋转您的楔形并以其所有的3D光辉看到它：
- en: '![](assets/58b84077-1876-4e42-81a2-61c883b69a2d.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/58b84077-1876-4e42-81a2-61c883b69a2d.png)'
- en: This demonstration is only the beginning of what can be done with OpenGL. While
    this chapter may not have made you an OpenGL expert, you'll hopefully feel more
    comfortable digging deeper with the resources at the end of this chapter.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示只是OpenGL可以做的开始。虽然本章可能没有使您成为OpenGL专家，但希望您能更加自如地深入挖掘本章末尾的资源。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned about creating 3D animations with OpenGL,
    and how to integrate them into your PyQt application. We explored the basic principles
    of OpenGL, such as the render pipeline, shaders, and GLSL. We learned how to use
    Qt widgets as an OpenGL context to draw and animate a simple 3D object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了如何使用OpenGL创建3D动画，以及如何将它们集成到您的PyQt应用程序中。我们探讨了OpenGL的基本原理，如渲染管道、着色器和GLSL。我们学会了如何使用Qt小部件作为OpenGL上下文来绘制和动画一个简单的3D对象。
- en: In the next chapter, we'll learn to visualize data interactively using the `QtCharts`
    module. We'll create basic charts and graphs and learn how to build charts using
    a model-view architecture.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习使用`QtCharts`模块交互地可视化数据。我们将创建基本的图表和图形，并学习如何使用模型-视图架构构建图表。
- en: Questions
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些问题来测试您从本章中学到的知识：
- en: Which steps of the OpenGL render pipeline are user-definable? Which steps *must*
    be defined in order to render anything? You may need to reference the documentation
    at [https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview](https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview).
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenGL渲染管线的哪些步骤是可由用户定义的？为了渲染任何东西，必须定义哪些步骤？您可能需要参考文档[https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview](https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview)。
- en: You're writing a shader for an OpenGL 2.1 program. Does the following look correct?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您正在为一个OpenGL 2.1程序编写着色器。以下内容看起来正确吗？
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Is the following a `vertex` or `fragment` shader? How can you tell?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是“顶点”还是“片段”着色器？你如何判断？
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Given the following `vertex` shader, what code do you need to write to assign
    simple values to the two variables?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定以下“顶点”着色器，您需要编写什么代码来为这两个变量分配简单的值？
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You enable face culling to save some processing power, but find that several
    of the visible primitives in your drawing are now not rendering. What could the
    problem be?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您启用面剔除以节省一些处理能力，但发现绘图中的几个可见基元现在没有渲染。问题可能是什么？
- en: What does the following code do to our OpenGL image?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码对我们的OpenGL图像有什么影响？
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Experiment with the demo and see whether you can add any of the following features:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用演示，看看是否可以添加以下功能：
- en: A more interesting shape (a pyramid, cube, and so on)
  id: totrans-232
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更有趣的形状（金字塔、立方体等）
- en: More controls for moving the object
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动对象的更多控制
- en: Shadows and lighting effects
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阴影和光照效果
- en: Animated shape changes in the object
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象中的动画形状变化
- en: Further reading
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For further information, please refer the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请参考以下内容：
- en: A complete tutorial on modern OpenGL programming can be found at [https://paroj.github.io/gltut](https://paroj.github.io/gltut)
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代OpenGL编程的完整教程可以在[https://paroj.github.io/gltut](https://paroj.github.io/gltut)找到。
- en: Packt Publications' *Learn OpenGL*, available at [https://www.packtpub.com/game-development/learn-opengl](https://www.packtpub.com/game-development/learn-opengl),
    is a good resource for learning the basics of OpenGL
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Packt Publications的*Learn OpenGL*，网址为[https://www.packtpub.com/game-development/learn-opengl](https://www.packtpub.com/game-development/learn-opengl)，是学习OpenGL基础知识的良好资源
- en: A free tutorial on matrix mathematics for 3D graphics is available from Central
    Connecticut State University at [https://chortle.ccsu.edu/VectorLessons/vectorIndex.html](https://chortle.ccsu.edu/VectorLessons/vectorIndex.html)
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中央康涅狄格州立大学提供了一份关于3D图形矩阵数学的免费教程，网址为[https://chortle.ccsu.edu/VectorLessons/vectorIndex.html](https://chortle.ccsu.edu/VectorLessons/vectorIndex.html)。
