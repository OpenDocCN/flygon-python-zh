- en: Overview of Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法概述
- en: This book covers the information needed to understand, classify, select, and
    implement important algorithms. In addition to explaining their logic, this book
    also discusses data structures, development environments, and production environments
    that are suitable for different classes of algorithms. We focus on modern machine
    learning algorithms that are becoming more and more important. Along with the
    logic, practical examples of the use of algorithms to solve actual everyday problems
    are also presented.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书涵盖了理解、分类、选择和实施重要算法所需的信息。除了解释它们的逻辑之外，本书还讨论了适用于不同类算法的数据结构、开发环境和生产环境。我们专注于越来越重要的现代机器学习算法。除了逻辑之外，还提供了算法实际解决日常问题的实际示例。
- en: This chapter provides an insight into the fundamentals of algorithms. It starts
    with a section on the basic concepts needed to understand the workings of different
    algorithms. This section summarizes how people started using algorithms to mathematically
    formulate a certain class of problems. It also mentions the limitations of different
    algorithms. The next section explains the various ways to specify the logic of
    an algorithm. As Python is used in this book to write the algorithms, how to set
    up the environment to run the examples is explained. Then, the various ways that
    an algorithm's performance can be quantified and compared against other algorithms
    are discussed. Finally, this chapter discusses various ways a particular implementation
    of an algorithm can be validated.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了算法基础知识。它从需要理解不同算法工作原理的基本概念开始。本节总结了人们如何开始使用算法来数学表达某一类问题，并提到了不同算法的局限性。接下来的部分解释了指定算法逻辑的各种方法。由于本书使用Python编写算法，因此解释了如何设置环境来运行示例。然后，讨论了算法性能可以如何量化并与其他算法进行比较的各种方法。最后，本章讨论了验证算法特定实现的各种方法。
- en: 'To sum up, this chapter covers the following main points:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，本章涵盖了以下主要内容：
- en: What is an algorithm?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是算法？
- en: Specifying the logic of an algorithm
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定算法的逻辑
- en: Introducing Python packages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Python包
- en: Algorithm design techniques
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法设计技术
- en: Performance analysis
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析
- en: Validating an algorithm
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证算法
- en: What is an algorithm?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是算法？
- en: 'In the simplest terms, an algorithm is a set of rules for carrying out some
    calculations to solve a problem. It is designed to yield results for any valid
    input according to precisely defined instructions. If you look up the word algorithm
    in an English language dictionary (such as American Heritage), it defines the
    concept as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，算法是一组用于解决问题的计算规则。它旨在根据精确定义的指令为任何有效输入产生结果。如果您在英语词典（如美国传统）中查找算法一词，它定义了以下概念：
- en: '"An algorithm is a finite set of unambiguous instructions that, given some
    set of initial conditions, can be performed in a prescribed sequence to achieve
    a certain goal and that has a recognizable set of end conditions."'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “算法是一组明确的指令，给定一些初始条件，可以按照规定的顺序执行，以达到某个目标，并具有可识别的一组结束条件。”
- en: Designing an algorithm is an effort to create a mathematical recipe in the most
    efficient way that can effectively be  used to solve a real-world problem. This
    recipe may be used as the basis for developing a more reusable and generic mathematical
    solution that can be applied to a wider set of similar problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 设计算法是创建数学配方的努力，以最有效的方式解决现实世界的问题。这个配方可以作为开发更可重用和通用的数学解决方案的基础，可以应用于更广泛的类似问题集。
- en: The phases of an algorithm
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法的阶段
- en: 'The different phases of developing, deploying, and finally using an algorithm
    are illustrated in the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了开发、部署和最终使用算法的不同阶段：
- en: '![](assets/c355481f-a903-437d-b3af-55bc3f84c8c1.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c355481f-a903-437d-b3af-55bc3f84c8c1.png)'
- en: As we can see, the process starts with understanding the requirements from the
    problem statement that detail what needs to be done. Once the problem is clearly
    stated, it leads us to the development phase.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个过程始于理解问题陈述中的需求，详细说明了需要做什么。一旦问题清晰陈述，就会引导我们进入开发阶段。
- en: 'The development phase consists of two phases:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 开发阶段包括两个阶段：
- en: '**The design phase**: In the design phase, the architecture, logic, and implementation
    details of the algorithm are envisioned and documented. While designing an algorithm,
    we keep both accuracy and performance in mind. While searching for the solution
    to a given problem, in many cases we will end up having more than one alternative
    algorithm. The design phase of an algorithm is an iterative process that involves
    comparing different candidate algorithms. Some algorithms may provide simple and
    fast solutions but may compromise on accuracy. Other algorithms may be very accurate
    but may take considerable time to run due to their complexity. Some of these complex
    algorithms may be more efficient than others. Before making a choice, all the
    inherent tradeoffs of the candidate algorithms should be carefully studied. Particularly
    for a complex problem, designing an efficient algorithm is really important. A
    correctly designed algorithm will result in an efficient solution that will be
    capable of providing both satisfactory performance and reasonable accuracy at
    the same time.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计阶段**：在设计阶段，算法的架构、逻辑和实现细节被构想和记录下来。在设计算法时，我们同时考虑准确性和性能。在寻找给定问题的解决方案时，在许多情况下，我们会得到多个备选算法。算法的设计阶段是一个迭代过程，涉及比较不同的候选算法。一些算法可能提供简单快速的解决方案，但可能会牺牲准确性。其他算法可能非常准确，但由于复杂性需要花费相当长的时间来运行。其中一些复杂算法可能比其他算法更有效。在做出选择之前，应仔细研究候选算法的所有固有权衡。特别是对于复杂问题，设计高效的算法非常重要。正确设计的算法将导致有效的解决方案，能够同时提供令人满意的性能和合理的准确性。'
- en: '**The coding phase**:In the coding phase, the designed algorithm is converted
    into a computer program. It is important that the actual program implements all
    the logic and architecture suggested in the design phase.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编码阶段**：在编码阶段，设计的算法被转换为计算机程序。实际程序实现设计阶段建议的所有逻辑和架构是很重要的。'
- en: 'The designing and coding phases of an algorithm are iterative in nature. Coming
    up with a design that meets both functional and non-functional requirements may
    take lots of time and effort. Functional requirements are those requirements that
    dictate what the right output for a given set of input data is. Non-functional
    requirements of an algorithm are mostly about the  performance for a given size
    of data. Validation and performance analysis of an algorithm are discussed later
    in this chapter. Validating an algorithm is about verifying that an algorithm
    meets its functional requirements. Performance analysis of an algorithm is about
    verifying that it meets its main non-functional requirement: performance.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的设计和编码阶段是迭代的。设计满足功能和非功能需求的设计可能需要大量的时间和精力。功能需求是指定给定输入数据的正确输出是什么的要求。算法的非功能需求主要是关于给定数据大小的性能。算法的验证和性能分析将在本章后面讨论。验证算法是验证算法是否满足其功能需求。算法的性能分析是验证它是否满足其主要的非功能需求：性能。
- en: Once designed and implemented in a programming language of your choice, the
    code of the algorithm is ready to be deployed. Deploying an algorithm involves
    the design of the actual production environment where the code will run. The production
    environment needs to be designed according to the data and processing needs of
    the algorithm. For example, for parallelizable algorithms, a cluster with an appropriate
    number of computer nodes will be needed for the efficient execution of the algorithm.
    For data-intensive algorithms, a data ingress pipeline and the strategy to cache
    and store data may need to be designed. Designing a production environment is
    discussed in more detail in [Chapter 13](271840d5-2d10-4fde-b403-d1a6657e10df.xhtml),
    *Large Scale Algorithms*, and [Chapter 14](28c50635-5b35-4f5f-a65b-2d4e984bdad5.xhtml),
    *Practical Considerations*. Once the production environment is designed and implemented,
    the algorithm is deployed, which takes the input data, processes it, and generates
    the output as per the requirements.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设计并在您选择的编程语言中实现，算法的代码就可以部署了。部署算法涉及设计实际的生产环境，代码将在其中运行。生产环境需要根据算法的数据和处理需求进行设计。例如，对于可并行化的算法，需要具有适当数量的计算节点的集群，以便有效地执行算法。对于数据密集型算法，可能需要设计数据进入管道和缓存和存储数据的策略。生产环境的设计将在[第13章](271840d5-2d10-4fde-b403-d1a6657e10df.xhtml)“大规模算法”和[第14章](28c50635-5b35-4f5f-a65b-2d4e984bdad5.xhtml)“实际考虑”中更详细地讨论。一旦设计并实施了生产环境，算法就可以部署，它将接受输入数据，处理它，并根据要求生成输出。
- en: Specifying the logic of an algorithm
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定算法的逻辑
- en: When designing an algorithm, it is important to find different ways to specify
    its details. The ability to capture both its logic and architecture is required.
    Generally, just like building a home, it is important to specify the structure
    of an algorithm before actually implementing it. For more complex distributed
    algorithms, pre-planning the way their logic will be distributed across the cluster
    at running time is important for the iterative efficient design process. Through
    pseudocode and execution plans, both these needs are fulfilled and are discussed
    in the next section.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计算法时，重要的是找到不同的方式来指定其细节。需要能够捕捉其逻辑和架构。通常，就像建造房屋一样，在实际实施算法之前，指定算法的结构是很重要的。对于更复杂的分布式算法，预先规划它们的逻辑在运行时如何分布在集群中对于迭代式高效设计过程是重要的。通过伪代码和执行计划，这两个需求都得到满足，并将在下一节中讨论。
- en: Understanding pseudocode
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解伪代码
- en: 'The simplest way to specify the logic for an algorithm is to write the higher-level
    description of an algorithm in a semi-structured way, called **pseudocode**. Before
    writing the logic in pseudocode, it is helpful to first describe its main flow
    by writing the main steps in plain English. Then, this English description is
    converted into pseudocode, which is a structured way of writing this English description
    that closely represents the logic and flow for the algorithm. Well-written algorithm
    pseudocode should describe the high-level steps of the algorithm in reasonable
    detail, even if the detailed code is not relevant to the main flow and structure
    of the algorithm. The following figure shows the flow of steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 指定算法逻辑的最简单方法是以半结构化方式编写算法的高级描述，称为**伪代码**。在用伪代码编写逻辑之前，首先描述其主要流程并用简单的英语写出主要步骤是有帮助的。然后，将这个英语描述转换成伪代码，这是一种以结构化方式编写这个英语描述的方法，它紧密地代表了算法的逻辑和流程。良好编写的算法伪代码应该以合理的细节描述算法的高级步骤，即使详细的代码与主要流程和结构无关。下图显示了步骤的流程：
- en: '![](assets/fd17310d-27ab-49b0-8620-05e4021a34e8.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: 伪代码的一个实际例子
- en: Note that once the pseudocode is written (as we will see in the next section),
    we are ready to  code the algorithm using the programming language of our choice.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦编写了伪代码（如我们将在下一节中看到的），我们就可以使用我们选择的编程语言编写算法代码了。
- en: A practical example of pseudocode
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![](assets/fd17310d-27ab-49b0-8620-05e4021a34e8.png)'
- en: 'Figure 1.3 shows the pseudocode of a resource allocation algorithm called **SRPMP**.In
    cluster computing, there are many situations where there are parallel tasks that
    need to be run on a set of available resources, collectively  called a **resource
    pool**. This algorithm assigns tasks to a resource and creates a mapping set,
    called `Ω`. Note that the presented pseudocode captures the logic and flow of
    the algorithm, which is further explained in the following section:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3显示了一个名为**SRPMP**的资源分配算法的伪代码。在集群计算中，有许多情况需要在一组可用资源上运行并行任务，统称为**资源池**。这个算法将任务分配给一个资源，并创建一个称为`Ω`的映射集。请注意，所呈现的伪代码捕捉了算法的逻辑和流程，这在下一节中进一步解释：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s parse this algorithm line by line:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行解析这个算法：
- en: We start the mapping by executing the algorithm. The `Ω` mapping set is empty.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过执行算法开始映射。`Ω`映射集是空的。
- en: The first partition is selected as the resource pool for the `T[1]` task (see
    line 3 of the preceding code). **Television Rating Point** (**TRPS**) iteratively
    calls the **Rheumatoid** **Arthritis** (**RA**)algorithm for each `T[i]`  task
    with one of the partitions chosen as the resource pool.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个分区被选为`T[1]`任务的资源池（参见前面代码的第3行）。**电视收视率**（**TRPS**）迭代地调用**类风湿性关节炎**（**RA**）算法，对于每个`T[i]`任务，选择一个分区作为资源池。
- en: The RA algorithm returns the set of resources chosen for the `T[i]`  task, represented
    by `ω[i]`  (see line 5 of the preceding code).
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RA算法返回为`T[i]`任务选择的资源集，由`ω[i]`表示（参见前面代码的第5行）。
- en: '`T[i]`  and `ω[i]` are added to the mapping set (see line 6 of the preceding
    code).'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`T[i]`和`ω[i]`被添加到映射集中（参见前面代码的第6行）。'
- en: The state of `T[i]`  is changed from `STATE 0:Idle/Mapping` to `STATE 1:Idle/Mapped`
    (see line 7 of the preceding code).
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`T[i]`的状态从`STATE 0:Idle/Mapping`更改为`STATE 1:Idle/Mapped`（参见前面代码的第7行）。'
- en: Note that for the first iteration, `k=1` and the first partition is selected.
    For each subsequent iteration, the value of `k` is increased until `k>q`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，对于第一次迭代，`k=1`，并且选择了第一个分区。对于每个后续迭代，`k`的值增加，直到`k>q`。
- en: If `k` becomes greater than `q`, it is reset to `1` again (see lines 9 and 10
    of the preceding code).
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`k`变得大于`q`，它会再次重置为`1`（参见前面代码的第9和第10行）。
- en: This process is repeated until a mapping between all tasks and the set of resources
    they will use is determined and stored in a mapping set called `Ω`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个过程重复进行，直到确定并存储了所有任务与它们将使用的资源集之间的映射，并存储在一个称为`Ω`的映射集中。
- en: Once each of the tasks is mapped to a set of the resources in the mapping phase,
    it is executed.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦每个任务在映射阶段映射到一组资源中，它就会被执行。
- en: Using snippets
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用片段
- en: 'With the popularity of simple but powerful coding language such as Python,
    an alternative approach is becoming popular, which is to represent the logic of
    the algorithm directly in the programming language in a somewhat simplified version.
    Like pseudocode, this selected code captures the important logic and structure
    of the proposed algorithm, avoiding detailed code. This selected code is sometimes
    called a **snippet**. In this book, snippets are used instead of pseudocode wherever
    possible as they save one additional step. For example, let''s look at a simple
    snippet that is about a Python function that can be used to swap two variables:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Python等简单但功能强大的编程语言的流行，另一种替代方法变得流行，即直接用编程语言表示算法的逻辑，以一种简化的方式。与伪代码一样，这个选定的代码捕捉了所提出的算法的重要逻辑和结构，避免了详细的代码。这个选定的代码有时被称为**片段**。在本书中，尽可能使用片段代替伪代码，因为它们节省了一个额外的步骤。例如，让我们看一个简单的片段，它是一个关于可以用来交换两个变量的Python函数的片段：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that snippets cannot always replace pseudocode. In pseudocode, sometimes
    we abstract many lines of code as one line of pseudocode, expressing the logic
    of the algorithm without becoming distracted by unnecessary coding details.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，片段并不能总是替代伪代码。在伪代码中，有时我们将许多行代码抽象为一行伪代码，表达算法的逻辑，而不会被不必要的编码细节分散注意力。
- en: Creating an execution plan
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建执行计划
- en: Pseudocode and snippets are not always enough to specify all the logic related
    to more complex distributed algorithms. For example, distributed algorithms usually
    need to be divided into different coding phases at runtime that have a precedence
    order. The right strategy to divide the larger problem into an optimal number
    of phases with the right precedence constraints is crucial for the efficient execution
    of an algorithm.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 伪代码和片段并不总是足以指定与更复杂的分布式算法相关的所有逻辑。例如，分布式算法通常需要在运行时分成不同的编码阶段，这些阶段具有优先顺序。将较大的问题划分为最佳数量的阶段，并具有正确的优先约束条件的正确策略对于有效执行算法至关重要。
- en: 'We need to find a way to represent this strategy as well to completely represent
    the logic and structure of an algorithm. An execution plan is one of the ways
    of detailing how the algorithm will be subdivided into a bunch of tasks. A task
    can be mappers or reducers that can be grouped together in blocks called **stages**.
    The following diagram shows an execution plan that is generated by an Apache Spark
    runtime before executing an algorithm. It details the runtime tasks that the job
    created for executing our algorithm will be divided into:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到一种方法来表示这种策略，以完全表示算法的逻辑和结构。执行计划是详细说明算法将如何被细分为一堆任务的一种方式。一个任务可以是映射器或减速器，可以被分组在称为**阶段**的块中。下图显示了在执行算法之前由Apache
    Spark运行时生成的执行计划。它详细说明了作业为执行我们的算法创建的运行时任务将被分成：
- en: '![](assets/c2519fcc-2e00-4c7d-948f-a25853e3d835.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c2519fcc-2e00-4c7d-948f-a25853e3d835.png)'
- en: 'Note that the preceding diagram has five tasks that have been divided into
    two different stages: Stage 11 and Stage 12.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的图表有五个任务，它们被分成了两个不同的阶段：阶段11和阶段12。
- en: Introducing Python packages
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入Python包
- en: Once designed, algorithms need to be implemented in a programming language as
    per the design. For this book, I chose the programming language Python. I chose
    it because Python is a flexible and open source programming language. Python is
    also the language of choice for increasingly important cloud computing infrastructures,
    such as **Amazon Web Services**  (**AWS**), Microsoft Azure, and **Google Cloud
    Platform** (**GCP**).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设计好算法，就需要根据设计在编程语言中实现。对于本书，我选择了编程语言Python。我选择它是因为Python是一种灵活的开源编程语言。Python也是越来越重要的云计算基础设施的首选语言，如**亚马逊网络服务**（**AWS**）、微软Azure和**谷歌云平台**（**GCP**）。
- en: The official Python home page is available at [https://www.python.org/](https://www.python.org/),
    which also has instructions for installation and a useful beginner's guide.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 官方Python主页可在[https://www.python.org/](https://www.python.org/)找到，其中还有安装说明和有用的初学者指南。
- en: If you have not used Python before, it is a good idea to browse through this
    beginner's guide to self-study. A basic understanding of Python will help you
    to better understand the concepts presented in this book.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前没有使用过Python，浏览这本初学者指南是一个好主意。对Python的基本理解将有助于您更好地理解本书中提出的概念。
- en: For this book, I expect you to use the recent version of Python 3\. At the time
    of writing, the most recent version is 3.7.3, which is what we will use to run
    the exercises in this book.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书，我希望您使用最新版本的Python 3。在撰写本文时，最新版本是3.7.3，这是我们将用来运行本书中的练习的版本。
- en: Python packages
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python软件包
- en: 'Python is a general-purpose language. It is designed in a way that comes with
    bare minimum functionality. Based on the use case that you intend to use Python
    for, additional packages need to be installed. The easiest way to install additional
    packages is through the pip installer program. This `pip` command can be used
    to install the additional packages:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种通用语言。它设计成具有最基本的功能。根据您打算使用Python的用例，需要安装额外的软件包。安装额外软件包的最简单方法是通过pip安装程序。这个`pip`命令可以用来安装额外的软件包：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The packages that have already been installed need to be periodically updated
    to get the latest functionality. This is achieved by using the `upgrade` flag:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 已安装的软件包需要定期更新以获得最新功能。这可以通过使用`upgrade`标志来实现：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Another Python distribution for scientific computing is Anaconda, which can
    be downloaded from [http://continuum.io/downloads](http://continuum.io/downloads).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 用于科学计算的另一个Python发行版是Anaconda，可以从[http://continuum.io/downloads](http://continuum.io/downloads)下载。
- en: 'In addition to using the `pip` command to install new packages, for Anaconda
    distribution, we also have the option of using the following command to install
    new packages:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`pip`命令安装新软件包外，对于Anaconda发行版，我们还可以使用以下命令来安装新软件包：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To update the existing packages, the Anaconda distribution gives us the option
    to use the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新现有的软件包，Anaconda发行版提供了以下命令选项：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are all sorts of Python packages that are available. Some of the important
    packages that are relevant for algorithms are described in the following section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种各样的Python软件包可用。一些与算法相关的重要软件包在以下部分中进行了描述。
- en: The SciPy ecosystem
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SciPy生态系统
- en: Scientific Python (SciPy)—pronounced *sigh pie—*is a group of Python packages
    created for the scientific community. It  contains many functions, including a
    wide range of random number generators, linear algebra routines, and optimizers.
    SciPy is a comprehensive package and, over time, people have developed many extensions
    to customize and extend the package according to their needs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 科学Python（SciPy）——发音为*sigh pie*——是为科学界创建的一组Python软件包。它包含许多函数，包括各种随机数生成器、线性代数例程和优化器。SciPy是一个综合性的软件包，随着时间的推移，人们开发了许多扩展来根据自己的需求定制和扩展软件包。
- en: 'The following are the main packages that are part of this ecosystem:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该生态系统的主要软件包：
- en: '**NumPy**:For algorithms, the ability to create multi-dimensional data structures,
    such as arrays and matrices, is really important. NumPy offers a set of array
    and matrix data types that are important for statistics and data analysis. Details
    about NumPy can be found at [http://www.numpy.org/](http://www.numpy.org/).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NumPy**：对于算法来说，创建多维数据结构（如数组和矩阵）的能力非常重要。NumPy提供了一组重要的用于统计和数据分析的数组和矩阵数据类型。有关NumPy的详细信息可以在[http://www.numpy.org/](http://www.numpy.org/)找到。'
- en: '**scikit-learn**:This machine learning extension is one of the most popular
    extensions of SciPy. Scikit-learn provides a wide range of important machine learning
    algorithms, including classification, regression, clustering, and model validation.
    You can find more details about scikit-learn at [http://scikit-learn.org/](http://scikit-learn.org/).'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**scikit-learn**：这个机器学习扩展是SciPy最受欢迎的扩展之一。Scikit-learn提供了一系列重要的机器学习算法，包括分类、回归、聚类和模型验证。您可以在[http://scikit-learn.org/](http://scikit-learn.org/)找到有关scikit-learn的更多详细信息。'
- en: '**pandas**:pandas is an open source software library. It contains the tabular
    complex data structure that is used widely to input, output, and process tabular
    data in various algorithms. The pandas library contains many useful functions
    and it also offers highly optimized performance. More details about pandas can
    be found at [http://pandas.pydata.org/](http://pandas.pydata.org/).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pandas**：pandas是一个开源软件库。它包含了广泛用于输入、输出和处理表格数据的表格复杂数据结构。pandas库包含许多有用的函数，还提供了高度优化的性能。有关pandas的更多详细信息可以在[http://pandas.pydata.org/](http://pandas.pydata.org/)找到。'
- en: '**Matplotlib**:Matplotlib provides tools to create powerful visualizations.
    Data can be presented as line plots, scatter plots, bar charts, histograms, pie
    charts, and so on. More information can be found at [https://matplotlib.org/](https://matplotlib.org/).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Matplotlib**：Matplotlib提供了创建强大可视化的工具。数据可以呈现为折线图、散点图、条形图、直方图、饼图等。更多信息可以在[https://matplotlib.org/](https://matplotlib.org/)找到。'
- en: '**Seaborn**:Seaborn can be thought of as similar to the popular ggplot2 library
    in R. It is based on Matplotlib and offers an advanced interface  for  drawing
    brilliant statistical  graphics. Further details can be found at [https://seaborn.pydata.org/](https://seaborn.pydata.org/).'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Seaborn**：Seaborn可以被认为类似于R中流行的ggplot2库。它基于Matplotlib，并提供了一个高级接口来绘制出色的统计图形。更多细节可以在[https://seaborn.pydata.org/](https://seaborn.pydata.org/)找到。'
- en: '**iPython**:iPython is an enhanced interactive console that is designed to
    facilitate the writing, testing, and debugging of Python code.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iPython**：iPython是一个增强的交互式控制台，旨在促进编写，测试和调试Python代码。'
- en: '**Running Python programs**:An interactive mode of programming is useful for
    learning and experimenting with code. Python programs can be saved in a text file
    with the `.py` extension and that file can be run from the console.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行Python程序**：交互式编程模式对于学习和实验代码非常有用。 Python程序可以保存在带有`.py`扩展名的文本文件中，并且可以从控制台运行该文件。'
- en: Implementing Python via the Jupyter Notebook
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Jupyter Notebook实现Python
- en: Another way to run Python programs is through the Jupyter Notebook. The Jupyter
    Notebook provides a browser-based user interface to develop code. The Jupyter
    Notebook is used to present the code examples in this book. The ability to annotate
    and describe the code with texts and graphics makes it the perfect tool for presenting
    and explaining an algorithm and a great tool for learning.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Jupyter Notebook运行Python程序的另一种方式。 Jupyter Notebook提供了基于浏览器的用户界面来开发代码。 Jupyter
    Notebook用于在本书中展示代码示例。 用文本和图形注释和描述代码的能力使其成为呈现和解释算法的完美工具，也是学习的好工具。
- en: 'To start the notebook, you need to start the `Juypter-notebook` process and
    then open your favorite browser and navigate to `http://localhost:8888`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动笔记本，您需要启动`Juypter-notebook`进程，然后打开您喜欢的浏览器并导航到`http://localhost:8888`：
- en: '![](assets/3667b86b-2e9a-4e5c-a3f4-8b4da8372dae.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3667b86b-2e9a-4e5c-a3f4-8b4da8372dae.png)'
- en: Note that a Jupyter Notebook consists of different blocks called **cells**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Jupyter Notebook由称为**单元格**的不同块组成。
- en: Algorithm design techniques
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法设计技术
- en: 'An algorithm is a mathematical solution to a real-world problem. When designing
    an algorithm, we keep the following three design concerns in mind as we work on
    designing and fine-tuning the algorithms:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 算法是对现实世界问题的数学解决方案。在设计算法时，我们在设计和微调算法时牢记以下三个设计关注点：
- en: '**Concern 1**: Is this algorithm producing the result we expected?'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注1**：这个算法是否产生了我们预期的结果？'
- en: '**Concern 2**: Is this the most optimal way to get these results?'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注2**：这是获得这些结果的最佳方式吗？'
- en: '**Concern 3**: How is the algorithm going to perform on larger datasets?'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注3**：算法在更大的数据集上的表现如何？'
- en: 'It is important to better understand the complexity of the problem itself before
    designing a solution for it. For example, it helps us to design an appropriate
    solution if we characterize the problem in terms of its needs and complexity.
    Generally, the algorithms can be divided into the following types based on the
    characteristics of the problem:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计解决方案之前更好地了解问题本身的复杂性是很重要的。例如，如果我们根据需求和复杂性对问题进行表征，这有助于我们设计适当的解决方案。通常，根据问题的特征，算法可以分为以下类型：
- en: '**Data-intensive algorithms:** Data-intensive algorithms are designed to deal
    with a large amount of data. They are expected to have relatively simplistic processing
    requirements. A compression algorithm applied to a huge file is a good example
    of data-intensive algorithms. For such algorithms, the size of the data is expected
    to be much larger than the memory of the processing engine (a single node or cluster)
    and an iterative processing design may need to be developed to efficiently process
    the data according to the requirements.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据密集型算法**：数据密集型算法旨在处理大量数据。预计它们具有相对简单的处理要求。应用于大型文件的压缩算法是数据密集型算法的一个很好的例子。对于这样的算法，数据的大小预计会远大于处理引擎（单个节点或集群）的内存，并且可能需要开发迭代处理设计以根据要求高效处理数据。'
- en: '**Compute-intensive algorithms**: Compute-intensive algorithms have considerable
    processing requirements but do not involve large amounts of data. A simple example
    is the algorithm to find a very large prime number. Finding a strategy to divide
    the algorithm into different phases so that at least some of the phases are parallelized
    is key to maximizing the performance of the algorithm.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算密集型算法**：计算密集型算法具有相当大的处理需求，但不涉及大量数据。一个简单的例子是查找非常大的质数的算法。找到将算法分成不同阶段的策略，以便至少有一些阶段是并行化的，是最大化算法性能的关键。'
- en: '**Both data and compute-intensive algorithms**: There are certain algorithms
    that deal with a large amount of data and also have considerable computing requirements.
    Algorithms used to perform sentiment analysis on live video feeds are a good example
    of where both the data and the processing requirements are huge in accomplishing
    the task. Such algorithms are the most resource-intensive algorithms and require
    careful design of the algorithm and intelligent allocation of available resources.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据和计算密集型算法**：有些算法处理大量数据，并且具有相当大的计算需求。用于对实时视频流执行情感分析的算法是处理任务中数据和处理要求都很大的很好的例子。这些算法是最资源密集的算法，需要仔细设计算法并智能分配可用资源。'
- en: To characterize the problem in terms of its complexity and needs, it helps if
    we study its data and compute dimensions in more depth, which we will do in the
    following section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地研究问题的复杂性和需求，有助于我们研究其数据并计算更深入的维度，这将在下一节中进行。
- en: The data dimension
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据维度
- en: 'To categorize the data dimension of the problem, we look at its **volume**,
    **velocity**, and **variety** (the **3Vs**), which are defined as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对问题的数据维度进行分类，我们看看其**体积**，**速度**和**多样性**（**3V**），其定义如下：
- en: '**Volume**: The volume is the expected size of the data that the algorithm
    will process.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**体积**：体积是算法将处理的数据的预期大小。'
- en: '**Velocity**: The velocity is the expected rate of new data generation when
    the algorithm is used. It can be zero.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：速度是在使用算法时预期的新数据生成速率。它可以为零。'
- en: '**Variety**: The variety quantifies how many different types of data the designed
    algorithm is expected to deal with.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多样性**：多样性量化了设计的算法预计要处理多少不同类型的数据。'
- en: 'The following figure shows the 3Vs of the data in more detail. The center of
    this diagram shows the simplest possible data, with a small volume and low variety
    and velocity. As we move away from the center, the complexity of the data increases.
    It can increase in one or more of the three dimensions. For example, in the dimension
    of velocity, we have the Batch process as the simplest, followed by the Periodic
    process, and then the Near Real-Time process. Finally, we have the Real-Time process,
    which is the most complex to handle in the context of data velocity. For example,
    a collection of live video feeds gathered by a group of monitoring cameras will
    have a high volume, high velocity, and high variety and may need an appropriate
    design to have the ability to store and process data effectively. On the other
    hand, a simple `.csv` file created in Excel will have a low volume, low velocity,
    and low variety:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下图更详细地显示了数据的3Vs。这个图的中心显示了最简单的数据，体积小，多样性和速度低。当我们远离中心时，数据的复杂性增加。它可以在三个维度中的一个或多个维度上增加。例如，在速度维度上，我们有批处理作为最简单的，然后是周期性处理，然后是准实时处理。最后，我们有实时处理，在数据速度的背景下处理起来最复杂。例如，由一组监控摄像头收集的实时视频流将具有高体积、高速度和高多样性，并且可能需要适当的设计来有效地存储和处理数据。另一方面，一个在Excel中创建的简单`.csv`文件将具有低体积、低速度和低多样性：
- en: '![](assets/7a6d1af7-5c9b-448c-a5b6-c6ef6b299db5.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7a6d1af7-5c9b-448c-a5b6-c6ef6b299db5.png)'
- en: For example, if the input data is a simple `csv` file, then the volume, velocity,
    and variety of the data will be low. On the other hand, if the input data is the
    live stream of a security video camera, then the volume, velocity, and variety
    of the data will be quite high and this problem should be kept in mind while designing
    an algorithm for it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果输入数据是一个简单的`csv`文件，那么数据的体积、速度和多样性将很低。另一方面，如果输入数据是安全视频摄像头的实时视频流，那么数据的体积、速度和多样性将会很高，这个问题在设计算法时应该牢记在心。
- en: Compute dimension
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算维度
- en: The compute dimension is about the processing and computing needs of the problem
    at hand. The processing requirements of an algorithm will determine what sort
    of design is most efficient for it. For example, deep learning algorithms, in
    general, require lots of processing power. It means that for deep learning algorithms,
    it is important to have multi-node parallel architecture wherever possible.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 计算维度是关于问题处理和计算需求的。算法的处理需求将决定最有效的设计是什么样的。例如，深度学习算法通常需要大量的处理能力。这意味着对于深度学习算法，尽可能拥有多节点并行架构是很重要的。
- en: A practical example
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个实际的例子
- en: 'Let''s assume that we want to conduct sentiment analysis on a video. Sentiment
    analysis is where we try to flag different portions of a video with human emotions
    of sadness, happiness, fear, joy, frustration, and ecstasy. It is a compute-intensive
    job where lots of computing power is needed. As you will see in the following
    figure, to design the compute dimension, we have divided the processing into five
    tasks, consisting of two stages. All the data transformation and preparation is
    implemented in three mappers. For that, we divide the video into three different
    partitions, called **splits**. After the mappers are executed, the resulting processed
    video is inputted to the two aggregators, called **reducers**. To conduct the
    required sentiment analysis, the reducers group the video according to the emotions.
    Finally, the results are combined in the output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想对一个视频进行情感分析。情感分析是指我们试图标记视频中不同部分的人类情感，如悲伤、快乐、恐惧、喜悦、挫折和狂喜。这是一个计算密集型的工作，需要大量的计算能力。正如你将在下图中看到的，为了设计计算维度，我们将处理分为五个任务，包括两个阶段。所有的数据转换和准备都是在三个mapper中实现的。为此，我们将视频分成三个不同的分区，称为**拆分**。在mapper执行完毕后，处理后的视频输入到两个聚合器，称为**reducer**。为了进行所需的情感分析，reducer根据情感对视频进行分组。最后，结果在输出中合并。
- en: '![](assets/e48c6ab1-cc03-463a-a759-a5ad2f48442f.png)Note that the number of
    mappers directly translates to the runtime parallelism of the algorithm. The optimal
    number of mappers and reducers is dependent on the characteristics of the data,
    the type of algorithm that is needed to be used, and the number of resources available.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/e48c6ab1-cc03-463a-a759-a5ad2f48442f.png)请注意，mapper的数量直接影响算法的运行并行性。最佳的mapper和reducer数量取决于数据的特性、需要使用的算法类型以及可用资源的数量。'
- en: Performance analysis
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析
- en: Analyzing the performance of an algorithm is an important part of its design.
    One of the ways to estimate the performance of an algorithm is to analyze its
    complexity.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 分析算法的性能是设计的重要部分。估计算法性能的一种方法是分析其复杂性。
- en: 'Complexity theory is the study of how complicated algorithms are. To be useful,
    any algorithm should have three key features:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性理论是研究复杂算法的学科。为了有用，任何算法都应该具有三个关键特征：
- en: It should be correct. An algorithm won't do you much good if it doesn't give
    you the right answers.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该是正确的。如果算法不能给出正确的答案，那么它对你来说没有太大的好处。
- en: A good algorithm should be understandable. The best algorithm in the world won't
    do you any good if it's too complicated for you to implement on a computer.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好的算法应该是可以理解的。即使是世界上最好的算法，如果对你来说太复杂而无法在计算机上实现，那也没有什么好处。
- en: A good algorithm should be efficient. Even if an algorithm produces a correct
    result, it won't help you much if it takes a thousand years or if it requires
    1 billion terabytes of memory.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个好的算法应该是高效的。即使一个算法产生了正确的结果，如果它需要花费一千年或者需要十亿太字节的内存，也不会对你有太大帮助。
- en: 'There are two possible types of analysis to quantify the complexity of an algorithm:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 算法复杂度的两种可能的分析类型：
- en: 'Space complexity analysis: Estimates the runtime memory requirements needed
    to execute the algorithm.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空间复杂度分析：估计执行算法所需的运行时内存需求。
- en: 'Time complexity analysis: Estimates the time the algorithm will take to run.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间复杂度分析：估计算法运行所需的时间。
- en: Space complexity analysis
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间复杂度分析
- en: Space complexity analysis estimates the amount of memory required by the algorithm
    to process input data. While processing the input data, the algorithm needs to
    store the transient temporary data structures in memory. The way the algorithm
    is designed affects the number, type, and size of these data structures. In an
    age of distributed computing and with increasingly large amounts of data that
    needs to be processed, space complexity analysis is becoming more and more important.
    The size, type, and number of these data structures will dictate the memory requirements
    for the underlying hardware. Modern in-memory data structures used in distributed
    computing—such as **Resilient Distributed Datasets** (**RDDs**)—need to have efficient
    resource allocation mechanisms that are aware of the memory requirements at different
    execution phases of the algorithm.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 空间复杂度分析估计算法处理输入数据所需的内存量。在处理输入数据时，算法需要将瞬态临时数据结构存储在内存中。算法的设计方式会影响这些数据结构的数量、类型和大小。在分布式计算时代，需要处理越来越多的数据，空间复杂度分析变得越来越重要。这些数据结构的大小、类型和数量将决定底层硬件的内存需求。在分布式计算中使用的现代内存数据结构，如弹性分布式数据集（RDD），需要具有高效的资源分配机制，以便在算法的不同执行阶段了解内存需求。
- en: Space complexity analysis is a must for the efficient design of algorithms.
    If proper space complexity analysis is not conducted while designing a particular
    algorithm, insufficient memory availability for the transient temporary data structures
    may trigger unnecessary disk spillovers, which could potentially considerably
    affect the performance and efficiency of the algorithm.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 空间复杂度分析是算法高效设计的必要条件。如果在设计特定算法时没有进行适当的空间复杂度分析，那么对于瞬态临时数据结构的内存可用性不足可能会触发不必要的磁盘溢出，这可能会显著影响算法的性能和效率。
- en: In this chapter, we will look deeper into time complexity. Space complexity
    will be discussed in [Chapter 13](271840d5-2d10-4fde-b403-d1a6657e10df.xhtml),
    *Large-Scale Algorithms*, in more detail, where we will deal with large-scale
    distributed algorithms with complex runtime memory requirements.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地研究时间复杂度。空间复杂度将在第13章《大规模算法》中更详细地讨论，那里我们将处理具有复杂运行时内存需求的大规模分布式算法。
- en: Time complexity analysis
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间复杂度分析
- en: Time complexity analysis estimates how long it will take for an algorithm to
    complete its assigned job based on its structure. In contrast to space complexity,
    time complexity is not dependent on any hardware that the algorithm will run on.
    Time complexity analysis solely depends on the structure of the algorithm itself.
    The overall goal of time complexity analysis is to try to answer these important
    questions—will this algorithm scale? How well will this algorithm handle larger
    datasets?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 时间复杂度分析估计算法基于其结构完成其分配工作所需的时间。与空间复杂度相比，时间复杂度不依赖于算法将在其上运行的任何硬件。时间复杂度分析仅仅取决于算法本身的结构。时间复杂度分析的总体目标是尝试回答这些重要问题——这个算法是否可扩展？这个算法将如何处理更大的数据集？
- en: To answer these questions, we need to determine the effect on the performance
    of an algorithm as the size of the data is increased and make sure that the algorithm
    is designed in a way that not only makes it accurate but also scales well. The
    performance of an algorithm is becoming more and more important for larger datasets
    in today's world of "big data."
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，我们需要确定算法在数据规模增大时对性能的影响，并确保算法不仅准确而且能够良好扩展。在当今“大数据”世界中，算法的性能对于更大的数据集变得越来越重要。
- en: 'In many cases, we may have more than one approach available to design the algorithm.
    The goal of conducting time complexity analysis, in this case, will be as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们可能有多种方法来设计算法。在这种情况下进行时间复杂度分析的目标将是：
- en: '"Given a certain problem and more than one algorithm, which one is the most
    efficient to use in terms of time efficiency?"'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: “对于一个特定的问题和多个算法，哪一个在时间效率上最有效？”
- en: 'There can be two basic approaches to calculating the time complexity of an
    algorithm:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 计算算法时间复杂度的基本方法有两种：
- en: '**A post-implementation profiling approach**: In this approach, different candidate
    algorithms are implemented and their performance is compared.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后实现的分析方法：在这种方法中，实现不同的候选算法并比较它们的性能。
- en: '**A pre-implementation theoretical approach**: In this approach, the performance
    of each algorithm is approximated mathematically before running an algorithm.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预实现的理论方法：在运行算法之前，通过数学近似来估计每个算法的性能。
- en: The advantage of the theoretical approach is that it only depends on the structure
    of the algorithm itself. It does not depend on the actual hardware that will be
    used to run the algorithm, the choice of the software stack chosen at runtime,
    or the programming language used to implement the algorithm.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 理论方法的优势在于它仅仅取决于算法本身的结构。它不依赖于实际用于运行算法的硬件、运行时选择的软件栈的选择，或者用于实现算法的编程语言。
- en: Estimating the performance
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能估计
- en: The performance of a typical algorithm will depend on the type of the data given
    to it as an input. For example, if the data is already sorted according to the
    context of the problem we are trying to solve, the algorithm may perform blazingly
    fast. If the sorted input is used to benchmark this particular algorithm, then
    it will give an unrealistically good performance number, which will not be a true
    reflection of its real performance in most scenarios. To handle this dependency
    of algorithms on the input data, we have different types of cases to consider
    when conducting a performance analysis.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 典型算法的性能将取决于输入的数据类型。例如，如果数据已根据我们试图解决的问题的上下文进行了排序，算法可能会执行得非常快。如果排序后的输入用于基准测试这个特定的算法，那么它将给出一个不真实的良好性能数字，这不会真实反映其在大多数情况下的真实性能。为了处理算法对输入数据的依赖性，我们在进行性能分析时需要考虑不同类型的情况。
- en: The best case
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳情况
- en: In the best case, the data given as input is organized in a way that the algorithm
    will give its best performance. Best-case analysis gives the upper bound of the
    performance*.*
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在最佳情况下，输入的数据组织方式使得算法能够发挥最佳性能。最佳情况分析给出了算法性能的上限。
- en: The worst case
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最坏情况
- en: The second way to estimate the performance of an algorithm is to try to find
    the maximum possible time it will take to get the job done under a given set of
    conditions. This worst-case analysis of an algorithm is quite useful as we are
    guaranteeing that regardless of the conditions, the performance of the algorithm
    will always be better than the numbers that come out of our analysis. Worst-case
    analysis is especially useful for estimating the performance when dealing with
    complex problems with larger datasets. Worst-case analysis gives the lower bound
    of the performance of the algorithm.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 估计算法性能的第二种方法是尝试找到在给定一组条件下完成工作所需的最长时间。算法的最坏情况分析非常有用，因为我们保证无论条件如何，算法的性能始终优于我们分析出来的数字。最坏情况分析在处理具有更大数据集的复杂问题时特别有用。最坏情况分析给出了算法性能的下限。
- en: The average case
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平均情况
- en: This starts by dividing the various possible inputs into various groups. Then,
    it conducts the performance analysis from one of the representative inputs from
    each group. Finally, it calculates the average of the performance of each of the
    groups.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这从将各种可能的输入分成各种组开始。然后，从每个组的一个代表性输入进行性能分析。最后，计算每个组的性能的平均值。
- en: Average-case analysis is not always accurate as it needs to consider all the
    different combinations and possibilities of input to the algorithm, which is not
    always easy to do.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 平均情况分析并不总是准确的，因为它需要考虑算法的所有不同组合和可能性，这并不总是容易做到。
- en: Selecting an algorithm
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择算法
- en: How do you know which one is a better solution? How do you know which algorithm
    runs faster? Time complexity and Big O notation (discussed later in this chapter)
    are really good tools for answering these types of questions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你怎么知道哪一个是更好的解决方案？你怎么知道哪个算法运行得更快？时间复杂度和大O符号（本章后面讨论）是回答这些问题的非常好的工具。
- en: To see where it can be useful, let's take a simple example where the objective
    is to sort a list of numbers. There are a couple of algorithms available that
    can do the job. The issue is how to choose the right one.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要看它在哪里有用，让我们举一个简单的例子，目标是对一组数字进行排序。有几种可用的算法可以完成这项工作。问题是如何选择正确的算法。
- en: First, an observation that can be made is that if there are not too many numbers
    in the list, then it does not matter which algorithm do we choose to sort the
    list of numbers. So, if there are only 10 numbers in the list (n=10), then it
    does not matter which algorithm we choose as it would probably not take more than
    a few microseconds, even with a very badly designed algorithm. But as soon as
    the size of the list becomes 1 million, now the choice of the right algorithm
    will make a difference. A very badly written algorithm might even take a couple
    of hours to run, while a well-designed algorithm may finish sorting the list in
    a couple of seconds. So, for larger input datasets, it makes a lot of sense to
    invest time and effort, perform a performance analysis, and choose the correctly
    designed algorithm that will do the job required in an efficient manner.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，可以观察到的一点是，如果列表中的数字不太多，那么我们选择哪种算法来对数字列表进行排序就无关紧要。因此，如果列表中只有10个数字（n=10），那么我们选择哪种算法都无关紧要，因为即使是设计非常糟糕的算法，也可能不会花费超过几微秒的时间。但是一旦列表的大小变成100万，现在选择正确的算法将会有所不同。一个非常糟糕的算法甚至可能需要几个小时才能运行，而一个设计良好的算法可能在几秒内完成对列表的排序。因此，对于更大的输入数据集，投入时间和精力进行性能分析，并选择正确设计的算法来高效地完成所需的工作是非常有意义的。
- en: Big O notation
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大O符号
- en: Big O notation is used to quantify the performance of various algorithms as
    the input size grows. Big O notation is one of the most popular methodologies
    used to conduct worst-case analysis. The different kinds of Big O notation types
    are discussed in this section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 大O符号用于量化各种算法的性能，随着输入规模的增长。大O符号是进行最坏情况分析的最流行方法之一。本节讨论了不同类型的大O符号。
- en: Constant time (O(1)) complexity
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常数时间（O(1)）复杂度
- en: 'If an algorithm takes the same amount of time to run, independent of the size
    of the input data, it is said to run in constant time. It is represented by O(1).
    Let''s take the example of accessing the *n*^(th) element of an array. Regardless
    of the size of the array, it will take constant time to get the results. For example,
    the following function will return the first element of the array and has a complexity
    of O(1):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个算法在运行时所需的时间与输入数据的大小无关，那么它被称为以常数时间运行。它用O(1)表示。让我们以访问数组的第n个元素为例。无论数组的大小如何，获取结果都需要恒定的时间。例如，以下函数将返回数组的第一个元素，并具有O(1)的复杂度：
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is shown as:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](assets/19c85f2d-d972-49ae-b098-b3dfd012daeb.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/19c85f2d-d972-49ae-b098-b3dfd012daeb.png)'
- en: Addition of a new element to a stack by using `push` or removing an element
    from a stack by using `pop`. Regardless of the size of the stack, it will take
    the same time to add or remove an element.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`push`添加新元素到栈或使用`pop`从栈中移除元素。无论栈的大小如何，添加或移除元素都需要相同的时间。
- en: Accessing the element of the hashtable (as discussed in [Chapter 2](04672393-683c-406b-8dd1-4dab5b5d9c4f.xhtml),
    *Data Structures Used in Algorithms*).
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问哈希表的元素（如[第2章](04672393-683c-406b-8dd1-4dab5b5d9c4f.xhtml)中讨论的，*算法中使用的数据结构*）。
- en: Bucket sort (as discussed in [Chapter 2](04672393-683c-406b-8dd1-4dab5b5d9c4f.xhtml),
    *Data Structures Used in Algorithms*).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桶排序（如[第2章](04672393-683c-406b-8dd1-4dab5b5d9c4f.xhtml)中讨论的，*算法中使用的数据结构*）。
- en: Linear time (O(n)) complexity
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性时间（O(n)）复杂度
- en: 'An algorithm is said to have a complexity of linear time, represented by O(n),
    if the execution time is directly proportional to the size of the input. A simple
    example is to add the elements in a single-dimensional data structure:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行时间与输入大小成正比，则称算法具有线性时间复杂度，表示为O(n)。一个简单的例子是在单维数据结构中添加元素：
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note the main loop of the algorithm. The number of iterations in the main loop
    increases linearly with an increasing value of *n*, producing an O(n) complexity
    in the following figure:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意算法的主循环。主循环中的迭代次数随着*n*的增加而线性增加，产生了下图中的O(n)复杂度：
- en: '![](assets/dd689660-a215-40e7-b5ed-3af5bddf280b.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dd689660-a215-40e7-b5ed-3af5bddf280b.png)'
- en: 'Some other examples of array operations are as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 数组操作的其他一些例子如下：
- en: Searching an element
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索一个元素
- en: Finding the minimum value among all the elements of an array
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数组的所有元素中找到最小值
- en: Quadratic time (O(n2)) complexity
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二次时间（O(n²)）复杂度
- en: 'An algorithm is said to run in quadratic time if the execution time of an algorithm
    is proportional to the square of the input size; for example, a simple function
    that sums up a two-dimensional array, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果算法的执行时间与输入大小的平方成正比，则称算法具有二次时间复杂度；例如，一个简单的函数对二维数组求和如下：
- en: '[PRE8]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note the nested inner loop within the other  main loop. This nested loop gives
    the preceding code the complexity of O(n²):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意主循环内嵌在另一个主循环中。这个嵌套循环使得前面的代码具有O(n²)的复杂度：
- en: '![](assets/68f8522f-353e-4392-a9d6-fe0d8f1fe69d.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/68f8522f-353e-4392-a9d6-fe0d8f1fe69d.png)'
- en: Another example is the **bubble sort algorithm** (as discussed in [Chapter 2](04672393-683c-406b-8dd1-4dab5b5d9c4f.xhtml),
    *Data Structures Used in Algorithms*).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是**冒泡排序算法**（如[第2章](04672393-683c-406b-8dd1-4dab5b5d9c4f.xhtml)中讨论的，*算法中使用的数据结构*）。
- en: Logarithmic time (O(logn)) complexity
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对数时间（O(logn)）复杂度
- en: 'An algorithm is said to run in logarithmic time if the execution time of the
    algorithm is proportional to the logarithm of the input size. With each iteration,
    the input size decreases by a constant multiple factor. An example of logarithmic
    is binary search. The binary search algorithm is used to find a particular element
    in a one-dimensional data structure, such as a Python list. The elements within
    the data structure need to be sorted in descending order. The binary search algorithm
    is implemented in a function named `searchBinary`, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果算法的执行时间与输入大小的对数成正比，则称算法具有对数时间复杂度。每次迭代，输入大小都会以一个常数倍数因子减少。对数的一个例子是二分搜索。二分搜索算法用于在一维数据结构中查找特定元素，例如Python列表。数据结构中的元素需要按降序排序。二分搜索算法在名为`searchBinary`的函数中实现，如下所示：
- en: '[PRE9]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The main loop takes advantage of the fact that the list is ordered. It divides
    the list in half with each iteration until it gets to the result:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环利用列表有序的事实。它每次迭代将列表分成一半，直到得到结果：
- en: '![](assets/91156654-6969-48d8-bc16-3a45a8c3599e.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/91156654-6969-48d8-bc16-3a45a8c3599e.png)'
- en: After defining the function, it is tested to search a particular element in
    lines 11 and 12\. The binary search algorithm is further discussed in [Chapter
    3](7f694829-0525-42b1-a485-fb37a07f31ec.xhtml), *Sorting and Searching Algorithms*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义函数之后，测试了在第11和12行搜索特定元素。二分搜索算法在[第3章](7f694829-0525-42b1-a485-fb37a07f31ec.xhtml)中进一步讨论，*排序和搜索算法*。
- en: Note that among the four types of Big O notation types presented, O(n²) has
    the worst performance and O(logn) has the best performance. In fact, O(logn)'s
    performance can be thought of as the gold standard for the performance of any
    algorithm (which is not always achieved, though). On the other hand, O(n²) is
    not as bad as O(n³) but still, algorithms that fall in this class cannot be used
    on big data as the time complexity puts limitations on how much data they can
    realistically process.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在所提出的四种大O符号类型中，O(n²)的性能最差，O(logn)的性能最佳。事实上，O(logn)的性能可以被视为任何算法性能的黄金标准（尽管并非总是实现）。另一方面，O(n²)并不像O(n³)那么糟糕，但是仍然，属于这一类的算法不能用于大数据，因为时间复杂度对它们能够实际处理的数据量施加了限制。
- en: One way to reduce the complexity of an algorithm is to compromise on its accuracy,
    producing a type of algorithm called an **approximate algorithm**.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 减少算法复杂度的一种方法是在准确性上做出妥协，产生一种称为**近似算法**的算法类型。
- en: 'The whole process of the performance evaluation of algorithms is iterative
    in nature, as shown in the following figure:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 算法性能评估的整个过程是迭代的，如下图所示：
- en: '![](assets/36636001-28f6-4df4-8df5-2f6b12926599.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/36636001-28f6-4df4-8df5-2f6b12926599.png)'
- en: Validating an algorithm
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证算法
- en: Validating an algorithm confirms that it is actually providing a mathematical
    solution to the problem we are trying to solve. A validation process should check
    the results for as many possible values and types of input values as possible.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 验证算法确认它实际上为我们尝试解决的问题提供了数学解决方案。验证过程应该检查尽可能多的可能值和输入值类型的结果。
- en: Exact, approximate, and randomized algorithms
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精确、近似和随机算法
- en: Validating an algorithm also depends on the type of the algorithm as the testing
    techniques are different. Let's first differentiate between deterministic and
    randomized algorithms.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 验证算法还取决于算法的类型，因为测试技术是不同的。让我们首先区分确定性和随机算法。
- en: 'For deterministic algorithms, a particular input always generates exactly the
    same output. But for certain classes of algorithms, a sequence of random numbers
    is also taken as input, which makes the output different each time the algorithm
    is run. The k-means clustering algorithm, which is detailed in [Chapter 6](ce14ecc1-8ad5-406e-88d0-7f3acb3e4569.xhtml),
    *Unsupervised Machine Learning Algorithms*, is an example of such an algorithm:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于确定性算法，特定输入总是生成完全相同的输出。但对于某些类别的算法，随机数序列也被视为输入，这使得每次运行算法时输出都不同。详见[第6章](ce14ecc1-8ad5-406e-88d0-7f3acb3e4569.xhtml)中详细介绍的k均值聚类算法，*无监督机器学习算法*，就是这种算法的一个例子：
- en: '![](assets/2241208c-9116-4716-bcfd-c46eae124ede.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2241208c-9116-4716-bcfd-c46eae124ede.png)'
- en: 'Algorithms can also be divided into the following two types based on assumptions
    or approximation used to simplify the logic to make them run faster:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用于简化逻辑以使其运行更快的假设或近似，算法也可以分为以下两种类型：
- en: '**An exact algorithm:** Exact algorithms are expected to produce a precise
    solution without introducing any assumptions or approximations.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种精确算法：精确算法预计能够在不引入任何假设或近似的情况下产生精确解决方案。
- en: '**An approximate algorithm:** When the problem complexity is too much to handle
    for the given resources, we simplify our problem by making some assumptions. The
    algorithms based on these simplifications or assumptions are called approximate
    algorithms, which doesn''t quite give us the precise solution.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种近似算法：当问题复杂度对于给定资源来说太大而难以处理时，我们通过做一些假设来简化问题。基于这些简化或假设的算法称为近似算法，它并不能给出精确解决方案。
- en: Let's look at an example to understand the difference between the exact and
    approximate algorithms—the famous traveling salesman problem, which was presented
    in 1930\. A traveling salesman challenges you to find the shortest route for a
    particular salesman that visits each city (from a list of cities) and then returns
    to the origin, which is why he is named the traveling salesman. The first attempt
    to provide the solution will include generating all the permutations of cities
    and choosing the combination of cities that is cheapest. The complexity of this
    approach to provide the solution is O(n!), where *n* is the number of cities.
    It is obvious that time complexity starts to become unmanageable beyond 30 cities*.*
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子来理解精确和近似算法之间的区别——著名的旅行推销员问题，它是在1930年提出的。一个旅行推销员向你挑战，要求你找到一名特定推销员访问每个城市（从城市列表中）并返回原点的最短路线。首次尝试提供解决方案将包括生成所有城市的排列并选择最便宜的城市组合。这种方法提供解决方案的复杂度是O(n!)，其中*n*是城市的数量。显然，随着城市数量的增加，时间复杂度开始变得难以管理。
- en: If the number of cities is more than 30, one way of reducing the complexity
    is to introduce some approximations and assumptions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果城市数量超过30个，减少复杂性的一种方法是引入一些近似和假设。
- en: For approximate algorithms, it is important to set the expectations for accuracy
    when gathering the requirements. Validating an approximation algorithm is about
    verifying that the error of the results is within an acceptable range.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于近似算法，在收集要求时设定准确性期望是很重要的。验证近似算法是为了验证结果的误差是否在可接受范围内。
- en: Explainability
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可解释性
- en: When algorithms are used for critical cases, it becomes important to have the
    ability to explain the reason behind each and every result whenever needed. This
    is necessary to make sure that decisions based on the results of the algorithms
    do not introduce bias.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当算法用于关键情况时，有必要能够在需要时解释每个结果背后的原因。这是为了确保基于算法结果的决策不会引入偏见。
- en: The ability to exactly identify the features that are used directly or indirectly
    to come up with a particular decision is called the **explainability** of an algorithm.
    Algorithms, when used for critical use cases, need to be evaluated for bias and
    prejudice. The ethical analysis of algorithms has become a standard part of the
    validation process for those algorithms that can affect decision-making that relates
    to the life of people.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 能够准确识别直接或间接用于做出特定决策的特征的能力被称为算法的“可解释性”。当算法用于关键用例时，需要对偏见和成见进行评估。算法的伦理分析已成为对可能影响与人们生活相关的决策的算法进行验证的标准部分。
- en: For algorithms that deal with deep learning, explainability is difficult to
    achieve. For example, if an algorithm is used to refuse the mortgage application
    of a person, it is important to have the transparency and ability to explain the
    reason.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于处理深度学习的算法，解释性很难实现。例如，如果算法用于拒绝某人的抵押贷款申请，具有透明度和解释原因的能力就很重要。
- en: Algorithmic explainability is an active area of research. One of the effective
    techniques that has been recently developed is **Local Interpretable Model-Agnostic
    Explanations** (**LIME**), as proposed in the proceedings of the 22^(nd) **Association
    for Computing Machinery** (**ACM**) at the **Special Interest Group on Knowledge
    Discovery** (**SIGKDD**) international conference on knowledge discovery and data
    mining in 2016\. LIME is based on a concept where small changes are induced to
    the input for each instance and then an effort to map the local decision boundary
    for that instance is made. It can then quantify the influence of each variable
    for that instance.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的可解释性是一个活跃的研究领域。最近开发的一种有效技术是**局部可解释模型无关解释**（**LIME**），该技术是在2016年的第22届**计算机协会**（**ACM**）**知识发现和数据挖掘专业兴趣小组**（**SIGKDD**）国际会议上提出的。LIME基于一个概念，即对每个实例的输入进行小的改变，然后努力绘制该实例的局部决策边界。它可以量化每个变量对该实例的影响。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was about learning the basics of algorithms. First, we learned
    about the different phases of developing an algorithm. We discussed the different
    ways of specifying the logic of an algorithm that are necessary for designing
    it.  Then, we looked at how to design an algorithm. We learned two different ways
    of analyzing the performance of an algorithm. Finally, we studied different aspects
    of validating an algorithm.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是关于学习算法的基础知识。首先，我们学习了开发算法的不同阶段。我们讨论了指定算法逻辑的不同方式，这对于设计算法是必要的。然后，我们看了如何设计算法。我们学会了分析算法性能的两种不同方式。最后，我们研究了验证算法的不同方面。
- en: After going through this chapter, we should be able to understand the pseudocode
    of an algorithm. We should understand the different phases in developing and deploying
    an algorithm. We also learned how to use Big O notation to evaluate the performance
    of an algorithm.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这一章的学习，我们应该能够理解算法的伪代码。我们应该了解开发和部署算法的不同阶段。我们还学会了如何使用大O符号来评估算法的性能。
- en: The next chapter is about the data structures used in algorithms. We will start
    by looking at the data structures available in Python. We will then look at how
    we can use these data structures to create more sophisticated data structures,
    such as stacks, queues, and trees, which are needed to develop complex algorithms.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是关于算法中使用的数据结构。我们将首先看一下Python中可用的数据结构。然后我们将看看如何使用这些数据结构来创建更复杂的数据结构，比如栈、队列和树，这些都是开发复杂算法所需的。
