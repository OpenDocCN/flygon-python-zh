- en: The Importance of Linearity in Finance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 金融中线性的重要性
- en: Nonlinear dynamics play a vital role in our world. Linear models are often employed
    in economics due to being easier to study and their easier modeling capabilities.
    In finance, linear models are widely used to help price securities and perform
    optimal portfolio allocation, among other useful things. One significant aspect
    of linearity in financial modeling is its assurance that a problem terminates
    at a globally-optimal solution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 非线性动力学在我们的世界中起着至关重要的作用。由于更容易研究和更容易建模的能力，线性模型经常在经济学中使用。在金融领域，线性模型被广泛用于帮助定价证券和执行最优投资组合分配，以及其他有用的事情。金融建模中线性的一个重要方面是它保证问题在全局最优解处终止。
- en: In order to perform prediction and forecasting, regression analysis is widely
    used in the field of statistics to estimate relationships among variables. With
    an extensive mathematics library being one of Python’s greatest strength, Python
    is frequently used as a scientific scripting language to aid in these problems.
    Modules such as the SciPy and NumPy packages contain a variety of linear regression
    functions for data scientists to work with.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行预测和预测，回归分析在统计学领域被广泛使用，以估计变量之间的关系。由于Python具有丰富的数学库是其最大的优势之一，因此Python经常被用作科学脚本语言来帮助解决这些问题。像SciPy和NumPy这样的模块包含各种线性回归函数，供数据科学家使用。
- en: In traditional portfolio management, the allocation of assets follows a linear
    pattern, and investors have individual styles of investing. We can describe the
    problem of portfolio allocation as a system of linear equations, containing either
    equalities or inequalities. These linear systems can then be represented in a
    matrix form as *Ax=B*, where *A* is our known coefficient value, *B* is the observed
    result, and *x* is the vector of values that we want to find out. More often than
    not, *x* contains the optimal security weights to maximize our utility. Using
    matrix algebra, we can efficiently solve for *x* using either direct or indirect
    methods.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的投资组合管理中，资产配置遵循线性模式，投资者有个人的投资风格。我们可以将投资组合分配问题描述为一个线性方程组，包含等式或不等式。然后，这些线性系统可以以矩阵形式表示为*Ax=B*，其中*A*是已知的系数值，*B*是观察到的结果，*x*是我们想要找出的值的向量。往往，*x*包含最大化效用的最优证券权重。使用矩阵代数，我们可以使用直接或间接方法高效地解出*x*。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Examining the Capital Asset Pricing Model and the security market line
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查资本资产定价模型和证券市场线
- en: Solving for the security market line using regression
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用回归解决证券市场线问题
- en: Examining the APT model and performing a multivariate linear regression
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查APT模型并执行多元线性回归
- en: Understanding linear optimization in portfolio allocation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解投资组合中的线性优化
- en: Performing linear optimization using the Pulp package
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Pulp软件包执行线性优化
- en: Understanding the outcomes of linear programming
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解线性规划的结果
- en: Introduction to integer programming
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数规划简介
- en: Implementing a linear integer programming model with binary conditions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用二进制条件实现线性整数规划模型
- en: Solving systems of linear equations with equalities using matrix linear algebra
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用矩阵线性代数解等式的线性方程组
- en: Solving systems of linear equations directly with LU, Cholesky, and QR decomposition
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LU、Cholesky和QR分解直接解线性方程组
- en: Solving systems of linear equations indirectly with the Jacobi and Gauss-Seidel
    method
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jacobi和Gauss-Seidel方法间接解线性方程组
- en: The Capital Asset Pricing Model and the security market line
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资本资产定价模型和证券市场线
- en: A lot of the financial literature devotes exclusive discussions to the **Capital
    Asset Pricing Model** (**CAPM**). In this section, we will explore key concepts
    that highlight the importance of linearity in finance.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 很多金融文献都专门讨论了**资本资产定价模型**（**CAPM**）。在本节中，我们将探讨突出金融中线性的重要性的关键概念。
- en: 'In the famous CAPM, the relationship between risk and rates of return in a
    security is described as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在著名的CAPM中，描述了证券的风险和回报率之间的关系如下：
- en: '![](Images/90b9951f-98de-427b-9d67-6b9bc56c0e71.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/90b9951f-98de-427b-9d67-6b9bc56c0e71.png)'
- en: 'For a security, *i*, its returns are defined as *R[i]* and its beta as *β[i]*.
    The CAPM defines the return of the security as the sum of the risk-free rate, *R[f]*,
    and the multiplication of its beta with the risk premium. The risk premium can
    be thought of as the market portfolio''s excess returns exclusive of the risk-free
    rate. The following is a visual representation of the CAPM:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于证券*i*，其回报被定义为*R[i]*，其beta被定义为*β[i]*。CAPM将证券的回报定义为无风险利率*R[f]*和其beta与风险溢价的乘积之和。风险溢价可以被视为市场投资组合的超额回报，不包括无风险利率。以下是CAPM的可视化表示：
- en: '![](Images/a8ce88b0-498f-4c1e-be55-8212d1ecabbb.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a8ce88b0-498f-4c1e-be55-8212d1ecabbb.png)'
- en: Beta is a measure of the systematic risk of a stock – a risk that cannot be
    diversified away. In essence, it describes the sensitivity of stock returns with
    respect to movements in the market. For example, a stock with a beta of zero produces
    no excess returns regardless of the direction the market moves in. It can only
    grow at a risk-free rate. A stock with a beta of 1 indicates that the stock moves
    perfectly with the market.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Beta是股票系统风险的度量 - 无法分散的风险。实质上，它描述了股票回报与市场波动的敏感性。例如，beta为零的股票无论市场走向如何都不会产生超额回报。它只能以无风险利率增长。beta为1的股票表示该股票与市场完全同步。
- en: The beta is mathematically derived by dividing the covariance of returns between
    the stock and the market by the variance of the market returns.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: beta是通过将股票与市场回报的协方差除以市场回报的方差来数学推导的。
- en: The CAPM model measures the relationship between risk and stock returns for
    every stock in the portfolio basket. By outlining the sum of this relationship,
    we obtain combinations or weights of risky securities that produce the lowest
    portfolio risk for every level of portfolio return. An investor who wishes to
    receive a particular return would own one such combination of an optimal portfolio
    that provides the least risk possible. Combinations of optimal portfolios lie
    along a line called the **efficient frontier**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: CAPM模型衡量了投资组合篮子中每支股票的风险和回报之间的关系。通过概述这种关系的总和，我们可以得到在每个投资组合回报水平下产生最低投资组合风险的风险证券的组合或权重。希望获得特定回报的投资者将拥有一个最佳投资组合的组合，以提供可能的最低风险。最佳投资组合的组合位于一条称为**有效边界**的线上。
- en: Along the efficient frontier, there exists a tangent point that denotes the
    best optimal portfolio available and gives the highest rate of return in exchange
    for the lowest risk possible. This optimal portfolio at the tangent point is known
    as the **market portfolio**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在有效边界上，存在一个切线点，表示最佳的可用最优投资组合，并以可能的最低风险换取最高的回报率。切线点处的最佳投资组合被称为**市场投资组合**。
- en: 'There exists a straight line drawn from the market portfolio to the risk-free
    rate. This line is called the **Capital Market Line** (**CML**). The CML can be
    thought of as the highest Sharpe ratio available among all the other Sharpe ratios
    of optimal portfolios. The **Sharpe ratio** is a risk-adjusted performance measure
    defined as the portfolio''s excess returns over the risk-free rate per unit of
    its risk in standard deviations. Investors are particularly interested in holding
    combinations of assets along the CML line. The following diagram illustrates the
    efficient frontier, the market portfolio, and the CML:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从市场投资组合到无风险利率之间存在一条直线。这条线被称为**资本市场线**（**CML**）。CML可以被认为是所有最优投资组合中最高夏普比率的夏普比率。**夏普比率**是一个风险调整后的绩效指标，定义为投资组合超额回报与标准差风险单位的比率。投资者特别感兴趣持有沿着CML线的资产组合。以下图表说明了有效边界、市场投资组合和CML：
- en: '![](Images/c344df85-44e8-4b9a-bab2-317311a22093.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c344df85-44e8-4b9a-bab2-317311a22093.png)'
- en: 'Another line of interest in CAPM studies is the **Security Market Line** (**SML**).
    The SML plots the asset''s expected returns against its beta. For a security with
    a beta value of 1, its returns perfectly match the market''s returns. Any security
    priced above the SML is deemed to be undervalued since investors expect a higher
    return given the same amount of risk. Conversely, any security priced below the
    SML is deemed to be overvalued, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: CAPM研究中另一个有趣的概念是**证券市场线**（**SML**）。SML绘制了资产的预期回报与其贝塔值的关系。对于贝塔值为1的证券，其回报完全匹配市场回报。任何定价高于SML的证券被认为是被低估的，因为投资者期望在相同风险下获得更高的回报。相反，任何定价低于SML的证券被认为是被高估的。
- en: '![](Images/1905e49e-f52c-4fd5-a639-e33fd1115c03.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1905e49e-f52c-4fd5-a639-e33fd1115c03.png)'
- en: Suppose we are interested in finding the beta, *β[i]*, of a security. We can
    regress the company's stock returns, *R[i]*, against the market's returns, *R[M]*,
    along with an intercept, *α*, in the form of the *R[i]=α+βR[M]* equation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有兴趣找到证券的贝塔值*β[i]*。我们可以对公司的股票回报*R[i]*与市场回报*R[M]*进行回归分析，同时加上一个截距*α*，形成*R[i]=α+βR[M]*的方程。
- en: 'Consider the following set of stock return and market return data measured
    over five time periods:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下一组在五个时间段内测得的股票回报和市场回报数据：
- en: '| **Time period** | **Stock returns** | **Market returns** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **时间段** | **股票回报** | **市场回报** |'
- en: '| 1 | 0.065 | 0.055 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0.065 | 0.055 |'
- en: '| 2 | 0.0265 | -0.09 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0.0265 | -0.09 |'
- en: '| 3 | -0.0593 | -0.041 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 3 | -0.0593 | -0.041 |'
- en: '| 4 | -0.001 | 0.045 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 4 | -0.001 | 0.045 |'
- en: '| 5 | 0.0346 | 0.022 |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 0.0346 | 0.022 |'
- en: 'Using the `stats` module of SciPy, we will perform a least-squares regression
    on the CAPM model, and derive the values of α and *β[i]* by running the following
    code in Python:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SciPy的`stats`模块，我们将对CAPM模型进行最小二乘回归，并通过在Python中运行以下代码来得出α和*β[i]*的值：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `scipty.stats.linregress` function returns five values: the slope of the
    regression line, the intercept of the regression line, the correlation coefficient,
    the p-value for a hypothesis test with a null hypothesis of a zero slope, and
    the standard error of the estimate. We are interested in finding the slope and
    intercept of the line by printing the values of `beta` and `alpha`, respectively:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`scipty.stats.linregress`函数返回五个值：回归线的斜率、回归线的截距、相关系数、零斜率假设的假设检验的p值，以及估计的标准误差。我们有兴趣通过打印`beta`和`alpha`的值来找到线的斜率和截距，分别为：'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The beta of the stock is 0.5077 and the alpha is nearly zero.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 股票的贝塔值为0.5077，α几乎为零。
- en: 'The equation that describes the SML can be written as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 描述SML的方程可以写成：
- en: '![](Images/a5b59b68-c605-4528-87d7-5ca98588efb1.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a5b59b68-c605-4528-87d7-5ca98588efb1.png)'
- en: The term *E[R[M]]−R[f]* is the market risk premium, and *E[R[M]]* is the expected
    return on the market portfolio. *R[f]* is the return on the risk-free rate, *E[R[i]]*
    is the expected return on asset, *i*, and *β[i]* is the beta of the asset.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*E[R[M]]−R[f]*是市场风险溢价，*E[R[M]]*是市场投资组合的预期回报。*R[f]*是无风险利率的回报，*E[R[i]]*是资产*i*的预期回报，*β[i]*是资产的贝塔值。
- en: Suppose the risk-free rate is 5% and the market risk premium is 8.5%. What is
    the expected return of the stock? Based on the CAPM, an equity with a beta of
    0.5077 would have a risk premium of 0.5077×8.5%, or 4.3%. The risk-free rate is
    5%, so the expected return on the equity is 9.3%.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设无风险利率为5%，市场风险溢价为8.5%。股票的预期回报率是多少？根据CAPM，贝塔值为0.5077的股票将有0.5077×8.5%的风险溢价，即4.3%。无风险利率为5%，因此股票的预期回报率为9.3%。
- en: If the security is observed in the same time period to have a higher return
    (for example, 10.5%) than the expected stock return, the security can be said
    to be undervalued, since the investor can expect a greater return for the same
    amount of risk.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在同一时间段内观察到证券的回报率高于预期的股票回报（例如，10.5%），则可以说该证券被低估，因为投资者可以期望在承担相同风险的情况下获得更高的回报。
- en: Conversely, should the return of the security be observed to have a lower return
    (for example, 7%) than the expected return as implied by the SML, the security
    can be said to be overvalued. The investor receives a reduced return while assuming
    the same amount of risk.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果观察到证券的回报率低于SML所暗示的预期回报率（例如，7%），则可以说该证券被高估。投资者在承担相同风险的情况下获得了降低的回报。
- en: The Arbitrage Pricing Theory model
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套利定价理论模型
- en: The CAPM suffers from several limitations, such as the use of a mean-variance
    framework and the fact that returns are captured by one risk factor – the market
    risk factor. In a well-diversified portfolio, the unsystematic risk of various
    stocks cancels out and is essentially eliminated.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: CAPM存在一些局限性，比如使用均值-方差框架和事实上回报被一个风险因素（市场风险因素）捕获。在一个分散投资组合中，各种股票的非系统风险相互抵消，基本上被消除了。
- en: The **Arbitrage Pricing Theory** (**APT**) model was put forward to address
    these shortcomings and offers a general approach of determining the asset prices
    other than the mean and variances.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**套利定价理论**（**APT**）模型被提出来解决这些缺点，并提供了一种除了均值和方差之外确定资产价格的一般方法。'
- en: The APT model assumes that the security returns are generated according to multiple
    factor models, which consist of a linear combination of several systematic risk
    factors. Such factors could be the inflation rate, GDP growth rate, real interest
    rates, or dividends.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: APT模型假设证券回报是根据多因素模型生成的，这些模型由几个系统风险因素的线性组合组成。这些因素可能是通货膨胀率、GDP增长率、实际利率或股利。
- en: 'The equilibrium asset pricing equation according to the APT model is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 根据APT模型的均衡资产定价方程如下：
- en: '![](Images/90170a01-87f1-4d7d-8966-6afcd2921d6c.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/90170a01-87f1-4d7d-8966-6afcd2921d6c.png)'
- en: Here, *E[R[i]]* is the expected rate of return on the *i* security, *α[i]* is
    the expected return on the *i* stock if all factors are negligible, *β[i,j]* is
    the sensitivity of the *i*^(th) asset to the *j*^(th) factor, and *F[j]* is the
    value of the *j*^(th) factor that influences the return on the *i* security.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*E[R[i]]*是第*i*个证券的预期回报率，*α[i]*是如果所有因素都可以忽略时第*i*个股票的预期回报，*β[i,j]*是第*i*个资产对第*j*个因素的敏感性，*F[j]*是影响第*i*个证券回报的第*j*个因素的值。
- en: Since our goal is to find all values of *α[i]* and *β*, we will perform a **multivariate
    linear regression** on the APT model.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的目标是找到*α[i]*和*β*的所有值，我们将在APT模型上执行**多元线性回归**。
- en: Multivariate linear regression of factor models
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 因子模型的多元线性回归
- en: Many Python packages, such as SciPy, come with several variants of regression
    functions. In particular, the `statsmodels` package is a complement to SciPy with
    descriptive statistics and the estimation of statistical models. The official
    page for Statsmodels is [https://www.statsmodels.org](https://www.statsmodels.org).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Python包（如SciPy）都带有几种回归函数的变体。特别是，`statsmodels`包是SciPy的补充，具有描述性统计信息和统计模型的估计。Statsmodels的官方页面是[https://www.statsmodels.org](https://www.statsmodels.org)。
- en: 'If Statsmodels is not yet installed in your Python environment, run the following
    command to do so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Python环境中尚未安装Statsmodels，请运行以下命令进行安装：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you have an existing package installed, the `-U` switch tells `pip` to upgrade
    the selected package to the newest available version.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经安装了一个现有的包，`-U`开关告诉`pip`将选定的包升级到最新可用版本。
- en: In this example, we will use the `ols` function of the `statsmodels` module
    to perform an ordinary least-squares regression and view its summary.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用`statsmodels`模块的`ols`函数执行普通最小二乘回归，并查看其摘要。
- en: 'Let''s assume that you have implemented an APT model with seven factors that
    return the values of *Y*. Consider the following set of data collected over nine
    time periods, *t[1]* to *t[9]*. *X*[1] to *X[7]* are independent variables observed
    at each period. The regression problem is therefore structured as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经实现了一个包含七个因素的APT模型，返回*Y*的值。考虑在九个时间段*t[1]*到*t[9]*内收集的以下数据集。*X*[1]到*X[7]*是在每个时间段观察到的自变量。因此，回归问题的结构如下：
- en: '![](Images/028272c7-3f1d-46e8-8845-32c433ca2f6b.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/028272c7-3f1d-46e8-8845-32c433ca2f6b.png)'
- en: 'A simple ordinary least-squares regression on values of *X* and *Y* can be
    performed with the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码对*X*和*Y*的值进行简单的普通最小二乘回归：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s view the detailed statistics of the regression:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看回归的详细统计信息：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The OLS regression results will output a pretty long table of statistical information.
    However, our interest lies in one particular section that gives us the coefficients
    of our APT model:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: OLS回归结果将输出一个相当长的统计信息表。然而，我们感兴趣的是一个特定部分，它给出了我们APT模型的系数：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `coef` column gives us the coefficient values of our regression for the *c* constant,
    and *X[1]* until *X[7]*. Similarly, we can use the `params` property to display
    these coefficients of interest:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`coef`列给出了我们回归的系数值，包括*c*常数和*X[1]*到*X[7]*。同样，我们可以使用`params`属性来显示这些感兴趣的系数：'
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Both the function calls produce the same coefficient values for the APT model
    in the same order.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数调用以相同的顺序产生了APT模型的相同系数值。
- en: Linear optimization
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性优化
- en: In the CAPM and APT pricing theories, we assumed linearity in the models and
    solved for expected security prices using regressions in Python.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在CAPM和APT定价理论中，我们假设模型是线性的，并使用Python中的回归来解决预期的证券价格。
- en: As the number of securities in our portfolio increases, certain limitations
    are introduced as well. Portfolio managers would find themselves constrained by
    these rules in pursuing certain objectives mandated by investors.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们投资组合中证券数量的增加，也会引入一定的限制。投资组合经理在追求投资者规定的某些目标时会受到这些规则的约束。
- en: Linear optimization helps overcome the problem of portfolio allocation. Optimization
    focuses on minimizing or maximizing the value of objective functions. Some examples
    include maximizing returns and minimizing volatility. These objectives are usually
    governed by certain regulations, such as a no short-selling rule, or limits on
    the number of securities to be invested.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 线性优化有助于克服投资组合分配的问题。优化侧重于最小化或最大化目标函数的值。一些例子包括最大化回报和最小化波动性。这些目标通常受到某些规定的约束，例如不允许空头交易规则，或者对要投资的证券数量的限制。
- en: Unfortunately, in Python, there is no single official package that supports
    this solution. However, there are third-party packages available with an implementation
    of the simplex algorithm for linear programming. For the purpose of this demonstration,
    we will use Pulp, an open source linear programming modeler, to assist us in this
    particular linear programming problem.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在Python中，没有一个官方的包支持这个解决方案。但是，有第三方包可用，其中包含线性规划的单纯形算法的实现。为了演示目的，我们将使用Pulp，一个开源线性规划建模器，来帮助我们解决这个特定的线性规划问题。
- en: Getting Pulp
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取Pulp
- en: You can obtain Pulp from [https://github.com/coin-or/pulp](https://github.com/coin-or/pulp).
    The project page contains a comprehensive list of documentation to help you get
    started with your optimization process.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/coin-or/pulp](https://github.com/coin-or/pulp)获取Pulp。该项目页面包含了一份全面的文档列表，以帮助您开始优化过程。
- en: 'You may also obtain the Pulp package with the `pip` package manager:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`pip`包管理器获取Pulp包：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A maximization example with linear programming
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性规划的最大化示例
- en: 'Suppose that we are interested in investing in two securities, *X* and *Y*.
    We would like to find out the actual number of units to invest for every three
    units of the security *X* and two units of the security *Y*, such that the total
    number of units invested is maximized, where possible. However, there are certain
    constraints on our investment strategy:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有兴趣投资两种证券*X*和*Y*。我们想要找出每三单位*X*和两单位*Y*的实际投资单位数，使得总投资单位数最大化，如果可能的话。然而，我们的投资策略有一定的限制：
- en: For every 2 units of the security *X* invested and 1 unit of the security *Y*
    invested, the total volume must not exceed 100
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每2单位*X*和1单位*Y*的投资，总量不得超过100
- en: For every unit of the securities *X* and *Y* invested, the total volume must
    not exceed 80
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每单位*X*和*Y*的投资，总量不得超过80
- en: The total volume allowed to invest in the security *X* must not exceed 40
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许投资*X*的总量不得超过40
- en: Short-selling is not allowed for securities
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许对证券进行空头交易
- en: 'The maximization problem can be mathematically represented as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最大化问题可以用数学表示如下：
- en: '![](Images/02a2f49c-93e7-40f6-a947-208df527a4e2.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/02a2f49c-93e7-40f6-a947-208df527a4e2.png)'
- en: 'subject to:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 受限于：
- en: '![](Images/b97a3c75-ad70-4c84-a5de-f1b995473e4c.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b97a3c75-ad70-4c84-a5de-f1b995473e4c.png)'
- en: '![](Images/752f3101-6e8c-4def-92ea-8edc58ffa41d.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/752f3101-6e8c-4def-92ea-8edc58ffa41d.png)'
- en: '![](Images/12d846a0-8f99-4a3a-b8ea-54b0c0d05e39.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12d846a0-8f99-4a3a-b8ea-54b0c0d05e39.png)'
- en: '![](Images/71b1620c-2dbb-4d04-924e-3fc006dfc30b.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/71b1620c-2dbb-4d04-924e-3fc006dfc30b.png)'
- en: 'By plotting the constraints on an *x* by *y* graph, a set of feasible solutions
    can be seen, given by the shaded area:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在*x*和*y*图上绘制约束条件，可以看到一组可行解，由阴影区域给出：
- en: '![](Images/178c4e94-bb47-4d90-97d3-e72dcee6b704.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/178c4e94-bb47-4d90-97d3-e72dcee6b704.png)'
- en: 'The problem can be translated into Python with the `pulp` package, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该问题可以用`pulp`包在Python中进行翻译，如下所示：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `LpVariable` function declares a variable to be solved. The `LpProblem`
    function initializes the problem with a text description of the problem and the
    type of optimization, which in this case is the maximization method. The `+=`
    operation allows an arbitrary number of constraints to be added, along with a
    text description. Finally, the `.solve()` method is called to begin performing
    linear optimization. To show the values solved by the optimizer, use the `.variables()`
    method to loop through each variable and print out its `varValue`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`LpVariable`函数声明要解决的变量。`LpProblem`函数用问题的文本描述和优化类型初始化问题，本例中是最大化方法。`+=`操作允许添加任意数量的约束，以及文本描述。最后，调用`.solve()`方法开始执行线性优化。要显示优化器解决的值，使用`.variables()`方法循环遍历每个变量并打印出其`varValue`。'
- en: 'The following output is generated when the code runs:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码运行时生成以下输出：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The results show that obtaining the maximum value of 180 is possible when the
    value of *x* is 20 and *y* is 60 while fulfilling the given set of constraints.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，在满足给定的一组约束条件的情况下，当*x*的值为20，*y*的值为60时，可以获得最大值180。
- en: Outcomes of linear programs
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线性规划的结果
- en: 'There are three outcomes in linear optimization, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 线性优化有三种结果，如下：
- en: A local optimal solution to a linear program is a feasible solution with a closer
    objective function value than all other feasible solutions close to it. It may
    or may not be the **global optimal solution**, a solution that is better than
    every feasible solution.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性规划的局部最优解是一个可行解，其目标函数值比其附近的所有其他可行解更接近。它可能是也可能不是**全局最优解**，即优于每个可行解的解。
- en: A linear program is **infeasible** if a solution cannot be found.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找不到解决方案，线性规划是**不可行**的。
- en: A linear program is **unbounded** if the optimal solution is unbounded or is
    infinite.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果最优解是无界的或无限的，线性规划是**无界**的。
- en: Integer programming
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数规划
- en: In the simple optimization problem we investigated earlier, *A maximization
    example with linear programming*, the variables were allowed to be continuous
    or fractional. What if the use of fractional values or results is not realistic?
    This problem is called the **linear integer programming** problem, where all the
    variables are restricted as integers. A special case of an integer variable is
    a binary variable that can either be 0 or 1\. Binary variables are especially
    useful in model decision-making when given a set of choices.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前调查的简单优化问题中，*线性规划的最大化示例*，变量被允许是连续的或分数的。如果使用分数值或结果不现实怎么办？这个问题被称为**线性整数规划**问题，其中所有变量都受限于整数。整数变量的一个特殊情况是二进制变量，可以是0或1。在给定一组选择时，二进制变量在模型决策时特别有用。
- en: Integer programming models are frequently used in operational research to model
    real-world working problems. More often than not, stating nonlinear problems in
    a linear or even binary fashion requires more art than science.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 整数规划模型经常用于运筹学中来模拟现实工作问题。通常情况下，将非线性问题陈述为线性或甚至二进制的问题需要更多的艺术而不是科学。
- en: A minimization example with integer programming
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数规划的最小化示例
- en: Suppose we must go for 150 contracts in a particular over-the-counter exotic
    security from three dealers. Dealer *X* quoted $500 per contract plus handling
    fees of $4,000, regardless of the number of contracts sold. Dealer *Y* charges
    $450 per contract plus a transaction fee of $2,000\. Dealer *Z* charges $450 per
    contract plus a fee of $6,000\. Dealer *X* will sell at most 100 contracts, dealer
    *Y* at most 90, and dealer *Z* at most 70\. The minimum transaction volume from
    any dealer is 30 contracts if any are transacted with that dealer. How should
    we minimize the cost of purchasing 150 contracts?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须从三家经销商那里购买150份某种场外奇特证券。经销商*X*报价每份合同500美元加上4000美元的手续费，无论卖出的合同数量如何。经销商*Y*每份合同收费450美元，加上2000美元的交易费。经销商*Z*每份合同收费450美元，加上6000美元的费用。经销商*X*最多销售100份合同，经销商*Y*最多销售90份，经销商*Z*最多销售70份。从任何经销商那里交易的最低交易量是30份合同。我们应该如何最小化购买150份合同的成本？
- en: 'Using the `pulp` package, let''s set up the required variables:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pulp`包，让我们设置所需的变量：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `dealers` variable simply contains the dictionary identifiers that are used
    to reference lists and dictionaries later on. The `variable_costs` and `fixed_costs` variables
    are dictionary objects that contain the respective contract cost and fees charged
    by each dealer. The Pulp solver solves for the values of `quantities` and `is_orders`,
    which are defined by the `LpVariable` function. The `dicts()` method tells Pulp
    to treat the assigned variable as a dictionary object, using the `dealers` variable
    for referencing. Note that the `quantities` variable has a lower boundary (0)
    that prevents us from entering a short position in any securities. The `is_orders`
    values are treated as binary objects, indicating whether we should enter into
    a transaction with any of the dealers.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`dealers`变量只是包含用于稍后引用列表和字典的字典标识符的字典。`variable_costs`和`fixed_costs`变量是包含每个经销商收取的相应合同成本和费用的字典对象。Pulp求解器解决了`quantities`和`is_orders`的值，这些值由`LpVariable`函数定义。`dicts()`方法告诉Pulp将分配的变量视为字典对象，使用`dealers`变量进行引用。请注意，`quantities`变量具有一个下限（0），防止我们在任何证券中进入空头头寸。`is_orders`值被视为二进制对象，指示我们是否应该与任何经销商进行交易。'
- en: 'What is the best approach to modeling this integer programming problem? At
    first glance, it seems fairly straightforward by applying this equation:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对建模这个整数规划问题的最佳方法是什么？乍一看，通过应用这个方程似乎相当简单：
- en: '![](Images/938c9cac-ca49-43ab-bfd7-b3447d480a2c.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/938c9cac-ca49-43ab-bfd7-b3447d480a2c.png)'
- en: 'Where the following is true:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 其中以下内容为真：
- en: '![](Images/982dfb3a-3cc6-4858-8a10-336823094b9b.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/982dfb3a-3cc6-4858-8a10-336823094b9b.png)'
- en: '![](Images/1c0a8992-5668-4ac8-9504-0e7e4ad4a537.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1c0a8992-5668-4ac8-9504-0e7e4ad4a537.png)'
- en: '![](Images/2ab9139e-96e8-4a5b-8111-2a5fe54c6242.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2ab9139e-96e8-4a5b-8111-2a5fe54c6242.png)'
- en: '![](Images/ee23bb15-cf12-4f08-8675-dcfe7de1a8b7.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ee23bb15-cf12-4f08-8675-dcfe7de1a8b7.png)'
- en: '![](Images/76571b12-5400-47c7-bf0d-ed4f8c7f1976.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/76571b12-5400-47c7-bf0d-ed4f8c7f1976.png)'
- en: The equation simply states that we want to minimize the total costs with the
    binary variable, *isOrder[i]*, to determine whether to account for the costs associated
    with buying from a specific dealer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该方程简单地陈述了我们希望最小化总成本，并使用二进制变量*isOrder[i]*来确定是否考虑从特定经销商购买的成本。
- en: 'Let''s implement this model in Python:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python中实现这个模型：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What happens when we run the solver? Check it out:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行求解器时会发生什么？看一下：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As it turned out, we were trying to perform multiplication on two unknown variables,
    `quantities` and `is_order`, which unknowingly led us to perform nonlinear programming.
    Such are the pitfalls encountered when performing integer programming.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，我们试图对两个未知变量`quantities`和`is_order`进行乘法运算，无意中导致我们执行了非线性规划。这就是在执行整数规划时遇到的陷阱。
- en: How should we solve this problem? We can consider using **binary variables**,
    as shown in the next section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何解决这个问题？我们可以考虑使用**二进制变量**，如下一节所示。
- en: Integer programming with binary conditions
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有二进制条件的整数规划
- en: 'Another method for formulating the minimization objective is to place all unknown
    variables in a linear fashion such that they are additive:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 制定最小化目标的另一种方法是将所有未知变量线性排列，使它们是可加的：
- en: '![](Images/59f4559c-4f21-4482-980f-92ca0b30d1ba.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/59f4559c-4f21-4482-980f-92ca0b30d1ba.png)'
- en: 'Comparing with the previous objective equation, we would obtain the same fixed
    cost values. However, the unknown variable, *quantity[i]*, remains in the first
    term of the equation. Hence, the *quantity[i]* variable is required to be solved
    as a function of *isOrder[i]*, such that the constraints are stated as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前的目标方程相比，我们将获得相同的固定成本值。但是，未知变量*quantity[i]*仍然在方程的第一项中。因此，需要将*quantity[i]*变量作为*isOrder[i]*的函数来求解，约束如下所述：
- en: '![](Images/6e531ad8-a8c9-4945-ad24-45c1f84efa0d.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6e531ad8-a8c9-4945-ad24-45c1f84efa0d.png)'
- en: '![](Images/11c3eecb-48e5-43ec-adc9-f49f534d4932.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11c3eecb-48e5-43ec-adc9-f49f534d4932.png)'
- en: '![](Images/2fbd74dc-0c7b-4ff5-a0aa-57a03a8788c7.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2fbd74dc-0c7b-4ff5-a0aa-57a03a8788c7.png)'
- en: 'Let’s apply these formulas in Python:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python中应用这些公式：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'What happens when we try to run the solver? Let''s see:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试运行求解器时会发生什么？让我们看看：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The output tells us that buying 90 contracts from dealer *Y* and 60 contracts
    from dealer *Z* gives us the lowest possible cost of $66,500 while fulfilling
    all other constraints.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 输出告诉我们，从经销商*Y*购买90份合同和从经销商*Z*购买60份合同可以以最低成本66,500美元满足所有其他约束。
- en: As we can see, careful planning is required in the design of integer programming
    models to arrive at an accurate solution in order for them to be useful in decision-making.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，需要在整数规划模型的设计中进行仔细规划，以便得出准确的解决方案，使其在决策中有用。
- en: Solving linear equations using matrices
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用矩阵解决线性方程
- en: In the previous section, we looked at solving a system of linear equations with
    inequality constraints. If a set of systematic linear equations has constraints
    that are deterministic, we can represent the problem as matrices and apply matrix
    algebra. Matrix methods represent multiple linear equations in a compact manner
    while using existing matrix library functions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看到了如何解决带有不等式约束的线性方程组。如果一组系统线性方程有确定性约束，我们可以将问题表示为矩阵，并应用矩阵代数。矩阵方法以紧凑的方式表示多个线性方程，同时使用现有的矩阵库函数。
- en: 'Suppose we would like to build a portfolio that consists of three securities: *a*,
    *b*, and *c*. The allocation of the portfolio must meet certain constraints: it
    must consist of six units of a long position in the security *a*. With every two
    units of the security *a*, one unit of the security *b*, and one unit of the security *c *invested,
    the net position must be long four units. With every one unit of the security
    *a*, three units of the security *b*, and two units of thesecurity *c*invested,
    the net position must be long five units.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要建立一个包含三种证券*a*、*b*和*c*的投资组合。投资组合的分配必须满足一定的约束条件：必须持有证券*a*的多头头寸6单位。对于每两单位的证券*a*，必须投资一单位的证券*b*和一单位的证券*c*，净头寸必须是多头四单位。对于每一单位的证券*a*，必须投资三单位的证券*b*和两单位的证券*c*，净头寸必须是多头五单位。
- en: 'To find out the number of securities to invest in, we can frame the problem
    mathematically, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出要投资的证券数量，我们可以用数学方式表述问题，如下：
- en: '![](Images/305091a5-a752-4963-8a03-8c4274cd3c76.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/305091a5-a752-4963-8a03-8c4274cd3c76.png)'
- en: '![](Images/310d1491-85a1-4798-9e64-4ce19f7632c1.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/310d1491-85a1-4798-9e64-4ce19f7632c1.png)'
- en: '![](Images/72498221-ef19-42a8-95d0-cfc4d9d0744c.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/72498221-ef19-42a8-95d0-cfc4d9d0744c.png)'
- en: 'With all of the coefficients visible, the equations are as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有系数可见的情况下，方程如下：
- en: '![](Images/2357e60f-d857-4038-99ca-e1d6889e49d0.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2357e60f-d857-4038-99ca-e1d6889e49d0.png)'
- en: '![](Images/c0c87d82-37a1-4d52-8ca1-1f0d6340d24e.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c0c87d82-37a1-4d52-8ca1-1f0d6340d24e.png)'
- en: '![](Images/b45e50af-e151-40bd-ba08-776f7971b4b4.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b45e50af-e151-40bd-ba08-776f7971b4b4.png)'
- en: 'Let''s take the coefficients of the equations and represent them in a matrix
    form:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把方程的系数表示成矩阵形式：
- en: '![](Images/534ad0ee-7490-4bb7-aadd-da72c240ceda.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/534ad0ee-7490-4bb7-aadd-da72c240ceda.png)'
- en: 'The linear equations can now be stated as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 线性方程现在可以陈述如下：
- en: '![](Images/802ae3dc-26ee-47d7-a18e-7d64d42faea7.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/802ae3dc-26ee-47d7-a18e-7d64d42faea7.png)'
- en: 'To solve for the *x* vector that contains the number of securities to invest
    in, the inverse of the *A* matrix is taken and the equation is written as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要解出包含要投资的证券数量的*x*向量，需要取矩阵*A*的逆，方程写为：
- en: '![](Images/b0bb9923-d74f-4cbf-a228-a8956441ebf8.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b0bb9923-d74f-4cbf-a228-a8956441ebf8.png)'
- en: 'Using NumPy arrays, the *A* and *B* matrices are assigned as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NumPy数组，*A*和*B*矩阵分配如下：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can use the `linalg.solve` function of NumPy to solve a system of linear
    scalar equations:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用NumPy的`linalg.solve`函数来解决一组线性标量方程：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The portfolio would require a long position of 6 units of the security *a*,
    15 units of the security  *b*, and a short position of 23 units of the security *c*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 投资组合需要持有6单位的证券*a*的多头头寸，15单位的证券*b*，和23单位的证券*c*的空头头寸。
- en: In portfolio management, we can use the matrix system of equations to solve
    for optimal weight allocations of securities, given a set of constraints. As the
    number of securities in the portfolio increases, the size of the *A* matrix increases
    and it becomes computationally expensive to compute the matrix inversion of *A*.
    Thus, one may consider methods such as the Cholesky decomposition, LU decomposition,
    QR decomposition, the Jacobi method, or the Gauss-Seidel method to break down
    the *A* matrix into simpler matrices for factorization.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在投资组合管理中，我们可以使用矩阵方程系统来解决给定一组约束条件的证券的最佳权重分配。随着投资组合中证券数量的增加，*A*矩阵的大小增加，计算*A*的矩阵求逆变得计算成本高昂。因此，人们可以考虑使用Cholesky分解、LU分解、QR分解、雅各比方法或高斯-赛德尔方法等方法，将*A*矩阵分解为更简单的矩阵进行因式分解。
- en: The LU decomposition
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LU分解
- en: 'The **LU decomposition**, or also known as **lower-upper factorization**, is
    one of the methods that solve square systems of linear equations. As its name
    implies, the LU factorization decomposes the *A* matrixinto a product of two matrices:
    a lower triangular matrix, *L*, and an upper triangular matrix, *U*. The decomposition
    can be represented as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**LU分解**，又称**下三角-上三角分解**，是解决方阵线性方程组的方法之一。顾名思义，LU分解将矩阵*A*分解为两个矩阵的乘积：一个下三角矩阵*L*和一个上三角矩阵*U*。分解可以表示如下：'
- en: '![](Images/71af5750-4c95-4836-b774-46acd01886f2.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/71af5750-4c95-4836-b774-46acd01886f2.png)'
- en: '![](Images/0243079e-6788-49c3-9ac0-1be05d2f85fa.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0243079e-6788-49c3-9ac0-1be05d2f85fa.png)'
- en: Here, we can see *a=l[11]u[11]*, *b=l[11]u[12]*, and so on. A lower triangular
    matrix is a matrix that contains values in its lower triangle with the remaining
    upper triangle populated with zeros. The converse is true for an upper triangular
    matrix.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到*a=l[11]u[11]*，*b=l[11]u[12]*，依此类推。下三角矩阵是一个矩阵，它在其下三角中包含值，其余的上三角中填充了零。上三角矩阵的情况相反。
- en: The definite advantage of the LU decomposition method over the Cholesky decomposition
    method is that it works for any square matrices. The latter only works for symmetric
    and positive definite matrices.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: LU分解方法相对于Cholesky分解方法的明显优势在于它适用于任何方阵。后者只适用于对称和正定矩阵。
- en: 'Think back to the previous example in *Solving linear equations using matrices*
    of a 3 x 3 *A* matrix*.* This time, we will use the `linalg` package of the SciPy
    module to perform the LU decomposition with the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下前面的例子，*使用矩阵解线性方程*，一个3 x 3的*A*矩阵。这次，我们将使用SciPy模块的`linalg`包来执行LU分解，使用以下代码：
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To view the values of `x`, execute the following command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`x`的值，请执行以下命令：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We get the same values of `6`, `15`, and `-23` for *a*, *b*, and *c*,respectively.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了*a*、*b*和*c*的值分别为`6`、`15`和`-23`。
- en: Note that we used the `lu_factor()` method of `scipy.linalg` here, which gives
    the `LU` variable as the pivoted LU decomposition of the *A* matrix*.* We used
    the `lu_solve()` method, which takes in the pivoted LU decomposition and the `B` vector,
    to solve the equation system.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里使用了`scipy.linalg`的`lu_factor()`方法，它给出了*A*矩阵的置换LU分解作为`LU`变量。我们使用了`lu_solve()`方法，它接受置换的LU分解和`B`向量来解方程组。
- en: 'We can display the LU decomposition of the A matrix using the `lu()` method
    of `scipy.linalg`. The `lu()` method returns three variables—the permutation matrix, *P*,
    the lower triangular matrix, *L*, and the upper triangular matrix, *U* – individually:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`scipy.linalg`的`lu()`方法显示*A*矩阵的LU分解。`lu()`方法返回三个变量——置换矩阵*P*，下三角矩阵*L*和上三角矩阵*U*——分别返回：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When we print out these variables, we can conclude the relationship between
    the LU factorization and *A* matrix, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印出这些变量时，我们可以得出LU分解和*A*矩阵之间的关系如下：
- en: '![](Images/226067c6-bb1e-447a-98b1-fa67ab8d1ac2.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/226067c6-bb1e-447a-98b1-fa67ab8d1ac2.png)'
- en: 'The LU decomposition can be viewed as the matrix form of Gaussian elimination
    performed on two simpler matrices: the upper triangular and lower triangular matrices.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: LU分解可以看作是在两个更简单的矩阵上执行的高斯消元的矩阵形式：上三角矩阵和下三角矩阵。
- en: The Cholesky decomposition
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cholesky分解
- en: The Cholesky decomposition is another way of solving systems of linear equations.
    It can be significantly faster and uses a lot less memory than the LU decomposition,
    by exploiting the property of symmetric matrices. However, the matrix being decomposed
    must be Hermitian (or real-valued symmetric and thus square) and positive definite.
    This means that the *A* matrix is decomposed as *A=LL^T*, where *L* is a lower
    triangular matrix with real and positive numbers on the diagonals, and *L^T* is
    the conjugate transpose of *L*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Cholesky分解是解线性方程组的另一种方法。它可以比LU分解快得多，并且使用的内存要少得多，因为它利用了对称矩阵的性质。然而，被分解的矩阵必须是Hermitian（或者是实对称的并且是方阵）和正定的。这意味着*A*矩阵被分解为*A=LL^T*，其中*L*是一个下三角矩阵，对角线上有实数和正数，*L^T*是*L*的共轭转置。
- en: 'Let''s consider another example of a system of linear equations where the *A*
    matrixis both Hermitian and positive definite. Again, the equation is in the form
    of *Ax=B*, where *A* and *B* take the following values:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个线性方程组的例子，其中*A*矩阵既是Hermitian又是正定的。同样，方程的形式是*Ax=B*，其中*A*和*B*取以下值：
- en: '![](Images/8ff30e92-f62d-46ec-ab09-a60a2fa81f49.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8ff30e92-f62d-46ec-ab09-a60a2fa81f49.png)'
- en: 'Let''s represent these matrices as NumPy arrays:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些矩阵表示为NumPy数组：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `cholesky()` function of `numpy.linalg` would compute the lower triangular
    factor of the *A* matrix. Let''s view the lower triangular matrix:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.linalg`的`cholesky()`函数将计算*A*矩阵的下三角因子。让我们查看下三角矩阵：'
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To verify that the Cholesky decomposition results are correct, we can use the
    definition of the Cholesky factorization by multiplying *L* by its conjugate transpose,
    which will lead us back to the values of the *A* matrix:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证Cholesky分解的结果是否正确，我们可以使用Cholesky分解的定义，将*L*乘以它的共轭转置，这将使我们回到*A*矩阵的值：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before solving for *x*, we need to solve for *L^Tx* as *y*. Let''s use the
    `solve()` method of `numpy.linalg`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在解出*x*之前，我们需要将*L^Tx*解为*y*。让我们使用`numpy.linalg`的`solve()`方法：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To solve for *x*, we need to solve again using the conjugate transpose of *L*
    and *y*:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要解出*x*，我们需要再次使用*L*的共轭转置和*y*来解：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s print our result of *x*:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印出*x*的结果：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The output gives us our values of *x* for *a*, *b*, *c*, and *d*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 输出给出了我们的*a*、*b*、*c*和*d*的*x*的值。
- en: 'To show that the Cholesky factorization gives us the correct values, we can
    verify the answer by multiplying the *A* matrix by the transpose of *x* to return
    the values of *B*:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明Cholesky分解给出了正确的值，我们可以通过将*A*矩阵乘以*x*的转置来验证答案，从而得到*B*的值：
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This shows that the values of *x* by the Cholesky decomposition would lead to
    the same values given by *B*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明通过Cholesky分解得到的*x*的值将与*B*给出的相同。
- en: The QR decomposition
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QR分解
- en: The **QR decomposition**, also known as the **QR factorization**, is another
    method of solving linear systems of equations using matrices, very much like the
    LU decomposition. The equation to solve is in the form of *Ax*=*B*, where matrix
    *A*=*QR*. However, in this case, *A* is a product of an orthogonal matrix, *Q*,
    and upper triangular matrix, *R*. The QR algorithm is commonly used to solve the
    linear least-squares problem.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**QR分解**，也称为**QR分解**，是使用矩阵解线性方程的另一种方法，非常类似于LU分解。要解的方程是*Ax*=*B*的形式，其中矩阵*A*=*QR*。然而，在这种情况下，*A*是正交矩阵*Q*和上三角矩阵*R*的乘积。QR算法通常用于解线性最小二乘问题。'
- en: 'An orthogonal matrix exhibits the following properties:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正交矩阵具有以下特性：
- en: It is a square matrix.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个方阵。
- en: 'Multiplying an orthogonal matrix by its transpose returns the identity matrix:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将正交矩阵乘以其转置返回单位矩阵：
- en: '![](Images/41efd8bc-3c81-4151-8192-8b66a4b75e01.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/41efd8bc-3c81-4151-8192-8b66a4b75e01.png)'
- en: 'The inverse of an orthogonal matrix equals its transpose:'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正交矩阵的逆等于其转置：
- en: '![](Images/f7719a52-7912-4827-b5d0-077d5a4f5f2a.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f7719a52-7912-4827-b5d0-077d5a4f5f2a.png)'
- en: An identity matrix is also a square matrix, with its main diagonal containing
    1s and 0s elsewhere.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵也是一个方阵，其主对角线包含1，其他位置包含0。
- en: 'The problem of *Ax=B* can now be restated as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在问题*Ax=B*可以重新表述如下：
- en: '![](Images/76ec1aa1-ad1a-4e44-a99b-6e2463dc3660.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/76ec1aa1-ad1a-4e44-a99b-6e2463dc3660.png)'
- en: '![](Images/97535969-d66b-4e3b-bbca-e2436beab295.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/97535969-d66b-4e3b-bbca-e2436beab295.png)'
- en: 'Using the same variables in the LU decomposition example, we will use the `qr()`
    method of `scipy.linalg` to compute our values of *Q* and *R*, and let the *y* variable
    represent our value of *BQ^T* with the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用LU分解示例中的相同变量，我们将使用`scipy.linalg`的`qr()`方法来计算我们的*Q*和*R*的值，并让*y*变量代表我们的*BQ^T*的值，代码如下：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that `Q.T` is simply the transpose of `Q`, which is also the same as the
    inverse of *Q*:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Q.T`只是`Q`的转置，也就是*Q*的逆：
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We get the same answers as those in the LU decomposition example.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了与LU分解示例中相同的答案。
- en: Solving with other matrix algebra methods
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他矩阵代数方法求解
- en: So far, we've looked at the use of matrix inversion, the LU decomposition, the
    Cholesky decomposition, and QR decomposition to solve for systems of linear equations.
    Should the size of our financial data in the *A* matrixbe large, it can be broken
    down by a number of schemes so that the solution can converge more quickly using
    matrix algebra. Quantitative portfolio analysts should be familiar with these
    methods.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过了使用矩阵求逆、LU分解、Cholesky分解和QR分解来解线性方程组。如果*A*矩阵中的财务数据规模很大，可以通过多种方案进行分解，以便使用矩阵代数更快地收敛。量化投资组合分析师应该熟悉这些方法。
- en: In some circumstances, the solution that we are looking for might not converge.
    Therefore, you might consider the use of iterative methods. Common methods to
    solve systems of linear equations iteratively are the Jacobi method, the Gauss-Seidel
    method, and the SOR method. We will take a brief look at examples of implementing
    the Jacobi and Gauss-Seidel methods.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们寻找的解可能不会收敛。因此，您可能需要考虑使用迭代方法。解决线性方程组的常见迭代方法包括雅各比方法、高斯-赛德尔方法和SOR方法。我们将简要介绍实现雅各比和高斯-赛德尔方法的示例。
- en: The Jacobi method
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 雅各比方法
- en: 'The Jacobi method solves a system of linear equations iteratively along its
    diagonal elements. The iteration procedure terminates when the solution converges.
    Again, the equation to solve is in the form of *Ax=B*, where the matrix  *A* can
    be decomposed into two matrices of the same size such that *A=D+R*. The matrix
    D consists of only the diagonal components of A, and the other matrix R consists
    of the remaining components. Let''s take a look at the example of a 4 x 4 *A* matrix:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 雅各比方法沿着其对角线元素迭代地解决线性方程组。当解收敛时，迭代过程终止。同样，要解决的方程式是*Ax=B*的形式，其中矩阵*A*可以分解为两个相同大小的矩阵，使得*A=D+R*。矩阵D仅包含A的对角分量，另一个矩阵R包含其余分量。让我们看一个4
    x 4的*A*矩阵的例子：
- en: '![](Images/7db794c0-7bda-4251-becc-1c94352bac6f.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7db794c0-7bda-4251-becc-1c94352bac6f.png)'
- en: 'The solution is then obtained iteratively, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后迭代地获得解如下：
- en: '![](Images/406fc895-12fa-49cd-9169-65d220203f1c.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/406fc895-12fa-49cd-9169-65d220203f1c.png)'
- en: '![](Images/3a031bd8-7c92-4c0a-9fe5-c59071007046.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3a031bd8-7c92-4c0a-9fe5-c59071007046.png)'
- en: '![](Images/1adeeed4-2adf-41b1-9e41-b180888d6393.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1adeeed4-2adf-41b1-9e41-b180888d6393.png)'
- en: '![](Images/f2e91e47-124e-4b15-9f34-1fd282f11b31.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f2e91e47-124e-4b15-9f34-1fd282f11b31.png)'
- en: As opposed to the Gauss-Siedel method, the value of *x[n]* in the Jacobi method
    is needed during each iteration in order to compute *x[n+1]* and cannot be overwritten.
    This would take up twice the amount of storage. However, the computations for
    each element can be done in parallel, which is useful for faster computations.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与高斯-赛德尔方法相反，在雅各比方法中，需要在每次迭代中使用*x[n]*的值来计算*x[n+1]*，并且不能被覆盖。这将占用两倍的存储空间。然而，每个元素的计算可以并行进行，这对于更快的计算是有用的。
- en: If the *A* matrix is strictly irreducibly diagonally dominant, this method is
    guaranteed to converge. A strictly irreducibly diagonally dominant matrix is one
    where the absolute diagonal element in every row is greater than the sum of the
    absolute values of other terms.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*A*矩阵是严格不可约对角占优的，这种方法保证收敛。严格不可约对角占优矩阵是指每一行的绝对对角元素大于其他项的绝对值之和。
- en: 'In some circumstances, the Jacobi method can converge even if these conditions
    are not met. The Python code is given as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，即使不满足这些条件，雅各比方法也可以收敛。Python代码如下：
- en: '[PRE29]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Consider the same matrix values in the Cholesky decomposition example. We will
    use 25 iterations in our `jacobi` function to find the values of *x*:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑Cholesky分解示例中的相同矩阵值。我们将在我们的`jacobi`函数中使用25次迭代来找到*x*的值：
- en: '[PRE30]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After initializing the values, we can now call the function and solve for *x*:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化值后，我们现在可以调用函数并求解*x*：
- en: '[PRE31]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We solved for the values of *x*, which are similar to the answers from the Cholesky
    decomposition.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们求解了*x*的值，这与Cholesky分解的答案类似。
- en: The Gauss-Seidel method
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高斯-赛德尔方法
- en: 'The Gauss-Seidel method works very much like the Jacobi method. It is another
    way to solve a square system of linear equations using an iterative procedure
    with the equation in the form of *Ax**=**B*. Here, the *A* matrix is decomposed
    as *A**=**L+U*, where the *A* matrix is a sum of a lower triangular matrix, *L*,
    and an upper triangular matrix, *U*. Let''s take a look at the example of a 4
    x 4 *A* matrix:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯-赛德尔方法与雅各比方法非常相似。这是使用迭代过程以*Ax**=**B*形式的方程解决线性方程组的另一种方法。在这里，*A*矩阵被分解为*A**=**L+U*，其中*A*矩阵是下三角矩阵*L*和上三角矩阵*U*的和。让我们看一个4
    x 4 *A*矩阵的例子：
- en: '![](Images/28f828fb-7354-4f6e-98b6-8db9994b2d99.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/28f828fb-7354-4f6e-98b6-8db9994b2d99.png)'
- en: 'The solution is then obtained iteratively, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过迭代获得解决方案，如下所示：
- en: '![](Images/8f6c1a8f-b4a1-4edc-8a95-767c34a75cf2.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8f6c1a8f-b4a1-4edc-8a95-767c34a75cf2.png)'
- en: '![](Images/e0a8bd69-a01b-4f19-a603-b631e2cff6d8.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e0a8bd69-a01b-4f19-a603-b631e2cff6d8.png)'
- en: '![](Images/7a7694e0-2b36-4079-bdd6-d06dd8a942f1.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7a7694e0-2b36-4079-bdd6-d06dd8a942f1.png)'
- en: '![](Images/68f67be8-9055-459b-8819-0d824806c9e3.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/68f67be8-9055-459b-8819-0d824806c9e3.png)'
- en: Using a lower triangular matrix, *L*, where zeroes fill up the upper triangle,
    the elements of *x[n]* can be overwritten in each iteration in order to compute
    *x[n+1]*. This results in the advantage of needing half the storage required when
    using the Jacobi method.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下三角矩阵*L*，其中零填充上三角，可以在每次迭代中覆盖*x[n]*的元素，以计算*x[n+1]*。这样做的好处是使用雅各比方法时所需的存储空间减少了一半。
- en: The rate of convergence in the Gauss-Seidel method largely lies in the properties
    of the *A* matrix, especially if the *A* matrix is needed to be strictly-diagonally
    dominant or symmetric positive definite. Even if these conditions are not met,
    the Gauss-Seidel method may converge.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯-赛德尔方法的收敛速度主要取决于*A*矩阵的性质，特别是如果需要严格对角占优或对称正定的*A*矩阵。即使不满足这些条件，高斯-赛德尔方法也可能收敛。
- en: 'The Python implementation of the Gauss-Seidel method is given as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯-赛德尔方法的Python实现如下：
- en: '[PRE32]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the `tril()` method of NumPy returns the lower triangular *A* matrix,
    from which we can find the lower triangular *U* matrix. Plugging the remaining
    values into *x* iteratively would lead us to the following solution, with some
    tolerance defined by `tol`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，NumPy的`tril()`方法返回下三角*A*矩阵，从中我们可以找到下三角*U*矩阵。将剩余的值迭代地插入*x*，将会得到以下解，其中由`tol`定义了一些容差。
- en: 'Let''s consider the same matrix values in the Jacobi method and Cholesky decomposition
    example. We will use a maximum of 100 iterations in our `gauss()` function to
    find the values of *x*, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑雅各比方法和乔列斯基分解示例中的相同矩阵值。我们将在我们的`gauss()`函数中使用最多100次迭代来找到*x*的值，如下所示：
- en: '[PRE33]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s see whether our *x* values match with those from the Jacobi method and
    Cholesky decomposition:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的*x*值是否与雅各比方法和乔列斯基分解中的值匹配：
- en: '[PRE34]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We solved for the values of *x*, which are similar to the answers from the Jacobi
    method and Cholesky decomposition.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解出了*x*的值，这些值与雅各比方法和乔列斯基分解的答案类似。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a brief look at the use of the CAPM model and APT model
    in finance. In the CAPM model, we visited the efficient frontier with the CML
    to determine the optimal portfolio and the market portfolio. Then, we solved for
    the SML using regression, which helped us to determine whether an asset is undervalued
    or overvalued. In the APT model, we explored how various factors affect security
    returns other than using the mean-variance framework. We performed a multivariate
    linear regression to help us determine the coefficients of the factors that led
    to the valuation of our security price.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们简要介绍了CAPM模型和APT模型在金融中的应用。在CAPM模型中，我们访问了CML的有效边界，以确定最佳投资组合和市场投资组合。然后，我们使用回归解决了SML，这有助于我们确定资产是被低估还是被高估。在APT模型中，我们探讨了除使用均值方差框架之外，各种因素如何影响证券回报。我们进行了多元线性回归，以帮助我们确定导致证券价格估值的因素的系数。
- en: In portfolio allocation, portfolio managers are typically mandated by investors
    to achieve a set of objectives while following certain constraints. We can model
    this problem using linear programming. Using the Pulp Python package, we can define
    a minimization or maximization objective function, and add inequality constraints
    to our problems to solve for unknown variables. The three outcomes in linear optimization
    can be an unbounded solution, only one solution, or no solution at all.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在投资组合配置中，投资组合经理通常被投资者授权实现一组目标，同时遵循某些约束。我们可以使用线性规划来建模这个问题。使用Pulp Python包，我们可以定义一个最小化或最大化的目标函数，并为我们的问题添加不等式约束以解决未知变量。线性优化的三种结果可以是无界解、仅有一个解或根本没有解。
- en: Another form of linear optimization is integer programming, where all the variables
    are restricted to being integers instead of fractional values. A special case
    of an integer variable is a binary variable, which can either be 0 or 1, and it
    is especially useful to model decision-making when given a set of choices. We
    worked on a simple integer programming model that contains binary conditions and
    saw how easy it is to run into a pitfall. Careful planning on the design of integer
    programming models is required for them to be useful in decision-making.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 线性优化的另一种形式是整数规划，其中所有变量都受限于整数，而不是分数值。整数变量的特殊情况是二进制变量，它可以是0或1，特别适用于在给定一组选择时建模决策。我们研究了一个包含二进制条件的简单整数规划模型，并看到了遇到陷阱有多容易。需要仔细规划整数规划模型的设计，以便它们在决策中有用。
- en: The portfolio-allocation problem may also be represented as a system of linear
    equations with equalities, which can be solved using matrices in the form of *Ax=B*.
    To find the values of *x*, we solved for *A^(−1)B* using various types of decomposition
    of the *A* matrix. The two types of matrix decomposition method are the direct
    and indirect methods. The direct method performs matrix algebra in a fixed number
    of iterations, and includes the LU decomposition, Cholesky decomposition, and
    QR decomposition methods. The indirect or iterative method iteratively computes
    the next values of *x* until a certain tolerance of accuracy is reached. This
    method is particularly useful for computing large matrices, but it also faces
    the risk of not having the solution converge. The indirect methods we used are
    the Jacobi method and the Gauss-Seidel method.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 投资组合分配问题也可以表示为一个具有相等性的线性方程组，可以使用矩阵形式的*Ax=B*来求解。为了找到*x*的值，我们使用了各种类型的*A*矩阵分解来求解*A^(−1)B*。矩阵分解方法有两种类型，直接和间接方法。直接方法在固定次数的迭代中执行矩阵代数运算，包括LU分解、Cholesky分解和QR分解方法。间接或迭代方法通过迭代计算*x*的下一个值，直到达到一定的精度容差。这种方法特别适用于计算大型矩阵，但也面临着解不收敛的风险。我们使用的间接方法有雅各比方法和高斯-赛德尔方法。
- en: In the next chapter, we will look at nonlinear modeling in finance.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论金融中的非线性建模。
