- en: The Iterator Pattern
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器模式
- en: 'We''ve discussed how many of Python''s built-ins and idioms seem, at first
    blush, to fly in the face of object-oriented principles, but are actually providing
    access to real objects under the hood. In this chapter, we''ll discuss how the
    `for` loop, which seems so structured, is actually a lightweight wrapper around
    a set of object-oriented principles. We''ll also see a variety of extensions to
    this syntax that automatically create even more types of object. We will cover
    the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Python的许多内置功能和习语，乍一看似乎违反了面向对象的原则，但实际上在幕后提供了对真实对象的访问。在本章中，我们将讨论`for`循环，它似乎如此结构化，实际上是一组面向对象原则的轻量级包装。我们还将看到一系列扩展到这种语法，自动创建更多类型的对象。我们将涵盖以下主题：
- en: What design patterns are
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式是什么
- en: The iterator protocol—one of the most powerful design patterns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器协议-最强大的设计模式之一
- en: List, set, and dictionary comprehensions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表、集合和字典推导
- en: Generators and coroutines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器和协程
- en: Design patterns in brief
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简要介绍设计模式
- en: When engineers and architects decide to build a bridge, or a tower, or a building,
    they follow certain principles to ensure structural integrity. There are various
    possible designs for bridges (suspension and cantilever, for example), but if
    the engineer doesn't use one of the standard designs, and doesn't have a brilliant
    new design, it is likely the bridge he/she designs will collapse.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当工程师和建筑师决定建造一座桥、一座塔或一座建筑时，他们遵循某些原则以确保结构完整性。桥梁有各种可能的设计（例如悬索和悬臂），但如果工程师不使用标准设计之一，并且没有一个杰出的新设计，那么他/她设计的桥梁可能会坍塌。
- en: Design patterns are an attempt to bring this same formal definition for correctly
    designed structures to software engineering. There are many different design patterns
    to solve different general problems. Design patterns typically solve a specific
    common problem faced by developers in some specific situation. The design pattern
    is then a suggestion as to the ideal solution for that problem, in terms of object-oriented
    design.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是试图将同样的正确设计结构的正式定义引入到软件工程中。有许多不同的设计模式来解决不同的一般问题。设计模式通常解决开发人员在某些特定情况下面临的特定常见问题。然后，设计模式是对该问题的理想解决方案的建议，从面向对象设计的角度来看。
- en: Knowing a design pattern and choosing to use it in our software does not, however,
    guarantee that we are creating a *correct* solution. In 1907, the Québec Bridge
    (to this day, the longest cantilever bridge in the world) collapsed before construction
    was completed, because the engineers who designed it grossly underestimated the
    weight of the steel used to construct it. Similarly, in software development,
    we may incorrectly choose or apply a design pattern, and create software that
    *collapses* under normal operating situations or when stressed beyond its original
    design limits.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 了解设计模式并选择在软件中使用它并不保证我们正在创建一个*正确*的解决方案。1907年，魁北克大桥（至今仍是世界上最长的悬臂桥）在建设完成之前坍塌，因为设计它的工程师严重低估了用于建造它的钢材重量。同样，在软件开发中，我们可能会错误地选择或应用设计模式，并创建在正常操作情况下或在超出原始设计限制时*崩溃*的软件。
- en: Any one design pattern proposes a set of objects interacting in a specific way
    to solve a general problem. The job of the programmer is to recognize when they
    are facing a specific version of such a problem, then to choose and adapt the
    general design in their precise needs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一个设计模式都提出了一组以特定方式相互作用的对象，以解决一般问题。程序员的工作是识别何时面临这样一个特定版本的问题，然后选择和调整通用设计以满足其精确需求。
- en: In this chapter, we'll be covering the iterator design pattern. This pattern
    is so powerful and pervasive that the Python developers have provided multiple
    syntaxes to access the object-oriented principles underlying the pattern. We will
    be covering other design patterns in the next two chapters. Some of them have
    language support and some don't, but none of them is so intrinsically a part of
    the Python coder's daily life as the iterator pattern.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍迭代器设计模式。这种模式如此强大和普遍，以至于Python开发人员提供了多种语法来访问该模式的基础面向对象原则。我们将在接下来的两章中介绍其他设计模式。其中一些具有语言支持，而另一些则没有，但没有一个像迭代器模式那样成为Python程序员日常生活中的固有部分。
- en: Iterators
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'In typical design pattern parlance, an iterator is an object with a `next()`
    method and a `done()` method; the latter returns `True` if there are no items
    left in the sequence. In a programming language without built-in support for iterators,
    the iterator would be looped over like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的设计模式术语中，迭代器是一个具有`next()`方法和`done()`方法的对象；后者如果序列中没有剩余项目，则返回`True`。在没有内置迭代器支持的编程语言中，迭代器将像这样循环：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In Python, iteration is a special feature, so the method gets a special name,
    `__next__`. This method can be accessed using the `next(iterator)` built-in. Rather
    than a `done` method, Python's iterator protocol raises `StopIteration` to notify
    the loop that it has completed. Finally, we have the much more readable `foriteminiterator`
    syntax to actually access items in an iterator instead of messing around with
    a `while` loop. Let's look at these in more detail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，迭代是一种特殊的特性，因此该方法得到了一个特殊的名称`__next__`。可以使用内置的`next(iterator)`来访问此方法。Python的迭代器协议不是使用`done`方法，而是引发`StopIteration`来通知循环已完成。最后，我们有更易读的`foriteminiterator`语法来实际访问迭代器中的项目，而不是使用`while`循环。让我们更详细地看看这些。
- en: The iterator protocol
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器协议
- en: The `Iterator` abstract base class, in the `collections.abc` module, defines
    the iterator protocol in Python. As mentioned, it must have a `__next__` method
    that the `for` loop (and other features that support iteration) can call to get
    a new element from the sequence. In addition, every iterator must also fulfill
    the `Iterable` interface. Any class that provides an `__iter__` method is iterable.
    That method must return an `Iterator` instance that will cover all the elements
    in that class.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator`抽象基类在`collections.abc`模块中定义了Python中的迭代器协议。正如前面提到的，它必须有一个`__next__`方法，`for`循环（以及其他支持迭代的功能）可以调用它来从序列中获取一个新元素。此外，每个迭代器还必须满足`Iterable`接口。任何提供`__iter__`方法的类都是可迭代的。该方法必须返回一个`Iterator`实例，该实例将覆盖该类中的所有元素。'
- en: 'This might sound a bit confusing, so have a look at the following example,
    but note that this is a very verbose way to solve this problem. It clearly explains
    iteration and the two protocols in question, but we''ll be looking at several
    more readable ways to get this effect later in this chapter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来有点混乱，所以看看以下示例，但请注意，这是解决这个问题的一种非常冗长的方式。它清楚地解释了迭代和所讨论的两个协议，但在本章的后面，我们将看到几种更易读的方法来实现这种效果：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This example defines an `CapitalIterable` class whose job is to loop over each
    of the words in a string and output them with the first letter capitalized. Most
    of the work of that iterable is passed to the `CapitalIterator` implementation.
    The canonical way to interact with this iterator is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子定义了一个`CapitalIterable`类，其工作是循环遍历字符串中的每个单词，并输出它们的首字母大写。这个可迭代对象的大部分工作都交给了`CapitalIterator`实现。与这个迭代器互动的规范方式如下：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example first constructs an iterable and retrieves an iterator from it.
    The distinction may need explanation; the iterable is an object with elements
    that can be looped over. Normally, these elements can be looped over multiple
    times, maybe even at the same time or in overlapping code. The iterator, on the
    other hand, represents a specific location in that iterable; some of the items
    have been consumed and some have not. Two different iterators might be at different
    places in the list of words, but any one iterator can mark only one place.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子首先构造了一个可迭代对象，并从中检索了一个迭代器。这种区别可能需要解释；可迭代对象是一个可以循环遍历的对象。通常，这些元素可以被多次循环遍历，甚至可能在同一时间或重叠的代码中。另一方面，迭代器代表可迭代对象中的特定位置；一些项目已被消耗，一些尚未被消耗。两个不同的迭代器可能在单词列表中的不同位置，但任何一个迭代器只能标记一个位置。
- en: Each time `next()` is called on the iterator, it returns another token from
    the iterable, in order. Eventually, the iterator will be exhausted (won't have
    any more elements to return), in which case `Stopiteration` is raised, and we
    break out of the loop.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每次在迭代器上调用`next()`时，它都会按顺序从可迭代对象中返回另一个标记。最终，迭代器将被耗尽（不再有任何元素返回），在这种情况下会引发`Stopiteration`，然后我们跳出循环。
- en: 'Of course, we already know a much simpler syntax for constructing an iterator
    from an iterable:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们已经知道了一个更简单的语法，用于从可迭代对象构造迭代器：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the `for` statement, in spite of not looking remotely object-oriented,
    is actually a shortcut to some obviously object-oriented design principles. Keep
    this in mind as we discuss comprehensions, as they, too, appear to be the polar
    opposite of an object-oriented tool. Yet, they use the exact same iteration protocol
    as `for` loops and are just another kind of shortcut.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`for`语句，尽管看起来并不像面向对象，实际上是一种显而易见的面向对象设计原则的快捷方式。在讨论理解时，请记住这一点，因为它们似乎是面向对象工具的完全相反。然而，它们使用与`for`循环完全相同的迭代协议，只是另一种快捷方式。
- en: Comprehensions
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解
- en: Comprehensions are simple, but powerful, syntaxes that allow us to transform
    or filter an iterable object in as little as one line of code. The resultant object
    can be a perfectly normal list, set, or dictionary, or it can be a generator expression
    that can be efficiently consumed while keeping just one element in memory at a
    time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 理解是一种简单但强大的语法，允许我们在一行代码中转换或过滤可迭代对象。结果对象可以是一个完全正常的列表、集合或字典，也可以是一个生成器表达式，可以在保持一次只有一个元素在内存中的情况下高效地消耗。
- en: List comprehensions
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表理解
- en: List comprehensions are one of the most powerful tools in Python, so people
    tend to think of them as advanced. They're not. Indeed, I've taken the liberty
    of littering previous examples with comprehensions, assuming you would understand
    them. While it's true that advanced programmers use comprehensions a lot, it's
    not because they're advanced. It's because they're trivial, and handle some of
    the most common operations in software development.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表理解是Python中最强大的工具之一，所以人们倾向于认为它们是高级的。事实并非如此。事实上，我已经在以前的例子中使用了理解，假设你会理解它们。虽然高级程序员确实经常使用理解，但并不是因为它们很高级。而是因为它们很简单，并处理了软件开发中最常见的一些操作。
- en: 'Let''s have a look at one of those common operations; namely, converting a
    list of items into a list of related items. Specifically, let''s assume we just
    read a list of strings from a file, and now we want to convert it to a list of
    integers. We know every item in the list is an integer, and we want to do some
    activity (say, calculate an average) on those numbers. Here''s one simple way
    to approach it:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看其中一个常见操作；即，将一个项目列表转换为相关项目列表。具体来说，假设我们刚刚从文件中读取了一个字符串列表，现在我们想将其转换为整数列表。我们知道列表中的每个项目都是整数，并且我们想对这些数字进行一些操作（比如计算平均值）。以下是一种简单的方法：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This works fine and it''s only three lines of code. If you aren''t used to
    comprehensions, you may not even think it looks ugly! Now, look at the same code
    using a list comprehension:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法很好用，而且只有三行代码。如果你不习惯理解，你可能不会觉得它看起来很丑陋！现在，看看使用列表理解的相同代码：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We're down to one line and, importantly for performance, we've dropped an `append`
    method call for each item in the list. Overall, it's pretty easy to tell what's
    going on, even if you're not used to comprehension syntax.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只剩下一行，而且，对于性能来说很重要的是，我们已经放弃了列表中每个项目的`append`方法调用。总的来说，即使你不习惯推导式语法，也很容易理解发生了什么。
- en: The square brackets indicate, as always, that we're creating a list. Inside
    this list is a `for` loop that iterates over each item in the input sequence.
    The only thing that may be confusing is what's happening between the list's opening
    brace and the start of the `for` loop. Whatever happens here is applied to *each*
    of the items in the input list. The item in question is referenced by the `num`
    variable from the loop. So, it's calling the `int` function for each element and
    storing the resulting integer in the new list.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号表示，我们正在创建一个列表。在这个列表中是一个`for`循环，它遍历输入序列中的每个项目。唯一可能令人困惑的是在列表的左大括号和`for`循环开始之间发生了什么。这里发生的事情应用于输入列表中的*每个*项目。所讨论的项目由循环中的`num`变量引用。因此，它对每个元素调用`int`函数，并将结果整数存储在新列表中。
- en: That's all there is to a basic list comprehension. Comprehensions are highly
    optimized C code; list comprehensions are far faster than `for` loops when looping
    over a large number of items. If readability alone isn't a convincing reason to
    use them as much as possible, speed should be.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基本列表推导式的全部内容。推导式是高度优化的C代码；当循环遍历大量项目时，列表推导式比`for`循环要快得多。如果仅仅从可读性的角度来看，不能说服你尽可能多地使用它们，那么速度应该是一个令人信服的理由。
- en: 'Converting one list of items into a related list isn''t the only thing we can
    do with a list comprehension. We can also choose to exclude certain values by
    adding an `if` statement inside the comprehension. Have a look:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个项目列表转换为相关列表并不是列表推导式唯一能做的事情。我们还可以选择通过在推导式中添加`if`语句来排除某些值。看一下：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All that's different between this example and the previous one is the `if len(num)
    < 3` part. This extra code excludes any strings with more than two characters.
    The `if` statement is applied to each element **before** the `int` function, so
    it's testing the length of a string. Since our input strings are all integers
    at heart, it excludes any number over 99.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子和前面的例子唯一不同的地方是`if len(num) < 3`部分。这个额外的代码排除了任何超过两个字符的字符串。`if`语句应用于**在**`int`函数之前的每个元素，因此它测试字符串的长度。由于我们的输入字符串在本质上都是整数，它排除了任何超过99的数字。
- en: List comprehensions are used to map input values to output values, applying
    a filter along the way to include or exclude any values that meet a specific condition.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式用于将输入值映射到输出值，并在途中应用过滤器以包括或排除满足特定条件的任何值。
- en: 'Any iterable can be the input to a list comprehension. In other words, anything
    we can wrap in a `for` loop can also be placed inside a comprehension. For example,
    text files are iterable; each call to `__next__` on the file''s iterator will
    return one line of the file. We could load a tab-delimited file where the first
    line is a header row into a dictionary using the `zip` function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可迭代对象都可以成为列表推导式的输入。换句话说，任何我们可以放入`for`循环中的东西也可以放入推导式中。例如，文本文件是可迭代的；对文件的迭代器每次调用`__next__`都会返回文件的一行。我们可以使用`zip`函数将第一行是标题行的制表符分隔文件加载到字典中：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This time, I've added some whitespace to make it more readable (list comprehensions
    don't *have* to fit on one line). This example creates a list of dictionaries
    from the zipped header and split lines for each line in the file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我添加了一些空白以使其更易读（列表推导式不一定要放在一行上）。这个例子从压缩的标题和分割行中创建了一个字典列表，对文件中的每一行进行了处理。
- en: Er, what? Don't worry if that code or explanation doesn't make sense; it's confusing.
    One list comprehension is doing a pile of work here, and the code is hard to understand,
    read, and ultimately, maintain. This example shows that list comprehensions aren't
    always the best solution; most programmers would agree that a `for` loop would
    be more readable than this version.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，什么？如果那段代码或解释没有意义，不要担心；它很令人困惑。一个列表推导式在这里做了一堆工作，代码很难理解、阅读，最终也很难维护。这个例子表明，列表推导式并不总是最好的解决方案；大多数程序员都会同意，`for`循环比这个版本更可读。
- en: 'Remember: the tools we are provided with should not be abused! Always pick
    the right tool for the job, which is always to write maintainable code.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：我们提供的工具不应该被滥用！始终选择适合工作的正确工具，这总是编写可维护代码。
- en: Set and dictionary comprehensions
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合和字典推导式
- en: Comprehensions aren't restricted to lists. We can use a similar syntax with
    braces to create sets and dictionaries as well. Let's start with sets. One way
    to create a set is to wrap a list comprehension in the `set()` constructor, which
    converts it to a set. But why waste memory on an intermediate list that gets discarded,
    when we can create a set directly?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 理解并不局限于列表。我们也可以使用类似的语法来创建集合和字典。让我们从集合开始。创建集合的一种方法是将列表推导式放入`set()`构造函数中，将其转换为集合。但是，为什么要浪费内存在一个被丢弃的中间列表上，当我们可以直接创建一个集合呢？
- en: 'Here''s an example that uses a named tuple to model author/title/genre triads,
    and then retrieves a set of all the authors that write in a specific genre:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用命名元组来模拟作者/标题/流派三元组的例子，然后检索写作特定流派的所有作者的集合：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The highlighted set comprehension sure is short in comparison to the demo-data
    setup! If we were to use a list comprehension, of course, Terry Pratchett would
    have been listed twice. As it is, the nature of sets removes the duplicates, and
    we end up with the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与演示数据设置相比，突出显示的集合推导式确实很短！如果我们使用列表推导式，特里·普拉切特当然会被列出两次。事实上，集合的性质消除了重复项，我们最终得到了以下结果：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Still using braces, we can introduce a colon to create a dictionary comprehension.
    This converts a sequence into a dictionary using *key:value* pairs. For example,
    it may be useful to quickly look up the author or genre in a dictionary if we
    know the title. We can use a dictionary comprehension to map titles to `books`
    objects:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然使用大括号，我们可以引入冒号来创建字典理解。这将使用*键:值*对将序列转换为字典。例如，如果我们知道标题，可能会很快地在字典中查找作者或流派。我们可以使用字典理解将标题映射到`books`对象：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we have a dictionary, and can look up books by title using the normal syntax.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个字典，并且可以使用正常的语法按标题查找书籍。
- en: In summary, comprehensions are not advanced Python, nor are they *non-object-oriented* tools
    that should be avoided. They are simply a more concise and optimized syntax for
    creating a list, set, or dictionary from an existing sequence.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，理解不是高级的Python，也不是应该避免使用的*非面向对象*工具。它们只是一种更简洁和优化的语法，用于从现有序列创建列表、集合或字典。
- en: Generator expressions
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: Sometimes we want to process a new sequence without pulling a new list, set,
    or dictionary into system memory. If we're just looping over items one at a time,
    and don't actually care about having a complete container (such as a list or dictionary)
    created, creating that container is a waste of memory. When processing one item
    at a time, we only need the current object available in memory at any one moment.
    But when we create a container, all the objects have to be stored in that container
    before we start processing them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想处理一个新的序列，而不将新的列表、集合或字典拉入系统内存。如果我们只是一个接一个地循环遍历项目，并且实际上并不关心是否创建了一个完整的容器（如列表或字典），那么创建该容器就是浪费内存。当一次处理一个项目时，我们只需要当前对象在内存中的可用性。但是当我们创建一个容器时，所有对象都必须在开始处理它们之前存储在该容器中。
- en: 'For example, consider a program that processes log files. A very simple log
    might contain information in this format:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个处理日志文件的程序。一个非常简单的日志文件可能以这种格式包含信息：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Log files for popular web servers, databases, or email servers can contain many
    gigabytes of data (I once had to clean nearly 2 terabytes of logs off a misbehaving
    system). If we want to process each line in the log, we can't use a list comprehension;
    it would create a list containing every line in the file. This probably wouldn't
    fit in RAM and could bring the computer to its knees, depending on the operating
    system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的网络服务器、数据库或电子邮件服务器的日志文件可能包含大量的数据（我曾经不得不清理近2TB的日志文件）。如果我们想处理日志中的每一行，我们不能使用列表理解；它会创建一个包含文件中每一行的列表。这可能不适合在RAM中，并且可能会使计算机陷入困境，这取决于操作系统。
- en: If we used a `for` loop on the log file, we could process one line at a time
    before reading the next one into memory. Wouldn't be nice if we could use comprehension
    syntax to get the same effect?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在日志文件上使用`for`循环，我们可以在将下一行读入内存之前一次处理一行。如果我们能使用理解语法来获得相同的效果，那不是很好吗？
- en: This is where generator expressions come in. They use the same syntax as comprehensions,
    but they don't create a final container object. To create a generator expression,
    wrap the comprehension in `()` instead of `[]` or `{}`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是生成器表达式的用武之地。它们使用与理解相同的语法，但不创建最终的容器对象。要创建生成器表达式，将理解包装在`()`中，而不是`[]`或`{}`。
- en: 'The following code parses a log file in the previously presented format and
    outputs a new log file that contains only the `WARNING` lines:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码解析了以前介绍的格式的日志文件，并输出了一个只包含`WARNING`行的新日志文件：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This program takes the two filenames on the command line, uses a generator
    expression to filter out the warnings (in this case, it uses the `if` syntax and
    leaves the line unmodified), and then outputs the warnings to another file. If
    we run it on our sample file, the output looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序在命令行上获取两个文件名，使用生成器表达式来过滤警告（在这种情况下，它使用`if`语法并保持行不变），然后将警告输出到另一个文件。如果我们在示例文件上运行它，输出如下：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Of course, with such a short input file, we could have safely used a list comprehension,
    but if the file is millions of lines long, the generator expression will have
    a huge impact on both memory and speed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于这样一个简短的输入文件，我们可以安全地使用列表理解，但是如果文件有数百万行，生成器表达式将对内存和速度产生巨大影响。
- en: Wrapping a `for` expression in parenthesis creates a generator expression, not
    a tuple.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将`for`表达式括在括号中会创建一个生成器表达式，而不是元组。
- en: Generator expressions are frequently most useful inside function calls. For
    example, we can call `sum`, `min`, or `max` on a generator expression instead
    of a list, since these functions process one object at a time. We're only interested
    in the aggregate result, not any intermediate container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式通常在函数调用内最有用。例如，我们可以在生成器表达式上调用`sum`、`min`或`max`，而不是列表，因为这些函数一次处理一个对象。我们只对聚合结果感兴趣，而不关心任何中间容器。
- en: In general, of the four options, a generator expression should be used whenever
    possible. If we don't actually need a list, set, or dictionary, but simply need
    to filter or convert items in a sequence, a generator expression will be most
    efficient. If we need to know the length of a list, or sort the result, remove
    duplicates, or create a dictionary, we'll have to use the comprehension syntax.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，在四个选项中，尽可能使用生成器表达式。如果我们实际上不需要列表、集合或字典，而只需要过滤或转换序列中的项目，生成器表达式将是最有效的。如果我们需要知道列表的长度，或对结果进行排序、去除重复项或创建字典，我们将不得不使用理解语法。
- en: Generators
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: Generator expressions are actually a sort of comprehension too; they compress
    the more advanced (this time it really is more advanced!) generator syntax into
    one line. The greater generator syntax looks even less object-oriented than anything
    we've seen, but we'll discover that once again, it is a simple syntax shortcut
    to create a kind of object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式实际上也是一种理解；它将更高级（这次确实更高级！）的生成器语法压缩成一行。更高级的生成器语法看起来甚至不那么面向对象，但我们将再次发现，这只是一种简单的语法快捷方式，用于创建一种对象。
- en: 'Let''s take the log file example a little further. If we want to delete the
    `WARNING` column from our output file (since it''s redundant: this file contains
    only warnings), we have several options at various levels of readability. We can
    do it with a generator expression:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步考虑一下日志文件示例。如果我们想要从输出文件中删除“WARNING”列（因为它是多余的：这个文件只包含警告），我们有几种不同级别的可读性选项。我们可以使用生成器表达式来实现：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That''s perfectly readable, though I wouldn''t want to make the expression
    much more complicated than that. We could also do it with a normal `for` loop:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这是完全可读的，但我不想使表达式比这更复杂。我们也可以使用普通的“for”循环来实现：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That's clearly maintainable, but so many levels of indent in so few lines is
    kind of ugly. More alarmingly, if we wanted to do something other than printing
    the lines out, we'd have to duplicate the looping and conditional code, too.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是可维护的，但在如此少的行数中有如此多级缩进有点丑陋。更令人担忧的是，如果我们想要做一些其他事情而不是简单地打印出行，我们还必须复制循环和条件代码。
- en: 'Now let''s consider a truly object-oriented solution, without any shortcuts:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一个真正面向对象的解决方案，没有任何捷径：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'No doubt about it: that is so ugly and difficult to read that you may not even
    be able to tell what''s going on. We created an object that takes a file object
    as input, and provides a `__next__` method like any iterator.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问：这太丑陋和难以阅读了，你甚至可能无法理解发生了什么。我们创建了一个以文件对象为输入的对象，并提供了一个像任何迭代器一样的“__next__”方法。
- en: This `__next__` method reads lines from the file, discarding them if they are
    not `WARNING` lines. When we encounter a `WARNING` line, we modify and return
    it. Then our `for` loop calls `__next__` again to process the subsequent `WARNING`
    line. When we run out of lines, we raise `StopIteration` to tell the loop we're
    finished iterating. It's pretty ugly compared to the other examples, but it's
    also powerful; now that we have a class in our hands, we can do whatever we want
    with it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“__next__”方法从文件中读取行，如果不是“WARNING”行，则将其丢弃。当我们遇到“WARNING”行时，我们修改并返回它。然后我们的“for”循环再次调用“__next__”来处理后续的“WARNING”行。当我们用完行时，我们引发“StopIteration”来告诉循环我们已经完成了迭代。与其他示例相比，这相当丑陋，但也很强大；现在我们手头有一个类，我们可以随心所欲地使用它。
- en: 'With that background behind us, we finally get to see true generators in action.
    This next example does *exactly* the same thing as the previous one: it creates
    an object with a `__next__` method that raises `StopIteration` when it''s out
    of inputs:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样的背景，我们终于可以看到真正的生成器在起作用了。下一个示例*完全*与前一个示例相同：它创建了一个具有“__next__”方法的对象，当输入用完时会引发“StopIteration”：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: OK, that's pretty readable, maybe... at least it's short. But what on earth
    is going on here? It makes no sense whatsoever. And what is `yield`, anyway?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那可能相当容易阅读...至少很简短。但这到底是怎么回事？这根本毫无意义。而且“yield”到底是什么？
- en: In fact, `yield` is the key to generators. When Python sees `yield` in a function,
    it takes that function and wraps it up in an object not unlike the one in our
    previous example. Think of the `yield` statement as similar to the `return` statement;
    it exits the function and returns a line. Unlike `return`, however, when the function
    is called again (via `next()`), it will start where it left off—on the line after
    the `yield` statement—instead of at the beginning of the function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，“yield”是生成器的关键。当Python在函数中看到“yield”时，它会将该函数包装在一个对象中，类似于我们之前示例中的对象。将“yield”语句视为类似于“return”语句；它退出函数并返回一行。但与“return”不同的是，当函数再次被调用（通过“next()”）时，它将从上次离开的地方开始——在“yield”语句之后的行——而不是从函数的开头开始。
- en: In this example, there is no line *after* the `yield` statement, so it jumps
    to the next iteration of the `for` loop. Since the `yield` statement is inside
    an `if` statement, it only yields lines that contain `WARNING`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，“yield”语句之后没有行，因此它会跳到“for”循环的下一个迭代。由于“yield”语句位于“if”语句内，它只会产生包含“WARNING”的行。
- en: 'While it looks like this is just a function looping over the lines, it is actually
    creating a special type of object, a generator object:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然看起来这只是一个循环遍历行的函数，但实际上它创建了一种特殊类型的对象，即生成器对象：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: I passed an empty list into the function to act as an iterator. All the function does
    is create and return a generator object. That object has `__iter__` and `__next__`
    methods on it, just like the one we created in the previous example. (You can
    call the `dir` built-in function on it to confirm.) Whenever `__next__` is called,
    the generator runs the function until it finds a `yield` statement. It then returns
    the value from `yield`, and the next time `__next__` is called, it picks up where
    it left off.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我将一个空列表传递给函数，充当迭代器。函数所做的就是创建并返回一个生成器对象。该对象上有“__iter__”和“__next__”方法，就像我们在前面的示例中创建的那样。（你可以调用内置的“dir”函数来确认。）每当调用“__next__”时，生成器运行函数，直到找到“yield”语句。然后它返回“yield”的值，下一次调用“__next__”时，它会从上次离开的地方继续。
- en: This use of generators isn't that advanced, but if you don't realize the function
    is creating an object, it can seem like magic. This example was quite simple,
    but you can get really powerful effects by making multiple calls to `yield` in
    a single function; on each loop, the generator will simply pick up at the most
    recent `yield` and continue to the next one.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种生成器的使用并不那么高级，但如果你没有意识到函数正在创建一个对象，它可能看起来像魔术一样。这个示例非常简单，但通过在单个函数中多次调用“yield”，你可以获得非常强大的效果；在每次循环中，生成器将简单地从最近的“yield”处继续到下一个“yield”处。
- en: Yield items from another iterable
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从另一个可迭代对象中产生值
- en: Often, when we build a generator function, we end up in a situation where we
    want to yield data from another iterable object, possibly a list comprehension
    or generator expression we constructed inside the generator, or perhaps some external
    items that were passed into the function. This has always been possible by looping
    over the iterable and individually yielding each item. However, in Python version
    3.3, the Python developers introduced a new syntax to make it a little more elegant.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们构建一个生成器函数时，我们会陷入一种情况，我们希望从另一个可迭代对象中产生数据，可能是我们在生成器内部构造的列表推导或生成器表达式，或者可能是一些传递到函数中的外部项目。以前可以通过循环遍历可迭代对象并逐个产生每个项目来实现。然而，在Python
    3.3版本中，Python开发人员引入了一种新的语法，使其更加优雅一些。
- en: Let's adapt the generator example a bit so that instead of accepting a sequence
    of lines, it accepts a filename. This would normally be frowned upon as it ties
    the object to a particular paradigm. When possible we should operate on iterators
    as input; this way the same function could be used regardless of whether the log
    lines came from a file, memory, or the web.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微调整一下生成器的例子，使其不再接受一系列行，而是接受一个文件名。这通常会被视为不好的做法，因为它将对象与特定的范例联系在一起。如果可能的话，我们应该在输入上操作迭代器；这样，同一个函数可以在日志行来自文件、内存或网络的情况下使用。
- en: 'This version of the code illustrates that your generator can do some basic
    setup before yielding information from another iterable (in this case, a generator
    expression):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码版本说明了你的生成器可以在从另一个可迭代对象（在本例中是一个生成器表达式）产生信息之前做一些基本的设置：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code combines the `for` loop from the previous example into a generator
    expression. Notice that this transformation didn't help anything; the previous
    example with a `for` loop was more readable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将前面示例中的`for`循环合并为一个生成器表达式。请注意，这种转换并没有帮助任何事情；前面的示例中使用`for`循环更易读。
- en: 'So, let''s consider an example that is more readable than its alternative.
    It can be useful to construct a generator that yields data from multiple other
    generators. The `itertools.chain` function, for example, yields data from iterables
    in sequence until they have all been exhausted. This can be implemented far too
    easily using the `yield from` syntax, so let''s consider a classic computer science
    problem: walking a general tree.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们考虑一个比其替代方案更易读的例子。构建一个生成器，从多个其他生成器中产生数据可能是有用的。例如，`itertools.chain`函数按顺序从可迭代对象中产生数据，直到它们全部耗尽。这可以使用`yield
    from`语法非常容易地实现，因此让我们考虑一个经典的计算机科学问题：遍历一棵通用树。
- en: 'A common implementation of the general tree data structure is a computer''s
    filesystem. Let''s model a few folders and files in a Unix filesystem so we can
    use `yield from` to walk them effectively:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通用树数据结构的一个常见实现是计算机的文件系统。让我们模拟Unix文件系统中的一些文件夹和文件，这样我们就可以有效地使用`yield from`来遍历它们：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This setup code looks like a lot of work, but in a real filesystem, it would
    be even more involved. We''d have to read data from the hard drive and structure
    it into the tree. Once in memory, however, the code that outputs every file in
    the filesystem is quite elegant:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置代码看起来很费力，但在一个真实的文件系统中，它会更加复杂。我们需要从硬盘读取数据并将其结构化成树。然而，一旦在内存中，输出文件系统中的每个文件的代码就非常优雅：
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If this code encounters a directory, it recursively asks `walk()` to generate
    a list of all files subordinate to each of its children, and then yields all that
    data plus its own filename. In the simple case that it has encountered a normal
    file, it just yields that name.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码遇到一个目录，它会递归地要求`walk()`生成每个子目录下所有文件的列表，然后产生所有这些数据以及它自己的文件名。在它遇到一个普通文件的简单情况下，它只会产生那个文件名。
- en: As an aside, solving the preceding problem without using a generator is tricky
    enough that it is a common interview question. If you answer it as shown like
    this, be prepared for your interviewer to be both impressed and somewhat irritated
    that you answered it so easily. They will likely demand that you explain exactly
    what is going on. Of course, armed with the principles you've learned in this
    chapter, you won't have any problem. Good luck!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，解决前面的问题而不使用生成器是相当棘手的，以至于它是一个常见的面试问题。如果你像这样回答，准备好让你的面试官既印象深刻又有些恼火，因为你回答得如此轻松。他们可能会要求你解释到底发生了什么。当然，凭借你在本章学到的原则，你不会有任何问题。祝你好运！
- en: The `yield from` syntax is a useful shortcut when writing chained generators.
    It was added to the language for a different reason, to support coroutines. It
    is not used all that much anymore, however, because it's usage has been replaced
    with `async` and `await` syntax. We'll see examples of both in the next section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield from`语法在编写链式生成器时是一个有用的快捷方式。它被添加到语言中是出于不同的原因，以支持协程。然而，它现在并没有被那么多地使用，因为它的用法已经被`async`和`await`语法所取代。我们将在下一节看到两者的例子。'
- en: Coroutines
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: Coroutines are extremely powerful constructs that are often confused with generators.
    Many authors inappropriately describe coroutines as *generators with a bit of
    extra syntax*. This is an easy mistake to make, as, way back in Python 2.5, when
    coroutines were introduced, they were presented as *we added a* `send` *method
    to the generator syntax*. The difference is actually a lot more nuanced and will
    make more sense after you've seen a few examples.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是非常强大的构造，经常被误解为生成器。许多作者不恰当地将协程描述为*带有一些额外语法的生成器*。这是一个容易犯的错误，因为在Python 2.5中引入协程时，它们被介绍为*我们在生成器语法中添加了一个*
    `send` *方法*。实际上，区别要更微妙一些，在看到一些例子之后会更有意义。
- en: Coroutines are pretty hard to understand. Outside the `asyncio` module, they
    are not used all that often in the wild. You can definitely skip this section
    and happily develop in Python for years without ever encountering coroutines.
    There are a couple of libraries that use coroutines extensively (mostly for concurrent
    or asynchronous programming), but they are normally written such that you can
    use coroutines without actually understanding how they work! So, if you get lost
    in this section, don't despair.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是相当难以理解的。在`asyncio`模块之外，它们在野外并不经常使用。你绝对可以跳过这一部分，快乐地在Python中开发多年，而不必遇到协程。有一些库广泛使用协程（主要用于并发或异步编程），但它们通常是这样编写的，以便你可以使用协程而不必真正理解它们是如何工作的！所以，如果你在这一部分迷失了方向，不要绝望。
- en: 'If I haven''t scared you off, let''s get started! Here''s one of the simplest
    possible coroutines; it allows us to keep a running tally that can be increased
    by arbitrary values:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我还没有吓到你，让我们开始吧！这是一个最简单的协程之一；它允许我们保持一个可以通过任意值增加的累加值：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code looks like black magic that couldn''t possibly work, so let''s prove
    it works before going into a line-by-line description. This simple object could
    be used by a scoring application for a baseball team. Separate tallies could be
    kept for each team, and their score could be incremented by the number of runs
    accumulated at the end of every half-innings. Look at this interactive session:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来像是不可能工作的黑魔法，所以在逐行描述之前，让我们证明它可以工作。这个简单的对象可以被棒球队的记分应用程序使用。可以为每个队伍分别保留计分，并且他们的得分可以在每个半局结束时累加的得分增加。看看这个交互式会话：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, we construct two `tally` objects, one for each team. Yes, they look like
    functions, but as with the generator objects in the previous section, the fact
    that there is a `yield` statement inside the function tells Python to put a great
    deal of effort into turning the simple function into an object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们构建了两个`tally`对象，一个用于每个队伍。是的，它们看起来像函数，但与上一节中的生成器对象一样，函数内部有`yield`语句告诉Python要付出很大的努力将简单的函数转换为对象。
- en: We then call `next()` on each of the coroutine objects. This does the same thing
    as calling next on any generator, which is to say, it executes each line of code
    until it encounters a `yield` statement, returns the value at that point, and
    then *pauses* until the next `next()` call.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对每个协程对象调用`next()`。这与调用任何生成器的`next()`做的事情是一样的，也就是说，它执行每一行代码，直到遇到`yield`语句，返回该点的值，然后*暂停*，直到下一个`next()`调用。
- en: 'So far, then, there''s nothing new. But look back at the `yield` statement
    in our coroutine:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，没有什么新鲜的。但是回顾一下我们协程中的`yield`语句：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Unlike with generators, this `yield` function looks like it's supposed to return
    a value and assign it to a variable. In fact, this is exactly what's happening.
    The coroutine is still paused at the `yield` statement and waiting to be activated
    again by another call to `next()`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与生成器不同，这个`yield`函数看起来像是要返回一个值并将其赋给一个变量。事实上，这正是发生的事情。协程仍然在`yield`语句处暂停，等待被另一个`next()`调用再次激活。
- en: Except we don't call `next()`. As you see in the interactive session, we instead
    call to a method called `send()`. The `send()` method does *exactly* the same
    thing as `next()` except that in addition to advancing the generator to the next
    `yield` statement, it also allows you to pass in a value from outside the generator.
    This value is what gets assigned to the left side of the `yield` statement.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们不调用`next()`。正如你在交互式会话中看到的，我们调用一个名为`send()`的方法。`send()`方法和`next()`做*完全*相同的事情，只是除了将生成器推进到下一个`yield`语句之外，它还允许你从生成器外部传入一个值。这个值被分配给`yield`语句的左侧。
- en: 'The thing that is really confusing for many people is the order in which this
    happens:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人来说，真正令人困惑的是这发生的顺序：
- en: '`yield` occurs and the generator pauses'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`yield`发生，生成器暂停'
- en: '`send()` occurs from outside the function and the generator wakes up'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`send()`发生在函数外部，生成器被唤醒'
- en: The value sent in is assigned to the left side of the `yield` statement
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传入的值被分配给`yield`语句的左侧
- en: The generator continues processing until it encounters another `yield` statement
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成器继续处理，直到遇到另一个`yield`语句
- en: 'So, in this particular example, after we construct the coroutine and advance
    it to the `yield` statement with a single call to `next()`, each successive call
    to `send()` passes a value into the coroutine. We add this value to its score.
    Then we go back to the top of the `while` loop, and keep processing until we hit
    the `yield` statement. The `yield` statement returns a value, which becomes the
    return value of our most recent call to `send`. Don''t miss that: like `next()`,
    the `send()` method does not just submit a value to the generator, it also returns
    the value from the upcoming `yield` statement. This is how we define the difference
    between a generator and a coroutine: a generator only produces values, while a
    coroutine can also consume them.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个特定的例子中，我们构建了协程并通过单次调用`next()`将其推进到`yield`语句，然后每次调用`send()`都将一个值传递给协程。我们将这个值加到它的得分上。然后我们回到`while`循环的顶部，并继续处理，直到我们遇到`yield`语句。`yield`语句返回一个值，这个值成为我们最近一次调用`send`的返回值。不要错过这一点：像`next()`一样，`send()`方法不仅提交一个值给生成器，还返回即将到来的`yield`语句的值。这就是我们定义生成器和协程之间的区别的方式：生成器只产生值，而协程也可以消耗值。
- en: 'The behavior and syntax of `next(i)`, `i.__next__()`, and `i.send(value)` are
    rather unintuitive and frustrating. The first is a normal function, the second
    is a special method, and the last is a normal method. But all three do the same
    thing: advance the generator until it yields a value and pause. Further, the `next()`
    function and associated method can be replicated by calling `i.send(None)`. There
    is value to having two different method names here, since it helps the reader
    of our code easily see whether they are interacting with a coroutine or a generator.
    I just find the fact that in one case it''s a function call and in the other it''s
    a normal method somewhat irritating.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`next(i)`、`i.__next__()`和`i.send(value)`的行为和语法相当不直观和令人沮丧。第一个是普通函数，第二个是特殊方法，最后一个是普通方法。但这三个都是做同样的事情：推进生成器直到它产生一个值并暂停。此外，`next()`函数和相关的方法可以通过调用`i.send(None)`来复制。在这里有两个不同的方法名是有价值的，因为它有助于我们的代码读者轻松地看到他们是在与协程还是生成器交互。我只是觉得在某些情况下它是一个函数调用，而在另一种情况下它是一个普通方法有点令人恼火。'
- en: Back to log parsing
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到日志解析
- en: Of course, the previous example could easily have been coded using a couple
    of integer variables and calling `x += increment` on them. Let's look at a second
    example where coroutines actually save us some code. This example is a somewhat
    simplified (for pedagogical reasons) version of a problem I had to solve while
    working at Facebook.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的例子可以很容易地使用一对整数变量编码，并在它们上调用`x += increment`。让我们看一个第二个例子，其中协程实际上节省了我们一些代码。这个例子是我在Facebook工作时不得不解决的问题的一个简化版本（出于教学目的）。
- en: 'The Linux kernel log contains lines that look almost, but not quite entirely,
    unlike this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核日志包含几乎看起来与此类似但又不完全相同的行：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There are a whole bunch of interspersed kernel log messages, some of which pertain
    to hard disks. The hard disk messages might be interspersed with other messages,
    but they occur in a predictable format and order. For each, a specific drive with
    a known serial number is associated with a bus identifier (such as `0:0:0:0`).
    A block device identifier (such as `sda`) is also associated with that bus. Finally,
    if the drive has a corrupt filesystem, it might fail with an XFS error.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有一大堆交错的内核日志消息，其中一些与硬盘有关。硬盘消息可能与其他消息交错，但它们以可预测的格式和顺序出现。对于每个硬盘，已知的序列号与总线标识符（如`0:0:0:0`）相关联。块设备标识符（如`sda`）也与该总线相关联。最后，如果驱动器的文件系统损坏，它可能会出现XFS错误。
- en: Now, given the preceding log file, the problem we need to solve is how to obtain
    the serial number of any drives that have XFS errors on them. This serial number
    might later be used by a data center technician to identify and replace the drive.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑到前面的日志文件，我们需要解决的问题是如何获取任何出现XFS错误的驱动器的序列号。这个序列号可能稍后会被数据中心的技术人员用来识别并更换驱动器。
- en: We know we can identify the individual lines using regular expressions, but
    we'll have to change the regular expressions as we loop through the lines, since
    we'll be looking for different things depending on what we found previously. The
    other difficult bit is that if we find an error string, the information about
    which bus contains that string as well as the serial number have already been
    processed. This can easily be solved by iterating through the lines of the file
    in reverse order.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们可以使用正则表达式识别单独的行，但是我们将不得不在循环遍历行时更改正则表达式，因为我们将根据先前找到的内容寻找不同的东西。另一个困难的地方是，如果我们找到一个错误字符串，包含该字符串的总线以及序列号的信息已经被处理过。这可以通过以相反的顺序迭代文件的行来轻松解决。
- en: 'Before you look at this example, be warned—the amount of code required for
    a coroutine-based solution is scarily small:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看这个例子之前，请注意——基于协程的解决方案所需的代码量非常少：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code neatly divides the job into two separate tasks. The first task is
    to loop over all the lines and spit out any lines that match a given regular expression.
    The second task is to interact with the first task and give it guidance as to
    what regular expression it is supposed to be searching for at any given time.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将工作分成了两个独立的任务。第一个任务是循环遍历所有行并输出与给定正则表达式匹配的任何行。第二个任务是与第一个任务交互，并为其提供指导，告诉它在任何给定时间应该搜索什么正则表达式。
- en: Look at the `match_regex` coroutine first. Remember, it doesn't execute any
    code when it is constructed; rather, it just creates a coroutine object. Once
    constructed, someone outside the coroutine will eventually call `next()` to start
    the code running. Then it stores the state of two variables `filename` and `regex`.
    It then reads all the lines in the file and iterates over them in reverse. Each
    line is compared to the regular expression that was passed in until it finds a
    match. When the match is found, the coroutine yields the first group from the
    regular expression and waits.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先看`match_regex`协程。记住，它在构造时不执行任何代码；相反，它只创建一个协程对象。一旦构造完成，协程外部的某人最终会调用`next()`来启动代码运行。然后它存储两个变量`filename`和`regex`的状态。然后它读取文件中的所有行并以相反的顺序对它们进行迭代。将传入的每一行与正则表达式进行比较，直到找到匹配项。当找到匹配项时，协程会产生正则表达式的第一个组并等待。
- en: At some point in the future, other code will send in a new regular expression
    to search for. Note that the coroutine never cares what regular expression it
    is trying to match; it's just looping over lines and comparing them to a regular
    expression. It's somebody else's responsibility to decide what regular expression
    to supply.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在将来的某个时候，其他代码将发送一个新的正则表达式来搜索。请注意，协程从不关心它试图匹配的正则表达式是什么；它只是循环遍历行并将它们与正则表达式进行比较。决定提供什么正则表达式是别人的责任。
- en: In this case, that somebody else is the `get_serials` generator. It doesn't
    care about the lines in the file; in fact, it isn't even aware of them. The first
    thing it does is create a `matcher` object from the `match_regex` coroutine constructor,
    giving it a default regular expression to search for. It advances the coroutine
    to its first `yield` and stores the value it returns. It then goes into a loop
    that instructs the `matcher` object to search for a bus ID based on the stored
    device ID, and then a serial number based on that bus ID.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，其他人是`get_serials`生成器。它不关心文件中的行；事实上，它甚至不知道它们。它做的第一件事是从`match_regex`协程构造函数创建一个`matcher`对象，给它一个默认的正则表达式来搜索。它将协程推进到它的第一个`yield`并存储它返回的值。然后它进入一个循环，指示`matcher`对象基于存储的设备ID搜索总线ID，然后基于该总线ID搜索序列号。
- en: It idly yields that serial number to the outside `for` loop before instructing
    the matcher to find another device ID and repeat the cycle.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它在向外部`for`循环空闲地产生该序列号之前指示匹配器找到另一个设备ID并重复循环。
- en: Basically, the coroutine's job is to search for the next important line in the
    file, while the generator's (`get_serial`, which uses the `yield` syntax without
    assignment) job is to decide which line is important. The generator has information
    about this particular problem, such as what order lines will appear in the file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，协程的工作是在文件中搜索下一个重要的行，而生成器（`get_serial`，它使用`yield`语法而不进行赋值）的工作是决定哪一行是重要的。生成器有关于这个特定问题的信息，比如文件中行的顺序。
- en: The coroutine, on the other hand, could be plugged into any problem that required
    searching a file for given regular expressions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，协程可以插入到需要搜索文件以获取给定正则表达式的任何问题中。
- en: Closing coroutines and throwing exceptions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭协程和引发异常
- en: Normal generators signal their exit from inside by raising `StopIteration`.
    If we chain multiple generators together (for example, by iterating over one generator
    from inside another), the `StopIteration` exception will be propagated outward.
    Eventually, it will hit a `for` loop that will see the exception and know that
    it's time to exit the loop.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 普通的生成器通过引发`StopIteration`来信号它们的退出。如果我们将多个生成器链接在一起（例如，通过在另一个生成器内部迭代一个生成器），`StopIteration`异常将向外传播。最终，它将遇到一个`for`循环，看到异常并知道是时候退出循环了。
- en: Even though they use a similar syntax, coroutines don't normally follow the
    iteration mechanism. Instead of pulling data through one until an exception is
    encountered, data is usually pushed into it (using `send`). The entity doing the
    pushing is normally the one in charge of telling the coroutine when it's finished.
    It does this by calling the `close()` method on the coroutine in question.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们使用类似的语法，协程通常不遵循迭代机制。通常不是通过一个直到遇到异常的数据，而是通常将数据推送到其中（使用`send`）。通常是负责推送的实体告诉协程何时完成。它通过在相关协程上调用`close()`方法来做到这一点。
- en: When called, the `close()` method will raise a `GeneratorExit` exception at
    the point the coroutine was waiting for a value to be sent in. It is normally
    good policy for coroutines to wrap their `yield` statements in a `try`...`finally`
    block so that any cleanup tasks (such as closing associated files or sockets)
    can be performed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`close()`方法时，它将在协程等待发送值的点引发`GeneratorExit`异常。通常，协程应该将它们的`yield`语句包装在`try`...`finally`块中，以便执行任何清理任务（例如关闭关联文件或套接字）。
- en: If we need to raise an exception inside a coroutine, we can use the `throw()`
    method in a similar way. It accepts an exception type with optional `value` and
    `traceback` arguments. The latter is useful when we encounter an exception in
    one coroutine and want to cause an exception to occur in an adjacent coroutine
    while maintaining the traceback.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在协程内部引发异常，我们可以类似地使用`throw()`方法。它接受一个异常类型，可选的`value`和`traceback`参数。当我们在一个协程中遇到异常并希望在相邻的协程中引发异常时，后者是有用的，同时保持回溯。
- en: The previous example could be written without coroutines and would be about
    equally readable. The truth is, correctly managing all the state between coroutines
    is pretty difficult, especially when you take things like context managers and
    exceptions into account. Luckily, the Python standard library contains a package
    called `asyncio` that can manage all of this for you. In general, I recommend
    you avoid using bare coroutines unless you are specifically coding for asyncio.
    The logging example could almost be considered an *anti-pattern*; a design pattern
    that should be avoided rather than embraced.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子可以在没有协程的情况下编写，并且读起来几乎一样。事实上，正确地管理协程之间的所有状态是相当困难的，特别是当你考虑到上下文管理器和异常等因素时。幸运的是，Python标准库包含一个名为`asyncio`的包，可以为您管理所有这些。一般来说，我建议您避免使用裸协程，除非您专门为asyncio编写代码。日志示例几乎可以被认为是一种*反模式*；一种应该避免而不是拥抱的设计模式。
- en: The relationship between coroutines, generators, and functions
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程、生成器和函数之间的关系
- en: We've seen coroutines in action, so now let's go back to that discussion of
    how they are related to generators. In Python, as is so often the case, the distinction
    is quite blurry. In fact, all coroutines are generator objects, and authors often
    use the two terms interchangeably. Sometimes, they describe coroutines as a subset
    of generators (only generators that return values from yield are considered coroutines).
    This is technically true in Python, as we've seen in the previous sections.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了协程的运行，现在让我们回到讨论它们与生成器的关系。在Python中，就像经常发生的情况一样，这种区别是相当模糊的。事实上，所有的协程都是生成器对象，作者经常交替使用这两个术语。有时，他们将协程描述为生成器的一个子集（只有从`yield`返回值的生成器被认为是协程）。这在Python中是技术上正确的，正如我们在前面的部分中看到的。
- en: However, in the greater sphere of theoretical computer science, coroutines are
    considered the more general principles, and generators are a specific type of
    coroutine. Further, normal functions are yet another distinct subset of coroutines.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在更广泛的理论计算机科学领域，协程被认为是更一般的原则，生成器是协程的一种特定类型。此外，普通函数是协程的另一个独特子集。
- en: A coroutine is a routine that can have data passed in at one or more points
    and get it out at one or more points. In Python, the point where data is passed
    in and out is the `yield` statement.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 协程是一个可以在一个或多个点传入数据并在一个或多个点获取数据的例程。在Python中，数据传入和传出的点是`yield`语句。
- en: A function, or subroutine, is the simplest type of coroutine. You can pass data
    in at one point, and get data out at one other point when the function returns.
    While a function can have multiple `return` statements, only one of them can be
    called for any given invocation of the function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 函数，或子例程，是协程的最简单类型。您可以在一个点传入数据，并在函数返回时在另一个点获取数据。虽然函数可以有多个`return`语句，但对于任何给定的函数调用，只能调用其中一个。
- en: Finally, a generator is a type of coroutine that can have data passed in at
    one point, but can pass data out at multiple points. In Python, the data would
    be passed out at a `yield` statement, but you can't pass data back in. If you
    called `send`, the data would be silently discarded.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，生成器是一种可以在一个点传入数据的协程，但可以在多个点传出数据的协程。在Python中，数据将在`yield`语句处传出，但无法再传入数据。如果调用`send`，数据将被悄悄丢弃。
- en: So, in theory, generators are types of coroutines, functions are types of coroutines,
    and there are coroutines that are neither functions nor generators. That's simple
    enough, eh? So, why does it feel more complicated in Python?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，理论上，生成器是协程的一种类型，函数是协程的一种类型，还有一些既不是函数也不是生成器的协程。够简单了吧？那么，为什么在Python中感觉更复杂呢？
- en: In Python, generators and coroutines are both constructed using a syntax that
    **looks** like we are constructing a function. But the resulting object is not
    a function at all; it's a totally different kind of object. Functions are, of
    course, also objects. But they have a different interface; functions are callable
    and return values, generators have data pulled out using `next()`, and coroutines
    have data pushed in using `send`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，生成器和协程都是使用类似于构造函数的语法构造的。但是生成的对象根本不是函数；它是一种完全不同类型的对象。函数当然也是对象。但它们有不同的接口；函数是可调用的并返回值，生成器使用`next()`提取数据，协程使用`send`推入数据。
- en: There is an alternate syntax for coroutines using the `async` and `await` keywords. The
    syntax makes it clearer that the code is a coroutine and further breaks the deceiving
    symmetry between coroutines and generators.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种使用`async`和`await`关键字的协程的替代语法。这种语法使得代码更清晰，表明代码是一个协程，并进一步打破了协程和生成器之间的欺骗性对称性。
- en: Case study
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: One of the fields in which Python is the most popular these days is data science.
    In honor of that fact, let's implement a basic machine learning algorithm.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Python目前最流行的领域之一是数据科学。为了纪念这一事实，让我们实现一个基本的机器学习算法。
- en: Machine learning is a huge topic, but the general idea is to make predictions
    or classifications about future data by using knowledge gained from past data.
    Uses of such algorithms abound, and data scientists are finding new ways to apply
    machine learning every day. Some important machine learning applications include
    computer vision (such as image classification or facial recognition), product
    recommendation, identifying spam, and self-driving cars.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习是一个庞大的主题，但总体思想是利用从过去数据中获得的知识对未来数据进行预测或分类。这些算法的用途层出不穷，数据科学家每天都在找到应用机器学习的新方法。一些重要的机器学习应用包括计算机视觉（如图像分类或人脸识别）、产品推荐、识别垃圾邮件和自动驾驶汽车。
- en: 'So as not to digress into an entire book on machine learning, we''ll look at
    a simpler problem: given an RGB color definition, what name would humans identify
    that color as?'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不偏离整本关于机器学习的书，我们将看一个更简单的问题：给定一个RGB颜色定义，人们会将该颜色定义为什么名字？
- en: 'There are more than 16 million colors in the standard RGB color space, and
    humans have come up with names for only a fraction of them. While there are thousands
    of names (some quite ridiculous; just go to any car dealership or paint store),
    let''s build a classifier that attempts to divide the RGB space into the basic
    colors:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 标准RGB颜色空间中有超过1600万种颜色，人类只为其中的一小部分取了名字。虽然有成千上万种名称（有些相当荒谬；只需去任何汽车经销商或油漆商店），让我们构建一个试图将RGB空间划分为基本颜色的分类器：
- en: Red
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色
- en: Purple
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 紫色
- en: Blue
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝色
- en: Green
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色
- en: Yellow
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黄色
- en: Orange
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 橙色
- en: Gray
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灰色
- en: Pink
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粉色
- en: (In my testing, I classified whitish and blackish colors as gray, and brownish
    colors as orange.)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: （在我的测试中，我将白色和黑色的颜色分类为灰色，棕色的颜色分类为橙色。）
- en: 'The first thing we need is a dataset to train our algorithm on. In a production
    system, you might scrape a *list of colors* website or survey thousands of people.
    Instead, I created a simple application that renders a random color and asks the
    user to select one of the preceding eight options to classify it. I implemented
    it using `tkinter`, the user interface toolkit that ships with Python. I''m not
    going to go into the details of what this script does, but here it is in its entirety
    for completeness (it''s a trifle long, so you may want to pull it from Packt''s
    GitHub repository with the examples for this book instead of typing it in):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的第一件事是一个数据集来训练我们的算法。在生产系统中，您可能会从*颜色列表*网站上获取数据，或者对成千上万的人进行调查。相反，我创建了一个简单的应用程序，它会呈现一个随机颜色，并要求用户从前面的八个选项中选择一个来分类。我使用了Python附带的用户界面工具包`tkinter`来实现它。我不打算详细介绍这个脚本的内容，但为了完整起见，这是它的全部内容（它有点长，所以您可能想从Packt的GitHub存储库中获取本书示例的完整内容，而不是自己输入）：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can easily add more buttons for other colors if you like. You may get tripped
    up on the layout; the second and third argument to `create_color_button` represent
    the row and column of a two column grid that the button goes in. Once you have
    all your colors in place, you will want to move the **Quit** button to the last
    row.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以轻松添加更多按钮以获取其他颜色。您可能会在布局上遇到问题；`create_color_button`的第二个和第三个参数表示按钮所在的两列网格的行和列。一旦您将所有颜色放在位，您将希望将**退出**按钮移动到最后一行。
- en: 'For the purposes of this case study, the important thing to know about this
    application is the output. It creates a **C****omma-Separated Value** (**CSV**)
    file named `colors.csv`. This file contains two CSVs: the label the user assigned
    to the color, and the hex RGB value for the color. Here''s an example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个案例研究，了解这个应用程序的重要事情是输出。它创建了一个名为`colors.csv`的**逗号分隔值**（**CSV**）文件。该文件包含两个CSV：用户为颜色分配的标签和颜色的十六进制RGB值。以下是一个示例：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I made over 250 datapoints before I got bored and decided it was time to start
    machine learning on my dataset. My datapoints are shipped with the examples for
    this chapter if you would like to use it (nobody's ever told me I'm colorblind,
    so it should be somewhat reasonable).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我厌倦并决定开始对我的数据集进行机器学习之前，我制作了250多个数据点。如果您想使用它，我的数据点已经与本章的示例一起提供（没有人告诉我我是色盲，所以它应该是合理的）。
- en: We'll be implementing one of the simpler machine learning algorithms, referred
    to as *k-nearest neighbor*. This algorithm relies on some kind of *distance* calculation
    between points in the dataset (in our case, we can use a three-dimensional version
    of the Pythagorean theorem). Given a new datapoint, it finds a certain number
    (referred to as *k*, which is the *k* in *k-nearest*) of datapoints that are closest
    to it when measured by that distance calculation. Then it combines those datapoints
    in some way (an average might work for linear calculations; for our classification
    problem, we'll use the mode), and returns the result.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一种更简单的机器学习算法，称为*k最近邻*。该算法依赖于数据集中点之间的某种*距离*计算（在我们的情况下，我们可以使用三维版本的毕达哥拉斯定理）。给定一个新的数据点，它找到一定数量（称为*k*，这是*k最近邻*中的*k*）的数据点，这些数据点在通过该距离计算进行测量时最接近它。然后以某种方式组合这些数据点（对于线性计算，平均值可能有效；对于我们的分类问题，我们将使用模式），并返回结果。
- en: We won't go into too much detail about what the algorithm does; rather, we'll
    focus on some of the ways we can apply the iterator pattern or iterator protocol
    to this problem.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍算法的工作原理；相反，我们将专注于如何将迭代器模式或迭代器协议应用于这个问题。
- en: 'Let''s now write a program that performs the following steps in order:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个程序，按顺序执行以下步骤：
- en: Load the sample data from the file and construct a model from it.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中加载示例数据并构建模型。
- en: Generate 100 random colors.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成100种随机颜色。
- en: Classify each color and output it to a file in the same format as the input.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每种颜色进行分类，并以与输入相同的格式输出到文件。
- en: 'The first step is a fairly simple generator that loads CSV data and converts
    it into a format that is amenable to our needs:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是一个相当简单的生成器，它加载CSV数据并将其转换为符合我们需求的格式：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We haven't seen the `csv.reader` function before. It returns an iterator over
    the lines in the file. Each value returned by the iterator is a list of strings,
    as separated by commas. So, the line `Green,#6edd13` is returned as `["Green",
    "#6edd13"]`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以前没有见过`csv.reader`函数。它返回文件中行的迭代器。迭代器返回的每个值都是一个由逗号分隔的字符串列表。因此，行`Green,#6edd13`返回为`["Green",
    "#6edd13"]`。
- en: The `load_colors` generator then consumes that iterator, one line at a time,
    and yields a tuple of RGB values as well as the label. It is quite common for
    generators to be chained in this way, where one iterator calls another that calls
    another and so on. You may want to look at the `itertools` module in the Python
    Standard Library for a whole host of such ready-made generators waiting for you.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`load_colors`生成器逐行消耗该迭代器，并产生RGB值的元组以及标签。这种方式将生成器链接在一起是非常常见的，其中一个迭代器调用另一个迭代器，依此类推。您可能希望查看Python标准库中的`itertools`模块，其中有许多等待您的现成生成器。
- en: 'The RGB values in this case are tuples of integers between 0 and 255\. The
    conversion from hex to RGB is a bit tricky, so we pulled it out into a separate
    function:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，RGB值是0到255之间的整数元组。从十六进制到RGB的转换有点棘手，因此我们将其提取到一个单独的函数中：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This generator expression is doing a lot of work. It takes a string such as `"#12abfe"`
    as input and returns a tuple such as `(18, 171, 254)`. Let's break it down from
    back to front.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成器表达式正在做很多工作。它以`“＃12abfe”`这样的字符串作为输入，并返回一个类似`(18, 171, 254)`的元组。让我们从后往前分解。
- en: The `range` call will return the numbers `[1, 3, 5]`. These represent the indexes
    of the three color channels in the hex string. The index, `0`, is skipped, since
    it represents the character `"#"`, which we don't care about. For each of the
    three numbers, it extracts the two character string between `i` and `i+2`. For
    the preceding example string , that would be `12`, `ab`, and `fe`. Then it converts
    this string value to an integer. The `16` passed as the second argument to the
    `int` function tells the function to use base-16 (hexadecimal) instead of the
    usual base-10 (decimal) for the conversion.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`调用将返回数字`[1, 3, 5]`。这些数字代表十六进制字符串中三个颜色通道的索引。索引`0`被跳过，因为它代表字符`“＃”`，而我们不关心这个字符。对于这三个数字中的每一个，它提取`i`和`i+2`之间的两个字符的字符串。对于前面的示例字符串，这将是`12`，`ab`和`fe`。然后将此字符串值转换为整数。作为`int`函数的第二个参数传递的`16`告诉函数使用基数16（十六进制）而不是通常的基数10（十进制）进行转换。'
- en: Given how difficult the generator expression is to read, do you think it should
    have been represented in a different format? It could be created as a sequence
    of multiple generator expressions, for example, or be unrolled into a normal generator
    function with `yield` statements. Which would you prefer?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到生成器表达式的阅读难度，您认为它应该以不同的格式表示吗？例如，它可以被创建为多个生成器表达式的序列，或者展开为一个带有`yield`语句的普通生成器函数。您更喜欢哪种？
- en: In this case, I am comfortable trusting the function name to explain what the
    ugly line of code is doing.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我相信函数名称能够解释这行丑陋代码在做什么。
- en: Now that we've loaded the *training data* (manually classified colors, we need
    some new data to test how well the algorithm is working. We can do this by generating
    a hundred random colors, each composed of three random numbers between 0 and 255.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经加载了*训练数据*（手动分类的颜色），我们需要一些新数据来测试算法的工作效果。我们可以通过生成一百种随机颜色来实现这一点，每种颜色由0到255之间的三个随机数字组成。
- en: 'There are so many ways this can be done:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以做到这一点：
- en: A list comprehension with a nested generator expression: ``[tuple(randint(0,255)
    for c in range(3)) for r in range(100)]``
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有嵌套生成器表达式的列表推导：``[tuple(randint(0,255) for c in range(3)) for r in range(100)]``
- en: A basic generator function
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基本的生成器函数
- en: A class that implements the `__iter__` and `__next__` protocols
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`__iter__`和`__next__`协议的类
- en: Push the data through a pipeline of coroutines
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过一系列协同程序将数据传递
- en: Even just a basic `for` loop
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使只是一个基本的`for`循环
- en: 'The generator version seems to be most readable, so let''s add that function
    to our program:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器版本似乎最易读，所以让我们将该函数添加到我们的程序中：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice how we parameterize the number of colors to generate. We can now reuse
    this function for other color-generating tasks in the future.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何对要生成的颜色数量进行参数化。现在我们可以在将来重用这个函数来执行其他生成颜色的任务。
- en: 'Now, before we do the classification step, we need a function to calculate
    the *distance* between two colors. Since it''s possible to think of colors as
    being three dimensional (red, green, and blue could map to the *x*, *y*, and *z*
    axes, for example), let''s use a little basic math:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在进行分类之前，我们需要一个计算两种颜色之间*距离*的函数。由于可以将颜色看作是三维的（例如，红色、绿色和蓝色可以映射到*x*、*y*和*z*轴），让我们使用一些基本的数学：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a pretty basic-looking function; it doesn't look like it's even using
    the iterator protocol. There's no `yield` function, no comprehensions. However,
    there is a `for` loop, and that call to the `zip` function is doing some real
    iteration as well (if you aren't familiar with it, `zip` yields tuples, each containing
    one element from each input iterator).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个看起来非常基本的函数；它看起来甚至没有使用迭代器协议。没有`yield`函数，也没有推导。但是，有一个`for`循环，`zip`函数的调用也在进行一些真正的迭代（如果您不熟悉它，`zip`会产生元组，每个元组包含来自每个输入迭代器的一个元素）。
- en: 'This distance calculation is the three-dimensional version of the Pythagorean
    theorem you may remember from school: *a² + b² = c²*. Since we are using three
    dimensions, I guess it would actually be *a² + b² + c² = d²*. The distance is
    technically the square root of *a² + b² + c²*, but there isn''t any need to perform
    the somewhat expensive `sqrt` calculation since the squared distances are all
    the same relative size to each other.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个距离计算是你可能从学校记得的勾股定理的三维版本：*a² + b² = c²*。由于我们使用了三个维度，我猜实际上应该是*a² + b² + c² =
    d²*。距离在技术上是*a² + b² + c²*的平方根，但没有必要执行相对昂贵的`sqrt`计算，因为平方距离在大小上都是相同的。
- en: 'Now that we have some plumbing in place, let''s do the actual k-nearest neighbor
    implementation. This routine can be thought of as consuming and combining the
    two generators we''ve already seen (`load_colors` and `generate_colors`):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一些基本的管道，让我们来实现实际的k-nearest neighbor。这个例程可以被认为是消耗和组合我们已经看到的两个生成器（`load_colors`和`generate_colors`）：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We first convert the `model_colors` generator to a list because it has to be
    consumed multiple times, once for each of the `target_colors`.  If we didn't do
    this, we would have to load the colors from the source file repeatedly, which
    would perform a lot of unnecessary disk reads.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`model_colors`生成器转换为列表，因为它必须被多次使用，每次用于`target_colors`中的一个。如果我们不这样做，就必须重复从源文件加载颜色，这将执行大量不必要的磁盘读取。
- en: The downside of this decision is that the entire list has to be stored in memory
    all at once. If we had a massive dataset that didn't fit in memory, it would actually
    be necessary to reload the generator from disk each time (though we'd actually
    be looking at different machine learning algorithms in that case).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这种决定的缺点是整个列表必须一次性全部存储在内存中。如果我们有一个无法放入内存的大型数据集，实际上需要每次从磁盘重新加载生成器（尽管在这种情况下，我们实际上会考虑不同的机器学习算法）。
- en: The `nearest_neighbors` generator loops over each target color (a three-tuple,
    such as `(255, 14, 168)`) and calls the `color_distance` function on it inside
    a generator expression. The `sorted` call surrounding that generator expression
    then sorts the results by their first element, which is the distance. It is a
    complicated piece of code and isn't object-oriented at all. You may want to break
    it down into a normal `for` loop to ensure you understand what the generator expression
    is doing.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`nearest_neighbors`生成器循环遍历每个目标颜色（例如`(255, 14, 168)`的三元组），并在生成器表达式中调用`color_distance`函数。然后，`sorted`调用对该生成器表达式的结果按其第一个元素进行排序，即距离。这是一段复杂的代码，一点也不面向对象。您可能需要将其分解为普通的`for`循环，以确保您理解生成器表达式在做什么。'
- en: The `yield` statement is a bit less complicated. For each RGB three-tuple from
    the `target_colors` generator, it yields the target, and a list comprehension
    of the `num_neighbors` (that's the *k* in *k-nearest*, by the way. Many mathematicians
    and, by extension, data scientists, have a horrible tendency to use unintelligible
    one-letter variable names) closest colors.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield`语句稍微复杂一些。对于`target_colors`生成器中的每个RGB三元组，它产生目标和`num_neighbors`（这是*k*在*k-nearest*中，顺便说一下，许多数学家和数据科学家倾向于使用难以理解的单字母变量名）最接近的颜色的列表推导。'
- en: 'The contents of each element in the list comprehension is an element from the
    `model_colors` generator; that is, a tuple of a tuple of three RGB values and
    the string name that was manually entered for that color. So, one element might
    look like this: `((104, 195, 77), ''Green'')`. The first thing I think when I
    see nested tuples like that is, *that is not the right datastructure*. The RGB
    color should probably be represented as a named tuple, and the two attributes
    should maybe go on a dataclass.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '列表推导中的每个元素的内容是`model_colors`生成器的一个元素；也就是说，一个包含三个RGB值和手动输入的字符串名称的元组。因此，一个元素可能看起来像这样：`((104,
    195, 77), ''Green'')`。当我看到嵌套元组时，我首先想到的是，*这不是正确的数据结构*。RGB颜色可能应该表示为一个命名元组，并且这两个属性可能应该放在一个数据类上。 '
- en: 'We can now add *another* generator to the chain to figure out what name we
    should give this target color:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加*另一个*生成器到链中，以找出我们应该给这个目标颜色起什么名字：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This generator is unpacking the tuple returned by `nearest_neighbors` into the
    three-tuple target and the five nearest datapoints. It uses a `Counter` to find
    the name that appears most often among the colors that were returned. There is
    yet another generator expression in the `Counter` constructor; this one extracts
    the second element (the color name) from each datapoint. Then it yields a tuple
    RGB value and the guessed name. An example of the return value is `(91, 158, 250)
    Blue`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成器将`nearest_neighbors`返回的元组解包成三元组目标和五个最近的数据点。它使用`Counter`来找到在返回的颜色中最常出现的名称。在`Counter`构造函数中还有另一个生成器表达式；这个生成器表达式从每个数据点中提取第二个元素（颜色名称）。然后它产生一个RGB值和猜测的名称的元组。返回值的一个例子是`(91,
    158, 250) Blue`。
- en: 'We can write a function that accepts the output from the `name_colors` generator
    and writes it to a CSV file, with the RGB colors represented as hex values:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个函数，接受`name_colors`生成器的输出，并将其写入CSV文件，RGB颜色表示为十六进制值：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is a function, not a generator. It's consuming the generator in a `for`
    loop, but it's not yielding anything. It constructs a CSV writer and outputs rows
    of name, hex value (for example, `Purple,#7f5f95`) pairs for each of the target
    colors. The only thing that might be confusing in here is the contents of the
    format string. The `:02x` modifier used with each of the `r`,`g`, and `b` channels
    outputs the number as a zero-padded two-digit hexadecimal number.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数，而不是一个生成器。它在`for`循环中消耗生成器，但它不产生任何东西。它构造了一个CSV写入器，并为每个目标颜色输出名称、十六进制值（例如`Purple,#7f5f95`）对的行。这里可能会让人困惑的唯一一件事是格式字符串的内容。与每个`r`、`g`和`b`通道一起使用的`:02x`修饰符将数字输出为前导零填充的两位十六进制数。
- en: 'Now all we have to do is connect these various generators and pipelines together,
    and kick off the process with a single function call:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所要做的就是将这些不同的生成器和管道连接在一起，并通过一个函数调用启动整个过程：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, this function, unlike almost every other function we've defined, is a perfectly
    normal function without any `yield` statements or `for` loops. It doesn't do any
    iteration at all.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个函数与我们定义的几乎所有其他函数不同，它是一个完全正常的函数，没有`yield`语句或`for`循环。它根本不进行任何迭代。
- en: 'It does, however, construct three generators. Can you see all three?:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它构造了三个生成器。你能看到所有三个吗？：
- en: '`load_colors` returns a generator'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load_colors`返回一个生成器'
- en: '`generate_colors` returns a generator'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate_colors`返回一个生成器'
- en: '`name_guess` returns a generator'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name_guess`返回一个生成器'
- en: The `name_guess` generator consumes the first two generators. It, in turn, is
    then consumed by the `write_results` function.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`name_guess`生成器消耗了前两个生成器。然后，它又被`write_results`函数消耗。'
- en: 'I wrote a second Tkinter app to check the accuracy of the algorithm. It is
    similar to the first app, except it renders each color and the label associated
    with that color. Then you have to manually click Yes or No if the label matches
    the color. For my example data, I got around 95% accuracy. This could be improved
    by implementing the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我写了第二个Tkinter应用程序来检查算法的准确性。它与第一个应用程序类似，只是它会渲染每种颜色及与该颜色相关联的标签。然后你必须手动点击是或否，以确定标签是否与颜色匹配。对于我的示例数据，我得到了大约95%的准确性。通过实施以下内容，这个准确性可以得到提高：
- en: Adding more color names
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加更多颜色名称
- en: Adding more training data by manually classifying more colors
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过手动分类更多颜色来添加更多的训练数据
- en: Tweaking the value of `num_neighbors`
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整`num_neighbors`的值
- en: Using a more advanced machine learning algorithm
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用更高级的机器学习算法
- en: 'Here''s the code for the output checking app, though I recommend downloading
    the example code instead. This would be tedious to type in:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出检查应用的代码，不过我建议下载示例代码。这样打字会很麻烦：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You might be wondering, *what does any of this have to do with object-oriented
    programming? There isn't even one class in this code!*. In some ways, you'd be
    right; generators are not commonly considered object-oriented. However, the functions
    that create them return objects; in fact, you could think of those functions as
    constructors. The constructed object has an appropriate `__next__()` method. Basically,
    the generator syntax is a syntax shortcut for a particular kind of object that
    would be quite verbose to create without it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，*这与面向对象编程有什么关系？这段代码中甚至没有一个类！* 从某些方面来说，你是对的；生成器通常不被认为是面向对象的。然而，创建它们的函数返回对象；实际上，你可以把这些函数看作构造函数。构造的对象有一个适当的`__next__()`方法。基本上，生成器语法是一种特定类型的对象的语法快捷方式，如果没有它，创建这种对象会非常冗长。
- en: Exercises
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: If you don't use comprehensions in your daily coding very often, the first thing
    you should do is search through some existing code and find some `for` loops.
    See whether any of them can be trivially converted to a generator expression or
    a list, set, or dictionary comprehension.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在日常编码中很少使用推导，那么你应该做的第一件事是搜索一些现有的代码，找到一些`for`循环。看看它们中是否有任何可以轻松转换为生成器表达式或列表、集合或字典推导的。
- en: Test the claim that list comprehensions are faster than `for` loops. This can
    be done with the built-in `timeit` module. Use the help documentation for the
    `timeit.timeit` function to find out how to use it. Basically, write two functions
    that do the same thing, one using a list comprehension, and one using a `for`
    loop to iterate over several thousand items. Pass each function into `timeit.timeit`,
    and compare the results. If you're feeling adventurous, compare generators and
    generator expressions as well. Testing code using `timeit` can become addictive,
    so bear in mind that code does not need to be hyperfast unless it's being executed
    an immense number of times, such as on a huge input list or file.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 测试列表推导是否比`for`循环更快。这可以通过内置的`timeit`模块来完成。使用`timeit.timeit`函数的帮助文档找出如何使用它。基本上，编写两个做同样事情的函数，一个使用列表推导，一个使用`for`循环来迭代数千个项目。将每个函数传入`timeit.timeit`，并比较结果。如果你感到有冒险精神，也可以比较生成器和生成器表达式。使用`timeit`测试代码可能会让人上瘾，所以请记住，除非代码被执行了大量次数，比如在一个巨大的输入列表或文件上，否则代码不需要非常快。
- en: Play around with generator functions. Start with basic iterators that require
    multiple values (mathematical sequences are canonical examples; the Fibonacci
    sequence is overused if you can't think of anything better). Try some more advanced
    generators that do things such as take multiple input lists and somehow yield
    values that merge them. Generators can also be used on files; can you write a
    simple generator that shows lines that are identical in two files?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 玩转生成器函数。从需要多个值的基本迭代器开始（数学序列是典型的例子；如果你想不出更好的例子，斐波那契数列已经被过度使用了）。尝试一些更高级的生成器，比如接受多个输入列表并以某种方式产生合并值的生成器。生成器也可以用在文件上；你能否编写一个简单的生成器，显示两个文件中相同的行？
- en: Coroutines abuse the iterator protocol but don't actually fulfill the iterator
    pattern. Can you build a non-coroutine version of the code that gets a serial
    number from a log file? Take an object-oriented approach so that you can store
    an additional state on a class. You'll learn a lot about coroutines if you can
    create an object that is a drop-in replacement for the existing coroutine.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 协程滥用迭代器协议，但实际上并不符合迭代器模式。你能否构建一个非协程版本的代码，从日志文件中获取序列号？采用面向对象的方法，以便在类上存储额外的状态。如果你能创建一个对象，它可以完全替代现有的协程，你将学到很多关于协程的知识。
- en: The case study for this chapter has a lot of odd tuples of tuples being passed
    around that are hard to keep track of. See whether you can replace those return
    values with more object-oriented solutions. Also, experiment with moving some
    of the functions that share data (for example, `model_colors` and `target_colors`)
    into a class. That should reduce the number of arguments that have to be passed
    into most of the generators since they can look them up on `self`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的案例研究中有很多奇怪的元组传递，很难跟踪。看看是否可以用更面向对象的解决方案替换这些返回值。另外，尝试将一些共享数据的函数（例如`model_colors`和`target_colors`）移入一个类中进行实验。这样可以减少大多数生成器需要传入的参数数量，因为它们可以在`self`上查找。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned that design patterns are useful abstractions that
    provide best-practice solutions for common programming problems. We covered our
    first design pattern, the iterator, as well as numerous ways that Python uses
    and abuses this pattern for its own nefarious purposes. The original iterator
    pattern is extremely object-oriented, but it is also rather ugly and verbose to
    code around. However, Python's built-in syntax abstracts the ugliness away, leaving
    us with a clean interface to these object-oriented constructs.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到设计模式是有用的抽象，为常见的编程问题提供最佳实践解决方案。我们介绍了我们的第一个设计模式，迭代器，以及Python使用和滥用这种模式的多种方式。原始的迭代器模式非常面向对象，但在代码上也相当丑陋和冗长。然而，Python的内置语法将丑陋抽象化，为我们留下了这些面向对象构造的清晰接口。
- en: Comprehensions and generator expressions can combine container construction
    with iteration in a single line. Generator objects can be constructed using the
    `yield` syntax. Coroutines look like generators on the outside but serve a much
    different purpose.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 理解推导和生成器表达式可以将容器构造与迭代结合在一行中。生成器对象可以使用`yield`语法构造。协程在外部看起来像生成器，但用途完全不同。
- en: We'll cover several more design patterns in the next two chapters.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的两章中介绍几种设计模式。
