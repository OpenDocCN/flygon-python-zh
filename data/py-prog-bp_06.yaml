- en: Extending TempMessenger with a User Authentication Microservice
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用用户认证微服务扩展TempMessenger
- en: In the last chapter, we created a web-based messenger, TempMessenger, which
    consists of two microservices—one that is responsible for storing and retrieving
    messages and another that is responsible for serving web requests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个基于Web的信使TempMessenger，它由两个微服务组成——一个负责存储和检索消息，另一个负责提供Web请求。
- en: In this chapter, we will look to extend our existing TempMessenger platform
    with a User Authentication microservice. This will consist of a Nameko service
    with a PostgreSQL database dependency that has the ability to create new users
    and authenticate existing users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试通过用户认证微服务扩展我们现有的TempMessenger平台。这将包括一个具有PostgreSQL数据库依赖项的Nameko服务，该服务具有创建新用户和验证现有用户的能力。
- en: We will also replace our Nameko Web Server microservice with a more suitable
    Flask app that will allow us to keep track of web sessions for our users.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将用一个更合适的Flask应用替换我们的Nameko Web服务器微服务，这将允许我们跟踪用户的Web会话。
- en: It is necessary to have read the last chapter in order to follow this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要阅读上一章才能跟上本章的内容。
- en: 'We will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Creating a Postgres dependency
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Postgres依赖项
- en: Creating a User Service
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户服务
- en: Securely storing passwords in a Database
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据库中安全存储密码
- en: Authenticating users
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证用户
- en: Creating a Flask app
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Flask应用
- en: Web sessions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web会话
- en: TempMessenger goals
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TempMessenger目标
- en: 'Let''s add some new goals for our new and improved TempMessenger:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的新的和改进的TempMessenger增加一些新目标：
- en: Users can now sign-up for the application
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户现在可以注册该应用
- en: To send messages, users must be logged in
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要发送消息，用户必须登录
- en: Users not logged in can still read all messages
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未登录的用户仍然可以阅读所有消息
- en: 'If at any point you would like to refer to all of the code in this chapter
    in its entirety, feel free to view it with tests at: [http://url.marcuspen.com/github-ppb](http://url.marcuspen.com/github-ppb).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在任何时候想要查看本章中的所有代码，请随时在以下网址查看带有测试的完整代码：[http://url.marcuspen.com/github-ppb](http://url.marcuspen.com/github-ppb)。
- en: Requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: 'In order to function in this chapter, your local machine will need the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本章中运行，您的本地计算机需要以下内容：
- en: An internet connection
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网连接
- en: 'Docker: If you haven''t installed Docker already, please see the official documentation:
    [http://url.marcuspen.com/docker-install](http://url.marcuspen.com/docker-install)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker：如果您尚未安装Docker，请参阅官方文档：[http://url.marcuspen.com/docker-install](http://url.marcuspen.com/docker-install)
- en: A virtualenv running Python 3.6 or later; you can reuse your virtualenv from
    the last chapter.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Python 3.6或更高版本的virtualenv；您可以重用上一章的virtualenv。
- en: 'pgAdmin: see the official documentation for installation instructions: [http://url.marcuspen.com/pgadmin](http://url.marcuspen.com/pgadmin)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pgAdmin：请参阅官方文档以获取安装说明：[http://url.marcuspen.com/pgadmin](http://url.marcuspen.com/pgadmin)
- en: 'A RabbitMQ container running on the default ports: this should be present from
    the last chapter, [Chapter 5](332eca24-e97d-470d-a00f-882dbf2092aa.xhtml), *Building
    a Web Messenger with Microservices.*'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行在默认端口上的RabbitMQ容器：这应该是上一章[第5章](332eca24-e97d-470d-a00f-882dbf2092aa.xhtml)中的内容，*使用微服务构建Web
    Messenger*。
- en: 'A Redis container running on the default ports: this should be present from
    the last chapter, [Chapter 5](332eca24-e97d-470d-a00f-882dbf2092aa.xhtml), *Building
    a Web Messenger with Microservices.*'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行在默认端口上的Redis容器：这应该是上一章[第5章](332eca24-e97d-470d-a00f-882dbf2092aa.xhtml)中的内容，*使用微服务构建Web
    Messenger*。
- en: All other requirements will be installed as we progress through the chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本章的学习过程中，所有其他要求都将被安装。
- en: All instructions in this chapter are tailored towards macOS or Debian/Ubuntu
    systems; however, I have made an effort to only use multi-platform dependencies.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有说明都针对macOS或Debian/Ubuntu系统；但是，我已经努力只使用多平台依赖项。
- en: 'Throughout this chapter, there will be blocks of code. Different types of code
    will have their own prefixes, which are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将会有一些代码块。不同类型的代码将有它们自己的前缀，如下所示：
- en: '`$`: to be executed in your terminal, always within your virtualenv'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`：在您的终端中执行，始终在您的virtualenv中'
- en: '`>>>`: to be executed in your Nameko/Python shell'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>>`：在您的Nameko/Python shell中执行'
- en: 'No prefix: block of Python code to be used in your editor'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 无前缀：要在您的编辑器中使用的Python代码块
- en: Creating a Postgres dependency
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Postgres依赖项
- en: Previously, all the data we wanted to store was temporary. Messages had a fixed
    lifetime and would expire automatically; if our application had a catastrophic
    failure then the worst-case scenario would be that our messages would be lost,
    which for TempMessenger is hardly an issue at all!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们想要存储的所有数据都是临时的。消息有固定的生命周期，并且会自动过期；如果我们的应用程序发生灾难性故障，那么最坏的情况就是我们的消息会丢失，对于TempMessenger来说几乎没有问题！
- en: However, user accounts are a totally different kettle of fish altogether. They
    must be stored for as long as the user wishes and they must be stored securely.
    We also need a proper schema for these accounts to keep the data consistent. We
    also need to be able to query and update the data with ease.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用户帐户是完全不同的问题。他们必须被存储，只要用户愿意，他们必须被安全地存储。我们还需要一个适当的模式来保持这些帐户的数据一致。我们还需要能够轻松地查询和更新数据。
- en: For these reasons, Redis probably isn't the best solution. One of the many benefits
    of building microservices is that we aren't tied to a specific technology; just
    because our Message Service uses Redis for storage doesn't mean that our User
    Service has to follow suit...
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Redis可能不是最佳解决方案。构建微服务的许多好处之一是，我们不会被特定的技术所束缚；仅因为我们的消息服务使用Redis进行存储并不意味着我们的用户服务也必须跟随...
- en: Starting a Postgres Docker container
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动一个Postgres Docker容器
- en: 'To begin, you will start a Postgres Docker container in your terminal:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在终端中启动一个Postgres Docker容器：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will start a Postgres container with some basic setup:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个带有一些基本设置的Postgres容器：
- en: '`--name` sets the name of the container'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name`设置容器的名称'
- en: '`-e` allows us to set environment variables:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -e允许我们设置环境变量：
- en: '`POSTGRES_PASSWORD`: The password used to access the database'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POSTGRES_PASSWORD`：用于访问数据库的密码'
- en: '`POSTGRES_DB`: The name of the database'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POSTGRES_DB`：数据库的名称'
- en: '`-p` allows us to expose port `5432` on the container to port `5432` on our
    local machine'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -p允许我们将容器上的端口`5432`暴露到本地机器上的端口`5432`
- en: '`-d` allows us to start the container in daemon mode (runs in the background)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -d允许我们以守护程序模式启动容器（在后台运行）
- en: If you are creating a database for a production environment then it is important
    to set a more secure password and keep it safe!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在为生产环境创建数据库，则设置更安全的密码并将其保密是非常重要的！
- en: 'You can check if the container is up and running by executing the following
    and ensuring that your `postgres` container is present:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行以下操作并确保您的`postgres`容器存在来检查容器是否正在运行：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating the user model
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户模型
- en: In order to store data about our users in Postgres, we first need to create
    a model that will define the fields and type of data we want to store.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Postgres中存储关于我们用户的数据，我们首先需要创建一个模型，该模型将定义我们要存储的字段和数据类型。
- en: 'We will first need to install two new Python packages: SQLAlchemy and Psycopg.
    SQLAlchemy is a toolkit and object-relational mapper that will serve as our gateway
    into the world of SQL. Psycopg is a PostgreSQL database adapter for Python.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要安装两个新的Python包：SQLAlchemy和Psycopg。SQLAlchemy是一个工具包和对象关系映射器，将作为我们进入SQL世界的入口。Psycopg是Python的PostgreSQL数据库适配器。
- en: 'Start by adding `sqlalchemy` (*version 1.2.1 at the time of writing*) and `psycopg2`
    (*version 2.7.4 at the time of writing*) to your `base.in` file. From the root
    of your project folder, within your virtualenv, run:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将`sqlalchemy`（*在撰写本文时为1.2.1版本*）和`psycopg2`（*在撰写本文时为2.7.4版本*）添加到您的`base.in`文件中。从项目文件夹的根目录，在您的虚拟环境中运行：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will add `sqlalchemy` and `psycopg2` to our requirements and will ensure
    that our virtualenv packages match them exactly. Alternatively, you can `pip install`
    them if you are choosing not to use pip-tools.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向我们的要求中添加`sqlalchemy`和`psycopg2`，并确保我们的虚拟环境包与它们完全匹配。或者，如果您选择不使用pip-tools，也可以使用`pip
    install`它们。
- en: 'In our dependencies folder, create a new file, `users.py`. Usually, you would
    have a different file for your database models, but for the purpose of simplicity
    we will embed it within our dependency. To start, let''s define our imports and
    the base class to be used by our model:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的依赖文件夹中，创建一个新文件`users.py`。通常，您会为您的数据库模型有一个不同的文件，但为了简单起见，我们将它嵌入到我们的依赖中。首先，让我们定义我们的导入和我们的模型将使用的基类：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We start by importing `Column`, which will be used to declare our database
    columns, and some basic field types: `Integer` and `Unicode`. As for `declarative_base`,
    we use that to create our `Base` class, from which our User model will inherit.
    This will create the mapping between our model and a database table.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`Column`，它将用于声明我们的数据库列，以及一些基本字段类型：`Integer`和`Unicode`。至于`declarative_base`，我们使用它来创建我们的`Base`类，从而我们的用户模型将继承自它。这将创建我们的模型与数据库表之间的映射。
- en: 'Now let''s define a basic model for our `users`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为我们的`users`定义一个基本模型：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, our `User` class inherits from the Base class we defined earlier.
    `__tablename__` sets the name of the table. Let''s briefly go over some of the
    database columns we have defined:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们的`User`类继承自我们之前定义的`Base`类。`__tablename__`设置表的名称。让我们简要地回顾一下我们定义的一些数据库列：
- en: '`id`: A unique identifier and primary key for each user in our database. It''s
    common practice for database models to have their IDs as integers for simplicity.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：我们数据库中每个用户的唯一标识符和主键。对于简单起见，数据库模型通常将其ID设置为整数。'
- en: '`first_name` and `last_name`: a maximum length of 128 characters should be
    enough for any name. We''ve also used `Unicode` as our type to cater for names
    that include symbols such as Chinese.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first_name`和`last_name`：128个字符的最大长度对于任何名称应该足够了。我们还使用`Unicode`作为我们的类型，以适应包含诸如中文之类的符号的名称。'
- en: '`email`: Again, a large field length and `Unicode` to cater for symbols. We''ve
    also made this field unique, which will prevent multiple users with the same email
    address from being created.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`：同样，一个大的字段长度和`Unicode`来适应符号。我们还使这个字段是唯一的，这将防止创建具有相同电子邮件地址的多个用户。'
- en: '`password`: We won''t be storing passwords in plain text here; we''ll come
    back to this later!'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`password`：我们不会在这里以明文存储密码；我们稍后会回到这个问题！'
- en: To learn more about SQLAlchemy, see [http://url.marcuspen.com/sqlalchemy](http://url.marcuspen.com/sqlalchemy).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于SQLAlchemy的信息，请参阅[http://url.marcuspen.com/sqlalchemy](http://url.marcuspen.com/sqlalchemy)。
- en: Creating the user dependency
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户依赖项
- en: Now that we have a basic user model defined, we can create a Nameko dependency
    for it. Luckily for us, some of the work has already been done for us in the form
    of `nameko-sqlalchemy`, an open-source Nameko dependency that will handle all
    of the semantics around database sessions and also gives us some very useful Pyest
    fixtures for testing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个基本的用户模型，我们可以为其创建一个Nameko依赖项。幸运的是，`nameko-sqlalchemy`已经为我们做了一些工作，这是一个开源的Nameko依赖项，它将处理围绕数据库会话的所有语义，并为我们提供一些非常有用的Pyest固定装置进行测试。
- en: Install `nameko-sqlalchemy` (*version 1.0.0 at the time of writing*) by adding
    it to the `requirements/base.in` file, and follow the same procedure as earlier
    to install `sqlalchemy`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其添加到`requirements/base.in`文件中安装`nameko-sqlalchemy`（*在撰写本文时为1.0.0版本*），并按照之前的相同步骤安装`sqlalchemy`。
- en: 'We will now create a wrapper class that will be used to encapsulate all of
    the logic around managing users. In `users.py`, add the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个包装器类，用于封装管理用户的所有逻辑。在`users.py`中，添加以下代码：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will be the basis of our wrapper and will require a database session object
    in the form of `session`. Later, we will add more methods to this class, such
    as `create` and `authenticate`. In order to create our user dependency, first
    let''s add the following to our imports:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们包装器的基础，并且将需要一个数据库会话对象，形式为`session`。稍后，我们将向这个类添加更多的方法，比如`create`和`authenticate`。为了创建我们的用户依赖项，首先让我们将以下内容添加到我们的导入中：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now let''s create a new class, User Store, which will serve as our dependency:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个新的类，User Store，它将作为我们的依赖：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To explain this code, first, let's talk about `DatabaseSession`. This pre-made
    dependency provider for Nameko, given to us by `nameko-sqlalchemy`, already includes
    methods such as `setup` and `get_dependency`, as covered in the previous chapter.
    Therefore, our `UserStore` class is simply inheriting from it to use this existing
    functionality.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 解释这段代码，首先让我们谈谈`DatabaseSession`。这是一个为Nameko预先制作的依赖提供者，由`nameko-sqlalchemy`提供给我们，已经包括了`setup`和`get_dependency`等方法，就像上一章介绍的那样。因此，我们的`UserStore`类只是继承它来使用这个现有的功能。
- en: The `DatabaseSession` class' `__init__` method takes the declarative base for
    our models as its only argument. In our `UserStore` class, we override this with
    our own `__init__` method, which amends it to use our `Base` and carry out the
    same functionality as it would have originally done by using Python's in-built
    `super` function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatabaseSession`类的`__init__`方法以我们的模型的声明性基础作为它唯一的参数。在我们的`UserStore`类中，我们用我们自己的`__init__`方法覆盖了这个方法，它修改为使用我们的`Base`并执行与原始功能相同的功能，使用Python内置的`super`函数。'
- en: 'To learn more about Python''s `super` method, see: [http://url.marcuspen.com/python-super](http://url.marcuspen.com/python-super).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Python的`super`方法，请参见：[http://url.marcuspen.com/python-super](http://url.marcuspen.com/python-super)。
- en: The original `get_dependency` method in the `DatabaseSession` class simply returns
    a database session; however, we want ours to return an instance of our `UserWrapper`
    so that we can easily call the `create` and `authenticate` methods that we will
    make later. To override this in an elegant way so that we still keep all of the
    logic that generates the database session, we again use the `super` function to
    generate `database_session` and return an instance of our `UserWrapper`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatabaseSession`类中的原始`get_dependency`方法只是返回一个数据库会话；然而，我们希望我们的方法返回一个`UserWrapper`的实例，这样我们就可以轻松调用后面将要创建的`create`和`authenticate`方法。为了以一种优雅的方式覆盖它，以便我们仍然保留生成数据库会话的所有逻辑，我们再次使用`super`函数来生成`database_session`并返回我们的`UserWrapper`的实例。'
- en: Creating users
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户
- en: 'Now that we have our Nameko dependency in place, we can start to add functionality
    to our `UserWrapper`. We will start by creating users. Add the following to the
    `UserWrapper` class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了Nameko的依赖，我们可以开始为我们的`UserWrapper`添加功能。我们将从创建用户开始。将以下内容添加到`UserWrapper`类中：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This `create` method will create a new `User` object, add it to our database
    session, commit that change to the database, and return the user. Nothing fancy
    here! But let's talk about the process of `self.session.add` and `self.session.commit`.
    When we first `add` the user to the session, this adds the user to our local database
    session in memory, rather than adding them to our actual database. The new user
    has been staged but no changes have actually taken place in our database. This
    is rather useful. Say we wanted to do multiple updates to the database, making
    a number of calls to the database can be expensive, so we first make all the changes
    we want in memory, then `commit` them all with a single database transaction.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`create`方法将创建一个新的`User`对象，将其添加到我们的数据库会话中，提交到数据库的更改，并返回用户。这里没有什么花哨的！但让我们谈谈`self.session.add`和`self.session.commit`的过程。当我们首次将用户添加到会话中时，这将把用户添加到我们本地数据库会话中的内存中，而不是将它们添加到我们的实际数据库中。新用户已经被暂存，但实际上并没有在我们的数据库中进行任何更改。这是非常有用的。假设我们想对数据库进行多次更新，多次调用数据库可能会很昂贵，所以我们首先在内存中进行所有想要的更改，然后使用单个数据库事务`commit`它们。
- en: Another thing you'll notice in the preceding code is that we use `**kwargs`
    instead of defining the actual arguments to create a new `User`. If we were to
    change the user model, this minimizes the changes needed since the keyword arguments
    directly map to the fields.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中你会注意到的另一件事是，我们使用了`**kwargs`而不是定义实际的参数来创建一个新的`User`。如果我们要更改用户模型，这样可以最小化所需的更改，因为关键字参数直接映射到字段。
- en: Creating the User Service
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户服务
- en: In the last chapter, we simply had two services in the same module, which is
    fine for any small-scale project. However, now that our platform is starting to
    grow and new roles are being defined between services, let's start to split these
    out by keeping them in different modules. Alongside your `service.py`, create
    a new file, `user_service.py`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们只是在同一个模块中有两个服务，这对于任何小规模项目来说都是可以的。然而，现在我们的平台开始增长，服务之间定义了新的角色，让我们开始通过将它们放在不同的模块中来拆分它们。在你的`service.py`旁边，创建一个新文件，`user_service.py`。
- en: 'Add the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you read the last chapter, then there is nothing new here. We've created
    a new `UserService`, given it the `UserStore` dependency and made an RPC, which
    is simply a pass-through to the `create` method on the dependency. However, here
    we have opted to define the arguments to create a user rather than use `**kwargs`
    like we did in the dependency method. This is because we want the RPC to define
    the contract it has with other services that will interface with it. If another
    service makes an invalid call, then we want the RPC to reject it as soon as possible
    without wasting time making a call to the dependency or, worse, making a database
    query.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你读过上一章，那么这里没有什么新的。我们创建了一个新的`UserService`，给它了`UserStore`依赖，并进行了一个RPC，这只是一个对依赖的`create`方法的透传。然而，在这里我们选择定义创建用户的参数，而不像我们在依赖方法中使用`**kwargs`。这是因为我们希望RPC定义它与其他服务的契约。如果另一个服务发出无效调用，我们希望RPC尽快拒绝它，而不是浪费时间去调用依赖，或者更糟糕的是进行数据库查询。
- en: 'We are close to the point where we can test this out, but first we need to
    update our `config.yaml` with our database settings. Provided you used the command
    supplied earlier to create a Docker Postgres container, append the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经接近可以测试这个功能的点了，但首先我们需要更新我们的`config.yaml`文件，加入我们的数据库设置。如果你使用了之前提供的命令来创建一个Docker
    Postgres容器，追加以下内容：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`DB_URIS` is used by `nameko-sqlalchemy` to map a Nameko service and a declarative
    base pair to a Postgres database.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`DB_URIS`被`nameko-sqlalchemy`用于将Nameko服务和声明性基础对映射到Postgres数据库。'
- en: 'We will also have to create the tables in our Postgres database. Usually, you
    would do this with a database migration tool, such as Alembic. However, for the
    purposes of this book, we will use a small one-off Python script to do this for
    us. In the root of your project directory, create a new file, `setup_db.py`, with
    the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在我们的Postgres数据库中创建表。通常情况下，您可以使用数据库迁移工具（如Alembic）来完成这项工作。但是，为了本书的目的，我们将使用一个小的一次性Python脚本来为我们完成这项工作。在项目目录的根目录中，创建一个名为`setup_db.py`的新文件，其中包含以下代码：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code takes our user model in our dependency module and creates the required
    table in our database for us. `create_engine` is the starting point as it establishes
    a connection with the database. We then use our user model `metadata` (which in
    our case consists of the table name and columns) and call `create_all`, which
    issues the `CREATE` SQL statements to the database using the `engine`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用我们依赖模块中的用户模型，并为我们在数据库中创建所需的表。`create_engine`是起点，因为它建立了与数据库的连接。然后我们使用我们的用户模型`metadata`（在我们的情况下包括表名和列）并调用`create_all`，它使用`engine`向数据库发出`CREATE`
    SQL语句。
- en: If you are going to want to make changes to the User model while retaining your
    existing user data, then learning how to use a database migration tool, such as
    Alembic, is a must and I strongly recommend it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要对用户模型进行更改并保留现有用户数据，那么学习如何使用数据库迁移工具（如Alembic）是必不可少的，我强烈推荐这样做。
- en: To learn more about how to use Alembic, see [http://url.marcuspen.com/alembic](http://url.marcuspen.com/alembic).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关如何使用Alembic的更多信息，请参阅[http://url.marcuspen.com/alembic](http://url.marcuspen.com/alembic)。
- en: 'To run, in your terminal with your virtualenv simply execute:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行，请在您的虚拟环境中的终端中执行：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now let's take a look at our new table using a Database Admin tool. There are
    many Database Admin tools out there, my personal favorite being Postico for Mac,
    but for the purposes of this book, we will use pgAdmin, which works on all platforms.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用数据库管理工具来查看我们的新表。有许多数据库管理工具，我个人最喜欢的是Mac上的Postico，但是为了本书的目的，我们将使用适用于所有平台的pgAdmin。
- en: 'Download and install pgAdmin from [http://url.marcuspen.com/pgadmin](http://url.marcuspen.com/pgadmin).
    Once installed, open and select Add new server, which will bring up the following
    window:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从[http://url.marcuspen.com/pgadmin](http://url.marcuspen.com/pgadmin)下载并安装pgAdmin。安装完成后，打开并选择“添加新服务器”，将会弹出以下窗口：
- en: '![](assets/dd0efeea-239c-4f78-8e41-92e76e614c9a.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dd0efeea-239c-4f78-8e41-92e76e614c9a.png)'
- en: Simply give it a name of your choice in the General tab, then in the Connection
    tab, you can fill out the details of our database with the configuration we set
    when we created our Postgres Docker screenshot earlier. However, if you did not
    make any changes to this, you can simply copy the details in the preceding image.
    Remember that the password was set to `secret`. Once you've filled this out, hit
    Save and it should connect to our database.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在“常规”选项卡中简单地给它一个您选择的名称，然后在“连接”选项卡中，您可以填写我们的数据库详细信息，这些详细信息是我们在之前创建Postgres Docker截图时设置的。但是，如果您没有对此进行任何更改，您可以简单地复制前面图像中的详细信息。请记住，密码设置为`secret`。填写完毕后，点击“保存”，它应该连接到我们的数据库。
- en: 'Once connected, we can start to look at the details of our database. To see
    our table, you''ll need to expand out and action the menus like so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 连接后，我们可以开始查看我们数据库的详细信息。要查看我们的表，您需要展开并操作菜单，就像这样：
- en: '![](assets/5f1adc41-40c7-4259-924f-9d9de30657a8.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5f1adc41-40c7-4259-924f-9d9de30657a8.png)'
- en: 'You should now be able to see our table, which represents our user model:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该能够看到我们的表，它代表了我们的用户模型：
- en: '![](assets/01d0e8bb-817f-4859-b394-84dd16821d1b.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/01d0e8bb-817f-4859-b394-84dd16821d1b.png)'
- en: 'We can now try out creating a user with the Nameko shell. Start our new User
    Service in the terminal by executing the following, within a virtualenv, in the
    root of our project folder:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试使用Nameko shell创建一个用户。通过在项目文件夹的根目录中，在虚拟环境中执行以下命令，在终端中启动我们的新用户服务：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In another terminal window, within your virtualenv, execute:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，在您的虚拟环境中执行：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once in your Nameko shell, execute the following to create a new user:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在Nameko shell中，执行以下命令以创建新用户：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now let''s check pgAdmin to see if the user was successfully created. To refresh
    the data, simply follow the earlier steps to show the user table or click the
    Refresh button:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查pgAdmin，看看用户是否成功创建。要刷新数据，只需按照之前的步骤显示用户表或单击“刷新”按钮即可：
- en: '![](assets/f26eb87a-f620-4449-bb3d-aee5f70aaa38.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f26eb87a-f620-4449-bb3d-aee5f70aaa38.png)'
- en: It worked! We now have a functioning User Service that can create new users.
    However, there is one major issue here... We have just committed one of the worst
    offenses a software developer can commit—storing passwords in plain text!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！我们现在有一个可以创建新用户的功能性用户服务。但是，这里有一个主要问题...我们刚刚犯了软件开发人员可以犯的最严重的错误之一——以明文形式存储密码！
- en: Securely storing passwords in the database
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在数据库中安全地存储密码
- en: The year is 2018 and by now we've probably all heard dozens of stories about
    companies leaking our sensitive data, including passwords, to hackers. In a lot
    of these cases, the passwords that were leaked were stored with extremely poor
    cryptography, meaning that they could be cracked with ease. In some cases, the
    passwords were even stored in plain text!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是2018年，到目前为止，我们可能已经听过数十个关于公司泄露我们的敏感数据，包括密码，给黑客的故事。在许多情况下，泄露的密码存储的加密非常差，这意味着它们可以轻松破解。在某些情况下，密码甚至以明文形式存储！
- en: Either way, this negligence has led to the leak of millions of users' email
    and password combinations. This would not be such an issue if we used different
    passwords for every online account we made... but unfortunately, we are lazy and
    password reuse is quite common practice. Therefore, the responsibility for mitigating
    some of the damage done by hackers infiltrating our servers falls to us, the developers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这种疏忽导致了数百万用户的电子邮件和密码组合泄漏。如果我们为每个在线账户使用不同的密码，这可能不是一个问题...但不幸的是，我们很懒，密码重用是相当普遍的做法。因此，减轻黑客入侵我们服务器造成的一些损害的责任落在我们开发人员身上。
- en: In October 2016, the popular video sharing platform Dailymotion suffered a data
    breach in which 85 million accounts were stolen. Of those 85 million accounts,
    18 million had passwords attached to them, but luckily they were hashed using
    Bcrypt. This meant that it would take hackers decades, maybe even centuries, of
    brute-force computing to crack them with today's hardware (source: [http://url.marcuspen.com/dailymotion-hack](http://url.marcuspen.com/dailymotion-hack)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年10月，流行的视频分享平台Dailymotion遭遇了一次数据泄露，其中有8500万个帐户被盗。在这8500万个帐户中，有1800万个帐户附带了密码，但幸运的是它们是使用Bcrypt进行散列的。这意味着黑客需要几十年，甚至几个世纪的暴力计算才能用今天的硬件破解它们（来源：[http://url.marcuspen.com/dailymotion-hack](http://url.marcuspen.com/dailymotion-hack)）。
- en: So despite hackers successfully breaching Dailymotion's servers, some of the
    damage was mitigated by using a hashing algorithm, such as Bcrypt, to store the
    passwords. With this in mind, we will now look at how to implement `bcrypt` hashing
    for our user passwords, rather than storing them insecurely in plain text.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管黑客成功侵入了Dailymotion的服务器，但通过使用散列算法（如Bcrypt）存储密码，部分损害得到了缓解。考虑到这一点，我们现在将看看如何为我们的用户密码实现`bcrypt`散列，而不是以明文方式存储它们。
- en: Using Bcrypt
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bcrypt
- en: Start by adding `bcrypt` to your `base.in` file and installing it (*version
    3.1.4 at the time of writing*) using the same process as earlier.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将`bcrypt`添加到您的`base.in`文件中，并使用与之前相同的过程安装它（*在撰写本文时为3.1.4版本*）。
- en: 'If you have issues installing Bcrypt, please see their installation instructions,
    which include details on system package dependencies: [http://url.marcuspen.com/pypi-bcrypt](http://url.marcuspen.com/pypi-bcrypt).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在安装Bcrypt时遇到问题，请参阅它们的安装说明，其中包括有关系统软件包依赖项的详细信息：[http://url.marcuspen.com/pypi-bcrypt](http://url.marcuspen.com/pypi-bcrypt)。
- en: 'In order for `bcrypt` to create a hash of a password, it requires two things—your
    password and a `salt`. A `salt` is simply a string of random characters. Let''s
    look at how you can create a `salt` in Python:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了`bcrypt`创建密码的散列，它需要两样东西——您的密码和一个`salt`。`salt`只是一串随机字符。让我们看看如何在Python中创建`salt`：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is the simplest way to create a `salt` compatible with Bcrypt. The `$`
    symbols represent different parts of the `salt`, and I''d like to point out the
    second section: `$12`. This part represents how many rounds of work are required
    to hash the password, which by default, is `12`. We can configure this like so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建与Bcrypt兼容的`salt`的最简单方法。`$`符号代表`salt`的不同部分，我想指出第二部分：`$12`。这部分表示生成密码散列所需的工作轮次，默认为`12`。我们可以这样配置：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Notice how in this `salt`, it has changed to `$14`. By increasing this, we
    are also increasing the amount of time it would take to create a  hash of the
    password. This will also increase the amount of time it takes to check the password
    attempt against the hash later on. This is useful since we are trying to prevent
    hackers from brute-forcing password attempts if they do manage to get hold of
    our database. However, the default number of rounds,  `12`, is plenty enough already!
    Let''s now create a hash of a password:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个`salt`，它已经改变成`$14`。通过增加这个值，我们也增加了创建密码的散列所需的时间。这也会增加后来检查密码尝试与散列的时间。这是有用的，因为我们试图阻止黑客在设法获取我们的数据库后对密码尝试进行暴力破解。然而，默认的轮次`12`已经足够了！现在让我们创建一个密码的散列：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we have simply generated a new `salt` using the default amount of rounds
    and used `hashpw` to generate the hash. Notice how the `salt` is also in the first
    part of the hash for our password? This is quite convenient as it means we don't
    also have to store the `salt` separately, which we'll need when it comes to authenticating
    users later.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是使用默认数量的轮次生成了一个新的`salt`，并使用`hashpw`生成了散列。注意我们的密码的`salt`也在散列的第一部分中？这非常方便，因为这意味着我们不必单独存储`salt`，这在以后验证用户时会需要。
- en: Since we used the default number of rounds to generate the `salt`, why not try
    setting your own amount of rounds? Notice how the amount of time taken by `hashpw`
    increases the higher you set this. My machine took almost 2 minutes to create
    a hash when the amount of rounds was set to 20!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了默认数量的轮次来生成`salt`，为什么不尝试设置自己的轮次？请注意，设置的轮次越高，`hashpw`所需的时间就越长。当轮次设置为20时，我的机器花了将近2分钟来创建一个散列！
- en: 'Now let''s look at how we check passwords against the hash:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何检查密码与散列相匹配：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, `checkpw` takes the password attempt that we are checking and
    the hashed password as arguments. When we implement this in our dependency, the
    password attempt will be the part coming from the web request and the hashed password
    will be stored in the database. Since it was a successful attempt, `checkpw` returns
    `True`. Let''s attempt the same operation  with an invalid password:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`checkpw`接受我们正在检查的密码尝试和散列密码作为参数。当我们在我们的依赖项中实现这一点时，密码尝试将是来自Web请求的部分，散列密码将存储在数据库中。由于这是一个成功的尝试，`checkpw`返回`True`。让我们尝试使用一个无效的密码进行相同的操作：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: No surprises here! It returned `False`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪！它返回了`False`。
- en: 'If you''d like to learn more about storing passwords and the pitfalls of certain
    methods, I''d suggest you read this short article from Dustin Boswell: [http://url.marcuspen.com/dustwell-passwords](http://url.marcuspen.com/dustwell-passwords).
    It explains nicely how hackers can attempt to crack passwords using brute force
    and rainbow tables. It also goes into a Bcrypt in bit more detail.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于存储密码和某些方法的缺陷的信息，我建议您阅读Dustin Boswell的这篇简短文章：[http://url.marcuspen.com/dustwell-passwords](http://url.marcuspen.com/dustwell-passwords)。它很好地解释了黑客如何尝试使用暴力破解和彩虹表来破解密码。它还更详细地介绍了Bcrypt。
- en: Hashing our user passwords
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 散列我们的用户密码
- en: 'Now that we know how to store passwords more securely, let''s amend our `create`
    method to hash our passwords before storing them in the database. Firstly, at
    the top of our `users.py` dependency file, let''s add `bcrypt` to our imports
    and add a new constant:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何更安全地存储密码了，让我们修改我们的`create`方法，在将密码存储到数据库之前对其进行哈希处理。首先，在我们的`users.py`依赖文件的顶部，让我们将`bcrypt`添加到我们的导入中，并添加一个新的常量：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Our new constant, `HASH_WORK_FACTOR` will be used for the rounds argument that
    `gensalt` uses. I've set it to 15, which will cause it to take slightly longer
    to create password hashes and check passwords, but it will be more secure. Please
    feel free to set this as you wish; just bare in mind that the more you increase
    this, the longer it will take for our application to create and authenticate users
    later on.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新常量`HASH_WORK_FACTOR`将用于`gensalt`使用的轮次参数。我把它设置为15，这将导致创建密码哈希和检查密码需要花费更长的时间，但会更安全。请随意设置，但请记住，增加这个值会导致我们的应用在以后创建和验证用户时需要更长的时间。
- en: 'Now, outside any classes, we will define a new helper function for hashing
    passwords:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在任何类之外，我们将定义一个新的辅助函数来哈希密码：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This helper function simply takes our plain text password, generates a `salt`,
    and returns a hashed password. Now, you may have noticed that when using Bcrypt,
    we always have to ensure that the passwords we give it are bytestrings. As you''ll
    notice from the preceding code, we had to `.encode()` the password (which by default
    is UTF-8) before giving it to `hashpw`. Bcrypt also will return the hashed password
    in the bytestring format. The problem this will bring is that our field for passwords
    in our database is currently set to Unicode, making it incompatible with our passwords.
    We have two options here: either call `.decode()` on the password before we store
    it or amend our password field to something that will accept bytestrings, such
    as `LargeBinary`. Let''s go with the latter, as it is cleaner and saves us from
    having to convert our data every time we wish to access it.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个辅助函数简单地获取我们的明文密码，生成一个`salt`，并返回一个哈希密码。现在，您可能已经注意到，当使用Bcrypt时，我们总是必须确保我们给它的密码是字节串。正如您从前面的代码中注意到的那样，我们必须在将密码（默认为UTF-8）传递给`hashpw`之前对其进行`.encode()`处理。Bcrypt还将以字节串格式返回哈希密码。这将带来的问题是，我们数据库中密码的字段当前设置为Unicode，与我们的密码不兼容。我们有两个选择：要么在存储密码之前调用`.decode()`，要么修改我们的密码字段为可以接受字节串的类型，比如`LargeBinary`。让我们选择后者，因为它更清晰，可以避免我们每次访问数据时都需要转换数据。
- en: 'First, let''s amend the line where we import our field types to include `LargeBinary`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们修改导入字段类型的行，包括`LargeBinary`：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can update our `User` model to use our new field type:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更新我们的`User`模型来使用我们的新字段类型：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The only problem we have now is that our existing database is not compatible
    with our new schema. To solve this, we can either delete the database table or
    perform a migration. In real-world environments, deleting a whole table is not
    an option, ever! If you have already taken my advice earlier to study Alembic,
    then I''d encourage you to put your knowledge to the test and perform a database
    migration. But for the purposes of this book, I will take advantage of throwaway
    Docker containers and start from scratch. To do this, in the root of your project,
    and inside your virtualenv, execute:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在唯一的问题是我们现有的数据库与我们的新模式不兼容。为了解决这个问题，我们可以删除数据库表或执行迁移。在现实世界的环境中，删除整个表是绝对不可取的！如果您已经采纳了我之前的建议学习Alembic，那么我鼓励您将您的知识付诸实践，并执行数据库迁移。但出于本书的目的，我将利用一次性的Docker容器并从头开始。为此，在您的项目根目录和虚拟环境内执行：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will delete your existing Postgres container, create a new one and run
    the `setup_db.py` script we made earlier. If you check pgAdmin, you'll now see
    that the field type in the column headers for password has changed from `character
    varying (512)` to `bytea`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除您现有的Postgres容器，创建一个新的容器，并运行我们之前制作的`setup_db.py`脚本。如果您检查pgAdmin，您现在会看到密码列标题中的字段类型已从`character
    varying (512)`更改为`bytea`。
- en: 'At last, we are now ready to update our `create` method to use our new `hash_password`
    function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们现在准备更新我们的`create`方法来使用我们的新的`hash_password`函数：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, in the first three lines of the method we:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在方法的前三行中所看到的：
- en: Extract the `plain_text_password` from `kwargs`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`kwargs`中提取`plain_text_password`。
- en: Call `hash_password` to create our `hashed_password`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`hash_password`来创建我们的`hashed_password`。
- en: Perform an update on `kwargs` to replace the password with the hashed version.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`kwargs`执行更新，以用哈希版本替换密码。
- en: The rest of the code is unchanged from our previous version.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分与我们之前的版本相同。
- en: 'Let''s try this out. In your terminal within your virtualenv, start (or restart)
    the User Service:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。在您的虚拟环境中的终端中，启动（或重新启动）用户服务：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In another terminal window within your virtualenv, start your Nameko shell:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的虚拟环境中的另一个终端窗口中，启动您的Nameko shell：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Inside your Nameko shell, execute the following to add a new user again:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Nameko shell中，执行以下操作再次添加新用户：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You should notice (depending on how large you set `HASH_WORK_FACTOR`) that there
    is now a slight delay compared to last time when creating a new user.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意到（取决于您设置的`HASH_WORK_FACTOR`有多大），与上次创建新用户相比，现在会有一些延迟。
- en: 'You should now see the following in your pgAdmin:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该在pgAdmin中看到以下内容：
- en: '![](assets/eaddd97d-b99e-4dfd-b087-1933233f9805.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/eaddd97d-b99e-4dfd-b087-1933233f9805.png)'
- en: Handling duplicate users
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理重复用户
- en: Since we set our email field to be unique, our database already prevents duplicate
    users. However, if you were to try this for yourself, the output we receive back
    is not the best. Try it for yourself by adding the same user again in the Nameko
    shell.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将email字段设置为唯一，我们的数据库已经阻止了重复的用户。但是，如果您自己尝试，您会发现返回的输出并不理想。尝试在Nameko shell中再次添加相同的用户。
- en: Another problem with this is that, if there were any other errors when creating
    a new user, there is no nice way for our external services to react to these different
    types of errors without knowing the type of database we are using, which we want
    to avoid at all costs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，如果在创建新用户时出现任何其他错误，我们的外部服务没有很好的方式来对这些不同类型的错误做出反应，而不知道我们正在使用的数据库类型，这是我们要尽一切努力避免的。
- en: 'To solve this, let''s start by creating two new exception classes in our `users.py`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们首先在我们的`users.py`中创建两个新的异常类：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also need to update our imports to include `IntegrityError`, which is the
    type of error SQLAlchemy raises when there is a unique key violation:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新我们的导入，包括`IntegrityError`，这是SQLAlchemy在唯一键违规时引发的错误类型：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Again, we will amend our `create` method, this time to use our two new exceptions:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将修改我们的`create`方法，这次使用我们的两个新异常：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'What we have done here is to:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是：
- en: Wrap the `self.session.commit()` in a try except block.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`self.session.commit()`包装在try except块中。
- en: If an `IntegrityError` occurs, rollback our session, which removes the user
    from our database session - not completely necessary in this case, but good practice
    nevertheless.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发生`IntegrityError`，回滚我们的会话，这将从我们的数据库会话中删除用户-在这种情况下并不完全必要，但无论如何都是一个好的做法。
- en: Extract the error message.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取错误消息。
- en: Check to see if it contains the string `'already exists'`. If so, then we know
    that the user already exists and we raise the appropriate exception, `UserAlreadyExists`,
    and give it an error message containing the user's email.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查它是否包含字符串`'already exists'`。如果是，那么我们知道用户已经存在，我们引发适当的异常`UserAlreadyExists`，并给它一个包含用户电子邮件的错误消息。
- en: If not, then we have an unexpected error and raise the more generic error tailored
    to our service, `CreateUserError`, and give it the whole error message.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是，那么我们有一个意外的错误，并引发更通用的错误，适合我们的服务，`CreateUserError`，并给出整个错误消息。
- en: By doing this, our external services will now be able to differentiate between
    a user error and an unexpected error.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们的外部服务现在将能够区分用户错误和意外错误。
- en: To test this out, restart the User Service and attempt to add the same user
    again in the Nameko shell.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，重新启动用户服务，并尝试在Nameko shell中再次添加相同的用户。
- en: Authenticating users
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证用户
- en: 'We can now look at how to authenticate users. This is a very simple process:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看看如何验证用户。这是一个非常简单的过程：
- en: Retrieve the user we want to authenticate from the database.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库中检索我们要验证的用户。
- en: Perform a `bcrypt.checkpw` giving it the attempted password and the password
    hash of the user.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`bcrypt.checkpw`，给出尝试的密码和用户的密码哈希。
- en: Raise an exception if the result is `False`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果结果是`False`，则引发异常。
- en: Return the user if it's `True`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是`True`，则返回用户。
- en: Retrieving users from the database
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据库中检索用户
- en: Starting with the first point, we will need to add a new dependency method,
    `get`, which returns the user, given the email, if it exists.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一点开始，我们需要添加一个新的依赖方法`get`，如果存在，则返回用户的电子邮件。
- en: 'First, add a new exception class in `users.py`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`users.py`中添加一个新的异常类：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is what we will raise in the event of the user not being found. Now we
    will update our imports to include the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在用户找不到时会引发的。现在我们将更新我们的导入，包括以下内容：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`NoResultFound`, as the name implies, is raised by SQLAlchemy when a requested
    object is not found in the database. Now we can add a new method to our `UserWrapper`
    class:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`NoResultFound`，顾名思义，是SQLAlchemy在数据库中找不到请求的对象时引发的。现在我们可以为我们的`UserWrapper`类添加一个新方法：'
- en: '[PRE35]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s understand what we''ve done in the preceding code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下我们在前面的代码中做了什么：
- en: In order to query our database, we first must make a query object using our
    user model as an argument.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了查询我们的数据库，我们首先必须使用我们的用户模型作为参数来创建一个查询对象。
- en: Once we have this, we can use `filter_by` and specify some parameters; in this
    case, we just want to filter by email. `filter_by` always returns an iterable,
    since you could have multiple results, but since we have a unique constraint on
    the email field, it's safe to assume that we are only ever going to have one match
    if it exists. Therefore, we call `.one()`, which returns the single object or
    raises `NoResultFound` if the filter is empty.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了这个，我们可以使用`filter_by`并指定一些参数；在这种情况下，我们只想按电子邮件过滤。`filter_by`总是返回一个可迭代对象，因为可能有多个结果，但由于我们在电子邮件字段上有一个唯一的约束，所以可以安全地假设如果存在，我们只会有一个匹配。因此，我们调用`.one()`，它返回单个对象，如果过滤器为空，则引发`NoResultFound`。
- en: We handle `NoResultFound` and raise our own exception, `UserNotFound`, with
    an error message, which better suits our User Service.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们处理`NoResultFound`并引发我们自己的异常`UserNotFound`，并附上错误消息，这更适合我们的用户服务。
- en: Authenticating a user's password
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证用户的密码
- en: We will now implement an `authenticate` method that will use the `get` method
    we just created.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现一个`authenticate`方法，该方法将使用我们刚刚创建的`get`方法。
- en: 'First, let''s create a new exception class that will be raised if there is
    a password mismatch:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的异常类，如果密码不匹配，将引发该异常：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can now create another method for our `UserWrapper` to authenticate users:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以为我们的`UserWrapper`创建另一个方法来验证用户：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We start by using our recently created `get` method to retrieve the user we
    want to authenticate from our database.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先使用我们最近创建的`get`方法从数据库中检索我们要验证的用户。
- en: We then use `bcrypt.checkpw` to check that the attempted password matches the
    password stored on the user object retrieved from the database. We call `.encode()`
    on the password attempt because our external services aren't going to do this
    for us. Nor should they; this is something specific to Bcrypt and such logic should
    stay in the dependency.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`bcrypt.checkpw`来检查尝试的密码是否与从数据库中检索的用户对象上存储的密码匹配。我们在密码尝试上调用`.encode()`，因为我们的外部服务不会为我们执行此操作。它也不应该；这是Bcrypt特有的逻辑，这样的逻辑应该留在依赖项中。
- en: If the password is incorrect, we raise our `AuthenticationError` error with
    an appropriate message.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果密码不正确，我们会引发`AuthenticationError`错误，并附上适当的消息。
- en: 'All that''s left to do now is to create an RPC on our `UserService` class in
    `user_service.py`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是在`user_service.py`中的`UserService`类上创建一个RPC：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Nothing special here, just a simple pass-through to the `user_store` dependency
    method we just made.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的，只是一个简单的传递到我们刚刚创建的`user_store`依赖方法。
- en: 'Let''s test this out. Restart the `user_service` and execute the following
    in your Nameko shell:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下。重新启动`user_service`，并在您的Nameko shell中执行以下操作：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If successful, it should do nothing! Now let''s try it with an incorrect password:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，它应该什么都不做！现在让我们尝试使用错误的密码：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That's it! That concludes our work on our User Service. We will now look at
    integrating it with our existing services.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！这结束了我们对用户服务的工作。现在我们将看看如何将其与我们现有的服务集成。
- en: If you'd like to see how to write some tests for the User Service, you'll find
    them, plus all the code, in the Github repository mentioned at the start of this
    chapter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看一下如何为用户服务编写一些测试，您会在本章开头提到的Github存储库中找到它们以及所有代码。
- en: Splitting out the services
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分服务
- en: 'As it stands, we have our `MessageServer` and `WebServer` in the same `service.py`
    module. It''s now time to split these, especially since we will be removing the
    `WebServer` in favor of a Flask server. At the end of this chapter, the goal is
    to have a total of three microservices working together, each with its own specific
    roles:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们在同一个`service.py`模块中有我们的`MessageServer`和`WebServer`。现在是时候拆分它们了，特别是因为我们将删除`WebServer`，转而使用Flask服务器。在本章结束时，目标是有三个微服务共同工作，每个都有自己特定的角色：
- en: '![](assets/57a9715d-61eb-4d8d-b15c-2dd353b3f03e.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/57a9715d-61eb-4d8d-b15c-2dd353b3f03e.jpg)'
- en: The preceding diagram demonstrates how our services will integrate with each
    other. Take note of how the Message Service and User Service are totally unaware
    of each other. A change to the User Service should not require a change to the
    Message Service and vice versa. By splitting these services, we also gain the
    advantage of being able to deploy new code to a single service without affecting
    the others. A bonus from Nameko using RabbitMQ is that, if a service does go down
    for a short period of time, any work will simply be queued until the service comes
    back online. We will now begin to reap some of the benefits of a microservice
    architecture.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了我们的服务将如何相互集成。请注意消息服务和用户服务是完全不知道彼此的。对用户服务的更改不应该需要对消息服务进行更改，反之亦然。通过拆分这些服务，我们还获得了能够在不影响其他服务的情况下部署新代码的优势。Nameko使用RabbitMQ的一个额外好处是，如果一个服务短暂下线，任何工作将被排队，直到服务重新上线。我们现在将开始收获微服务架构的一些好处。
- en: 'To start this refactoring, let''s create a new file within our `temp_messenger`
    folder, `message_service.py`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这个重构，让我们在`temp_messenger`文件夹中创建一个新文件，名为`message_service.py`：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: All we have done here is take the `MessageService` and all related code from
    our old `service.py` and place it into our new `message_service.py` module.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是从旧的`service.py`中取出`MessageService`和所有相关代码，放入我们的新的`message_service.py`模块中。
- en: Creating a Flask server
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Flask服务器
- en: We will now create a new Flask web server, which will replace our Nameko Web
    Server. Flask is better suited to handling web requests than Nameko and comes
    with a lot more baked in while still being fairly lightweight. One of the features
    we will take advantage of is Sessions, which will allow our server to keep track
    of who's logged in. It also works with Jinja2 for templating, meaning that our
    existing template should already work.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个新的Flask Web服务器，它将取代我们的Nameko Web服务器。Flask更适合处理Web请求，而且内置功能更多，同时还相当轻量级。我们将利用其中的一个功能，即会话，它将允许我们的服务器跟踪谁已登录。它还与Jinja2一起使用模板，这意味着我们现有的模板应该已经可以工作。
- en: Start by adding `flask` to our `base.in` file, then `pip-compile` and install
    (*version 0.12.2 at the time of writing*) using the same process as earlier.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在我们的`base.in`文件中添加`flask`，然后使用与之前相同的过程`pip-compile`和安装（*在撰写本文时为0.12.2版本*）。
- en: 'Getting started with Flask is quite straightforward; we will start by creating
    our new home page endpoint. Within your `temp_messenger` directory, create a new
    file, `web_server.py` , with the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用Flask非常简单；我们将从创建新的主页端点开始。在您的`temp_messenger`目录中，创建一个名为`web_server.py`的新文件，内容如下：
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We import the following from `flask`:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`flask`中导入以下内容：
- en: '`Flask`: used to create our Flask app object'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flask`：用于创建我们的Flask应用对象'
- en: '`render_template`: renders a given template file'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render_template`：渲染给定的模板文件'
- en: Create our `app`, the only argument being the name of our module derived from
    `__name__`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的`app`，唯一的参数是从`__name__`派生的模块名称。
- en: '`@app.route` allows you decorate a function with a URL endpoint.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@app.route`允许您使用URL端点装饰一个函数。'
- en: 'With this, we will be able to get our new Flask web server up and running,
    albeit with no functionality. To test this, first export some environment variables:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们将能够启动我们的新Flask Web服务器，尽管没有功能。要测试这一点，首先导出一些环境变量：
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The first will set the app to debug mode, one of the features I like about this
    as it will hot-reload when we update our code, unlike a Nameko service. The second
    simply tells Flask where our app lives.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个将设置应用程序为调试模式，这是我喜欢的一个功能，因为当我们更新代码时，它将热重载，不像Nameko服务。第二个简单地告诉Flask我们的应用程序在哪里。
- en: Before we start the Flask app, please ensure that you are not currently running
    your old Nameko web server as this will cause a port clash.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动Flask应用程序之前，请确保您当前没有运行旧的Nameko Web服务器，因为这将导致端口冲突。
- en: 'Within your virtualenv, execute the following in the root of our project to
    start the server:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的虚拟环境中，在项目的根目录中执行以下命令以启动服务器：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will start the Flask server on port `8000`, the same port we had our old
    Nameko web server running on. Provided your local network allows, you can even
    have other devices on the same network navigate to your machine''s IP and use
    TempMessenger! Now go to `http://127.0.0.1:8000` on your browser and you should
    see the following (albeit with no functionality):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在端口`8000`上启动Flask服务器，与我们以前的Nameko web服务器运行的端口相同。只要您的本地网络允许，甚至可以让同一网络上的其他设备导航到您的机器IP并使用TempMessenger！现在在浏览器中转到`http://127.0.0.1:8000`，您应该看到以下内容（尽管没有功能）：
- en: '![](assets/b97a2733-ea93-46ee-9911-6cc0bd049e39.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b97a2733-ea93-46ee-9911-6cc0bd049e39.png)'
- en: Looks similar to what we had before right? That's because Flask already uses
    Jinja2 as its default templating engine, so if we want we can delete our old `jinja2.py`
    dependency as it's no longer needed. Flask also looks for a folder called `templates`
    in the same directory as the app, which is how it automatically knew where to
    find `home.html`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来与我们以前的类似，对吧？那是因为Flask已经使用Jinja2作为其默认的模板引擎，所以如果我们愿意，我们可以删除我们旧的`jinja2.py`依赖，因为它不再需要了。Flask还会在与应用程序相同的目录中查找一个名为`templates`的文件夹，这就是它自动知道在哪里找到`home.html`的方式。
- en: 'Let''s now add the functionality of retrieving messages from our Message Service.
    This is slightly different from when we were communicating between two Nameko
    services since Flask does not know how to perform RPC''s. First, let''s add the
    following to our imports:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加从我们的消息服务中检索消息的功能。这与我们在两个Nameko服务之间通信时略有不同，因为Flask不知道如何执行RPC。首先，让我们添加以下内容到我们的导入中：
- en: '[PRE45]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We will also need to add some config so that Flask knows where to find our
    RabbitMQ server. We could just add this in our module as a constant, but since
    we already have `AMQP_URI` in our `config.yaml`, it makes no sense to duplicate
    it! In our `web_server.py` module, before `app = Flask(__name__)`, add the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加一些配置，以便Flask知道在哪里找到我们的RabbitMQ服务器。我们可以将其添加到我们的模块中作为一个常量，但由于我们已经在`config.yaml`中有`AMQP_URI`，所以没有必要重复！在我们的`web_server.py`模块中，在`app
    = Flask(__name__)`之前，添加以下内容：
- en: '[PRE46]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will load all of our config variables from `config.yaml`. Now add the
    following class to `web_server.py`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从`config.yaml`中加载所有的配置变量。现在将以下类添加到`web_server.py`中：
- en: '[PRE47]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Whereas our home page endpoint has a function-based view, here we have a class-based
    view. We've defined a `get` method, which will be used for any `GET` requests
    to this `MessageAPI`. Take note that the names of the methods are important here
    since they map to their respective request types. If we were to add a `post` method
    (and we will later), then that would map to all `POST` requests on the `MessageAPI`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 而我们的主页端点有一个基于函数的视图，这里我们有一个基于类的视图。我们定义了一个`get`方法，它将用于对这个`MessageAPI`的任何`GET`请求。请注意，这里方法的名称很重要，因为它们映射到它们各自的请求类型。如果我们要添加一个`post`方法（我们稍后会添加），那么它将映射到`MessageAPI`上的所有`POST`请求。
- en: '`ClusterRpcProxy` allows us to make RPCs outside a Nameko service. It''s used
    as a context manager and allows us to easily call our Message Service. Flask comes
    with a handy helper function, `jsonify`, which converts our list of messages into
    JSON. It''s then a simple task of returning that payload, whereby Flask handles
    the response headers and status code for us.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClusterRpcProxy`允许我们在Nameko服务之外进行RPC。它被用作上下文管理器，并允许我们轻松调用我们的消息服务。Flask带有一个方便的辅助函数`jsonify`，它将我们的消息列表转换为JSON。然后简单地返回该有效负载，Flask会为我们处理响应头和状态码。'
- en: 'Let''s now add the functionality of sending new messages. First, amend your
    flask import to include request:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加发送新消息的功能。首先，修改你的flask导入以包括请求：
- en: '[PRE48]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now add a new post method to the `MessageAPI` class:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`MessageAPI`类中添加一个新的post方法：
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You may notice that, rather than obtaining the `request` object from the `post`
    parameters like we did with our Nameko web server, we are importing it from Flask.
    In this context, it is a global object that parses all incoming request data for
    us.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能会注意到，与我们在Nameko web服务器中使用`post`参数获取`request`对象的方式不同，我们是从Flask中导入它的。在这种情况下，它是一个全局对象，为我们解析所有传入的请求数据。
- en: We use `get_json`, which is an inbuilt JSON parser that will replace our `get_request_data`
    function from the last chapter. We specify that `force=True`, which will enforce
    that the request has valid JSON data; otherwise it will return a `400 Bad Request`
    error code.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`get_json`，这是一个内置的JSON解析器，将替换我们上一章的`get_request_data`函数。我们指定`force=True`，这将强制要求请求具有有效的JSON数据；否则它将返回`400
    Bad Request`错误代码。
- en: Like our old `post_message` HTTP endpoint, we `try` to get `data['message']`
    or return a `400`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们旧的`post_message`HTTP端点一样，我们尝试获取`data['message']`，否则返回`400`。
- en: We then again use `ClusterRpcProxy` to make an RPC to save the message.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们再次使用`ClusterRpcProxy`进行RPC以保存消息。
- en: Return a `204` if all went well. We use `204` rather than a `200` here to indicate
    that, while the request was still successful, there is no content to be returned.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，返回`204`。我们在这里使用`204`而不是`200`来表示，虽然请求仍然成功，但没有要返回的内容。
- en: 'There''s one more thing we need to do before this will work, and that is to
    register our `MessageAPI` with an API endpoint. At the bottom of our `web_server.py`,
    outside the `MessageAPI` class, add the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这之前，我们还需要做一件事，那就是注册我们的`MessageAPI`到一个API端点。在我们的`web_server.py`的底部，在`MessageAPI`类之外，添加以下内容：
- en: '[PRE50]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This will direct any requests to `/messages` to the `MessageAPI`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把任何请求重定向到`/messages`到`MessageAPI`。
- en: 'It''s now time to bring our Message Service back online. In a new terminal
    window and inside your virtualenv, execute:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候重新启动我们的消息服务了。在一个新的终端窗口中，在您的虚拟环境中执行：
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Since we now have multiple services, this requires multiple instances running
    in different terminal windows. If one of your Nameko services is down when you
    make a request, this can cause functionality to hang indefinitely until that service
    is back online. This is a side-effect of Nameko using a messaging queue to consume
    new tasks; the task is simply on the queue, waiting for a service to take it.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在有多个服务，这需要在不同的终端窗口中运行多个实例。如果您的Nameko服务在您发出请求时关闭，这可能会导致功能无限期地挂起，直到该服务再次上线。这是Nameko使用消息队列来消耗新任务的一个副作用；任务只是在队列中等待服务接收。
- en: Provided that you still have your Flask server running, you should now be able
    to visit our app in all its former glory at `http://127.0.0.1:8000`!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的Flask服务器仍在运行，现在您应该能够访问我们的应用程序，以前的所有功能都在`http://127.0.0.1:8000`上！
- en: '![](assets/b4105130-c7d8-4265-904c-77168f84e27c.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b4105130-c7d8-4265-904c-77168f84e27c.png)'
- en: Web sessions
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web会话
- en: Now that we have our old functionality back using our new Flask server, we can
    start to add some new features such as logging users in and out, creating new
    users , and allowing only logged in users to send messages. All of these depend
    heavily on web sessions.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过新的Flask服务器恢复了旧的功能，我们可以开始添加一些新功能，比如登录和注销用户，创建新用户，并且只允许已登录的用户发送消息。所有这些都严重依赖于Web会话。
- en: 'Web sessions allow us to keep track of users between different requests via
    cookies. In these cookies, we store information that can be passed on from one
    request to the next. For example, we could store whether a user is authenticated,
    what their email address is, and so on. The cookies are signed cryptographically
    using a secret key, which we will need to define before we can use Flask''s Sessions.
    In `config.yaml`, add the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Web会话允许我们通过cookie在不同的请求之间跟踪用户。在这些cookie中，我们存储可以从一个请求传递到下一个请求的信息。例如，我们可以存储用户是否经过身份验证，他们的电子邮件地址是什么，等等。这些cookie使用一个密钥进行加密签名，我们需要在使用Flask的会话之前定义它。在`config.yaml`中，添加以下内容：
- en: '[PRE52]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Feel free to set your own secret key, this is just an example. In a production-like
    environment, this would have to be kept safe and secure, otherwise a user could
    forge their own session cookies.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 随意设置您自己的密钥，这只是一个例子。在类似生产环境中，这必须保持安全和安全，否则用户可以伪造自己的会话cookie。
- en: 'We will now need to tell our `app` to use this secret key. After `app = Flask(__name__),`
    add the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要告诉我们的`app`使用这个密钥。在`app = Flask(__name__)`之后添加以下内容：
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: With this done, Flask will now use our `FLASK_SECRET_KEY` from our `config.yaml`
    to sign cookies.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，Flask现在将使用我们在`config.yaml`中的`FLASK_SECRET_KEY`来签署cookie。
- en: Creating a sign-up page
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建注册页面
- en: 'We will start these new features by adding the ability for new users to sign
    up. In `web_server.py`, add the following new class:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过为新用户添加注册功能来开始这些新功能。在`web_server.py`中，添加以下新类：
- en: '[PRE54]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This new `SignUpView` class will be responsible for dealing with the sign-up
    process. We've added a get method, which will simply render the `sign_up.html`
    template that we will create later.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`SignUpView`类将负责处理注册过程。我们添加了一个get方法，它将简单地渲染我们稍后将创建的`sign_up.html`模板。
- en: 'At the end of the `web_server.py` module, create the following URL rule:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在`web_server.py`模块的末尾，创建以下URL规则：
- en: '[PRE55]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As you probably already know, this will direct all requests to `/sign_up` to
    our new `SignUpView` class.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经知道的，这将把所有请求重定向到`/sign_up`到我们的新`SignUpView`类。
- en: 'Now let''s create our new template. In the `templates` folder, create a new
    file, `sign_up.html`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的新模板。在`templates`文件夹中，创建一个新文件，`sign_up.html`：
- en: '[PRE56]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is a basic HTML form, consisting of the fields needed to create a new user
    in our database. The  `action` and `method` forms tell it to make a `post` request
    to the `/sign_up` endpoint. All fields are `text` fields with the exception of
    password, which is of type `password`, which will cause the user input to be masked.
    We also have a Jinja `if` statement that will check to see if the template was
    rendered with an `error_message`. If so, then it will be displayed in a paragraph
    block. We will use this later to display messages such as User already exists to
    the user.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的HTML表单，包括在我们的数据库中创建新用户所需的字段。`action`和`method`表单告诉它向`/sign_up`端点发出`post`请求。所有字段都是`text`字段，除了密码，它是`password`类型，这将导致用户输入被掩盖。我们还有一个Jinja
    `if`语句，它将检查模板是否渲染了`error_message`。如果是，那么它将显示在段落块中。我们稍后将使用这个来向用户显示消息，比如“用户已存在”。
- en: 'With these changes made, provided you still have the Flask server running,
    navigate to `http://127.0.0.1:8000/sign_up` and you should see the new sign-up
    page:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 做出这些更改后，假设您的Flask服务器仍在运行，请导航到`http://127.0.0.1:8000/sign_up`，您应该看到新的注册页面：
- en: '![](assets/043bf8b2-c94c-429f-8581-b4f28366ad6b.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/043bf8b2-c94c-429f-8581-b4f28366ad6b.png)'
- en: 'This form will not yet do anything, as we have not defined a post method for
    our `SignUpView`. Let''s go ahead and create that. First, update our imports in
    `web_server.py` to include `RemoteError` from Nameko and `session`, `redirect`,
    and `url_for` from Flask:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格目前还没有任何作用，因为我们还没有为`SignUpView`定义一个post方法。让我们继续创建。首先，在`web_server.py`中更新我们的导入，包括从Nameko导入`RemoteError`，从Flask导入`session`，`redirect`和`url_for`：
- en: '[PRE57]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In your `SignUpView` class, add the following `post` method:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`SignUpView`类中，添加以下`post`方法：
- en: '[PRE58]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is quite a long method, but it''s fairly simple. Let''s go through it
    step-by-step:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当长的方法，但它非常简单。让我们一步一步地来看：
- en: We start by retrieving all relevant fields for a user from `request.form`.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从`request.form`中检索用户的所有相关字段。
- en: We then use `ClusterRpcProxy` to make a `create_user` RPC to our `user_service`.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用`ClusterRpcProxy`向我们的`user_service`发出`create_user` RPC。
- en: 'If an error occurs, handle it by:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发生错误，通过以下方式处理：
- en: Constructing an error message
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建错误消息
- en: Logging that message to the console using Flask's `app.logger`
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask的`app.logger`将该消息记录到控制台
- en: Rendering the `sign_up.html` template with the error message
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用错误消息渲染`sign_up.html`模板
- en: If there are no errors, then we continue by adding an `authenticated` Boolean
    of `True` to the `session` object.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有错误，那么我们继续向`session`对象添加一个`True`的`authenticated`布尔值。
- en: Add the user's email to the `session` object.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户的电子邮件添加到`session`对象中。
- en: Finally, we redirect the user using `url_for`, which will look for the function
    endpoint named `home`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`url_for`重定向用户，它将寻找名为`home`的函数端点。
- en: 'Before we test this out, if you don''t already have the User Service running,
    in a new terminal within your virtualenv execute:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试之前，如果您还没有运行用户服务，请在虚拟环境中的新终端中执行：
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: With this, you should now have your User Service, Message Service and Flask
    web server running simultaneously in different terminal windows. If not, then
    start them using the `nameko` and `flask` commands from earlier.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，现在您应该同时在不同的终端窗口中运行用户服务、消息服务和Flask Web服务器。如果没有，请使用之前的`nameko`和`flask`命令启动它们。
- en: 'Navigate to `http://127.0.0.1:8000/sign_up` and attempt to create a new user:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`http://127.0.0.1:8000/sign_up`，尝试创建一个新用户：
- en: '![](assets/280e4a06-0dea-45cd-97b3-c29bf62fd2ec.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/280e4a06-0dea-45cd-97b3-c29bf62fd2ec.png)'
- en: Once you hit Submit, it should redirect you to the home page and you should
    have a new user in your database. Check pgAdmin to ensure that they have been
    created.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您点击提交，它应该将您重定向到主页，并且您的数据库中应该有一个新用户。检查pgAdmin以确保它们已经被创建。
- en: 'Now go back to `http://127.0.0.1:8000/sign_up` and attempt to add the same
    user again. It should keep you on the same page and display the error message:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在返回`http://127.0.0.1:8000/sign_up`，尝试再次添加相同的用户。它应该让您保持在同一个页面上并显示错误消息：
- en: '![](assets/1921cfef-7c6e-4eb9-8a32-5f82bb38520c.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1921cfef-7c6e-4eb9-8a32-5f82bb38520c.png)'
- en: 'It''s all well and good having a sign-up page, but our users need to be able
    to navigate to it without knowing the URL! Let''s make some adjustments to our
    `home.html` to add a simple Sign up link. While we are at it, we can also hide
    the ability to send new messages unless they are logged in! In our `home.html`,
    amend our existing `postMessage` form to the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有注册页面是很好的，但是我们的用户需要能够在不知道URL的情况下导航到它！让我们对`home.html`进行一些调整，添加一个简单的注册链接。与此同时，我们还可以隐藏发送新消息的功能，除非他们已登录！在我们的`home.html`中，修改现有的`postMessage`表单如下：
- en: '[PRE60]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: What we have done here is to wrap our form in a Jinja `if` block. If the user
    is `authenticated`, then we will show the `postMessage` form; otherwise, we will
    display a link directing the user to the sign-up page.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是将我们的表单包装在Jinja的`if`块中。如果用户经过身份验证，那么我们将显示`postMessage`表单；否则，我们将显示一个链接，引导用户转到注册页面。
- en: 'We will now also have to update our home endpoint to pass the `authenticated`
    Boolean from the `session` object to the template renderer. First, let''s add
    a new helper function that gets the authenticated state of a user. This should
    sit outside any classes inside your `web_server.py` module:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们还需要更新我们的主页端点，将`session`对象中的`authenticated`布尔值传递给模板渲染器。首先，让我们添加一个新的帮助函数，用于获取用户的认证状态。这应该位于`web_server.py`模块中任何类之外：
- en: '[PRE61]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This will attempt to get the `authenticated` Boolean from the `session` object.
    If it's a brand new `session` then we can't guarantee that the `authenticated`
    will be there, so we default it to `False` and return it.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这将尝试从`session`对象中获取`authenticated`布尔值。如果它是一个全新的`session`，那么我们不能保证`authenticated`会在那里，所以我们将其默认为`False`并返回它。
- en: 'In `web_server.py`, update the `home` endpoint to be the following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在`web_server.py`中，更新`home`端点如下：
- en: '[PRE62]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This will make a call to `user_authenticated` to get the authenticated Boolean
    of our user. We then render the template by passing it `authenticated`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用`user_authenticated`来获取我们用户的`authenticated`布尔值。然后我们通过传递`authenticated`来渲染模板。
- en: 'Another nice adjustment we can make is to only allow the user to go to the
    sign up page if they are not authenticated. To do this, we will need to update
    our `get` method in our `SignUpView` as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的另一个不错的调整是，只有在用户未经过身份验证时才允许其转到注册页面。为此，我们需要更新`SignUpView`中的`get`方法如下：
- en: '[PRE63]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If we are authenticated, then we redirect the user to the `home` endpoint; otherwise,
    we render the `sign_up.html` template.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们经过身份验证，那么我们将用户重定向到`home`端点；否则，我们渲染`sign_up.html`模板。
- en: If you still have the browser open that you used to create your first user,
    then if you try to navigate to `http://127.0.0.1:8000/sign_up` it should redirect
    you to the home page of our site since you are already authenticated.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍然打开了用于创建第一个用户的浏览器，那么如果您尝试导航到`http://127.0.0.1:8000/sign_up`，它应该将您重定向到我们网站的主页，因为您已经经过身份验证。
- en: If you open a different browser, on the home page, you should see the new Sign
    up link we made and the ability to send new messages should have disappeared,
    since you have a new session.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开一个不同的浏览器，在主页上，您应该看到我们制作的新的注册链接，发送新消息的功能应该已经消失，因为您有一个新的会话。
- en: 'We now have a new issue. We have prevented users from sending new messages
    from the app, but they can still send them if they were to use Curl or a REST
    client. To stop this from happening, we need to make a small tweak to our `MessageAPI`.
    At the start of the `MessageAPI` post method, add the following:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个新问题。我们已经阻止了用户从应用程序发送新消息，但是如果他们使用Curl或REST客户端，他们仍然可以发送消息。为了阻止这种情况发生，我们需要对`MessageAPI`进行一点小调整。在`MessageAPI`的post方法开头添加以下内容：
- en: '[PRE64]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Be sure not to adjust any of the other code; the `...` denotes the rest of the
    code from our `post` method. This will simply reject the user's request with a
    `401` response that tells the user to log in.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 确保不要调整任何其他代码；`...`表示我们`post`方法的其余代码。这将简单地拒绝用户的请求，并使用`401`响应告诉用户登录。
- en: Logging users out
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登出用户
- en: 'We now need to implement the ability for users to log out. In `web_server.py`,
    add the following `logout` function endpoint:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要实现用户注销的功能。在`web_server.py`中，添加以下`logout`函数端点：
- en: '[PRE65]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If a user hits this endpoint, Flask will clear their `session` object and redirect
    them to the `home` endpoint. Since the session is cleared, the `authenticated`
    Boolean will be deleted.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户访问此端点，Flask将清除他们的`session`对象并将其重定向到`home`端点。由于会话已清除，`authenticated`布尔值将被删除。
- en: 'In `home.html`, let''s update our page to include the link for users to log
    out. To do this, we will add a new link just after our `postMessage` form:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在`home.html`中，让我们更新我们的页面，包括用户注销的链接。为此，我们将在`postMessage`表单之后添加一个新链接：
- en: '[PRE66]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Once saved, and provided we are logged in, we should now have a Logout link
    underneath our message form:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，只要我们已登录，现在我们应该在消息表单下面有一个注销链接：
- en: '![](assets/1bbcc2f0-51be-485b-8af0-9abb6cb5f4e3.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1bbcc2f0-51be-485b-8af0-9abb6cb5f4e3.png)'
- en: After clicking the Logout link, you should be redirected back to the home page,
    where you will no longer be able to send messages.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 点击注销链接后，您将被重定向回主页，您将无法再发送消息。
- en: Logging users in
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录用户登录
- en: 'Our app can''t be complete without the ability to log a user in! In our `web_server.py`,
    create a new class, `LoginView`:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序如果没有用户登录的能力就不完整！在我们的`web_server.py`中，创建一个新的类`LoginView`：
- en: '[PRE67]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Like the get in our `SignUpView`, this one will check to see if the user is
    already `authenticated`. If so, then we will redirect them to the `home` endpoint,
    otherwise, we will render the `login.html` template.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的`SignUpView`中的get方法类似，这个方法将检查用户是否已经`authenticated`。如果是，则将重定向到`home`端点，否则，将呈现`login.html`模板。
- en: 'At the end of our `web_server.py` module, add the following URL rule for the
    `LoginView`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`web_server.py`模块的末尾，添加以下URL规则以使用`LoginView`：
- en: '[PRE68]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Any request to `/login` will now be directed to our `LoginView`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对`/login`的请求现在都将被重定向到我们的`LoginView`。
- en: 'Now create a new template, `login.html` , inside our templates folder:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们的模板文件夹中创建一个新模板`login.html`：
- en: '[PRE69]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As you can see, this is quite similar to our `sign_up.html` template. We create
    a form, but this time we only have the `email` and `password` fields. We also
    have a Jinja `if` block for error messages. However, this one has a hardcoded
    error message rather than one returned from the `LoginView`. This is because it
    is bad practice to tell a user why they failed to log in. If it was a malicious
    user and we were telling them things such as *This user does not exist* or *Password
    incorrect* then this alone would tell them which users exist in our database and
    they could possibly attempt to brute-force passwords.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这与我们的`sign_up.html`模板非常相似。我们创建一个表单，但这次我们只有`email`和`password`字段。我们还有一个Jinja的`if`块用于错误消息。但是，这个错误消息是硬编码的，而不是从`LoginView`返回的。这是因为告诉用户登录失败的原因是不好的做法。如果是恶意用户，我们告诉他们诸如*此用户不存在*或*密码不正确*之类的东西，那么这就足以告诉他们我们数据库中存在哪些用户，他们可能会尝试暴力破解密码。
- en: 'In our `home.html` template, let''s also add a link for users to log in. To
    do this, we will add a new link in the `else` statement of our `if authenticated`
    block:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`home.html`模板中，让我们还添加一个用户登录的链接。为此，我们将在`if authenticated`块的`else`语句中添加一个新链接：
- en: '[PRE70]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We should now be able to navigate to the Login page from the home page:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够从主页导航到登录页面：
- en: '![](assets/23037fa1-de70-4735-8b4a-0894a259f1f1.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/23037fa1-de70-4735-8b4a-0894a259f1f1.png)'
- en: 'In order for our Login page to work, we will need to create a `post` method
    in our `LoginView`. Add the following to `LoginView`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的登录页面工作，我们需要在我们的`LoginView`中创建一个`post`方法。将以下内容添加到`LoginView`中：
- en: '[PRE71]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You''ll notice that this is quite similar to our `SignUpView` post method.
    Let''s briefly go over what is happening:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到这与我们的`SignUpView`中的post方法非常相似。让我们简要地了解一下正在发生的事情：
- en: We retrieve the email and password from `request.form`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`request.form`中检索电子邮件和密码。
- en: We use `ClusterRpcProxy` to make an `authenticate_user` RPC to the `user_service`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`ClusterRpcProxy`向`user_service`发出`authenticate_user` RPC。
- en: 'If a `RemoteError` occurs, then we:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发生`RemoteError`，那么我们：
- en: Use Flask's `app.logger` to log the error to the console
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask的`app.logger`将错误记录到控制台
- en: Render the `login.html` template with `login_error` set to `True`
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`login_error`设置为`True`呈现`login.html`模板
- en: If they authenticate successfully, we set `authenticated` to `True` in the `session`
    object.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果他们成功验证，我们将在`session`对象中将`authenticated`设置为`True`。
- en: Set email to the user's `email` in the `session` object.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电子邮件设置为`session`对象中的用户`email`。
- en: Redirect the user to the `home` endpoint.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将用户重定向到`home`端点。
- en: With the preceding code, rather than return the error message to the user, we
    choose to log the error message to the console where only we can see it. This
    allows us to see if there are any issues with our authentication system or if
    a malicious user is up to no good, while still letting the user know that they
    supplied invalid information.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述代码，我们选择将错误消息记录到只有我们可以看到的控制台，而不是将错误消息返回给用户。这使我们能够查看我们的身份验证系统是否存在任何问题，或者恶意用户是否在做坏事，同时仍然让用户知道他们提供了无效的信息。
- en: Provided our services are all still running, you should now be able to test
    this out! We now have a fully functioning authentication system for TempMessenger
    and our goals are complete.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务仍在运行，现在您应该能够测试它了！我们现在为TempMessenger拥有一个完全运作的身份验证系统，我们的目标已经实现。
- en: Prepending the email to our messages
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的消息中添加电子邮件前缀
- en: One thing that our TempMessenger is missing is accountability. We have no idea
    which users are posting what, which is fine for an anonymous messaging application
    (and if that is what you want, then skip this section altogether). To do this,
    when we store our messages, we will want to also store the email of the user who
    sent it.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的TempMessenger缺少的一个重要功能是问责制。我们不知道哪些用户发布了什么，对于一个匿名的消息应用来说这是可以接受的（如果这是您想要的话，那么可以跳过这一部分）。为了做到这一点，当我们存储我们的消息时，我们还希望存储发送者的电子邮件。
- en: 'Let''s start by revisiting the `messages.py` dependency. Update `save_message`
    in our `RedisClient` to the following:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先重新审视`messages.py`的依赖关系。将我们`RedisClient`中的`save_message`更新为以下内容：
- en: '[PRE72]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The first thing you'll notice is that, in order to call `save_message`, we now
    require the user's email.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到的第一件事是，为了调用`save_message`，我们现在需要用户的电子邮件。
- en: What we have also done here is to change the format of the data we are storing
    in Redis from a string to a hash. Redis hashes allow us to store dictionary-like
    objects as the value. They also have the added benefit of being able to pick which
    key from the dictionary we want to get back out later, as opposed to getting the
    whole object out.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的另一件事是将我们在Redis中存储的数据格式从字符串更改为哈希。Redis哈希允许我们将类似字典的对象存储为值。它们还有一个额外的好处，就是可以选择以后从字典中获取哪个键，而不是获取整个对象。
- en: So here we create a dictionary of the user's email and password and use `hmset`
    to store it in Redis. `hmset` does not have a `px` or `ex` argument, so instead
    we make a call to `pexpire`, which expires the given key for the given number
    of milliseconds. There is also an `expire` equivalent of this for seconds.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了用户电子邮件和密码的字典，并使用`hmset`将其存储在Redis中。`hmset`没有`px`或`ex`参数，所以我们调用`pexpire`，它会在给定的毫秒数后使给定的键过期。还有一个相当于秒的`expire`。
- en: 'To learn more about Redis hashes and other data types, see: [http://url.marcuspen.com/redis-data-types](http://url.marcuspen.com/redis-data-types).'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关Redis哈希和其他数据类型的更多信息，请参阅：[http://url.marcuspen.com/redis-data-types](http://url.marcuspen.com/redis-data-types)。
- en: 'We will now update our `get_all_messages` method in the `RedisClient` to the
    following:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更新`RedisClient`中的`get_all_messages`方法如下：
- en: '[PRE73]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Since the data has changed to a hash, we also have to retrieve it from Redis
    differently, using the `hget` method. We also get the email corresponding to each
    message.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据已更改为哈希，我们还必须以不同的方式从Redis中检索数据，使用`hget`方法。我们还获取与每条消息对应的电子邮件。
- en: 'Now we will move on to `message_service.py`. Within the `MessageService`, update
    the `save_message` RPC to the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将继续进行`message_service.py`。在`MessageService`中，将`save_message` RPC更新为以下内容：
- en: '[PRE74]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: All we have done here is update the arguments for the RPC to include `email`
    and pass that to the updated `message_store.save_message`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的只是更新RPC的参数，包括`email`并将其传递给更新后的`message_store.save_message`。
- en: 'Back in our `web_server.py`, we will need to update the `MessageAPI` post method
    to send the user''s email when it makes the RPC to the `MessageService`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`web_server.py`，我们需要更新`MessageAPI`的post方法，在调用`MessageService`时发送用户的电子邮件：
- en: '[PRE75]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Two small changes we have just made:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚做了两个小改动：
- en: Obtain the `email` from the `session` object.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`session`对象中获取`email`。
- en: Update the RPC to also pass the `email`.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新RPC以传递`email`。
- en: 'In order to see these changes on our page, we will also need to update the
    `home.html` template. For our JavaScript function, `updateMessages`, update it
    to the following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的页面上看到这些更改，我们还需要更新`home.html`模板。对于我们的JavaScript函数`updateMessages`，将其更新为以下内容：
- en: '[PRE76]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This is a minor tweak. If you can't spot it, we've updated the `messageList.push`
    to include the `email`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个小调整。如果你没注意到，我们已经更新了`messageList.push`以包括`email`。
- en: 'Before you test this, ensure that your Redis store is empty, as old messages
    will be in the old format and will break our app. You can do this by using `redis-cli`
    inside of our Redis container:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试之前，请确保您的Redis存储为空，因为旧消息将以旧格式存在，这将破坏我们的应用程序。您可以通过在我们的Redis容器内使用`redis-cli`来做到这一点：
- en: '[PRE77]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Also, be sure to restart our Message Service so that it takes the new changes
    into effect. Once you have done that, we can test this new functionality:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保重新启动我们的消息服务，以使新更改生效。一旦你做到了，我们就可以测试这个新功能：
- en: '![](assets/5069299d-f391-4c07-9735-07bb57c96d62.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5069299d-f391-4c07-9735-07bb57c96d62.png)'
- en: Summary
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This now concludes our work on the TempMessenger User Authentication system.
    We started this chapter by using a Postgres database with Python and created a
    Nameko Dependency to encapsulate it. This was different from our Redis dependency
    from the last chapter since the data is permanent and required a lot more planning.
    Despite this, we tucked this logic away and simply exposed two RPC''s: `create_user`
    and `authenticate_user`.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对TempMessenger用户认证系统的工作。我们从本章开始使用Python和Postgres数据库，并创建了一个Nameko依赖项来封装它。这与上一章的Redis依赖项不同，因为数据是永久的，需要更多的规划。尽管如此，我们将这个逻辑隐藏起来，并简单地暴露了两个RPC：`create_user`和`authenticate_user`。
- en: We then looked at how to securely store user passwords in a database. We explored
    some of the ways you can do this incorrectly, such as by storing passwords in
    plain text. We used Bcrypt to cryptographically hash our passwords to prevent
    them from being read if our database was compromised.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们研究了如何在数据库中安全存储用户密码。我们探讨了一些错误的存储密码的方式，比如以明文存储密码。我们使用Bcrypt对我们的密码进行加密哈希，以防止在数据库受到损害时被读取。
- en: When it came to linking the new User Service to the rest of our application,
    we first split out each service into its own module to allow us to deploy, update,
    and manage them independently. We reaped some of the benefits of a microservice
    architecture by showing how easy it was to replace one framework (Nameko) with
    another (Flask) in the Web Server without affecting the rest of the platform.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及将新的用户服务链接到我们应用程序的其他部分时，我们首先将每个服务拆分为自己的模块，以便我们可以独立部署、更新和管理它们。通过展示如何在Web服务器中轻松替换一个框架（Nameko）为另一个框架（Flask），我们获得了微服务架构的一些好处，而不会影响平台的其他部分。
- en: We explored the Flask framework and how to create function-based and class-based
    views. We also looked at Flask session objects and how we could store user data
    from one request to the next.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探索了Flask框架以及如何创建基于函数和基于类的视图。我们还研究了Flask会话对象以及如何从一个请求到下一个存储用户数据。
- en: As a bonus, we amended our message list to also include the email address of
    the user who sent it.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 作为奖励，我们修改了消息列表，还包括发送者的电子邮件地址。
- en: I'd encourage you to think of new enhancements to make for TempMessenger and
    plan accordingly how you would add them, ensuring that logic from our dependencies
    does not leak outside the service it belongs to—a mistake made by many! Keeping
    our service boundaries well defined is a hard task and sometimes it helps to start
    off with a more monolithic approach and separate them out later once they are
    clear. This is similar to the approach we took with `MessageService` and `WebServer`
    from the last chapter. *Building Microservices* (O'Reilly) by Sam Newman explains
    this very well and also covers in more detail the benefits, drawbacks, and challenges
    associated with building distributed systems.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你考虑为TempMessenger制定新的增强功能，并相应地计划如何添加它们，确保我们的依赖逻辑不会泄漏到属于它的服务之外——这是许多人犯的错误！保持我们的服务边界定义清晰是一项艰巨的任务，有时候从更单片的方式开始，等清晰之后再将它们分离出来会有所帮助。这与我们在上一章中对`MessageService`和`WebServer`采取的方法类似。Sam
    Newman的《构建微服务》（O'Reilly）很好地解释了这一点，并更详细地介绍了构建分布式系统所涉及的好处、缺点和挑战。
- en: With this chapter complete, I hope I have given you a deeper insight into how
    you can benefit from a Microservice architecture in practice. The journey we took
    creating this application was purposely modular, not only to reflect the modularity
    of microservices but to demonstrate how we should go about adding new features
    with minimal impact to the rest of the platform.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了这一章，我希望我已经让你更深入地了解了如何在实践中从微服务架构中受益。我们创建这个应用程序的过程是有意模块化的，不仅反映了微服务的模块化，而且演示了我们应该如何在对平台的影响最小的情况下添加新功能。
