- en: Lists and Pointer Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表和指针结构
- en: You will have already seen lists in Python. They are convenient and powerful.
    Normally, any time you need to store something in a list, you use python's built-in
    list implementation. In this chapter, however, we are more interested in understanding
    how lists work. So we are going to study list internals. As you will notice, there
    are different types of lists.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在Python中看到了列表。它们方便而强大。通常，每当你需要在列表中存储东西时，你使用Python的内置列表实现。然而，在本章中，我们更感兴趣的是理解列表的工作原理。因此，我们将研究列表的内部。正如你将注意到的，有不同类型的列表。
- en: Python's list implementation is designed to be powerful and to encompass several
    different use cases. We are going to be a bit more strict in our definition of
    what a list is. The concept of a node is very important to lists. We shall discuss them
    in this chapter, but this concept will, in different forms, come back throughout
    the rest of the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python的列表实现旨在强大并包含几种不同的用例。我们将对列表的定义更加严格。节点的概念对列表非常重要。我们将在本章讨论它们，但这个概念将以不同的形式在本书的其余部分中再次出现。
- en: 'The focus of this chapter will be the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点将是以下内容：
- en: Understand pointers in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Python中的指针
- en: Treating the concept of nodes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理节点的概念
- en: Implementing singly, doubly, and circularly linked lists
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现单向、双向和循环链表
- en: In this chapter, we are going to deal quite a bit with pointers. So it may be
    useful to remind ourselves what these are. To begin with, imagine that you have
    a house that you want to sell. Lacking time, you contact an agent to find interested
    buyers. So you pick up your house and take it over to the agent, who will in turn
    carry the house to anybody who may want to buy it. Ludicrous, you say? Now imagine
    that you have a few Python functions that work with images. So you pass high-resolution
    image data between your functions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将处理相当多的指针。因此，提醒自己这些是有用的。首先，想象一下你有一所房子想要出售。由于时间不够，你联系了一个中介来寻找感兴趣的买家。所以你拿起你的房子，把它带到中介那里，中介会把房子带给任何可能想要购买它的人。你觉得荒谬吗？现在想象一下你有一些Python函数，用于处理图像。所以你在函数之间传递高分辨率图像数据。
- en: Of course, you don't carry your house around. What you would do is write the
    address of the house down on a piece of scrap paper and hand it over to the agent.
    The house remains where it is, but the note containing the directions to the house
    is passed around. You might even write it down on several pieces of paper. Each
    one is small enough to fit in your wallet, but they all point to the same house.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不会把你的房子随身携带。你会把房子的地址写在一张废纸上，交给中介。房子还在原地，但包含房子方向的纸条在传递。你甚至可能在几张纸上写下来。每张纸都足够小，可以放在钱包里，但它们都指向同一所房子。
- en: As it turns out, things are not very different in Python land. Those large image
    files remain in one single place in memory. What you do is create variables that
    hold the locations of those images in memory. These variables are small and can
    easily be passed around between different functions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，在Python领域并没有太大的不同。那些大型图像文件仍然在内存中的一个地方。你所做的是创建变量，保存这些图像在内存中的位置。这些变量很小，可以在不同的函数之间轻松传递。
- en: 'That is the big benefit of pointers: they allow you to point to a potentially
    large segment of memory with just a simple memory address.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是指针的巨大好处：它们允许你用简单的内存地址指向潜在的大内存段。
- en: Support for pointers exists in your computer's hardware, where it is known as
    indirect addressing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 指针存在于计算机的硬件中，被称为间接寻址。
- en: 'In Python, you don''t manipulate pointers directly, unlike in some other languages,
    such as C or Pascal. This has led some people to think that pointers aren''t used
    in Python. Nothing could be further from the truth. Consider this assignment in
    the Python interactive shell:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你不直接操作指针，不像其他一些语言，比如C或Pascal。这导致一些人认为Python中不使用指针。这是大错特错。考虑一下在Python交互式shell中的这个赋值：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We would normally say that `s` is a variable of the type set. That is, `s` is
    a set. This is not strictly true, however. The variable `s` is rather a reference
    (a "safe" pointer) to a set. The set constructor creates a set somewhere in memory
    and returns the memory location where that set starts. This is what gets stored
    in `s`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会说`s`是set类型的变量。也就是说，`s`是一个集合。然而，这并不严格正确。变量`s`实际上是一个引用（一个“安全”的指针）指向一个集合。集合构造函数在内存中创建一个集合，并返回该集合开始的内存位置。这就是存储在`s`中的内容。
- en: Python hides this complexity from us. We can safely assume that `s` is a set
    and that everything works fine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Python将这种复杂性隐藏起来。我们可以安全地假设`s`是一个集合，并且一切都运行正常。
- en: Arrays
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An array is a sequential list of data. Being sequential means that each element
    is stored right after the previous one in memory. If your array is really big
    and you are low on memory, it could be impossible to find large enough storage
    to fit your entire array. This will lead to problems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是数据的顺序列表。顺序意味着每个元素都存储在前一个元素的后面。如果你的数组非常大，而且内存不足，可能找不到足够大的存储空间来容纳整个数组。这将导致问题。
- en: Of course, the flip side of the coin is that arrays are very fast. Since each
    element follows from the previous one in memory, there is no need to jump around
    between different memory locations. This can be a very important point to take
    into consideration when choosing between a list and an array in your own real-world
    applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，硬币的另一面是数组非常快。由于每个元素都紧随前一个元素在内存中，不需要在不同的内存位置之间跳转。在选择列表和数组在你自己的实际应用程序中时，这可能是一个非常重要的考虑因素。
- en: Pointer structures
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指针结构
- en: Contrary to arrays, pointer structures are lists of items that can be spread
    out in memory. This is because each item contains one or more links to other items
    in the structure. What type of links these are dependent on the type of structure
    we have. If we are dealing with linked lists, then we will have links to the next
    (and possibly previous) items in the structure. In the case of a tree, we have
    parent-child links as well as sibling links. In a tile-based game where the game
    map is built up of hexes, each node will have links to up to six adjacent map
    cells.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组相反，指针结构是可以在内存中分散的项目列表。这是因为每个项目包含一个或多个链接到结构中其他项目的链接。这些链接的类型取决于我们拥有的结构类型。如果我们处理的是链表，那么我们将有链接到结构中下一个（可能是上一个）项目的链接。在树的情况下，我们有父子链接以及兄弟链接。在基于瓦片的游戏中，游戏地图由六边形构建，每个节点将链接到最多六个相邻的地图单元。
- en: There are several benefits with pointer structures. First of all, they don't
    require sequential storage space. Second, they can start small and grow arbitrarily
    as you add more nodes to the structure.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 指针结构有几个好处。首先，它们不需要顺序存储空间。其次，它们可以从小开始，随着向结构中添加更多节点而任意增长。
- en: This, however, comes at a cost. If you have a list of integers, each node is
    going to take up the space of an integer, as well as an additional integer for
    storing the pointer to the next node.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是有代价的。如果你有一个整数列表，每个节点将占据一个整数的空间，以及额外的整数用于存储指向下一个节点的指针。
- en: Nodes
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点
- en: At the heart of lists (and several other data structures) is the concept of
    a node. Before we go any further, let us consider this idea for a while.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表（以及其他几种数据结构）的核心是节点的概念。在我们进一步之前，让我们考虑一下这个想法。
- en: 'To begin with, we shall create a few strings:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一些字符串：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now you have three variables, each with a unique name, a type, and a value.
    What we do not have is a way of saying in which way the variables relate to each
    other. Nodes allow us to do this. A node is a container of data, together with
    one or more links to other nodes. A link is a pointer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有三个变量，每个变量都有一个唯一的名称、类型和值。我们没有的是一种方法来说明变量之间的关系。节点允许我们这样做。节点是数据的容器，以及一个或多个指向其他节点的链接。链接是一个指针。
- en: A simple type of node is one that only has a link to the next node.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单类型的节点只有一个指向下一个节点的链接。
- en: 'Of course, knowing what we do about pointers, we realize that this is not entirely
    true. The string is not really stored in the node, but is rather a pointer to
    the actual string:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，根据我们对指针的了解，我们意识到这并不完全正确。字符串并没有真正存储在节点中，而是指向实际字符串的指针：
- en: '![](assets/f0120953-dde0-440a-b6e4-c435d9aaa949.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f0120953-dde0-440a-b6e4-c435d9aaa949.jpg)'
- en: Thus the storage requirement for this simple node is two memory addresses. The
    data attribute of the nodes are pointers to the strings `eggs` and `ham`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个简单节点的存储需求是两个内存地址。节点的数据属性是指向字符串`eggs`和`ham`的指针。
- en: Finding endpoints
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找终点
- en: 'We have created three nodes: one containing **eggs**, one **ham**, and another
    **spam**. The **eggs** node points to the **ham** node, which in turn points to
    the **spam** node. But what does the **spam** node point to? Since this is the
    last element in the list, we need to make sure its next member has a value that
    makes this clear.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了三个节点：一个包含**eggs**，一个**ham**，另一个**spam**。**eggs**节点指向**ham**节点，**ham**节点又指向**spam**节点。但**spam**节点指向什么？由于这是列表中的最后一个元素，我们需要确保它的下一个成员有一个清晰的值。
- en: 'If we make the last element point to nothing then we make this fact clear.
    In python, we will use the special value `None` to denote nothing:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使最后一个元素指向空，则我们使这一事实清楚。在Python中，我们将使用特殊值`None`来表示空：
- en: '![](assets/51d9ca4b-c0d8-4d9b-96fc-ff09f98627c3.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/51d9ca4b-c0d8-4d9b-96fc-ff09f98627c3.jpg)'
- en: The last node has its next point pointing to None. As such it is the last node
    in the chain of nodes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个节点的下一个指针指向None。因此它是节点链中的最后一个节点。
- en: Node
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点
- en: 'Here is a simple node implementation of what we have discussed so far:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们迄今为止讨论的一个简单节点实现：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Do not confuse the concept of a node with Node.js, a server-side technology
    implemented in JavaScript.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将节点的概念与Node.js混淆，Node.js是一种使用JavaScript实现的服务器端技术。
- en: The `next` pointer is initialized to `None`, meaning that unless you change
    the value of `next`, the node is going to be an end-point. This is a good idea,
    so that we do not forget to terminate the list properly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`next`指针被初始化为`None`，这意味着除非你改变`next`的值，否则节点将成为一个终点。这是一个好主意，这样我们就不会忘记正确终止列表。'
- en: You can add other things to the `node` class as you see fit. Just make sure
    that you keep in mind the distinction between node and data. If your node is going
    to contain customer data, then create a `Customer` class and put all the data
    there.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要向`node`类添加其他内容。只需记住节点和数据之间的区别。如果你的节点将包含客户数据，那么创建一个`Customer`类并将所有数据放在那里。
- en: 'One thing you may want to do is implement the `__str__` method so that it calls
    the `__str__` method of the contained object is called when the node object is
    passed to print:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要实现`__str__`方法，这样当节点对象传递给print时，它调用包含对象的`__str__`方法：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Other node types
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他节点类型
- en: We have assumed nodes that have a pointer to the next node. This is probably
    the simplest type of node. However, depending on our requirements, we can create
    a number of other types of nodes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设节点具有指向下一个节点的指针。这可能是最简单的节点类型。然而，根据我们的要求，我们可以创建许多其他类型的节点。
- en: 'Sometimes we want to go from A to B, but at the same time from B to A. In that
    case, we add a previous pointer in addition to the next pointer:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想从A到B，但同时也想从B到A。在这种情况下，我们除了下一个指针外还添加了一个前一个指针：
- en: '![](assets/124fe45b-0d55-4db6-b881-2ee91e2ed608.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/124fe45b-0d55-4db6-b881-2ee91e2ed608.jpg)'
- en: As you can see from the figure, we let both the last and the first nodes point
    to `None`, to indicate that we have reached they form the boundary of our list
    end-point. The first node’s previous pointer points to None since it has no predecessor,
    just as the last item’s next pointer points to `None` because it no successor
    node.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中可以看出，我们让最后一个节点和第一个节点都指向“None”，表示我们已经到达它们作为列表端点的边界。第一个节点的前指针指向None，因为它没有前任，就像最后一个项目的后指针指向“None”一样，因为它没有后继节点。
- en: 'You might also be creating tiles for a tile-based game. In such a case, instead
    of previous and next, you might use north, south, east, and west. There are more
    types of pointers, but the principle is the same. Tiles at the end of the map
    will point to `None`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还在为基于瓦片的游戏创建瓦片。在这种情况下，您可能使用北、南、东和西代替前一个和后一个。指针的类型更多，但原理是相同的。地图末尾的瓦片将指向“None”：
- en: '![](assets/117da9a1-faa1-4324-a90b-72c8d7041c7f.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/117da9a1-faa1-4324-a90b-72c8d7041c7f.jpg)'
- en: You can take this as far as you need to. If you need to be able to move north-west,
    north-east, south-east, and south-west as well, all you have to do is add these
    pointers to your `node` class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要扩展到任何程度。如果您需要能够向西北、东北、东南和西南移动，您只需将这些指针添加到您的“node”类中。
- en: Singly linked lists
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单链表
- en: A singly linked list is a list with only one pointer between two successive
    nodes. It can only be traversed in a single direction, that is, you can go from
    the first node in the list to the last node, but you cannot move from the last
    node to the first node.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 单链表是一个只有两个连续节点之间的指针的列表。它只能以单个方向遍历，也就是说，您可以从列表中的第一个节点移动到最后一个节点，但不能从最后一个节点移动到第一个节点。
- en: 'We can actually use the `node` class that we created earlier to implement a
    very simple singly linked list:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以使用之前创建的“node”类来实现一个非常简单的单链表：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next we link the nodes together so that they form a *chain*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将节点链接在一起，使它们形成一个*链*：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To traverse the list, you could do something like the following. We start by
    setting the variable `current` to the first item in the list:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历列表，您可以执行以下操作。我们首先将变量“current”设置为列表中的第一个项目：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the loop we print out the current element after which we set current to point
    to the next element in the list. We keep doing this until we have reached the
    end of the list.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，我们打印当前元素，然后将当前设置为指向列表中的下一个元素。我们一直这样做，直到我们到达列表的末尾。
- en: 'There are, however, several problems with this simplistic list implementation:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这种简单的列表实现存在几个问题：
- en: It requires too much manual work by the programmer
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员需要太多的手动工作
- en: It is too error-prone (this is a consequence of the first point)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这太容易出错了（这是第一个问题的结果）
- en: Too much of the inner workings of the list is exposed to the programmer
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表的内部工作方式对程序员暴露得太多
- en: We are going to address all these issues in the following sections.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下部分解决所有这些问题。
- en: Singly linked list class
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单链表类
- en: 'A list is clearly a separate concept from a node. So we start by creating a
    very simple class to hold our list. We will start with a constructor that holds
    a reference to the very first node in the list. Since this list is initially empty,
    we will start by setting this reference to `None`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表显然是一个与节点不同的概念。因此，我们首先创建一个非常简单的类来保存我们的列表。我们将从一个持有对列表中第一个节点的引用的构造函数开始。由于此列表最初为空，因此我们将首先将此引用设置为“None”：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Append operation
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加操作
- en: The first operation that we need to perform is to append items to the list.
    This operation is sometimes called an insert operation. Here we get a chance to
    hide away the `Node` class. The user of our `list` class should really never have
    to interact with Node objects. These are purely for internal use.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行的第一个操作是向列表附加项目。这个操作有时被称为插入操作。在这里，我们有机会隐藏“Node”类。我们的“list”类的用户实际上不应该与Node对象进行交互。这些纯粹是内部使用。
- en: 'A first shot at an `append()` method may look like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次尝试“append()”方法可能如下所示：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We encapsulate data in a node, so that it now has the next pointer attribute.
    From here we check if there are any existing nodes in the list (that is, does
    `self.tail` point to a Node). If there is none, we make the new node the first
    node of the list; otherwise, find the insertion point by traversing the list to
    the last node, updating the next pointer of the last node to the new node.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数据封装在一个节点中，因此它现在具有下一个指针属性。从这里开始，我们检查列表中是否存在任何现有节点（即“self.tail”指向一个节点）。如果没有，我们将新节点设置为列表的第一个节点；否则，通过遍历列表找到插入点，将最后一个节点的下一个指针更新为新节点。
- en: 'We can append a few items:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以附加一些项目：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'List traversal will work more or less like before. You will get the first element
    of the list from the list itself:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表遍历将更多或更少地像以前一样工作。您将从列表本身获取列表的第一个元素：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A faster append operation
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更快的附加操作
- en: 'There is a big problem with the append method in the previous section: it has
    to traverse the entire list to find the insertion point. This may not be a problem
    when there are just a few items in the list, but wait until you need to add thousands
    of items. Each append will be slightly slower than the previous one. A **O**(n)
    goes to prove how slow our current implementation of the `append` method will
    actually be.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，附加方法存在一个大问题：它必须遍历整个列表以找到插入点。当列表中只有几个项目时，这可能不是问题，但等到您需要添加成千上万个项目时再等等。每次附加都会比上一次慢一点。一个**O**(n)证明了我们当前的“append”方法实际上会有多慢。
- en: 'To fix this, we will store, not only a reference to the first node in the list,
    but also a reference to the last node. That way, we can quickly append a new node
    at the end of the list. The worst case running time of the append operation is
    now reduced from **O**(n) to **O**(1). All we have to do is make sure the previous
    last node points to the new node, that is about to be appended to the list. Here
    is our updated code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将存储的不仅是列表中第一个节点的引用，还有最后一个节点的引用。这样，我们可以快速地在列表的末尾附加一个新节点。附加操作的最坏情况运行时间现在从**O**(n)减少到**O**(1)。我们所要做的就是确保前一个最后一个节点指向即将附加到列表中的新节点。以下是我们更新后的代码：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Take note of the convention being used. The point at which we append new nodes
    is through `self.head`. The `self.tail` variable points to the first node in the
    list.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意正在使用的约定。我们附加新节点的位置是通过`self.head`。`self.tail`变量指向列表中的第一个节点。
- en: Getting the size of the list
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取列表的大小
- en: 'We would like to be able to get the size of the list by counting the number
    of nodes. One way we could do this is by traversing the entire list and increasing
    a counter as we go along:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过计算节点数来获取列表的大小。我们可以通过遍历整个列表并在遍历过程中增加一个计数器来实现这一点：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This works, but list traversal is potentially an expensive operation that we
    should avoid when we can. So instead, we shall opt for another rewrite of the
    method. We add a size member to the `SinglyLinkedList` class, initializing it
    to 0 in the constructor. Then we increment size by one in the `append` method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是可以的，但列表遍历可能是一个昂贵的操作，我们应该尽量避免。因此，我们将选择另一种重写方法。我们在`SinglyLinkedList`类中添加一个size成员，在构造函数中将其初始化为0。然后我们在`append`方法中将size增加一：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because we are now only reading the size attribute of the node object, and not
    using a loop to count the number of nodes in the list, we get to reduce the worst
    case running time from **O**(n) to **O**(1).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们现在只读取节点对象的size属性，而不使用循环来计算列表中的节点数，所以我们可以将最坏情况的运行时间从**O**(n)减少到**O**(1)。
- en: Improving list traversal
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进列表遍历
- en: 'If you notice how we traverse our list. That one place where we are still exposed
    to the `node` class. We need to use `node.data` to get the contents of the node
    and `node.next` to get the next node. But we mentioned earlier that client code
    should never need to interact with Node objects. We can achieve this by creating
    a method that returns a generator. It looks as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到我们如何遍历我们的列表。那里我们仍然暴露给`node`类的地方。我们需要使用`node.data`来获取节点的内容和`node.next`来获取下一个节点。但我们之前提到客户端代码不应该需要与Node对象进行交互。我们可以通过创建一个返回生成器的方法来实现这一点。它看起来如下：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now list traversal is much simpler and looks a lot better as well. We can completely
    ignore the fact that there is anything called a Node outside of the list:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在列表遍历变得简单得多，看起来也好得多。我们可以完全忽略列表之外有一个叫做Node的东西：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that since the `iter()` method yields the data member of the node, our
    client code doesn't need to worry about that at all.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于`iter()`方法产生节点的数据成员，我们的客户端代码根本不需要担心这一点。
- en: Deleting nodes
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除节点
- en: Another common operation that you would need to be able to do on a list is to
    delete nodes. This may seem simple, but we'd first have to decide how to select
    a node for deletion. Is it going to be by an index number or by the data the node
    contains? Here we will choose to delete a node by the data it contains.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表上的另一个常见操作是删除节点。这可能看起来很简单，但我们首先必须决定如何选择要删除的节点。是按索引号还是按节点包含的数据？在这里，我们将选择按节点包含的数据删除节点。
- en: 'The following is a figure of a special case considered when deleting a node
    from the list:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从列表中删除节点时考虑的一个特殊情况的图示：
- en: '![](assets/681a0c61-f4fc-4b58-bd9d-ff3ade3c9d61.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/681a0c61-f4fc-4b58-bd9d-ff3ade3c9d61.jpg)'
- en: When we want to delete a node that is between two other nodes, all we have to
    do is make the previous node directly to the successor of its next node. That
    is, we simply cut the node to be deleted out of the chain as in the preceding
    image.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要删除两个其他节点之间的节点时，我们所要做的就是将前一个节点直接指向其下一个节点的后继节点。也就是说，我们只需像前面的图像中那样将要删除的节点从链中切断。
- en: 'Here is the implementation of the `delete()` method may look like:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`delete()`方法的实现可能是这样的：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It should take a **O**(n) to delete a node.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 删除节点应该需要**O**(n)的时间。
- en: List search
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表搜索
- en: 'We may also need a way to check whether a list contains an item. This method
    is fairly easy to implement thanks to the `iter()` method we previously wrote.
    Each pass of the loop compares the current data to the data being searched for.
    If a match is found, `True` is returned, or else `False` is returned:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还需要一种方法来检查列表是否包含某个项目。由于我们之前编写的`iter()`方法，这种方法实现起来相当容易。循环的每一次通过都将当前数据与正在搜索的数据进行比较。如果找到匹配项，则返回`True`，否则返回`False`：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Clearing a list
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清空列表
- en: 'We may want a quick way to clear a list. Fortunately for us, this is very simple.
    All we do is clear the pointers `head` and `tail` by setting them to `None`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望快速清空列表。幸运的是，这非常简单。我们只需将指针`head`和`tail`设置为`None`即可：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In one fell swoop, we orphan all the nodes at the `tail` and `head` pointers
    of the list. This has a ripple effect of orphaning all the nodes in between.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一举两得，我们将列表的`tail`和`head`指针上的所有节点都变成了孤立的。这会导致中间所有的节点都变成了孤立的。
- en: Doubly linked lists
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表
- en: Now that we have a solid grounding on what a singly linked list is and the kind
    of operations that can be performed on it, we shall now turn our focus one notch
    higher to the topic of doubly linked lists.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对单向链表有了扎实的基础，知道了可以对其执行的操作类型，我们现在将把注意力转向更高一级的双向链表主题。
- en: 'A doubly linked list is somehow similar to a singly linked list in that we
    make use of the same fundamental idea of stringing nodes together. In a Singly
    linked list, there exists one link between each successive node. A node in a doubly
    linked list has two pointers: a pointer to the next node and a pointer to the
    previous node:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表在某种程度上类似于单向链表，因为我们利用了将节点串联在一起的相同基本思想。在单向链表中，每个连续节点之间存在一个链接。双向链表中的节点有两个指针：指向下一个节点和指向前一个节点的指针：
- en: '![](assets/48886177-4080-49b0-bc7b-0a8a995fc324.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/48886177-4080-49b0-bc7b-0a8a995fc324.jpg)'
- en: A node in a singly linked list can only determine the next node associated with
    it. But the referenced node or next node has no way of telling who is doing the
    referencing. The flow of direction is **only one way**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 单向链表中的节点只能确定与其关联的下一个节点。但是被引用的节点或下一个节点无法知道是谁在引用它。方向的流动是**单向的**。
- en: In a doubly linked list, we add to each node the ability to not only reference
    the next node but also the previous node.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在双向链表中，我们为每个节点添加了不仅引用下一个节点而且引用前一个节点的能力。
- en: 'Let''s examine the nature of the linkages that exist between two successive
    nodes for better understanding:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下两个连续节点之间存在的连接性质，以便更好地理解：
- en: '![](assets/03bff824-7bea-410e-acb8-a1d607bca4db.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/03bff824-7bea-410e-acb8-a1d607bca4db.jpg)'
- en: With the existence of two pointers that point to the next and previous nodes,
    doubly linked lists become equipped with certain capabilities.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在指向下一个和前一个节点的两个指针，双向链表具有某些能力。
- en: Doubly linked lists can be traversed in any direction. Depending on the operation
    being performed, a node within a doubly linked list can easily refer to its previous
    node where necessary without having to designate a variable to keep track of that
    node. Because a Singly linked list can only be traversed in one direction it may
    sometimes mean moving to the start or beginning of the list in order to effect
    certain changes buried within the list.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表可以在任何方向遍历。根据正在执行的操作，双向链表中的节点可以在必要时轻松地引用其前一个节点，而无需指定变量来跟踪该节点。因为单向链表只能在一个方向上遍历，有时可能意味着移动到列表的开始或开头，以便影响列表中隐藏的某些更改。
- en: Since there is immediate access to both next and previous nodes, deletion operations
    are much easier to perform, as you will see later on in this chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于立即可以访问下一个和前一个节点，删除操作要容易得多，后面在本章中会看到。
- en: A doubly linked list node
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表节点
- en: 'The Python code that creates a class to capture what a doubly linked list node
    is includes in its initializing method, the `prev`, `next`, and `data` instance
    variables. When a node is newly created, all these variables default to `None`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类来捕获双向链表节点的Python代码，在其初始化方法中包括`prev`、`next`和`data`实例变量。当新创建一个节点时，所有这些变量默认为`None`：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `prev` variable holds a reference to the previous node, while the `next`
    variable continues to hold a reference to the next node.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev`变量保存对前一个节点的引用，而`next`变量继续保存对下一个节点的引用。'
- en: Doubly linked list
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表
- en: 'It is still important to create a class that captures the data that our functions
    will be operating on:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然很重要的是创建一个类，以捕获我们的函数将要操作的数据：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For the purposes of enhancing the `size` method, we also set the `count` instance
    variable to 0\. `head` and `tail` will point to the head and tail of the list
    when we begin to insert nodes into the list.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强`size`方法，我们还将`count`实例变量设置为0。当我们开始向列表中插入节点时，`head`和`tail`将指向列表的头部和尾部。
- en: We adopt a new convention where `self.head` points to the beginner node of the
    list and `self.tail` points to the latest node added to the list. This is contrary
    to the convention we used in the singly linked list. There are no fixed rules
    as to the naming of the head and tail node pointers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采用了一个新的约定，其中`self.head`指向列表的起始节点，而`self.tail`指向列表中最新添加的节点。这与我们在单向链表中使用的约定相反。关于头部和尾部节点指针的命名没有固定的规则。
- en: Doubly linked lists also need to provide functions that return the size of the
    list, inserts into the list, and also deletes nodes from the list. We will be
    examining some of the code to do this. Let's commence with the `append` operation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 双向链表还需要提供返回列表大小、插入列表和从列表中删除节点的函数。我们将检查一些执行此操作的代码。让我们从`append`操作开始。
- en: Append operation
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追加操作
- en: 'During an `append` operation, it is important to check whether the `head` is
    `None`. If it is `None`, it means that the list is empty and should have the `head`
    set pointing to the just-created node. The `tail` of the list is also pointed
    at the new node through the head. By the end of these series of steps, `head`
    and `tail` will now be pointing to the same node:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`append`操作期间，重要的是检查`head`是否为`None`。如果是`None`，则意味着列表为空，并且应该将`head`设置为指向刚创建的节点。通过头部，列表的尾部也指向新节点。在这一系列步骤结束时，`head`和`tail`现在将指向同一个节点：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The following diagram illustrates the head and tail pointers of the doubly linked
    list when a new node is added to an empty list.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了在向空列表添加新节点时，双向链表的头部和尾部指针。
- en: '![](assets/4726485a-16d3-40e4-ae32-b63afef3b054.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4726485a-16d3-40e4-ae32-b63afef3b054.jpg)'
- en: 'The `else` part of the algorithm is only executed if the list is not empty.
    The new node''s previous variable is set to the tail of the list:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的`else`部分仅在列表不为空时执行。新节点的前一个变量设置为列表的尾部：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The tail''s next pointer (or variable) is set to the new node:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尾部的下一个指针（或变量）设置为新节点：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Lastly, we update the tail pointer to point to the new node:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更新尾部指针指向新节点：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since an `append` operation increases the number of nodes by one, we increase
    the counter by one:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`append`操作将节点数增加了一个，我们将计数器增加了一个：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A visual representation of the `append` operation is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`操作的视觉表示如下：'
- en: '![](assets/e7446f9f-dddb-4220-99f4-182bc7fe4416.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e7446f9f-dddb-4220-99f4-182bc7fe4416.jpg)'
- en: Delete operation
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除操作
- en: Unlike the singly linked list, where we needed to keep track of the previously
    encountered node anytime we traversed the whole length of the list, the doubly
    linked list avoids that whole step. This is made possible by the use of the previous
    pointer.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与单向链表不同，我们需要在遍历整个列表的时候跟踪先前遇到的节点，双向链表避免了这一步。这是通过使用前一个指针实现的。
- en: 'The algorithm for removing nodes from a doubly linked list caters for basically
    four scenarios before deletion of a node is completed. These are:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从双向链表中删除节点的算法在完成节点删除之前，为基本上四种情况提供了支持。这些是：
- en: When the search item is not found at all
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当根本找不到搜索项时
- en: When the search item is found at the very beginning of the list
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当搜索项在列表的开头找到时
- en: When the search item is found at the tail end of the list
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当搜索项在列表的尾部找到时
- en: When the search item is found somewhere in the middle of the list
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当搜索项在列表的中间找到时
- en: 'The node to be removed is identified when its `data` instance variable matches
    the data that is passed to the method to be used in the search for the node. If
    a matching node is found and subsequently removed, the variable `node_deleted`
    is set to `True`. Any other outcome results in `node_deleted` being set to `False`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当其`data`实例变量与传递给用于搜索节点的方法的数据匹配时，将识别要移除的节点。如果找到匹配的节点并随后删除，则将变量`node_deleted`设置为`True`。任何其他结果都会导致`node_deleted`被设置为`False`：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the `delete` method, the `current` variable is set to the head of the list
    (that is, it points to the `self.head` of the list). A set of `if... else` statements
    are then used to search the various parts of the list to find the node with the
    specified data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`delete`方法中，`current`变量被设置为列表的头部（即指向列表的`self.head`）。然后使用一组`if...else`语句搜索列表的各个部分，以找到具有指定数据的节点。
- en: 'The `head` node is searched first. Since `current` is pointing at `head`, if
    `current` is None, it is presumed that the list has no nodes for a search to even
    begin to find the node to be removed:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先搜索`head`节点。由于`current`指向`head`，如果`current`为None，则假定列表没有节点，甚至无法开始搜索要删除的节点：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, if `current` (which now points to head) contains the very data being
    searched for, then `self.head` is set to point to the `current` next node. Since
    there is no node behind head now, `self.head.prev` is set to `None`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果`current`（现在指向头部）包含正在搜索的数据，那么`self.head`被设置为指向`current`的下一个节点。由于现在头部后面没有节点了，`self.head.prev`被设置为`None`：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A similar strategy is adopted if the node to be removed is located at the tail
    end of the list. This is the third statement that searches for the possibility
    that the node to be removed might be located at the end of the list:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要删除的节点位于列表的尾部，将采用类似的策略。这是第三个语句，搜索要删除的节点可能位于列表末尾的可能性：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Lastly, the algorithm to find and remove a node loops through the list of nodes.
    If a matching node is found, `current`''s previous node is connected to current''s
    next node. After that step, `current`''s next node is connected to previous node
    of `current`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，查找并删除节点的算法循环遍历节点列表。如果找到匹配的节点，`current`的前一个节点将连接到`current`的下一个节点。在这一步之后，`current`的下一个节点将连接到`current`的前一个节点：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `node_delete` variable is then checked after all the `if-else` statements
    has been evaluated. If any of the `if-else` statements changed this variable,
    then it means a node has been deleted from the list. The count variable is therefore
    decremented by 1:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在评估所有`if-else`语句之后检查`node_delete`变量。如果任何`if-else`语句更改了这个变量，那么意味着从列表中删除了一个节点。因此，计数变量减1：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As an example of deleting a node that is buried within a list, assume the existence
    of three nodes, A, B, and C. To delete node B in the middle of the list, we will
    essentially make A point to C as its next node, while making C point to A as its
    previous node:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 作为删除列表中嵌入的节点的示例，假设存在三个节点A、B和C。要删除列表中间的节点B，我们将使A指向C作为它的下一个节点，同时使C指向A作为它的前一个节点：
- en: '![](assets/95e53e49-1f8e-4c1c-82ae-950c6bd20d8b.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/95e53e49-1f8e-4c1c-82ae-950c6bd20d8b.jpg)'
- en: 'After such an operation, we end up with the following list:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的操作之后，我们得到以下列表：
- en: '![](assets/290796b6-c426-4da7-81d2-0b4fd7fc3a65.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/290796b6-c426-4da7-81d2-0b4fd7fc3a65.jpg)'
- en: List search
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表搜索
- en: 'The search algorithm is similar to that of the `search` method in a singly
    linked list. We call the internal method `iter()` to return the data in all the
    nodes. As we loop through the data, each is matched against the data passed into
    the `contain` method. If there is a match, we return `True`, or else we return
    `False` to symbolize that no match was found:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索算法类似于单向链表中`search`方法的算法。我们调用内部方法`iter()`返回所有节点中的数据。当我们循环遍历数据时，每个数据都与传入`contain`方法的数据进行匹配。如果匹配，则返回`True`，否则返回`False`以表示未找到匹配项：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Our doubly linked list has a **O**(1) for the `append` operation and **O**(n)
    for the `delete` operation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的双向链表对于`append`操作具有**O**(1)，对于`delete`操作具有**O**(n)。
- en: Circular lists
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环列表
- en: A circular list is a special case of a linked list. It is a list where the endpoints
    are connected. That is, the last node in the list points back to the first node.
    Circular lists can be based on both singly and doubly linked lists. In the case
    of a doubly linked circular list, the first node also needs to point to the last
    node.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 循环列表是链表的一种特殊情况。它是一个端点连接的列表。也就是说，列表中的最后一个节点指向第一个节点。循环列表可以基于单向链表和双向链表。对于双向循环链表，第一个节点还需要指向最后一个节点。
- en: Here we are going to look at an implementation of a singly linked circular list.
    It should be straightforward to implement a doubly linked circular list, once
    you have grasped the basic concepts.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看一个单向循环链表的实现。一旦你掌握了基本概念，实现双向循环链表就应该很简单了。
- en: We can reuse the `node` class that we created in the section on singly linked
    lists. As a matter of fact, we can reuse most parts of the `SinglyLinkedList`
    class as well. So we are going to focus on the methods where the circular list
    implementation differs from the normal singly linked list.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用我们在单链表部分创建的`node`类。事实上，我们也可以重用`SinglyLinkedList`类的大部分部分。因此，我们将专注于循环列表实现与普通单链表不同的方法。
- en: Appending elements
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加元素
- en: 'When we append an element to the circular list, we need to make sure that the
    new node points back to the tail node. This is demonstrated in the following code.
    There is one extra line as compared to the singly linked list implementation:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向循环列表附加一个元素时，我们需要确保新节点指向尾节点。这在以下代码中得到了证明。与单链表实现相比，多了一行额外的代码：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Deleting an element
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除元素
- en: 'We may think that we can follow the same principle as for append and simply
    make sure the head points to the tail. This would give us the following implementation:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能认为我们可以遵循与附加相同的原则，并确保头部指向尾部。这将给我们以下实现：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As previously, there is just a single line that needs to change. It is only
    when we remove the tail node that we need to make sure that the head node is updated
    to point to the new tail node.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，只有一行需要更改。只有在删除尾节点时，我们需要确保头节点被更新为指向新的尾节点。
- en: However, there is a serious problem with this code. In the case of a circular
    list, we cannot loop until current becomes `None`, since that will never happen.
    If you delete an existing node, you wouldn't see this, but try deleting a nonexistent
    node and you will get stuck in an indefinite loop.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码存在一个严重的问题。在循环列表的情况下，我们不能循环直到当前变为`None`，因为那永远不会发生。如果您删除一个现有节点，您不会看到这一点，但是尝试删除一个不存在的节点，您将陷入无限循环。
- en: 'We thus need to find a different way to control the `while` loop. We cannot
    check whether current has reached head, because then it will never check the last
    node. But we could use `prev`, since it lags behind current by one node. There
    is a special case, however. The very first loop iteration, `current` and `prev`,
    will point to the same node, namely the tail node. We want to ensure that the
    loop does run here, since we need to take the one node list into consideration.
    The updated `delete` method now looks as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要找到一种不同的方法来控制`while`循环。我们不能检查当前是否已经到达头部，因为那样它就永远不会检查最后一个节点。但是我们可以使用`prev`，因为它落后于当前一个节点。然而，有一个特殊情况。在第一个循环迭代中，`current`和`prev`将指向同一个节点，即尾节点。我们希望确保循环在这里运行，因为我们需要考虑只有一个节点的情况。更新后的`delete`方法现在如下所示：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Iterating through a circular list
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历循环列表
- en: 'You do not need to modify the `iter()` method. It will work perfectly well
    for our circular list. But you do need to put in an exit condition when you are
    iterating through the circular list, otherwise your program will get stuck in
    a loop. Here is a way you could do this, by using a counter variable:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要修改`iter()`方法。它对于我们的循环列表可以完美地工作。但是在遍历循环列表时，您需要设置一个退出条件，否则您的程序将陷入循环。以下是一种方法，可以使用计数器变量来实现：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once we have printed out 1,000 elements, we break out of the loop.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们打印出1,000个元素，我们就跳出循环。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have looked at linked lists. We have studied the concepts
    that underlie lists, such as nodes and pointers to other nodes. We implemented
    the major operations that occur on these types of list and saw how their worst
    case running times compare.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经研究了链表。我们研究了构成列表的概念，如节点和指向其他节点的指针。我们实现了在这些类型的列表上发生的主要操作，并看到了它们的最坏情况运行时间是如何比较的。
- en: 'In the next chapter, we are going to look at two other data structures that
    are usually implemented using lists: stacks and queues.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看两种通常使用列表实现的其他数据结构：栈和队列。
