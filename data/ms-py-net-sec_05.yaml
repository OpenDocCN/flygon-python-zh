- en: Analyzing Network Traffic
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析网络流量
- en: This chapter will introduce you to some of the basics of analyzing network traffic
    using the pcapy and scapy modules in Python. These modules provide an investigator
    with the ability to write small Python scripts that can investigate network traffic.
    An investigator can write scapy scripts to investigate either realtime traffic
    by sniffing a promiscuous network interface, or load previously-captured pcap
    files.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍使用Python中的pcapy和scapy模块分析网络流量的一些基础知识。这些模块为调查员提供了编写小型Python脚本来调查网络流量的能力。调查员可以编写scapy脚本来调查通过嗅探混杂网络接口的实时流量，或者加载先前捕获的pcap文件。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Capturing and injecting packets on the network with the pcapy package
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pcapy包在网络上捕获和注入数据包
- en: Capturing, analyzing, manipulating, and injecting network packets with the scapy
    package
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用scapy包捕获、分析、操作和注入网络数据包
- en: Port-scanning and traceroute in a network with the scapy package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用scapy包在网络中进行端口扫描和跟踪路由
- en: Reading a pcap file with the scapy package
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用scapy包读取pcap文件
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Examples and source code for this chapter are available in the GitHub repository
    in the `chapter 5` folder: [https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security](https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例和源代码可在GitHub存储库的`第5章`文件夹中找到：[https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security](https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security)。
- en: You will need to install a Python distribution on your local machine and have
    some basic knowledge about packets, capturing, and sniffing networks with tools
    such as Wireshark. It is also recommended to use a Unix distribution to facilitate
    the installation and use of scapy and the execution of commands.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在本地计算机上安装Python发行版，并对数据包、捕获和使用诸如Wireshark之类的工具嗅探网络具有一些基本知识。还建议使用Unix发行版以便于安装和使用scapy以及执行命令。
- en: Capturing and injecting packets with pcapy
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pcapy捕获和注入数据包
- en: In this section, you will learn the basics of pcapy and how to capture and read
    headers from packets.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习pcapy的基础知识以及如何捕获和读取数据包的头部。
- en: Introduction to pcapy
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pcapy简介
- en: Pcapy is a Python extension module that interfaces with the `libpcap` packet
    capture library. Pcapy enables Python scripts to capture packets on the network.
    Pcapy is highly effective when used in conjunction with other collections of Python
    classes for constructing and packet-handling.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Pcapy是一个Python扩展模块，它与`libpcap`数据包捕获库进行接口。Pcapy使Python脚本能够在网络上捕获数据包。Pcapy在与其他Python类集合一起使用构建和处理数据包时非常有效。
- en: You can download the source code and the latest stable and development version
    at [https://github.com/CoreSecurity/pcapy](https://github.com/CoreSecurity/pcapy).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/CoreSecurity/pcapy](https://github.com/CoreSecurity/pcapy)下载源代码和最新的稳定和开发版本。
- en: 'To install `python-pcapy` on the Ubuntu linux distribution, run the following
    commands:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Ubuntu Linux发行版上安装`python-pcapy`，请运行以下命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Capturing packets with pcapy
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pcapy捕获数据包
- en: We can use the `open_live` method in the pcapy interface to capture packets
    in a specific device and we can specify the number of bytes per capture and other
    parameters such as promiscuous mode and timeout.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用pcapy接口中的`open_live`方法来捕获特定设备中的数据包，并且可以指定每次捕获的字节数以及其他参数，如混杂模式和超时。
- en: In the following example, we'll count the packets that are capturing the eht0
    interface.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将计算捕获eht0接口的数据包。
- en: 'You can find the following code in the **`capturing_packets.py` **file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在**`capturing_packets.py`**文件中找到以下代码：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Reading headers from packets
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据包中读取头部
- en: In the following example, we are capturing packets in a specific device(`eth0`),
    and for each packet we obtain the header and payload for extracting information
    about Mac addresses, IP headers, and protocol.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们正在捕获特定设备（`eth0`）中的数据包，并且对于每个数据包，我们获取头部和有效载荷，以提取有关Mac地址、IP头和协议的信息。
- en: 'You can find the following code in the **`reading_headers.py` **file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在**`reading_headers.py`**文件中找到以下代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Capturing and injecting packets with scapy
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用scapy捕获和注入数据包
- en: The analysis of network traffic is the process by which intercept packets can
    be intercepted that are exchanged between two hosts, knowing the details of the
    systems that intervene in the communication. The message and the duration of the
    communication are some of the valuable information that an attacker who is listening
    in the network medium can obtain.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 网络流量分析是拦截两个主机之间交换的数据包的过程，了解介入通信的系统的细节。消息和通信持续时间是监听网络媒介的攻击者可以获取的一些有价值的信息。
- en: What can we do with scapy?
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们可以用scapy做什么？
- en: 'Scapy is a Swiss-army knife for network manipulation. For this reason, it can
    be used in many tasks and areas:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy是用于网络操作的瑞士军刀。因此，它可以用于许多任务和领域：
- en: Research in communications networks
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信网络研究
- en: Security tests and ethical hacking to manipulate the traffic generated
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全测试和道德黑客以操纵生成的流量
- en: Package-capture, processing, and handling
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据包捕获、处理和处理
- en: Generating packages with a specific protocol
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定协议生成数据包
- en: Showing detailed information about a certain package
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示有关特定包的详细信息
- en: Packet-capturing, crafting, and manipulation
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据包捕获、制作和操作
- en: Network Traffic Analysis Tools
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络流量分析工具
- en: Fuzzing protocols and IDS/IPS testing
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊协议和IDS/IPS测试
- en: Wireless discovery tools
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无线发现工具
- en: Scapy advantages and disadvantages
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scapy的优点和缺点
- en: 'Following are some of the advantages of Scapy:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Scapy的一些优点：
- en: Supports multiple network protocols
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多种网络协议
- en: Its API provides the classes needed to capture packets across a network segment
    and execute a function each time a packet is captured
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其API提供了在网络段中捕获数据包并在捕获每个数据包时执行函数所需的类
- en: It can be executed in the command interpreter mode or it can also be used from
    scripts in Python programmatically
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在命令解释器模式下执行，也可以从Python脚本中以编程方式使用
- en: It allows us to manipulate network traffic at a very low level
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许我们在非常低的级别上操纵网络流量
- en: It allows us to use protocol stacks and combine them
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许我们使用协议堆栈并将它们组合起来
- en: It allows us to configure all the parameters of each protocol
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许我们配置每个协议的所有参数
- en: 'Also, Scapy has some weaknesses:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Scapy也有一些弱点：
- en: Can't handle a large number of packets simultaneously
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法同时处理大量数据包
- en: Partial support for certain complex protocols
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对某些复杂协议的部分支持
- en: Introduction to scapy
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scapy简介
- en: '`Scapy` is a module written in Python to manipulate data packages with support
    for multiple network protocols. It allows the creation and modification of network
    packets of various types, implements functions to passively capture and sniff
    packets, and then executes actions on these packets.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scapy`是用Python编写的模块，用于操作支持多种网络协议的数据包。它允许创建和修改各种类型的网络数据包，实现了捕获和嗅探数据包的功能，然后对这些数据包执行操作。'
- en: '`Scapy` is a software specialized in the manipulation of network packets and
    frames. Scapy is written in the Python programming language and can be used interactively,
    with its **CLI (Command-Line Interpreter)**, or as a library in our programs written
    in Python.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scapy`是一种专门用于操作网络数据包和帧的软件。Scapy是用Python编程语言编写的，可以在其**CLI（命令行解释器）**中交互使用，也可以作为Python程序中的库使用。'
- en: '**Scapy installation:** I recommend using Scapy on a Linux system, as it was
    designed with Linux in mind.The newest version of Scapy does support Windows,
    but for the purpose of this chapter, I assume you are using a linux distribution
    that has a fully-functioning Scapy installation. To install Scapy, go to [http://www.secdev.org/projects/scapy](http://www.secdev.org/projects/scapy).
    The installation instructions are perfectly detailed in the official installation
    guide: [https://scapy.readthedocs.io/en/latest/](https://scapy.readthedocs.io/en/latest/)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scapy安装：**我建议在Linux系统上使用Scapy，因为它是为Linux设计的。最新版本的Scapy确实支持Windows，但在本章中，我假设您使用的是具有完全功能的Scapy安装的Linux发行版。要安装Scapy，请访问[http://www.secdev.org/projects/scapy](http://www.secdev.org/projects/scapy)。安装说明在官方安装指南中有详细说明：[https://scapy.readthedocs.io/en/latest/](https://scapy.readthedocs.io/en/latest/)'
- en: Scapy commands
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scapy命令
- en: 'Scapy provides us with many commands to investigate a network. We can use scapy
    in two ways: interactively within a terminal window or programmatically from a
    Python script by importing it as a library.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy为我们提供了许多用于调查网络的命令。我们可以以两种方式使用Scapy：在终端窗口中交互式使用，或者通过将其作为Python脚本的库导入来以编程方式使用。
- en: 'These are the commands that may be useful to show in detail the operation of
    scapy:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可能有用的命令，可以详细显示Scapy的操作：
- en: '`**ls()**`: Displays all the protocols supported by scapy'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**ls()**`：显示Scapy支持的所有协议'
- en: '`**lsc()**`: Displays the list of commands and functions supported by scapy'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**lsc()**`：显示Scapy支持的命令和函数列表'
- en: '`**conf**`: Displays all configuration options'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**conf**`：显示所有配置选项'
- en: '`**help()**`: Displays help on a specific command, for example, help(sniff)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**help()**`：显示特定命令的帮助信息，例如，help(sniff)'
- en: '`**show()**`: Displays the details of a specific packet, for example, Newpacket.show()'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**show()**`：显示特定数据包的详细信息，例如，Newpacket.show()'
- en: 'Scapy supports about 300 network protocols. We can have an idea with the **ls()**
    command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy支持大约300种网络协议。我们可以通过**ls()**命令来了解一下：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The screenshot shows an execution of the ls() command where we can see some
    of the protocols supported by scapy:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕截图显示了ls()命令的执行，我们可以看到Scapy支持的一些协议：
- en: '![](assets/edfaf3de-5216-4501-a3f3-0028e4b2e7dd.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/edfaf3de-5216-4501-a3f3-0028e4b2e7dd.png)'
- en: 'We can see the parameters that can be sent in a certain layer if we execute
    the **ls()** command, in parentheses we indicate the layer on which we want more
    information:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行**ls()**命令，可以看到可以在特定层发送的参数，括号中指示我们想要更多信息的层：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next screenshot shows an execution of the **ls(TCP)** command, where we
    can see fields supported by the TCP protocol in scapy:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个屏幕截图显示了**ls(TCP)**命令的执行，我们可以看到Scapy中TCP协议支持的字段：
- en: '![](assets/1804705b-5e6a-46f0-ae6d-4a4521af6678.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1804705b-5e6a-46f0-ae6d-4a4521af6678.png)'
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With the `lsc()` command, we can see the functions available in scapy:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`lsc()`命令，我们可以看到Scapy中可用的函数：
- en: '![](assets/3b545bf7-fec8-4173-921b-7ac83b913c65.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3b545bf7-fec8-4173-921b-7ac83b913c65.png)'
- en: Scapy helps us to create custom packets in any of the layers of the TCP/IP protocol.
    In the following example, we create ICMP/IP packets in an interactive Scapy shell.
    The packages are created by layers starting from the lowest layer at the physical
    level (Ethernet) until reaching the data layer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy帮助我们在TCP/IP协议的任何一层中创建自定义数据包。在下面的示例中，我们在交互式Scapy shell中创建了ICMP/IP数据包。数据包是通过从物理层（以太网）开始的层创建的，直到达到数据层。
- en: 'This is the structure scapy manages by layers:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Scapy通过层管理的结构：
- en: '![](assets/8b6047ac-e6a8-4c20-ab8f-b688e9039617.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8b6047ac-e6a8-4c20-ab8f-b688e9039617.png)'
- en: In Scapy, a layer usually represents a protocol. Network protocols are structured
    in stacks, where each step consists of a layer or protocol. A network pack consists
    of multiple layers, where each layer is responsible for a part of the communication.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scapy中，一个层通常代表一个协议。网络协议以堆栈的形式结构化，每一步都由一个层或协议组成。网络包由多个层组成，每个层负责通信的一部分。
- en: A packet in Scapy is a set of structured data ready to be sent to the network.
    Packets must follow a logical structure, according to the type of communication
    you want to simulate. If you want to send a TCP/IP packet, you must follow it
    the protocol rules defined in the TCP/IP standard.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scapy中，数据包是一组结构化数据，准备好发送到网络。数据包必须遵循逻辑结构，根据您想要模拟的通信类型。如果要发送TCP/IP数据包，必须遵循TCP/IP标准中定义的协议规则。
- en: By default, `IP layer()` is configured as a destination IP of 127.0.0.1, which
    refers to the local machine where Scapy is running. If we want the packet to be
    sent to another IP or domain, we will have to configure the IP layer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`IP layer()`被配置为目标IP为127.0.0.1，这指的是Scapy运行的本地机器。如果我们希望将数据包发送到另一个IP或域，我们将不得不配置IP层。
- en: 'The following command will create a packet in the IP and ICMP layers:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将在IP和ICMP层创建一个数据包：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, we can create a packet over other layers:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以在其他层创建数据包：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With the `show()` methods, we can see information of the detail of a certain
    package. The difference between `show()` and `show2()` is that the `show2()` function
    shows the package as it is sent by the network:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`show()`方法，我们可以查看特定数据包的详细信息。`show()`和`show2()`之间的区别在于，`show2()`函数显示的是数据包在网络上发送的样子：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can see the structure of a particular package:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到特定数据包的结构：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Scapy creates and analyzes packages layer by layer. The packages in scapy are
    Python dictionaries, so each package is a set of nested dictionaries, and each
    layer is a child dictionary of the main layer. The **summary()** method will provide
    the details of the layers of each package:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy逐层创建和分析数据包。Scapy中的数据包是Python字典，因此每个数据包都是一组嵌套的字典，每个层都是主层的子字典。**summary()**方法将提供每个数据包层的详细信息：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With these functions, we see the package received in a more friendly and simplified
    format:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些功能，我们可以以更友好和简化的格式看到接收到的数据包：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Sending packets with scapy
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用scapy发送数据包
- en: 'To send a package in scapy, we have two methods:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送scapy中的数据包，我们有两种方法：
- en: '**send():** Sends layer-3 packets'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**send():**发送第三层数据包'
- en: '**sendp():** Sends layer-2 packets'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sendp():**发送第二层数据包'
- en: We will use `send()` if we do it from layer 3 or IP and trust the routes of
    the operating system itself to send it. We will use `sendp()` if we need control
    at layer 2 (for example, Ethernet).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从第三层或IP发送数据包并信任操作系统本身的路由来发送它，我们将使用`send()`。如果我们需要在第二层（例如以太网）进行控制，我们将使用`sendp()`。
- en: 'The main arguments for the send commands are:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 发送命令的主要参数是：
- en: '**iface:** The interface to send packets.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iface:**发送数据包的接口。'
- en: '**Inter:** The time, in seconds, that we want to pass between package and package
    sent.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Inter:**我们希望在发送数据包之间经过的时间，以秒为单位。'
- en: '**loop**: To keep sending packets endlessly, set this to 1\. If it is different
    from 0, send the packet, or list of packages, in an infinite loop until we stop
    it by pressing *Ctrl* + *C*.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**loop:**设置为1以无限地发送数据包。如果不为0，则以无限循环发送数据包，直到我们按下*Ctrl* + *C*停止。'
- en: '**packet**: Packet or a list of packets.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**packet:**数据包或数据包列表。'
- en: '**verbose**: It allows us to change the log level or even deactivate it completely
    (with the value of 0).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**verbose:**允许我们更改日志级别，甚至完全停用（值为0）。'
- en: 'Now we send the previous packet in **layer-3** with the send method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用send方法发送前面的数据包**第三层**：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To send a **layer-2** packet, we have to add an Ethernet layer and provide
    the correct interface to send the packet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 发送**第二层**数据包，我们必须添加一个以太网层，并提供正确的接口来发送数据包：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the `sendp()` function, we send the packet to its corresponding destination:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sendp()`函数，我们将数据包发送到相应的目的地：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the inter and loop options, we can send the packet indefinitely every
    N seconds in the form of a loop:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用inter和loop选项，我们可以以循环的形式每N秒无限地发送数据包：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `sendp (...)` function works exactly like `send (...)` ,the difference is
    that it works in layer 2\. This means that  system routes are not necessary, the
    information will be sent directly through the network adapter indicated as a parameter
    of the function. The information will be sent although there is apparently no
    communication through any system route.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendp (...)`函数的工作方式与`send (...)`完全相同，不同之处在于它在第二层中工作。这意味着不需要系统路由，信息将直接通过作为函数参数指示的网络适配器发送。即使通过任何系统路由似乎没有通信，信息也将被发送。'
- en: 'This function also allows us to specify the physical or MAC addresses of the
    destination network card. If we indicate the addresses, scapy will try to resolve
    them automatically with both local and remote addresses:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数还允许我们指定目标网络卡的物理或MAC地址。如果我们指定地址，scapy将尝试自动解析本地和远程地址：
- en: '![](assets/8229382d-c9e7-423e-a855-1fb4eadbb0e7.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8229382d-c9e7-423e-a855-1fb4eadbb0e7.png)'
- en: The send and `sendp` functions allow us to send the information we need to the
    network, but it does not allow us to receive the answers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`send`和`sendp`函数允许我们将所需的信息发送到网络，但不允许我们接收答案。'
- en: 'There are many ways to receive responses from the packages we generate, but
    the most useful for the interactive mode is the `sr` family of functions (from
    the English acronym: Send and Receive).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以接收我们生成的数据包的响应，但对于交互模式最有用的是`sr`函数系列（来自英文缩写：发送和接收）。
- en: We can do the same operation with a Python script. First we need import the
    `scapy` module.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Python脚本执行相同的操作。首先，我们需要导入`scapy`模块。
- en: 'You can find the following code in the `**scapy_icmp_google.py**` file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`**scapy_icmp_google.py**`文件中找到以下代码：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The family of functions for the send and receive packets include the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 用于发送和接收数据包的函数系列包括以下内容：
- en: '**sr (...):** Send and receive a packet, or list of packages to the network.
    Wait until a response has been received for all sent packets. It is important
    to note that this function works in layer 3\. In other words, to know how to send
    the packages, use the system''s routes. If there is no route to send the package(s)
    to the desired destination, it cannot be sent.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sr (...):**发送并接收数据包，或数据包列表到网络。等待所有发送的数据包都收到响应。重要的是要注意，此函数在第三层中工作。换句话说，要知道如何发送数据包，请使用系统的路由。如果没有路由将数据包发送到所需的目的地，它将无法发送。'
- en: '**sr1 (...)**: It works the same as the `sr (...)` function except that it
    only captures the first response received and ignores others, if any.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sr1 (...)**：与`sr (...)`函数的工作方式相同，只是它只捕获收到的第一个响应，并忽略其他响应（如果有）。'
- en: '**srp (...)**: It works the same as the `sr (...)` function but in layer 2\.
    That is to say, it allows us to send the information through a specific network
    card. The information will always be sent, even if there is no route for it.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**srp (...)**：它的操作与`sr (...)`函数相同，但在第2层。也就是说，它允许我们通过特定的网络卡发送信息。即使没有路由，信息也会被发送。'
- en: '**srp1 (...):** Its operation is identical to the `sr1 (...)` function but
    in layer 2.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**srp1 (...):** 其操作与`sr1 (...)`函数相同，但在第2层。'
- en: '**srbt (...)**: Sends information through a Bluetooth connection.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**srbt (...)**：通过蓝牙连接发送信息。'
- en: '**srloop (...)**: Allow us to send and receive information `N` times. That
    is, we can tell you to send one package three times and, therefore, we will receive
    the response to the three packages, in consecutive order. It also allows us to
    specify the actions to be taken when a package is received and when no response
    is received.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**srloop (...)**：允许我们发送和接收信息`N`次。也就是说，我们可以告诉它发送一个包三次，因此，我们将按顺序接收三个包的响应。它还允许我们指定在接收到包时要采取的操作以及在没有收到响应时要采取的操作。'
- en: '**srploop (...)**: Same as `srloop` but works in layer 2.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**srploop (...)**：与`srloop`相同，但在第2层工作。'
- en: If we want to send and receive packages with the possibility to see the response
    package, the srp1 function can be useful.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要发送和接收数据包，并有可能看到响应数据包，那么srp1函数可能会有用。
- en: 'In the following example, we build an ICMP packet and send with `sr1`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们构建了一个ICMP数据包，并使用`sr1`发送：
- en: '![](assets/d3c98aff-84ce-498f-a79d-550ff872e03b.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d3c98aff-84ce-498f-a79d-550ff872e03b.png)'
- en: This package is the answer to a TCP connection to Google.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据包是对Google的TCP连接的回应。
- en: 'We can see that it has three layers (Ethernet, IP, and TCP):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它有三层（以太网，IP和TCP）：
- en: '![](assets/9e4cd29a-9d7d-4782-b8f2-c21fb5f1e509.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9e4cd29a-9d7d-4782-b8f2-c21fb5f1e509.png)'
- en: Packet-sniffing with scapy
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用scapy进行数据包嗅探
- en: Most networks use broadcasting technology (view info), which means that each
    packet that a device transmits over the network can be read by any other device
    connected to the network.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络使用广播技术（查看信息），这意味着设备在网络上传输的每个数据包都可以被连接到网络的任何其他设备读取。
- en: WiFi networks and networks with a HUB device use this approach, however smarted
    devices such as routers and switches will only route and pass packets to the machines
    available in their route table. More information about broadcast networks can
    be found at [https://en.wikipedia.org/wiki/Broadcasting_(networking)](https://en.wikipedia.org/wiki/Broadcasting_(networking)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: WiFi网络和带有HUB设备的网络使用这种方法，但是路由器和交换机等智能设备只会将数据包路由并传递给其路由表中可用的机器。有关广播网络的更多信息可以在[https://en.wikipedia.org/wiki/Broadcasting_(networking)](https://en.wikipedia.org/wiki/Broadcasting_(networking))找到。
- en: In practice, all computers except the recipient of the message will realize
    that the message is not intended for them and ignore it. However, many computers
    can be programmed to see each message that crosses the network.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，除了消息的接收者之外的所有计算机都会意识到消息不是为它们而设计的，并将其忽略。然而，许多计算机可以被编程为查看通过网络传输的每条消息。
- en: One of the features offered by scapy is to sniff the network packets passing
    through a interface. Let's create a simple Python script to sniff traffic on your
    local machine network interface.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: scapy提供的一个功能是嗅探通过接口传递的网络数据包。让我们创建一个简单的Python脚本来嗅探本地机器网络接口上的流量。
- en: 'Scapy provides a method for sniffing packets and dissecting their contents:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy提供了一种嗅探数据包并解析其内容的方法：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With the sniff function, we can capture packets in the same way as tools such
    as tcpdump or Wireshark do, indicating the network interface from which we want
    to collect the traffic it generates and a counter that indicates the number of
    packets we want to capture:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用嗅探函数，我们可以像tcpdump或Wireshark等工具一样捕获数据包，指示我们要收集流量的网络接口以及一个计数器，指示我们要捕获的数据包数量：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we are going to see each parameter of the sniff function in detail. The
    arguments for the **sniff()** method are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将详细介绍嗅探函数的每个参数。**sniff()**方法的参数如下：
- en: '**count**: Number of packets to capture, but 0 means infinity'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**count**：要捕获的数据包数量，但0表示无限'
- en: '**iface**: Interface to sniff; sniff for packets only on this interface'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iface**：要嗅探的接口；仅在此接口上嗅探数据包'
- en: '**prn**: Function to run on each packet'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**prn**：要在每个数据包上运行的函数'
- en: '**store**: Whether to store or discard the sniffed packets; set to 0 when we
    only need to monitor them'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**store**：是否存储或丢弃嗅探到的数据包；当我们只需要监视它们时设置为0'
- en: '**timeout**: Stops sniffing after a given time; the default value is none'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**timeout**：在给定时间后停止嗅探；默认值为none'
- en: '**filter**: Takes BPF syntax filters to filter sniffing'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**filter**：采用BPF语法过滤器来过滤嗅探'
- en: 'We can highlight the `prn` parameter that provides the function to apply to
    each packet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以突出显示`prn`参数，该参数提供了要应用于每个数据包的函数：
- en: '![](assets/412d3fa6-d502-4715-9680-bdc7a1dc9549.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/412d3fa6-d502-4715-9680-bdc7a1dc9549.png)'
- en: This parameter will be present in other many functions and, as can be seen in
    the documentation, refers to a function as an input parameter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数将出现在许多其他函数中，并且正如文档中所述，它是指一个函数作为输入参数。
- en: In the case of the `sniff()` function, this function will be applied to each
    captured packet. In this way, each time the `sniff()` function intercepts a packet,
    it will call this function with the intercepted packet as a parameter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sniff()`函数的情况下，这个函数将被应用于每个捕获的数据包。这样，每当`sniff()`函数拦截一个数据包时，它将以拦截的数据包作为参数调用这个函数。
- en: 'This functionality gives us great power, imagine that we want to build a script
    that intercepts all communications and stores all detected hosts in the network.
    Using this feature would be very simple:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能给了我们很大的力量，想象一下，我们想要构建一个拦截所有通信并存储网络中所有检测到的主机的脚本。使用这个功能将会非常简单：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the following example, we can see the result of executing the `lambda` function
    after capturing packets in the eth0 interface:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们可以看到在eth0接口捕获数据包后执行`lambda`函数的结果：
- en: '![](assets/6b4b64e9-85fd-4437-b4ef-3ad8a1fd5a7e.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6b4b64e9-85fd-4437-b4ef-3ad8a1fd5a7e.png)'
- en: In the following example, we use the sniff method within the `scapy` module.
    We are using this method for capturing packets at the `eth0` interface. Inside
    the `print_packet` function, we are obtaining the IP layer of the packet.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们使用`scapy`模块中的sniff方法。我们正在使用此方法来捕获`eth0`接口的数据包。在`print_packet`函数内，我们正在获取数据包的IP层。
- en: 'You can find the following code in the **`sniff_main_thread.py` **file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在**`sniff_main_thread.py`**文件中找到以下代码：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the following example, we use the sniff method within the `scapy` module.
    This method takes as parameters the interface on which you want to capture the
    packets, and the filter parameter is used to specify which packets you want to
    filter. The prn parameter specifies which function to call and sends the packet
    as a parameter to the function. In this case, our custom function is `sniffPackets`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们使用`scapy`模块中的sniff方法。该方法的参数是您想要捕获数据包的接口，filter参数用于指定要过滤的数据包。prn参数指定要调用的函数，并将数据包作为参数发送到函数。在这种情况下，我们自定义的函数是`sniffPackets`。
- en: Inside the `sniffPackets` function, we are checking whether the sniffed packet
    has an IP layer, if it has an IP layer then we store the source, destination,
    and TTL values of the sniffed packet and print them out.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sniffPackets`函数内，我们正在检查捕获的数据包是否具有IP层，如果有IP层，则我们存储捕获的数据包的源、目的地和TTL值，并将它们打印出来。
- en: 'You can find the following code in the **`sniff_packets.py` **file:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在**`sniff_packets.py`**文件中找到以下代码：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using Lamda functions with scapy
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用scapy的Lambda函数
- en: 'Another interesting feature of the `sniff` function is that it has the "`prn`"
    attribute, which allows us to execute a function each time a packet is captured.
    It is very useful if we want to manipulate and re-inject data packets:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`sniff`函数的另一个有趣特性是它具有“`prn`”属性，允许我们每次捕获数据包时执行一个函数。如果我们想要操作和重新注入数据包，这非常有用：'
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For example, if we want capture n packets for the TCP protocol,we can do that
    with the sniff method:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要捕获TCP协议的n个数据包，我们可以使用sniff方法来实现：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this instruction, we are capturing 100 packets for the TCP protocol:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在此指令中，我们正在捕获TCP协议的100个数据包：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the following example, we see how we can apply custom actions on captured
    packets.We define a `customAction` method that takes a packet as a parameter.
    For each packet captured by the `sniff` function, we call this method and increment `packetCount`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们看到了如何对捕获的数据包应用自定义操作。我们定义了一个`customAction`方法，该方法以数据包作为参数。对于`sniff`函数捕获的每个数据包，我们调用此方法并递增`packetCount`。
- en: 'You can find the following code in the** `sniff_packets_customAction.py` **file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在**`sniff_packets_customAction.py`**文件中找到以下代码：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Also, we can monitor ARP packets with the `sniff` function and **ARP filter.**
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以使用`sniff`函数和**ARP过滤**来监视ARP数据包。
- en: 'You can find the following code in the **`sniff_packets_arp.py` **file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在**`sniff_packets_arp.py`**文件中找到以下代码：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Filtering UDP packets
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤UDP数据包
- en: 'In the following example, we see how we define a function that will be executed
    every time a packet of type UDP is obtained when making a **DNS request**:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们看到了如何定义一个函数，每当进行**DNS请求**时，都会执行该函数以获得UDP类型的数据包：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This function can be defined from the command line in this way. First we define
    a global variable called `DNS_QUERIES`, and when scapy finds a packet with the
    UDP protocol and port 53, it will call this function to increment this variable,
    which indicates there has been a DNS request in the communications:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过命令行以这种方式定义此函数。首先，我们定义一个名为`DNS_QUERIES`的全局变量，当scapy发现使用UDP协议和端口53的数据包时，它将调用此函数来增加此变量，这表明通信中存在DNS请求：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Port-scanning and traceroute with scapy
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用scapy进行端口扫描和跟踪路由
- en: At this point, we will see a port scanner on a certain network segment. In the
    same way we do port-scanning with nmap, with scapy we could also perform a simple
    port-scanner that tells us for a specific host and a list of ports, whether they
    are open or closed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将在某个网络段上看到一个端口扫描程序。与nmap一样，使用scapy，我们也可以执行一个简单的端口扫描程序，告诉我们特定主机和端口列表是否打开或关闭。
- en: Port-scanning with scapy
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用scapy进行端口扫描
- en: In the following example, we see that we have defined a `analyze_port()` function
    that has as parameters the host and port to analyze.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们看到我们已经定义了一个`analyze_port()`函数，该函数的参数是要分析的主机和端口。
- en: 'You can find the following code in the **`port_scan_scapy.py` **file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在**`port_scan_scapy.py`**文件中找到以下代码：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Traceroute command with scapy
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用scapy进行跟踪路由命令
- en: Traceroute is a network tool, available in Linux and Windows, that allows you
    to follow the route that a data packet (IP packet) will take to go from computer
    A to computer B.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪路由是一种网络工具，可在Linux和Windows中使用，允许您跟踪数据包（IP数据包）从计算机A到计算机B的路由。
- en: By default, the packet is sent over the internet, but the route followed by
    the packet may vary, in the event of a link failure or in the case of changing
    the provider connections.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，数据包通过互联网发送，但数据包的路由可能会有所不同，如果链路故障或更改提供者连接的情况下。
- en: Once the packets have been sent to the access provider, the packet will be sent
    to the intermediate routers that will transport it to its destination. The packet
    may undergo changes during its journey. It is also possible that it never reaches
    its destination if the number of intermediate nodes or machines is too big and
    the package lifetime expires.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据包被发送到接入提供商，数据包将被发送到中间路由器，将其传送到目的地。数据包在传输过程中可能会发生变化。如果中间节点或机器的数量太多，数据包的生存期到期，它也可能永远无法到达目的地。
- en: In the following example, we are going to study the possibilities of making
    a traceroute using scapy.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将研究使用scapy进行跟踪路由的可能性。
- en: 'Using scapy, IP and UDP packets can be built in the following way:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用scapy，IP和UDP数据包可以按以下方式构建：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To send the package, the `send` function is used:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送数据包，使用`send`函数：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: IP packets include an attribute (TTL) where you indicate the lifetime of the
    packet. In this way, each time a device receives an IP packet, it decrements the
    TTL (package lifetime) by 1 and passes it to the next machine. Basically, it is
    a smart way to make sure that packets do not get into infinite loops.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: IP数据包包括一个属性（TTL），其中指示数据包的生存时间。因此，每当设备接收到IP数据包时，它会将TTL（数据包生存时间）减少1，并将其传递给下一个设备。基本上，这是一种确保数据包不会陷入无限循环的聪明方式。
- en: To implement traceroute, we send a UDP packet with TTL = i for i = 1,2,3, n
    and check the response packet to see whether we have reached the destination and
    we need to continue doing jumps for each host that we reach.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现traceroute，我们发送一个TTL = i的UDP数据包，其中i = 1,2,3, n，并检查响应数据包，以查看我们是否已到达目的地，以及我们是否需要继续为我们到达的每个主机进行跳转。
- en: 'You can find the following code in the **`traceroute_scapy.py` **file:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在**`traceroute_scapy.py`**文件中找到以下代码：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the following screenshot, we can see the result of executing the traceroute
    script. Our target is the IP address of 216.58.210.142 and we can see the hops
    until we reach our target:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们可以看到执行traceroute脚本的结果。我们的目标是IP地址216.58.210.142，我们可以看到直到到达目标的跳数：
- en: '![](assets/7e8ec4d6-7168-408c-8928-3a733b319b68.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7e8ec4d6-7168-408c-8928-3a733b319b68.png)'
- en: 'Also, we can see all the machines for each hop until we arrive at our target:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以看到每一跳的所有机器，直到到达我们的目标：
- en: '![](assets/02dfb561-eff6-43b3-9ca4-d5b1730eb5c1.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/02dfb561-eff6-43b3-9ca4-d5b1730eb5c1.png)'
- en: Reading pcap files with scapy
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用scapy读取pcap文件
- en: In this section, you will learn the basics for reading pcap files. PCAP (Packet
    CAPture) refers to the API that allows you to capture network packets for processing.
    The PCAP format is a standard and is used by practically all network-analysis
    tools, such as TCPDump, WinDump, Wireshark, TShark, and Ettercap.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习读取pcap文件的基础知识。PCAP（数据包捕获）是指允许您捕获网络数据包以进行处理的API。PCAP格式是一种标准，几乎所有网络分析工具都使用它，如TCPDump、WinDump、Wireshark、TShark和Ettercap。
- en: Introduction to the PCAP format
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PCAP格式简介
- en: By analogy, the information captured using this technique is stored in a file
    with the .pcap extension. This file contains frames and network packets and is
    very useful if we need to save the result of a network analysis for later processing.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用这种技术捕获的信息存储在扩展名为.pcap的文件中。该文件包含帧和网络数据包，如果我们需要保存网络分析的结果以供以后处理，它非常有用。
- en: These files are very useful if we need to save the result of a network analysis
    for later processing or as evidence of the work done.The information stored in
    a .pcap file can be analyzed as many times as we need without the original file
    being altered.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要保存网络分析的结果以供以后处理，或者作为工作成果的证据，这些文件非常有用。.pcap文件中存储的信息可以被分析多次，而不会改变原始文件。
- en: 'Scapy incorporates two functions to work with PCAP file, which will allow us
    to read and write about them:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy包含两个用于处理PCAP文件的函数，它们允许我们对其进行读取和写入：
- en: '`rdcap ()`**:** Reads and loads a .pcap file.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rdcap()`**：**读取并加载.pcap文件。'
- en: '`wdcap ()`**:** Writes the contents of a list of packages in a .pcap file.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wdcap()`**：**将一个包列表的内容写入.pcap文件。'
- en: Reading pcap files with scapy
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用scapy读取pcap文件
- en: 'With the `rdpcap()` function, we can read a `pcap` file and get a list of packages
    that can be handled directly from Python:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`rdpcap()`函数，我们可以读取`pcap`文件并获得一个可以直接从Python处理的包列表：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Writing a pcap file
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个pcap文件
- en: 'With the `wrpcap()` function, we can store the captured packets in a pcap file.
    Also, it is possible to write the packets to a pcap file with Scapy. To write
    the packets to a pcap file, we can use the `wrpcap()` method. In the following
    example, we are capturing tcp packets for FTP transmissions and saving this packets
    in a pcap file:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`wrpcap()`函数，我们可以将捕获的数据包存储在pcap文件中。此外，还可以使用Scapy将数据包写入pcap文件。要将数据包写入pcap文件，我们可以使用`wrpcap()`方法。在下面的示例中，我们正在捕获FTP传输的tcp数据包，并将这些数据包保存在pcap文件中：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Sniffing from a pcap file with scapy
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用scapy从pcap文件中嗅探
- en: 'With the `rdpcap()` function, we can read a pcap file and get a list of packages
    that can be handled directly from Python:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`rdpcap()`函数，我们可以读取pcap文件并获得一个可以直接从Python处理的包列表：
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We also have the possibility of similar packet capture from the reading of
    a pcap file:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从读取pcap文件中进行类似的数据包捕获：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Scapy supports the B**PF (Beerkeley Packet Filters)** format, it is a standard
    format for applying filters over network packets. These filters can be applied
    on a set of specific packages or directly on an active capture:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy支持B**PF（Beerkeley Packet Filters）**格式，这是一种应用于网络数据包的过滤器的标准格式。这些过滤器可以应用于一组特定的数据包，也可以直接应用于活动捕获：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can format the output of sniff() in such a way that it adapts just to the
    data we want to see and sorts them as we want. We are going to capture traffic
    HTTP and HTTPS with the **"tcp and (port 443 or port 80)"** activated filter and
    using **prn = lamba x: x.sprintf**. We want to show the following data and in
    the following way:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以格式化sniff()的输出，使其适应我们想要查看的数据，并按我们想要的方式对其进行排序。我们将使用**“tcp and (port 443 or
    port 80)”**激活过滤器，并使用**prn = lamba x: x.sprintf**来捕获HTTP和HTTPS流量。我们想以以下方式显示以下数据：'
- en: Source IP and origin port
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源IP和原始端口
- en: Destination IP and destination port
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标IP和目标端口
- en: Flags TCP or Flags
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP标志或标志
- en: Payload of the TCP segment
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP段的有效载荷
- en: 'We can see the parameters for the `sniff` function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看`sniff`函数的参数：
- en: '[PRE38]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the following example, we can see the result of executing the sniff function
    after capturing packets and applying filters:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们可以看到在捕获数据包并应用过滤器后执行sniff函数的结果：
- en: '![](assets/a04b900f-9919-4596-a73b-d048281311c5.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a04b900f-9919-4596-a73b-d048281311c5.png)'
- en: 'The protocol output is not now TCP, UDP, etc. its hexadecimal value:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 协议输出现在不是TCP、UDP等，而是十六进制值：
- en: '**006 refers to the IP PROTOCOL field**; it refers to the next-level protocol
    that is used in the data part. Length 8 bits. In this case hex (06) (00000110)
    = TCP in decimal would be 6.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**006指的是IP协议字段**；它指的是数据部分中使用的下一级协议。长度为8位。在这种情况下，十六进制（06）（00000110）= TCP在十进制中为6。'
- en: 2, 16, 18, 24, ... are the flags of the TCP header that are expressed, in this
    case in hexadecimal format. For example, 18 would be in binary 11000 which, as
    we already know, would be for activated ACK + PSH.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 2、16、18、24等是TCP头部的标志，以十六进制格式表示。例如，18在二进制中是11000，正如我们已经知道的那样，这将激活ACK + PSH。
- en: Network Forensic with scapy
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用scapy进行网络取证
- en: Scapy is also useful for performing network forensic from SQL injection attacks
    or extracting ftp credentials from a server. By using the Python scapy library,
    we can identify when/where/how the attacker performs the SQL injection. With the
    help of the Python scapy library, we can analyze the network packet's pcap files.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy还可用于从SQL注入攻击中执行网络取证或从服务器提取ftp凭据。通过使用Python scapy库，我们可以确定攻击者何时/在哪里/如何执行SQL注入。借助Python
    scapy库的帮助，我们可以分析网络数据包的pcap文件。
- en: With scapy, we can analyze networks packets and detect whether an attacker is
    performing a SQL injection.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用scapy，我们可以分析网络数据包并检测攻击者是否正在执行SQL注入。
- en: We will be able to analyze, intercept, and dissect network packets, as well
    as reuse their content. We have the capacity to manipulate PCAP files with the
    information captured or produced by us.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将能够分析、拦截和解剖网络数据包，并重用它们的内容。我们有能力操作由我们捕获或生成的PCAP文件中的信息。
- en: For example, we could develop a simple script for an ARP MITM attack.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以开发一个简单的ARP MITM攻击脚本。
- en: 'You can find the following code in the **`arp_attack_mitm.py` **file:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在**`arp_attack_mitm.py` **文件中找到以下代码：
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at  the basics of packet-crafting and sniffing with
    various Python modules, and saw that scapy is very powerful and easy to use. By
    now, we have learned the basics of socket programming and scapy. During our security
    assessments, we may need the raw output and access to basic levels of packet topology
    so that we can analyze the information and make decisions ourselves. The most
    attractive part of scapy is that it can be imported and used to create networking
    tools without going to create packets from scratch.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了使用各种Python模块进行数据包构建和嗅探的基础知识，并且发现scapy非常强大且易于使用。到目前为止，我们已经学会了套接字编程和scapy的基础知识。在我们的安全评估中，我们可能需要原始输出和对数据包拓扑的基本级别访问，以便我们可以分析信息并自行做出决定。scapy最吸引人的部分是可以导入并用于创建网络工具，而无需从头开始创建数据包。
- en: In the next [chapter](f294d743-c9f1-40f5-a9b7-9904d7f634b2.xhtml), we will explore
    programming packages in Python to extract public information from servers with
    services such as shodan.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用Python编程包从具有shodan等服务的服务器中提取公共信息。
- en: Questions
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the scapy function that can capture packets in the same way tools such
    as tcpdump or Wireshark do?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以捕获数据包的scapy函数与tcpdump或Wireshark等工具的方式相同吗？
- en: What is the best way to send a packet with scapy indefinitely every five seconds
    in the form of a loop?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用scapy无限制地每五秒发送一个数据包的最佳方法是什么？
- en: What is the method that must be invoked with scapy to check whether a certain
    port (port) is open or closed on a certain machine (host), and also show detailed
    information about how the packets are being sent?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须使用scapy调用的方法来检查某台机器（主机）上的某个端口（端口）是打开还是关闭，并显示有关发送的数据包的详细信息是什么？
- en: What functions are necessary to implement the traceroute command in scapy?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在scapy中实现traceroute命令需要哪些功能？
- en: Which Python extension module interfaces with the libpcap packet capture library?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个Python扩展模块与libpcap数据包捕获库进行接口？
- en: Which method in the pcapy interface allows us to capture packets on a specific
    device?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: pcapy接口中的哪个方法允许我们在特定设备上捕获数据包？
- en: What are the methods to send a package in Scapy?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Scapy中发送数据包的方法是什么？
- en: Which parameter of the sniff function allows us to define a function that will
    be applied to each captured packet?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: sniff函数的哪个参数允许我们定义一个将应用于每个捕获数据包的函数？
- en: Which format supports scapy for applying filters over network packets?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: scapy支持哪种格式来对网络数据包应用过滤器？
- en: What is the command that allows you to follow the route that a data packet (IP
    packet) will take to go from computer A to computer B?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许您跟踪数据包（IP数据包）从计算机A到计算机B的路由的命令是什么？
- en: Further reading
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'In these links, you will find more information about the mentioned tools and
    the official Python documentation for some of the commented modules:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些链接中，您将找到有关提到的工具以及一些评论模块的官方Python文档的更多信息：
- en: '[http://www.secdev.org/projects/scapy](http://www.secdev.org/projects/scapy)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.secdev.org/projects/scapy](http://www.secdev.org/projects/scapy)'
- en: '[http://www.secdev.org/projects/scapy/build_your_own_tools.html](http://www.secdev.org/projects/scapy/build_your_own_tools.html)'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.secdev.org/projects/scapy/build_your_own_tools.html](http://www.secdev.org/projects/scapy/build_your_own_tools.html)'
- en: '[http://scapy.readthedocs.io/en/latest/usage.html](http://scapy.readthedocs.io/en/latest/usage.html)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://scapy.readthedocs.io/en/latest/usage.html](http://scapy.readthedocs.io/en/latest/usage.html)'
- en: '[https://github.com/CoreSecurity/pcapy](https://github.com/CoreSecurity/pcapy)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/CoreSecurity/pcapy](https://github.com/CoreSecurity/pcapy)'
- en: 'Tools based in scapy:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 基于scapy的工具：
- en: '[https://github.com/nottinghamprisateam/pyersinia](https://github.com/nottinghamprisateam/pyersinia)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/nottinghamprisateam/pyersinia](https://github.com/nottinghamprisateam/pyersinia)'
- en: '[https://github.com/adon90/sneaky_arpspoofing](https://github.com/adon90/sneaky_arpspoofing)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/adon90/sneaky_arpspoofing](https://github.com/adon90/sneaky_arpspoofing)'
- en: '[https://github.com/tetrillard/pynetdiscover](https://github.com/tetrillard/pynetdiscover)'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/tetrillard/pynetdiscover](https://github.com/tetrillard/pynetdiscover)'
- en: pyNetdiscover is an active/passive address-reconnaissance tool and ARP Scanner,
    which has as requirements python2.7, and the `scapy`, `argparse`, and `netaddr`
    modules.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: pyNetdiscover是一种主动/被动地址侦察工具和ARP扫描仪，其要求是python2.7和`scapy`、`argparse`和`netaddr`模块。
