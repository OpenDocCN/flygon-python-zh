- en: Working with Data and Statistics
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数据和统计
- en: One of the most attractive features of Python for people who need to analyze
    data is the huge ecosystem of data manipulation and analysis packages, as well
    as the active community of data scientists working with Python. Python is easy
    to use, while also offering very powerful, fast libraries, which enables even
    relatively novice programmers to quickly and easily process vast sets of data.
    At the heart of many data science packages and tools is the pandas library. Pandas
    provides two data container types that build on top of NumPy arrays and have good
    support for labels (other than simple integers). They also make working with large
    sets of data extremely easy.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要分析数据的人来说，Python 最吸引人的特点之一是数据操作和分析软件包的庞大生态系统，以及与 Python 合作的数据科学家活跃的社区。Python
    使用起来很容易，同时还提供非常强大、快速的库，使得即使是相对新手的程序员也能够快速、轻松地处理大量数据。许多数据科学软件包和工具的核心是 pandas 库。Pandas
    提供了两种数据容器类型，它们建立在 NumPy 数组的基础上，并且对于标签（除了简单的整数）有很好的支持。它们还使得处理大量数据变得非常容易。
- en: Statistics is the systematic study of data using mathematical—specifically,
    probability—theory. There are two aspects to statistics. The first is to find
    numerical values that describe a set of data, including characteristics such as
    the center (mean or median) and spread (standard deviation or variance) of the
    data. The second aspect of statistics is inference, describing a much larger set
    of data (a population) using a relatively small sample dataset.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学是使用数学—特别是概率—理论对数据进行系统研究。统计学有两个方面。第一个是找到描述一组数据的数值，包括数据的中心（均值或中位数）和离散程度（标准差或方差）等特征。统计学的第二个方面是推断，使用相对较小的样本数据集来描述一个更大的数据集（总体）。
- en: In this chapter, we will see how to leverage Python and pandas to work with
    large sets of data and perform statistical tests.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何利用 Python 和 pandas 处理大量数据并进行统计测试。
- en: 'This chapter contains the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下示例：
- en: Creating Series and DataFrame objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Series 和 DataFrame 对象
- en: Loading and storing data from a DataFrame
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 DataFrame 中加载和存储数据
- en: Manipulating data in DataFrames
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据框中操作数据
- en: Plotting data from a DataFrame
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 DataFrame 绘制数据
- en: Getting descriptive statistics from a DataFrame
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 DataFrame 获取描述性统计信息
- en: Understanding a population using sampling
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽样了解总体
- en: Testing hypotheses using t-tests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 t 检验来测试假设
- en: Testing hypotheses using ANOVA
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方差分析进行假设检验
- en: Testing hypotheses for non-parametric data
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对非参数数据进行假设检验
- en: Creating interactive plots with Bokeh
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Bokeh 创建交互式图表
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, we will mostly make use of the pandas library for data manipulation,
    which provides R like data structures, such as `Series` and `DataFrame` objects,
    for storing, organizing, and manipulating data. We will also use the Bokeh data
    visualization library in the final recipe of this chapter. These libraries can
    be installed using your favorite package manager, such as pip:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要使用 pandas 库进行数据操作，该库提供了类似于 R 的数据结构，如 `Series` 和 `DataFrame` 对象，用于存储、组织和操作数据。我们还将在本章的最后一个示例中使用
    Bokeh 数据可视化库。这些库可以使用您喜欢的软件包管理器（如 pip）进行安装：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will also make use of the NumPy and SciPy packages.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用 NumPy 和 SciPy 软件包。
- en: The code for this chapter can be found in the `Chapter 06` folder of the GitHub
    repository at [https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2006](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2006).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 GitHub 代码库的 `Chapter 06` 文件夹中找到：[https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2006](https://github.com/PacktPublishing/Applying-Math-with-Python/tree/master/Chapter%2006)。
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2OQs6NX](https://bit.ly/2OQs6NX).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码示例：[https://bit.ly/2OQs6NX](https://bit.ly/2OQs6NX)。
- en: Creating Series and DataFrame objects
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Series 和 DataFrame 对象
- en: Most data handling in Python is done using the pandas library, which builds
    on NumPy to provide R-like structures for holding data. These structures allow
    the easy indexing of rows and columns, using strings or other Python objects besides
    just integers. Once data is loaded into a pandas `DataFrame` or `Series`, it can
    be easily manipulated, just as if it were in a spreadsheet. This makes Python
    when combined with pandas a powerful tool for processing and analyzing data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的大多数数据处理都是使用 pandas 库完成的，它构建在 NumPy 的基础上，提供了类似于 R 的数据结构来保存数据。这些结构允许使用字符串或其他
    Python 对象而不仅仅是整数来轻松索引行和列。一旦数据加载到 pandas 的 `DataFrame` 或 `Series` 中，就可以轻松地进行操作，就像在电子表格中一样。这使得
    Python 结合 pandas 成为处理和分析数据的强大工具。
- en: In this recipe, we will see how to create new pandas `Series` and `DataFrame`
    objects and access items from `Series` or `DataFrame`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将看到如何创建新的 pandas `Series` 和 `DataFrame` 对象，并访问 `Series` 或 `DataFrame`
    中的项目。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will import the pandas library as pd using the following
    command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用以下命令导入 pandas 库：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The NumPy package is `np`. We also create a (seeded) random number generator
    from NumPy, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 软件包是 `np`。我们还可以从 NumPy 创建一个（种子）随机数生成器，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps outline how to create a `Series` and `DataFrame` object
    that holds data:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了如何创建包含数据的 `Series` 和 `DataFrame` 对象：
- en: 'First, create the random data that we will store in the `Series` and `DataFrame`
    objects:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建我们将存储在 `Series` 和 `DataFrame` 对象中的随机数据：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, create a `Series` object that holds `diff_data`. We''ll print `Series`
    to produce a view of the data:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个包含 `diff_data` 的 `Series` 对象。我们将打印 `Series` 以查看数据的视图：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, create a `DataFrame` object with two columns:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个具有两列的 `DataFrame` 对象：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Print the `DataFrame` object to produce a view of the data it holds:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印 `DataFrame` 对象以查看其包含的数据：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The pandas package provides the `Series` and `DataFrame` classes, which mirror
    the function and capabilities of their R counterparts. `Series` is used to store
    one-dimensional data, such as time-series data, and `DataFrame` is used to store
    multidimensional data; you can think of a `DataFrame` object as a "spreadsheet."
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: pandas包提供了`Series`和`DataFrame`类，它们反映了它们的R对应物的功能和能力。`Series`用于存储一维数据，如时间序列数据，`DataFrame`用于存储多维数据；您可以将`DataFrame`对象视为"电子表格"。
- en: What separates `Series` from a simple NumPy `ndarray` is the way that `Series`
    indexes its items. A NumPy array is indexed by integers, which is also the default
    for a `Series` object. However, `Series` can be indexed by any hashable Python
    object, including strings and `datetime` objects. This makes `Series` useful for
    storing time-series data. A `Series` can be created in a number of ways. In this
    recipe, we used a NumPy array, but any Python iterable, such as a list, can be
    used instead.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series`与简单的NumPy `ndarray`的区别在于`Series`索引其项的方式。NumPy数组由整数索引，这也是`Series`对象的默认索引。但是，`Series`可以由任何可散列的Python对象索引，包括字符串和`datetime`对象。这使得`Series`对于存储时间序列数据非常有用。`Series`可以以多种方式创建。在这个示例中，我们使用了NumPy数组，但是任何Python可迭代对象，如列表，都可以替代。'
- en: Each column in a `DataFrame` object is a series containing rows, just as in
    a traditional database or spreadsheet. In this recipe, the columns are given labels
    when the `DataFrame` object is constructed via the keys of the dictionary.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame对象中的每一列都是包含行的系列，就像传统数据库或电子表格中一样。在这个示例中，当通过字典的键构造DataFrame对象时，列被赋予标签。
- en: The `DataFrame` and `Series` objects create a summary of the data they contain
    when printed. This includes column names, the number of rows and columns, and
    the first and last five rows of the frame (series). This is useful for quickly
    obtaining an overview of the object and the spread of data it contains.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrame`和`Series`对象在打印时会创建它们包含的数据的摘要。这包括列名、行数和列数，以及框架（系列）的前五行和最后五行。这对于快速获取对象和包含的数据的概述非常有用。'
- en: There's more...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The individual rows (records) of a `Series` object can be accessed using the
    usual index notation by providing the corresponding index. We can also access
    the rows by their numerical position using the special `iloc` property object.
    This allows us to access the rows by their numerical (integer) index, such as
    with Python lists or NumPy arrays.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series`对象的单个行（记录）可以使用通常的索引符号通过提供相应的索引来访问。我们还可以使用特殊的`iloc`属性对象按其数值位置访问行。这允许我们按照它们的数值（整数）索引访问行，就像Python列表或NumPy数组一样。'
- en: The columns in a `DataFrame` object can be accessed using the usual index notation,
    providing the name of the column. The result of this is a `Series` object that
    contains the data from the selected column. DataFrames also provides two properties
    that can be used to access data. The `loc` attribute provides access to individual
    rows by their index, whatever this object may be. The `iloc` attribute provides
    access to the rows by numerical index, just as for the `Series` object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用通常的索引符号访问`DataFrame`对象中的列，提供列的名称。这样做的结果是一个包含所选列数据的`Series`对象。DataFrames还提供了两个属性，可以用来访问数据。`loc`属性提供对个别行的访问，无论这个对象是什么。`iloc`属性提供按数值索引访问行，就像`Series`对象一样。
- en: You can provide selection criteria to `loc`(or just using index notation for
    the object) to select data. This includes a single label, a list of labels, a
    slice of labels, or a Boolean array (of an appropriate size). The `iloc`selection
    method accepts similar criteria.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向`loc`（或只使用对象的索引符号）提供选择条件来选择数据。这包括单个标签、标签列表、标签切片或布尔数组（适当大小的数组）。`iloc`选择方法接受类似的条件。
- en: There are other ways to select data from a `Series`or `DataFrame`object beyond
    the simple methods we describe here. For example, we can use the `at`attribute
    to access a single value at a specified row (and column) in the object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在这里描述的简单方法之外，还有其他从Series或DataFrame对象中选择数据的方法。例如，我们可以使用`at`属性来访问对象中指定行（和列）的单个值。
- en: See also
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The pandas documentation contains a detailed description of the different ways
    to create and index a `DataFrame` or `Series` object, at [https://pandas.pydata.org/docs/user_guide/indexing.html](https://pandas.pydata.org/docs/user_guide/indexing.html).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: pandas文档包含了创建和索引DataFrame或Series对象的不同方法的详细描述，网址为[https://pandas.pydata.org/docs/user_guide/indexing.html](https://pandas.pydata.org/docs/user_guide/indexing.html)。
- en: Loading and storing data from a DataFrame
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从DataFrame加载和存储数据
- en: It is fairly unusual to create a `DataFrame` object from the raw data in a Python
    session. In practice, the data will often come from an external source, such as
    an existing spreadsheet or CSV file, database, or API endpoint. For this reason,
    pandas provides numerous utilities for loading and storing data to file. Out of
    the box, pandas supports loading and storing data from CSV, Excel (`xls` or `xlsx`),
    JSON, SQL, Parquet, and Google BigQuery. This makes it very easy to import your
    data into pandas and then manipulate and analyze this data using Python.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python会话中从原始数据创建DataFrame对象是相当不寻常的。实际上，数据通常来自外部来源，如现有的电子表格或CSV文件、数据库或API端点。因此，pandas提供了许多用于加载和存储数据到文件的实用程序。pandas支持从CSV、Excel（xls或xlsx）、JSON、SQL、Parquet和Google
    BigQuery加载和存储数据。这使得将数据导入pandas然后使用Python操纵和分析这些数据变得非常容易。
- en: In this recipe, we will see how to load and store data into a CSV file. The
    instructions will be similar for loading and storing data to other file formats.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何将数据加载和存储到CSV文件中。加载和存储数据到其他文件格式的指令将类似。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'For this recipe, we will need to import the pandas package under the `pd`alias
    and the NumPy library as `np`, and we create a default random number generator
    from NumPy using the following commands:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要导入pandas包作为`pd`别名和NumPy库作为`np`，并使用以下命令创建一个默认的随机数生成器：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to store data to a file and then load the data back into
    Python:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将数据存储到文件，然后将数据加载回Python：
- en: 'First, we''ll create a sample `DataFrame` object using random data. We then
    print this `DataFrame` object so that we can compare it to the data that we will
    read later:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用随机数据创建一个样本`DataFrame`对象。然后打印这个`DataFrame`对象，以便我们可以将其与稍后将要读取的数据进行比较：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will store the data in this `DataFrame` object into the `sample.csv` file
    using the `to_csv` method on the `DataFrame` object. We will use the `index=False`
    keyword argument so that the index is not stored in the CSV file:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`DataFrame`对象中的数据将数据存储到`sample.csv`文件中，使用`DataFrame`对象上的`to_csv`方法。我们将使用`index=False`关键字参数，以便索引不存储在CSV文件中：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can use the `read_csv` routine from pandas to read the `sample.csv`
    file into a new `DataFrame` object. We will print this object to show the result:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用pandas中的`read_csv`例程将`sample.csv`文件读入一个新的`DataFrame`对象。我们将打印这个对象以显示结果：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The core of this recipe is the `read_csv` routine in pandas. This routine takes
    path- or file-like objects as an argument and reads the contents of the file as
    CSV data. We can customize the delimiter using the `sep` keyword argument, which
    is a comma (`,`) by default. There are also options to customize the column headers
    and customize the type of each column.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的核心是pandas中的`read_csv`例程。这个例程以路径或类文件对象作为参数，并将文件的内容读取为CSV数据。我们可以使用`sep`关键字参数自定义分隔符，默认为逗号（`,`）。还有一些选项可以自定义列标题和自定义每列的类型。
- en: The `to_csv` method in a `DataFrame` or `Series` stores the contents into a
    CSV file. We used the `index` keyword argument here so that the indices are not
    printed into the file. This means that pandas will infer the index from the row
    number in the CSV file. This behavior is desirable if the data is indexed by integers,
    but this might not be the case if the data is indexed by times or dates, for example.
    We can also use this keyword argument to specify which column in the CSV file
    is the indexing column.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrame`或`Series`中的`to_csv`方法将内容存储到CSV文件中。我们在这里使用了`index`关键字参数，以便索引不会打印到文件中。这意味着pandas将从CSV文件中的行号推断索引。如果数据是由整数索引的，这种行为是可取的，但如果数据是由时间或日期索引的，情况可能不同。我们还可以使用这个关键字参数来指定CSV文件中的哪一列是索引列。'
- en: See also
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the pandas documentation for a list of supported file formats at[https://pandas.pydata.org/docs/reference/io.html](https://pandas.pydata.org/docs/reference/io.html)[.](https://pandas.pydata.org/docs/reference/io.html)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅pandas文档，了解支持的文件格式列表[https://pandas.pydata.org/docs/reference/io.html](https://pandas.pydata.org/docs/reference/io.html)。
- en: Manipulating data in DataFrames
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在DataFrames中操作数据
- en: Once we have data in a `DataFrame`, we often need to apply some simple transformations
    or filters to the data before we can perform any analysis. This could include,
    for example, filtering the rows that are missing data or applying a function to
    individual columns.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`DataFrame`中有了数据，我们经常需要对数据应用一些简单的转换或过滤，然后才能进行任何分析。例如，这可能包括过滤缺少数据的行或对单独的列应用函数。
- en: In this recipe, we will see how to perform some basic manipulation of `DataFrame`
    objects to prepare the data for analysis.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何对`DataFrame`对象执行一些基本操作，以准备数据进行分析。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the `pandas` package imported under the `pd`alias,
    the NumPy package imported under the `np`alias, and a default random number generator
    object from NumPy created using the following commands:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要导入`pandas`包并使用`pd`别名，导入NumPy包并使用`np`别名，并使用以下命令从NumPy创建一个默认随机数生成器对象：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following steps illustrate how to perform some basic filtering and manipulations
    on a pandas `DataFrame`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤说明了如何对pandas的`DataFrame`执行一些基本的过滤和操作：
- en: 'We will first create a sample `DataFrame` using random data:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先使用随机数据创建一个样本`DataFrame`：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we have to generate a new column from an existing column. This new column
    will hold `True` if the corresponding entry of column `"one"` is greater than
    `0.5`, and `False` otherwise:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须从现有列生成一个新列。这个新列将在相应的列“one”的条目大于`0.5`时保持`True`，否则为`False`：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We now have to create a new function that we will apply to our `DataFrame`.
    This function multiplies the row `"two"` value by the maximum of row `"one"` and
    `0.5` (there are more concise ways to write this function):'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须创建一个新的函数，我们将应用到我们的`DataFrame`上。这个函数将把行“two”的值乘以行“one”和`0.5`的最大值（有更简洁的编写这个函数的方法）：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will now apply the previously defined function to each row in the DataFrame
    to generate a new column. We will also print the updated DataFrame for comparison
    later:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将对DataFrame中的每一行应用先前定义的函数以生成一个新列。我们还将打印更新后的DataFrame，以便稍后进行比较：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we have to filter out the rows in the DataFrame that contain a **Not
    a Number** (**NaN**) value. We will print the resulting DataFrame:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须过滤掉DataFrame中包含**NaN**值的行。我们将打印结果DataFrame：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: New columns can be added to an existing `DataFrame` by simply assigning them
    to the new column index. However, some care needs to be taken here. In some situations,
    pandas will create a "view" to a `DataFrame` object rather than copying, and in
    this case, assigning to a new column might not have the desired effect. This is
    discussed in the pandas documentation ([https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过简单地将它们分配给新的列索引来向现有的`DataFrame`添加新列。但是，在这里需要注意一些问题。在某些情况下，pandas会创建一个“视图”到`DataFrame`对象，而不是复制，这种情况下，分配给新列可能不会产生预期的效果。这在pandas文档中有所讨论（[https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy](https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy)）。
- en: Pandas `Series` objects (columns in a `DataFrame`) support the rich comparison
    operators, such as equality and less than or greater than (in this recipe, we
    used the greater than operator). These comparison operators return a `Series`
    containing Boolean values corresponding to the positions at which the comparison
    was true and false. This can, in turn, be used to index the original Series and
    get just the rows where the comparison was true. In this recipe, we have simply
    added this Series of Boolean values to the original `DataFrame`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas `Series`对象（`DataFrame`中的列）支持丰富的比较运算符，如等于、小于或大于（在本示例中，我们使用了大于运算符）。这些比较运算符返回一个包含布尔值的`Series`，对应于比较为真和假的位置。这可以用来索引原始`Series`，并只获取比较为真的行。在本示例中，我们简单地将这个布尔值的`Series`添加到原始的`DataFrame`中。
- en: The `apply` method takes a function (or other callable function) and applies
    it to each column in the DataFrame. In this recipe, we insteadwanted to apply
    the function to each row, so we used the `axis=1`keyword argument to apply the
    function to each row in the DataFrame. In either case, the function is provided
    with a `Series`object indexed by the rows (columns). We have also applied a function
    to each row, which returned a value computed using the data from each row. In
    practice, this application would be quite slow if the DataFrame contains a large
    number of rows. If possible, you should operate on the columns as a whole, using
    functions designed to operate on NumPy arrays, for better efficiency. This is
    especially true for performing simple arithmetic on values in columns of a DataFrame.
    Just like NumPy arrays, `Series` objects implement standard arithmetic operations,
    which can greatly improve the operation time for large DataFrames.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply`方法接受一个函数（或其他可调用函数）并将其应用于DataFrame中的每一列。在本示例中，我们希望将函数应用于每一行，因此我们使用了`axis=1`关键字参数将函数应用于DataFrame中的每一行。无论哪种情况，函数都提供了一个由行（列）索引的`Series`对象。我们还将函数应用于每一行，返回使用每一行数据计算的值。实际上，如果DataFrame包含大量行，这种应用会相当慢。如果可能的话，应该整体操作列，使用设计用于操作NumPy数组的函数，以获得更好的效率。这对于在DataFrame的列中执行简单的算术运算尤其如此。就像NumPy数组一样，`Series`对象实现了标准的算术运算，这可以极大地提高大型DataFrame的操作时间。'
- en: In the final step of this recipe, we used the `dropna` method to quickly select
    only the rows from the DataFrames that do not contain a NaN value. Pandas uses
    NaN to represent missing data in a DataFrame, so this method selects the rows
    that don't contain a missing value. This method returns a view to the original
    `DataFrame` object, but it can also modify the original DataFrame by passing the
    `inplace=True` keyword argument. As used in this recipe, this is roughly equivalent
    to using the indexing notation to select rows using an indexing array containing
    Boolean values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例的最后一步中，我们使用了`dropna`方法，快速选择了不包含NaN值的DataFrame行。Pandas使用NaN来表示DataFrame中的缺失数据，因此这个方法选择了不包含缺失值的行。这个方法返回原始`DataFrame`对象的视图，但也可以通过传递`inplace=True`关键字参数来修改原始DataFrame。在本示例中，这大致相当于使用索引表示法，使用包含布尔值的索引数组来选择行。
- en: You should always be cautious when modifying original data directly since it
    might not be possible to return to this data to repeat your analysis later. If
    you do need to modify the data directly, you should make sure that it is either
    backed up or that the modifications do not remove data that you might later need.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当直接修改原始数据时，应该始终谨慎，因为可能无法返回到原始数据以重复分析。如果确实需要直接修改数据，应确保数据已备份，或者修改不会删除以后可能需要的数据。
- en: There's more...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Most pandas routines deal with missing data (NaN) in a sensible way. However,
    if you do need to remove or replace missing data in a DataFrame, then there are
    several ways to do this. In this recipe, we have used the `dropna` method to simply
    drop the rows from the DataFrames that are missing data. We could instead fill
    all the missing values with a specific value using the `fillna` method, or interpolate
    missing values using the surrounding values using the `interpolate` method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数pandas例程以明智的方式处理缺失数据（NaN）。然而，如果确实需要在DataFrame中删除或替换缺失数据，则有几种方法可以做到这一点。在本示例中，我们使用了`dropna`方法，简单地删除了缺失数据的行。我们也可以使用`fillna`方法填充所有缺失值，或者使用`interpolate`方法插值缺失值使用周围的值。
- en: More generally, we can use the `replace` method to replace specific (non-NaN)
    values with other values. This method can work with both numeric values or string
    values, including pattern-matching with regex.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，我们可以使用`replace`方法来用其他值替换特定（非NaN）值。这种方法可以处理数字值或字符串值，包括与正则表达式匹配。
- en: The `DataFrame` class has many useful methods. We've only covered the very basic
    methods here, but there are two other methods that we should also mention. These
    are the `agg` method and the `merge` method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFrame`类有许多有用的方法。我们在这里只涵盖了非常基本的方法，但还有两个方法我们也应该提到。这些是`agg`方法和`merge`方法。'
- en: The `agg` method aggregates the results of one or more operations over a given
    axis of the DataFrame. This allows us to quickly produce summary information for
    each column (or row) by applying an aggregating function. The output is a DataFrame
    that has the names of the functions applied as the rows, and the labels for the
    chosen axis (column labels, for instance) for the columns.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`agg`方法在DataFrame的给定轴上聚合一个或多个操作的结果。这允许我们通过应用聚合函数快速为每列（或行）生成摘要信息。输出是一个DataFrame，其中应用的函数的名称作为行，所选轴的标签（例如列标签）作为列。'
- en: The `merge` method performs a SQL-like join over two DataFrames. This will produce
    a new DataFrame that contains the result of the join. There are various parameters
    that can be passed to the `how` keyword argument to specify the type of merge
    to be performed, with the default being `inner`. The name of the column or index
    over which to perform the join should be passed to either the `on` keyword argument—if
    both `DataFrame` objects contain the same key—or to `left_on` and `right_on`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge`方法在两个DataFrame上执行类似SQL的连接。这将产生一个包含连接结果的新DataFrame。可以传递各种参数给`how`关键字参数，以指定要执行的合并类型，默认为`inner`。应该将要执行连接的列或索引的名称传递给`on`关键字参数
    - 如果两个`DataFrame`对象包含相同的键 - 或者传递给`left_on`和`right_on`。'
- en: Plotting data from a DataFrame
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从DataFrame绘制数据
- en: As with many mathematical problems, one of the first steps to find some way
    to visualize the problem and all the information is to formulate a strategy. For
    data-based problems, this usually means producing a plot of the data and visually
    inspecting it for trends, patterns, and the underlying structure. Since this is
    such a common operation, pandas provides a quick and simple interface for plotting
    data in various forms, using Matplotlib under the hood by default, directly from
    a `Series` or `DataFrame`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多数学问题一样，找到可视化问题和所有信息的一种方法是制定策略。对于基于数据的问题，这通常意味着生成数据的图表，并在视觉上检查趋势、模式和基本结构。由于这是一个常见的操作，pandas提供了一个快速简单的接口，可以直接从`Series`或`DataFrame`中以各种形式使用Matplotlib默认情况下的底层绘制数据。
- en: In this recipe, we will see how to plot data directly from a `DataFrame` or
    `Series` to understand the underlying trends and structure.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将看到如何直接从`DataFrame`或`Series`绘制数据，以了解其中的趋势和结构。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the pandas library import as `pd`, the NumPy
    library import as `np`, the matplotlib `pyplot` module imported as `plt`, and
    a default random number generator instance created using the following commands:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我们将需要导入pandas库为`pd`，导入NumPy库为`np`，导入matplotlib的`pyplot`模块为`plt`，并使用以下命令创建一个默认的随机数生成器实例：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Follow these steps to create a simple DataFrame using random data and produce
    plots of the data it contains:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用随机数据创建一个简单的DataFrame，并绘制其包含的数据的图表：
- en: 'Create a sample DataFrame using random data:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用随机数据创建一个示例DataFrame：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we have to create a blank figure with two subplots ready for plotting:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建一个空白图，准备好绘图的两个子图：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have to plot the `walk`column as a standard line graph. This is done by
    using the `plot`method on the `Series` (column) object without additional arguments.
    We will force the plotting on `ax1`by passing the `ax=ax1`keyword argument:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须将`walk`列绘制为标准折线图。这是通过在`Series`（列）对象上使用`plot`方法而不使用其他参数来完成的。我们将通过传递`ax=ax1`关键字参数来强制在`ax1`上绘图：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we have to plot a histogram of the `diffs` column by passing the `kind="hist"`
    keyword argument to the `plot` method:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须通过将`kind="hist"`关键字参数传递给`plot`方法来绘制`diffs`列的直方图：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The resulting plots are shown here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图表如下所示：
- en: '![](assets/32597d04-7669-4b87-a2cc-8ecb88435534.png)Figure 6.1 – Plot of the
    walk value and a histogram of differences from a DataFrame'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/32597d04-7669-4b87-a2cc-8ecb88435534.png)图6.1 - DataFrame中行走值和差异直方图的图表'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `plot` method on a `Series` (or a `DataFrame`) is a quick way to plot the
    data it contains against the row index. The `kind` keyword argument is used to
    control the type of plot that is produced, with a line plot being the default.
    There are lots of options for the plotting type, including `bar` for a vertical
    bar chart, `barh` for a horizontal bar chart, `hist` for a histogram (also seen
    in this recipe), `box` for a box plot, and `scatter` for a scatter plot. There
    are several other keyword arguments to customize the plot that it produces. In
    this recipe, we also provided the `title` keyword argument to add a title to each
    subplot.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`Series`（或`DataFrame`）上的`plot`方法是绘制其包含的数据与行索引的快速方法。`kind`关键字参数用于控制生成的图表类型，默认情况下是线图。有许多选项可用于绘图类型，包括`bar`用于垂直条形图，`barh`用于水平条形图，`hist`用于直方图（也在本教程中看到），`box`用于箱线图，`scatter`用于散点图。还有其他几个关键字参数可用于自定义生成的图表。在本教程中，我们还提供了`title`关键字参数，以向每个子图添加标题。'
- en: Since we wanted to put both plots on the same figure side by side using subplots
    that we had already created, we used the `ax` keyword argument to pass in the
    respective axes handles to the plotting routine. Even if you let the `plot` method
    construct its own figure, you may still need to use the `plt.show` routine in
    order to display the figure with certain settings.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要将两个图形放在同一图上，我们使用了`ax`关键字参数将各自的轴句柄传递给绘图例程。即使您让`plot`方法构建自己的图形，您可能仍然需要使用`plt.show`例程来显示具有某些设置的图形。
- en: There's more...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can produce several common types of plots using the pandas interface. This
    includes, in addition to those mentioned in this recipe, scatter plots, bar plots
    (horizontal bars and vertical bars), area plots, pie charts, and box plots. The
    `plot` method also accepts various keyword arguments to customize the appearance
    of the plot.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用pandas接口生成几种常见类型的图表。除了本教程中提到的图表类型之外，还包括散点图、条形图（水平条形图和垂直条形图）、面积图、饼图和箱线图。`plot`方法还接受各种关键字参数来自定义图表的外观。
- en: Getting descriptive statistics from a DataFrame
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从DataFrame获取描述性统计信息
- en: Descriptive statistics, or summary statistics, are simple values associated
    with a set of data, such as the mean, median, standard deviation, minimum, maximum,
    and quartile values. These values describe the location and spread of a dataset
    in various ways. The mean and median are measures of the center (location) of
    the data, and the other values measure the spread of the data from the mean and
    median. These statistics are vital in understanding a dataset and form the basis
    for many techniques for analysis.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 描述统计或汇总统计是与一组数据相关的简单值，例如平均值、中位数、标准差、最小值、最大值和四分位数。这些值以各种方式描述了数据集的位置和分布。平均值和中位数是数据的中心（位置）的度量，其他值则度量了数据相对于平均值和中位数的分布。这些统计数据对于理解数据集至关重要，并为许多分析技术奠定了基础。
- en: In this recipe, we will see how to generate descriptive statistics for each
    column in a DataFrame.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何为 DataFrame 中的每列生成描述性统计。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we need the pandas package imported as `pd`, the NumPy package
    imported as `np`, the matplotlib `pyplot` module imported as `plt`, and a default
    random number generator created using the following commands:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个示例，我们需要导入 pandas 包为 `pd`，导入 NumPy 包为 `np`，导入 matplotlib 的 `pyplot` 模块为 `plt`，并使用以下命令创建一个默认的随机数生成器：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The following steps show how to generate descriptive statistics for each column
    in a DataFrame:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何为 DataFrame 中的每一列生成描述性统计：
- en: 'We will first create some sample data that we can analyze:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先创建一些样本数据，以便进行分析：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we plot histograms of the data so that we can understand the distribution
    of the data in the DataFrame:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们绘制数据的直方图，以便了解 DataFrame 中数据的分布：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Pandas `DataFrame` objects have a method for getting several common descriptive
    statistics for each column. The `describe` method creates a new DataFrame, where
    the column headers are the same as from the original object and each row contains
    a different descriptive statistic:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pandas `DataFrame` 对象有一个方法，可以为每列获取几个常见的描述性统计。`describe` 方法创建一个新的 DataFrame，其中列标题与原始对象相同，每行包含不同的描述性统计：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We also compute the *kurtosis* and add this to the new DataFrame we just obtained.
    We also print the descriptive statistics to the console to see what the values
    are:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还计算了*峰度*并将其添加到我们刚刚获得的新 DataFrame 中。我们还将描述性统计打印到控制台上，以查看这些值是什么：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we add vertical lines to the histograms to illustrate the value of
    the mean in each case:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在直方图上添加了垂直线，以说明每种情况下的平均值：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The resulting histograms are shown here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 结果直方图如下所示：
- en: '![](assets/46b543ec-8e94-4bb2-8246-3bb9db0e213c.png)Figure 6.2 – Histograms
    of three sets of data with their mean values indicated'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/46b543ec-8e94-4bb2-8246-3bb9db0e213c.png)图 6.2 – 三组数据的直方图及其平均值'
- en: How it works...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `describe` method returns a DataFrame with rows for the following descriptive
    statistics of the data: the count, mean, standard deviation, minimum value, 25%
    quartile, median (50% quartile), 75% quartile, and maximum value. The count is
    fairly self-explanatory, as are the minimum and maximum values. The mean and the
    median are two different *averages* of the data, which roughly represent the central
    value of the data. The mean is defined in a familiar way as the sum of all values
    divided by the number of values. We can express this quantity using the following
    formula:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe` 方法返回一个包含以下数据描述统计的 DataFrame：计数、平均值、标准差、最小值、25% 四分位数、中位数（50% 四分位数）、75%
    四分位数和最大值。计数相当直观，最小值和最大值也是如此。平均值和中位数是数据的两种不同的“平均值”，大致代表了数据的中心值。平均值的定义是所有值的总和除以值的数量。我们可以用以下公式表示这个数量：'
- en: '![](assets/c536ac7d-473a-45ef-9c61-437e89e568c5.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c536ac7d-473a-45ef-9c61-437e89e568c5.png)'
- en: Here, the *x[i]* values represent the data values and *N* is the number (count)
    of values. Here, we also adopt the common notation of the bar to represent the
    mean value. The median is the "middle value" when all the data is sorted (taking
    an average of the two middle values if there are an odd number of values). The
    quartile values at 25% and 75% are similarly defined, but taking the value at
    25% or 75% of the way through the ordered values. You might also think of the
    minimum as the 0% quartile and the maximum as the 100% quartile.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*x[i]* 值代表数据值，*N* 是值的数量。在这里，我们也采用了用条形表示平均值的常见符号。中位数是当所有数据排序时的“中间值”（如果值的数量是奇数，则取两个中间值的平均值）。25%
    和 75% 的四分位数同样定义，但是取排序后数值的 25% 或 75% 处的值。你也可以将最小值看作是 0% 四分位数，最大值看作是 100% 四分位数。
- en: '**Standard deviation** is a measure of the spread of the data from the mean
    and is related to another quantity that is frequently mentioned in statistics,
    the **variance***.* The variance is the square of the standard deviation and is
    defined as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**标准差**是数据相对于平均值的分布的度量，与统计学中经常提到的另一个量**方差**有关。方差是标准差的平方，定义如下：'
- en: '![](assets/f014bad4-8c1c-4559-bd40-9607e5653105.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f014bad4-8c1c-4559-bd40-9607e5653105.png)'
- en: You might also see *N –* 1 appear in the fraction here, which is a correction
    for **bias** when estimating population parameters from a sample. We will discuss
    population parameters and their estimation in the next recipe. Standard deviation,
    variance, the quartiles, and the maximum and minimum values describe the spread
    of the data. For example, if the maximum value is 5, the minimum value is 0, the
    25% quartile is 2, and the 75% quartile is 4, then this indicates that most (at
    least 50% of the values, in fact) of the data is concentrated between 2 and 4.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会看到这里的分数中出现了 *N –* 1，这是从样本中估计总体参数时的**偏差**校正。我们将在下一个示例中讨论总体参数及其估计。标准差、方差、四分位数、最大值和最小值描述了数据的分布。例如，如果最大值是
    5，最小值是 0，25% 四分位数是 2，75% 四分位数是 4，那么这表明大部分（实际上至少有 50% 的值）数据集中在 2 和 4 之间。
- en: The *kurtosis* is a measure of how much the data is concentrated in the "tails"
    of the distribution (far from the mean). This is not as common as the other quantities
    we have discussed in this recipe, but it does appear in some analysis. We have
    included it here mostly as a demonstration of how to compute summary statistic
    values that do not appear in the DataFrame returned from the `describe` method
    using the appropriately named method—here, `kurtosis`. There are, of course, separate
    methods for computing the mean (`mean`), standard deviation (`std`), and the other
    quantities from the `describe` method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*kurtosis*是衡量数据在分布的“尾部”（远离平均值）集中程度的指标。这不像我们在本教程中讨论的其他数量那样常见，但在一些分析中确实会出现。我们在这里包括它主要是为了演示如何计算不出现在`describe`方法返回的DataFrame中的摘要统计值，使用适当命名的方法——在这里是`kurtosis`。当然，还有单独的方法来计算平均值（`mean`）、标准差（`std`）和`describe`方法中的其他数量。'
- en: When pandas computes the quantities described in this recipe, it will automatically
    ignore any "missing values" represented by NaN. This will also be reflected in
    the count reported in the descriptive statistics.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当pandas计算本教程中描述的数量时，它将自动忽略由NaN表示的任何“缺失值”。这也将反映在描述性统计中报告的计数中。
- en: There's more...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The third dataset that we included in our statistics illustrates the importance
    of looking at the data to make sure the values we have calculated make sense.
    Indeed, we compute the mean as approximately `2.9`, but looking at the histogram,
    it is clear that most of the data is relatively far from this value. We should
    always check whether the summary statistics that we calculate give an accurate
    summary of the data in our sample. Simply quoting the mean might give an inaccurate
    representation of the sample.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在统计中包含的第三个数据集说明了查看数据的重要性，以确保我们计算的值是合理的。事实上，我们计算的平均值约为`2.9`，但通过查看直方图，很明显大部分数据与这个值相差甚远。我们应该始终检查我们计算的摘要统计数据是否准确地总结了样本中的数据。仅仅引用平均值可能会给出样本的不准确表示。
- en: Understanding a population using sampling
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用抽样理解人口
- en: One of the central problems in statistics is to make estimations—and quantify
    how good these estimations are—of the distribution of an entire population given
    only a small (random) sample. A classic example is to estimate the average height
    of all the people in a country when measuring the height of a randomly selected
    sample of people. These kinds of problems are particularly interesting when the
    true population distribution, by which we usually mean the mean of the whole population,
    cannot feasibly be measured. In this case, we must rely on our knowledge of statistics
    and a (usually much smaller) randomly selected sample to estimate the true population
    mean and standard deviation, and also quantify how good our estimations are. It
    is the latter that is the source of confusion, misunderstanding, and misrepresentation
    of statistics in the wider world.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学中的一个核心问题是对整个人口的分布进行估计，并量化这些估计的准确程度，只给出一个小（随机）样本。一个经典的例子是，在测量随机选择的人群的身高时，估计一个国家所有人的平均身高。当通常意味着整个人口的平均值的真实人口分布无法被测量时，这种问题尤其有趣。在这种情况下，我们必须依靠我们对统计学的知识和一个（通常要小得多的）随机选择的样本来估计真实的人口平均值和标准差，并量化我们估计的准确程度。后者是导致广泛世界中统计学的混淆、误解和错误表述的根源。
- en: In this recipe, we will see how to estimate the population mean and give a **confidence
    interval** for these estimates.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将看到如何估计总体均值，并为这些估计提供**置信区间**。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we need the pandas package import as `pd`, the `math` module
    from the Python standard library, and the SciPy `stats` module, imported using
    the following command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我们需要导入pandas包作为`pd`，从Python标准库导入`math`模块，以及使用以下命令导入SciPy的`stats`模块：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'In the following steps, we will give an estimation of the mean height of males
    in the United Kingdom, based on a randomly selected sample of 20 people:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将根据随机选择的20个人的样本，对英国男性的平均身高进行估计：
- en: 'We have to load our sample data into a pandas `Series`:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须将我们的样本数据加载到pandas的`Series`中：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we will compute the sample mean and standard deviation:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将计算样本均值和标准差：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we will compute the **standard error***,* as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将计算**标准误差**，如下所示：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will compute the **critical values** for the confidence values we desire
    from the student *t* distribution:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将计算我们从学生*t*分布中所需的置信值的**临界值**：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we can compute the 95% and 99% confidence intervals for the true population
    mean using the following code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码计算真实总体均值的95%和99%置信区间：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The key to parameter estimation is normal distribution, which we discussed in
    [Chapter 4](5da67d86-40e0-4cc5-9dd1-26b6d52369af.xhtml), *Working with Randomness
    and Probability*. If we find the critical value of *z* for which the probability
    that a standard, normally distributed random number lies below this value *z*
    is 97.5%, then the probability that such a number lies between the values of -*z*
    and *z* is 95% (2.5% in each tail). This critical value of *z* turns out to be
    1.96, rounded to 2 decimal places. That is, we can be 95% sure that the value
    of a standard normally distributed random number lies between *-z* and *z*. Similarly,
    the critical value of 99% confidence is 2.58 (rounded to 2 decimal places).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 参数估计的关键是正态分布，我们在[第4章](5da67d86-40e0-4cc5-9dd1-26b6d52369af.xhtml)中讨论过。如果我们找到*z*的临界值，使得标准正态分布随机数小于这个值*z*的概率为97.5%，那么这样的数值在*-z*和*z*之间的概率为95%（每个尾部为2.5%）。这个*z*的临界值结果为1.96，四舍五入到2位小数。也就是说，我们可以有95%的把握，标准正态分布随机数的值在*-z*和*z*之间。类似地，99%置信的临界值为2.58（四舍五入到2位小数）。
- en: If our sample is "large," we could invoke the **central limit theorem**, which
    tells us that even if the population is not normally distributed itself, the means
    of random samples drawn from this population will be normally distributed with
    the same mean as the whole population. However, this is only valid assuming our
    samples are large. In this recipe, the sample is not large—it only has 20 values,
    which is certainly not large compared to the male population of the UK. This means
    that, rather than the normal distribution, we have to use a student *t* distribution
    with *N-*1 degrees of freedom to find our critical values, where *N* is the size
    of our sample. For this, we use the `stats.t.ppf` routine from the SciPy `stats`
    module.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的样本是“大”的，我们可以引用**中心极限定理**，它告诉我们，即使总体本身不服从正态分布，从这个总体中抽取的随机样本的均值将服从与整个总体相同均值的正态分布。然而，这仅在我们的样本足够大的情况下才有效。在这个配方中，样本并不大——它只有20个值，与英国男性总体相比显然不大。这意味着，我们不得不使用具有*N-*1自由度的学生*t*分布来找到我们的临界值，而不是正态分布，其中*N*是我们样本的大小。为此，我们使用SciPy
    `stats`模块中的`stats.t.ppf`例程。
- en: The student *t* distribution is related to the normal distribution but has a
    parameter—the degree of freedom—that changes the shape of the distribution. As
    the number of degrees of freedom increases, the student *t* distribution will
    look more and more like a normal distribution. The point at which you consider
    the distributions to be sufficiently similar depends on your application and your
    data. A general rule of thumb says that a sample size of 30 is sufficient to invoke
    the central limit theorem and simply use the normal distribution, but it is by
    no means a good rule. You should be very careful when making deductions based
    on a sample, especially if the sample is very small compared to the total population.
    (Clearly, using a sample size of 20 would be pretty descriptive if the total population
    consists of 30 people, but not if the total population consists of 30 million
    people.)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 学生*t*分布与正态分布有关，但有一个参数——自由度——它改变了分布的形状。随着自由度的增加，学生*t*分布将越来越像正态分布。你认为分布足够相似的点取决于你的应用和你的数据。一个经验法则说，样本大小为30足以引用中心极限定理，并简单使用正态分布，但这绝不是一个好的规则。在基于样本进行推断时，你应该非常小心，特别是如果样本与总体相比非常小。（显然，如果总体由30人组成，使用20个样本量将是相当描述性的，但如果总体由3000万人组成，情况就不同了。）
- en: Once we have the critical values, the confidence interval for the true population
    mean can be computed by multiplying the critical value by the standard error of
    the sample and adding and subtracting this from the sample mean. The standard
    error is an approximation of the spread of the distribution of sample means of
    a given sample size from the true population mean. This is why we use the standard
    error to give the confidence interval for our estimation of the population mean.
    When we multiply the standard error by the critical value taken from the student
    *t* distribution (in this case), we obtain an estimate of the maximum difference
    between the observed sample mean and the true population mean at the given confidence
    level.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了临界值，真实总体均值的置信区间可以通过将临界值乘以样本的标准误差，并从样本均值中加减得出。标准误差是对给定样本大小的样本均值分布与真实总体均值之间的差距的近似。这就是为什么我们使用标准误差来给出我们对总体均值的估计的置信区间。当我们将标准误差乘以从学生*t*分布中取得的临界值（在这种情况下）时，我们得到了在给定置信水平下观察到的样本均值与真实总体均值之间的最大差异的估计。
- en: In this recipe, that means that we are 95% certain that the mean height of UK
    males lies between 168.7 cm and 175.6 cm, and we are 99% certain that the mean
    height of UK males lies between 167.4 cm and 176.9 cm. In fact, our sample was
    drawn from a population with a mean of 175.3 cm and a standard deviation of 7.2
    cm. This true mean (175.3 cm) does indeed lie within both of our confidence intervals,
    but only just.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，这意味着我们有95%的把握，英国男性的平均身高在168.7厘米和175.6厘米之间，我们有99%的把握，英国男性的平均身高在167.4厘米和176.9厘米之间。事实上，我们的样本是从一个平均身高为175.3厘米，标准偏差为7.2厘米的人群中抽取的。这个真实的平均值（175.3厘米）确实位于我们两个置信区间内，但仅仅是刚好。
- en: See also
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: There is a useful package called `uncertainties` for doing computations involving
    values with some uncertainty attached. See the *Accounting for uncertainty in
    calculations* recipe in [Chapter 10](169df36b-7160-4fe9-ab59-e20047fc4dc6.xhtml),
    *Miscellaneous Topics*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个有用的包叫做`uncertainties`，用于进行涉及一定不确定性的值的计算。请参阅[第10章](169df36b-7160-4fe9-ab59-e20047fc4dc6.xhtml)中的*计算中的不确定性*配方，*其他主题*。
- en: Testing hypotheses using t-tests
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用t检验进行假设检验
- en: One of the most common tasks in statistics is to test the validity of a hypothesis
    about the mean of a normally distributed population given that you have collected
    sample data from that population. For example, in quality control, we might wish
    to test that the thickness of a sheet produced at a mill is 2 mm. To test this,
    we would randomly select sample sheets and measure the thickness to obtain our
    sample data. Then, we can use a **t-test** to test our null hypothesis, *H[0]*,
    that the mean paper thickness is 2 mm, against the alternative hypothesis, *H[1]*,
    that the mean paper thickness is not 2 mm. We use the SciPy `stats` module to
    compute a *t* statistic*and a *p* value. If the *p* value is below 0.05, then
    we accept the null hypothesis with 5% significance (95% confidence). If the *p*
    value is larger than 0.05, then we must reject the null hypothesis in favor of
    our alternative hypothesis.*
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学中最常见的任务之一是在从总体中收集样本数据的情况下，测试关于正态分布总体均值的假设的有效性。例如，在质量控制中，我们可能希望测试在工厂生产的一张纸的厚度是否为2毫米。为了测试这一点，我们将随机选择样本纸张并测量厚度以获得我们的样本数据。然后，我们可以使用**t检验**来测试我们的零假设*H[0]*，即纸张的平均厚度为2毫米，对抗备择假设*H[1]*，即纸张的平均厚度不是2毫米。我们使用SciPy的`stats`模块来计算*t*统计量和*p*值。如果*p*值小于0.05，则我们接受零假设，显著性为5%（置信度95%）。如果*p*值大于0.05，则我们必须拒绝零假设，支持备择假设。
- en: '*In this recipe, we will see how to use a t-test to test whether the assumed
    population mean is valid given a sample.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这个步骤中，我们将看到如何使用t检验来测试给定样本的假设总体均值是否有效。'
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe we will need the pandas package imported as `pd` and the SciPy
    `stats` module imported using the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个步骤，我们需要导入pandas包作为`pd`，并使用以下命令导入SciPy的`stats`模块：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to use a t-test to test the validity of a proposed population
    mean given some sample data:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤使用t检验来测试给定一些样本数据的假设总体均值的有效性：
- en: 'We will first load the data into a pandas `Series`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将数据加载到pandas的`Series`中：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, set the hypothesized population mean and the significance level that we
    will be testing at:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，设置我们将进行测试的假设总体均值和显著性水平：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, use the `ttest_1samp`routine from the SciPy `stats`module to generate
    the *t* statistic and the *p* value:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用SciPy的`stats`模块中的`ttest_1samp`例程生成*t*统计量和*p*值：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, test whether the *p* value is smaller than the significance level
    we chose:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，测试*p*值是否小于我们选择的显著性水平：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The *t* statistic is computed using the following formula:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*t*统计量是使用以下公式计算的：'
- en: '![](assets/e9dc48d2-75d6-4d0c-a377-3b9a6ecbd9d1.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e9dc48d2-75d6-4d0c-a377-3b9a6ecbd9d1.png)'
- en: Here, *μ[0]* is the hypothesized mean (from the null hypothesis), *x* bar is
    the sample mean, *s* is the sample standard deviation, and *N* is the size of
    the sample. The *t* statistic is an estimation of the difference between the observed
    sample mean and the hypothesized population mean, *μ[0]*, normalized by the standard
    error. Assuming the population is normally distributed, the *t* statistic will
    follow a *t* distributionwith *N*-1degrees of freedom. Looking at where the t
    statistic lies within in the corresponding student *t* distribution gives us an
    idea of how likely it is that the sample mean we observed came from the population
    with the hypothesized mean. This is given in the form of a *p* value.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*μ[0]*是假设均值（来自零假设），*x* bar是样本均值，*s*是样本标准差，*N*是样本大小。*t*统计量是观察到的样本均值与假设总体均值*μ[0]*之间差异的估计，通过标准误差进行归一化。假设总体呈正态分布，*t*统计量将遵循*N*-1自由度的*t*分布。查看t统计量在相应的学生*t*分布中的位置，可以让我们了解我们观察到的样本均值来自具有假设均值的总体的可能性。这以*p*值的形式给出。
- en: The *p* value is the probability of observing a more extreme value than the
    sample mean we have observed, given the assumption that the population mean is
    equal to*μ[0]*. If the *p* value is smaller than the significance value we have
    chosen, then we cannot expect the true population mean to be the value,*μ[0]*,
    that we assumed. In this case, we have to accept the alternative hypothesis that
    the true population norm is not equal to*μ[0]*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*值是观察到比我们观察到的样本均值更极端值的概率，假设总体均值等于*μ[0]*。如果*p*值小于我们选择的显著性值，那么我们不能期望真实的总体均值是我们假设的值*μ[0]*。在这种情况下，我们必须接受备择假设，即真实的总体均值不等于*μ[0]*。'
- en: There's more...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The test that we demonstrated in this recipe is the most basic use of a t-test.
    Here, we compared the sample mean to a hypothesized population mean to decide
    whether it was reasonable that the mean of the whole population is this hypothesized
    value. More generally, we can use t-tests to compare two independent populations
    given samples taken from each using a **2-sample t-test**, or compare the populations
    where data is paired (in some way) using a **paired t-test**. This makes the t-test
    an important tool for a statistician.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中我们演示的测试是t检验的最基本用法。在这里，我们比较了样本均值和假设的总体均值，以决定整个总体的均值是否合理为假设值。更一般地，我们可以使用t检验来比较从每个样本中取出的两个独立总体的**2样本t检验**，或者使用**配对t检验**来比较数据成对（某种方式）的总体。这使得t检验成为统计学家的重要工具。
- en: Significance and confidence are two concepts that occur frequently in statistics.
    A statistically significant result is one that has a high probability of being
    correct. In many contexts, we consider any result that has a probability of being
    wrong below a certain threshold (usually either 5% or 1%) to be statistically
    significant. Confidence is a quantification of how certain we are about a result.
    The confidence of a result is 1 minus the significance.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在统计学中，显著性和置信度是两个经常出现的概念。统计上显著的结果是指具有高正确概率的结果。在许多情境中，我们认为任何具有低于一定阈值（通常为5%或1%）的错误概率的结果都是统计上显著的。置信度是对结果的确定程度的量化。结果的置信度是1减去显著性。
- en: Unfortunately, the significance of a result is something that is often misused
    or misunderstood. To say that a result is statistically significant at 5% is to
    say that there is a 5% chance that we have wrongly accepted the null hypothesis.
    That is, if we repeated the same test on 20 other samples from the population,
    we would expect at least one of them to give the opposite result. That, however,
    is not to say that one of them is guaranteed to do so.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，结果的显著性经常被误用或误解。说一个结果在5%的显著水平上是统计显著的，意味着我们有5%的机会错误地接受了零假设。也就是说，如果我们从总体中另外抽取20个样本进行相同的测试，我们至少期望其中一个会给出相反的结果。然而，这并不意味着其中一个一定会这样做。
- en: High significance indicates that we are more sure that the conclusion we have
    reached is correct, but it is certainly not a guarantee that this is indeed the
    case. In fact, the results found in this recipe are evidence for this; the sample
    that we used was in fact drawn from a population with a mean of `2.5` and a standard
    deviation of `0.35`. (Some rounding was applied to the sample after creating,
    which will have altered the distribution slightly.) This is not to say that our
    analysis is wrong, or that the conclusion we reached from our sample is not the
    right one.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 高显著性表明我们更加确信我们得出的结论是正确的，但这并不意味着这确实是情况。事实上，这个配方中找到的结果就是证据；我们使用的样本实际上是从均值为`2.5`，标准差为`0.35`的总体中抽取的。（在创建后对样本进行了一些四舍五入，这会稍微改变分布。）这并不意味着我们的分析是错误的，或者我们从样本得出的结论不正确。
- en: It is important to remember that t-tests are only valid when the underlying
    populations follow a normal distribution, or at least approximately do so. If
    this is not the case, then you might need to use a non-parametric test instead.
    We will discuss this in the *Testing hypotheses for non-parametric data* recipe.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，t检验只有在基础总体遵循正态分布，或者至少近似遵循正态分布时才有效。如果不是这种情况，那么您可能需要使用非参数检验。我们将在*测试非参数数据的假设*配方中讨论这一点。
- en: Testing hypotheses using ANOVA
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ANOVA进行假设检验
- en: Suppose we have designed an experiment that tests two new processes against
    the current process and we want to test whether the results of these new processes
    are different from the current process. In this case, we can use **Analysis of
    Variance***(**ANOVA**) to help us determine whether there are any differences
    between the mean values of the three sets of results (for this, we need to assume
    that each sample is drawn from a normal distribution with a common variance).*
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们设计了一个实验，测试两个新的过程与当前过程，并且我们想测试这些新过程的结果是否与当前过程不同。在这种情况下，我们可以使用**方差分析**（**ANOVA**）来帮助我们确定这三组结果的均值之间是否有任何差异（为此，我们需要假设每个样本都是从具有共同方差的正态分布中抽取的）。
- en: '*In this recipe, we will see how to use ANOVA to compare multiple samples with
    one another.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*在这个配方中，我们将看到如何使用ANOVA来比较多个样本。'
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'For this recipe, we need the SciPy `stats` module. We will also need a default
    random number generator instance created using the following commands:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要SciPy的`stats`模块。我们还需要使用以下命令创建一个默认的随机数生成器实例：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How to do it...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to perform a (oneway) ANOVA test to test for differences
    between three different processes:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤执行（单向）ANOVA测试，以测试三个不同过程之间的差异：
- en: 'First, we will create some sample data, which we will analyze:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一些样本数据，然后对其进行分析：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we will set the significance level for our test:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们的测试设置显著性水平：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we will use the `f_oneway`routine from the SciPy `stats`module to generate
    the F-statistic and the *p* value:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用SciPy的`stats`模块中的`f_oneway`例程来生成F统计量和*p*值：
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we must test whether the *p* value is sufficiently small to see whether
    we should accept or reject our null hypothesis that all mean values are equal:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须测试*p*值是否足够小，以确定我们是否应该接受或拒绝所有均值相等的零假设：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: ANOVA is a powerful technique for comparing multiple samples against one another
    simultaneously. It works by comparing the variation in the samples relative to
    the overall variation. ANOVA is especially powerful when comparing three or more
    samples since no cumulative error is incurred from running multiple tests. Unfortunately,
    if ANOVA detects that not all the mean values are equal, then there is no way
    from the test information to determine which sample(s) are significantly different
    from the others. For this, you would need to use an extra test to find the differences.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ANOVA是一种强大的技术，可以同时比较多个样本。它通过比较样本的变化与总体变化的相对变化来工作。ANOVA在比较三个或更多样本时特别强大，因为不会因运行多个测试而产生累积误差。不幸的是，如果ANOVA检测到不是所有的均值都相等，那么从测试信息中无法确定哪个样本与其他样本有显著差异。为此，您需要使用额外的测试来找出差异。
- en: The`f_oneway` SciPy `stats`package routine performs a one-way ANOVA test—the
    test statistic generated in ANOVA follows an F-distribution. Again, the *p* value
    is the crucial piece of information coming from the test. We accept the null hypothesis
    if the *p* value is less than our predefined significance level (in this recipe,
    5%) and reject the null hypothesis otherwise.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`f_oneway` SciPy `stats`包例程执行单向ANOVA测试——ANOVA生成的检验统计量遵循F分布。同样，*p*值是来自测试的关键信息。如果*p*值小于我们预先设定的显著性水平（在这个配方中为5%），我们接受零假设，否则拒绝零假设。'
- en: There's more...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The ANOVA method is very flexible. The one-way ANOVA test that we presented
    here is the most simple case as there is only a single factor to test. A two-way
    ANOVA test can be used to test for differences over two different factors. This
    is useful in clinical trials of medicines, for example, where we test against
    a control but also measure the effects of gender (for instance) on the outcomes.
    Unfortunately, SciPy does not have a routine for performing two-way ANOVA in the
    `stats` module. You will need to use an alternative package, such as the `statsmodels`
    package. We will use this package in [Chapter 7](51dde93b-1346-4b79-af00-09004cc77864.xhtml),
    *Regression and Forecasting*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ANOVA方法非常灵活。我们在这里介绍的单因素方差分析检验是最简单的情况，因为只有一个因素需要测试。双因素方差分析检验可用于测试两个不同因素之间的差异。例如，在药物临床试验中，我们测试对照组，同时也测量性别（例如）对结果的影响。不幸的是，SciPy在`stats`模块中没有执行双因素方差分析的例程。您需要使用其他包，比如`statsmodels`包。我们将在[第7章](51dde93b-1346-4b79-af00-09004cc77864.xhtml)
    *回归和预测* 中使用这个包。
- en: As mentioned, ANOVA can only detect whether there are differences. It cannot
    detect where these differences occur if there are significant differences. For
    example, we can use Durnett's test to test whether the other sample mean values
    differ from a control sample, or Tukey's range test to test each group mean against
    every other group mean.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，ANOVA只能检测是否存在差异。如果存在显著差异，它无法检测这些差异发生在哪里。例如，我们可以使用Durnett's检验来测试其他样本均值是否与对照样本不同，或者使用Tukey's范围检验来测试每个组均值与其他每个组均值之间的差异。
- en: Testing hypotheses for non-parametric data
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非参数数据的假设检验
- en: 'Both t-tests and ANOVA have a major drawback: the population that is being
    sampled must follow a normal distribution. In many applications, this is not too
    restrictive because many real-world population values follow a normal distribution,
    or some rules, such as the central limit theorem, allow us to analyze some related
    data. However, it is simply not true that all possible population values follow
    a normal distribution in any reasonable way. For these (thankfully, rare) cases,
    we need some alternative test statistics to use as replacements for t-tests and
    ANOVA.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: t检验和ANOVA都有一个主要缺点：被抽样的总体必须遵循正态分布。在许多应用中，这并不太严格，因为许多真实世界的总体值遵循正态分布，或者一些规则，如中心极限定理，允许我们分析一些相关数据。然而，事实并非所有可能的总体值以任何合理的方式都遵循正态分布。对于这些（幸运地是罕见的）情况，我们需要一些替代的检验统计量来替代t检验和ANOVA。
- en: In this recipe, we will use a Wilcoxon rank-sum test and the Kruskal-Wallis
    test to test for differences between two (or more, in the latter case) populations.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用Wilcoxon秩和检验和Kruskal-Wallis检验来测试两个（或更多，在后一种情况下）总体之间的差异。
- en: Getting ready
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the pandas package imported as `pd`, the SciPy
    `stats` module, and a default random number generator instance created using the
    following commands:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要导入pandas包作为`pd`，SciPy的`stats`模块，以及使用以下命令创建的默认随机数生成器实例：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to compare the populations of two or more populations that
    are not normally distributed:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤比较两个或更多个不服从正态分布的总体：
- en: 'First, we will generate some sample data to use in our analysis:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将生成一些样本数据用于分析：
- en: '[PRE45]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we set the significance level that we will use in this analysis:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们设置在此分析中使用的显著性水平：
- en: '[PRE46]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we use the `stats.kruskal`routine to generate the test statistic and the
    *p* value for the null hypothesis that the populations have the same median value:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`stats.kruskal`例程生成零假设的检验统计量和*p*值，即总体具有相同中位数值的零假设：
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will use a conditional statement to print a statement about the outcome
    of the test:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用条件语句打印关于测试结果的声明：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we use Wilcoxon rank-sum tests to obtain the *p* values for the comparisons
    between each pair of samples:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用Wilcoxon秩和检验来获得每对样本之间比较的*p*值：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we use conditional statements to print out messages for those comparisons
    that indicate a significant difference:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用条件语句打印出针对那些表明存在显著差异的比较的消息：
- en: '[PRE50]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We say that data is non-parametric if the population from which the data was
    sampled does not follow a distribution that can be described by a small number
    of parameters. This usually means that the population is not normally distributed
    but is broader than this. In this recipe, we sampled from uniform distributions,
    but this is still a more structured example than we would generally have when
    non-parametric tests are necessary. Non-parametric tests can and should be used
    in any situation where we are not sure about the underlying distribution. The
    cost of doing this is that the tests are slightly less powerful.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从数据抽样的总体不遵循可以用少量参数描述的分布，我们称数据为非参数数据。这通常意味着总体不是正态分布，但比这更广泛。在这个配方中，我们从均匀分布中抽样，但这仍然比通常需要非参数检验时更有结构化的例子。非参数检验可以和应该在我们不确定基础分布的任何情况下使用。这样做的代价是检验略微不够有力。
- en: The first step of any (real) analysis should be to plot a histogram of the data
    and inspect the distribution visually. If you draw a random sample from a normally
    distributed population, you might also expect the sample to be normally distributed
    (we have seen this several times in this book). If your sample shows the characteristic
    bell curve of a normal distribution, then it is fairly likely that the population
    is itself normally distributed. You might also use a **kernel density estimation**
    plot to help determine the distribution. This is available on the pandas plotting
    interface as `kind="kde"`. If you still aren't sure whether the population is
    normal, you can apply a statistical test, such as D'Agostino's K-squared test
    or Pearson's Chi-squared test for normality. These two tests are combined into
    a single routine to test for normality called `normaltest` in the SciPy `stats`
    module, along with several other tests for normality.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 任何（真实）分析的第一步应该是绘制数据的直方图并通过视觉检查分布。如果你从一个正态分布的总体中抽取一个随机样本，你可能也期望样本是正态分布的（我们在本书中已经看到了几次）。如果你的样本显示出正态分布的典型钟形曲线，那么总体本身很可能也是正态分布的。你还可以使用**核密度估计**图来帮助确定分布。这在pandas绘图界面上可用，`kind="kde"`。如果你仍然不确定总体是否正态分布，你可以应用统计测试，比如D'Agostino的K平方检验或Pearson的卡方检验。这两个测试被合并成一个用于正态性检验的单一程序，称为SciPy
    `stats`模块中的`normaltest`，还有其他几个正态性测试。
- en: The Wilcoxon rank-sum test—also called the Mann-Whitney U test—is a non-parametric
    replacement for a two-sample t-test. Unlike the t-test, the rank-sum test does
    not compare the sample mean values to quantify whether the populations have different
    distributions. Instead, it combines the data of the samples and ranks them in
    order of size. The test statistic is generated from the sum of the ranks from
    the sample with the fewest elements. From here, as usual, we generate a *p* value
    for the null hypothesis that the two populations have the same distribution.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Wilcoxon秩和检验——也称为Mann-Whitney U检验——是双样本t检验的非参数替代方法。与t检验不同，秩和检验不会比较样本均值，以量化两个总体是否具有不同分布。相反，它将样本数据组合并按大小排序。检验统计量是从具有最少元素的样本的秩的总和生成的。从这里开始，像往常一样，我们为零假设生成一个*p*值，即两个总体具有相同分布的假设。
- en: The Kruskal-Wallis test is a non-parametric replacement for a one-way ANOVA
    test. Like the rank-sum test, it uses the ranking of the sample data to generate
    a test statistic and *p* values for the null hypothesis that all the populations
    have the same median value. As with one-way ANOVA, we can only detect whether
    all of the populations have the same median, and not where the differences lie.
    For this, we would have to use additional tests.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Kruskal-Wallis检验是一种一元ANOVA检验的非参数替代方法。与秩和检验一样，它使用样本数据的排名来生成检验统计量和零假设的*p*值，即所有总体具有相同中位数值的假设。与一元ANOVA一样，我们只能检测所有总体是否具有相同的中位数，而不能确定差异在哪里。为此，我们需要使用额外的测试。
- en: In this recipe, we used the Kruskal-Wallis test to determine whether there were
    any significant differences between the populations corresponding to our three
    samples. A difference was detected with a *p* value of `0.07`, which is not far
    from being significant at 5%. We then used rank-sum tests to determine where significant
    differences occur between the populations. Here, we found that sample A is significantly
    different from samples B and C, and samples B and C are not significantly different.
    This is hardly surprising given the way that these samples were generated.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们使用了Kruskal-Wallis检验来确定与我们三个样本对应的总体之间是否存在显著差异。我们发现了一个*p*值为`0.07`的差异，这离5%的显著性并不远。然后我们使用秩和检验来确定总体之间的显著差异发生在哪里。在这里，我们发现样本A与样本B和C存在显著差异，而样本B和C之间没有显著差异。考虑到这些样本的生成方式，这并不奇怪。
- en: Unfortunately, since we have used multiple tests in this recipe, our overall
    confidence in our conclusions is not as high as we might expect it to be. We performed
    four tests with 95% confidence, which means our overall confidence in our conclusion
    is only approximately 81%. This is because errors aggregate over multiple tests,
    reducing the overall confidence. To correct for this, we would have to adjust
    our significance threshold for each test, using the Bonferroni correction (or
    similar).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于我们在这个实验中使用了多个测试，我们对结论的整体信心并不像我们期望的那样高。我们进行了四次测试，置信度为95%，这意味着我们对结论的整体信心仅约为81%。这是因为错误在多次测试中累积，降低了整体信心。为了纠正这一点，我们需要调整每个测试的显著性阈值，使用Bonferroni校正（或类似方法）。
- en: Creating interactive plots with Bokeh
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bokeh创建交互式图表
- en: Test statistics and numerical reasoning are good for systematically analyzing
    sets of data. However, they don't really give us a good picture of the whole set
    of data like a plot would. Numerical values are definitive but can be difficult
    to understand, especially in statistics, whereas a plot instantly illustrates
    differences between sets of data and trends. For this reason, there is a large
    number of libraries for plotting data in ever more creative ways. One particularly
    interesting package for producing plots of data is Bokeh, which allows us to create
    interactive plots in the browser by leveraging JavaScript libraries.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 测试统计和数值推理对于系统分析数据集是很好的。然而，它们并不能真正给我们一个数据集的整体图像，就像图表那样。数值是确定的，但在统计学中可能很难理解，而图表可以立即说明数据集之间的差异和趋势。因此，有大量的库用于以越来越有创意的方式绘制数据。一个特别有趣的用于生成数据图的包是Bokeh，它允许我们通过利用JavaScript库在浏览器中创建交互式图。
- en: In this recipe, we will see how to use Bokeh to create an interactive plot that
    can be displayed in the browser.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将看到如何使用Bokeh创建一个可以在浏览器中显示的交互式图。
- en: Getting ready
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, we will need the pandas package imported as `pd`, the NumPy
    package imported as `np`, an instance of the default random number generator constructed
    with the following code, and the `plotting` module from Bokeh, which we have imported
    under the `bk`alias:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要将pandas包导入为`pd`，将NumPy包导入为`np`，使用以下代码构建默认随机数生成器的实例，并从Bokeh导入`plotting`模块，我们使用`bk`别名导入：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How to do it...
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'These steps show how to create an interactive plot in the browser using Bokeh:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤展示了如何使用Bokeh在浏览器中创建交互式绘图：
- en: 'We first need to create some sample data to plot:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要创建一些样本数据来绘制：
- en: '[PRE52]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we specify the output file where the HTML code for the plot will be stored
    by using the `output_file`routine:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`output_file`例程指定HTML代码的输出文件位置：
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we create a new figure and set the title and axes labels, and set the
    *x*-axis type to `datetime` so that our date index will be correctly displayed:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们创建一个新的图，并设置标题和轴标签，并将*x*轴类型设置为`datetime`，以便我们的日期索引将被正确显示：
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We add the data to the figure as a line:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将数据添加到图中作为一条线：
- en: '[PRE55]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we use either the `show`routine or the `save`routine to save or update
    the HTML in the specified output file. We use `show`here to cause the plot to
    open in the browser:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`show`例程或`save`例程来保存或更新指定输出文件中的HTML。我们在这里使用`show`来在浏览器中打开绘图：
- en: '[PRE56]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Bokeh plots are not static objects and are supposed to be interactive via the
    browser. The data as it will appear in the Bokeh plot has been recreated here,
    using `matplotlib` for comparison:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Bokeh绘图不是静态对象，应该通过浏览器进行交互。这里使用`matplotlib`重新创建了数据，以便进行比较：
- en: '![](assets/dbe31bab-0892-4040-a72c-a2f9cd6c6900.png)Figure 6.3 – Plot of Time
    series data created using Matplotlib'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/dbe31bab-0892-4040-a72c-a2f9cd6c6900.png)图6.3 - 使用Matplotlib创建的时间序列数据的绘图'
- en: How it works...
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Bokeh uses a JavaScript library to render a plot in a browser, using data provided
    by the Python backend. The advantage of this is that it can generate plots that
    a user can inspect for themselves. For instance, we can zoom in to see detail
    in the plot that might otherwise be hidden, or pan through the data in a natural
    way. The example given in this recipe is just a taster of what is possible using
    Bokeh.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Bokeh使用JavaScript库在浏览器中呈现绘图，使用Python后端提供的数据。这样做的好处是用户可以自行生成绘图。例如，我们可以放大以查看绘图中可能隐藏的细节，或者以自然的方式浏览数据。本示例只是展示了使用Bokeh可能性的一小部分。
- en: The `figure` routine creates an object representing the plot, which we add elements
    to—such as a line through the data points—in the same way that we would add plots
    to a matplotlib `Axes` object. In this recipe, we created a simple HTML file that
    contains JavaScript code to render the data. This HTML code is dumped to the specified
    file whenever we save or, as is in the recipe, call the `show` routine. In practice,
    the smaller the *p* value, the more confident we can be that the hypothesized
    population mean is correct.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`figure`例程创建一个代表绘图的对象，我们可以向其中添加元素，比如通过数据点的线条，就像我们向matplotlib的`Axes`对象添加绘图一样。在这个示例中，我们创建了一个简单的HTML文件，其中包含JavaScript代码来呈现数据。无论是保存还是调用`show`例程，这段HTML代码都会被转储到指定的文件中。在实践中，*p*值越小，我们对假设的总体均值正确性的信心就越大。'
- en: There's more...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The capabilities of Bokeh go far beyond what is described here. Bokeh plots
    can be embedded in files such as Jupyter notebooks, which are also rendered in
    the browser, or into existing websites. If you are using a Jupyter notebook, you
    should use the `output_notebook` routine instead of the `output_file` routine
    to print the plot directly into the notebook. It has a wide array of different
    plotting styles, supports the sharing of data between plots (data can be selected
    in one plot and highlighted in the other(s), for example), and supports streaming
    data.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Bokeh的功能远不止本文所描述的。Bokeh绘图可以嵌入到文件中，比如Jupyter笔记本，这些文件也可以在浏览器中呈现，或者嵌入到现有的网站中。如果您使用的是Jupyter笔记本，您应该使用`output_notebook`例程，而不是`output_file`例程，将绘图直接打印到笔记本中。它有各种不同的绘图样式，支持在绘图之间共享数据（例如，可以在一个绘图中选择数据，并在其他绘图中突出显示），并支持流数据。
- en: Further reading
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'There are a large number of textbooks on statistics and statistical theory.
    The following book was used as reference for this chapter:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 统计学和统计理论的教科书有很多。以下书籍被用作本章的参考：
- en: '*Mendenhall, W., Beaver, R., and Beaver, B., (2006), Introduction To Probability
    And Statistics, 12th ed., (Belmont, Calif.: Thomson Brooks/Cole)*'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Mendenhall, W., Beaver, R., and Beaver, B., (2006), Introduction To Probability
    And Statistics, 12th ed., (Belmont, Calif.: Thomson Brooks/Cole)*'
- en: 'The pandas documentation ([https://pandas.pydata.org/docs/index.html](https://pandas.pydata.org/docs/index.html))
    and the following pandas book serve as good references for working with pandas:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: pandas文档([https://pandas.pydata.org/docs/index.html](https://pandas.pydata.org/docs/index.html))和以下pandas书籍是使用pandas的良好参考资料：
- en: '*McKinney, W.,*(*2017*),*Python for Data Analysis, 2nd ed.,*(*Sebastopol: O''Reilly
    Media, Inc,* *US*)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*McKinney, W.,*(*2017*),*Python for Data Analysis, 2nd ed.,*(*Sebastopol: O''Reilly
    Media, Inc,* *US*)'
- en: The SciPy documentation ([https://docs.scipy.org/doc/scipy/reference/tutorial/stats.html](https://docs.scipy.org/doc/scipy/reference/tutorial/stats.html))
    also contains detailed information about the statistics module that was used several
    times in this chapter.**
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy文档([https://docs.scipy.org/doc/scipy/reference/tutorial/stats.html](https://docs.scipy.org/doc/scipy/reference/tutorial/stats.html))还包含了本章中多次使用的统计模块的详细信息。
